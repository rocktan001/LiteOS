
../out/STM32F767_Fire/Huawei_LiteOS.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c8 <__text_start>:
 80001c8:	20003df0 	.word	0x20003df0
 80001cc:	2007fbff 	.word	0x2007fbff
 80001d0:	080243ac 	.word	0x080243ac
 80001d4:	20000000 	.word	0x20000000
 80001d8:	20000400 	.word	0x20000400
 80001dc:	080247ac 	.word	0x080247ac
 80001e0:	20000400 	.word	0x20000400
 80001e4:	20000724 	.word	0x20000724
 80001e8:	20000728 	.word	0x20000728
 80001ec:	200037ec 	.word	0x200037ec

080001f0 <__LOS_HEAP_ADDR_START__>:
 80001f0:	20003df0 	.word	0x20003df0

080001f4 <__LOS_HEAP_ADDR_END__>:
 80001f4:	2007fbff 	.word	0x2007fbff

080001f8 <__aeabi_drsub>:
 80001f8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80001fc:	e002      	b.n	8000204 <__adddf3>
 80001fe:	bf00      	nop

08000200 <__aeabi_dsub>:
 8000200:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000204 <__adddf3>:
 8000204:	b530      	push	{r4, r5, lr}
 8000206:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800020a:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800020e:	ea94 0f05 	teq	r4, r5
 8000212:	bf08      	it	eq
 8000214:	ea90 0f02 	teqeq	r0, r2
 8000218:	bf1f      	itttt	ne
 800021a:	ea54 0c00 	orrsne.w	ip, r4, r0
 800021e:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000222:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000226:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800022a:	f000 80e2 	beq.w	80003f2 <__adddf3+0x1ee>
 800022e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000232:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000236:	bfb8      	it	lt
 8000238:	426d      	neglt	r5, r5
 800023a:	dd0c      	ble.n	8000256 <__adddf3+0x52>
 800023c:	442c      	add	r4, r5
 800023e:	ea80 0202 	eor.w	r2, r0, r2
 8000242:	ea81 0303 	eor.w	r3, r1, r3
 8000246:	ea82 0000 	eor.w	r0, r2, r0
 800024a:	ea83 0101 	eor.w	r1, r3, r1
 800024e:	ea80 0202 	eor.w	r2, r0, r2
 8000252:	ea81 0303 	eor.w	r3, r1, r3
 8000256:	2d36      	cmp	r5, #54	; 0x36
 8000258:	bf88      	it	hi
 800025a:	bd30      	pophi	{r4, r5, pc}
 800025c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000260:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000264:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000268:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800026c:	d002      	beq.n	8000274 <__adddf3+0x70>
 800026e:	4240      	negs	r0, r0
 8000270:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000274:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000278:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800027c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000280:	d002      	beq.n	8000288 <__adddf3+0x84>
 8000282:	4252      	negs	r2, r2
 8000284:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000288:	ea94 0f05 	teq	r4, r5
 800028c:	f000 80a7 	beq.w	80003de <__adddf3+0x1da>
 8000290:	f1a4 0401 	sub.w	r4, r4, #1
 8000294:	f1d5 0e20 	rsbs	lr, r5, #32
 8000298:	db0d      	blt.n	80002b6 <__adddf3+0xb2>
 800029a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800029e:	fa22 f205 	lsr.w	r2, r2, r5
 80002a2:	1880      	adds	r0, r0, r2
 80002a4:	f141 0100 	adc.w	r1, r1, #0
 80002a8:	fa03 f20e 	lsl.w	r2, r3, lr
 80002ac:	1880      	adds	r0, r0, r2
 80002ae:	fa43 f305 	asr.w	r3, r3, r5
 80002b2:	4159      	adcs	r1, r3
 80002b4:	e00e      	b.n	80002d4 <__adddf3+0xd0>
 80002b6:	f1a5 0520 	sub.w	r5, r5, #32
 80002ba:	f10e 0e20 	add.w	lr, lr, #32
 80002be:	2a01      	cmp	r2, #1
 80002c0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80002c4:	bf28      	it	cs
 80002c6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80002ca:	fa43 f305 	asr.w	r3, r3, r5
 80002ce:	18c0      	adds	r0, r0, r3
 80002d0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80002d4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80002d8:	d507      	bpl.n	80002ea <__adddf3+0xe6>
 80002da:	f04f 0e00 	mov.w	lr, #0
 80002de:	f1dc 0c00 	rsbs	ip, ip, #0
 80002e2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80002e6:	eb6e 0101 	sbc.w	r1, lr, r1
 80002ea:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80002ee:	d31b      	bcc.n	8000328 <__adddf3+0x124>
 80002f0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80002f4:	d30c      	bcc.n	8000310 <__adddf3+0x10c>
 80002f6:	0849      	lsrs	r1, r1, #1
 80002f8:	ea5f 0030 	movs.w	r0, r0, rrx
 80002fc:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000300:	f104 0401 	add.w	r4, r4, #1
 8000304:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000308:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800030c:	f080 809a 	bcs.w	8000444 <__adddf3+0x240>
 8000310:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000314:	bf08      	it	eq
 8000316:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800031a:	f150 0000 	adcs.w	r0, r0, #0
 800031e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000322:	ea41 0105 	orr.w	r1, r1, r5
 8000326:	bd30      	pop	{r4, r5, pc}
 8000328:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800032c:	4140      	adcs	r0, r0
 800032e:	eb41 0101 	adc.w	r1, r1, r1
 8000332:	3c01      	subs	r4, #1
 8000334:	bf28      	it	cs
 8000336:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 800033a:	d2e9      	bcs.n	8000310 <__adddf3+0x10c>
 800033c:	f091 0f00 	teq	r1, #0
 8000340:	bf04      	itt	eq
 8000342:	4601      	moveq	r1, r0
 8000344:	2000      	moveq	r0, #0
 8000346:	fab1 f381 	clz	r3, r1
 800034a:	bf08      	it	eq
 800034c:	3320      	addeq	r3, #32
 800034e:	f1a3 030b 	sub.w	r3, r3, #11
 8000352:	f1b3 0220 	subs.w	r2, r3, #32
 8000356:	da0c      	bge.n	8000372 <__adddf3+0x16e>
 8000358:	320c      	adds	r2, #12
 800035a:	dd08      	ble.n	800036e <__adddf3+0x16a>
 800035c:	f102 0c14 	add.w	ip, r2, #20
 8000360:	f1c2 020c 	rsb	r2, r2, #12
 8000364:	fa01 f00c 	lsl.w	r0, r1, ip
 8000368:	fa21 f102 	lsr.w	r1, r1, r2
 800036c:	e00c      	b.n	8000388 <__adddf3+0x184>
 800036e:	f102 0214 	add.w	r2, r2, #20
 8000372:	bfd8      	it	le
 8000374:	f1c2 0c20 	rsble	ip, r2, #32
 8000378:	fa01 f102 	lsl.w	r1, r1, r2
 800037c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000380:	bfdc      	itt	le
 8000382:	ea41 010c 	orrle.w	r1, r1, ip
 8000386:	4090      	lslle	r0, r2
 8000388:	1ae4      	subs	r4, r4, r3
 800038a:	bfa2      	ittt	ge
 800038c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000390:	4329      	orrge	r1, r5
 8000392:	bd30      	popge	{r4, r5, pc}
 8000394:	ea6f 0404 	mvn.w	r4, r4
 8000398:	3c1f      	subs	r4, #31
 800039a:	da1c      	bge.n	80003d6 <__adddf3+0x1d2>
 800039c:	340c      	adds	r4, #12
 800039e:	dc0e      	bgt.n	80003be <__adddf3+0x1ba>
 80003a0:	f104 0414 	add.w	r4, r4, #20
 80003a4:	f1c4 0220 	rsb	r2, r4, #32
 80003a8:	fa20 f004 	lsr.w	r0, r0, r4
 80003ac:	fa01 f302 	lsl.w	r3, r1, r2
 80003b0:	ea40 0003 	orr.w	r0, r0, r3
 80003b4:	fa21 f304 	lsr.w	r3, r1, r4
 80003b8:	ea45 0103 	orr.w	r1, r5, r3
 80003bc:	bd30      	pop	{r4, r5, pc}
 80003be:	f1c4 040c 	rsb	r4, r4, #12
 80003c2:	f1c4 0220 	rsb	r2, r4, #32
 80003c6:	fa20 f002 	lsr.w	r0, r0, r2
 80003ca:	fa01 f304 	lsl.w	r3, r1, r4
 80003ce:	ea40 0003 	orr.w	r0, r0, r3
 80003d2:	4629      	mov	r1, r5
 80003d4:	bd30      	pop	{r4, r5, pc}
 80003d6:	fa21 f004 	lsr.w	r0, r1, r4
 80003da:	4629      	mov	r1, r5
 80003dc:	bd30      	pop	{r4, r5, pc}
 80003de:	f094 0f00 	teq	r4, #0
 80003e2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80003e6:	bf06      	itte	eq
 80003e8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80003ec:	3401      	addeq	r4, #1
 80003ee:	3d01      	subne	r5, #1
 80003f0:	e74e      	b.n	8000290 <__adddf3+0x8c>
 80003f2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80003f6:	bf18      	it	ne
 80003f8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80003fc:	d029      	beq.n	8000452 <__adddf3+0x24e>
 80003fe:	ea94 0f05 	teq	r4, r5
 8000402:	bf08      	it	eq
 8000404:	ea90 0f02 	teqeq	r0, r2
 8000408:	d005      	beq.n	8000416 <__adddf3+0x212>
 800040a:	ea54 0c00 	orrs.w	ip, r4, r0
 800040e:	bf04      	itt	eq
 8000410:	4619      	moveq	r1, r3
 8000412:	4610      	moveq	r0, r2
 8000414:	bd30      	pop	{r4, r5, pc}
 8000416:	ea91 0f03 	teq	r1, r3
 800041a:	bf1e      	ittt	ne
 800041c:	2100      	movne	r1, #0
 800041e:	2000      	movne	r0, #0
 8000420:	bd30      	popne	{r4, r5, pc}
 8000422:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000426:	d105      	bne.n	8000434 <__adddf3+0x230>
 8000428:	0040      	lsls	r0, r0, #1
 800042a:	4149      	adcs	r1, r1
 800042c:	bf28      	it	cs
 800042e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000432:	bd30      	pop	{r4, r5, pc}
 8000434:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000438:	bf3c      	itt	cc
 800043a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800043e:	bd30      	popcc	{r4, r5, pc}
 8000440:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000444:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000448:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800044c:	f04f 0000 	mov.w	r0, #0
 8000450:	bd30      	pop	{r4, r5, pc}
 8000452:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000456:	bf1a      	itte	ne
 8000458:	4619      	movne	r1, r3
 800045a:	4610      	movne	r0, r2
 800045c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000460:	bf1c      	itt	ne
 8000462:	460b      	movne	r3, r1
 8000464:	4602      	movne	r2, r0
 8000466:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800046a:	bf06      	itte	eq
 800046c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000470:	ea91 0f03 	teqeq	r1, r3
 8000474:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000478:	bd30      	pop	{r4, r5, pc}
 800047a:	bf00      	nop

0800047c <__aeabi_ui2d>:
 800047c:	f090 0f00 	teq	r0, #0
 8000480:	bf04      	itt	eq
 8000482:	2100      	moveq	r1, #0
 8000484:	4770      	bxeq	lr
 8000486:	b530      	push	{r4, r5, lr}
 8000488:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800048c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000490:	f04f 0500 	mov.w	r5, #0
 8000494:	f04f 0100 	mov.w	r1, #0
 8000498:	e750      	b.n	800033c <__adddf3+0x138>
 800049a:	bf00      	nop

0800049c <__aeabi_i2d>:
 800049c:	f090 0f00 	teq	r0, #0
 80004a0:	bf04      	itt	eq
 80004a2:	2100      	moveq	r1, #0
 80004a4:	4770      	bxeq	lr
 80004a6:	b530      	push	{r4, r5, lr}
 80004a8:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80004ac:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80004b0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80004b4:	bf48      	it	mi
 80004b6:	4240      	negmi	r0, r0
 80004b8:	f04f 0100 	mov.w	r1, #0
 80004bc:	e73e      	b.n	800033c <__adddf3+0x138>
 80004be:	bf00      	nop

080004c0 <__aeabi_f2d>:
 80004c0:	0042      	lsls	r2, r0, #1
 80004c2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80004c6:	ea4f 0131 	mov.w	r1, r1, rrx
 80004ca:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80004ce:	bf1f      	itttt	ne
 80004d0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80004d4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80004d8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80004dc:	4770      	bxne	lr
 80004de:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80004e2:	bf08      	it	eq
 80004e4:	4770      	bxeq	lr
 80004e6:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80004ea:	bf04      	itt	eq
 80004ec:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80004f0:	4770      	bxeq	lr
 80004f2:	b530      	push	{r4, r5, lr}
 80004f4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80004f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004fc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000500:	e71c      	b.n	800033c <__adddf3+0x138>
 8000502:	bf00      	nop

08000504 <__aeabi_ul2d>:
 8000504:	ea50 0201 	orrs.w	r2, r0, r1
 8000508:	bf08      	it	eq
 800050a:	4770      	bxeq	lr
 800050c:	b530      	push	{r4, r5, lr}
 800050e:	f04f 0500 	mov.w	r5, #0
 8000512:	e00a      	b.n	800052a <__aeabi_l2d+0x16>

08000514 <__aeabi_l2d>:
 8000514:	ea50 0201 	orrs.w	r2, r0, r1
 8000518:	bf08      	it	eq
 800051a:	4770      	bxeq	lr
 800051c:	b530      	push	{r4, r5, lr}
 800051e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000522:	d502      	bpl.n	800052a <__aeabi_l2d+0x16>
 8000524:	4240      	negs	r0, r0
 8000526:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800052a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800052e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000532:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000536:	f43f aed8 	beq.w	80002ea <__adddf3+0xe6>
 800053a:	f04f 0203 	mov.w	r2, #3
 800053e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000542:	bf18      	it	ne
 8000544:	3203      	addne	r2, #3
 8000546:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800054a:	bf18      	it	ne
 800054c:	3203      	addne	r2, #3
 800054e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000552:	f1c2 0320 	rsb	r3, r2, #32
 8000556:	fa00 fc03 	lsl.w	ip, r0, r3
 800055a:	fa20 f002 	lsr.w	r0, r0, r2
 800055e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000562:	ea40 000e 	orr.w	r0, r0, lr
 8000566:	fa21 f102 	lsr.w	r1, r1, r2
 800056a:	4414      	add	r4, r2
 800056c:	e6bd      	b.n	80002ea <__adddf3+0xe6>
 800056e:	bf00      	nop

08000570 <__aeabi_dmul>:
 8000570:	b570      	push	{r4, r5, r6, lr}
 8000572:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000576:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800057a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800057e:	bf1d      	ittte	ne
 8000580:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000584:	ea94 0f0c 	teqne	r4, ip
 8000588:	ea95 0f0c 	teqne	r5, ip
 800058c:	f000 f8de 	bleq	800074c <__aeabi_dmul+0x1dc>
 8000590:	442c      	add	r4, r5
 8000592:	ea81 0603 	eor.w	r6, r1, r3
 8000596:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800059a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800059e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80005a2:	bf18      	it	ne
 80005a4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80005a8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80005ac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80005b0:	d038      	beq.n	8000624 <__aeabi_dmul+0xb4>
 80005b2:	fba0 ce02 	umull	ip, lr, r0, r2
 80005b6:	f04f 0500 	mov.w	r5, #0
 80005ba:	fbe1 e502 	umlal	lr, r5, r1, r2
 80005be:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80005c2:	fbe0 e503 	umlal	lr, r5, r0, r3
 80005c6:	f04f 0600 	mov.w	r6, #0
 80005ca:	fbe1 5603 	umlal	r5, r6, r1, r3
 80005ce:	f09c 0f00 	teq	ip, #0
 80005d2:	bf18      	it	ne
 80005d4:	f04e 0e01 	orrne.w	lr, lr, #1
 80005d8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80005dc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80005e0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80005e4:	d204      	bcs.n	80005f0 <__aeabi_dmul+0x80>
 80005e6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80005ea:	416d      	adcs	r5, r5
 80005ec:	eb46 0606 	adc.w	r6, r6, r6
 80005f0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80005f4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80005f8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80005fc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000600:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000604:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000608:	bf88      	it	hi
 800060a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800060e:	d81e      	bhi.n	800064e <__aeabi_dmul+0xde>
 8000610:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000614:	bf08      	it	eq
 8000616:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800061a:	f150 0000 	adcs.w	r0, r0, #0
 800061e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000622:	bd70      	pop	{r4, r5, r6, pc}
 8000624:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000628:	ea46 0101 	orr.w	r1, r6, r1
 800062c:	ea40 0002 	orr.w	r0, r0, r2
 8000630:	ea81 0103 	eor.w	r1, r1, r3
 8000634:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000638:	bfc2      	ittt	gt
 800063a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800063e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000642:	bd70      	popgt	{r4, r5, r6, pc}
 8000644:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000648:	f04f 0e00 	mov.w	lr, #0
 800064c:	3c01      	subs	r4, #1
 800064e:	f300 80ab 	bgt.w	80007a8 <__aeabi_dmul+0x238>
 8000652:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000656:	bfde      	ittt	le
 8000658:	2000      	movle	r0, #0
 800065a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800065e:	bd70      	pople	{r4, r5, r6, pc}
 8000660:	f1c4 0400 	rsb	r4, r4, #0
 8000664:	3c20      	subs	r4, #32
 8000666:	da35      	bge.n	80006d4 <__aeabi_dmul+0x164>
 8000668:	340c      	adds	r4, #12
 800066a:	dc1b      	bgt.n	80006a4 <__aeabi_dmul+0x134>
 800066c:	f104 0414 	add.w	r4, r4, #20
 8000670:	f1c4 0520 	rsb	r5, r4, #32
 8000674:	fa00 f305 	lsl.w	r3, r0, r5
 8000678:	fa20 f004 	lsr.w	r0, r0, r4
 800067c:	fa01 f205 	lsl.w	r2, r1, r5
 8000680:	ea40 0002 	orr.w	r0, r0, r2
 8000684:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000688:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800068c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000690:	fa21 f604 	lsr.w	r6, r1, r4
 8000694:	eb42 0106 	adc.w	r1, r2, r6
 8000698:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800069c:	bf08      	it	eq
 800069e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006a2:	bd70      	pop	{r4, r5, r6, pc}
 80006a4:	f1c4 040c 	rsb	r4, r4, #12
 80006a8:	f1c4 0520 	rsb	r5, r4, #32
 80006ac:	fa00 f304 	lsl.w	r3, r0, r4
 80006b0:	fa20 f005 	lsr.w	r0, r0, r5
 80006b4:	fa01 f204 	lsl.w	r2, r1, r4
 80006b8:	ea40 0002 	orr.w	r0, r0, r2
 80006bc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80006c0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006c4:	f141 0100 	adc.w	r1, r1, #0
 80006c8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006cc:	bf08      	it	eq
 80006ce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006d2:	bd70      	pop	{r4, r5, r6, pc}
 80006d4:	f1c4 0520 	rsb	r5, r4, #32
 80006d8:	fa00 f205 	lsl.w	r2, r0, r5
 80006dc:	ea4e 0e02 	orr.w	lr, lr, r2
 80006e0:	fa20 f304 	lsr.w	r3, r0, r4
 80006e4:	fa01 f205 	lsl.w	r2, r1, r5
 80006e8:	ea43 0302 	orr.w	r3, r3, r2
 80006ec:	fa21 f004 	lsr.w	r0, r1, r4
 80006f0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80006f4:	fa21 f204 	lsr.w	r2, r1, r4
 80006f8:	ea20 0002 	bic.w	r0, r0, r2
 80006fc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000700:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000704:	bf08      	it	eq
 8000706:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800070a:	bd70      	pop	{r4, r5, r6, pc}
 800070c:	f094 0f00 	teq	r4, #0
 8000710:	d10f      	bne.n	8000732 <__aeabi_dmul+0x1c2>
 8000712:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000716:	0040      	lsls	r0, r0, #1
 8000718:	eb41 0101 	adc.w	r1, r1, r1
 800071c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000720:	bf08      	it	eq
 8000722:	3c01      	subeq	r4, #1
 8000724:	d0f7      	beq.n	8000716 <__aeabi_dmul+0x1a6>
 8000726:	ea41 0106 	orr.w	r1, r1, r6
 800072a:	f095 0f00 	teq	r5, #0
 800072e:	bf18      	it	ne
 8000730:	4770      	bxne	lr
 8000732:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000736:	0052      	lsls	r2, r2, #1
 8000738:	eb43 0303 	adc.w	r3, r3, r3
 800073c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000740:	bf08      	it	eq
 8000742:	3d01      	subeq	r5, #1
 8000744:	d0f7      	beq.n	8000736 <__aeabi_dmul+0x1c6>
 8000746:	ea43 0306 	orr.w	r3, r3, r6
 800074a:	4770      	bx	lr
 800074c:	ea94 0f0c 	teq	r4, ip
 8000750:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000754:	bf18      	it	ne
 8000756:	ea95 0f0c 	teqne	r5, ip
 800075a:	d00c      	beq.n	8000776 <__aeabi_dmul+0x206>
 800075c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000760:	bf18      	it	ne
 8000762:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000766:	d1d1      	bne.n	800070c <__aeabi_dmul+0x19c>
 8000768:	ea81 0103 	eor.w	r1, r1, r3
 800076c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000770:	f04f 0000 	mov.w	r0, #0
 8000774:	bd70      	pop	{r4, r5, r6, pc}
 8000776:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800077a:	bf06      	itte	eq
 800077c:	4610      	moveq	r0, r2
 800077e:	4619      	moveq	r1, r3
 8000780:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000784:	d019      	beq.n	80007ba <__aeabi_dmul+0x24a>
 8000786:	ea94 0f0c 	teq	r4, ip
 800078a:	d102      	bne.n	8000792 <__aeabi_dmul+0x222>
 800078c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000790:	d113      	bne.n	80007ba <__aeabi_dmul+0x24a>
 8000792:	ea95 0f0c 	teq	r5, ip
 8000796:	d105      	bne.n	80007a4 <__aeabi_dmul+0x234>
 8000798:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800079c:	bf1c      	itt	ne
 800079e:	4610      	movne	r0, r2
 80007a0:	4619      	movne	r1, r3
 80007a2:	d10a      	bne.n	80007ba <__aeabi_dmul+0x24a>
 80007a4:	ea81 0103 	eor.w	r1, r1, r3
 80007a8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007ac:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80007b0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80007b4:	f04f 0000 	mov.w	r0, #0
 80007b8:	bd70      	pop	{r4, r5, r6, pc}
 80007ba:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80007be:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80007c2:	bd70      	pop	{r4, r5, r6, pc}

080007c4 <__aeabi_ddiv>:
 80007c4:	b570      	push	{r4, r5, r6, lr}
 80007c6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80007ca:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80007ce:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80007d2:	bf1d      	ittte	ne
 80007d4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80007d8:	ea94 0f0c 	teqne	r4, ip
 80007dc:	ea95 0f0c 	teqne	r5, ip
 80007e0:	f000 f8a7 	bleq	8000932 <__aeabi_ddiv+0x16e>
 80007e4:	eba4 0405 	sub.w	r4, r4, r5
 80007e8:	ea81 0e03 	eor.w	lr, r1, r3
 80007ec:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80007f0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80007f4:	f000 8088 	beq.w	8000908 <__aeabi_ddiv+0x144>
 80007f8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80007fc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000800:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000804:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000808:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800080c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000810:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000814:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000818:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800081c:	429d      	cmp	r5, r3
 800081e:	bf08      	it	eq
 8000820:	4296      	cmpeq	r6, r2
 8000822:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000826:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800082a:	d202      	bcs.n	8000832 <__aeabi_ddiv+0x6e>
 800082c:	085b      	lsrs	r3, r3, #1
 800082e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000832:	1ab6      	subs	r6, r6, r2
 8000834:	eb65 0503 	sbc.w	r5, r5, r3
 8000838:	085b      	lsrs	r3, r3, #1
 800083a:	ea4f 0232 	mov.w	r2, r2, rrx
 800083e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000842:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000846:	ebb6 0e02 	subs.w	lr, r6, r2
 800084a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800084e:	bf22      	ittt	cs
 8000850:	1ab6      	subcs	r6, r6, r2
 8000852:	4675      	movcs	r5, lr
 8000854:	ea40 000c 	orrcs.w	r0, r0, ip
 8000858:	085b      	lsrs	r3, r3, #1
 800085a:	ea4f 0232 	mov.w	r2, r2, rrx
 800085e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000862:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000866:	bf22      	ittt	cs
 8000868:	1ab6      	subcs	r6, r6, r2
 800086a:	4675      	movcs	r5, lr
 800086c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000870:	085b      	lsrs	r3, r3, #1
 8000872:	ea4f 0232 	mov.w	r2, r2, rrx
 8000876:	ebb6 0e02 	subs.w	lr, r6, r2
 800087a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800087e:	bf22      	ittt	cs
 8000880:	1ab6      	subcs	r6, r6, r2
 8000882:	4675      	movcs	r5, lr
 8000884:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000888:	085b      	lsrs	r3, r3, #1
 800088a:	ea4f 0232 	mov.w	r2, r2, rrx
 800088e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000892:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000896:	bf22      	ittt	cs
 8000898:	1ab6      	subcs	r6, r6, r2
 800089a:	4675      	movcs	r5, lr
 800089c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80008a0:	ea55 0e06 	orrs.w	lr, r5, r6
 80008a4:	d018      	beq.n	80008d8 <__aeabi_ddiv+0x114>
 80008a6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80008aa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80008ae:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80008b2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80008b6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80008ba:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80008be:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80008c2:	d1c0      	bne.n	8000846 <__aeabi_ddiv+0x82>
 80008c4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80008c8:	d10b      	bne.n	80008e2 <__aeabi_ddiv+0x11e>
 80008ca:	ea41 0100 	orr.w	r1, r1, r0
 80008ce:	f04f 0000 	mov.w	r0, #0
 80008d2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80008d6:	e7b6      	b.n	8000846 <__aeabi_ddiv+0x82>
 80008d8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80008dc:	bf04      	itt	eq
 80008de:	4301      	orreq	r1, r0
 80008e0:	2000      	moveq	r0, #0
 80008e2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80008e6:	bf88      	it	hi
 80008e8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80008ec:	f63f aeaf 	bhi.w	800064e <__aeabi_dmul+0xde>
 80008f0:	ebb5 0c03 	subs.w	ip, r5, r3
 80008f4:	bf04      	itt	eq
 80008f6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80008fa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80008fe:	f150 0000 	adcs.w	r0, r0, #0
 8000902:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000906:	bd70      	pop	{r4, r5, r6, pc}
 8000908:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800090c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000910:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000914:	bfc2      	ittt	gt
 8000916:	ebd4 050c 	rsbsgt	r5, r4, ip
 800091a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800091e:	bd70      	popgt	{r4, r5, r6, pc}
 8000920:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000924:	f04f 0e00 	mov.w	lr, #0
 8000928:	3c01      	subs	r4, #1
 800092a:	e690      	b.n	800064e <__aeabi_dmul+0xde>
 800092c:	ea45 0e06 	orr.w	lr, r5, r6
 8000930:	e68d      	b.n	800064e <__aeabi_dmul+0xde>
 8000932:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000936:	ea94 0f0c 	teq	r4, ip
 800093a:	bf08      	it	eq
 800093c:	ea95 0f0c 	teqeq	r5, ip
 8000940:	f43f af3b 	beq.w	80007ba <__aeabi_dmul+0x24a>
 8000944:	ea94 0f0c 	teq	r4, ip
 8000948:	d10a      	bne.n	8000960 <__aeabi_ddiv+0x19c>
 800094a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800094e:	f47f af34 	bne.w	80007ba <__aeabi_dmul+0x24a>
 8000952:	ea95 0f0c 	teq	r5, ip
 8000956:	f47f af25 	bne.w	80007a4 <__aeabi_dmul+0x234>
 800095a:	4610      	mov	r0, r2
 800095c:	4619      	mov	r1, r3
 800095e:	e72c      	b.n	80007ba <__aeabi_dmul+0x24a>
 8000960:	ea95 0f0c 	teq	r5, ip
 8000964:	d106      	bne.n	8000974 <__aeabi_ddiv+0x1b0>
 8000966:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800096a:	f43f aefd 	beq.w	8000768 <__aeabi_dmul+0x1f8>
 800096e:	4610      	mov	r0, r2
 8000970:	4619      	mov	r1, r3
 8000972:	e722      	b.n	80007ba <__aeabi_dmul+0x24a>
 8000974:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000978:	bf18      	it	ne
 800097a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800097e:	f47f aec5 	bne.w	800070c <__aeabi_dmul+0x19c>
 8000982:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000986:	f47f af0d 	bne.w	80007a4 <__aeabi_dmul+0x234>
 800098a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800098e:	f47f aeeb 	bne.w	8000768 <__aeabi_dmul+0x1f8>
 8000992:	e712      	b.n	80007ba <__aeabi_dmul+0x24a>

08000994 <__aeabi_uldivmod>:
 8000994:	b953      	cbnz	r3, 80009ac <__aeabi_uldivmod+0x18>
 8000996:	b94a      	cbnz	r2, 80009ac <__aeabi_uldivmod+0x18>
 8000998:	2900      	cmp	r1, #0
 800099a:	bf08      	it	eq
 800099c:	2800      	cmpeq	r0, #0
 800099e:	bf1c      	itt	ne
 80009a0:	f04f 31ff 	movne.w	r1, #4294967295
 80009a4:	f04f 30ff 	movne.w	r0, #4294967295
 80009a8:	f000 b96e 	b.w	8000c88 <__aeabi_idiv0>
 80009ac:	f1ad 0c08 	sub.w	ip, sp, #8
 80009b0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80009b4:	f000 f806 	bl	80009c4 <__udivmoddi4>
 80009b8:	f8dd e004 	ldr.w	lr, [sp, #4]
 80009bc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80009c0:	b004      	add	sp, #16
 80009c2:	4770      	bx	lr

080009c4 <__udivmoddi4>:
 80009c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80009c8:	9d08      	ldr	r5, [sp, #32]
 80009ca:	4604      	mov	r4, r0
 80009cc:	468c      	mov	ip, r1
 80009ce:	2b00      	cmp	r3, #0
 80009d0:	f040 8083 	bne.w	8000ada <__udivmoddi4+0x116>
 80009d4:	428a      	cmp	r2, r1
 80009d6:	4617      	mov	r7, r2
 80009d8:	d947      	bls.n	8000a6a <__udivmoddi4+0xa6>
 80009da:	fab2 f282 	clz	r2, r2
 80009de:	b142      	cbz	r2, 80009f2 <__udivmoddi4+0x2e>
 80009e0:	f1c2 0020 	rsb	r0, r2, #32
 80009e4:	fa24 f000 	lsr.w	r0, r4, r0
 80009e8:	4091      	lsls	r1, r2
 80009ea:	4097      	lsls	r7, r2
 80009ec:	ea40 0c01 	orr.w	ip, r0, r1
 80009f0:	4094      	lsls	r4, r2
 80009f2:	ea4f 4817 	mov.w	r8, r7, lsr #16
 80009f6:	0c23      	lsrs	r3, r4, #16
 80009f8:	fbbc f6f8 	udiv	r6, ip, r8
 80009fc:	fa1f fe87 	uxth.w	lr, r7
 8000a00:	fb08 c116 	mls	r1, r8, r6, ip
 8000a04:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000a08:	fb06 f10e 	mul.w	r1, r6, lr
 8000a0c:	4299      	cmp	r1, r3
 8000a0e:	d909      	bls.n	8000a24 <__udivmoddi4+0x60>
 8000a10:	18fb      	adds	r3, r7, r3
 8000a12:	f106 30ff 	add.w	r0, r6, #4294967295
 8000a16:	f080 8119 	bcs.w	8000c4c <__udivmoddi4+0x288>
 8000a1a:	4299      	cmp	r1, r3
 8000a1c:	f240 8116 	bls.w	8000c4c <__udivmoddi4+0x288>
 8000a20:	3e02      	subs	r6, #2
 8000a22:	443b      	add	r3, r7
 8000a24:	1a5b      	subs	r3, r3, r1
 8000a26:	b2a4      	uxth	r4, r4
 8000a28:	fbb3 f0f8 	udiv	r0, r3, r8
 8000a2c:	fb08 3310 	mls	r3, r8, r0, r3
 8000a30:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000a34:	fb00 fe0e 	mul.w	lr, r0, lr
 8000a38:	45a6      	cmp	lr, r4
 8000a3a:	d909      	bls.n	8000a50 <__udivmoddi4+0x8c>
 8000a3c:	193c      	adds	r4, r7, r4
 8000a3e:	f100 33ff 	add.w	r3, r0, #4294967295
 8000a42:	f080 8105 	bcs.w	8000c50 <__udivmoddi4+0x28c>
 8000a46:	45a6      	cmp	lr, r4
 8000a48:	f240 8102 	bls.w	8000c50 <__udivmoddi4+0x28c>
 8000a4c:	3802      	subs	r0, #2
 8000a4e:	443c      	add	r4, r7
 8000a50:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000a54:	eba4 040e 	sub.w	r4, r4, lr
 8000a58:	2600      	movs	r6, #0
 8000a5a:	b11d      	cbz	r5, 8000a64 <__udivmoddi4+0xa0>
 8000a5c:	40d4      	lsrs	r4, r2
 8000a5e:	2300      	movs	r3, #0
 8000a60:	e9c5 4300 	strd	r4, r3, [r5]
 8000a64:	4631      	mov	r1, r6
 8000a66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000a6a:	b902      	cbnz	r2, 8000a6e <__udivmoddi4+0xaa>
 8000a6c:	deff      	udf	#255	; 0xff
 8000a6e:	fab2 f282 	clz	r2, r2
 8000a72:	2a00      	cmp	r2, #0
 8000a74:	d150      	bne.n	8000b18 <__udivmoddi4+0x154>
 8000a76:	1bcb      	subs	r3, r1, r7
 8000a78:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000a7c:	fa1f f887 	uxth.w	r8, r7
 8000a80:	2601      	movs	r6, #1
 8000a82:	fbb3 fcfe 	udiv	ip, r3, lr
 8000a86:	0c21      	lsrs	r1, r4, #16
 8000a88:	fb0e 331c 	mls	r3, lr, ip, r3
 8000a8c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000a90:	fb08 f30c 	mul.w	r3, r8, ip
 8000a94:	428b      	cmp	r3, r1
 8000a96:	d907      	bls.n	8000aa8 <__udivmoddi4+0xe4>
 8000a98:	1879      	adds	r1, r7, r1
 8000a9a:	f10c 30ff 	add.w	r0, ip, #4294967295
 8000a9e:	d202      	bcs.n	8000aa6 <__udivmoddi4+0xe2>
 8000aa0:	428b      	cmp	r3, r1
 8000aa2:	f200 80e9 	bhi.w	8000c78 <__udivmoddi4+0x2b4>
 8000aa6:	4684      	mov	ip, r0
 8000aa8:	1ac9      	subs	r1, r1, r3
 8000aaa:	b2a3      	uxth	r3, r4
 8000aac:	fbb1 f0fe 	udiv	r0, r1, lr
 8000ab0:	fb0e 1110 	mls	r1, lr, r0, r1
 8000ab4:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 8000ab8:	fb08 f800 	mul.w	r8, r8, r0
 8000abc:	45a0      	cmp	r8, r4
 8000abe:	d907      	bls.n	8000ad0 <__udivmoddi4+0x10c>
 8000ac0:	193c      	adds	r4, r7, r4
 8000ac2:	f100 33ff 	add.w	r3, r0, #4294967295
 8000ac6:	d202      	bcs.n	8000ace <__udivmoddi4+0x10a>
 8000ac8:	45a0      	cmp	r8, r4
 8000aca:	f200 80d9 	bhi.w	8000c80 <__udivmoddi4+0x2bc>
 8000ace:	4618      	mov	r0, r3
 8000ad0:	eba4 0408 	sub.w	r4, r4, r8
 8000ad4:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000ad8:	e7bf      	b.n	8000a5a <__udivmoddi4+0x96>
 8000ada:	428b      	cmp	r3, r1
 8000adc:	d909      	bls.n	8000af2 <__udivmoddi4+0x12e>
 8000ade:	2d00      	cmp	r5, #0
 8000ae0:	f000 80b1 	beq.w	8000c46 <__udivmoddi4+0x282>
 8000ae4:	2600      	movs	r6, #0
 8000ae6:	e9c5 0100 	strd	r0, r1, [r5]
 8000aea:	4630      	mov	r0, r6
 8000aec:	4631      	mov	r1, r6
 8000aee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000af2:	fab3 f683 	clz	r6, r3
 8000af6:	2e00      	cmp	r6, #0
 8000af8:	d14a      	bne.n	8000b90 <__udivmoddi4+0x1cc>
 8000afa:	428b      	cmp	r3, r1
 8000afc:	d302      	bcc.n	8000b04 <__udivmoddi4+0x140>
 8000afe:	4282      	cmp	r2, r0
 8000b00:	f200 80b8 	bhi.w	8000c74 <__udivmoddi4+0x2b0>
 8000b04:	1a84      	subs	r4, r0, r2
 8000b06:	eb61 0103 	sbc.w	r1, r1, r3
 8000b0a:	2001      	movs	r0, #1
 8000b0c:	468c      	mov	ip, r1
 8000b0e:	2d00      	cmp	r5, #0
 8000b10:	d0a8      	beq.n	8000a64 <__udivmoddi4+0xa0>
 8000b12:	e9c5 4c00 	strd	r4, ip, [r5]
 8000b16:	e7a5      	b.n	8000a64 <__udivmoddi4+0xa0>
 8000b18:	f1c2 0320 	rsb	r3, r2, #32
 8000b1c:	fa20 f603 	lsr.w	r6, r0, r3
 8000b20:	4097      	lsls	r7, r2
 8000b22:	fa01 f002 	lsl.w	r0, r1, r2
 8000b26:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000b2a:	40d9      	lsrs	r1, r3
 8000b2c:	4330      	orrs	r0, r6
 8000b2e:	0c03      	lsrs	r3, r0, #16
 8000b30:	fbb1 f6fe 	udiv	r6, r1, lr
 8000b34:	fa1f f887 	uxth.w	r8, r7
 8000b38:	fb0e 1116 	mls	r1, lr, r6, r1
 8000b3c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000b40:	fb06 f108 	mul.w	r1, r6, r8
 8000b44:	4299      	cmp	r1, r3
 8000b46:	fa04 f402 	lsl.w	r4, r4, r2
 8000b4a:	d909      	bls.n	8000b60 <__udivmoddi4+0x19c>
 8000b4c:	18fb      	adds	r3, r7, r3
 8000b4e:	f106 3cff 	add.w	ip, r6, #4294967295
 8000b52:	f080 808d 	bcs.w	8000c70 <__udivmoddi4+0x2ac>
 8000b56:	4299      	cmp	r1, r3
 8000b58:	f240 808a 	bls.w	8000c70 <__udivmoddi4+0x2ac>
 8000b5c:	3e02      	subs	r6, #2
 8000b5e:	443b      	add	r3, r7
 8000b60:	1a5b      	subs	r3, r3, r1
 8000b62:	b281      	uxth	r1, r0
 8000b64:	fbb3 f0fe 	udiv	r0, r3, lr
 8000b68:	fb0e 3310 	mls	r3, lr, r0, r3
 8000b6c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000b70:	fb00 f308 	mul.w	r3, r0, r8
 8000b74:	428b      	cmp	r3, r1
 8000b76:	d907      	bls.n	8000b88 <__udivmoddi4+0x1c4>
 8000b78:	1879      	adds	r1, r7, r1
 8000b7a:	f100 3cff 	add.w	ip, r0, #4294967295
 8000b7e:	d273      	bcs.n	8000c68 <__udivmoddi4+0x2a4>
 8000b80:	428b      	cmp	r3, r1
 8000b82:	d971      	bls.n	8000c68 <__udivmoddi4+0x2a4>
 8000b84:	3802      	subs	r0, #2
 8000b86:	4439      	add	r1, r7
 8000b88:	1acb      	subs	r3, r1, r3
 8000b8a:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8000b8e:	e778      	b.n	8000a82 <__udivmoddi4+0xbe>
 8000b90:	f1c6 0c20 	rsb	ip, r6, #32
 8000b94:	fa03 f406 	lsl.w	r4, r3, r6
 8000b98:	fa22 f30c 	lsr.w	r3, r2, ip
 8000b9c:	431c      	orrs	r4, r3
 8000b9e:	fa20 f70c 	lsr.w	r7, r0, ip
 8000ba2:	fa01 f306 	lsl.w	r3, r1, r6
 8000ba6:	ea4f 4e14 	mov.w	lr, r4, lsr #16
 8000baa:	fa21 f10c 	lsr.w	r1, r1, ip
 8000bae:	431f      	orrs	r7, r3
 8000bb0:	0c3b      	lsrs	r3, r7, #16
 8000bb2:	fbb1 f9fe 	udiv	r9, r1, lr
 8000bb6:	fa1f f884 	uxth.w	r8, r4
 8000bba:	fb0e 1119 	mls	r1, lr, r9, r1
 8000bbe:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8000bc2:	fb09 fa08 	mul.w	sl, r9, r8
 8000bc6:	458a      	cmp	sl, r1
 8000bc8:	fa02 f206 	lsl.w	r2, r2, r6
 8000bcc:	fa00 f306 	lsl.w	r3, r0, r6
 8000bd0:	d908      	bls.n	8000be4 <__udivmoddi4+0x220>
 8000bd2:	1861      	adds	r1, r4, r1
 8000bd4:	f109 30ff 	add.w	r0, r9, #4294967295
 8000bd8:	d248      	bcs.n	8000c6c <__udivmoddi4+0x2a8>
 8000bda:	458a      	cmp	sl, r1
 8000bdc:	d946      	bls.n	8000c6c <__udivmoddi4+0x2a8>
 8000bde:	f1a9 0902 	sub.w	r9, r9, #2
 8000be2:	4421      	add	r1, r4
 8000be4:	eba1 010a 	sub.w	r1, r1, sl
 8000be8:	b2bf      	uxth	r7, r7
 8000bea:	fbb1 f0fe 	udiv	r0, r1, lr
 8000bee:	fb0e 1110 	mls	r1, lr, r0, r1
 8000bf2:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8000bf6:	fb00 f808 	mul.w	r8, r0, r8
 8000bfa:	45b8      	cmp	r8, r7
 8000bfc:	d907      	bls.n	8000c0e <__udivmoddi4+0x24a>
 8000bfe:	19e7      	adds	r7, r4, r7
 8000c00:	f100 31ff 	add.w	r1, r0, #4294967295
 8000c04:	d22e      	bcs.n	8000c64 <__udivmoddi4+0x2a0>
 8000c06:	45b8      	cmp	r8, r7
 8000c08:	d92c      	bls.n	8000c64 <__udivmoddi4+0x2a0>
 8000c0a:	3802      	subs	r0, #2
 8000c0c:	4427      	add	r7, r4
 8000c0e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000c12:	eba7 0708 	sub.w	r7, r7, r8
 8000c16:	fba0 8902 	umull	r8, r9, r0, r2
 8000c1a:	454f      	cmp	r7, r9
 8000c1c:	46c6      	mov	lr, r8
 8000c1e:	4649      	mov	r1, r9
 8000c20:	d31a      	bcc.n	8000c58 <__udivmoddi4+0x294>
 8000c22:	d017      	beq.n	8000c54 <__udivmoddi4+0x290>
 8000c24:	b15d      	cbz	r5, 8000c3e <__udivmoddi4+0x27a>
 8000c26:	ebb3 020e 	subs.w	r2, r3, lr
 8000c2a:	eb67 0701 	sbc.w	r7, r7, r1
 8000c2e:	fa07 fc0c 	lsl.w	ip, r7, ip
 8000c32:	40f2      	lsrs	r2, r6
 8000c34:	ea4c 0202 	orr.w	r2, ip, r2
 8000c38:	40f7      	lsrs	r7, r6
 8000c3a:	e9c5 2700 	strd	r2, r7, [r5]
 8000c3e:	2600      	movs	r6, #0
 8000c40:	4631      	mov	r1, r6
 8000c42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c46:	462e      	mov	r6, r5
 8000c48:	4628      	mov	r0, r5
 8000c4a:	e70b      	b.n	8000a64 <__udivmoddi4+0xa0>
 8000c4c:	4606      	mov	r6, r0
 8000c4e:	e6e9      	b.n	8000a24 <__udivmoddi4+0x60>
 8000c50:	4618      	mov	r0, r3
 8000c52:	e6fd      	b.n	8000a50 <__udivmoddi4+0x8c>
 8000c54:	4543      	cmp	r3, r8
 8000c56:	d2e5      	bcs.n	8000c24 <__udivmoddi4+0x260>
 8000c58:	ebb8 0e02 	subs.w	lr, r8, r2
 8000c5c:	eb69 0104 	sbc.w	r1, r9, r4
 8000c60:	3801      	subs	r0, #1
 8000c62:	e7df      	b.n	8000c24 <__udivmoddi4+0x260>
 8000c64:	4608      	mov	r0, r1
 8000c66:	e7d2      	b.n	8000c0e <__udivmoddi4+0x24a>
 8000c68:	4660      	mov	r0, ip
 8000c6a:	e78d      	b.n	8000b88 <__udivmoddi4+0x1c4>
 8000c6c:	4681      	mov	r9, r0
 8000c6e:	e7b9      	b.n	8000be4 <__udivmoddi4+0x220>
 8000c70:	4666      	mov	r6, ip
 8000c72:	e775      	b.n	8000b60 <__udivmoddi4+0x19c>
 8000c74:	4630      	mov	r0, r6
 8000c76:	e74a      	b.n	8000b0e <__udivmoddi4+0x14a>
 8000c78:	f1ac 0c02 	sub.w	ip, ip, #2
 8000c7c:	4439      	add	r1, r7
 8000c7e:	e713      	b.n	8000aa8 <__udivmoddi4+0xe4>
 8000c80:	3802      	subs	r0, #2
 8000c82:	443c      	add	r4, r7
 8000c84:	e724      	b.n	8000ad0 <__udivmoddi4+0x10c>
 8000c86:	bf00      	nop

08000c88 <__aeabi_idiv0>:
 8000c88:	4770      	bx	lr
 8000c8a:	bf00      	nop

08000c8c <OsStartToRun>:
.type OsStartToRun, %function
.global OsStartToRun
OsStartToRun:
    .fnstart
    .cantunwind
    ldr     r4, =OS_NVIC_SYSPRI2
 8000c8c:	4c28      	ldr	r4, [pc, #160]	; (8000d30 <TaskSwitch+0x42>)
    ldr     r5, =OS_NVIC_PENDSV_PRI
 8000c8e:	4d29      	ldr	r5, [pc, #164]	; (8000d34 <TaskSwitch+0x46>)
    str     r5, [r4]
 8000c90:	6025      	str	r5, [r4, #0]

    ldr     r1, =g_oldTask
 8000c92:	4929      	ldr	r1, [pc, #164]	; (8000d38 <TaskSwitch+0x4a>)
    str     r0, [r1]
 8000c94:	6008      	str	r0, [r1, #0]

    ldr     r1, =g_runTask
 8000c96:	4929      	ldr	r1, [pc, #164]	; (8000d3c <TaskSwitch+0x4e>)
    str     r0, [r1]
 8000c98:	6008      	str	r0, [r1, #0]

    movs    r1, #2
 8000c9a:	2102      	movs	r1, #2
    msr     CONTROL, r1
 8000c9c:	f381 8814 	msr	CONTROL, r1
    ldrh    r7, [r0 , #4]
 8000ca0:	8887      	ldrh	r7, [r0, #4]

    movs    r6,  #OS_TASK_STATUS_RUNNING
 8000ca2:	2610      	movs	r6, #16
    strh    r6,  [r0 , #4]
 8000ca4:	8086      	strh	r6, [r0, #4]

    msr     psp, r3
    subs    r3, r3, #20
    ldr     r3,  [r3]
#else
    ldr     r12, [r0]
 8000ca6:	f8d0 c000 	ldr.w	ip, [r0]

    add     r12, r12, #36
 8000caa:	f10c 0c24 	add.w	ip, ip, #36	; 0x24
    /* __VFP_FP__ is set by -mfpu; __SOFTFP__ is set by -mfloat-abi=soft. */
#if defined(__VFP_FP__) && !defined(__SOFTFP__)
    add     r12, r12, #4
 8000cae:	f10c 0c04 	add.w	ip, ip, #4
#endif

    ldmfd   r12!, {R0-R7}
 8000cb2:	e8bc 00ff 	ldmia.w	ip!, {r0, r1, r2, r3, r4, r5, r6, r7}

    msr     psp, r12
 8000cb6:	f38c 8809 	msr	PSP, ip

#ifdef LOSCFG_ARCH_FPU_ENABLE
    vpush   {s0};
 8000cba:	ed2d 0a01 	vpush	{s0}
    vpop    {s0};
 8000cbe:	ecbd 0a01 	vpop	{s0}
#endif

#endif

    mov     lr, r5
 8000cc2:	46ae      	mov	lr, r5

    cpsie   I
 8000cc4:	b662      	cpsie	i
    bx      r6
 8000cc6:	4730      	bx	r6

08000cc8 <ArchIntLock>:
.type ArchIntLock, %function
.global ArchIntLock
ArchIntLock:
    .fnstart
    .cantunwind
    mrs     r0, PRIMASK
 8000cc8:	f3ef 8010 	mrs	r0, PRIMASK
    cpsid   I
 8000ccc:	b672      	cpsid	i
    bx      lr
 8000cce:	4770      	bx	lr

08000cd0 <ArchIntUnlock>:
.type ArchIntUnlock, %function
.global ArchIntUnlock
ArchIntUnlock:
    .fnstart
    .cantunwind
    mrs     r0, PRIMASK
 8000cd0:	f3ef 8010 	mrs	r0, PRIMASK
    cpsie   I
 8000cd4:	b662      	cpsie	i
    bx      lr
 8000cd6:	4770      	bx	lr

08000cd8 <ArchIntRestore>:
.type ArchIntRestore, %function
.global ArchIntRestore
ArchIntRestore:
    .fnstart
    .cantunwind
    msr     PRIMASK, r0
 8000cd8:	f380 8810 	msr	PRIMASK, r0
    bx      lr
 8000cdc:	4770      	bx	lr

08000cde <OsTaskSchedule>:
.type OsTaskSchedule, %function
.global OsTaskSchedule
OsTaskSchedule:
    .fnstart
    .cantunwind
    ldr     r2, =OS_NVIC_INT_CTRL
 8000cde:	4a18      	ldr	r2, [pc, #96]	; (8000d40 <TaskSwitch+0x52>)
    ldr     r3, =OS_NVIC_PENDSVSET
 8000ce0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    str     r3, [r2]
 8000ce4:	6013      	str	r3, [r2, #0]
    bx      lr
 8000ce6:	4770      	bx	lr

08000ce8 <osPendSV>:
.type osPendSV, %function
.global osPendSV
osPendSV:
    .fnstart
    .cantunwind
    mrs     r12, PRIMASK
 8000ce8:	f3ef 8c10 	mrs	ip, PRIMASK
    cpsid   I
 8000cec:	b672      	cpsid	i

08000cee <TaskSwitch>:

TaskSwitch:
    mrs     r0, psp
 8000cee:	f3ef 8009 	mrs	r0, PSP

    subs    r0, #36
#else
#if defined(__VFP_FP__) && !defined(__SOFTFP__)
    /* when enter the exc or interrut, lr's value is EXC_RETURN. If FPCA = 1, the 4's bit of EXC_RETURN is 0. */
    tst     lr, #0x10
 8000cf2:	f01e 0f10 	tst.w	lr, #16
    it      eq
 8000cf6:	bf08      	it	eq
    vstmdbeq  r0!, {d8-d15} /* push VFP registers. */
 8000cf8:	ed20 8b10 	vstmdbeq	r0!, {d8-d15}
    stmfd     r0!, {r14}
 8000cfc:	f840 ed04 	str.w	lr, [r0, #-4]!
#endif
    stmfd   r0!, {r4-r12}
 8000d00:	e920 1ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#endif
    ldr     r5, =g_oldTask
 8000d04:	4d0c      	ldr	r5, [pc, #48]	; (8000d38 <TaskSwitch+0x4a>)
    ldr     r1, [r5]
 8000d06:	6829      	ldr	r1, [r5, #0]
    str     r0, [r1]
 8000d08:	6008      	str	r0, [r1, #0]

    ldr     r0, =g_runTask
 8000d0a:	480c      	ldr	r0, [pc, #48]	; (8000d3c <TaskSwitch+0x4e>)
    ldr     r0, [r0]
 8000d0c:	6800      	ldr	r0, [r0, #0]
    /* g_oldTask = g_runTask */
    str     r0, [r5]
 8000d0e:	6028      	str	r0, [r5, #0]
    ldr     r1, [r0]
 8000d10:	6801      	ldr	r1, [r0, #0]
    subs    r1,  #36
    ldmfd   r1!, {r4-r7}

    adds    r1,   #20
#else
    ldmfd   r1!, {r4-r12}
 8000d12:	e8b1 1ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#endif

#if defined(__VFP_FP__) && !defined(__SOFTFP__)
    ldmfd   r1!, {r14}
 8000d16:	f851 eb04 	ldr.w	lr, [r1], #4
    tst     r14, #0x10
 8000d1a:	f01e 0f10 	tst.w	lr, #16
    it      eq
 8000d1e:	bf08      	it	eq
    vldmiaeq r1!, {d8-d15}
 8000d20:	ecb1 8b10 	vldmiaeq	r1!, {d8-d15}
#endif

    msr     psp,  r1
 8000d24:	f381 8809 	msr	PSP, r1

    msr     PRIMASK, r12
 8000d28:	f38c 8810 	msr	PRIMASK, ip
    bx      lr
 8000d2c:	4770      	bx	lr
 8000d2e:	0000      	.short	0x0000
    ldr     r4, =OS_NVIC_SYSPRI2
 8000d30:	e000ed20 	.word	0xe000ed20
    ldr     r5, =OS_NVIC_PENDSV_PRI
 8000d34:	f0f00000 	.word	0xf0f00000
    ldr     r1, =g_oldTask
 8000d38:	200033c0 	.word	0x200033c0
    ldr     r1, =g_runTask
 8000d3c:	200033bc 	.word	0x200033bc
    ldr     r2, =OS_NVIC_INT_CTRL
 8000d40:	e000ed04 	.word	0xe000ed04

08000d44 <OsExcNMI>:
    .type OsExcNMI, %function
    .global OsExcNMI
OsExcNMI:
    .fnstart
    .cantunwind
    MOV  R0, #OS_EXC_CAUSE_NMI
 8000d44:	f04f 0010 	mov.w	r0, #16
    MOV  R1, #0
 8000d48:	f04f 0100 	mov.w	r1, #0
    B    OsExcDispatch
 8000d4c:	e074      	b.n	8000e38 <OsExcDispatch>

08000d4e <OsExcHardFault>:
    .type OsExcHardFault, %function
    .global OsExcHardFault
OsExcHardFault:
    .fnstart
    .cantunwind
    MOV  R0, #OS_EXC_CAUSE_HARDFAULT
 8000d4e:	f04f 0011 	mov.w	r0, #17
    LDR  R2, =OS_NVIC_HFSR
 8000d52:	4a6e      	ldr	r2, [pc, #440]	; (8000f0c <HandleEntry+0xe>)
    LDR  R2, [R2]
 8000d54:	6812      	ldr	r2, [r2, #0]

    MOV  R1, #HF_DEBUGEVT
 8000d56:	f04f 0114 	mov.w	r1, #20
    ORR  R0, R0, R1, LSL #0x8
 8000d5a:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
    TST  R2, #0x80000000
 8000d5e:	f012 4f00 	tst.w	r2, #2147483648	; 0x80000000
    BNE  OsExcDispatch /* DEBUGEVT */
 8000d62:	d169      	bne.n	8000e38 <OsExcDispatch>

    AND  R0, #0x000000FF
 8000d64:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    MOV  R1, #HF_VECTBL
 8000d68:	f04f 0115 	mov.w	r1, #21
    ORR  R0, R0, R1, LSL #0x8
 8000d6c:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
    TST  R2, #0x00000002
 8000d70:	f012 0f02 	tst.w	r2, #2
    BNE  OsExcDispatch /* VECTBL */
 8000d74:	d160      	bne.n	8000e38 <OsExcDispatch>

    /* if not DEBUGEVT and VECTBL then is FORCED */
    AND  R0, #0x000000FF
 8000d76:	f000 00ff 	and.w	r0, r0, #255	; 0xff

    MRS  R2, MSP
 8000d7a:	f3ef 8208 	mrs	r2, MSP
    LDR  R1, [R2, EXCEPT_FRAME_OFFSET_PC]
 8000d7e:	6991      	ldr	r1, [r2, #24]

    LDR  R2, =OS_NVIC_FSR
 8000d80:	4a63      	ldr	r2, [pc, #396]	; (8000f10 <HandleEntry+0x12>)
    LDR  R2, [R2]
 8000d82:	6812      	ldr	r2, [r2, #0]

    TST  R2, #0x8000 /* BFARVALID */
 8000d84:	f412 4f00 	tst.w	r2, #32768	; 0x8000
    BNE  HFBusFault /* BusFault */
 8000d88:	d106      	bne.n	8000d98 <HFBusFault>

    TST  R2, #0x80 /* MMARVALID */
 8000d8a:	f012 0f80 	tst.w	r2, #128	; 0x80
    BNE  HFMemFault /* MemFault */
 8000d8e:	d109      	bne.n	8000da4 <HFMemFault>

    MOV  R12,#0
 8000d90:	f04f 0c00 	mov.w	ip, #0
    B    OsHFExcCommonBMU
 8000d94:	f000 b80a 	b.w	8000dac <OsHFExcCommonBMU>

08000d98 <HFBusFault>:

    .type HFBusFault, %function
HFBusFault:
    .fnstart
    .cantunwind
    LDR  R1, =OS_NVIC_BFAR
 8000d98:	495e      	ldr	r1, [pc, #376]	; (8000f14 <HandleEntry+0x16>)
    LDR  R1, [R1]
 8000d9a:	6809      	ldr	r1, [r1, #0]
    MOV  R12, #OS_EXC_FLAG_FAULTADDR_VALID
 8000d9c:	f44f 3c80 	mov.w	ip, #65536	; 0x10000
    B    OsHFExcCommonBMU
 8000da0:	f000 b804 	b.w	8000dac <OsHFExcCommonBMU>

08000da4 <HFMemFault>:

    .type HFMemFault, %function
HFMemFault:
    .fnstart
    .cantunwind
    LDR  R1, =OS_NVIC_MMAR
 8000da4:	495c      	ldr	r1, [pc, #368]	; (8000f18 <HandleEntry+0x1a>)
    LDR  R1, [R1]
 8000da6:	6809      	ldr	r1, [r1, #0]
    MOV  R12, #OS_EXC_FLAG_FAULTADDR_VALID
 8000da8:	f44f 3c80 	mov.w	ip, #65536	; 0x10000

08000dac <OsHFExcCommonBMU>:
    .type OsHFExcCommonBMU, %function
    .global OsHFExcCommonBMU
OsHFExcCommonBMU:
    .fnstart
    .cantunwind
    CLZ  R2, R2
 8000dac:	fab2 f282 	clz	r2, r2
    LDR  R3, =g_excTbl
 8000db0:	4b5a      	ldr	r3, [pc, #360]	; (8000f1c <HandleEntry+0x1e>)
    ADD  R3, R3, R2
 8000db2:	4413      	add	r3, r2
    LDRB R2, [R3]
 8000db4:	781a      	ldrb	r2, [r3, #0]
    ORR  R0, R0, R2, LSL #0x8
 8000db6:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
    ORR  R0, R12
 8000dba:	ea40 000c 	orr.w	r0, r0, ip
    B    OsExcDispatch
 8000dbe:	e03b      	b.n	8000e38 <OsExcDispatch>

08000dc0 <OsExcSvcCall>:
    .type OsExcSvcCall, %function
    .global OsExcSvcCall
OsExcSvcCall:
    .fnstart
    .cantunwind
    TST   LR, #0x4
 8000dc0:	f01e 0f04 	tst.w	lr, #4
    ITE   EQ
 8000dc4:	bf0c      	ite	eq
    MRSEQ R0, MSP
 8000dc6:	f3ef 8008 	mrseq	r0, MSP
    MRSNE R0, PSP
 8000dca:	f3ef 8009 	mrsne	r0, PSP
    LDR   R1, [R0,#24]
 8000dce:	6981      	ldr	r1, [r0, #24]
    LDRB  R0, [R1,#-2]
 8000dd0:	f811 0c02 	ldrb.w	r0, [r1, #-2]
    MOV   R1, #0
 8000dd4:	f04f 0100 	mov.w	r1, #0
    B     OsExcDispatch
 8000dd8:	e02e      	b.n	8000e38 <OsExcDispatch>

08000dda <OsExcBusFault>:
    .type OsExcBusFault, %function
    .global OsExcBusFault
OsExcBusFault:
    .fnstart
    .cantunwind
    LDR  R0, =OS_NVIC_FSR
 8000dda:	484d      	ldr	r0, [pc, #308]	; (8000f10 <HandleEntry+0x12>)
    LDR  R0, [R0]
 8000ddc:	6800      	ldr	r0, [r0, #0]

    TST  R0, #0x8000 /* BFARVALID */
 8000dde:	f410 4f00 	tst.w	r0, #32768	; 0x8000
    BEQ  ExcBusNoAddr
 8000de2:	d006      	beq.n	8000df2 <ExcBusNoAddr>
    LDR  R1, =OS_NVIC_BFAR
 8000de4:	494b      	ldr	r1, [pc, #300]	; (8000f14 <HandleEntry+0x16>)
    LDR  R1, [R1]
 8000de6:	6809      	ldr	r1, [r1, #0]
    MOV  R12, #OS_EXC_FLAG_FAULTADDR_VALID
 8000de8:	f44f 3c80 	mov.w	ip, #65536	; 0x10000
    AND  R0, #0x1F00
 8000dec:	f400 50f8 	and.w	r0, r0, #7936	; 0x1f00

    B    OsExcCommonBMU
 8000df0:	e01b      	b.n	8000e2a <OsExcCommonBMU>

08000df2 <ExcBusNoAddr>:

    .type ExcBusNoAddr, %function
ExcBusNoAddr:
    .fnstart
    .cantunwind
    MOV  R12,#0
 8000df2:	f04f 0c00 	mov.w	ip, #0
    B    OsExcCommonBMU
 8000df6:	e018      	b.n	8000e2a <OsExcCommonBMU>

08000df8 <OsExcMemFault>:
    .type OsExcMemFault, %function
    .global OsExcMemFault
OsExcMemFault:
    .fnstart
    .cantunwind
    LDR  R0, =OS_NVIC_FSR
 8000df8:	4845      	ldr	r0, [pc, #276]	; (8000f10 <HandleEntry+0x12>)
    LDR  R0, [R0]
 8000dfa:	6800      	ldr	r0, [r0, #0]

    TST  R0, #0x80 /* MMARVALID */
 8000dfc:	f010 0f80 	tst.w	r0, #128	; 0x80
    BEQ  ExcMemNoAddr
 8000e00:	d006      	beq.n	8000e10 <ExcMemNoAddr>
    LDR  R1, =OS_NVIC_MMAR
 8000e02:	4945      	ldr	r1, [pc, #276]	; (8000f18 <HandleEntry+0x1a>)
    LDR  R1, [R1]
 8000e04:	6809      	ldr	r1, [r1, #0]
    MOV  R12, #OS_EXC_FLAG_FAULTADDR_VALID
 8000e06:	f44f 3c80 	mov.w	ip, #65536	; 0x10000
    AND  R0, #0x1B
 8000e0a:	f000 001b 	and.w	r0, r0, #27

    B    OsExcCommonBMU
 8000e0e:	e00c      	b.n	8000e2a <OsExcCommonBMU>

08000e10 <ExcMemNoAddr>:

    .type ExcMemNoAddr, %function
ExcMemNoAddr:
    .fnstart
    .cantunwind
    MOV  R12,#0
 8000e10:	f04f 0c00 	mov.w	ip, #0
    B    OsExcCommonBMU
 8000e14:	e009      	b.n	8000e2a <OsExcCommonBMU>

08000e16 <OsExcUsageFault>:
    .fnend

    .type OsExcUsageFault, %function
    .global OsExcUsageFault
OsExcUsageFault:
    LDR  R0, =OS_NVIC_FSR
 8000e16:	483e      	ldr	r0, [pc, #248]	; (8000f10 <HandleEntry+0x12>)
    LDR  R0, [R0]
 8000e18:	6800      	ldr	r0, [r0, #0]

    LDR  R1, =#0x030F
 8000e1a:	f240 310f 	movw	r1, #783	; 0x30f
    LSL  R1, #16
 8000e1e:	ea4f 4101 	mov.w	r1, r1, lsl #16
    AND  R0, R1
 8000e22:	ea00 0001 	and.w	r0, r0, r1
    MOV  R12, #0
 8000e26:	f04f 0c00 	mov.w	ip, #0

08000e2a <OsExcCommonBMU>:

OsExcCommonBMU:
    CLZ  R0, R0
 8000e2a:	fab0 f080 	clz	r0, r0
    LDR  R3, =g_excTbl
 8000e2e:	4b3b      	ldr	r3, [pc, #236]	; (8000f1c <HandleEntry+0x1e>)
    ADD  R3, R3, R0
 8000e30:	4403      	add	r3, r0
    LDRB R0, [R3]
 8000e32:	7818      	ldrb	r0, [r3, #0]
    ORR  R0, R0, R12
 8000e34:	ea40 000c 	orr.w	r0, r0, ip

08000e38 <OsExcDispatch>:

/* R0 -- EXCCAUSE(bit 16 is 1 if EXCADDR valid),  R1 -- EXCADDR */
OsExcDispatch:
    LDR   R2, =OS_NVIC_ACT_BASE
 8000e38:	4a39      	ldr	r2, [pc, #228]	; (8000f20 <HandleEntry+0x22>)
    MOV   R12, #8 /* R12 is hwi check loop counter */
 8000e3a:	f04f 0c08 	mov.w	ip, #8

08000e3e <HwiActiveCheck>:

HwiActiveCheck:
    LDR   R3, [R2] /* R3 store active hwi register when exc */
 8000e3e:	6813      	ldr	r3, [r2, #0]
    CMP   R3, #0
 8000e40:	2b00      	cmp	r3, #0
    BEQ   HwiActiveCheckNext
 8000e42:	d01e      	beq.n	8000e82 <HwiActiveCheckNext>

    /* exc occurred in IRQ */
    ORR   R0, #OS_EXC_FLAG_IN_HWI
 8000e44:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
    RBIT  R2, R3
 8000e48:	fa93 f2a3 	rbit	r2, r3
    CLZ   R2, R2
 8000e4c:	fab2 f282 	clz	r2, r2
    AND   R12, #1
 8000e50:	f00c 0c01 	and.w	ip, ip, #1
    ADD   R2, R2, R12, LSL #5 /* calculate R2 (hwi number) as pid, thrid parameter */
 8000e54:	eb02 124c 	add.w	r2, r2, ip, lsl #5

08000e58 <ExcInMSP>:

ExcInMSP:
    CMP   LR, #0xFFFFFFED
 8000e58:	f11e 0f13 	cmn.w	lr, #19
    BNE   NoFloatInMsp
 8000e5c:	d108      	bne.n	8000e70 <NoFloatInMsp>
    ADD   R3, R13, #104
 8000e5e:	ab1a      	add	r3, sp, #104	; 0x68
    PUSH  {R3}
 8000e60:	b408      	push	{r3}
    MRS   R12, PRIMASK /* store message-->exc: disable int */
 8000e62:	f3ef 8c10 	mrs	ip, PRIMASK
    PUSH  {R4-R12} /* store message-->exc: {R4-R12} */
 8000e66:	e92d 1ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    VPUSH {D8-D15}
 8000e6a:	ed2d 8b10 	vpush	{d8-d15}
    B     HandleEntry
 8000e6e:	e046      	b.n	8000efe <HandleEntry>

08000e70 <NoFloatInMsp>:

NoFloatInMsp:
    ADD   R3, R13, #32
 8000e70:	ab08      	add	r3, sp, #32
    PUSH  {R3} /* save IRQ SP, store message-->exc: MSP(R13) */
 8000e72:	b408      	push	{r3}

    MRS   R12, PRIMASK /* store message-->exc: disable int? */
 8000e74:	f3ef 8c10 	mrs	ip, PRIMASK
    PUSH  {R4-R12} /* store message-->exc: {R4-R12} */
 8000e78:	e92d 1ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    ORR   R0, R0, #OS_EXC_FLAG_NO_FLOAT
 8000e7c:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000
    B     HandleEntry
 8000e80:	e03d      	b.n	8000efe <HandleEntry>

08000e82 <HwiActiveCheckNext>:

HwiActiveCheckNext:
    ADD   R2, #4 /* next NVIC ACT ADDR */
 8000e82:	f102 0204 	add.w	r2, r2, #4
    SUBS  R12, #1
 8000e86:	f1bc 0c01 	subs.w	ip, ip, #1
    BNE   HwiActiveCheck
 8000e8a:	d1d8      	bne.n	8000e3e <HwiActiveCheck>

    /* NMI interrupt excption */
    LDR   R2, =OS_NVIC_SHCSRS
 8000e8c:	4a25      	ldr	r2, [pc, #148]	; (8000f24 <HandleEntry+0x26>)
    LDRH  R2,[R2]
 8000e8e:	8812      	ldrh	r2, [r2, #0]
    LDR   R3,=OS_NVIC_SHCSR_MASK
 8000e90:	f44f 6340 	mov.w	r3, #3072	; 0xc00
    AND   R2, R2,R3
 8000e94:	ea02 0203 	and.w	r2, r2, r3
    CMP   R2,#0
 8000e98:	2a00      	cmp	r2, #0
    BNE   ExcInMSP
 8000e9a:	d1dd      	bne.n	8000e58 <ExcInMSP>

    /* exc occurred in Task or Init or exc reserved for register info from task stack */
    LDR   R2, =g_taskScheduled
 8000e9c:	4a22      	ldr	r2, [pc, #136]	; (8000f28 <HandleEntry+0x2a>)
    LDR   R2, [R2]
 8000e9e:	6812      	ldr	r2, [r2, #0]
    TST   R2, #1 /*os scheduled */
 8000ea0:	f012 0f01 	tst.w	r2, #1
    BEQ   ExcInMSP /* if exc occurred in Init then branch */
 8000ea4:	d0d8      	beq.n	8000e58 <ExcInMSP>


    CMP   LR, #0xFFFFFFED /*auto push floating registers */
 8000ea6:	f11e 0f13 	cmn.w	lr, #19
    BNE   NoFloatInPsp
 8000eaa:	d116      	bne.n	8000eda <NoFloatInPsp>

    /* exc occurred in Task */
    MOV   R2,  R13
 8000eac:	466a      	mov	r2, sp
    SUB   R13, #96 /* add 8 Bytes reg(for STMFD) */
 8000eae:	b098      	sub	sp, #96	; 0x60

    MRS   R3,  PSP
 8000eb0:	f3ef 8309 	mrs	r3, PSP
    ADD   R12, R3, #104
 8000eb4:	f103 0c68 	add.w	ip, r3, #104	; 0x68
    PUSH  {R12} /* save task SP */
 8000eb8:	f84d cd04 	str.w	ip, [sp, #-4]!

    MRS   R12, PRIMASK
 8000ebc:	f3ef 8c10 	mrs	ip, PRIMASK
    PUSH  {R4-R12}
 8000ec0:	e92d 1ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    VPUSH {D8-D15}
 8000ec4:	ed2d 8b10 	vpush	{d8-d15}

    /* copy auto saved task register */
    LDMFD   R3!, {R4-R11} /* R4-R11 store PSP reg(auto push when exc in task) */
 8000ec8:	e8b3 0ff0 	ldmia.w	r3!, {r4, r5, r6, r7, r8, r9, sl, fp}
    VLDMIA  R3!, {D8-D15}
 8000ecc:	ecb3 8b10 	vldmia	r3!, {d8-d15}
    VSTMDB  R2!, {D8-D15}
 8000ed0:	ed22 8b10 	vstmdb	r2!, {d8-d15}
    STMFD   R2!, {R4-R11}
 8000ed4:	e922 0ff0 	stmdb	r2!, {r4, r5, r6, r7, r8, r9, sl, fp}
    B       HandleEntry
 8000ed8:	e011      	b.n	8000efe <HandleEntry>

08000eda <NoFloatInPsp>:

NoFloatInPsp:
    MOV   R2,  R13 /*no auto push floating registers */
 8000eda:	466a      	mov	r2, sp
    SUB   R13, #32 /* add 8 Bytes reg(for STMFD) */
 8000edc:	b088      	sub	sp, #32

    MRS   R3,  PSP
 8000ede:	f3ef 8309 	mrs	r3, PSP
    ADD   R12, R3, #32
 8000ee2:	f103 0c20 	add.w	ip, r3, #32
    PUSH  {R12} /* save task SP */
 8000ee6:	f84d cd04 	str.w	ip, [sp, #-4]!

    MRS   R12, PRIMASK
 8000eea:	f3ef 8c10 	mrs	ip, PRIMASK
    PUSH  {R4-R12}
 8000eee:	e92d 1ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    LDMFD R3, {R4-R11} /* R4-R11 store PSP reg(auto push when exc in task) */
 8000ef2:	e893 0ff0 	ldmia.w	r3, {r4, r5, r6, r7, r8, r9, sl, fp}
    STMFD R2!, {R4-R11}
 8000ef6:	e922 0ff0 	stmdb	r2!, {r4, r5, r6, r7, r8, r9, sl, fp}
    ORR   R0, R0, #OS_EXC_FLAG_NO_FLOAT
 8000efa:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000

08000efe <HandleEntry>:

HandleEntry:
    MOV   R3, R13 /* R13:the 4th param */
 8000efe:	466b      	mov	r3, sp
    CPSID I
 8000f00:	b672      	cpsid	i
    CPSID F
 8000f02:	b671      	cpsid	f
    B     OsExcHandleEntry
 8000f04:	f014 bd6c 	b.w	80159e0 <OsExcHandleEntry>

    NOP
 8000f08:	bf00      	nop
 8000f0a:	0000      	.short	0x0000
    LDR  R2, =OS_NVIC_HFSR
 8000f0c:	e000ed2c 	.word	0xe000ed2c
    LDR  R2, =OS_NVIC_FSR
 8000f10:	e000ed28 	.word	0xe000ed28
    LDR  R1, =OS_NVIC_BFAR
 8000f14:	e000ed38 	.word	0xe000ed38
    LDR  R1, =OS_NVIC_MMAR
 8000f18:	e000ed34 	.word	0xe000ed34
    LDR  R3, =g_excTbl
 8000f1c:	2000050c 	.word	0x2000050c
    LDR   R2, =OS_NVIC_ACT_BASE
 8000f20:	e000e300 	.word	0xe000e300
    LDR   R2, =OS_NVIC_SHCSRS
 8000f24:	e000ed24 	.word	0xe000ed24
    LDR   R2, =g_taskScheduled
 8000f28:	200036dc 	.word	0x200036dc

08000f2c <__gedf2>:
 8000f2c:	f04f 3cff 	mov.w	ip, #4294967295
 8000f30:	e006      	b.n	8000f40 <__cmpdf2+0x4>
 8000f32:	bf00      	nop

08000f34 <__ledf2>:
 8000f34:	f04f 0c01 	mov.w	ip, #1
 8000f38:	e002      	b.n	8000f40 <__cmpdf2+0x4>
 8000f3a:	bf00      	nop

08000f3c <__cmpdf2>:
 8000f3c:	f04f 0c01 	mov.w	ip, #1
 8000f40:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000f44:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000f48:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000f4c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000f50:	bf18      	it	ne
 8000f52:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000f56:	d01b      	beq.n	8000f90 <__cmpdf2+0x54>
 8000f58:	b001      	add	sp, #4
 8000f5a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000f5e:	bf0c      	ite	eq
 8000f60:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000f64:	ea91 0f03 	teqne	r1, r3
 8000f68:	bf02      	ittt	eq
 8000f6a:	ea90 0f02 	teqeq	r0, r2
 8000f6e:	2000      	moveq	r0, #0
 8000f70:	4770      	bxeq	lr
 8000f72:	f110 0f00 	cmn.w	r0, #0
 8000f76:	ea91 0f03 	teq	r1, r3
 8000f7a:	bf58      	it	pl
 8000f7c:	4299      	cmppl	r1, r3
 8000f7e:	bf08      	it	eq
 8000f80:	4290      	cmpeq	r0, r2
 8000f82:	bf2c      	ite	cs
 8000f84:	17d8      	asrcs	r0, r3, #31
 8000f86:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000f8a:	f040 0001 	orr.w	r0, r0, #1
 8000f8e:	4770      	bx	lr
 8000f90:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000f94:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000f98:	d102      	bne.n	8000fa0 <__cmpdf2+0x64>
 8000f9a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000f9e:	d107      	bne.n	8000fb0 <__cmpdf2+0x74>
 8000fa0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000fa4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000fa8:	d1d6      	bne.n	8000f58 <__cmpdf2+0x1c>
 8000faa:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000fae:	d0d3      	beq.n	8000f58 <__cmpdf2+0x1c>
 8000fb0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000fb4:	4770      	bx	lr
 8000fb6:	bf00      	nop

08000fb8 <__aeabi_cdrcmple>:
 8000fb8:	4684      	mov	ip, r0
 8000fba:	4610      	mov	r0, r2
 8000fbc:	4662      	mov	r2, ip
 8000fbe:	468c      	mov	ip, r1
 8000fc0:	4619      	mov	r1, r3
 8000fc2:	4663      	mov	r3, ip
 8000fc4:	e000      	b.n	8000fc8 <__aeabi_cdcmpeq>
 8000fc6:	bf00      	nop

08000fc8 <__aeabi_cdcmpeq>:
 8000fc8:	b501      	push	{r0, lr}
 8000fca:	f7ff ffb7 	bl	8000f3c <__cmpdf2>
 8000fce:	2800      	cmp	r0, #0
 8000fd0:	bf48      	it	mi
 8000fd2:	f110 0f00 	cmnmi.w	r0, #0
 8000fd6:	bd01      	pop	{r0, pc}

08000fd8 <__aeabi_dcmpeq>:
 8000fd8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000fdc:	f7ff fff4 	bl	8000fc8 <__aeabi_cdcmpeq>
 8000fe0:	bf0c      	ite	eq
 8000fe2:	2001      	moveq	r0, #1
 8000fe4:	2000      	movne	r0, #0
 8000fe6:	f85d fb08 	ldr.w	pc, [sp], #8
 8000fea:	bf00      	nop

08000fec <__aeabi_dcmplt>:
 8000fec:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ff0:	f7ff ffea 	bl	8000fc8 <__aeabi_cdcmpeq>
 8000ff4:	bf34      	ite	cc
 8000ff6:	2001      	movcc	r0, #1
 8000ff8:	2000      	movcs	r0, #0
 8000ffa:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ffe:	bf00      	nop

08001000 <__aeabi_dcmple>:
 8001000:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001004:	f7ff ffe0 	bl	8000fc8 <__aeabi_cdcmpeq>
 8001008:	bf94      	ite	ls
 800100a:	2001      	movls	r0, #1
 800100c:	2000      	movhi	r0, #0
 800100e:	f85d fb08 	ldr.w	pc, [sp], #8
 8001012:	bf00      	nop

08001014 <__aeabi_dcmpge>:
 8001014:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001018:	f7ff ffce 	bl	8000fb8 <__aeabi_cdrcmple>
 800101c:	bf94      	ite	ls
 800101e:	2001      	movls	r0, #1
 8001020:	2000      	movhi	r0, #0
 8001022:	f85d fb08 	ldr.w	pc, [sp], #8
 8001026:	bf00      	nop

08001028 <__aeabi_dcmpgt>:
 8001028:	f84d ed08 	str.w	lr, [sp, #-8]!
 800102c:	f7ff ffc4 	bl	8000fb8 <__aeabi_cdrcmple>
 8001030:	bf34      	ite	cc
 8001032:	2001      	movcc	r0, #1
 8001034:	2000      	movcs	r0, #0
 8001036:	f85d fb08 	ldr.w	pc, [sp], #8
 800103a:	bf00      	nop

0800103c <__aeabi_d2iz>:
 800103c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8001040:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8001044:	d215      	bcs.n	8001072 <__aeabi_d2iz+0x36>
 8001046:	d511      	bpl.n	800106c <__aeabi_d2iz+0x30>
 8001048:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800104c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8001050:	d912      	bls.n	8001078 <__aeabi_d2iz+0x3c>
 8001052:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8001056:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800105a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800105e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8001062:	fa23 f002 	lsr.w	r0, r3, r2
 8001066:	bf18      	it	ne
 8001068:	4240      	negne	r0, r0
 800106a:	4770      	bx	lr
 800106c:	f04f 0000 	mov.w	r0, #0
 8001070:	4770      	bx	lr
 8001072:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8001076:	d105      	bne.n	8001084 <__aeabi_d2iz+0x48>
 8001078:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800107c:	bf08      	it	eq
 800107e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8001082:	4770      	bx	lr
 8001084:	f04f 0000 	mov.w	r0, #0
 8001088:	4770      	bx	lr
 800108a:	bf00      	nop

0800108c <__aeabi_d2uiz>:
 800108c:	004a      	lsls	r2, r1, #1
 800108e:	d211      	bcs.n	80010b4 <__aeabi_d2uiz+0x28>
 8001090:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8001094:	d211      	bcs.n	80010ba <__aeabi_d2uiz+0x2e>
 8001096:	d50d      	bpl.n	80010b4 <__aeabi_d2uiz+0x28>
 8001098:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800109c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80010a0:	d40e      	bmi.n	80010c0 <__aeabi_d2uiz+0x34>
 80010a2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80010a6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80010aa:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80010ae:	fa23 f002 	lsr.w	r0, r3, r2
 80010b2:	4770      	bx	lr
 80010b4:	f04f 0000 	mov.w	r0, #0
 80010b8:	4770      	bx	lr
 80010ba:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80010be:	d102      	bne.n	80010c6 <__aeabi_d2uiz+0x3a>
 80010c0:	f04f 30ff 	mov.w	r0, #4294967295
 80010c4:	4770      	bx	lr
 80010c6:	f04f 0000 	mov.w	r0, #0
 80010ca:	4770      	bx	lr

080010cc <__aeabi_ldivmod>:
 80010cc:	b97b      	cbnz	r3, 80010ee <__aeabi_ldivmod+0x22>
 80010ce:	b972      	cbnz	r2, 80010ee <__aeabi_ldivmod+0x22>
 80010d0:	2900      	cmp	r1, #0
 80010d2:	bfbe      	ittt	lt
 80010d4:	2000      	movlt	r0, #0
 80010d6:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 80010da:	e006      	blt.n	80010ea <__aeabi_ldivmod+0x1e>
 80010dc:	bf08      	it	eq
 80010de:	2800      	cmpeq	r0, #0
 80010e0:	bf1c      	itt	ne
 80010e2:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 80010e6:	f04f 30ff 	movne.w	r0, #4294967295
 80010ea:	f7ff bdcd 	b.w	8000c88 <__aeabi_idiv0>
 80010ee:	f1ad 0c08 	sub.w	ip, sp, #8
 80010f2:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80010f6:	2900      	cmp	r1, #0
 80010f8:	db09      	blt.n	800110e <__aeabi_ldivmod+0x42>
 80010fa:	2b00      	cmp	r3, #0
 80010fc:	db1a      	blt.n	8001134 <__aeabi_ldivmod+0x68>
 80010fe:	f7ff fc61 	bl	80009c4 <__udivmoddi4>
 8001102:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001106:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800110a:	b004      	add	sp, #16
 800110c:	4770      	bx	lr
 800110e:	4240      	negs	r0, r0
 8001110:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8001114:	2b00      	cmp	r3, #0
 8001116:	db1b      	blt.n	8001150 <__aeabi_ldivmod+0x84>
 8001118:	f7ff fc54 	bl	80009c4 <__udivmoddi4>
 800111c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001120:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8001124:	b004      	add	sp, #16
 8001126:	4240      	negs	r0, r0
 8001128:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800112c:	4252      	negs	r2, r2
 800112e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8001132:	4770      	bx	lr
 8001134:	4252      	negs	r2, r2
 8001136:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800113a:	f7ff fc43 	bl	80009c4 <__udivmoddi4>
 800113e:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001142:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8001146:	b004      	add	sp, #16
 8001148:	4240      	negs	r0, r0
 800114a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800114e:	4770      	bx	lr
 8001150:	4252      	negs	r2, r2
 8001152:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8001156:	f7ff fc35 	bl	80009c4 <__udivmoddi4>
 800115a:	f8dd e004 	ldr.w	lr, [sp, #4]
 800115e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8001162:	b004      	add	sp, #16
 8001164:	4252      	negs	r2, r2
 8001166:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800116a:	4770      	bx	lr

0800116c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler: 
  cpsid i 
 800116c:	b672      	cpsid	i
  ldr   sp, =_estack      /* set stack pointer */
 800116e:	f8df d048 	ldr.w	sp, [pc, #72]	; 80011b8 <LoopFillZerobss+0x10>

  movs  r1, #0
 8001172:	2100      	movs	r1, #0
  b  LoopCopyVectorInit
 8001174:	e003      	b.n	800117e <LoopCopyVectorInit>

08001176 <CopyVectorInit>:

CopyVectorInit:
  ldr   r3, =_si_liteos_vector_data
 8001176:	4b11      	ldr	r3, [pc, #68]	; (80011bc <LoopFillZerobss+0x14>)
  ldr   r3, [r3, r1]
 8001178:	585b      	ldr	r3, [r3, r1]
  str   r3, [r0, r1]
 800117a:	5043      	str	r3, [r0, r1]
  adds   r1, r1, #4
 800117c:	3104      	adds	r1, #4

0800117e <LoopCopyVectorInit>:

LoopCopyVectorInit:
  ldr   r0, =_s_liteos_vector
 800117e:	4810      	ldr	r0, [pc, #64]	; (80011c0 <LoopFillZerobss+0x18>)
  ldr   r3, =_e_liteos_vector
 8001180:	4b10      	ldr	r3, [pc, #64]	; (80011c4 <LoopFillZerobss+0x1c>)
  adds   r2, r0, r1
 8001182:	1842      	adds	r2, r0, r1
  cmp   r2, r3
 8001184:	429a      	cmp	r2, r3
  bcc   CopyVectorInit
 8001186:	d3f6      	bcc.n	8001176 <CopyVectorInit>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8001188:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800118a:	e003      	b.n	8001194 <LoopCopyDataInit>

0800118c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800118c:	4b0e      	ldr	r3, [pc, #56]	; (80011c8 <LoopFillZerobss+0x20>)
  ldr  r3, [r3, r1]
 800118e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8001190:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8001192:	3104      	adds	r1, #4

08001194 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8001194:	480d      	ldr	r0, [pc, #52]	; (80011cc <LoopFillZerobss+0x24>)
  ldr  r3, =_edata
 8001196:	4b0e      	ldr	r3, [pc, #56]	; (80011d0 <LoopFillZerobss+0x28>)
  adds  r2, r0, r1
 8001198:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800119a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800119c:	d3f6      	bcc.n	800118c <CopyDataInit>
  ldr  r2, =_sbss
 800119e:	4a0d      	ldr	r2, [pc, #52]	; (80011d4 <LoopFillZerobss+0x2c>)
  b  LoopFillZerobss
 80011a0:	e002      	b.n	80011a8 <LoopFillZerobss>

080011a2 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80011a2:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80011a4:	f842 3b04 	str.w	r3, [r2], #4

080011a8 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80011a8:	4b0b      	ldr	r3, [pc, #44]	; (80011d8 <LoopFillZerobss+0x30>)
  cmp  r2, r3
 80011aa:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80011ac:	d3f9      	bcc.n	80011a2 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 80011ae:	f000 f829 	bl	8001204 <SystemInit>
/* Call static constructors */
/*    bl __libc_init_array */
/* Call the application's entry point.*/
  bl  main
 80011b2:	f000 f89b 	bl	80012ec <main>
  bx  lr    
 80011b6:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 80011b8:	20080000 	.word	0x20080000
  ldr   r3, =_si_liteos_vector_data
 80011bc:	080243ac 	.word	0x080243ac
  ldr   r0, =_s_liteos_vector
 80011c0:	20000000 	.word	0x20000000
  ldr   r3, =_e_liteos_vector
 80011c4:	20000400 	.word	0x20000400
  ldr  r3, =_sidata
 80011c8:	080247ac 	.word	0x080247ac
  ldr  r0, =_sdata
 80011cc:	20000400 	.word	0x20000400
  ldr  r3, =_edata
 80011d0:	20000724 	.word	0x20000724
  ldr  r2, =_sbss
 80011d4:	20000728 	.word	0x20000728
  ldr  r3, = _ebss
 80011d8:	200037ec 	.word	0x200037ec

080011dc <IrqEntryV7M_Handler>:
    .section  .text.IrqEntryV7M_Handler
  .weak  IrqEntryV7M_Handler
  .type  IrqEntryV7M_Handler, %function
IrqEntryV7M_Handler: 

   push  {r0, r1}                      /* R0,R1 */
 80011dc:	b403      	push	{r0, r1}
   and.w  r0, lr, #4                   /* MSP/PSP */
 80011de:	f00e 0004 	and.w	r0, lr, #4
   cmp  r0, #0                         /* EXC_RETUR 2 */
 80011e2:	2800      	cmp	r0, #0
                                       /* 0=MSP*/ 
                                       /* 1=PSP */
   beq SAVE_MSP
 80011e4:	d002      	beq.n	80011ec <SAVE_MSP>

080011e6 <SAVE_PSP>:

SAVE_PSP:     
   mrs  r0, psp                       /* PSPR0 */
 80011e6:	f3ef 8009 	mrs	r0, PSP
   b SAVE_END 
 80011ea:	e001      	b.n	80011f0 <SAVE_END>

080011ec <SAVE_MSP>:

SAVE_MSP:                             /* ISR MSP */
   mrs  r0, msp                       /* MSPR0 */
 80011ec:	f3ef 8008 	mrs	r0, MSP

080011f0 <SAVE_END>:

SAVE_END:  
   ldr r0, [r0,#24]                   /* R0+4*6 => PC */
 80011f0:	6980      	ldr	r0, [r0, #24]
   ldr  r1, =g_interrupt_pc           /* g_interrupt_pc R1 */
 80011f2:	4902      	ldr	r1, [pc, #8]	; (80011fc <SAVE_END+0xc>)
   str  r0, [r1]                      /* PC g_interrupt_pc */
 80011f4:	6008      	str	r0, [r1, #0]
   pop  {r0,r1}                       /* RO,R1 */
 80011f6:	bc03      	pop	{r0, r1}
  
   b IrqEntryV7M
 80011f8:	f00e bb08 	b.w	800f80c <IrqEntryV7M>
   ldr  r1, =g_interrupt_pc           /* g_interrupt_pc R1 */
 80011fc:	20003764 	.word	0x20003764

08001200 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001200:	e7fe      	b.n	8001200 <ADC_IRQHandler>
	...

08001204 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8001204:	b480      	push	{r7}
 8001206:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001208:	4b15      	ldr	r3, [pc, #84]	; (8001260 <SystemInit+0x5c>)
 800120a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800120e:	4a14      	ldr	r2, [pc, #80]	; (8001260 <SystemInit+0x5c>)
 8001210:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001214:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001218:	4b12      	ldr	r3, [pc, #72]	; (8001264 <SystemInit+0x60>)
 800121a:	681b      	ldr	r3, [r3, #0]
 800121c:	4a11      	ldr	r2, [pc, #68]	; (8001264 <SystemInit+0x60>)
 800121e:	f043 0301 	orr.w	r3, r3, #1
 8001222:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8001224:	4b0f      	ldr	r3, [pc, #60]	; (8001264 <SystemInit+0x60>)
 8001226:	2200      	movs	r2, #0
 8001228:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800122a:	4b0e      	ldr	r3, [pc, #56]	; (8001264 <SystemInit+0x60>)
 800122c:	681a      	ldr	r2, [r3, #0]
 800122e:	490d      	ldr	r1, [pc, #52]	; (8001264 <SystemInit+0x60>)
 8001230:	4b0d      	ldr	r3, [pc, #52]	; (8001268 <SystemInit+0x64>)
 8001232:	4013      	ands	r3, r2
 8001234:	600b      	str	r3, [r1, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8001236:	4b0b      	ldr	r3, [pc, #44]	; (8001264 <SystemInit+0x60>)
 8001238:	4a0c      	ldr	r2, [pc, #48]	; (800126c <SystemInit+0x68>)
 800123a:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800123c:	4b09      	ldr	r3, [pc, #36]	; (8001264 <SystemInit+0x60>)
 800123e:	681b      	ldr	r3, [r3, #0]
 8001240:	4a08      	ldr	r2, [pc, #32]	; (8001264 <SystemInit+0x60>)
 8001242:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001246:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8001248:	4b06      	ldr	r3, [pc, #24]	; (8001264 <SystemInit+0x60>)
 800124a:	2200      	movs	r2, #0
 800124c:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800124e:	4b04      	ldr	r3, [pc, #16]	; (8001260 <SystemInit+0x5c>)
 8001250:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001254:	609a      	str	r2, [r3, #8]
#endif
}
 8001256:	bf00      	nop
 8001258:	46bd      	mov	sp, r7
 800125a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800125e:	4770      	bx	lr
 8001260:	e000ed00 	.word	0xe000ed00
 8001264:	40023800 	.word	0x40023800
 8001268:	fef6ffff 	.word	0xfef6ffff
 800126c:	24003010 	.word	0x24003010

08001270 <ArchCurrTaskSet>:
{
    return g_runTask;
}

STATIC INLINE VOID ArchCurrTaskSet(VOID *val)
{
 8001270:	b480      	push	{r7}
 8001272:	b083      	sub	sp, #12
 8001274:	af00      	add	r7, sp, #0
 8001276:	6078      	str	r0, [r7, #4]
    g_runTask = val;
 8001278:	4a04      	ldr	r2, [pc, #16]	; (800128c <ArchCurrTaskSet+0x1c>)
 800127a:	687b      	ldr	r3, [r7, #4]
 800127c:	6013      	str	r3, [r2, #0]
}
 800127e:	bf00      	nop
 8001280:	370c      	adds	r7, #12
 8001282:	46bd      	mov	sp, r7
 8001284:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001288:	4770      	bx	lr
 800128a:	bf00      	nop
 800128c:	200033bc 	.word	0x200033bc

08001290 <OsCurrTaskSet>:
{
    return (LosTaskCB *)ArchCurrTaskGet();
}

STATIC INLINE VOID OsCurrTaskSet(LosTaskCB *task)
{
 8001290:	b580      	push	{r7, lr}
 8001292:	b082      	sub	sp, #8
 8001294:	af00      	add	r7, sp, #0
 8001296:	6078      	str	r0, [r7, #4]
    ArchCurrTaskSet(task);
 8001298:	6878      	ldr	r0, [r7, #4]
 800129a:	f7ff ffe9 	bl	8001270 <ArchCurrTaskSet>
}
 800129e:	bf00      	nop
 80012a0:	3708      	adds	r7, #8
 80012a2:	46bd      	mov	sp, r7
 80012a4:	bd80      	pop	{r7, pc}
	...

080012a8 <BoardConfig>:
/* USER CODE BEGIN 0 */
// uint32_t pbuff[(32*1024*1024)/4] __attribute__((at(0xD0000000)));
/* USER CODE END 0 */

VOID BoardConfig(VOID)
{
 80012a8:	b480      	push	{r7}
 80012aa:	af00      	add	r7, sp, #0
    g_sys_mem_addr_end = __LOS_HEAP_ADDR_END__;
 80012ac:	4b04      	ldr	r3, [pc, #16]	; (80012c0 <BoardConfig+0x18>)
 80012ae:	681b      	ldr	r3, [r3, #0]
 80012b0:	4a04      	ldr	r2, [pc, #16]	; (80012c4 <BoardConfig+0x1c>)
 80012b2:	6013      	str	r3, [r2, #0]
}
 80012b4:	bf00      	nop
 80012b6:	46bd      	mov	sp, r7
 80012b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80012bc:	4770      	bx	lr
 80012be:	bf00      	nop
 80012c0:	080001f4 	.word	0x080001f4
 80012c4:	20000478 	.word	0x20000478

080012c8 <HardwareInit>:

INT32 HardwareInit(VOID)
{
 80012c8:	b580      	push	{r7, lr}
 80012ca:	af00      	add	r7, sp, #0
    (VOID)HAL_Init();
 80012cc:	f00a fa74 	bl	800b7b8 <HAL_Init>
    SystemClock_Config();
 80012d0:	f000 fd66 	bl	8001da0 <SystemClock_Config>
    TimInit();
 80012d4:	f000 fb1e 	bl	8001914 <TimInit>
    MX_GPIO_Init();
 80012d8:	f000 f836 	bl	8001348 <MX_GPIO_Init>
    MX_USART1_UART_Init();
 80012dc:	f000 fbc4 	bl	8001a68 <MX_USART1_UART_Init>
    MX_FMC_Init();   
 80012e0:	f000 f91e 	bl	8001520 <MX_FMC_Init>
    return 0;
 80012e4:	2300      	movs	r3, #0
}
 80012e6:	4618      	mov	r0, r3
 80012e8:	bd80      	pop	{r7, pc}
	...

080012ec <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
INT32 main (VOID)
{
 80012ec:	b580      	push	{r7, lr}
 80012ee:	b082      	sub	sp, #8
 80012f0:	af00      	add	r7, sp, #0
#ifdef __GNUC__
    ArchStackGuardInit();
 80012f2:	f014 faaf 	bl	8015854 <ArchStackGuardInit>
#endif
    OsSetMainTask();
 80012f6:	f00a f8a5 	bl	800b444 <OsSetMainTask>
    OsCurrTaskSet(OsGetMainTask());
 80012fa:	f00a f893 	bl	800b424 <OsGetMainTask>
 80012fe:	4603      	mov	r3, r0
 8001300:	4618      	mov	r0, r3
 8001302:	f7ff ffc5 	bl	8001290 <OsCurrTaskSet>

    BoardConfig();
 8001306:	f7ff ffcf 	bl	80012a8 <BoardConfig>
    (VOID)HardwareInit();
 800130a:	f7ff ffdd 	bl	80012c8 <HardwareInit>

    PRINT_RELEASE("\n********Hello Huawei LiteOS********\n"
 800130e:	4b0a      	ldr	r3, [pc, #40]	; (8001338 <main+0x4c>)
 8001310:	4a0a      	ldr	r2, [pc, #40]	; (800133c <main+0x50>)
 8001312:	490b      	ldr	r1, [pc, #44]	; (8001340 <main+0x54>)
 8001314:	480b      	ldr	r0, [pc, #44]	; (8001344 <main+0x58>)
 8001316:	f003 f9d9 	bl	80046cc <dprintf>
                  "\nLiteOS Kernel Version : %s\n"
                  "build date : %s %s\n\n"
                  "**********************************\n",
                  HW_LITEOS_KERNEL_VERSION_STRING, __DATE__, __TIME__);

    UINT32 ret = OsMain();
 800131a:	f00a f99d 	bl	800b658 <OsMain>
 800131e:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 8001320:	687b      	ldr	r3, [r7, #4]
 8001322:	2b00      	cmp	r3, #0
 8001324:	d001      	beq.n	800132a <main+0x3e>
        return LOS_NOK;
 8001326:	2301      	movs	r3, #1
 8001328:	e002      	b.n	8001330 <main+0x44>
    }

    OsStart();
 800132a:	f00a f8e1 	bl	800b4f0 <OsStart>

    return LOS_OK;
 800132e:	2300      	movs	r3, #0
 8001330:	4618      	mov	r0, r3
 8001332:	3708      	adds	r7, #8
 8001334:	46bd      	mov	sp, r7
 8001336:	bd80      	pop	{r7, pc}
 8001338:	0801fda4 	.word	0x0801fda4
 800133c:	0801fdb0 	.word	0x0801fdb0
 8001340:	0801fdbc 	.word	0x0801fdbc
 8001344:	0801fdc4 	.word	0x0801fdc4

08001348 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8001348:	b580      	push	{r7, lr}
 800134a:	b090      	sub	sp, #64	; 0x40
 800134c:	af00      	add	r7, sp, #0
 800134e:	4b69      	ldr	r3, [pc, #420]	; (80014f4 <MX_GPIO_Init+0x1ac>)
 8001350:	681b      	ldr	r3, [r3, #0]
 8001352:	63fb      	str	r3, [r7, #60]	; 0x3c
 8001354:	f04f 0300 	mov.w	r3, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001358:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800135c:	2200      	movs	r2, #0
 800135e:	601a      	str	r2, [r3, #0]
 8001360:	605a      	str	r2, [r3, #4]
 8001362:	609a      	str	r2, [r3, #8]
 8001364:	60da      	str	r2, [r3, #12]
 8001366:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8001368:	4b63      	ldr	r3, [pc, #396]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800136a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800136c:	4a62      	ldr	r2, [pc, #392]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800136e:	f043 0320 	orr.w	r3, r3, #32
 8001372:	6313      	str	r3, [r2, #48]	; 0x30
 8001374:	4b60      	ldr	r3, [pc, #384]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001376:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001378:	f003 0320 	and.w	r3, r3, #32
 800137c:	607b      	str	r3, [r7, #4]
 800137e:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8001380:	4b5d      	ldr	r3, [pc, #372]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001382:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001384:	4a5c      	ldr	r2, [pc, #368]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001386:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800138a:	6313      	str	r3, [r2, #48]	; 0x30
 800138c:	4b5a      	ldr	r3, [pc, #360]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800138e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001390:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8001394:	60bb      	str	r3, [r7, #8]
 8001396:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001398:	4b57      	ldr	r3, [pc, #348]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800139a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800139c:	4a56      	ldr	r2, [pc, #344]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800139e:	f043 0304 	orr.w	r3, r3, #4
 80013a2:	6313      	str	r3, [r2, #48]	; 0x30
 80013a4:	4b54      	ldr	r3, [pc, #336]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013a8:	f003 0304 	and.w	r3, r3, #4
 80013ac:	60fb      	str	r3, [r7, #12]
 80013ae:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80013b0:	4b51      	ldr	r3, [pc, #324]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013b4:	4a50      	ldr	r2, [pc, #320]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013b6:	f043 0301 	orr.w	r3, r3, #1
 80013ba:	6313      	str	r3, [r2, #48]	; 0x30
 80013bc:	4b4e      	ldr	r3, [pc, #312]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013c0:	f003 0301 	and.w	r3, r3, #1
 80013c4:	613b      	str	r3, [r7, #16]
 80013c6:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 80013c8:	4b4b      	ldr	r3, [pc, #300]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013cc:	4a4a      	ldr	r2, [pc, #296]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013ce:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80013d2:	6313      	str	r3, [r2, #48]	; 0x30
 80013d4:	4b48      	ldr	r3, [pc, #288]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013d8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80013dc:	617b      	str	r3, [r7, #20]
 80013de:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80013e0:	4b45      	ldr	r3, [pc, #276]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013e4:	4a44      	ldr	r2, [pc, #272]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013e6:	f043 0310 	orr.w	r3, r3, #16
 80013ea:	6313      	str	r3, [r2, #48]	; 0x30
 80013ec:	4b42      	ldr	r3, [pc, #264]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013f0:	f003 0310 	and.w	r3, r3, #16
 80013f4:	61bb      	str	r3, [r7, #24]
 80013f6:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80013f8:	4b3f      	ldr	r3, [pc, #252]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013fc:	4a3e      	ldr	r2, [pc, #248]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013fe:	f043 0308 	orr.w	r3, r3, #8
 8001402:	6313      	str	r3, [r2, #48]	; 0x30
 8001404:	4b3c      	ldr	r3, [pc, #240]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001406:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001408:	f003 0308 	and.w	r3, r3, #8
 800140c:	61fb      	str	r3, [r7, #28]
 800140e:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001410:	4b39      	ldr	r3, [pc, #228]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001412:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001414:	4a38      	ldr	r2, [pc, #224]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001416:	f043 0302 	orr.w	r3, r3, #2
 800141a:	6313      	str	r3, [r2, #48]	; 0x30
 800141c:	4b36      	ldr	r3, [pc, #216]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800141e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001420:	f003 0302 	and.w	r3, r3, #2
 8001424:	623b      	str	r3, [r7, #32]
 8001426:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOI_CLK_ENABLE();
 8001428:	4b33      	ldr	r3, [pc, #204]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800142a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800142c:	4a32      	ldr	r2, [pc, #200]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800142e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001432:	6313      	str	r3, [r2, #48]	; 0x30
 8001434:	4b30      	ldr	r3, [pc, #192]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001436:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001438:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800143c:	627b      	str	r3, [r7, #36]	; 0x24
 800143e:	6a7b      	ldr	r3, [r7, #36]	; 0x24

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 8001440:	2200      	movs	r2, #0
 8001442:	2110      	movs	r1, #16
 8001444:	482d      	ldr	r0, [pc, #180]	; (80014fc <MX_GPIO_Init+0x1b4>)
 8001446:	f00c fb11 	bl	800da6c <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOH, GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12, GPIO_PIN_RESET);
 800144a:	2200      	movs	r2, #0
 800144c:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
 8001450:	482b      	ldr	r0, [pc, #172]	; (8001500 <MX_GPIO_Init+0x1b8>)
 8001452:	f00c fb0b 	bl	800da6c <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8001456:	2200      	movs	r2, #0
 8001458:	21c0      	movs	r1, #192	; 0xc0
 800145a:	482a      	ldr	r0, [pc, #168]	; (8001504 <MX_GPIO_Init+0x1bc>)
 800145c:	f00c fb06 	bl	800da6c <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOI, GPIO_PIN_7, GPIO_PIN_RESET);
 8001460:	2200      	movs	r2, #0
 8001462:	2180      	movs	r1, #128	; 0x80
 8001464:	4828      	ldr	r0, [pc, #160]	; (8001508 <MX_GPIO_Init+0x1c0>)
 8001466:	f00c fb01 	bl	800da6c <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PA4 */
  GPIO_InitStruct.Pin = GPIO_PIN_4;
 800146a:	2310      	movs	r3, #16
 800146c:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800146e:	2301      	movs	r3, #1
 8001470:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001472:	2300      	movs	r3, #0
 8001474:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001476:	2300      	movs	r3, #0
 8001478:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800147a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800147e:	4619      	mov	r1, r3
 8001480:	481e      	ldr	r0, [pc, #120]	; (80014fc <MX_GPIO_Init+0x1b4>)
 8001482:	f00c f947 	bl	800d714 <HAL_GPIO_Init>

  /*Configure GPIO pins : PH10 PH11 PH12 */
  GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
 8001486:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800148a:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800148c:	2301      	movs	r3, #1
 800148e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001490:	2300      	movs	r3, #0
 8001492:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001494:	2300      	movs	r3, #0
 8001496:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8001498:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800149c:	4619      	mov	r1, r3
 800149e:	4818      	ldr	r0, [pc, #96]	; (8001500 <MX_GPIO_Init+0x1b8>)
 80014a0:	f00c f938 	bl	800d714 <HAL_GPIO_Init>

  /*Configure GPIO pins : PB6 PB7 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 80014a4:	23c0      	movs	r3, #192	; 0xc0
 80014a6:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 80014a8:	2311      	movs	r3, #17
 80014aa:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80014ac:	2300      	movs	r3, #0
 80014ae:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80014b0:	2300      	movs	r3, #0
 80014b2:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80014b4:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80014b8:	4619      	mov	r1, r3
 80014ba:	4812      	ldr	r0, [pc, #72]	; (8001504 <MX_GPIO_Init+0x1bc>)
 80014bc:	f00c f92a 	bl	800d714 <HAL_GPIO_Init>

  /*Configure GPIO pin : PI7 */
  GPIO_InitStruct.Pin = GPIO_PIN_7;
 80014c0:	2380      	movs	r3, #128	; 0x80
 80014c2:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80014c4:	2301      	movs	r3, #1
 80014c6:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80014c8:	2300      	movs	r3, #0
 80014ca:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80014cc:	2300      	movs	r3, #0
 80014ce:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 80014d0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80014d4:	4619      	mov	r1, r3
 80014d6:	480c      	ldr	r0, [pc, #48]	; (8001508 <MX_GPIO_Init+0x1c0>)
 80014d8:	f00c f91c 	bl	800d714 <HAL_GPIO_Init>

}
 80014dc:	bf00      	nop
 80014de:	4b05      	ldr	r3, [pc, #20]	; (80014f4 <MX_GPIO_Init+0x1ac>)
 80014e0:	681a      	ldr	r2, [r3, #0]
 80014e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80014e4:	405a      	eors	r2, r3
 80014e6:	d001      	beq.n	80014ec <MX_GPIO_Init+0x1a4>
 80014e8:	f002 ff7e 	bl	80043e8 <__stack_chk_fail>
 80014ec:	3740      	adds	r7, #64	; 0x40
 80014ee:	46bd      	mov	sp, r7
 80014f0:	bd80      	pop	{r7, pc}
 80014f2:	bf00      	nop
 80014f4:	0801fe40 	.word	0x0801fe40
 80014f8:	40023800 	.word	0x40023800
 80014fc:	40020000 	.word	0x40020000
 8001500:	40021c00 	.word	0x40021c00
 8001504:	40020400 	.word	0x40020400
 8001508:	40022000 	.word	0x40022000

0800150c <Error_Handler>:
uint32_t HAL_GetTick(void);
void SystemClock_Config(void);
void _Error_Handler(char const *, int);

STATIC INLINE VOID Error_Handler(VOID)
{
 800150c:	b580      	push	{r7, lr}
 800150e:	af00      	add	r7, sp, #0
    _Error_Handler(__FILE__, __LINE__);
 8001510:	213b      	movs	r1, #59	; 0x3b
 8001512:	4802      	ldr	r0, [pc, #8]	; (800151c <Error_Handler+0x10>)
 8001514:	f000 fc3d 	bl	8001d92 <_Error_Handler>
}
 8001518:	bf00      	nop
 800151a:	bd80      	pop	{r7, pc}
 800151c:	0801fe44 	.word	0x0801fe44

08001520 <MX_FMC_Init>:

SDRAM_HandleTypeDef hsdram2;

/* FMC initialization function */
void MX_FMC_Init(void)
{
 8001520:	b580      	push	{r7, lr}
 8001522:	b08c      	sub	sp, #48	; 0x30
 8001524:	af00      	add	r7, sp, #0
 8001526:	4b4d      	ldr	r3, [pc, #308]	; (800165c <MX_FMC_Init+0x13c>)
 8001528:	681b      	ldr	r3, [r3, #0]
 800152a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800152c:	f04f 0300 	mov.w	r3, #0
  /* USER CODE BEGIN FMC_Init 0 */

  /* USER CODE END FMC_Init 0 */

  FMC_SDRAM_TimingTypeDef SdramTiming = {0};
 8001530:	f107 0310 	add.w	r3, r7, #16
 8001534:	2200      	movs	r2, #0
 8001536:	601a      	str	r2, [r3, #0]
 8001538:	605a      	str	r2, [r3, #4]
 800153a:	609a      	str	r2, [r3, #8]
 800153c:	60da      	str	r2, [r3, #12]
 800153e:	611a      	str	r2, [r3, #16]
 8001540:	615a      	str	r2, [r3, #20]
 8001542:	619a      	str	r2, [r3, #24]

  /* USER CODE END FMC_Init 1 */

  /** Perform the SDRAM2 memory initialization sequence
  */
  hsdram2.Instance = FMC_SDRAM_DEVICE;
 8001544:	4b46      	ldr	r3, [pc, #280]	; (8001660 <MX_FMC_Init+0x140>)
 8001546:	4a47      	ldr	r2, [pc, #284]	; (8001664 <MX_FMC_Init+0x144>)
 8001548:	601a      	str	r2, [r3, #0]
  /* hsdram2.Init */
  hsdram2.Init.SDBank = FMC_SDRAM_BANK2;
 800154a:	4b45      	ldr	r3, [pc, #276]	; (8001660 <MX_FMC_Init+0x140>)
 800154c:	2201      	movs	r2, #1
 800154e:	605a      	str	r2, [r3, #4]
  hsdram2.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
 8001550:	4b43      	ldr	r3, [pc, #268]	; (8001660 <MX_FMC_Init+0x140>)
 8001552:	2201      	movs	r2, #1
 8001554:	609a      	str	r2, [r3, #8]
  hsdram2.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
 8001556:	4b42      	ldr	r3, [pc, #264]	; (8001660 <MX_FMC_Init+0x140>)
 8001558:	2208      	movs	r2, #8
 800155a:	60da      	str	r2, [r3, #12]
  hsdram2.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
 800155c:	4b40      	ldr	r3, [pc, #256]	; (8001660 <MX_FMC_Init+0x140>)
 800155e:	2210      	movs	r2, #16
 8001560:	611a      	str	r2, [r3, #16]
  hsdram2.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8001562:	4b3f      	ldr	r3, [pc, #252]	; (8001660 <MX_FMC_Init+0x140>)
 8001564:	2240      	movs	r2, #64	; 0x40
 8001566:	615a      	str	r2, [r3, #20]
  hsdram2.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_3;
 8001568:	4b3d      	ldr	r3, [pc, #244]	; (8001660 <MX_FMC_Init+0x140>)
 800156a:	f44f 72c0 	mov.w	r2, #384	; 0x180
 800156e:	619a      	str	r2, [r3, #24]
  hsdram2.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 8001570:	4b3b      	ldr	r3, [pc, #236]	; (8001660 <MX_FMC_Init+0x140>)
 8001572:	2200      	movs	r2, #0
 8001574:	61da      	str	r2, [r3, #28]
  hsdram2.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
 8001576:	4b3a      	ldr	r3, [pc, #232]	; (8001660 <MX_FMC_Init+0x140>)
 8001578:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800157c:	621a      	str	r2, [r3, #32]
  hsdram2.Init.ReadBurst = FMC_SDRAM_RBURST_DISABLE;
 800157e:	4b38      	ldr	r3, [pc, #224]	; (8001660 <MX_FMC_Init+0x140>)
 8001580:	2200      	movs	r2, #0
 8001582:	625a      	str	r2, [r3, #36]	; 0x24
  hsdram2.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
 8001584:	4b36      	ldr	r3, [pc, #216]	; (8001660 <MX_FMC_Init+0x140>)
 8001586:	2200      	movs	r2, #0
 8001588:	629a      	str	r2, [r3, #40]	; 0x28
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
 800158a:	2302      	movs	r3, #2
 800158c:	613b      	str	r3, [r7, #16]
  SdramTiming.ExitSelfRefreshDelay = 9;
 800158e:	2309      	movs	r3, #9
 8001590:	617b      	str	r3, [r7, #20]
  SdramTiming.SelfRefreshTime = 6;
 8001592:	2306      	movs	r3, #6
 8001594:	61bb      	str	r3, [r7, #24]
  SdramTiming.RowCycleDelay = 8;
 8001596:	2308      	movs	r3, #8
 8001598:	61fb      	str	r3, [r7, #28]
  SdramTiming.WriteRecoveryTime = 3;
 800159a:	2303      	movs	r3, #3
 800159c:	623b      	str	r3, [r7, #32]
  SdramTiming.RPDelay = 3;
 800159e:	2303      	movs	r3, #3
 80015a0:	627b      	str	r3, [r7, #36]	; 0x24
  SdramTiming.RCDDelay = 3;
 80015a2:	2303      	movs	r3, #3
 80015a4:	62bb      	str	r3, [r7, #40]	; 0x28

  if (HAL_SDRAM_Init(&hsdram2, &SdramTiming) != HAL_OK)
 80015a6:	f107 0310 	add.w	r3, r7, #16
 80015aa:	4619      	mov	r1, r3
 80015ac:	482c      	ldr	r0, [pc, #176]	; (8001660 <MX_FMC_Init+0x140>)
 80015ae:	f00b ff2b 	bl	800d408 <HAL_SDRAM_Init>
 80015b2:	4603      	mov	r3, r0
 80015b4:	2b00      	cmp	r3, #0
 80015b6:	d001      	beq.n	80015bc <MX_FMC_Init+0x9c>
  {
    Error_Handler( );
 80015b8:	f7ff ffa8 	bl	800150c <Error_Handler>
  }

  /* USER CODE BEGIN FMC_Init 2 */
// SDRAM
  FMC_SDRAM_CommandTypeDef Command;
  Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 80015bc:	2301      	movs	r3, #1
 80015be:	603b      	str	r3, [r7, #0]
  Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK2;
 80015c0:	2308      	movs	r3, #8
 80015c2:	607b      	str	r3, [r7, #4]
  Command.AutoRefreshNumber = 1;
 80015c4:	2301      	movs	r3, #1
 80015c6:	60bb      	str	r3, [r7, #8]
  Command.ModeRegisterDefinition = 0;
 80015c8:	2300      	movs	r3, #0
 80015ca:	60fb      	str	r3, [r7, #12]
  
  HAL_SDRAM_SendCommand(&hsdram2,&Command,0xFFFF);
 80015cc:	463b      	mov	r3, r7
 80015ce:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80015d2:	4619      	mov	r1, r3
 80015d4:	4822      	ldr	r0, [pc, #136]	; (8001660 <MX_FMC_Init+0x140>)
 80015d6:	f00b ff46 	bl	800d466 <HAL_SDRAM_SendCommand>
  
  // 200us
  // SDRAM_delay(1);
  HAL_Delay(1);
 80015da:	2001      	movs	r0, #1
 80015dc:	f00a f92a 	bl	800b834 <HAL_Delay>
  
  // Banks
  Command.CommandMode = FMC_SDRAM_CMD_PALL;
 80015e0:	2302      	movs	r3, #2
 80015e2:	603b      	str	r3, [r7, #0]
  Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK2;
 80015e4:	2308      	movs	r3, #8
 80015e6:	607b      	str	r3, [r7, #4]
  Command.AutoRefreshNumber = 1;
 80015e8:	2301      	movs	r3, #1
 80015ea:	60bb      	str	r3, [r7, #8]
  Command.ModeRegisterDefinition = 0;
 80015ec:	2300      	movs	r3, #0
 80015ee:	60fb      	str	r3, [r7, #12]
  
  HAL_SDRAM_SendCommand(&hsdram2,&Command,0xFFFF);
 80015f0:	463b      	mov	r3, r7
 80015f2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80015f6:	4619      	mov	r1, r3
 80015f8:	4819      	ldr	r0, [pc, #100]	; (8001660 <MX_FMC_Init+0x140>)
 80015fa:	f00b ff34 	bl	800d466 <HAL_SDRAM_SendCommand>
  
  // 8
  Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 80015fe:	2303      	movs	r3, #3
 8001600:	603b      	str	r3, [r7, #0]
  Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK2;
 8001602:	2308      	movs	r3, #8
 8001604:	607b      	str	r3, [r7, #4]
  Command.AutoRefreshNumber = 8;
 8001606:	2308      	movs	r3, #8
 8001608:	60bb      	str	r3, [r7, #8]
  Command.ModeRegisterDefinition = 0;
 800160a:	2300      	movs	r3, #0
 800160c:	60fb      	str	r3, [r7, #12]
  
  HAL_SDRAM_SendCommand(&hsdram2,&Command,0xFFFF);
 800160e:	463b      	mov	r3, r7
 8001610:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001614:	4619      	mov	r1, r3
 8001616:	4812      	ldr	r0, [pc, #72]	; (8001660 <MX_FMC_Init+0x140>)
 8001618:	f00b ff25 	bl	800d466 <HAL_SDRAM_SendCommand>
  
  // SDRAM
  Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
 800161c:	2304      	movs	r3, #4
 800161e:	603b      	str	r3, [r7, #0]
  Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK2;
 8001620:	2308      	movs	r3, #8
 8001622:	607b      	str	r3, [r7, #4]
  Command.AutoRefreshNumber = 1;
 8001624:	2301      	movs	r3, #1
 8001626:	60bb      	str	r3, [r7, #8]
  Command.ModeRegisterDefinition = 0x230;
 8001628:	f44f 730c 	mov.w	r3, #560	; 0x230
 800162c:	60fb      	str	r3, [r7, #12]
  
  HAL_SDRAM_SendCommand(&hsdram2,&Command,0xFFFF);
 800162e:	463b      	mov	r3, r7
 8001630:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001634:	4619      	mov	r1, r3
 8001636:	480a      	ldr	r0, [pc, #40]	; (8001660 <MX_FMC_Init+0x140>)
 8001638:	f00b ff15 	bl	800d466 <HAL_SDRAM_SendCommand>
  
  // STM32FMCSDRAM
  HAL_SDRAM_ProgramRefreshRate( &hsdram2, 824);
 800163c:	f44f 714e 	mov.w	r1, #824	; 0x338
 8001640:	4807      	ldr	r0, [pc, #28]	; (8001660 <MX_FMC_Init+0x140>)
 8001642:	f00b ff41 	bl	800d4c8 <HAL_SDRAM_ProgramRefreshRate>

#if DEBUG_SDRAM_CHECK
  SDRAM_Test();
#endif  
  /* USER CODE END FMC_Init 2 */
}
 8001646:	bf00      	nop
 8001648:	4b04      	ldr	r3, [pc, #16]	; (800165c <MX_FMC_Init+0x13c>)
 800164a:	681a      	ldr	r2, [r3, #0]
 800164c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800164e:	405a      	eors	r2, r3
 8001650:	d001      	beq.n	8001656 <MX_FMC_Init+0x136>
 8001652:	f002 fec9 	bl	80043e8 <__stack_chk_fail>
 8001656:	3730      	adds	r7, #48	; 0x30
 8001658:	46bd      	mov	sp, r7
 800165a:	bd80      	pop	{r7, pc}
 800165c:	0801fea0 	.word	0x0801fea0
 8001660:	20003498 	.word	0x20003498
 8001664:	a0000140 	.word	0xa0000140

08001668 <HAL_FMC_MspInit>:

static uint32_t FMC_Initialized = 0;

static void HAL_FMC_MspInit(void){
 8001668:	b580      	push	{r7, lr}
 800166a:	b088      	sub	sp, #32
 800166c:	af00      	add	r7, sp, #0
 800166e:	4b48      	ldr	r3, [pc, #288]	; (8001790 <HAL_FMC_MspInit+0x128>)
 8001670:	681b      	ldr	r3, [r3, #0]
 8001672:	61fb      	str	r3, [r7, #28]
 8001674:	f04f 0300 	mov.w	r3, #0
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001678:	f107 0308 	add.w	r3, r7, #8
 800167c:	2200      	movs	r2, #0
 800167e:	601a      	str	r2, [r3, #0]
 8001680:	605a      	str	r2, [r3, #4]
 8001682:	609a      	str	r2, [r3, #8]
 8001684:	60da      	str	r2, [r3, #12]
 8001686:	611a      	str	r2, [r3, #16]
  if (FMC_Initialized) {
 8001688:	4b42      	ldr	r3, [pc, #264]	; (8001794 <HAL_FMC_MspInit+0x12c>)
 800168a:	681b      	ldr	r3, [r3, #0]
 800168c:	2b00      	cmp	r3, #0
 800168e:	d173      	bne.n	8001778 <HAL_FMC_MspInit+0x110>
    return;
  }
  FMC_Initialized = 1;
 8001690:	4b40      	ldr	r3, [pc, #256]	; (8001794 <HAL_FMC_MspInit+0x12c>)
 8001692:	2201      	movs	r2, #1
 8001694:	601a      	str	r2, [r3, #0]

  /* Peripheral clock enable */
  __HAL_RCC_FMC_CLK_ENABLE();
 8001696:	4b40      	ldr	r3, [pc, #256]	; (8001798 <HAL_FMC_MspInit+0x130>)
 8001698:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800169a:	4a3f      	ldr	r2, [pc, #252]	; (8001798 <HAL_FMC_MspInit+0x130>)
 800169c:	f043 0301 	orr.w	r3, r3, #1
 80016a0:	6393      	str	r3, [r2, #56]	; 0x38
 80016a2:	4b3d      	ldr	r3, [pc, #244]	; (8001798 <HAL_FMC_MspInit+0x130>)
 80016a4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80016a6:	f003 0301 	and.w	r3, r3, #1
 80016aa:	607b      	str	r3, [r7, #4]
 80016ac:	687b      	ldr	r3, [r7, #4]
  PG15   ------> FMC_SDNCAS
  PE0   ------> FMC_NBL0
  PE1   ------> FMC_NBL1
  */
  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 80016ae:	f64f 033f 	movw	r3, #63551	; 0xf83f
 80016b2:	60bb      	str	r3, [r7, #8]
                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11|GPIO_PIN_12
                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80016b4:	2302      	movs	r3, #2
 80016b6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80016b8:	2300      	movs	r3, #0
 80016ba:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80016bc:	2303      	movs	r3, #3
 80016be:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 80016c0:	230c      	movs	r3, #12
 80016c2:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 80016c4:	f107 0308 	add.w	r3, r7, #8
 80016c8:	4619      	mov	r1, r3
 80016ca:	4834      	ldr	r0, [pc, #208]	; (800179c <HAL_FMC_MspInit+0x134>)
 80016cc:	f00c f822 	bl	800d714 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 80016d0:	2301      	movs	r3, #1
 80016d2:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80016d4:	2302      	movs	r3, #2
 80016d6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80016d8:	2300      	movs	r3, #0
 80016da:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80016dc:	2303      	movs	r3, #3
 80016de:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 80016e0:	230c      	movs	r3, #12
 80016e2:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80016e4:	f107 0308 	add.w	r3, r7, #8
 80016e8:	4619      	mov	r1, r3
 80016ea:	482d      	ldr	r0, [pc, #180]	; (80017a0 <HAL_FMC_MspInit+0x138>)
 80016ec:	f00c f812 	bl	800d714 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4
 80016f0:	f248 1337 	movw	r3, #33079	; 0x8137
 80016f4:	60bb      	str	r3, [r7, #8]
                          |GPIO_PIN_5|GPIO_PIN_8|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80016f6:	2302      	movs	r3, #2
 80016f8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80016fa:	2300      	movs	r3, #0
 80016fc:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80016fe:	2303      	movs	r3, #3
 8001700:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8001702:	230c      	movs	r3, #12
 8001704:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8001706:	f107 0308 	add.w	r3, r7, #8
 800170a:	4619      	mov	r1, r3
 800170c:	4825      	ldr	r0, [pc, #148]	; (80017a4 <HAL_FMC_MspInit+0x13c>)
 800170e:	f00c f801 	bl	800d714 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10
 8001712:	f64f 7383 	movw	r3, #65411	; 0xff83
 8001716:	60bb      	str	r3, [r7, #8]
                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001718:	2302      	movs	r3, #2
 800171a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800171c:	2300      	movs	r3, #0
 800171e:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001720:	2303      	movs	r3, #3
 8001722:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8001724:	230c      	movs	r3, #12
 8001726:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8001728:	f107 0308 	add.w	r3, r7, #8
 800172c:	4619      	mov	r1, r3
 800172e:	481e      	ldr	r0, [pc, #120]	; (80017a8 <HAL_FMC_MspInit+0x140>)
 8001730:	f00b fff0 	bl	800d714 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8001734:	23c0      	movs	r3, #192	; 0xc0
 8001736:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001738:	2302      	movs	r3, #2
 800173a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800173c:	2300      	movs	r3, #0
 800173e:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001740:	2303      	movs	r3, #3
 8001742:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8001744:	230c      	movs	r3, #12
 8001746:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8001748:	f107 0308 	add.w	r3, r7, #8
 800174c:	4619      	mov	r1, r3
 800174e:	4817      	ldr	r0, [pc, #92]	; (80017ac <HAL_FMC_MspInit+0x144>)
 8001750:	f00b ffe0 	bl	800d714 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14
 8001754:	f24c 7303 	movw	r3, #50947	; 0xc703
 8001758:	60bb      	str	r3, [r7, #8]
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800175a:	2302      	movs	r3, #2
 800175c:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800175e:	2300      	movs	r3, #0
 8001760:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001762:	2303      	movs	r3, #3
 8001764:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8001766:	230c      	movs	r3, #12
 8001768:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800176a:	f107 0308 	add.w	r3, r7, #8
 800176e:	4619      	mov	r1, r3
 8001770:	480f      	ldr	r0, [pc, #60]	; (80017b0 <HAL_FMC_MspInit+0x148>)
 8001772:	f00b ffcf 	bl	800d714 <HAL_GPIO_Init>
 8001776:	e000      	b.n	800177a <HAL_FMC_MspInit+0x112>
    return;
 8001778:	bf00      	nop

  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}
 800177a:	4b05      	ldr	r3, [pc, #20]	; (8001790 <HAL_FMC_MspInit+0x128>)
 800177c:	681a      	ldr	r2, [r3, #0]
 800177e:	69fb      	ldr	r3, [r7, #28]
 8001780:	405a      	eors	r2, r3
 8001782:	d001      	beq.n	8001788 <HAL_FMC_MspInit+0x120>
 8001784:	f002 fe30 	bl	80043e8 <__stack_chk_fail>
 8001788:	3720      	adds	r7, #32
 800178a:	46bd      	mov	sp, r7
 800178c:	bd80      	pop	{r7, pc}
 800178e:	bf00      	nop
 8001790:	0801fea4 	.word	0x0801fea4
 8001794:	20000728 	.word	0x20000728
 8001798:	40023800 	.word	0x40023800
 800179c:	40021400 	.word	0x40021400
 80017a0:	40020800 	.word	0x40020800
 80017a4:	40021800 	.word	0x40021800
 80017a8:	40021000 	.word	0x40021000
 80017ac:	40021c00 	.word	0x40021c00
 80017b0:	40020c00 	.word	0x40020c00

080017b4 <HAL_SDRAM_MspInit>:

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
 80017b4:	b580      	push	{r7, lr}
 80017b6:	b082      	sub	sp, #8
 80017b8:	af00      	add	r7, sp, #0
 80017ba:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN SDRAM_MspInit 0 */

  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
 80017bc:	f7ff ff54 	bl	8001668 <HAL_FMC_MspInit>
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
 80017c0:	bf00      	nop
 80017c2:	3708      	adds	r7, #8
 80017c4:	46bd      	mov	sp, r7
 80017c6:	bd80      	pop	{r7, pc}

080017c8 <Error_Handler>:
{
 80017c8:	b580      	push	{r7, lr}
 80017ca:	af00      	add	r7, sp, #0
    _Error_Handler(__FILE__, __LINE__);
 80017cc:	213b      	movs	r1, #59	; 0x3b
 80017ce:	4802      	ldr	r0, [pc, #8]	; (80017d8 <Error_Handler+0x10>)
 80017d0:	f000 fadf 	bl	8001d92 <_Error_Handler>
}
 80017d4:	bf00      	nop
 80017d6:	bd80      	pop	{r7, pc}
 80017d8:	0801fea8 	.word	0x0801fea8

080017dc <MX_TIM3_Init>:
TIM_HandleTypeDef htim3;

static UINT64 g_tim3_cycleTimes = 0;
/* TIM3 init function */
void MX_TIM3_Init(void)
{
 80017dc:	b580      	push	{r7, lr}
 80017de:	b088      	sub	sp, #32
 80017e0:	af00      	add	r7, sp, #0
 80017e2:	4b29      	ldr	r3, [pc, #164]	; (8001888 <MX_TIM3_Init+0xac>)
 80017e4:	681b      	ldr	r3, [r3, #0]
 80017e6:	61fb      	str	r3, [r7, #28]
 80017e8:	f04f 0300 	mov.w	r3, #0
    TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
 80017ec:	f107 030c 	add.w	r3, r7, #12
 80017f0:	2200      	movs	r2, #0
 80017f2:	601a      	str	r2, [r3, #0]
 80017f4:	605a      	str	r2, [r3, #4]
 80017f6:	609a      	str	r2, [r3, #8]
 80017f8:	60da      	str	r2, [r3, #12]
    TIM_MasterConfigTypeDef sMasterConfig = { 0 };
 80017fa:	463b      	mov	r3, r7
 80017fc:	2200      	movs	r2, #0
 80017fe:	601a      	str	r2, [r3, #0]
 8001800:	605a      	str	r2, [r3, #4]
 8001802:	609a      	str	r2, [r3, #8]
    /* TIM_Period*/
    //TIMxCLK = 2 * PCLK1  
    //              PCLK1 = HCLK / 4 
    //              => TIMxCLK=HCLK/2=SystemCoreClock/2=108MHz
    //  = TIMxCLK/(TIM_Prescaler+1)=1000000Hz
    htim3.Instance = TIM3;
 8001804:	4b21      	ldr	r3, [pc, #132]	; (800188c <MX_TIM3_Init+0xb0>)
 8001806:	4a22      	ldr	r2, [pc, #136]	; (8001890 <MX_TIM3_Init+0xb4>)
 8001808:	601a      	str	r2, [r3, #0]
    htim3.Init.Prescaler = 108 - 1; // 5400 - 1, Set timer3 prescaler.
 800180a:	4b20      	ldr	r3, [pc, #128]	; (800188c <MX_TIM3_Init+0xb0>)
 800180c:	226b      	movs	r2, #107	; 0x6b
 800180e:	605a      	str	r2, [r3, #4]
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001810:	4b1e      	ldr	r3, [pc, #120]	; (800188c <MX_TIM3_Init+0xb0>)
 8001812:	2200      	movs	r2, #0
 8001814:	609a      	str	r2, [r3, #8]
    htim3.Init.Period = 50000 - 1; // 50000 - 1, Set timer3 period.
 8001816:	4b1d      	ldr	r3, [pc, #116]	; (800188c <MX_TIM3_Init+0xb0>)
 8001818:	f24c 324f 	movw	r2, #49999	; 0xc34f
 800181c:	60da      	str	r2, [r3, #12]

    /* Period (50000) / TIMxCLK(10000HZ) = 5s */
    htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800181e:	4b1b      	ldr	r3, [pc, #108]	; (800188c <MX_TIM3_Init+0xb0>)
 8001820:	2200      	movs	r2, #0
 8001822:	611a      	str	r2, [r3, #16]
    htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8001824:	4b19      	ldr	r3, [pc, #100]	; (800188c <MX_TIM3_Init+0xb0>)
 8001826:	2200      	movs	r2, #0
 8001828:	619a      	str	r2, [r3, #24]
    if (HAL_TIM_Base_Init(&htim3) != HAL_OK) {
 800182a:	4818      	ldr	r0, [pc, #96]	; (800188c <MX_TIM3_Init+0xb0>)
 800182c:	f00a fc4c 	bl	800c0c8 <HAL_TIM_Base_Init>
 8001830:	4603      	mov	r3, r0
 8001832:	2b00      	cmp	r3, #0
 8001834:	d001      	beq.n	800183a <MX_TIM3_Init+0x5e>
        Error_Handler();
 8001836:	f7ff ffc7 	bl	80017c8 <Error_Handler>
    }
    sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800183a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800183e:	60fb      	str	r3, [r7, #12]
    if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK) {
 8001840:	f107 030c 	add.w	r3, r7, #12
 8001844:	4619      	mov	r1, r3
 8001846:	4811      	ldr	r0, [pc, #68]	; (800188c <MX_TIM3_Init+0xb0>)
 8001848:	f00a fe12 	bl	800c470 <HAL_TIM_ConfigClockSource>
 800184c:	4603      	mov	r3, r0
 800184e:	2b00      	cmp	r3, #0
 8001850:	d001      	beq.n	8001856 <MX_TIM3_Init+0x7a>
        Error_Handler();
 8001852:	f7ff ffb9 	bl	80017c8 <Error_Handler>
    }
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8001856:	2300      	movs	r3, #0
 8001858:	603b      	str	r3, [r7, #0]
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800185a:	2300      	movs	r3, #0
 800185c:	60bb      	str	r3, [r7, #8]
    if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK) {
 800185e:	463b      	mov	r3, r7
 8001860:	4619      	mov	r1, r3
 8001862:	480a      	ldr	r0, [pc, #40]	; (800188c <MX_TIM3_Init+0xb0>)
 8001864:	f00b fd18 	bl	800d298 <HAL_TIMEx_MasterConfigSynchronization>
 8001868:	4603      	mov	r3, r0
 800186a:	2b00      	cmp	r3, #0
 800186c:	d001      	beq.n	8001872 <MX_TIM3_Init+0x96>
        Error_Handler();
 800186e:	f7ff ffab 	bl	80017c8 <Error_Handler>
    }
}
 8001872:	bf00      	nop
 8001874:	4b04      	ldr	r3, [pc, #16]	; (8001888 <MX_TIM3_Init+0xac>)
 8001876:	681a      	ldr	r2, [r3, #0]
 8001878:	69fb      	ldr	r3, [r7, #28]
 800187a:	405a      	eors	r2, r3
 800187c:	d001      	beq.n	8001882 <MX_TIM3_Init+0xa6>
 800187e:	f002 fdb3 	bl	80043e8 <__stack_chk_fail>
 8001882:	3720      	adds	r7, #32
 8001884:	46bd      	mov	sp, r7
 8001886:	bd80      	pop	{r7, pc}
 8001888:	0801ff04 	.word	0x0801ff04
 800188c:	200034d0 	.word	0x200034d0
 8001890:	40000400 	.word	0x40000400

08001894 <HAL_TIM_Base_MspInit>:


void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
 8001894:	b580      	push	{r7, lr}
 8001896:	b084      	sub	sp, #16
 8001898:	af00      	add	r7, sp, #0
 800189a:	6078      	str	r0, [r7, #4]

  if(tim_baseHandle->Instance==TIM3)
 800189c:	687b      	ldr	r3, [r7, #4]
 800189e:	681b      	ldr	r3, [r3, #0]
 80018a0:	4a0d      	ldr	r2, [pc, #52]	; (80018d8 <HAL_TIM_Base_MspInit+0x44>)
 80018a2:	4293      	cmp	r3, r2
 80018a4:	d113      	bne.n	80018ce <HAL_TIM_Base_MspInit+0x3a>
  {
  /* USER CODE BEGIN TIM3_MspInit 0 */

  /* USER CODE END TIM3_MspInit 0 */
    /* TIM3 clock enable */
    __HAL_RCC_TIM3_CLK_ENABLE();
 80018a6:	4b0d      	ldr	r3, [pc, #52]	; (80018dc <HAL_TIM_Base_MspInit+0x48>)
 80018a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80018aa:	4a0c      	ldr	r2, [pc, #48]	; (80018dc <HAL_TIM_Base_MspInit+0x48>)
 80018ac:	f043 0302 	orr.w	r3, r3, #2
 80018b0:	6413      	str	r3, [r2, #64]	; 0x40
 80018b2:	4b0a      	ldr	r3, [pc, #40]	; (80018dc <HAL_TIM_Base_MspInit+0x48>)
 80018b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80018b6:	f003 0302 	and.w	r3, r3, #2
 80018ba:	60fb      	str	r3, [r7, #12]
 80018bc:	68fb      	ldr	r3, [r7, #12]

    /* TIM3 interrupt Init */
    HAL_NVIC_SetPriority(TIM3_IRQn, 0, 3);
 80018be:	2203      	movs	r2, #3
 80018c0:	2100      	movs	r1, #0
 80018c2:	201d      	movs	r0, #29
 80018c4:	f00b fef5 	bl	800d6b2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
 80018c8:	201d      	movs	r0, #29
 80018ca:	f00b ff0b 	bl	800d6e4 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
}
 80018ce:	bf00      	nop
 80018d0:	3710      	adds	r7, #16
 80018d2:	46bd      	mov	sp, r7
 80018d4:	bd80      	pop	{r7, pc}
 80018d6:	bf00      	nop
 80018d8:	40000400 	.word	0x40000400
 80018dc:	40023800 	.word	0x40023800

080018e0 <TIM3_IRQHandler>:

/* *
 * @brief This function handles TIM3 global interrupt.
 */
void TIM3_IRQHandler(void)
{
 80018e0:	b5b0      	push	{r4, r5, r7, lr}
 80018e2:	af00      	add	r7, sp, #0
    /* USER CODE BEGIN TIM3_IRQn 0 */

    /* USER CODE END TIM3_IRQn 0 */
    // Fire_DEBUG_GPIOB6_TRIGGER(); 
    Fire_DEBUG_GPIOB7(1);
 80018e4:	2001      	movs	r0, #1
 80018e6:	f000 fa2b 	bl	8001d40 <Fire_DEBUG_GPIOB7>
    g_tim3_cycleTimes ++;
 80018ea:	4b08      	ldr	r3, [pc, #32]	; (800190c <TIM3_IRQHandler+0x2c>)
 80018ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80018f0:	1c54      	adds	r4, r2, #1
 80018f2:	f143 0500 	adc.w	r5, r3, #0
 80018f6:	4b05      	ldr	r3, [pc, #20]	; (800190c <TIM3_IRQHandler+0x2c>)
 80018f8:	e9c3 4500 	strd	r4, r5, [r3]
    HAL_TIM_IRQHandler(&htim3);
 80018fc:	4804      	ldr	r0, [pc, #16]	; (8001910 <TIM3_IRQHandler+0x30>)
 80018fe:	f00a fc97 	bl	800c230 <HAL_TIM_IRQHandler>
    Fire_DEBUG_GPIOB7(0);
 8001902:	2000      	movs	r0, #0
 8001904:	f000 fa1c 	bl	8001d40 <Fire_DEBUG_GPIOB7>
    /* USER CODE BEGIN TIM3_IRQn 1 */

    /* USER CODE END TIM3_IRQn 1 */
}
 8001908:	bf00      	nop
 800190a:	bdb0      	pop	{r4, r5, r7, pc}
 800190c:	20000730 	.word	0x20000730
 8001910:	200034d0 	.word	0x200034d0

08001914 <TimInit>:

/* USER CODE BEGIN 1 */
VOID TimInit(VOID)
{
 8001914:	b580      	push	{r7, lr}
 8001916:	af00      	add	r7, sp, #0
    MX_TIM3_Init();
 8001918:	f7ff ff60 	bl	80017dc <MX_TIM3_Init>
    
    // 
    // (VOID)HAL_TIM_Base_Start_IT(&htim3);
    HAL_TIM_Base_Start(&htim3);
 800191c:	4802      	ldr	r0, [pc, #8]	; (8001928 <TimInit+0x14>)
 800191e:	f00a fc1b 	bl	800c158 <HAL_TIM_Base_Start>
}
 8001922:	bf00      	nop
 8001924:	bd80      	pop	{r7, pc}
 8001926:	bf00      	nop
 8001928:	200034d0 	.word	0x200034d0

0800192c <TimerHwiCreate>:

VOID TimerHwiCreate(VOID)
{
 800192c:	b580      	push	{r7, lr}
 800192e:	b084      	sub	sp, #16
 8001930:	af02      	add	r7, sp, #8
    UINT32 ret;

    ret = LOS_HwiCreate(TIM_IRQ, 0, 0, TIM3_IRQHandler, 0); // 16: cortex-m irq num shift
 8001932:	2300      	movs	r3, #0
 8001934:	9300      	str	r3, [sp, #0]
 8001936:	4b09      	ldr	r3, [pc, #36]	; (800195c <TimerHwiCreate+0x30>)
 8001938:	2200      	movs	r2, #0
 800193a:	2100      	movs	r1, #0
 800193c:	202d      	movs	r0, #45	; 0x2d
 800193e:	f000 fdad 	bl	800249c <LOS_HwiCreate>
 8001942:	6078      	str	r0, [r7, #4]
    if (ret != 0) {
 8001944:	687b      	ldr	r3, [r7, #4]
 8001946:	2b00      	cmp	r3, #0
 8001948:	d004      	beq.n	8001954 <TimerHwiCreate+0x28>
        printf("ret of TIM3 LOS_HwiCreate = %#x\n", ret);
 800194a:	6879      	ldr	r1, [r7, #4]
 800194c:	4804      	ldr	r0, [pc, #16]	; (8001960 <TimerHwiCreate+0x34>)
 800194e:	f00d fe55 	bl	800f5fc <printf>
        return;
 8001952:	bf00      	nop
    }

}
 8001954:	3708      	adds	r7, #8
 8001956:	46bd      	mov	sp, r7
 8001958:	bd80      	pop	{r7, pc}
 800195a:	bf00      	nop
 800195c:	080018e1 	.word	0x080018e1
 8001960:	0801ff08 	.word	0x0801ff08

08001964 <Hal_STM32F767_Get_Timer_CNT>:

/* 2022-04-07 tanzhongqiang  
    CNT 1us 
*/
UINT64 Hal_STM32F767_Get_Timer_CNT(VOID)
{
 8001964:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
 8001968:	b083      	sub	sp, #12
 800196a:	af00      	add	r7, sp, #0
    static UINT64 bacCycle = 0;
    static UINT64 cycleTimes = 0;
    if (htim3.Instance == NULL) {
 800196c:	4b23      	ldr	r3, [pc, #140]	; (80019fc <Hal_STM32F767_Get_Timer_CNT+0x98>)
 800196e:	681b      	ldr	r3, [r3, #0]
 8001970:	2b00      	cmp	r3, #0
 8001972:	d104      	bne.n	800197e <Hal_STM32F767_Get_Timer_CNT+0x1a>
        return 0;
 8001974:	f04f 0400 	mov.w	r4, #0
 8001978:	f04f 0500 	mov.w	r5, #0
 800197c:	e034      	b.n	80019e8 <Hal_STM32F767_Get_Timer_CNT+0x84>
    }

    UINT64 swCycles = htim3.Instance->CNT;
 800197e:	4b1f      	ldr	r3, [pc, #124]	; (80019fc <Hal_STM32F767_Get_Timer_CNT+0x98>)
 8001980:	681b      	ldr	r3, [r3, #0]
 8001982:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001984:	461a      	mov	r2, r3
 8001986:	f04f 0300 	mov.w	r3, #0
 800198a:	e9c7 2300 	strd	r2, r3, [r7]

    if (swCycles < bacCycle) {
 800198e:	4b1c      	ldr	r3, [pc, #112]	; (8001a00 <Hal_STM32F767_Get_Timer_CNT+0x9c>)
 8001990:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001994:	e9d7 8900 	ldrd	r8, r9, [r7]
 8001998:	4599      	cmp	r9, r3
 800199a:	bf08      	it	eq
 800199c:	4590      	cmpeq	r8, r2
 800199e:	d208      	bcs.n	80019b2 <Hal_STM32F767_Get_Timer_CNT+0x4e>
        cycleTimes++;
 80019a0:	4b18      	ldr	r3, [pc, #96]	; (8001a04 <Hal_STM32F767_Get_Timer_CNT+0xa0>)
 80019a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80019a6:	1c50      	adds	r0, r2, #1
 80019a8:	f143 0100 	adc.w	r1, r3, #0
 80019ac:	4b15      	ldr	r3, [pc, #84]	; (8001a04 <Hal_STM32F767_Get_Timer_CNT+0xa0>)
 80019ae:	e9c3 0100 	strd	r0, r1, [r3]
    }
    bacCycle = swCycles;
 80019b2:	4913      	ldr	r1, [pc, #76]	; (8001a00 <Hal_STM32F767_Get_Timer_CNT+0x9c>)
 80019b4:	e9d7 2300 	ldrd	r2, r3, [r7]
 80019b8:	e9c1 2300 	strd	r2, r3, [r1]

    return (swCycles + cycleTimes * TIMER3_RELOAD);
 80019bc:	4b11      	ldr	r3, [pc, #68]	; (8001a04 <Hal_STM32F767_Get_Timer_CNT+0xa0>)
 80019be:	e9d3 2300 	ldrd	r2, r3, [r3]
 80019c2:	f24c 3150 	movw	r1, #50000	; 0xc350
 80019c6:	fb01 f003 	mul.w	r0, r1, r3
 80019ca:	2100      	movs	r1, #0
 80019cc:	fb01 f102 	mul.w	r1, r1, r2
 80019d0:	4401      	add	r1, r0
 80019d2:	f24c 3050 	movw	r0, #50000	; 0xc350
 80019d6:	fba2 2300 	umull	r2, r3, r2, r0
 80019da:	4419      	add	r1, r3
 80019dc:	460b      	mov	r3, r1
 80019de:	e9d7 0100 	ldrd	r0, r1, [r7]
 80019e2:	1814      	adds	r4, r2, r0
 80019e4:	eb43 0501 	adc.w	r5, r3, r1
 80019e8:	4622      	mov	r2, r4
 80019ea:	462b      	mov	r3, r5
}
 80019ec:	4610      	mov	r0, r2
 80019ee:	4619      	mov	r1, r3
 80019f0:	370c      	adds	r7, #12
 80019f2:	46bd      	mov	sp, r7
 80019f4:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
 80019f8:	4770      	bx	lr
 80019fa:	bf00      	nop
 80019fc:	200034d0 	.word	0x200034d0
 8001a00:	20000738 	.word	0x20000738
 8001a04:	20000740 	.word	0x20000740

08001a08 <GetTimerCycles>:

/* 
    2022-04-07 tanzhongqiang SYSCLK cycles YSCLK 216MHZ.
*/
UINT64 GetTimerCycles(VOID)
{
 8001a08:	b5b0      	push	{r4, r5, r7, lr}
 8001a0a:	af00      	add	r7, sp, #0
#4  0x08013f36 in OsCpupIrqStart () at los_cpup.c:520
#5  0x08001f62 in OsIntHandle (hwiNum=45, hwiForm=0x20002490 <g_hwiForm+720>) at los_hwi.c:123
#6  0x0800f178 in IrqEntryV7M () at arm_nvic.c:100
* */

    return Hal_STM32F767_Get_Timer_CNT() * 216;// * 1000000;
 8001a0c:	f7ff ffaa 	bl	8001964 <Hal_STM32F767_Get_Timer_CNT>
 8001a10:	4602      	mov	r2, r0
 8001a12:	460b      	mov	r3, r1
 8001a14:	1894      	adds	r4, r2, r2
 8001a16:	eb43 0503 	adc.w	r5, r3, r3
 8001a1a:	4622      	mov	r2, r4
 8001a1c:	462b      	mov	r3, r5
 8001a1e:	1812      	adds	r2, r2, r0
 8001a20:	eb41 0303 	adc.w	r3, r1, r3
 8001a24:	f04f 0000 	mov.w	r0, #0
 8001a28:	f04f 0100 	mov.w	r1, #0
 8001a2c:	00d9      	lsls	r1, r3, #3
 8001a2e:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8001a32:	00d0      	lsls	r0, r2, #3
 8001a34:	1812      	adds	r2, r2, r0
 8001a36:	eb41 0303 	adc.w	r3, r1, r3
 8001a3a:	f04f 0000 	mov.w	r0, #0
 8001a3e:	f04f 0100 	mov.w	r1, #0
 8001a42:	00d9      	lsls	r1, r3, #3
 8001a44:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8001a48:	00d0      	lsls	r0, r2, #3
 8001a4a:	4602      	mov	r2, r0
 8001a4c:	460b      	mov	r3, r1
}
 8001a4e:	4610      	mov	r0, r2
 8001a50:	4619      	mov	r1, r3
 8001a52:	bdb0      	pop	{r4, r5, r7, pc}

08001a54 <Error_Handler>:
{
 8001a54:	b580      	push	{r7, lr}
 8001a56:	af00      	add	r7, sp, #0
    _Error_Handler(__FILE__, __LINE__);
 8001a58:	213b      	movs	r1, #59	; 0x3b
 8001a5a:	4802      	ldr	r0, [pc, #8]	; (8001a64 <Error_Handler+0x10>)
 8001a5c:	f000 f999 	bl	8001d92 <_Error_Handler>
}
 8001a60:	bf00      	nop
 8001a62:	bd80      	pop	{r7, pc}
 8001a64:	0801ff2c 	.word	0x0801ff2c

08001a68 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart1;

/* USART3 init function */

void MX_USART1_UART_Init(void)
{
 8001a68:	b580      	push	{r7, lr}
 8001a6a:	af00      	add	r7, sp, #0
  huart1.Instance = USART1;
 8001a6c:	4b14      	ldr	r3, [pc, #80]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a6e:	4a15      	ldr	r2, [pc, #84]	; (8001ac4 <MX_USART1_UART_Init+0x5c>)
 8001a70:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 8001a72:	4b13      	ldr	r3, [pc, #76]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a74:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8001a78:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8001a7a:	4b11      	ldr	r3, [pc, #68]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a7c:	2200      	movs	r2, #0
 8001a7e:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8001a80:	4b0f      	ldr	r3, [pc, #60]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a82:	2200      	movs	r2, #0
 8001a84:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8001a86:	4b0e      	ldr	r3, [pc, #56]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a88:	2200      	movs	r2, #0
 8001a8a:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8001a8c:	4b0c      	ldr	r3, [pc, #48]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a8e:	220c      	movs	r2, #12
 8001a90:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001a92:	4b0b      	ldr	r3, [pc, #44]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a94:	2200      	movs	r2, #0
 8001a96:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8001a98:	4b09      	ldr	r3, [pc, #36]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a9a:	2200      	movs	r2, #0
 8001a9c:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001a9e:	4b08      	ldr	r3, [pc, #32]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001aa0:	2200      	movs	r2, #0
 8001aa2:	621a      	str	r2, [r3, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001aa4:	4b06      	ldr	r3, [pc, #24]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001aa6:	2200      	movs	r2, #0
 8001aa8:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8001aaa:	4805      	ldr	r0, [pc, #20]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001aac:	f00c f810 	bl	800dad0 <HAL_UART_Init>
 8001ab0:	4603      	mov	r3, r0
 8001ab2:	2b00      	cmp	r3, #0
 8001ab4:	d001      	beq.n	8001aba <MX_USART1_UART_Init+0x52>
  {
    Error_Handler();
 8001ab6:	f7ff ffcd 	bl	8001a54 <Error_Handler>
  }
}
 8001aba:	bf00      	nop
 8001abc:	bd80      	pop	{r7, pc}
 8001abe:	bf00      	nop
 8001ac0:	20003540 	.word	0x20003540
 8001ac4:	40011000 	.word	0x40011000

08001ac8 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8001ac8:	b580      	push	{r7, lr}
 8001aca:	b08a      	sub	sp, #40	; 0x28
 8001acc:	af00      	add	r7, sp, #0
 8001ace:	6078      	str	r0, [r7, #4]
 8001ad0:	4b22      	ldr	r3, [pc, #136]	; (8001b5c <HAL_UART_MspInit+0x94>)
 8001ad2:	681b      	ldr	r3, [r3, #0]
 8001ad4:	627b      	str	r3, [r7, #36]	; 0x24
 8001ad6:	f04f 0300 	mov.w	r3, #0

  GPIO_InitTypeDef GPIO_InitStructure = {0};
 8001ada:	f107 0310 	add.w	r3, r7, #16
 8001ade:	2200      	movs	r2, #0
 8001ae0:	601a      	str	r2, [r3, #0]
 8001ae2:	605a      	str	r2, [r3, #4]
 8001ae4:	609a      	str	r2, [r3, #8]
 8001ae6:	60da      	str	r2, [r3, #12]
 8001ae8:	611a      	str	r2, [r3, #16]
  if(uartHandle->Instance==USART1)
 8001aea:	687b      	ldr	r3, [r7, #4]
 8001aec:	681b      	ldr	r3, [r3, #0]
 8001aee:	4a1c      	ldr	r2, [pc, #112]	; (8001b60 <HAL_UART_MspInit+0x98>)
 8001af0:	4293      	cmp	r3, r2
 8001af2:	d128      	bne.n	8001b46 <HAL_UART_MspInit+0x7e>
  {
     /* Enable GPIOA clock */
      __HAL_RCC_GPIOA_CLK_ENABLE();
 8001af4:	4b1b      	ldr	r3, [pc, #108]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001af6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001af8:	4a1a      	ldr	r2, [pc, #104]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001afa:	f043 0301 	orr.w	r3, r3, #1
 8001afe:	6313      	str	r3, [r2, #48]	; 0x30
 8001b00:	4b18      	ldr	r3, [pc, #96]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001b02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001b04:	f003 0301 	and.w	r3, r3, #1
 8001b08:	60bb      	str	r3, [r7, #8]
 8001b0a:	68bb      	ldr	r3, [r7, #8]
      /* Enable USART1 clock */
      __HAL_RCC_USART1_CLK_ENABLE();
 8001b0c:	4b15      	ldr	r3, [pc, #84]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001b0e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001b10:	4a14      	ldr	r2, [pc, #80]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001b12:	f043 0310 	orr.w	r3, r3, #16
 8001b16:	6453      	str	r3, [r2, #68]	; 0x44
 8001b18:	4b12      	ldr	r3, [pc, #72]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001b1a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001b1c:	f003 0310 	and.w	r3, r3, #16
 8001b20:	60fb      	str	r3, [r7, #12]
 8001b22:	68fb      	ldr	r3, [r7, #12]

      /* Configure USART1_TX (PA9) and USART1_RX (PA10) */
      GPIO_InitStructure.Pin = GPIO_PIN_9 | GPIO_PIN_10;
 8001b24:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8001b28:	613b      	str	r3, [r7, #16]
      GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
 8001b2a:	2302      	movs	r3, #2
 8001b2c:	617b      	str	r3, [r7, #20]
      GPIO_InitStructure.Pull = GPIO_PULLUP;
 8001b2e:	2301      	movs	r3, #1
 8001b30:	61bb      	str	r3, [r7, #24]
      GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
 8001b32:	2302      	movs	r3, #2
 8001b34:	61fb      	str	r3, [r7, #28]
      GPIO_InitStructure.Alternate = GPIO_AF7_USART1;
 8001b36:	2307      	movs	r3, #7
 8001b38:	623b      	str	r3, [r7, #32]
      HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001b3a:	f107 0310 	add.w	r3, r7, #16
 8001b3e:	4619      	mov	r1, r3
 8001b40:	4809      	ldr	r0, [pc, #36]	; (8001b68 <HAL_UART_MspInit+0xa0>)
 8001b42:	f00b fde7 	bl	800d714 <HAL_GPIO_Init>
  }
}
 8001b46:	bf00      	nop
 8001b48:	4b04      	ldr	r3, [pc, #16]	; (8001b5c <HAL_UART_MspInit+0x94>)
 8001b4a:	681a      	ldr	r2, [r3, #0]
 8001b4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001b4e:	405a      	eors	r2, r3
 8001b50:	d001      	beq.n	8001b56 <HAL_UART_MspInit+0x8e>
 8001b52:	f002 fc49 	bl	80043e8 <__stack_chk_fail>
 8001b56:	3728      	adds	r7, #40	; 0x28
 8001b58:	46bd      	mov	sp, r7
 8001b5a:	bd80      	pop	{r7, pc}
 8001b5c:	0801ff88 	.word	0x0801ff88
 8001b60:	40011000 	.word	0x40011000
 8001b64:	40023800 	.word	0x40023800
 8001b68:	40020000 	.word	0x40020000

08001b6c <UsartInit>:
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_9|GPIO_PIN_10);
  }
}

/* USER CODE BEGIN 1 */
VOID UsartInit(VOID) {
 8001b6c:	b580      	push	{r7, lr}
 8001b6e:	af00      	add	r7, sp, #0
    MX_USART1_UART_Init();
 8001b70:	f7ff ff7a 	bl	8001a68 <MX_USART1_UART_Init>
}
 8001b74:	bf00      	nop
 8001b76:	bd80      	pop	{r7, pc}

08001b78 <UsartWrite>:

VOID UsartWrite(const CHAR c)
{
 8001b78:	b580      	push	{r7, lr}
 8001b7a:	b082      	sub	sp, #8
 8001b7c:	af00      	add	r7, sp, #0
 8001b7e:	4603      	mov	r3, r0
 8001b80:	71fb      	strb	r3, [r7, #7]
    (VOID)HAL_UART_Transmit(&huart1, (UINT8 *)&c, 1, DEFAULT_TIMEOUT);
 8001b82:	1df9      	adds	r1, r7, #7
 8001b84:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001b88:	2201      	movs	r2, #1
 8001b8a:	4803      	ldr	r0, [pc, #12]	; (8001b98 <UsartWrite+0x20>)
 8001b8c:	f00b ffed 	bl	800db6a <HAL_UART_Transmit>
}
 8001b90:	bf00      	nop
 8001b92:	3708      	adds	r7, #8
 8001b94:	46bd      	mov	sp, r7
 8001b96:	bd80      	pop	{r7, pc}
 8001b98:	20003540 	.word	0x20003540

08001b9c <UsartRead>:

UINT8 UsartRead(VOID)
{
 8001b9c:	b580      	push	{r7, lr}
 8001b9e:	b082      	sub	sp, #8
 8001ba0:	af00      	add	r7, sp, #0
 8001ba2:	4b0b      	ldr	r3, [pc, #44]	; (8001bd0 <UsartRead+0x34>)
 8001ba4:	681b      	ldr	r3, [r3, #0]
 8001ba6:	607b      	str	r3, [r7, #4]
 8001ba8:	f04f 0300 	mov.w	r3, #0
    UINT8 ch;
    // LedTaskTrigger();
    (VOID)HAL_UART_Receive(&huart1, &ch, sizeof(UINT8), 0);
 8001bac:	1cf9      	adds	r1, r7, #3
 8001bae:	2300      	movs	r3, #0
 8001bb0:	2201      	movs	r2, #1
 8001bb2:	4808      	ldr	r0, [pc, #32]	; (8001bd4 <UsartRead+0x38>)
 8001bb4:	f00c f868 	bl	800dc88 <HAL_UART_Receive>
    return ch;
 8001bb8:	78fb      	ldrb	r3, [r7, #3]
}
 8001bba:	4a05      	ldr	r2, [pc, #20]	; (8001bd0 <UsartRead+0x34>)
 8001bbc:	6811      	ldr	r1, [r2, #0]
 8001bbe:	687a      	ldr	r2, [r7, #4]
 8001bc0:	4051      	eors	r1, r2
 8001bc2:	d001      	beq.n	8001bc8 <UsartRead+0x2c>
 8001bc4:	f002 fc10 	bl	80043e8 <__stack_chk_fail>
 8001bc8:	4618      	mov	r0, r3
 8001bca:	3708      	adds	r7, #8
 8001bcc:	46bd      	mov	sp, r7
 8001bce:	bd80      	pop	{r7, pc}
 8001bd0:	0801ff8c 	.word	0x0801ff8c
 8001bd4:	20003540 	.word	0x20003540

08001bd8 <USART1_IdleCallback>:

//
void USART1_IdleCallback(uint8_t *pData,uint16_t len)
{
 8001bd8:	b480      	push	{r7}
 8001bda:	b083      	sub	sp, #12
 8001bdc:	af00      	add	r7, sp, #0
 8001bde:	6078      	str	r0, [r7, #4]
 8001be0:	460b      	mov	r3, r1
 8001be2:	807b      	strh	r3, [r7, #2]
    while(__HAL_UART_GET_FLAG(&huart1,UART_FLAG_TC) != SET);
 8001be4:	bf00      	nop
 8001be6:	4b07      	ldr	r3, [pc, #28]	; (8001c04 <USART1_IdleCallback+0x2c>)
 8001be8:	681b      	ldr	r3, [r3, #0]
 8001bea:	69db      	ldr	r3, [r3, #28]
 8001bec:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8001bf0:	2b40      	cmp	r3, #64	; 0x40
 8001bf2:	d1f8      	bne.n	8001be6 <USART1_IdleCallback+0xe>
    // HAL_UART_Transmit(&huart1,pData,len,1000);
}
 8001bf4:	bf00      	nop
 8001bf6:	bf00      	nop
 8001bf8:	370c      	adds	r7, #12
 8001bfa:	46bd      	mov	sp, r7
 8001bfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c00:	4770      	bx	lr
 8001c02:	bf00      	nop
 8001c04:	20003540 	.word	0x20003540

08001c08 <__USART1_IRQHandler>:

void __USART1_IRQHandler(void)
{
 8001c08:	b580      	push	{r7, lr}
 8001c0a:	af00      	add	r7, sp, #0

    if(__HAL_UART_GET_FLAG(&huart1,UART_FLAG_ORE) != RESET) {
 8001c0c:	4b1b      	ldr	r3, [pc, #108]	; (8001c7c <__USART1_IRQHandler+0x74>)
 8001c0e:	681b      	ldr	r3, [r3, #0]
 8001c10:	69db      	ldr	r3, [r3, #28]
 8001c12:	f003 0308 	and.w	r3, r3, #8
 8001c16:	2b08      	cmp	r3, #8
 8001c18:	d104      	bne.n	8001c24 <__USART1_IRQHandler+0x1c>
        __HAL_UART_CLEAR_FLAG(&huart1, UART_CLEAR_OREF);
 8001c1a:	4b18      	ldr	r3, [pc, #96]	; (8001c7c <__USART1_IRQHandler+0x74>)
 8001c1c:	681b      	ldr	r3, [r3, #0]
 8001c1e:	2208      	movs	r2, #8
 8001c20:	621a      	str	r2, [r3, #32]
        goto out;
 8001c22:	e028      	b.n	8001c76 <__USART1_IRQHandler+0x6e>
    }

    //
    if(__HAL_UART_GET_FLAG(&huart1,UART_FLAG_RXNE) != RESET) {
 8001c24:	4b15      	ldr	r3, [pc, #84]	; (8001c7c <__USART1_IRQHandler+0x74>)
 8001c26:	681b      	ldr	r3, [r3, #0]
 8001c28:	69db      	ldr	r3, [r3, #28]
 8001c2a:	f003 0320 	and.w	r3, r3, #32
 8001c2e:	2b20      	cmp	r3, #32
 8001c30:	d106      	bne.n	8001c40 <__USART1_IRQHandler+0x38>
        (VOID)uart_getc();
 8001c32:	f00e f8f1 	bl	800fe18 <uart_getc>
        __HAL_UART_CLEAR_FLAG(&huart1,UART_FLAG_RXNE);
 8001c36:	4b11      	ldr	r3, [pc, #68]	; (8001c7c <__USART1_IRQHandler+0x74>)
 8001c38:	681b      	ldr	r3, [r3, #0]
 8001c3a:	2220      	movs	r2, #32
 8001c3c:	621a      	str	r2, [r3, #32]
        goto out;
 8001c3e:	e01a      	b.n	8001c76 <__USART1_IRQHandler+0x6e>
    }
    //
    if(__HAL_UART_GET_FLAG(&huart1,UART_FLAG_IDLE) != RESET) {
 8001c40:	4b0e      	ldr	r3, [pc, #56]	; (8001c7c <__USART1_IRQHandler+0x74>)
 8001c42:	681b      	ldr	r3, [r3, #0]
 8001c44:	69db      	ldr	r3, [r3, #28]
 8001c46:	f003 0310 	and.w	r3, r3, #16
 8001c4a:	2b10      	cmp	r3, #16
 8001c4c:	d10b      	bne.n	8001c66 <__USART1_IRQHandler+0x5e>
        //  
        USART1_IdleCallback(aRxBuffer,rxConut);
 8001c4e:	4b0c      	ldr	r3, [pc, #48]	; (8001c80 <__USART1_IRQHandler+0x78>)
 8001c50:	681b      	ldr	r3, [r3, #0]
 8001c52:	b29b      	uxth	r3, r3
 8001c54:	4619      	mov	r1, r3
 8001c56:	480b      	ldr	r0, [pc, #44]	; (8001c84 <__USART1_IRQHandler+0x7c>)
 8001c58:	f7ff ffbe 	bl	8001bd8 <USART1_IdleCallback>
        __HAL_UART_CLEAR_FLAG(&huart1,UART_CLEAR_IDLEF);
 8001c5c:	4b07      	ldr	r3, [pc, #28]	; (8001c7c <__USART1_IRQHandler+0x74>)
 8001c5e:	681b      	ldr	r3, [r3, #0]
 8001c60:	2210      	movs	r2, #16
 8001c62:	621a      	str	r2, [r3, #32]
        goto out;
 8001c64:	e007      	b.n	8001c76 <__USART1_IRQHandler+0x6e>
    }

    while(1) {
        printf("huart1.Instance->ISR 0x%x\n",huart1.Instance->ISR);
 8001c66:	4b05      	ldr	r3, [pc, #20]	; (8001c7c <__USART1_IRQHandler+0x74>)
 8001c68:	681b      	ldr	r3, [r3, #0]
 8001c6a:	69db      	ldr	r3, [r3, #28]
 8001c6c:	4619      	mov	r1, r3
 8001c6e:	4806      	ldr	r0, [pc, #24]	; (8001c88 <__USART1_IRQHandler+0x80>)
 8001c70:	f00d fcc4 	bl	800f5fc <printf>
 8001c74:	e7f7      	b.n	8001c66 <__USART1_IRQHandler+0x5e>
    }
    out:
    return;
 8001c76:	bf00      	nop
}
 8001c78:	bd80      	pop	{r7, pc}
 8001c7a:	bf00      	nop
 8001c7c:	20003540 	.word	0x20003540
 8001c80:	20000748 	.word	0x20000748
 8001c84:	200035c4 	.word	0x200035c4
 8001c88:	0801ff90 	.word	0x0801ff90

08001c8c <UsartHwi>:


INT32 UsartHwi(VOID)
{
 8001c8c:	b580      	push	{r7, lr}
 8001c8e:	b082      	sub	sp, #8
 8001c90:	af02      	add	r7, sp, #8
    if (huart1.Instance == NULL) {
 8001c92:	4b17      	ldr	r3, [pc, #92]	; (8001cf0 <UsartHwi+0x64>)
 8001c94:	681b      	ldr	r3, [r3, #0]
 8001c96:	2b00      	cmp	r3, #0
 8001c98:	d101      	bne.n	8001c9e <UsartHwi+0x12>
        return LOS_NOK;
 8001c9a:	2301      	movs	r3, #1
 8001c9c:	e024      	b.n	8001ce8 <UsartHwi+0x5c>
    }
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8001c9e:	2025      	movs	r0, #37	; 0x25
 8001ca0:	f00b fd20 	bl	800d6e4 <HAL_NVIC_EnableIRQ>
    __HAL_UART_CLEAR_FLAG(&huart1, UART_FLAG_TC);
 8001ca4:	4b12      	ldr	r3, [pc, #72]	; (8001cf0 <UsartHwi+0x64>)
 8001ca6:	681b      	ldr	r3, [r3, #0]
 8001ca8:	2240      	movs	r2, #64	; 0x40
 8001caa:	621a      	str	r2, [r3, #32]
    (VOID)LOS_HwiCreate(NUM_HAL_INTERRUPT_UART, 0, 0, __USART1_IRQHandler, NULL);
 8001cac:	2300      	movs	r3, #0
 8001cae:	9300      	str	r3, [sp, #0]
 8001cb0:	4b10      	ldr	r3, [pc, #64]	; (8001cf4 <UsartHwi+0x68>)
 8001cb2:	2200      	movs	r2, #0
 8001cb4:	2100      	movs	r1, #0
 8001cb6:	2035      	movs	r0, #53	; 0x35
 8001cb8:	f000 fbf0 	bl	800249c <LOS_HwiCreate>
    HAL_NVIC_SetPriority(USART1_IRQn, 15, 0U);
 8001cbc:	2200      	movs	r2, #0
 8001cbe:	210f      	movs	r1, #15
 8001cc0:	2025      	movs	r0, #37	; 0x25
 8001cc2:	f00b fcf6 	bl	800d6b2 <HAL_NVIC_SetPriority>

    __HAL_UART_ENABLE_IT(&huart1,UART_IT_RXNE);//
 8001cc6:	4b0a      	ldr	r3, [pc, #40]	; (8001cf0 <UsartHwi+0x64>)
 8001cc8:	681b      	ldr	r3, [r3, #0]
 8001cca:	681a      	ldr	r2, [r3, #0]
 8001ccc:	4b08      	ldr	r3, [pc, #32]	; (8001cf0 <UsartHwi+0x64>)
 8001cce:	681b      	ldr	r3, [r3, #0]
 8001cd0:	f042 0220 	orr.w	r2, r2, #32
 8001cd4:	601a      	str	r2, [r3, #0]
    __HAL_UART_ENABLE_IT(&huart1,UART_IT_IDLE);//
 8001cd6:	4b06      	ldr	r3, [pc, #24]	; (8001cf0 <UsartHwi+0x64>)
 8001cd8:	681b      	ldr	r3, [r3, #0]
 8001cda:	681a      	ldr	r2, [r3, #0]
 8001cdc:	4b04      	ldr	r3, [pc, #16]	; (8001cf0 <UsartHwi+0x64>)
 8001cde:	681b      	ldr	r3, [r3, #0]
 8001ce0:	f042 0210 	orr.w	r2, r2, #16
 8001ce4:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 8001ce6:	2300      	movs	r3, #0
}
 8001ce8:	4618      	mov	r0, r3
 8001cea:	46bd      	mov	sp, r7
 8001cec:	bd80      	pop	{r7, pc}
 8001cee:	bf00      	nop
 8001cf0:	20003540 	.word	0x20003540
 8001cf4:	08001c09 	.word	0x08001c09

08001cf8 <Fire_DEBUG_GPIOB6_TRIGGER>:

	HAL_GPIO_WritePin(LED_BLUE_GPIO_PORT,LED_BLUE_PIN,!on);
}

void Fire_DEBUG_GPIOB6_TRIGGER(void)
{
 8001cf8:	b580      	push	{r7, lr}
 8001cfa:	af00      	add	r7, sp, #0
    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_6);
 8001cfc:	2140      	movs	r1, #64	; 0x40
 8001cfe:	4802      	ldr	r0, [pc, #8]	; (8001d08 <Fire_DEBUG_GPIOB6_TRIGGER+0x10>)
 8001d00:	f00b fecc 	bl	800da9c <HAL_GPIO_TogglePin>
}
 8001d04:	bf00      	nop
 8001d06:	bd80      	pop	{r7, pc}
 8001d08:	40020400 	.word	0x40020400

08001d0c <Fire_DEBUG_GPIOB7_TRIGGER>:

void Fire_DEBUG_GPIOB7_TRIGGER(void)
{
 8001d0c:	b580      	push	{r7, lr}
 8001d0e:	af00      	add	r7, sp, #0
    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_7);
 8001d10:	2180      	movs	r1, #128	; 0x80
 8001d12:	4802      	ldr	r0, [pc, #8]	; (8001d1c <Fire_DEBUG_GPIOB7_TRIGGER+0x10>)
 8001d14:	f00b fec2 	bl	800da9c <HAL_GPIO_TogglePin>
}
 8001d18:	bf00      	nop
 8001d1a:	bd80      	pop	{r7, pc}
 8001d1c:	40020400 	.word	0x40020400

08001d20 <Fire_DEBUG_GPIOB6>:
{
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, on);
}

void Fire_DEBUG_GPIOB6(int on)
{
 8001d20:	b580      	push	{r7, lr}
 8001d22:	b082      	sub	sp, #8
 8001d24:	af00      	add	r7, sp, #0
 8001d26:	6078      	str	r0, [r7, #4]
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, on);
 8001d28:	687b      	ldr	r3, [r7, #4]
 8001d2a:	461a      	mov	r2, r3
 8001d2c:	2140      	movs	r1, #64	; 0x40
 8001d2e:	4803      	ldr	r0, [pc, #12]	; (8001d3c <Fire_DEBUG_GPIOB6+0x1c>)
 8001d30:	f00b fe9c 	bl	800da6c <HAL_GPIO_WritePin>
}
 8001d34:	bf00      	nop
 8001d36:	3708      	adds	r7, #8
 8001d38:	46bd      	mov	sp, r7
 8001d3a:	bd80      	pop	{r7, pc}
 8001d3c:	40020400 	.word	0x40020400

08001d40 <Fire_DEBUG_GPIOB7>:

void Fire_DEBUG_GPIOB7(int on)
{
 8001d40:	b580      	push	{r7, lr}
 8001d42:	b082      	sub	sp, #8
 8001d44:	af00      	add	r7, sp, #0
 8001d46:	6078      	str	r0, [r7, #4]
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, on);
 8001d48:	687b      	ldr	r3, [r7, #4]
 8001d4a:	461a      	mov	r2, r3
 8001d4c:	2180      	movs	r1, #128	; 0x80
 8001d4e:	4803      	ldr	r0, [pc, #12]	; (8001d5c <Fire_DEBUG_GPIOB7+0x1c>)
 8001d50:	f00b fe8c 	bl	800da6c <HAL_GPIO_WritePin>
}
 8001d54:	bf00      	nop
 8001d56:	3708      	adds	r7, #8
 8001d58:	46bd      	mov	sp, r7
 8001d5a:	bd80      	pop	{r7, pc}
 8001d5c:	40020400 	.word	0x40020400

08001d60 <Error_Handler>:
{
 8001d60:	b580      	push	{r7, lr}
 8001d62:	af00      	add	r7, sp, #0
    _Error_Handler(__FILE__, __LINE__);
 8001d64:	213b      	movs	r1, #59	; 0x3b
 8001d66:	4802      	ldr	r0, [pc, #8]	; (8001d70 <Error_Handler+0x10>)
 8001d68:	f000 f813 	bl	8001d92 <_Error_Handler>
}
 8001d6c:	bf00      	nop
 8001d6e:	bd80      	pop	{r7, pc}
 8001d70:	0801ffac 	.word	0x0801ffac

08001d74 <HAL_GetTick>:
 * --------------------------------------------------------------------------- */

#include "sys_init.h"
#include "los_sys.h"

uint32_t HAL_GetTick(void) {
 8001d74:	b580      	push	{r7, lr}
 8001d76:	af00      	add	r7, sp, #0
#ifdef LOSCFG_PLATFORM_STM32F767_FIRE
    extern UINT64 Hal_STM32F767_Get_Timer_CNT(VOID);
    return Hal_STM32F767_Get_Timer_CNT()/1000;
 8001d78:	f7ff fdf4 	bl	8001964 <Hal_STM32F767_Get_Timer_CNT>
 8001d7c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001d80:	f04f 0300 	mov.w	r3, #0
 8001d84:	f7fe fe06 	bl	8000994 <__aeabi_uldivmod>
 8001d88:	4602      	mov	r2, r0
 8001d8a:	460b      	mov	r3, r1
 8001d8c:	4613      	mov	r3, r2
#else
    return (UINT32)LOS_TickCountGet();
#endif    
}
 8001d8e:	4618      	mov	r0, r3
 8001d90:	bd80      	pop	{r7, pc}

08001d92 <_Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  file: The file name as string.
  * @param  line: The line in file as a number.
  * @retval None
  */
void _Error_Handler(char const *file, int line) {
 8001d92:	b480      	push	{r7}
 8001d94:	b083      	sub	sp, #12
 8001d96:	af00      	add	r7, sp, #0
 8001d98:	6078      	str	r0, [r7, #4]
 8001d9a:	6039      	str	r1, [r7, #0]
    /* USER CODE BEGIN Error_Handler_Debug */
    /* User can add his own implementation to report the HAL error return state */
    (void)file;
    (void)line;
    while (1) {
 8001d9c:	e7fe      	b.n	8001d9c <_Error_Handler+0xa>
	...

08001da0 <SystemClock_Config>:

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void) {
 8001da0:	b580      	push	{r7, lr}
 8001da2:	b0ba      	sub	sp, #232	; 0xe8
 8001da4:	af00      	add	r7, sp, #0
 8001da6:	4b48      	ldr	r3, [pc, #288]	; (8001ec8 <SystemClock_Config+0x128>)
 8001da8:	681b      	ldr	r3, [r3, #0]
 8001daa:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8001dae:	f04f 0300 	mov.w	r3, #0
    RCC_OscInitTypeDef rccOscInitStruct = {0};
 8001db2:	f107 0320 	add.w	r3, r7, #32
 8001db6:	2234      	movs	r2, #52	; 0x34
 8001db8:	2100      	movs	r1, #0
 8001dba:	4618      	mov	r0, r3
 8001dbc:	f00c fd42 	bl	800e844 <memset>
    RCC_ClkInitTypeDef rccClkInitStruct = {0};
 8001dc0:	f107 030c 	add.w	r3, r7, #12
 8001dc4:	2200      	movs	r2, #0
 8001dc6:	601a      	str	r2, [r3, #0]
 8001dc8:	605a      	str	r2, [r3, #4]
 8001dca:	609a      	str	r2, [r3, #8]
 8001dcc:	60da      	str	r2, [r3, #12]
 8001dce:	611a      	str	r2, [r3, #16]
    RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001dd0:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8001dd4:	2290      	movs	r2, #144	; 0x90
 8001dd6:	2100      	movs	r1, #0
 8001dd8:	4618      	mov	r0, r3
 8001dda:	f00c fd33 	bl	800e844 <memset>

    /** Configure LSE Drive Capability
    */
    HAL_PWR_EnableBkUpAccess();
 8001dde:	f00b fb03 	bl	800d3e8 <HAL_PWR_EnableBkUpAccess>
    /** Configure the main internal regulator output voltage
    */
    __HAL_RCC_PWR_CLK_ENABLE();
 8001de2:	4b3a      	ldr	r3, [pc, #232]	; (8001ecc <SystemClock_Config+0x12c>)
 8001de4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001de6:	4a39      	ldr	r2, [pc, #228]	; (8001ecc <SystemClock_Config+0x12c>)
 8001de8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001dec:	6413      	str	r3, [r2, #64]	; 0x40
 8001dee:	4b37      	ldr	r3, [pc, #220]	; (8001ecc <SystemClock_Config+0x12c>)
 8001df0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001df2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001df6:	607b      	str	r3, [r7, #4]
 8001df8:	687b      	ldr	r3, [r7, #4]
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001dfa:	4b35      	ldr	r3, [pc, #212]	; (8001ed0 <SystemClock_Config+0x130>)
 8001dfc:	681b      	ldr	r3, [r3, #0]
 8001dfe:	4a34      	ldr	r2, [pc, #208]	; (8001ed0 <SystemClock_Config+0x130>)
 8001e00:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8001e04:	6013      	str	r3, [r2, #0]
 8001e06:	4b32      	ldr	r3, [pc, #200]	; (8001ed0 <SystemClock_Config+0x130>)
 8001e08:	681b      	ldr	r3, [r3, #0]
 8001e0a:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8001e0e:	60bb      	str	r3, [r7, #8]
 8001e10:	68bb      	ldr	r3, [r7, #8]
    /** Initializes the RCC Oscillators according to the specified parameters
    * in the RCC_OscInitTypeDef structure.
    */

    rccOscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001e12:	2301      	movs	r3, #1
 8001e14:	623b      	str	r3, [r7, #32]
    rccOscInitStruct.HSEState = RCC_HSE_ON;
 8001e16:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001e1a:	627b      	str	r3, [r7, #36]	; 0x24
    rccOscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001e1c:	2302      	movs	r3, #2
 8001e1e:	63bb      	str	r3, [r7, #56]	; 0x38
    rccOscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001e20:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8001e24:	63fb      	str	r3, [r7, #60]	; 0x3c
    rccOscInitStruct.PLL.PLLM = 25;// 4, Division factor for PLL VCO iput clock.
 8001e26:	2319      	movs	r3, #25
 8001e28:	643b      	str	r3, [r7, #64]	; 0x40
    rccOscInitStruct.PLL.PLLN = 432; // 216, Multiplication factor for PLL VCO output clock.
 8001e2a:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
 8001e2e:	647b      	str	r3, [r7, #68]	; 0x44
    rccOscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8001e30:	2302      	movs	r3, #2
 8001e32:	64bb      	str	r3, [r7, #72]	; 0x48
    rccOscInitStruct.PLL.PLLQ = 2; // 9, Division factor for
 8001e34:	2302      	movs	r3, #2
 8001e36:	64fb      	str	r3, [r7, #76]	; 0x4c
    rccOscInitStruct.PLL.PLLR = 2;
 8001e38:	2302      	movs	r3, #2
 8001e3a:	653b      	str	r3, [r7, #80]	; 0x50


    if (HAL_RCC_OscConfig(&rccOscInitStruct) != HAL_OK) {
 8001e3c:	f107 0320 	add.w	r3, r7, #32
 8001e40:	4618      	mov	r0, r3
 8001e42:	f00a fd95 	bl	800c970 <HAL_RCC_OscConfig>
 8001e46:	4603      	mov	r3, r0
 8001e48:	2b00      	cmp	r3, #0
 8001e4a:	d001      	beq.n	8001e50 <SystemClock_Config+0xb0>
        Error_Handler();
 8001e4c:	f7ff ff88 	bl	8001d60 <Error_Handler>
    }
    /** Activate the Over-Drive mode
    */
    if (HAL_PWREx_EnableOverDrive() != HAL_OK) {
 8001e50:	f00a fd3e 	bl	800c8d0 <HAL_PWREx_EnableOverDrive>
 8001e54:	4603      	mov	r3, r0
 8001e56:	2b00      	cmp	r3, #0
 8001e58:	d001      	beq.n	8001e5e <SystemClock_Config+0xbe>
        Error_Handler();
 8001e5a:	f7ff ff81 	bl	8001d60 <Error_Handler>
    }
    /** Initializes the CPU, AHB and APB buses clocks
    */
    rccClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
 8001e5e:	230f      	movs	r3, #15
 8001e60:	60fb      	str	r3, [r7, #12]
                                  | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
    rccClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8001e62:	2302      	movs	r3, #2
 8001e64:	613b      	str	r3, [r7, #16]
    rccClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001e66:	2300      	movs	r3, #0
 8001e68:	617b      	str	r3, [r7, #20]
    rccClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8001e6a:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8001e6e:	61bb      	str	r3, [r7, #24]
    rccClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8001e70:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001e74:	61fb      	str	r3, [r7, #28]

    if (HAL_RCC_ClockConfig(&rccClkInitStruct, FLASH_LATENCY_7) != HAL_OK) {
 8001e76:	f107 030c 	add.w	r3, r7, #12
 8001e7a:	2107      	movs	r1, #7
 8001e7c:	4618      	mov	r0, r3
 8001e7e:	f00b f825 	bl	800cecc <HAL_RCC_ClockConfig>
 8001e82:	4603      	mov	r3, r0
 8001e84:	2b00      	cmp	r3, #0
 8001e86:	d001      	beq.n	8001e8c <SystemClock_Config+0xec>
        Error_Handler();
 8001e88:	f7ff ff6a 	bl	8001d60 <Error_Handler>
    }

    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8001e8c:	2340      	movs	r3, #64	; 0x40
 8001e8e:	657b      	str	r3, [r7, #84]	; 0x54
    PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 8001e90:	2300      	movs	r3, #0
 8001e92:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001e96:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8001e9a:	4618      	mov	r0, r3
 8001e9c:	f009 fcec 	bl	800b878 <HAL_RCCEx_PeriphCLKConfig>
 8001ea0:	4603      	mov	r3, r0
 8001ea2:	2b00      	cmp	r3, #0
 8001ea4:	d001      	beq.n	8001eaa <SystemClock_Config+0x10a>
    {
        Error_Handler();
 8001ea6:	f7ff ff5b 	bl	8001d60 <Error_Handler>
    }
    /** Enables the Clock Security System
    */
    HAL_RCC_EnableCSS();
 8001eaa:	f00b f8fb 	bl	800d0a4 <HAL_RCC_EnableCSS>
}
 8001eae:	bf00      	nop
 8001eb0:	4b05      	ldr	r3, [pc, #20]	; (8001ec8 <SystemClock_Config+0x128>)
 8001eb2:	681a      	ldr	r2, [r3, #0]
 8001eb4:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8001eb8:	405a      	eors	r2, r3
 8001eba:	d001      	beq.n	8001ec0 <SystemClock_Config+0x120>
 8001ebc:	f002 fa94 	bl	80043e8 <__stack_chk_fail>
 8001ec0:	37e8      	adds	r7, #232	; 0xe8
 8001ec2:	46bd      	mov	sp, r7
 8001ec4:	bd80      	pop	{r7, pc}
 8001ec6:	bf00      	nop
 8001ec8:	08020008 	.word	0x08020008
 8001ecc:	40023800 	.word	0x40023800
 8001ed0:	40007000 	.word	0x40007000

08001ed4 <HAL_MspInit>:

void HAL_MspInit(void)
{
 8001ed4:	b480      	push	{r7}
 8001ed6:	b083      	sub	sp, #12
 8001ed8:	af00      	add	r7, sp, #0
    __HAL_RCC_PWR_CLK_ENABLE();
 8001eda:	4b0f      	ldr	r3, [pc, #60]	; (8001f18 <HAL_MspInit+0x44>)
 8001edc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001ede:	4a0e      	ldr	r2, [pc, #56]	; (8001f18 <HAL_MspInit+0x44>)
 8001ee0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001ee4:	6413      	str	r3, [r2, #64]	; 0x40
 8001ee6:	4b0c      	ldr	r3, [pc, #48]	; (8001f18 <HAL_MspInit+0x44>)
 8001ee8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001eea:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001eee:	603b      	str	r3, [r7, #0]
 8001ef0:	683b      	ldr	r3, [r7, #0]
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001ef2:	4b09      	ldr	r3, [pc, #36]	; (8001f18 <HAL_MspInit+0x44>)
 8001ef4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001ef6:	4a08      	ldr	r2, [pc, #32]	; (8001f18 <HAL_MspInit+0x44>)
 8001ef8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001efc:	6453      	str	r3, [r2, #68]	; 0x44
 8001efe:	4b06      	ldr	r3, [pc, #24]	; (8001f18 <HAL_MspInit+0x44>)
 8001f00:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001f02:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001f06:	607b      	str	r3, [r7, #4]
 8001f08:	687b      	ldr	r3, [r7, #4]
}
 8001f0a:	bf00      	nop
 8001f0c:	370c      	adds	r7, #12
 8001f0e:	46bd      	mov	sp, r7
 8001f10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f14:	4770      	bx	lr
 8001f16:	bf00      	nop
 8001f18:	40023800 	.word	0x40023800

08001f1c <ArchCurrCpuid>:

    return regMsp;
}

STATIC INLINE UINT32 ArchCurrCpuid(void)
{
 8001f1c:	b480      	push	{r7}
 8001f1e:	af00      	add	r7, sp, #0
    return 0;
 8001f20:	2300      	movs	r3, #0
}
 8001f22:	4618      	mov	r0, r3
 8001f24:	46bd      	mov	sp, r7
 8001f26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f2a:	4770      	bx	lr

08001f2c <LOS_IntLock>:
 * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_IntRestore
 * @since Huawei LiteOS V100R001C00
 */
STATIC INLINE UINT32 LOS_IntLock(VOID)
{
 8001f2c:	b580      	push	{r7, lr}
 8001f2e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8001f30:	f7fe feca 	bl	8000cc8 <ArchIntLock>
 8001f34:	4603      	mov	r3, r0
}
 8001f36:	4618      	mov	r0, r3
 8001f38:	bd80      	pop	{r7, pc}

08001f3a <LOS_IntRestore>:
 * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_IntLock
 * @since Huawei LiteOS V100R001C00
 */
STATIC INLINE VOID LOS_IntRestore(UINT32 intSave)
{
 8001f3a:	b580      	push	{r7, lr}
 8001f3c:	b082      	sub	sp, #8
 8001f3e:	af00      	add	r7, sp, #0
 8001f40:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8001f42:	6878      	ldr	r0, [r7, #4]
 8001f44:	f7fe fec8 	bl	8000cd8 <ArchIntRestore>
}
 8001f48:	bf00      	nop
 8001f4a:	3708      	adds	r7, #8
 8001f4c:	46bd      	mov	sp, r7
 8001f4e:	bd80      	pop	{r7, pc}

08001f50 <LOS_SpinLockSave>:
{
    (VOID)lock;
}

LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_SpinLockSave(SPIN_LOCK_S *lock, UINT32 *intSave)
{
 8001f50:	b580      	push	{r7, lr}
 8001f52:	b082      	sub	sp, #8
 8001f54:	af00      	add	r7, sp, #0
 8001f56:	6078      	str	r0, [r7, #4]
 8001f58:	6039      	str	r1, [r7, #0]
    (VOID)lock;
    *intSave = LOS_IntLock();
 8001f5a:	f7ff ffe7 	bl	8001f2c <LOS_IntLock>
 8001f5e:	4602      	mov	r2, r0
 8001f60:	683b      	ldr	r3, [r7, #0]
 8001f62:	601a      	str	r2, [r3, #0]
}
 8001f64:	bf00      	nop
 8001f66:	3708      	adds	r7, #8
 8001f68:	46bd      	mov	sp, r7
 8001f6a:	bd80      	pop	{r7, pc}

08001f6c <LOS_SpinUnlockRestore>:

LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_SpinUnlockRestore(SPIN_LOCK_S *lock, UINT32 intSave)
{
 8001f6c:	b580      	push	{r7, lr}
 8001f6e:	b082      	sub	sp, #8
 8001f70:	af00      	add	r7, sp, #0
 8001f72:	6078      	str	r0, [r7, #4]
 8001f74:	6039      	str	r1, [r7, #0]
    (VOID)lock;
    LOS_IntRestore(intSave);
 8001f76:	6838      	ldr	r0, [r7, #0]
 8001f78:	f7ff ffdf 	bl	8001f3a <LOS_IntRestore>
}
 8001f7c:	bf00      	nop
 8001f7e:	3708      	adds	r7, #8
 8001f80:	46bd      	mov	sp, r7
 8001f82:	bd80      	pop	{r7, pc}

08001f84 <OsIrqNestingActive>:

typedef VOID (*HWI_PROC_FUNC0)(VOID);
typedef VOID (*HWI_PROC_FUNC2)(INT32, VOID *);

STATIC INLINE VOID OsIrqNestingActive(UINT32 hwiNum)
{
 8001f84:	b480      	push	{r7}
 8001f86:	b083      	sub	sp, #12
 8001f88:	af00      	add	r7, sp, #0
 8001f8a:	6078      	str	r0, [r7, #4]
    /* preemption not allowed when handling tick interrupt */
    if (hwiNum != OS_TICK_INT_NUM) {
        (VOID)LOS_IntUnLock();
    }
#endif
}
 8001f8c:	bf00      	nop
 8001f8e:	370c      	adds	r7, #12
 8001f90:	46bd      	mov	sp, r7
 8001f92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f96:	4770      	bx	lr

08001f98 <OsIrqNestingInactive>:

STATIC INLINE VOID OsIrqNestingInactive(UINT32 hwiNum)
{
 8001f98:	b480      	push	{r7}
 8001f9a:	b083      	sub	sp, #12
 8001f9c:	af00      	add	r7, sp, #0
 8001f9e:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_ARCH_INTERRUPT_PREEMPTION
    if (hwiNum != OS_TICK_INT_NUM) {
        (VOID)LOS_IntLock();
    }
#endif
}
 8001fa0:	bf00      	nop
 8001fa2:	370c      	adds	r7, #12
 8001fa4:	46bd      	mov	sp, r7
 8001fa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001faa:	4770      	bx	lr

08001fac <InterruptHandle>:
{
    g_intCount[ArchCurrCpuid()] = val;
}

STATIC INLINE VOID InterruptHandle(HwiHandleInfo *hwiForm)
{
 8001fac:	b580      	push	{r7, lr}
 8001fae:	b086      	sub	sp, #24
 8001fb0:	af00      	add	r7, sp, #0
 8001fb2:	6078      	str	r0, [r7, #4]
    hwiForm->respCount++;
 8001fb4:	687b      	ldr	r3, [r7, #4]
 8001fb6:	68db      	ldr	r3, [r3, #12]
 8001fb8:	1c5a      	adds	r2, r3, #1
 8001fba:	687b      	ldr	r3, [r7, #4]
 8001fbc:	60da      	str	r2, [r3, #12]
#ifdef LOSCFG_SHARED_IRQ
    while (hwiForm->next != NULL) {
 8001fbe:	e022      	b.n	8002006 <InterruptHandle+0x5a>
        hwiForm = hwiForm->next;
 8001fc0:	687b      	ldr	r3, [r7, #4]
 8001fc2:	689b      	ldr	r3, [r3, #8]
 8001fc4:	607b      	str	r3, [r7, #4]
#endif
        if (hwiForm->registerInfo) {
 8001fc6:	687b      	ldr	r3, [r7, #4]
 8001fc8:	685b      	ldr	r3, [r3, #4]
 8001fca:	2b00      	cmp	r3, #0
 8001fcc:	d013      	beq.n	8001ff6 <InterruptHandle+0x4a>
            HWI_PROC_FUNC2 func = (HWI_PROC_FUNC2)hwiForm->hook;
 8001fce:	687b      	ldr	r3, [r7, #4]
 8001fd0:	681b      	ldr	r3, [r3, #0]
 8001fd2:	613b      	str	r3, [r7, #16]
            if (func != NULL) {
 8001fd4:	693b      	ldr	r3, [r7, #16]
 8001fd6:	2b00      	cmp	r3, #0
 8001fd8:	d015      	beq.n	8002006 <InterruptHandle+0x5a>
                UINTPTR *param = (UINTPTR *)(hwiForm->registerInfo);
 8001fda:	687b      	ldr	r3, [r7, #4]
 8001fdc:	685b      	ldr	r3, [r3, #4]
 8001fde:	617b      	str	r3, [r7, #20]
                func((INT32)(*param), (VOID *)(*(param + 1)));
 8001fe0:	697b      	ldr	r3, [r7, #20]
 8001fe2:	681b      	ldr	r3, [r3, #0]
 8001fe4:	461a      	mov	r2, r3
 8001fe6:	697b      	ldr	r3, [r7, #20]
 8001fe8:	3304      	adds	r3, #4
 8001fea:	681b      	ldr	r3, [r3, #0]
 8001fec:	4619      	mov	r1, r3
 8001fee:	693b      	ldr	r3, [r7, #16]
 8001ff0:	4610      	mov	r0, r2
 8001ff2:	4798      	blx	r3
 8001ff4:	e007      	b.n	8002006 <InterruptHandle+0x5a>
            }
        } else {
            HWI_PROC_FUNC0 func = (HWI_PROC_FUNC0)hwiForm->hook;
 8001ff6:	687b      	ldr	r3, [r7, #4]
 8001ff8:	681b      	ldr	r3, [r3, #0]
 8001ffa:	60fb      	str	r3, [r7, #12]
            if (func != NULL) {
 8001ffc:	68fb      	ldr	r3, [r7, #12]
 8001ffe:	2b00      	cmp	r3, #0
 8002000:	d001      	beq.n	8002006 <InterruptHandle+0x5a>
                func();
 8002002:	68fb      	ldr	r3, [r7, #12]
 8002004:	4798      	blx	r3
    while (hwiForm->next != NULL) {
 8002006:	687b      	ldr	r3, [r7, #4]
 8002008:	689b      	ldr	r3, [r3, #8]
 800200a:	2b00      	cmp	r3, #0
 800200c:	d1d8      	bne.n	8001fc0 <InterruptHandle+0x14>
            }
        }
#ifdef LOSCFG_SHARED_IRQ
    }
#endif
}
 800200e:	bf00      	nop
 8002010:	bf00      	nop
 8002012:	3718      	adds	r7, #24
 8002014:	46bd      	mov	sp, r7
 8002016:	bd80      	pop	{r7, pc}

08002018 <OsIntHandle>:

VOID OsIntHandle(UINT32 hwiNum, HwiHandleInfo *hwiForm)
{
 8002018:	b590      	push	{r4, r7, lr}
 800201a:	b089      	sub	sp, #36	; 0x24
 800201c:	af00      	add	r7, sp, #0
 800201e:	6078      	str	r0, [r7, #4]
 8002020:	6039      	str	r1, [r7, #0]
 8002022:	4b3d      	ldr	r3, [pc, #244]	; (8002118 <OsIntHandle+0x100>)
 8002024:	681b      	ldr	r3, [r3, #0]
 8002026:	61fb      	str	r3, [r7, #28]
 8002028:	f04f 0300 	mov.w	r3, #0
    size_t *intCnt = NULL;
 800202c:	2300      	movs	r3, #0
 800202e:	60bb      	str	r3, [r7, #8]

#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    OsCpupIrqStart();
 8002030:	f012 f9f2 	bl	8014418 <OsCpupIrqStart>
#endif
    intCnt = &g_intCount[ArchCurrCpuid()];
 8002034:	f7ff ff72 	bl	8001f1c <ArchCurrCpuid>
 8002038:	4603      	mov	r3, r0
 800203a:	009b      	lsls	r3, r3, #2
 800203c:	4a37      	ldr	r2, [pc, #220]	; (800211c <OsIntHandle+0x104>)
 800203e:	4413      	add	r3, r2
 8002040:	60bb      	str	r3, [r7, #8]
    *intCnt = *intCnt + 1;
 8002042:	68bb      	ldr	r3, [r7, #8]
 8002044:	681b      	ldr	r3, [r3, #0]
 8002046:	1c5a      	adds	r2, r3, #1
 8002048:	68bb      	ldr	r3, [r7, #8]
 800204a:	601a      	str	r2, [r3, #0]

#ifdef LOSCFG_DEBUG_SCHED_STATISTICS
    OsHwiStatistics(hwiNum);
 800204c:	6878      	ldr	r0, [r7, #4]
 800204e:	f004 fef3 	bl	8006e38 <OsHwiStatistics>
#endif

#ifdef LOSCFG_KERNEL_LOWPOWER
    if (g_intWakeupHook != NULL) {
 8002052:	4b33      	ldr	r3, [pc, #204]	; (8002120 <OsIntHandle+0x108>)
 8002054:	681b      	ldr	r3, [r3, #0]
 8002056:	2b00      	cmp	r3, #0
 8002058:	d003      	beq.n	8002062 <OsIntHandle+0x4a>
        g_intWakeupHook(hwiNum);
 800205a:	4b31      	ldr	r3, [pc, #196]	; (8002120 <OsIntHandle+0x108>)
 800205c:	681b      	ldr	r3, [r3, #0]
 800205e:	6878      	ldr	r0, [r7, #4]
 8002060:	4798      	blx	r3
    }
#endif
    LOS_TRACE(HWI_RESPONSE_IN, hwiNum);
 8002062:	2300      	movs	r3, #0
 8002064:	617b      	str	r3, [r7, #20]
 8002066:	687b      	ldr	r3, [r7, #4]
 8002068:	61bb      	str	r3, [r7, #24]
 800206a:	2302      	movs	r3, #2
 800206c:	60fb      	str	r3, [r7, #12]
 800206e:	68fb      	ldr	r3, [r7, #12]
 8002070:	2b01      	cmp	r3, #1
 8002072:	d915      	bls.n	80020a0 <OsIntHandle+0x88>
 8002074:	4b2b      	ldr	r3, [pc, #172]	; (8002124 <OsIntHandle+0x10c>)
 8002076:	681b      	ldr	r3, [r3, #0]
 8002078:	2b00      	cmp	r3, #0
 800207a:	d011      	beq.n	80020a0 <OsIntHandle+0x88>
 800207c:	4b29      	ldr	r3, [pc, #164]	; (8002124 <OsIntHandle+0x10c>)
 800207e:	681c      	ldr	r4, [r3, #0]
 8002080:	69b9      	ldr	r1, [r7, #24]
 8002082:	68fb      	ldr	r3, [r7, #12]
 8002084:	2b02      	cmp	r3, #2
 8002086:	d904      	bls.n	8002092 <OsIntHandle+0x7a>
 8002088:	f107 0314 	add.w	r3, r7, #20
 800208c:	f103 0208 	add.w	r2, r3, #8
 8002090:	e000      	b.n	8002094 <OsIntHandle+0x7c>
 8002092:	2200      	movs	r2, #0
 8002094:	68fb      	ldr	r3, [r7, #12]
 8002096:	b29b      	uxth	r3, r3
 8002098:	3b02      	subs	r3, #2
 800209a:	b29b      	uxth	r3, r3
 800209c:	2024      	movs	r0, #36	; 0x24
 800209e:	47a0      	blx	r4

    OsIrqNestingActive(hwiNum);
 80020a0:	6878      	ldr	r0, [r7, #4]
 80020a2:	f7ff ff6f 	bl	8001f84 <OsIrqNestingActive>
    InterruptHandle(hwiForm);
 80020a6:	6838      	ldr	r0, [r7, #0]
 80020a8:	f7ff ff80 	bl	8001fac <InterruptHandle>
    OsIrqNestingInactive(hwiNum);
 80020ac:	6878      	ldr	r0, [r7, #4]
 80020ae:	f7ff ff73 	bl	8001f98 <OsIrqNestingInactive>

    LOS_TRACE(HWI_RESPONSE_OUT, hwiNum);
 80020b2:	2300      	movs	r3, #0
 80020b4:	617b      	str	r3, [r7, #20]
 80020b6:	687b      	ldr	r3, [r7, #4]
 80020b8:	61bb      	str	r3, [r7, #24]
 80020ba:	2302      	movs	r3, #2
 80020bc:	613b      	str	r3, [r7, #16]
 80020be:	693b      	ldr	r3, [r7, #16]
 80020c0:	2b01      	cmp	r3, #1
 80020c2:	d915      	bls.n	80020f0 <OsIntHandle+0xd8>
 80020c4:	4b17      	ldr	r3, [pc, #92]	; (8002124 <OsIntHandle+0x10c>)
 80020c6:	681b      	ldr	r3, [r3, #0]
 80020c8:	2b00      	cmp	r3, #0
 80020ca:	d011      	beq.n	80020f0 <OsIntHandle+0xd8>
 80020cc:	4b15      	ldr	r3, [pc, #84]	; (8002124 <OsIntHandle+0x10c>)
 80020ce:	681c      	ldr	r4, [r3, #0]
 80020d0:	69b9      	ldr	r1, [r7, #24]
 80020d2:	693b      	ldr	r3, [r7, #16]
 80020d4:	2b02      	cmp	r3, #2
 80020d6:	d904      	bls.n	80020e2 <OsIntHandle+0xca>
 80020d8:	f107 0314 	add.w	r3, r7, #20
 80020dc:	f103 0208 	add.w	r2, r3, #8
 80020e0:	e000      	b.n	80020e4 <OsIntHandle+0xcc>
 80020e2:	2200      	movs	r2, #0
 80020e4:	693b      	ldr	r3, [r7, #16]
 80020e6:	b29b      	uxth	r3, r3
 80020e8:	3b02      	subs	r3, #2
 80020ea:	b29b      	uxth	r3, r3
 80020ec:	2025      	movs	r0, #37	; 0x25
 80020ee:	47a0      	blx	r4

    *intCnt = *intCnt - 1;
 80020f0:	68bb      	ldr	r3, [r7, #8]
 80020f2:	681b      	ldr	r3, [r3, #0]
 80020f4:	1e5a      	subs	r2, r3, #1
 80020f6:	68bb      	ldr	r3, [r7, #8]
 80020f8:	601a      	str	r2, [r3, #0]

#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    OsCpupIrqEnd(hwiNum);
 80020fa:	6878      	ldr	r0, [r7, #4]
 80020fc:	f012 f99e 	bl	801443c <OsCpupIrqEnd>
#endif
}
 8002100:	bf00      	nop
 8002102:	4b05      	ldr	r3, [pc, #20]	; (8002118 <OsIntHandle+0x100>)
 8002104:	681a      	ldr	r2, [r3, #0]
 8002106:	69fb      	ldr	r3, [r7, #28]
 8002108:	405a      	eors	r2, r3
 800210a:	d001      	beq.n	8002110 <OsIntHandle+0xf8>
 800210c:	f002 f96c 	bl	80043e8 <__stack_chk_fail>
 8002110:	3724      	adds	r7, #36	; 0x24
 8002112:	46bd      	mov	sp, r7
 8002114:	bd90      	pop	{r4, r7, pc}
 8002116:	bf00      	nop
 8002118:	0802000c 	.word	0x0802000c
 800211c:	20000750 	.word	0x20000750
 8002120:	20000754 	.word	0x20000754
 8002124:	2000075c 	.word	0x2000075c

08002128 <OsHwiCpIrqParam>:
    }
    return;
}

STATIC HWI_ARG_T OsHwiCpIrqParam(const HWI_IRQ_PARAM_S *irqParam)
{
 8002128:	b580      	push	{r7, lr}
 800212a:	b084      	sub	sp, #16
 800212c:	af00      	add	r7, sp, #0
 800212e:	6078      	str	r0, [r7, #4]
    HWI_IRQ_PARAM_S *paramByAlloc = NULL;
 8002130:	2300      	movs	r3, #0
 8002132:	60fb      	str	r3, [r7, #12]

    paramByAlloc = (HWI_IRQ_PARAM_S *)LOS_MemAlloc(m_aucSysMem0, sizeof(HWI_IRQ_PARAM_S));
 8002134:	4b0a      	ldr	r3, [pc, #40]	; (8002160 <OsHwiCpIrqParam+0x38>)
 8002136:	681b      	ldr	r3, [r3, #0]
 8002138:	210c      	movs	r1, #12
 800213a:	4618      	mov	r0, r3
 800213c:	f006 fc34 	bl	80089a8 <LOS_MemAlloc>
 8002140:	60f8      	str	r0, [r7, #12]
    if (paramByAlloc != NULL) {
 8002142:	68fb      	ldr	r3, [r7, #12]
 8002144:	2b00      	cmp	r3, #0
 8002146:	d005      	beq.n	8002154 <OsHwiCpIrqParam+0x2c>
        (VOID)memcpy_s(paramByAlloc, sizeof(HWI_IRQ_PARAM_S), irqParam, sizeof(HWI_IRQ_PARAM_S));
 8002148:	230c      	movs	r3, #12
 800214a:	687a      	ldr	r2, [r7, #4]
 800214c:	210c      	movs	r1, #12
 800214e:	68f8      	ldr	r0, [r7, #12]
 8002150:	f014 fa24 	bl	801659c <memcpy_s>
    }

    return (HWI_ARG_T)paramByAlloc;
 8002154:	68fb      	ldr	r3, [r7, #12]
}
 8002156:	4618      	mov	r0, r3
 8002158:	3710      	adds	r7, #16
 800215a:	46bd      	mov	sp, r7
 800215c:	bd80      	pop	{r7, pc}
 800215e:	bf00      	nop
 8002160:	200021b4 	.word	0x200021b4

08002164 <OsFreeHwiNode>:
    HWI_UNLOCK(intSave);
    return LOS_OK;
}
#else /* LOSCFG_SHARED_IRQ */
STATIC INLINE UINT32 OsFreeHwiNode(HwiHandleInfo *head, HwiHandleInfo *hwiForm, UINT32 irqId)
{
 8002164:	b580      	push	{r7, lr}
 8002166:	b086      	sub	sp, #24
 8002168:	af00      	add	r7, sp, #0
 800216a:	60f8      	str	r0, [r7, #12]
 800216c:	60b9      	str	r1, [r7, #8]
 800216e:	607a      	str	r2, [r7, #4]
    UINT32 ret = LOS_OK;
 8002170:	2300      	movs	r3, #0
 8002172:	617b      	str	r3, [r7, #20]

    if (hwiForm->registerInfo != (HWI_ARG_T)NULL) {
 8002174:	68bb      	ldr	r3, [r7, #8]
 8002176:	685b      	ldr	r3, [r3, #4]
 8002178:	2b00      	cmp	r3, #0
 800217a:	d007      	beq.n	800218c <OsFreeHwiNode+0x28>
        (VOID)LOS_MemFree(m_aucSysMem0, (VOID *)hwiForm->registerInfo);
 800217c:	4b15      	ldr	r3, [pc, #84]	; (80021d4 <OsFreeHwiNode+0x70>)
 800217e:	681a      	ldr	r2, [r3, #0]
 8002180:	68bb      	ldr	r3, [r7, #8]
 8002182:	685b      	ldr	r3, [r3, #4]
 8002184:	4619      	mov	r1, r3
 8002186:	4610      	mov	r0, r2
 8002188:	f006 fcc6 	bl	8008b18 <LOS_MemFree>
    }

    (VOID)LOS_MemFree(m_aucSysMem0, hwiForm);
 800218c:	4b11      	ldr	r3, [pc, #68]	; (80021d4 <OsFreeHwiNode+0x70>)
 800218e:	681b      	ldr	r3, [r3, #0]
 8002190:	68b9      	ldr	r1, [r7, #8]
 8002192:	4618      	mov	r0, r3
 8002194:	f006 fcc0 	bl	8008b18 <LOS_MemFree>

    if (head->next == NULL) {
 8002198:	68fb      	ldr	r3, [r7, #12]
 800219a:	689b      	ldr	r3, [r3, #8]
 800219c:	2b00      	cmp	r3, #0
 800219e:	d113      	bne.n	80021c8 <OsFreeHwiNode+0x64>
        head->shareMode = 0;
 80021a0:	68fb      	ldr	r3, [r7, #12]
 80021a2:	2200      	movs	r2, #0
 80021a4:	605a      	str	r2, [r3, #4]
        head->respCount = 0;
 80021a6:	68fb      	ldr	r3, [r7, #12]
 80021a8:	2200      	movs	r2, #0
 80021aa:	60da      	str	r2, [r3, #12]
        if (g_hwiOps->disableIrq == NULL) {
 80021ac:	4b0a      	ldr	r3, [pc, #40]	; (80021d8 <OsFreeHwiNode+0x74>)
 80021ae:	681b      	ldr	r3, [r3, #0]
 80021b0:	68db      	ldr	r3, [r3, #12]
 80021b2:	2b00      	cmp	r3, #0
 80021b4:	d103      	bne.n	80021be <OsFreeHwiNode+0x5a>
            ret = LOS_ERRNO_HWI_PROC_FUNC_NULL;
 80021b6:	4b09      	ldr	r3, [pc, #36]	; (80021dc <OsFreeHwiNode+0x78>)
 80021b8:	617b      	str	r3, [r7, #20]
            return ret;
 80021ba:	697b      	ldr	r3, [r7, #20]
 80021bc:	e005      	b.n	80021ca <OsFreeHwiNode+0x66>
        }
        g_hwiOps->disableIrq(irqId);
 80021be:	4b06      	ldr	r3, [pc, #24]	; (80021d8 <OsFreeHwiNode+0x74>)
 80021c0:	681b      	ldr	r3, [r3, #0]
 80021c2:	68db      	ldr	r3, [r3, #12]
 80021c4:	6878      	ldr	r0, [r7, #4]
 80021c6:	4798      	blx	r3
    }

    return ret;
 80021c8:	697b      	ldr	r3, [r7, #20]
}
 80021ca:	4618      	mov	r0, r3
 80021cc:	3718      	adds	r7, #24
 80021ce:	46bd      	mov	sp, r7
 80021d0:	bd80      	pop	{r7, pc}
 80021d2:	bf00      	nop
 80021d4:	200021b4 	.word	0x200021b4
 80021d8:	20000758 	.word	0x20000758
 80021dc:	02000901 	.word	0x02000901

080021e0 <OsHwiDel>:

STATIC UINT32 OsHwiDel(HwiHandleInfo *head, const HWI_IRQ_PARAM_S *irqParam, UINT32 irqId)
{
 80021e0:	b580      	push	{r7, lr}
 80021e2:	b08a      	sub	sp, #40	; 0x28
 80021e4:	af00      	add	r7, sp, #0
 80021e6:	60f8      	str	r0, [r7, #12]
 80021e8:	60b9      	str	r1, [r7, #8]
 80021ea:	607a      	str	r2, [r7, #4]
 80021ec:	4b41      	ldr	r3, [pc, #260]	; (80022f4 <OsHwiDel+0x114>)
 80021ee:	681b      	ldr	r3, [r3, #0]
 80021f0:	627b      	str	r3, [r7, #36]	; 0x24
 80021f2:	f04f 0300 	mov.w	r3, #0
    HwiHandleInfo *hwiFormPrev = NULL;
 80021f6:	2300      	movs	r3, #0
 80021f8:	61bb      	str	r3, [r7, #24]
    HwiHandleInfo *hwiForm = NULL;
 80021fa:	2300      	movs	r3, #0
 80021fc:	61fb      	str	r3, [r7, #28]
    UINT32 intSave;
    UINT32 ret;

    HWI_LOCK(intSave);
 80021fe:	f107 0314 	add.w	r3, r7, #20
 8002202:	4619      	mov	r1, r3
 8002204:	483c      	ldr	r0, [pc, #240]	; (80022f8 <OsHwiDel+0x118>)
 8002206:	f7ff fea3 	bl	8001f50 <LOS_SpinLockSave>

    if ((head->shareMode & IRQF_SHARED) && ((irqParam == NULL) || (irqParam->pDevId == NULL))) {
 800220a:	68fb      	ldr	r3, [r7, #12]
 800220c:	685b      	ldr	r3, [r3, #4]
 800220e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002212:	2b00      	cmp	r3, #0
 8002214:	d00d      	beq.n	8002232 <OsHwiDel+0x52>
 8002216:	68bb      	ldr	r3, [r7, #8]
 8002218:	2b00      	cmp	r3, #0
 800221a:	d003      	beq.n	8002224 <OsHwiDel+0x44>
 800221c:	68bb      	ldr	r3, [r7, #8]
 800221e:	685b      	ldr	r3, [r3, #4]
 8002220:	2b00      	cmp	r3, #0
 8002222:	d106      	bne.n	8002232 <OsHwiDel+0x52>
        HWI_UNLOCK(intSave);
 8002224:	697b      	ldr	r3, [r7, #20]
 8002226:	4619      	mov	r1, r3
 8002228:	4833      	ldr	r0, [pc, #204]	; (80022f8 <OsHwiDel+0x118>)
 800222a:	f7ff fe9f 	bl	8001f6c <LOS_SpinUnlockRestore>
        return LOS_ERRNO_HWI_SHARED_ERROR;
 800222e:	4b33      	ldr	r3, [pc, #204]	; (80022fc <OsHwiDel+0x11c>)
 8002230:	e054      	b.n	80022dc <OsHwiDel+0xfc>
    }

    /* Non-shared interrupt. */
    if (!(head->shareMode & IRQF_SHARED)) {
 8002232:	68fb      	ldr	r3, [r7, #12]
 8002234:	685b      	ldr	r3, [r3, #4]
 8002236:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800223a:	2b00      	cmp	r3, #0
 800223c:	d11d      	bne.n	800227a <OsHwiDel+0x9a>
        if (head->next == NULL) {
 800223e:	68fb      	ldr	r3, [r7, #12]
 8002240:	689b      	ldr	r3, [r3, #8]
 8002242:	2b00      	cmp	r3, #0
 8002244:	d106      	bne.n	8002254 <OsHwiDel+0x74>
            HWI_UNLOCK(intSave);
 8002246:	697b      	ldr	r3, [r7, #20]
 8002248:	4619      	mov	r1, r3
 800224a:	482b      	ldr	r0, [pc, #172]	; (80022f8 <OsHwiDel+0x118>)
 800224c:	f7ff fe8e 	bl	8001f6c <LOS_SpinUnlockRestore>
            return LOS_ERRNO_HWI_HWINUM_UNCREATE;
 8002250:	4b2b      	ldr	r3, [pc, #172]	; (8002300 <OsHwiDel+0x120>)
 8002252:	e043      	b.n	80022dc <OsHwiDel+0xfc>
        }

        hwiForm = head->next;
 8002254:	68fb      	ldr	r3, [r7, #12]
 8002256:	689b      	ldr	r3, [r3, #8]
 8002258:	61fb      	str	r3, [r7, #28]
        head->next = NULL;
 800225a:	68fb      	ldr	r3, [r7, #12]
 800225c:	2200      	movs	r2, #0
 800225e:	609a      	str	r2, [r3, #8]
        ret = OsFreeHwiNode(head, hwiForm, irqId);
 8002260:	687a      	ldr	r2, [r7, #4]
 8002262:	69f9      	ldr	r1, [r7, #28]
 8002264:	68f8      	ldr	r0, [r7, #12]
 8002266:	f7ff ff7d 	bl	8002164 <OsFreeHwiNode>
 800226a:	6238      	str	r0, [r7, #32]
        HWI_UNLOCK(intSave);
 800226c:	697b      	ldr	r3, [r7, #20]
 800226e:	4619      	mov	r1, r3
 8002270:	4821      	ldr	r0, [pc, #132]	; (80022f8 <OsHwiDel+0x118>)
 8002272:	f7ff fe7b 	bl	8001f6c <LOS_SpinUnlockRestore>
        return ret;
 8002276:	6a3b      	ldr	r3, [r7, #32]
 8002278:	e030      	b.n	80022dc <OsHwiDel+0xfc>
    }

    /* Shared interrupt. */
    hwiFormPrev = head;
 800227a:	68fb      	ldr	r3, [r7, #12]
 800227c:	61bb      	str	r3, [r7, #24]
    hwiForm = head->next;
 800227e:	68fb      	ldr	r3, [r7, #12]
 8002280:	689b      	ldr	r3, [r3, #8]
 8002282:	61fb      	str	r3, [r7, #28]
    while (hwiForm != NULL) {
 8002284:	e00b      	b.n	800229e <OsHwiDel+0xbe>
        if (((HWI_IRQ_PARAM_S *)(hwiForm->registerInfo))->pDevId == irqParam->pDevId) {
 8002286:	69fb      	ldr	r3, [r7, #28]
 8002288:	685b      	ldr	r3, [r3, #4]
 800228a:	685a      	ldr	r2, [r3, #4]
 800228c:	68bb      	ldr	r3, [r7, #8]
 800228e:	685b      	ldr	r3, [r3, #4]
 8002290:	429a      	cmp	r2, r3
 8002292:	d008      	beq.n	80022a6 <OsHwiDel+0xc6>
            break;
        }
        hwiFormPrev = hwiForm;
 8002294:	69fb      	ldr	r3, [r7, #28]
 8002296:	61bb      	str	r3, [r7, #24]
        hwiForm = hwiForm->next;
 8002298:	69fb      	ldr	r3, [r7, #28]
 800229a:	689b      	ldr	r3, [r3, #8]
 800229c:	61fb      	str	r3, [r7, #28]
    while (hwiForm != NULL) {
 800229e:	69fb      	ldr	r3, [r7, #28]
 80022a0:	2b00      	cmp	r3, #0
 80022a2:	d1f0      	bne.n	8002286 <OsHwiDel+0xa6>
 80022a4:	e000      	b.n	80022a8 <OsHwiDel+0xc8>
            break;
 80022a6:	bf00      	nop
    }

    if (hwiForm == NULL) {
 80022a8:	69fb      	ldr	r3, [r7, #28]
 80022aa:	2b00      	cmp	r3, #0
 80022ac:	d106      	bne.n	80022bc <OsHwiDel+0xdc>
        HWI_UNLOCK(intSave);
 80022ae:	697b      	ldr	r3, [r7, #20]
 80022b0:	4619      	mov	r1, r3
 80022b2:	4811      	ldr	r0, [pc, #68]	; (80022f8 <OsHwiDel+0x118>)
 80022b4:	f7ff fe5a 	bl	8001f6c <LOS_SpinUnlockRestore>
        return LOS_ERRNO_HWI_HWINUM_UNCREATE;
 80022b8:	4b11      	ldr	r3, [pc, #68]	; (8002300 <OsHwiDel+0x120>)
 80022ba:	e00f      	b.n	80022dc <OsHwiDel+0xfc>
    }

    hwiFormPrev->next = hwiForm->next;
 80022bc:	69fb      	ldr	r3, [r7, #28]
 80022be:	689a      	ldr	r2, [r3, #8]
 80022c0:	69bb      	ldr	r3, [r7, #24]
 80022c2:	609a      	str	r2, [r3, #8]
    ret = OsFreeHwiNode(head, hwiForm, irqId);
 80022c4:	687a      	ldr	r2, [r7, #4]
 80022c6:	69f9      	ldr	r1, [r7, #28]
 80022c8:	68f8      	ldr	r0, [r7, #12]
 80022ca:	f7ff ff4b 	bl	8002164 <OsFreeHwiNode>
 80022ce:	6238      	str	r0, [r7, #32]
    HWI_UNLOCK(intSave);
 80022d0:	697b      	ldr	r3, [r7, #20]
 80022d2:	4619      	mov	r1, r3
 80022d4:	4808      	ldr	r0, [pc, #32]	; (80022f8 <OsHwiDel+0x118>)
 80022d6:	f7ff fe49 	bl	8001f6c <LOS_SpinUnlockRestore>
    return ret;
 80022da:	6a3b      	ldr	r3, [r7, #32]
}
 80022dc:	4a05      	ldr	r2, [pc, #20]	; (80022f4 <OsHwiDel+0x114>)
 80022de:	6811      	ldr	r1, [r2, #0]
 80022e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80022e2:	4051      	eors	r1, r2
 80022e4:	d001      	beq.n	80022ea <OsHwiDel+0x10a>
 80022e6:	f002 f87f 	bl	80043e8 <__stack_chk_fail>
 80022ea:	4618      	mov	r0, r3
 80022ec:	3728      	adds	r7, #40	; 0x28
 80022ee:	46bd      	mov	sp, r7
 80022f0:	bd80      	pop	{r7, pc}
 80022f2:	bf00      	nop
 80022f4:	08020010 	.word	0x08020010
 80022f8:	2000074c 	.word	0x2000074c
 80022fc:	02000909 	.word	0x02000909
 8002300:	0200090b 	.word	0x0200090b

08002304 <OsHwiCreate>:

STATIC UINT32 OsHwiCreate(HwiHandleInfo *head, HWI_MODE_T hwiMode, HWI_PROC_FUNC hwiHandler,
                          const HWI_IRQ_PARAM_S *irqParam)
{
 8002304:	b580      	push	{r7, lr}
 8002306:	b08a      	sub	sp, #40	; 0x28
 8002308:	af00      	add	r7, sp, #0
 800230a:	60f8      	str	r0, [r7, #12]
 800230c:	607a      	str	r2, [r7, #4]
 800230e:	603b      	str	r3, [r7, #0]
 8002310:	460b      	mov	r3, r1
 8002312:	817b      	strh	r3, [r7, #10]
 8002314:	4b4f      	ldr	r3, [pc, #316]	; (8002454 <OsHwiCreate+0x150>)
 8002316:	681b      	ldr	r3, [r3, #0]
 8002318:	627b      	str	r3, [r7, #36]	; 0x24
 800231a:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    HwiHandleInfo *hwiFormNode = NULL;
 800231e:	2300      	movs	r3, #0
 8002320:	61fb      	str	r3, [r7, #28]
    HWI_IRQ_PARAM_S *hwiParam = NULL;
 8002322:	2300      	movs	r3, #0
 8002324:	623b      	str	r3, [r7, #32]
    HWI_MODE_T modeResult = hwiMode & IRQF_SHARED;
 8002326:	897b      	ldrh	r3, [r7, #10]
 8002328:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 800232c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8002330:	827b      	strh	r3, [r7, #18]
    HwiHandleInfo *hwiForm = NULL;
 8002332:	2300      	movs	r3, #0
 8002334:	61bb      	str	r3, [r7, #24]

    if (modeResult && ((irqParam == NULL) || (irqParam->pDevId == NULL))) {
 8002336:	8a7b      	ldrh	r3, [r7, #18]
 8002338:	2b00      	cmp	r3, #0
 800233a:	d008      	beq.n	800234e <OsHwiCreate+0x4a>
 800233c:	683b      	ldr	r3, [r7, #0]
 800233e:	2b00      	cmp	r3, #0
 8002340:	d003      	beq.n	800234a <OsHwiCreate+0x46>
 8002342:	683b      	ldr	r3, [r7, #0]
 8002344:	685b      	ldr	r3, [r3, #4]
 8002346:	2b00      	cmp	r3, #0
 8002348:	d101      	bne.n	800234e <OsHwiCreate+0x4a>
        return LOS_ERRNO_HWI_SHARED_ERROR;
 800234a:	4b43      	ldr	r3, [pc, #268]	; (8002458 <OsHwiCreate+0x154>)
 800234c:	e076      	b.n	800243c <OsHwiCreate+0x138>
    }

    HWI_LOCK(intSave);
 800234e:	f107 0314 	add.w	r3, r7, #20
 8002352:	4619      	mov	r1, r3
 8002354:	4841      	ldr	r0, [pc, #260]	; (800245c <OsHwiCreate+0x158>)
 8002356:	f7ff fdfb 	bl	8001f50 <LOS_SpinLockSave>

    if ((head->next != NULL) && ((modeResult == 0) || (!(head->shareMode & IRQF_SHARED)))) {
 800235a:	68fb      	ldr	r3, [r7, #12]
 800235c:	689b      	ldr	r3, [r3, #8]
 800235e:	2b00      	cmp	r3, #0
 8002360:	d00f      	beq.n	8002382 <OsHwiCreate+0x7e>
 8002362:	8a7b      	ldrh	r3, [r7, #18]
 8002364:	2b00      	cmp	r3, #0
 8002366:	d005      	beq.n	8002374 <OsHwiCreate+0x70>
 8002368:	68fb      	ldr	r3, [r7, #12]
 800236a:	685b      	ldr	r3, [r3, #4]
 800236c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002370:	2b00      	cmp	r3, #0
 8002372:	d106      	bne.n	8002382 <OsHwiCreate+0x7e>
        HWI_UNLOCK(intSave);
 8002374:	697b      	ldr	r3, [r7, #20]
 8002376:	4619      	mov	r1, r3
 8002378:	4838      	ldr	r0, [pc, #224]	; (800245c <OsHwiCreate+0x158>)
 800237a:	f7ff fdf7 	bl	8001f6c <LOS_SpinUnlockRestore>
        return LOS_ERRNO_HWI_SHARED_ERROR;
 800237e:	4b36      	ldr	r3, [pc, #216]	; (8002458 <OsHwiCreate+0x154>)
 8002380:	e05c      	b.n	800243c <OsHwiCreate+0x138>
    }

    hwiForm = head;
 8002382:	68fb      	ldr	r3, [r7, #12]
 8002384:	61bb      	str	r3, [r7, #24]
    while (hwiForm->next != NULL) {
 8002386:	e012      	b.n	80023ae <OsHwiCreate+0xaa>
        hwiForm = hwiForm->next;
 8002388:	69bb      	ldr	r3, [r7, #24]
 800238a:	689b      	ldr	r3, [r3, #8]
 800238c:	61bb      	str	r3, [r7, #24]
        hwiParam = (HWI_IRQ_PARAM_S *)(hwiForm->registerInfo);
 800238e:	69bb      	ldr	r3, [r7, #24]
 8002390:	685b      	ldr	r3, [r3, #4]
 8002392:	623b      	str	r3, [r7, #32]
        if (hwiParam->pDevId == irqParam->pDevId) {
 8002394:	6a3b      	ldr	r3, [r7, #32]
 8002396:	685a      	ldr	r2, [r3, #4]
 8002398:	683b      	ldr	r3, [r7, #0]
 800239a:	685b      	ldr	r3, [r3, #4]
 800239c:	429a      	cmp	r2, r3
 800239e:	d106      	bne.n	80023ae <OsHwiCreate+0xaa>
            HWI_UNLOCK(intSave);
 80023a0:	697b      	ldr	r3, [r7, #20]
 80023a2:	4619      	mov	r1, r3
 80023a4:	482d      	ldr	r0, [pc, #180]	; (800245c <OsHwiCreate+0x158>)
 80023a6:	f7ff fde1 	bl	8001f6c <LOS_SpinUnlockRestore>
            return LOS_ERRNO_HWI_ALREADY_CREATED;
 80023aa:	4b2d      	ldr	r3, [pc, #180]	; (8002460 <OsHwiCreate+0x15c>)
 80023ac:	e046      	b.n	800243c <OsHwiCreate+0x138>
    while (hwiForm->next != NULL) {
 80023ae:	69bb      	ldr	r3, [r7, #24]
 80023b0:	689b      	ldr	r3, [r3, #8]
 80023b2:	2b00      	cmp	r3, #0
 80023b4:	d1e8      	bne.n	8002388 <OsHwiCreate+0x84>
        }
    }

    hwiFormNode = (HwiHandleInfo *)LOS_MemAlloc(m_aucSysMem0, sizeof(HwiHandleInfo));
 80023b6:	4b2b      	ldr	r3, [pc, #172]	; (8002464 <OsHwiCreate+0x160>)
 80023b8:	681b      	ldr	r3, [r3, #0]
 80023ba:	2110      	movs	r1, #16
 80023bc:	4618      	mov	r0, r3
 80023be:	f006 faf3 	bl	80089a8 <LOS_MemAlloc>
 80023c2:	61f8      	str	r0, [r7, #28]
    if (hwiFormNode == NULL) {
 80023c4:	69fb      	ldr	r3, [r7, #28]
 80023c6:	2b00      	cmp	r3, #0
 80023c8:	d106      	bne.n	80023d8 <OsHwiCreate+0xd4>
        HWI_UNLOCK(intSave);
 80023ca:	697b      	ldr	r3, [r7, #20]
 80023cc:	4619      	mov	r1, r3
 80023ce:	4823      	ldr	r0, [pc, #140]	; (800245c <OsHwiCreate+0x158>)
 80023d0:	f7ff fdcc 	bl	8001f6c <LOS_SpinUnlockRestore>
        return LOS_ERRNO_HWI_NO_MEMORY;
 80023d4:	4b24      	ldr	r3, [pc, #144]	; (8002468 <OsHwiCreate+0x164>)
 80023d6:	e031      	b.n	800243c <OsHwiCreate+0x138>
    }
    hwiForm->respCount = 0;
 80023d8:	69bb      	ldr	r3, [r7, #24]
 80023da:	2200      	movs	r2, #0
 80023dc:	60da      	str	r2, [r3, #12]

    if (irqParam != NULL) {
 80023de:	683b      	ldr	r3, [r7, #0]
 80023e0:	2b00      	cmp	r3, #0
 80023e2:	d016      	beq.n	8002412 <OsHwiCreate+0x10e>
        hwiFormNode->registerInfo = OsHwiCpIrqParam(irqParam);
 80023e4:	6838      	ldr	r0, [r7, #0]
 80023e6:	f7ff fe9f 	bl	8002128 <OsHwiCpIrqParam>
 80023ea:	4602      	mov	r2, r0
 80023ec:	69fb      	ldr	r3, [r7, #28]
 80023ee:	605a      	str	r2, [r3, #4]
        if (hwiFormNode->registerInfo == (HWI_ARG_T)NULL) {
 80023f0:	69fb      	ldr	r3, [r7, #28]
 80023f2:	685b      	ldr	r3, [r3, #4]
 80023f4:	2b00      	cmp	r3, #0
 80023f6:	d10f      	bne.n	8002418 <OsHwiCreate+0x114>
            HWI_UNLOCK(intSave);
 80023f8:	697b      	ldr	r3, [r7, #20]
 80023fa:	4619      	mov	r1, r3
 80023fc:	4817      	ldr	r0, [pc, #92]	; (800245c <OsHwiCreate+0x158>)
 80023fe:	f7ff fdb5 	bl	8001f6c <LOS_SpinUnlockRestore>
            (VOID) LOS_MemFree(m_aucSysMem0, hwiFormNode);
 8002402:	4b18      	ldr	r3, [pc, #96]	; (8002464 <OsHwiCreate+0x160>)
 8002404:	681b      	ldr	r3, [r3, #0]
 8002406:	69f9      	ldr	r1, [r7, #28]
 8002408:	4618      	mov	r0, r3
 800240a:	f006 fb85 	bl	8008b18 <LOS_MemFree>
            return LOS_ERRNO_HWI_NO_MEMORY;
 800240e:	4b16      	ldr	r3, [pc, #88]	; (8002468 <OsHwiCreate+0x164>)
 8002410:	e014      	b.n	800243c <OsHwiCreate+0x138>
        }
    } else {
        hwiFormNode->registerInfo = 0;
 8002412:	69fb      	ldr	r3, [r7, #28]
 8002414:	2200      	movs	r2, #0
 8002416:	605a      	str	r2, [r3, #4]
    }

    hwiFormNode->hook = hwiHandler;
 8002418:	69fb      	ldr	r3, [r7, #28]
 800241a:	687a      	ldr	r2, [r7, #4]
 800241c:	601a      	str	r2, [r3, #0]
    hwiFormNode->next = (struct tagHwiHandleForm *)NULL;
 800241e:	69fb      	ldr	r3, [r7, #28]
 8002420:	2200      	movs	r2, #0
 8002422:	609a      	str	r2, [r3, #8]
    hwiForm->next = hwiFormNode;
 8002424:	69bb      	ldr	r3, [r7, #24]
 8002426:	69fa      	ldr	r2, [r7, #28]
 8002428:	609a      	str	r2, [r3, #8]

    head->shareMode = modeResult;
 800242a:	8a7a      	ldrh	r2, [r7, #18]
 800242c:	68fb      	ldr	r3, [r7, #12]
 800242e:	605a      	str	r2, [r3, #4]

    HWI_UNLOCK(intSave);
 8002430:	697b      	ldr	r3, [r7, #20]
 8002432:	4619      	mov	r1, r3
 8002434:	4809      	ldr	r0, [pc, #36]	; (800245c <OsHwiCreate+0x158>)
 8002436:	f7ff fd99 	bl	8001f6c <LOS_SpinUnlockRestore>
    return LOS_OK;
 800243a:	2300      	movs	r3, #0
}
 800243c:	4a05      	ldr	r2, [pc, #20]	; (8002454 <OsHwiCreate+0x150>)
 800243e:	6811      	ldr	r1, [r2, #0]
 8002440:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002442:	4051      	eors	r1, r2
 8002444:	d001      	beq.n	800244a <OsHwiCreate+0x146>
 8002446:	f001 ffcf 	bl	80043e8 <__stack_chk_fail>
 800244a:	4618      	mov	r0, r3
 800244c:	3728      	adds	r7, #40	; 0x28
 800244e:	46bd      	mov	sp, r7
 8002450:	bd80      	pop	{r7, pc}
 8002452:	bf00      	nop
 8002454:	08020014 	.word	0x08020014
 8002458:	02000909 	.word	0x02000909
 800245c:	2000074c 	.word	0x2000074c
 8002460:	02000904 	.word	0x02000904
 8002464:	200021b4 	.word	0x200021b4
 8002468:	02000903 	.word	0x02000903

0800246c <IntActive>:
#endif

size_t IntActive()
{
 800246c:	b580      	push	{r7, lr}
 800246e:	b082      	sub	sp, #8
 8002470:	af00      	add	r7, sp, #0
    size_t intCount;
    UINT32 intSave = LOS_IntLock();
 8002472:	f7ff fd5b 	bl	8001f2c <LOS_IntLock>
 8002476:	6038      	str	r0, [r7, #0]

    intCount = g_intCount[ArchCurrCpuid()];
 8002478:	f7ff fd50 	bl	8001f1c <ArchCurrCpuid>
 800247c:	4603      	mov	r3, r0
 800247e:	4a06      	ldr	r2, [pc, #24]	; (8002498 <IntActive+0x2c>)
 8002480:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002484:	607b      	str	r3, [r7, #4]
    LOS_IntRestore(intSave);
 8002486:	6838      	ldr	r0, [r7, #0]
 8002488:	f7ff fd57 	bl	8001f3a <LOS_IntRestore>
    return intCount;
 800248c:	687b      	ldr	r3, [r7, #4]
}
 800248e:	4618      	mov	r0, r3
 8002490:	3708      	adds	r7, #8
 8002492:	46bd      	mov	sp, r7
 8002494:	bd80      	pop	{r7, pc}
 8002496:	bf00      	nop
 8002498:	20000750 	.word	0x20000750

0800249c <LOS_HwiCreate>:
LITE_OS_SEC_TEXT UINT32 LOS_HwiCreate(HWI_HANDLE_T hwiNum,
                                           HWI_PRIOR_T hwiPrio,
                                           HWI_MODE_T hwiMode,
                                           HWI_PROC_FUNC hwiHandler,
                                           HWI_IRQ_PARAM_S *irqParam)
{
 800249c:	b590      	push	{r4, r7, lr}
 800249e:	b08f      	sub	sp, #60	; 0x3c
 80024a0:	af00      	add	r7, sp, #0
 80024a2:	60f8      	str	r0, [r7, #12]
 80024a4:	607b      	str	r3, [r7, #4]
 80024a6:	460b      	mov	r3, r1
 80024a8:	817b      	strh	r3, [r7, #10]
 80024aa:	4613      	mov	r3, r2
 80024ac:	813b      	strh	r3, [r7, #8]
 80024ae:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80024b0:	603b      	str	r3, [r7, #0]
 80024b2:	4b4e      	ldr	r3, [pc, #312]	; (80025ec <LOS_HwiCreate+0x150>)
 80024b4:	681b      	ldr	r3, [r3, #0]
 80024b6:	637b      	str	r3, [r7, #52]	; 0x34
 80024b8:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    HwiHandleInfo *hwiForm = NULL;
 80024bc:	2300      	movs	r3, #0
 80024be:	617b      	str	r3, [r7, #20]

    if (hwiHandler == NULL) {
 80024c0:	687b      	ldr	r3, [r7, #4]
 80024c2:	2b00      	cmp	r3, #0
 80024c4:	d101      	bne.n	80024ca <LOS_HwiCreate+0x2e>
        return LOS_ERRNO_HWI_PROC_FUNC_NULL;
 80024c6:	4b4a      	ldr	r3, [pc, #296]	; (80025f0 <LOS_HwiCreate+0x154>)
 80024c8:	e084      	b.n	80025d4 <LOS_HwiCreate+0x138>
    }

    if ((g_hwiOps == NULL) || (g_hwiOps->getHandleForm == NULL)) {
 80024ca:	4b4a      	ldr	r3, [pc, #296]	; (80025f4 <LOS_HwiCreate+0x158>)
 80024cc:	681b      	ldr	r3, [r3, #0]
 80024ce:	2b00      	cmp	r3, #0
 80024d0:	d004      	beq.n	80024dc <LOS_HwiCreate+0x40>
 80024d2:	4b48      	ldr	r3, [pc, #288]	; (80025f4 <LOS_HwiCreate+0x158>)
 80024d4:	681b      	ldr	r3, [r3, #0]
 80024d6:	69db      	ldr	r3, [r3, #28]
 80024d8:	2b00      	cmp	r3, #0
 80024da:	d101      	bne.n	80024e0 <LOS_HwiCreate+0x44>
        return LOS_ERRNO_HWI_PROC_FUNC_NULL;
 80024dc:	4b44      	ldr	r3, [pc, #272]	; (80025f0 <LOS_HwiCreate+0x154>)
 80024de:	e079      	b.n	80025d4 <LOS_HwiCreate+0x138>
    }

    hwiForm = g_hwiOps->getHandleForm(hwiNum);
 80024e0:	4b44      	ldr	r3, [pc, #272]	; (80025f4 <LOS_HwiCreate+0x158>)
 80024e2:	681b      	ldr	r3, [r3, #0]
 80024e4:	69db      	ldr	r3, [r3, #28]
 80024e6:	68f8      	ldr	r0, [r7, #12]
 80024e8:	4798      	blx	r3
 80024ea:	6178      	str	r0, [r7, #20]
    if (hwiForm == NULL) {
 80024ec:	697b      	ldr	r3, [r7, #20]
 80024ee:	2b00      	cmp	r3, #0
 80024f0:	d101      	bne.n	80024f6 <LOS_HwiCreate+0x5a>
        return LOS_ERRNO_HWI_NUM_INVALID;
 80024f2:	4b41      	ldr	r3, [pc, #260]	; (80025f8 <LOS_HwiCreate+0x15c>)
 80024f4:	e06e      	b.n	80025d4 <LOS_HwiCreate+0x138>
    }
    LOS_TRACE(HWI_CREATE, hwiNum, hwiPrio, hwiMode, (UINTPTR)hwiHandler);
 80024f6:	2300      	movs	r3, #0
 80024f8:	623b      	str	r3, [r7, #32]
 80024fa:	68fb      	ldr	r3, [r7, #12]
 80024fc:	627b      	str	r3, [r7, #36]	; 0x24
 80024fe:	897b      	ldrh	r3, [r7, #10]
 8002500:	62bb      	str	r3, [r7, #40]	; 0x28
 8002502:	893b      	ldrh	r3, [r7, #8]
 8002504:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002506:	687b      	ldr	r3, [r7, #4]
 8002508:	633b      	str	r3, [r7, #48]	; 0x30
 800250a:	2305      	movs	r3, #5
 800250c:	61bb      	str	r3, [r7, #24]
 800250e:	69bb      	ldr	r3, [r7, #24]
 8002510:	2b01      	cmp	r3, #1
 8002512:	d915      	bls.n	8002540 <LOS_HwiCreate+0xa4>
 8002514:	4b39      	ldr	r3, [pc, #228]	; (80025fc <LOS_HwiCreate+0x160>)
 8002516:	681b      	ldr	r3, [r3, #0]
 8002518:	2b00      	cmp	r3, #0
 800251a:	d011      	beq.n	8002540 <LOS_HwiCreate+0xa4>
 800251c:	4b37      	ldr	r3, [pc, #220]	; (80025fc <LOS_HwiCreate+0x160>)
 800251e:	681c      	ldr	r4, [r3, #0]
 8002520:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8002522:	69bb      	ldr	r3, [r7, #24]
 8002524:	2b02      	cmp	r3, #2
 8002526:	d904      	bls.n	8002532 <LOS_HwiCreate+0x96>
 8002528:	f107 0320 	add.w	r3, r7, #32
 800252c:	f103 0208 	add.w	r2, r3, #8
 8002530:	e000      	b.n	8002534 <LOS_HwiCreate+0x98>
 8002532:	2200      	movs	r2, #0
 8002534:	69bb      	ldr	r3, [r7, #24]
 8002536:	b29b      	uxth	r3, r3
 8002538:	3b02      	subs	r3, #2
 800253a:	b29b      	uxth	r3, r3
 800253c:	2020      	movs	r0, #32
 800253e:	47a0      	blx	r4

    ret = OsHwiCreate(hwiForm, hwiMode, hwiHandler, irqParam);
 8002540:	8939      	ldrh	r1, [r7, #8]
 8002542:	683b      	ldr	r3, [r7, #0]
 8002544:	687a      	ldr	r2, [r7, #4]
 8002546:	6978      	ldr	r0, [r7, #20]
 8002548:	f7ff fedc 	bl	8002304 <OsHwiCreate>
 800254c:	6138      	str	r0, [r7, #16]
    LOS_TRACE(HWI_CREATE_SHARE, hwiNum, (UINTPTR)(irqParam != NULL ? irqParam->pDevId : NULL), ret);
 800254e:	2300      	movs	r3, #0
 8002550:	623b      	str	r3, [r7, #32]
 8002552:	68fb      	ldr	r3, [r7, #12]
 8002554:	627b      	str	r3, [r7, #36]	; 0x24
 8002556:	683b      	ldr	r3, [r7, #0]
 8002558:	2b00      	cmp	r3, #0
 800255a:	d002      	beq.n	8002562 <LOS_HwiCreate+0xc6>
 800255c:	683b      	ldr	r3, [r7, #0]
 800255e:	685b      	ldr	r3, [r3, #4]
 8002560:	e000      	b.n	8002564 <LOS_HwiCreate+0xc8>
 8002562:	2300      	movs	r3, #0
 8002564:	62bb      	str	r3, [r7, #40]	; 0x28
 8002566:	693b      	ldr	r3, [r7, #16]
 8002568:	62fb      	str	r3, [r7, #44]	; 0x2c
 800256a:	2304      	movs	r3, #4
 800256c:	61fb      	str	r3, [r7, #28]
 800256e:	69fb      	ldr	r3, [r7, #28]
 8002570:	2b01      	cmp	r3, #1
 8002572:	d915      	bls.n	80025a0 <LOS_HwiCreate+0x104>
 8002574:	4b21      	ldr	r3, [pc, #132]	; (80025fc <LOS_HwiCreate+0x160>)
 8002576:	681b      	ldr	r3, [r3, #0]
 8002578:	2b00      	cmp	r3, #0
 800257a:	d011      	beq.n	80025a0 <LOS_HwiCreate+0x104>
 800257c:	4b1f      	ldr	r3, [pc, #124]	; (80025fc <LOS_HwiCreate+0x160>)
 800257e:	681c      	ldr	r4, [r3, #0]
 8002580:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8002582:	69fb      	ldr	r3, [r7, #28]
 8002584:	2b02      	cmp	r3, #2
 8002586:	d904      	bls.n	8002592 <LOS_HwiCreate+0xf6>
 8002588:	f107 0320 	add.w	r3, r7, #32
 800258c:	f103 0208 	add.w	r2, r3, #8
 8002590:	e000      	b.n	8002594 <LOS_HwiCreate+0xf8>
 8002592:	2200      	movs	r2, #0
 8002594:	69fb      	ldr	r3, [r7, #28]
 8002596:	b29b      	uxth	r3, r3
 8002598:	3b02      	subs	r3, #2
 800259a:	b29b      	uxth	r3, r3
 800259c:	2021      	movs	r0, #33	; 0x21
 800259e:	47a0      	blx	r4

    /* priority will be changed if setIrqPriority implemented,
     * but interrupt preemption only allowed when LOSCFG_ARCH_INTERRUPT_PREEMPTION enable */
    if ((ret == LOS_OK) && (g_hwiOps->setIrqPriority != NULL)) {
 80025a0:	693b      	ldr	r3, [r7, #16]
 80025a2:	2b00      	cmp	r3, #0
 80025a4:	d115      	bne.n	80025d2 <LOS_HwiCreate+0x136>
 80025a6:	4b13      	ldr	r3, [pc, #76]	; (80025f4 <LOS_HwiCreate+0x158>)
 80025a8:	681b      	ldr	r3, [r3, #0]
 80025aa:	691b      	ldr	r3, [r3, #16]
 80025ac:	2b00      	cmp	r3, #0
 80025ae:	d010      	beq.n	80025d2 <LOS_HwiCreate+0x136>
        ret = g_hwiOps->setIrqPriority(hwiNum, hwiPrio);
 80025b0:	4b10      	ldr	r3, [pc, #64]	; (80025f4 <LOS_HwiCreate+0x158>)
 80025b2:	681b      	ldr	r3, [r3, #0]
 80025b4:	691b      	ldr	r3, [r3, #16]
 80025b6:	897a      	ldrh	r2, [r7, #10]
 80025b8:	b2d2      	uxtb	r2, r2
 80025ba:	4611      	mov	r1, r2
 80025bc:	68f8      	ldr	r0, [r7, #12]
 80025be:	4798      	blx	r3
 80025c0:	6138      	str	r0, [r7, #16]
        if (ret != LOS_OK) {
 80025c2:	693b      	ldr	r3, [r7, #16]
 80025c4:	2b00      	cmp	r3, #0
 80025c6:	d004      	beq.n	80025d2 <LOS_HwiCreate+0x136>
            (VOID)OsHwiDel(hwiForm, irqParam, hwiNum);
 80025c8:	68fa      	ldr	r2, [r7, #12]
 80025ca:	6839      	ldr	r1, [r7, #0]
 80025cc:	6978      	ldr	r0, [r7, #20]
 80025ce:	f7ff fe07 	bl	80021e0 <OsHwiDel>
        }
    }
    return ret;
 80025d2:	693b      	ldr	r3, [r7, #16]
}
 80025d4:	4a05      	ldr	r2, [pc, #20]	; (80025ec <LOS_HwiCreate+0x150>)
 80025d6:	6811      	ldr	r1, [r2, #0]
 80025d8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80025da:	4051      	eors	r1, r2
 80025dc:	d001      	beq.n	80025e2 <LOS_HwiCreate+0x146>
 80025de:	f001 ff03 	bl	80043e8 <__stack_chk_fail>
 80025e2:	4618      	mov	r0, r3
 80025e4:	373c      	adds	r7, #60	; 0x3c
 80025e6:	46bd      	mov	sp, r7
 80025e8:	bd90      	pop	{r4, r7, pc}
 80025ea:	bf00      	nop
 80025ec:	08020018 	.word	0x08020018
 80025f0:	02000901 	.word	0x02000901
 80025f4:	20000758 	.word	0x20000758
 80025f8:	02000900 	.word	0x02000900
 80025fc:	2000075c 	.word	0x2000075c

08002600 <LOS_HwiEnable>:

    return g_hwiOps->triggerIrq(hwiNum);
}

LITE_OS_SEC_TEXT UINT32 LOS_HwiEnable(HWI_HANDLE_T hwiNum)
{
 8002600:	b590      	push	{r4, r7, lr}
 8002602:	b087      	sub	sp, #28
 8002604:	af00      	add	r7, sp, #0
 8002606:	6078      	str	r0, [r7, #4]
 8002608:	4b1f      	ldr	r3, [pc, #124]	; (8002688 <LOS_HwiEnable+0x88>)
 800260a:	681b      	ldr	r3, [r3, #0]
 800260c:	617b      	str	r3, [r7, #20]
 800260e:	f04f 0300 	mov.w	r3, #0
    if ((g_hwiOps == NULL) || (g_hwiOps->enableIrq == NULL)) {
 8002612:	4b1e      	ldr	r3, [pc, #120]	; (800268c <LOS_HwiEnable+0x8c>)
 8002614:	681b      	ldr	r3, [r3, #0]
 8002616:	2b00      	cmp	r3, #0
 8002618:	d004      	beq.n	8002624 <LOS_HwiEnable+0x24>
 800261a:	4b1c      	ldr	r3, [pc, #112]	; (800268c <LOS_HwiEnable+0x8c>)
 800261c:	681b      	ldr	r3, [r3, #0]
 800261e:	689b      	ldr	r3, [r3, #8]
 8002620:	2b00      	cmp	r3, #0
 8002622:	d101      	bne.n	8002628 <LOS_HwiEnable+0x28>
        return LOS_ERRNO_HWI_PROC_FUNC_NULL;
 8002624:	4b1a      	ldr	r3, [pc, #104]	; (8002690 <LOS_HwiEnable+0x90>)
 8002626:	e024      	b.n	8002672 <LOS_HwiEnable+0x72>
    }
    LOS_TRACE(HWI_ENABLE, hwiNum);
 8002628:	2300      	movs	r3, #0
 800262a:	60fb      	str	r3, [r7, #12]
 800262c:	687b      	ldr	r3, [r7, #4]
 800262e:	613b      	str	r3, [r7, #16]
 8002630:	2302      	movs	r3, #2
 8002632:	60bb      	str	r3, [r7, #8]
 8002634:	68bb      	ldr	r3, [r7, #8]
 8002636:	2b01      	cmp	r3, #1
 8002638:	d915      	bls.n	8002666 <LOS_HwiEnable+0x66>
 800263a:	4b16      	ldr	r3, [pc, #88]	; (8002694 <LOS_HwiEnable+0x94>)
 800263c:	681b      	ldr	r3, [r3, #0]
 800263e:	2b00      	cmp	r3, #0
 8002640:	d011      	beq.n	8002666 <LOS_HwiEnable+0x66>
 8002642:	4b14      	ldr	r3, [pc, #80]	; (8002694 <LOS_HwiEnable+0x94>)
 8002644:	681c      	ldr	r4, [r3, #0]
 8002646:	6939      	ldr	r1, [r7, #16]
 8002648:	68bb      	ldr	r3, [r7, #8]
 800264a:	2b02      	cmp	r3, #2
 800264c:	d904      	bls.n	8002658 <LOS_HwiEnable+0x58>
 800264e:	f107 030c 	add.w	r3, r7, #12
 8002652:	f103 0208 	add.w	r2, r3, #8
 8002656:	e000      	b.n	800265a <LOS_HwiEnable+0x5a>
 8002658:	2200      	movs	r2, #0
 800265a:	68bb      	ldr	r3, [r7, #8]
 800265c:	b29b      	uxth	r3, r3
 800265e:	3b02      	subs	r3, #2
 8002660:	b29b      	uxth	r3, r3
 8002662:	2026      	movs	r0, #38	; 0x26
 8002664:	47a0      	blx	r4

    return g_hwiOps->enableIrq(hwiNum);
 8002666:	4b09      	ldr	r3, [pc, #36]	; (800268c <LOS_HwiEnable+0x8c>)
 8002668:	681b      	ldr	r3, [r3, #0]
 800266a:	689b      	ldr	r3, [r3, #8]
 800266c:	6878      	ldr	r0, [r7, #4]
 800266e:	4798      	blx	r3
 8002670:	4603      	mov	r3, r0
}
 8002672:	4a05      	ldr	r2, [pc, #20]	; (8002688 <LOS_HwiEnable+0x88>)
 8002674:	6811      	ldr	r1, [r2, #0]
 8002676:	697a      	ldr	r2, [r7, #20]
 8002678:	4051      	eors	r1, r2
 800267a:	d001      	beq.n	8002680 <LOS_HwiEnable+0x80>
 800267c:	f001 feb4 	bl	80043e8 <__stack_chk_fail>
 8002680:	4618      	mov	r0, r3
 8002682:	371c      	adds	r7, #28
 8002684:	46bd      	mov	sp, r7
 8002686:	bd90      	pop	{r4, r7, pc}
 8002688:	08020024 	.word	0x08020024
 800268c:	20000758 	.word	0x20000758
 8002690:	02000901 	.word	0x02000901
 8002694:	2000075c 	.word	0x2000075c

08002698 <LOS_IntWakeupHookReg>:
}
#endif

#ifdef LOSCFG_KERNEL_LOWPOWER
LITE_OS_SEC_TEXT_MINOR VOID LOS_IntWakeupHookReg(WAKEUPFROMINTHOOK hook)
{
 8002698:	b480      	push	{r7}
 800269a:	b083      	sub	sp, #12
 800269c:	af00      	add	r7, sp, #0
 800269e:	6078      	str	r0, [r7, #4]
    g_intWakeupHook = hook;
 80026a0:	4a04      	ldr	r2, [pc, #16]	; (80026b4 <LOS_IntWakeupHookReg+0x1c>)
 80026a2:	687b      	ldr	r3, [r7, #4]
 80026a4:	6013      	str	r3, [r2, #0]
}
 80026a6:	bf00      	nop
 80026a8:	370c      	adds	r7, #12
 80026aa:	46bd      	mov	sp, r7
 80026ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80026b0:	4770      	bx	lr
 80026b2:	bf00      	nop
 80026b4:	20000754 	.word	0x20000754

080026b8 <OsHwiInit>:
#endif

/* Initialization of the hardware interrupt */
LITE_OS_SEC_TEXT_INIT VOID OsHwiInit(VOID)
{
 80026b8:	b580      	push	{r7, lr}
 80026ba:	af00      	add	r7, sp, #0
    ArchIrqInit();
 80026bc:	f00d f9ac 	bl	800fa18 <ArchIrqInit>
    return;
 80026c0:	bf00      	nop
}
 80026c2:	bd80      	pop	{r7, pc}

080026c4 <LOS_Align>:
LMS_INIT_HOOK g_lmsMemInitHook = NULL;
LMS_FUNC_HOOK g_lmsMallocHook = NULL;
LMS_FUNC_HOOK g_lmsFreeHook = NULL;
#endif
LITE_OS_SEC_TEXT UINTPTR LOS_Align(UINTPTR addr, UINT32 boundary)
{
 80026c4:	b480      	push	{r7}
 80026c6:	b083      	sub	sp, #12
 80026c8:	af00      	add	r7, sp, #0
 80026ca:	6078      	str	r0, [r7, #4]
 80026cc:	6039      	str	r1, [r7, #0]
    return (addr + boundary - 1) & ~((UINTPTR)(boundary - 1));
 80026ce:	687a      	ldr	r2, [r7, #4]
 80026d0:	683b      	ldr	r3, [r7, #0]
 80026d2:	4413      	add	r3, r2
 80026d4:	1e5a      	subs	r2, r3, #1
 80026d6:	683b      	ldr	r3, [r7, #0]
 80026d8:	425b      	negs	r3, r3
 80026da:	4013      	ands	r3, r2
}
 80026dc:	4618      	mov	r0, r3
 80026de:	370c      	adds	r7, #12
 80026e0:	46bd      	mov	sp, r7
 80026e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80026e6:	4770      	bx	lr

080026e8 <OsArraySort>:
}

#if defined(LOSCFG_DEBUG_SEMAPHORE) || defined(LOSCFG_DEBUG_MUTEX) || defined(LOSCFG_DEBUG_QUEUE)
VOID OsArraySort(UINT32 *sortArray, UINT32 start, UINT32 end,
                 const SortParam *sortParam, OsCompareFunc compareFunc)
{
 80026e8:	b580      	push	{r7, lr}
 80026ea:	b08a      	sub	sp, #40	; 0x28
 80026ec:	af02      	add	r7, sp, #8
 80026ee:	60f8      	str	r0, [r7, #12]
 80026f0:	60b9      	str	r1, [r7, #8]
 80026f2:	607a      	str	r2, [r7, #4]
 80026f4:	603b      	str	r3, [r7, #0]
    UINT32 left = start;
 80026f6:	68bb      	ldr	r3, [r7, #8]
 80026f8:	613b      	str	r3, [r7, #16]
    UINT32 right = end;
 80026fa:	687b      	ldr	r3, [r7, #4]
 80026fc:	617b      	str	r3, [r7, #20]
    UINT32 idx = start;
 80026fe:	68bb      	ldr	r3, [r7, #8]
 8002700:	61bb      	str	r3, [r7, #24]
    UINT32 pivot = sortArray[start];
 8002702:	68bb      	ldr	r3, [r7, #8]
 8002704:	009b      	lsls	r3, r3, #2
 8002706:	68fa      	ldr	r2, [r7, #12]
 8002708:	4413      	add	r3, r2
 800270a:	681b      	ldr	r3, [r3, #0]
 800270c:	61fb      	str	r3, [r7, #28]

    while (left < right) {
 800270e:	e068      	b.n	80027e2 <OsArraySort+0xfa>
        while ((left < right) && (sortArray[right] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
               compareFunc(sortParam, sortArray[right], pivot)) {
            right--;
 8002710:	697b      	ldr	r3, [r7, #20]
 8002712:	3b01      	subs	r3, #1
 8002714:	617b      	str	r3, [r7, #20]
        while ((left < right) && (sortArray[right] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
 8002716:	693a      	ldr	r2, [r7, #16]
 8002718:	697b      	ldr	r3, [r7, #20]
 800271a:	429a      	cmp	r2, r3
 800271c:	d219      	bcs.n	8002752 <OsArraySort+0x6a>
 800271e:	697b      	ldr	r3, [r7, #20]
 8002720:	009b      	lsls	r3, r3, #2
 8002722:	68fa      	ldr	r2, [r7, #12]
 8002724:	4413      	add	r3, r2
 8002726:	681a      	ldr	r2, [r3, #0]
 8002728:	683b      	ldr	r3, [r7, #0]
 800272a:	689b      	ldr	r3, [r3, #8]
 800272c:	429a      	cmp	r2, r3
 800272e:	d210      	bcs.n	8002752 <OsArraySort+0x6a>
 8002730:	683b      	ldr	r3, [r7, #0]
 8002732:	689b      	ldr	r3, [r3, #8]
 8002734:	69fa      	ldr	r2, [r7, #28]
 8002736:	429a      	cmp	r2, r3
 8002738:	d20b      	bcs.n	8002752 <OsArraySort+0x6a>
               compareFunc(sortParam, sortArray[right], pivot)) {
 800273a:	697b      	ldr	r3, [r7, #20]
 800273c:	009b      	lsls	r3, r3, #2
 800273e:	68fa      	ldr	r2, [r7, #12]
 8002740:	4413      	add	r3, r2
 8002742:	6819      	ldr	r1, [r3, #0]
 8002744:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002746:	69fa      	ldr	r2, [r7, #28]
 8002748:	6838      	ldr	r0, [r7, #0]
 800274a:	4798      	blx	r3
 800274c:	4603      	mov	r3, r0
        while ((left < right) && (sortArray[right] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
 800274e:	2b00      	cmp	r3, #0
 8002750:	d1de      	bne.n	8002710 <OsArraySort+0x28>
        }

        if (left < right) {
 8002752:	693a      	ldr	r2, [r7, #16]
 8002754:	697b      	ldr	r3, [r7, #20]
 8002756:	429a      	cmp	r2, r3
 8002758:	d212      	bcs.n	8002780 <OsArraySort+0x98>
            sortArray[left] = sortArray[right];
 800275a:	697b      	ldr	r3, [r7, #20]
 800275c:	009b      	lsls	r3, r3, #2
 800275e:	68fa      	ldr	r2, [r7, #12]
 8002760:	441a      	add	r2, r3
 8002762:	693b      	ldr	r3, [r7, #16]
 8002764:	009b      	lsls	r3, r3, #2
 8002766:	68f9      	ldr	r1, [r7, #12]
 8002768:	440b      	add	r3, r1
 800276a:	6812      	ldr	r2, [r2, #0]
 800276c:	601a      	str	r2, [r3, #0]
            idx = right;
 800276e:	697b      	ldr	r3, [r7, #20]
 8002770:	61bb      	str	r3, [r7, #24]
            left++;
 8002772:	693b      	ldr	r3, [r7, #16]
 8002774:	3301      	adds	r3, #1
 8002776:	613b      	str	r3, [r7, #16]
        }

        while ((left < right) && (sortArray[left] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
 8002778:	e002      	b.n	8002780 <OsArraySort+0x98>
               compareFunc(sortParam, pivot, sortArray[left])) {
            left++;
 800277a:	693b      	ldr	r3, [r7, #16]
 800277c:	3301      	adds	r3, #1
 800277e:	613b      	str	r3, [r7, #16]
        while ((left < right) && (sortArray[left] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
 8002780:	693a      	ldr	r2, [r7, #16]
 8002782:	697b      	ldr	r3, [r7, #20]
 8002784:	429a      	cmp	r2, r3
 8002786:	d219      	bcs.n	80027bc <OsArraySort+0xd4>
 8002788:	693b      	ldr	r3, [r7, #16]
 800278a:	009b      	lsls	r3, r3, #2
 800278c:	68fa      	ldr	r2, [r7, #12]
 800278e:	4413      	add	r3, r2
 8002790:	681a      	ldr	r2, [r3, #0]
 8002792:	683b      	ldr	r3, [r7, #0]
 8002794:	689b      	ldr	r3, [r3, #8]
 8002796:	429a      	cmp	r2, r3
 8002798:	d210      	bcs.n	80027bc <OsArraySort+0xd4>
 800279a:	683b      	ldr	r3, [r7, #0]
 800279c:	689b      	ldr	r3, [r3, #8]
 800279e:	69fa      	ldr	r2, [r7, #28]
 80027a0:	429a      	cmp	r2, r3
 80027a2:	d20b      	bcs.n	80027bc <OsArraySort+0xd4>
               compareFunc(sortParam, pivot, sortArray[left])) {
 80027a4:	693b      	ldr	r3, [r7, #16]
 80027a6:	009b      	lsls	r3, r3, #2
 80027a8:	68fa      	ldr	r2, [r7, #12]
 80027aa:	4413      	add	r3, r2
 80027ac:	681a      	ldr	r2, [r3, #0]
 80027ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80027b0:	69f9      	ldr	r1, [r7, #28]
 80027b2:	6838      	ldr	r0, [r7, #0]
 80027b4:	4798      	blx	r3
 80027b6:	4603      	mov	r3, r0
        while ((left < right) && (sortArray[left] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
 80027b8:	2b00      	cmp	r3, #0
 80027ba:	d1de      	bne.n	800277a <OsArraySort+0x92>
        }

        if (left < right) {
 80027bc:	693a      	ldr	r2, [r7, #16]
 80027be:	697b      	ldr	r3, [r7, #20]
 80027c0:	429a      	cmp	r2, r3
 80027c2:	d20e      	bcs.n	80027e2 <OsArraySort+0xfa>
            sortArray[right] = sortArray[left];
 80027c4:	693b      	ldr	r3, [r7, #16]
 80027c6:	009b      	lsls	r3, r3, #2
 80027c8:	68fa      	ldr	r2, [r7, #12]
 80027ca:	441a      	add	r2, r3
 80027cc:	697b      	ldr	r3, [r7, #20]
 80027ce:	009b      	lsls	r3, r3, #2
 80027d0:	68f9      	ldr	r1, [r7, #12]
 80027d2:	440b      	add	r3, r1
 80027d4:	6812      	ldr	r2, [r2, #0]
 80027d6:	601a      	str	r2, [r3, #0]
            idx = left;
 80027d8:	693b      	ldr	r3, [r7, #16]
 80027da:	61bb      	str	r3, [r7, #24]
            right--;
 80027dc:	697b      	ldr	r3, [r7, #20]
 80027de:	3b01      	subs	r3, #1
 80027e0:	617b      	str	r3, [r7, #20]
    while (left < right) {
 80027e2:	693a      	ldr	r2, [r7, #16]
 80027e4:	697b      	ldr	r3, [r7, #20]
 80027e6:	429a      	cmp	r2, r3
 80027e8:	d395      	bcc.n	8002716 <OsArraySort+0x2e>
        }
    }

    sortArray[idx] = pivot;
 80027ea:	69bb      	ldr	r3, [r7, #24]
 80027ec:	009b      	lsls	r3, r3, #2
 80027ee:	68fa      	ldr	r2, [r7, #12]
 80027f0:	4413      	add	r3, r2
 80027f2:	69fa      	ldr	r2, [r7, #28]
 80027f4:	601a      	str	r2, [r3, #0]

    if (start < idx) {
 80027f6:	68ba      	ldr	r2, [r7, #8]
 80027f8:	69bb      	ldr	r3, [r7, #24]
 80027fa:	429a      	cmp	r2, r3
 80027fc:	d208      	bcs.n	8002810 <OsArraySort+0x128>
        OsArraySort(sortArray, start, idx - 1, sortParam, compareFunc);
 80027fe:	69bb      	ldr	r3, [r7, #24]
 8002800:	1e5a      	subs	r2, r3, #1
 8002802:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002804:	9300      	str	r3, [sp, #0]
 8002806:	683b      	ldr	r3, [r7, #0]
 8002808:	68b9      	ldr	r1, [r7, #8]
 800280a:	68f8      	ldr	r0, [r7, #12]
 800280c:	f7ff ff6c 	bl	80026e8 <OsArraySort>
    }
    if (idx < end) {
 8002810:	69ba      	ldr	r2, [r7, #24]
 8002812:	687b      	ldr	r3, [r7, #4]
 8002814:	429a      	cmp	r2, r3
 8002816:	d208      	bcs.n	800282a <OsArraySort+0x142>
        OsArraySort(sortArray, idx + 1, end, sortParam, compareFunc);
 8002818:	69bb      	ldr	r3, [r7, #24]
 800281a:	1c59      	adds	r1, r3, #1
 800281c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800281e:	9300      	str	r3, [sp, #0]
 8002820:	683b      	ldr	r3, [r7, #0]
 8002822:	687a      	ldr	r2, [r7, #4]
 8002824:	68f8      	ldr	r0, [r7, #12]
 8002826:	f7ff ff5f 	bl	80026e8 <OsArraySort>
    }
}
 800282a:	bf00      	nop
 800282c:	3720      	adds	r7, #32
 800282e:	46bd      	mov	sp, r7
 8002830:	bd80      	pop	{r7, pc}

08002832 <LOS_ListInit>:
 * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_DL_LIST_HEAD
 * @since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_ListInit(LOS_DL_LIST *list)
{
 8002832:	b480      	push	{r7}
 8002834:	b083      	sub	sp, #12
 8002836:	af00      	add	r7, sp, #0
 8002838:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 800283a:	687b      	ldr	r3, [r7, #4]
 800283c:	687a      	ldr	r2, [r7, #4]
 800283e:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 8002840:	687b      	ldr	r3, [r7, #4]
 8002842:	687a      	ldr	r2, [r7, #4]
 8002844:	601a      	str	r2, [r3, #0]
}
 8002846:	bf00      	nop
 8002848:	370c      	adds	r7, #12
 800284a:	46bd      	mov	sp, r7
 800284c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002850:	4770      	bx	lr

08002852 <LOS_ListAdd>:
 * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_ListDelete | LOS_ListTailInsert | LOS_ListHeadInsert
 * @since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_ListAdd(LOS_DL_LIST *list, LOS_DL_LIST *node)
{
 8002852:	b480      	push	{r7}
 8002854:	b083      	sub	sp, #12
 8002856:	af00      	add	r7, sp, #0
 8002858:	6078      	str	r0, [r7, #4]
 800285a:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 800285c:	687b      	ldr	r3, [r7, #4]
 800285e:	685a      	ldr	r2, [r3, #4]
 8002860:	683b      	ldr	r3, [r7, #0]
 8002862:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 8002864:	683b      	ldr	r3, [r7, #0]
 8002866:	687a      	ldr	r2, [r7, #4]
 8002868:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 800286a:	687b      	ldr	r3, [r7, #4]
 800286c:	685b      	ldr	r3, [r3, #4]
 800286e:	683a      	ldr	r2, [r7, #0]
 8002870:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 8002872:	687b      	ldr	r3, [r7, #4]
 8002874:	683a      	ldr	r2, [r7, #0]
 8002876:	605a      	str	r2, [r3, #4]
}
 8002878:	bf00      	nop
 800287a:	370c      	adds	r7, #12
 800287c:	46bd      	mov	sp, r7
 800287e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002882:	4770      	bx	lr

08002884 <LOS_ListTailInsert>:
 * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_ListAdd | LOS_ListHeadInsert
 * @since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_ListTailInsert(LOS_DL_LIST *list, LOS_DL_LIST *node)
{
 8002884:	b580      	push	{r7, lr}
 8002886:	b082      	sub	sp, #8
 8002888:	af00      	add	r7, sp, #0
 800288a:	6078      	str	r0, [r7, #4]
 800288c:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 800288e:	687b      	ldr	r3, [r7, #4]
 8002890:	681b      	ldr	r3, [r3, #0]
 8002892:	6839      	ldr	r1, [r7, #0]
 8002894:	4618      	mov	r0, r3
 8002896:	f7ff ffdc 	bl	8002852 <LOS_ListAdd>
}
 800289a:	bf00      	nop
 800289c:	3708      	adds	r7, #8
 800289e:	46bd      	mov	sp, r7
 80028a0:	bd80      	pop	{r7, pc}

080028a2 <LOS_ListDelete>:
 * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_ListAdd
 * @since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_ListDelete(LOS_DL_LIST *node)
{
 80028a2:	b480      	push	{r7}
 80028a4:	b083      	sub	sp, #12
 80028a6:	af00      	add	r7, sp, #0
 80028a8:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 80028aa:	687b      	ldr	r3, [r7, #4]
 80028ac:	685b      	ldr	r3, [r3, #4]
 80028ae:	687a      	ldr	r2, [r7, #4]
 80028b0:	6812      	ldr	r2, [r2, #0]
 80028b2:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 80028b4:	687b      	ldr	r3, [r7, #4]
 80028b6:	681b      	ldr	r3, [r3, #0]
 80028b8:	687a      	ldr	r2, [r7, #4]
 80028ba:	6852      	ldr	r2, [r2, #4]
 80028bc:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 80028be:	687b      	ldr	r3, [r7, #4]
 80028c0:	2200      	movs	r2, #0
 80028c2:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 80028c4:	687b      	ldr	r3, [r7, #4]
 80028c6:	2200      	movs	r2, #0
 80028c8:	601a      	str	r2, [r3, #0]
}
 80028ca:	bf00      	nop
 80028cc:	370c      	adds	r7, #12
 80028ce:	46bd      	mov	sp, r7
 80028d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028d4:	4770      	bx	lr

080028d6 <LOS_ListEmpty>:
 * @par Dependency:
 * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
 * @since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE STATIC INLINE BOOL LOS_ListEmpty(LOS_DL_LIST *list)
{
 80028d6:	b480      	push	{r7}
 80028d8:	b083      	sub	sp, #12
 80028da:	af00      	add	r7, sp, #0
 80028dc:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 80028de:	687b      	ldr	r3, [r7, #4]
 80028e0:	685b      	ldr	r3, [r3, #4]
 80028e2:	687a      	ldr	r2, [r7, #4]
 80028e4:	429a      	cmp	r2, r3
 80028e6:	bf0c      	ite	eq
 80028e8:	2301      	moveq	r3, #1
 80028ea:	2300      	movne	r3, #0
 80028ec:	b2db      	uxtb	r3, r3
}
 80028ee:	4618      	mov	r0, r3
 80028f0:	370c      	adds	r7, #12
 80028f2:	46bd      	mov	sp, r7
 80028f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028f8:	4770      	bx	lr

080028fa <ArchCurrCpuid>:
{
 80028fa:	b480      	push	{r7}
 80028fc:	af00      	add	r7, sp, #0
    return 0;
 80028fe:	2300      	movs	r3, #0
}
 8002900:	4618      	mov	r0, r3
 8002902:	46bd      	mov	sp, r7
 8002904:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002908:	4770      	bx	lr

0800290a <LOS_IntLock>:
{
 800290a:	b580      	push	{r7, lr}
 800290c:	af00      	add	r7, sp, #0
    return ArchIntLock();
 800290e:	f7fe f9db 	bl	8000cc8 <ArchIntLock>
 8002912:	4603      	mov	r3, r0
}
 8002914:	4618      	mov	r0, r3
 8002916:	bd80      	pop	{r7, pc}

08002918 <LOS_IntUnLock>:
{
 8002918:	b580      	push	{r7, lr}
 800291a:	af00      	add	r7, sp, #0
    return ArchIntUnlock();
 800291c:	f7fe f9d8 	bl	8000cd0 <ArchIntUnlock>
 8002920:	4603      	mov	r3, r0
}
 8002922:	4618      	mov	r0, r3
 8002924:	bd80      	pop	{r7, pc}

08002926 <LOS_IntRestore>:
{
 8002926:	b580      	push	{r7, lr}
 8002928:	b082      	sub	sp, #8
 800292a:	af00      	add	r7, sp, #0
 800292c:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800292e:	6878      	ldr	r0, [r7, #4]
 8002930:	f7fe f9d2 	bl	8000cd8 <ArchIntRestore>
}
 8002934:	bf00      	nop
 8002936:	3708      	adds	r7, #8
 8002938:	46bd      	mov	sp, r7
 800293a:	bd80      	pop	{r7, pc}

0800293c <ArchCurrTaskGet>:
{
 800293c:	b480      	push	{r7}
 800293e:	af00      	add	r7, sp, #0
    return g_runTask;
 8002940:	4b03      	ldr	r3, [pc, #12]	; (8002950 <ArchCurrTaskGet+0x14>)
 8002942:	681b      	ldr	r3, [r3, #0]
}
 8002944:	4618      	mov	r0, r3
 8002946:	46bd      	mov	sp, r7
 8002948:	f85d 7b04 	ldr.w	r7, [sp], #4
 800294c:	4770      	bx	lr
 800294e:	bf00      	nop
 8002950:	200033bc 	.word	0x200033bc

08002954 <OsPercpuGet>:

/* the kernel per-cpu structure */
extern Percpu g_percpu[LOSCFG_KERNEL_CORE_NUM];

STATIC INLINE Percpu *OsPercpuGet(VOID)
{
 8002954:	b580      	push	{r7, lr}
 8002956:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 8002958:	f7ff ffcf 	bl	80028fa <ArchCurrCpuid>
 800295c:	4602      	mov	r2, r0
 800295e:	4613      	mov	r3, r2
 8002960:	00db      	lsls	r3, r3, #3
 8002962:	4413      	add	r3, r2
 8002964:	009b      	lsls	r3, r3, #2
 8002966:	4a02      	ldr	r2, [pc, #8]	; (8002970 <OsPercpuGet+0x1c>)
 8002968:	4413      	add	r3, r2
}
 800296a:	4618      	mov	r0, r3
 800296c:	bd80      	pop	{r7, pc}
 800296e:	bf00      	nop
 8002970:	200036fc 	.word	0x200036fc

08002974 <OsPreemptable>:
 * CPU 
 * 
 *  percpu->schedFlag = INT_PEND_RESCH
 */
STATIC INLINE BOOL OsPreemptable(VOID)
{
 8002974:	b580      	push	{r7, lr}
 8002976:	b082      	sub	sp, #8
 8002978:	af00      	add	r7, sp, #0
    /*
     * Unlike OsPreemptableInSched, the int may be not disabled when OsPreemptable
     * is called, needs manually disable interrupt, to prevent current task from
     * being migrated to another core, and get the wrong preemptable status.
     */
    UINT32 intSave = LOS_IntLock();
 800297a:	f7ff ffc6 	bl	800290a <LOS_IntLock>
 800297e:	6038      	str	r0, [r7, #0]
    BOOL preemptable = (OsPercpuGet()->taskLockCnt == 0);
 8002980:	f7ff ffe8 	bl	8002954 <OsPercpuGet>
 8002984:	4603      	mov	r3, r0
 8002986:	695b      	ldr	r3, [r3, #20]
 8002988:	2b00      	cmp	r3, #0
 800298a:	bf0c      	ite	eq
 800298c:	2301      	moveq	r3, #1
 800298e:	2300      	movne	r3, #0
 8002990:	b2db      	uxtb	r3, r3
 8002992:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 8002994:	687b      	ldr	r3, [r7, #4]
 8002996:	2b00      	cmp	r3, #0
 8002998:	d104      	bne.n	80029a4 <OsPreemptable+0x30>
        /* Set schedule flag if preemption is disabled */
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 800299a:	f7ff ffdb 	bl	8002954 <OsPercpuGet>
 800299e:	4603      	mov	r3, r0
 80029a0:	2201      	movs	r2, #1
 80029a2:	621a      	str	r2, [r3, #32]
    }
    LOS_IntRestore(intSave);
 80029a4:	6838      	ldr	r0, [r7, #0]
 80029a6:	f7ff ffbe 	bl	8002926 <LOS_IntRestore>
    return preemptable;
 80029aa:	687b      	ldr	r3, [r7, #4]
}
 80029ac:	4618      	mov	r0, r3
 80029ae:	3708      	adds	r7, #8
 80029b0:	46bd      	mov	sp, r7
 80029b2:	bd80      	pop	{r7, pc}

080029b4 <OsPreemptableInSched>:

STATIC INLINE BOOL OsPreemptableInSched(VOID)
{
 80029b4:	b580      	push	{r7, lr}
 80029b6:	b082      	sub	sp, #8
 80029b8:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 80029ba:	2300      	movs	r3, #0
 80029bc:	607b      	str	r3, [r7, #4]
     * will increase by 1 in that case.
     */
    preemptable = (OsPercpuGet()->taskLockCnt == 1);

#else
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 80029be:	f7ff ffc9 	bl	8002954 <OsPercpuGet>
 80029c2:	4603      	mov	r3, r0
 80029c4:	695b      	ldr	r3, [r3, #20]
 80029c6:	2b00      	cmp	r3, #0
 80029c8:	bf0c      	ite	eq
 80029ca:	2301      	moveq	r3, #1
 80029cc:	2300      	movne	r3, #0
 80029ce:	b2db      	uxtb	r3, r3
 80029d0:	607b      	str	r3, [r7, #4]
#endif
    if (!preemptable) {
 80029d2:	687b      	ldr	r3, [r7, #4]
 80029d4:	2b00      	cmp	r3, #0
 80029d6:	d104      	bne.n	80029e2 <OsPreemptableInSched+0x2e>
        /* Set schedule flag if preemption is disabled */
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 80029d8:	f7ff ffbc 	bl	8002954 <OsPercpuGet>
 80029dc:	4603      	mov	r3, r0
 80029de:	2201      	movs	r2, #1
 80029e0:	621a      	str	r2, [r3, #32]
    }

    return preemptable;
 80029e2:	687b      	ldr	r3, [r7, #4]
}
 80029e4:	4618      	mov	r0, r3
 80029e6:	3708      	adds	r7, #8
 80029e8:	46bd      	mov	sp, r7
 80029ea:	bd80      	pop	{r7, pc}

080029ec <LOS_Schedule>:
 * systick INT_PEND_RESCH 
 * ISR 
 * INT_PEND_RESCH (OsSchedPreempt)
 */
STATIC INLINE VOID LOS_Schedule(VOID)
{
 80029ec:	b580      	push	{r7, lr}
 80029ee:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 80029f0:	f7ff fd3c 	bl	800246c <IntActive>
 80029f4:	4603      	mov	r3, r0
 80029f6:	2b00      	cmp	r3, #0
 80029f8:	d005      	beq.n	8002a06 <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 80029fa:	f7ff ffab 	bl	8002954 <OsPercpuGet>
 80029fe:	4603      	mov	r3, r0
 8002a00:	2201      	movs	r2, #1
 8002a02:	621a      	str	r2, [r3, #32]
        return;
 8002a04:	e001      	b.n	8002a0a <LOS_Schedule+0x1e>
    /*
     * trigger schedule in task will also do the slice check
     * if necessary, it will give up the timeslice more in time.
     * otherwise, there's no other side effects.
     */
    OsSchedPreempt();
 8002a06:	f005 fc5f 	bl	80082c8 <OsSchedPreempt>
}
 8002a0a:	bd80      	pop	{r7, pc}

08002a0c <LOS_SpinLock>:
{
 8002a0c:	b480      	push	{r7}
 8002a0e:	b083      	sub	sp, #12
 8002a10:	af00      	add	r7, sp, #0
 8002a12:	6078      	str	r0, [r7, #4]
}
 8002a14:	bf00      	nop
 8002a16:	370c      	adds	r7, #12
 8002a18:	46bd      	mov	sp, r7
 8002a1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a1e:	4770      	bx	lr

08002a20 <LOS_SpinUnlock>:
{
 8002a20:	b480      	push	{r7}
 8002a22:	b083      	sub	sp, #12
 8002a24:	af00      	add	r7, sp, #0
 8002a26:	6078      	str	r0, [r7, #4]
}
 8002a28:	bf00      	nop
 8002a2a:	370c      	adds	r7, #12
 8002a2c:	46bd      	mov	sp, r7
 8002a2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a32:	4770      	bx	lr

08002a34 <LOS_SpinLockSave>:
{
 8002a34:	b580      	push	{r7, lr}
 8002a36:	b082      	sub	sp, #8
 8002a38:	af00      	add	r7, sp, #0
 8002a3a:	6078      	str	r0, [r7, #4]
 8002a3c:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8002a3e:	f7ff ff64 	bl	800290a <LOS_IntLock>
 8002a42:	4602      	mov	r2, r0
 8002a44:	683b      	ldr	r3, [r7, #0]
 8002a46:	601a      	str	r2, [r3, #0]
}
 8002a48:	bf00      	nop
 8002a4a:	3708      	adds	r7, #8
 8002a4c:	46bd      	mov	sp, r7
 8002a4e:	bd80      	pop	{r7, pc}

08002a50 <LOS_SpinUnlockRestore>:
{
 8002a50:	b580      	push	{r7, lr}
 8002a52:	b082      	sub	sp, #8
 8002a54:	af00      	add	r7, sp, #0
 8002a56:	6078      	str	r0, [r7, #4]
 8002a58:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8002a5a:	6838      	ldr	r0, [r7, #0]
 8002a5c:	f7ff ff63 	bl	8002926 <LOS_IntRestore>
}
 8002a60:	bf00      	nop
 8002a62:	3708      	adds	r7, #8
 8002a64:	46bd      	mov	sp, r7
 8002a66:	bd80      	pop	{r7, pc}

08002a68 <LOS_SpinHeld>:

LITE_OS_SEC_ALW_INLINE STATIC INLINE BOOL LOS_SpinHeld(const SPIN_LOCK_S *lock)
{
 8002a68:	b480      	push	{r7}
 8002a6a:	b083      	sub	sp, #12
 8002a6c:	af00      	add	r7, sp, #0
 8002a6e:	6078      	str	r0, [r7, #4]
    (VOID)lock;
    return TRUE;
 8002a70:	2301      	movs	r3, #1
}
 8002a72:	4618      	mov	r0, r3
 8002a74:	370c      	adds	r7, #12
 8002a76:	46bd      	mov	sp, r7
 8002a78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a7c:	4770      	bx	lr

08002a7e <OsCurrTaskGet>:
{
 8002a7e:	b580      	push	{r7, lr}
 8002a80:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 8002a82:	f7ff ff5b 	bl	800293c <ArchCurrTaskGet>
 8002a86:	4603      	mov	r3, r0
}
 8002a88:	4618      	mov	r0, r3
 8002a8a:	bd80      	pop	{r7, pc}

08002a8c <OsMuxDlockCheckInitHook>:
#endif /* __cplusplus */

/* Deadlock detection initialization interface */
extern UINT32 OsMuxDlockCheckInit(VOID);
STATIC INLINE UINT32 OsMuxDlockCheckInitHook(VOID)
{
 8002a8c:	b580      	push	{r7, lr}
 8002a8e:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_MUTEX_DEADLOCK
    return OsMuxDlockCheckInit();
 8002a90:	f003 f9de 	bl	8005e50 <OsMuxDlockCheckInit>
 8002a94:	4603      	mov	r3, r0
#else
    return LOS_OK;
#endif
}
 8002a96:	4618      	mov	r0, r3
 8002a98:	bd80      	pop	{r7, pc}

08002a9a <LOS_MpSchedule>:
extern VOID OsMpScheduleHandler(VOID);
extern VOID OsMpHaltHandler(VOID);
extern UINT32 OsMpInit(VOID);
#else
STATIC INLINE VOID LOS_MpSchedule(UINT32 target)
{
 8002a9a:	b480      	push	{r7}
 8002a9c:	b083      	sub	sp, #12
 8002a9e:	af00      	add	r7, sp, #0
 8002aa0:	6078      	str	r0, [r7, #4]
    (VOID)target;
}
 8002aa2:	bf00      	nop
 8002aa4:	370c      	adds	r7, #12
 8002aa6:	46bd      	mov	sp, r7
 8002aa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002aac:	4770      	bx	lr
	...

08002ab0 <OsTaskCBRecycleToFree>:
    g_taskDelHook = hook;
}
#endif

LITE_OS_SEC_TEXT_INIT STATIC VOID OsTaskCBRecycleToFree(VOID)
{
 8002ab0:	b580      	push	{r7, lr}
 8002ab2:	b082      	sub	sp, #8
 8002ab4:	af00      	add	r7, sp, #0
    LosTaskCB *taskCB = NULL;
 8002ab6:	2300      	movs	r3, #0
 8002ab8:	603b      	str	r3, [r7, #0]
    VOID *poolTmp = NULL;
 8002aba:	2300      	movs	r3, #0
 8002abc:	607b      	str	r3, [r7, #4]
#ifdef LOSCFG_TASK_STACK_PROTECT
    UINTPTR MMUProtectAddr;
#endif
    while (!LOS_ListEmpty(&g_taskRecycleList)) {
 8002abe:	e01a      	b.n	8002af6 <OsTaskCBRecycleToFree+0x46>
        poolTmp = (VOID *)m_aucSysMem1;
 8002ac0:	4b12      	ldr	r3, [pc, #72]	; (8002b0c <OsTaskCBRecycleToFree+0x5c>)
 8002ac2:	681b      	ldr	r3, [r3, #0]
 8002ac4:	607b      	str	r3, [r7, #4]
        taskCB = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&g_taskRecycleList));
 8002ac6:	4b12      	ldr	r3, [pc, #72]	; (8002b10 <OsTaskCBRecycleToFree+0x60>)
 8002ac8:	685b      	ldr	r3, [r3, #4]
 8002aca:	3b40      	subs	r3, #64	; 0x40
 8002acc:	603b      	str	r3, [r7, #0]
        LOS_ListDelete(LOS_DL_LIST_FIRST(&g_taskRecycleList));
 8002ace:	4b10      	ldr	r3, [pc, #64]	; (8002b10 <OsTaskCBRecycleToFree+0x60>)
 8002ad0:	685b      	ldr	r3, [r3, #4]
 8002ad2:	4618      	mov	r0, r3
 8002ad4:	f7ff fee5 	bl	80028a2 <LOS_ListDelete>
        LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
 8002ad8:	683b      	ldr	r3, [r7, #0]
 8002ada:	3340      	adds	r3, #64	; 0x40
 8002adc:	4619      	mov	r1, r3
 8002ade:	480d      	ldr	r0, [pc, #52]	; (8002b14 <OsTaskCBRecycleToFree+0x64>)
 8002ae0:	f7ff feb7 	bl	8002852 <LOS_ListAdd>
#ifdef LOSCFG_EXC_INTERACTION
        if (taskCB->topOfStack < (UINTPTR)m_aucSysMem1) {
            poolTmp = (VOID *)m_aucSysMem0;
        }
#endif
        (VOID)LOS_MemFree(poolTmp, (VOID *)taskCB->topOfStack);
 8002ae4:	683b      	ldr	r3, [r7, #0]
 8002ae6:	691b      	ldr	r3, [r3, #16]
 8002ae8:	4619      	mov	r1, r3
 8002aea:	6878      	ldr	r0, [r7, #4]
 8002aec:	f006 f814 	bl	8008b18 <LOS_MemFree>
#endif
        taskCB->topOfStack = 0;
 8002af0:	683b      	ldr	r3, [r7, #0]
 8002af2:	2200      	movs	r2, #0
 8002af4:	611a      	str	r2, [r3, #16]
    while (!LOS_ListEmpty(&g_taskRecycleList)) {
 8002af6:	4806      	ldr	r0, [pc, #24]	; (8002b10 <OsTaskCBRecycleToFree+0x60>)
 8002af8:	f7ff feed 	bl	80028d6 <LOS_ListEmpty>
 8002afc:	4603      	mov	r3, r0
 8002afe:	2b00      	cmp	r3, #0
 8002b00:	d0de      	beq.n	8002ac0 <OsTaskCBRecycleToFree+0x10>
    }
}
 8002b02:	bf00      	nop
 8002b04:	bf00      	nop
 8002b06:	3708      	adds	r7, #8
 8002b08:	46bd      	mov	sp, r7
 8002b0a:	bd80      	pop	{r7, pc}
 8002b0c:	200021b8 	.word	0x200021b8
 8002b10:	200036c8 	.word	0x200036c8
 8002b14:	200036d0 	.word	0x200036d0

08002b18 <LOS_TaskResRecycle>:

VOID LOS_TaskResRecycle(VOID)
{
 8002b18:	b580      	push	{r7, lr}
 8002b1a:	b082      	sub	sp, #8
 8002b1c:	af00      	add	r7, sp, #0
 8002b1e:	4b0e      	ldr	r3, [pc, #56]	; (8002b58 <LOS_TaskResRecycle+0x40>)
 8002b20:	681b      	ldr	r3, [r3, #0]
 8002b22:	607b      	str	r3, [r7, #4]
 8002b24:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    SCHEDULER_LOCK(intSave);
 8002b28:	463b      	mov	r3, r7
 8002b2a:	4619      	mov	r1, r3
 8002b2c:	480b      	ldr	r0, [pc, #44]	; (8002b5c <LOS_TaskResRecycle+0x44>)
 8002b2e:	f7ff ff81 	bl	8002a34 <LOS_SpinLockSave>
    OsTaskCBRecycleToFree();
 8002b32:	f7ff ffbd 	bl	8002ab0 <OsTaskCBRecycleToFree>
    SCHEDULER_UNLOCK(intSave);
 8002b36:	683b      	ldr	r3, [r7, #0]
 8002b38:	4619      	mov	r1, r3
 8002b3a:	4808      	ldr	r0, [pc, #32]	; (8002b5c <LOS_TaskResRecycle+0x44>)
 8002b3c:	f7ff ff88 	bl	8002a50 <LOS_SpinUnlockRestore>
}
 8002b40:	bf00      	nop
 8002b42:	4b05      	ldr	r3, [pc, #20]	; (8002b58 <LOS_TaskResRecycle+0x40>)
 8002b44:	681a      	ldr	r2, [r3, #0]
 8002b46:	687b      	ldr	r3, [r7, #4]
 8002b48:	405a      	eors	r2, r3
 8002b4a:	d001      	beq.n	8002b50 <LOS_TaskResRecycle+0x38>
 8002b4c:	f001 fc4c 	bl	80043e8 <__stack_chk_fail>
 8002b50:	3708      	adds	r7, #8
 8002b52:	46bd      	mov	sp, r7
 8002b54:	bd80      	pop	{r7, pc}
 8002b56:	bf00      	nop
 8002b58:	08020034 	.word	0x08020034
 8002b5c:	20000764 	.word	0x20000764

08002b60 <OsIdleTask>:
    return FALSE;
}
#endif

LITE_OS_SEC_TEXT WEAK VOID OsIdleTask(VOID)
{
 8002b60:	b580      	push	{r7, lr}
 8002b62:	af00      	add	r7, sp, #0
    while (1) {
        LOS_TaskResRecycle();
 8002b64:	f7ff ffd8 	bl	8002b18 <LOS_TaskResRecycle>

        if (g_idleHandlerHook != NULL) {
 8002b68:	4b07      	ldr	r3, [pc, #28]	; (8002b88 <OsIdleTask+0x28>)
 8002b6a:	681b      	ldr	r3, [r3, #0]
 8002b6c:	2b00      	cmp	r3, #0
 8002b6e:	d002      	beq.n	8002b76 <OsIdleTask+0x16>
            g_idleHandlerHook();
 8002b70:	4b05      	ldr	r3, [pc, #20]	; (8002b88 <OsIdleTask+0x28>)
 8002b72:	681b      	ldr	r3, [r3, #0]
 8002b74:	4798      	blx	r3
        }

#ifdef LOSCFG_KERNEL_LOWPOWER
        if (g_lowPowerHook != NULL) {
 8002b76:	4b05      	ldr	r3, [pc, #20]	; (8002b8c <OsIdleTask+0x2c>)
 8002b78:	681b      	ldr	r3, [r3, #0]
 8002b7a:	2b00      	cmp	r3, #0
 8002b7c:	d0f2      	beq.n	8002b64 <OsIdleTask+0x4>
            g_lowPowerHook();
 8002b7e:	4b03      	ldr	r3, [pc, #12]	; (8002b8c <OsIdleTask+0x2c>)
 8002b80:	681b      	ldr	r3, [r3, #0]
 8002b82:	4798      	blx	r3
        LOS_TaskResRecycle();
 8002b84:	e7ee      	b.n	8002b64 <OsIdleTask+0x4>
 8002b86:	bf00      	nop
 8002b88:	20000770 	.word	0x20000770
 8002b8c:	2000076c 	.word	0x2000076c

08002b90 <OsTaskPriModify>:
 * Description : Change task priority.
 * Input       : taskCB    --- task control block
 *               priority  --- priority
 */
LITE_OS_SEC_TEXT_MINOR VOID OsTaskPriModify(LosTaskCB *taskCB, UINT16 priority)
{
 8002b90:	b590      	push	{r4, r7, lr}
 8002b92:	b08b      	sub	sp, #44	; 0x2c
 8002b94:	af00      	add	r7, sp, #0
 8002b96:	6078      	str	r0, [r7, #4]
 8002b98:	460b      	mov	r3, r1
 8002b9a:	807b      	strh	r3, [r7, #2]
 8002b9c:	4b32      	ldr	r3, [pc, #200]	; (8002c68 <OsTaskPriModify+0xd8>)
 8002b9e:	681b      	ldr	r3, [r3, #0]
 8002ba0:	627b      	str	r3, [r7, #36]	; 0x24
 8002ba2:	f04f 0300 	mov.w	r3, #0
    LOS_ASSERT(LOS_SpinHeld(&g_taskSpin));
 8002ba6:	4831      	ldr	r0, [pc, #196]	; (8002c6c <OsTaskPriModify+0xdc>)
 8002ba8:	f7ff ff5e 	bl	8002a68 <LOS_SpinHeld>
 8002bac:	4603      	mov	r3, r0
 8002bae:	2b00      	cmp	r3, #0
 8002bb0:	d10b      	bne.n	8002bca <OsTaskPriModify+0x3a>
 8002bb2:	f7ff feaa 	bl	800290a <LOS_IntLock>
 8002bb6:	482e      	ldr	r0, [pc, #184]	; (8002c70 <OsTaskPriModify+0xe0>)
 8002bb8:	f001 fd88 	bl	80046cc <dprintf>
 8002bbc:	4b2d      	ldr	r3, [pc, #180]	; (8002c74 <OsTaskPriModify+0xe4>)
 8002bbe:	22b1      	movs	r2, #177	; 0xb1
 8002bc0:	492d      	ldr	r1, [pc, #180]	; (8002c78 <OsTaskPriModify+0xe8>)
 8002bc2:	482e      	ldr	r0, [pc, #184]	; (8002c7c <OsTaskPriModify+0xec>)
 8002bc4:	f001 fd82 	bl	80046cc <dprintf>
 8002bc8:	e7fe      	b.n	8002bc8 <OsTaskPriModify+0x38>

    LOS_TRACE(TASK_PRIOSET, taskCB->taskId, taskCB->taskStatus, taskCB->priority, priority);
 8002bca:	2300      	movs	r3, #0
 8002bcc:	613b      	str	r3, [r7, #16]
 8002bce:	687b      	ldr	r3, [r7, #4]
 8002bd0:	695b      	ldr	r3, [r3, #20]
 8002bd2:	617b      	str	r3, [r7, #20]
 8002bd4:	687b      	ldr	r3, [r7, #4]
 8002bd6:	889b      	ldrh	r3, [r3, #4]
 8002bd8:	61bb      	str	r3, [r7, #24]
 8002bda:	687b      	ldr	r3, [r7, #4]
 8002bdc:	88db      	ldrh	r3, [r3, #6]
 8002bde:	61fb      	str	r3, [r7, #28]
 8002be0:	887b      	ldrh	r3, [r7, #2]
 8002be2:	623b      	str	r3, [r7, #32]
 8002be4:	2305      	movs	r3, #5
 8002be6:	60fb      	str	r3, [r7, #12]
 8002be8:	68fb      	ldr	r3, [r7, #12]
 8002bea:	2b01      	cmp	r3, #1
 8002bec:	d915      	bls.n	8002c1a <OsTaskPriModify+0x8a>
 8002bee:	4b24      	ldr	r3, [pc, #144]	; (8002c80 <OsTaskPriModify+0xf0>)
 8002bf0:	681b      	ldr	r3, [r3, #0]
 8002bf2:	2b00      	cmp	r3, #0
 8002bf4:	d011      	beq.n	8002c1a <OsTaskPriModify+0x8a>
 8002bf6:	4b22      	ldr	r3, [pc, #136]	; (8002c80 <OsTaskPriModify+0xf0>)
 8002bf8:	681c      	ldr	r4, [r3, #0]
 8002bfa:	6979      	ldr	r1, [r7, #20]
 8002bfc:	68fb      	ldr	r3, [r7, #12]
 8002bfe:	2b02      	cmp	r3, #2
 8002c00:	d904      	bls.n	8002c0c <OsTaskPriModify+0x7c>
 8002c02:	f107 0310 	add.w	r3, r7, #16
 8002c06:	f103 0208 	add.w	r2, r3, #8
 8002c0a:	e000      	b.n	8002c0e <OsTaskPriModify+0x7e>
 8002c0c:	2200      	movs	r2, #0
 8002c0e:	68fb      	ldr	r3, [r7, #12]
 8002c10:	b29b      	uxth	r3, r3
 8002c12:	3b02      	subs	r3, #2
 8002c14:	b29b      	uxth	r3, r3
 8002c16:	2041      	movs	r0, #65	; 0x41
 8002c18:	47a0      	blx	r4

    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {
 8002c1a:	687b      	ldr	r3, [r7, #4]
 8002c1c:	889b      	ldrh	r3, [r3, #4]
 8002c1e:	f003 0304 	and.w	r3, r3, #4
 8002c22:	2b00      	cmp	r3, #0
 8002c24:	d011      	beq.n	8002c4a <OsTaskPriModify+0xba>
        OsPriQueueDequeue(&taskCB->pendList);
 8002c26:	687b      	ldr	r3, [r7, #4]
 8002c28:	3340      	adds	r3, #64	; 0x40
 8002c2a:	4618      	mov	r0, r3
 8002c2c:	f005 fcfa 	bl	8008624 <OsPriQueueDequeue>
        taskCB->priority = priority;
 8002c30:	687b      	ldr	r3, [r7, #4]
 8002c32:	887a      	ldrh	r2, [r7, #2]
 8002c34:	80da      	strh	r2, [r3, #6]
        OsPriQueueEnqueue(&taskCB->pendList, taskCB->priority);
 8002c36:	687b      	ldr	r3, [r7, #4]
 8002c38:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8002c3c:	687b      	ldr	r3, [r7, #4]
 8002c3e:	88db      	ldrh	r3, [r3, #6]
 8002c40:	4619      	mov	r1, r3
 8002c42:	4610      	mov	r0, r2
 8002c44:	f005 fcac 	bl	80085a0 <OsPriQueueEnqueue>
    } else {
        taskCB->priority = priority;
    }
}
 8002c48:	e002      	b.n	8002c50 <OsTaskPriModify+0xc0>
        taskCB->priority = priority;
 8002c4a:	687b      	ldr	r3, [r7, #4]
 8002c4c:	887a      	ldrh	r2, [r7, #2]
 8002c4e:	80da      	strh	r2, [r3, #6]
}
 8002c50:	bf00      	nop
 8002c52:	4b05      	ldr	r3, [pc, #20]	; (8002c68 <OsTaskPriModify+0xd8>)
 8002c54:	681a      	ldr	r2, [r3, #0]
 8002c56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c58:	405a      	eors	r2, r3
 8002c5a:	d001      	beq.n	8002c60 <OsTaskPriModify+0xd0>
 8002c5c:	f001 fbc4 	bl	80043e8 <__stack_chk_fail>
 8002c60:	372c      	adds	r7, #44	; 0x2c
 8002c62:	46bd      	mov	sp, r7
 8002c64:	bd90      	pop	{r4, r7, pc}
 8002c66:	bf00      	nop
 8002c68:	08020068 	.word	0x08020068
 8002c6c:	20000764 	.word	0x20000764
 8002c70:	08020038 	.word	0x08020038
 8002c74:	080232ec 	.word	0x080232ec
 8002c78:	08020040 	.word	0x08020040
 8002c7c:	0802004c 	.word	0x0802004c
 8002c80:	2000075c 	.word	0x2000075c

08002c84 <OsTaskAdd2TimerList>:
 * Description : Add task to sorted delay list.
 * Input       : taskCB  --- task control block
 *               timeout --- wait time, ticks
 */
LITE_OS_SEC_TEXT VOID OsTaskAdd2TimerList(LosTaskCB *taskCB, UINT32 timeout)
{
 8002c84:	b580      	push	{r7, lr}
 8002c86:	b082      	sub	sp, #8
 8002c88:	af00      	add	r7, sp, #0
 8002c8a:	6078      	str	r0, [r7, #4]
 8002c8c:	6039      	str	r1, [r7, #0]
    SET_SORTLIST_VALUE(&(taskCB->sortList), timeout);
 8002c8e:	687b      	ldr	r3, [r7, #4]
 8002c90:	683a      	ldr	r2, [r7, #0]
 8002c92:	651a      	str	r2, [r3, #80]	; 0x50
    OsAdd2SortLink(&OsPercpuGet()->taskSortLink, &taskCB->sortList);
 8002c94:	f7ff fe5e 	bl	8002954 <OsPercpuGet>
 8002c98:	4603      	mov	r3, r0
 8002c9a:	461a      	mov	r2, r3
 8002c9c:	687b      	ldr	r3, [r7, #4]
 8002c9e:	3348      	adds	r3, #72	; 0x48
 8002ca0:	4619      	mov	r1, r3
 8002ca2:	4610      	mov	r0, r2
 8002ca4:	f006 fd32 	bl	800970c <OsAdd2SortLink>
#ifdef LOSCFG_KERNEL_SMP
    taskCB->timerCpu = ArchCurrCpuid();
#endif
}
 8002ca8:	bf00      	nop
 8002caa:	3708      	adds	r7, #8
 8002cac:	46bd      	mov	sp, r7
 8002cae:	bd80      	pop	{r7, pc}

08002cb0 <OsTimerListDelete>:

LITE_OS_SEC_TEXT VOID OsTimerListDelete(LosTaskCB *taskCB)
{
 8002cb0:	b580      	push	{r7, lr}
 8002cb2:	b084      	sub	sp, #16
 8002cb4:	af00      	add	r7, sp, #0
 8002cb6:	6078      	str	r0, [r7, #4]
    SortLinkAttribute *sortLinkHeader = NULL;
 8002cb8:	2300      	movs	r3, #0
 8002cba:	60fb      	str	r3, [r7, #12]
     * the task delay timer is on the specific processor,
     * we need delete the timer from that processor's sortlink.
     */
    sortLinkHeader = &g_percpu[taskCB->timerCpu].taskSortLink;
#else
    sortLinkHeader = &g_percpu[0].taskSortLink;
 8002cbc:	4b05      	ldr	r3, [pc, #20]	; (8002cd4 <OsTimerListDelete+0x24>)
 8002cbe:	60fb      	str	r3, [r7, #12]
#endif
    OsDeleteSortLink(sortLinkHeader, &taskCB->sortList);
 8002cc0:	687b      	ldr	r3, [r7, #4]
 8002cc2:	3348      	adds	r3, #72	; 0x48
 8002cc4:	4619      	mov	r1, r3
 8002cc6:	68f8      	ldr	r0, [r7, #12]
 8002cc8:	f006 fdca 	bl	8009860 <OsDeleteSortLink>
}
 8002ccc:	bf00      	nop
 8002cce:	3710      	adds	r7, #16
 8002cd0:	46bd      	mov	sp, r7
 8002cd2:	bd80      	pop	{r7, pc}
 8002cd4:	200036fc 	.word	0x200036fc

08002cd8 <OsTaskScan>:

LITE_OS_SEC_TEXT VOID OsTaskScan(VOID)
{
 8002cd8:	b580      	push	{r7, lr}
 8002cda:	b086      	sub	sp, #24
 8002cdc:	af00      	add	r7, sp, #0
    SortLinkList *sortList = NULL;
 8002cde:	2300      	movs	r3, #0
 8002ce0:	607b      	str	r3, [r7, #4]
    LosTaskCB *taskCB = NULL;
 8002ce2:	2300      	movs	r3, #0
 8002ce4:	60fb      	str	r3, [r7, #12]
    BOOL needSchedule = FALSE;
 8002ce6:	2300      	movs	r3, #0
 8002ce8:	60bb      	str	r3, [r7, #8]
    UINT16 tempStatus;
    LOS_DL_LIST *listObject = NULL;
 8002cea:	2300      	movs	r3, #0
 8002cec:	613b      	str	r3, [r7, #16]
    SortLinkAttribute *taskSortLink = NULL;
 8002cee:	2300      	movs	r3, #0
 8002cf0:	617b      	str	r3, [r7, #20]

    taskSortLink = &OsPercpuGet()->taskSortLink;
 8002cf2:	f7ff fe2f 	bl	8002954 <OsPercpuGet>
 8002cf6:	4603      	mov	r3, r0
 8002cf8:	617b      	str	r3, [r7, #20]
    SORTLINK_CURSOR_UPDATE(taskSortLink->cursor);
 8002cfa:	697b      	ldr	r3, [r7, #20]
 8002cfc:	889b      	ldrh	r3, [r3, #4]
 8002cfe:	3301      	adds	r3, #1
 8002d00:	b29b      	uxth	r3, r3
 8002d02:	f003 0307 	and.w	r3, r3, #7
 8002d06:	b29a      	uxth	r2, r3
 8002d08:	697b      	ldr	r3, [r7, #20]
 8002d0a:	809a      	strh	r2, [r3, #4]
    SORTLINK_LISTOBJ_GET(listObject, taskSortLink);
 8002d0c:	697b      	ldr	r3, [r7, #20]
 8002d0e:	681a      	ldr	r2, [r3, #0]
 8002d10:	697b      	ldr	r3, [r7, #20]
 8002d12:	889b      	ldrh	r3, [r3, #4]
 8002d14:	00db      	lsls	r3, r3, #3
 8002d16:	4413      	add	r3, r2
 8002d18:	613b      	str	r3, [r7, #16]
     * up by either timeout or corresponding ipc it's waiting.
     *
     * Now synchronize sortlink procedure is used, therefore the whole task scan needs
     * to be protected, preventing another core from doing sortlink deletion at same time.
     */
    LOS_SpinLock(&g_taskSpin);
 8002d1a:	4841      	ldr	r0, [pc, #260]	; (8002e20 <OsTaskScan+0x148>)
 8002d1c:	f7ff fe76 	bl	8002a0c <LOS_SpinLock>

    if (LOS_ListEmpty(listObject)) {
 8002d20:	6938      	ldr	r0, [r7, #16]
 8002d22:	f7ff fdd8 	bl	80028d6 <LOS_ListEmpty>
 8002d26:	4603      	mov	r3, r0
 8002d28:	2b00      	cmp	r3, #0
 8002d2a:	d003      	beq.n	8002d34 <OsTaskScan+0x5c>
        LOS_SpinUnlock(&g_taskSpin);
 8002d2c:	483c      	ldr	r0, [pc, #240]	; (8002e20 <OsTaskScan+0x148>)
 8002d2e:	f7ff fe77 	bl	8002a20 <LOS_SpinUnlock>
        return;
 8002d32:	e072      	b.n	8002e1a <OsTaskScan+0x142>
    }
    sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 8002d34:	693b      	ldr	r3, [r7, #16]
 8002d36:	685b      	ldr	r3, [r3, #4]
 8002d38:	607b      	str	r3, [r7, #4]
    ROLLNUM_DEC(sortList->idxRollNum);
 8002d3a:	687b      	ldr	r3, [r7, #4]
 8002d3c:	689b      	ldr	r3, [r3, #8]
 8002d3e:	1e5a      	subs	r2, r3, #1
 8002d40:	687b      	ldr	r3, [r7, #4]
 8002d42:	609a      	str	r2, [r3, #8]

    while (ROLLNUM(sortList->idxRollNum) == 0) {
 8002d44:	e056      	b.n	8002df4 <OsTaskScan+0x11c>
        LOS_ListDelete(&sortList->sortLinkNode);
 8002d46:	687b      	ldr	r3, [r7, #4]
 8002d48:	4618      	mov	r0, r3
 8002d4a:	f7ff fdaa 	bl	80028a2 <LOS_ListDelete>
        taskCB = LOS_DL_LIST_ENTRY(sortList, LosTaskCB, sortList);
 8002d4e:	687b      	ldr	r3, [r7, #4]
 8002d50:	3b48      	subs	r3, #72	; 0x48
 8002d52:	60fb      	str	r3, [r7, #12]
        taskCB->taskStatus &= ~OS_TASK_STATUS_PEND_TIME;
 8002d54:	68fb      	ldr	r3, [r7, #12]
 8002d56:	889b      	ldrh	r3, [r3, #4]
 8002d58:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002d5c:	b29a      	uxth	r2, r3
 8002d5e:	68fb      	ldr	r3, [r7, #12]
 8002d60:	809a      	strh	r2, [r3, #4]
        tempStatus = taskCB->taskStatus;
 8002d62:	68fb      	ldr	r3, [r7, #12]
 8002d64:	889b      	ldrh	r3, [r3, #4]
 8002d66:	807b      	strh	r3, [r7, #2]
        if (tempStatus & OS_TASK_STATUS_PEND) {
 8002d68:	887b      	ldrh	r3, [r7, #2]
 8002d6a:	f003 0308 	and.w	r3, r3, #8
 8002d6e:	2b00      	cmp	r3, #0
 8002d70:	d019      	beq.n	8002da6 <OsTaskScan+0xce>
            taskCB->taskStatus &= ~OS_TASK_STATUS_PEND;
 8002d72:	68fb      	ldr	r3, [r7, #12]
 8002d74:	889b      	ldrh	r3, [r3, #4]
 8002d76:	f023 0308 	bic.w	r3, r3, #8
 8002d7a:	b29a      	uxth	r2, r3
 8002d7c:	68fb      	ldr	r3, [r7, #12]
 8002d7e:	809a      	strh	r2, [r3, #4]
            taskCB->taskStatus |= OS_TASK_STATUS_TIMEOUT;
 8002d80:	68fb      	ldr	r3, [r7, #12]
 8002d82:	889b      	ldrh	r3, [r3, #4]
 8002d84:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002d88:	b29a      	uxth	r2, r3
 8002d8a:	68fb      	ldr	r3, [r7, #12]
 8002d8c:	809a      	strh	r2, [r3, #4]
            LOS_ListDelete(&taskCB->pendList);
 8002d8e:	68fb      	ldr	r3, [r7, #12]
 8002d90:	3340      	adds	r3, #64	; 0x40
 8002d92:	4618      	mov	r0, r3
 8002d94:	f7ff fd85 	bl	80028a2 <LOS_ListDelete>
            taskCB->taskSem = NULL;
 8002d98:	68fb      	ldr	r3, [r7, #12]
 8002d9a:	2200      	movs	r2, #0
 8002d9c:	61da      	str	r2, [r3, #28]
            taskCB->taskMux = NULL;
 8002d9e:	68fb      	ldr	r3, [r7, #12]
 8002da0:	2200      	movs	r2, #0
 8002da2:	629a      	str	r2, [r3, #40]	; 0x28
 8002da4:	e006      	b.n	8002db4 <OsTaskScan+0xdc>
        } else {
            taskCB->taskStatus &= ~OS_TASK_STATUS_DELAY;
 8002da6:	68fb      	ldr	r3, [r7, #12]
 8002da8:	889b      	ldrh	r3, [r3, #4]
 8002daa:	f023 0320 	bic.w	r3, r3, #32
 8002dae:	b29a      	uxth	r2, r3
 8002db0:	68fb      	ldr	r3, [r7, #12]
 8002db2:	809a      	strh	r2, [r3, #4]
        }

        if (!(tempStatus & OS_TASK_STATUS_SUSPEND)) {
 8002db4:	887b      	ldrh	r3, [r7, #2]
 8002db6:	f003 0302 	and.w	r3, r3, #2
 8002dba:	2b00      	cmp	r3, #0
 8002dbc:	d111      	bne.n	8002de2 <OsTaskScan+0x10a>
            taskCB->taskStatus |= OS_TASK_STATUS_READY;
 8002dbe:	68fb      	ldr	r3, [r7, #12]
 8002dc0:	889b      	ldrh	r3, [r3, #4]
 8002dc2:	f043 0304 	orr.w	r3, r3, #4
 8002dc6:	b29a      	uxth	r2, r3
 8002dc8:	68fb      	ldr	r3, [r7, #12]
 8002dca:	809a      	strh	r2, [r3, #4]
            OsPriQueueEnqueue(&taskCB->pendList, taskCB->priority);
 8002dcc:	68fb      	ldr	r3, [r7, #12]
 8002dce:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8002dd2:	68fb      	ldr	r3, [r7, #12]
 8002dd4:	88db      	ldrh	r3, [r3, #6]
 8002dd6:	4619      	mov	r1, r3
 8002dd8:	4610      	mov	r0, r2
 8002dda:	f005 fbe1 	bl	80085a0 <OsPriQueueEnqueue>
            needSchedule = TRUE;
 8002dde:	2301      	movs	r3, #1
 8002de0:	60bb      	str	r3, [r7, #8]
        }

        if (LOS_ListEmpty(listObject)) {
 8002de2:	6938      	ldr	r0, [r7, #16]
 8002de4:	f7ff fd77 	bl	80028d6 <LOS_ListEmpty>
 8002de8:	4603      	mov	r3, r0
 8002dea:	2b00      	cmp	r3, #0
 8002dec:	d109      	bne.n	8002e02 <OsTaskScan+0x12a>
            break;
        }

        sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 8002dee:	693b      	ldr	r3, [r7, #16]
 8002df0:	685b      	ldr	r3, [r3, #4]
 8002df2:	607b      	str	r3, [r7, #4]
    while (ROLLNUM(sortList->idxRollNum) == 0) {
 8002df4:	687b      	ldr	r3, [r7, #4]
 8002df6:	689b      	ldr	r3, [r3, #8]
 8002df8:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8002dfc:	2b00      	cmp	r3, #0
 8002dfe:	d0a2      	beq.n	8002d46 <OsTaskScan+0x6e>
 8002e00:	e000      	b.n	8002e04 <OsTaskScan+0x12c>
            break;
 8002e02:	bf00      	nop
    }

    LOS_SpinUnlock(&g_taskSpin);
 8002e04:	4806      	ldr	r0, [pc, #24]	; (8002e20 <OsTaskScan+0x148>)
 8002e06:	f7ff fe0b 	bl	8002a20 <LOS_SpinUnlock>

    if (needSchedule != FALSE) {
 8002e0a:	68bb      	ldr	r3, [r7, #8]
 8002e0c:	2b00      	cmp	r3, #0
 8002e0e:	d004      	beq.n	8002e1a <OsTaskScan+0x142>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 8002e10:	2001      	movs	r0, #1
 8002e12:	f7ff fe42 	bl	8002a9a <LOS_MpSchedule>
        LOS_Schedule();
 8002e16:	f7ff fde9 	bl	80029ec <LOS_Schedule>
    }
}
 8002e1a:	3718      	adds	r7, #24
 8002e1c:	46bd      	mov	sp, r7
 8002e1e:	bd80      	pop	{r7, pc}
 8002e20:	20000764 	.word	0x20000764

08002e24 <OsTaskInit>:

LITE_OS_SEC_TEXT_INIT UINT32 OsTaskInit(VOID)
{
 8002e24:	b580      	push	{r7, lr}
 8002e26:	b084      	sub	sp, #16
 8002e28:	af00      	add	r7, sp, #0
    UINT32 index;
    UINT32 ret;
    UINT32 size;

    size = (KERNEL_TSK_LIMIT + 1) * sizeof(LosTaskCB);
 8002e2a:	f44f 632a 	mov.w	r3, #2720	; 0xaa0
 8002e2e:	60bb      	str	r3, [r7, #8]
    /*
     * This memory is resident memory and is used to save the system resources
     * of task control block and will not be freed.
     */
    g_taskCBArray = (LosTaskCB *)LOS_MemAlloc(m_aucSysMem0, size);
 8002e30:	4b3b      	ldr	r3, [pc, #236]	; (8002f20 <OsTaskInit+0xfc>)
 8002e32:	681b      	ldr	r3, [r3, #0]
 8002e34:	68b9      	ldr	r1, [r7, #8]
 8002e36:	4618      	mov	r0, r3
 8002e38:	f005 fdb6 	bl	80089a8 <LOS_MemAlloc>
 8002e3c:	4603      	mov	r3, r0
 8002e3e:	4a39      	ldr	r2, [pc, #228]	; (8002f24 <OsTaskInit+0x100>)
 8002e40:	6013      	str	r3, [r2, #0]
    if (g_taskCBArray == NULL) {
 8002e42:	4b38      	ldr	r3, [pc, #224]	; (8002f24 <OsTaskInit+0x100>)
 8002e44:	681b      	ldr	r3, [r3, #0]
 8002e46:	2b00      	cmp	r3, #0
 8002e48:	d101      	bne.n	8002e4e <OsTaskInit+0x2a>
        return LOS_ERRNO_TSK_NO_MEMORY;
 8002e4a:	4b37      	ldr	r3, [pc, #220]	; (8002f28 <OsTaskInit+0x104>)
 8002e4c:	e063      	b.n	8002f16 <OsTaskInit+0xf2>
    }
    (VOID)memset_s(g_taskCBArray, size, 0, size);
 8002e4e:	4b35      	ldr	r3, [pc, #212]	; (8002f24 <OsTaskInit+0x100>)
 8002e50:	6818      	ldr	r0, [r3, #0]
 8002e52:	68bb      	ldr	r3, [r7, #8]
 8002e54:	2200      	movs	r2, #0
 8002e56:	68b9      	ldr	r1, [r7, #8]
 8002e58:	f013 f918 	bl	801608c <memset_s>

    LOS_ListInit(&g_losFreeTask);
 8002e5c:	4833      	ldr	r0, [pc, #204]	; (8002f2c <OsTaskInit+0x108>)
 8002e5e:	f7ff fce8 	bl	8002832 <LOS_ListInit>
    LOS_ListInit(&g_taskRecycleList);
 8002e62:	4833      	ldr	r0, [pc, #204]	; (8002f30 <OsTaskInit+0x10c>)
 8002e64:	f7ff fce5 	bl	8002832 <LOS_ListInit>
    for (index = 0; index < KERNEL_TSK_LIMIT; index++) {
 8002e68:	2300      	movs	r3, #0
 8002e6a:	607b      	str	r3, [r7, #4]
 8002e6c:	e023      	b.n	8002eb6 <OsTaskInit+0x92>
        g_taskCBArray[index].taskStatus = OS_TASK_STATUS_UNUSED;
 8002e6e:	4b2d      	ldr	r3, [pc, #180]	; (8002f24 <OsTaskInit+0x100>)
 8002e70:	6819      	ldr	r1, [r3, #0]
 8002e72:	687a      	ldr	r2, [r7, #4]
 8002e74:	4613      	mov	r3, r2
 8002e76:	009b      	lsls	r3, r3, #2
 8002e78:	4413      	add	r3, r2
 8002e7a:	015b      	lsls	r3, r3, #5
 8002e7c:	440b      	add	r3, r1
 8002e7e:	2201      	movs	r2, #1
 8002e80:	809a      	strh	r2, [r3, #4]
        g_taskCBArray[index].taskId = index;
 8002e82:	4b28      	ldr	r3, [pc, #160]	; (8002f24 <OsTaskInit+0x100>)
 8002e84:	6819      	ldr	r1, [r3, #0]
 8002e86:	687a      	ldr	r2, [r7, #4]
 8002e88:	4613      	mov	r3, r2
 8002e8a:	009b      	lsls	r3, r3, #2
 8002e8c:	4413      	add	r3, r2
 8002e8e:	015b      	lsls	r3, r3, #5
 8002e90:	440b      	add	r3, r1
 8002e92:	687a      	ldr	r2, [r7, #4]
 8002e94:	615a      	str	r2, [r3, #20]
        LOS_ListTailInsert(&g_losFreeTask, &g_taskCBArray[index].pendList);
 8002e96:	4b23      	ldr	r3, [pc, #140]	; (8002f24 <OsTaskInit+0x100>)
 8002e98:	6819      	ldr	r1, [r3, #0]
 8002e9a:	687a      	ldr	r2, [r7, #4]
 8002e9c:	4613      	mov	r3, r2
 8002e9e:	009b      	lsls	r3, r3, #2
 8002ea0:	4413      	add	r3, r2
 8002ea2:	015b      	lsls	r3, r3, #5
 8002ea4:	440b      	add	r3, r1
 8002ea6:	3340      	adds	r3, #64	; 0x40
 8002ea8:	4619      	mov	r1, r3
 8002eaa:	4820      	ldr	r0, [pc, #128]	; (8002f2c <OsTaskInit+0x108>)
 8002eac:	f7ff fcea 	bl	8002884 <LOS_ListTailInsert>
    for (index = 0; index < KERNEL_TSK_LIMIT; index++) {
 8002eb0:	687b      	ldr	r3, [r7, #4]
 8002eb2:	3301      	adds	r3, #1
 8002eb4:	607b      	str	r3, [r7, #4]
 8002eb6:	687b      	ldr	r3, [r7, #4]
 8002eb8:	2b0f      	cmp	r3, #15
 8002eba:	d9d8      	bls.n	8002e6e <OsTaskInit+0x4a>
    }

    ret = OsPriQueueInit();
 8002ebc:	f005 fb00 	bl	80084c0 <OsPriQueueInit>
 8002ec0:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 8002ec2:	68fb      	ldr	r3, [r7, #12]
 8002ec4:	2b00      	cmp	r3, #0
 8002ec6:	d001      	beq.n	8002ecc <OsTaskInit+0xa8>
        return LOS_ERRNO_TSK_NO_MEMORY;
 8002ec8:	4b17      	ldr	r3, [pc, #92]	; (8002f28 <OsTaskInit+0x104>)
 8002eca:	e024      	b.n	8002f16 <OsTaskInit+0xf2>
    }

    ret = OsMuxDlockCheckInitHook();
 8002ecc:	f7ff fdde 	bl	8002a8c <OsMuxDlockCheckInitHook>
 8002ed0:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 8002ed2:	68fb      	ldr	r3, [r7, #12]
 8002ed4:	2b00      	cmp	r3, #0
 8002ed6:	d001      	beq.n	8002edc <OsTaskInit+0xb8>
        return LOS_ERRNO_TSK_NO_MEMORY;
 8002ed8:	4b13      	ldr	r3, [pc, #76]	; (8002f28 <OsTaskInit+0x104>)
 8002eda:	e01c      	b.n	8002f16 <OsTaskInit+0xf2>
    }

    /* init sortlink for each core */
    for (index = 0; index < LOSCFG_KERNEL_CORE_NUM; index++) {
 8002edc:	2300      	movs	r3, #0
 8002ede:	607b      	str	r3, [r7, #4]
 8002ee0:	e012      	b.n	8002f08 <OsTaskInit+0xe4>
        ret = OsSortLinkInit(&g_percpu[index].taskSortLink);
 8002ee2:	687a      	ldr	r2, [r7, #4]
 8002ee4:	4613      	mov	r3, r2
 8002ee6:	00db      	lsls	r3, r3, #3
 8002ee8:	4413      	add	r3, r2
 8002eea:	009b      	lsls	r3, r3, #2
 8002eec:	4a11      	ldr	r2, [pc, #68]	; (8002f34 <OsTaskInit+0x110>)
 8002eee:	4413      	add	r3, r2
 8002ef0:	4618      	mov	r0, r3
 8002ef2:	f006 fbd5 	bl	80096a0 <OsSortLinkInit>
 8002ef6:	60f8      	str	r0, [r7, #12]
        if (ret != LOS_OK) {
 8002ef8:	68fb      	ldr	r3, [r7, #12]
 8002efa:	2b00      	cmp	r3, #0
 8002efc:	d001      	beq.n	8002f02 <OsTaskInit+0xde>
            return LOS_ERRNO_TSK_NO_MEMORY;
 8002efe:	4b0a      	ldr	r3, [pc, #40]	; (8002f28 <OsTaskInit+0x104>)
 8002f00:	e009      	b.n	8002f16 <OsTaskInit+0xf2>
    for (index = 0; index < LOSCFG_KERNEL_CORE_NUM; index++) {
 8002f02:	687b      	ldr	r3, [r7, #4]
 8002f04:	3301      	adds	r3, #1
 8002f06:	607b      	str	r3, [r7, #4]
 8002f08:	687b      	ldr	r3, [r7, #4]
 8002f0a:	2b00      	cmp	r3, #0
 8002f0c:	d0e9      	beq.n	8002ee2 <OsTaskInit+0xbe>
        }
    }

    g_taskMaxNum = KERNEL_TSK_LIMIT;
 8002f0e:	4b0a      	ldr	r3, [pc, #40]	; (8002f38 <OsTaskInit+0x114>)
 8002f10:	2210      	movs	r2, #16
 8002f12:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 8002f14:	2300      	movs	r3, #0
}
 8002f16:	4618      	mov	r0, r3
 8002f18:	3710      	adds	r7, #16
 8002f1a:	46bd      	mov	sp, r7
 8002f1c:	bd80      	pop	{r7, pc}
 8002f1e:	bf00      	nop
 8002f20:	200021b4 	.word	0x200021b4
 8002f24:	200036c4 	.word	0x200036c4
 8002f28:	03000200 	.word	0x03000200
 8002f2c:	200036d0 	.word	0x200036d0
 8002f30:	200036c8 	.word	0x200036c8
 8002f34:	200036fc 	.word	0x200036fc
 8002f38:	200036d8 	.word	0x200036d8

08002f3c <OsGetIdleTaskId>:

UINT32 OsGetIdleTaskId(VOID)
{
 8002f3c:	b580      	push	{r7, lr}
 8002f3e:	b082      	sub	sp, #8
 8002f40:	af00      	add	r7, sp, #0
    Percpu *perCpu = OsPercpuGet();
 8002f42:	f7ff fd07 	bl	8002954 <OsPercpuGet>
 8002f46:	6078      	str	r0, [r7, #4]
    return perCpu->idleTaskId;
 8002f48:	687b      	ldr	r3, [r7, #4]
 8002f4a:	691b      	ldr	r3, [r3, #16]
}
 8002f4c:	4618      	mov	r0, r3
 8002f4e:	3708      	adds	r7, #8
 8002f50:	46bd      	mov	sp, r7
 8002f52:	bd80      	pop	{r7, pc}

08002f54 <OsIdleTaskCreate>:

LITE_OS_SEC_TEXT_INIT UINT32 OsIdleTaskCreate(VOID)
{
 8002f54:	b580      	push	{r7, lr}
 8002f56:	b08e      	sub	sp, #56	; 0x38
 8002f58:	af00      	add	r7, sp, #0
 8002f5a:	4b26      	ldr	r3, [pc, #152]	; (8002ff4 <OsIdleTaskCreate+0xa0>)
 8002f5c:	681b      	ldr	r3, [r3, #0]
 8002f5e:	637b      	str	r3, [r7, #52]	; 0x34
 8002f60:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    TSK_INIT_PARAM_S taskInitParam;
    Percpu *perCpu = OsPercpuGet();
 8002f64:	f7ff fcf6 	bl	8002954 <OsPercpuGet>
 8002f68:	6078      	str	r0, [r7, #4]
    UINT32 *idleTaskId = &perCpu->idleTaskId;
 8002f6a:	687b      	ldr	r3, [r7, #4]
 8002f6c:	3310      	adds	r3, #16
 8002f6e:	60bb      	str	r3, [r7, #8]

    (VOID)memset_s((VOID *)(&taskInitParam), sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
 8002f70:	f107 0010 	add.w	r0, r7, #16
 8002f74:	2324      	movs	r3, #36	; 0x24
 8002f76:	2200      	movs	r2, #0
 8002f78:	2124      	movs	r1, #36	; 0x24
 8002f7a:	f013 f887 	bl	801608c <memset_s>
    taskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)OsIdleTask;
 8002f7e:	4b1e      	ldr	r3, [pc, #120]	; (8002ff8 <OsIdleTaskCreate+0xa4>)
 8002f80:	613b      	str	r3, [r7, #16]
    taskInitParam.uwStackSize = KERNEL_TSK_IDLE_STACK_SIZE;
 8002f82:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8002f86:	62bb      	str	r3, [r7, #40]	; 0x28
    taskInitParam.pcName = "IdleCore000";
 8002f88:	4b1c      	ldr	r3, [pc, #112]	; (8002ffc <OsIdleTaskCreate+0xa8>)
 8002f8a:	62fb      	str	r3, [r7, #44]	; 0x2c
    taskInitParam.usTaskPrio = OS_TASK_PRIORITY_LOWEST;
 8002f8c:	231f      	movs	r3, #31
 8002f8e:	82bb      	strh	r3, [r7, #20]
#ifdef LOSCFG_KERNEL_SMP
    taskInitParam.usCpuAffiMask = CPUID_TO_AFFI_MASK(ArchCurrCpuid());
#endif
    ret = LOS_TaskCreate(idleTaskId, &taskInitParam);
 8002f90:	f107 0310 	add.w	r3, r7, #16
 8002f94:	4619      	mov	r1, r3
 8002f96:	68b8      	ldr	r0, [r7, #8]
 8002f98:	f000 fcce 	bl	8003938 <LOS_TaskCreate>
 8002f9c:	60f8      	str	r0, [r7, #12]
    if (ret == LOS_OK) {
 8002f9e:	68fb      	ldr	r3, [r7, #12]
 8002fa0:	2b00      	cmp	r3, #0
 8002fa2:	d11a      	bne.n	8002fda <OsIdleTaskCreate+0x86>
        OS_TCB_FROM_TID(*idleTaskId)->taskFlags |= OS_TASK_FLAG_SYSTEM;
 8002fa4:	4b16      	ldr	r3, [pc, #88]	; (8003000 <OsIdleTaskCreate+0xac>)
 8002fa6:	6819      	ldr	r1, [r3, #0]
 8002fa8:	68bb      	ldr	r3, [r7, #8]
 8002faa:	681a      	ldr	r2, [r3, #0]
 8002fac:	4613      	mov	r3, r2
 8002fae:	009b      	lsls	r3, r3, #2
 8002fb0:	4413      	add	r3, r2
 8002fb2:	015b      	lsls	r3, r3, #5
 8002fb4:	440b      	add	r3, r1
 8002fb6:	689b      	ldr	r3, [r3, #8]
 8002fb8:	f3c3 011e 	ubfx	r1, r3, #0, #31
 8002fbc:	4b10      	ldr	r3, [pc, #64]	; (8003000 <OsIdleTaskCreate+0xac>)
 8002fbe:	6818      	ldr	r0, [r3, #0]
 8002fc0:	68bb      	ldr	r3, [r7, #8]
 8002fc2:	681a      	ldr	r2, [r3, #0]
 8002fc4:	4613      	mov	r3, r2
 8002fc6:	009b      	lsls	r3, r3, #2
 8002fc8:	4413      	add	r3, r2
 8002fca:	015b      	lsls	r3, r3, #5
 8002fcc:	18c2      	adds	r2, r0, r3
 8002fce:	f041 0102 	orr.w	r1, r1, #2
 8002fd2:	6893      	ldr	r3, [r2, #8]
 8002fd4:	f361 031e 	bfi	r3, r1, #0, #31
 8002fd8:	6093      	str	r3, [r2, #8]
    }

    return ret;
 8002fda:	68fb      	ldr	r3, [r7, #12]
}
 8002fdc:	4a05      	ldr	r2, [pc, #20]	; (8002ff4 <OsIdleTaskCreate+0xa0>)
 8002fde:	6811      	ldr	r1, [r2, #0]
 8002fe0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002fe2:	4051      	eors	r1, r2
 8002fe4:	d001      	beq.n	8002fea <OsIdleTaskCreate+0x96>
 8002fe6:	f001 f9ff 	bl	80043e8 <__stack_chk_fail>
 8002fea:	4618      	mov	r0, r3
 8002fec:	3738      	adds	r7, #56	; 0x38
 8002fee:	46bd      	mov	sp, r7
 8002ff0:	bd80      	pop	{r7, pc}
 8002ff2:	bf00      	nop
 8002ff4:	08020078 	.word	0x08020078
 8002ff8:	08002b61 	.word	0x08002b61
 8002ffc:	0802006c 	.word	0x0802006c
 8003000:	200036c4 	.word	0x200036c4

08003004 <LOS_CurTaskIDGet>:
/*
 * Description : get id of current running task.
 * Return      : task id
 */
LITE_OS_SEC_TEXT UINT32 LOS_CurTaskIDGet(VOID)
{
 8003004:	b580      	push	{r7, lr}
 8003006:	b082      	sub	sp, #8
 8003008:	af00      	add	r7, sp, #0
    LosTaskCB *runTask = OsCurrTaskGet();
 800300a:	f7ff fd38 	bl	8002a7e <OsCurrTaskGet>
 800300e:	6078      	str	r0, [r7, #4]

    if (runTask == NULL) {
 8003010:	687b      	ldr	r3, [r7, #4]
 8003012:	2b00      	cmp	r3, #0
 8003014:	d101      	bne.n	800301a <LOS_CurTaskIDGet+0x16>
        return LOS_ERRNO_TSK_ID_INVALID;
 8003016:	4b04      	ldr	r3, [pc, #16]	; (8003028 <LOS_CurTaskIDGet+0x24>)
 8003018:	e001      	b.n	800301e <LOS_CurTaskIDGet+0x1a>
    }
    return runTask->taskId;
 800301a:	687b      	ldr	r3, [r7, #4]
 800301c:	695b      	ldr	r3, [r3, #20]
}
 800301e:	4618      	mov	r0, r3
 8003020:	3708      	adds	r7, #8
 8003022:	46bd      	mov	sp, r7
 8003024:	bd80      	pop	{r7, pc}
 8003026:	bf00      	nop
 8003028:	02000207 	.word	0x02000207

0800302c <OsTaskStackCheck>:
    return NULL;
}

#ifdef LOSCFG_BASE_CORE_TSK_MONITOR
LITE_OS_SEC_TEXT STATIC VOID OsTaskStackCheck(const LosTaskCB *oldTask, const LosTaskCB *newTask)
{
 800302c:	b580      	push	{r7, lr}
 800302e:	b084      	sub	sp, #16
 8003030:	af02      	add	r7, sp, #8
 8003032:	6078      	str	r0, [r7, #4]
 8003034:	6039      	str	r1, [r7, #0]
    if (!OS_STACK_MAGIC_CHECK(oldTask->topOfStack)) {
 8003036:	687b      	ldr	r3, [r7, #4]
 8003038:	691b      	ldr	r3, [r3, #16]
 800303a:	681b      	ldr	r3, [r3, #0]
 800303c:	f1b3 3fcc 	cmp.w	r3, #3435973836	; 0xcccccccc
 8003040:	d007      	beq.n	8003052 <OsTaskStackCheck+0x26>
        LOS_Panic("CURRENT task ID: %s:%u stack overflow!\n", oldTask->taskName, oldTask->taskId);
 8003042:	687b      	ldr	r3, [r7, #4]
 8003044:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8003046:	687b      	ldr	r3, [r7, #4]
 8003048:	695b      	ldr	r3, [r3, #20]
 800304a:	461a      	mov	r2, r3
 800304c:	4814      	ldr	r0, [pc, #80]	; (80030a0 <OsTaskStackCheck+0x74>)
 800304e:	f001 f945 	bl	80042dc <LOS_Panic>
    }

    if (((UINTPTR)(newTask->stackPointer) <= newTask->topOfStack) ||
 8003052:	683b      	ldr	r3, [r7, #0]
 8003054:	681b      	ldr	r3, [r3, #0]
 8003056:	461a      	mov	r2, r3
 8003058:	683b      	ldr	r3, [r7, #0]
 800305a:	691b      	ldr	r3, [r3, #16]
 800305c:	429a      	cmp	r2, r3
 800305e:	d909      	bls.n	8003074 <OsTaskStackCheck+0x48>
        ((UINTPTR)(newTask->stackPointer) > (newTask->topOfStack + newTask->stackSize))) {
 8003060:	683b      	ldr	r3, [r7, #0]
 8003062:	681b      	ldr	r3, [r3, #0]
 8003064:	4619      	mov	r1, r3
 8003066:	683b      	ldr	r3, [r7, #0]
 8003068:	691a      	ldr	r2, [r3, #16]
 800306a:	683b      	ldr	r3, [r7, #0]
 800306c:	68db      	ldr	r3, [r3, #12]
 800306e:	4413      	add	r3, r2
    if (((UINTPTR)(newTask->stackPointer) <= newTask->topOfStack) ||
 8003070:	4299      	cmp	r1, r3
 8003072:	d90c      	bls.n	800308e <OsTaskStackCheck+0x62>
        LOS_Panic("HIGHEST task ID: %s:%u SP error! StackPointer: %p TopOfStack: %p\n",
 8003074:	683b      	ldr	r3, [r7, #0]
 8003076:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8003078:	683b      	ldr	r3, [r7, #0]
 800307a:	695a      	ldr	r2, [r3, #20]
 800307c:	683b      	ldr	r3, [r7, #0]
 800307e:	6818      	ldr	r0, [r3, #0]
 8003080:	683b      	ldr	r3, [r7, #0]
 8003082:	691b      	ldr	r3, [r3, #16]
 8003084:	9300      	str	r3, [sp, #0]
 8003086:	4603      	mov	r3, r0
 8003088:	4806      	ldr	r0, [pc, #24]	; (80030a4 <OsTaskStackCheck+0x78>)
 800308a:	f001 f927 	bl	80042dc <LOS_Panic>
                  newTask->taskName, newTask->taskId, newTask->stackPointer, newTask->topOfStack);
    }

    if (OsExcStackCheckHook != NULL) {
 800308e:	4b06      	ldr	r3, [pc, #24]	; (80030a8 <OsTaskStackCheck+0x7c>)
 8003090:	2b00      	cmp	r3, #0
 8003092:	d001      	beq.n	8003098 <OsTaskStackCheck+0x6c>
        OsExcStackCheckHook();
 8003094:	f3af 8000 	nop.w
    }
}
 8003098:	bf00      	nop
 800309a:	3708      	adds	r7, #8
 800309c:	46bd      	mov	sp, r7
 800309e:	bd80      	pop	{r7, pc}
 80030a0:	0802007c 	.word	0x0802007c
 80030a4:	080200a4 	.word	0x080200a4
 80030a8:	00000000 	.word	0x00000000

080030ac <OsTaskMonInit>:

LITE_OS_SEC_TEXT_MINOR VOID OsTaskMonInit(VOID)
{
 80030ac:	b480      	push	{r7}
 80030ae:	af00      	add	r7, sp, #0
    g_pfnUsrTskSwitchHook = NULL;
 80030b0:	4b03      	ldr	r3, [pc, #12]	; (80030c0 <OsTaskMonInit+0x14>)
 80030b2:	2200      	movs	r2, #0
 80030b4:	601a      	str	r2, [r3, #0]
}
 80030b6:	bf00      	nop
 80030b8:	46bd      	mov	sp, r7
 80030ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030be:	4770      	bx	lr
 80030c0:	20000768 	.word	0x20000768

080030c4 <OsTaskSwitchCheck>:
{
    g_pfnUsrTskSwitchHook = hook;
}

LITE_OS_SEC_TEXT_MINOR VOID OsTaskSwitchCheck(const LosTaskCB *oldTask, const LosTaskCB *newTask)
{
 80030c4:	b580      	push	{r7, lr}
 80030c6:	b082      	sub	sp, #8
 80030c8:	af00      	add	r7, sp, #0
 80030ca:	6078      	str	r0, [r7, #4]
 80030cc:	6039      	str	r1, [r7, #0]
    OsTaskStackCheck(oldTask, newTask);
 80030ce:	6839      	ldr	r1, [r7, #0]
 80030d0:	6878      	ldr	r0, [r7, #4]
 80030d2:	f7ff ffab 	bl	800302c <OsTaskStackCheck>

    if (g_pfnUsrTskSwitchHook != NULL) {
 80030d6:	4b05      	ldr	r3, [pc, #20]	; (80030ec <OsTaskSwitchCheck+0x28>)
 80030d8:	681b      	ldr	r3, [r3, #0]
 80030da:	2b00      	cmp	r3, #0
 80030dc:	d002      	beq.n	80030e4 <OsTaskSwitchCheck+0x20>
        g_pfnUsrTskSwitchHook();
 80030de:	4b03      	ldr	r3, [pc, #12]	; (80030ec <OsTaskSwitchCheck+0x28>)
 80030e0:	681b      	ldr	r3, [r3, #0]
 80030e2:	4798      	blx	r3
    }
}
 80030e4:	bf00      	nop
 80030e6:	3708      	adds	r7, #8
 80030e8:	46bd      	mov	sp, r7
 80030ea:	bd80      	pop	{r7, pc}
 80030ec:	20000768 	.word	0x20000768

080030f0 <LOS_LowpowerHookReg>:
#endif /* LOSCFG_BASE_CORE_TSK_MONITOR */

#ifdef LOSCFG_KERNEL_LOWPOWER
LITE_OS_SEC_TEXT_MINOR VOID LOS_LowpowerHookReg(LOWPOWERIDLEHOOK hook)
{
 80030f0:	b480      	push	{r7}
 80030f2:	b083      	sub	sp, #12
 80030f4:	af00      	add	r7, sp, #0
 80030f6:	6078      	str	r0, [r7, #4]
    g_lowPowerHook = hook;
 80030f8:	4a04      	ldr	r2, [pc, #16]	; (800310c <LOS_LowpowerHookReg+0x1c>)
 80030fa:	687b      	ldr	r3, [r7, #4]
 80030fc:	6013      	str	r3, [r2, #0]
}
 80030fe:	bf00      	nop
 8003100:	370c      	adds	r7, #12
 8003102:	46bd      	mov	sp, r7
 8003104:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003108:	4770      	bx	lr
 800310a:	bf00      	nop
 800310c:	2000076c 	.word	0x2000076c

08003110 <OsTaskDeleteCheckDetached>:
{
    g_idleHandlerHook = hook;
}

STATIC BOOL OsTaskDeleteCheckDetached(const LosTaskCB *taskCB)
{
 8003110:	b480      	push	{r7}
 8003112:	b083      	sub	sp, #12
 8003114:	af00      	add	r7, sp, #0
 8003116:	6078      	str	r0, [r7, #4]
#if LOSCFG_COMPAT_POSIX
    return ((taskCB->taskFlags & OS_TASK_FLAG_DETACHED) != 0);
 8003118:	687b      	ldr	r3, [r7, #4]
 800311a:	689b      	ldr	r3, [r3, #8]
 800311c:	f3c3 031e 	ubfx	r3, r3, #0, #31
 8003120:	f003 0301 	and.w	r3, r3, #1
 8003124:	2b00      	cmp	r3, #0
 8003126:	bf14      	ite	ne
 8003128:	2301      	movne	r3, #1
 800312a:	2300      	moveq	r3, #0
 800312c:	b2db      	uxtb	r3, r3
#else
    return TRUE;
#endif
}
 800312e:	4618      	mov	r0, r3
 8003130:	370c      	adds	r7, #12
 8003132:	46bd      	mov	sp, r7
 8003134:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003138:	4770      	bx	lr

0800313a <OsTaskDeleteDetached>:

STATIC VOID OsTaskDeleteDetached(const LosTaskCB *taskCB)
{
 800313a:	b580      	push	{r7, lr}
 800313c:	b084      	sub	sp, #16
 800313e:	af00      	add	r7, sp, #0
 8003140:	6078      	str	r0, [r7, #4]
    UINT32 intSave;
    intSave = LOS_IntLock();
 8003142:	f7ff fbe2 	bl	800290a <LOS_IntLock>
 8003146:	60f8      	str	r0, [r7, #12]
    OsPercpuGet()->taskLockCnt = 0;
 8003148:	f7ff fc04 	bl	8002954 <OsPercpuGet>
 800314c:	4603      	mov	r3, r0
 800314e:	2200      	movs	r2, #0
 8003150:	615a      	str	r2, [r3, #20]
    LOS_IntRestore(intSave);
 8003152:	68f8      	ldr	r0, [r7, #12]
 8003154:	f7ff fbe7 	bl	8002926 <LOS_IntRestore>
    (VOID)LOS_TaskDelete(taskCB->taskId);
 8003158:	687b      	ldr	r3, [r7, #4]
 800315a:	695b      	ldr	r3, [r3, #20]
 800315c:	4618      	mov	r0, r3
 800315e:	f000 fc03 	bl	8003968 <LOS_TaskDelete>
}
 8003162:	bf00      	nop
 8003164:	3710      	adds	r7, #16
 8003166:	46bd      	mov	sp, r7
 8003168:	bd80      	pop	{r7, pc}
	...

0800316c <OsTaskDeleteJoined>:

STATIC VOID OsTaskDeleteJoined(LosTaskCB *taskCB, VOID *ret)
{
 800316c:	b580      	push	{r7, lr}
 800316e:	b084      	sub	sp, #16
 8003170:	af00      	add	r7, sp, #0
 8003172:	6078      	str	r0, [r7, #4]
 8003174:	6039      	str	r1, [r7, #0]
#ifdef LOSCFG_COMPAT_POSIX
    UINT32 intSave;
    taskCB->threadJoinRetval = ret;
 8003176:	687b      	ldr	r3, [r7, #4]
 8003178:	683a      	ldr	r2, [r7, #0]
 800317a:	625a      	str	r2, [r3, #36]	; 0x24

    intSave = LOS_IntLock();
 800317c:	f7ff fbc5 	bl	800290a <LOS_IntLock>
 8003180:	60f8      	str	r0, [r7, #12]
    OsPercpuGet()->taskLockCnt = 1;
 8003182:	f7ff fbe7 	bl	8002954 <OsPercpuGet>
 8003186:	4603      	mov	r3, r0
 8003188:	2201      	movs	r2, #1
 800318a:	615a      	str	r2, [r3, #20]

    if (taskCB->threadJoin != NULL) {
 800318c:	687b      	ldr	r3, [r7, #4]
 800318e:	6a1b      	ldr	r3, [r3, #32]
 8003190:	2b00      	cmp	r3, #0
 8003192:	d011      	beq.n	80031b8 <OsTaskDeleteJoined+0x4c>
        if (LOS_SemPost((UINT32)(((LosSemCB *)taskCB->threadJoin)->semId)) != LOS_OK) {
 8003194:	687b      	ldr	r3, [r7, #4]
 8003196:	6a1b      	ldr	r3, [r3, #32]
 8003198:	685b      	ldr	r3, [r3, #4]
 800319a:	4618      	mov	r0, r3
 800319c:	f001 fc26 	bl	80049ec <LOS_SemPost>
 80031a0:	4603      	mov	r3, r0
 80031a2:	2b00      	cmp	r3, #0
 80031a4:	d005      	beq.n	80031b2 <OsTaskDeleteJoined+0x46>
            PRINT_ERR("OsTaskEntry LOS_SemPost fail!\n");
 80031a6:	480e      	ldr	r0, [pc, #56]	; (80031e0 <OsTaskDeleteJoined+0x74>)
 80031a8:	f001 fa90 	bl	80046cc <dprintf>
 80031ac:	480d      	ldr	r0, [pc, #52]	; (80031e4 <OsTaskDeleteJoined+0x78>)
 80031ae:	f001 fa8d 	bl	80046cc <dprintf>
        }
        taskCB->threadJoin = NULL;
 80031b2:	687b      	ldr	r3, [r7, #4]
 80031b4:	2200      	movs	r2, #0
 80031b6:	621a      	str	r2, [r3, #32]
    }
    OsPercpuGet()->taskLockCnt = 0;
 80031b8:	f7ff fbcc 	bl	8002954 <OsPercpuGet>
 80031bc:	4603      	mov	r3, r0
 80031be:	2200      	movs	r2, #0
 80031c0:	615a      	str	r2, [r3, #20]

    LOS_SpinLock(&g_taskSpin);
 80031c2:	4809      	ldr	r0, [pc, #36]	; (80031e8 <OsTaskDeleteJoined+0x7c>)
 80031c4:	f7ff fc22 	bl	8002a0c <LOS_SpinLock>
    OsSchedResched();
 80031c8:	f004 ffc0 	bl	800814c <OsSchedResched>

    LOS_SpinUnlock(&g_taskSpin);
 80031cc:	4806      	ldr	r0, [pc, #24]	; (80031e8 <OsTaskDeleteJoined+0x7c>)
 80031ce:	f7ff fc27 	bl	8002a20 <LOS_SpinUnlock>
    LOS_IntRestore(intSave);
 80031d2:	68f8      	ldr	r0, [r7, #12]
 80031d4:	f7ff fba7 	bl	8002926 <LOS_IntRestore>
#endif
}
 80031d8:	bf00      	nop
 80031da:	3710      	adds	r7, #16
 80031dc:	46bd      	mov	sp, r7
 80031de:	bd80      	pop	{r7, pc}
 80031e0:	08020038 	.word	0x08020038
 80031e4:	080200e8 	.word	0x080200e8
 80031e8:	20000764 	.word	0x20000764

080031ec <OsTaskEntry>:
/*
 * Description : All task entry
 * Input       : taskId     --- The ID of the task to be run
 */
LITE_OS_SEC_TEXT_INIT VOID OsTaskEntry(UINT32 taskId)
{
 80031ec:	b590      	push	{r4, r7, lr}
 80031ee:	b085      	sub	sp, #20
 80031f0:	af00      	add	r7, sp, #0
 80031f2:	6078      	str	r0, [r7, #4]
    LosTaskCB *taskCB = NULL;
 80031f4:	2300      	movs	r3, #0
 80031f6:	60bb      	str	r3, [r7, #8]
    VOID *ret = NULL;
 80031f8:	2300      	movs	r3, #0
 80031fa:	60fb      	str	r3, [r7, #12]

    LOS_ASSERT(OS_TSK_GET_INDEX(taskId) < g_taskMaxNum);
 80031fc:	4b1e      	ldr	r3, [pc, #120]	; (8003278 <OsTaskEntry+0x8c>)
 80031fe:	681b      	ldr	r3, [r3, #0]
 8003200:	687a      	ldr	r2, [r7, #4]
 8003202:	429a      	cmp	r2, r3
 8003204:	d30c      	bcc.n	8003220 <OsTaskEntry+0x34>
 8003206:	f7ff fb80 	bl	800290a <LOS_IntLock>
 800320a:	481c      	ldr	r0, [pc, #112]	; (800327c <OsTaskEntry+0x90>)
 800320c:	f001 fa5e 	bl	80046cc <dprintf>
 8003210:	4b1b      	ldr	r3, [pc, #108]	; (8003280 <OsTaskEntry+0x94>)
 8003212:	f240 12e9 	movw	r2, #489	; 0x1e9
 8003216:	491b      	ldr	r1, [pc, #108]	; (8003284 <OsTaskEntry+0x98>)
 8003218:	481b      	ldr	r0, [pc, #108]	; (8003288 <OsTaskEntry+0x9c>)
 800321a:	f001 fa57 	bl	80046cc <dprintf>
 800321e:	e7fe      	b.n	800321e <OsTaskEntry+0x32>
    /*
     * task scheduler needs to be protected throughout the whole process
     * from interrupt and other cores. release task spinlock and enable
     * interrupt in sequence at the task entry.
     */
    LOS_SpinUnlock(&g_taskSpin);
 8003220:	481a      	ldr	r0, [pc, #104]	; (800328c <OsTaskEntry+0xa0>)
 8003222:	f7ff fbfd 	bl	8002a20 <LOS_SpinUnlock>
    (VOID)LOS_IntUnLock();
 8003226:	f7ff fb77 	bl	8002918 <LOS_IntUnLock>

    taskCB = OS_TCB_FROM_TID(taskId);
 800322a:	4b19      	ldr	r3, [pc, #100]	; (8003290 <OsTaskEntry+0xa4>)
 800322c:	6819      	ldr	r1, [r3, #0]
 800322e:	687a      	ldr	r2, [r7, #4]
 8003230:	4613      	mov	r3, r2
 8003232:	009b      	lsls	r3, r3, #2
 8003234:	4413      	add	r3, r2
 8003236:	015b      	lsls	r3, r3, #5
 8003238:	440b      	add	r3, r1
 800323a:	60bb      	str	r3, [r7, #8]

#ifdef LOSCFG_OBSOLETE_API
    ret = taskCB->taskEntry(taskCB->args[0], taskCB->args[1], taskCB->args[2],
 800323c:	68bb      	ldr	r3, [r7, #8]
 800323e:	699c      	ldr	r4, [r3, #24]
 8003240:	68bb      	ldr	r3, [r7, #8]
 8003242:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8003244:	68bb      	ldr	r3, [r7, #8]
 8003246:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8003248:	68bb      	ldr	r3, [r7, #8]
 800324a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800324c:	68bb      	ldr	r3, [r7, #8]
 800324e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003250:	47a0      	blx	r4
 8003252:	60f8      	str	r0, [r7, #12]
        taskCB->args[3]); /* 0~3: just for args array index */
#else
    ret = taskCB->taskEntry(taskCB->args);
#endif

    if (OsTaskDeleteCheckDetached(taskCB)) {
 8003254:	68b8      	ldr	r0, [r7, #8]
 8003256:	f7ff ff5b 	bl	8003110 <OsTaskDeleteCheckDetached>
 800325a:	4603      	mov	r3, r0
 800325c:	2b00      	cmp	r3, #0
 800325e:	d003      	beq.n	8003268 <OsTaskEntry+0x7c>
        OsTaskDeleteDetached(taskCB);
 8003260:	68b8      	ldr	r0, [r7, #8]
 8003262:	f7ff ff6a 	bl	800313a <OsTaskDeleteDetached>
    } else {
        OsTaskDeleteJoined(taskCB, ret);
    }
}
 8003266:	e003      	b.n	8003270 <OsTaskEntry+0x84>
        OsTaskDeleteJoined(taskCB, ret);
 8003268:	68f9      	ldr	r1, [r7, #12]
 800326a:	68b8      	ldr	r0, [r7, #8]
 800326c:	f7ff ff7e 	bl	800316c <OsTaskDeleteJoined>
}
 8003270:	bf00      	nop
 8003272:	3714      	adds	r7, #20
 8003274:	46bd      	mov	sp, r7
 8003276:	bd90      	pop	{r4, r7, pc}
 8003278:	200036d8 	.word	0x200036d8
 800327c:	08020038 	.word	0x08020038
 8003280:	080232fc 	.word	0x080232fc
 8003284:	08020040 	.word	0x08020040
 8003288:	0802004c 	.word	0x0802004c
 800328c:	20000764 	.word	0x20000764
 8003290:	200036c4 	.word	0x200036c4

08003294 <OsTaskInitParamCheck>:

STATIC UINT32 OsTaskInitParamCheck(const TSK_INIT_PARAM_S *initParam)
{
 8003294:	b480      	push	{r7}
 8003296:	b083      	sub	sp, #12
 8003298:	af00      	add	r7, sp, #0
 800329a:	6078      	str	r0, [r7, #4]
    if (initParam == NULL) {
 800329c:	687b      	ldr	r3, [r7, #4]
 800329e:	2b00      	cmp	r3, #0
 80032a0:	d101      	bne.n	80032a6 <OsTaskInitParamCheck+0x12>
        return LOS_ERRNO_TSK_PTR_NULL;
 80032a2:	4b0d      	ldr	r3, [pc, #52]	; (80032d8 <OsTaskInitParamCheck+0x44>)
 80032a4:	e012      	b.n	80032cc <OsTaskInitParamCheck+0x38>
    }

    if (initParam->pcName == NULL) {
 80032a6:	687b      	ldr	r3, [r7, #4]
 80032a8:	69db      	ldr	r3, [r3, #28]
 80032aa:	2b00      	cmp	r3, #0
 80032ac:	d101      	bne.n	80032b2 <OsTaskInitParamCheck+0x1e>
        return LOS_ERRNO_TSK_NAME_EMPTY;
 80032ae:	4b0b      	ldr	r3, [pc, #44]	; (80032dc <OsTaskInitParamCheck+0x48>)
 80032b0:	e00c      	b.n	80032cc <OsTaskInitParamCheck+0x38>
    }

    if (initParam->pfnTaskEntry == NULL) {
 80032b2:	687b      	ldr	r3, [r7, #4]
 80032b4:	681b      	ldr	r3, [r3, #0]
 80032b6:	2b00      	cmp	r3, #0
 80032b8:	d101      	bne.n	80032be <OsTaskInitParamCheck+0x2a>
        return LOS_ERRNO_TSK_ENTRY_NULL;
 80032ba:	4b09      	ldr	r3, [pc, #36]	; (80032e0 <OsTaskInitParamCheck+0x4c>)
 80032bc:	e006      	b.n	80032cc <OsTaskInitParamCheck+0x38>
    }

    if (initParam->usTaskPrio > OS_TASK_PRIORITY_LOWEST) {
 80032be:	687b      	ldr	r3, [r7, #4]
 80032c0:	889b      	ldrh	r3, [r3, #4]
 80032c2:	2b1f      	cmp	r3, #31
 80032c4:	d901      	bls.n	80032ca <OsTaskInitParamCheck+0x36>
        return LOS_ERRNO_TSK_PRIOR_ERROR;
 80032c6:	4b07      	ldr	r3, [pc, #28]	; (80032e4 <OsTaskInitParamCheck+0x50>)
 80032c8:	e000      	b.n	80032cc <OsTaskInitParamCheck+0x38>
    }

    return LOS_OK;
 80032ca:	2300      	movs	r3, #0
}
 80032cc:	4618      	mov	r0, r3
 80032ce:	370c      	adds	r7, #12
 80032d0:	46bd      	mov	sp, r7
 80032d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032d6:	4770      	bx	lr
 80032d8:	02000201 	.word	0x02000201
 80032dc:	02000205 	.word	0x02000205
 80032e0:	02000204 	.word	0x02000204
 80032e4:	02000203 	.word	0x02000203

080032e8 <OsTaskCreateParamCheck>:
}
#endif

LITE_OS_SEC_TEXT_INIT STATIC UINT32 OsTaskCreateParamCheck(const UINT32 *taskId,
    TSK_INIT_PARAM_S *initParam, VOID **pool)
{
 80032e8:	b590      	push	{r4, r7, lr}
 80032ea:	b087      	sub	sp, #28
 80032ec:	af00      	add	r7, sp, #0
 80032ee:	60f8      	str	r0, [r7, #12]
 80032f0:	60b9      	str	r1, [r7, #8]
 80032f2:	607a      	str	r2, [r7, #4]
    UINT32 ret;
    UINT32 poolSize = OS_SYS_MEM_SIZE;
 80032f4:	4b20      	ldr	r3, [pc, #128]	; (8003378 <OsTaskCreateParamCheck+0x90>)
 80032f6:	681a      	ldr	r2, [r3, #0]
 80032f8:	4b20      	ldr	r3, [pc, #128]	; (800337c <OsTaskCreateParamCheck+0x94>)
 80032fa:	681b      	ldr	r3, [r3, #0]
 80032fc:	1ad3      	subs	r3, r2, r3
 80032fe:	3301      	adds	r3, #1
 8003300:	613b      	str	r3, [r7, #16]
    *pool = (VOID *)m_aucSysMem1;
 8003302:	4b1f      	ldr	r3, [pc, #124]	; (8003380 <OsTaskCreateParamCheck+0x98>)
 8003304:	681a      	ldr	r2, [r3, #0]
 8003306:	687b      	ldr	r3, [r7, #4]
 8003308:	601a      	str	r2, [r3, #0]

    if (taskId == NULL) {
 800330a:	68fb      	ldr	r3, [r7, #12]
 800330c:	2b00      	cmp	r3, #0
 800330e:	d101      	bne.n	8003314 <OsTaskCreateParamCheck+0x2c>
        return LOS_ERRNO_TSK_ID_INVALID;
 8003310:	4b1c      	ldr	r3, [pc, #112]	; (8003384 <OsTaskCreateParamCheck+0x9c>)
 8003312:	e02d      	b.n	8003370 <OsTaskCreateParamCheck+0x88>
    }

    ret = OsTaskInitParamCheck(initParam);
 8003314:	68b8      	ldr	r0, [r7, #8]
 8003316:	f7ff ffbd 	bl	8003294 <OsTaskInitParamCheck>
 800331a:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 800331c:	697b      	ldr	r3, [r7, #20]
 800331e:	2b00      	cmp	r3, #0
 8003320:	d001      	beq.n	8003326 <OsTaskCreateParamCheck+0x3e>
        return ret;
 8003322:	697b      	ldr	r3, [r7, #20]
 8003324:	e024      	b.n	8003370 <OsTaskCreateParamCheck+0x88>
    }
#endif
#ifdef LOSCFG_TASK_STACK_PROTECT
    poolSize = (poolSize > (MMU_4K << 1)) ? (poolSize - (MMU_4K << 1)) : 0;
#endif
    if (initParam->uwStackSize > poolSize) {
 8003326:	68bb      	ldr	r3, [r7, #8]
 8003328:	699b      	ldr	r3, [r3, #24]
 800332a:	693a      	ldr	r2, [r7, #16]
 800332c:	429a      	cmp	r2, r3
 800332e:	d201      	bcs.n	8003334 <OsTaskCreateParamCheck+0x4c>
        return LOS_ERRNO_TSK_STKSZ_TOO_LARGE;
 8003330:	4b15      	ldr	r3, [pc, #84]	; (8003388 <OsTaskCreateParamCheck+0xa0>)
 8003332:	e01d      	b.n	8003370 <OsTaskCreateParamCheck+0x88>
    }

    if (initParam->uwStackSize == 0) {
 8003334:	68bb      	ldr	r3, [r7, #8]
 8003336:	699b      	ldr	r3, [r3, #24]
 8003338:	2b00      	cmp	r3, #0
 800333a:	d103      	bne.n	8003344 <OsTaskCreateParamCheck+0x5c>
        initParam->uwStackSize = KERNEL_TSK_DEFAULT_STACK_SIZE;
 800333c:	68bb      	ldr	r3, [r7, #8]
 800333e:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 8003342:	619a      	str	r2, [r3, #24]
    }
    initParam->uwStackSize = (UINT32)ALIGN(initParam->uwStackSize, LOSCFG_STACK_POINT_ALIGN_SIZE);
 8003344:	68bb      	ldr	r3, [r7, #8]
 8003346:	699b      	ldr	r3, [r3, #24]
 8003348:	2108      	movs	r1, #8
 800334a:	4618      	mov	r0, r3
 800334c:	f7ff f9ba 	bl	80026c4 <LOS_Align>
 8003350:	4602      	mov	r2, r0
 8003352:	68bb      	ldr	r3, [r7, #8]
 8003354:	619a      	str	r2, [r3, #24]

    if (initParam->uwStackSize < LOS_TASK_MIN_STACK_SIZE) {
 8003356:	68bb      	ldr	r3, [r7, #8]
 8003358:	699c      	ldr	r4, [r3, #24]
 800335a:	2108      	movs	r1, #8
 800335c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8003360:	f7ff f9b0 	bl	80026c4 <LOS_Align>
 8003364:	4603      	mov	r3, r0
 8003366:	429c      	cmp	r4, r3
 8003368:	d201      	bcs.n	800336e <OsTaskCreateParamCheck+0x86>
        return LOS_ERRNO_TSK_STKSZ_TOO_SMALL;
 800336a:	4b08      	ldr	r3, [pc, #32]	; (800338c <OsTaskCreateParamCheck+0xa4>)
 800336c:	e000      	b.n	8003370 <OsTaskCreateParamCheck+0x88>
    }

    return LOS_OK;
 800336e:	2300      	movs	r3, #0
}
 8003370:	4618      	mov	r0, r3
 8003372:	371c      	adds	r7, #28
 8003374:	46bd      	mov	sp, r7
 8003376:	bd90      	pop	{r4, r7, pc}
 8003378:	080001f4 	.word	0x080001f4
 800337c:	080001f0 	.word	0x080001f0
 8003380:	200021b8 	.word	0x200021b8
 8003384:	02000207 	.word	0x02000207
 8003388:	02000220 	.word	0x02000220
 800338c:	02000206 	.word	0x02000206

08003390 <OsTaskStackAlloc>:

LITE_OS_SEC_TEXT_INIT STATIC VOID OsTaskStackAlloc(VOID **topStack, UINT32 stackSize, VOID *pool)
{
 8003390:	b580      	push	{r7, lr}
 8003392:	b084      	sub	sp, #16
 8003394:	af00      	add	r7, sp, #0
 8003396:	60f8      	str	r0, [r7, #12]
 8003398:	60b9      	str	r1, [r7, #8]
 800339a:	607a      	str	r2, [r7, #4]
    } else {
        *topStack = (VOID *)(MMUProtectAddr + MMU_4K);
        OsTaskStackProtect(MMUProtectAddr, MMU_4K, ACCESS_PERM_RO_RO);
    }
#else
    *topStack = (VOID *)LOS_MemAllocAlign(pool, stackSize, LOSCFG_STACK_POINT_ALIGN_SIZE);
 800339c:	2208      	movs	r2, #8
 800339e:	68b9      	ldr	r1, [r7, #8]
 80033a0:	6878      	ldr	r0, [r7, #4]
 80033a2:	f005 fb63 	bl	8008a6c <LOS_MemAllocAlign>
 80033a6:	4602      	mov	r2, r0
 80033a8:	68fb      	ldr	r3, [r7, #12]
 80033aa:	601a      	str	r2, [r3, #0]
#endif
}
 80033ac:	bf00      	nop
 80033ae:	3710      	adds	r7, #16
 80033b0:	46bd      	mov	sp, r7
 80033b2:	bd80      	pop	{r7, pc}

080033b4 <OsTaskSyncCreate>:

    LOS_SpinLock(&g_taskSpin);
}
#else
STATIC INLINE UINT32 OsTaskSyncCreate(LosTaskCB *taskCB)
{
 80033b4:	b480      	push	{r7}
 80033b6:	b083      	sub	sp, #12
 80033b8:	af00      	add	r7, sp, #0
 80033ba:	6078      	str	r0, [r7, #4]
    (VOID)taskCB;
    return LOS_OK;
 80033bc:	2300      	movs	r3, #0
}
 80033be:	4618      	mov	r0, r3
 80033c0:	370c      	adds	r7, #12
 80033c2:	46bd      	mov	sp, r7
 80033c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033c8:	4770      	bx	lr

080033ca <OsTaskSyncDestroy>:

STATIC INLINE VOID OsTaskSyncDestroy(const LosTaskCB *taskCB)
{
 80033ca:	b480      	push	{r7}
 80033cc:	b083      	sub	sp, #12
 80033ce:	af00      	add	r7, sp, #0
 80033d0:	6078      	str	r0, [r7, #4]
    (VOID)taskCB;
}
 80033d2:	bf00      	nop
 80033d4:	370c      	adds	r7, #12
 80033d6:	46bd      	mov	sp, r7
 80033d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033dc:	4770      	bx	lr

080033de <OsTaskSyncWake>:
    (VOID)taskCB;
    return LOS_OK;
}

STATIC INLINE VOID OsTaskSyncWake(const LosTaskCB *taskCB)
{
 80033de:	b480      	push	{r7}
 80033e0:	b083      	sub	sp, #12
 80033e2:	af00      	add	r7, sp, #0
 80033e4:	6078      	str	r0, [r7, #4]
    (VOID)taskCB;
}
 80033e6:	bf00      	nop
 80033e8:	370c      	adds	r7, #12
 80033ea:	46bd      	mov	sp, r7
 80033ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033f0:	4770      	bx	lr
	...

080033f4 <OsTaskDelActionOnRun>:
#endif

STATIC VOID OsTaskDelActionOnRun(LosTaskCB *taskCB)
{
 80033f4:	b480      	push	{r7}
 80033f6:	b085      	sub	sp, #20
 80033f8:	af00      	add	r7, sp, #0
 80033fa:	6078      	str	r0, [r7, #4]
    LosTaskCB *runTask = NULL;
 80033fc:	2300      	movs	r3, #0
 80033fe:	60fb      	str	r3, [r7, #12]

    runTask = &g_taskCBArray[g_taskMaxNum];
 8003400:	4b11      	ldr	r3, [pc, #68]	; (8003448 <OsTaskDelActionOnRun+0x54>)
 8003402:	6819      	ldr	r1, [r3, #0]
 8003404:	4b11      	ldr	r3, [pc, #68]	; (800344c <OsTaskDelActionOnRun+0x58>)
 8003406:	681a      	ldr	r2, [r3, #0]
 8003408:	4613      	mov	r3, r2
 800340a:	009b      	lsls	r3, r3, #2
 800340c:	4413      	add	r3, r2
 800340e:	015b      	lsls	r3, r3, #5
 8003410:	440b      	add	r3, r1
 8003412:	60fb      	str	r3, [r7, #12]
    runTask->taskId = taskCB->taskId;
 8003414:	687b      	ldr	r3, [r7, #4]
 8003416:	695a      	ldr	r2, [r3, #20]
 8003418:	68fb      	ldr	r3, [r7, #12]
 800341a:	615a      	str	r2, [r3, #20]
    runTask->taskStatus = taskCB->taskStatus;
 800341c:	687b      	ldr	r3, [r7, #4]
 800341e:	889a      	ldrh	r2, [r3, #4]
 8003420:	68fb      	ldr	r3, [r7, #12]
 8003422:	809a      	strh	r2, [r3, #4]
    runTask->topOfStack = taskCB->topOfStack;
 8003424:	687b      	ldr	r3, [r7, #4]
 8003426:	691a      	ldr	r2, [r3, #16]
 8003428:	68fb      	ldr	r3, [r7, #12]
 800342a:	611a      	str	r2, [r3, #16]
    runTask->taskName = taskCB->taskName;
 800342c:	687b      	ldr	r3, [r7, #4]
 800342e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8003430:	68fb      	ldr	r3, [r7, #12]
 8003432:	63da      	str	r2, [r3, #60]	; 0x3c
    taskCB->taskStatus = OS_TASK_STATUS_UNUSED;
 8003434:	687b      	ldr	r3, [r7, #4]
 8003436:	2201      	movs	r2, #1
 8003438:	809a      	strh	r2, [r3, #4]
}
 800343a:	bf00      	nop
 800343c:	3714      	adds	r7, #20
 800343e:	46bd      	mov	sp, r7
 8003440:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003444:	4770      	bx	lr
 8003446:	bf00      	nop
 8003448:	200036c4 	.word	0x200036c4
 800344c:	200036d8 	.word	0x200036d8

08003450 <OsTaskDelAction>:

LITE_OS_SEC_TEXT_INIT STATIC BOOL OsTaskDelAction(LosTaskCB *taskCB, BOOL useUsrStack)
{
 8003450:	b590      	push	{r4, r7, lr}
 8003452:	b08b      	sub	sp, #44	; 0x2c
 8003454:	af00      	add	r7, sp, #0
 8003456:	6078      	str	r0, [r7, #4]
 8003458:	6039      	str	r1, [r7, #0]
 800345a:	4b32      	ldr	r3, [pc, #200]	; (8003524 <OsTaskDelAction+0xd4>)
 800345c:	681b      	ldr	r3, [r3, #0]
 800345e:	627b      	str	r3, [r7, #36]	; 0x24
 8003460:	f04f 0300 	mov.w	r3, #0
    VOID *pool = (VOID *)m_aucSysMem1;
 8003464:	4b30      	ldr	r3, [pc, #192]	; (8003528 <OsTaskDelAction+0xd8>)
 8003466:	681b      	ldr	r3, [r3, #0]
 8003468:	60bb      	str	r3, [r7, #8]
    UINTPTR taskStack;

    LOS_TRACE(TASK_DELETE, taskCB->taskId, taskCB->taskStatus, taskCB->usrStack);
 800346a:	2300      	movs	r3, #0
 800346c:	617b      	str	r3, [r7, #20]
 800346e:	687b      	ldr	r3, [r7, #4]
 8003470:	695b      	ldr	r3, [r3, #20]
 8003472:	61bb      	str	r3, [r7, #24]
 8003474:	687b      	ldr	r3, [r7, #4]
 8003476:	889b      	ldrh	r3, [r3, #4]
 8003478:	61fb      	str	r3, [r7, #28]
 800347a:	687b      	ldr	r3, [r7, #4]
 800347c:	7adb      	ldrb	r3, [r3, #11]
 800347e:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8003482:	b2db      	uxtb	r3, r3
 8003484:	623b      	str	r3, [r7, #32]
 8003486:	2304      	movs	r3, #4
 8003488:	60fb      	str	r3, [r7, #12]
 800348a:	68fb      	ldr	r3, [r7, #12]
 800348c:	2b01      	cmp	r3, #1
 800348e:	d915      	bls.n	80034bc <OsTaskDelAction+0x6c>
 8003490:	4b26      	ldr	r3, [pc, #152]	; (800352c <OsTaskDelAction+0xdc>)
 8003492:	681b      	ldr	r3, [r3, #0]
 8003494:	2b00      	cmp	r3, #0
 8003496:	d011      	beq.n	80034bc <OsTaskDelAction+0x6c>
 8003498:	4b24      	ldr	r3, [pc, #144]	; (800352c <OsTaskDelAction+0xdc>)
 800349a:	681c      	ldr	r4, [r3, #0]
 800349c:	69b9      	ldr	r1, [r7, #24]
 800349e:	68fb      	ldr	r3, [r7, #12]
 80034a0:	2b02      	cmp	r3, #2
 80034a2:	d904      	bls.n	80034ae <OsTaskDelAction+0x5e>
 80034a4:	f107 0314 	add.w	r3, r7, #20
 80034a8:	f103 0208 	add.w	r2, r3, #8
 80034ac:	e000      	b.n	80034b0 <OsTaskDelAction+0x60>
 80034ae:	2200      	movs	r2, #0
 80034b0:	68fb      	ldr	r3, [r7, #12]
 80034b2:	b29b      	uxth	r3, r3
 80034b4:	3b02      	subs	r3, #2
 80034b6:	b29b      	uxth	r3, r3
 80034b8:	2042      	movs	r0, #66	; 0x42
 80034ba:	47a0      	blx	r4
#ifdef LOSCFG_KERNEL_INTERMIT
    if (g_taskDelHook != NULL) {
        g_taskDelHook(taskCB);
    }
#endif
    if (taskCB->taskStatus & OS_TASK_STATUS_RUNNING) {
 80034bc:	687b      	ldr	r3, [r7, #4]
 80034be:	889b      	ldrh	r3, [r3, #4]
 80034c0:	f003 0310 	and.w	r3, r3, #16
 80034c4:	2b00      	cmp	r3, #0
 80034c6:	d00a      	beq.n	80034de <OsTaskDelAction+0x8e>
#ifdef LOSCFG_TASK_STATIC_ALLOCATION
        if (useUsrStack) {
            LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
        } else {
#endif
            LOS_ListTailInsert(&g_taskRecycleList, &taskCB->pendList);
 80034c8:	687b      	ldr	r3, [r7, #4]
 80034ca:	3340      	adds	r3, #64	; 0x40
 80034cc:	4619      	mov	r1, r3
 80034ce:	4818      	ldr	r0, [pc, #96]	; (8003530 <OsTaskDelAction+0xe0>)
 80034d0:	f7ff f9d8 	bl	8002884 <LOS_ListTailInsert>
#ifdef LOSCFG_TASK_STATIC_ALLOCATION
        }
#endif
        OsTaskDelActionOnRun(taskCB);
 80034d4:	6878      	ldr	r0, [r7, #4]
 80034d6:	f7ff ff8d 	bl	80033f4 <OsTaskDelActionOnRun>
        return TRUE;
 80034da:	2301      	movs	r3, #1
 80034dc:	e017      	b.n	800350e <OsTaskDelAction+0xbe>
    }

    taskCB->taskStatus = OS_TASK_STATUS_UNUSED;
 80034de:	687b      	ldr	r3, [r7, #4]
 80034e0:	2201      	movs	r2, #1
 80034e2:	809a      	strh	r2, [r3, #4]
    LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
 80034e4:	687b      	ldr	r3, [r7, #4]
 80034e6:	3340      	adds	r3, #64	; 0x40
 80034e8:	4619      	mov	r1, r3
 80034ea:	4812      	ldr	r0, [pc, #72]	; (8003534 <OsTaskDelAction+0xe4>)
 80034ec:	f7ff f9b1 	bl	8002852 <LOS_ListAdd>
    if (useUsrStack == FALSE) {
 80034f0:	683b      	ldr	r3, [r7, #0]
 80034f2:	2b00      	cmp	r3, #0
 80034f4:	d107      	bne.n	8003506 <OsTaskDelAction+0xb6>
#ifdef LOSCFG_TASK_STACK_PROTECT
        taskStack = taskCB->topOfStack - MMU_4K;
        OsTaskStackProtect(taskStack, MMU_4K, ACCESS_PERM_RW_RW);
#else
        taskStack = taskCB->topOfStack;
 80034f6:	687b      	ldr	r3, [r7, #4]
 80034f8:	691b      	ldr	r3, [r3, #16]
 80034fa:	613b      	str	r3, [r7, #16]
#ifdef LOSCFG_EXC_INTERACTION
        if (taskStack < (UINTPTR)m_aucSysMem1) {
            pool = (VOID *)m_aucSysMem0;
        }
#endif
        (VOID)LOS_MemFree(pool, (VOID *)taskStack);
 80034fc:	693b      	ldr	r3, [r7, #16]
 80034fe:	4619      	mov	r1, r3
 8003500:	68b8      	ldr	r0, [r7, #8]
 8003502:	f005 fb09 	bl	8008b18 <LOS_MemFree>
    }
    taskCB->topOfStack = 0;
 8003506:	687b      	ldr	r3, [r7, #4]
 8003508:	2200      	movs	r2, #0
 800350a:	611a      	str	r2, [r3, #16]
    return FALSE;
 800350c:	2300      	movs	r3, #0
}
 800350e:	4a05      	ldr	r2, [pc, #20]	; (8003524 <OsTaskDelAction+0xd4>)
 8003510:	6811      	ldr	r1, [r2, #0]
 8003512:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003514:	4051      	eors	r1, r2
 8003516:	d001      	beq.n	800351c <OsTaskDelAction+0xcc>
 8003518:	f000 ff66 	bl	80043e8 <__stack_chk_fail>
 800351c:	4618      	mov	r0, r3
 800351e:	372c      	adds	r7, #44	; 0x2c
 8003520:	46bd      	mov	sp, r7
 8003522:	bd90      	pop	{r4, r7, pc}
 8003524:	08020108 	.word	0x08020108
 8003528:	200021b8 	.word	0x200021b8
 800352c:	2000075c 	.word	0x2000075c
 8003530:	200036c8 	.word	0x200036c8
 8003534:	200036d0 	.word	0x200036d0

08003538 <OsTaskDeleteCheckOnRun>:
 * 2. Do the deletion when preemption is disabled
 * 3. Do the deletion in hard-irq
 * then LOS_TaskDelete will directly return with 'ret' value.
 */
LITE_OS_SEC_TEXT_INIT STATIC BOOL OsTaskDeleteCheckOnRun(LosTaskCB *taskCB, UINT32 *ret)
{
 8003538:	b580      	push	{r7, lr}
 800353a:	b082      	sub	sp, #8
 800353c:	af00      	add	r7, sp, #0
 800353e:	6078      	str	r0, [r7, #4]
 8003540:	6039      	str	r1, [r7, #0]
    /* init default out return value */
    *ret = LOS_OK;
 8003542:	683b      	ldr	r3, [r7, #0]
 8003544:	2200      	movs	r2, #0
 8003546:	601a      	str	r2, [r3, #0]
        *ret = OsTaskSyncWait(taskCB);
        return FALSE;
    }
#endif

    if (!OsPreemptableInSched()) {
 8003548:	f7ff fa34 	bl	80029b4 <OsPreemptableInSched>
 800354c:	4603      	mov	r3, r0
 800354e:	2b00      	cmp	r3, #0
 8003550:	d104      	bne.n	800355c <OsTaskDeleteCheckOnRun+0x24>
        /* If the task is running and scheduler is locked then you can not delete it */
        *ret = LOS_ERRNO_TSK_DELETE_LOCKED;
 8003552:	683b      	ldr	r3, [r7, #0]
 8003554:	4a09      	ldr	r2, [pc, #36]	; (800357c <OsTaskDeleteCheckOnRun+0x44>)
 8003556:	601a      	str	r2, [r3, #0]
        return FALSE;
 8003558:	2300      	movs	r3, #0
 800355a:	e00a      	b.n	8003572 <OsTaskDeleteCheckOnRun+0x3a>
    }

    if (OS_INT_ACTIVE) {
 800355c:	f7fe ff86 	bl	800246c <IntActive>
 8003560:	4603      	mov	r3, r0
 8003562:	2b00      	cmp	r3, #0
 8003564:	d004      	beq.n	8003570 <OsTaskDeleteCheckOnRun+0x38>
        /*
         * delete running task in interrupt.
         * mask "kill" signal and later deletion will be handled.
         */
        taskCB->signal = SIGNAL_KILL;
 8003566:	687b      	ldr	r3, [r7, #4]
 8003568:	2201      	movs	r2, #1
 800356a:	671a      	str	r2, [r3, #112]	; 0x70
        return FALSE;
 800356c:	2300      	movs	r3, #0
 800356e:	e000      	b.n	8003572 <OsTaskDeleteCheckOnRun+0x3a>
    }

    return TRUE;
 8003570:	2301      	movs	r3, #1
}
 8003572:	4618      	mov	r0, r3
 8003574:	3708      	adds	r7, #8
 8003576:	46bd      	mov	sp, r7
 8003578:	bd80      	pop	{r7, pc}
 800357a:	bf00      	nop
 800357c:	0300020b 	.word	0x0300020b

08003580 <OsTaskCBInit>:

LITE_OS_SEC_TEXT_INIT STATIC VOID OsTaskCBInit(LosTaskCB *taskCB, const TSK_INIT_PARAM_S *initParam,
                                               VOID *stackPtr, const VOID *topStack, BOOL useUsrStack)
{
 8003580:	b580      	push	{r7, lr}
 8003582:	b084      	sub	sp, #16
 8003584:	af00      	add	r7, sp, #0
 8003586:	60f8      	str	r0, [r7, #12]
 8003588:	60b9      	str	r1, [r7, #8]
 800358a:	607a      	str	r2, [r7, #4]
 800358c:	603b      	str	r3, [r7, #0]
    taskCB->stackPointer = stackPtr;
 800358e:	68fb      	ldr	r3, [r7, #12]
 8003590:	687a      	ldr	r2, [r7, #4]
 8003592:	601a      	str	r2, [r3, #0]
#ifdef LOSCFG_OBSOLETE_API
    taskCB->args[0]      = initParam->auwArgs[0]; /* 0~3: just for args array index */
 8003594:	68bb      	ldr	r3, [r7, #8]
 8003596:	689a      	ldr	r2, [r3, #8]
 8003598:	68fb      	ldr	r3, [r7, #12]
 800359a:	62da      	str	r2, [r3, #44]	; 0x2c
    taskCB->args[1]      = initParam->auwArgs[1];
 800359c:	68bb      	ldr	r3, [r7, #8]
 800359e:	68da      	ldr	r2, [r3, #12]
 80035a0:	68fb      	ldr	r3, [r7, #12]
 80035a2:	631a      	str	r2, [r3, #48]	; 0x30
    taskCB->args[2]      = initParam->auwArgs[2];
 80035a4:	68bb      	ldr	r3, [r7, #8]
 80035a6:	691a      	ldr	r2, [r3, #16]
 80035a8:	68fb      	ldr	r3, [r7, #12]
 80035aa:	635a      	str	r2, [r3, #52]	; 0x34
    taskCB->args[3]      = initParam->auwArgs[3];
 80035ac:	68bb      	ldr	r3, [r7, #8]
 80035ae:	695a      	ldr	r2, [r3, #20]
 80035b0:	68fb      	ldr	r3, [r7, #12]
 80035b2:	639a      	str	r2, [r3, #56]	; 0x38
#else
    taskCB->args         = initParam->pArgs;
#endif
    taskCB->topOfStack   = (UINTPTR)topStack;
 80035b4:	683a      	ldr	r2, [r7, #0]
 80035b6:	68fb      	ldr	r3, [r7, #12]
 80035b8:	611a      	str	r2, [r3, #16]
    taskCB->stackSize    = initParam->uwStackSize;
 80035ba:	68bb      	ldr	r3, [r7, #8]
 80035bc:	699a      	ldr	r2, [r3, #24]
 80035be:	68fb      	ldr	r3, [r7, #12]
 80035c0:	60da      	str	r2, [r3, #12]
    taskCB->taskSem      = NULL;
 80035c2:	68fb      	ldr	r3, [r7, #12]
 80035c4:	2200      	movs	r2, #0
 80035c6:	61da      	str	r2, [r3, #28]
#ifdef LOSCFG_COMPAT_POSIX
    taskCB->threadJoin   = NULL;
 80035c8:	68fb      	ldr	r3, [r7, #12]
 80035ca:	2200      	movs	r2, #0
 80035cc:	621a      	str	r2, [r3, #32]
#endif
    taskCB->taskMux      = NULL;
 80035ce:	68fb      	ldr	r3, [r7, #12]
 80035d0:	2200      	movs	r2, #0
 80035d2:	629a      	str	r2, [r3, #40]	; 0x28
    taskCB->taskStatus   = OS_TASK_STATUS_SUSPEND;
 80035d4:	68fb      	ldr	r3, [r7, #12]
 80035d6:	2202      	movs	r2, #2
 80035d8:	809a      	strh	r2, [r3, #4]
    taskCB->priority     = initParam->usTaskPrio;
 80035da:	68bb      	ldr	r3, [r7, #8]
 80035dc:	889a      	ldrh	r2, [r3, #4]
 80035de:	68fb      	ldr	r3, [r7, #12]
 80035e0:	80da      	strh	r2, [r3, #6]
    taskCB->priBitMap    = 0;
 80035e2:	68fb      	ldr	r3, [r7, #12]
 80035e4:	2200      	movs	r2, #0
 80035e6:	66da      	str	r2, [r3, #108]	; 0x6c
    taskCB->taskEntry    = initParam->pfnTaskEntry;
 80035e8:	68bb      	ldr	r3, [r7, #8]
 80035ea:	681a      	ldr	r2, [r3, #0]
 80035ec:	68fb      	ldr	r3, [r7, #12]
 80035ee:	619a      	str	r2, [r3, #24]
#ifdef LOSCFG_BASE_IPC_EVENT
    LOS_ListInit(&taskCB->event.stEventList);
 80035f0:	68fb      	ldr	r3, [r7, #12]
 80035f2:	3358      	adds	r3, #88	; 0x58
 80035f4:	4618      	mov	r0, r3
 80035f6:	f7ff f91c 	bl	8002832 <LOS_ListInit>
    taskCB->event.uwEventID = 0;
 80035fa:	68fb      	ldr	r3, [r7, #12]
 80035fc:	2200      	movs	r2, #0
 80035fe:	655a      	str	r2, [r3, #84]	; 0x54
    taskCB->eventMask    = 0;
 8003600:	68fb      	ldr	r3, [r7, #12]
 8003602:	2200      	movs	r2, #0
 8003604:	661a      	str	r2, [r3, #96]	; 0x60
#endif

    taskCB->taskName     = initParam->pcName;
 8003606:	68bb      	ldr	r3, [r7, #8]
 8003608:	69da      	ldr	r2, [r3, #28]
 800360a:	68fb      	ldr	r3, [r7, #12]
 800360c:	63da      	str	r2, [r3, #60]	; 0x3c
    taskCB->msg          = NULL;
 800360e:	68fb      	ldr	r3, [r7, #12]
 8003610:	2200      	movs	r2, #0
 8003612:	669a      	str	r2, [r3, #104]	; 0x68

     /* set the task is detached or joinable */
    taskCB->taskFlags    = ((initParam->uwResved == LOS_TASK_STATUS_DETACHED) ? OS_TASK_FLAG_DETACHED : 0);
 8003614:	68bb      	ldr	r3, [r7, #8]
 8003616:	6a1b      	ldr	r3, [r3, #32]
 8003618:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800361c:	d101      	bne.n	8003622 <OsTaskCBInit+0xa2>
 800361e:	2101      	movs	r1, #1
 8003620:	e000      	b.n	8003624 <OsTaskCBInit+0xa4>
 8003622:	2100      	movs	r1, #0
 8003624:	68fa      	ldr	r2, [r7, #12]
 8003626:	6893      	ldr	r3, [r2, #8]
 8003628:	f361 031e 	bfi	r3, r1, #0, #31
 800362c:	6093      	str	r3, [r2, #8]
    taskCB->usrStack     = useUsrStack ? 1 : 0; /* 0: dynamicly alloc stack space;1: user inputs stack space */
 800362e:	69bb      	ldr	r3, [r7, #24]
 8003630:	2b00      	cmp	r3, #0
 8003632:	bf14      	ite	ne
 8003634:	2301      	movne	r3, #1
 8003636:	2300      	moveq	r3, #0
 8003638:	b2d9      	uxtb	r1, r3
 800363a:	68fa      	ldr	r2, [r7, #12]
 800363c:	7ad3      	ldrb	r3, [r2, #11]
 800363e:	f361 13c7 	bfi	r3, r1, #7, #1
 8003642:	72d3      	strb	r3, [r2, #11]
    taskCB->signal       = SIGNAL_NONE;
 8003644:	68fb      	ldr	r3, [r7, #12]
 8003646:	2200      	movs	r2, #0
 8003648:	671a      	str	r2, [r3, #112]	; 0x70
    taskCB->lastCpu      = OS_TASK_INVALID_CPUID;
#endif
    taskCB->cpuAffiMask  = (initParam->usCpuAffiMask) ? initParam->usCpuAffiMask : LOSCFG_KERNEL_CPU_MASK;
#endif
#ifdef LOSCFG_BASE_CORE_TIMESLICE
    taskCB->timeSlice    = 0;
 800364a:	68fb      	ldr	r3, [r7, #12]
 800364c:	2200      	movs	r2, #0
 800364e:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
#ifdef LOSCFG_KERNEL_SMP_LOCKDEP
    taskCB->lockDep.waitLock  = NULL;
    taskCB->lockDep.lockDepth = 0;
#endif
#ifdef LOSCFG_DEBUG_SCHED_STATISTICS
    (VOID)memset_s(&taskCB->schedStat, sizeof(SchedStat), 0, sizeof(SchedStat));
 8003652:	68fb      	ldr	r3, [r7, #12]
 8003654:	f103 0078 	add.w	r0, r3, #120	; 0x78
 8003658:	2328      	movs	r3, #40	; 0x28
 800365a:	2200      	movs	r2, #0
 800365c:	2128      	movs	r1, #40	; 0x28
 800365e:	f012 fd15 	bl	801608c <memset_s>
#endif
}
 8003662:	bf00      	nop
 8003664:	3710      	adds	r7, #16
 8003666:	46bd      	mov	sp, r7
 8003668:	bd80      	pop	{r7, pc}
	...

0800366c <OsTaskGetFreeTaskCB>:

STATIC UINT32 OsTaskGetFreeTaskCB(LosTaskCB **taskCB)
{
 800366c:	b580      	push	{r7, lr}
 800366e:	b082      	sub	sp, #8
 8003670:	af00      	add	r7, sp, #0
 8003672:	6078      	str	r0, [r7, #4]
    if (LOS_ListEmpty(&g_losFreeTask)) {
 8003674:	480e      	ldr	r0, [pc, #56]	; (80036b0 <OsTaskGetFreeTaskCB+0x44>)
 8003676:	f7ff f92e 	bl	80028d6 <LOS_ListEmpty>
 800367a:	4603      	mov	r3, r0
 800367c:	2b00      	cmp	r3, #0
 800367e:	d001      	beq.n	8003684 <OsTaskGetFreeTaskCB+0x18>
        return LOS_ERRNO_TSK_TCB_UNAVAILABLE;
 8003680:	4b0c      	ldr	r3, [pc, #48]	; (80036b4 <OsTaskGetFreeTaskCB+0x48>)
 8003682:	e011      	b.n	80036a8 <OsTaskGetFreeTaskCB+0x3c>
    }

    *taskCB = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&g_losFreeTask));
 8003684:	4b0a      	ldr	r3, [pc, #40]	; (80036b0 <OsTaskGetFreeTaskCB+0x44>)
 8003686:	685b      	ldr	r3, [r3, #4]
 8003688:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
 800368c:	687b      	ldr	r3, [r7, #4]
 800368e:	601a      	str	r2, [r3, #0]
    if (*taskCB == NULL) {
 8003690:	687b      	ldr	r3, [r7, #4]
 8003692:	681b      	ldr	r3, [r3, #0]
 8003694:	2b00      	cmp	r3, #0
 8003696:	d101      	bne.n	800369c <OsTaskGetFreeTaskCB+0x30>
        return LOS_ERRNO_TSK_PTR_NULL;
 8003698:	4b07      	ldr	r3, [pc, #28]	; (80036b8 <OsTaskGetFreeTaskCB+0x4c>)
 800369a:	e005      	b.n	80036a8 <OsTaskGetFreeTaskCB+0x3c>
    }
    LOS_ListDelete(LOS_DL_LIST_FIRST(&g_losFreeTask));
 800369c:	4b04      	ldr	r3, [pc, #16]	; (80036b0 <OsTaskGetFreeTaskCB+0x44>)
 800369e:	685b      	ldr	r3, [r3, #4]
 80036a0:	4618      	mov	r0, r3
 80036a2:	f7ff f8fe 	bl	80028a2 <LOS_ListDelete>
    return LOS_OK;
 80036a6:	2300      	movs	r3, #0
}
 80036a8:	4618      	mov	r0, r3
 80036aa:	3708      	adds	r7, #8
 80036ac:	46bd      	mov	sp, r7
 80036ae:	bd80      	pop	{r7, pc}
 80036b0:	200036d0 	.word	0x200036d0
 80036b4:	02000211 	.word	0x02000211
 80036b8:	02000201 	.word	0x02000201

080036bc <OsTaskCreateOnly>:

STATIC UINT32 OsTaskCreateOnly(UINT32 *taskId, TSK_INIT_PARAM_S *initParam, VOID *topStack, BOOL useUsrStack)
{
 80036bc:	b590      	push	{r4, r7, lr}
 80036be:	b08f      	sub	sp, #60	; 0x3c
 80036c0:	af02      	add	r7, sp, #8
 80036c2:	60f8      	str	r0, [r7, #12]
 80036c4:	60b9      	str	r1, [r7, #8]
 80036c6:	607a      	str	r2, [r7, #4]
 80036c8:	603b      	str	r3, [r7, #0]
 80036ca:	4b4d      	ldr	r3, [pc, #308]	; (8003800 <OsTaskCreateOnly+0x144>)
 80036cc:	681b      	ldr	r3, [r3, #0]
 80036ce:	62fb      	str	r3, [r7, #44]	; 0x2c
 80036d0:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave, errRet;
    VOID *stackPtr = NULL;
 80036d4:	2300      	movs	r3, #0
 80036d6:	627b      	str	r3, [r7, #36]	; 0x24
    LosTaskCB *taskCB = NULL;
 80036d8:	2300      	movs	r3, #0
 80036da:	61bb      	str	r3, [r7, #24]
    VOID *pool = NULL;
 80036dc:	2300      	movs	r3, #0
 80036de:	61fb      	str	r3, [r7, #28]
#ifdef LOSCFG_TASK_STATIC_ALLOCATION
    if (useUsrStack) {
        errRet = OsTaskCreateParamCheckStatic(taskId, initParam, topStack);
    } else {
#endif
        errRet = OsTaskCreateParamCheck(taskId, initParam, &pool);
 80036e0:	f107 031c 	add.w	r3, r7, #28
 80036e4:	461a      	mov	r2, r3
 80036e6:	68b9      	ldr	r1, [r7, #8]
 80036e8:	68f8      	ldr	r0, [r7, #12]
 80036ea:	f7ff fdfd 	bl	80032e8 <OsTaskCreateParamCheck>
 80036ee:	6238      	str	r0, [r7, #32]
#ifdef LOSCFG_TASK_STATIC_ALLOCATION
    }
#endif
    if (errRet != LOS_OK) {
 80036f0:	6a3b      	ldr	r3, [r7, #32]
 80036f2:	2b00      	cmp	r3, #0
 80036f4:	d001      	beq.n	80036fa <OsTaskCreateOnly+0x3e>
        return errRet;
 80036f6:	6a3b      	ldr	r3, [r7, #32]
 80036f8:	e077      	b.n	80037ea <OsTaskCreateOnly+0x12e>
    }

    SCHEDULER_LOCK(intSave);
 80036fa:	f107 0314 	add.w	r3, r7, #20
 80036fe:	4619      	mov	r1, r3
 8003700:	4840      	ldr	r0, [pc, #256]	; (8003804 <OsTaskCreateOnly+0x148>)
 8003702:	f7ff f997 	bl	8002a34 <LOS_SpinLockSave>
    errRet = OsTaskGetFreeTaskCB(&taskCB);
 8003706:	f107 0318 	add.w	r3, r7, #24
 800370a:	4618      	mov	r0, r3
 800370c:	f7ff ffae 	bl	800366c <OsTaskGetFreeTaskCB>
 8003710:	6238      	str	r0, [r7, #32]
    if (errRet != LOS_OK) {
 8003712:	6a3b      	ldr	r3, [r7, #32]
 8003714:	2b00      	cmp	r3, #0
 8003716:	d161      	bne.n	80037dc <OsTaskCreateOnly+0x120>
        goto LOS_ERREND;
    }
    SCHEDULER_UNLOCK(intSave);
 8003718:	697b      	ldr	r3, [r7, #20]
 800371a:	4619      	mov	r1, r3
 800371c:	4839      	ldr	r0, [pc, #228]	; (8003804 <OsTaskCreateOnly+0x148>)
 800371e:	f7ff f997 	bl	8002a50 <LOS_SpinUnlockRestore>

    errRet = OsTaskSyncCreate(taskCB);
 8003722:	69bb      	ldr	r3, [r7, #24]
 8003724:	4618      	mov	r0, r3
 8003726:	f7ff fe45 	bl	80033b4 <OsTaskSyncCreate>
 800372a:	6238      	str	r0, [r7, #32]
    if (errRet != LOS_OK) {
 800372c:	6a3b      	ldr	r3, [r7, #32]
 800372e:	2b00      	cmp	r3, #0
 8003730:	d146      	bne.n	80037c0 <OsTaskCreateOnly+0x104>
        goto LOS_ERREND_REWIND_TCB;
    }

    if (useUsrStack == FALSE) {
 8003732:	683b      	ldr	r3, [r7, #0]
 8003734:	2b00      	cmp	r3, #0
 8003736:	d110      	bne.n	800375a <OsTaskCreateOnly+0x9e>
        OsTaskStackAlloc(&topStack, initParam->uwStackSize, pool);
 8003738:	68bb      	ldr	r3, [r7, #8]
 800373a:	6999      	ldr	r1, [r3, #24]
 800373c:	69fa      	ldr	r2, [r7, #28]
 800373e:	1d3b      	adds	r3, r7, #4
 8003740:	4618      	mov	r0, r3
 8003742:	f7ff fe25 	bl	8003390 <OsTaskStackAlloc>
        if (topStack == NULL) {
 8003746:	687b      	ldr	r3, [r7, #4]
 8003748:	2b00      	cmp	r3, #0
 800374a:	d106      	bne.n	800375a <OsTaskCreateOnly+0x9e>
            errRet = LOS_ERRNO_TSK_NO_MEMORY;
 800374c:	4b2e      	ldr	r3, [pc, #184]	; (8003808 <OsTaskCreateOnly+0x14c>)
 800374e:	623b      	str	r3, [r7, #32]
            OsTaskSyncDestroy(taskCB);
 8003750:	69bb      	ldr	r3, [r7, #24]
 8003752:	4618      	mov	r0, r3
 8003754:	f7ff fe39 	bl	80033ca <OsTaskSyncDestroy>
            goto LOS_ERREND_REWIND_TCB;
 8003758:	e033      	b.n	80037c2 <OsTaskCreateOnly+0x106>
        }
    }
    stackPtr = OsTaskStackInit(taskCB->taskId, initParam->uwStackSize, topStack);
 800375a:	69bb      	ldr	r3, [r7, #24]
 800375c:	6958      	ldr	r0, [r3, #20]
 800375e:	68bb      	ldr	r3, [r7, #8]
 8003760:	699b      	ldr	r3, [r3, #24]
 8003762:	687a      	ldr	r2, [r7, #4]
 8003764:	4619      	mov	r1, r3
 8003766:	f012 f817 	bl	8015798 <OsTaskStackInit>
 800376a:	6278      	str	r0, [r7, #36]	; 0x24
    OsTaskCBInit(taskCB, initParam, stackPtr, topStack, useUsrStack);
 800376c:	69b8      	ldr	r0, [r7, #24]
 800376e:	687a      	ldr	r2, [r7, #4]
 8003770:	683b      	ldr	r3, [r7, #0]
 8003772:	9300      	str	r3, [sp, #0]
 8003774:	4613      	mov	r3, r2
 8003776:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003778:	68b9      	ldr	r1, [r7, #8]
 800377a:	f7ff ff01 	bl	8003580 <OsTaskCBInit>

    if (OsConsoleIDSetHook != NULL) {
 800377e:	4b23      	ldr	r3, [pc, #140]	; (800380c <OsTaskCreateOnly+0x150>)
 8003780:	2b00      	cmp	r3, #0
 8003782:	d009      	beq.n	8003798 <OsTaskCreateOnly+0xdc>
        OsConsoleIDSetHook(taskCB->taskId, OsCurrTaskGet()->taskId);
 8003784:	69bb      	ldr	r3, [r7, #24]
 8003786:	695c      	ldr	r4, [r3, #20]
 8003788:	f7ff f979 	bl	8002a7e <OsCurrTaskGet>
 800378c:	4603      	mov	r3, r0
 800378e:	695b      	ldr	r3, [r3, #20]
 8003790:	4619      	mov	r1, r3
 8003792:	4620      	mov	r0, r4
 8003794:	f3af 8000 	nop.w
    }

#ifdef LOSCFG_KERNEL_CPUP
    OsCpupCB *cpup = OsCpupCBGet(taskCB->taskId);
 8003798:	69bb      	ldr	r3, [r7, #24]
 800379a:	695b      	ldr	r3, [r3, #20]
 800379c:	4618      	mov	r0, r3
 800379e:	f010 f827 	bl	80137f0 <OsCpupCBGet>
 80037a2:	62b8      	str	r0, [r7, #40]	; 0x28
    cpup->id = taskCB->taskId;
 80037a4:	69bb      	ldr	r3, [r7, #24]
 80037a6:	695a      	ldr	r2, [r3, #20]
 80037a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80037aa:	601a      	str	r2, [r3, #0]
    cpup->status = taskCB->taskStatus;
 80037ac:	69bb      	ldr	r3, [r7, #24]
 80037ae:	889a      	ldrh	r2, [r3, #4]
 80037b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80037b2:	809a      	strh	r2, [r3, #4]
#endif

    *taskId = taskCB->taskId;
 80037b4:	69bb      	ldr	r3, [r7, #24]
 80037b6:	695a      	ldr	r2, [r3, #20]
 80037b8:	68fb      	ldr	r3, [r7, #12]
 80037ba:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 80037bc:	2300      	movs	r3, #0
 80037be:	e014      	b.n	80037ea <OsTaskCreateOnly+0x12e>
        goto LOS_ERREND_REWIND_TCB;
 80037c0:	bf00      	nop

LOS_ERREND_REWIND_TCB:
    SCHEDULER_LOCK(intSave);
 80037c2:	f107 0314 	add.w	r3, r7, #20
 80037c6:	4619      	mov	r1, r3
 80037c8:	480e      	ldr	r0, [pc, #56]	; (8003804 <OsTaskCreateOnly+0x148>)
 80037ca:	f7ff f933 	bl	8002a34 <LOS_SpinLockSave>
    LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
 80037ce:	69bb      	ldr	r3, [r7, #24]
 80037d0:	3340      	adds	r3, #64	; 0x40
 80037d2:	4619      	mov	r1, r3
 80037d4:	480e      	ldr	r0, [pc, #56]	; (8003810 <OsTaskCreateOnly+0x154>)
 80037d6:	f7ff f83c 	bl	8002852 <LOS_ListAdd>
 80037da:	e000      	b.n	80037de <OsTaskCreateOnly+0x122>
        goto LOS_ERREND;
 80037dc:	bf00      	nop
LOS_ERREND:
    SCHEDULER_UNLOCK(intSave);
 80037de:	697b      	ldr	r3, [r7, #20]
 80037e0:	4619      	mov	r1, r3
 80037e2:	4808      	ldr	r0, [pc, #32]	; (8003804 <OsTaskCreateOnly+0x148>)
 80037e4:	f7ff f934 	bl	8002a50 <LOS_SpinUnlockRestore>
    return errRet;
 80037e8:	6a3b      	ldr	r3, [r7, #32]
}
 80037ea:	4a05      	ldr	r2, [pc, #20]	; (8003800 <OsTaskCreateOnly+0x144>)
 80037ec:	6811      	ldr	r1, [r2, #0]
 80037ee:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80037f0:	4051      	eors	r1, r2
 80037f2:	d001      	beq.n	80037f8 <OsTaskCreateOnly+0x13c>
 80037f4:	f000 fdf8 	bl	80043e8 <__stack_chk_fail>
 80037f8:	4618      	mov	r0, r3
 80037fa:	3734      	adds	r7, #52	; 0x34
 80037fc:	46bd      	mov	sp, r7
 80037fe:	bd90      	pop	{r4, r7, pc}
 8003800:	0802010c 	.word	0x0802010c
 8003804:	20000764 	.word	0x20000764
 8003808:	03000200 	.word	0x03000200
 800380c:	00000000 	.word	0x00000000
 8003810:	200036d0 	.word	0x200036d0

08003814 <OsTaskResume>:

STATIC VOID OsTaskResume(const UINT32 *taskId)
{
 8003814:	b590      	push	{r4, r7, lr}
 8003816:	b08b      	sub	sp, #44	; 0x2c
 8003818:	af00      	add	r7, sp, #0
 800381a:	6078      	str	r0, [r7, #4]
 800381c:	4b39      	ldr	r3, [pc, #228]	; (8003904 <OsTaskResume+0xf0>)
 800381e:	681b      	ldr	r3, [r3, #0]
 8003820:	627b      	str	r3, [r7, #36]	; 0x24
 8003822:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosTaskCB *taskCB = NULL;
 8003826:	2300      	movs	r3, #0
 8003828:	60fb      	str	r3, [r7, #12]

    taskCB = OS_TCB_FROM_TID(*taskId);
 800382a:	4b37      	ldr	r3, [pc, #220]	; (8003908 <OsTaskResume+0xf4>)
 800382c:	6819      	ldr	r1, [r3, #0]
 800382e:	687b      	ldr	r3, [r7, #4]
 8003830:	681a      	ldr	r2, [r3, #0]
 8003832:	4613      	mov	r3, r2
 8003834:	009b      	lsls	r3, r3, #2
 8003836:	4413      	add	r3, r2
 8003838:	015b      	lsls	r3, r3, #5
 800383a:	440b      	add	r3, r1
 800383c:	60fb      	str	r3, [r7, #12]

    SCHEDULER_LOCK(intSave);
 800383e:	f107 0308 	add.w	r3, r7, #8
 8003842:	4619      	mov	r1, r3
 8003844:	4831      	ldr	r0, [pc, #196]	; (800390c <OsTaskResume+0xf8>)
 8003846:	f7ff f8f5 	bl	8002a34 <LOS_SpinLockSave>

    taskCB->taskStatus &= ~OS_TASK_STATUS_SUSPEND;
 800384a:	68fb      	ldr	r3, [r7, #12]
 800384c:	889b      	ldrh	r3, [r3, #4]
 800384e:	f023 0302 	bic.w	r3, r3, #2
 8003852:	b29a      	uxth	r2, r3
 8003854:	68fb      	ldr	r3, [r7, #12]
 8003856:	809a      	strh	r2, [r3, #4]
    taskCB->taskStatus |= OS_TASK_STATUS_READY;
 8003858:	68fb      	ldr	r3, [r7, #12]
 800385a:	889b      	ldrh	r3, [r3, #4]
 800385c:	f043 0304 	orr.w	r3, r3, #4
 8003860:	b29a      	uxth	r2, r3
 8003862:	68fb      	ldr	r3, [r7, #12]
 8003864:	809a      	strh	r2, [r3, #4]
    OsPriQueueEnqueue(&taskCB->pendList, taskCB->priority);
 8003866:	68fb      	ldr	r3, [r7, #12]
 8003868:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800386c:	68fb      	ldr	r3, [r7, #12]
 800386e:	88db      	ldrh	r3, [r3, #6]
 8003870:	4619      	mov	r1, r3
 8003872:	4610      	mov	r0, r2
 8003874:	f004 fe94 	bl	80085a0 <OsPriQueueEnqueue>

    SCHEDULER_UNLOCK(intSave);
 8003878:	68bb      	ldr	r3, [r7, #8]
 800387a:	4619      	mov	r1, r3
 800387c:	4823      	ldr	r0, [pc, #140]	; (800390c <OsTaskResume+0xf8>)
 800387e:	f7ff f8e7 	bl	8002a50 <LOS_SpinUnlockRestore>

    LOS_TRACE(TASK_CREATE, taskCB->taskId, taskCB->taskStatus, taskCB->priority);
 8003882:	2300      	movs	r3, #0
 8003884:	617b      	str	r3, [r7, #20]
 8003886:	68fb      	ldr	r3, [r7, #12]
 8003888:	695b      	ldr	r3, [r3, #20]
 800388a:	61bb      	str	r3, [r7, #24]
 800388c:	68fb      	ldr	r3, [r7, #12]
 800388e:	889b      	ldrh	r3, [r3, #4]
 8003890:	61fb      	str	r3, [r7, #28]
 8003892:	68fb      	ldr	r3, [r7, #12]
 8003894:	88db      	ldrh	r3, [r3, #6]
 8003896:	623b      	str	r3, [r7, #32]
 8003898:	2304      	movs	r3, #4
 800389a:	613b      	str	r3, [r7, #16]
 800389c:	693b      	ldr	r3, [r7, #16]
 800389e:	2b01      	cmp	r3, #1
 80038a0:	d915      	bls.n	80038ce <OsTaskResume+0xba>
 80038a2:	4b1b      	ldr	r3, [pc, #108]	; (8003910 <OsTaskResume+0xfc>)
 80038a4:	681b      	ldr	r3, [r3, #0]
 80038a6:	2b00      	cmp	r3, #0
 80038a8:	d011      	beq.n	80038ce <OsTaskResume+0xba>
 80038aa:	4b19      	ldr	r3, [pc, #100]	; (8003910 <OsTaskResume+0xfc>)
 80038ac:	681c      	ldr	r4, [r3, #0]
 80038ae:	69b9      	ldr	r1, [r7, #24]
 80038b0:	693b      	ldr	r3, [r7, #16]
 80038b2:	2b02      	cmp	r3, #2
 80038b4:	d904      	bls.n	80038c0 <OsTaskResume+0xac>
 80038b6:	f107 0314 	add.w	r3, r7, #20
 80038ba:	f103 0208 	add.w	r2, r3, #8
 80038be:	e000      	b.n	80038c2 <OsTaskResume+0xae>
 80038c0:	2200      	movs	r2, #0
 80038c2:	693b      	ldr	r3, [r7, #16]
 80038c4:	b29b      	uxth	r3, r3
 80038c6:	3b02      	subs	r3, #2
 80038c8:	b29b      	uxth	r3, r3
 80038ca:	2040      	movs	r0, #64	; 0x40
 80038cc:	47a0      	blx	r4

    /* in case created task not running on this core,
       schedule or not depends on other schedulers status. */
    LOS_MpSchedule(OS_MP_CPU_ALL);
 80038ce:	2001      	movs	r0, #1
 80038d0:	f7ff f8e3 	bl	8002a9a <LOS_MpSchedule>
    if (OS_SCHEDULER_ACTIVE) {
 80038d4:	f7ff f811 	bl	80028fa <ArchCurrCpuid>
 80038d8:	4603      	mov	r3, r0
 80038da:	2201      	movs	r2, #1
 80038dc:	409a      	lsls	r2, r3
 80038de:	4b0d      	ldr	r3, [pc, #52]	; (8003914 <OsTaskResume+0x100>)
 80038e0:	681b      	ldr	r3, [r3, #0]
 80038e2:	4013      	ands	r3, r2
 80038e4:	2b00      	cmp	r3, #0
 80038e6:	d001      	beq.n	80038ec <OsTaskResume+0xd8>
        LOS_Schedule();
 80038e8:	f7ff f880 	bl	80029ec <LOS_Schedule>
    }
}
 80038ec:	bf00      	nop
 80038ee:	4b05      	ldr	r3, [pc, #20]	; (8003904 <OsTaskResume+0xf0>)
 80038f0:	681a      	ldr	r2, [r3, #0]
 80038f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80038f4:	405a      	eors	r2, r3
 80038f6:	d001      	beq.n	80038fc <OsTaskResume+0xe8>
 80038f8:	f000 fd76 	bl	80043e8 <__stack_chk_fail>
 80038fc:	372c      	adds	r7, #44	; 0x2c
 80038fe:	46bd      	mov	sp, r7
 8003900:	bd90      	pop	{r4, r7, pc}
 8003902:	bf00      	nop
 8003904:	08020110 	.word	0x08020110
 8003908:	200036c4 	.word	0x200036c4
 800390c:	20000764 	.word	0x20000764
 8003910:	2000075c 	.word	0x2000075c
 8003914:	200036dc 	.word	0x200036dc

08003918 <LOS_TaskCreateOnly>:
    return LOS_OK;
}
#endif

LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreateOnly(UINT32 *taskId, TSK_INIT_PARAM_S *initParam)
{
 8003918:	b580      	push	{r7, lr}
 800391a:	b082      	sub	sp, #8
 800391c:	af00      	add	r7, sp, #0
 800391e:	6078      	str	r0, [r7, #4]
 8003920:	6039      	str	r1, [r7, #0]
    return OsTaskCreateOnly(taskId, initParam, NULL, FALSE);
 8003922:	2300      	movs	r3, #0
 8003924:	2200      	movs	r2, #0
 8003926:	6839      	ldr	r1, [r7, #0]
 8003928:	6878      	ldr	r0, [r7, #4]
 800392a:	f7ff fec7 	bl	80036bc <OsTaskCreateOnly>
 800392e:	4603      	mov	r3, r0
}
 8003930:	4618      	mov	r0, r3
 8003932:	3708      	adds	r7, #8
 8003934:	46bd      	mov	sp, r7
 8003936:	bd80      	pop	{r7, pc}

08003938 <LOS_TaskCreate>:

LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreate(UINT32 *taskId, TSK_INIT_PARAM_S *initParam)
{
 8003938:	b580      	push	{r7, lr}
 800393a:	b084      	sub	sp, #16
 800393c:	af00      	add	r7, sp, #0
 800393e:	6078      	str	r0, [r7, #4]
 8003940:	6039      	str	r1, [r7, #0]
    UINT32 ret;

    ret = LOS_TaskCreateOnly(taskId, initParam);
 8003942:	6839      	ldr	r1, [r7, #0]
 8003944:	6878      	ldr	r0, [r7, #4]
 8003946:	f7ff ffe7 	bl	8003918 <LOS_TaskCreateOnly>
 800394a:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 800394c:	68fb      	ldr	r3, [r7, #12]
 800394e:	2b00      	cmp	r3, #0
 8003950:	d001      	beq.n	8003956 <LOS_TaskCreate+0x1e>
        return ret;
 8003952:	68fb      	ldr	r3, [r7, #12]
 8003954:	e003      	b.n	800395e <LOS_TaskCreate+0x26>
    }

    OsTaskResume(taskId);
 8003956:	6878      	ldr	r0, [r7, #4]
 8003958:	f7ff ff5c 	bl	8003814 <OsTaskResume>

    return LOS_OK;
 800395c:	2300      	movs	r3, #0
}
 800395e:	4618      	mov	r0, r3
 8003960:	3710      	adds	r7, #16
 8003962:	46bd      	mov	sp, r7
 8003964:	bd80      	pop	{r7, pc}
	...

08003968 <LOS_TaskDelete>:

LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskDelete(UINT32 taskId)
{
 8003968:	b580      	push	{r7, lr}
 800396a:	b088      	sub	sp, #32
 800396c:	af00      	add	r7, sp, #0
 800396e:	6078      	str	r0, [r7, #4]
 8003970:	4b56      	ldr	r3, [pc, #344]	; (8003acc <LOS_TaskDelete+0x164>)
 8003972:	681b      	ldr	r3, [r3, #0]
 8003974:	61fb      	str	r3, [r7, #28]
 8003976:	f04f 0300 	mov.w	r3, #0
    LosTaskCB *taskCB = NULL;
 800397a:	2300      	movs	r3, #0
 800397c:	61bb      	str	r3, [r7, #24]
    UINT32 intSave;
    UINT32 errRet = LOS_OK;
 800397e:	2300      	movs	r3, #0
 8003980:	617b      	str	r3, [r7, #20]
    UINT16 tempStatus;

    if (OS_TASK_ID_CHECK_INVALID(taskId)) {
 8003982:	4b53      	ldr	r3, [pc, #332]	; (8003ad0 <LOS_TaskDelete+0x168>)
 8003984:	681b      	ldr	r3, [r3, #0]
 8003986:	687a      	ldr	r2, [r7, #4]
 8003988:	429a      	cmp	r2, r3
 800398a:	d301      	bcc.n	8003990 <LOS_TaskDelete+0x28>
        return LOS_ERRNO_TSK_ID_INVALID;
 800398c:	4b51      	ldr	r3, [pc, #324]	; (8003ad4 <LOS_TaskDelete+0x16c>)
 800398e:	e092      	b.n	8003ab6 <LOS_TaskDelete+0x14e>
    }

    taskCB = OS_TCB_FROM_TID(taskId);
 8003990:	4b51      	ldr	r3, [pc, #324]	; (8003ad8 <LOS_TaskDelete+0x170>)
 8003992:	6819      	ldr	r1, [r3, #0]
 8003994:	687a      	ldr	r2, [r7, #4]
 8003996:	4613      	mov	r3, r2
 8003998:	009b      	lsls	r3, r3, #2
 800399a:	4413      	add	r3, r2
 800399c:	015b      	lsls	r3, r3, #5
 800399e:	440b      	add	r3, r1
 80039a0:	61bb      	str	r3, [r7, #24]
    if (taskCB->taskFlags & OS_TASK_FLAG_SYSTEM) {
 80039a2:	69bb      	ldr	r3, [r7, #24]
 80039a4:	689b      	ldr	r3, [r3, #8]
 80039a6:	f3c3 031e 	ubfx	r3, r3, #0, #31
 80039aa:	f003 0302 	and.w	r3, r3, #2
 80039ae:	2b00      	cmp	r3, #0
 80039b0:	d001      	beq.n	80039b6 <LOS_TaskDelete+0x4e>
        return LOS_ERRNO_TSK_OPERATE_SYSTEM_TASK;
 80039b2:	4b4a      	ldr	r3, [pc, #296]	; (8003adc <LOS_TaskDelete+0x174>)
 80039b4:	e07f      	b.n	8003ab6 <LOS_TaskDelete+0x14e>
    }

    SCHEDULER_LOCK(intSave);
 80039b6:	f107 0310 	add.w	r3, r7, #16
 80039ba:	4619      	mov	r1, r3
 80039bc:	4848      	ldr	r0, [pc, #288]	; (8003ae0 <LOS_TaskDelete+0x178>)
 80039be:	f7ff f839 	bl	8002a34 <LOS_SpinLockSave>

    tempStatus = taskCB->taskStatus;
 80039c2:	69bb      	ldr	r3, [r7, #24]
 80039c4:	889b      	ldrh	r3, [r3, #4]
 80039c6:	81fb      	strh	r3, [r7, #14]
    if (tempStatus & OS_TASK_STATUS_UNUSED) {
 80039c8:	89fb      	ldrh	r3, [r7, #14]
 80039ca:	f003 0301 	and.w	r3, r3, #1
 80039ce:	2b00      	cmp	r3, #0
 80039d0:	d002      	beq.n	80039d8 <LOS_TaskDelete+0x70>
        errRet = LOS_ERRNO_TSK_NOT_CREATED;
 80039d2:	4b44      	ldr	r3, [pc, #272]	; (8003ae4 <LOS_TaskDelete+0x17c>)
 80039d4:	617b      	str	r3, [r7, #20]
        goto LOS_RETURN;
 80039d6:	e068      	b.n	8003aaa <LOS_TaskDelete+0x142>
    }
    if ((tempStatus & OS_TASK_STATUS_RUNNING) &&
 80039d8:	89fb      	ldrh	r3, [r7, #14]
 80039da:	f003 0310 	and.w	r3, r3, #16
 80039de:	2b00      	cmp	r3, #0
 80039e0:	d008      	beq.n	80039f4 <LOS_TaskDelete+0x8c>
        !OsTaskDeleteCheckOnRun(taskCB, &errRet)) {
 80039e2:	f107 0314 	add.w	r3, r7, #20
 80039e6:	4619      	mov	r1, r3
 80039e8:	69b8      	ldr	r0, [r7, #24]
 80039ea:	f7ff fda5 	bl	8003538 <OsTaskDeleteCheckOnRun>
 80039ee:	4603      	mov	r3, r0
    if ((tempStatus & OS_TASK_STATUS_RUNNING) &&
 80039f0:	2b00      	cmp	r3, #0
 80039f2:	d057      	beq.n	8003aa4 <LOS_TaskDelete+0x13c>
        goto LOS_RETURN;
    }

    if (tempStatus & OS_TASK_STATUS_READY) {
 80039f4:	89fb      	ldrh	r3, [r7, #14]
 80039f6:	f003 0304 	and.w	r3, r3, #4
 80039fa:	2b00      	cmp	r3, #0
 80039fc:	d00c      	beq.n	8003a18 <LOS_TaskDelete+0xb0>
        OsPriQueueDequeue(&taskCB->pendList);
 80039fe:	69bb      	ldr	r3, [r7, #24]
 8003a00:	3340      	adds	r3, #64	; 0x40
 8003a02:	4618      	mov	r0, r3
 8003a04:	f004 fe0e 	bl	8008624 <OsPriQueueDequeue>
        taskCB->taskStatus &= ~OS_TASK_STATUS_READY;
 8003a08:	69bb      	ldr	r3, [r7, #24]
 8003a0a:	889b      	ldrh	r3, [r3, #4]
 8003a0c:	f023 0304 	bic.w	r3, r3, #4
 8003a10:	b29a      	uxth	r2, r3
 8003a12:	69bb      	ldr	r3, [r7, #24]
 8003a14:	809a      	strh	r2, [r3, #4]
 8003a16:	e009      	b.n	8003a2c <LOS_TaskDelete+0xc4>
    } else if (tempStatus & OS_TASK_STATUS_PEND) {
 8003a18:	89fb      	ldrh	r3, [r7, #14]
 8003a1a:	f003 0308 	and.w	r3, r3, #8
 8003a1e:	2b00      	cmp	r3, #0
 8003a20:	d004      	beq.n	8003a2c <LOS_TaskDelete+0xc4>
        LOS_ListDelete(&taskCB->pendList);
 8003a22:	69bb      	ldr	r3, [r7, #24]
 8003a24:	3340      	adds	r3, #64	; 0x40
 8003a26:	4618      	mov	r0, r3
 8003a28:	f7fe ff3b 	bl	80028a2 <LOS_ListDelete>
    }

    if (tempStatus & (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND_TIME)) {
 8003a2c:	89fb      	ldrh	r3, [r7, #14]
 8003a2e:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
 8003a32:	2b00      	cmp	r3, #0
 8003a34:	d002      	beq.n	8003a3c <LOS_TaskDelete+0xd4>
        OsTimerListDelete(taskCB);
 8003a36:	69b8      	ldr	r0, [r7, #24]
 8003a38:	f7ff f93a 	bl	8002cb0 <OsTimerListDelete>
    }

    taskCB->taskStatus &= ~OS_TASK_STATUS_SUSPEND;
 8003a3c:	69bb      	ldr	r3, [r7, #24]
 8003a3e:	889b      	ldrh	r3, [r3, #4]
 8003a40:	f023 0302 	bic.w	r3, r3, #2
 8003a44:	b29a      	uxth	r2, r3
 8003a46:	69bb      	ldr	r3, [r7, #24]
 8003a48:	809a      	strh	r2, [r3, #4]
    taskCB->taskStatus |= OS_TASK_STATUS_UNUSED;
 8003a4a:	69bb      	ldr	r3, [r7, #24]
 8003a4c:	889b      	ldrh	r3, [r3, #4]
 8003a4e:	f043 0301 	orr.w	r3, r3, #1
 8003a52:	b29a      	uxth	r2, r3
 8003a54:	69bb      	ldr	r3, [r7, #24]
 8003a56:	809a      	strh	r2, [r3, #4]
#ifdef LOSCFG_BASE_IPC_EVENT
    taskCB->event.uwEventID = OS_INVALID_VALUE;
 8003a58:	69bb      	ldr	r3, [r7, #24]
 8003a5a:	f04f 32ff 	mov.w	r2, #4294967295
 8003a5e:	655a      	str	r2, [r3, #84]	; 0x54
    taskCB->eventMask = 0;
 8003a60:	69bb      	ldr	r3, [r7, #24]
 8003a62:	2200      	movs	r2, #0
 8003a64:	661a      	str	r2, [r3, #96]	; 0x60
#endif
#ifdef LOSCFG_KERNEL_CPUP
    (VOID)memset_s((VOID *)OsCpupCBGet(taskCB->taskId), sizeof(OsCpupCB), 0, sizeof(OsCpupCB));
 8003a66:	69bb      	ldr	r3, [r7, #24]
 8003a68:	695b      	ldr	r3, [r3, #20]
 8003a6a:	4618      	mov	r0, r3
 8003a6c:	f00f fec0 	bl	80137f0 <OsCpupCBGet>
 8003a70:	2378      	movs	r3, #120	; 0x78
 8003a72:	2200      	movs	r2, #0
 8003a74:	2178      	movs	r1, #120	; 0x78
 8003a76:	f012 fb09 	bl	801608c <memset_s>
#endif
    OS_MEM_CLEAR(taskId);
 8003a7a:	6878      	ldr	r0, [r7, #4]
 8003a7c:	f005 fd78 	bl	8009570 <OsMemTaskClear>

    OsTaskSyncWake(taskCB);
 8003a80:	69b8      	ldr	r0, [r7, #24]
 8003a82:	f7ff fcac 	bl	80033de <OsTaskSyncWake>
    if (OsTaskDelAction(taskCB, taskCB->usrStack)) {
 8003a86:	69bb      	ldr	r3, [r7, #24]
 8003a88:	7adb      	ldrb	r3, [r3, #11]
 8003a8a:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8003a8e:	b2db      	uxtb	r3, r3
 8003a90:	4619      	mov	r1, r3
 8003a92:	69b8      	ldr	r0, [r7, #24]
 8003a94:	f7ff fcdc 	bl	8003450 <OsTaskDelAction>
 8003a98:	4603      	mov	r3, r0
 8003a9a:	2b00      	cmp	r3, #0
 8003a9c:	d004      	beq.n	8003aa8 <LOS_TaskDelete+0x140>
        OsSchedResched();
 8003a9e:	f004 fb55 	bl	800814c <OsSchedResched>
 8003aa2:	e002      	b.n	8003aaa <LOS_TaskDelete+0x142>
        goto LOS_RETURN;
 8003aa4:	bf00      	nop
 8003aa6:	e000      	b.n	8003aaa <LOS_TaskDelete+0x142>
    }

LOS_RETURN:
 8003aa8:	bf00      	nop
    SCHEDULER_UNLOCK(intSave);
 8003aaa:	693b      	ldr	r3, [r7, #16]
 8003aac:	4619      	mov	r1, r3
 8003aae:	480c      	ldr	r0, [pc, #48]	; (8003ae0 <LOS_TaskDelete+0x178>)
 8003ab0:	f7fe ffce 	bl	8002a50 <LOS_SpinUnlockRestore>
    return errRet;
 8003ab4:	697b      	ldr	r3, [r7, #20]
}
 8003ab6:	4a05      	ldr	r2, [pc, #20]	; (8003acc <LOS_TaskDelete+0x164>)
 8003ab8:	6811      	ldr	r1, [r2, #0]
 8003aba:	69fa      	ldr	r2, [r7, #28]
 8003abc:	4051      	eors	r1, r2
 8003abe:	d001      	beq.n	8003ac4 <LOS_TaskDelete+0x15c>
 8003ac0:	f000 fc92 	bl	80043e8 <__stack_chk_fail>
 8003ac4:	4618      	mov	r0, r3
 8003ac6:	3720      	adds	r7, #32
 8003ac8:	46bd      	mov	sp, r7
 8003aca:	bd80      	pop	{r7, pc}
 8003acc:	08020114 	.word	0x08020114
 8003ad0:	200036d8 	.word	0x200036d8
 8003ad4:	02000207 	.word	0x02000207
 8003ad8:	200036c4 	.word	0x200036c4
 8003adc:	02000214 	.word	0x02000214
 8003ae0:	20000764 	.word	0x20000764
 8003ae4:	0200020a 	.word	0x0200020a

08003ae8 <OsTaskSuspendCheckOnRun>:
 * 2. Do the suspension when preemption is disabled
 * 3. Do the suspension in hard-irq
 * then LOS_TaskSuspend will directly return with 'ret' value.
 */
LITE_OS_SEC_TEXT_INIT STATIC BOOL OsTaskSuspendCheckOnRun(LosTaskCB *taskCB, UINT32 *ret)
{
 8003ae8:	b580      	push	{r7, lr}
 8003aea:	b082      	sub	sp, #8
 8003aec:	af00      	add	r7, sp, #0
 8003aee:	6078      	str	r0, [r7, #4]
 8003af0:	6039      	str	r1, [r7, #0]
    /* init default out return value */
    *ret = LOS_OK;
 8003af2:	683b      	ldr	r3, [r7, #0]
 8003af4:	2200      	movs	r2, #0
 8003af6:	601a      	str	r2, [r3, #0]
        LOS_MpSchedule(taskCB->currCpu);
        return FALSE;
    }
#endif

    if (!OsPreemptableInSched()) {
 8003af8:	f7fe ff5c 	bl	80029b4 <OsPreemptableInSched>
 8003afc:	4603      	mov	r3, r0
 8003afe:	2b00      	cmp	r3, #0
 8003b00:	d104      	bne.n	8003b0c <OsTaskSuspendCheckOnRun+0x24>
        /* Suspending the current core's running task */
        *ret = LOS_ERRNO_TSK_SUSPEND_LOCKED;
 8003b02:	683b      	ldr	r3, [r7, #0]
 8003b04:	4a09      	ldr	r2, [pc, #36]	; (8003b2c <OsTaskSuspendCheckOnRun+0x44>)
 8003b06:	601a      	str	r2, [r3, #0]
        return FALSE;
 8003b08:	2300      	movs	r3, #0
 8003b0a:	e00a      	b.n	8003b22 <OsTaskSuspendCheckOnRun+0x3a>
    }

    if (OS_INT_ACTIVE) {
 8003b0c:	f7fe fcae 	bl	800246c <IntActive>
 8003b10:	4603      	mov	r3, r0
 8003b12:	2b00      	cmp	r3, #0
 8003b14:	d004      	beq.n	8003b20 <OsTaskSuspendCheckOnRun+0x38>
        /* suspend running task in interrupt */
        taskCB->signal = SIGNAL_SUSPEND;
 8003b16:	687b      	ldr	r3, [r7, #4]
 8003b18:	2202      	movs	r2, #2
 8003b1a:	671a      	str	r2, [r3, #112]	; 0x70
        return FALSE;
 8003b1c:	2300      	movs	r3, #0
 8003b1e:	e000      	b.n	8003b22 <OsTaskSuspendCheckOnRun+0x3a>
    }

    return TRUE;
 8003b20:	2301      	movs	r3, #1
}
 8003b22:	4618      	mov	r0, r3
 8003b24:	3708      	adds	r7, #8
 8003b26:	46bd      	mov	sp, r7
 8003b28:	bd80      	pop	{r7, pc}
 8003b2a:	bf00      	nop
 8003b2c:	03000215 	.word	0x03000215

08003b30 <LOS_TaskSuspend>:

LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskSuspend(UINT32 taskId)
{
 8003b30:	b590      	push	{r4, r7, lr}
 8003b32:	b08f      	sub	sp, #60	; 0x3c
 8003b34:	af00      	add	r7, sp, #0
 8003b36:	6078      	str	r0, [r7, #4]
 8003b38:	4b54      	ldr	r3, [pc, #336]	; (8003c8c <LOS_TaskSuspend+0x15c>)
 8003b3a:	681b      	ldr	r3, [r3, #0]
 8003b3c:	637b      	str	r3, [r7, #52]	; 0x34
 8003b3e:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosTaskCB *taskCB = NULL;
 8003b42:	2300      	movs	r3, #0
 8003b44:	61bb      	str	r3, [r7, #24]
    LosTaskCB *runTask = NULL;
 8003b46:	2300      	movs	r3, #0
 8003b48:	61fb      	str	r3, [r7, #28]
    UINT16 tempStatus;
    UINT32 errRet = LOS_OK;
 8003b4a:	2300      	movs	r3, #0
 8003b4c:	617b      	str	r3, [r7, #20]

    if (OS_TASK_ID_CHECK_INVALID(taskId)) {
 8003b4e:	4b50      	ldr	r3, [pc, #320]	; (8003c90 <LOS_TaskSuspend+0x160>)
 8003b50:	681b      	ldr	r3, [r3, #0]
 8003b52:	687a      	ldr	r2, [r7, #4]
 8003b54:	429a      	cmp	r2, r3
 8003b56:	d301      	bcc.n	8003b5c <LOS_TaskSuspend+0x2c>
        return LOS_ERRNO_TSK_ID_INVALID;
 8003b58:	4b4e      	ldr	r3, [pc, #312]	; (8003c94 <LOS_TaskSuspend+0x164>)
 8003b5a:	e08b      	b.n	8003c74 <LOS_TaskSuspend+0x144>
    }

    taskCB = OS_TCB_FROM_TID(taskId);
 8003b5c:	4b4e      	ldr	r3, [pc, #312]	; (8003c98 <LOS_TaskSuspend+0x168>)
 8003b5e:	6819      	ldr	r1, [r3, #0]
 8003b60:	687a      	ldr	r2, [r7, #4]
 8003b62:	4613      	mov	r3, r2
 8003b64:	009b      	lsls	r3, r3, #2
 8003b66:	4413      	add	r3, r2
 8003b68:	015b      	lsls	r3, r3, #5
 8003b6a:	440b      	add	r3, r1
 8003b6c:	61bb      	str	r3, [r7, #24]
    if (taskCB->taskFlags & OS_TASK_FLAG_SYSTEM) {
 8003b6e:	69bb      	ldr	r3, [r7, #24]
 8003b70:	689b      	ldr	r3, [r3, #8]
 8003b72:	f3c3 031e 	ubfx	r3, r3, #0, #31
 8003b76:	f003 0302 	and.w	r3, r3, #2
 8003b7a:	2b00      	cmp	r3, #0
 8003b7c:	d001      	beq.n	8003b82 <LOS_TaskSuspend+0x52>
        return LOS_ERRNO_TSK_OPERATE_SYSTEM_TASK;
 8003b7e:	4b47      	ldr	r3, [pc, #284]	; (8003c9c <LOS_TaskSuspend+0x16c>)
 8003b80:	e078      	b.n	8003c74 <LOS_TaskSuspend+0x144>
    }

    SCHEDULER_LOCK(intSave);
 8003b82:	f107 0310 	add.w	r3, r7, #16
 8003b86:	4619      	mov	r1, r3
 8003b88:	4845      	ldr	r0, [pc, #276]	; (8003ca0 <LOS_TaskSuspend+0x170>)
 8003b8a:	f7fe ff53 	bl	8002a34 <LOS_SpinLockSave>
    tempStatus = taskCB->taskStatus;
 8003b8e:	69bb      	ldr	r3, [r7, #24]
 8003b90:	889b      	ldrh	r3, [r3, #4]
 8003b92:	81fb      	strh	r3, [r7, #14]
    if (tempStatus & OS_TASK_STATUS_UNUSED) {
 8003b94:	89fb      	ldrh	r3, [r7, #14]
 8003b96:	f003 0301 	and.w	r3, r3, #1
 8003b9a:	2b00      	cmp	r3, #0
 8003b9c:	d002      	beq.n	8003ba4 <LOS_TaskSuspend+0x74>
        errRet = LOS_ERRNO_TSK_NOT_CREATED;
 8003b9e:	4b41      	ldr	r3, [pc, #260]	; (8003ca4 <LOS_TaskSuspend+0x174>)
 8003ba0:	617b      	str	r3, [r7, #20]
        goto LOS_RETURN;
 8003ba2:	e061      	b.n	8003c68 <LOS_TaskSuspend+0x138>
    }

    if (tempStatus & OS_TASK_STATUS_SUSPEND) {
 8003ba4:	89fb      	ldrh	r3, [r7, #14]
 8003ba6:	f003 0302 	and.w	r3, r3, #2
 8003baa:	2b00      	cmp	r3, #0
 8003bac:	d002      	beq.n	8003bb4 <LOS_TaskSuspend+0x84>
        errRet = LOS_ERRNO_TSK_ALREADY_SUSPENDED;
 8003bae:	4b3e      	ldr	r3, [pc, #248]	; (8003ca8 <LOS_TaskSuspend+0x178>)
 8003bb0:	617b      	str	r3, [r7, #20]
        goto LOS_RETURN;
 8003bb2:	e059      	b.n	8003c68 <LOS_TaskSuspend+0x138>
    }

    if ((tempStatus & OS_TASK_STATUS_RUNNING) &&
 8003bb4:	89fb      	ldrh	r3, [r7, #14]
 8003bb6:	f003 0310 	and.w	r3, r3, #16
 8003bba:	2b00      	cmp	r3, #0
 8003bbc:	d008      	beq.n	8003bd0 <LOS_TaskSuspend+0xa0>
        !OsTaskSuspendCheckOnRun(taskCB, &errRet)) {
 8003bbe:	f107 0314 	add.w	r3, r7, #20
 8003bc2:	4619      	mov	r1, r3
 8003bc4:	69b8      	ldr	r0, [r7, #24]
 8003bc6:	f7ff ff8f 	bl	8003ae8 <OsTaskSuspendCheckOnRun>
 8003bca:	4603      	mov	r3, r0
    if ((tempStatus & OS_TASK_STATUS_RUNNING) &&
 8003bcc:	2b00      	cmp	r3, #0
 8003bce:	d048      	beq.n	8003c62 <LOS_TaskSuspend+0x132>
        goto LOS_RETURN;
    }

    if (tempStatus & OS_TASK_STATUS_READY) {
 8003bd0:	89fb      	ldrh	r3, [r7, #14]
 8003bd2:	f003 0304 	and.w	r3, r3, #4
 8003bd6:	2b00      	cmp	r3, #0
 8003bd8:	d00b      	beq.n	8003bf2 <LOS_TaskSuspend+0xc2>
        OsPriQueueDequeue(&taskCB->pendList);
 8003bda:	69bb      	ldr	r3, [r7, #24]
 8003bdc:	3340      	adds	r3, #64	; 0x40
 8003bde:	4618      	mov	r0, r3
 8003be0:	f004 fd20 	bl	8008624 <OsPriQueueDequeue>
        taskCB->taskStatus &= ~OS_TASK_STATUS_READY;
 8003be4:	69bb      	ldr	r3, [r7, #24]
 8003be6:	889b      	ldrh	r3, [r3, #4]
 8003be8:	f023 0304 	bic.w	r3, r3, #4
 8003bec:	b29a      	uxth	r2, r3
 8003bee:	69bb      	ldr	r3, [r7, #24]
 8003bf0:	809a      	strh	r2, [r3, #4]
    }

    taskCB->taskStatus |= OS_TASK_STATUS_SUSPEND;
 8003bf2:	69bb      	ldr	r3, [r7, #24]
 8003bf4:	889b      	ldrh	r3, [r3, #4]
 8003bf6:	f043 0302 	orr.w	r3, r3, #2
 8003bfa:	b29a      	uxth	r2, r3
 8003bfc:	69bb      	ldr	r3, [r7, #24]
 8003bfe:	809a      	strh	r2, [r3, #4]

    runTask = OsCurrTaskGet();
 8003c00:	f7fe ff3d 	bl	8002a7e <OsCurrTaskGet>
 8003c04:	61f8      	str	r0, [r7, #28]

    LOS_TRACE(TASK_SUSPEND, taskCB->taskId, taskCB->taskStatus, runTask->taskId);
 8003c06:	2300      	movs	r3, #0
 8003c08:	627b      	str	r3, [r7, #36]	; 0x24
 8003c0a:	69bb      	ldr	r3, [r7, #24]
 8003c0c:	695b      	ldr	r3, [r3, #20]
 8003c0e:	62bb      	str	r3, [r7, #40]	; 0x28
 8003c10:	69bb      	ldr	r3, [r7, #24]
 8003c12:	889b      	ldrh	r3, [r3, #4]
 8003c14:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003c16:	69fb      	ldr	r3, [r7, #28]
 8003c18:	695b      	ldr	r3, [r3, #20]
 8003c1a:	633b      	str	r3, [r7, #48]	; 0x30
 8003c1c:	2304      	movs	r3, #4
 8003c1e:	623b      	str	r3, [r7, #32]
 8003c20:	6a3b      	ldr	r3, [r7, #32]
 8003c22:	2b01      	cmp	r3, #1
 8003c24:	d915      	bls.n	8003c52 <LOS_TaskSuspend+0x122>
 8003c26:	4b21      	ldr	r3, [pc, #132]	; (8003cac <LOS_TaskSuspend+0x17c>)
 8003c28:	681b      	ldr	r3, [r3, #0]
 8003c2a:	2b00      	cmp	r3, #0
 8003c2c:	d011      	beq.n	8003c52 <LOS_TaskSuspend+0x122>
 8003c2e:	4b1f      	ldr	r3, [pc, #124]	; (8003cac <LOS_TaskSuspend+0x17c>)
 8003c30:	681c      	ldr	r4, [r3, #0]
 8003c32:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8003c34:	6a3b      	ldr	r3, [r7, #32]
 8003c36:	2b02      	cmp	r3, #2
 8003c38:	d904      	bls.n	8003c44 <LOS_TaskSuspend+0x114>
 8003c3a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8003c3e:	f103 0208 	add.w	r2, r3, #8
 8003c42:	e000      	b.n	8003c46 <LOS_TaskSuspend+0x116>
 8003c44:	2200      	movs	r2, #0
 8003c46:	6a3b      	ldr	r3, [r7, #32]
 8003c48:	b29b      	uxth	r3, r3
 8003c4a:	3b02      	subs	r3, #2
 8003c4c:	b29b      	uxth	r3, r3
 8003c4e:	2043      	movs	r0, #67	; 0x43
 8003c50:	47a0      	blx	r4

    if (taskId == runTask->taskId) {
 8003c52:	69fb      	ldr	r3, [r7, #28]
 8003c54:	695b      	ldr	r3, [r3, #20]
 8003c56:	687a      	ldr	r2, [r7, #4]
 8003c58:	429a      	cmp	r2, r3
 8003c5a:	d104      	bne.n	8003c66 <LOS_TaskSuspend+0x136>
        OsSchedResched();
 8003c5c:	f004 fa76 	bl	800814c <OsSchedResched>
 8003c60:	e002      	b.n	8003c68 <LOS_TaskSuspend+0x138>
        goto LOS_RETURN;
 8003c62:	bf00      	nop
 8003c64:	e000      	b.n	8003c68 <LOS_TaskSuspend+0x138>
    }

LOS_RETURN:
 8003c66:	bf00      	nop
    SCHEDULER_UNLOCK(intSave);
 8003c68:	693b      	ldr	r3, [r7, #16]
 8003c6a:	4619      	mov	r1, r3
 8003c6c:	480c      	ldr	r0, [pc, #48]	; (8003ca0 <LOS_TaskSuspend+0x170>)
 8003c6e:	f7fe feef 	bl	8002a50 <LOS_SpinUnlockRestore>
    return errRet;
 8003c72:	697b      	ldr	r3, [r7, #20]
}
 8003c74:	4a05      	ldr	r2, [pc, #20]	; (8003c8c <LOS_TaskSuspend+0x15c>)
 8003c76:	6811      	ldr	r1, [r2, #0]
 8003c78:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003c7a:	4051      	eors	r1, r2
 8003c7c:	d001      	beq.n	8003c82 <LOS_TaskSuspend+0x152>
 8003c7e:	f000 fbb3 	bl	80043e8 <__stack_chk_fail>
 8003c82:	4618      	mov	r0, r3
 8003c84:	373c      	adds	r7, #60	; 0x3c
 8003c86:	46bd      	mov	sp, r7
 8003c88:	bd90      	pop	{r4, r7, pc}
 8003c8a:	bf00      	nop
 8003c8c:	0802011c 	.word	0x0802011c
 8003c90:	200036d8 	.word	0x200036d8
 8003c94:	02000207 	.word	0x02000207
 8003c98:	200036c4 	.word	0x200036c4
 8003c9c:	02000214 	.word	0x02000214
 8003ca0:	20000764 	.word	0x20000764
 8003ca4:	0200020a 	.word	0x0200020a
 8003ca8:	02000208 	.word	0x02000208
 8003cac:	2000075c 	.word	0x2000075c

08003cb0 <LOS_TaskDelay>:

LITE_OS_SEC_TEXT UINT32 LOS_TaskDelay(UINT32 tick)
{
 8003cb0:	b580      	push	{r7, lr}
 8003cb2:	b086      	sub	sp, #24
 8003cb4:	af00      	add	r7, sp, #0
 8003cb6:	6078      	str	r0, [r7, #4]
 8003cb8:	4b27      	ldr	r3, [pc, #156]	; (8003d58 <LOS_TaskDelay+0xa8>)
 8003cba:	681b      	ldr	r3, [r3, #0]
 8003cbc:	617b      	str	r3, [r7, #20]
 8003cbe:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosTaskCB *runTask = NULL;
 8003cc2:	2300      	movs	r3, #0
 8003cc4:	613b      	str	r3, [r7, #16]

    if (OS_INT_ACTIVE) {
 8003cc6:	f7fe fbd1 	bl	800246c <IntActive>
 8003cca:	4603      	mov	r3, r0
 8003ccc:	2b00      	cmp	r3, #0
 8003cce:	d001      	beq.n	8003cd4 <LOS_TaskDelay+0x24>
        return LOS_ERRNO_TSK_DELAY_IN_INT;
 8003cd0:	4b22      	ldr	r3, [pc, #136]	; (8003d5c <LOS_TaskDelay+0xac>)
 8003cd2:	e035      	b.n	8003d40 <LOS_TaskDelay+0x90>
    }

    runTask = OsCurrTaskGet();
 8003cd4:	f7fe fed3 	bl	8002a7e <OsCurrTaskGet>
 8003cd8:	6138      	str	r0, [r7, #16]
    if (runTask->taskFlags & OS_TASK_FLAG_SYSTEM) {
 8003cda:	693b      	ldr	r3, [r7, #16]
 8003cdc:	689b      	ldr	r3, [r3, #8]
 8003cde:	f3c3 031e 	ubfx	r3, r3, #0, #31
 8003ce2:	f003 0302 	and.w	r3, r3, #2
 8003ce6:	2b00      	cmp	r3, #0
 8003ce8:	d003      	beq.n	8003cf2 <LOS_TaskDelay+0x42>
        OsBackTrace();
 8003cea:	f000 fb1b 	bl	8004324 <LOS_BackTrace>
        return LOS_ERRNO_TSK_OPERATE_SYSTEM_TASK;
 8003cee:	4b1c      	ldr	r3, [pc, #112]	; (8003d60 <LOS_TaskDelay+0xb0>)
 8003cf0:	e026      	b.n	8003d40 <LOS_TaskDelay+0x90>
    }

    if (!OsPreemptable()) {
 8003cf2:	f7fe fe3f 	bl	8002974 <OsPreemptable>
 8003cf6:	4603      	mov	r3, r0
 8003cf8:	2b00      	cmp	r3, #0
 8003cfa:	d101      	bne.n	8003d00 <LOS_TaskDelay+0x50>
        return LOS_ERRNO_TSK_DELAY_IN_LOCK;
 8003cfc:	4b19      	ldr	r3, [pc, #100]	; (8003d64 <LOS_TaskDelay+0xb4>)
 8003cfe:	e01f      	b.n	8003d40 <LOS_TaskDelay+0x90>
    }

    if (tick == 0) {
 8003d00:	687b      	ldr	r3, [r7, #4]
 8003d02:	2b00      	cmp	r3, #0
 8003d04:	d103      	bne.n	8003d0e <LOS_TaskDelay+0x5e>
        return LOS_TaskYield();
 8003d06:	f000 f8a9 	bl	8003e5c <LOS_TaskYield>
 8003d0a:	4603      	mov	r3, r0
 8003d0c:	e018      	b.n	8003d40 <LOS_TaskDelay+0x90>
    } else {
        SCHEDULER_LOCK(intSave);
 8003d0e:	f107 030c 	add.w	r3, r7, #12
 8003d12:	4619      	mov	r1, r3
 8003d14:	4814      	ldr	r0, [pc, #80]	; (8003d68 <LOS_TaskDelay+0xb8>)
 8003d16:	f7fe fe8d 	bl	8002a34 <LOS_SpinLockSave>
        OsTaskAdd2TimerList(runTask, tick);
 8003d1a:	6879      	ldr	r1, [r7, #4]
 8003d1c:	6938      	ldr	r0, [r7, #16]
 8003d1e:	f7fe ffb1 	bl	8002c84 <OsTaskAdd2TimerList>
        runTask->taskStatus |= OS_TASK_STATUS_DELAY;
 8003d22:	693b      	ldr	r3, [r7, #16]
 8003d24:	889b      	ldrh	r3, [r3, #4]
 8003d26:	f043 0320 	orr.w	r3, r3, #32
 8003d2a:	b29a      	uxth	r2, r3
 8003d2c:	693b      	ldr	r3, [r7, #16]
 8003d2e:	809a      	strh	r2, [r3, #4]
        OsSchedResched();
 8003d30:	f004 fa0c 	bl	800814c <OsSchedResched>
        SCHEDULER_UNLOCK(intSave);
 8003d34:	68fb      	ldr	r3, [r7, #12]
 8003d36:	4619      	mov	r1, r3
 8003d38:	480b      	ldr	r0, [pc, #44]	; (8003d68 <LOS_TaskDelay+0xb8>)
 8003d3a:	f7fe fe89 	bl	8002a50 <LOS_SpinUnlockRestore>
    }

    return LOS_OK;
 8003d3e:	2300      	movs	r3, #0
}
 8003d40:	4a05      	ldr	r2, [pc, #20]	; (8003d58 <LOS_TaskDelay+0xa8>)
 8003d42:	6811      	ldr	r1, [r2, #0]
 8003d44:	697a      	ldr	r2, [r7, #20]
 8003d46:	4051      	eors	r1, r2
 8003d48:	d001      	beq.n	8003d4e <LOS_TaskDelay+0x9e>
 8003d4a:	f000 fb4d 	bl	80043e8 <__stack_chk_fail>
 8003d4e:	4618      	mov	r0, r3
 8003d50:	3718      	adds	r7, #24
 8003d52:	46bd      	mov	sp, r7
 8003d54:	bd80      	pop	{r7, pc}
 8003d56:	bf00      	nop
 8003d58:	08020120 	.word	0x08020120
 8003d5c:	0300020d 	.word	0x0300020d
 8003d60:	02000214 	.word	0x02000214
 8003d64:	0200020e 	.word	0x0200020e
 8003d68:	20000764 	.word	0x20000764

08003d6c <OsTaskWait>:
 *               taskStatus --- task status
 *               timeOut    ---  Expiry time
 * Return      : LOS_OK on success or LOS_NOK on failure
 */
VOID OsTaskWait(LOS_DL_LIST *list, UINT16 taskStatus, UINT32 timeout)
{
 8003d6c:	b580      	push	{r7, lr}
 8003d6e:	b086      	sub	sp, #24
 8003d70:	af00      	add	r7, sp, #0
 8003d72:	60f8      	str	r0, [r7, #12]
 8003d74:	460b      	mov	r3, r1
 8003d76:	607a      	str	r2, [r7, #4]
 8003d78:	817b      	strh	r3, [r7, #10]
    LosTaskCB *runTask = NULL;
 8003d7a:	2300      	movs	r3, #0
 8003d7c:	613b      	str	r3, [r7, #16]
    LOS_DL_LIST *pendObj = NULL;
 8003d7e:	2300      	movs	r3, #0
 8003d80:	617b      	str	r3, [r7, #20]

    runTask = OsCurrTaskGet();
 8003d82:	f7fe fe7c 	bl	8002a7e <OsCurrTaskGet>
 8003d86:	6138      	str	r0, [r7, #16]
    runTask->taskStatus &= ~OS_TASK_STATUS_READY;
 8003d88:	693b      	ldr	r3, [r7, #16]
 8003d8a:	889b      	ldrh	r3, [r3, #4]
 8003d8c:	f023 0304 	bic.w	r3, r3, #4
 8003d90:	b29a      	uxth	r2, r3
 8003d92:	693b      	ldr	r3, [r7, #16]
 8003d94:	809a      	strh	r2, [r3, #4]
    pendObj = &runTask->pendList;
 8003d96:	693b      	ldr	r3, [r7, #16]
 8003d98:	3340      	adds	r3, #64	; 0x40
 8003d9a:	617b      	str	r3, [r7, #20]
    runTask->taskStatus |= taskStatus;
 8003d9c:	693b      	ldr	r3, [r7, #16]
 8003d9e:	889a      	ldrh	r2, [r3, #4]
 8003da0:	897b      	ldrh	r3, [r7, #10]
 8003da2:	4313      	orrs	r3, r2
 8003da4:	b29a      	uxth	r2, r3
 8003da6:	693b      	ldr	r3, [r7, #16]
 8003da8:	809a      	strh	r2, [r3, #4]
    LOS_ListTailInsert(list, pendObj);
 8003daa:	6979      	ldr	r1, [r7, #20]
 8003dac:	68f8      	ldr	r0, [r7, #12]
 8003dae:	f7fe fd69 	bl	8002884 <LOS_ListTailInsert>
    if (timeout != LOS_WAIT_FOREVER) {
 8003db2:	687b      	ldr	r3, [r7, #4]
 8003db4:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003db8:	d00a      	beq.n	8003dd0 <OsTaskWait+0x64>
        runTask->taskStatus |= OS_TASK_STATUS_PEND_TIME;
 8003dba:	693b      	ldr	r3, [r7, #16]
 8003dbc:	889b      	ldrh	r3, [r3, #4]
 8003dbe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003dc2:	b29a      	uxth	r2, r3
 8003dc4:	693b      	ldr	r3, [r7, #16]
 8003dc6:	809a      	strh	r2, [r3, #4]
        OsTaskAdd2TimerList((LosTaskCB *)runTask, timeout);
 8003dc8:	6879      	ldr	r1, [r7, #4]
 8003dca:	6938      	ldr	r0, [r7, #16]
 8003dcc:	f7fe ff5a 	bl	8002c84 <OsTaskAdd2TimerList>
    }
}
 8003dd0:	bf00      	nop
 8003dd2:	3718      	adds	r7, #24
 8003dd4:	46bd      	mov	sp, r7
 8003dd6:	bd80      	pop	{r7, pc}

08003dd8 <OsTaskWake>:
 * Description : delete the task from pendlist and also add to the priqueue
 * Input       : resumedTask --- resumed task
 *               taskStatus  --- task status
 */
VOID OsTaskWake(LosTaskCB *resumedTask, UINT16 taskStatus)
{
 8003dd8:	b580      	push	{r7, lr}
 8003dda:	b082      	sub	sp, #8
 8003ddc:	af00      	add	r7, sp, #0
 8003dde:	6078      	str	r0, [r7, #4]
 8003de0:	460b      	mov	r3, r1
 8003de2:	807b      	strh	r3, [r7, #2]
    LOS_ListDelete(&resumedTask->pendList);
 8003de4:	687b      	ldr	r3, [r7, #4]
 8003de6:	3340      	adds	r3, #64	; 0x40
 8003de8:	4618      	mov	r0, r3
 8003dea:	f7fe fd5a 	bl	80028a2 <LOS_ListDelete>
    resumedTask->taskStatus &= ~taskStatus;
 8003dee:	687b      	ldr	r3, [r7, #4]
 8003df0:	889b      	ldrh	r3, [r3, #4]
 8003df2:	b21a      	sxth	r2, r3
 8003df4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8003df8:	43db      	mvns	r3, r3
 8003dfa:	b21b      	sxth	r3, r3
 8003dfc:	4013      	ands	r3, r2
 8003dfe:	b21b      	sxth	r3, r3
 8003e00:	b29a      	uxth	r2, r3
 8003e02:	687b      	ldr	r3, [r7, #4]
 8003e04:	809a      	strh	r2, [r3, #4]

    if (resumedTask->taskStatus & OS_TASK_STATUS_PEND_TIME) {
 8003e06:	687b      	ldr	r3, [r7, #4]
 8003e08:	889b      	ldrh	r3, [r3, #4]
 8003e0a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003e0e:	2b00      	cmp	r3, #0
 8003e10:	d009      	beq.n	8003e26 <OsTaskWake+0x4e>
        OsTimerListDelete(resumedTask);
 8003e12:	6878      	ldr	r0, [r7, #4]
 8003e14:	f7fe ff4c 	bl	8002cb0 <OsTimerListDelete>
        resumedTask->taskStatus &= ~OS_TASK_STATUS_PEND_TIME;
 8003e18:	687b      	ldr	r3, [r7, #4]
 8003e1a:	889b      	ldrh	r3, [r3, #4]
 8003e1c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8003e20:	b29a      	uxth	r2, r3
 8003e22:	687b      	ldr	r3, [r7, #4]
 8003e24:	809a      	strh	r2, [r3, #4]
    }
    if (!(resumedTask->taskStatus & OS_TASK_STATUS_SUSPEND)) {
 8003e26:	687b      	ldr	r3, [r7, #4]
 8003e28:	889b      	ldrh	r3, [r3, #4]
 8003e2a:	f003 0302 	and.w	r3, r3, #2
 8003e2e:	2b00      	cmp	r3, #0
 8003e30:	d10f      	bne.n	8003e52 <OsTaskWake+0x7a>
        resumedTask->taskStatus |= OS_TASK_STATUS_READY;
 8003e32:	687b      	ldr	r3, [r7, #4]
 8003e34:	889b      	ldrh	r3, [r3, #4]
 8003e36:	f043 0304 	orr.w	r3, r3, #4
 8003e3a:	b29a      	uxth	r2, r3
 8003e3c:	687b      	ldr	r3, [r7, #4]
 8003e3e:	809a      	strh	r2, [r3, #4]
        OsPriQueueEnqueue(&resumedTask->pendList, resumedTask->priority);
 8003e40:	687b      	ldr	r3, [r7, #4]
 8003e42:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8003e46:	687b      	ldr	r3, [r7, #4]
 8003e48:	88db      	ldrh	r3, [r3, #6]
 8003e4a:	4619      	mov	r1, r3
 8003e4c:	4610      	mov	r0, r2
 8003e4e:	f004 fba7 	bl	80085a0 <OsPriQueueEnqueue>
    }
}
 8003e52:	bf00      	nop
 8003e54:	3708      	adds	r7, #8
 8003e56:	46bd      	mov	sp, r7
 8003e58:	bd80      	pop	{r7, pc}
	...

08003e5c <LOS_TaskYield>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskYield(VOID)
{
 8003e5c:	b580      	push	{r7, lr}
 8003e5e:	b084      	sub	sp, #16
 8003e60:	af00      	add	r7, sp, #0
 8003e62:	4b2e      	ldr	r3, [pc, #184]	; (8003f1c <LOS_TaskYield+0xc0>)
 8003e64:	681b      	ldr	r3, [r3, #0]
 8003e66:	60fb      	str	r3, [r7, #12]
 8003e68:	f04f 0300 	mov.w	r3, #0
    UINT32 tskCount;
    UINT32 intSave;
    LosTaskCB *runTask = NULL;
 8003e6c:	2300      	movs	r3, #0
 8003e6e:	607b      	str	r3, [r7, #4]

    if (OS_INT_ACTIVE) {
 8003e70:	f7fe fafc 	bl	800246c <IntActive>
 8003e74:	4603      	mov	r3, r0
 8003e76:	2b00      	cmp	r3, #0
 8003e78:	d001      	beq.n	8003e7e <LOS_TaskYield+0x22>
        return LOS_ERRNO_TSK_YIELD_IN_INT;
 8003e7a:	4b29      	ldr	r3, [pc, #164]	; (8003f20 <LOS_TaskYield+0xc4>)
 8003e7c:	e042      	b.n	8003f04 <LOS_TaskYield+0xa8>
    }

    if (!OsPreemptable()) {
 8003e7e:	f7fe fd79 	bl	8002974 <OsPreemptable>
 8003e82:	4603      	mov	r3, r0
 8003e84:	2b00      	cmp	r3, #0
 8003e86:	d101      	bne.n	8003e8c <LOS_TaskYield+0x30>
        return LOS_ERRNO_TSK_YIELD_IN_LOCK;
 8003e88:	4b26      	ldr	r3, [pc, #152]	; (8003f24 <LOS_TaskYield+0xc8>)
 8003e8a:	e03b      	b.n	8003f04 <LOS_TaskYield+0xa8>
    }

    runTask = OsCurrTaskGet();
 8003e8c:	f7fe fdf7 	bl	8002a7e <OsCurrTaskGet>
 8003e90:	6078      	str	r0, [r7, #4]
    if (runTask->taskId >= g_taskMaxNum) {
 8003e92:	687b      	ldr	r3, [r7, #4]
 8003e94:	695a      	ldr	r2, [r3, #20]
 8003e96:	4b24      	ldr	r3, [pc, #144]	; (8003f28 <LOS_TaskYield+0xcc>)
 8003e98:	681b      	ldr	r3, [r3, #0]
 8003e9a:	429a      	cmp	r2, r3
 8003e9c:	d301      	bcc.n	8003ea2 <LOS_TaskYield+0x46>
        return LOS_ERRNO_TSK_ID_INVALID;
 8003e9e:	4b23      	ldr	r3, [pc, #140]	; (8003f2c <LOS_TaskYield+0xd0>)
 8003ea0:	e030      	b.n	8003f04 <LOS_TaskYield+0xa8>
    }

    SCHEDULER_LOCK(intSave);
 8003ea2:	463b      	mov	r3, r7
 8003ea4:	4619      	mov	r1, r3
 8003ea6:	4822      	ldr	r0, [pc, #136]	; (8003f30 <LOS_TaskYield+0xd4>)
 8003ea8:	f7fe fdc4 	bl	8002a34 <LOS_SpinLockSave>

#ifdef LOSCFG_BASE_CORE_TIMESLICE
    /* reset timeslice of yielded task */
    runTask->timeSlice = 0;
 8003eac:	687b      	ldr	r3, [r7, #4]
 8003eae:	2200      	movs	r2, #0
 8003eb0:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
#endif
    tskCount = OsPriQueueSize(runTask->priority);
 8003eb4:	687b      	ldr	r3, [r7, #4]
 8003eb6:	88db      	ldrh	r3, [r3, #6]
 8003eb8:	4618      	mov	r0, r3
 8003eba:	f004 fbdf 	bl	800867c <OsPriQueueSize>
 8003ebe:	60b8      	str	r0, [r7, #8]
    if (tskCount > 0) {
 8003ec0:	68bb      	ldr	r3, [r7, #8]
 8003ec2:	2b00      	cmp	r3, #0
 8003ec4:	d018      	beq.n	8003ef8 <LOS_TaskYield+0x9c>
        runTask->taskStatus |= OS_TASK_STATUS_READY;
 8003ec6:	687b      	ldr	r3, [r7, #4]
 8003ec8:	889b      	ldrh	r3, [r3, #4]
 8003eca:	f043 0304 	orr.w	r3, r3, #4
 8003ece:	b29a      	uxth	r2, r3
 8003ed0:	687b      	ldr	r3, [r7, #4]
 8003ed2:	809a      	strh	r2, [r3, #4]
        OsPriQueueEnqueue(&(runTask->pendList), runTask->priority);
 8003ed4:	687b      	ldr	r3, [r7, #4]
 8003ed6:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8003eda:	687b      	ldr	r3, [r7, #4]
 8003edc:	88db      	ldrh	r3, [r3, #6]
 8003ede:	4619      	mov	r1, r3
 8003ee0:	4610      	mov	r0, r2
 8003ee2:	f004 fb5d 	bl	80085a0 <OsPriQueueEnqueue>
    } else {
        SCHEDULER_UNLOCK(intSave);
        return LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK;
    }
    OsSchedResched();
 8003ee6:	f004 f931 	bl	800814c <OsSchedResched>
    SCHEDULER_UNLOCK(intSave);
 8003eea:	683b      	ldr	r3, [r7, #0]
 8003eec:	4619      	mov	r1, r3
 8003eee:	4810      	ldr	r0, [pc, #64]	; (8003f30 <LOS_TaskYield+0xd4>)
 8003ef0:	f7fe fdae 	bl	8002a50 <LOS_SpinUnlockRestore>
    return LOS_OK;
 8003ef4:	2300      	movs	r3, #0
 8003ef6:	e005      	b.n	8003f04 <LOS_TaskYield+0xa8>
        SCHEDULER_UNLOCK(intSave);
 8003ef8:	683b      	ldr	r3, [r7, #0]
 8003efa:	4619      	mov	r1, r3
 8003efc:	480c      	ldr	r0, [pc, #48]	; (8003f30 <LOS_TaskYield+0xd4>)
 8003efe:	f7fe fda7 	bl	8002a50 <LOS_SpinUnlockRestore>
        return LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK;
 8003f02:	4b0c      	ldr	r3, [pc, #48]	; (8003f34 <LOS_TaskYield+0xd8>)
}
 8003f04:	4a05      	ldr	r2, [pc, #20]	; (8003f1c <LOS_TaskYield+0xc0>)
 8003f06:	6811      	ldr	r1, [r2, #0]
 8003f08:	68fa      	ldr	r2, [r7, #12]
 8003f0a:	4051      	eors	r1, r2
 8003f0c:	d001      	beq.n	8003f12 <LOS_TaskYield+0xb6>
 8003f0e:	f000 fa6b 	bl	80043e8 <__stack_chk_fail>
 8003f12:	4618      	mov	r0, r3
 8003f14:	3710      	adds	r7, #16
 8003f16:	46bd      	mov	sp, r7
 8003f18:	bd80      	pop	{r7, pc}
 8003f1a:	bf00      	nop
 8003f1c:	0802012c 	.word	0x0802012c
 8003f20:	02000224 	.word	0x02000224
 8003f24:	0200020f 	.word	0x0200020f
 8003f28:	200036d8 	.word	0x200036d8
 8003f2c:	02000207 	.word	0x02000207
 8003f30:	20000764 	.word	0x20000764
 8003f34:	02000210 	.word	0x02000210

08003f38 <OsTaskProcSignal>:

/*
 * Description : Process pending signals tagged by others cores
 */
LITE_OS_SEC_TEXT_MINOR UINT32 OsTaskProcSignal(VOID)
{
 8003f38:	b590      	push	{r4, r7, lr}
 8003f3a:	b087      	sub	sp, #28
 8003f3c:	af00      	add	r7, sp, #0
 8003f3e:	4b3d      	ldr	r3, [pc, #244]	; (8004034 <OsTaskProcSignal+0xfc>)
 8003f40:	681b      	ldr	r3, [r3, #0]
 8003f42:	617b      	str	r3, [r7, #20]
 8003f44:	f04f 0300 	mov.w	r3, #0
    Percpu    *percpu = NULL;
 8003f48:	2300      	movs	r3, #0
 8003f4a:	603b      	str	r3, [r7, #0]
    LosTaskCB *runTask = NULL;
 8003f4c:	2300      	movs	r3, #0
 8003f4e:	607b      	str	r3, [r7, #4]
    /*
     * private and uninterruptable, no protection needed.
     * while this task is always running when others cores see it,
     * so it keeps recieving signals while follow code excuting.
     */
    runTask = OsCurrTaskGet();
 8003f50:	f7fe fd95 	bl	8002a7e <OsCurrTaskGet>
 8003f54:	6078      	str	r0, [r7, #4]
    if (runTask->signal == SIGNAL_NONE) {
 8003f56:	687b      	ldr	r3, [r7, #4]
 8003f58:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003f5a:	2b00      	cmp	r3, #0
 8003f5c:	d02c      	beq.n	8003fb8 <OsTaskProcSignal+0x80>
        goto EXIT;
    }

    if (runTask->signal & SIGNAL_KILL) {
 8003f5e:	687b      	ldr	r3, [r7, #4]
 8003f60:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003f62:	f003 0301 	and.w	r3, r3, #1
 8003f66:	2b00      	cmp	r3, #0
 8003f68:	d014      	beq.n	8003f94 <OsTaskProcSignal+0x5c>
        /*
         * clear the signal, and do the task deletion. if the signaled task has been
         * scheduled out, then this deletion will wait until next run.
         */
        runTask->signal = SIGNAL_NONE;
 8003f6a:	687b      	ldr	r3, [r7, #4]
 8003f6c:	2200      	movs	r2, #0
 8003f6e:	671a      	str	r2, [r3, #112]	; 0x70
        ret = LOS_TaskDelete(runTask->taskId);
 8003f70:	687b      	ldr	r3, [r7, #4]
 8003f72:	695b      	ldr	r3, [r3, #20]
 8003f74:	4618      	mov	r0, r3
 8003f76:	f7ff fcf7 	bl	8003968 <LOS_TaskDelete>
 8003f7a:	60b8      	str	r0, [r7, #8]
        if (ret) {
 8003f7c:	68bb      	ldr	r3, [r7, #8]
 8003f7e:	2b00      	cmp	r3, #0
 8003f80:	d01d      	beq.n	8003fbe <OsTaskProcSignal+0x86>
            PRINT_ERR("%s: tsk del fail err:0x%x\n", __FUNCTION__, ret);
 8003f82:	482d      	ldr	r0, [pc, #180]	; (8004038 <OsTaskProcSignal+0x100>)
 8003f84:	f000 fba2 	bl	80046cc <dprintf>
 8003f88:	68ba      	ldr	r2, [r7, #8]
 8003f8a:	492c      	ldr	r1, [pc, #176]	; (800403c <OsTaskProcSignal+0x104>)
 8003f8c:	482c      	ldr	r0, [pc, #176]	; (8004040 <OsTaskProcSignal+0x108>)
 8003f8e:	f000 fb9d 	bl	80046cc <dprintf>
 8003f92:	e014      	b.n	8003fbe <OsTaskProcSignal+0x86>
        }
    } else if (runTask->signal & SIGNAL_SUSPEND) {
 8003f94:	687b      	ldr	r3, [r7, #4]
 8003f96:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003f98:	f003 0302 	and.w	r3, r3, #2
 8003f9c:	2b00      	cmp	r3, #0
 8003f9e:	d00d      	beq.n	8003fbc <OsTaskProcSignal+0x84>
        runTask->signal &= ~SIGNAL_SUSPEND;
 8003fa0:	687b      	ldr	r3, [r7, #4]
 8003fa2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003fa4:	f023 0202 	bic.w	r2, r3, #2
 8003fa8:	687b      	ldr	r3, [r7, #4]
 8003faa:	671a      	str	r2, [r3, #112]	; 0x70

        /* suspend killed task may fail, ignore the result */
        (VOID)LOS_TaskSuspend(runTask->taskId);
 8003fac:	687b      	ldr	r3, [r7, #4]
 8003fae:	695b      	ldr	r3, [r3, #20]
 8003fb0:	4618      	mov	r0, r3
 8003fb2:	f7ff fdbd 	bl	8003b30 <LOS_TaskSuspend>
 8003fb6:	e002      	b.n	8003fbe <OsTaskProcSignal+0x86>
        goto EXIT;
 8003fb8:	bf00      	nop
 8003fba:	e000      	b.n	8003fbe <OsTaskProcSignal+0x86>
        /* pri-queue has updated, notify the target cpu */
        LOS_MpSchedule((UINT32)runTask->cpuAffiMask);
#endif
    }

EXIT:
 8003fbc:	bf00      	nop
    /* check if needs to schedule */
    percpu = OsPercpuGet();
 8003fbe:	f7fe fcc9 	bl	8002954 <OsPercpuGet>
 8003fc2:	6038      	str	r0, [r7, #0]

    LOS_TRACE(TASK_SIGNAL, runTask->taskId, runTask->signal, percpu->schedFlag);
 8003fc4:	2300      	movs	r3, #0
 8003fc6:	613b      	str	r3, [r7, #16]
 8003fc8:	2301      	movs	r3, #1
 8003fca:	60fb      	str	r3, [r7, #12]
 8003fcc:	68fb      	ldr	r3, [r7, #12]
 8003fce:	2b01      	cmp	r3, #1
 8003fd0:	d915      	bls.n	8003ffe <OsTaskProcSignal+0xc6>
 8003fd2:	4b1c      	ldr	r3, [pc, #112]	; (8004044 <OsTaskProcSignal+0x10c>)
 8003fd4:	681b      	ldr	r3, [r3, #0]
 8003fd6:	2b00      	cmp	r3, #0
 8003fd8:	d011      	beq.n	8003ffe <OsTaskProcSignal+0xc6>
 8003fda:	4b1a      	ldr	r3, [pc, #104]	; (8004044 <OsTaskProcSignal+0x10c>)
 8003fdc:	681c      	ldr	r4, [r3, #0]
 8003fde:	6979      	ldr	r1, [r7, #20]
 8003fe0:	68fb      	ldr	r3, [r7, #12]
 8003fe2:	2b02      	cmp	r3, #2
 8003fe4:	d904      	bls.n	8003ff0 <OsTaskProcSignal+0xb8>
 8003fe6:	f107 0310 	add.w	r3, r7, #16
 8003fea:	f103 0208 	add.w	r2, r3, #8
 8003fee:	e000      	b.n	8003ff2 <OsTaskProcSignal+0xba>
 8003ff0:	2200      	movs	r2, #0
 8003ff2:	68fb      	ldr	r3, [r7, #12]
 8003ff4:	b29b      	uxth	r3, r3
 8003ff6:	3b02      	subs	r3, #2
 8003ff8:	b29b      	uxth	r3, r3
 8003ffa:	2046      	movs	r0, #70	; 0x46
 8003ffc:	47a0      	blx	r4

    if (OsPreemptable() && (percpu->schedFlag == INT_PEND_RESCH)) {
 8003ffe:	f7fe fcb9 	bl	8002974 <OsPreemptable>
 8004002:	4603      	mov	r3, r0
 8004004:	2b00      	cmp	r3, #0
 8004006:	d008      	beq.n	800401a <OsTaskProcSignal+0xe2>
 8004008:	683b      	ldr	r3, [r7, #0]
 800400a:	6a1b      	ldr	r3, [r3, #32]
 800400c:	2b01      	cmp	r3, #1
 800400e:	d104      	bne.n	800401a <OsTaskProcSignal+0xe2>
        percpu->schedFlag = INT_NO_RESCH;
 8004010:	683b      	ldr	r3, [r7, #0]
 8004012:	2200      	movs	r2, #0
 8004014:	621a      	str	r2, [r3, #32]
        return INT_PEND_RESCH;
 8004016:	2301      	movs	r3, #1
 8004018:	e000      	b.n	800401c <OsTaskProcSignal+0xe4>
    }

    return INT_NO_RESCH;
 800401a:	2300      	movs	r3, #0
}
 800401c:	4a05      	ldr	r2, [pc, #20]	; (8004034 <OsTaskProcSignal+0xfc>)
 800401e:	6811      	ldr	r1, [r2, #0]
 8004020:	697a      	ldr	r2, [r7, #20]
 8004022:	4051      	eors	r1, r2
 8004024:	d001      	beq.n	800402a <OsTaskProcSignal+0xf2>
 8004026:	f000 f9df 	bl	80043e8 <__stack_chk_fail>
 800402a:	4618      	mov	r0, r3
 800402c:	371c      	adds	r7, #28
 800402e:	46bd      	mov	sp, r7
 8004030:	bd90      	pop	{r4, r7, pc}
 8004032:	bf00      	nop
 8004034:	08020170 	.word	0x08020170
 8004038:	08020038 	.word	0x08020038
 800403c:	08023308 	.word	0x08023308
 8004040:	08020154 	.word	0x08020154
 8004044:	2000075c 	.word	0x2000075c

08004048 <ArchCurrCpuid>:
{
 8004048:	b480      	push	{r7}
 800404a:	af00      	add	r7, sp, #0
    return 0;
 800404c:	2300      	movs	r3, #0
}
 800404e:	4618      	mov	r0, r3
 8004050:	46bd      	mov	sp, r7
 8004052:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004056:	4770      	bx	lr

08004058 <LOS_IntLock>:
{
 8004058:	b580      	push	{r7, lr}
 800405a:	af00      	add	r7, sp, #0
    return ArchIntLock();
 800405c:	f7fc fe34 	bl	8000cc8 <ArchIntLock>
 8004060:	4603      	mov	r3, r0
}
 8004062:	4618      	mov	r0, r3
 8004064:	bd80      	pop	{r7, pc}

08004066 <LOS_IntRestore>:
{
 8004066:	b580      	push	{r7, lr}
 8004068:	b082      	sub	sp, #8
 800406a:	af00      	add	r7, sp, #0
 800406c:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800406e:	6878      	ldr	r0, [r7, #4]
 8004070:	f7fc fe32 	bl	8000cd8 <ArchIntRestore>
}
 8004074:	bf00      	nop
 8004076:	3708      	adds	r7, #8
 8004078:	46bd      	mov	sp, r7
 800407a:	bd80      	pop	{r7, pc}

0800407c <LOS_SpinLockSave>:
{
 800407c:	b580      	push	{r7, lr}
 800407e:	b082      	sub	sp, #8
 8004080:	af00      	add	r7, sp, #0
 8004082:	6078      	str	r0, [r7, #4]
 8004084:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8004086:	f7ff ffe7 	bl	8004058 <LOS_IntLock>
 800408a:	4602      	mov	r2, r0
 800408c:	683b      	ldr	r3, [r7, #0]
 800408e:	601a      	str	r2, [r3, #0]
}
 8004090:	bf00      	nop
 8004092:	3708      	adds	r7, #8
 8004094:	46bd      	mov	sp, r7
 8004096:	bd80      	pop	{r7, pc}

08004098 <LOS_SpinUnlockRestore>:
{
 8004098:	b580      	push	{r7, lr}
 800409a:	b082      	sub	sp, #8
 800409c:	af00      	add	r7, sp, #0
 800409e:	6078      	str	r0, [r7, #4]
 80040a0:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 80040a2:	6838      	ldr	r0, [r7, #0]
 80040a4:	f7ff ffdf 	bl	8004066 <LOS_IntRestore>
}
 80040a8:	bf00      	nop
 80040aa:	3708      	adds	r7, #8
 80040ac:	46bd      	mov	sp, r7
 80040ae:	bd80      	pop	{r7, pc}

080040b0 <OsTickHandler>:

/*
 * Description : Tick interruption handler
 */
LITE_OS_SEC_TEXT VOID OsTickHandler(VOID)
{
 80040b0:	b5b0      	push	{r4, r5, r7, lr}
 80040b2:	b082      	sub	sp, #8
 80040b4:	af00      	add	r7, sp, #0
 80040b6:	4b1c      	ldr	r3, [pc, #112]	; (8004128 <OsTickHandler+0x78>)
 80040b8:	681b      	ldr	r3, [r3, #0]
 80040ba:	607b      	str	r3, [r7, #4]
 80040bc:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    TICK_LOCK(intSave);
 80040c0:	463b      	mov	r3, r7
 80040c2:	4619      	mov	r1, r3
 80040c4:	4819      	ldr	r0, [pc, #100]	; (800412c <OsTickHandler+0x7c>)
 80040c6:	f7ff ffd9 	bl	800407c <LOS_SpinLockSave>
    g_tickCount[ArchCurrCpuid()]++;
 80040ca:	f7ff ffbd 	bl	8004048 <ArchCurrCpuid>
 80040ce:	4601      	mov	r1, r0
 80040d0:	4a17      	ldr	r2, [pc, #92]	; (8004130 <OsTickHandler+0x80>)
 80040d2:	00cb      	lsls	r3, r1, #3
 80040d4:	4413      	add	r3, r2
 80040d6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80040da:	1c54      	adds	r4, r2, #1
 80040dc:	f143 0500 	adc.w	r5, r3, #0
 80040e0:	4a13      	ldr	r2, [pc, #76]	; (8004130 <OsTickHandler+0x80>)
 80040e2:	00cb      	lsls	r3, r1, #3
 80040e4:	4413      	add	r3, r2
 80040e6:	e9c3 4500 	strd	r4, r5, [r3]
    TICK_UNLOCK(intSave);
 80040ea:	683b      	ldr	r3, [r7, #0]
 80040ec:	4619      	mov	r1, r3
 80040ee:	480f      	ldr	r0, [pc, #60]	; (800412c <OsTickHandler+0x7c>)
 80040f0:	f7ff ffd2 	bl	8004098 <LOS_SpinUnlockRestore>

#ifdef LOSCFG_KERNEL_TICKLESS
    if (g_tickWakeupHook != NULL) {
 80040f4:	4b0f      	ldr	r3, [pc, #60]	; (8004134 <OsTickHandler+0x84>)
 80040f6:	681b      	ldr	r3, [r3, #0]
 80040f8:	2b00      	cmp	r3, #0
 80040fa:	d004      	beq.n	8004106 <OsTickHandler+0x56>
        g_tickWakeupHook(LOS_TICK_INT_FLAG);
 80040fc:	4b0d      	ldr	r3, [pc, #52]	; (8004134 <OsTickHandler+0x84>)
 80040fe:	681b      	ldr	r3, [r3, #0]
 8004100:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 8004104:	4798      	blx	r3
    }
#endif

#ifdef LOSCFG_BASE_CORE_TIMESLICE
    OsTimesliceCheck();
 8004106:	f004 f92d 	bl	8008364 <OsTimesliceCheck>
#endif

    OsTaskScan(); /* task timeout scan */
 800410a:	f7fe fde5 	bl	8002cd8 <OsTaskScan>

#ifdef LOSCFG_BASE_CORE_SWTMR
    OsSwtmrScan();
 800410e:	f000 ff59 	bl	8004fc4 <OsSwtmrScan>
#endif
}
 8004112:	bf00      	nop
 8004114:	4b04      	ldr	r3, [pc, #16]	; (8004128 <OsTickHandler+0x78>)
 8004116:	681a      	ldr	r2, [r3, #0]
 8004118:	687b      	ldr	r3, [r7, #4]
 800411a:	405a      	eors	r2, r3
 800411c:	d001      	beq.n	8004122 <OsTickHandler+0x72>
 800411e:	f000 f963 	bl	80043e8 <__stack_chk_fail>
 8004122:	3708      	adds	r7, #8
 8004124:	46bd      	mov	sp, r7
 8004126:	bdb0      	pop	{r4, r5, r7, pc}
 8004128:	08020174 	.word	0x08020174
 800412c:	20000780 	.word	0x20000780
 8004130:	20000778 	.word	0x20000778
 8004134:	20000784 	.word	0x20000784

08004138 <OsTickInit>:

LITE_OS_SEC_TEXT_INIT UINT32 OsTickInit(UINT32 systemClock, UINT32 tickPerSecond)
{
 8004138:	b580      	push	{r7, lr}
 800413a:	b082      	sub	sp, #8
 800413c:	af00      	add	r7, sp, #0
 800413e:	6078      	str	r0, [r7, #4]
 8004140:	6039      	str	r1, [r7, #0]
    if ((systemClock == 0) ||
 8004142:	687b      	ldr	r3, [r7, #4]
 8004144:	2b00      	cmp	r3, #0
 8004146:	d006      	beq.n	8004156 <OsTickInit+0x1e>
 8004148:	683b      	ldr	r3, [r7, #0]
 800414a:	2b00      	cmp	r3, #0
 800414c:	d003      	beq.n	8004156 <OsTickInit+0x1e>
        (tickPerSecond == 0) ||
 800414e:	683a      	ldr	r2, [r7, #0]
 8004150:	687b      	ldr	r3, [r7, #4]
 8004152:	429a      	cmp	r2, r3
 8004154:	d901      	bls.n	800415a <OsTickInit+0x22>
        (tickPerSecond > systemClock)) {
        return LOS_ERRNO_TICK_CFG_INVALID;
 8004156:	4b04      	ldr	r3, [pc, #16]	; (8004168 <OsTickInit+0x30>)
 8004158:	e002      	b.n	8004160 <OsTickInit+0x28>
    }
    HalClockInit();
 800415a:	f00b fcdf 	bl	800fb1c <HalClockInit>

    return LOS_OK;
 800415e:	2300      	movs	r3, #0
}
 8004160:	4618      	mov	r0, r3
 8004162:	3708      	adds	r7, #8
 8004164:	46bd      	mov	sp, r7
 8004166:	bd80      	pop	{r7, pc}
 8004168:	02000400 	.word	0x02000400

0800416c <OsTickStart>:

LITE_OS_SEC_TEXT_INIT VOID OsTickStart(VOID)
{
 800416c:	b580      	push	{r7, lr}
 800416e:	af00      	add	r7, sp, #0
    HalClockStart();
 8004170:	f00b fcf8 	bl	800fb64 <HalClockStart>
}
 8004174:	bf00      	nop
 8004176:	bd80      	pop	{r7, pc}

08004178 <LOS_TickCountGet>:

LITE_OS_SEC_TEXT_MINOR UINT64 LOS_TickCountGet(VOID)
{
 8004178:	b580      	push	{r7, lr}
 800417a:	b086      	sub	sp, #24
 800417c:	af00      	add	r7, sp, #0
 800417e:	4b11      	ldr	r3, [pc, #68]	; (80041c4 <LOS_TickCountGet+0x4c>)
 8004180:	681b      	ldr	r3, [r3, #0]
 8004182:	617b      	str	r3, [r7, #20]
 8004184:	f04f 0300 	mov.w	r3, #0

    /*
     * use core0's tick as system's timeline,
     * the tick needs to be atomic.
     */
    TICK_LOCK(intSave);
 8004188:	1d3b      	adds	r3, r7, #4
 800418a:	4619      	mov	r1, r3
 800418c:	480e      	ldr	r0, [pc, #56]	; (80041c8 <LOS_TickCountGet+0x50>)
 800418e:	f7ff ff75 	bl	800407c <LOS_SpinLockSave>
    tick = g_tickCount[0];
 8004192:	4b0e      	ldr	r3, [pc, #56]	; (80041cc <LOS_TickCountGet+0x54>)
 8004194:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004198:	e9c7 2302 	strd	r2, r3, [r7, #8]
    TICK_UNLOCK(intSave);
 800419c:	687b      	ldr	r3, [r7, #4]
 800419e:	4619      	mov	r1, r3
 80041a0:	4809      	ldr	r0, [pc, #36]	; (80041c8 <LOS_TickCountGet+0x50>)
 80041a2:	f7ff ff79 	bl	8004098 <LOS_SpinUnlockRestore>

    return tick;
 80041a6:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
}
 80041aa:	4906      	ldr	r1, [pc, #24]	; (80041c4 <LOS_TickCountGet+0x4c>)
 80041ac:	6808      	ldr	r0, [r1, #0]
 80041ae:	6979      	ldr	r1, [r7, #20]
 80041b0:	4048      	eors	r0, r1
 80041b2:	d001      	beq.n	80041b8 <LOS_TickCountGet+0x40>
 80041b4:	f000 f918 	bl	80043e8 <__stack_chk_fail>
 80041b8:	4610      	mov	r0, r2
 80041ba:	4619      	mov	r1, r3
 80041bc:	3718      	adds	r7, #24
 80041be:	46bd      	mov	sp, r7
 80041c0:	bd80      	pop	{r7, pc}
 80041c2:	bf00      	nop
 80041c4:	08020178 	.word	0x08020178
 80041c8:	20000780 	.word	0x20000780
 80041cc:	20000778 	.word	0x20000778

080041d0 <LOS_GetCpuCycle>:
{
    return g_sysClock / KERNEL_TICK_PER_SECOND;
}

LITE_OS_SEC_TEXT_MINOR VOID LOS_GetCpuCycle(UINT32 *highCnt, UINT32 *lowCnt)
{
 80041d0:	b580      	push	{r7, lr}
 80041d2:	b084      	sub	sp, #16
 80041d4:	af00      	add	r7, sp, #0
 80041d6:	6078      	str	r0, [r7, #4]
 80041d8:	6039      	str	r1, [r7, #0]
    UINT64 cycle;

    if ((highCnt == NULL) || (lowCnt == NULL)) {
 80041da:	687b      	ldr	r3, [r7, #4]
 80041dc:	2b00      	cmp	r3, #0
 80041de:	d014      	beq.n	800420a <LOS_GetCpuCycle+0x3a>
 80041e0:	683b      	ldr	r3, [r7, #0]
 80041e2:	2b00      	cmp	r3, #0
 80041e4:	d011      	beq.n	800420a <LOS_GetCpuCycle+0x3a>
        return;
    }
    cycle = HalClockGetCycles();
 80041e6:	f00b fcf3 	bl	800fbd0 <HalClockGetCycles>
 80041ea:	e9c7 0102 	strd	r0, r1, [r7, #8]

    /* get the high 32 bits */
    *highCnt = (UINT32)(cycle >> 32);
 80041ee:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 80041f2:	f04f 0200 	mov.w	r2, #0
 80041f6:	f04f 0300 	mov.w	r3, #0
 80041fa:	000a      	movs	r2, r1
 80041fc:	2300      	movs	r3, #0
 80041fe:	687b      	ldr	r3, [r7, #4]
 8004200:	601a      	str	r2, [r3, #0]
    /* get the low 32 bits */
    *lowCnt = (UINT32)(cycle & 0xFFFFFFFFULL);
 8004202:	68ba      	ldr	r2, [r7, #8]
 8004204:	683b      	ldr	r3, [r7, #0]
 8004206:	601a      	str	r2, [r3, #0]
 8004208:	e000      	b.n	800420c <LOS_GetCpuCycle+0x3c>
        return;
 800420a:	bf00      	nop
}
 800420c:	3710      	adds	r7, #16
 800420e:	46bd      	mov	sp, r7
 8004210:	bd80      	pop	{r7, pc}
	...

08004214 <LOS_CurrNanosec>:

LITE_OS_SEC_TEXT_MINOR UINT64 LOS_CurrNanosec(VOID)
{
 8004214:	b5b0      	push	{r4, r5, r7, lr}
 8004216:	b082      	sub	sp, #8
 8004218:	af00      	add	r7, sp, #0
    UINT64 nanos;

    nanos = HalClockGetCycles() * (OS_SYS_NS_PER_SECOND / OS_SYS_NS_PER_MS) / (g_sysClock / OS_SYS_NS_PER_MS);
 800421a:	f00b fcd9 	bl	800fbd0 <HalClockGetCycles>
 800421e:	4602      	mov	r2, r0
 8004220:	460b      	mov	r3, r1
 8004222:	f04f 0400 	mov.w	r4, #0
 8004226:	f04f 0500 	mov.w	r5, #0
 800422a:	015d      	lsls	r5, r3, #5
 800422c:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 8004230:	0154      	lsls	r4, r2, #5
 8004232:	4622      	mov	r2, r4
 8004234:	462b      	mov	r3, r5
 8004236:	1a12      	subs	r2, r2, r0
 8004238:	eb63 0301 	sbc.w	r3, r3, r1
 800423c:	f04f 0400 	mov.w	r4, #0
 8004240:	f04f 0500 	mov.w	r5, #0
 8004244:	009d      	lsls	r5, r3, #2
 8004246:	ea45 7592 	orr.w	r5, r5, r2, lsr #30
 800424a:	0094      	lsls	r4, r2, #2
 800424c:	4622      	mov	r2, r4
 800424e:	462b      	mov	r3, r5
 8004250:	1812      	adds	r2, r2, r0
 8004252:	eb41 0303 	adc.w	r3, r1, r3
 8004256:	f04f 0000 	mov.w	r0, #0
 800425a:	f04f 0100 	mov.w	r1, #0
 800425e:	00d9      	lsls	r1, r3, #3
 8004260:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8004264:	00d0      	lsls	r0, r2, #3
 8004266:	4602      	mov	r2, r0
 8004268:	460b      	mov	r3, r1
 800426a:	4610      	mov	r0, r2
 800426c:	4619      	mov	r1, r3
 800426e:	4b0b      	ldr	r3, [pc, #44]	; (800429c <LOS_CurrNanosec+0x88>)
 8004270:	681b      	ldr	r3, [r3, #0]
 8004272:	4a0b      	ldr	r2, [pc, #44]	; (80042a0 <LOS_CurrNanosec+0x8c>)
 8004274:	fba2 2303 	umull	r2, r3, r2, r3
 8004278:	0c9b      	lsrs	r3, r3, #18
 800427a:	461a      	mov	r2, r3
 800427c:	f04f 0300 	mov.w	r3, #0
 8004280:	f7fc fb88 	bl	8000994 <__aeabi_uldivmod>
 8004284:	4602      	mov	r2, r0
 8004286:	460b      	mov	r3, r1
 8004288:	e9c7 2300 	strd	r2, r3, [r7]
    return nanos;
 800428c:	e9d7 2300 	ldrd	r2, r3, [r7]
}
 8004290:	4610      	mov	r0, r2
 8004292:	4619      	mov	r1, r3
 8004294:	3708      	adds	r7, #8
 8004296:	46bd      	mov	sp, r7
 8004298:	bdb0      	pop	{r4, r5, r7, pc}
 800429a:	bf00      	nop
 800429c:	200036e0 	.word	0x200036e0
 80042a0:	431bde83 	.word	0x431bde83

080042a4 <ArchHaltCpu>:
 */
extern VOID OsTaskBackTrace(UINT32 taskId);
VOID ArchExcInit(VOID);

STATIC INLINE VOID ArchHaltCpu(VOID)
{
 80042a4:	b480      	push	{r7}
 80042a6:	af00      	add	r7, sp, #0
    __asm__ __volatile__("swi 0");
 80042a8:	df00      	svc	0
}
 80042aa:	bf00      	nop
 80042ac:	46bd      	mov	sp, r7
 80042ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80042b2:	4770      	bx	lr

080042b4 <ArchCurrTaskGet>:
{
 80042b4:	b480      	push	{r7}
 80042b6:	af00      	add	r7, sp, #0
    return g_runTask;
 80042b8:	4b03      	ldr	r3, [pc, #12]	; (80042c8 <ArchCurrTaskGet+0x14>)
 80042ba:	681b      	ldr	r3, [r3, #0]
}
 80042bc:	4618      	mov	r0, r3
 80042be:	46bd      	mov	sp, r7
 80042c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80042c4:	4770      	bx	lr
 80042c6:	bf00      	nop
 80042c8:	200033bc 	.word	0x200033bc

080042cc <OsCurrTaskGet>:
{
 80042cc:	b580      	push	{r7, lr}
 80042ce:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 80042d0:	f7ff fff0 	bl	80042b4 <ArchCurrTaskGet>
 80042d4:	4603      	mov	r3, r0
}
 80042d6:	4618      	mov	r0, r3
 80042d8:	bd80      	pop	{r7, pc}
	...

080042dc <LOS_Panic>:
}

#endif

VOID LOS_Panic(const CHAR *fmt, ...)
{
 80042dc:	b40f      	push	{r0, r1, r2, r3}
 80042de:	b580      	push	{r7, lr}
 80042e0:	b084      	sub	sp, #16
 80042e2:	af00      	add	r7, sp, #0
 80042e4:	69bb      	ldr	r3, [r7, #24]
 80042e6:	607b      	str	r3, [r7, #4]
 80042e8:	4b0d      	ldr	r3, [pc, #52]	; (8004320 <LOS_Panic+0x44>)
 80042ea:	681b      	ldr	r3, [r3, #0]
 80042ec:	60fb      	str	r3, [r7, #12]
 80042ee:	f04f 0300 	mov.w	r3, #0
    va_list ap;
    va_start(ap, fmt);
 80042f2:	f107 031c 	add.w	r3, r7, #28
 80042f6:	60bb      	str	r3, [r7, #8]
    UartVprintf(fmt, ap);
 80042f8:	68b9      	ldr	r1, [r7, #8]
 80042fa:	6878      	ldr	r0, [r7, #4]
 80042fc:	f000 f9d8 	bl	80046b0 <UartVprintf>
    va_end(ap);
    ArchHaltCpu();
 8004300:	f7ff ffd0 	bl	80042a4 <ArchHaltCpu>
}
 8004304:	bf00      	nop
 8004306:	4b06      	ldr	r3, [pc, #24]	; (8004320 <LOS_Panic+0x44>)
 8004308:	681a      	ldr	r2, [r3, #0]
 800430a:	68fb      	ldr	r3, [r7, #12]
 800430c:	405a      	eors	r2, r3
 800430e:	d001      	beq.n	8004314 <LOS_Panic+0x38>
 8004310:	f000 f86a 	bl	80043e8 <__stack_chk_fail>
 8004314:	3710      	adds	r7, #16
 8004316:	46bd      	mov	sp, r7
 8004318:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800431c:	b004      	add	sp, #16
 800431e:	4770      	bx	lr
 8004320:	0802017c 	.word	0x0802017c

08004324 <LOS_BackTrace>:

VOID LOS_BackTrace(VOID)
{
 8004324:	b580      	push	{r7, lr}
 8004326:	b082      	sub	sp, #8
 8004328:	af00      	add	r7, sp, #0
#ifdef LOSCFG_BACKTRACE
    LosTaskCB *runTask = OsCurrTaskGet();
 800432a:	f7ff ffcf 	bl	80042cc <OsCurrTaskGet>
 800432e:	6078      	str	r0, [r7, #4]
    PrintExcInfo("runTask->taskName = %s\n""runTask->taskId = %u\n",
 8004330:	687b      	ldr	r3, [r7, #4]
 8004332:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8004334:	687b      	ldr	r3, [r7, #4]
 8004336:	695b      	ldr	r3, [r3, #20]
 8004338:	461a      	mov	r2, r3
 800433a:	4804      	ldr	r0, [pc, #16]	; (800434c <LOS_BackTrace+0x28>)
 800433c:	f000 f9ea 	bl	8004714 <PrintExcInfo>
        runTask->taskName, runTask->taskId);
    ArchBackTrace();
 8004340:	f011 fd6e 	bl	8015e20 <ArchBackTrace>
#endif
}
 8004344:	bf00      	nop
 8004346:	3708      	adds	r7, #8
 8004348:	46bd      	mov	sp, r7
 800434a:	bd80      	pop	{r7, pc}
 800434c:	08020180 	.word	0x08020180

08004350 <LOS_TaskBackTrace>:

VOID LOS_TaskBackTrace(UINT32 taskID)
{
 8004350:	b580      	push	{r7, lr}
 8004352:	b084      	sub	sp, #16
 8004354:	af00      	add	r7, sp, #0
 8004356:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_BACKTRACE
    LosTaskCB *taskCB = NULL;
 8004358:	2300      	movs	r3, #0
 800435a:	60fb      	str	r3, [r7, #12]

    if (taskID >= g_taskMaxNum) {
 800435c:	4b1c      	ldr	r3, [pc, #112]	; (80043d0 <LOS_TaskBackTrace+0x80>)
 800435e:	681b      	ldr	r3, [r3, #0]
 8004360:	687a      	ldr	r2, [r7, #4]
 8004362:	429a      	cmp	r2, r3
 8004364:	d306      	bcc.n	8004374 <LOS_TaskBackTrace+0x24>
        PRINT_ERR("\r\nTask PID is invalid!\n");
 8004366:	481b      	ldr	r0, [pc, #108]	; (80043d4 <LOS_TaskBackTrace+0x84>)
 8004368:	f000 f9b0 	bl	80046cc <dprintf>
 800436c:	481a      	ldr	r0, [pc, #104]	; (80043d8 <LOS_TaskBackTrace+0x88>)
 800436e:	f000 f9ad 	bl	80046cc <dprintf>
        return;
 8004372:	e02a      	b.n	80043ca <LOS_TaskBackTrace+0x7a>
    }
    taskCB = OS_TCB_FROM_TID(taskID);
 8004374:	4b19      	ldr	r3, [pc, #100]	; (80043dc <LOS_TaskBackTrace+0x8c>)
 8004376:	6819      	ldr	r1, [r3, #0]
 8004378:	687a      	ldr	r2, [r7, #4]
 800437a:	4613      	mov	r3, r2
 800437c:	009b      	lsls	r3, r3, #2
 800437e:	4413      	add	r3, r2
 8004380:	015b      	lsls	r3, r3, #5
 8004382:	440b      	add	r3, r1
 8004384:	60fb      	str	r3, [r7, #12]
    if ((taskCB->taskStatus & OS_TASK_STATUS_UNUSED) ||
 8004386:	68fb      	ldr	r3, [r7, #12]
 8004388:	889b      	ldrh	r3, [r3, #4]
 800438a:	f003 0301 	and.w	r3, r3, #1
 800438e:	2b00      	cmp	r3, #0
 8004390:	d107      	bne.n	80043a2 <LOS_TaskBackTrace+0x52>
        (taskCB->taskEntry == NULL) ||
 8004392:	68fb      	ldr	r3, [r7, #12]
 8004394:	699b      	ldr	r3, [r3, #24]
    if ((taskCB->taskStatus & OS_TASK_STATUS_UNUSED) ||
 8004396:	2b00      	cmp	r3, #0
 8004398:	d003      	beq.n	80043a2 <LOS_TaskBackTrace+0x52>
        (taskCB->taskName == NULL)) {
 800439a:	68fb      	ldr	r3, [r7, #12]
 800439c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
        (taskCB->taskEntry == NULL) ||
 800439e:	2b00      	cmp	r3, #0
 80043a0:	d106      	bne.n	80043b0 <LOS_TaskBackTrace+0x60>
        PRINT_ERR("\r\nThe task is not created!\n");
 80043a2:	480c      	ldr	r0, [pc, #48]	; (80043d4 <LOS_TaskBackTrace+0x84>)
 80043a4:	f000 f992 	bl	80046cc <dprintf>
 80043a8:	480d      	ldr	r0, [pc, #52]	; (80043e0 <LOS_TaskBackTrace+0x90>)
 80043aa:	f000 f98f 	bl	80046cc <dprintf>
        return;
 80043ae:	e00c      	b.n	80043ca <LOS_TaskBackTrace+0x7a>
    }
    PRINTK("TaskName = %s\n""TaskId = 0x%x\n",
 80043b0:	68fb      	ldr	r3, [r7, #12]
 80043b2:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80043b4:	68fb      	ldr	r3, [r7, #12]
 80043b6:	695b      	ldr	r3, [r3, #20]
 80043b8:	461a      	mov	r2, r3
 80043ba:	480a      	ldr	r0, [pc, #40]	; (80043e4 <LOS_TaskBackTrace+0x94>)
 80043bc:	f000 f986 	bl	80046cc <dprintf>
        taskCB->taskName, taskCB->taskId);
    ArchBackTraceWithSp(taskCB->stackPointer);
 80043c0:	68fb      	ldr	r3, [r7, #12]
 80043c2:	681b      	ldr	r3, [r3, #0]
 80043c4:	4618      	mov	r0, r3
 80043c6:	f011 fd3f 	bl	8015e48 <ArchBackTraceWithSp>
#else
    (VOID)taskID;
#endif
}
 80043ca:	3710      	adds	r7, #16
 80043cc:	46bd      	mov	sp, r7
 80043ce:	bd80      	pop	{r7, pc}
 80043d0:	200036d8 	.word	0x200036d8
 80043d4:	080201b0 	.word	0x080201b0
 80043d8:	080201b8 	.word	0x080201b8
 80043dc:	200036c4 	.word	0x200036c4
 80043e0:	080201d0 	.word	0x080201d0
 80043e4:	080201ec 	.word	0x080201ec

080043e8 <__stack_chk_fail>:

#ifdef __GNUC__
/* stack protector */
VOID __stack_chk_fail(VOID)
{
 80043e8:	b580      	push	{r7, lr}
 80043ea:	af00      	add	r7, sp, #0
 80043ec:	4673      	mov	r3, lr
    /* __builtin_return_address is a builtin function, building in gcc */
    LOS_Panic("stack-protector: Kernel stack is corrupted in: %p\n",
 80043ee:	4619      	mov	r1, r3
 80043f0:	4802      	ldr	r0, [pc, #8]	; (80043fc <__stack_chk_fail+0x14>)
 80043f2:	f7ff ff73 	bl	80042dc <LOS_Panic>
              __builtin_return_address(0));
}
 80043f6:	bf00      	nop
 80043f8:	bd80      	pop	{r7, pc}
 80043fa:	bf00      	nop
 80043fc:	0802020c 	.word	0x0802020c

08004400 <ErrorMsg>:
    CONSOLE_OUTPUT = 2,
    EXC_OUTPUT = 3
} OutputType;

STATIC VOID ErrorMsg(VOID)
{
 8004400:	b580      	push	{r7, lr}
 8004402:	b082      	sub	sp, #8
 8004404:	af00      	add	r7, sp, #0
    const CHAR *p = "Output illegal string! vsnprintf_s failed!\n";
 8004406:	4b07      	ldr	r3, [pc, #28]	; (8004424 <ErrorMsg+0x24>)
 8004408:	607b      	str	r3, [r7, #4]
    UartPuts(p, (UINT32)strlen(p), UART_WITH_LOCK);
 800440a:	6878      	ldr	r0, [r7, #4]
 800440c:	f00a fb3d 	bl	800ea8a <strlen>
 8004410:	4603      	mov	r3, r0
 8004412:	2201      	movs	r2, #1
 8004414:	4619      	mov	r1, r3
 8004416:	6878      	ldr	r0, [r7, #4]
 8004418:	f00b fd9e 	bl	800ff58 <UartPuts>
}
 800441c:	bf00      	nop
 800441e:	3708      	adds	r7, #8
 8004420:	46bd      	mov	sp, r7
 8004422:	bd80      	pop	{r7, pc}
 8004424:	08020240 	.word	0x08020240

08004428 <UartOutput>:

STATIC VOID UartOutput(const CHAR *str, UINT32 len, BOOL isLock)
{
 8004428:	b580      	push	{r7, lr}
 800442a:	b084      	sub	sp, #16
 800442c:	af00      	add	r7, sp, #0
 800442e:	60f8      	str	r0, [r7, #12]
 8004430:	60b9      	str	r1, [r7, #8]
 8004432:	607a      	str	r2, [r7, #4]
#ifdef LOSCFG_SHELL_DMESG
    if (!OsCheckUartLock()) {
 8004434:	f00c f87e 	bl	8010534 <OsCheckUartLock>
 8004438:	4603      	mov	r3, r0
 800443a:	2b00      	cmp	r3, #0
 800443c:	d104      	bne.n	8004448 <UartOutput+0x20>
        UartPuts(str, len, isLock);
 800443e:	687a      	ldr	r2, [r7, #4]
 8004440:	68b9      	ldr	r1, [r7, #8]
 8004442:	68f8      	ldr	r0, [r7, #12]
 8004444:	f00b fd88 	bl	800ff58 <UartPuts>
    }
    if (isLock != UART_WITHOUT_LOCK) {
 8004448:	687b      	ldr	r3, [r7, #4]
 800444a:	2b00      	cmp	r3, #0
 800444c:	d003      	beq.n	8004456 <UartOutput+0x2e>
        (VOID)OsLogMemcpyRecord(str, len);
 800444e:	68b9      	ldr	r1, [r7, #8]
 8004450:	68f8      	ldr	r0, [r7, #12]
 8004452:	f00c fabb 	bl	80109cc <OsLogMemcpyRecord>
    }
#else
    UartPuts(str, len, isLock);
#endif
}
 8004456:	bf00      	nop
 8004458:	3710      	adds	r7, #16
 800445a:	46bd      	mov	sp, r7
 800445c:	bd80      	pop	{r7, pc}

0800445e <OutputControl>:

STATIC VOID OutputControl(const CHAR *str, UINT32 len, OutputType type)
{
 800445e:	b580      	push	{r7, lr}
 8004460:	b084      	sub	sp, #16
 8004462:	af00      	add	r7, sp, #0
 8004464:	60f8      	str	r0, [r7, #12]
 8004466:	60b9      	str	r1, [r7, #8]
 8004468:	607a      	str	r2, [r7, #4]
    switch (type) {
 800446a:	687b      	ldr	r3, [r7, #4]
 800446c:	2b02      	cmp	r3, #2
 800446e:	d803      	bhi.n	8004478 <OutputControl+0x1a>
 8004470:	687b      	ldr	r3, [r7, #4]
 8004472:	2b00      	cmp	r3, #0
 8004474:	d104      	bne.n	8004480 <OutputControl+0x22>
            break;
        case EXC_OUTPUT:
            UartOutput(str, len, UART_WITHOUT_LOCK);
            break;
        default:
            break;
 8004476:	e00f      	b.n	8004498 <OutputControl+0x3a>
    switch (type) {
 8004478:	687b      	ldr	r3, [r7, #4]
 800447a:	2b03      	cmp	r3, #3
 800447c:	d006      	beq.n	800448c <OutputControl+0x2e>
            break;
 800447e:	e00b      	b.n	8004498 <OutputControl+0x3a>
            UartOutput(str, len, UART_WITH_LOCK);
 8004480:	2201      	movs	r2, #1
 8004482:	68b9      	ldr	r1, [r7, #8]
 8004484:	68f8      	ldr	r0, [r7, #12]
 8004486:	f7ff ffcf 	bl	8004428 <UartOutput>
            break;
 800448a:	e005      	b.n	8004498 <OutputControl+0x3a>
            UartOutput(str, len, UART_WITHOUT_LOCK);
 800448c:	2200      	movs	r2, #0
 800448e:	68b9      	ldr	r1, [r7, #8]
 8004490:	68f8      	ldr	r0, [r7, #12]
 8004492:	f7ff ffc9 	bl	8004428 <UartOutput>
            break;
 8004496:	bf00      	nop
    }
    return;
 8004498:	bf00      	nop
}
 800449a:	3710      	adds	r7, #16
 800449c:	46bd      	mov	sp, r7
 800449e:	bd80      	pop	{r7, pc}

080044a0 <OsVprintfFree>:

STATIC VOID OsVprintfFree(CHAR *buf, UINT32 bufLen)
{
 80044a0:	b580      	push	{r7, lr}
 80044a2:	b082      	sub	sp, #8
 80044a4:	af00      	add	r7, sp, #0
 80044a6:	6078      	str	r0, [r7, #4]
 80044a8:	6039      	str	r1, [r7, #0]
    if (bufLen != SIZEBUF) {
 80044aa:	683b      	ldr	r3, [r7, #0]
 80044ac:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80044b0:	d005      	beq.n	80044be <OsVprintfFree+0x1e>
        (VOID)LOS_MemFree(m_aucSysMem0, buf);
 80044b2:	4b05      	ldr	r3, [pc, #20]	; (80044c8 <OsVprintfFree+0x28>)
 80044b4:	681b      	ldr	r3, [r3, #0]
 80044b6:	6879      	ldr	r1, [r7, #4]
 80044b8:	4618      	mov	r0, r3
 80044ba:	f004 fb2d 	bl	8008b18 <LOS_MemFree>
    }
}
 80044be:	bf00      	nop
 80044c0:	3708      	adds	r7, #8
 80044c2:	46bd      	mov	sp, r7
 80044c4:	bd80      	pop	{r7, pc}
 80044c6:	bf00      	nop
 80044c8:	200021b4 	.word	0x200021b4

080044cc <OsVprintf>:

STATIC VOID OsVprintf(const CHAR *fmt, va_list ap, OutputType type)
{
 80044cc:	b5b0      	push	{r4, r5, r7, lr}
 80044ce:	b0cc      	sub	sp, #304	; 0x130
 80044d0:	af02      	add	r7, sp, #8
 80044d2:	f107 030c 	add.w	r3, r7, #12
 80044d6:	6018      	str	r0, [r3, #0]
 80044d8:	f107 0308 	add.w	r3, r7, #8
 80044dc:	6019      	str	r1, [r3, #0]
 80044de:	1d3b      	adds	r3, r7, #4
 80044e0:	601a      	str	r2, [r3, #0]
 80044e2:	4b6f      	ldr	r3, [pc, #444]	; (80046a0 <OsVprintf+0x1d4>)
 80044e4:	681b      	ldr	r3, [r3, #0]
 80044e6:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 80044ea:	f04f 0300 	mov.w	r3, #0
    INT32 len;
    const CHAR *errMsgMalloc = "OsVprintf, malloc failed!\n";
 80044ee:	f107 031c 	add.w	r3, r7, #28
 80044f2:	4a6c      	ldr	r2, [pc, #432]	; (80046a4 <OsVprintf+0x1d8>)
 80044f4:	601a      	str	r2, [r3, #0]
    const CHAR *errMsgLen = "OsVprintf, length overflow!\n";
 80044f6:	f107 0320 	add.w	r3, r7, #32
 80044fa:	4a6b      	ldr	r2, [pc, #428]	; (80046a8 <OsVprintf+0x1dc>)
 80044fc:	601a      	str	r2, [r3, #0]
    CHAR aBuf[SIZEBUF] = {0};
 80044fe:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8004502:	2200      	movs	r2, #0
 8004504:	601a      	str	r2, [r3, #0]
 8004506:	3304      	adds	r3, #4
 8004508:	22fc      	movs	r2, #252	; 0xfc
 800450a:	2100      	movs	r1, #0
 800450c:	4618      	mov	r0, r3
 800450e:	f00a f999 	bl	800e844 <memset>
    CHAR *bBuf = NULL;
 8004512:	f107 0314 	add.w	r3, r7, #20
 8004516:	2200      	movs	r2, #0
 8004518:	601a      	str	r2, [r3, #0]
    UINT32 bufLen = SIZEBUF;
 800451a:	f107 0318 	add.w	r3, r7, #24
 800451e:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004522:	601a      	str	r2, [r3, #0]

    bBuf = aBuf;
 8004524:	f107 0314 	add.w	r3, r7, #20
 8004528:	f107 0224 	add.w	r2, r7, #36	; 0x24
 800452c:	601a      	str	r2, [r3, #0]
    len = vsnprintf_s(bBuf, bufLen, bufLen - 1, fmt, ap);
 800452e:	f107 0318 	add.w	r3, r7, #24
 8004532:	681b      	ldr	r3, [r3, #0]
 8004534:	1e5d      	subs	r5, r3, #1
 8004536:	f107 0410 	add.w	r4, r7, #16
 800453a:	f107 030c 	add.w	r3, r7, #12
 800453e:	f107 0118 	add.w	r1, r7, #24
 8004542:	f107 0014 	add.w	r0, r7, #20
 8004546:	f107 0208 	add.w	r2, r7, #8
 800454a:	6812      	ldr	r2, [r2, #0]
 800454c:	9200      	str	r2, [sp, #0]
 800454e:	681b      	ldr	r3, [r3, #0]
 8004550:	462a      	mov	r2, r5
 8004552:	6809      	ldr	r1, [r1, #0]
 8004554:	6800      	ldr	r0, [r0, #0]
 8004556:	f011 fdce 	bl	80160f6 <vsnprintf_s>
 800455a:	6020      	str	r0, [r4, #0]
    if ((len == -1) && (*bBuf == '\0')) {
 800455c:	f107 0310 	add.w	r3, r7, #16
 8004560:	681b      	ldr	r3, [r3, #0]
 8004562:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004566:	d16e      	bne.n	8004646 <OsVprintf+0x17a>
 8004568:	f107 0314 	add.w	r3, r7, #20
 800456c:	681b      	ldr	r3, [r3, #0]
 800456e:	781b      	ldrb	r3, [r3, #0]
 8004570:	2b00      	cmp	r3, #0
 8004572:	d168      	bne.n	8004646 <OsVprintf+0x17a>
        /* parameter is illegal or some features in fmt dont support */
        ErrorMsg();
 8004574:	f7ff ff44 	bl	8004400 <ErrorMsg>
        return;
 8004578:	e086      	b.n	8004688 <OsVprintf+0x1bc>
    }

    while (len == -1) {
        /* bBuf is not enough */
        OsVprintfFree(bBuf, bufLen);
 800457a:	f107 0218 	add.w	r2, r7, #24
 800457e:	f107 0314 	add.w	r3, r7, #20
 8004582:	6811      	ldr	r1, [r2, #0]
 8004584:	6818      	ldr	r0, [r3, #0]
 8004586:	f7ff ff8b 	bl	80044a0 <OsVprintfFree>

        bufLen = bufLen << 1;
 800458a:	f107 0318 	add.w	r3, r7, #24
 800458e:	f107 0218 	add.w	r2, r7, #24
 8004592:	6812      	ldr	r2, [r2, #0]
 8004594:	0052      	lsls	r2, r2, #1
 8004596:	601a      	str	r2, [r3, #0]
        if ((INT32)bufLen <= 0) {
 8004598:	f107 0318 	add.w	r3, r7, #24
 800459c:	681b      	ldr	r3, [r3, #0]
 800459e:	2b00      	cmp	r3, #0
 80045a0:	dc0c      	bgt.n	80045bc <OsVprintf+0xf0>
            UartPuts(errMsgLen, (UINT32)strlen(errMsgLen), UART_WITH_LOCK);
 80045a2:	f107 0320 	add.w	r3, r7, #32
 80045a6:	6818      	ldr	r0, [r3, #0]
 80045a8:	f00a fa6f 	bl	800ea8a <strlen>
 80045ac:	4601      	mov	r1, r0
 80045ae:	f107 0320 	add.w	r3, r7, #32
 80045b2:	2201      	movs	r2, #1
 80045b4:	6818      	ldr	r0, [r3, #0]
 80045b6:	f00b fccf 	bl	800ff58 <UartPuts>
            return;
 80045ba:	e065      	b.n	8004688 <OsVprintf+0x1bc>
        }
        bBuf = (CHAR *)LOS_MemAlloc(m_aucSysMem0, bufLen);
 80045bc:	4b3b      	ldr	r3, [pc, #236]	; (80046ac <OsVprintf+0x1e0>)
 80045be:	681a      	ldr	r2, [r3, #0]
 80045c0:	f107 0414 	add.w	r4, r7, #20
 80045c4:	f107 0318 	add.w	r3, r7, #24
 80045c8:	6819      	ldr	r1, [r3, #0]
 80045ca:	4610      	mov	r0, r2
 80045cc:	f004 f9ec 	bl	80089a8 <LOS_MemAlloc>
 80045d0:	6020      	str	r0, [r4, #0]
        if (bBuf == NULL) {
 80045d2:	f107 0314 	add.w	r3, r7, #20
 80045d6:	681b      	ldr	r3, [r3, #0]
 80045d8:	2b00      	cmp	r3, #0
 80045da:	d10c      	bne.n	80045f6 <OsVprintf+0x12a>
            UartPuts(errMsgMalloc, (UINT32)strlen(errMsgMalloc), UART_WITH_LOCK);
 80045dc:	f107 031c 	add.w	r3, r7, #28
 80045e0:	6818      	ldr	r0, [r3, #0]
 80045e2:	f00a fa52 	bl	800ea8a <strlen>
 80045e6:	4601      	mov	r1, r0
 80045e8:	f107 031c 	add.w	r3, r7, #28
 80045ec:	2201      	movs	r2, #1
 80045ee:	6818      	ldr	r0, [r3, #0]
 80045f0:	f00b fcb2 	bl	800ff58 <UartPuts>
            return;
 80045f4:	e048      	b.n	8004688 <OsVprintf+0x1bc>
        }
        len = vsnprintf_s(bBuf, bufLen, bufLen - 1, fmt, ap);
 80045f6:	f107 0318 	add.w	r3, r7, #24
 80045fa:	681b      	ldr	r3, [r3, #0]
 80045fc:	1e5d      	subs	r5, r3, #1
 80045fe:	f107 0410 	add.w	r4, r7, #16
 8004602:	f107 030c 	add.w	r3, r7, #12
 8004606:	f107 0118 	add.w	r1, r7, #24
 800460a:	f107 0014 	add.w	r0, r7, #20
 800460e:	f107 0208 	add.w	r2, r7, #8
 8004612:	6812      	ldr	r2, [r2, #0]
 8004614:	9200      	str	r2, [sp, #0]
 8004616:	681b      	ldr	r3, [r3, #0]
 8004618:	462a      	mov	r2, r5
 800461a:	6809      	ldr	r1, [r1, #0]
 800461c:	6800      	ldr	r0, [r0, #0]
 800461e:	f011 fd6a 	bl	80160f6 <vsnprintf_s>
 8004622:	6020      	str	r0, [r4, #0]
        if (*bBuf == '\0') {
 8004624:	f107 0314 	add.w	r3, r7, #20
 8004628:	681b      	ldr	r3, [r3, #0]
 800462a:	781b      	ldrb	r3, [r3, #0]
 800462c:	2b00      	cmp	r3, #0
 800462e:	d10a      	bne.n	8004646 <OsVprintf+0x17a>
            /* parameter is illegal or some features in fmt dont support */
            (VOID)LOS_MemFree(m_aucSysMem0, bBuf);
 8004630:	4b1e      	ldr	r3, [pc, #120]	; (80046ac <OsVprintf+0x1e0>)
 8004632:	681a      	ldr	r2, [r3, #0]
 8004634:	f107 0314 	add.w	r3, r7, #20
 8004638:	6819      	ldr	r1, [r3, #0]
 800463a:	4610      	mov	r0, r2
 800463c:	f004 fa6c 	bl	8008b18 <LOS_MemFree>
            ErrorMsg();
 8004640:	f7ff fede 	bl	8004400 <ErrorMsg>
            return;
 8004644:	e020      	b.n	8004688 <OsVprintf+0x1bc>
    while (len == -1) {
 8004646:	f107 0310 	add.w	r3, r7, #16
 800464a:	681b      	ldr	r3, [r3, #0]
 800464c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004650:	d093      	beq.n	800457a <OsVprintf+0xae>
        }
    }
    *(bBuf + len) = '\0';
 8004652:	f107 0310 	add.w	r3, r7, #16
 8004656:	681b      	ldr	r3, [r3, #0]
 8004658:	f107 0214 	add.w	r2, r7, #20
 800465c:	6812      	ldr	r2, [r2, #0]
 800465e:	4413      	add	r3, r2
 8004660:	2200      	movs	r2, #0
 8004662:	701a      	strb	r2, [r3, #0]
    OutputControl(bBuf, len, type);
 8004664:	f107 0310 	add.w	r3, r7, #16
 8004668:	6819      	ldr	r1, [r3, #0]
 800466a:	1d3a      	adds	r2, r7, #4
 800466c:	f107 0314 	add.w	r3, r7, #20
 8004670:	6812      	ldr	r2, [r2, #0]
 8004672:	6818      	ldr	r0, [r3, #0]
 8004674:	f7ff fef3 	bl	800445e <OutputControl>
    OsVprintfFree(bBuf, bufLen);
 8004678:	f107 0218 	add.w	r2, r7, #24
 800467c:	f107 0314 	add.w	r3, r7, #20
 8004680:	6811      	ldr	r1, [r2, #0]
 8004682:	6818      	ldr	r0, [r3, #0]
 8004684:	f7ff ff0c 	bl	80044a0 <OsVprintfFree>
}
 8004688:	4b05      	ldr	r3, [pc, #20]	; (80046a0 <OsVprintf+0x1d4>)
 800468a:	681a      	ldr	r2, [r3, #0]
 800468c:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8004690:	405a      	eors	r2, r3
 8004692:	d001      	beq.n	8004698 <OsVprintf+0x1cc>
 8004694:	f7ff fea8 	bl	80043e8 <__stack_chk_fail>
 8004698:	f507 7794 	add.w	r7, r7, #296	; 0x128
 800469c:	46bd      	mov	sp, r7
 800469e:	bdb0      	pop	{r4, r5, r7, pc}
 80046a0:	080202a8 	.word	0x080202a8
 80046a4:	0802026c 	.word	0x0802026c
 80046a8:	08020288 	.word	0x08020288
 80046ac:	200021b4 	.word	0x200021b4

080046b0 <UartVprintf>:

VOID UartVprintf(const CHAR *fmt, va_list ap)
{
 80046b0:	b580      	push	{r7, lr}
 80046b2:	b082      	sub	sp, #8
 80046b4:	af00      	add	r7, sp, #0
 80046b6:	6078      	str	r0, [r7, #4]
 80046b8:	6039      	str	r1, [r7, #0]
    OsVprintf(fmt, ap, UART_OUTPUT);
 80046ba:	2201      	movs	r2, #1
 80046bc:	6839      	ldr	r1, [r7, #0]
 80046be:	6878      	ldr	r0, [r7, #4]
 80046c0:	f7ff ff04 	bl	80044cc <OsVprintf>
}
 80046c4:	bf00      	nop
 80046c6:	3708      	adds	r7, #8
 80046c8:	46bd      	mov	sp, r7
 80046ca:	bd80      	pop	{r7, pc}

080046cc <dprintf>:
    OsVprintf(fmt, ap, UART_OUTPUT);
    va_end(ap);
}

__attribute__ ((noinline)) VOID dprintf(const CHAR *fmt, ...)
{
 80046cc:	b40f      	push	{r0, r1, r2, r3}
 80046ce:	b580      	push	{r7, lr}
 80046d0:	b084      	sub	sp, #16
 80046d2:	af00      	add	r7, sp, #0
 80046d4:	69bb      	ldr	r3, [r7, #24]
 80046d6:	607b      	str	r3, [r7, #4]
 80046d8:	4b0d      	ldr	r3, [pc, #52]	; (8004710 <dprintf+0x44>)
 80046da:	681b      	ldr	r3, [r3, #0]
 80046dc:	60fb      	str	r3, [r7, #12]
 80046de:	f04f 0300 	mov.w	r3, #0
    va_list ap;
    va_start(ap, fmt);
 80046e2:	f107 031c 	add.w	r3, r7, #28
 80046e6:	60bb      	str	r3, [r7, #8]
    OsVprintf(fmt, ap, CONSOLE_OUTPUT);
 80046e8:	2202      	movs	r2, #2
 80046ea:	68b9      	ldr	r1, [r7, #8]
 80046ec:	6878      	ldr	r0, [r7, #4]
 80046ee:	f7ff feed 	bl	80044cc <OsVprintf>
    va_end(ap);
}
 80046f2:	bf00      	nop
 80046f4:	4b06      	ldr	r3, [pc, #24]	; (8004710 <dprintf+0x44>)
 80046f6:	681a      	ldr	r2, [r3, #0]
 80046f8:	68fb      	ldr	r3, [r7, #12]
 80046fa:	405a      	eors	r2, r3
 80046fc:	d001      	beq.n	8004702 <dprintf+0x36>
 80046fe:	f7ff fe73 	bl	80043e8 <__stack_chk_fail>
 8004702:	3710      	adds	r7, #16
 8004704:	46bd      	mov	sp, r7
 8004706:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800470a:	b004      	add	sp, #16
 800470c:	4770      	bx	lr
 800470e:	bf00      	nop
 8004710:	080202b0 	.word	0x080202b0

08004714 <PrintExcInfo>:
    OsVprintf(fmt, ap, EXC_OUTPUT);
    va_end(ap);
}

VOID PrintExcInfo(const CHAR *fmt, ...)
{
 8004714:	b40f      	push	{r0, r1, r2, r3}
 8004716:	b580      	push	{r7, lr}
 8004718:	b084      	sub	sp, #16
 800471a:	af00      	add	r7, sp, #0
 800471c:	69bb      	ldr	r3, [r7, #24]
 800471e:	607b      	str	r3, [r7, #4]
 8004720:	4b0d      	ldr	r3, [pc, #52]	; (8004758 <PrintExcInfo+0x44>)
 8004722:	681b      	ldr	r3, [r3, #0]
 8004724:	60fb      	str	r3, [r7, #12]
 8004726:	f04f 0300 	mov.w	r3, #0
    va_list ap;
    va_start(ap, fmt);
 800472a:	f107 031c 	add.w	r3, r7, #28
 800472e:	60bb      	str	r3, [r7, #8]
    /* uart output without print-spinlock */
    OsVprintf(fmt, ap, EXC_OUTPUT);
 8004730:	2203      	movs	r2, #3
 8004732:	68b9      	ldr	r1, [r7, #8]
 8004734:	6878      	ldr	r0, [r7, #4]
 8004736:	f7ff fec9 	bl	80044cc <OsVprintf>
#ifdef LOSCFG_SHELL_EXCINFO_DUMP
    WriteExcBufVa(fmt, ap);
#endif
    va_end(ap);
}
 800473a:	bf00      	nop
 800473c:	4b06      	ldr	r3, [pc, #24]	; (8004758 <PrintExcInfo+0x44>)
 800473e:	681a      	ldr	r2, [r3, #0]
 8004740:	68fb      	ldr	r3, [r7, #12]
 8004742:	405a      	eors	r2, r3
 8004744:	d001      	beq.n	800474a <PrintExcInfo+0x36>
 8004746:	f7ff fe4f 	bl	80043e8 <__stack_chk_fail>
 800474a:	3710      	adds	r7, #16
 800474c:	46bd      	mov	sp, r7
 800474e:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8004752:	b004      	add	sp, #16
 8004754:	4770      	bx	lr
 8004756:	bf00      	nop
 8004758:	080202b8 	.word	0x080202b8

0800475c <LOS_ListInit>:
{
 800475c:	b480      	push	{r7}
 800475e:	b083      	sub	sp, #12
 8004760:	af00      	add	r7, sp, #0
 8004762:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 8004764:	687b      	ldr	r3, [r7, #4]
 8004766:	687a      	ldr	r2, [r7, #4]
 8004768:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 800476a:	687b      	ldr	r3, [r7, #4]
 800476c:	687a      	ldr	r2, [r7, #4]
 800476e:	601a      	str	r2, [r3, #0]
}
 8004770:	bf00      	nop
 8004772:	370c      	adds	r7, #12
 8004774:	46bd      	mov	sp, r7
 8004776:	f85d 7b04 	ldr.w	r7, [sp], #4
 800477a:	4770      	bx	lr

0800477c <LOS_ListAdd>:
{
 800477c:	b480      	push	{r7}
 800477e:	b083      	sub	sp, #12
 8004780:	af00      	add	r7, sp, #0
 8004782:	6078      	str	r0, [r7, #4]
 8004784:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 8004786:	687b      	ldr	r3, [r7, #4]
 8004788:	685a      	ldr	r2, [r3, #4]
 800478a:	683b      	ldr	r3, [r7, #0]
 800478c:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 800478e:	683b      	ldr	r3, [r7, #0]
 8004790:	687a      	ldr	r2, [r7, #4]
 8004792:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8004794:	687b      	ldr	r3, [r7, #4]
 8004796:	685b      	ldr	r3, [r3, #4]
 8004798:	683a      	ldr	r2, [r7, #0]
 800479a:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 800479c:	687b      	ldr	r3, [r7, #4]
 800479e:	683a      	ldr	r2, [r7, #0]
 80047a0:	605a      	str	r2, [r3, #4]
}
 80047a2:	bf00      	nop
 80047a4:	370c      	adds	r7, #12
 80047a6:	46bd      	mov	sp, r7
 80047a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80047ac:	4770      	bx	lr

080047ae <LOS_ListTailInsert>:
{
 80047ae:	b580      	push	{r7, lr}
 80047b0:	b082      	sub	sp, #8
 80047b2:	af00      	add	r7, sp, #0
 80047b4:	6078      	str	r0, [r7, #4]
 80047b6:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 80047b8:	687b      	ldr	r3, [r7, #4]
 80047ba:	681b      	ldr	r3, [r3, #0]
 80047bc:	6839      	ldr	r1, [r7, #0]
 80047be:	4618      	mov	r0, r3
 80047c0:	f7ff ffdc 	bl	800477c <LOS_ListAdd>
}
 80047c4:	bf00      	nop
 80047c6:	3708      	adds	r7, #8
 80047c8:	46bd      	mov	sp, r7
 80047ca:	bd80      	pop	{r7, pc}

080047cc <LOS_ListEmpty>:
{
 80047cc:	b480      	push	{r7}
 80047ce:	b083      	sub	sp, #12
 80047d0:	af00      	add	r7, sp, #0
 80047d2:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 80047d4:	687b      	ldr	r3, [r7, #4]
 80047d6:	685b      	ldr	r3, [r3, #4]
 80047d8:	687a      	ldr	r2, [r7, #4]
 80047da:	429a      	cmp	r2, r3
 80047dc:	bf0c      	ite	eq
 80047de:	2301      	moveq	r3, #1
 80047e0:	2300      	movne	r3, #0
 80047e2:	b2db      	uxtb	r3, r3
}
 80047e4:	4618      	mov	r0, r3
 80047e6:	370c      	adds	r7, #12
 80047e8:	46bd      	mov	sp, r7
 80047ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80047ee:	4770      	bx	lr

080047f0 <ArchCurrCpuid>:
{
 80047f0:	b480      	push	{r7}
 80047f2:	af00      	add	r7, sp, #0
    return 0;
 80047f4:	2300      	movs	r3, #0
}
 80047f6:	4618      	mov	r0, r3
 80047f8:	46bd      	mov	sp, r7
 80047fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80047fe:	4770      	bx	lr

08004800 <LOS_IntLock>:
{
 8004800:	b580      	push	{r7, lr}
 8004802:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8004804:	f7fc fa60 	bl	8000cc8 <ArchIntLock>
 8004808:	4603      	mov	r3, r0
}
 800480a:	4618      	mov	r0, r3
 800480c:	bd80      	pop	{r7, pc}

0800480e <LOS_IntRestore>:
{
 800480e:	b580      	push	{r7, lr}
 8004810:	b082      	sub	sp, #8
 8004812:	af00      	add	r7, sp, #0
 8004814:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8004816:	6878      	ldr	r0, [r7, #4]
 8004818:	f7fc fa5e 	bl	8000cd8 <ArchIntRestore>
}
 800481c:	bf00      	nop
 800481e:	3708      	adds	r7, #8
 8004820:	46bd      	mov	sp, r7
 8004822:	bd80      	pop	{r7, pc}

08004824 <OsSemDbgInitHook>:
#endif /* __cplusplus */

/* semaphore debug initialization interface */
extern UINT32 OsSemDbgInit(VOID);
STATIC INLINE UINT32 OsSemDbgInitHook(VOID)
{
 8004824:	b580      	push	{r7, lr}
 8004826:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_SEMAPHORE
    return OsSemDbgInit();
 8004828:	f001 fe9a 	bl	8006560 <OsSemDbgInit>
 800482c:	4603      	mov	r3, r0
#else
    return LOS_OK;
#endif
}
 800482e:	4618      	mov	r0, r3
 8004830:	bd80      	pop	{r7, pc}

08004832 <OsSemDbgTimeUpdateHook>:
/* Update the last time the semaphore was executed */
extern VOID OsSemDbgTimeUpdate(UINT32 semId);
STATIC INLINE VOID OsSemDbgTimeUpdateHook(UINT32 semId)
{
 8004832:	b580      	push	{r7, lr}
 8004834:	b082      	sub	sp, #8
 8004836:	af00      	add	r7, sp, #0
 8004838:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_DEBUG_SEMAPHORE
    OsSemDbgTimeUpdate(semId);
 800483a:	6878      	ldr	r0, [r7, #4]
 800483c:	f001 fec2 	bl	80065c4 <OsSemDbgTimeUpdate>
#endif
    return;
 8004840:	bf00      	nop
}
 8004842:	3708      	adds	r7, #8
 8004844:	46bd      	mov	sp, r7
 8004846:	bd80      	pop	{r7, pc}

08004848 <OsPercpuGet>:
{
 8004848:	b580      	push	{r7, lr}
 800484a:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 800484c:	f7ff ffd0 	bl	80047f0 <ArchCurrCpuid>
 8004850:	4602      	mov	r2, r0
 8004852:	4613      	mov	r3, r2
 8004854:	00db      	lsls	r3, r3, #3
 8004856:	4413      	add	r3, r2
 8004858:	009b      	lsls	r3, r3, #2
 800485a:	4a02      	ldr	r2, [pc, #8]	; (8004864 <OsPercpuGet+0x1c>)
 800485c:	4413      	add	r3, r2
}
 800485e:	4618      	mov	r0, r3
 8004860:	bd80      	pop	{r7, pc}
 8004862:	bf00      	nop
 8004864:	200036fc 	.word	0x200036fc

08004868 <LOS_Schedule>:
{
 8004868:	b580      	push	{r7, lr}
 800486a:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 800486c:	f7fd fdfe 	bl	800246c <IntActive>
 8004870:	4603      	mov	r3, r0
 8004872:	2b00      	cmp	r3, #0
 8004874:	d005      	beq.n	8004882 <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8004876:	f7ff ffe7 	bl	8004848 <OsPercpuGet>
 800487a:	4603      	mov	r3, r0
 800487c:	2201      	movs	r2, #1
 800487e:	621a      	str	r2, [r3, #32]
        return;
 8004880:	e001      	b.n	8004886 <LOS_Schedule+0x1e>
    OsSchedPreempt();
 8004882:	f003 fd21 	bl	80082c8 <OsSchedPreempt>
}
 8004886:	bd80      	pop	{r7, pc}

08004888 <LOS_SpinLockSave>:
{
 8004888:	b580      	push	{r7, lr}
 800488a:	b082      	sub	sp, #8
 800488c:	af00      	add	r7, sp, #0
 800488e:	6078      	str	r0, [r7, #4]
 8004890:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8004892:	f7ff ffb5 	bl	8004800 <LOS_IntLock>
 8004896:	4602      	mov	r2, r0
 8004898:	683b      	ldr	r3, [r7, #0]
 800489a:	601a      	str	r2, [r3, #0]
}
 800489c:	bf00      	nop
 800489e:	3708      	adds	r7, #8
 80048a0:	46bd      	mov	sp, r7
 80048a2:	bd80      	pop	{r7, pc}

080048a4 <LOS_SpinUnlockRestore>:
{
 80048a4:	b580      	push	{r7, lr}
 80048a6:	b082      	sub	sp, #8
 80048a8:	af00      	add	r7, sp, #0
 80048aa:	6078      	str	r0, [r7, #4]
 80048ac:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 80048ae:	6838      	ldr	r0, [r7, #0]
 80048b0:	f7ff ffad 	bl	800480e <LOS_IntRestore>
}
 80048b4:	bf00      	nop
 80048b6:	3708      	adds	r7, #8
 80048b8:	46bd      	mov	sp, r7
 80048ba:	bd80      	pop	{r7, pc}

080048bc <LOS_MpSchedule>:
{
 80048bc:	b480      	push	{r7}
 80048be:	b083      	sub	sp, #12
 80048c0:	af00      	add	r7, sp, #0
 80048c2:	6078      	str	r0, [r7, #4]
}
 80048c4:	bf00      	nop
 80048c6:	370c      	adds	r7, #12
 80048c8:	46bd      	mov	sp, r7
 80048ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80048ce:	4770      	bx	lr

080048d0 <OsSemNodeRecycle>:

LITE_OS_SEC_DATA_INIT STATIC LOS_DL_LIST g_unusedSemList;
LITE_OS_SEC_BSS LosSemCB *g_allSem = NULL;

STATIC_INLINE VOID OsSemNodeRecycle(LosSemCB *semNode)
{
 80048d0:	b580      	push	{r7, lr}
 80048d2:	b082      	sub	sp, #8
 80048d4:	af00      	add	r7, sp, #0
 80048d6:	6078      	str	r0, [r7, #4]
    semNode->semStat = LOS_UNUSED;
 80048d8:	687b      	ldr	r3, [r7, #4]
 80048da:	2200      	movs	r2, #0
 80048dc:	701a      	strb	r2, [r3, #0]
    LOS_ListTailInsert(&g_unusedSemList, &semNode->semList);
 80048de:	687b      	ldr	r3, [r7, #4]
 80048e0:	3308      	adds	r3, #8
 80048e2:	4619      	mov	r1, r3
 80048e4:	4803      	ldr	r0, [pc, #12]	; (80048f4 <OsSemNodeRecycle+0x24>)
 80048e6:	f7ff ff62 	bl	80047ae <LOS_ListTailInsert>
}
 80048ea:	bf00      	nop
 80048ec:	3708      	adds	r7, #8
 80048ee:	46bd      	mov	sp, r7
 80048f0:	bd80      	pop	{r7, pc}
 80048f2:	bf00      	nop
 80048f4:	20000788 	.word	0x20000788

080048f8 <OsSemInit>:

LITE_OS_SEC_TEXT_INIT UINT32 OsSemInit(VOID)
{
 80048f8:	b580      	push	{r7, lr}
 80048fa:	b082      	sub	sp, #8
 80048fc:	af00      	add	r7, sp, #0
    LosSemCB *semNode = NULL;
 80048fe:	2300      	movs	r3, #0
 8004900:	607b      	str	r3, [r7, #4]
    UINT16 index; // support at most 65536 semaphores

    /* system resident memory, don't free */
    g_allSem = (LosSemCB *)LOS_MemAlloc(m_aucSysMem0, (KERNEL_SEM_LIMIT * sizeof(LosSemCB)));
 8004902:	4b1a      	ldr	r3, [pc, #104]	; (800496c <OsSemInit+0x74>)
 8004904:	681b      	ldr	r3, [r3, #0]
 8004906:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800490a:	4618      	mov	r0, r3
 800490c:	f004 f84c 	bl	80089a8 <LOS_MemAlloc>
 8004910:	4603      	mov	r3, r0
 8004912:	4a17      	ldr	r2, [pc, #92]	; (8004970 <OsSemInit+0x78>)
 8004914:	6013      	str	r3, [r2, #0]
    if (g_allSem == NULL) {
 8004916:	4b16      	ldr	r3, [pc, #88]	; (8004970 <OsSemInit+0x78>)
 8004918:	681b      	ldr	r3, [r3, #0]
 800491a:	2b00      	cmp	r3, #0
 800491c:	d101      	bne.n	8004922 <OsSemInit+0x2a>
        return LOS_ERRNO_SEM_NO_MEMORY;
 800491e:	4b15      	ldr	r3, [pc, #84]	; (8004974 <OsSemInit+0x7c>)
 8004920:	e01f      	b.n	8004962 <OsSemInit+0x6a>
    }

    LOS_ListInit(&g_unusedSemList);
 8004922:	4815      	ldr	r0, [pc, #84]	; (8004978 <OsSemInit+0x80>)
 8004924:	f7ff ff1a 	bl	800475c <LOS_ListInit>

    for (index = 0; index < KERNEL_SEM_LIMIT; index++) {
 8004928:	2300      	movs	r3, #0
 800492a:	807b      	strh	r3, [r7, #2]
 800492c:	e00e      	b.n	800494c <OsSemInit+0x54>
        semNode = ((LosSemCB *)g_allSem) + index;
 800492e:	4b10      	ldr	r3, [pc, #64]	; (8004970 <OsSemInit+0x78>)
 8004930:	681a      	ldr	r2, [r3, #0]
 8004932:	887b      	ldrh	r3, [r7, #2]
 8004934:	011b      	lsls	r3, r3, #4
 8004936:	4413      	add	r3, r2
 8004938:	607b      	str	r3, [r7, #4]
        semNode->semId = (UINT32)index;
 800493a:	887a      	ldrh	r2, [r7, #2]
 800493c:	687b      	ldr	r3, [r7, #4]
 800493e:	605a      	str	r2, [r3, #4]
        OsSemNodeRecycle(semNode);
 8004940:	6878      	ldr	r0, [r7, #4]
 8004942:	f7ff ffc5 	bl	80048d0 <OsSemNodeRecycle>
    for (index = 0; index < KERNEL_SEM_LIMIT; index++) {
 8004946:	887b      	ldrh	r3, [r7, #2]
 8004948:	3301      	adds	r3, #1
 800494a:	807b      	strh	r3, [r7, #2]
 800494c:	887b      	ldrh	r3, [r7, #2]
 800494e:	2b13      	cmp	r3, #19
 8004950:	d9ed      	bls.n	800492e <OsSemInit+0x36>
    }

    if (OsSemDbgInitHook() != LOS_OK) {
 8004952:	f7ff ff67 	bl	8004824 <OsSemDbgInitHook>
 8004956:	4603      	mov	r3, r0
 8004958:	2b00      	cmp	r3, #0
 800495a:	d001      	beq.n	8004960 <OsSemInit+0x68>
        return LOS_ERRNO_SEM_NO_MEMORY;
 800495c:	4b05      	ldr	r3, [pc, #20]	; (8004974 <OsSemInit+0x7c>)
 800495e:	e000      	b.n	8004962 <OsSemInit+0x6a>
    }
    return LOS_OK;
 8004960:	2300      	movs	r3, #0
}
 8004962:	4618      	mov	r0, r3
 8004964:	3708      	adds	r7, #8
 8004966:	46bd      	mov	sp, r7
 8004968:	bd80      	pop	{r7, pc}
 800496a:	bf00      	nop
 800496c:	200021b4 	.word	0x200021b4
 8004970:	20000790 	.word	0x20000790
 8004974:	02000700 	.word	0x02000700
 8004978:	20000788 	.word	0x20000788

0800497c <OsSemStateVerify>:
    }
    return OsSemCreate(count, OS_SEM_BINARY, semHandle);
}

STATIC_INLINE UINT32 OsSemStateVerify(UINT32 semId, const LosSemCB *semNode)
{
 800497c:	b480      	push	{r7}
 800497e:	b083      	sub	sp, #12
 8004980:	af00      	add	r7, sp, #0
 8004982:	6078      	str	r0, [r7, #4]
 8004984:	6039      	str	r1, [r7, #0]
#ifndef LOSCFG_RESOURCE_ID_NOT_USE_HIGH_BITS
    if ((semNode->semStat == LOS_UNUSED) || (semNode->semId != semId)) {
 8004986:	683b      	ldr	r3, [r7, #0]
 8004988:	781b      	ldrb	r3, [r3, #0]
 800498a:	2b00      	cmp	r3, #0
 800498c:	d004      	beq.n	8004998 <OsSemStateVerify+0x1c>
 800498e:	683b      	ldr	r3, [r7, #0]
 8004990:	685b      	ldr	r3, [r3, #4]
 8004992:	687a      	ldr	r2, [r7, #4]
 8004994:	429a      	cmp	r2, r3
 8004996:	d001      	beq.n	800499c <OsSemStateVerify+0x20>
#else
    if (semNode->semStat == LOS_UNUSED) {
#endif
        return LOS_ERRNO_SEM_INVALID;
 8004998:	4b04      	ldr	r3, [pc, #16]	; (80049ac <OsSemStateVerify+0x30>)
 800499a:	e000      	b.n	800499e <OsSemStateVerify+0x22>
    }
    return LOS_OK;
 800499c:	2300      	movs	r3, #0
}
 800499e:	4618      	mov	r0, r3
 80049a0:	370c      	adds	r7, #12
 80049a2:	46bd      	mov	sp, r7
 80049a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049a8:	4770      	bx	lr
 80049aa:	bf00      	nop
 80049ac:	02000701 	.word	0x02000701

080049b0 <OsSemGetCBWithCheck>:

STATIC UINT32 OsSemGetCBWithCheck(UINT32 semHandle, LosSemCB **semCB)
{
 80049b0:	b480      	push	{r7}
 80049b2:	b083      	sub	sp, #12
 80049b4:	af00      	add	r7, sp, #0
 80049b6:	6078      	str	r0, [r7, #4]
 80049b8:	6039      	str	r1, [r7, #0]
    if (GET_SEM_INDEX(semHandle) >= (UINT32)KERNEL_SEM_LIMIT) {
 80049ba:	687b      	ldr	r3, [r7, #4]
 80049bc:	b29b      	uxth	r3, r3
 80049be:	2b13      	cmp	r3, #19
 80049c0:	d901      	bls.n	80049c6 <OsSemGetCBWithCheck+0x16>
        return LOS_ERRNO_SEM_INVALID;
 80049c2:	4b08      	ldr	r3, [pc, #32]	; (80049e4 <OsSemGetCBWithCheck+0x34>)
 80049c4:	e008      	b.n	80049d8 <OsSemGetCBWithCheck+0x28>
    }

    *semCB = GET_SEM(semHandle);
 80049c6:	4b08      	ldr	r3, [pc, #32]	; (80049e8 <OsSemGetCBWithCheck+0x38>)
 80049c8:	681a      	ldr	r2, [r3, #0]
 80049ca:	687b      	ldr	r3, [r7, #4]
 80049cc:	b29b      	uxth	r3, r3
 80049ce:	011b      	lsls	r3, r3, #4
 80049d0:	441a      	add	r2, r3
 80049d2:	683b      	ldr	r3, [r7, #0]
 80049d4:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 80049d6:	2300      	movs	r3, #0
}
 80049d8:	4618      	mov	r0, r3
 80049da:	370c      	adds	r7, #12
 80049dc:	46bd      	mov	sp, r7
 80049de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049e2:	4770      	bx	lr
 80049e4:	02000701 	.word	0x02000701
 80049e8:	20000790 	.word	0x20000790

080049ec <LOS_SemPost>:
    SCHEDULER_UNLOCK(intSave);
    return ret;
}

LITE_OS_SEC_TEXT UINT32 LOS_SemPost(UINT32 semHandle)
{
 80049ec:	b590      	push	{r4, r7, lr}
 80049ee:	b08f      	sub	sp, #60	; 0x3c
 80049f0:	af00      	add	r7, sp, #0
 80049f2:	6078      	str	r0, [r7, #4]
 80049f4:	4b4a      	ldr	r3, [pc, #296]	; (8004b20 <LOS_SemPost+0x134>)
 80049f6:	681b      	ldr	r3, [r3, #0]
 80049f8:	637b      	str	r3, [r7, #52]	; 0x34
 80049fa:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosSemCB *semPosted = NULL;
 80049fe:	2300      	movs	r3, #0
 8004a00:	617b      	str	r3, [r7, #20]
    LosTaskCB *resumedTask = NULL;
 8004a02:	2300      	movs	r3, #0
 8004a04:	61fb      	str	r3, [r7, #28]
    UINT16 maxCount;
    UINT32 ret;

    ret = OsSemGetCBWithCheck(semHandle, &semPosted);
 8004a06:	f107 0314 	add.w	r3, r7, #20
 8004a0a:	4619      	mov	r1, r3
 8004a0c:	6878      	ldr	r0, [r7, #4]
 8004a0e:	f7ff ffcf 	bl	80049b0 <OsSemGetCBWithCheck>
 8004a12:	61b8      	str	r0, [r7, #24]
    if (ret != LOS_OK) {
 8004a14:	69bb      	ldr	r3, [r7, #24]
 8004a16:	2b00      	cmp	r3, #0
 8004a18:	d001      	beq.n	8004a1e <LOS_SemPost+0x32>
        return ret;
 8004a1a:	69bb      	ldr	r3, [r7, #24]
 8004a1c:	e074      	b.n	8004b08 <LOS_SemPost+0x11c>
    }

    LOS_TRACE(SEM_POST, semHandle, semPosted->semType, semPosted->semCount);
 8004a1e:	2300      	movs	r3, #0
 8004a20:	627b      	str	r3, [r7, #36]	; 0x24
 8004a22:	687b      	ldr	r3, [r7, #4]
 8004a24:	62bb      	str	r3, [r7, #40]	; 0x28
 8004a26:	697b      	ldr	r3, [r7, #20]
 8004a28:	785b      	ldrb	r3, [r3, #1]
 8004a2a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004a2c:	697b      	ldr	r3, [r7, #20]
 8004a2e:	885b      	ldrh	r3, [r3, #2]
 8004a30:	633b      	str	r3, [r7, #48]	; 0x30
 8004a32:	2304      	movs	r3, #4
 8004a34:	623b      	str	r3, [r7, #32]
 8004a36:	6a3b      	ldr	r3, [r7, #32]
 8004a38:	2b01      	cmp	r3, #1
 8004a3a:	d916      	bls.n	8004a6a <LOS_SemPost+0x7e>
 8004a3c:	4b39      	ldr	r3, [pc, #228]	; (8004b24 <LOS_SemPost+0x138>)
 8004a3e:	681b      	ldr	r3, [r3, #0]
 8004a40:	2b00      	cmp	r3, #0
 8004a42:	d012      	beq.n	8004a6a <LOS_SemPost+0x7e>
 8004a44:	4b37      	ldr	r3, [pc, #220]	; (8004b24 <LOS_SemPost+0x138>)
 8004a46:	681c      	ldr	r4, [r3, #0]
 8004a48:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8004a4a:	6a3b      	ldr	r3, [r7, #32]
 8004a4c:	2b02      	cmp	r3, #2
 8004a4e:	d904      	bls.n	8004a5a <LOS_SemPost+0x6e>
 8004a50:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8004a54:	f103 0208 	add.w	r2, r3, #8
 8004a58:	e000      	b.n	8004a5c <LOS_SemPost+0x70>
 8004a5a:	2200      	movs	r2, #0
 8004a5c:	6a3b      	ldr	r3, [r7, #32]
 8004a5e:	b29b      	uxth	r3, r3
 8004a60:	3b02      	subs	r3, #2
 8004a62:	b29b      	uxth	r3, r3
 8004a64:	f640 0003 	movw	r0, #2051	; 0x803
 8004a68:	47a0      	blx	r4

    SCHEDULER_LOCK(intSave);
 8004a6a:	f107 0310 	add.w	r3, r7, #16
 8004a6e:	4619      	mov	r1, r3
 8004a70:	482d      	ldr	r0, [pc, #180]	; (8004b28 <LOS_SemPost+0x13c>)
 8004a72:	f7ff ff09 	bl	8004888 <LOS_SpinLockSave>

    ret = OsSemStateVerify(semHandle, semPosted);
 8004a76:	697b      	ldr	r3, [r7, #20]
 8004a78:	4619      	mov	r1, r3
 8004a7a:	6878      	ldr	r0, [r7, #4]
 8004a7c:	f7ff ff7e 	bl	800497c <OsSemStateVerify>
 8004a80:	61b8      	str	r0, [r7, #24]
    if (ret != LOS_OK) {
 8004a82:	69bb      	ldr	r3, [r7, #24]
 8004a84:	2b00      	cmp	r3, #0
 8004a86:	d138      	bne.n	8004afa <LOS_SemPost+0x10e>
        goto OUT;
    }

    /* Update the operate time, no matter the actual Post success or not */
    OsSemDbgTimeUpdateHook(semHandle);
 8004a88:	6878      	ldr	r0, [r7, #4]
 8004a8a:	f7ff fed2 	bl	8004832 <OsSemDbgTimeUpdateHook>

    maxCount = (semPosted->semType == OS_SEM_COUNTING) ? LOS_SEM_COUNT_MAX : OS_SEM_BINARY_COUNT_MAX;
 8004a8e:	697b      	ldr	r3, [r7, #20]
 8004a90:	785b      	ldrb	r3, [r3, #1]
 8004a92:	2b00      	cmp	r3, #0
 8004a94:	d102      	bne.n	8004a9c <LOS_SemPost+0xb0>
 8004a96:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8004a9a:	e000      	b.n	8004a9e <LOS_SemPost+0xb2>
 8004a9c:	2301      	movs	r3, #1
 8004a9e:	81fb      	strh	r3, [r7, #14]
    if (semPosted->semCount >= maxCount) {
 8004aa0:	697b      	ldr	r3, [r7, #20]
 8004aa2:	885b      	ldrh	r3, [r3, #2]
 8004aa4:	89fa      	ldrh	r2, [r7, #14]
 8004aa6:	429a      	cmp	r2, r3
 8004aa8:	d802      	bhi.n	8004ab0 <LOS_SemPost+0xc4>
        ret = LOS_ERRNO_SEM_OVERFLOW;
 8004aaa:	4b20      	ldr	r3, [pc, #128]	; (8004b2c <LOS_SemPost+0x140>)
 8004aac:	61bb      	str	r3, [r7, #24]
        goto OUT;
 8004aae:	e025      	b.n	8004afc <LOS_SemPost+0x110>
    }
    if (!LOS_ListEmpty(&semPosted->semList)) {
 8004ab0:	697b      	ldr	r3, [r7, #20]
 8004ab2:	3308      	adds	r3, #8
 8004ab4:	4618      	mov	r0, r3
 8004ab6:	f7ff fe89 	bl	80047cc <LOS_ListEmpty>
 8004aba:	4603      	mov	r3, r0
 8004abc:	2b00      	cmp	r3, #0
 8004abe:	d116      	bne.n	8004aee <LOS_SemPost+0x102>
        resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&(semPosted->semList)));
 8004ac0:	697b      	ldr	r3, [r7, #20]
 8004ac2:	68db      	ldr	r3, [r3, #12]
 8004ac4:	3b40      	subs	r3, #64	; 0x40
 8004ac6:	61fb      	str	r3, [r7, #28]
        resumedTask->taskSem = NULL;
 8004ac8:	69fb      	ldr	r3, [r7, #28]
 8004aca:	2200      	movs	r2, #0
 8004acc:	61da      	str	r2, [r3, #28]
        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
 8004ace:	2108      	movs	r1, #8
 8004ad0:	69f8      	ldr	r0, [r7, #28]
 8004ad2:	f7ff f981 	bl	8003dd8 <OsTaskWake>

        SCHEDULER_UNLOCK(intSave);
 8004ad6:	693b      	ldr	r3, [r7, #16]
 8004ad8:	4619      	mov	r1, r3
 8004ada:	4813      	ldr	r0, [pc, #76]	; (8004b28 <LOS_SemPost+0x13c>)
 8004adc:	f7ff fee2 	bl	80048a4 <LOS_SpinUnlockRestore>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 8004ae0:	2001      	movs	r0, #1
 8004ae2:	f7ff feeb 	bl	80048bc <LOS_MpSchedule>
        LOS_Schedule();
 8004ae6:	f7ff febf 	bl	8004868 <LOS_Schedule>
        return LOS_OK;
 8004aea:	2300      	movs	r3, #0
 8004aec:	e00c      	b.n	8004b08 <LOS_SemPost+0x11c>
    } else {
        semPosted->semCount++;
 8004aee:	697b      	ldr	r3, [r7, #20]
 8004af0:	885a      	ldrh	r2, [r3, #2]
 8004af2:	3201      	adds	r2, #1
 8004af4:	b292      	uxth	r2, r2
 8004af6:	805a      	strh	r2, [r3, #2]
 8004af8:	e000      	b.n	8004afc <LOS_SemPost+0x110>
        goto OUT;
 8004afa:	bf00      	nop
    }

OUT:
    SCHEDULER_UNLOCK(intSave);
 8004afc:	693b      	ldr	r3, [r7, #16]
 8004afe:	4619      	mov	r1, r3
 8004b00:	4809      	ldr	r0, [pc, #36]	; (8004b28 <LOS_SemPost+0x13c>)
 8004b02:	f7ff fecf 	bl	80048a4 <LOS_SpinUnlockRestore>
    return ret;
 8004b06:	69bb      	ldr	r3, [r7, #24]
}
 8004b08:	4a05      	ldr	r2, [pc, #20]	; (8004b20 <LOS_SemPost+0x134>)
 8004b0a:	6811      	ldr	r1, [r2, #0]
 8004b0c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004b0e:	4051      	eors	r1, r2
 8004b10:	d001      	beq.n	8004b16 <LOS_SemPost+0x12a>
 8004b12:	f7ff fc69 	bl	80043e8 <__stack_chk_fail>
 8004b16:	4618      	mov	r0, r3
 8004b18:	373c      	adds	r7, #60	; 0x3c
 8004b1a:	46bd      	mov	sp, r7
 8004b1c:	bd90      	pop	{r4, r7, pc}
 8004b1e:	bf00      	nop
 8004b20:	080202dc 	.word	0x080202dc
 8004b24:	2000075c 	.word	0x2000075c
 8004b28:	20000764 	.word	0x20000764
 8004b2c:	02000708 	.word	0x02000708

08004b30 <LOS_ListInit>:
{
 8004b30:	b480      	push	{r7}
 8004b32:	b083      	sub	sp, #12
 8004b34:	af00      	add	r7, sp, #0
 8004b36:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 8004b38:	687b      	ldr	r3, [r7, #4]
 8004b3a:	687a      	ldr	r2, [r7, #4]
 8004b3c:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 8004b3e:	687b      	ldr	r3, [r7, #4]
 8004b40:	687a      	ldr	r2, [r7, #4]
 8004b42:	601a      	str	r2, [r3, #0]
}
 8004b44:	bf00      	nop
 8004b46:	370c      	adds	r7, #12
 8004b48:	46bd      	mov	sp, r7
 8004b4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004b4e:	4770      	bx	lr

08004b50 <LOS_ListAdd>:
{
 8004b50:	b480      	push	{r7}
 8004b52:	b083      	sub	sp, #12
 8004b54:	af00      	add	r7, sp, #0
 8004b56:	6078      	str	r0, [r7, #4]
 8004b58:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 8004b5a:	687b      	ldr	r3, [r7, #4]
 8004b5c:	685a      	ldr	r2, [r3, #4]
 8004b5e:	683b      	ldr	r3, [r7, #0]
 8004b60:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 8004b62:	683b      	ldr	r3, [r7, #0]
 8004b64:	687a      	ldr	r2, [r7, #4]
 8004b66:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8004b68:	687b      	ldr	r3, [r7, #4]
 8004b6a:	685b      	ldr	r3, [r3, #4]
 8004b6c:	683a      	ldr	r2, [r7, #0]
 8004b6e:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 8004b70:	687b      	ldr	r3, [r7, #4]
 8004b72:	683a      	ldr	r2, [r7, #0]
 8004b74:	605a      	str	r2, [r3, #4]
}
 8004b76:	bf00      	nop
 8004b78:	370c      	adds	r7, #12
 8004b7a:	46bd      	mov	sp, r7
 8004b7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004b80:	4770      	bx	lr

08004b82 <LOS_ListTailInsert>:
{
 8004b82:	b580      	push	{r7, lr}
 8004b84:	b082      	sub	sp, #8
 8004b86:	af00      	add	r7, sp, #0
 8004b88:	6078      	str	r0, [r7, #4]
 8004b8a:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 8004b8c:	687b      	ldr	r3, [r7, #4]
 8004b8e:	681b      	ldr	r3, [r3, #0]
 8004b90:	6839      	ldr	r1, [r7, #0]
 8004b92:	4618      	mov	r0, r3
 8004b94:	f7ff ffdc 	bl	8004b50 <LOS_ListAdd>
}
 8004b98:	bf00      	nop
 8004b9a:	3708      	adds	r7, #8
 8004b9c:	46bd      	mov	sp, r7
 8004b9e:	bd80      	pop	{r7, pc}

08004ba0 <LOS_ListDelete>:
{
 8004ba0:	b480      	push	{r7}
 8004ba2:	b083      	sub	sp, #12
 8004ba4:	af00      	add	r7, sp, #0
 8004ba6:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8004ba8:	687b      	ldr	r3, [r7, #4]
 8004baa:	685b      	ldr	r3, [r3, #4]
 8004bac:	687a      	ldr	r2, [r7, #4]
 8004bae:	6812      	ldr	r2, [r2, #0]
 8004bb0:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 8004bb2:	687b      	ldr	r3, [r7, #4]
 8004bb4:	681b      	ldr	r3, [r3, #0]
 8004bb6:	687a      	ldr	r2, [r7, #4]
 8004bb8:	6852      	ldr	r2, [r2, #4]
 8004bba:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8004bbc:	687b      	ldr	r3, [r7, #4]
 8004bbe:	2200      	movs	r2, #0
 8004bc0:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 8004bc2:	687b      	ldr	r3, [r7, #4]
 8004bc4:	2200      	movs	r2, #0
 8004bc6:	601a      	str	r2, [r3, #0]
}
 8004bc8:	bf00      	nop
 8004bca:	370c      	adds	r7, #12
 8004bcc:	46bd      	mov	sp, r7
 8004bce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004bd2:	4770      	bx	lr

08004bd4 <LOS_ListEmpty>:
{
 8004bd4:	b480      	push	{r7}
 8004bd6:	b083      	sub	sp, #12
 8004bd8:	af00      	add	r7, sp, #0
 8004bda:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8004bdc:	687b      	ldr	r3, [r7, #4]
 8004bde:	685b      	ldr	r3, [r3, #4]
 8004be0:	687a      	ldr	r2, [r7, #4]
 8004be2:	429a      	cmp	r2, r3
 8004be4:	bf0c      	ite	eq
 8004be6:	2301      	moveq	r3, #1
 8004be8:	2300      	movne	r3, #0
 8004bea:	b2db      	uxtb	r3, r3
}
 8004bec:	4618      	mov	r0, r3
 8004bee:	370c      	adds	r7, #12
 8004bf0:	46bd      	mov	sp, r7
 8004bf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004bf6:	4770      	bx	lr

08004bf8 <ArchCurrCpuid>:
{
 8004bf8:	b480      	push	{r7}
 8004bfa:	af00      	add	r7, sp, #0
    return 0;
 8004bfc:	2300      	movs	r3, #0
}
 8004bfe:	4618      	mov	r0, r3
 8004c00:	46bd      	mov	sp, r7
 8004c02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c06:	4770      	bx	lr

08004c08 <LOS_IntLock>:
{
 8004c08:	b580      	push	{r7, lr}
 8004c0a:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8004c0c:	f7fc f85c 	bl	8000cc8 <ArchIntLock>
 8004c10:	4603      	mov	r3, r0
}
 8004c12:	4618      	mov	r0, r3
 8004c14:	bd80      	pop	{r7, pc}

08004c16 <LOS_IntRestore>:
{
 8004c16:	b580      	push	{r7, lr}
 8004c18:	b082      	sub	sp, #8
 8004c1a:	af00      	add	r7, sp, #0
 8004c1c:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8004c1e:	6878      	ldr	r0, [r7, #4]
 8004c20:	f7fc f85a 	bl	8000cd8 <ArchIntRestore>
}
 8004c24:	bf00      	nop
 8004c26:	3708      	adds	r7, #8
 8004c28:	46bd      	mov	sp, r7
 8004c2a:	bd80      	pop	{r7, pc}

08004c2c <LOS_SpinLock>:
{
 8004c2c:	b480      	push	{r7}
 8004c2e:	b083      	sub	sp, #12
 8004c30:	af00      	add	r7, sp, #0
 8004c32:	6078      	str	r0, [r7, #4]
}
 8004c34:	bf00      	nop
 8004c36:	370c      	adds	r7, #12
 8004c38:	46bd      	mov	sp, r7
 8004c3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c3e:	4770      	bx	lr

08004c40 <LOS_SpinUnlock>:
{
 8004c40:	b480      	push	{r7}
 8004c42:	b083      	sub	sp, #12
 8004c44:	af00      	add	r7, sp, #0
 8004c46:	6078      	str	r0, [r7, #4]
}
 8004c48:	bf00      	nop
 8004c4a:	370c      	adds	r7, #12
 8004c4c:	46bd      	mov	sp, r7
 8004c4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c52:	4770      	bx	lr

08004c54 <LOS_SpinLockSave>:
{
 8004c54:	b580      	push	{r7, lr}
 8004c56:	b082      	sub	sp, #8
 8004c58:	af00      	add	r7, sp, #0
 8004c5a:	6078      	str	r0, [r7, #4]
 8004c5c:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8004c5e:	f7ff ffd3 	bl	8004c08 <LOS_IntLock>
 8004c62:	4602      	mov	r2, r0
 8004c64:	683b      	ldr	r3, [r7, #0]
 8004c66:	601a      	str	r2, [r3, #0]
}
 8004c68:	bf00      	nop
 8004c6a:	3708      	adds	r7, #8
 8004c6c:	46bd      	mov	sp, r7
 8004c6e:	bd80      	pop	{r7, pc}

08004c70 <LOS_SpinUnlockRestore>:
{
 8004c70:	b580      	push	{r7, lr}
 8004c72:	b082      	sub	sp, #8
 8004c74:	af00      	add	r7, sp, #0
 8004c76:	6078      	str	r0, [r7, #4]
 8004c78:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8004c7a:	6838      	ldr	r0, [r7, #0]
 8004c7c:	f7ff ffcb 	bl	8004c16 <LOS_IntRestore>
}
 8004c80:	bf00      	nop
 8004c82:	3708      	adds	r7, #8
 8004c84:	46bd      	mov	sp, r7
 8004c86:	bd80      	pop	{r7, pc}

08004c88 <OsPercpuGet>:
{
 8004c88:	b580      	push	{r7, lr}
 8004c8a:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 8004c8c:	f7ff ffb4 	bl	8004bf8 <ArchCurrCpuid>
 8004c90:	4602      	mov	r2, r0
 8004c92:	4613      	mov	r3, r2
 8004c94:	00db      	lsls	r3, r3, #3
 8004c96:	4413      	add	r3, r2
 8004c98:	009b      	lsls	r3, r3, #2
 8004c9a:	4a02      	ldr	r2, [pc, #8]	; (8004ca4 <OsPercpuGet+0x1c>)
 8004c9c:	4413      	add	r3, r2
}
 8004c9e:	4618      	mov	r0, r3
 8004ca0:	bd80      	pop	{r7, pc}
 8004ca2:	bf00      	nop
 8004ca4:	200036fc 	.word	0x200036fc

08004ca8 <OsSwtmrStart>:
/*
 * Description: Start Software Timer
 * Input      : swtmr --- Need to start software timer
 */
LITE_OS_SEC_TEXT VOID OsSwtmrStart(LosSwtmrCB *swtmr)
{
 8004ca8:	b580      	push	{r7, lr}
 8004caa:	b082      	sub	sp, #8
 8004cac:	af00      	add	r7, sp, #0
 8004cae:	6078      	str	r0, [r7, #4]
    if ((swtmr->overrun == 0) && ((swtmr->mode == LOS_SWTMR_MODE_ONCE) ||
 8004cb0:	687b      	ldr	r3, [r7, #4]
 8004cb2:	7b9b      	ldrb	r3, [r3, #14]
 8004cb4:	2b00      	cmp	r3, #0
 8004cb6:	d110      	bne.n	8004cda <OsSwtmrStart+0x32>
 8004cb8:	687b      	ldr	r3, [r7, #4]
 8004cba:	7b5b      	ldrb	r3, [r3, #13]
 8004cbc:	2b00      	cmp	r3, #0
 8004cbe:	d007      	beq.n	8004cd0 <OsSwtmrStart+0x28>
        (swtmr->mode == LOS_SWTMR_MODE_OPP) ||
 8004cc0:	687b      	ldr	r3, [r7, #4]
 8004cc2:	7b5b      	ldrb	r3, [r3, #13]
    if ((swtmr->overrun == 0) && ((swtmr->mode == LOS_SWTMR_MODE_ONCE) ||
 8004cc4:	2b03      	cmp	r3, #3
 8004cc6:	d003      	beq.n	8004cd0 <OsSwtmrStart+0x28>
        (swtmr->mode == LOS_SWTMR_MODE_NO_SELFDELETE))) {
 8004cc8:	687b      	ldr	r3, [r7, #4]
 8004cca:	7b5b      	ldrb	r3, [r3, #13]
        (swtmr->mode == LOS_SWTMR_MODE_OPP) ||
 8004ccc:	2b02      	cmp	r3, #2
 8004cce:	d104      	bne.n	8004cda <OsSwtmrStart+0x32>
        SET_SORTLIST_VALUE(&(swtmr->sortList), swtmr->expiry);
 8004cd0:	687b      	ldr	r3, [r7, #4]
 8004cd2:	699a      	ldr	r2, [r3, #24]
 8004cd4:	687b      	ldr	r3, [r7, #4]
 8004cd6:	609a      	str	r2, [r3, #8]
 8004cd8:	e003      	b.n	8004ce2 <OsSwtmrStart+0x3a>
    } else {
        SET_SORTLIST_VALUE(&(swtmr->sortList), swtmr->interval);
 8004cda:	687b      	ldr	r3, [r7, #4]
 8004cdc:	695a      	ldr	r2, [r3, #20]
 8004cde:	687b      	ldr	r3, [r7, #4]
 8004ce0:	609a      	str	r2, [r3, #8]
    }

    OsAdd2SortLink(&OsPercpuGet()->swtmrSortLink, &swtmr->sortList);
 8004ce2:	f7ff ffd1 	bl	8004c88 <OsPercpuGet>
 8004ce6:	4603      	mov	r3, r0
 8004ce8:	3308      	adds	r3, #8
 8004cea:	687a      	ldr	r2, [r7, #4]
 8004cec:	4611      	mov	r1, r2
 8004cee:	4618      	mov	r0, r3
 8004cf0:	f004 fd0c 	bl	800970c <OsAdd2SortLink>

    swtmr->state = OS_SWTMR_STATUS_TICKING;
 8004cf4:	687b      	ldr	r3, [r7, #4]
 8004cf6:	2202      	movs	r2, #2
 8004cf8:	731a      	strb	r2, [r3, #12]

#ifdef LOSCFG_KERNEL_SMP
    swtmr->cpuid = ArchCurrCpuid();
#endif
}
 8004cfa:	bf00      	nop
 8004cfc:	3708      	adds	r7, #8
 8004cfe:	46bd      	mov	sp, r7
 8004d00:	bd80      	pop	{r7, pc}
	...

08004d04 <OsSwtmrDelete>:
/*
 * Description: Delete Software Timer
 * Input      : swtmr --- Need to delete software timer, When using, Ensure that it can't be NULL.
 */
STATIC INLINE VOID OsSwtmrDelete(LosSwtmrCB *swtmr)
{
 8004d04:	b580      	push	{r7, lr}
 8004d06:	b082      	sub	sp, #8
 8004d08:	af00      	add	r7, sp, #0
 8004d0a:	6078      	str	r0, [r7, #4]
    /* insert to free list */
    LOS_ListTailInsert(&g_swtmrFreeList, &swtmr->sortList.sortLinkNode);
 8004d0c:	687b      	ldr	r3, [r7, #4]
 8004d0e:	4619      	mov	r1, r3
 8004d10:	4804      	ldr	r0, [pc, #16]	; (8004d24 <OsSwtmrDelete+0x20>)
 8004d12:	f7ff ff36 	bl	8004b82 <LOS_ListTailInsert>
    swtmr->state = OS_SWTMR_STATUS_UNUSED;
 8004d16:	687b      	ldr	r3, [r7, #4]
 8004d18:	2200      	movs	r2, #0
 8004d1a:	731a      	strb	r2, [r3, #12]
}
 8004d1c:	bf00      	nop
 8004d1e:	3708      	adds	r7, #8
 8004d20:	46bd      	mov	sp, r7
 8004d22:	bd80      	pop	{r7, pc}
 8004d24:	200036f0 	.word	0x200036f0

08004d28 <OsSwtmrUpdate>:

STATIC INLINE VOID OsSwtmrUpdate(LosSwtmrCB *swtmr)
{
 8004d28:	b580      	push	{r7, lr}
 8004d2a:	b082      	sub	sp, #8
 8004d2c:	af00      	add	r7, sp, #0
 8004d2e:	6078      	str	r0, [r7, #4]
    if (swtmr->mode == LOS_SWTMR_MODE_ONCE) {
 8004d30:	687b      	ldr	r3, [r7, #4]
 8004d32:	7b5b      	ldrb	r3, [r3, #13]
 8004d34:	2b00      	cmp	r3, #0
 8004d36:	d117      	bne.n	8004d68 <OsSwtmrUpdate+0x40>
        OsSwtmrDelete(swtmr);
 8004d38:	6878      	ldr	r0, [r7, #4]
 8004d3a:	f7ff ffe3 	bl	8004d04 <OsSwtmrDelete>

        if (swtmr->timerId < (OS_SWTMR_MAX_TIMERID - KERNEL_SWTMR_LIMIT)) {
 8004d3e:	687b      	ldr	r3, [r7, #4]
 8004d40:	8a1b      	ldrh	r3, [r3, #16]
 8004d42:	f64f 72df 	movw	r2, #65503	; 0xffdf
 8004d46:	4293      	cmp	r3, r2
 8004d48:	d806      	bhi.n	8004d58 <OsSwtmrUpdate+0x30>
            swtmr->timerId += KERNEL_SWTMR_LIMIT;
 8004d4a:	687b      	ldr	r3, [r7, #4]
 8004d4c:	8a1b      	ldrh	r3, [r3, #16]
 8004d4e:	3310      	adds	r3, #16
 8004d50:	b29a      	uxth	r2, r3
 8004d52:	687b      	ldr	r3, [r7, #4]
 8004d54:	821a      	strh	r2, [r3, #16]
        swtmr->state = OS_SWTMR_STATUS_CREATED;
    } else {
        swtmr->overrun++;
        OsSwtmrStart(swtmr);
    }
}
 8004d56:	e018      	b.n	8004d8a <OsSwtmrUpdate+0x62>
            swtmr->timerId %= KERNEL_SWTMR_LIMIT;
 8004d58:	687b      	ldr	r3, [r7, #4]
 8004d5a:	8a1b      	ldrh	r3, [r3, #16]
 8004d5c:	f003 030f 	and.w	r3, r3, #15
 8004d60:	b29a      	uxth	r2, r3
 8004d62:	687b      	ldr	r3, [r7, #4]
 8004d64:	821a      	strh	r2, [r3, #16]
}
 8004d66:	e010      	b.n	8004d8a <OsSwtmrUpdate+0x62>
    } else if (swtmr->mode == LOS_SWTMR_MODE_NO_SELFDELETE) {
 8004d68:	687b      	ldr	r3, [r7, #4]
 8004d6a:	7b5b      	ldrb	r3, [r3, #13]
 8004d6c:	2b02      	cmp	r3, #2
 8004d6e:	d103      	bne.n	8004d78 <OsSwtmrUpdate+0x50>
        swtmr->state = OS_SWTMR_STATUS_CREATED;
 8004d70:	687b      	ldr	r3, [r7, #4]
 8004d72:	2201      	movs	r2, #1
 8004d74:	731a      	strb	r2, [r3, #12]
}
 8004d76:	e008      	b.n	8004d8a <OsSwtmrUpdate+0x62>
        swtmr->overrun++;
 8004d78:	687b      	ldr	r3, [r7, #4]
 8004d7a:	7b9b      	ldrb	r3, [r3, #14]
 8004d7c:	3301      	adds	r3, #1
 8004d7e:	b2da      	uxtb	r2, r3
 8004d80:	687b      	ldr	r3, [r7, #4]
 8004d82:	739a      	strb	r2, [r3, #14]
        OsSwtmrStart(swtmr);
 8004d84:	6878      	ldr	r0, [r7, #4]
 8004d86:	f7ff ff8f 	bl	8004ca8 <OsSwtmrStart>
}
 8004d8a:	bf00      	nop
 8004d8c:	3708      	adds	r7, #8
 8004d8e:	46bd      	mov	sp, r7
 8004d90:	bd80      	pop	{r7, pc}
	...

08004d94 <OsSwtmrTask>:

#ifndef LOSCFG_BASE_CORE_SWTMR_IN_ISR
LITE_OS_SEC_TEXT VOID OsSwtmrTask(VOID)
{
 8004d94:	b580      	push	{r7, lr}
 8004d96:	b088      	sub	sp, #32
 8004d98:	af00      	add	r7, sp, #0
 8004d9a:	4b18      	ldr	r3, [pc, #96]	; (8004dfc <OsSwtmrTask+0x68>)
 8004d9c:	681b      	ldr	r3, [r3, #0]
 8004d9e:	61fb      	str	r3, [r7, #28]
 8004da0:	f04f 0300 	mov.w	r3, #0
    UINT32 ret, swtmrHandlerQueue;
    SwtmrHandlerItemPtr swtmrHandler = NULL;
 8004da4:	2300      	movs	r3, #0
 8004da6:	607b      	str	r3, [r7, #4]
    UINT32 readSize;
    readSize = sizeof(CHAR *);
 8004da8:	2304      	movs	r3, #4
 8004daa:	60bb      	str	r3, [r7, #8]

    swtmrHandlerQueue = OsPercpuGet()->swtmrHandlerQueue;
 8004dac:	f7ff ff6c 	bl	8004c88 <OsPercpuGet>
 8004db0:	4603      	mov	r3, r0
 8004db2:	699b      	ldr	r3, [r3, #24]
 8004db4:	60fb      	str	r3, [r7, #12]
    for (;;) {
        ret = LOS_QueueReadCopy(swtmrHandlerQueue, &swtmrHandler, &readSize, LOS_WAIT_FOREVER);
 8004db6:	f107 0208 	add.w	r2, r7, #8
 8004dba:	1d39      	adds	r1, r7, #4
 8004dbc:	f04f 33ff 	mov.w	r3, #4294967295
 8004dc0:	68f8      	ldr	r0, [r7, #12]
 8004dc2:	f005 fc11 	bl	800a5e8 <LOS_QueueReadCopy>
 8004dc6:	6138      	str	r0, [r7, #16]
        if ((ret == LOS_OK) && (readSize == sizeof(CHAR *))) {
 8004dc8:	693b      	ldr	r3, [r7, #16]
 8004dca:	2b00      	cmp	r3, #0
 8004dcc:	d1f3      	bne.n	8004db6 <OsSwtmrTask+0x22>
 8004dce:	68bb      	ldr	r3, [r7, #8]
 8004dd0:	2b04      	cmp	r3, #4
 8004dd2:	d1f0      	bne.n	8004db6 <OsSwtmrTask+0x22>
            SWTMR_PROC_FUNC handler = swtmrHandler->handler;
 8004dd4:	687b      	ldr	r3, [r7, #4]
 8004dd6:	681b      	ldr	r3, [r3, #0]
 8004dd8:	617b      	str	r3, [r7, #20]
            UINTPTR arg = swtmrHandler->arg;
 8004dda:	687b      	ldr	r3, [r7, #4]
 8004ddc:	685b      	ldr	r3, [r3, #4]
 8004dde:	61bb      	str	r3, [r7, #24]
            (VOID)LOS_MemFree(m_aucSysMem0, swtmrHandler);
 8004de0:	4b07      	ldr	r3, [pc, #28]	; (8004e00 <OsSwtmrTask+0x6c>)
 8004de2:	681b      	ldr	r3, [r3, #0]
 8004de4:	687a      	ldr	r2, [r7, #4]
 8004de6:	4611      	mov	r1, r2
 8004de8:	4618      	mov	r0, r3
 8004dea:	f003 fe95 	bl	8008b18 <LOS_MemFree>
            if (handler != NULL) {
 8004dee:	697b      	ldr	r3, [r7, #20]
 8004df0:	2b00      	cmp	r3, #0
 8004df2:	d0e0      	beq.n	8004db6 <OsSwtmrTask+0x22>
                handler(arg);
 8004df4:	697b      	ldr	r3, [r7, #20]
 8004df6:	69b8      	ldr	r0, [r7, #24]
 8004df8:	4798      	blx	r3
        ret = LOS_QueueReadCopy(swtmrHandlerQueue, &swtmrHandler, &readSize, LOS_WAIT_FOREVER);
 8004dfa:	e7dc      	b.n	8004db6 <OsSwtmrTask+0x22>
 8004dfc:	080202e0 	.word	0x080202e0
 8004e00:	200021b4 	.word	0x200021b4

08004e04 <OsSwtmrTaskCreate>:
    return FALSE;
}
#endif

LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrTaskCreate(VOID)
{
 8004e04:	b580      	push	{r7, lr}
 8004e06:	b08e      	sub	sp, #56	; 0x38
 8004e08:	af00      	add	r7, sp, #0
 8004e0a:	4b2a      	ldr	r3, [pc, #168]	; (8004eb4 <OsSwtmrTaskCreate+0xb0>)
 8004e0c:	681b      	ldr	r3, [r3, #0]
 8004e0e:	637b      	str	r3, [r7, #52]	; 0x34
 8004e10:	f04f 0300 	mov.w	r3, #0
    UINT32 ret, swtmrTaskId;
    TSK_INIT_PARAM_S swtmrTask;
    UINT32 cpuid = ArchCurrCpuid();
 8004e14:	f7ff fef0 	bl	8004bf8 <ArchCurrCpuid>
 8004e18:	60b8      	str	r0, [r7, #8]

    (VOID)memset_s(&swtmrTask, sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
 8004e1a:	f107 0010 	add.w	r0, r7, #16
 8004e1e:	2324      	movs	r3, #36	; 0x24
 8004e20:	2200      	movs	r2, #0
 8004e22:	2124      	movs	r1, #36	; 0x24
 8004e24:	f011 f932 	bl	801608c <memset_s>
    swtmrTask.pfnTaskEntry = (TSK_ENTRY_FUNC)OsSwtmrTask;
 8004e28:	4b23      	ldr	r3, [pc, #140]	; (8004eb8 <OsSwtmrTaskCreate+0xb4>)
 8004e2a:	613b      	str	r3, [r7, #16]
    swtmrTask.uwStackSize = KERNEL_TSK_SWTMR_STACK_SIZE;
 8004e2c:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8004e30:	62bb      	str	r3, [r7, #40]	; 0x28
    swtmrTask.pcName = "Swt_Task";
 8004e32:	4b22      	ldr	r3, [pc, #136]	; (8004ebc <OsSwtmrTaskCreate+0xb8>)
 8004e34:	62fb      	str	r3, [r7, #44]	; 0x2c
    swtmrTask.usTaskPrio = 0;
 8004e36:	2300      	movs	r3, #0
 8004e38:	82bb      	strh	r3, [r7, #20]
    swtmrTask.uwResved = LOS_TASK_STATUS_DETACHED;
 8004e3a:	f44f 7380 	mov.w	r3, #256	; 0x100
 8004e3e:	633b      	str	r3, [r7, #48]	; 0x30
#ifdef LOSCFG_KERNEL_SMP
    swtmrTask.usCpuAffiMask = CPUID_TO_AFFI_MASK(cpuid);
#endif
    ret = LOS_TaskCreate(&swtmrTaskId, &swtmrTask);
 8004e40:	f107 0210 	add.w	r2, r7, #16
 8004e44:	1d3b      	adds	r3, r7, #4
 8004e46:	4611      	mov	r1, r2
 8004e48:	4618      	mov	r0, r3
 8004e4a:	f7fe fd75 	bl	8003938 <LOS_TaskCreate>
 8004e4e:	60f8      	str	r0, [r7, #12]
    if (ret == LOS_OK) {
 8004e50:	68fb      	ldr	r3, [r7, #12]
 8004e52:	2b00      	cmp	r3, #0
 8004e54:	d122      	bne.n	8004e9c <OsSwtmrTaskCreate+0x98>
        g_percpu[cpuid].swtmrTaskId = swtmrTaskId;
 8004e56:	6879      	ldr	r1, [r7, #4]
 8004e58:	4819      	ldr	r0, [pc, #100]	; (8004ec0 <OsSwtmrTaskCreate+0xbc>)
 8004e5a:	68ba      	ldr	r2, [r7, #8]
 8004e5c:	4613      	mov	r3, r2
 8004e5e:	00db      	lsls	r3, r3, #3
 8004e60:	4413      	add	r3, r2
 8004e62:	009b      	lsls	r3, r3, #2
 8004e64:	4403      	add	r3, r0
 8004e66:	331c      	adds	r3, #28
 8004e68:	6019      	str	r1, [r3, #0]
        OS_TCB_FROM_TID(swtmrTaskId)->taskFlags |= OS_TASK_FLAG_SYSTEM;
 8004e6a:	4b16      	ldr	r3, [pc, #88]	; (8004ec4 <OsSwtmrTaskCreate+0xc0>)
 8004e6c:	6819      	ldr	r1, [r3, #0]
 8004e6e:	687a      	ldr	r2, [r7, #4]
 8004e70:	4613      	mov	r3, r2
 8004e72:	009b      	lsls	r3, r3, #2
 8004e74:	4413      	add	r3, r2
 8004e76:	015b      	lsls	r3, r3, #5
 8004e78:	440b      	add	r3, r1
 8004e7a:	689b      	ldr	r3, [r3, #8]
 8004e7c:	f3c3 011e 	ubfx	r1, r3, #0, #31
 8004e80:	4b10      	ldr	r3, [pc, #64]	; (8004ec4 <OsSwtmrTaskCreate+0xc0>)
 8004e82:	6818      	ldr	r0, [r3, #0]
 8004e84:	687a      	ldr	r2, [r7, #4]
 8004e86:	4613      	mov	r3, r2
 8004e88:	009b      	lsls	r3, r3, #2
 8004e8a:	4413      	add	r3, r2
 8004e8c:	015b      	lsls	r3, r3, #5
 8004e8e:	18c2      	adds	r2, r0, r3
 8004e90:	f041 0102 	orr.w	r1, r1, #2
 8004e94:	6893      	ldr	r3, [r2, #8]
 8004e96:	f361 031e 	bfi	r3, r1, #0, #31
 8004e9a:	6093      	str	r3, [r2, #8]
    }

    return ret;
 8004e9c:	68fb      	ldr	r3, [r7, #12]
}
 8004e9e:	4a05      	ldr	r2, [pc, #20]	; (8004eb4 <OsSwtmrTaskCreate+0xb0>)
 8004ea0:	6811      	ldr	r1, [r2, #0]
 8004ea2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004ea4:	4051      	eors	r1, r2
 8004ea6:	d001      	beq.n	8004eac <OsSwtmrTaskCreate+0xa8>
 8004ea8:	f7ff fa9e 	bl	80043e8 <__stack_chk_fail>
 8004eac:	4618      	mov	r0, r3
 8004eae:	3738      	adds	r7, #56	; 0x38
 8004eb0:	46bd      	mov	sp, r7
 8004eb2:	bd80      	pop	{r7, pc}
 8004eb4:	080202f0 	.word	0x080202f0
 8004eb8:	08004d95 	.word	0x08004d95
 8004ebc:	080202e4 	.word	0x080202e4
 8004ec0:	200036fc 	.word	0x200036fc
 8004ec4:	200036c4 	.word	0x200036c4

08004ec8 <OsSwtmrInit>:
#endif

LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrInit(VOID)
{
 8004ec8:	b580      	push	{r7, lr}
 8004eca:	b088      	sub	sp, #32
 8004ecc:	af02      	add	r7, sp, #8
    UINT32 size;
    UINT16 index;
    UINT32 ret;
    LosSwtmrCB *swtmr = NULL;
 8004ece:	2300      	movs	r3, #0
 8004ed0:	60bb      	str	r3, [r7, #8]
    UINT32 cpuid = ArchCurrCpuid();
 8004ed2:	f7ff fe91 	bl	8004bf8 <ArchCurrCpuid>
 8004ed6:	60f8      	str	r0, [r7, #12]
    if (cpuid == 0) {
 8004ed8:	68fb      	ldr	r3, [r7, #12]
 8004eda:	2b00      	cmp	r3, #0
 8004edc:	d12e      	bne.n	8004f3c <OsSwtmrInit+0x74>
        size = sizeof(LosSwtmrCB) * KERNEL_SWTMR_LIMIT;
 8004ede:	f44f 7310 	mov.w	r3, #576	; 0x240
 8004ee2:	613b      	str	r3, [r7, #16]
        swtmr = (LosSwtmrCB *)LOS_MemAlloc(m_aucSysMem0, size); /* system resident resource */
 8004ee4:	4b2f      	ldr	r3, [pc, #188]	; (8004fa4 <OsSwtmrInit+0xdc>)
 8004ee6:	681b      	ldr	r3, [r3, #0]
 8004ee8:	6939      	ldr	r1, [r7, #16]
 8004eea:	4618      	mov	r0, r3
 8004eec:	f003 fd5c 	bl	80089a8 <LOS_MemAlloc>
 8004ef0:	60b8      	str	r0, [r7, #8]
        if (swtmr == NULL) {
 8004ef2:	68bb      	ldr	r3, [r7, #8]
 8004ef4:	2b00      	cmp	r3, #0
 8004ef6:	d101      	bne.n	8004efc <OsSwtmrInit+0x34>
            return LOS_ERRNO_SWTMR_NO_MEMORY;
 8004ef8:	4b2b      	ldr	r3, [pc, #172]	; (8004fa8 <OsSwtmrInit+0xe0>)
 8004efa:	e04e      	b.n	8004f9a <OsSwtmrInit+0xd2>
        }

        (VOID)memset_s(swtmr, size, 0, size);
 8004efc:	693b      	ldr	r3, [r7, #16]
 8004efe:	2200      	movs	r2, #0
 8004f00:	6939      	ldr	r1, [r7, #16]
 8004f02:	68b8      	ldr	r0, [r7, #8]
 8004f04:	f011 f8c2 	bl	801608c <memset_s>
        g_swtmrCBArray = swtmr;
 8004f08:	4a28      	ldr	r2, [pc, #160]	; (8004fac <OsSwtmrInit+0xe4>)
 8004f0a:	68bb      	ldr	r3, [r7, #8]
 8004f0c:	6013      	str	r3, [r2, #0]
        LOS_ListInit(&g_swtmrFreeList);
 8004f0e:	4828      	ldr	r0, [pc, #160]	; (8004fb0 <OsSwtmrInit+0xe8>)
 8004f10:	f7ff fe0e 	bl	8004b30 <LOS_ListInit>
        for (index = 0; index < KERNEL_SWTMR_LIMIT; index++, swtmr++) {
 8004f14:	2300      	movs	r3, #0
 8004f16:	80fb      	strh	r3, [r7, #6]
 8004f18:	e00d      	b.n	8004f36 <OsSwtmrInit+0x6e>
            swtmr->timerId = index;
 8004f1a:	68bb      	ldr	r3, [r7, #8]
 8004f1c:	88fa      	ldrh	r2, [r7, #6]
 8004f1e:	821a      	strh	r2, [r3, #16]
            LOS_ListTailInsert(&g_swtmrFreeList, &swtmr->sortList.sortLinkNode);
 8004f20:	68bb      	ldr	r3, [r7, #8]
 8004f22:	4619      	mov	r1, r3
 8004f24:	4822      	ldr	r0, [pc, #136]	; (8004fb0 <OsSwtmrInit+0xe8>)
 8004f26:	f7ff fe2c 	bl	8004b82 <LOS_ListTailInsert>
        for (index = 0; index < KERNEL_SWTMR_LIMIT; index++, swtmr++) {
 8004f2a:	88fb      	ldrh	r3, [r7, #6]
 8004f2c:	3301      	adds	r3, #1
 8004f2e:	80fb      	strh	r3, [r7, #6]
 8004f30:	68bb      	ldr	r3, [r7, #8]
 8004f32:	3324      	adds	r3, #36	; 0x24
 8004f34:	60bb      	str	r3, [r7, #8]
 8004f36:	88fb      	ldrh	r3, [r7, #6]
 8004f38:	2b0f      	cmp	r3, #15
 8004f3a:	d9ee      	bls.n	8004f1a <OsSwtmrInit+0x52>
        }
    }

#ifndef LOSCFG_BASE_CORE_SWTMR_IN_ISR
    ret = LOS_QueueCreate(NULL, OS_SWTMR_HANDLE_QUEUE_SIZE, &g_percpu[cpuid].swtmrHandlerQueue, 0, sizeof(CHAR *));
 8004f3c:	68fa      	ldr	r2, [r7, #12]
 8004f3e:	4613      	mov	r3, r2
 8004f40:	00db      	lsls	r3, r3, #3
 8004f42:	4413      	add	r3, r2
 8004f44:	009b      	lsls	r3, r3, #2
 8004f46:	3318      	adds	r3, #24
 8004f48:	4a1a      	ldr	r2, [pc, #104]	; (8004fb4 <OsSwtmrInit+0xec>)
 8004f4a:	441a      	add	r2, r3
 8004f4c:	2304      	movs	r3, #4
 8004f4e:	9300      	str	r3, [sp, #0]
 8004f50:	2300      	movs	r3, #0
 8004f52:	2110      	movs	r1, #16
 8004f54:	2000      	movs	r0, #0
 8004f56:	f005 f829 	bl	8009fac <LOS_QueueCreate>
 8004f5a:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 8004f5c:	697b      	ldr	r3, [r7, #20]
 8004f5e:	2b00      	cmp	r3, #0
 8004f60:	d001      	beq.n	8004f66 <OsSwtmrInit+0x9e>
        return LOS_ERRNO_SWTMR_QUEUE_CREATE_FAILED;
 8004f62:	4b15      	ldr	r3, [pc, #84]	; (8004fb8 <OsSwtmrInit+0xf0>)
 8004f64:	e019      	b.n	8004f9a <OsSwtmrInit+0xd2>
    }

    ret = OsSwtmrTaskCreate();
 8004f66:	f7ff ff4d 	bl	8004e04 <OsSwtmrTaskCreate>
 8004f6a:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 8004f6c:	697b      	ldr	r3, [r7, #20]
 8004f6e:	2b00      	cmp	r3, #0
 8004f70:	d001      	beq.n	8004f76 <OsSwtmrInit+0xae>
        return LOS_ERRNO_SWTMR_TASK_CREATE_FAILED;
 8004f72:	4b12      	ldr	r3, [pc, #72]	; (8004fbc <OsSwtmrInit+0xf4>)
 8004f74:	e011      	b.n	8004f9a <OsSwtmrInit+0xd2>
    }
#endif

    ret = OsSortLinkInit(&g_percpu[cpuid].swtmrSortLink);
 8004f76:	68fa      	ldr	r2, [r7, #12]
 8004f78:	4613      	mov	r3, r2
 8004f7a:	00db      	lsls	r3, r3, #3
 8004f7c:	4413      	add	r3, r2
 8004f7e:	009b      	lsls	r3, r3, #2
 8004f80:	3308      	adds	r3, #8
 8004f82:	4a0c      	ldr	r2, [pc, #48]	; (8004fb4 <OsSwtmrInit+0xec>)
 8004f84:	4413      	add	r3, r2
 8004f86:	4618      	mov	r0, r3
 8004f88:	f004 fb8a 	bl	80096a0 <OsSortLinkInit>
 8004f8c:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 8004f8e:	697b      	ldr	r3, [r7, #20]
 8004f90:	2b00      	cmp	r3, #0
 8004f92:	d001      	beq.n	8004f98 <OsSwtmrInit+0xd0>
        return LOS_ERRNO_SWTMR_SORTLINK_CREATE_FAILED;
 8004f94:	4b0a      	ldr	r3, [pc, #40]	; (8004fc0 <OsSwtmrInit+0xf8>)
 8004f96:	e000      	b.n	8004f9a <OsSwtmrInit+0xd2>
    }

    return LOS_OK;
 8004f98:	2300      	movs	r3, #0
}
 8004f9a:	4618      	mov	r0, r3
 8004f9c:	3718      	adds	r7, #24
 8004f9e:	46bd      	mov	sp, r7
 8004fa0:	bd80      	pop	{r7, pc}
 8004fa2:	bf00      	nop
 8004fa4:	200021b4 	.word	0x200021b4
 8004fa8:	02000307 	.word	0x02000307
 8004fac:	20000794 	.word	0x20000794
 8004fb0:	200036f0 	.word	0x200036f0
 8004fb4:	200036fc 	.word	0x200036fc
 8004fb8:	0200030b 	.word	0x0200030b
 8004fbc:	0200030c 	.word	0x0200030c
 8004fc0:	02000311 	.word	0x02000311

08004fc4 <OsSwtmrScan>:
/*
 * Description: Tick interrupt interface module of software timer
 * Return     : LOS_OK on success or error code on failure
 */
LITE_OS_SEC_TEXT VOID OsSwtmrScan(VOID)
{
 8004fc4:	b590      	push	{r4, r7, lr}
 8004fc6:	b08b      	sub	sp, #44	; 0x2c
 8004fc8:	af00      	add	r7, sp, #0
 8004fca:	4b53      	ldr	r3, [pc, #332]	; (8005118 <OsSwtmrScan+0x154>)
 8004fcc:	681b      	ldr	r3, [r3, #0]
 8004fce:	627b      	str	r3, [r7, #36]	; 0x24
 8004fd0:	f04f 0300 	mov.w	r3, #0
    SortLinkList *sortList = NULL;
 8004fd4:	2300      	movs	r3, #0
 8004fd6:	60bb      	str	r3, [r7, #8]
    LosSwtmrCB *swtmr = NULL;
 8004fd8:	2300      	movs	r3, #0
 8004fda:	60fb      	str	r3, [r7, #12]
    LOS_DL_LIST *listObject = NULL;
 8004fdc:	2300      	movs	r3, #0
 8004fde:	613b      	str	r3, [r7, #16]
    SortLinkAttribute* swtmrSortLink = &OsPercpuGet()->swtmrSortLink;
 8004fe0:	f7ff fe52 	bl	8004c88 <OsPercpuGet>
 8004fe4:	4603      	mov	r3, r0
 8004fe6:	3308      	adds	r3, #8
 8004fe8:	617b      	str	r3, [r7, #20]

    SORTLINK_CURSOR_UPDATE(swtmrSortLink->cursor);
 8004fea:	697b      	ldr	r3, [r7, #20]
 8004fec:	889b      	ldrh	r3, [r3, #4]
 8004fee:	3301      	adds	r3, #1
 8004ff0:	b29b      	uxth	r3, r3
 8004ff2:	f003 0307 	and.w	r3, r3, #7
 8004ff6:	b29a      	uxth	r2, r3
 8004ff8:	697b      	ldr	r3, [r7, #20]
 8004ffa:	809a      	strh	r2, [r3, #4]
    SORTLINK_LISTOBJ_GET(listObject, swtmrSortLink);
 8004ffc:	697b      	ldr	r3, [r7, #20]
 8004ffe:	681a      	ldr	r2, [r3, #0]
 8005000:	697b      	ldr	r3, [r7, #20]
 8005002:	889b      	ldrh	r3, [r3, #4]
 8005004:	00db      	lsls	r3, r3, #3
 8005006:	4413      	add	r3, r2
 8005008:	613b      	str	r3, [r7, #16]

    /*
     * it needs to be carefully coped with, since the swtmr is in specific sortlink
     * while other cores still has the chance to process it, like stop the timer.
     */
    LOS_SpinLock(&g_swtmrSpin);
 800500a:	4844      	ldr	r0, [pc, #272]	; (800511c <OsSwtmrScan+0x158>)
 800500c:	f7ff fe0e 	bl	8004c2c <LOS_SpinLock>

    if (LOS_ListEmpty(listObject)) {
 8005010:	6938      	ldr	r0, [r7, #16]
 8005012:	f7ff fddf 	bl	8004bd4 <LOS_ListEmpty>
 8005016:	4603      	mov	r3, r0
 8005018:	2b00      	cmp	r3, #0
 800501a:	d003      	beq.n	8005024 <OsSwtmrScan+0x60>
        LOS_SpinUnlock(&g_swtmrSpin);
 800501c:	483f      	ldr	r0, [pc, #252]	; (800511c <OsSwtmrScan+0x158>)
 800501e:	f7ff fe0f 	bl	8004c40 <LOS_SpinUnlock>
        return;
 8005022:	e06e      	b.n	8005102 <OsSwtmrScan+0x13e>
    }
    sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 8005024:	693b      	ldr	r3, [r7, #16]
 8005026:	685b      	ldr	r3, [r3, #4]
 8005028:	60bb      	str	r3, [r7, #8]
    ROLLNUM_DEC(sortList->idxRollNum);
 800502a:	68bb      	ldr	r3, [r7, #8]
 800502c:	689b      	ldr	r3, [r3, #8]
 800502e:	1e5a      	subs	r2, r3, #1
 8005030:	68bb      	ldr	r3, [r7, #8]
 8005032:	609a      	str	r2, [r3, #8]

    while (ROLLNUM(sortList->idxRollNum) == 0) {
 8005034:	e05a      	b.n	80050ec <OsSwtmrScan+0x128>
        sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 8005036:	693b      	ldr	r3, [r7, #16]
 8005038:	685b      	ldr	r3, [r3, #4]
 800503a:	60bb      	str	r3, [r7, #8]
        LOS_ListDelete(&sortList->sortLinkNode);
 800503c:	68bb      	ldr	r3, [r7, #8]
 800503e:	4618      	mov	r0, r3
 8005040:	f7ff fdae 	bl	8004ba0 <LOS_ListDelete>
        swtmr = LOS_DL_LIST_ENTRY(sortList, LosSwtmrCB, sortList);
 8005044:	68bb      	ldr	r3, [r7, #8]
 8005046:	60fb      	str	r3, [r7, #12]

#ifndef LOSCFG_BASE_CORE_SWTMR_IN_ISR
        LOS_TRACE(SWTMR_EXPIRED, swtmr->timerId);
 8005048:	2300      	movs	r3, #0
 800504a:	61fb      	str	r3, [r7, #28]
 800504c:	68fb      	ldr	r3, [r7, #12]
 800504e:	8a1b      	ldrh	r3, [r3, #16]
 8005050:	623b      	str	r3, [r7, #32]
 8005052:	2302      	movs	r3, #2
 8005054:	61bb      	str	r3, [r7, #24]
 8005056:	69bb      	ldr	r3, [r7, #24]
 8005058:	2b01      	cmp	r3, #1
 800505a:	d915      	bls.n	8005088 <OsSwtmrScan+0xc4>
 800505c:	4b30      	ldr	r3, [pc, #192]	; (8005120 <OsSwtmrScan+0x15c>)
 800505e:	681b      	ldr	r3, [r3, #0]
 8005060:	2b00      	cmp	r3, #0
 8005062:	d011      	beq.n	8005088 <OsSwtmrScan+0xc4>
 8005064:	4b2e      	ldr	r3, [pc, #184]	; (8005120 <OsSwtmrScan+0x15c>)
 8005066:	681c      	ldr	r4, [r3, #0]
 8005068:	6a39      	ldr	r1, [r7, #32]
 800506a:	69bb      	ldr	r3, [r7, #24]
 800506c:	2b02      	cmp	r3, #2
 800506e:	d904      	bls.n	800507a <OsSwtmrScan+0xb6>
 8005070:	f107 031c 	add.w	r3, r7, #28
 8005074:	f103 0208 	add.w	r2, r3, #8
 8005078:	e000      	b.n	800507c <OsSwtmrScan+0xb8>
 800507a:	2200      	movs	r2, #0
 800507c:	69bb      	ldr	r3, [r7, #24]
 800507e:	b29b      	uxth	r3, r3
 8005080:	3b02      	subs	r3, #2
 8005082:	b29b      	uxth	r3, r3
 8005084:	2084      	movs	r0, #132	; 0x84
 8005086:	47a0      	blx	r4
        SwtmrHandlerItemPtr swtmrHandler = (SwtmrHandlerItemPtr)LOS_MemAlloc(m_aucSysMem0, sizeof(SwtmrHandlerItem));
 8005088:	4b26      	ldr	r3, [pc, #152]	; (8005124 <OsSwtmrScan+0x160>)
 800508a:	681b      	ldr	r3, [r3, #0]
 800508c:	2108      	movs	r1, #8
 800508e:	4618      	mov	r0, r3
 8005090:	f003 fc8a 	bl	80089a8 <LOS_MemAlloc>
 8005094:	4603      	mov	r3, r0
 8005096:	607b      	str	r3, [r7, #4]
        if (swtmrHandler != NULL) {
 8005098:	687b      	ldr	r3, [r7, #4]
 800509a:	2b00      	cmp	r3, #0
 800509c:	d01a      	beq.n	80050d4 <OsSwtmrScan+0x110>
            swtmrHandler->handler = swtmr->handler;
 800509e:	687b      	ldr	r3, [r7, #4]
 80050a0:	68fa      	ldr	r2, [r7, #12]
 80050a2:	6a12      	ldr	r2, [r2, #32]
 80050a4:	601a      	str	r2, [r3, #0]
            swtmrHandler->arg = swtmr->arg;
 80050a6:	687b      	ldr	r3, [r7, #4]
 80050a8:	68fa      	ldr	r2, [r7, #12]
 80050aa:	69d2      	ldr	r2, [r2, #28]
 80050ac:	605a      	str	r2, [r3, #4]
            if (LOS_QueueWriteCopy(OsPercpuGet()->swtmrHandlerQueue, &swtmrHandler,
 80050ae:	f7ff fdeb 	bl	8004c88 <OsPercpuGet>
 80050b2:	4603      	mov	r3, r0
 80050b4:	6998      	ldr	r0, [r3, #24]
 80050b6:	1d39      	adds	r1, r7, #4
 80050b8:	2300      	movs	r3, #0
 80050ba:	2204      	movs	r2, #4
 80050bc:	f005 fab6 	bl	800a62c <LOS_QueueWriteCopy>
 80050c0:	4603      	mov	r3, r0
 80050c2:	2b00      	cmp	r3, #0
 80050c4:	d006      	beq.n	80050d4 <OsSwtmrScan+0x110>
                                   sizeof(CHAR *), LOS_NO_WAIT) != LOS_OK) {
                (VOID)LOS_MemFree(m_aucSysMem0, swtmrHandler);
 80050c6:	4b17      	ldr	r3, [pc, #92]	; (8005124 <OsSwtmrScan+0x160>)
 80050c8:	681b      	ldr	r3, [r3, #0]
 80050ca:	687a      	ldr	r2, [r7, #4]
 80050cc:	4611      	mov	r1, r2
 80050ce:	4618      	mov	r0, r3
 80050d0:	f003 fd22 	bl	8008b18 <LOS_MemFree>
            }
        }
        OsSwtmrUpdate(swtmr);
 80050d4:	68f8      	ldr	r0, [r7, #12]
 80050d6:	f7ff fe27 	bl	8004d28 <OsSwtmrUpdate>

            LOS_SpinLock(&g_swtmrSpin);
        }
#endif

        if (LOS_ListEmpty(listObject)) {
 80050da:	6938      	ldr	r0, [r7, #16]
 80050dc:	f7ff fd7a 	bl	8004bd4 <LOS_ListEmpty>
 80050e0:	4603      	mov	r3, r0
 80050e2:	2b00      	cmp	r3, #0
 80050e4:	d109      	bne.n	80050fa <OsSwtmrScan+0x136>
            break;
        }

        sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 80050e6:	693b      	ldr	r3, [r7, #16]
 80050e8:	685b      	ldr	r3, [r3, #4]
 80050ea:	60bb      	str	r3, [r7, #8]
    while (ROLLNUM(sortList->idxRollNum) == 0) {
 80050ec:	68bb      	ldr	r3, [r7, #8]
 80050ee:	689b      	ldr	r3, [r3, #8]
 80050f0:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80050f4:	2b00      	cmp	r3, #0
 80050f6:	d09e      	beq.n	8005036 <OsSwtmrScan+0x72>
 80050f8:	e000      	b.n	80050fc <OsSwtmrScan+0x138>
            break;
 80050fa:	bf00      	nop
    }

    LOS_SpinUnlock(&g_swtmrSpin);
 80050fc:	4807      	ldr	r0, [pc, #28]	; (800511c <OsSwtmrScan+0x158>)
 80050fe:	f7ff fd9f 	bl	8004c40 <LOS_SpinUnlock>
}
 8005102:	4b05      	ldr	r3, [pc, #20]	; (8005118 <OsSwtmrScan+0x154>)
 8005104:	681a      	ldr	r2, [r3, #0]
 8005106:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005108:	405a      	eors	r2, r3
 800510a:	d001      	beq.n	8005110 <OsSwtmrScan+0x14c>
 800510c:	f7ff f96c 	bl	80043e8 <__stack_chk_fail>
 8005110:	372c      	adds	r7, #44	; 0x2c
 8005112:	46bd      	mov	sp, r7
 8005114:	bd90      	pop	{r4, r7, pc}
 8005116:	bf00      	nop
 8005118:	080202f4 	.word	0x080202f4
 800511c:	20000798 	.word	0x20000798
 8005120:	2000075c 	.word	0x2000075c
 8005124:	200021b4 	.word	0x200021b4

08005128 <OsSwtmrStop>:
/*
 * Description: Stop of Software Timer interface
 * Input      : swtmr --- the software timer control handler
 */
LITE_OS_SEC_TEXT STATIC VOID OsSwtmrStop(LosSwtmrCB *swtmr)
{
 8005128:	b580      	push	{r7, lr}
 800512a:	b084      	sub	sp, #16
 800512c:	af00      	add	r7, sp, #0
 800512e:	6078      	str	r0, [r7, #4]
    SortLinkAttribute *sortLinkHeader = NULL;
 8005130:	2300      	movs	r3, #0
 8005132:	60fb      	str	r3, [r7, #12]
     * the timer is running on the specific processor,
     * we need delete the timer from that processor's sortlink.
     */
    sortLinkHeader = &g_percpu[swtmr->cpuid].swtmrSortLink;
#else
    sortLinkHeader = &g_percpu[0].swtmrSortLink;
 8005134:	4b08      	ldr	r3, [pc, #32]	; (8005158 <OsSwtmrStop+0x30>)
 8005136:	60fb      	str	r3, [r7, #12]
#endif
    OsDeleteSortLink(sortLinkHeader, &swtmr->sortList);
 8005138:	687b      	ldr	r3, [r7, #4]
 800513a:	4619      	mov	r1, r3
 800513c:	68f8      	ldr	r0, [r7, #12]
 800513e:	f004 fb8f 	bl	8009860 <OsDeleteSortLink>

    swtmr->state = OS_SWTMR_STATUS_CREATED;
 8005142:	687b      	ldr	r3, [r7, #4]
 8005144:	2201      	movs	r2, #1
 8005146:	731a      	strb	r2, [r3, #12]
    swtmr->overrun = 0;
 8005148:	687b      	ldr	r3, [r7, #4]
 800514a:	2200      	movs	r2, #0
 800514c:	739a      	strb	r2, [r3, #14]
}
 800514e:	bf00      	nop
 8005150:	3710      	adds	r7, #16
 8005152:	46bd      	mov	sp, r7
 8005154:	bd80      	pop	{r7, pc}
 8005156:	bf00      	nop
 8005158:	20003704 	.word	0x20003704

0800515c <LOS_SwtmrCreate>:
LITE_OS_SEC_TEXT_INIT UINT32 LOS_SwtmrCreate(UINT32 interval,
                                             UINT8 mode,
                                             SWTMR_PROC_FUNC handler,
                                             UINT16 *swtmrId,
                                             UINTPTR arg)
{
 800515c:	b590      	push	{r4, r7, lr}
 800515e:	b08d      	sub	sp, #52	; 0x34
 8005160:	af00      	add	r7, sp, #0
 8005162:	60f8      	str	r0, [r7, #12]
 8005164:	607a      	str	r2, [r7, #4]
 8005166:	603b      	str	r3, [r7, #0]
 8005168:	460b      	mov	r3, r1
 800516a:	72fb      	strb	r3, [r7, #11]
 800516c:	4b46      	ldr	r3, [pc, #280]	; (8005288 <LOS_SwtmrCreate+0x12c>)
 800516e:	681b      	ldr	r3, [r3, #0]
 8005170:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005172:	f04f 0300 	mov.w	r3, #0
    LosSwtmrCB *swtmr = NULL;
 8005176:	2300      	movs	r3, #0
 8005178:	61bb      	str	r3, [r7, #24]
    UINT32 intSave;
    SortLinkList *sortList = NULL;
 800517a:	2300      	movs	r3, #0
 800517c:	61fb      	str	r3, [r7, #28]

    if (interval == 0) {
 800517e:	68fb      	ldr	r3, [r7, #12]
 8005180:	2b00      	cmp	r3, #0
 8005182:	d101      	bne.n	8005188 <LOS_SwtmrCreate+0x2c>
        return LOS_ERRNO_SWTMR_INTERVAL_NOT_SUITED;
 8005184:	4b41      	ldr	r3, [pc, #260]	; (800528c <LOS_SwtmrCreate+0x130>)
 8005186:	e073      	b.n	8005270 <LOS_SwtmrCreate+0x114>
    }

    if ((mode != LOS_SWTMR_MODE_ONCE) && (mode != LOS_SWTMR_MODE_PERIOD) &&
 8005188:	7afb      	ldrb	r3, [r7, #11]
 800518a:	2b00      	cmp	r3, #0
 800518c:	d007      	beq.n	800519e <LOS_SwtmrCreate+0x42>
 800518e:	7afb      	ldrb	r3, [r7, #11]
 8005190:	2b01      	cmp	r3, #1
 8005192:	d004      	beq.n	800519e <LOS_SwtmrCreate+0x42>
 8005194:	7afb      	ldrb	r3, [r7, #11]
 8005196:	2b02      	cmp	r3, #2
 8005198:	d001      	beq.n	800519e <LOS_SwtmrCreate+0x42>
        (mode != LOS_SWTMR_MODE_NO_SELFDELETE)) {
        return LOS_ERRNO_SWTMR_MODE_INVALID;
 800519a:	4b3d      	ldr	r3, [pc, #244]	; (8005290 <LOS_SwtmrCreate+0x134>)
 800519c:	e068      	b.n	8005270 <LOS_SwtmrCreate+0x114>
    }

    if (handler == NULL) {
 800519e:	687b      	ldr	r3, [r7, #4]
 80051a0:	2b00      	cmp	r3, #0
 80051a2:	d101      	bne.n	80051a8 <LOS_SwtmrCreate+0x4c>
        return LOS_ERRNO_SWTMR_PTR_NULL;
 80051a4:	4b3b      	ldr	r3, [pc, #236]	; (8005294 <LOS_SwtmrCreate+0x138>)
 80051a6:	e063      	b.n	8005270 <LOS_SwtmrCreate+0x114>
    }

    if (swtmrId == NULL) {
 80051a8:	683b      	ldr	r3, [r7, #0]
 80051aa:	2b00      	cmp	r3, #0
 80051ac:	d101      	bne.n	80051b2 <LOS_SwtmrCreate+0x56>
        return LOS_ERRNO_SWTMR_RET_PTR_NULL;
 80051ae:	4b3a      	ldr	r3, [pc, #232]	; (8005298 <LOS_SwtmrCreate+0x13c>)
 80051b0:	e05e      	b.n	8005270 <LOS_SwtmrCreate+0x114>
    }

    SWTMR_LOCK(intSave);
 80051b2:	f107 0314 	add.w	r3, r7, #20
 80051b6:	4619      	mov	r1, r3
 80051b8:	4838      	ldr	r0, [pc, #224]	; (800529c <LOS_SwtmrCreate+0x140>)
 80051ba:	f7ff fd4b 	bl	8004c54 <LOS_SpinLockSave>
    if (LOS_ListEmpty(&g_swtmrFreeList)) {
 80051be:	4838      	ldr	r0, [pc, #224]	; (80052a0 <LOS_SwtmrCreate+0x144>)
 80051c0:	f7ff fd08 	bl	8004bd4 <LOS_ListEmpty>
 80051c4:	4603      	mov	r3, r0
 80051c6:	2b00      	cmp	r3, #0
 80051c8:	d006      	beq.n	80051d8 <LOS_SwtmrCreate+0x7c>
        SWTMR_UNLOCK(intSave);
 80051ca:	697b      	ldr	r3, [r7, #20]
 80051cc:	4619      	mov	r1, r3
 80051ce:	4833      	ldr	r0, [pc, #204]	; (800529c <LOS_SwtmrCreate+0x140>)
 80051d0:	f7ff fd4e 	bl	8004c70 <LOS_SpinUnlockRestore>
        return LOS_ERRNO_SWTMR_MAXSIZE;
 80051d4:	4b33      	ldr	r3, [pc, #204]	; (80052a4 <LOS_SwtmrCreate+0x148>)
 80051d6:	e04b      	b.n	8005270 <LOS_SwtmrCreate+0x114>
    }

    sortList = LOS_DL_LIST_ENTRY(g_swtmrFreeList.pstNext, SortLinkList, sortLinkNode);
 80051d8:	4b31      	ldr	r3, [pc, #196]	; (80052a0 <LOS_SwtmrCreate+0x144>)
 80051da:	685b      	ldr	r3, [r3, #4]
 80051dc:	61fb      	str	r3, [r7, #28]
    swtmr = LOS_DL_LIST_ENTRY(sortList, LosSwtmrCB, sortList);
 80051de:	69fb      	ldr	r3, [r7, #28]
 80051e0:	61bb      	str	r3, [r7, #24]
    LOS_ListDelete(LOS_DL_LIST_FIRST(&g_swtmrFreeList));
 80051e2:	4b2f      	ldr	r3, [pc, #188]	; (80052a0 <LOS_SwtmrCreate+0x144>)
 80051e4:	685b      	ldr	r3, [r3, #4]
 80051e6:	4618      	mov	r0, r3
 80051e8:	f7ff fcda 	bl	8004ba0 <LOS_ListDelete>
    SWTMR_UNLOCK(intSave);
 80051ec:	697b      	ldr	r3, [r7, #20]
 80051ee:	4619      	mov	r1, r3
 80051f0:	482a      	ldr	r0, [pc, #168]	; (800529c <LOS_SwtmrCreate+0x140>)
 80051f2:	f7ff fd3d 	bl	8004c70 <LOS_SpinUnlockRestore>

    swtmr->handler = handler;
 80051f6:	69bb      	ldr	r3, [r7, #24]
 80051f8:	687a      	ldr	r2, [r7, #4]
 80051fa:	621a      	str	r2, [r3, #32]
    swtmr->mode = mode;
 80051fc:	69bb      	ldr	r3, [r7, #24]
 80051fe:	7afa      	ldrb	r2, [r7, #11]
 8005200:	735a      	strb	r2, [r3, #13]
    swtmr->overrun = 0;
 8005202:	69bb      	ldr	r3, [r7, #24]
 8005204:	2200      	movs	r2, #0
 8005206:	739a      	strb	r2, [r3, #14]
    swtmr->interval = interval;
 8005208:	69bb      	ldr	r3, [r7, #24]
 800520a:	68fa      	ldr	r2, [r7, #12]
 800520c:	615a      	str	r2, [r3, #20]
    swtmr->expiry = interval;
 800520e:	69bb      	ldr	r3, [r7, #24]
 8005210:	68fa      	ldr	r2, [r7, #12]
 8005212:	619a      	str	r2, [r3, #24]
    swtmr->arg = arg;
 8005214:	69bb      	ldr	r3, [r7, #24]
 8005216:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8005218:	61da      	str	r2, [r3, #28]
    swtmr->state = OS_SWTMR_STATUS_CREATED;
 800521a:	69bb      	ldr	r3, [r7, #24]
 800521c:	2201      	movs	r2, #1
 800521e:	731a      	strb	r2, [r3, #12]
    SET_SORTLIST_VALUE(&(swtmr->sortList), 0);
 8005220:	69bb      	ldr	r3, [r7, #24]
 8005222:	2200      	movs	r2, #0
 8005224:	609a      	str	r2, [r3, #8]
    *swtmrId = swtmr->timerId;
 8005226:	69bb      	ldr	r3, [r7, #24]
 8005228:	8a1a      	ldrh	r2, [r3, #16]
 800522a:	683b      	ldr	r3, [r7, #0]
 800522c:	801a      	strh	r2, [r3, #0]
    LOS_TRACE(SWTMR_CREATE, swtmr->timerId);
 800522e:	2300      	movs	r3, #0
 8005230:	627b      	str	r3, [r7, #36]	; 0x24
 8005232:	69bb      	ldr	r3, [r7, #24]
 8005234:	8a1b      	ldrh	r3, [r3, #16]
 8005236:	62bb      	str	r3, [r7, #40]	; 0x28
 8005238:	2302      	movs	r3, #2
 800523a:	623b      	str	r3, [r7, #32]
 800523c:	6a3b      	ldr	r3, [r7, #32]
 800523e:	2b01      	cmp	r3, #1
 8005240:	d915      	bls.n	800526e <LOS_SwtmrCreate+0x112>
 8005242:	4b19      	ldr	r3, [pc, #100]	; (80052a8 <LOS_SwtmrCreate+0x14c>)
 8005244:	681b      	ldr	r3, [r3, #0]
 8005246:	2b00      	cmp	r3, #0
 8005248:	d011      	beq.n	800526e <LOS_SwtmrCreate+0x112>
 800524a:	4b17      	ldr	r3, [pc, #92]	; (80052a8 <LOS_SwtmrCreate+0x14c>)
 800524c:	681c      	ldr	r4, [r3, #0]
 800524e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005250:	6a3b      	ldr	r3, [r7, #32]
 8005252:	2b02      	cmp	r3, #2
 8005254:	d904      	bls.n	8005260 <LOS_SwtmrCreate+0x104>
 8005256:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800525a:	f103 0208 	add.w	r2, r3, #8
 800525e:	e000      	b.n	8005262 <LOS_SwtmrCreate+0x106>
 8005260:	2200      	movs	r2, #0
 8005262:	6a3b      	ldr	r3, [r7, #32]
 8005264:	b29b      	uxth	r3, r3
 8005266:	3b02      	subs	r3, #2
 8005268:	b29b      	uxth	r3, r3
 800526a:	2080      	movs	r0, #128	; 0x80
 800526c:	47a0      	blx	r4

    return LOS_OK;
 800526e:	2300      	movs	r3, #0
}
 8005270:	4a05      	ldr	r2, [pc, #20]	; (8005288 <LOS_SwtmrCreate+0x12c>)
 8005272:	6811      	ldr	r1, [r2, #0]
 8005274:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005276:	4051      	eors	r1, r2
 8005278:	d001      	beq.n	800527e <LOS_SwtmrCreate+0x122>
 800527a:	f7ff f8b5 	bl	80043e8 <__stack_chk_fail>
 800527e:	4618      	mov	r0, r3
 8005280:	3734      	adds	r7, #52	; 0x34
 8005282:	46bd      	mov	sp, r7
 8005284:	bd90      	pop	{r4, r7, pc}
 8005286:	bf00      	nop
 8005288:	080202f8 	.word	0x080202f8
 800528c:	02000301 	.word	0x02000301
 8005290:	02000302 	.word	0x02000302
 8005294:	02000300 	.word	0x02000300
 8005298:	02000303 	.word	0x02000303
 800529c:	20000798 	.word	0x20000798
 80052a0:	200036f0 	.word	0x200036f0
 80052a4:	02000304 	.word	0x02000304
 80052a8:	2000075c 	.word	0x2000075c

080052ac <LOS_SwtmrStart>:

LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStart(UINT16 swtmrId)
{
 80052ac:	b590      	push	{r4, r7, lr}
 80052ae:	b08f      	sub	sp, #60	; 0x3c
 80052b0:	af00      	add	r7, sp, #0
 80052b2:	4603      	mov	r3, r0
 80052b4:	80fb      	strh	r3, [r7, #6]
 80052b6:	4b42      	ldr	r3, [pc, #264]	; (80053c0 <LOS_SwtmrStart+0x114>)
 80052b8:	681b      	ldr	r3, [r3, #0]
 80052ba:	637b      	str	r3, [r7, #52]	; 0x34
 80052bc:	f04f 0300 	mov.w	r3, #0
    LosSwtmrCB *swtmr = NULL;
 80052c0:	2300      	movs	r3, #0
 80052c2:	617b      	str	r3, [r7, #20]
    UINT32 intSave;
    UINT32 ret = LOS_OK;
 80052c4:	2300      	movs	r3, #0
 80052c6:	613b      	str	r3, [r7, #16]
    UINT16 swtmrCBId;

    if (swtmrId >= OS_SWTMR_MAX_TIMERID) {
 80052c8:	88fb      	ldrh	r3, [r7, #6]
 80052ca:	f64f 72ef 	movw	r2, #65519	; 0xffef
 80052ce:	4293      	cmp	r3, r2
 80052d0:	d901      	bls.n	80052d6 <LOS_SwtmrStart+0x2a>
        return LOS_ERRNO_SWTMR_ID_INVALID;
 80052d2:	4b3c      	ldr	r3, [pc, #240]	; (80053c4 <LOS_SwtmrStart+0x118>)
 80052d4:	e068      	b.n	80053a8 <LOS_SwtmrStart+0xfc>
    }

    SWTMR_LOCK(intSave);
 80052d6:	f107 030c 	add.w	r3, r7, #12
 80052da:	4619      	mov	r1, r3
 80052dc:	483a      	ldr	r0, [pc, #232]	; (80053c8 <LOS_SwtmrStart+0x11c>)
 80052de:	f7ff fcb9 	bl	8004c54 <LOS_SpinLockSave>
    swtmrCBId = swtmrId % KERNEL_SWTMR_LIMIT;
 80052e2:	88fb      	ldrh	r3, [r7, #6]
 80052e4:	f003 030f 	and.w	r3, r3, #15
 80052e8:	817b      	strh	r3, [r7, #10]
    swtmr = g_swtmrCBArray + swtmrCBId;
 80052ea:	4b38      	ldr	r3, [pc, #224]	; (80053cc <LOS_SwtmrStart+0x120>)
 80052ec:	6819      	ldr	r1, [r3, #0]
 80052ee:	897a      	ldrh	r2, [r7, #10]
 80052f0:	4613      	mov	r3, r2
 80052f2:	00db      	lsls	r3, r3, #3
 80052f4:	4413      	add	r3, r2
 80052f6:	009b      	lsls	r3, r3, #2
 80052f8:	440b      	add	r3, r1
 80052fa:	617b      	str	r3, [r7, #20]

    if (swtmr->timerId != swtmrId) {
 80052fc:	697b      	ldr	r3, [r7, #20]
 80052fe:	8a1b      	ldrh	r3, [r3, #16]
 8005300:	88fa      	ldrh	r2, [r7, #6]
 8005302:	429a      	cmp	r2, r3
 8005304:	d006      	beq.n	8005314 <LOS_SwtmrStart+0x68>
        SWTMR_UNLOCK(intSave);
 8005306:	68fb      	ldr	r3, [r7, #12]
 8005308:	4619      	mov	r1, r3
 800530a:	482f      	ldr	r0, [pc, #188]	; (80053c8 <LOS_SwtmrStart+0x11c>)
 800530c:	f7ff fcb0 	bl	8004c70 <LOS_SpinUnlockRestore>
        return LOS_ERRNO_SWTMR_ID_INVALID;
 8005310:	4b2c      	ldr	r3, [pc, #176]	; (80053c4 <LOS_SwtmrStart+0x118>)
 8005312:	e049      	b.n	80053a8 <LOS_SwtmrStart+0xfc>
    }

    switch (swtmr->state) {
 8005314:	697b      	ldr	r3, [r7, #20]
 8005316:	7b1b      	ldrb	r3, [r3, #12]
 8005318:	2b02      	cmp	r3, #2
 800531a:	d009      	beq.n	8005330 <LOS_SwtmrStart+0x84>
 800531c:	2b02      	cmp	r3, #2
 800531e:	dc0e      	bgt.n	800533e <LOS_SwtmrStart+0x92>
 8005320:	2b00      	cmp	r3, #0
 8005322:	d002      	beq.n	800532a <LOS_SwtmrStart+0x7e>
 8005324:	2b01      	cmp	r3, #1
 8005326:	d006      	beq.n	8005336 <LOS_SwtmrStart+0x8a>
 8005328:	e009      	b.n	800533e <LOS_SwtmrStart+0x92>
        case OS_SWTMR_STATUS_UNUSED:
            ret = LOS_ERRNO_SWTMR_NOT_CREATED;
 800532a:	4b29      	ldr	r3, [pc, #164]	; (80053d0 <LOS_SwtmrStart+0x124>)
 800532c:	613b      	str	r3, [r7, #16]
            break;
 800532e:	e009      	b.n	8005344 <LOS_SwtmrStart+0x98>
        /*
         * If the status of swtmr is timing, it should stop the swtmr first,
         * then start the swtmr again.
         */
        case OS_SWTMR_STATUS_TICKING:
            OsSwtmrStop(swtmr);
 8005330:	6978      	ldr	r0, [r7, #20]
 8005332:	f7ff fef9 	bl	8005128 <OsSwtmrStop>
            /* fall-through */
        case OS_SWTMR_STATUS_CREATED:
            OsSwtmrStart(swtmr);
 8005336:	6978      	ldr	r0, [r7, #20]
 8005338:	f7ff fcb6 	bl	8004ca8 <OsSwtmrStart>
            break;
 800533c:	e002      	b.n	8005344 <LOS_SwtmrStart+0x98>
        default:
            ret = LOS_ERRNO_SWTMR_STATUS_INVALID;
 800533e:	4b25      	ldr	r3, [pc, #148]	; (80053d4 <LOS_SwtmrStart+0x128>)
 8005340:	613b      	str	r3, [r7, #16]
            break;
 8005342:	bf00      	nop
    }

    SWTMR_UNLOCK(intSave);
 8005344:	68fb      	ldr	r3, [r7, #12]
 8005346:	4619      	mov	r1, r3
 8005348:	481f      	ldr	r0, [pc, #124]	; (80053c8 <LOS_SwtmrStart+0x11c>)
 800534a:	f7ff fc91 	bl	8004c70 <LOS_SpinUnlockRestore>
    LOS_TRACE(SWTMR_START, swtmr->timerId, swtmr->mode, swtmr->overrun, swtmr->interval, swtmr->expiry);
 800534e:	2300      	movs	r3, #0
 8005350:	61fb      	str	r3, [r7, #28]
 8005352:	697b      	ldr	r3, [r7, #20]
 8005354:	8a1b      	ldrh	r3, [r3, #16]
 8005356:	623b      	str	r3, [r7, #32]
 8005358:	697b      	ldr	r3, [r7, #20]
 800535a:	7b5b      	ldrb	r3, [r3, #13]
 800535c:	627b      	str	r3, [r7, #36]	; 0x24
 800535e:	697b      	ldr	r3, [r7, #20]
 8005360:	7b9b      	ldrb	r3, [r3, #14]
 8005362:	62bb      	str	r3, [r7, #40]	; 0x28
 8005364:	697b      	ldr	r3, [r7, #20]
 8005366:	695b      	ldr	r3, [r3, #20]
 8005368:	62fb      	str	r3, [r7, #44]	; 0x2c
 800536a:	697b      	ldr	r3, [r7, #20]
 800536c:	699b      	ldr	r3, [r3, #24]
 800536e:	633b      	str	r3, [r7, #48]	; 0x30
 8005370:	2306      	movs	r3, #6
 8005372:	61bb      	str	r3, [r7, #24]
 8005374:	69bb      	ldr	r3, [r7, #24]
 8005376:	2b01      	cmp	r3, #1
 8005378:	d915      	bls.n	80053a6 <LOS_SwtmrStart+0xfa>
 800537a:	4b17      	ldr	r3, [pc, #92]	; (80053d8 <LOS_SwtmrStart+0x12c>)
 800537c:	681b      	ldr	r3, [r3, #0]
 800537e:	2b00      	cmp	r3, #0
 8005380:	d011      	beq.n	80053a6 <LOS_SwtmrStart+0xfa>
 8005382:	4b15      	ldr	r3, [pc, #84]	; (80053d8 <LOS_SwtmrStart+0x12c>)
 8005384:	681c      	ldr	r4, [r3, #0]
 8005386:	6a39      	ldr	r1, [r7, #32]
 8005388:	69bb      	ldr	r3, [r7, #24]
 800538a:	2b02      	cmp	r3, #2
 800538c:	d904      	bls.n	8005398 <LOS_SwtmrStart+0xec>
 800538e:	f107 031c 	add.w	r3, r7, #28
 8005392:	f103 0208 	add.w	r2, r3, #8
 8005396:	e000      	b.n	800539a <LOS_SwtmrStart+0xee>
 8005398:	2200      	movs	r2, #0
 800539a:	69bb      	ldr	r3, [r7, #24]
 800539c:	b29b      	uxth	r3, r3
 800539e:	3b02      	subs	r3, #2
 80053a0:	b29b      	uxth	r3, r3
 80053a2:	2082      	movs	r0, #130	; 0x82
 80053a4:	47a0      	blx	r4
    return ret;
 80053a6:	693b      	ldr	r3, [r7, #16]
}
 80053a8:	4a05      	ldr	r2, [pc, #20]	; (80053c0 <LOS_SwtmrStart+0x114>)
 80053aa:	6811      	ldr	r1, [r2, #0]
 80053ac:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80053ae:	4051      	eors	r1, r2
 80053b0:	d001      	beq.n	80053b6 <LOS_SwtmrStart+0x10a>
 80053b2:	f7ff f819 	bl	80043e8 <__stack_chk_fail>
 80053b6:	4618      	mov	r0, r3
 80053b8:	373c      	adds	r7, #60	; 0x3c
 80053ba:	46bd      	mov	sp, r7
 80053bc:	bd90      	pop	{r4, r7, pc}
 80053be:	bf00      	nop
 80053c0:	080202fc 	.word	0x080202fc
 80053c4:	02000305 	.word	0x02000305
 80053c8:	20000798 	.word	0x20000798
 80053cc:	20000794 	.word	0x20000794
 80053d0:	02000306 	.word	0x02000306
 80053d4:	0200030e 	.word	0x0200030e
 80053d8:	2000075c 	.word	0x2000075c

080053dc <LOS_ListEmpty>:
{
 80053dc:	b480      	push	{r7}
 80053de:	b083      	sub	sp, #12
 80053e0:	af00      	add	r7, sp, #0
 80053e2:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 80053e4:	687b      	ldr	r3, [r7, #4]
 80053e6:	685b      	ldr	r3, [r3, #4]
 80053e8:	687a      	ldr	r2, [r7, #4]
 80053ea:	429a      	cmp	r2, r3
 80053ec:	bf0c      	ite	eq
 80053ee:	2301      	moveq	r3, #1
 80053f0:	2300      	movne	r3, #0
 80053f2:	b2db      	uxtb	r3, r3
}
 80053f4:	4618      	mov	r0, r3
 80053f6:	370c      	adds	r7, #12
 80053f8:	46bd      	mov	sp, r7
 80053fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80053fe:	4770      	bx	lr

08005400 <LOS_IntLock>:
{
 8005400:	b580      	push	{r7, lr}
 8005402:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8005404:	f7fb fc60 	bl	8000cc8 <ArchIntLock>
 8005408:	4603      	mov	r3, r0
}
 800540a:	4618      	mov	r0, r3
 800540c:	bd80      	pop	{r7, pc}

0800540e <LOS_IntRestore>:
{
 800540e:	b580      	push	{r7, lr}
 8005410:	b082      	sub	sp, #8
 8005412:	af00      	add	r7, sp, #0
 8005414:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8005416:	6878      	ldr	r0, [r7, #4]
 8005418:	f7fb fc5e 	bl	8000cd8 <ArchIntRestore>
}
 800541c:	bf00      	nop
 800541e:	3708      	adds	r7, #8
 8005420:	46bd      	mov	sp, r7
 8005422:	bd80      	pop	{r7, pc}

08005424 <LOS_SpinLockSave>:
{
 8005424:	b580      	push	{r7, lr}
 8005426:	b082      	sub	sp, #8
 8005428:	af00      	add	r7, sp, #0
 800542a:	6078      	str	r0, [r7, #4]
 800542c:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 800542e:	f7ff ffe7 	bl	8005400 <LOS_IntLock>
 8005432:	4602      	mov	r2, r0
 8005434:	683b      	ldr	r3, [r7, #0]
 8005436:	601a      	str	r2, [r3, #0]
}
 8005438:	bf00      	nop
 800543a:	3708      	adds	r7, #8
 800543c:	46bd      	mov	sp, r7
 800543e:	bd80      	pop	{r7, pc}

08005440 <LOS_SpinUnlockRestore>:
{
 8005440:	b580      	push	{r7, lr}
 8005442:	b082      	sub	sp, #8
 8005444:	af00      	add	r7, sp, #0
 8005446:	6078      	str	r0, [r7, #4]
 8005448:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 800544a:	6838      	ldr	r0, [r7, #0]
 800544c:	f7ff ffdf 	bl	800540e <LOS_IntRestore>
}
 8005450:	bf00      	nop
 8005452:	3708      	adds	r7, #8
 8005454:	46bd      	mov	sp, r7
 8005456:	bd80      	pop	{r7, pc}

08005458 <QueueCompareValue>:
    UINT64  lastAccessTime; /* The last access time */
} QueueDebugCB;
STATIC QueueDebugCB *g_queueDebugArray = NULL;

STATIC BOOL QueueCompareValue(const SortParam *sortParam, UINT32 left, UINT32 right)
{
 8005458:	b490      	push	{r4, r7}
 800545a:	b084      	sub	sp, #16
 800545c:	af00      	add	r7, sp, #0
 800545e:	60f8      	str	r0, [r7, #12]
 8005460:	60b9      	str	r1, [r7, #8]
 8005462:	607a      	str	r2, [r7, #4]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 8005464:	68fb      	ldr	r3, [r7, #12]
 8005466:	681a      	ldr	r2, [r3, #0]
 8005468:	68fb      	ldr	r3, [r7, #12]
 800546a:	685b      	ldr	r3, [r3, #4]
 800546c:	68b9      	ldr	r1, [r7, #8]
 800546e:	fb01 f103 	mul.w	r1, r1, r3
 8005472:	68fb      	ldr	r3, [r7, #12]
 8005474:	68db      	ldr	r3, [r3, #12]
 8005476:	440b      	add	r3, r1
 8005478:	4413      	add	r3, r2
 800547a:	e9d3 2300 	ldrd	r2, r3, [r3]
            *((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, right)));
 800547e:	68f9      	ldr	r1, [r7, #12]
 8005480:	6808      	ldr	r0, [r1, #0]
 8005482:	68f9      	ldr	r1, [r7, #12]
 8005484:	6849      	ldr	r1, [r1, #4]
 8005486:	687c      	ldr	r4, [r7, #4]
 8005488:	fb04 f401 	mul.w	r4, r4, r1
 800548c:	68f9      	ldr	r1, [r7, #12]
 800548e:	68c9      	ldr	r1, [r1, #12]
 8005490:	4421      	add	r1, r4
 8005492:	4401      	add	r1, r0
 8005494:	e9d1 0100 	ldrd	r0, r1, [r1]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 8005498:	4299      	cmp	r1, r3
 800549a:	bf08      	it	eq
 800549c:	4290      	cmpeq	r0, r2
 800549e:	bf34      	ite	cc
 80054a0:	2301      	movcc	r3, #1
 80054a2:	2300      	movcs	r3, #0
 80054a4:	b2db      	uxtb	r3, r3
}
 80054a6:	4618      	mov	r0, r3
 80054a8:	3710      	adds	r7, #16
 80054aa:	46bd      	mov	sp, r7
 80054ac:	bc90      	pop	{r4, r7}
 80054ae:	4770      	bx	lr

080054b0 <OsQueueDbgInit>:

UINT32 OsQueueDbgInit(VOID)
{
 80054b0:	b580      	push	{r7, lr}
 80054b2:	b082      	sub	sp, #8
 80054b4:	af00      	add	r7, sp, #0
    UINT32 size = LOSCFG_BASE_IPC_QUEUE_LIMIT * sizeof(QueueDebugCB);
 80054b6:	23a0      	movs	r3, #160	; 0xa0
 80054b8:	607b      	str	r3, [r7, #4]

    /* system resident memory, don't free */
    g_queueDebugArray = (QueueDebugCB *)LOS_MemAlloc(m_aucSysMem1, size);
 80054ba:	4b11      	ldr	r3, [pc, #68]	; (8005500 <OsQueueDbgInit+0x50>)
 80054bc:	681b      	ldr	r3, [r3, #0]
 80054be:	6879      	ldr	r1, [r7, #4]
 80054c0:	4618      	mov	r0, r3
 80054c2:	f003 fa71 	bl	80089a8 <LOS_MemAlloc>
 80054c6:	4603      	mov	r3, r0
 80054c8:	4a0e      	ldr	r2, [pc, #56]	; (8005504 <OsQueueDbgInit+0x54>)
 80054ca:	6013      	str	r3, [r2, #0]
    if (g_queueDebugArray == NULL) {
 80054cc:	4b0d      	ldr	r3, [pc, #52]	; (8005504 <OsQueueDbgInit+0x54>)
 80054ce:	681b      	ldr	r3, [r3, #0]
 80054d0:	2b00      	cmp	r3, #0
 80054d2:	d108      	bne.n	80054e6 <OsQueueDbgInit+0x36>
        PRINT_ERR("%s: malloc failed!\n", __FUNCTION__);
 80054d4:	480c      	ldr	r0, [pc, #48]	; (8005508 <OsQueueDbgInit+0x58>)
 80054d6:	f7ff f8f9 	bl	80046cc <dprintf>
 80054da:	490c      	ldr	r1, [pc, #48]	; (800550c <OsQueueDbgInit+0x5c>)
 80054dc:	480c      	ldr	r0, [pc, #48]	; (8005510 <OsQueueDbgInit+0x60>)
 80054de:	f7ff f8f5 	bl	80046cc <dprintf>
        return LOS_NOK;
 80054e2:	2301      	movs	r3, #1
 80054e4:	e007      	b.n	80054f6 <OsQueueDbgInit+0x46>
    }
    (VOID)memset_s(g_queueDebugArray, size, 0, size);
 80054e6:	4b07      	ldr	r3, [pc, #28]	; (8005504 <OsQueueDbgInit+0x54>)
 80054e8:	6818      	ldr	r0, [r3, #0]
 80054ea:	687b      	ldr	r3, [r7, #4]
 80054ec:	2200      	movs	r2, #0
 80054ee:	6879      	ldr	r1, [r7, #4]
 80054f0:	f010 fdcc 	bl	801608c <memset_s>
    return LOS_OK;
 80054f4:	2300      	movs	r3, #0
}
 80054f6:	4618      	mov	r0, r3
 80054f8:	3708      	adds	r7, #8
 80054fa:	46bd      	mov	sp, r7
 80054fc:	bd80      	pop	{r7, pc}
 80054fe:	bf00      	nop
 8005500:	200021b8 	.word	0x200021b8
 8005504:	2000079c 	.word	0x2000079c
 8005508:	0802030c 	.word	0x0802030c
 800550c:	0802331c 	.word	0x0802331c
 8005510:	08020314 	.word	0x08020314

08005514 <OsQueueDbgTimeUpdate>:

VOID OsQueueDbgTimeUpdate(UINT32 queueId)
{
 8005514:	b580      	push	{r7, lr}
 8005516:	b084      	sub	sp, #16
 8005518:	af00      	add	r7, sp, #0
 800551a:	6078      	str	r0, [r7, #4]
    QueueDebugCB *queueDebug = &g_queueDebugArray[GET_QUEUE_INDEX(queueId)];
 800551c:	4b08      	ldr	r3, [pc, #32]	; (8005540 <OsQueueDbgTimeUpdate+0x2c>)
 800551e:	681a      	ldr	r2, [r3, #0]
 8005520:	687b      	ldr	r3, [r7, #4]
 8005522:	b29b      	uxth	r3, r3
 8005524:	011b      	lsls	r3, r3, #4
 8005526:	4413      	add	r3, r2
 8005528:	60fb      	str	r3, [r7, #12]
    queueDebug->lastAccessTime = LOS_TickCountGet();
 800552a:	f7fe fe25 	bl	8004178 <LOS_TickCountGet>
 800552e:	4602      	mov	r2, r0
 8005530:	460b      	mov	r3, r1
 8005532:	68f9      	ldr	r1, [r7, #12]
 8005534:	e9c1 2302 	strd	r2, r3, [r1, #8]
    return;
 8005538:	bf00      	nop
}
 800553a:	3710      	adds	r7, #16
 800553c:	46bd      	mov	sp, r7
 800553e:	bd80      	pop	{r7, pc}
 8005540:	2000079c 	.word	0x2000079c

08005544 <OsQueueDbgUpdate>:

VOID OsQueueDbgUpdate(UINT32 queueId, TSK_ENTRY_FUNC entry)
{
 8005544:	b580      	push	{r7, lr}
 8005546:	b084      	sub	sp, #16
 8005548:	af00      	add	r7, sp, #0
 800554a:	6078      	str	r0, [r7, #4]
 800554c:	6039      	str	r1, [r7, #0]
    QueueDebugCB *queueDebug = &g_queueDebugArray[GET_QUEUE_INDEX(queueId)];
 800554e:	4b0a      	ldr	r3, [pc, #40]	; (8005578 <OsQueueDbgUpdate+0x34>)
 8005550:	681a      	ldr	r2, [r3, #0]
 8005552:	687b      	ldr	r3, [r7, #4]
 8005554:	b29b      	uxth	r3, r3
 8005556:	011b      	lsls	r3, r3, #4
 8005558:	4413      	add	r3, r2
 800555a:	60fb      	str	r3, [r7, #12]
    queueDebug->creator = entry;
 800555c:	68fb      	ldr	r3, [r7, #12]
 800555e:	683a      	ldr	r2, [r7, #0]
 8005560:	601a      	str	r2, [r3, #0]
    queueDebug->lastAccessTime = LOS_TickCountGet();
 8005562:	f7fe fe09 	bl	8004178 <LOS_TickCountGet>
 8005566:	4602      	mov	r2, r0
 8005568:	460b      	mov	r3, r1
 800556a:	68f9      	ldr	r1, [r7, #12]
 800556c:	e9c1 2302 	strd	r2, r3, [r1, #8]
    return;
 8005570:	bf00      	nop
}
 8005572:	3710      	adds	r7, #16
 8005574:	46bd      	mov	sp, r7
 8005576:	bd80      	pop	{r7, pc}
 8005578:	2000079c 	.word	0x2000079c

0800557c <OsQueueInfoOutPut>:

STATIC INLINE VOID OsQueueInfoOutPut(const LosQueueCB *node)
{
 800557c:	b580      	push	{r7, lr}
 800557e:	b084      	sub	sp, #16
 8005580:	af02      	add	r7, sp, #8
 8005582:	6078      	str	r0, [r7, #4]
    PRINTK("Queue ID <0x%x> may leak, queue len is 0x%x, "
 8005584:	687b      	ldr	r3, [r7, #4]
 8005586:	68d9      	ldr	r1, [r3, #12]
 8005588:	687b      	ldr	r3, [r7, #4]
 800558a:	88db      	ldrh	r3, [r3, #6]
 800558c:	461a      	mov	r2, r3
 800558e:	687b      	ldr	r3, [r7, #4]
 8005590:	8a9b      	ldrh	r3, [r3, #20]
 8005592:	4618      	mov	r0, r3
 8005594:	687b      	ldr	r3, [r7, #4]
 8005596:	8adb      	ldrh	r3, [r3, #22]
 8005598:	9300      	str	r3, [sp, #0]
 800559a:	4603      	mov	r3, r0
 800559c:	4803      	ldr	r0, [pc, #12]	; (80055ac <OsQueueInfoOutPut+0x30>)
 800559e:	f7ff f895 	bl	80046cc <dprintf>
           "readable cnt:0x%x, writeable cnt:0x%x, ",
           node->queueId,
           node->queueLen,
           node->readWriteableCnt[OS_QUEUE_READ],
           node->readWriteableCnt[OS_QUEUE_WRITE]);
}
 80055a2:	bf00      	nop
 80055a4:	3708      	adds	r7, #8
 80055a6:	46bd      	mov	sp, r7
 80055a8:	bd80      	pop	{r7, pc}
 80055aa:	bf00      	nop
 80055ac:	08020328 	.word	0x08020328

080055b0 <OsQueueOpsOutput>:

STATIC INLINE VOID OsQueueOpsOutput(const QueueDebugCB *node)
{
 80055b0:	b580      	push	{r7, lr}
 80055b2:	b082      	sub	sp, #8
 80055b4:	af00      	add	r7, sp, #0
 80055b6:	6078      	str	r0, [r7, #4]
    PRINTK("TaskEntry of creator:0x%p, Latest operation time: 0x%llx\n",
 80055b8:	687b      	ldr	r3, [r7, #4]
 80055ba:	6819      	ldr	r1, [r3, #0]
 80055bc:	687b      	ldr	r3, [r7, #4]
 80055be:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80055c2:	4803      	ldr	r0, [pc, #12]	; (80055d0 <OsQueueOpsOutput+0x20>)
 80055c4:	f7ff f882 	bl	80046cc <dprintf>
           node->creator, node->lastAccessTime);
}
 80055c8:	bf00      	nop
 80055ca:	3708      	adds	r7, #8
 80055cc:	46bd      	mov	sp, r7
 80055ce:	bd80      	pop	{r7, pc}
 80055d0:	08020380 	.word	0x08020380

080055d4 <SortQueueIndexArray>:

STATIC VOID SortQueueIndexArray(UINT32 *indexArray, UINT32 count)
{
 80055d4:	b580      	push	{r7, lr}
 80055d6:	b09c      	sub	sp, #112	; 0x70
 80055d8:	af02      	add	r7, sp, #8
 80055da:	6078      	str	r0, [r7, #4]
 80055dc:	6039      	str	r1, [r7, #0]
 80055de:	4b46      	ldr	r3, [pc, #280]	; (80056f8 <SortQueueIndexArray+0x124>)
 80055e0:	681b      	ldr	r3, [r3, #0]
 80055e2:	667b      	str	r3, [r7, #100]	; 0x64
 80055e4:	f04f 0300 	mov.w	r3, #0
    LosQueueCB queueNode = {0};
 80055e8:	f107 0334 	add.w	r3, r7, #52	; 0x34
 80055ec:	2230      	movs	r2, #48	; 0x30
 80055ee:	2100      	movs	r1, #0
 80055f0:	4618      	mov	r0, r3
 80055f2:	f009 f927 	bl	800e844 <memset>
    QueueDebugCB queueDebugNode = {0};
 80055f6:	f107 0310 	add.w	r3, r7, #16
 80055fa:	2200      	movs	r2, #0
 80055fc:	601a      	str	r2, [r3, #0]
 80055fe:	605a      	str	r2, [r3, #4]
 8005600:	609a      	str	r2, [r3, #8]
 8005602:	60da      	str	r2, [r3, #12]
    UINT32 index, intSave;
    SortParam queueSortParam;
    queueSortParam.buf = (CHAR *)g_queueDebugArray;
 8005604:	4b3d      	ldr	r3, [pc, #244]	; (80056fc <SortQueueIndexArray+0x128>)
 8005606:	681b      	ldr	r3, [r3, #0]
 8005608:	627b      	str	r3, [r7, #36]	; 0x24
    queueSortParam.ctrlBlockSize = sizeof(QueueDebugCB);
 800560a:	2310      	movs	r3, #16
 800560c:	62bb      	str	r3, [r7, #40]	; 0x28
    queueSortParam.ctrlBlockCnt = LOSCFG_BASE_IPC_QUEUE_LIMIT;
 800560e:	230a      	movs	r3, #10
 8005610:	62fb      	str	r3, [r7, #44]	; 0x2c
    queueSortParam.sortElemOff = LOS_OFF_SET_OF(QueueDebugCB, lastAccessTime);
 8005612:	2308      	movs	r3, #8
 8005614:	633b      	str	r3, [r7, #48]	; 0x30

    if (count > 0) {
 8005616:	683b      	ldr	r3, [r7, #0]
 8005618:	2b00      	cmp	r3, #0
 800561a:	d05b      	beq.n	80056d4 <SortQueueIndexArray+0x100>
        SCHEDULER_LOCK(intSave);
 800561c:	f107 0308 	add.w	r3, r7, #8
 8005620:	4619      	mov	r1, r3
 8005622:	4837      	ldr	r0, [pc, #220]	; (8005700 <SortQueueIndexArray+0x12c>)
 8005624:	f7ff fefe 	bl	8005424 <LOS_SpinLockSave>
        OsArraySort(indexArray, 0, count - 1, &queueSortParam, QueueCompareValue);
 8005628:	683b      	ldr	r3, [r7, #0]
 800562a:	1e5a      	subs	r2, r3, #1
 800562c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005630:	4934      	ldr	r1, [pc, #208]	; (8005704 <SortQueueIndexArray+0x130>)
 8005632:	9100      	str	r1, [sp, #0]
 8005634:	2100      	movs	r1, #0
 8005636:	6878      	ldr	r0, [r7, #4]
 8005638:	f7fd f856 	bl	80026e8 <OsArraySort>
        SCHEDULER_UNLOCK(intSave);
 800563c:	68bb      	ldr	r3, [r7, #8]
 800563e:	4619      	mov	r1, r3
 8005640:	482f      	ldr	r0, [pc, #188]	; (8005700 <SortQueueIndexArray+0x12c>)
 8005642:	f7ff fefd 	bl	8005440 <LOS_SpinUnlockRestore>
        for (index = 0; index < count; index++) {
 8005646:	2300      	movs	r3, #0
 8005648:	60fb      	str	r3, [r7, #12]
 800564a:	e03f      	b.n	80056cc <SortQueueIndexArray+0xf8>
            SCHEDULER_LOCK(intSave);
 800564c:	f107 0308 	add.w	r3, r7, #8
 8005650:	4619      	mov	r1, r3
 8005652:	482b      	ldr	r0, [pc, #172]	; (8005700 <SortQueueIndexArray+0x12c>)
 8005654:	f7ff fee6 	bl	8005424 <LOS_SpinLockSave>
            (VOID)memcpy_s(&queueNode, sizeof(LosQueueCB),
 8005658:	4b2b      	ldr	r3, [pc, #172]	; (8005708 <SortQueueIndexArray+0x134>)
 800565a:	6819      	ldr	r1, [r3, #0]
                           GET_QUEUE_HANDLE(indexArray[index]), sizeof(LosQueueCB));
 800565c:	68fb      	ldr	r3, [r7, #12]
 800565e:	009b      	lsls	r3, r3, #2
 8005660:	687a      	ldr	r2, [r7, #4]
 8005662:	4413      	add	r3, r2
 8005664:	681b      	ldr	r3, [r3, #0]
 8005666:	b29a      	uxth	r2, r3
 8005668:	4613      	mov	r3, r2
 800566a:	005b      	lsls	r3, r3, #1
 800566c:	4413      	add	r3, r2
 800566e:	011b      	lsls	r3, r3, #4
 8005670:	18ca      	adds	r2, r1, r3
            (VOID)memcpy_s(&queueNode, sizeof(LosQueueCB),
 8005672:	f107 0034 	add.w	r0, r7, #52	; 0x34
 8005676:	2330      	movs	r3, #48	; 0x30
 8005678:	2130      	movs	r1, #48	; 0x30
 800567a:	f010 ff8f 	bl	801659c <memcpy_s>
            (VOID)memcpy_s(&queueDebugNode, sizeof(QueueDebugCB),
 800567e:	4b1f      	ldr	r3, [pc, #124]	; (80056fc <SortQueueIndexArray+0x128>)
 8005680:	681a      	ldr	r2, [r3, #0]
                           &g_queueDebugArray[indexArray[index]], sizeof(QueueDebugCB));
 8005682:	68fb      	ldr	r3, [r7, #12]
 8005684:	009b      	lsls	r3, r3, #2
 8005686:	6879      	ldr	r1, [r7, #4]
 8005688:	440b      	add	r3, r1
 800568a:	681b      	ldr	r3, [r3, #0]
 800568c:	011b      	lsls	r3, r3, #4
 800568e:	441a      	add	r2, r3
            (VOID)memcpy_s(&queueDebugNode, sizeof(QueueDebugCB),
 8005690:	f107 0010 	add.w	r0, r7, #16
 8005694:	2310      	movs	r3, #16
 8005696:	2110      	movs	r1, #16
 8005698:	f010 ff80 	bl	801659c <memcpy_s>
            SCHEDULER_UNLOCK(intSave);
 800569c:	68bb      	ldr	r3, [r7, #8]
 800569e:	4619      	mov	r1, r3
 80056a0:	4817      	ldr	r0, [pc, #92]	; (8005700 <SortQueueIndexArray+0x12c>)
 80056a2:	f7ff fecd 	bl	8005440 <LOS_SpinUnlockRestore>
            if (queueNode.queueState == LOS_UNUSED) {
 80056a6:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 80056aa:	2b00      	cmp	r3, #0
 80056ac:	d00a      	beq.n	80056c4 <SortQueueIndexArray+0xf0>
                continue;
            }
            OsQueueInfoOutPut(&queueNode);
 80056ae:	f107 0334 	add.w	r3, r7, #52	; 0x34
 80056b2:	4618      	mov	r0, r3
 80056b4:	f7ff ff62 	bl	800557c <OsQueueInfoOutPut>
            OsQueueOpsOutput(&queueDebugNode);
 80056b8:	f107 0310 	add.w	r3, r7, #16
 80056bc:	4618      	mov	r0, r3
 80056be:	f7ff ff77 	bl	80055b0 <OsQueueOpsOutput>
 80056c2:	e000      	b.n	80056c6 <SortQueueIndexArray+0xf2>
                continue;
 80056c4:	bf00      	nop
        for (index = 0; index < count; index++) {
 80056c6:	68fb      	ldr	r3, [r7, #12]
 80056c8:	3301      	adds	r3, #1
 80056ca:	60fb      	str	r3, [r7, #12]
 80056cc:	68fa      	ldr	r2, [r7, #12]
 80056ce:	683b      	ldr	r3, [r7, #0]
 80056d0:	429a      	cmp	r2, r3
 80056d2:	d3bb      	bcc.n	800564c <SortQueueIndexArray+0x78>
        }
    }
    (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, indexArray);
 80056d4:	4b0d      	ldr	r3, [pc, #52]	; (800570c <SortQueueIndexArray+0x138>)
 80056d6:	681b      	ldr	r3, [r3, #0]
 80056d8:	6879      	ldr	r1, [r7, #4]
 80056da:	4618      	mov	r0, r3
 80056dc:	f003 fa1c 	bl	8008b18 <LOS_MemFree>
}
 80056e0:	bf00      	nop
 80056e2:	4b05      	ldr	r3, [pc, #20]	; (80056f8 <SortQueueIndexArray+0x124>)
 80056e4:	681a      	ldr	r2, [r3, #0]
 80056e6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80056e8:	405a      	eors	r2, r3
 80056ea:	d001      	beq.n	80056f0 <SortQueueIndexArray+0x11c>
 80056ec:	f7fe fe7c 	bl	80043e8 <__stack_chk_fail>
 80056f0:	3768      	adds	r7, #104	; 0x68
 80056f2:	46bd      	mov	sp, r7
 80056f4:	bd80      	pop	{r7, pc}
 80056f6:	bf00      	nop
 80056f8:	080203bc 	.word	0x080203bc
 80056fc:	2000079c 	.word	0x2000079c
 8005700:	20000764 	.word	0x20000764
 8005704:	08005459 	.word	0x08005459
 8005708:	200021bc 	.word	0x200021bc
 800570c:	080001f0 	.word	0x080001f0

08005710 <OsQueueCheck>:

VOID OsQueueCheck(VOID)
{
 8005710:	b580      	push	{r7, lr}
 8005712:	b096      	sub	sp, #88	; 0x58
 8005714:	af00      	add	r7, sp, #0
 8005716:	4b57      	ldr	r3, [pc, #348]	; (8005874 <OsQueueCheck+0x164>)
 8005718:	681b      	ldr	r3, [r3, #0]
 800571a:	657b      	str	r3, [r7, #84]	; 0x54
 800571c:	f04f 0300 	mov.w	r3, #0
    LosQueueCB queueNode = {0};
 8005720:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005724:	2230      	movs	r2, #48	; 0x30
 8005726:	2100      	movs	r1, #0
 8005728:	4618      	mov	r0, r3
 800572a:	f009 f88b 	bl	800e844 <memset>
    QueueDebugCB queueDebugNode = {0};
 800572e:	f107 0310 	add.w	r3, r7, #16
 8005732:	2200      	movs	r2, #0
 8005734:	601a      	str	r2, [r3, #0]
 8005736:	605a      	str	r2, [r3, #4]
 8005738:	609a      	str	r2, [r3, #8]
 800573a:	60da      	str	r2, [r3, #12]
    UINT32 index, intSave;
    UINT32 count = 0;
 800573c:	2300      	movs	r3, #0
 800573e:	60bb      	str	r3, [r7, #8]
    /*
     * This return value does not need to be judged immediately,
     * and the following code logic has already distinguished the return value from null and non-empty,
     * and there is no case of accessing the null pointer.
     */
    UINT32 *indexArray = (UINT32 *)LOS_MemAlloc((VOID *)OS_SYS_MEM_ADDR, LOSCFG_BASE_IPC_QUEUE_LIMIT * sizeof(UINT32));
 8005740:	4b4d      	ldr	r3, [pc, #308]	; (8005878 <OsQueueCheck+0x168>)
 8005742:	681b      	ldr	r3, [r3, #0]
 8005744:	2128      	movs	r1, #40	; 0x28
 8005746:	4618      	mov	r0, r3
 8005748:	f003 f92e 	bl	80089a8 <LOS_MemAlloc>
 800574c:	60f8      	str	r0, [r7, #12]

    for (index = 0; index < LOSCFG_BASE_IPC_QUEUE_LIMIT; index++) {
 800574e:	2300      	movs	r3, #0
 8005750:	607b      	str	r3, [r7, #4]
 8005752:	e079      	b.n	8005848 <OsQueueCheck+0x138>
        SCHEDULER_LOCK(intSave);
 8005754:	463b      	mov	r3, r7
 8005756:	4619      	mov	r1, r3
 8005758:	4848      	ldr	r0, [pc, #288]	; (800587c <OsQueueCheck+0x16c>)
 800575a:	f7ff fe63 	bl	8005424 <LOS_SpinLockSave>
        (VOID)memcpy_s(&queueNode, sizeof(LosQueueCB),
 800575e:	4b48      	ldr	r3, [pc, #288]	; (8005880 <OsQueueCheck+0x170>)
 8005760:	6819      	ldr	r1, [r3, #0]
                       GET_QUEUE_HANDLE(index), sizeof(LosQueueCB));
 8005762:	687b      	ldr	r3, [r7, #4]
 8005764:	b29a      	uxth	r2, r3
 8005766:	4613      	mov	r3, r2
 8005768:	005b      	lsls	r3, r3, #1
 800576a:	4413      	add	r3, r2
 800576c:	011b      	lsls	r3, r3, #4
 800576e:	18ca      	adds	r2, r1, r3
        (VOID)memcpy_s(&queueNode, sizeof(LosQueueCB),
 8005770:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8005774:	2330      	movs	r3, #48	; 0x30
 8005776:	2130      	movs	r1, #48	; 0x30
 8005778:	f010 ff10 	bl	801659c <memcpy_s>
        (VOID)memcpy_s(&queueDebugNode, sizeof(QueueDebugCB),
 800577c:	4b41      	ldr	r3, [pc, #260]	; (8005884 <OsQueueCheck+0x174>)
 800577e:	681a      	ldr	r2, [r3, #0]
                       &g_queueDebugArray[index], sizeof(QueueDebugCB));
 8005780:	687b      	ldr	r3, [r7, #4]
 8005782:	011b      	lsls	r3, r3, #4
 8005784:	441a      	add	r2, r3
        (VOID)memcpy_s(&queueDebugNode, sizeof(QueueDebugCB),
 8005786:	f107 0010 	add.w	r0, r7, #16
 800578a:	2310      	movs	r3, #16
 800578c:	2110      	movs	r1, #16
 800578e:	f010 ff05 	bl	801659c <memcpy_s>
        SCHEDULER_UNLOCK(intSave);
 8005792:	683b      	ldr	r3, [r7, #0]
 8005794:	4619      	mov	r1, r3
 8005796:	4839      	ldr	r0, [pc, #228]	; (800587c <OsQueueCheck+0x16c>)
 8005798:	f7ff fe52 	bl	8005440 <LOS_SpinUnlockRestore>
        if ((queueNode.queueState == LOS_UNUSED) ||
 800579c:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80057a0:	2b00      	cmp	r3, #0
 80057a2:	d04d      	beq.n	8005840 <OsQueueCheck+0x130>
            ((queueNode.queueState == LOS_USED) && (queueDebugNode.creator == NULL))) {
 80057a4:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
        if ((queueNode.queueState == LOS_UNUSED) ||
 80057a8:	2b01      	cmp	r3, #1
 80057aa:	d102      	bne.n	80057b2 <OsQueueCheck+0xa2>
            ((queueNode.queueState == LOS_USED) && (queueDebugNode.creator == NULL))) {
 80057ac:	693b      	ldr	r3, [r7, #16]
 80057ae:	2b00      	cmp	r3, #0
 80057b0:	d046      	beq.n	8005840 <OsQueueCheck+0x130>
            continue;
        }
        if ((queueNode.queueState == LOS_USED) &&
 80057b2:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80057b6:	2b01      	cmp	r3, #1
 80057b8:	d12a      	bne.n	8005810 <OsQueueCheck+0x100>
            (queueNode.queueLen == queueNode.readWriteableCnt[OS_QUEUE_WRITE]) &&
 80057ba:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 80057bc:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
        if ((queueNode.queueState == LOS_USED) &&
 80057be:	429a      	cmp	r2, r3
 80057c0:	d126      	bne.n	8005810 <OsQueueCheck+0x100>
            LOS_ListEmpty(&queueNode.readWriteList[OS_QUEUE_READ]) &&
 80057c2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80057c6:	3318      	adds	r3, #24
 80057c8:	4618      	mov	r0, r3
 80057ca:	f7ff fe07 	bl	80053dc <LOS_ListEmpty>
 80057ce:	4603      	mov	r3, r0
            (queueNode.queueLen == queueNode.readWriteableCnt[OS_QUEUE_WRITE]) &&
 80057d0:	2b00      	cmp	r3, #0
 80057d2:	d01d      	beq.n	8005810 <OsQueueCheck+0x100>
            LOS_ListEmpty(&queueNode.readWriteList[OS_QUEUE_WRITE]) &&
 80057d4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80057d8:	3320      	adds	r3, #32
 80057da:	4618      	mov	r0, r3
 80057dc:	f7ff fdfe 	bl	80053dc <LOS_ListEmpty>
 80057e0:	4603      	mov	r3, r0
            LOS_ListEmpty(&queueNode.readWriteList[OS_QUEUE_READ]) &&
 80057e2:	2b00      	cmp	r3, #0
 80057e4:	d014      	beq.n	8005810 <OsQueueCheck+0x100>
            LOS_ListEmpty(&queueNode.memList)) {
 80057e6:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80057ea:	3328      	adds	r3, #40	; 0x28
 80057ec:	4618      	mov	r0, r3
 80057ee:	f7ff fdf5 	bl	80053dc <LOS_ListEmpty>
 80057f2:	4603      	mov	r3, r0
            LOS_ListEmpty(&queueNode.readWriteList[OS_QUEUE_WRITE]) &&
 80057f4:	2b00      	cmp	r3, #0
 80057f6:	d00b      	beq.n	8005810 <OsQueueCheck+0x100>
            PRINTK("Queue ID <0x%x> may leak, No task uses it, "
 80057f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80057fa:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 80057fc:	4619      	mov	r1, r3
 80057fe:	4822      	ldr	r0, [pc, #136]	; (8005888 <OsQueueCheck+0x178>)
 8005800:	f7fe ff64 	bl	80046cc <dprintf>
                   "QueueLen is 0x%x, ",
                   queueNode.queueId,
                   queueNode.queueLen);
            OsQueueOpsOutput(&queueDebugNode);
 8005804:	f107 0310 	add.w	r3, r7, #16
 8005808:	4618      	mov	r0, r3
 800580a:	f7ff fed1 	bl	80055b0 <OsQueueOpsOutput>
 800580e:	e018      	b.n	8005842 <OsQueueCheck+0x132>
        } else {
            if (indexArray != NULL) {
 8005810:	68fb      	ldr	r3, [r7, #12]
 8005812:	2b00      	cmp	r3, #0
 8005814:	d009      	beq.n	800582a <OsQueueCheck+0x11a>
                *(indexArray + count) = index;
 8005816:	68bb      	ldr	r3, [r7, #8]
 8005818:	009b      	lsls	r3, r3, #2
 800581a:	68fa      	ldr	r2, [r7, #12]
 800581c:	4413      	add	r3, r2
 800581e:	687a      	ldr	r2, [r7, #4]
 8005820:	601a      	str	r2, [r3, #0]
                count++;
 8005822:	68bb      	ldr	r3, [r7, #8]
 8005824:	3301      	adds	r3, #1
 8005826:	60bb      	str	r3, [r7, #8]
 8005828:	e00b      	b.n	8005842 <OsQueueCheck+0x132>
            } else {
                OsQueueInfoOutPut(&queueNode);
 800582a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800582e:	4618      	mov	r0, r3
 8005830:	f7ff fea4 	bl	800557c <OsQueueInfoOutPut>
                OsQueueOpsOutput(&queueDebugNode);
 8005834:	f107 0310 	add.w	r3, r7, #16
 8005838:	4618      	mov	r0, r3
 800583a:	f7ff feb9 	bl	80055b0 <OsQueueOpsOutput>
 800583e:	e000      	b.n	8005842 <OsQueueCheck+0x132>
            continue;
 8005840:	bf00      	nop
    for (index = 0; index < LOSCFG_BASE_IPC_QUEUE_LIMIT; index++) {
 8005842:	687b      	ldr	r3, [r7, #4]
 8005844:	3301      	adds	r3, #1
 8005846:	607b      	str	r3, [r7, #4]
 8005848:	687b      	ldr	r3, [r7, #4]
 800584a:	2b09      	cmp	r3, #9
 800584c:	d982      	bls.n	8005754 <OsQueueCheck+0x44>
            }
        }
    }

    if (indexArray != NULL) {
 800584e:	68fb      	ldr	r3, [r7, #12]
 8005850:	2b00      	cmp	r3, #0
 8005852:	d004      	beq.n	800585e <OsQueueCheck+0x14e>
        SortQueueIndexArray(indexArray, count);
 8005854:	68b9      	ldr	r1, [r7, #8]
 8005856:	68f8      	ldr	r0, [r7, #12]
 8005858:	f7ff febc 	bl	80055d4 <SortQueueIndexArray>
    }

    return;
 800585c:	bf00      	nop
 800585e:	bf00      	nop
}
 8005860:	4b04      	ldr	r3, [pc, #16]	; (8005874 <OsQueueCheck+0x164>)
 8005862:	681a      	ldr	r2, [r3, #0]
 8005864:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005866:	405a      	eors	r2, r3
 8005868:	d001      	beq.n	800586e <OsQueueCheck+0x15e>
 800586a:	f7fe fdbd 	bl	80043e8 <__stack_chk_fail>
 800586e:	3758      	adds	r7, #88	; 0x58
 8005870:	46bd      	mov	sp, r7
 8005872:	bd80      	pop	{r7, pc}
 8005874:	08020400 	.word	0x08020400
 8005878:	080001f0 	.word	0x080001f0
 800587c:	20000764 	.word	0x20000764
 8005880:	200021bc 	.word	0x200021bc
 8005884:	2000079c 	.word	0x2000079c
 8005888:	080203c0 	.word	0x080203c0

0800588c <OsShellCmdQueueInfoGet>:

#ifdef LOSCFG_SHELL
LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdQueueInfoGet(UINT32 argc, const CHAR **argv)
{
 800588c:	b580      	push	{r7, lr}
 800588e:	b082      	sub	sp, #8
 8005890:	af00      	add	r7, sp, #0
 8005892:	6078      	str	r0, [r7, #4]
 8005894:	6039      	str	r1, [r7, #0]
    if (argc > 0) {
 8005896:	687b      	ldr	r3, [r7, #4]
 8005898:	2b00      	cmp	r3, #0
 800589a:	d005      	beq.n	80058a8 <OsShellCmdQueueInfoGet+0x1c>
        PRINTK("\nUsage: queue\n");
 800589c:	4807      	ldr	r0, [pc, #28]	; (80058bc <OsShellCmdQueueInfoGet+0x30>)
 800589e:	f7fe ff15 	bl	80046cc <dprintf>
        return OS_ERROR;
 80058a2:	f04f 33ff 	mov.w	r3, #4294967295
 80058a6:	e005      	b.n	80058b4 <OsShellCmdQueueInfoGet+0x28>
    }
    PRINTK("used queues information: \n");
 80058a8:	4805      	ldr	r0, [pc, #20]	; (80058c0 <OsShellCmdQueueInfoGet+0x34>)
 80058aa:	f7fe ff0f 	bl	80046cc <dprintf>
    OsQueueCheck();
 80058ae:	f7ff ff2f 	bl	8005710 <OsQueueCheck>
    return LOS_OK;
 80058b2:	2300      	movs	r3, #0
}
 80058b4:	4618      	mov	r0, r3
 80058b6:	3708      	adds	r7, #8
 80058b8:	46bd      	mov	sp, r7
 80058ba:	bd80      	pop	{r7, pc}
 80058bc:	08020404 	.word	0x08020404
 80058c0:	08020414 	.word	0x08020414

080058c4 <LOS_IntLock>:
{
 80058c4:	b580      	push	{r7, lr}
 80058c6:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80058c8:	f7fb f9fe 	bl	8000cc8 <ArchIntLock>
 80058cc:	4603      	mov	r3, r0
}
 80058ce:	4618      	mov	r0, r3
 80058d0:	bd80      	pop	{r7, pc}

080058d2 <LOS_IntRestore>:
{
 80058d2:	b580      	push	{r7, lr}
 80058d4:	b082      	sub	sp, #8
 80058d6:	af00      	add	r7, sp, #0
 80058d8:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80058da:	6878      	ldr	r0, [r7, #4]
 80058dc:	f7fb f9fc 	bl	8000cd8 <ArchIntRestore>
}
 80058e0:	bf00      	nop
 80058e2:	3708      	adds	r7, #8
 80058e4:	46bd      	mov	sp, r7
 80058e6:	bd80      	pop	{r7, pc}

080058e8 <LOS_SpinLockSave>:
{
 80058e8:	b580      	push	{r7, lr}
 80058ea:	b082      	sub	sp, #8
 80058ec:	af00      	add	r7, sp, #0
 80058ee:	6078      	str	r0, [r7, #4]
 80058f0:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 80058f2:	f7ff ffe7 	bl	80058c4 <LOS_IntLock>
 80058f6:	4602      	mov	r2, r0
 80058f8:	683b      	ldr	r3, [r7, #0]
 80058fa:	601a      	str	r2, [r3, #0]
}
 80058fc:	bf00      	nop
 80058fe:	3708      	adds	r7, #8
 8005900:	46bd      	mov	sp, r7
 8005902:	bd80      	pop	{r7, pc}

08005904 <LOS_SpinUnlockRestore>:
{
 8005904:	b580      	push	{r7, lr}
 8005906:	b082      	sub	sp, #8
 8005908:	af00      	add	r7, sp, #0
 800590a:	6078      	str	r0, [r7, #4]
 800590c:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 800590e:	6838      	ldr	r0, [r7, #0]
 8005910:	f7ff ffdf 	bl	80058d2 <LOS_IntRestore>
}
 8005914:	bf00      	nop
 8005916:	3708      	adds	r7, #8
 8005918:	46bd      	mov	sp, r7
 800591a:	bd80      	pop	{r7, pc}

0800591c <MuxCompareValue>:
    UINT64  lastAccessTime; /* The last access time */
} MuxDebugCB;
STATIC MuxDebugCB *g_muxDebugArray = NULL;

STATIC BOOL MuxCompareValue(const SortParam *sortParam, UINT32 left, UINT32 right)
{
 800591c:	b490      	push	{r4, r7}
 800591e:	b084      	sub	sp, #16
 8005920:	af00      	add	r7, sp, #0
 8005922:	60f8      	str	r0, [r7, #12]
 8005924:	60b9      	str	r1, [r7, #8]
 8005926:	607a      	str	r2, [r7, #4]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 8005928:	68fb      	ldr	r3, [r7, #12]
 800592a:	681a      	ldr	r2, [r3, #0]
 800592c:	68fb      	ldr	r3, [r7, #12]
 800592e:	685b      	ldr	r3, [r3, #4]
 8005930:	68b9      	ldr	r1, [r7, #8]
 8005932:	fb01 f103 	mul.w	r1, r1, r3
 8005936:	68fb      	ldr	r3, [r7, #12]
 8005938:	68db      	ldr	r3, [r3, #12]
 800593a:	440b      	add	r3, r1
 800593c:	4413      	add	r3, r2
 800593e:	e9d3 2300 	ldrd	r2, r3, [r3]
            *((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, right)));
 8005942:	68f9      	ldr	r1, [r7, #12]
 8005944:	6808      	ldr	r0, [r1, #0]
 8005946:	68f9      	ldr	r1, [r7, #12]
 8005948:	6849      	ldr	r1, [r1, #4]
 800594a:	687c      	ldr	r4, [r7, #4]
 800594c:	fb04 f401 	mul.w	r4, r4, r1
 8005950:	68f9      	ldr	r1, [r7, #12]
 8005952:	68c9      	ldr	r1, [r1, #12]
 8005954:	4421      	add	r1, r4
 8005956:	4401      	add	r1, r0
 8005958:	e9d1 0100 	ldrd	r0, r1, [r1]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 800595c:	4299      	cmp	r1, r3
 800595e:	bf08      	it	eq
 8005960:	4290      	cmpeq	r0, r2
 8005962:	bf34      	ite	cc
 8005964:	2301      	movcc	r3, #1
 8005966:	2300      	movcs	r3, #0
 8005968:	b2db      	uxtb	r3, r3
}
 800596a:	4618      	mov	r0, r3
 800596c:	3710      	adds	r7, #16
 800596e:	46bd      	mov	sp, r7
 8005970:	bc90      	pop	{r4, r7}
 8005972:	4770      	bx	lr

08005974 <OsMuxDbgInit>:

UINT32 OsMuxDbgInit(VOID)
{
 8005974:	b580      	push	{r7, lr}
 8005976:	b082      	sub	sp, #8
 8005978:	af00      	add	r7, sp, #0
    UINT32 size = LOSCFG_BASE_IPC_MUX_LIMIT * sizeof(MuxDebugCB);
 800597a:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800597e:	607b      	str	r3, [r7, #4]
    /* system resident memory, don't free */
    g_muxDebugArray = (MuxDebugCB *)LOS_MemAlloc(m_aucSysMem1, size);
 8005980:	4b10      	ldr	r3, [pc, #64]	; (80059c4 <OsMuxDbgInit+0x50>)
 8005982:	681b      	ldr	r3, [r3, #0]
 8005984:	6879      	ldr	r1, [r7, #4]
 8005986:	4618      	mov	r0, r3
 8005988:	f003 f80e 	bl	80089a8 <LOS_MemAlloc>
 800598c:	4603      	mov	r3, r0
 800598e:	4a0e      	ldr	r2, [pc, #56]	; (80059c8 <OsMuxDbgInit+0x54>)
 8005990:	6013      	str	r3, [r2, #0]
    if (g_muxDebugArray == NULL) {
 8005992:	4b0d      	ldr	r3, [pc, #52]	; (80059c8 <OsMuxDbgInit+0x54>)
 8005994:	681b      	ldr	r3, [r3, #0]
 8005996:	2b00      	cmp	r3, #0
 8005998:	d108      	bne.n	80059ac <OsMuxDbgInit+0x38>
        PRINT_ERR("%s: malloc failed!\n", __FUNCTION__);
 800599a:	480c      	ldr	r0, [pc, #48]	; (80059cc <OsMuxDbgInit+0x58>)
 800599c:	f7fe fe96 	bl	80046cc <dprintf>
 80059a0:	490b      	ldr	r1, [pc, #44]	; (80059d0 <OsMuxDbgInit+0x5c>)
 80059a2:	480c      	ldr	r0, [pc, #48]	; (80059d4 <OsMuxDbgInit+0x60>)
 80059a4:	f7fe fe92 	bl	80046cc <dprintf>
        return LOS_NOK;
 80059a8:	2301      	movs	r3, #1
 80059aa:	e007      	b.n	80059bc <OsMuxDbgInit+0x48>
    }
    (VOID)memset_s(g_muxDebugArray, size, 0, size);
 80059ac:	4b06      	ldr	r3, [pc, #24]	; (80059c8 <OsMuxDbgInit+0x54>)
 80059ae:	6818      	ldr	r0, [r3, #0]
 80059b0:	687b      	ldr	r3, [r7, #4]
 80059b2:	2200      	movs	r2, #0
 80059b4:	6879      	ldr	r1, [r7, #4]
 80059b6:	f010 fb69 	bl	801608c <memset_s>
    return LOS_OK;
 80059ba:	2300      	movs	r3, #0
}
 80059bc:	4618      	mov	r0, r3
 80059be:	3708      	adds	r7, #8
 80059c0:	46bd      	mov	sp, r7
 80059c2:	bd80      	pop	{r7, pc}
 80059c4:	200021b8 	.word	0x200021b8
 80059c8:	200007a0 	.word	0x200007a0
 80059cc:	08020438 	.word	0x08020438
 80059d0:	0802332c 	.word	0x0802332c
 80059d4:	08020440 	.word	0x08020440

080059d8 <OsMuxDbgTimeUpdate>:

VOID OsMuxDbgTimeUpdate(UINT32 muxId)
{
 80059d8:	b580      	push	{r7, lr}
 80059da:	b084      	sub	sp, #16
 80059dc:	af00      	add	r7, sp, #0
 80059de:	6078      	str	r0, [r7, #4]
    MuxDebugCB *muxDebug = &g_muxDebugArray[GET_MUX_INDEX(muxId)];
 80059e0:	4b08      	ldr	r3, [pc, #32]	; (8005a04 <OsMuxDbgTimeUpdate+0x2c>)
 80059e2:	681a      	ldr	r2, [r3, #0]
 80059e4:	687b      	ldr	r3, [r7, #4]
 80059e6:	b29b      	uxth	r3, r3
 80059e8:	011b      	lsls	r3, r3, #4
 80059ea:	4413      	add	r3, r2
 80059ec:	60fb      	str	r3, [r7, #12]
    muxDebug->lastAccessTime = LOS_TickCountGet();
 80059ee:	f7fe fbc3 	bl	8004178 <LOS_TickCountGet>
 80059f2:	4602      	mov	r2, r0
 80059f4:	460b      	mov	r3, r1
 80059f6:	68f9      	ldr	r1, [r7, #12]
 80059f8:	e9c1 2302 	strd	r2, r3, [r1, #8]
}
 80059fc:	bf00      	nop
 80059fe:	3710      	adds	r7, #16
 8005a00:	46bd      	mov	sp, r7
 8005a02:	bd80      	pop	{r7, pc}
 8005a04:	200007a0 	.word	0x200007a0

08005a08 <OsMuxDbgUpdate>:

VOID OsMuxDbgUpdate(UINT32 muxId, TSK_ENTRY_FUNC creator)
{
 8005a08:	b580      	push	{r7, lr}
 8005a0a:	b084      	sub	sp, #16
 8005a0c:	af00      	add	r7, sp, #0
 8005a0e:	6078      	str	r0, [r7, #4]
 8005a10:	6039      	str	r1, [r7, #0]
    MuxDebugCB *muxDebug = &g_muxDebugArray[GET_MUX_INDEX(muxId)];
 8005a12:	4b0a      	ldr	r3, [pc, #40]	; (8005a3c <OsMuxDbgUpdate+0x34>)
 8005a14:	681a      	ldr	r2, [r3, #0]
 8005a16:	687b      	ldr	r3, [r7, #4]
 8005a18:	b29b      	uxth	r3, r3
 8005a1a:	011b      	lsls	r3, r3, #4
 8005a1c:	4413      	add	r3, r2
 8005a1e:	60fb      	str	r3, [r7, #12]
    muxDebug->creator = creator;
 8005a20:	68fb      	ldr	r3, [r7, #12]
 8005a22:	683a      	ldr	r2, [r7, #0]
 8005a24:	601a      	str	r2, [r3, #0]
    muxDebug->lastAccessTime = LOS_TickCountGet();
 8005a26:	f7fe fba7 	bl	8004178 <LOS_TickCountGet>
 8005a2a:	4602      	mov	r2, r0
 8005a2c:	460b      	mov	r3, r1
 8005a2e:	68f9      	ldr	r1, [r7, #12]
 8005a30:	e9c1 2302 	strd	r2, r3, [r1, #8]
}
 8005a34:	bf00      	nop
 8005a36:	3710      	adds	r7, #16
 8005a38:	46bd      	mov	sp, r7
 8005a3a:	bd80      	pop	{r7, pc}
 8005a3c:	200007a0 	.word	0x200007a0

08005a40 <SortMuxIndexArray>:

STATIC VOID SortMuxIndexArray(UINT32 *indexArray, UINT32 count)
{
 8005a40:	b5b0      	push	{r4, r5, r7, lr}
 8005a42:	b096      	sub	sp, #88	; 0x58
 8005a44:	af04      	add	r7, sp, #16
 8005a46:	6078      	str	r0, [r7, #4]
 8005a48:	6039      	str	r1, [r7, #0]
 8005a4a:	4b4f      	ldr	r3, [pc, #316]	; (8005b88 <SortMuxIndexArray+0x148>)
 8005a4c:	681b      	ldr	r3, [r3, #0]
 8005a4e:	647b      	str	r3, [r7, #68]	; 0x44
 8005a50:	f04f 0300 	mov.w	r3, #0
    LosMuxCB muxNode = {{0, 0}, 0, 0, 0, 0};
 8005a54:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8005a58:	2200      	movs	r2, #0
 8005a5a:	601a      	str	r2, [r3, #0]
 8005a5c:	605a      	str	r2, [r3, #4]
 8005a5e:	609a      	str	r2, [r3, #8]
 8005a60:	60da      	str	r2, [r3, #12]
 8005a62:	611a      	str	r2, [r3, #16]
    MuxDebugCB muxDebugNode = {0};
 8005a64:	f107 0310 	add.w	r3, r7, #16
 8005a68:	2200      	movs	r2, #0
 8005a6a:	601a      	str	r2, [r3, #0]
 8005a6c:	605a      	str	r2, [r3, #4]
 8005a6e:	609a      	str	r2, [r3, #8]
 8005a70:	60da      	str	r2, [r3, #12]
    UINT32 index, intSave;
    SortParam muxSortParam;
    muxSortParam.buf = (CHAR *)g_muxDebugArray;
 8005a72:	4b46      	ldr	r3, [pc, #280]	; (8005b8c <SortMuxIndexArray+0x14c>)
 8005a74:	681b      	ldr	r3, [r3, #0]
 8005a76:	623b      	str	r3, [r7, #32]
    muxSortParam.ctrlBlockSize = sizeof(MuxDebugCB);
 8005a78:	2310      	movs	r3, #16
 8005a7a:	627b      	str	r3, [r7, #36]	; 0x24
    muxSortParam.ctrlBlockCnt = LOSCFG_BASE_IPC_MUX_LIMIT;
 8005a7c:	2314      	movs	r3, #20
 8005a7e:	62bb      	str	r3, [r7, #40]	; 0x28
    muxSortParam.sortElemOff = LOS_OFF_SET_OF(MuxDebugCB, lastAccessTime);
 8005a80:	2308      	movs	r3, #8
 8005a82:	62fb      	str	r3, [r7, #44]	; 0x2c

    if (count > 0) {
 8005a84:	683b      	ldr	r3, [r7, #0]
 8005a86:	2b00      	cmp	r3, #0
 8005a88:	d06c      	beq.n	8005b64 <SortMuxIndexArray+0x124>
        SCHEDULER_LOCK(intSave);
 8005a8a:	f107 0308 	add.w	r3, r7, #8
 8005a8e:	4619      	mov	r1, r3
 8005a90:	483f      	ldr	r0, [pc, #252]	; (8005b90 <SortMuxIndexArray+0x150>)
 8005a92:	f7ff ff29 	bl	80058e8 <LOS_SpinLockSave>
        OsArraySort(indexArray, 0, count - 1, &muxSortParam, MuxCompareValue);
 8005a96:	683b      	ldr	r3, [r7, #0]
 8005a98:	1e5a      	subs	r2, r3, #1
 8005a9a:	f107 0320 	add.w	r3, r7, #32
 8005a9e:	493d      	ldr	r1, [pc, #244]	; (8005b94 <SortMuxIndexArray+0x154>)
 8005aa0:	9100      	str	r1, [sp, #0]
 8005aa2:	2100      	movs	r1, #0
 8005aa4:	6878      	ldr	r0, [r7, #4]
 8005aa6:	f7fc fe1f 	bl	80026e8 <OsArraySort>
        SCHEDULER_UNLOCK(intSave);
 8005aaa:	68bb      	ldr	r3, [r7, #8]
 8005aac:	4619      	mov	r1, r3
 8005aae:	4838      	ldr	r0, [pc, #224]	; (8005b90 <SortMuxIndexArray+0x150>)
 8005ab0:	f7ff ff28 	bl	8005904 <LOS_SpinUnlockRestore>
        for (index = 0; index < count; index++) {
 8005ab4:	2300      	movs	r3, #0
 8005ab6:	60fb      	str	r3, [r7, #12]
 8005ab8:	e050      	b.n	8005b5c <SortMuxIndexArray+0x11c>
            SCHEDULER_LOCK(intSave);
 8005aba:	f107 0308 	add.w	r3, r7, #8
 8005abe:	4619      	mov	r1, r3
 8005ac0:	4833      	ldr	r0, [pc, #204]	; (8005b90 <SortMuxIndexArray+0x150>)
 8005ac2:	f7ff ff11 	bl	80058e8 <LOS_SpinLockSave>
            (VOID)memcpy_s(&muxNode, sizeof(LosMuxCB),
 8005ac6:	4b34      	ldr	r3, [pc, #208]	; (8005b98 <SortMuxIndexArray+0x158>)
 8005ac8:	6819      	ldr	r1, [r3, #0]
                           GET_MUX(indexArray[index]), sizeof(LosMuxCB));
 8005aca:	68fb      	ldr	r3, [r7, #12]
 8005acc:	009b      	lsls	r3, r3, #2
 8005ace:	687a      	ldr	r2, [r7, #4]
 8005ad0:	4413      	add	r3, r2
 8005ad2:	681b      	ldr	r3, [r3, #0]
 8005ad4:	b29a      	uxth	r2, r3
 8005ad6:	4613      	mov	r3, r2
 8005ad8:	009b      	lsls	r3, r3, #2
 8005ada:	4413      	add	r3, r2
 8005adc:	009b      	lsls	r3, r3, #2
 8005ade:	18ca      	adds	r2, r1, r3
            (VOID)memcpy_s(&muxNode, sizeof(LosMuxCB),
 8005ae0:	f107 0030 	add.w	r0, r7, #48	; 0x30
 8005ae4:	2314      	movs	r3, #20
 8005ae6:	2114      	movs	r1, #20
 8005ae8:	f010 fd58 	bl	801659c <memcpy_s>
            (VOID)memcpy_s(&muxDebugNode, sizeof(MuxDebugCB),
 8005aec:	4b27      	ldr	r3, [pc, #156]	; (8005b8c <SortMuxIndexArray+0x14c>)
 8005aee:	681a      	ldr	r2, [r3, #0]
                           &g_muxDebugArray[indexArray[index]], sizeof(MuxDebugCB));
 8005af0:	68fb      	ldr	r3, [r7, #12]
 8005af2:	009b      	lsls	r3, r3, #2
 8005af4:	6879      	ldr	r1, [r7, #4]
 8005af6:	440b      	add	r3, r1
 8005af8:	681b      	ldr	r3, [r3, #0]
 8005afa:	011b      	lsls	r3, r3, #4
 8005afc:	441a      	add	r2, r3
            (VOID)memcpy_s(&muxDebugNode, sizeof(MuxDebugCB),
 8005afe:	f107 0010 	add.w	r0, r7, #16
 8005b02:	2310      	movs	r3, #16
 8005b04:	2110      	movs	r1, #16
 8005b06:	f010 fd49 	bl	801659c <memcpy_s>
            SCHEDULER_UNLOCK(intSave);
 8005b0a:	68bb      	ldr	r3, [r7, #8]
 8005b0c:	4619      	mov	r1, r3
 8005b0e:	4820      	ldr	r0, [pc, #128]	; (8005b90 <SortMuxIndexArray+0x150>)
 8005b10:	f7ff fef8 	bl	8005904 <LOS_SpinUnlockRestore>
            /*
             * muxStat may be altered after the g_taskSpin is unlocked in OsMutexCheck.
             * We should recheck the muxStat before the print.
             */
            if ((muxNode.muxStat != LOS_USED) ||
 8005b14:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 8005b18:	2b01      	cmp	r3, #1
 8005b1a:	d11b      	bne.n	8005b54 <SortMuxIndexArray+0x114>
                ((muxNode.muxStat == LOS_USED) && ((muxDebugNode.creator == NULL) || (muxNode.owner == NULL)))) {
 8005b1c:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
            if ((muxNode.muxStat != LOS_USED) ||
 8005b20:	2b01      	cmp	r3, #1
 8005b22:	d105      	bne.n	8005b30 <SortMuxIndexArray+0xf0>
                ((muxNode.muxStat == LOS_USED) && ((muxDebugNode.creator == NULL) || (muxNode.owner == NULL)))) {
 8005b24:	693b      	ldr	r3, [r7, #16]
 8005b26:	2b00      	cmp	r3, #0
 8005b28:	d014      	beq.n	8005b54 <SortMuxIndexArray+0x114>
 8005b2a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005b2c:	2b00      	cmp	r3, #0
 8005b2e:	d011      	beq.n	8005b54 <SortMuxIndexArray+0x114>
                continue;
            }
            PRINTK("Mutex ID <0x%x> may leak, TaskID of owner:0x%x, TaskEntry of owner: %p,"
 8005b30:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8005b32:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005b34:	695c      	ldr	r4, [r3, #20]
 8005b36:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005b38:	699d      	ldr	r5, [r3, #24]
 8005b3a:	6939      	ldr	r1, [r7, #16]
 8005b3c:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8005b40:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8005b44:	9100      	str	r1, [sp, #0]
 8005b46:	462b      	mov	r3, r5
 8005b48:	4622      	mov	r2, r4
 8005b4a:	4601      	mov	r1, r0
 8005b4c:	4813      	ldr	r0, [pc, #76]	; (8005b9c <SortMuxIndexArray+0x15c>)
 8005b4e:	f7fe fdbd 	bl	80046cc <dprintf>
 8005b52:	e000      	b.n	8005b56 <SortMuxIndexArray+0x116>
                continue;
 8005b54:	bf00      	nop
        for (index = 0; index < count; index++) {
 8005b56:	68fb      	ldr	r3, [r7, #12]
 8005b58:	3301      	adds	r3, #1
 8005b5a:	60fb      	str	r3, [r7, #12]
 8005b5c:	68fa      	ldr	r2, [r7, #12]
 8005b5e:	683b      	ldr	r3, [r7, #0]
 8005b60:	429a      	cmp	r2, r3
 8005b62:	d3aa      	bcc.n	8005aba <SortMuxIndexArray+0x7a>
                   "TaskEntry of creator: %p,Latest operation time: 0x%llx\n",
                   muxNode.muxId, muxNode.owner->taskId, muxNode.owner->taskEntry, muxDebugNode.creator,
                   muxDebugNode.lastAccessTime);
        }
    }
    (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, indexArray);
 8005b64:	4b0e      	ldr	r3, [pc, #56]	; (8005ba0 <SortMuxIndexArray+0x160>)
 8005b66:	681b      	ldr	r3, [r3, #0]
 8005b68:	6879      	ldr	r1, [r7, #4]
 8005b6a:	4618      	mov	r0, r3
 8005b6c:	f002 ffd4 	bl	8008b18 <LOS_MemFree>
}
 8005b70:	bf00      	nop
 8005b72:	4b05      	ldr	r3, [pc, #20]	; (8005b88 <SortMuxIndexArray+0x148>)
 8005b74:	681a      	ldr	r2, [r3, #0]
 8005b76:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005b78:	405a      	eors	r2, r3
 8005b7a:	d001      	beq.n	8005b80 <SortMuxIndexArray+0x140>
 8005b7c:	f7fe fc34 	bl	80043e8 <__stack_chk_fail>
 8005b80:	3748      	adds	r7, #72	; 0x48
 8005b82:	46bd      	mov	sp, r7
 8005b84:	bdb0      	pop	{r4, r5, r7, pc}
 8005b86:	bf00      	nop
 8005b88:	080204d4 	.word	0x080204d4
 8005b8c:	200007a0 	.word	0x200007a0
 8005b90:	20000764 	.word	0x20000764
 8005b94:	0800591d 	.word	0x0800591d
 8005b98:	200021c8 	.word	0x200021c8
 8005b9c:	08020454 	.word	0x08020454
 8005ba0:	080001f0 	.word	0x080001f0

08005ba4 <OsMutexCheck>:

VOID OsMutexCheck(VOID)
{
 8005ba4:	b5b0      	push	{r4, r5, r7, lr}
 8005ba6:	b092      	sub	sp, #72	; 0x48
 8005ba8:	af04      	add	r7, sp, #16
 8005baa:	4b4c      	ldr	r3, [pc, #304]	; (8005cdc <OsMutexCheck+0x138>)
 8005bac:	681b      	ldr	r3, [r3, #0]
 8005bae:	637b      	str	r3, [r7, #52]	; 0x34
 8005bb0:	f04f 0300 	mov.w	r3, #0
    LosMuxCB muxNode = {{0, 0}, 0, 0, 0, 0};
 8005bb4:	f107 0320 	add.w	r3, r7, #32
 8005bb8:	2200      	movs	r2, #0
 8005bba:	601a      	str	r2, [r3, #0]
 8005bbc:	605a      	str	r2, [r3, #4]
 8005bbe:	609a      	str	r2, [r3, #8]
 8005bc0:	60da      	str	r2, [r3, #12]
 8005bc2:	611a      	str	r2, [r3, #16]
    MuxDebugCB muxDebugNode = {0};
 8005bc4:	f107 0310 	add.w	r3, r7, #16
 8005bc8:	2200      	movs	r2, #0
 8005bca:	601a      	str	r2, [r3, #0]
 8005bcc:	605a      	str	r2, [r3, #4]
 8005bce:	609a      	str	r2, [r3, #8]
 8005bd0:	60da      	str	r2, [r3, #12]
    UINT32 index, intSave;
    UINT32 count = 0;
 8005bd2:	2300      	movs	r3, #0
 8005bd4:	60bb      	str	r3, [r7, #8]
    /*
     * This return value does not need to be judged immediately,
     * and the following code logic has already distinguished the return value from null and non-empty,
     * and there is no case of accessing the null pointer.
     */
    UINT32 *indexArray = (UINT32 *)LOS_MemAlloc((VOID *)OS_SYS_MEM_ADDR, LOSCFG_BASE_IPC_MUX_LIMIT * sizeof(UINT32));
 8005bd6:	4b42      	ldr	r3, [pc, #264]	; (8005ce0 <OsMutexCheck+0x13c>)
 8005bd8:	681b      	ldr	r3, [r3, #0]
 8005bda:	2150      	movs	r1, #80	; 0x50
 8005bdc:	4618      	mov	r0, r3
 8005bde:	f002 fee3 	bl	80089a8 <LOS_MemAlloc>
 8005be2:	60f8      	str	r0, [r7, #12]

    for (index = 0; index < LOSCFG_BASE_IPC_MUX_LIMIT; index++) {
 8005be4:	2300      	movs	r3, #0
 8005be6:	607b      	str	r3, [r7, #4]
 8005be8:	e063      	b.n	8005cb2 <OsMutexCheck+0x10e>
        SCHEDULER_LOCK(intSave);
 8005bea:	463b      	mov	r3, r7
 8005bec:	4619      	mov	r1, r3
 8005bee:	483d      	ldr	r0, [pc, #244]	; (8005ce4 <OsMutexCheck+0x140>)
 8005bf0:	f7ff fe7a 	bl	80058e8 <LOS_SpinLockSave>
        (VOID)memcpy_s(&muxNode, sizeof(LosMuxCB), GET_MUX(index), sizeof(LosMuxCB));
 8005bf4:	4b3c      	ldr	r3, [pc, #240]	; (8005ce8 <OsMutexCheck+0x144>)
 8005bf6:	6819      	ldr	r1, [r3, #0]
 8005bf8:	687b      	ldr	r3, [r7, #4]
 8005bfa:	b29a      	uxth	r2, r3
 8005bfc:	4613      	mov	r3, r2
 8005bfe:	009b      	lsls	r3, r3, #2
 8005c00:	4413      	add	r3, r2
 8005c02:	009b      	lsls	r3, r3, #2
 8005c04:	18ca      	adds	r2, r1, r3
 8005c06:	f107 0020 	add.w	r0, r7, #32
 8005c0a:	2314      	movs	r3, #20
 8005c0c:	2114      	movs	r1, #20
 8005c0e:	f010 fcc5 	bl	801659c <memcpy_s>
        (VOID)memcpy_s(&muxDebugNode, sizeof(MuxDebugCB), &g_muxDebugArray[index], sizeof(MuxDebugCB));
 8005c12:	4b36      	ldr	r3, [pc, #216]	; (8005cec <OsMutexCheck+0x148>)
 8005c14:	681a      	ldr	r2, [r3, #0]
 8005c16:	687b      	ldr	r3, [r7, #4]
 8005c18:	011b      	lsls	r3, r3, #4
 8005c1a:	441a      	add	r2, r3
 8005c1c:	f107 0010 	add.w	r0, r7, #16
 8005c20:	2310      	movs	r3, #16
 8005c22:	2110      	movs	r1, #16
 8005c24:	f010 fcba 	bl	801659c <memcpy_s>
        SCHEDULER_UNLOCK(intSave);
 8005c28:	683b      	ldr	r3, [r7, #0]
 8005c2a:	4619      	mov	r1, r3
 8005c2c:	482d      	ldr	r0, [pc, #180]	; (8005ce4 <OsMutexCheck+0x140>)
 8005c2e:	f7ff fe69 	bl	8005904 <LOS_SpinUnlockRestore>

        if ((muxNode.muxStat != LOS_USED) ||
 8005c32:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8005c36:	2b01      	cmp	r3, #1
 8005c38:	d137      	bne.n	8005caa <OsMutexCheck+0x106>
            ((muxNode.muxStat == LOS_USED) && (muxDebugNode.creator == NULL))) {
 8005c3a:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
        if ((muxNode.muxStat != LOS_USED) ||
 8005c3e:	2b01      	cmp	r3, #1
 8005c40:	d102      	bne.n	8005c48 <OsMutexCheck+0xa4>
            ((muxNode.muxStat == LOS_USED) && (muxDebugNode.creator == NULL))) {
 8005c42:	693b      	ldr	r3, [r7, #16]
 8005c44:	2b00      	cmp	r3, #0
 8005c46:	d030      	beq.n	8005caa <OsMutexCheck+0x106>
            continue;
        } else if ((muxNode.muxStat == LOS_USED) && (muxNode.owner == NULL)) {
 8005c48:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8005c4c:	2b01      	cmp	r3, #1
 8005c4e:	d10d      	bne.n	8005c6c <OsMutexCheck+0xc8>
 8005c50:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005c52:	2b00      	cmp	r3, #0
 8005c54:	d10a      	bne.n	8005c6c <OsMutexCheck+0xc8>
            PRINTK("Mutex ID <0x%x> may leak, Owner is null, TaskEntry of creator: %p,"
 8005c56:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8005c58:	6938      	ldr	r0, [r7, #16]
 8005c5a:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8005c5e:	e9cd 2300 	strd	r2, r3, [sp]
 8005c62:	4602      	mov	r2, r0
 8005c64:	4822      	ldr	r0, [pc, #136]	; (8005cf0 <OsMutexCheck+0x14c>)
 8005c66:	f7fe fd31 	bl	80046cc <dprintf>
 8005c6a:	e01f      	b.n	8005cac <OsMutexCheck+0x108>
                   "Latest operation time: 0x%llx\n",
                   muxNode.muxId, muxDebugNode.creator, muxDebugNode.lastAccessTime);
        } else {
            if (indexArray != NULL) {
 8005c6c:	68fb      	ldr	r3, [r7, #12]
 8005c6e:	2b00      	cmp	r3, #0
 8005c70:	d009      	beq.n	8005c86 <OsMutexCheck+0xe2>
                *(indexArray + count) = index;
 8005c72:	68bb      	ldr	r3, [r7, #8]
 8005c74:	009b      	lsls	r3, r3, #2
 8005c76:	68fa      	ldr	r2, [r7, #12]
 8005c78:	4413      	add	r3, r2
 8005c7a:	687a      	ldr	r2, [r7, #4]
 8005c7c:	601a      	str	r2, [r3, #0]
                count++;
 8005c7e:	68bb      	ldr	r3, [r7, #8]
 8005c80:	3301      	adds	r3, #1
 8005c82:	60bb      	str	r3, [r7, #8]
 8005c84:	e012      	b.n	8005cac <OsMutexCheck+0x108>
            } else {
                PRINTK("Mutex ID <0x%x> may leak, TaskID of owner:0x%x, TaskEntry of owner: %p,"
 8005c86:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8005c88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005c8a:	695c      	ldr	r4, [r3, #20]
 8005c8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005c8e:	699d      	ldr	r5, [r3, #24]
 8005c90:	6939      	ldr	r1, [r7, #16]
 8005c92:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8005c96:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8005c9a:	9100      	str	r1, [sp, #0]
 8005c9c:	462b      	mov	r3, r5
 8005c9e:	4622      	mov	r2, r4
 8005ca0:	4601      	mov	r1, r0
 8005ca2:	4814      	ldr	r0, [pc, #80]	; (8005cf4 <OsMutexCheck+0x150>)
 8005ca4:	f7fe fd12 	bl	80046cc <dprintf>
 8005ca8:	e000      	b.n	8005cac <OsMutexCheck+0x108>
            continue;
 8005caa:	bf00      	nop
    for (index = 0; index < LOSCFG_BASE_IPC_MUX_LIMIT; index++) {
 8005cac:	687b      	ldr	r3, [r7, #4]
 8005cae:	3301      	adds	r3, #1
 8005cb0:	607b      	str	r3, [r7, #4]
 8005cb2:	687b      	ldr	r3, [r7, #4]
 8005cb4:	2b13      	cmp	r3, #19
 8005cb6:	d998      	bls.n	8005bea <OsMutexCheck+0x46>
                       muxDebugNode.lastAccessTime);
            }
        }
    }

    if (indexArray != NULL) {
 8005cb8:	68fb      	ldr	r3, [r7, #12]
 8005cba:	2b00      	cmp	r3, #0
 8005cbc:	d003      	beq.n	8005cc6 <OsMutexCheck+0x122>
        SortMuxIndexArray(indexArray, count);
 8005cbe:	68b9      	ldr	r1, [r7, #8]
 8005cc0:	68f8      	ldr	r0, [r7, #12]
 8005cc2:	f7ff febd 	bl	8005a40 <SortMuxIndexArray>
    }
}
 8005cc6:	bf00      	nop
 8005cc8:	4b04      	ldr	r3, [pc, #16]	; (8005cdc <OsMutexCheck+0x138>)
 8005cca:	681a      	ldr	r2, [r3, #0]
 8005ccc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005cce:	405a      	eors	r2, r3
 8005cd0:	d001      	beq.n	8005cd6 <OsMutexCheck+0x132>
 8005cd2:	f7fe fb89 	bl	80043e8 <__stack_chk_fail>
 8005cd6:	3738      	adds	r7, #56	; 0x38
 8005cd8:	46bd      	mov	sp, r7
 8005cda:	bdb0      	pop	{r4, r5, r7, pc}
 8005cdc:	0802053c 	.word	0x0802053c
 8005ce0:	080001f0 	.word	0x080001f0
 8005ce4:	20000764 	.word	0x20000764
 8005ce8:	200021c8 	.word	0x200021c8
 8005cec:	200007a0 	.word	0x200007a0
 8005cf0:	080204d8 	.word	0x080204d8
 8005cf4:	08020454 	.word	0x08020454

08005cf8 <OsShellCmdMuxInfoGet>:

#ifdef LOSCFG_SHELL
LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdMuxInfoGet(UINT32 argc, const CHAR **argv)
{
 8005cf8:	b580      	push	{r7, lr}
 8005cfa:	b082      	sub	sp, #8
 8005cfc:	af00      	add	r7, sp, #0
 8005cfe:	6078      	str	r0, [r7, #4]
 8005d00:	6039      	str	r1, [r7, #0]
    if (argc > 0) {
 8005d02:	687b      	ldr	r3, [r7, #4]
 8005d04:	2b00      	cmp	r3, #0
 8005d06:	d005      	beq.n	8005d14 <OsShellCmdMuxInfoGet+0x1c>
        PRINTK("\nUsage: mutex\n");
 8005d08:	4807      	ldr	r0, [pc, #28]	; (8005d28 <OsShellCmdMuxInfoGet+0x30>)
 8005d0a:	f7fe fcdf 	bl	80046cc <dprintf>
        return OS_ERROR;
 8005d0e:	f04f 33ff 	mov.w	r3, #4294967295
 8005d12:	e005      	b.n	8005d20 <OsShellCmdMuxInfoGet+0x28>
    }
    PRINTK("used mutexs information: \n");
 8005d14:	4805      	ldr	r0, [pc, #20]	; (8005d2c <OsShellCmdMuxInfoGet+0x34>)
 8005d16:	f7fe fcd9 	bl	80046cc <dprintf>
    OsMutexCheck();
 8005d1a:	f7ff ff43 	bl	8005ba4 <OsMutexCheck>
    return LOS_OK;
 8005d1e:	2300      	movs	r3, #0
}
 8005d20:	4618      	mov	r0, r3
 8005d22:	3708      	adds	r7, #8
 8005d24:	46bd      	mov	sp, r7
 8005d26:	bd80      	pop	{r7, pc}
 8005d28:	08020540 	.word	0x08020540
 8005d2c:	08020550 	.word	0x08020550

08005d30 <LOS_ListInit>:
{
 8005d30:	b480      	push	{r7}
 8005d32:	b083      	sub	sp, #12
 8005d34:	af00      	add	r7, sp, #0
 8005d36:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 8005d38:	687b      	ldr	r3, [r7, #4]
 8005d3a:	687a      	ldr	r2, [r7, #4]
 8005d3c:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 8005d3e:	687b      	ldr	r3, [r7, #4]
 8005d40:	687a      	ldr	r2, [r7, #4]
 8005d42:	601a      	str	r2, [r3, #0]
}
 8005d44:	bf00      	nop
 8005d46:	370c      	adds	r7, #12
 8005d48:	46bd      	mov	sp, r7
 8005d4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d4e:	4770      	bx	lr

08005d50 <LOS_ListAdd>:
{
 8005d50:	b480      	push	{r7}
 8005d52:	b083      	sub	sp, #12
 8005d54:	af00      	add	r7, sp, #0
 8005d56:	6078      	str	r0, [r7, #4]
 8005d58:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 8005d5a:	687b      	ldr	r3, [r7, #4]
 8005d5c:	685a      	ldr	r2, [r3, #4]
 8005d5e:	683b      	ldr	r3, [r7, #0]
 8005d60:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 8005d62:	683b      	ldr	r3, [r7, #0]
 8005d64:	687a      	ldr	r2, [r7, #4]
 8005d66:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8005d68:	687b      	ldr	r3, [r7, #4]
 8005d6a:	685b      	ldr	r3, [r3, #4]
 8005d6c:	683a      	ldr	r2, [r7, #0]
 8005d6e:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 8005d70:	687b      	ldr	r3, [r7, #4]
 8005d72:	683a      	ldr	r2, [r7, #0]
 8005d74:	605a      	str	r2, [r3, #4]
}
 8005d76:	bf00      	nop
 8005d78:	370c      	adds	r7, #12
 8005d7a:	46bd      	mov	sp, r7
 8005d7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d80:	4770      	bx	lr

08005d82 <LOS_ListTailInsert>:
{
 8005d82:	b580      	push	{r7, lr}
 8005d84:	b082      	sub	sp, #8
 8005d86:	af00      	add	r7, sp, #0
 8005d88:	6078      	str	r0, [r7, #4]
 8005d8a:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 8005d8c:	687b      	ldr	r3, [r7, #4]
 8005d8e:	681b      	ldr	r3, [r3, #0]
 8005d90:	6839      	ldr	r1, [r7, #0]
 8005d92:	4618      	mov	r0, r3
 8005d94:	f7ff ffdc 	bl	8005d50 <LOS_ListAdd>
}
 8005d98:	bf00      	nop
 8005d9a:	3708      	adds	r7, #8
 8005d9c:	46bd      	mov	sp, r7
 8005d9e:	bd80      	pop	{r7, pc}

08005da0 <LOS_ListDelete>:
{
 8005da0:	b480      	push	{r7}
 8005da2:	b083      	sub	sp, #12
 8005da4:	af00      	add	r7, sp, #0
 8005da6:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8005da8:	687b      	ldr	r3, [r7, #4]
 8005daa:	685b      	ldr	r3, [r3, #4]
 8005dac:	687a      	ldr	r2, [r7, #4]
 8005dae:	6812      	ldr	r2, [r2, #0]
 8005db0:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 8005db2:	687b      	ldr	r3, [r7, #4]
 8005db4:	681b      	ldr	r3, [r3, #0]
 8005db6:	687a      	ldr	r2, [r7, #4]
 8005db8:	6852      	ldr	r2, [r2, #4]
 8005dba:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8005dbc:	687b      	ldr	r3, [r7, #4]
 8005dbe:	2200      	movs	r2, #0
 8005dc0:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 8005dc2:	687b      	ldr	r3, [r7, #4]
 8005dc4:	2200      	movs	r2, #0
 8005dc6:	601a      	str	r2, [r3, #0]
}
 8005dc8:	bf00      	nop
 8005dca:	370c      	adds	r7, #12
 8005dcc:	46bd      	mov	sp, r7
 8005dce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005dd2:	4770      	bx	lr

08005dd4 <LOS_ListEmpty>:
{
 8005dd4:	b480      	push	{r7}
 8005dd6:	b083      	sub	sp, #12
 8005dd8:	af00      	add	r7, sp, #0
 8005dda:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8005ddc:	687b      	ldr	r3, [r7, #4]
 8005dde:	685b      	ldr	r3, [r3, #4]
 8005de0:	687a      	ldr	r2, [r7, #4]
 8005de2:	429a      	cmp	r2, r3
 8005de4:	bf0c      	ite	eq
 8005de6:	2301      	moveq	r3, #1
 8005de8:	2300      	movne	r3, #0
 8005dea:	b2db      	uxtb	r3, r3
}
 8005dec:	4618      	mov	r0, r3
 8005dee:	370c      	adds	r7, #12
 8005df0:	46bd      	mov	sp, r7
 8005df2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005df6:	4770      	bx	lr

08005df8 <LOS_IntLock>:
{
 8005df8:	b580      	push	{r7, lr}
 8005dfa:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8005dfc:	f7fa ff64 	bl	8000cc8 <ArchIntLock>
 8005e00:	4603      	mov	r3, r0
}
 8005e02:	4618      	mov	r0, r3
 8005e04:	bd80      	pop	{r7, pc}

08005e06 <LOS_IntRestore>:
{
 8005e06:	b580      	push	{r7, lr}
 8005e08:	b082      	sub	sp, #8
 8005e0a:	af00      	add	r7, sp, #0
 8005e0c:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8005e0e:	6878      	ldr	r0, [r7, #4]
 8005e10:	f7fa ff62 	bl	8000cd8 <ArchIntRestore>
}
 8005e14:	bf00      	nop
 8005e16:	3708      	adds	r7, #8
 8005e18:	46bd      	mov	sp, r7
 8005e1a:	bd80      	pop	{r7, pc}

08005e1c <LOS_SpinLockSave>:
{
 8005e1c:	b580      	push	{r7, lr}
 8005e1e:	b082      	sub	sp, #8
 8005e20:	af00      	add	r7, sp, #0
 8005e22:	6078      	str	r0, [r7, #4]
 8005e24:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8005e26:	f7ff ffe7 	bl	8005df8 <LOS_IntLock>
 8005e2a:	4602      	mov	r2, r0
 8005e2c:	683b      	ldr	r3, [r7, #0]
 8005e2e:	601a      	str	r2, [r3, #0]
}
 8005e30:	bf00      	nop
 8005e32:	3708      	adds	r7, #8
 8005e34:	46bd      	mov	sp, r7
 8005e36:	bd80      	pop	{r7, pc}

08005e38 <LOS_SpinUnlockRestore>:
{
 8005e38:	b580      	push	{r7, lr}
 8005e3a:	b082      	sub	sp, #8
 8005e3c:	af00      	add	r7, sp, #0
 8005e3e:	6078      	str	r0, [r7, #4]
 8005e40:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8005e42:	6838      	ldr	r0, [r7, #0]
 8005e44:	f7ff ffdf 	bl	8005e06 <LOS_IntRestore>
}
 8005e48:	bf00      	nop
 8005e4a:	3708      	adds	r7, #8
 8005e4c:	46bd      	mov	sp, r7
 8005e4e:	bd80      	pop	{r7, pc}

08005e50 <OsMuxDlockCheckInit>:
 * The unit is tick.
 */
#define OS_MUX_DEADLOCK_CHECK_THRESHOLD 60000

UINT32 OsMuxDlockCheckInit(VOID)
{
 8005e50:	b580      	push	{r7, lr}
 8005e52:	b082      	sub	sp, #8
 8005e54:	af00      	add	r7, sp, #0
    UINT32 index;
    UINT32 size = (LOSCFG_BASE_CORE_TSK_LIMIT + 1) * sizeof(MuxDLinkCB);
 8005e56:	f44f 7388 	mov.w	r3, #272	; 0x110
 8005e5a:	607b      	str	r3, [r7, #4]

    /* system resident memory, don't free */
    g_muxDeadlockCBArray = (MuxDLinkCB *)LOS_MemAlloc(m_aucSysMem1, size);
 8005e5c:	4b1b      	ldr	r3, [pc, #108]	; (8005ecc <OsMuxDlockCheckInit+0x7c>)
 8005e5e:	681b      	ldr	r3, [r3, #0]
 8005e60:	6879      	ldr	r1, [r7, #4]
 8005e62:	4618      	mov	r0, r3
 8005e64:	f002 fda0 	bl	80089a8 <LOS_MemAlloc>
 8005e68:	4603      	mov	r3, r0
 8005e6a:	4a19      	ldr	r2, [pc, #100]	; (8005ed0 <OsMuxDlockCheckInit+0x80>)
 8005e6c:	6013      	str	r3, [r2, #0]
    if (g_muxDeadlockCBArray == NULL) {
 8005e6e:	4b18      	ldr	r3, [pc, #96]	; (8005ed0 <OsMuxDlockCheckInit+0x80>)
 8005e70:	681b      	ldr	r3, [r3, #0]
 8005e72:	2b00      	cmp	r3, #0
 8005e74:	d108      	bne.n	8005e88 <OsMuxDlockCheckInit+0x38>
        PRINT_ERR("%s: malloc failed!\n", __FUNCTION__);
 8005e76:	4817      	ldr	r0, [pc, #92]	; (8005ed4 <OsMuxDlockCheckInit+0x84>)
 8005e78:	f7fe fc28 	bl	80046cc <dprintf>
 8005e7c:	4916      	ldr	r1, [pc, #88]	; (8005ed8 <OsMuxDlockCheckInit+0x88>)
 8005e7e:	4817      	ldr	r0, [pc, #92]	; (8005edc <OsMuxDlockCheckInit+0x8c>)
 8005e80:	f7fe fc24 	bl	80046cc <dprintf>
        return LOS_NOK;
 8005e84:	2301      	movs	r3, #1
 8005e86:	e01c      	b.n	8005ec2 <OsMuxDlockCheckInit+0x72>
    }

    for (index = 0; index < LOSCFG_BASE_CORE_TSK_LIMIT + 1; index++) {
 8005e88:	2300      	movs	r3, #0
 8005e8a:	603b      	str	r3, [r7, #0]
 8005e8c:	e015      	b.n	8005eba <OsMuxDlockCheckInit+0x6a>
        g_muxDeadlockCBArray[index].lastAccessTime = 0;
 8005e8e:	4b10      	ldr	r3, [pc, #64]	; (8005ed0 <OsMuxDlockCheckInit+0x80>)
 8005e90:	681a      	ldr	r2, [r3, #0]
 8005e92:	683b      	ldr	r3, [r7, #0]
 8005e94:	011b      	lsls	r3, r3, #4
 8005e96:	18d1      	adds	r1, r2, r3
 8005e98:	f04f 0200 	mov.w	r2, #0
 8005e9c:	f04f 0300 	mov.w	r3, #0
 8005ea0:	e9c1 2302 	strd	r2, r3, [r1, #8]
        LOS_ListInit(&g_muxDeadlockCBArray[index].muxListHead);
 8005ea4:	4b0a      	ldr	r3, [pc, #40]	; (8005ed0 <OsMuxDlockCheckInit+0x80>)
 8005ea6:	681a      	ldr	r2, [r3, #0]
 8005ea8:	683b      	ldr	r3, [r7, #0]
 8005eaa:	011b      	lsls	r3, r3, #4
 8005eac:	4413      	add	r3, r2
 8005eae:	4618      	mov	r0, r3
 8005eb0:	f7ff ff3e 	bl	8005d30 <LOS_ListInit>
    for (index = 0; index < LOSCFG_BASE_CORE_TSK_LIMIT + 1; index++) {
 8005eb4:	683b      	ldr	r3, [r7, #0]
 8005eb6:	3301      	adds	r3, #1
 8005eb8:	603b      	str	r3, [r7, #0]
 8005eba:	683b      	ldr	r3, [r7, #0]
 8005ebc:	2b10      	cmp	r3, #16
 8005ebe:	d9e6      	bls.n	8005e8e <OsMuxDlockCheckInit+0x3e>
    }
    return LOS_OK;
 8005ec0:	2300      	movs	r3, #0
}
 8005ec2:	4618      	mov	r0, r3
 8005ec4:	3708      	adds	r7, #8
 8005ec6:	46bd      	mov	sp, r7
 8005ec8:	bd80      	pop	{r7, pc}
 8005eca:	bf00      	nop
 8005ecc:	200021b8 	.word	0x200021b8
 8005ed0:	200007a4 	.word	0x200007a4
 8005ed4:	08020574 	.word	0x08020574
 8005ed8:	0802333c 	.word	0x0802333c
 8005edc:	0802057c 	.word	0x0802057c

08005ee0 <OsMuxDlockNodeInsert>:

VOID OsMuxDlockNodeInsert(UINT32 taskId, VOID *muxCB)
{
 8005ee0:	b580      	push	{r7, lr}
 8005ee2:	b084      	sub	sp, #16
 8005ee4:	af00      	add	r7, sp, #0
 8005ee6:	6078      	str	r0, [r7, #4]
 8005ee8:	6039      	str	r1, [r7, #0]
    MuxDLinkNode *muxDLNode = NULL;
 8005eea:	2300      	movs	r3, #0
 8005eec:	60fb      	str	r3, [r7, #12]

    if ((taskId > LOSCFG_BASE_CORE_TSK_LIMIT) || (muxCB == NULL)) {
 8005eee:	687b      	ldr	r3, [r7, #4]
 8005ef0:	2b10      	cmp	r3, #16
 8005ef2:	d821      	bhi.n	8005f38 <OsMuxDlockNodeInsert+0x58>
 8005ef4:	683b      	ldr	r3, [r7, #0]
 8005ef6:	2b00      	cmp	r3, #0
 8005ef8:	d01e      	beq.n	8005f38 <OsMuxDlockNodeInsert+0x58>
        return;
    }

    muxDLNode = (MuxDLinkNode *)LOS_MemAlloc(m_aucSysMem1, sizeof(MuxDLinkNode));
 8005efa:	4b12      	ldr	r3, [pc, #72]	; (8005f44 <OsMuxDlockNodeInsert+0x64>)
 8005efc:	681b      	ldr	r3, [r3, #0]
 8005efe:	210c      	movs	r1, #12
 8005f00:	4618      	mov	r0, r3
 8005f02:	f002 fd51 	bl	80089a8 <LOS_MemAlloc>
 8005f06:	60f8      	str	r0, [r7, #12]
    if (muxDLNode == NULL) {
 8005f08:	68fb      	ldr	r3, [r7, #12]
 8005f0a:	2b00      	cmp	r3, #0
 8005f0c:	d016      	beq.n	8005f3c <OsMuxDlockNodeInsert+0x5c>
        return;
    }
    (VOID)memset_s(muxDLNode, sizeof(MuxDLinkNode), 0, sizeof(MuxDLinkNode));
 8005f0e:	230c      	movs	r3, #12
 8005f10:	2200      	movs	r2, #0
 8005f12:	210c      	movs	r1, #12
 8005f14:	68f8      	ldr	r0, [r7, #12]
 8005f16:	f010 f8b9 	bl	801608c <memset_s>
    muxDLNode->muxCB = muxCB;
 8005f1a:	68fb      	ldr	r3, [r7, #12]
 8005f1c:	683a      	ldr	r2, [r7, #0]
 8005f1e:	609a      	str	r2, [r3, #8]

    LOS_ListTailInsert(&g_muxDeadlockCBArray[taskId].muxListHead, &muxDLNode->muxList);
 8005f20:	4b09      	ldr	r3, [pc, #36]	; (8005f48 <OsMuxDlockNodeInsert+0x68>)
 8005f22:	681a      	ldr	r2, [r3, #0]
 8005f24:	687b      	ldr	r3, [r7, #4]
 8005f26:	011b      	lsls	r3, r3, #4
 8005f28:	4413      	add	r3, r2
 8005f2a:	461a      	mov	r2, r3
 8005f2c:	68fb      	ldr	r3, [r7, #12]
 8005f2e:	4619      	mov	r1, r3
 8005f30:	4610      	mov	r0, r2
 8005f32:	f7ff ff26 	bl	8005d82 <LOS_ListTailInsert>
 8005f36:	e002      	b.n	8005f3e <OsMuxDlockNodeInsert+0x5e>
        return;
 8005f38:	bf00      	nop
 8005f3a:	e000      	b.n	8005f3e <OsMuxDlockNodeInsert+0x5e>
        return;
 8005f3c:	bf00      	nop
}
 8005f3e:	3710      	adds	r7, #16
 8005f40:	46bd      	mov	sp, r7
 8005f42:	bd80      	pop	{r7, pc}
 8005f44:	200021b8 	.word	0x200021b8
 8005f48:	200007a4 	.word	0x200007a4

08005f4c <OsMuxDlockNodeDelete>:

VOID OsMuxDlockNodeDelete(UINT32 taskId, const VOID *muxCB)
{
 8005f4c:	b580      	push	{r7, lr}
 8005f4e:	b086      	sub	sp, #24
 8005f50:	af00      	add	r7, sp, #0
 8005f52:	6078      	str	r0, [r7, #4]
 8005f54:	6039      	str	r1, [r7, #0]
    MuxDLinkCB *muxDLCB = NULL;
 8005f56:	2300      	movs	r3, #0
 8005f58:	613b      	str	r3, [r7, #16]
    LOS_DL_LIST *list = NULL;
 8005f5a:	2300      	movs	r3, #0
 8005f5c:	60fb      	str	r3, [r7, #12]
    MuxDLinkNode *muxDLNode = NULL;
 8005f5e:	2300      	movs	r3, #0
 8005f60:	617b      	str	r3, [r7, #20]

    if ((taskId > LOSCFG_BASE_CORE_TSK_LIMIT) || (muxCB == NULL)) {
 8005f62:	687b      	ldr	r3, [r7, #4]
 8005f64:	2b10      	cmp	r3, #16
 8005f66:	d826      	bhi.n	8005fb6 <OsMuxDlockNodeDelete+0x6a>
 8005f68:	683b      	ldr	r3, [r7, #0]
 8005f6a:	2b00      	cmp	r3, #0
 8005f6c:	d023      	beq.n	8005fb6 <OsMuxDlockNodeDelete+0x6a>
        return;
    }

    muxDLCB = &g_muxDeadlockCBArray[taskId];
 8005f6e:	4b14      	ldr	r3, [pc, #80]	; (8005fc0 <OsMuxDlockNodeDelete+0x74>)
 8005f70:	681a      	ldr	r2, [r3, #0]
 8005f72:	687b      	ldr	r3, [r7, #4]
 8005f74:	011b      	lsls	r3, r3, #4
 8005f76:	4413      	add	r3, r2
 8005f78:	613b      	str	r3, [r7, #16]
    LOS_DL_LIST_FOR_EACH(list, &muxDLCB->muxListHead) {
 8005f7a:	693b      	ldr	r3, [r7, #16]
 8005f7c:	685b      	ldr	r3, [r3, #4]
 8005f7e:	60fb      	str	r3, [r7, #12]
 8005f80:	e014      	b.n	8005fac <OsMuxDlockNodeDelete+0x60>
        muxDLNode = LOS_DL_LIST_ENTRY(list, MuxDLinkNode, muxList);
 8005f82:	68fb      	ldr	r3, [r7, #12]
 8005f84:	617b      	str	r3, [r7, #20]
        if (muxDLNode->muxCB == muxCB) {
 8005f86:	697b      	ldr	r3, [r7, #20]
 8005f88:	689b      	ldr	r3, [r3, #8]
 8005f8a:	683a      	ldr	r2, [r7, #0]
 8005f8c:	429a      	cmp	r2, r3
 8005f8e:	d10a      	bne.n	8005fa6 <OsMuxDlockNodeDelete+0x5a>
            LOS_ListDelete(&muxDLNode->muxList);
 8005f90:	697b      	ldr	r3, [r7, #20]
 8005f92:	4618      	mov	r0, r3
 8005f94:	f7ff ff04 	bl	8005da0 <LOS_ListDelete>
            (VOID)LOS_MemFree(m_aucSysMem1, muxDLNode);
 8005f98:	4b0a      	ldr	r3, [pc, #40]	; (8005fc4 <OsMuxDlockNodeDelete+0x78>)
 8005f9a:	681b      	ldr	r3, [r3, #0]
 8005f9c:	6979      	ldr	r1, [r7, #20]
 8005f9e:	4618      	mov	r0, r3
 8005fa0:	f002 fdba 	bl	8008b18 <LOS_MemFree>
            return;
 8005fa4:	e008      	b.n	8005fb8 <OsMuxDlockNodeDelete+0x6c>
    LOS_DL_LIST_FOR_EACH(list, &muxDLCB->muxListHead) {
 8005fa6:	68fb      	ldr	r3, [r7, #12]
 8005fa8:	685b      	ldr	r3, [r3, #4]
 8005faa:	60fb      	str	r3, [r7, #12]
 8005fac:	693b      	ldr	r3, [r7, #16]
 8005fae:	68fa      	ldr	r2, [r7, #12]
 8005fb0:	429a      	cmp	r2, r3
 8005fb2:	d1e6      	bne.n	8005f82 <OsMuxDlockNodeDelete+0x36>
 8005fb4:	e000      	b.n	8005fb8 <OsMuxDlockNodeDelete+0x6c>
        return;
 8005fb6:	bf00      	nop
        }
    }
}
 8005fb8:	3718      	adds	r7, #24
 8005fba:	46bd      	mov	sp, r7
 8005fbc:	bd80      	pop	{r7, pc}
 8005fbe:	bf00      	nop
 8005fc0:	200007a4 	.word	0x200007a4
 8005fc4:	200021b8 	.word	0x200021b8

08005fc8 <OsTaskTimeUpdate>:

VOID OsTaskTimeUpdate(UINT32 taskId, UINT64 tickCount)
{
 8005fc8:	b480      	push	{r7}
 8005fca:	b085      	sub	sp, #20
 8005fcc:	af00      	add	r7, sp, #0
 8005fce:	60f8      	str	r0, [r7, #12]
 8005fd0:	e9c7 2300 	strd	r2, r3, [r7]
    if (taskId > LOSCFG_BASE_CORE_TSK_LIMIT) {
 8005fd4:	68fb      	ldr	r3, [r7, #12]
 8005fd6:	2b10      	cmp	r3, #16
 8005fd8:	d809      	bhi.n	8005fee <OsTaskTimeUpdate+0x26>
        return;
    }

    g_muxDeadlockCBArray[taskId].lastAccessTime = tickCount;
 8005fda:	4b08      	ldr	r3, [pc, #32]	; (8005ffc <OsTaskTimeUpdate+0x34>)
 8005fdc:	681a      	ldr	r2, [r3, #0]
 8005fde:	68fb      	ldr	r3, [r7, #12]
 8005fe0:	011b      	lsls	r3, r3, #4
 8005fe2:	18d1      	adds	r1, r2, r3
 8005fe4:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005fe8:	e9c1 2302 	strd	r2, r3, [r1, #8]
 8005fec:	e000      	b.n	8005ff0 <OsTaskTimeUpdate+0x28>
        return;
 8005fee:	bf00      	nop
}
 8005ff0:	3714      	adds	r7, #20
 8005ff2:	46bd      	mov	sp, r7
 8005ff4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ff8:	4770      	bx	lr
 8005ffa:	bf00      	nop
 8005ffc:	200007a4 	.word	0x200007a4

08006000 <OsDeadlockBackTrace>:

STATIC VOID OsDeadlockBackTrace(const LosTaskCB *taskCB)
{
 8006000:	b580      	push	{r7, lr}
 8006002:	b084      	sub	sp, #16
 8006004:	af00      	add	r7, sp, #0
 8006006:	6078      	str	r0, [r7, #4]
    TaskContext *context = NULL;
 8006008:	2300      	movs	r3, #0
 800600a:	60fb      	str	r3, [r7, #12]

    PRINTK("*******backtrace begin*******\n");
 800600c:	4807      	ldr	r0, [pc, #28]	; (800602c <OsDeadlockBackTrace+0x2c>)
 800600e:	f7fe fb5d 	bl	80046cc <dprintf>
    context = (TaskContext *)taskCB->stackPointer;
 8006012:	687b      	ldr	r3, [r7, #4]
 8006014:	681b      	ldr	r3, [r3, #0]
 8006016:	60fb      	str	r3, [r7, #12]
    ArchBackTraceWithSp(context);
 8006018:	68f8      	ldr	r0, [r7, #12]
 800601a:	f00f ff15 	bl	8015e48 <ArchBackTraceWithSp>
    PRINTK("********backtrace end********\n");
 800601e:	4804      	ldr	r0, [pc, #16]	; (8006030 <OsDeadlockBackTrace+0x30>)
 8006020:	f7fe fb54 	bl	80046cc <dprintf>
    return;
 8006024:	bf00      	nop
}
 8006026:	3710      	adds	r7, #16
 8006028:	46bd      	mov	sp, r7
 800602a:	bd80      	pop	{r7, pc}
 800602c:	08020590 	.word	0x08020590
 8006030:	080205b0 	.word	0x080205b0

08006034 <OsMutexPendTaskList>:

STATIC VOID OsMutexPendTaskList(LOS_DL_LIST *list)
{
 8006034:	b580      	push	{r7, lr}
 8006036:	b08a      	sub	sp, #40	; 0x28
 8006038:	af00      	add	r7, sp, #0
 800603a:	6078      	str	r0, [r7, #4]
 800603c:	4b31      	ldr	r3, [pc, #196]	; (8006104 <OsMutexPendTaskList+0xd0>)
 800603e:	681b      	ldr	r3, [r3, #0]
 8006040:	627b      	str	r3, [r7, #36]	; 0x24
 8006042:	f04f 0300 	mov.w	r3, #0
    LOS_DL_LIST *listTmp = NULL;
 8006046:	2300      	movs	r3, #0
 8006048:	613b      	str	r3, [r7, #16]
    LosTaskCB *pendedTask = NULL;
 800604a:	2300      	movs	r3, #0
 800604c:	61bb      	str	r3, [r7, #24]
    CHAR *name = NULL;
 800604e:	2300      	movs	r3, #0
 8006050:	61fb      	str	r3, [r7, #28]
    UINT32 index = 0;
 8006052:	2300      	movs	r3, #0
 8006054:	617b      	str	r3, [r7, #20]
    UINT32 id, intSave;

    SCHEDULER_LOCK(intSave);
 8006056:	f107 030c 	add.w	r3, r7, #12
 800605a:	4619      	mov	r1, r3
 800605c:	482a      	ldr	r0, [pc, #168]	; (8006108 <OsMutexPendTaskList+0xd4>)
 800605e:	f7ff fedd 	bl	8005e1c <LOS_SpinLockSave>
    if (LOS_ListEmpty(list) == TRUE) {
 8006062:	6878      	ldr	r0, [r7, #4]
 8006064:	f7ff feb6 	bl	8005dd4 <LOS_ListEmpty>
 8006068:	4603      	mov	r3, r0
 800606a:	2b01      	cmp	r3, #1
 800606c:	d108      	bne.n	8006080 <OsMutexPendTaskList+0x4c>
        SCHEDULER_UNLOCK(intSave);
 800606e:	68fb      	ldr	r3, [r7, #12]
 8006070:	4619      	mov	r1, r3
 8006072:	4825      	ldr	r0, [pc, #148]	; (8006108 <OsMutexPendTaskList+0xd4>)
 8006074:	f7ff fee0 	bl	8005e38 <LOS_SpinUnlockRestore>
        PRINTK("Pended Task: null\n");
 8006078:	4824      	ldr	r0, [pc, #144]	; (800610c <OsMutexPendTaskList+0xd8>)
 800607a:	f7fe fb27 	bl	80046cc <dprintf>
 800607e:	e036      	b.n	80060ee <OsMutexPendTaskList+0xba>
        return;
    }

    LOS_DL_LIST_FOR_EACH(listTmp, list) {
 8006080:	687b      	ldr	r3, [r7, #4]
 8006082:	685b      	ldr	r3, [r3, #4]
 8006084:	613b      	str	r3, [r7, #16]
 8006086:	e029      	b.n	80060dc <OsMutexPendTaskList+0xa8>
        pendedTask = OS_TCB_FROM_PENDLIST(listTmp);
 8006088:	693b      	ldr	r3, [r7, #16]
 800608a:	3b40      	subs	r3, #64	; 0x40
 800608c:	61bb      	str	r3, [r7, #24]
        name = pendedTask->taskName;
 800608e:	69bb      	ldr	r3, [r7, #24]
 8006090:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006092:	61fb      	str	r3, [r7, #28]
        id = pendedTask->taskId;
 8006094:	69bb      	ldr	r3, [r7, #24]
 8006096:	695b      	ldr	r3, [r3, #20]
 8006098:	623b      	str	r3, [r7, #32]
        SCHEDULER_UNLOCK(intSave);
 800609a:	68fb      	ldr	r3, [r7, #12]
 800609c:	4619      	mov	r1, r3
 800609e:	481a      	ldr	r0, [pc, #104]	; (8006108 <OsMutexPendTaskList+0xd4>)
 80060a0:	f7ff feca 	bl	8005e38 <LOS_SpinUnlockRestore>
        if (index == 0) {
 80060a4:	697b      	ldr	r3, [r7, #20]
 80060a6:	2b00      	cmp	r3, #0
 80060a8:	d106      	bne.n	80060b8 <OsMutexPendTaskList+0x84>
            PRINTK("Pended task: %u. name:%-15s, id:0x%-5x\n", index, name, id);
 80060aa:	6a3b      	ldr	r3, [r7, #32]
 80060ac:	69fa      	ldr	r2, [r7, #28]
 80060ae:	6979      	ldr	r1, [r7, #20]
 80060b0:	4817      	ldr	r0, [pc, #92]	; (8006110 <OsMutexPendTaskList+0xdc>)
 80060b2:	f7fe fb0b 	bl	80046cc <dprintf>
 80060b6:	e005      	b.n	80060c4 <OsMutexPendTaskList+0x90>
        } else {
            PRINTK("             %u. name:%-15s, id:0x%-5x\n", index, name, id);
 80060b8:	6a3b      	ldr	r3, [r7, #32]
 80060ba:	69fa      	ldr	r2, [r7, #28]
 80060bc:	6979      	ldr	r1, [r7, #20]
 80060be:	4815      	ldr	r0, [pc, #84]	; (8006114 <OsMutexPendTaskList+0xe0>)
 80060c0:	f7fe fb04 	bl	80046cc <dprintf>
        }
        index++;
 80060c4:	697b      	ldr	r3, [r7, #20]
 80060c6:	3301      	adds	r3, #1
 80060c8:	617b      	str	r3, [r7, #20]
        SCHEDULER_LOCK(intSave);
 80060ca:	f107 030c 	add.w	r3, r7, #12
 80060ce:	4619      	mov	r1, r3
 80060d0:	480d      	ldr	r0, [pc, #52]	; (8006108 <OsMutexPendTaskList+0xd4>)
 80060d2:	f7ff fea3 	bl	8005e1c <LOS_SpinLockSave>
    LOS_DL_LIST_FOR_EACH(listTmp, list) {
 80060d6:	693b      	ldr	r3, [r7, #16]
 80060d8:	685b      	ldr	r3, [r3, #4]
 80060da:	613b      	str	r3, [r7, #16]
 80060dc:	693a      	ldr	r2, [r7, #16]
 80060de:	687b      	ldr	r3, [r7, #4]
 80060e0:	429a      	cmp	r2, r3
 80060e2:	d1d1      	bne.n	8006088 <OsMutexPendTaskList+0x54>
    }
    SCHEDULER_UNLOCK(intSave);
 80060e4:	68fb      	ldr	r3, [r7, #12]
 80060e6:	4619      	mov	r1, r3
 80060e8:	4807      	ldr	r0, [pc, #28]	; (8006108 <OsMutexPendTaskList+0xd4>)
 80060ea:	f7ff fea5 	bl	8005e38 <LOS_SpinUnlockRestore>
}
 80060ee:	4b05      	ldr	r3, [pc, #20]	; (8006104 <OsMutexPendTaskList+0xd0>)
 80060f0:	681a      	ldr	r2, [r3, #0]
 80060f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80060f4:	405a      	eors	r2, r3
 80060f6:	d001      	beq.n	80060fc <OsMutexPendTaskList+0xc8>
 80060f8:	f7fe f976 	bl	80043e8 <__stack_chk_fail>
 80060fc:	3728      	adds	r7, #40	; 0x28
 80060fe:	46bd      	mov	sp, r7
 8006100:	bd80      	pop	{r7, pc}
 8006102:	bf00      	nop
 8006104:	08020634 	.word	0x08020634
 8006108:	20000764 	.word	0x20000764
 800610c:	080205d0 	.word	0x080205d0
 8006110:	080205e4 	.word	0x080205e4
 8006114:	0802060c 	.word	0x0802060c

08006118 <OsTaskHoldMutexList>:

STATIC VOID OsTaskHoldMutexList(MuxDLinkCB *muxDLCB)
{
 8006118:	b580      	push	{r7, lr}
 800611a:	b08c      	sub	sp, #48	; 0x30
 800611c:	af00      	add	r7, sp, #0
 800611e:	6078      	str	r0, [r7, #4]
 8006120:	4b38      	ldr	r3, [pc, #224]	; (8006204 <OsTaskHoldMutexList+0xec>)
 8006122:	681b      	ldr	r3, [r3, #0]
 8006124:	62fb      	str	r3, [r7, #44]	; 0x2c
 8006126:	f04f 0300 	mov.w	r3, #0
    UINT32 index = 0;
 800612a:	2300      	movs	r3, #0
 800612c:	613b      	str	r3, [r7, #16]
    MuxDLinkNode *muxDLNode = NULL;
 800612e:	2300      	movs	r3, #0
 8006130:	61bb      	str	r3, [r7, #24]
    CHAR *ownerName = NULL;
 8006132:	2300      	movs	r3, #0
 8006134:	61fb      	str	r3, [r7, #28]
    LosMuxCB *muxCB = NULL;
 8006136:	2300      	movs	r3, #0
 8006138:	623b      	str	r3, [r7, #32]
    LOS_DL_LIST *list = NULL;
 800613a:	2300      	movs	r3, #0
 800613c:	617b      	str	r3, [r7, #20]
    LOS_DL_LIST *listTmp = NULL;
 800613e:	2300      	movs	r3, #0
 8006140:	627b      	str	r3, [r7, #36]	; 0x24
    UINT32 count, intSave;

    SCHEDULER_LOCK(intSave);
 8006142:	f107 030c 	add.w	r3, r7, #12
 8006146:	4619      	mov	r1, r3
 8006148:	482f      	ldr	r0, [pc, #188]	; (8006208 <OsTaskHoldMutexList+0xf0>)
 800614a:	f7ff fe67 	bl	8005e1c <LOS_SpinLockSave>
    if (LOS_ListEmpty(&muxDLCB->muxListHead) == TRUE) {
 800614e:	687b      	ldr	r3, [r7, #4]
 8006150:	4618      	mov	r0, r3
 8006152:	f7ff fe3f 	bl	8005dd4 <LOS_ListEmpty>
 8006156:	4603      	mov	r3, r0
 8006158:	2b01      	cmp	r3, #1
 800615a:	d108      	bne.n	800616e <OsTaskHoldMutexList+0x56>
        SCHEDULER_UNLOCK(intSave);
 800615c:	68fb      	ldr	r3, [r7, #12]
 800615e:	4619      	mov	r1, r3
 8006160:	4829      	ldr	r0, [pc, #164]	; (8006208 <OsTaskHoldMutexList+0xf0>)
 8006162:	f7ff fe69 	bl	8005e38 <LOS_SpinUnlockRestore>
        PRINTK("null\n");
 8006166:	4829      	ldr	r0, [pc, #164]	; (800620c <OsTaskHoldMutexList+0xf4>)
 8006168:	f7fe fab0 	bl	80046cc <dprintf>
            index++;
            SCHEDULER_LOCK(intSave);
        }
        SCHEDULER_UNLOCK(intSave);
    }
}
 800616c:	e03e      	b.n	80061ec <OsTaskHoldMutexList+0xd4>
        LOS_DL_LIST_FOR_EACH(list, &muxDLCB->muxListHead) {
 800616e:	687b      	ldr	r3, [r7, #4]
 8006170:	685b      	ldr	r3, [r3, #4]
 8006172:	617b      	str	r3, [r7, #20]
 8006174:	e031      	b.n	80061da <OsTaskHoldMutexList+0xc2>
            muxDLNode = LOS_DL_LIST_ENTRY(list, MuxDLinkNode, muxList);
 8006176:	697b      	ldr	r3, [r7, #20]
 8006178:	61bb      	str	r3, [r7, #24]
            muxCB = (LosMuxCB *)muxDLNode->muxCB;
 800617a:	69bb      	ldr	r3, [r7, #24]
 800617c:	689b      	ldr	r3, [r3, #8]
 800617e:	623b      	str	r3, [r7, #32]
            count = muxCB->muxCount;
 8006180:	6a3b      	ldr	r3, [r7, #32]
 8006182:	899b      	ldrh	r3, [r3, #12]
 8006184:	62bb      	str	r3, [r7, #40]	; 0x28
            ownerName = muxCB->owner->taskName;
 8006186:	6a3b      	ldr	r3, [r7, #32]
 8006188:	689b      	ldr	r3, [r3, #8]
 800618a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800618c:	61fb      	str	r3, [r7, #28]
            SCHEDULER_UNLOCK(intSave);
 800618e:	68fb      	ldr	r3, [r7, #12]
 8006190:	4619      	mov	r1, r3
 8006192:	481d      	ldr	r0, [pc, #116]	; (8006208 <OsTaskHoldMutexList+0xf0>)
 8006194:	f7ff fe50 	bl	8005e38 <LOS_SpinUnlockRestore>
            PRINTK("<Mutex%u info>\n", index);
 8006198:	6939      	ldr	r1, [r7, #16]
 800619a:	481d      	ldr	r0, [pc, #116]	; (8006210 <OsTaskHoldMutexList+0xf8>)
 800619c:	f7fe fa96 	bl	80046cc <dprintf>
            PRINTK("Ptr handle:%p\n", muxCB);
 80061a0:	6a39      	ldr	r1, [r7, #32]
 80061a2:	481c      	ldr	r0, [pc, #112]	; (8006214 <OsTaskHoldMutexList+0xfc>)
 80061a4:	f7fe fa92 	bl	80046cc <dprintf>
            PRINTK("Owner:%s\n", ownerName);
 80061a8:	69f9      	ldr	r1, [r7, #28]
 80061aa:	481b      	ldr	r0, [pc, #108]	; (8006218 <OsTaskHoldMutexList+0x100>)
 80061ac:	f7fe fa8e 	bl	80046cc <dprintf>
            PRINTK("Count:%u\n", count);
 80061b0:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80061b2:	481a      	ldr	r0, [pc, #104]	; (800621c <OsTaskHoldMutexList+0x104>)
 80061b4:	f7fe fa8a 	bl	80046cc <dprintf>
            listTmp = &muxCB->muxList;
 80061b8:	6a3b      	ldr	r3, [r7, #32]
 80061ba:	627b      	str	r3, [r7, #36]	; 0x24
            OsMutexPendTaskList(listTmp);
 80061bc:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80061be:	f7ff ff39 	bl	8006034 <OsMutexPendTaskList>
            index++;
 80061c2:	693b      	ldr	r3, [r7, #16]
 80061c4:	3301      	adds	r3, #1
 80061c6:	613b      	str	r3, [r7, #16]
            SCHEDULER_LOCK(intSave);
 80061c8:	f107 030c 	add.w	r3, r7, #12
 80061cc:	4619      	mov	r1, r3
 80061ce:	480e      	ldr	r0, [pc, #56]	; (8006208 <OsTaskHoldMutexList+0xf0>)
 80061d0:	f7ff fe24 	bl	8005e1c <LOS_SpinLockSave>
        LOS_DL_LIST_FOR_EACH(list, &muxDLCB->muxListHead) {
 80061d4:	697b      	ldr	r3, [r7, #20]
 80061d6:	685b      	ldr	r3, [r3, #4]
 80061d8:	617b      	str	r3, [r7, #20]
 80061da:	687b      	ldr	r3, [r7, #4]
 80061dc:	697a      	ldr	r2, [r7, #20]
 80061de:	429a      	cmp	r2, r3
 80061e0:	d1c9      	bne.n	8006176 <OsTaskHoldMutexList+0x5e>
        SCHEDULER_UNLOCK(intSave);
 80061e2:	68fb      	ldr	r3, [r7, #12]
 80061e4:	4619      	mov	r1, r3
 80061e6:	4808      	ldr	r0, [pc, #32]	; (8006208 <OsTaskHoldMutexList+0xf0>)
 80061e8:	f7ff fe26 	bl	8005e38 <LOS_SpinUnlockRestore>
}
 80061ec:	bf00      	nop
 80061ee:	4b05      	ldr	r3, [pc, #20]	; (8006204 <OsTaskHoldMutexList+0xec>)
 80061f0:	681a      	ldr	r2, [r3, #0]
 80061f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80061f4:	405a      	eors	r2, r3
 80061f6:	d001      	beq.n	80061fc <OsTaskHoldMutexList+0xe4>
 80061f8:	f7fe f8f6 	bl	80043e8 <__stack_chk_fail>
 80061fc:	3730      	adds	r7, #48	; 0x30
 80061fe:	46bd      	mov	sp, r7
 8006200:	bd80      	pop	{r7, pc}
 8006202:	bf00      	nop
 8006204:	08020678 	.word	0x08020678
 8006208:	20000764 	.word	0x20000764
 800620c:	08020638 	.word	0x08020638
 8006210:	08020640 	.word	0x08020640
 8006214:	08020650 	.word	0x08020650
 8006218:	08020660 	.word	0x08020660
 800621c:	0802066c 	.word	0x0802066c

08006220 <OsMutexDlockCheck>:

VOID OsMutexDlockCheck(VOID)
{
 8006220:	b5b0      	push	{r4, r5, r7, lr}
 8006222:	b088      	sub	sp, #32
 8006224:	af00      	add	r7, sp, #0
 8006226:	4b38      	ldr	r3, [pc, #224]	; (8006308 <OsMutexDlockCheck+0xe8>)
 8006228:	681b      	ldr	r3, [r3, #0]
 800622a:	61fb      	str	r3, [r7, #28]
 800622c:	f04f 0300 	mov.w	r3, #0
    UINT32 loop, intSave;
    UINT32 taskId;
    CHAR *name = NULL;
 8006230:	2300      	movs	r3, #0
 8006232:	60fb      	str	r3, [r7, #12]
    LosTaskCB *taskCB = NULL;
 8006234:	2300      	movs	r3, #0
 8006236:	613b      	str	r3, [r7, #16]
    MuxDLinkCB *muxDLCB = NULL;
 8006238:	2300      	movs	r3, #0
 800623a:	617b      	str	r3, [r7, #20]

    SCHEDULER_LOCK(intSave);
 800623c:	1d3b      	adds	r3, r7, #4
 800623e:	4619      	mov	r1, r3
 8006240:	4832      	ldr	r0, [pc, #200]	; (800630c <OsMutexDlockCheck+0xec>)
 8006242:	f7ff fdeb 	bl	8005e1c <LOS_SpinLockSave>
    for (loop = 0; loop < g_taskMaxNum; loop++) {
 8006246:	2300      	movs	r3, #0
 8006248:	60bb      	str	r3, [r7, #8]
 800624a:	e048      	b.n	80062de <OsMutexDlockCheck+0xbe>
        taskCB = (LosTaskCB *)g_taskCBArray + loop;
 800624c:	4b30      	ldr	r3, [pc, #192]	; (8006310 <OsMutexDlockCheck+0xf0>)
 800624e:	6819      	ldr	r1, [r3, #0]
 8006250:	68ba      	ldr	r2, [r7, #8]
 8006252:	4613      	mov	r3, r2
 8006254:	009b      	lsls	r3, r3, #2
 8006256:	4413      	add	r3, r2
 8006258:	015b      	lsls	r3, r3, #5
 800625a:	440b      	add	r3, r1
 800625c:	613b      	str	r3, [r7, #16]
        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 800625e:	693b      	ldr	r3, [r7, #16]
 8006260:	889b      	ldrh	r3, [r3, #4]
 8006262:	f003 0301 	and.w	r3, r3, #1
 8006266:	2b00      	cmp	r3, #0
 8006268:	d135      	bne.n	80062d6 <OsMutexDlockCheck+0xb6>
            continue;
        }

        muxDLCB = &g_muxDeadlockCBArray[taskCB->taskId];
 800626a:	4b2a      	ldr	r3, [pc, #168]	; (8006314 <OsMutexDlockCheck+0xf4>)
 800626c:	681a      	ldr	r2, [r3, #0]
 800626e:	693b      	ldr	r3, [r7, #16]
 8006270:	695b      	ldr	r3, [r3, #20]
 8006272:	011b      	lsls	r3, r3, #4
 8006274:	4413      	add	r3, r2
 8006276:	617b      	str	r3, [r7, #20]
        if ((LOS_TickCountGet() - muxDLCB->lastAccessTime) > OS_MUX_DEADLOCK_CHECK_THRESHOLD) {
 8006278:	f7fd ff7e 	bl	8004178 <LOS_TickCountGet>
 800627c:	697b      	ldr	r3, [r7, #20]
 800627e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8006282:	1a84      	subs	r4, r0, r2
 8006284:	eb61 0503 	sbc.w	r5, r1, r3
 8006288:	f64e 2260 	movw	r2, #60000	; 0xea60
 800628c:	f04f 0300 	mov.w	r3, #0
 8006290:	42ab      	cmp	r3, r5
 8006292:	bf08      	it	eq
 8006294:	42a2      	cmpeq	r2, r4
 8006296:	d21f      	bcs.n	80062d8 <OsMutexDlockCheck+0xb8>
            name = taskCB->taskName;
 8006298:	693b      	ldr	r3, [r7, #16]
 800629a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800629c:	60fb      	str	r3, [r7, #12]
            taskId = taskCB->taskId;
 800629e:	693b      	ldr	r3, [r7, #16]
 80062a0:	695b      	ldr	r3, [r3, #20]
 80062a2:	61bb      	str	r3, [r7, #24]
            SCHEDULER_UNLOCK(intSave);
 80062a4:	687b      	ldr	r3, [r7, #4]
 80062a6:	4619      	mov	r1, r3
 80062a8:	4818      	ldr	r0, [pc, #96]	; (800630c <OsMutexDlockCheck+0xec>)
 80062aa:	f7ff fdc5 	bl	8005e38 <LOS_SpinUnlockRestore>
            PRINTK("Task_name:%s, ID:0x%x, holds the Mutexs below:\n", name, taskId);
 80062ae:	69ba      	ldr	r2, [r7, #24]
 80062b0:	68f9      	ldr	r1, [r7, #12]
 80062b2:	4819      	ldr	r0, [pc, #100]	; (8006318 <OsMutexDlockCheck+0xf8>)
 80062b4:	f7fe fa0a 	bl	80046cc <dprintf>
            OsTaskHoldMutexList(muxDLCB);
 80062b8:	6978      	ldr	r0, [r7, #20]
 80062ba:	f7ff ff2d 	bl	8006118 <OsTaskHoldMutexList>
            OsDeadlockBackTrace(taskCB);
 80062be:	6938      	ldr	r0, [r7, #16]
 80062c0:	f7ff fe9e 	bl	8006000 <OsDeadlockBackTrace>
            PRINTK("\n");
 80062c4:	4815      	ldr	r0, [pc, #84]	; (800631c <OsMutexDlockCheck+0xfc>)
 80062c6:	f7fe fa01 	bl	80046cc <dprintf>
            SCHEDULER_LOCK(intSave);
 80062ca:	1d3b      	adds	r3, r7, #4
 80062cc:	4619      	mov	r1, r3
 80062ce:	480f      	ldr	r0, [pc, #60]	; (800630c <OsMutexDlockCheck+0xec>)
 80062d0:	f7ff fda4 	bl	8005e1c <LOS_SpinLockSave>
 80062d4:	e000      	b.n	80062d8 <OsMutexDlockCheck+0xb8>
            continue;
 80062d6:	bf00      	nop
    for (loop = 0; loop < g_taskMaxNum; loop++) {
 80062d8:	68bb      	ldr	r3, [r7, #8]
 80062da:	3301      	adds	r3, #1
 80062dc:	60bb      	str	r3, [r7, #8]
 80062de:	4b10      	ldr	r3, [pc, #64]	; (8006320 <OsMutexDlockCheck+0x100>)
 80062e0:	681b      	ldr	r3, [r3, #0]
 80062e2:	68ba      	ldr	r2, [r7, #8]
 80062e4:	429a      	cmp	r2, r3
 80062e6:	d3b1      	bcc.n	800624c <OsMutexDlockCheck+0x2c>
        }
    }
    SCHEDULER_UNLOCK(intSave);
 80062e8:	687b      	ldr	r3, [r7, #4]
 80062ea:	4619      	mov	r1, r3
 80062ec:	4807      	ldr	r0, [pc, #28]	; (800630c <OsMutexDlockCheck+0xec>)
 80062ee:	f7ff fda3 	bl	8005e38 <LOS_SpinUnlockRestore>
}
 80062f2:	bf00      	nop
 80062f4:	4b04      	ldr	r3, [pc, #16]	; (8006308 <OsMutexDlockCheck+0xe8>)
 80062f6:	681a      	ldr	r2, [r3, #0]
 80062f8:	69fb      	ldr	r3, [r7, #28]
 80062fa:	405a      	eors	r2, r3
 80062fc:	d001      	beq.n	8006302 <OsMutexDlockCheck+0xe2>
 80062fe:	f7fe f873 	bl	80043e8 <__stack_chk_fail>
 8006302:	3720      	adds	r7, #32
 8006304:	46bd      	mov	sp, r7
 8006306:	bdb0      	pop	{r4, r5, r7, pc}
 8006308:	080206b0 	.word	0x080206b0
 800630c:	20000764 	.word	0x20000764
 8006310:	200036c4 	.word	0x200036c4
 8006314:	200007a4 	.word	0x200007a4
 8006318:	0802067c 	.word	0x0802067c
 800631c:	080206ac 	.word	0x080206ac
 8006320:	200036d8 	.word	0x200036d8

08006324 <OsShellCmdMuxDeadlockCheck>:

#ifdef LOSCFG_SHELL
UINT32 OsShellCmdMuxDeadlockCheck(UINT32 argc, const CHAR **argv)
{
 8006324:	b580      	push	{r7, lr}
 8006326:	b082      	sub	sp, #8
 8006328:	af00      	add	r7, sp, #0
 800632a:	6078      	str	r0, [r7, #4]
 800632c:	6039      	str	r1, [r7, #0]
    if (argc > 0) {
 800632e:	687b      	ldr	r3, [r7, #4]
 8006330:	2b00      	cmp	r3, #0
 8006332:	d005      	beq.n	8006340 <OsShellCmdMuxDeadlockCheck+0x1c>
        PRINTK("\nUsage: dlock\n");
 8006334:	4809      	ldr	r0, [pc, #36]	; (800635c <OsShellCmdMuxDeadlockCheck+0x38>)
 8006336:	f7fe f9c9 	bl	80046cc <dprintf>
        return OS_ERROR;
 800633a:	f04f 33ff 	mov.w	r3, #4294967295
 800633e:	e008      	b.n	8006352 <OsShellCmdMuxDeadlockCheck+0x2e>
    }
    PRINTK("Start mutexs deadlock check: \n");
 8006340:	4807      	ldr	r0, [pc, #28]	; (8006360 <OsShellCmdMuxDeadlockCheck+0x3c>)
 8006342:	f7fe f9c3 	bl	80046cc <dprintf>
    OsMutexDlockCheck();
 8006346:	f7ff ff6b 	bl	8006220 <OsMutexDlockCheck>
    PRINTK("-----------End-----------\n");
 800634a:	4806      	ldr	r0, [pc, #24]	; (8006364 <OsShellCmdMuxDeadlockCheck+0x40>)
 800634c:	f7fe f9be 	bl	80046cc <dprintf>
    return LOS_OK;
 8006350:	2300      	movs	r3, #0
}
 8006352:	4618      	mov	r0, r3
 8006354:	3708      	adds	r7, #8
 8006356:	46bd      	mov	sp, r7
 8006358:	bd80      	pop	{r7, pc}
 800635a:	bf00      	nop
 800635c:	080206b4 	.word	0x080206b4
 8006360:	080206c4 	.word	0x080206c4
 8006364:	080206e4 	.word	0x080206e4

08006368 <LOS_ListEmpty>:
{
 8006368:	b480      	push	{r7}
 800636a:	b083      	sub	sp, #12
 800636c:	af00      	add	r7, sp, #0
 800636e:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8006370:	687b      	ldr	r3, [r7, #4]
 8006372:	685b      	ldr	r3, [r3, #4]
 8006374:	687a      	ldr	r2, [r7, #4]
 8006376:	429a      	cmp	r2, r3
 8006378:	bf0c      	ite	eq
 800637a:	2301      	moveq	r3, #1
 800637c:	2300      	movne	r3, #0
 800637e:	b2db      	uxtb	r3, r3
}
 8006380:	4618      	mov	r0, r3
 8006382:	370c      	adds	r7, #12
 8006384:	46bd      	mov	sp, r7
 8006386:	f85d 7b04 	ldr.w	r7, [sp], #4
 800638a:	4770      	bx	lr

0800638c <LOS_IntLock>:
{
 800638c:	b580      	push	{r7, lr}
 800638e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8006390:	f7fa fc9a 	bl	8000cc8 <ArchIntLock>
 8006394:	4603      	mov	r3, r0
}
 8006396:	4618      	mov	r0, r3
 8006398:	bd80      	pop	{r7, pc}

0800639a <LOS_IntRestore>:
{
 800639a:	b580      	push	{r7, lr}
 800639c:	b082      	sub	sp, #8
 800639e:	af00      	add	r7, sp, #0
 80063a0:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80063a2:	6878      	ldr	r0, [r7, #4]
 80063a4:	f7fa fc98 	bl	8000cd8 <ArchIntRestore>
}
 80063a8:	bf00      	nop
 80063aa:	3708      	adds	r7, #8
 80063ac:	46bd      	mov	sp, r7
 80063ae:	bd80      	pop	{r7, pc}

080063b0 <LOS_SpinLockSave>:
{
 80063b0:	b580      	push	{r7, lr}
 80063b2:	b082      	sub	sp, #8
 80063b4:	af00      	add	r7, sp, #0
 80063b6:	6078      	str	r0, [r7, #4]
 80063b8:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 80063ba:	f7ff ffe7 	bl	800638c <LOS_IntLock>
 80063be:	4602      	mov	r2, r0
 80063c0:	683b      	ldr	r3, [r7, #0]
 80063c2:	601a      	str	r2, [r3, #0]
}
 80063c4:	bf00      	nop
 80063c6:	3708      	adds	r7, #8
 80063c8:	46bd      	mov	sp, r7
 80063ca:	bd80      	pop	{r7, pc}

080063cc <LOS_SpinUnlockRestore>:
{
 80063cc:	b580      	push	{r7, lr}
 80063ce:	b082      	sub	sp, #8
 80063d0:	af00      	add	r7, sp, #0
 80063d2:	6078      	str	r0, [r7, #4]
 80063d4:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 80063d6:	6838      	ldr	r0, [r7, #0]
 80063d8:	f7ff ffdf 	bl	800639a <LOS_IntRestore>
}
 80063dc:	bf00      	nop
 80063de:	3708      	adds	r7, #8
 80063e0:	46bd      	mov	sp, r7
 80063e2:	bd80      	pop	{r7, pc}

080063e4 <OsSemPendedTaskNamePrint>:

#ifdef LOSCFG_DEBUG_SEMAPHORE
#define OS_ALL_SEM_MASK 0xffffffff

STATIC VOID OsSemPendedTaskNamePrint(LosSemCB *semNode)
{
 80063e4:	b580      	push	{r7, lr}
 80063e6:	b098      	sub	sp, #96	; 0x60
 80063e8:	af00      	add	r7, sp, #0
 80063ea:	6078      	str	r0, [r7, #4]
 80063ec:	4b40      	ldr	r3, [pc, #256]	; (80064f0 <OsSemPendedTaskNamePrint+0x10c>)
 80063ee:	681b      	ldr	r3, [r3, #0]
 80063f0:	65fb      	str	r3, [r7, #92]	; 0x5c
 80063f2:	f04f 0300 	mov.w	r3, #0
    LosTaskCB *tskCB = NULL;
 80063f6:	2300      	movs	r3, #0
 80063f8:	613b      	str	r3, [r7, #16]
    CHAR *nameArr[LOSCFG_BASE_CORE_TSK_LIMIT] = {0};
 80063fa:	f107 031c 	add.w	r3, r7, #28
 80063fe:	2240      	movs	r2, #64	; 0x40
 8006400:	2100      	movs	r1, #0
 8006402:	4618      	mov	r0, r3
 8006404:	f008 fa1e 	bl	800e844 <memset>
    UINT32 i, intSave;
    UINT32 num = 0;
 8006408:	2300      	movs	r3, #0
 800640a:	61bb      	str	r3, [r7, #24]

    SCHEDULER_LOCK(intSave);
 800640c:	f107 030c 	add.w	r3, r7, #12
 8006410:	4619      	mov	r1, r3
 8006412:	4838      	ldr	r0, [pc, #224]	; (80064f4 <OsSemPendedTaskNamePrint+0x110>)
 8006414:	f7ff ffcc 	bl	80063b0 <LOS_SpinLockSave>
    if ((semNode->semStat == LOS_UNUSED) || (LOS_ListEmpty(&semNode->semList))) {
 8006418:	687b      	ldr	r3, [r7, #4]
 800641a:	781b      	ldrb	r3, [r3, #0]
 800641c:	2b00      	cmp	r3, #0
 800641e:	d007      	beq.n	8006430 <OsSemPendedTaskNamePrint+0x4c>
 8006420:	687b      	ldr	r3, [r7, #4]
 8006422:	3308      	adds	r3, #8
 8006424:	4618      	mov	r0, r3
 8006426:	f7ff ff9f 	bl	8006368 <LOS_ListEmpty>
 800642a:	4603      	mov	r3, r0
 800642c:	2b00      	cmp	r3, #0
 800642e:	d005      	beq.n	800643c <OsSemPendedTaskNamePrint+0x58>
        SCHEDULER_UNLOCK(intSave);
 8006430:	68fb      	ldr	r3, [r7, #12]
 8006432:	4619      	mov	r1, r3
 8006434:	482f      	ldr	r0, [pc, #188]	; (80064f4 <OsSemPendedTaskNamePrint+0x110>)
 8006436:	f7ff ffc9 	bl	80063cc <LOS_SpinUnlockRestore>
 800643a:	e04e      	b.n	80064da <OsSemPendedTaskNamePrint+0xf6>
        return;
    }

    LOS_DL_LIST_FOR_EACH_ENTRY(tskCB, &semNode->semList, LosTaskCB, pendList) {
 800643c:	687b      	ldr	r3, [r7, #4]
 800643e:	68db      	ldr	r3, [r3, #12]
 8006440:	3b40      	subs	r3, #64	; 0x40
 8006442:	613b      	str	r3, [r7, #16]
 8006444:	e011      	b.n	800646a <OsSemPendedTaskNamePrint+0x86>
        nameArr[num++] = tskCB->taskName;
 8006446:	69bb      	ldr	r3, [r7, #24]
 8006448:	1c5a      	adds	r2, r3, #1
 800644a:	61ba      	str	r2, [r7, #24]
 800644c:	693a      	ldr	r2, [r7, #16]
 800644e:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8006450:	009b      	lsls	r3, r3, #2
 8006452:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8006456:	440b      	add	r3, r1
 8006458:	f843 2c44 	str.w	r2, [r3, #-68]
        if (num == LOSCFG_BASE_CORE_TSK_LIMIT) {
 800645c:	69bb      	ldr	r3, [r7, #24]
 800645e:	2b10      	cmp	r3, #16
 8006460:	d00b      	beq.n	800647a <OsSemPendedTaskNamePrint+0x96>
    LOS_DL_LIST_FOR_EACH_ENTRY(tskCB, &semNode->semList, LosTaskCB, pendList) {
 8006462:	693b      	ldr	r3, [r7, #16]
 8006464:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8006466:	3b40      	subs	r3, #64	; 0x40
 8006468:	613b      	str	r3, [r7, #16]
 800646a:	693b      	ldr	r3, [r7, #16]
 800646c:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8006470:	687b      	ldr	r3, [r7, #4]
 8006472:	3308      	adds	r3, #8
 8006474:	429a      	cmp	r2, r3
 8006476:	d1e6      	bne.n	8006446 <OsSemPendedTaskNamePrint+0x62>
 8006478:	e000      	b.n	800647c <OsSemPendedTaskNamePrint+0x98>
            break;
 800647a:	bf00      	nop
        }
    }
    SCHEDULER_UNLOCK(intSave);
 800647c:	68fb      	ldr	r3, [r7, #12]
 800647e:	4619      	mov	r1, r3
 8006480:	481c      	ldr	r0, [pc, #112]	; (80064f4 <OsSemPendedTaskNamePrint+0x110>)
 8006482:	f7ff ffa3 	bl	80063cc <LOS_SpinUnlockRestore>

    PRINTK("Pended task list : ");
 8006486:	481c      	ldr	r0, [pc, #112]	; (80064f8 <OsSemPendedTaskNamePrint+0x114>)
 8006488:	f7fe f920 	bl	80046cc <dprintf>
    for (i = 0; i < num; i++) {
 800648c:	2300      	movs	r3, #0
 800648e:	617b      	str	r3, [r7, #20]
 8006490:	e01c      	b.n	80064cc <OsSemPendedTaskNamePrint+0xe8>
        if (i == 0) {
 8006492:	697b      	ldr	r3, [r7, #20]
 8006494:	2b00      	cmp	r3, #0
 8006496:	d10b      	bne.n	80064b0 <OsSemPendedTaskNamePrint+0xcc>
            PRINTK("%s\n", nameArr[i]);
 8006498:	697b      	ldr	r3, [r7, #20]
 800649a:	009b      	lsls	r3, r3, #2
 800649c:	f107 0260 	add.w	r2, r7, #96	; 0x60
 80064a0:	4413      	add	r3, r2
 80064a2:	f853 3c44 	ldr.w	r3, [r3, #-68]
 80064a6:	4619      	mov	r1, r3
 80064a8:	4814      	ldr	r0, [pc, #80]	; (80064fc <OsSemPendedTaskNamePrint+0x118>)
 80064aa:	f7fe f90f 	bl	80046cc <dprintf>
 80064ae:	e00a      	b.n	80064c6 <OsSemPendedTaskNamePrint+0xe2>
        } else {
            PRINTK(", %s", nameArr[i]);
 80064b0:	697b      	ldr	r3, [r7, #20]
 80064b2:	009b      	lsls	r3, r3, #2
 80064b4:	f107 0260 	add.w	r2, r7, #96	; 0x60
 80064b8:	4413      	add	r3, r2
 80064ba:	f853 3c44 	ldr.w	r3, [r3, #-68]
 80064be:	4619      	mov	r1, r3
 80064c0:	480f      	ldr	r0, [pc, #60]	; (8006500 <OsSemPendedTaskNamePrint+0x11c>)
 80064c2:	f7fe f903 	bl	80046cc <dprintf>
    for (i = 0; i < num; i++) {
 80064c6:	697b      	ldr	r3, [r7, #20]
 80064c8:	3301      	adds	r3, #1
 80064ca:	617b      	str	r3, [r7, #20]
 80064cc:	697a      	ldr	r2, [r7, #20]
 80064ce:	69bb      	ldr	r3, [r7, #24]
 80064d0:	429a      	cmp	r2, r3
 80064d2:	d3de      	bcc.n	8006492 <OsSemPendedTaskNamePrint+0xae>
        }
    }
    PRINTK("\n");
 80064d4:	480b      	ldr	r0, [pc, #44]	; (8006504 <OsSemPendedTaskNamePrint+0x120>)
 80064d6:	f7fe f8f9 	bl	80046cc <dprintf>
}
 80064da:	4b05      	ldr	r3, [pc, #20]	; (80064f0 <OsSemPendedTaskNamePrint+0x10c>)
 80064dc:	681a      	ldr	r2, [r3, #0]
 80064de:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80064e0:	405a      	eors	r2, r3
 80064e2:	d001      	beq.n	80064e8 <OsSemPendedTaskNamePrint+0x104>
 80064e4:	f7fd ff80 	bl	80043e8 <__stack_chk_fail>
 80064e8:	3760      	adds	r7, #96	; 0x60
 80064ea:	46bd      	mov	sp, r7
 80064ec:	bd80      	pop	{r7, pc}
 80064ee:	bf00      	nop
 80064f0:	0802072c 	.word	0x0802072c
 80064f4:	20000764 	.word	0x20000764
 80064f8:	08020708 	.word	0x08020708
 80064fc:	0802071c 	.word	0x0802071c
 8006500:	08020720 	.word	0x08020720
 8006504:	08020728 	.word	0x08020728

08006508 <SemCompareValue>:
    TSK_ENTRY_FUNC creator; /* The task entry who created this sem */
} SemDebugCB;
STATIC SemDebugCB *g_semDebugArray = NULL;

STATIC BOOL SemCompareValue(const SortParam *sortParam, UINT32 left, UINT32 right)
{
 8006508:	b490      	push	{r4, r7}
 800650a:	b084      	sub	sp, #16
 800650c:	af00      	add	r7, sp, #0
 800650e:	60f8      	str	r0, [r7, #12]
 8006510:	60b9      	str	r1, [r7, #8]
 8006512:	607a      	str	r2, [r7, #4]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 8006514:	68fb      	ldr	r3, [r7, #12]
 8006516:	681a      	ldr	r2, [r3, #0]
 8006518:	68fb      	ldr	r3, [r7, #12]
 800651a:	685b      	ldr	r3, [r3, #4]
 800651c:	68b9      	ldr	r1, [r7, #8]
 800651e:	fb01 f103 	mul.w	r1, r1, r3
 8006522:	68fb      	ldr	r3, [r7, #12]
 8006524:	68db      	ldr	r3, [r3, #12]
 8006526:	440b      	add	r3, r1
 8006528:	4413      	add	r3, r2
 800652a:	e9d3 2300 	ldrd	r2, r3, [r3]
            *((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, right)));
 800652e:	68f9      	ldr	r1, [r7, #12]
 8006530:	6808      	ldr	r0, [r1, #0]
 8006532:	68f9      	ldr	r1, [r7, #12]
 8006534:	6849      	ldr	r1, [r1, #4]
 8006536:	687c      	ldr	r4, [r7, #4]
 8006538:	fb04 f401 	mul.w	r4, r4, r1
 800653c:	68f9      	ldr	r1, [r7, #12]
 800653e:	68c9      	ldr	r1, [r1, #12]
 8006540:	4421      	add	r1, r4
 8006542:	4401      	add	r1, r0
 8006544:	e9d1 0100 	ldrd	r0, r1, [r1]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 8006548:	4299      	cmp	r1, r3
 800654a:	bf08      	it	eq
 800654c:	4290      	cmpeq	r0, r2
 800654e:	bf34      	ite	cc
 8006550:	2301      	movcc	r3, #1
 8006552:	2300      	movcs	r3, #0
 8006554:	b2db      	uxtb	r3, r3
}
 8006556:	4618      	mov	r0, r3
 8006558:	3710      	adds	r7, #16
 800655a:	46bd      	mov	sp, r7
 800655c:	bc90      	pop	{r4, r7}
 800655e:	4770      	bx	lr

08006560 <OsSemDbgInit>:

UINT32 OsSemDbgInit(VOID)
{
 8006560:	b580      	push	{r7, lr}
 8006562:	b082      	sub	sp, #8
 8006564:	af00      	add	r7, sp, #0
    UINT32 size = LOSCFG_BASE_IPC_SEM_LIMIT * sizeof(SemDebugCB);
 8006566:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 800656a:	607b      	str	r3, [r7, #4]
    /* system resident memory, don't free */
    g_semDebugArray = (SemDebugCB *)LOS_MemAlloc(m_aucSysMem1, size);
 800656c:	4b10      	ldr	r3, [pc, #64]	; (80065b0 <OsSemDbgInit+0x50>)
 800656e:	681b      	ldr	r3, [r3, #0]
 8006570:	6879      	ldr	r1, [r7, #4]
 8006572:	4618      	mov	r0, r3
 8006574:	f002 fa18 	bl	80089a8 <LOS_MemAlloc>
 8006578:	4603      	mov	r3, r0
 800657a:	4a0e      	ldr	r2, [pc, #56]	; (80065b4 <OsSemDbgInit+0x54>)
 800657c:	6013      	str	r3, [r2, #0]
    if (g_semDebugArray == NULL) {
 800657e:	4b0d      	ldr	r3, [pc, #52]	; (80065b4 <OsSemDbgInit+0x54>)
 8006580:	681b      	ldr	r3, [r3, #0]
 8006582:	2b00      	cmp	r3, #0
 8006584:	d108      	bne.n	8006598 <OsSemDbgInit+0x38>
        PRINT_ERR("%s: malloc failed!\n", __FUNCTION__);
 8006586:	480c      	ldr	r0, [pc, #48]	; (80065b8 <OsSemDbgInit+0x58>)
 8006588:	f7fe f8a0 	bl	80046cc <dprintf>
 800658c:	490b      	ldr	r1, [pc, #44]	; (80065bc <OsSemDbgInit+0x5c>)
 800658e:	480c      	ldr	r0, [pc, #48]	; (80065c0 <OsSemDbgInit+0x60>)
 8006590:	f7fe f89c 	bl	80046cc <dprintf>
        return LOS_NOK;
 8006594:	2301      	movs	r3, #1
 8006596:	e007      	b.n	80065a8 <OsSemDbgInit+0x48>
    }
    (VOID)memset_s(g_semDebugArray, size, 0, size);
 8006598:	4b06      	ldr	r3, [pc, #24]	; (80065b4 <OsSemDbgInit+0x54>)
 800659a:	6818      	ldr	r0, [r3, #0]
 800659c:	687b      	ldr	r3, [r7, #4]
 800659e:	2200      	movs	r2, #0
 80065a0:	6879      	ldr	r1, [r7, #4]
 80065a2:	f00f fd73 	bl	801608c <memset_s>
    return LOS_OK;
 80065a6:	2300      	movs	r3, #0
}
 80065a8:	4618      	mov	r0, r3
 80065aa:	3708      	adds	r7, #8
 80065ac:	46bd      	mov	sp, r7
 80065ae:	bd80      	pop	{r7, pc}
 80065b0:	200021b8 	.word	0x200021b8
 80065b4:	200007a8 	.word	0x200007a8
 80065b8:	08020730 	.word	0x08020730
 80065bc:	08023350 	.word	0x08023350
 80065c0:	08020738 	.word	0x08020738

080065c4 <OsSemDbgTimeUpdate>:

VOID OsSemDbgTimeUpdate(UINT32 semId)
{
 80065c4:	b580      	push	{r7, lr}
 80065c6:	b084      	sub	sp, #16
 80065c8:	af00      	add	r7, sp, #0
 80065ca:	6078      	str	r0, [r7, #4]
    SemDebugCB *semDebug = &g_semDebugArray[GET_SEM_INDEX(semId)];
 80065cc:	4b0a      	ldr	r3, [pc, #40]	; (80065f8 <OsSemDbgTimeUpdate+0x34>)
 80065ce:	6819      	ldr	r1, [r3, #0]
 80065d0:	687b      	ldr	r3, [r7, #4]
 80065d2:	b29a      	uxth	r2, r3
 80065d4:	4613      	mov	r3, r2
 80065d6:	005b      	lsls	r3, r3, #1
 80065d8:	4413      	add	r3, r2
 80065da:	00db      	lsls	r3, r3, #3
 80065dc:	440b      	add	r3, r1
 80065de:	60fb      	str	r3, [r7, #12]
    semDebug->lastAccessTime = LOS_TickCountGet();
 80065e0:	f7fd fdca 	bl	8004178 <LOS_TickCountGet>
 80065e4:	4602      	mov	r2, r0
 80065e6:	460b      	mov	r3, r1
 80065e8:	68f9      	ldr	r1, [r7, #12]
 80065ea:	e9c1 2302 	strd	r2, r3, [r1, #8]
    return;
 80065ee:	bf00      	nop
}
 80065f0:	3710      	adds	r7, #16
 80065f2:	46bd      	mov	sp, r7
 80065f4:	bd80      	pop	{r7, pc}
 80065f6:	bf00      	nop
 80065f8:	200007a8 	.word	0x200007a8

080065fc <OsSemSort>:
    semDebug->origSemCount = count;
    return;
}

STATIC VOID OsSemSort(UINT32 *semIndexArray, UINT32 usedCount)
{
 80065fc:	b5b0      	push	{r4, r5, r7, lr}
 80065fe:	b09a      	sub	sp, #104	; 0x68
 8006600:	af04      	add	r7, sp, #16
 8006602:	6078      	str	r0, [r7, #4]
 8006604:	6039      	str	r1, [r7, #0]
 8006606:	4b53      	ldr	r3, [pc, #332]	; (8006754 <OsSemSort+0x158>)
 8006608:	681b      	ldr	r3, [r3, #0]
 800660a:	657b      	str	r3, [r7, #84]	; 0x54
 800660c:	f04f 0300 	mov.w	r3, #0
    UINT32 i, intSave;
    LosSemCB *semCB = NULL;
 8006610:	2300      	movs	r3, #0
 8006612:	617b      	str	r3, [r7, #20]
    LosSemCB semNode = {0};
 8006614:	f107 0318 	add.w	r3, r7, #24
 8006618:	2200      	movs	r2, #0
 800661a:	601a      	str	r2, [r3, #0]
 800661c:	605a      	str	r2, [r3, #4]
 800661e:	609a      	str	r2, [r3, #8]
 8006620:	60da      	str	r2, [r3, #12]
    SemDebugCB semDebug = {0};
 8006622:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8006626:	2200      	movs	r2, #0
 8006628:	601a      	str	r2, [r3, #0]
 800662a:	605a      	str	r2, [r3, #4]
 800662c:	609a      	str	r2, [r3, #8]
 800662e:	60da      	str	r2, [r3, #12]
 8006630:	611a      	str	r2, [r3, #16]
 8006632:	615a      	str	r2, [r3, #20]
    SortParam semSortParam;
    semSortParam.buf = (CHAR *)g_semDebugArray;
 8006634:	4b48      	ldr	r3, [pc, #288]	; (8006758 <OsSemSort+0x15c>)
 8006636:	681b      	ldr	r3, [r3, #0]
 8006638:	62bb      	str	r3, [r7, #40]	; 0x28
    semSortParam.ctrlBlockSize = sizeof(SemDebugCB);
 800663a:	2318      	movs	r3, #24
 800663c:	62fb      	str	r3, [r7, #44]	; 0x2c
    semSortParam.ctrlBlockCnt = LOSCFG_BASE_IPC_SEM_LIMIT;
 800663e:	2314      	movs	r3, #20
 8006640:	633b      	str	r3, [r7, #48]	; 0x30
    semSortParam.sortElemOff = LOS_OFF_SET_OF(SemDebugCB, lastAccessTime);
 8006642:	2308      	movs	r3, #8
 8006644:	637b      	str	r3, [r7, #52]	; 0x34

    /* It will Print out ALL the Used Semaphore List. */
    PRINTK("Used Semaphore List: \n");
 8006646:	4845      	ldr	r0, [pc, #276]	; (800675c <OsSemSort+0x160>)
 8006648:	f7fe f840 	bl	80046cc <dprintf>
    PRINTK("\r\n   SemID    Count    OriginalCount   Creater(TaskEntry)    LastAccessTime\n");
 800664c:	4844      	ldr	r0, [pc, #272]	; (8006760 <OsSemSort+0x164>)
 800664e:	f7fe f83d 	bl	80046cc <dprintf>
    PRINTK("   ------   ------   -------------   ------------------    --------------   \n");
 8006652:	4844      	ldr	r0, [pc, #272]	; (8006764 <OsSemSort+0x168>)
 8006654:	f7fe f83a 	bl	80046cc <dprintf>

    SCHEDULER_LOCK(intSave);
 8006658:	f107 030c 	add.w	r3, r7, #12
 800665c:	4619      	mov	r1, r3
 800665e:	4842      	ldr	r0, [pc, #264]	; (8006768 <OsSemSort+0x16c>)
 8006660:	f7ff fea6 	bl	80063b0 <LOS_SpinLockSave>
    OsArraySort(semIndexArray, 0, usedCount - 1, &semSortParam, SemCompareValue);
 8006664:	683b      	ldr	r3, [r7, #0]
 8006666:	1e5a      	subs	r2, r3, #1
 8006668:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800666c:	493f      	ldr	r1, [pc, #252]	; (800676c <OsSemSort+0x170>)
 800666e:	9100      	str	r1, [sp, #0]
 8006670:	2100      	movs	r1, #0
 8006672:	6878      	ldr	r0, [r7, #4]
 8006674:	f7fc f838 	bl	80026e8 <OsArraySort>
    SCHEDULER_UNLOCK(intSave);
 8006678:	68fb      	ldr	r3, [r7, #12]
 800667a:	4619      	mov	r1, r3
 800667c:	483a      	ldr	r0, [pc, #232]	; (8006768 <OsSemSort+0x16c>)
 800667e:	f7ff fea5 	bl	80063cc <LOS_SpinUnlockRestore>
    for (i = 0; i < usedCount; i++) {
 8006682:	2300      	movs	r3, #0
 8006684:	613b      	str	r3, [r7, #16]
 8006686:	e056      	b.n	8006736 <OsSemSort+0x13a>
        semCB = GET_SEM(semIndexArray[i]);
 8006688:	4b39      	ldr	r3, [pc, #228]	; (8006770 <OsSemSort+0x174>)
 800668a:	681a      	ldr	r2, [r3, #0]
 800668c:	693b      	ldr	r3, [r7, #16]
 800668e:	009b      	lsls	r3, r3, #2
 8006690:	6879      	ldr	r1, [r7, #4]
 8006692:	440b      	add	r3, r1
 8006694:	681b      	ldr	r3, [r3, #0]
 8006696:	b29b      	uxth	r3, r3
 8006698:	011b      	lsls	r3, r3, #4
 800669a:	4413      	add	r3, r2
 800669c:	617b      	str	r3, [r7, #20]
        SCHEDULER_LOCK(intSave);
 800669e:	f107 030c 	add.w	r3, r7, #12
 80066a2:	4619      	mov	r1, r3
 80066a4:	4830      	ldr	r0, [pc, #192]	; (8006768 <OsSemSort+0x16c>)
 80066a6:	f7ff fe83 	bl	80063b0 <LOS_SpinLockSave>
        (VOID)memcpy_s(&semNode, sizeof(LosSemCB), semCB, sizeof(LosSemCB));
 80066aa:	f107 0018 	add.w	r0, r7, #24
 80066ae:	2310      	movs	r3, #16
 80066b0:	697a      	ldr	r2, [r7, #20]
 80066b2:	2110      	movs	r1, #16
 80066b4:	f00f ff72 	bl	801659c <memcpy_s>
        (VOID)memcpy_s(&semDebug, sizeof(SemDebugCB), &g_semDebugArray[semIndexArray[i]], sizeof(SemDebugCB));
 80066b8:	4b27      	ldr	r3, [pc, #156]	; (8006758 <OsSemSort+0x15c>)
 80066ba:	6819      	ldr	r1, [r3, #0]
 80066bc:	693b      	ldr	r3, [r7, #16]
 80066be:	009b      	lsls	r3, r3, #2
 80066c0:	687a      	ldr	r2, [r7, #4]
 80066c2:	4413      	add	r3, r2
 80066c4:	681a      	ldr	r2, [r3, #0]
 80066c6:	4613      	mov	r3, r2
 80066c8:	005b      	lsls	r3, r3, #1
 80066ca:	4413      	add	r3, r2
 80066cc:	00db      	lsls	r3, r3, #3
 80066ce:	18ca      	adds	r2, r1, r3
 80066d0:	f107 0038 	add.w	r0, r7, #56	; 0x38
 80066d4:	2318      	movs	r3, #24
 80066d6:	2118      	movs	r1, #24
 80066d8:	f00f ff60 	bl	801659c <memcpy_s>
        SCHEDULER_UNLOCK(intSave);
 80066dc:	68fb      	ldr	r3, [r7, #12]
 80066de:	4619      	mov	r1, r3
 80066e0:	4821      	ldr	r0, [pc, #132]	; (8006768 <OsSemSort+0x16c>)
 80066e2:	f7ff fe73 	bl	80063cc <LOS_SpinUnlockRestore>
        if ((semNode.semStat != LOS_USED) || (semDebug.creator == NULL)) {
 80066e6:	7e3b      	ldrb	r3, [r7, #24]
 80066e8:	2b01      	cmp	r3, #1
 80066ea:	d120      	bne.n	800672e <OsSemSort+0x132>
 80066ec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80066ee:	2b00      	cmp	r3, #0
 80066f0:	d01d      	beq.n	800672e <OsSemSort+0x132>
            continue;
        }
        PRINTK("   0x%-07x0x%-07u0x%-14u%-22p0x%llx\n", semNode.semId, semDebug.origSemCount,
 80066f2:	69f8      	ldr	r0, [r7, #28]
 80066f4:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 80066f6:	461c      	mov	r4, r3
 80066f8:	8b7b      	ldrh	r3, [r7, #26]
 80066fa:	461d      	mov	r5, r3
 80066fc:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 80066fe:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 8006702:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8006706:	9100      	str	r1, [sp, #0]
 8006708:	462b      	mov	r3, r5
 800670a:	4622      	mov	r2, r4
 800670c:	4601      	mov	r1, r0
 800670e:	4819      	ldr	r0, [pc, #100]	; (8006774 <OsSemSort+0x178>)
 8006710:	f7fd ffdc 	bl	80046cc <dprintf>
               semNode.semCount, semDebug.creator, semDebug.lastAccessTime);
        if (!LOS_ListEmpty(&semNode.semList)) {
 8006714:	f107 0318 	add.w	r3, r7, #24
 8006718:	3308      	adds	r3, #8
 800671a:	4618      	mov	r0, r3
 800671c:	f7ff fe24 	bl	8006368 <LOS_ListEmpty>
 8006720:	4603      	mov	r3, r0
 8006722:	2b00      	cmp	r3, #0
 8006724:	d104      	bne.n	8006730 <OsSemSort+0x134>
            OsSemPendedTaskNamePrint(semCB);
 8006726:	6978      	ldr	r0, [r7, #20]
 8006728:	f7ff fe5c 	bl	80063e4 <OsSemPendedTaskNamePrint>
 800672c:	e000      	b.n	8006730 <OsSemSort+0x134>
            continue;
 800672e:	bf00      	nop
    for (i = 0; i < usedCount; i++) {
 8006730:	693b      	ldr	r3, [r7, #16]
 8006732:	3301      	adds	r3, #1
 8006734:	613b      	str	r3, [r7, #16]
 8006736:	693a      	ldr	r2, [r7, #16]
 8006738:	683b      	ldr	r3, [r7, #0]
 800673a:	429a      	cmp	r2, r3
 800673c:	d3a4      	bcc.n	8006688 <OsSemSort+0x8c>
        }
    }
}
 800673e:	bf00      	nop
 8006740:	4b04      	ldr	r3, [pc, #16]	; (8006754 <OsSemSort+0x158>)
 8006742:	681a      	ldr	r2, [r3, #0]
 8006744:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006746:	405a      	eors	r2, r3
 8006748:	d001      	beq.n	800674e <OsSemSort+0x152>
 800674a:	f7fd fe4d 	bl	80043e8 <__stack_chk_fail>
 800674e:	3758      	adds	r7, #88	; 0x58
 8006750:	46bd      	mov	sp, r7
 8006752:	bdb0      	pop	{r4, r5, r7, pc}
 8006754:	0802082c 	.word	0x0802082c
 8006758:	200007a8 	.word	0x200007a8
 800675c:	0802074c 	.word	0x0802074c
 8006760:	08020764 	.word	0x08020764
 8006764:	080207b4 	.word	0x080207b4
 8006768:	20000764 	.word	0x20000764
 800676c:	08006509 	.word	0x08006509
 8006770:	20000790 	.word	0x20000790
 8006774:	08020804 	.word	0x08020804

08006778 <OsSemInfoGetFullData>:

UINT32 OsSemInfoGetFullData(VOID)
{
 8006778:	b580      	push	{r7, lr}
 800677a:	b088      	sub	sp, #32
 800677c:	af00      	add	r7, sp, #0
 800677e:	4b52      	ldr	r3, [pc, #328]	; (80068c8 <OsSemInfoGetFullData+0x150>)
 8006780:	681b      	ldr	r3, [r3, #0]
 8006782:	61fb      	str	r3, [r7, #28]
 8006784:	f04f 0300 	mov.w	r3, #0
    UINT32 usedSemCnt = 0;
 8006788:	2300      	movs	r3, #0
 800678a:	607b      	str	r3, [r7, #4]
    LosSemCB *semNode = NULL;
 800678c:	2300      	movs	r3, #0
 800678e:	613b      	str	r3, [r7, #16]
    SemDebugCB *semDebug = NULL;
 8006790:	2300      	movs	r3, #0
 8006792:	617b      	str	r3, [r7, #20]
    UINT32 i;
    UINT32 *semIndexArray = NULL;
 8006794:	2300      	movs	r3, #0
 8006796:	61bb      	str	r3, [r7, #24]
    UINT32 count, intSave;

    SCHEDULER_LOCK(intSave);
 8006798:	463b      	mov	r3, r7
 800679a:	4619      	mov	r1, r3
 800679c:	484b      	ldr	r0, [pc, #300]	; (80068cc <OsSemInfoGetFullData+0x154>)
 800679e:	f7ff fe07 	bl	80063b0 <LOS_SpinLockSave>
    /* Get the used semaphore count. */
    for (i = 0; i < LOSCFG_BASE_IPC_SEM_LIMIT; i++) {
 80067a2:	2300      	movs	r3, #0
 80067a4:	60bb      	str	r3, [r7, #8]
 80067a6:	e01d      	b.n	80067e4 <OsSemInfoGetFullData+0x6c>
        semNode = GET_SEM(i);
 80067a8:	4b49      	ldr	r3, [pc, #292]	; (80068d0 <OsSemInfoGetFullData+0x158>)
 80067aa:	681a      	ldr	r2, [r3, #0]
 80067ac:	68bb      	ldr	r3, [r7, #8]
 80067ae:	b29b      	uxth	r3, r3
 80067b0:	011b      	lsls	r3, r3, #4
 80067b2:	4413      	add	r3, r2
 80067b4:	613b      	str	r3, [r7, #16]
        semDebug = &g_semDebugArray[i];
 80067b6:	4b47      	ldr	r3, [pc, #284]	; (80068d4 <OsSemInfoGetFullData+0x15c>)
 80067b8:	6819      	ldr	r1, [r3, #0]
 80067ba:	68ba      	ldr	r2, [r7, #8]
 80067bc:	4613      	mov	r3, r2
 80067be:	005b      	lsls	r3, r3, #1
 80067c0:	4413      	add	r3, r2
 80067c2:	00db      	lsls	r3, r3, #3
 80067c4:	440b      	add	r3, r1
 80067c6:	617b      	str	r3, [r7, #20]
        if ((semNode->semStat == LOS_USED) && (semDebug->creator != NULL)) {
 80067c8:	693b      	ldr	r3, [r7, #16]
 80067ca:	781b      	ldrb	r3, [r3, #0]
 80067cc:	2b01      	cmp	r3, #1
 80067ce:	d106      	bne.n	80067de <OsSemInfoGetFullData+0x66>
 80067d0:	697b      	ldr	r3, [r7, #20]
 80067d2:	691b      	ldr	r3, [r3, #16]
 80067d4:	2b00      	cmp	r3, #0
 80067d6:	d002      	beq.n	80067de <OsSemInfoGetFullData+0x66>
            usedSemCnt++;
 80067d8:	687b      	ldr	r3, [r7, #4]
 80067da:	3301      	adds	r3, #1
 80067dc:	607b      	str	r3, [r7, #4]
    for (i = 0; i < LOSCFG_BASE_IPC_SEM_LIMIT; i++) {
 80067de:	68bb      	ldr	r3, [r7, #8]
 80067e0:	3301      	adds	r3, #1
 80067e2:	60bb      	str	r3, [r7, #8]
 80067e4:	68bb      	ldr	r3, [r7, #8]
 80067e6:	2b13      	cmp	r3, #19
 80067e8:	d9de      	bls.n	80067a8 <OsSemInfoGetFullData+0x30>
        }
    }
    SCHEDULER_UNLOCK(intSave);
 80067ea:	683b      	ldr	r3, [r7, #0]
 80067ec:	4619      	mov	r1, r3
 80067ee:	4837      	ldr	r0, [pc, #220]	; (80068cc <OsSemInfoGetFullData+0x154>)
 80067f0:	f7ff fdec 	bl	80063cc <LOS_SpinUnlockRestore>

    if (usedSemCnt > 0) {
 80067f4:	687b      	ldr	r3, [r7, #4]
 80067f6:	2b00      	cmp	r3, #0
 80067f8:	d05a      	beq.n	80068b0 <OsSemInfoGetFullData+0x138>
        semIndexArray = (UINT32 *)LOS_MemAlloc((VOID *)OS_SYS_MEM_ADDR, usedSemCnt * sizeof(UINT32));
 80067fa:	4b37      	ldr	r3, [pc, #220]	; (80068d8 <OsSemInfoGetFullData+0x160>)
 80067fc:	681b      	ldr	r3, [r3, #0]
 80067fe:	461a      	mov	r2, r3
 8006800:	687b      	ldr	r3, [r7, #4]
 8006802:	009b      	lsls	r3, r3, #2
 8006804:	4619      	mov	r1, r3
 8006806:	4610      	mov	r0, r2
 8006808:	f002 f8ce 	bl	80089a8 <LOS_MemAlloc>
 800680c:	61b8      	str	r0, [r7, #24]
        if (semIndexArray == NULL) {
 800680e:	69bb      	ldr	r3, [r7, #24]
 8006810:	2b00      	cmp	r3, #0
 8006812:	d105      	bne.n	8006820 <OsSemInfoGetFullData+0xa8>
            PRINTK("LOS_MemAlloc failed in %s \n", __func__);
 8006814:	4931      	ldr	r1, [pc, #196]	; (80068dc <OsSemInfoGetFullData+0x164>)
 8006816:	4832      	ldr	r0, [pc, #200]	; (80068e0 <OsSemInfoGetFullData+0x168>)
 8006818:	f7fd ff58 	bl	80046cc <dprintf>
            return LOS_NOK;
 800681c:	2301      	movs	r3, #1
 800681e:	e048      	b.n	80068b2 <OsSemInfoGetFullData+0x13a>
        }

        /* Fill the semIndexArray with the real index. */
        count = 0;
 8006820:	2300      	movs	r3, #0
 8006822:	60fb      	str	r3, [r7, #12]

        SCHEDULER_LOCK(intSave);
 8006824:	463b      	mov	r3, r7
 8006826:	4619      	mov	r1, r3
 8006828:	4828      	ldr	r0, [pc, #160]	; (80068cc <OsSemInfoGetFullData+0x154>)
 800682a:	f7ff fdc1 	bl	80063b0 <LOS_SpinLockSave>
        for (i = 0; i < LOSCFG_BASE_IPC_SEM_LIMIT; i++) {
 800682e:	2300      	movs	r3, #0
 8006830:	60bb      	str	r3, [r7, #8]
 8006832:	e029      	b.n	8006888 <OsSemInfoGetFullData+0x110>
            semNode = GET_SEM(i);
 8006834:	4b26      	ldr	r3, [pc, #152]	; (80068d0 <OsSemInfoGetFullData+0x158>)
 8006836:	681a      	ldr	r2, [r3, #0]
 8006838:	68bb      	ldr	r3, [r7, #8]
 800683a:	b29b      	uxth	r3, r3
 800683c:	011b      	lsls	r3, r3, #4
 800683e:	4413      	add	r3, r2
 8006840:	613b      	str	r3, [r7, #16]
            semDebug = &g_semDebugArray[i];
 8006842:	4b24      	ldr	r3, [pc, #144]	; (80068d4 <OsSemInfoGetFullData+0x15c>)
 8006844:	6819      	ldr	r1, [r3, #0]
 8006846:	68ba      	ldr	r2, [r7, #8]
 8006848:	4613      	mov	r3, r2
 800684a:	005b      	lsls	r3, r3, #1
 800684c:	4413      	add	r3, r2
 800684e:	00db      	lsls	r3, r3, #3
 8006850:	440b      	add	r3, r1
 8006852:	617b      	str	r3, [r7, #20]
            if ((semNode->semStat != LOS_USED) || (semDebug->creator == NULL)) {
 8006854:	693b      	ldr	r3, [r7, #16]
 8006856:	781b      	ldrb	r3, [r3, #0]
 8006858:	2b01      	cmp	r3, #1
 800685a:	d111      	bne.n	8006880 <OsSemInfoGetFullData+0x108>
 800685c:	697b      	ldr	r3, [r7, #20]
 800685e:	691b      	ldr	r3, [r3, #16]
 8006860:	2b00      	cmp	r3, #0
 8006862:	d00d      	beq.n	8006880 <OsSemInfoGetFullData+0x108>
                continue;
            }
            *(semIndexArray + count) = i;
 8006864:	68fb      	ldr	r3, [r7, #12]
 8006866:	009b      	lsls	r3, r3, #2
 8006868:	69ba      	ldr	r2, [r7, #24]
 800686a:	4413      	add	r3, r2
 800686c:	68ba      	ldr	r2, [r7, #8]
 800686e:	601a      	str	r2, [r3, #0]
            count++;
 8006870:	68fb      	ldr	r3, [r7, #12]
 8006872:	3301      	adds	r3, #1
 8006874:	60fb      	str	r3, [r7, #12]
            /* if the count is touched usedSemCnt break. */
            if (count >= usedSemCnt) {
 8006876:	68fa      	ldr	r2, [r7, #12]
 8006878:	687b      	ldr	r3, [r7, #4]
 800687a:	429a      	cmp	r2, r3
 800687c:	d208      	bcs.n	8006890 <OsSemInfoGetFullData+0x118>
 800687e:	e000      	b.n	8006882 <OsSemInfoGetFullData+0x10a>
                continue;
 8006880:	bf00      	nop
        for (i = 0; i < LOSCFG_BASE_IPC_SEM_LIMIT; i++) {
 8006882:	68bb      	ldr	r3, [r7, #8]
 8006884:	3301      	adds	r3, #1
 8006886:	60bb      	str	r3, [r7, #8]
 8006888:	68bb      	ldr	r3, [r7, #8]
 800688a:	2b13      	cmp	r3, #19
 800688c:	d9d2      	bls.n	8006834 <OsSemInfoGetFullData+0xbc>
 800688e:	e000      	b.n	8006892 <OsSemInfoGetFullData+0x11a>
                break;
 8006890:	bf00      	nop
            }
        }
        SCHEDULER_UNLOCK(intSave);
 8006892:	683b      	ldr	r3, [r7, #0]
 8006894:	4619      	mov	r1, r3
 8006896:	480d      	ldr	r0, [pc, #52]	; (80068cc <OsSemInfoGetFullData+0x154>)
 8006898:	f7ff fd98 	bl	80063cc <LOS_SpinUnlockRestore>
        OsSemSort(semIndexArray, count);
 800689c:	68f9      	ldr	r1, [r7, #12]
 800689e:	69b8      	ldr	r0, [r7, #24]
 80068a0:	f7ff feac 	bl	80065fc <OsSemSort>

        /* free the index array. */
        (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, semIndexArray);
 80068a4:	4b0c      	ldr	r3, [pc, #48]	; (80068d8 <OsSemInfoGetFullData+0x160>)
 80068a6:	681b      	ldr	r3, [r3, #0]
 80068a8:	69b9      	ldr	r1, [r7, #24]
 80068aa:	4618      	mov	r0, r3
 80068ac:	f002 f934 	bl	8008b18 <LOS_MemFree>
    }
    return LOS_OK;
 80068b0:	2300      	movs	r3, #0
}
 80068b2:	4a05      	ldr	r2, [pc, #20]	; (80068c8 <OsSemInfoGetFullData+0x150>)
 80068b4:	6811      	ldr	r1, [r2, #0]
 80068b6:	69fa      	ldr	r2, [r7, #28]
 80068b8:	4051      	eors	r1, r2
 80068ba:	d001      	beq.n	80068c0 <OsSemInfoGetFullData+0x148>
 80068bc:	f7fd fd94 	bl	80043e8 <__stack_chk_fail>
 80068c0:	4618      	mov	r0, r3
 80068c2:	3720      	adds	r7, #32
 80068c4:	46bd      	mov	sp, r7
 80068c6:	bd80      	pop	{r7, pc}
 80068c8:	0802084c 	.word	0x0802084c
 80068cc:	20000764 	.word	0x20000764
 80068d0:	20000790 	.word	0x20000790
 80068d4:	200007a8 	.word	0x200007a8
 80068d8:	080001f0 	.word	0x080001f0
 80068dc:	08023360 	.word	0x08023360
 80068e0:	08020830 	.word	0x08020830

080068e4 <OsSemInfoOutput>:

#ifdef LOSCFG_SHELL
STATIC UINT32 OsSemInfoOutput(size_t semId)
{
 80068e4:	b580      	push	{r7, lr}
 80068e6:	b08c      	sub	sp, #48	; 0x30
 80068e8:	af00      	add	r7, sp, #0
 80068ea:	6078      	str	r0, [r7, #4]
 80068ec:	4b4e      	ldr	r3, [pc, #312]	; (8006a28 <OsSemInfoOutput+0x144>)
 80068ee:	681b      	ldr	r3, [r3, #0]
 80068f0:	62fb      	str	r3, [r7, #44]	; 0x2c
 80068f2:	f04f 0300 	mov.w	r3, #0
    UINT32 loop, semCnt, intSave;
    LosSemCB *semCB = NULL;
 80068f6:	2300      	movs	r3, #0
 80068f8:	61bb      	str	r3, [r7, #24]
    LosSemCB semNode = {0};
 80068fa:	f107 031c 	add.w	r3, r7, #28
 80068fe:	2200      	movs	r2, #0
 8006900:	601a      	str	r2, [r3, #0]
 8006902:	605a      	str	r2, [r3, #4]
 8006904:	609a      	str	r2, [r3, #8]
 8006906:	60da      	str	r2, [r3, #12]

    if (semId == OS_ALL_SEM_MASK) {
 8006908:	687b      	ldr	r3, [r7, #4]
 800690a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800690e:	d13f      	bne.n	8006990 <OsSemInfoOutput+0xac>
        for (loop = 0, semCnt = 0; loop < LOSCFG_BASE_IPC_SEM_LIMIT; loop++) {
 8006910:	2300      	movs	r3, #0
 8006912:	613b      	str	r3, [r7, #16]
 8006914:	2300      	movs	r3, #0
 8006916:	617b      	str	r3, [r7, #20]
 8006918:	e031      	b.n	800697e <OsSemInfoOutput+0x9a>
            semCB = GET_SEM(loop);
 800691a:	4b44      	ldr	r3, [pc, #272]	; (8006a2c <OsSemInfoOutput+0x148>)
 800691c:	681a      	ldr	r2, [r3, #0]
 800691e:	693b      	ldr	r3, [r7, #16]
 8006920:	b29b      	uxth	r3, r3
 8006922:	011b      	lsls	r3, r3, #4
 8006924:	4413      	add	r3, r2
 8006926:	61bb      	str	r3, [r7, #24]
            SCHEDULER_LOCK(intSave);
 8006928:	f107 030c 	add.w	r3, r7, #12
 800692c:	4619      	mov	r1, r3
 800692e:	4840      	ldr	r0, [pc, #256]	; (8006a30 <OsSemInfoOutput+0x14c>)
 8006930:	f7ff fd3e 	bl	80063b0 <LOS_SpinLockSave>
            if (semCB->semStat == LOS_USED) {
 8006934:	69bb      	ldr	r3, [r7, #24]
 8006936:	781b      	ldrb	r3, [r3, #0]
 8006938:	2b01      	cmp	r3, #1
 800693a:	d118      	bne.n	800696e <OsSemInfoOutput+0x8a>
                (VOID)memcpy_s(&semNode, sizeof(LosSemCB), semCB, sizeof(LosSemCB));
 800693c:	f107 001c 	add.w	r0, r7, #28
 8006940:	2310      	movs	r3, #16
 8006942:	69ba      	ldr	r2, [r7, #24]
 8006944:	2110      	movs	r1, #16
 8006946:	f00f fe29 	bl	801659c <memcpy_s>
                SCHEDULER_UNLOCK(intSave);
 800694a:	68fb      	ldr	r3, [r7, #12]
 800694c:	4619      	mov	r1, r3
 800694e:	4838      	ldr	r0, [pc, #224]	; (8006a30 <OsSemInfoOutput+0x14c>)
 8006950:	f7ff fd3c 	bl	80063cc <LOS_SpinUnlockRestore>
                semCnt++;
 8006954:	697b      	ldr	r3, [r7, #20]
 8006956:	3301      	adds	r3, #1
 8006958:	617b      	str	r3, [r7, #20]
                PRINTK("\r\n   SemID       Count\n   ----------  -----\n");
 800695a:	4836      	ldr	r0, [pc, #216]	; (8006a34 <OsSemInfoOutput+0x150>)
 800695c:	f7fd feb6 	bl	80046cc <dprintf>
                PRINTK("   0x%08x  %u\n", semNode.semId, semNode.semCount);
 8006960:	6a3b      	ldr	r3, [r7, #32]
 8006962:	8bfa      	ldrh	r2, [r7, #30]
 8006964:	4619      	mov	r1, r3
 8006966:	4834      	ldr	r0, [pc, #208]	; (8006a38 <OsSemInfoOutput+0x154>)
 8006968:	f7fd feb0 	bl	80046cc <dprintf>
                continue;
 800696c:	e004      	b.n	8006978 <OsSemInfoOutput+0x94>
            }
            SCHEDULER_UNLOCK(intSave);
 800696e:	68fb      	ldr	r3, [r7, #12]
 8006970:	4619      	mov	r1, r3
 8006972:	482f      	ldr	r0, [pc, #188]	; (8006a30 <OsSemInfoOutput+0x14c>)
 8006974:	f7ff fd2a 	bl	80063cc <LOS_SpinUnlockRestore>
        for (loop = 0, semCnt = 0; loop < LOSCFG_BASE_IPC_SEM_LIMIT; loop++) {
 8006978:	693b      	ldr	r3, [r7, #16]
 800697a:	3301      	adds	r3, #1
 800697c:	613b      	str	r3, [r7, #16]
 800697e:	693b      	ldr	r3, [r7, #16]
 8006980:	2b13      	cmp	r3, #19
 8006982:	d9ca      	bls.n	800691a <OsSemInfoOutput+0x36>
        }
        PRINTK("   SemUsingNum    :  %u\n\n", semCnt);
 8006984:	6979      	ldr	r1, [r7, #20]
 8006986:	482d      	ldr	r0, [pc, #180]	; (8006a3c <OsSemInfoOutput+0x158>)
 8006988:	f7fd fea0 	bl	80046cc <dprintf>
        return LOS_OK;
 800698c:	2300      	movs	r3, #0
 800698e:	e03f      	b.n	8006a10 <OsSemInfoOutput+0x12c>
    } else {
        semCB = GET_SEM(semId);
 8006990:	4b26      	ldr	r3, [pc, #152]	; (8006a2c <OsSemInfoOutput+0x148>)
 8006992:	681a      	ldr	r2, [r3, #0]
 8006994:	687b      	ldr	r3, [r7, #4]
 8006996:	b29b      	uxth	r3, r3
 8006998:	011b      	lsls	r3, r3, #4
 800699a:	4413      	add	r3, r2
 800699c:	61bb      	str	r3, [r7, #24]
        SCHEDULER_LOCK(intSave);
 800699e:	f107 030c 	add.w	r3, r7, #12
 80069a2:	4619      	mov	r1, r3
 80069a4:	4822      	ldr	r0, [pc, #136]	; (8006a30 <OsSemInfoOutput+0x14c>)
 80069a6:	f7ff fd03 	bl	80063b0 <LOS_SpinLockSave>
        (VOID)memcpy_s(&semNode, sizeof(LosSemCB), semCB, sizeof(LosSemCB));
 80069aa:	f107 001c 	add.w	r0, r7, #28
 80069ae:	2310      	movs	r3, #16
 80069b0:	69ba      	ldr	r2, [r7, #24]
 80069b2:	2110      	movs	r1, #16
 80069b4:	f00f fdf2 	bl	801659c <memcpy_s>
        SCHEDULER_UNLOCK(intSave);
 80069b8:	68fb      	ldr	r3, [r7, #12]
 80069ba:	4619      	mov	r1, r3
 80069bc:	481c      	ldr	r0, [pc, #112]	; (8006a30 <OsSemInfoOutput+0x14c>)
 80069be:	f7ff fd05 	bl	80063cc <LOS_SpinUnlockRestore>
        if ((semNode.semId != semId) || (semNode.semStat != LOS_USED)) {
 80069c2:	6a3b      	ldr	r3, [r7, #32]
 80069c4:	687a      	ldr	r2, [r7, #4]
 80069c6:	429a      	cmp	r2, r3
 80069c8:	d102      	bne.n	80069d0 <OsSemInfoOutput+0xec>
 80069ca:	7f3b      	ldrb	r3, [r7, #28]
 80069cc:	2b01      	cmp	r3, #1
 80069ce:	d004      	beq.n	80069da <OsSemInfoOutput+0xf6>
            PRINTK("\nThe semaphore is not in use!\n");
 80069d0:	481b      	ldr	r0, [pc, #108]	; (8006a40 <OsSemInfoOutput+0x15c>)
 80069d2:	f7fd fe7b 	bl	80046cc <dprintf>
            return LOS_OK;
 80069d6:	2300      	movs	r3, #0
 80069d8:	e01a      	b.n	8006a10 <OsSemInfoOutput+0x12c>
        }

        PRINTK("\r\n   SemID       Count\n   ----------  -----\n");
 80069da:	4816      	ldr	r0, [pc, #88]	; (8006a34 <OsSemInfoOutput+0x150>)
 80069dc:	f7fd fe76 	bl	80046cc <dprintf>
        PRINTK("   0x%08x      0x%u\n", semNode.semId, semNode.semCount);
 80069e0:	6a3b      	ldr	r3, [r7, #32]
 80069e2:	8bfa      	ldrh	r2, [r7, #30]
 80069e4:	4619      	mov	r1, r3
 80069e6:	4817      	ldr	r0, [pc, #92]	; (8006a44 <OsSemInfoOutput+0x160>)
 80069e8:	f7fd fe70 	bl	80046cc <dprintf>

        if (LOS_ListEmpty(&semNode.semList)) {
 80069ec:	f107 031c 	add.w	r3, r7, #28
 80069f0:	3308      	adds	r3, #8
 80069f2:	4618      	mov	r0, r3
 80069f4:	f7ff fcb8 	bl	8006368 <LOS_ListEmpty>
 80069f8:	4603      	mov	r3, r0
 80069fa:	2b00      	cmp	r3, #0
 80069fc:	d004      	beq.n	8006a08 <OsSemInfoOutput+0x124>
            PRINTK("No task is pended on this semaphore!\n");
 80069fe:	4812      	ldr	r0, [pc, #72]	; (8006a48 <OsSemInfoOutput+0x164>)
 8006a00:	f7fd fe64 	bl	80046cc <dprintf>
            return LOS_OK;
 8006a04:	2300      	movs	r3, #0
 8006a06:	e003      	b.n	8006a10 <OsSemInfoOutput+0x12c>
        } else {
            OsSemPendedTaskNamePrint(semCB);
 8006a08:	69b8      	ldr	r0, [r7, #24]
 8006a0a:	f7ff fceb 	bl	80063e4 <OsSemPendedTaskNamePrint>
        }
    }
    return LOS_OK;
 8006a0e:	2300      	movs	r3, #0
}
 8006a10:	4a05      	ldr	r2, [pc, #20]	; (8006a28 <OsSemInfoOutput+0x144>)
 8006a12:	6811      	ldr	r1, [r2, #0]
 8006a14:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006a16:	4051      	eors	r1, r2
 8006a18:	d001      	beq.n	8006a1e <OsSemInfoOutput+0x13a>
 8006a1a:	f7fd fce5 	bl	80043e8 <__stack_chk_fail>
 8006a1e:	4618      	mov	r0, r3
 8006a20:	3730      	adds	r7, #48	; 0x30
 8006a22:	46bd      	mov	sp, r7
 8006a24:	bd80      	pop	{r7, pc}
 8006a26:	bf00      	nop
 8006a28:	0802090c 	.word	0x0802090c
 8006a2c:	20000790 	.word	0x20000790
 8006a30:	20000764 	.word	0x20000764
 8006a34:	08020850 	.word	0x08020850
 8006a38:	08020880 	.word	0x08020880
 8006a3c:	08020890 	.word	0x08020890
 8006a40:	080208ac 	.word	0x080208ac
 8006a44:	080208cc 	.word	0x080208cc
 8006a48:	080208e4 	.word	0x080208e4

08006a4c <OsShellCmdSemInfoGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdSemInfoGet(UINT32 argc, const CHAR **argv)
{
 8006a4c:	b580      	push	{r7, lr}
 8006a4e:	b086      	sub	sp, #24
 8006a50:	af00      	add	r7, sp, #0
 8006a52:	6078      	str	r0, [r7, #4]
 8006a54:	6039      	str	r1, [r7, #0]
 8006a56:	4b27      	ldr	r3, [pc, #156]	; (8006af4 <OsShellCmdSemInfoGet+0xa8>)
 8006a58:	681b      	ldr	r3, [r3, #0]
 8006a5a:	617b      	str	r3, [r7, #20]
 8006a5c:	f04f 0300 	mov.w	r3, #0
    size_t semId;
    CHAR *endPtr = NULL;
 8006a60:	2300      	movs	r3, #0
 8006a62:	60bb      	str	r3, [r7, #8]
    UINT32 ret;

    if (argc > 1) {
 8006a64:	687b      	ldr	r3, [r7, #4]
 8006a66:	2b01      	cmp	r3, #1
 8006a68:	d905      	bls.n	8006a76 <OsShellCmdSemInfoGet+0x2a>
        PRINTK("\nUsage: sem [fulldata|ID]\n");
 8006a6a:	4823      	ldr	r0, [pc, #140]	; (8006af8 <OsShellCmdSemInfoGet+0xac>)
 8006a6c:	f7fd fe2e 	bl	80046cc <dprintf>
        return OS_ERROR;
 8006a70:	f04f 33ff 	mov.w	r3, #4294967295
 8006a74:	e033      	b.n	8006ade <OsShellCmdSemInfoGet+0x92>
    }

    if (argc == 0) {
 8006a76:	687b      	ldr	r3, [r7, #4]
 8006a78:	2b00      	cmp	r3, #0
 8006a7a:	d103      	bne.n	8006a84 <OsShellCmdSemInfoGet+0x38>
        semId = OS_ALL_SEM_MASK;
 8006a7c:	f04f 33ff 	mov.w	r3, #4294967295
 8006a80:	60fb      	str	r3, [r7, #12]
 8006a82:	e027      	b.n	8006ad4 <OsShellCmdSemInfoGet+0x88>
    } else {
        if (strcmp(argv[0], "fulldata") == 0) {
 8006a84:	683b      	ldr	r3, [r7, #0]
 8006a86:	681b      	ldr	r3, [r3, #0]
 8006a88:	491c      	ldr	r1, [pc, #112]	; (8006afc <OsShellCmdSemInfoGet+0xb0>)
 8006a8a:	4618      	mov	r0, r3
 8006a8c:	f007 ffdb 	bl	800ea46 <strcmp>
 8006a90:	4603      	mov	r3, r0
 8006a92:	2b00      	cmp	r3, #0
 8006a94:	d104      	bne.n	8006aa0 <OsShellCmdSemInfoGet+0x54>
            ret = OsSemInfoGetFullData();
 8006a96:	f7ff fe6f 	bl	8006778 <OsSemInfoGetFullData>
 8006a9a:	6138      	str	r0, [r7, #16]
            return ret;
 8006a9c:	693b      	ldr	r3, [r7, #16]
 8006a9e:	e01e      	b.n	8006ade <OsShellCmdSemInfoGet+0x92>
        }

        semId = strtoul(argv[0], &endPtr, 0);
 8006aa0:	683b      	ldr	r3, [r7, #0]
 8006aa2:	681b      	ldr	r3, [r3, #0]
 8006aa4:	f107 0108 	add.w	r1, r7, #8
 8006aa8:	2200      	movs	r2, #0
 8006aaa:	4618      	mov	r0, r3
 8006aac:	f008 f870 	bl	800eb90 <strtoul>
 8006ab0:	60f8      	str	r0, [r7, #12]
        if ((*endPtr != 0) || (GET_SEM_INDEX(semId) >= LOSCFG_BASE_IPC_SEM_LIMIT)) {
 8006ab2:	68bb      	ldr	r3, [r7, #8]
 8006ab4:	781b      	ldrb	r3, [r3, #0]
 8006ab6:	2b00      	cmp	r3, #0
 8006ab8:	d103      	bne.n	8006ac2 <OsShellCmdSemInfoGet+0x76>
 8006aba:	68fb      	ldr	r3, [r7, #12]
 8006abc:	b29b      	uxth	r3, r3
 8006abe:	2b13      	cmp	r3, #19
 8006ac0:	d908      	bls.n	8006ad4 <OsShellCmdSemInfoGet+0x88>
            PRINTK("\nsem ID can't access %s.\n", argv[0]);
 8006ac2:	683b      	ldr	r3, [r7, #0]
 8006ac4:	681b      	ldr	r3, [r3, #0]
 8006ac6:	4619      	mov	r1, r3
 8006ac8:	480d      	ldr	r0, [pc, #52]	; (8006b00 <OsShellCmdSemInfoGet+0xb4>)
 8006aca:	f7fd fdff 	bl	80046cc <dprintf>
            return OS_ERROR;
 8006ace:	f04f 33ff 	mov.w	r3, #4294967295
 8006ad2:	e004      	b.n	8006ade <OsShellCmdSemInfoGet+0x92>
        }
    }

    ret = OsSemInfoOutput(semId);
 8006ad4:	68f8      	ldr	r0, [r7, #12]
 8006ad6:	f7ff ff05 	bl	80068e4 <OsSemInfoOutput>
 8006ada:	6138      	str	r0, [r7, #16]
    return ret;
 8006adc:	693b      	ldr	r3, [r7, #16]
}
 8006ade:	4a05      	ldr	r2, [pc, #20]	; (8006af4 <OsShellCmdSemInfoGet+0xa8>)
 8006ae0:	6811      	ldr	r1, [r2, #0]
 8006ae2:	697a      	ldr	r2, [r7, #20]
 8006ae4:	4051      	eors	r1, r2
 8006ae6:	d001      	beq.n	8006aec <OsShellCmdSemInfoGet+0xa0>
 8006ae8:	f7fd fc7e 	bl	80043e8 <__stack_chk_fail>
 8006aec:	4618      	mov	r0, r3
 8006aee:	3718      	adds	r7, #24
 8006af0:	46bd      	mov	sp, r7
 8006af2:	bd80      	pop	{r7, pc}
 8006af4:	08020954 	.word	0x08020954
 8006af8:	08020910 	.word	0x08020910
 8006afc:	0802092c 	.word	0x0802092c
 8006b00:	08020938 	.word	0x08020938

08006b04 <ArchCurrCpuid>:
{
 8006b04:	b480      	push	{r7}
 8006b06:	af00      	add	r7, sp, #0
    return 0;
 8006b08:	2300      	movs	r3, #0
}
 8006b0a:	4618      	mov	r0, r3
 8006b0c:	46bd      	mov	sp, r7
 8006b0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006b12:	4770      	bx	lr

08006b14 <OsSchedStatisticsPerCpu>:
STATIC BOOL g_statisticsStartFlag = FALSE;
STATIC UINT64 g_statisticsStartTime;
STATIC StatPercpu g_statPercpu[LOSCFG_KERNEL_CORE_NUM];

STATIC VOID OsSchedStatisticsPerCpu(const LosTaskCB *runTask, const LosTaskCB *newTask)
{
 8006b14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006b18:	b08d      	sub	sp, #52	; 0x34
 8006b1a:	af00      	add	r7, sp, #0
 8006b1c:	6178      	str	r0, [r7, #20]
 8006b1e:	6139      	str	r1, [r7, #16]
    UINT32 cpuId;
    UINT32 idleTaskId;
    UINT64 now, runtime;

    if (g_statisticsStartFlag != TRUE) {
 8006b20:	4b96      	ldr	r3, [pc, #600]	; (8006d7c <OsSchedStatisticsPerCpu+0x268>)
 8006b22:	681b      	ldr	r3, [r3, #0]
 8006b24:	2b01      	cmp	r3, #1
 8006b26:	f040 8121 	bne.w	8006d6c <OsSchedStatisticsPerCpu+0x258>
        return;
    }

    cpuId = ArchCurrCpuid();
 8006b2a:	f7ff ffeb 	bl	8006b04 <ArchCurrCpuid>
 8006b2e:	61b8      	str	r0, [r7, #24]
    idleTaskId = OsGetIdleTaskId();
 8006b30:	f7fc fa04 	bl	8002f3c <OsGetIdleTaskId>
 8006b34:	61f8      	str	r0, [r7, #28]
    now = LOS_CurrNanosec();
 8006b36:	f7fd fb6d 	bl	8004214 <LOS_CurrNanosec>
 8006b3a:	e9c7 0108 	strd	r0, r1, [r7, #32]

    g_statPercpu[cpuId].contexSwitch++;
 8006b3e:	4990      	ldr	r1, [pc, #576]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006b40:	69ba      	ldr	r2, [r7, #24]
 8006b42:	4613      	mov	r3, r2
 8006b44:	00db      	lsls	r3, r3, #3
 8006b46:	1a9b      	subs	r3, r3, r2
 8006b48:	00db      	lsls	r3, r3, #3
 8006b4a:	440b      	add	r3, r1
 8006b4c:	3330      	adds	r3, #48	; 0x30
 8006b4e:	681b      	ldr	r3, [r3, #0]
 8006b50:	1c59      	adds	r1, r3, #1
 8006b52:	488b      	ldr	r0, [pc, #556]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006b54:	69ba      	ldr	r2, [r7, #24]
 8006b56:	4613      	mov	r3, r2
 8006b58:	00db      	lsls	r3, r3, #3
 8006b5a:	1a9b      	subs	r3, r3, r2
 8006b5c:	00db      	lsls	r3, r3, #3
 8006b5e:	4403      	add	r3, r0
 8006b60:	3330      	adds	r3, #48	; 0x30
 8006b62:	6019      	str	r1, [r3, #0]

    if ((runTask->taskId != idleTaskId) && (newTask->taskId == idleTaskId)) {
 8006b64:	697b      	ldr	r3, [r7, #20]
 8006b66:	695b      	ldr	r3, [r3, #20]
 8006b68:	69fa      	ldr	r2, [r7, #28]
 8006b6a:	429a      	cmp	r2, r3
 8006b6c:	d011      	beq.n	8006b92 <OsSchedStatisticsPerCpu+0x7e>
 8006b6e:	693b      	ldr	r3, [r7, #16]
 8006b70:	695b      	ldr	r3, [r3, #20]
 8006b72:	69fa      	ldr	r2, [r7, #28]
 8006b74:	429a      	cmp	r2, r3
 8006b76:	d10c      	bne.n	8006b92 <OsSchedStatisticsPerCpu+0x7e>
        g_statPercpu[cpuId].idleStarttime = now;
 8006b78:	4981      	ldr	r1, [pc, #516]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006b7a:	69ba      	ldr	r2, [r7, #24]
 8006b7c:	4613      	mov	r3, r2
 8006b7e:	00db      	lsls	r3, r3, #3
 8006b80:	1a9b      	subs	r3, r3, r2
 8006b82:	00db      	lsls	r3, r3, #3
 8006b84:	440b      	add	r3, r1
 8006b86:	f103 0108 	add.w	r1, r3, #8
 8006b8a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8006b8e:	e9c1 2300 	strd	r2, r3, [r1]
    }

    if ((runTask->taskId == idleTaskId) && (newTask->taskId != idleTaskId)) {
 8006b92:	697b      	ldr	r3, [r7, #20]
 8006b94:	695b      	ldr	r3, [r3, #20]
 8006b96:	69fa      	ldr	r2, [r7, #28]
 8006b98:	429a      	cmp	r2, r3
 8006b9a:	d143      	bne.n	8006c24 <OsSchedStatisticsPerCpu+0x110>
 8006b9c:	693b      	ldr	r3, [r7, #16]
 8006b9e:	695b      	ldr	r3, [r3, #20]
 8006ba0:	69fa      	ldr	r2, [r7, #28]
 8006ba2:	429a      	cmp	r2, r3
 8006ba4:	d03e      	beq.n	8006c24 <OsSchedStatisticsPerCpu+0x110>
        runtime = now - g_statPercpu[cpuId].idleStarttime;
 8006ba6:	4976      	ldr	r1, [pc, #472]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006ba8:	69ba      	ldr	r2, [r7, #24]
 8006baa:	4613      	mov	r3, r2
 8006bac:	00db      	lsls	r3, r3, #3
 8006bae:	1a9b      	subs	r3, r3, r2
 8006bb0:	00db      	lsls	r3, r3, #3
 8006bb2:	440b      	add	r3, r1
 8006bb4:	3308      	adds	r3, #8
 8006bb6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006bba:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8006bbe:	1a86      	subs	r6, r0, r2
 8006bc0:	603e      	str	r6, [r7, #0]
 8006bc2:	eb61 0303 	sbc.w	r3, r1, r3
 8006bc6:	607b      	str	r3, [r7, #4]
 8006bc8:	e9d7 2300 	ldrd	r2, r3, [r7]
 8006bcc:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
        g_statPercpu[cpuId].idleRuntime += runtime;
 8006bd0:	496b      	ldr	r1, [pc, #428]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006bd2:	69ba      	ldr	r2, [r7, #24]
 8006bd4:	4613      	mov	r3, r2
 8006bd6:	00db      	lsls	r3, r3, #3
 8006bd8:	1a9b      	subs	r3, r3, r2
 8006bda:	00db      	lsls	r3, r3, #3
 8006bdc:	440b      	add	r3, r1
 8006bde:	e9d3 0100 	ldrd	r0, r1, [r3]
 8006be2:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8006be6:	1886      	adds	r6, r0, r2
 8006be8:	60be      	str	r6, [r7, #8]
 8006bea:	eb41 0303 	adc.w	r3, r1, r3
 8006bee:	60fb      	str	r3, [r7, #12]
 8006bf0:	4963      	ldr	r1, [pc, #396]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006bf2:	69ba      	ldr	r2, [r7, #24]
 8006bf4:	4613      	mov	r3, r2
 8006bf6:	00db      	lsls	r3, r3, #3
 8006bf8:	1a9b      	subs	r3, r3, r2
 8006bfa:	00db      	lsls	r3, r3, #3
 8006bfc:	440b      	add	r3, r1
 8006bfe:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 8006c02:	e9c3 1200 	strd	r1, r2, [r3]
        g_statPercpu[cpuId].idleStarttime = 0;
 8006c06:	495e      	ldr	r1, [pc, #376]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006c08:	69ba      	ldr	r2, [r7, #24]
 8006c0a:	4613      	mov	r3, r2
 8006c0c:	00db      	lsls	r3, r3, #3
 8006c0e:	1a9b      	subs	r3, r3, r2
 8006c10:	00db      	lsls	r3, r3, #3
 8006c12:	440b      	add	r3, r1
 8006c14:	f103 0108 	add.w	r1, r3, #8
 8006c18:	f04f 0200 	mov.w	r2, #0
 8006c1c:	f04f 0300 	mov.w	r3, #0
 8006c20:	e9c1 2300 	strd	r2, r3, [r1]
    }

    if ((runTask->priority >= HIGHTASKPRI) && (newTask->priority < HIGHTASKPRI)) {
 8006c24:	697b      	ldr	r3, [r7, #20]
 8006c26:	88db      	ldrh	r3, [r3, #6]
 8006c28:	2b0f      	cmp	r3, #15
 8006c2a:	d910      	bls.n	8006c4e <OsSchedStatisticsPerCpu+0x13a>
 8006c2c:	693b      	ldr	r3, [r7, #16]
 8006c2e:	88db      	ldrh	r3, [r3, #6]
 8006c30:	2b0f      	cmp	r3, #15
 8006c32:	d80c      	bhi.n	8006c4e <OsSchedStatisticsPerCpu+0x13a>
        g_statPercpu[cpuId].highTaskStarttime = now;
 8006c34:	4952      	ldr	r1, [pc, #328]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006c36:	69ba      	ldr	r2, [r7, #24]
 8006c38:	4613      	mov	r3, r2
 8006c3a:	00db      	lsls	r3, r3, #3
 8006c3c:	1a9b      	subs	r3, r3, r2
 8006c3e:	00db      	lsls	r3, r3, #3
 8006c40:	440b      	add	r3, r1
 8006c42:	f103 0118 	add.w	r1, r3, #24
 8006c46:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8006c4a:	e9c1 2300 	strd	r2, r3, [r1]
    }

    if ((runTask->priority < HIGHTASKPRI) && (newTask->priority >= HIGHTASKPRI)) {
 8006c4e:	697b      	ldr	r3, [r7, #20]
 8006c50:	88db      	ldrh	r3, [r3, #6]
 8006c52:	2b0f      	cmp	r3, #15
 8006c54:	d83e      	bhi.n	8006cd4 <OsSchedStatisticsPerCpu+0x1c0>
 8006c56:	693b      	ldr	r3, [r7, #16]
 8006c58:	88db      	ldrh	r3, [r3, #6]
 8006c5a:	2b0f      	cmp	r3, #15
 8006c5c:	d93a      	bls.n	8006cd4 <OsSchedStatisticsPerCpu+0x1c0>
        runtime = now - g_statPercpu[cpuId].highTaskStarttime;
 8006c5e:	4948      	ldr	r1, [pc, #288]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006c60:	69ba      	ldr	r2, [r7, #24]
 8006c62:	4613      	mov	r3, r2
 8006c64:	00db      	lsls	r3, r3, #3
 8006c66:	1a9b      	subs	r3, r3, r2
 8006c68:	00db      	lsls	r3, r3, #3
 8006c6a:	440b      	add	r3, r1
 8006c6c:	3318      	adds	r3, #24
 8006c6e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006c72:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8006c76:	ebb0 0a02 	subs.w	sl, r0, r2
 8006c7a:	eb61 0b03 	sbc.w	fp, r1, r3
 8006c7e:	e9c7 ab0a 	strd	sl, fp, [r7, #40]	; 0x28
        g_statPercpu[cpuId].highTaskRuntime += runtime;
 8006c82:	493f      	ldr	r1, [pc, #252]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006c84:	69ba      	ldr	r2, [r7, #24]
 8006c86:	4613      	mov	r3, r2
 8006c88:	00db      	lsls	r3, r3, #3
 8006c8a:	1a9b      	subs	r3, r3, r2
 8006c8c:	00db      	lsls	r3, r3, #3
 8006c8e:	440b      	add	r3, r1
 8006c90:	3310      	adds	r3, #16
 8006c92:	e9d3 0100 	ldrd	r0, r1, [r3]
 8006c96:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8006c9a:	eb10 0802 	adds.w	r8, r0, r2
 8006c9e:	eb41 0903 	adc.w	r9, r1, r3
 8006ca2:	4937      	ldr	r1, [pc, #220]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006ca4:	69ba      	ldr	r2, [r7, #24]
 8006ca6:	4613      	mov	r3, r2
 8006ca8:	00db      	lsls	r3, r3, #3
 8006caa:	1a9b      	subs	r3, r3, r2
 8006cac:	00db      	lsls	r3, r3, #3
 8006cae:	440b      	add	r3, r1
 8006cb0:	3310      	adds	r3, #16
 8006cb2:	e9c3 8900 	strd	r8, r9, [r3]
        g_statPercpu[cpuId].highTaskStarttime = 0;
 8006cb6:	4932      	ldr	r1, [pc, #200]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006cb8:	69ba      	ldr	r2, [r7, #24]
 8006cba:	4613      	mov	r3, r2
 8006cbc:	00db      	lsls	r3, r3, #3
 8006cbe:	1a9b      	subs	r3, r3, r2
 8006cc0:	00db      	lsls	r3, r3, #3
 8006cc2:	440b      	add	r3, r1
 8006cc4:	f103 0118 	add.w	r1, r3, #24
 8006cc8:	f04f 0200 	mov.w	r2, #0
 8006ccc:	f04f 0300 	mov.w	r3, #0
 8006cd0:	e9c1 2300 	strd	r2, r3, [r1]
    }

    if (newTask->priority < HIGHTASKPRI) {
 8006cd4:	693b      	ldr	r3, [r7, #16]
 8006cd6:	88db      	ldrh	r3, [r3, #6]
 8006cd8:	2b0f      	cmp	r3, #15
 8006cda:	d812      	bhi.n	8006d02 <OsSchedStatisticsPerCpu+0x1ee>
        g_statPercpu[cpuId].highTaskSwitch++;
 8006cdc:	4928      	ldr	r1, [pc, #160]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006cde:	69ba      	ldr	r2, [r7, #24]
 8006ce0:	4613      	mov	r3, r2
 8006ce2:	00db      	lsls	r3, r3, #3
 8006ce4:	1a9b      	subs	r3, r3, r2
 8006ce6:	00db      	lsls	r3, r3, #3
 8006ce8:	440b      	add	r3, r1
 8006cea:	332c      	adds	r3, #44	; 0x2c
 8006cec:	681b      	ldr	r3, [r3, #0]
 8006cee:	1c59      	adds	r1, r3, #1
 8006cf0:	4823      	ldr	r0, [pc, #140]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006cf2:	69ba      	ldr	r2, [r7, #24]
 8006cf4:	4613      	mov	r3, r2
 8006cf6:	00db      	lsls	r3, r3, #3
 8006cf8:	1a9b      	subs	r3, r3, r2
 8006cfa:	00db      	lsls	r3, r3, #3
 8006cfc:	4403      	add	r3, r0
 8006cfe:	332c      	adds	r3, #44	; 0x2c
 8006d00:	6019      	str	r1, [r3, #0]
    }

    if (newTask->taskId != idleTaskId) {
 8006d02:	693b      	ldr	r3, [r7, #16]
 8006d04:	695b      	ldr	r3, [r3, #20]
 8006d06:	69fa      	ldr	r2, [r7, #28]
 8006d08:	429a      	cmp	r2, r3
 8006d0a:	d031      	beq.n	8006d70 <OsSchedStatisticsPerCpu+0x25c>
        g_statPercpu[cpuId].sumPriority += newTask->priority;
 8006d0c:	491c      	ldr	r1, [pc, #112]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006d0e:	69ba      	ldr	r2, [r7, #24]
 8006d10:	4613      	mov	r3, r2
 8006d12:	00db      	lsls	r3, r3, #3
 8006d14:	1a9b      	subs	r3, r3, r2
 8006d16:	00db      	lsls	r3, r3, #3
 8006d18:	440b      	add	r3, r1
 8006d1a:	3320      	adds	r3, #32
 8006d1c:	e9d3 0100 	ldrd	r0, r1, [r3]
 8006d20:	693b      	ldr	r3, [r7, #16]
 8006d22:	88db      	ldrh	r3, [r3, #6]
 8006d24:	b29a      	uxth	r2, r3
 8006d26:	f04f 0300 	mov.w	r3, #0
 8006d2a:	1884      	adds	r4, r0, r2
 8006d2c:	eb41 0503 	adc.w	r5, r1, r3
 8006d30:	4913      	ldr	r1, [pc, #76]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006d32:	69ba      	ldr	r2, [r7, #24]
 8006d34:	4613      	mov	r3, r2
 8006d36:	00db      	lsls	r3, r3, #3
 8006d38:	1a9b      	subs	r3, r3, r2
 8006d3a:	00db      	lsls	r3, r3, #3
 8006d3c:	440b      	add	r3, r1
 8006d3e:	3320      	adds	r3, #32
 8006d40:	e9c3 4500 	strd	r4, r5, [r3]
        g_statPercpu[cpuId].prioritySwitch++;
 8006d44:	490e      	ldr	r1, [pc, #56]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006d46:	69ba      	ldr	r2, [r7, #24]
 8006d48:	4613      	mov	r3, r2
 8006d4a:	00db      	lsls	r3, r3, #3
 8006d4c:	1a9b      	subs	r3, r3, r2
 8006d4e:	00db      	lsls	r3, r3, #3
 8006d50:	440b      	add	r3, r1
 8006d52:	3328      	adds	r3, #40	; 0x28
 8006d54:	681b      	ldr	r3, [r3, #0]
 8006d56:	1c59      	adds	r1, r3, #1
 8006d58:	4809      	ldr	r0, [pc, #36]	; (8006d80 <OsSchedStatisticsPerCpu+0x26c>)
 8006d5a:	69ba      	ldr	r2, [r7, #24]
 8006d5c:	4613      	mov	r3, r2
 8006d5e:	00db      	lsls	r3, r3, #3
 8006d60:	1a9b      	subs	r3, r3, r2
 8006d62:	00db      	lsls	r3, r3, #3
 8006d64:	4403      	add	r3, r0
 8006d66:	3328      	adds	r3, #40	; 0x28
 8006d68:	6019      	str	r1, [r3, #0]
    }

    return;
 8006d6a:	e001      	b.n	8006d70 <OsSchedStatisticsPerCpu+0x25c>
        return;
 8006d6c:	bf00      	nop
 8006d6e:	e000      	b.n	8006d72 <OsSchedStatisticsPerCpu+0x25e>
    return;
 8006d70:	bf00      	nop
}
 8006d72:	3734      	adds	r7, #52	; 0x34
 8006d74:	46bd      	mov	sp, r7
 8006d76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006d7a:	bf00      	nop
 8006d7c:	200007ac 	.word	0x200007ac
 8006d80:	200007b0 	.word	0x200007b0

08006d84 <OsSchedStatistics>:

LITE_OS_SEC_TEXT_MINOR VOID OsSchedStatistics(LosTaskCB *runTask, LosTaskCB *newTask)
{
 8006d84:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8006d88:	b08c      	sub	sp, #48	; 0x30
 8006d8a:	af00      	add	r7, sp, #0
 8006d8c:	6078      	str	r0, [r7, #4]
 8006d8e:	6039      	str	r1, [r7, #0]
    UINT64 runtime;
    UINT32 cpuId = ArchCurrCpuid();
 8006d90:	f7ff feb8 	bl	8006b04 <ArchCurrCpuid>
 8006d94:	60f8      	str	r0, [r7, #12]
    UINT64 now = LOS_CurrNanosec();
 8006d96:	f7fd fa3d 	bl	8004214 <LOS_CurrNanosec>
 8006d9a:	e9c7 0108 	strd	r0, r1, [r7, #32]

    SchedStat *schedRun = &runTask->schedStat;
 8006d9e:	687b      	ldr	r3, [r7, #4]
 8006da0:	3378      	adds	r3, #120	; 0x78
 8006da2:	613b      	str	r3, [r7, #16]
    SchedStat *schedNew = &newTask->schedStat;
 8006da4:	683b      	ldr	r3, [r7, #0]
 8006da6:	3378      	adds	r3, #120	; 0x78
 8006da8:	617b      	str	r3, [r7, #20]
    SchedPercpu *cpuRun = &schedRun->schedPercpu[cpuId];
 8006daa:	68fb      	ldr	r3, [r7, #12]
 8006dac:	011b      	lsls	r3, r3, #4
 8006dae:	3318      	adds	r3, #24
 8006db0:	693a      	ldr	r2, [r7, #16]
 8006db2:	4413      	add	r3, r2
 8006db4:	61bb      	str	r3, [r7, #24]
    SchedPercpu *cpuNew = &schedNew->schedPercpu[cpuId];
 8006db6:	68fb      	ldr	r3, [r7, #12]
 8006db8:	011b      	lsls	r3, r3, #4
 8006dba:	3318      	adds	r3, #24
 8006dbc:	697a      	ldr	r2, [r7, #20]
 8006dbe:	4413      	add	r3, r2
 8006dc0:	61fb      	str	r3, [r7, #28]

    /* calculate one chance of running time */
    runtime = now - schedRun->startRuntime;
 8006dc2:	693b      	ldr	r3, [r7, #16]
 8006dc4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006dc8:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8006dcc:	ebb0 0a02 	subs.w	sl, r0, r2
 8006dd0:	eb61 0b03 	sbc.w	fp, r1, r3
 8006dd4:	e9c7 ab0a 	strd	sl, fp, [r7, #40]	; 0x28

    /* add running timer to running task statistics */
    cpuRun->runtime += runtime;
 8006dd8:	69bb      	ldr	r3, [r7, #24]
 8006dda:	e9d3 0100 	ldrd	r0, r1, [r3]
 8006dde:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8006de2:	eb10 0802 	adds.w	r8, r0, r2
 8006de6:	eb41 0903 	adc.w	r9, r1, r3
 8006dea:	69bb      	ldr	r3, [r7, #24]
 8006dec:	e9c3 8900 	strd	r8, r9, [r3]
    schedRun->allRuntime += runtime;
 8006df0:	693b      	ldr	r3, [r7, #16]
 8006df2:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8006df6:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8006dfa:	1884      	adds	r4, r0, r2
 8006dfc:	eb41 0503 	adc.w	r5, r1, r3
 8006e00:	693b      	ldr	r3, [r7, #16]
 8006e02:	e9c3 4502 	strd	r4, r5, [r3, #8]

    /* add context switch counters and schedule start time */
    cpuNew->contexSwitch++;
 8006e06:	69fb      	ldr	r3, [r7, #28]
 8006e08:	689b      	ldr	r3, [r3, #8]
 8006e0a:	1c5a      	adds	r2, r3, #1
 8006e0c:	69fb      	ldr	r3, [r7, #28]
 8006e0e:	609a      	str	r2, [r3, #8]
    schedNew->allContextSwitch++;
 8006e10:	697b      	ldr	r3, [r7, #20]
 8006e12:	691b      	ldr	r3, [r3, #16]
 8006e14:	1c5a      	adds	r2, r3, #1
 8006e16:	697b      	ldr	r3, [r7, #20]
 8006e18:	611a      	str	r2, [r3, #16]
    schedNew->startRuntime = now;
 8006e1a:	6979      	ldr	r1, [r7, #20]
 8006e1c:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8006e20:	e9c1 2300 	strd	r2, r3, [r1]
    OsSchedStatisticsPerCpu(runTask, newTask);
 8006e24:	6839      	ldr	r1, [r7, #0]
 8006e26:	6878      	ldr	r0, [r7, #4]
 8006e28:	f7ff fe74 	bl	8006b14 <OsSchedStatisticsPerCpu>
}
 8006e2c:	bf00      	nop
 8006e2e:	3730      	adds	r7, #48	; 0x30
 8006e30:	46bd      	mov	sp, r7
 8006e32:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
	...

08006e38 <OsHwiStatistics>:

LITE_OS_SEC_TEXT_MINOR VOID OsHwiStatistics(size_t intNum)
{
 8006e38:	b580      	push	{r7, lr}
 8006e3a:	b084      	sub	sp, #16
 8006e3c:	af00      	add	r7, sp, #0
 8006e3e:	6078      	str	r0, [r7, #4]
    UINT32 cpuId = ArchCurrCpuid();
 8006e40:	f7ff fe60 	bl	8006b04 <ArchCurrCpuid>
 8006e44:	60f8      	str	r0, [r7, #12]

    if ((g_statisticsStartFlag != TRUE) || (intNum == OS_TICK_INT_NUM)) {
 8006e46:	4b0f      	ldr	r3, [pc, #60]	; (8006e84 <OsHwiStatistics+0x4c>)
 8006e48:	681b      	ldr	r3, [r3, #0]
 8006e4a:	2b01      	cmp	r3, #1
 8006e4c:	d116      	bne.n	8006e7c <OsHwiStatistics+0x44>
 8006e4e:	687b      	ldr	r3, [r7, #4]
 8006e50:	2b0f      	cmp	r3, #15
 8006e52:	d013      	beq.n	8006e7c <OsHwiStatistics+0x44>
        return;
    }

    g_statPercpu[cpuId].hwiNum++;
 8006e54:	490c      	ldr	r1, [pc, #48]	; (8006e88 <OsHwiStatistics+0x50>)
 8006e56:	68fa      	ldr	r2, [r7, #12]
 8006e58:	4613      	mov	r3, r2
 8006e5a:	00db      	lsls	r3, r3, #3
 8006e5c:	1a9b      	subs	r3, r3, r2
 8006e5e:	00db      	lsls	r3, r3, #3
 8006e60:	440b      	add	r3, r1
 8006e62:	3334      	adds	r3, #52	; 0x34
 8006e64:	681b      	ldr	r3, [r3, #0]
 8006e66:	1c59      	adds	r1, r3, #1
 8006e68:	4807      	ldr	r0, [pc, #28]	; (8006e88 <OsHwiStatistics+0x50>)
 8006e6a:	68fa      	ldr	r2, [r7, #12]
 8006e6c:	4613      	mov	r3, r2
 8006e6e:	00db      	lsls	r3, r3, #3
 8006e70:	1a9b      	subs	r3, r3, r2
 8006e72:	00db      	lsls	r3, r3, #3
 8006e74:	4403      	add	r3, r0
 8006e76:	3334      	adds	r3, #52	; 0x34
 8006e78:	6019      	str	r1, [r3, #0]
    /* 16: 0~15 is ipi interrupts */
    if (intNum < 16) {
        g_statPercpu[cpuId].ipiIrqNum++;
    }
#endif
    return;
 8006e7a:	e000      	b.n	8006e7e <OsHwiStatistics+0x46>
        return;
 8006e7c:	bf00      	nop
}
 8006e7e:	3710      	adds	r7, #16
 8006e80:	46bd      	mov	sp, r7
 8006e82:	bd80      	pop	{r7, pc}
 8006e84:	200007ac 	.word	0x200007ac
 8006e88:	200007b0 	.word	0x200007b0

08006e8c <LOS_IntLock>:
{
 8006e8c:	b580      	push	{r7, lr}
 8006e8e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8006e90:	f7f9 ff1a 	bl	8000cc8 <ArchIntLock>
 8006e94:	4603      	mov	r3, r0
}
 8006e96:	4618      	mov	r0, r3
 8006e98:	bd80      	pop	{r7, pc}

08006e9a <LOS_IntRestore>:
{
 8006e9a:	b580      	push	{r7, lr}
 8006e9c:	b082      	sub	sp, #8
 8006e9e:	af00      	add	r7, sp, #0
 8006ea0:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8006ea2:	6878      	ldr	r0, [r7, #4]
 8006ea4:	f7f9 ff18 	bl	8000cd8 <ArchIntRestore>
}
 8006ea8:	bf00      	nop
 8006eaa:	3708      	adds	r7, #8
 8006eac:	46bd      	mov	sp, r7
 8006eae:	bd80      	pop	{r7, pc}

08006eb0 <OsGetHwiForm>:
 * will not respond. eg: Used for arm(cortex-a/r)/arm64.
 */
extern VOID OsIntEntry(VOID);

STATIC INLINE HwiHandleInfo *OsGetHwiForm(UINT32 hwiNum)
{
 8006eb0:	b580      	push	{r7, lr}
 8006eb2:	b082      	sub	sp, #8
 8006eb4:	af00      	add	r7, sp, #0
 8006eb6:	6078      	str	r0, [r7, #4]
    if ((g_hwiOps == NULL) || (g_hwiOps->getHandleForm == NULL)) {
 8006eb8:	4b0a      	ldr	r3, [pc, #40]	; (8006ee4 <OsGetHwiForm+0x34>)
 8006eba:	681b      	ldr	r3, [r3, #0]
 8006ebc:	2b00      	cmp	r3, #0
 8006ebe:	d004      	beq.n	8006eca <OsGetHwiForm+0x1a>
 8006ec0:	4b08      	ldr	r3, [pc, #32]	; (8006ee4 <OsGetHwiForm+0x34>)
 8006ec2:	681b      	ldr	r3, [r3, #0]
 8006ec4:	69db      	ldr	r3, [r3, #28]
 8006ec6:	2b00      	cmp	r3, #0
 8006ec8:	d101      	bne.n	8006ece <OsGetHwiForm+0x1e>
        return NULL;
 8006eca:	2300      	movs	r3, #0
 8006ecc:	e005      	b.n	8006eda <OsGetHwiForm+0x2a>
    }
    return g_hwiOps->getHandleForm(hwiNum);
 8006ece:	4b05      	ldr	r3, [pc, #20]	; (8006ee4 <OsGetHwiForm+0x34>)
 8006ed0:	681b      	ldr	r3, [r3, #0]
 8006ed2:	69db      	ldr	r3, [r3, #28]
 8006ed4:	6878      	ldr	r0, [r7, #4]
 8006ed6:	4798      	blx	r3
 8006ed8:	4603      	mov	r3, r0
}
 8006eda:	4618      	mov	r0, r3
 8006edc:	3708      	adds	r7, #8
 8006ede:	46bd      	mov	sp, r7
 8006ee0:	bd80      	pop	{r7, pc}
 8006ee2:	bf00      	nop
 8006ee4:	20000758 	.word	0x20000758

08006ee8 <OsGetHwiFormCnt>:

STATIC INLINE UINT32 OsGetHwiFormCnt(UINT32 hwiNum)
{
 8006ee8:	b580      	push	{r7, lr}
 8006eea:	b084      	sub	sp, #16
 8006eec:	af00      	add	r7, sp, #0
 8006eee:	6078      	str	r0, [r7, #4]
    HwiHandleInfo *hwiForm = OsGetHwiForm(hwiNum);
 8006ef0:	6878      	ldr	r0, [r7, #4]
 8006ef2:	f7ff ffdd 	bl	8006eb0 <OsGetHwiForm>
 8006ef6:	60f8      	str	r0, [r7, #12]

    if (hwiForm == NULL) {
 8006ef8:	68fb      	ldr	r3, [r7, #12]
 8006efa:	2b00      	cmp	r3, #0
 8006efc:	d101      	bne.n	8006f02 <OsGetHwiFormCnt+0x1a>
        return LOS_ERRNO_HWI_NUM_INVALID;
 8006efe:	4b04      	ldr	r3, [pc, #16]	; (8006f10 <OsGetHwiFormCnt+0x28>)
 8006f00:	e001      	b.n	8006f06 <OsGetHwiFormCnt+0x1e>
    }
    return hwiForm->respCount;
 8006f02:	68fb      	ldr	r3, [r7, #12]
 8006f04:	68db      	ldr	r3, [r3, #12]
}
 8006f06:	4618      	mov	r0, r3
 8006f08:	3710      	adds	r7, #16
 8006f0a:	46bd      	mov	sp, r7
 8006f0c:	bd80      	pop	{r7, pc}
 8006f0e:	bf00      	nop
 8006f10:	02000900 	.word	0x02000900

08006f14 <OsIntIsRegisted>:
    }
    return g_hwiOps->getCurIrqNum();
}

STATIC INLINE BOOL OsIntIsRegisted(UINT32 num)
{
 8006f14:	b580      	push	{r7, lr}
 8006f16:	b084      	sub	sp, #16
 8006f18:	af00      	add	r7, sp, #0
 8006f1a:	6078      	str	r0, [r7, #4]
    HwiHandleInfo *hwiForm = OsGetHwiForm(num);
 8006f1c:	6878      	ldr	r0, [r7, #4]
 8006f1e:	f7ff ffc7 	bl	8006eb0 <OsGetHwiForm>
 8006f22:	60f8      	str	r0, [r7, #12]

    if (hwiForm == NULL) {
 8006f24:	68fb      	ldr	r3, [r7, #12]
 8006f26:	2b00      	cmp	r3, #0
 8006f28:	d101      	bne.n	8006f2e <OsIntIsRegisted+0x1a>
        return false;
 8006f2a:	2300      	movs	r3, #0
 8006f2c:	e006      	b.n	8006f3c <OsIntIsRegisted+0x28>
    }
#ifdef LOSCFG_SHARED_IRQ
    return (hwiForm->next != NULL);
 8006f2e:	68fb      	ldr	r3, [r7, #12]
 8006f30:	689b      	ldr	r3, [r3, #8]
 8006f32:	2b00      	cmp	r3, #0
 8006f34:	bf14      	ite	ne
 8006f36:	2301      	movne	r3, #1
 8006f38:	2300      	moveq	r3, #0
 8006f3a:	b2db      	uxtb	r3, r3
#else
    return (hwiForm->hook != NULL);
#endif
}
 8006f3c:	4618      	mov	r0, r3
 8006f3e:	3710      	adds	r7, #16
 8006f40:	46bd      	mov	sp, r7
 8006f42:	bd80      	pop	{r7, pc}

08006f44 <OsShellCmdHwiInfoTitle>:
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

LITE_OS_SEC_TEXT_MINOR STATIC VOID OsShellCmdHwiInfoTitle(VOID)
{
 8006f44:	b580      	push	{r7, lr}
 8006f46:	af00      	add	r7, sp, #0
#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    PRINTK("InterruptNo     Share     ResponseCount     CYCLECOST     CPUUSE     CPUUSE10s     CPUUSE1s     Name"
 8006f48:	4803      	ldr	r0, [pc, #12]	; (8006f58 <OsShellCmdHwiInfoTitle+0x14>)
 8006f4a:	f7fd fbbf 	bl	80046cc <dprintf>
           "             DevId\n");
    PRINTK("-----------     -----     -------------     ---------     ------     ---------     --------     ---------"
 8006f4e:	4803      	ldr	r0, [pc, #12]	; (8006f5c <OsShellCmdHwiInfoTitle+0x18>)
 8006f50:	f7fd fbbc 	bl	80046cc <dprintf>

#else
    PRINTK("InterruptNo     Share     ResponseCount     Name             DevId\n");
    PRINTK("-----------     -----     -------------     ---------        --------\n");
#endif
}
 8006f54:	bf00      	nop
 8006f56:	bd80      	pop	{r7, pc}
 8006f58:	0802095c 	.word	0x0802095c
 8006f5c:	080209d4 	.word	0x080209d4

08006f60 <GetHwiShare>:

STATIC BOOL GetHwiShare(const HwiHandleInfo *hwiForm)
{
 8006f60:	b480      	push	{r7}
 8006f62:	b083      	sub	sp, #12
 8006f64:	af00      	add	r7, sp, #0
 8006f66:	6078      	str	r0, [r7, #4]
#ifndef LOSCFG_SHARED_IRQ
    return false;
#else
    return (hwiForm->shareMode);
 8006f68:	687b      	ldr	r3, [r7, #4]
 8006f6a:	685b      	ldr	r3, [r3, #4]
#endif
}
 8006f6c:	4618      	mov	r0, r3
 8006f6e:	370c      	adds	r7, #12
 8006f70:	46bd      	mov	sp, r7
 8006f72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f76:	4770      	bx	lr

08006f78 <OsShellCmdHwi>:
#ifdef LOSCFG_CPUP_INCLUDE_IRQ
STATIC CPUP_INFO_S g_hwiCpupAll[LOSCFG_PLATFORM_HWI_LIMIT];
STATIC CPUP_INFO_S g_hwiCpup10s[LOSCFG_PLATFORM_HWI_LIMIT];
STATIC CPUP_INFO_S g_hwiCpup1s[LOSCFG_PLATFORM_HWI_LIMIT];
LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdHwi(INT32 argc, const CHAR **argv)
{
 8006f78:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006f7a:	b093      	sub	sp, #76	; 0x4c
 8006f7c:	af08      	add	r7, sp, #32
 8006f7e:	60f8      	str	r0, [r7, #12]
 8006f80:	60b9      	str	r1, [r7, #8]
    UINT32 i, intSave;
    UINT64 cycles = 0;
 8006f82:	f04f 0200 	mov.w	r2, #0
 8006f86:	f04f 0300 	mov.w	r3, #0
 8006f8a:	e9c7 2308 	strd	r2, r3, [r7, #32]
    size_t size = sizeof(CPUP_INFO_S) * LOSCFG_PLATFORM_HWI_LIMIT;
 8006f8e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8006f92:	61bb      	str	r3, [r7, #24]
    HwiHandleInfo *hwiForm = NULL;
 8006f94:	2300      	movs	r3, #0
 8006f96:	617b      	str	r3, [r7, #20]

    (VOID)argv;
    if (argc > 0) {
 8006f98:	68fb      	ldr	r3, [r7, #12]
 8006f9a:	2b00      	cmp	r3, #0
 8006f9c:	dd05      	ble.n	8006faa <OsShellCmdHwi+0x32>
        PRINTK("\nUsage: hwi\n");
 8006f9e:	4881      	ldr	r0, [pc, #516]	; (80071a4 <OsShellCmdHwi+0x22c>)
 8006fa0:	f7fd fb94 	bl	80046cc <dprintf>
        return OS_ERROR;
 8006fa4:	f04f 33ff 	mov.w	r3, #4294967295
 8006fa8:	e0f7      	b.n	800719a <OsShellCmdHwi+0x222>
    }

    (VOID)memset_s(g_hwiCpupAll, size, 0, size);
 8006faa:	69bb      	ldr	r3, [r7, #24]
 8006fac:	2200      	movs	r2, #0
 8006fae:	69b9      	ldr	r1, [r7, #24]
 8006fb0:	487d      	ldr	r0, [pc, #500]	; (80071a8 <OsShellCmdHwi+0x230>)
 8006fb2:	f00f f86b 	bl	801608c <memset_s>
    (VOID)memset_s(g_hwiCpup10s, size, 0, size);
 8006fb6:	69bb      	ldr	r3, [r7, #24]
 8006fb8:	2200      	movs	r2, #0
 8006fba:	69b9      	ldr	r1, [r7, #24]
 8006fbc:	487b      	ldr	r0, [pc, #492]	; (80071ac <OsShellCmdHwi+0x234>)
 8006fbe:	f00f f865 	bl	801608c <memset_s>
    (VOID)memset_s(g_hwiCpup1s, size, 0, size);
 8006fc2:	69bb      	ldr	r3, [r7, #24]
 8006fc4:	2200      	movs	r2, #0
 8006fc6:	69b9      	ldr	r1, [r7, #24]
 8006fc8:	4879      	ldr	r0, [pc, #484]	; (80071b0 <OsShellCmdHwi+0x238>)
 8006fca:	f00f f85f 	bl	801608c <memset_s>

    intSave = LOS_IntLock();
 8006fce:	f7ff ff5d 	bl	8006e8c <LOS_IntLock>
 8006fd2:	61f8      	str	r0, [r7, #28]
    (VOID)LOS_AllCpuUsage(LOSCFG_PLATFORM_HWI_LIMIT, g_hwiCpupAll, CPUP_ALL_TIME, 0);
 8006fd4:	2300      	movs	r3, #0
 8006fd6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006fda:	4973      	ldr	r1, [pc, #460]	; (80071a8 <OsShellCmdHwi+0x230>)
 8006fdc:	f44f 7080 	mov.w	r0, #256	; 0x100
 8006fe0:	f00d f906 	bl	80141f0 <LOS_AllCpuUsage>
    (VOID)LOS_AllCpuUsage(LOSCFG_PLATFORM_HWI_LIMIT, g_hwiCpup10s, CPUP_LAST_TEN_SECONDS, 0);
 8006fe4:	2300      	movs	r3, #0
 8006fe6:	2200      	movs	r2, #0
 8006fe8:	4970      	ldr	r1, [pc, #448]	; (80071ac <OsShellCmdHwi+0x234>)
 8006fea:	f44f 7080 	mov.w	r0, #256	; 0x100
 8006fee:	f00d f8ff 	bl	80141f0 <LOS_AllCpuUsage>
    (VOID)LOS_AllCpuUsage(LOSCFG_PLATFORM_HWI_LIMIT, g_hwiCpup1s, CPUP_LAST_ONE_SECONDS, 0);
 8006ff2:	2300      	movs	r3, #0
 8006ff4:	2201      	movs	r2, #1
 8006ff6:	496e      	ldr	r1, [pc, #440]	; (80071b0 <OsShellCmdHwi+0x238>)
 8006ff8:	f44f 7080 	mov.w	r0, #256	; 0x100
 8006ffc:	f00d f8f8 	bl	80141f0 <LOS_AllCpuUsage>
    LOS_IntRestore(intSave);
 8007000:	69f8      	ldr	r0, [r7, #28]
 8007002:	f7ff ff4a 	bl	8006e9a <LOS_IntRestore>

    OsShellCmdHwiInfoTitle();
 8007006:	f7ff ff9d 	bl	8006f44 <OsShellCmdHwiInfoTitle>
    for (i = 0; i < LOSCFG_PLATFORM_HWI_LIMIT; i++) {
 800700a:	2300      	movs	r3, #0
 800700c:	613b      	str	r3, [r7, #16]
 800700e:	e0bf      	b.n	8007190 <OsShellCmdHwi+0x218>
        if (!HWI_IS_REGISTED(i)) {
 8007010:	6938      	ldr	r0, [r7, #16]
 8007012:	f7ff ff7f 	bl	8006f14 <OsIntIsRegisted>
 8007016:	4603      	mov	r3, r0
 8007018:	2b00      	cmp	r3, #0
 800701a:	f000 80b5 	beq.w	8007188 <OsShellCmdHwi+0x210>
            continue;
        }

        if (OsGetHwiFormCnt(i)) {
 800701e:	6938      	ldr	r0, [r7, #16]
 8007020:	f7ff ff62 	bl	8006ee8 <OsGetHwiFormCnt>
 8007024:	4603      	mov	r3, r0
 8007026:	2b00      	cmp	r3, #0
 8007028:	d018      	beq.n	800705c <OsShellCmdHwi+0xe4>
            cycles = (OsCpupCBGet(g_taskMaxNum + i))->allTime / OsGetHwiFormCnt(i);
 800702a:	4b62      	ldr	r3, [pc, #392]	; (80071b4 <OsShellCmdHwi+0x23c>)
 800702c:	681a      	ldr	r2, [r3, #0]
 800702e:	693b      	ldr	r3, [r7, #16]
 8007030:	4413      	add	r3, r2
 8007032:	4618      	mov	r0, r3
 8007034:	f00c fbdc 	bl	80137f0 <OsCpupCBGet>
 8007038:	4603      	mov	r3, r0
 800703a:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 800703e:	6938      	ldr	r0, [r7, #16]
 8007040:	f7ff ff52 	bl	8006ee8 <OsGetHwiFormCnt>
 8007044:	4603      	mov	r3, r0
 8007046:	461a      	mov	r2, r3
 8007048:	f04f 0300 	mov.w	r3, #0
 800704c:	4620      	mov	r0, r4
 800704e:	4629      	mov	r1, r5
 8007050:	f7f9 fca0 	bl	8000994 <__aeabi_uldivmod>
 8007054:	4602      	mov	r2, r0
 8007056:	460b      	mov	r3, r1
 8007058:	e9c7 2308 	strd	r2, r3, [r7, #32]
        }

        /* Different cores has different hwi form implementation */
        hwiForm = OsGetHwiForm(i);
 800705c:	6938      	ldr	r0, [r7, #16]
 800705e:	f7ff ff27 	bl	8006eb0 <OsGetHwiForm>
 8007062:	6178      	str	r0, [r7, #20]
        PRINTK("%-8u\t  %-s\t  %-10u\t    %-10llu   %2u.%-7u %2u.%-7u    %2u.%-6u",
 8007064:	6978      	ldr	r0, [r7, #20]
 8007066:	f7ff ff7b 	bl	8006f60 <GetHwiShare>
 800706a:	4603      	mov	r3, r0
 800706c:	2b00      	cmp	r3, #0
 800706e:	d002      	beq.n	8007076 <OsShellCmdHwi+0xfe>
 8007070:	4b51      	ldr	r3, [pc, #324]	; (80071b8 <OsShellCmdHwi+0x240>)
 8007072:	607b      	str	r3, [r7, #4]
 8007074:	e001      	b.n	800707a <OsShellCmdHwi+0x102>
 8007076:	4b51      	ldr	r3, [pc, #324]	; (80071bc <OsShellCmdHwi+0x244>)
 8007078:	607b      	str	r3, [r7, #4]
 800707a:	6938      	ldr	r0, [r7, #16]
 800707c:	f7ff ff34 	bl	8006ee8 <OsGetHwiFormCnt>
 8007080:	4684      	mov	ip, r0
 8007082:	4a49      	ldr	r2, [pc, #292]	; (80071a8 <OsShellCmdHwi+0x230>)
 8007084:	693b      	ldr	r3, [r7, #16]
 8007086:	00db      	lsls	r3, r3, #3
 8007088:	4413      	add	r3, r2
 800708a:	685b      	ldr	r3, [r3, #4]
 800708c:	4a4c      	ldr	r2, [pc, #304]	; (80071c0 <OsShellCmdHwi+0x248>)
 800708e:	fba2 2303 	umull	r2, r3, r2, r3
 8007092:	08dd      	lsrs	r5, r3, #3
 8007094:	4a44      	ldr	r2, [pc, #272]	; (80071a8 <OsShellCmdHwi+0x230>)
 8007096:	693b      	ldr	r3, [r7, #16]
 8007098:	00db      	lsls	r3, r3, #3
 800709a:	4413      	add	r3, r2
 800709c:	6859      	ldr	r1, [r3, #4]
 800709e:	4b48      	ldr	r3, [pc, #288]	; (80071c0 <OsShellCmdHwi+0x248>)
 80070a0:	fba3 2301 	umull	r2, r3, r3, r1
 80070a4:	08da      	lsrs	r2, r3, #3
 80070a6:	4613      	mov	r3, r2
 80070a8:	009b      	lsls	r3, r3, #2
 80070aa:	4413      	add	r3, r2
 80070ac:	005b      	lsls	r3, r3, #1
 80070ae:	1aca      	subs	r2, r1, r3
 80070b0:	493e      	ldr	r1, [pc, #248]	; (80071ac <OsShellCmdHwi+0x234>)
 80070b2:	693b      	ldr	r3, [r7, #16]
 80070b4:	00db      	lsls	r3, r3, #3
 80070b6:	440b      	add	r3, r1
 80070b8:	685b      	ldr	r3, [r3, #4]
 80070ba:	4941      	ldr	r1, [pc, #260]	; (80071c0 <OsShellCmdHwi+0x248>)
 80070bc:	fba1 1303 	umull	r1, r3, r1, r3
 80070c0:	08de      	lsrs	r6, r3, #3
 80070c2:	493a      	ldr	r1, [pc, #232]	; (80071ac <OsShellCmdHwi+0x234>)
 80070c4:	693b      	ldr	r3, [r7, #16]
 80070c6:	00db      	lsls	r3, r3, #3
 80070c8:	440b      	add	r3, r1
 80070ca:	6858      	ldr	r0, [r3, #4]
 80070cc:	4b3c      	ldr	r3, [pc, #240]	; (80071c0 <OsShellCmdHwi+0x248>)
 80070ce:	fba3 1300 	umull	r1, r3, r3, r0
 80070d2:	08d9      	lsrs	r1, r3, #3
 80070d4:	460b      	mov	r3, r1
 80070d6:	009b      	lsls	r3, r3, #2
 80070d8:	440b      	add	r3, r1
 80070da:	005b      	lsls	r3, r3, #1
 80070dc:	1ac1      	subs	r1, r0, r3
 80070de:	4834      	ldr	r0, [pc, #208]	; (80071b0 <OsShellCmdHwi+0x238>)
 80070e0:	693b      	ldr	r3, [r7, #16]
 80070e2:	00db      	lsls	r3, r3, #3
 80070e4:	4403      	add	r3, r0
 80070e6:	685b      	ldr	r3, [r3, #4]
 80070e8:	4835      	ldr	r0, [pc, #212]	; (80071c0 <OsShellCmdHwi+0x248>)
 80070ea:	fba0 0303 	umull	r0, r3, r0, r3
 80070ee:	08db      	lsrs	r3, r3, #3
 80070f0:	603b      	str	r3, [r7, #0]
 80070f2:	482f      	ldr	r0, [pc, #188]	; (80071b0 <OsShellCmdHwi+0x238>)
 80070f4:	693b      	ldr	r3, [r7, #16]
 80070f6:	00db      	lsls	r3, r3, #3
 80070f8:	4403      	add	r3, r0
 80070fa:	685c      	ldr	r4, [r3, #4]
 80070fc:	4b30      	ldr	r3, [pc, #192]	; (80071c0 <OsShellCmdHwi+0x248>)
 80070fe:	fba3 0304 	umull	r0, r3, r3, r4
 8007102:	08d8      	lsrs	r0, r3, #3
 8007104:	4603      	mov	r3, r0
 8007106:	009b      	lsls	r3, r3, #2
 8007108:	4403      	add	r3, r0
 800710a:	005b      	lsls	r3, r3, #1
 800710c:	1ae0      	subs	r0, r4, r3
 800710e:	9007      	str	r0, [sp, #28]
 8007110:	683b      	ldr	r3, [r7, #0]
 8007112:	9306      	str	r3, [sp, #24]
 8007114:	9105      	str	r1, [sp, #20]
 8007116:	9604      	str	r6, [sp, #16]
 8007118:	9203      	str	r2, [sp, #12]
 800711a:	9502      	str	r5, [sp, #8]
 800711c:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8007120:	e9cd 2300 	strd	r2, r3, [sp]
 8007124:	4663      	mov	r3, ip
 8007126:	687a      	ldr	r2, [r7, #4]
 8007128:	6939      	ldr	r1, [r7, #16]
 800712a:	4826      	ldr	r0, [pc, #152]	; (80071c4 <OsShellCmdHwi+0x24c>)
 800712c:	f7fd face 	bl	80046cc <dprintf>
               i, GetHwiShare(hwiForm) ? "Y" : "N", OsGetHwiFormCnt(i), cycles,
               g_hwiCpupAll[i].uwUsage / LOS_CPUP_PRECISION_MULT, g_hwiCpupAll[i].uwUsage % LOS_CPUP_PRECISION_MULT,
               g_hwiCpup10s[i].uwUsage / LOS_CPUP_PRECISION_MULT, g_hwiCpup10s[i].uwUsage % LOS_CPUP_PRECISION_MULT,
               g_hwiCpup1s[i].uwUsage / LOS_CPUP_PRECISION_MULT, g_hwiCpup1s[i].uwUsage % LOS_CPUP_PRECISION_MULT);
#ifdef LOSCFG_SHARED_IRQ
        hwiForm = hwiForm->next;
 8007130:	697b      	ldr	r3, [r7, #20]
 8007132:	689b      	ldr	r3, [r3, #8]
 8007134:	617b      	str	r3, [r7, #20]
#endif
        if ((hwiForm->registerInfo != 0) && ((HWI_IRQ_PARAM_S *)hwiForm->registerInfo)->pName != NULL) {
 8007136:	697b      	ldr	r3, [r7, #20]
 8007138:	685b      	ldr	r3, [r3, #4]
 800713a:	2b00      	cmp	r3, #0
 800713c:	d00f      	beq.n	800715e <OsShellCmdHwi+0x1e6>
 800713e:	697b      	ldr	r3, [r7, #20]
 8007140:	685b      	ldr	r3, [r3, #4]
 8007142:	689b      	ldr	r3, [r3, #8]
 8007144:	2b00      	cmp	r3, #0
 8007146:	d00a      	beq.n	800715e <OsShellCmdHwi+0x1e6>
            PRINTK("\t %-16s 0x%-.8x\n",
 8007148:	697b      	ldr	r3, [r7, #20]
 800714a:	685b      	ldr	r3, [r3, #4]
 800714c:	6899      	ldr	r1, [r3, #8]
 800714e:	697b      	ldr	r3, [r7, #20]
 8007150:	685b      	ldr	r3, [r3, #4]
 8007152:	685b      	ldr	r3, [r3, #4]
 8007154:	461a      	mov	r2, r3
 8007156:	481c      	ldr	r0, [pc, #112]	; (80071c8 <OsShellCmdHwi+0x250>)
 8007158:	f7fd fab8 	bl	80046cc <dprintf>
 800715c:	e002      	b.n	8007164 <OsShellCmdHwi+0x1ec>
                   ((HWI_IRQ_PARAM_S *)hwiForm->registerInfo)->pName,
                   ((HWI_IRQ_PARAM_S *)hwiForm->registerInfo)->pDevId);
        } else {
            PRINTK("\n");
 800715e:	481b      	ldr	r0, [pc, #108]	; (80071cc <OsShellCmdHwi+0x254>)
 8007160:	f7fd fab4 	bl	80046cc <dprintf>
        }
#ifdef LOSCFG_SHARED_IRQ
        while ((hwiForm = hwiForm->next) != NULL) {
 8007164:	e009      	b.n	800717a <OsShellCmdHwi+0x202>
            PRINTK("\t\t\t\t\t\t\t\t\t\t\t\t %-16s 0x%-.8x\n",
 8007166:	697b      	ldr	r3, [r7, #20]
 8007168:	685b      	ldr	r3, [r3, #4]
 800716a:	6899      	ldr	r1, [r3, #8]
 800716c:	697b      	ldr	r3, [r7, #20]
 800716e:	685b      	ldr	r3, [r3, #4]
 8007170:	685b      	ldr	r3, [r3, #4]
 8007172:	461a      	mov	r2, r3
 8007174:	4816      	ldr	r0, [pc, #88]	; (80071d0 <OsShellCmdHwi+0x258>)
 8007176:	f7fd faa9 	bl	80046cc <dprintf>
        while ((hwiForm = hwiForm->next) != NULL) {
 800717a:	697b      	ldr	r3, [r7, #20]
 800717c:	689b      	ldr	r3, [r3, #8]
 800717e:	617b      	str	r3, [r7, #20]
 8007180:	697b      	ldr	r3, [r7, #20]
 8007182:	2b00      	cmp	r3, #0
 8007184:	d1ef      	bne.n	8007166 <OsShellCmdHwi+0x1ee>
 8007186:	e000      	b.n	800718a <OsShellCmdHwi+0x212>
            continue;
 8007188:	bf00      	nop
    for (i = 0; i < LOSCFG_PLATFORM_HWI_LIMIT; i++) {
 800718a:	693b      	ldr	r3, [r7, #16]
 800718c:	3301      	adds	r3, #1
 800718e:	613b      	str	r3, [r7, #16]
 8007190:	693b      	ldr	r3, [r7, #16]
 8007192:	2bff      	cmp	r3, #255	; 0xff
 8007194:	f67f af3c 	bls.w	8007010 <OsShellCmdHwi+0x98>
                   ((HWI_IRQ_PARAM_S *)hwiForm->registerInfo)->pName,
                   ((HWI_IRQ_PARAM_S *)hwiForm->registerInfo)->pDevId);
        }
#endif
    }
    return 0;
 8007198:	2300      	movs	r3, #0
}
 800719a:	4618      	mov	r0, r3
 800719c:	372c      	adds	r7, #44	; 0x2c
 800719e:	46bd      	mov	sp, r7
 80071a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80071a2:	bf00      	nop
 80071a4:	08020a50 	.word	0x08020a50
 80071a8:	200007e8 	.word	0x200007e8
 80071ac:	20000fe8 	.word	0x20000fe8
 80071b0:	200017e8 	.word	0x200017e8
 80071b4:	200036d8 	.word	0x200036d8
 80071b8:	08020a60 	.word	0x08020a60
 80071bc:	08020a64 	.word	0x08020a64
 80071c0:	cccccccd 	.word	0xcccccccd
 80071c4:	08020a68 	.word	0x08020a68
 80071c8:	08020aa8 	.word	0x08020aa8
 80071cc:	08020abc 	.word	0x08020abc
 80071d0:	08020ac0 	.word	0x08020ac0

080071d4 <OsShellCmdMemCheck>:

#define MEM_SIZE_1K 0x400
#define MEM_SIZE_1M 0x100000

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdMemCheck(INT32 argc, const CHAR *argv[])
{
 80071d4:	b580      	push	{r7, lr}
 80071d6:	b082      	sub	sp, #8
 80071d8:	af00      	add	r7, sp, #0
 80071da:	6078      	str	r0, [r7, #4]
 80071dc:	6039      	str	r1, [r7, #0]
    if (argc > 0) {
 80071de:	687b      	ldr	r3, [r7, #4]
 80071e0:	2b00      	cmp	r3, #0
 80071e2:	dd05      	ble.n	80071f0 <OsShellCmdMemCheck+0x1c>
        PRINTK("\nUsage: memcheck\n");
 80071e4:	4806      	ldr	r0, [pc, #24]	; (8007200 <OsShellCmdMemCheck+0x2c>)
 80071e6:	f7fd fa71 	bl	80046cc <dprintf>
        return OS_ERROR;
 80071ea:	f04f 33ff 	mov.w	r3, #4294967295
 80071ee:	e002      	b.n	80071f6 <OsShellCmdMemCheck+0x22>
    }

    OsMemIntegrityMultiCheck();
 80071f0:	f001 fdc4 	bl	8008d7c <OsMemIntegrityMultiCheck>
    return 0;
 80071f4:	2300      	movs	r3, #0
}
 80071f6:	4618      	mov	r0, r3
 80071f8:	3708      	adds	r7, #8
 80071fa:	46bd      	mov	sp, r7
 80071fc:	bd80      	pop	{r7, pc}
 80071fe:	bf00      	nop
 8007200:	08020ae0 	.word	0x08020ae0

08007204 <OsShellCmdSectionInfo>:

    return 0;
}

LITE_OS_SEC_TEXT_MINOR STATIC VOID OsShellCmdSectionInfo(INT32 argc, const CHAR *argv[])
{
 8007204:	b580      	push	{r7, lr}
 8007206:	b088      	sub	sp, #32
 8007208:	af02      	add	r7, sp, #8
 800720a:	6078      	str	r0, [r7, #4]
 800720c:	6039      	str	r1, [r7, #0]
    size_t textLen = &__text_end - &__text_start;
 800720e:	4a2a      	ldr	r2, [pc, #168]	; (80072b8 <OsShellCmdSectionInfo+0xb4>)
 8007210:	4b2a      	ldr	r3, [pc, #168]	; (80072bc <OsShellCmdSectionInfo+0xb8>)
 8007212:	1ad3      	subs	r3, r2, r3
 8007214:	60bb      	str	r3, [r7, #8]
    size_t dataLen = &__ram_data_end - &__ram_data_start;
 8007216:	4a2a      	ldr	r2, [pc, #168]	; (80072c0 <OsShellCmdSectionInfo+0xbc>)
 8007218:	4b2a      	ldr	r3, [pc, #168]	; (80072c4 <OsShellCmdSectionInfo+0xc0>)
 800721a:	1ad3      	subs	r3, r2, r3
 800721c:	60fb      	str	r3, [r7, #12]
    size_t rodataLen = &__rodata_end - &__rodata_start;
 800721e:	4a2a      	ldr	r2, [pc, #168]	; (80072c8 <OsShellCmdSectionInfo+0xc4>)
 8007220:	4b2a      	ldr	r3, [pc, #168]	; (80072cc <OsShellCmdSectionInfo+0xc8>)
 8007222:	1ad3      	subs	r3, r2, r3
 8007224:	613b      	str	r3, [r7, #16]
    size_t bssLen = &__bss_end - &__bss_start;
 8007226:	4a2a      	ldr	r2, [pc, #168]	; (80072d0 <OsShellCmdSectionInfo+0xcc>)
 8007228:	4b2a      	ldr	r3, [pc, #168]	; (80072d4 <OsShellCmdSectionInfo+0xd0>)
 800722a:	1ad3      	subs	r3, r2, r3
 800722c:	617b      	str	r3, [r7, #20]
    textLen += &__fast_text_end - &__fast_text_start;
    dataLen += &__fast_data_end - &__fast_data_start;
    rodataLen += &__fast_rodata_end - &__fast_rodata_start;
#endif

    PRINTK("\r\n        text         data          rodata        bss\n");
 800722e:	482a      	ldr	r0, [pc, #168]	; (80072d8 <OsShellCmdSectionInfo+0xd4>)
 8007230:	f7fd fa4c 	bl	80046cc <dprintf>
    if ((argc == 1) && (strcmp(argv[0], "-k") == 0)) {
 8007234:	687b      	ldr	r3, [r7, #4]
 8007236:	2b01      	cmp	r3, #1
 8007238:	d116      	bne.n	8007268 <OsShellCmdSectionInfo+0x64>
 800723a:	683b      	ldr	r3, [r7, #0]
 800723c:	681b      	ldr	r3, [r3, #0]
 800723e:	4927      	ldr	r1, [pc, #156]	; (80072dc <OsShellCmdSectionInfo+0xd8>)
 8007240:	4618      	mov	r0, r3
 8007242:	f007 fc00 	bl	800ea46 <strcmp>
 8007246:	4603      	mov	r3, r0
 8007248:	2b00      	cmp	r3, #0
 800724a:	d10d      	bne.n	8007268 <OsShellCmdSectionInfo+0x64>
        PRINTK("Mem:    %-9lu    %-10lu    %-10lu    %-10lu\n", textLen / MEM_SIZE_1K, dataLen / MEM_SIZE_1K,
 800724c:	68bb      	ldr	r3, [r7, #8]
 800724e:	0a99      	lsrs	r1, r3, #10
 8007250:	68fb      	ldr	r3, [r7, #12]
 8007252:	0a9a      	lsrs	r2, r3, #10
 8007254:	693b      	ldr	r3, [r7, #16]
 8007256:	0a98      	lsrs	r0, r3, #10
 8007258:	697b      	ldr	r3, [r7, #20]
 800725a:	0a9b      	lsrs	r3, r3, #10
 800725c:	9300      	str	r3, [sp, #0]
 800725e:	4603      	mov	r3, r0
 8007260:	481f      	ldr	r0, [pc, #124]	; (80072e0 <OsShellCmdSectionInfo+0xdc>)
 8007262:	f7fd fa33 	bl	80046cc <dprintf>
 8007266:	e022      	b.n	80072ae <OsShellCmdSectionInfo+0xaa>
               rodataLen / MEM_SIZE_1K, bssLen / MEM_SIZE_1K);
    } else if ((argc == 1) && (strcmp(argv[0], "-m") == 0)) {
 8007268:	687b      	ldr	r3, [r7, #4]
 800726a:	2b01      	cmp	r3, #1
 800726c:	d116      	bne.n	800729c <OsShellCmdSectionInfo+0x98>
 800726e:	683b      	ldr	r3, [r7, #0]
 8007270:	681b      	ldr	r3, [r3, #0]
 8007272:	491c      	ldr	r1, [pc, #112]	; (80072e4 <OsShellCmdSectionInfo+0xe0>)
 8007274:	4618      	mov	r0, r3
 8007276:	f007 fbe6 	bl	800ea46 <strcmp>
 800727a:	4603      	mov	r3, r0
 800727c:	2b00      	cmp	r3, #0
 800727e:	d10d      	bne.n	800729c <OsShellCmdSectionInfo+0x98>
        PRINTK("Mem:    %-9lu    %-10lu    %-10lu    %-10lu\n", textLen / MEM_SIZE_1M, dataLen / MEM_SIZE_1M,
 8007280:	68bb      	ldr	r3, [r7, #8]
 8007282:	0d19      	lsrs	r1, r3, #20
 8007284:	68fb      	ldr	r3, [r7, #12]
 8007286:	0d1a      	lsrs	r2, r3, #20
 8007288:	693b      	ldr	r3, [r7, #16]
 800728a:	0d18      	lsrs	r0, r3, #20
 800728c:	697b      	ldr	r3, [r7, #20]
 800728e:	0d1b      	lsrs	r3, r3, #20
 8007290:	9300      	str	r3, [sp, #0]
 8007292:	4603      	mov	r3, r0
 8007294:	4812      	ldr	r0, [pc, #72]	; (80072e0 <OsShellCmdSectionInfo+0xdc>)
 8007296:	f7fd fa19 	bl	80046cc <dprintf>
 800729a:	e008      	b.n	80072ae <OsShellCmdSectionInfo+0xaa>
               rodataLen / MEM_SIZE_1M, bssLen / MEM_SIZE_1M);
    } else {
        PRINTK("Mem:    %-9lu    %-10lu    %-10lu    %-10lu\n", textLen, dataLen, rodataLen, bssLen);
 800729c:	697b      	ldr	r3, [r7, #20]
 800729e:	9300      	str	r3, [sp, #0]
 80072a0:	693b      	ldr	r3, [r7, #16]
 80072a2:	68fa      	ldr	r2, [r7, #12]
 80072a4:	68b9      	ldr	r1, [r7, #8]
 80072a6:	480e      	ldr	r0, [pc, #56]	; (80072e0 <OsShellCmdSectionInfo+0xdc>)
 80072a8:	f7fd fa10 	bl	80046cc <dprintf>
    }
}
 80072ac:	bf00      	nop
 80072ae:	bf00      	nop
 80072b0:	3718      	adds	r7, #24
 80072b2:	46bd      	mov	sp, r7
 80072b4:	bd80      	pop	{r7, pc}
 80072b6:	bf00      	nop
 80072b8:	0801fda4 	.word	0x0801fda4
 80072bc:	080001c8 	.word	0x080001c8
 80072c0:	20000724 	.word	0x20000724
 80072c4:	20000400 	.word	0x20000400
 80072c8:	080243a4 	.word	0x080243a4
 80072cc:	0801fda4 	.word	0x0801fda4
 80072d0:	200037ec 	.word	0x200037ec
 80072d4:	20000728 	.word	0x20000728
 80072d8:	08020b54 	.word	0x08020b54
 80072dc:	08020b8c 	.word	0x08020b8c
 80072e0:	08020b90 	.word	0x08020b90
 80072e4:	08020bc0 	.word	0x08020bc0

080072e8 <OsShellCmdFreeInfo>:

LITE_OS_SEC_TEXT_MINOR STATIC UINT32 OsShellCmdFreeInfo(INT32 argc, const CHAR *argv[])
{
 80072e8:	b580      	push	{r7, lr}
 80072ea:	b086      	sub	sp, #24
 80072ec:	af00      	add	r7, sp, #0
 80072ee:	6078      	str	r0, [r7, #4]
 80072f0:	6039      	str	r1, [r7, #0]
    UINT32 memUsed0 = LOS_MemTotalUsedGet(m_aucSysMem0);
    UINT32 totalMem0 = LOS_MemPoolSizeGet(m_aucSysMem0);
    UINT32 freeMem0 = totalMem0 - memUsed0;
#endif

    UINT32 memUsed = LOS_MemTotalUsedGet(m_aucSysMem1);
 80072f2:	4b37      	ldr	r3, [pc, #220]	; (80073d0 <OsShellCmdFreeInfo+0xe8>)
 80072f4:	681b      	ldr	r3, [r3, #0]
 80072f6:	4618      	mov	r0, r3
 80072f8:	f001 fcc4 	bl	8008c84 <LOS_MemTotalUsedGet>
 80072fc:	60f8      	str	r0, [r7, #12]
    UINT32 totalMem = LOS_MemPoolSizeGet(m_aucSysMem1);
 80072fe:	4b34      	ldr	r3, [pc, #208]	; (80073d0 <OsShellCmdFreeInfo+0xe8>)
 8007300:	681b      	ldr	r3, [r3, #0]
 8007302:	4618      	mov	r0, r3
 8007304:	f001 fcf6 	bl	8008cf4 <LOS_MemPoolSizeGet>
 8007308:	6138      	str	r0, [r7, #16]
    UINT32 freeMem = totalMem - memUsed;
 800730a:	693a      	ldr	r2, [r7, #16]
 800730c:	68fb      	ldr	r3, [r7, #12]
 800730e:	1ad3      	subs	r3, r2, r3
 8007310:	617b      	str	r3, [r7, #20]

    if ((argc == 0) ||
 8007312:	687b      	ldr	r3, [r7, #4]
 8007314:	2b00      	cmp	r3, #0
 8007316:	d017      	beq.n	8007348 <OsShellCmdFreeInfo+0x60>
 8007318:	687b      	ldr	r3, [r7, #4]
 800731a:	2b01      	cmp	r3, #1
 800731c:	d108      	bne.n	8007330 <OsShellCmdFreeInfo+0x48>
        ((argc == 1) && (strcmp(argv[0], "-k") == 0)) ||
 800731e:	683b      	ldr	r3, [r7, #0]
 8007320:	681b      	ldr	r3, [r3, #0]
 8007322:	492c      	ldr	r1, [pc, #176]	; (80073d4 <OsShellCmdFreeInfo+0xec>)
 8007324:	4618      	mov	r0, r3
 8007326:	f007 fb8e 	bl	800ea46 <strcmp>
 800732a:	4603      	mov	r3, r0
 800732c:	2b00      	cmp	r3, #0
 800732e:	d00b      	beq.n	8007348 <OsShellCmdFreeInfo+0x60>
 8007330:	687b      	ldr	r3, [r7, #4]
 8007332:	2b01      	cmp	r3, #1
 8007334:	d10b      	bne.n	800734e <OsShellCmdFreeInfo+0x66>
        ((argc == 1) && (strcmp(argv[0], "-m") == 0))) {
 8007336:	683b      	ldr	r3, [r7, #0]
 8007338:	681b      	ldr	r3, [r3, #0]
 800733a:	4927      	ldr	r1, [pc, #156]	; (80073d8 <OsShellCmdFreeInfo+0xf0>)
 800733c:	4618      	mov	r0, r3
 800733e:	f007 fb82 	bl	800ea46 <strcmp>
 8007342:	4603      	mov	r3, r0
 8007344:	2b00      	cmp	r3, #0
 8007346:	d102      	bne.n	800734e <OsShellCmdFreeInfo+0x66>
#ifdef LOSCFG_EXC_INTERACTION
        PRINTK("\r\n***** Mem:system mem      Mem1:exception interaction mem *****\n");
#endif
        PRINTK("\r\n        total        used          free\n");
 8007348:	4824      	ldr	r0, [pc, #144]	; (80073dc <OsShellCmdFreeInfo+0xf4>)
 800734a:	f7fd f9bf 	bl	80046cc <dprintf>
    }

    if ((argc == 1) && (strcmp(argv[0], "-k") == 0)) {
 800734e:	687b      	ldr	r3, [r7, #4]
 8007350:	2b01      	cmp	r3, #1
 8007352:	d112      	bne.n	800737a <OsShellCmdFreeInfo+0x92>
 8007354:	683b      	ldr	r3, [r7, #0]
 8007356:	681b      	ldr	r3, [r3, #0]
 8007358:	491e      	ldr	r1, [pc, #120]	; (80073d4 <OsShellCmdFreeInfo+0xec>)
 800735a:	4618      	mov	r0, r3
 800735c:	f007 fb73 	bl	800ea46 <strcmp>
 8007360:	4603      	mov	r3, r0
 8007362:	2b00      	cmp	r3, #0
 8007364:	d109      	bne.n	800737a <OsShellCmdFreeInfo+0x92>
        PRINTK("Mem:    %-9u    %-10u    %-10u\n", totalMem / MEM_SIZE_1K, memUsed / MEM_SIZE_1K,
 8007366:	693b      	ldr	r3, [r7, #16]
 8007368:	0a99      	lsrs	r1, r3, #10
 800736a:	68fb      	ldr	r3, [r7, #12]
 800736c:	0a9a      	lsrs	r2, r3, #10
 800736e:	697b      	ldr	r3, [r7, #20]
 8007370:	0a9b      	lsrs	r3, r3, #10
 8007372:	481b      	ldr	r0, [pc, #108]	; (80073e0 <OsShellCmdFreeInfo+0xf8>)
 8007374:	f7fd f9aa 	bl	80046cc <dprintf>
 8007378:	e025      	b.n	80073c6 <OsShellCmdFreeInfo+0xde>
               freeMem / MEM_SIZE_1K);
#ifdef LOSCFG_EXC_INTERACTION
        PRINTK("Mem1:   %-9u    %-10u    %-10u\n", totalMem0 / MEM_SIZE_1K, memUsed0 / MEM_SIZE_1K,
               freeMem0 / MEM_SIZE_1K);
#endif
    } else if ((argc == 1) && (strcmp(argv[0], "-m") == 0)) {
 800737a:	687b      	ldr	r3, [r7, #4]
 800737c:	2b01      	cmp	r3, #1
 800737e:	d112      	bne.n	80073a6 <OsShellCmdFreeInfo+0xbe>
 8007380:	683b      	ldr	r3, [r7, #0]
 8007382:	681b      	ldr	r3, [r3, #0]
 8007384:	4914      	ldr	r1, [pc, #80]	; (80073d8 <OsShellCmdFreeInfo+0xf0>)
 8007386:	4618      	mov	r0, r3
 8007388:	f007 fb5d 	bl	800ea46 <strcmp>
 800738c:	4603      	mov	r3, r0
 800738e:	2b00      	cmp	r3, #0
 8007390:	d109      	bne.n	80073a6 <OsShellCmdFreeInfo+0xbe>
        PRINTK("Mem:    %-9u    %-10u    %-10u\n", totalMem / MEM_SIZE_1M, memUsed / MEM_SIZE_1M,
 8007392:	693b      	ldr	r3, [r7, #16]
 8007394:	0d19      	lsrs	r1, r3, #20
 8007396:	68fb      	ldr	r3, [r7, #12]
 8007398:	0d1a      	lsrs	r2, r3, #20
 800739a:	697b      	ldr	r3, [r7, #20]
 800739c:	0d1b      	lsrs	r3, r3, #20
 800739e:	4810      	ldr	r0, [pc, #64]	; (80073e0 <OsShellCmdFreeInfo+0xf8>)
 80073a0:	f7fd f994 	bl	80046cc <dprintf>
 80073a4:	e00f      	b.n	80073c6 <OsShellCmdFreeInfo+0xde>
               freeMem / MEM_SIZE_1M);
#ifdef LOSCFG_EXC_INTERACTION
        PRINTK("Mem1:   %-9u    %-10u    %-10u\n", totalMem0 / MEM_SIZE_1M, memUsed0 / MEM_SIZE_1M,
               freeMem0 / MEM_SIZE_1M);
#endif
    } else if (argc == 0) {
 80073a6:	687b      	ldr	r3, [r7, #4]
 80073a8:	2b00      	cmp	r3, #0
 80073aa:	d106      	bne.n	80073ba <OsShellCmdFreeInfo+0xd2>
        PRINTK("Mem:    %-9u    %-10u    %-10u\n", totalMem, memUsed, freeMem);
 80073ac:	697b      	ldr	r3, [r7, #20]
 80073ae:	68fa      	ldr	r2, [r7, #12]
 80073b0:	6939      	ldr	r1, [r7, #16]
 80073b2:	480b      	ldr	r0, [pc, #44]	; (80073e0 <OsShellCmdFreeInfo+0xf8>)
 80073b4:	f7fd f98a 	bl	80046cc <dprintf>
 80073b8:	e005      	b.n	80073c6 <OsShellCmdFreeInfo+0xde>
#ifdef LOSCFG_EXC_INTERACTION
        PRINTK("Mem1:   %-9u    %-10u    %-10u\n", totalMem0, memUsed0, freeMem0);
#endif
    } else {
        PRINTK("\nUsage: free or free [-k/-m]\n");
 80073ba:	480a      	ldr	r0, [pc, #40]	; (80073e4 <OsShellCmdFreeInfo+0xfc>)
 80073bc:	f7fd f986 	bl	80046cc <dprintf>
        return OS_ERROR;
 80073c0:	f04f 33ff 	mov.w	r3, #4294967295
 80073c4:	e000      	b.n	80073c8 <OsShellCmdFreeInfo+0xe0>
    }
    return 0;
 80073c6:	2300      	movs	r3, #0
}
 80073c8:	4618      	mov	r0, r3
 80073ca:	3718      	adds	r7, #24
 80073cc:	46bd      	mov	sp, r7
 80073ce:	bd80      	pop	{r7, pc}
 80073d0:	200021b8 	.word	0x200021b8
 80073d4:	08020b8c 	.word	0x08020b8c
 80073d8:	08020bc0 	.word	0x08020bc0
 80073dc:	08020bc4 	.word	0x08020bc4
 80073e0:	08020bf0 	.word	0x08020bf0
 80073e4:	08020c10 	.word	0x08020c10

080073e8 <OsShellCmdFree>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdFree(INT32 argc, const CHAR *argv[])
{
 80073e8:	b580      	push	{r7, lr}
 80073ea:	b082      	sub	sp, #8
 80073ec:	af00      	add	r7, sp, #0
 80073ee:	6078      	str	r0, [r7, #4]
 80073f0:	6039      	str	r1, [r7, #0]
    if (argc > 1) {
 80073f2:	687b      	ldr	r3, [r7, #4]
 80073f4:	2b01      	cmp	r3, #1
 80073f6:	dd05      	ble.n	8007404 <OsShellCmdFree+0x1c>
        PRINTK("\nUsage: free or free [-k/-m]\n");
 80073f8:	480c      	ldr	r0, [pc, #48]	; (800742c <OsShellCmdFree+0x44>)
 80073fa:	f7fd f967 	bl	80046cc <dprintf>
        return OS_ERROR;
 80073fe:	f04f 33ff 	mov.w	r3, #4294967295
 8007402:	e00e      	b.n	8007422 <OsShellCmdFree+0x3a>
    }
    if (OsShellCmdFreeInfo(argc, argv) != 0) {
 8007404:	6839      	ldr	r1, [r7, #0]
 8007406:	6878      	ldr	r0, [r7, #4]
 8007408:	f7ff ff6e 	bl	80072e8 <OsShellCmdFreeInfo>
 800740c:	4603      	mov	r3, r0
 800740e:	2b00      	cmp	r3, #0
 8007410:	d002      	beq.n	8007418 <OsShellCmdFree+0x30>
        return OS_ERROR;
 8007412:	f04f 33ff 	mov.w	r3, #4294967295
 8007416:	e004      	b.n	8007422 <OsShellCmdFree+0x3a>
    }
    OsShellCmdSectionInfo(argc, argv);
 8007418:	6839      	ldr	r1, [r7, #0]
 800741a:	6878      	ldr	r0, [r7, #4]
 800741c:	f7ff fef2 	bl	8007204 <OsShellCmdSectionInfo>
    return 0;
 8007420:	2300      	movs	r3, #0
}
 8007422:	4618      	mov	r0, r3
 8007424:	3708      	adds	r7, #8
 8007426:	46bd      	mov	sp, r7
 8007428:	bd80      	pop	{r7, pc}
 800742a:	bf00      	nop
 800742c:	08020c10 	.word	0x08020c10

08007430 <OsShellCmdUname>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdUname(INT32 argc, const CHAR *argv[])
{
 8007430:	b580      	push	{r7, lr}
 8007432:	b084      	sub	sp, #16
 8007434:	af02      	add	r7, sp, #8
 8007436:	6078      	str	r0, [r7, #4]
 8007438:	6039      	str	r1, [r7, #0]
    if (argc == 0) {
 800743a:	687b      	ldr	r3, [r7, #4]
 800743c:	2b00      	cmp	r3, #0
 800743e:	d104      	bne.n	800744a <OsShellCmdUname+0x1a>
        PRINTK("Huawei LiteOS\n");
 8007440:	4833      	ldr	r0, [pc, #204]	; (8007510 <OsShellCmdUname+0xe0>)
 8007442:	f7fd f943 	bl	80046cc <dprintf>
        return 0;
 8007446:	2300      	movs	r3, #0
 8007448:	e05e      	b.n	8007508 <OsShellCmdUname+0xd8>
    }

    if (argc == 1) {
 800744a:	687b      	ldr	r3, [r7, #4]
 800744c:	2b01      	cmp	r3, #1
 800744e:	d153      	bne.n	80074f8 <OsShellCmdUname+0xc8>
        if (strcmp(argv[0], "-a") == 0) {
 8007450:	683b      	ldr	r3, [r7, #0]
 8007452:	681b      	ldr	r3, [r3, #0]
 8007454:	492f      	ldr	r1, [pc, #188]	; (8007514 <OsShellCmdUname+0xe4>)
 8007456:	4618      	mov	r0, r3
 8007458:	f007 faf5 	bl	800ea46 <strcmp>
 800745c:	4603      	mov	r3, r0
 800745e:	2b00      	cmp	r3, #0
 8007460:	d10b      	bne.n	800747a <OsShellCmdUname+0x4a>
            PRINTK("%s %s %s %s %s\n", HW_LITEOS_VER, HW_LITEOS_SYSNAME, HW_LITEOS_KERNEL_VERSION_STRING,
 8007462:	4b2d      	ldr	r3, [pc, #180]	; (8007518 <OsShellCmdUname+0xe8>)
 8007464:	9301      	str	r3, [sp, #4]
 8007466:	4b2d      	ldr	r3, [pc, #180]	; (800751c <OsShellCmdUname+0xec>)
 8007468:	9300      	str	r3, [sp, #0]
 800746a:	4b2d      	ldr	r3, [pc, #180]	; (8007520 <OsShellCmdUname+0xf0>)
 800746c:	4a2d      	ldr	r2, [pc, #180]	; (8007524 <OsShellCmdUname+0xf4>)
 800746e:	492e      	ldr	r1, [pc, #184]	; (8007528 <OsShellCmdUname+0xf8>)
 8007470:	482e      	ldr	r0, [pc, #184]	; (800752c <OsShellCmdUname+0xfc>)
 8007472:	f7fd f92b 	bl	80046cc <dprintf>
                   __DATE__, __TIME__);
            return 0;
 8007476:	2300      	movs	r3, #0
 8007478:	e046      	b.n	8007508 <OsShellCmdUname+0xd8>
        } else if (strcmp(argv[0], "-s") == 0) {
 800747a:	683b      	ldr	r3, [r7, #0]
 800747c:	681b      	ldr	r3, [r3, #0]
 800747e:	492c      	ldr	r1, [pc, #176]	; (8007530 <OsShellCmdUname+0x100>)
 8007480:	4618      	mov	r0, r3
 8007482:	f007 fae0 	bl	800ea46 <strcmp>
 8007486:	4603      	mov	r3, r0
 8007488:	2b00      	cmp	r3, #0
 800748a:	d104      	bne.n	8007496 <OsShellCmdUname+0x66>
            PRINTK("Huawei LiteOS\n");
 800748c:	4820      	ldr	r0, [pc, #128]	; (8007510 <OsShellCmdUname+0xe0>)
 800748e:	f7fd f91d 	bl	80046cc <dprintf>
            return 0;
 8007492:	2300      	movs	r3, #0
 8007494:	e038      	b.n	8007508 <OsShellCmdUname+0xd8>
        } else if (strcmp(argv[0], "-t") == 0) {
 8007496:	683b      	ldr	r3, [r7, #0]
 8007498:	681b      	ldr	r3, [r3, #0]
 800749a:	4926      	ldr	r1, [pc, #152]	; (8007534 <OsShellCmdUname+0x104>)
 800749c:	4618      	mov	r0, r3
 800749e:	f007 fad2 	bl	800ea46 <strcmp>
 80074a2:	4603      	mov	r3, r0
 80074a4:	2b00      	cmp	r3, #0
 80074a6:	d106      	bne.n	80074b6 <OsShellCmdUname+0x86>
            PRINTK("build date : %s %s", __DATE__, __TIME__);
 80074a8:	4a1b      	ldr	r2, [pc, #108]	; (8007518 <OsShellCmdUname+0xe8>)
 80074aa:	491c      	ldr	r1, [pc, #112]	; (800751c <OsShellCmdUname+0xec>)
 80074ac:	4822      	ldr	r0, [pc, #136]	; (8007538 <OsShellCmdUname+0x108>)
 80074ae:	f7fd f90d 	bl	80046cc <dprintf>
            return 0;
 80074b2:	2300      	movs	r3, #0
 80074b4:	e028      	b.n	8007508 <OsShellCmdUname+0xd8>
        } else if (strcmp(argv[0], "-v") == 0) {
 80074b6:	683b      	ldr	r3, [r7, #0]
 80074b8:	681b      	ldr	r3, [r3, #0]
 80074ba:	4920      	ldr	r1, [pc, #128]	; (800753c <OsShellCmdUname+0x10c>)
 80074bc:	4618      	mov	r0, r3
 80074be:	f007 fac2 	bl	800ea46 <strcmp>
 80074c2:	4603      	mov	r3, r0
 80074c4:	2b00      	cmp	r3, #0
 80074c6:	d109      	bne.n	80074dc <OsShellCmdUname+0xac>
            PRINTK("%s %s %s %s\n", HW_LITEOS_SYSNAME, HW_LITEOS_KERNEL_VERSION_STRING,
 80074c8:	4b13      	ldr	r3, [pc, #76]	; (8007518 <OsShellCmdUname+0xe8>)
 80074ca:	9300      	str	r3, [sp, #0]
 80074cc:	4b13      	ldr	r3, [pc, #76]	; (800751c <OsShellCmdUname+0xec>)
 80074ce:	4a14      	ldr	r2, [pc, #80]	; (8007520 <OsShellCmdUname+0xf0>)
 80074d0:	4914      	ldr	r1, [pc, #80]	; (8007524 <OsShellCmdUname+0xf4>)
 80074d2:	481b      	ldr	r0, [pc, #108]	; (8007540 <OsShellCmdUname+0x110>)
 80074d4:	f7fd f8fa 	bl	80046cc <dprintf>
                   __DATE__, __TIME__);
            return 0;
 80074d8:	2300      	movs	r3, #0
 80074da:	e015      	b.n	8007508 <OsShellCmdUname+0xd8>
        } else if (strcmp(argv[0], "--help") == 0) {
 80074dc:	683b      	ldr	r3, [r7, #0]
 80074de:	681b      	ldr	r3, [r3, #0]
 80074e0:	4918      	ldr	r1, [pc, #96]	; (8007544 <OsShellCmdUname+0x114>)
 80074e2:	4618      	mov	r0, r3
 80074e4:	f007 faaf 	bl	800ea46 <strcmp>
 80074e8:	4603      	mov	r3, r0
 80074ea:	2b00      	cmp	r3, #0
 80074ec:	d104      	bne.n	80074f8 <OsShellCmdUname+0xc8>
            PRINTK("-a,            print all information\n"
 80074ee:	4816      	ldr	r0, [pc, #88]	; (8007548 <OsShellCmdUname+0x118>)
 80074f0:	f7fd f8ec 	bl	80046cc <dprintf>
                   "-s,            print the kernel name\n"
                   "-t,            print the build date\n"
                   "-v,            print the kernel version\n");
            return 0;
 80074f4:	2300      	movs	r3, #0
 80074f6:	e007      	b.n	8007508 <OsShellCmdUname+0xd8>
        }
    }

    PRINTK("uname: invalid option %s\n"
 80074f8:	683b      	ldr	r3, [r7, #0]
 80074fa:	681b      	ldr	r3, [r3, #0]
 80074fc:	4619      	mov	r1, r3
 80074fe:	4813      	ldr	r0, [pc, #76]	; (800754c <OsShellCmdUname+0x11c>)
 8007500:	f7fd f8e4 	bl	80046cc <dprintf>
           "Try 'uname --help' for more information.\n",
           argv[0]);
    return OS_ERROR;
 8007504:	f04f 33ff 	mov.w	r3, #4294967295
}
 8007508:	4618      	mov	r0, r3
 800750a:	3708      	adds	r7, #8
 800750c:	46bd      	mov	sp, r7
 800750e:	bd80      	pop	{r7, pc}
 8007510:	08020c30 	.word	0x08020c30
 8007514:	08020c40 	.word	0x08020c40
 8007518:	08020c90 	.word	0x08020c90
 800751c:	08020c9c 	.word	0x08020c9c
 8007520:	08020c44 	.word	0x08020c44
 8007524:	08020c4c 	.word	0x08020c4c
 8007528:	08020c5c 	.word	0x08020c5c
 800752c:	08020c80 	.word	0x08020c80
 8007530:	08020ca8 	.word	0x08020ca8
 8007534:	08020cac 	.word	0x08020cac
 8007538:	08020cb0 	.word	0x08020cb0
 800753c:	08020cc4 	.word	0x08020cc4
 8007540:	08020cc8 	.word	0x08020cc8
 8007544:	08020cd8 	.word	0x08020cd8
 8007548:	08020ce0 	.word	0x08020ce0
 800754c:	08020d78 	.word	0x08020d78

08007550 <OsPrintSwtmrMsg>:
    "Created",
    "Ticking",
};

STATIC VOID OsPrintSwtmrMsg(const LosSwtmrCB *swtmr)
{
 8007550:	b5b0      	push	{r4, r5, r7, lr}
 8007552:	b086      	sub	sp, #24
 8007554:	af04      	add	r7, sp, #16
 8007556:	6078      	str	r0, [r7, #4]
    PRINTK("0x%08x  "
 8007558:	687b      	ldr	r3, [r7, #4]
 800755a:	8a1b      	ldrh	r3, [r3, #16]
 800755c:	f003 000f 	and.w	r0, r3, #15
 8007560:	687b      	ldr	r3, [r7, #4]
 8007562:	7b1b      	ldrb	r3, [r3, #12]
 8007564:	461a      	mov	r2, r3
 8007566:	4613      	mov	r3, r2
 8007568:	005b      	lsls	r3, r3, #1
 800756a:	4413      	add	r3, r2
 800756c:	009b      	lsls	r3, r3, #2
 800756e:	4a0f      	ldr	r2, [pc, #60]	; (80075ac <OsPrintSwtmrMsg+0x5c>)
 8007570:	189c      	adds	r4, r3, r2
 8007572:	687b      	ldr	r3, [r7, #4]
 8007574:	7b5b      	ldrb	r3, [r3, #13]
 8007576:	461a      	mov	r2, r3
 8007578:	4613      	mov	r3, r2
 800757a:	005b      	lsls	r3, r3, #1
 800757c:	4413      	add	r3, r2
 800757e:	009b      	lsls	r3, r3, #2
 8007580:	4a0b      	ldr	r2, [pc, #44]	; (80075b0 <OsPrintSwtmrMsg+0x60>)
 8007582:	189d      	adds	r5, r3, r2
 8007584:	687b      	ldr	r3, [r7, #4]
 8007586:	695b      	ldr	r3, [r3, #20]
 8007588:	687a      	ldr	r2, [r7, #4]
 800758a:	69d2      	ldr	r2, [r2, #28]
 800758c:	6879      	ldr	r1, [r7, #4]
 800758e:	6a09      	ldr	r1, [r1, #32]
 8007590:	9102      	str	r1, [sp, #8]
 8007592:	9201      	str	r2, [sp, #4]
 8007594:	9300      	str	r3, [sp, #0]
 8007596:	462b      	mov	r3, r5
 8007598:	4622      	mov	r2, r4
 800759a:	4601      	mov	r1, r0
 800759c:	4805      	ldr	r0, [pc, #20]	; (80075b4 <OsPrintSwtmrMsg+0x64>)
 800759e:	f7fd f895 	bl	80046cc <dprintf>
           g_shellSwtmrStatus[swtmr->state],
           g_shellSwtmrMode[swtmr->mode],
           swtmr->interval,
           swtmr->arg,
           swtmr->handler);
}
 80075a2:	bf00      	nop
 80075a4:	3708      	adds	r7, #8
 80075a6:	46bd      	mov	sp, r7
 80075a8:	bdb0      	pop	{r4, r5, r7, pc}
 80075aa:	bf00      	nop
 80075ac:	20000454 	.word	0x20000454
 80075b0:	20000424 	.word	0x20000424
 80075b4:	08020dd8 	.word	0x08020dd8

080075b8 <OsPrintSwtmrMsgHead>:

STATIC INLINE VOID OsPrintSwtmrMsgHead(VOID)
{
 80075b8:	b580      	push	{r7, lr}
 80075ba:	af00      	add	r7, sp, #0
    PRINTK("\r\nSwTmrID     State    Mode    Interval  Arg         handlerAddr\n");
 80075bc:	4803      	ldr	r0, [pc, #12]	; (80075cc <OsPrintSwtmrMsgHead+0x14>)
 80075be:	f7fd f885 	bl	80046cc <dprintf>
    PRINTK("----------  -------  ------- --------- ----------  --------\n");
 80075c2:	4803      	ldr	r0, [pc, #12]	; (80075d0 <OsPrintSwtmrMsgHead+0x18>)
 80075c4:	f7fd f882 	bl	80046cc <dprintf>
}
 80075c8:	bf00      	nop
 80075ca:	bd80      	pop	{r7, pc}
 80075cc:	08020e00 	.word	0x08020e00
 80075d0:	08020e44 	.word	0x08020e44

080075d4 <OsShellCmdSwtmrInfoGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdSwtmrInfoGet(INT32 argc, const UINT8 **argv)
{
 80075d4:	b580      	push	{r7, lr}
 80075d6:	b088      	sub	sp, #32
 80075d8:	af00      	add	r7, sp, #0
 80075da:	6078      	str	r0, [r7, #4]
 80075dc:	6039      	str	r1, [r7, #0]
 80075de:	4b4e      	ldr	r3, [pc, #312]	; (8007718 <OsShellCmdSwtmrInfoGet+0x144>)
 80075e0:	681b      	ldr	r3, [r3, #0]
 80075e2:	61fb      	str	r3, [r7, #28]
 80075e4:	f04f 0300 	mov.w	r3, #0
#define OS_ALL_SWTMR_MASK 0xffffffff
    LosSwtmrCB *swtmr = g_swtmrCBArray;
 80075e8:	4b4c      	ldr	r3, [pc, #304]	; (800771c <OsShellCmdSwtmrInfoGet+0x148>)
 80075ea:	681b      	ldr	r3, [r3, #0]
 80075ec:	613b      	str	r3, [r7, #16]
    LosSwtmrCB *swtmr1 = g_swtmrCBArray;
 80075ee:	4b4b      	ldr	r3, [pc, #300]	; (800771c <OsShellCmdSwtmrInfoGet+0x148>)
 80075f0:	681b      	ldr	r3, [r3, #0]
 80075f2:	617b      	str	r3, [r7, #20]
    UINT16 index;
    size_t timerId;
    UINT16 num = 0;
 80075f4:	2300      	movs	r3, #0
 80075f6:	817b      	strh	r3, [r7, #10]
    CHAR *endPtr = NULL;
 80075f8:	2300      	movs	r3, #0
 80075fa:	60fb      	str	r3, [r7, #12]

    if (argc > 1) {
 80075fc:	687b      	ldr	r3, [r7, #4]
 80075fe:	2b01      	cmp	r3, #1
 8007600:	dd05      	ble.n	800760e <OsShellCmdSwtmrInfoGet+0x3a>
        PRINTK("\nUsage: swtmr [ID]\n");
 8007602:	4847      	ldr	r0, [pc, #284]	; (8007720 <OsShellCmdSwtmrInfoGet+0x14c>)
 8007604:	f7fd f862 	bl	80046cc <dprintf>
        return OS_ERROR;
 8007608:	f04f 33ff 	mov.w	r3, #4294967295
 800760c:	e078      	b.n	8007700 <OsShellCmdSwtmrInfoGet+0x12c>
    }

    if (argc == 0) {
 800760e:	687b      	ldr	r3, [r7, #4]
 8007610:	2b00      	cmp	r3, #0
 8007612:	d103      	bne.n	800761c <OsShellCmdSwtmrInfoGet+0x48>
        timerId = OS_ALL_SWTMR_MASK;
 8007614:	f04f 33ff 	mov.w	r3, #4294967295
 8007618:	61bb      	str	r3, [r7, #24]
 800761a:	e01b      	b.n	8007654 <OsShellCmdSwtmrInfoGet+0x80>
    } else {
        timerId = strtoul((CHAR *)argv[0], &endPtr, 0);
 800761c:	683b      	ldr	r3, [r7, #0]
 800761e:	681b      	ldr	r3, [r3, #0]
 8007620:	f107 010c 	add.w	r1, r7, #12
 8007624:	2200      	movs	r2, #0
 8007626:	4618      	mov	r0, r3
 8007628:	f007 fab2 	bl	800eb90 <strtoul>
 800762c:	61b8      	str	r0, [r7, #24]
        if ((endPtr == NULL) || (*endPtr != 0) || (timerId > LOSCFG_BASE_CORE_SWTMR_LIMIT)) {
 800762e:	68fb      	ldr	r3, [r7, #12]
 8007630:	2b00      	cmp	r3, #0
 8007632:	d006      	beq.n	8007642 <OsShellCmdSwtmrInfoGet+0x6e>
 8007634:	68fb      	ldr	r3, [r7, #12]
 8007636:	781b      	ldrb	r3, [r3, #0]
 8007638:	2b00      	cmp	r3, #0
 800763a:	d102      	bne.n	8007642 <OsShellCmdSwtmrInfoGet+0x6e>
 800763c:	69bb      	ldr	r3, [r7, #24]
 800763e:	2b10      	cmp	r3, #16
 8007640:	d908      	bls.n	8007654 <OsShellCmdSwtmrInfoGet+0x80>
            PRINTK("\nswtmr ID can't access %s.\n", argv[0]);
 8007642:	683b      	ldr	r3, [r7, #0]
 8007644:	681b      	ldr	r3, [r3, #0]
 8007646:	4619      	mov	r1, r3
 8007648:	4836      	ldr	r0, [pc, #216]	; (8007724 <OsShellCmdSwtmrInfoGet+0x150>)
 800764a:	f7fd f83f 	bl	80046cc <dprintf>
            return OS_ERROR;
 800764e:	f04f 33ff 	mov.w	r3, #4294967295
 8007652:	e055      	b.n	8007700 <OsShellCmdSwtmrInfoGet+0x12c>
        }
    }

    for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr1++) {
 8007654:	2300      	movs	r3, #0
 8007656:	813b      	strh	r3, [r7, #8]
 8007658:	e00c      	b.n	8007674 <OsShellCmdSwtmrInfoGet+0xa0>
        if (swtmr1->state == 0) {
 800765a:	697b      	ldr	r3, [r7, #20]
 800765c:	7b1b      	ldrb	r3, [r3, #12]
 800765e:	2b00      	cmp	r3, #0
 8007660:	d102      	bne.n	8007668 <OsShellCmdSwtmrInfoGet+0x94>
            num = num + 1;
 8007662:	897b      	ldrh	r3, [r7, #10]
 8007664:	3301      	adds	r3, #1
 8007666:	817b      	strh	r3, [r7, #10]
    for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr1++) {
 8007668:	893b      	ldrh	r3, [r7, #8]
 800766a:	3301      	adds	r3, #1
 800766c:	813b      	strh	r3, [r7, #8]
 800766e:	697b      	ldr	r3, [r7, #20]
 8007670:	3324      	adds	r3, #36	; 0x24
 8007672:	617b      	str	r3, [r7, #20]
 8007674:	893b      	ldrh	r3, [r7, #8]
 8007676:	2b0f      	cmp	r3, #15
 8007678:	d9ef      	bls.n	800765a <OsShellCmdSwtmrInfoGet+0x86>
        }
    }

    if (num == LOSCFG_BASE_CORE_SWTMR_LIMIT) {
 800767a:	897b      	ldrh	r3, [r7, #10]
 800767c:	2b10      	cmp	r3, #16
 800767e:	d105      	bne.n	800768c <OsShellCmdSwtmrInfoGet+0xb8>
        PRINTK("\r\nThere is no swtmr was created!\n");
 8007680:	4829      	ldr	r0, [pc, #164]	; (8007728 <OsShellCmdSwtmrInfoGet+0x154>)
 8007682:	f7fd f823 	bl	80046cc <dprintf>
        return OS_ERROR;
 8007686:	f04f 33ff 	mov.w	r3, #4294967295
 800768a:	e039      	b.n	8007700 <OsShellCmdSwtmrInfoGet+0x12c>
    }

    OsPrintSwtmrMsgHead();
 800768c:	f7ff ff94 	bl	80075b8 <OsPrintSwtmrMsgHead>
    if (timerId == OS_ALL_SWTMR_MASK) {
 8007690:	69bb      	ldr	r3, [r7, #24]
 8007692:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007696:	d113      	bne.n	80076c0 <OsShellCmdSwtmrInfoGet+0xec>
        for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
 8007698:	2300      	movs	r3, #0
 800769a:	813b      	strh	r3, [r7, #8]
 800769c:	e00c      	b.n	80076b8 <OsShellCmdSwtmrInfoGet+0xe4>
            if (swtmr->state != 0) {
 800769e:	693b      	ldr	r3, [r7, #16]
 80076a0:	7b1b      	ldrb	r3, [r3, #12]
 80076a2:	2b00      	cmp	r3, #0
 80076a4:	d002      	beq.n	80076ac <OsShellCmdSwtmrInfoGet+0xd8>
                OsPrintSwtmrMsg(swtmr);
 80076a6:	6938      	ldr	r0, [r7, #16]
 80076a8:	f7ff ff52 	bl	8007550 <OsPrintSwtmrMsg>
        for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
 80076ac:	893b      	ldrh	r3, [r7, #8]
 80076ae:	3301      	adds	r3, #1
 80076b0:	813b      	strh	r3, [r7, #8]
 80076b2:	693b      	ldr	r3, [r7, #16]
 80076b4:	3324      	adds	r3, #36	; 0x24
 80076b6:	613b      	str	r3, [r7, #16]
 80076b8:	893b      	ldrh	r3, [r7, #8]
 80076ba:	2b0f      	cmp	r3, #15
 80076bc:	d9ef      	bls.n	800769e <OsShellCmdSwtmrInfoGet+0xca>
 80076be:	e01e      	b.n	80076fe <OsShellCmdSwtmrInfoGet+0x12a>
            }
        }
    } else {
        for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
 80076c0:	2300      	movs	r3, #0
 80076c2:	813b      	strh	r3, [r7, #8]
 80076c4:	e015      	b.n	80076f2 <OsShellCmdSwtmrInfoGet+0x11e>
            if ((timerId == (size_t)(swtmr->timerId % LOSCFG_BASE_CORE_SWTMR_LIMIT)) && (swtmr->state != 0)) {
 80076c6:	693b      	ldr	r3, [r7, #16]
 80076c8:	8a1b      	ldrh	r3, [r3, #16]
 80076ca:	f003 030f 	and.w	r3, r3, #15
 80076ce:	69ba      	ldr	r2, [r7, #24]
 80076d0:	429a      	cmp	r2, r3
 80076d2:	d108      	bne.n	80076e6 <OsShellCmdSwtmrInfoGet+0x112>
 80076d4:	693b      	ldr	r3, [r7, #16]
 80076d6:	7b1b      	ldrb	r3, [r3, #12]
 80076d8:	2b00      	cmp	r3, #0
 80076da:	d004      	beq.n	80076e6 <OsShellCmdSwtmrInfoGet+0x112>
                OsPrintSwtmrMsg(swtmr);
 80076dc:	6938      	ldr	r0, [r7, #16]
 80076de:	f7ff ff37 	bl	8007550 <OsPrintSwtmrMsg>
                return LOS_OK;
 80076e2:	2300      	movs	r3, #0
 80076e4:	e00c      	b.n	8007700 <OsShellCmdSwtmrInfoGet+0x12c>
        for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
 80076e6:	893b      	ldrh	r3, [r7, #8]
 80076e8:	3301      	adds	r3, #1
 80076ea:	813b      	strh	r3, [r7, #8]
 80076ec:	693b      	ldr	r3, [r7, #16]
 80076ee:	3324      	adds	r3, #36	; 0x24
 80076f0:	613b      	str	r3, [r7, #16]
 80076f2:	893b      	ldrh	r3, [r7, #8]
 80076f4:	2b0f      	cmp	r3, #15
 80076f6:	d9e6      	bls.n	80076c6 <OsShellCmdSwtmrInfoGet+0xf2>
            }
        }
        PRINTK("\r\nThe SwTimerID is not exist.\n");
 80076f8:	480c      	ldr	r0, [pc, #48]	; (800772c <OsShellCmdSwtmrInfoGet+0x158>)
 80076fa:	f7fc ffe7 	bl	80046cc <dprintf>
    }
    return LOS_OK;
 80076fe:	2300      	movs	r3, #0
}
 8007700:	4a05      	ldr	r2, [pc, #20]	; (8007718 <OsShellCmdSwtmrInfoGet+0x144>)
 8007702:	6811      	ldr	r1, [r2, #0]
 8007704:	69fa      	ldr	r2, [r7, #28]
 8007706:	4051      	eors	r1, r2
 8007708:	d001      	beq.n	800770e <OsShellCmdSwtmrInfoGet+0x13a>
 800770a:	f7fc fe6d 	bl	80043e8 <__stack_chk_fail>
 800770e:	4618      	mov	r0, r3
 8007710:	3720      	adds	r7, #32
 8007712:	46bd      	mov	sp, r7
 8007714:	bd80      	pop	{r7, pc}
 8007716:	bf00      	nop
 8007718:	08020ef8 	.word	0x08020ef8
 800771c:	20000794 	.word	0x20000794
 8007720:	08020e84 	.word	0x08020e84
 8007724:	08020e98 	.word	0x08020e98
 8007728:	08020eb4 	.word	0x08020eb4
 800772c:	08020ed8 	.word	0x08020ed8

08007730 <LOS_IntLock>:
{
 8007730:	b580      	push	{r7, lr}
 8007732:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8007734:	f7f9 fac8 	bl	8000cc8 <ArchIntLock>
 8007738:	4603      	mov	r3, r0
}
 800773a:	4618      	mov	r0, r3
 800773c:	bd80      	pop	{r7, pc}

0800773e <LOS_IntRestore>:
{
 800773e:	b580      	push	{r7, lr}
 8007740:	b082      	sub	sp, #8
 8007742:	af00      	add	r7, sp, #0
 8007744:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8007746:	6878      	ldr	r0, [r7, #4]
 8007748:	f7f9 fac6 	bl	8000cd8 <ArchIntRestore>
}
 800774c:	bf00      	nop
 800774e:	3708      	adds	r7, #8
 8007750:	46bd      	mov	sp, r7
 8007752:	bd80      	pop	{r7, pc}

08007754 <OsShellCmdTaskCntGet>:
extern "C" {
#endif
#endif /* __cplusplus */

UINT32 OsShellCmdTaskCntGet(VOID)
{
 8007754:	b580      	push	{r7, lr}
 8007756:	b084      	sub	sp, #16
 8007758:	af00      	add	r7, sp, #0
    UINT32 loop;
    UINT32 taskCnt = 0;
 800775a:	2300      	movs	r3, #0
 800775c:	607b      	str	r3, [r7, #4]
    UINT32 intSave;
    LosTaskCB *taskCB = NULL;
 800775e:	2300      	movs	r3, #0
 8007760:	60bb      	str	r3, [r7, #8]

    intSave = LOS_IntLock();
 8007762:	f7ff ffe5 	bl	8007730 <LOS_IntLock>
 8007766:	60f8      	str	r0, [r7, #12]
    for (loop = 0; loop < g_taskMaxNum; loop++) {
 8007768:	2300      	movs	r3, #0
 800776a:	603b      	str	r3, [r7, #0]
 800776c:	e016      	b.n	800779c <OsShellCmdTaskCntGet+0x48>
        taskCB = (LosTaskCB *)g_taskCBArray + loop;
 800776e:	4b12      	ldr	r3, [pc, #72]	; (80077b8 <OsShellCmdTaskCntGet+0x64>)
 8007770:	6819      	ldr	r1, [r3, #0]
 8007772:	683a      	ldr	r2, [r7, #0]
 8007774:	4613      	mov	r3, r2
 8007776:	009b      	lsls	r3, r3, #2
 8007778:	4413      	add	r3, r2
 800777a:	015b      	lsls	r3, r3, #5
 800777c:	440b      	add	r3, r1
 800777e:	60bb      	str	r3, [r7, #8]
        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 8007780:	68bb      	ldr	r3, [r7, #8]
 8007782:	889b      	ldrh	r3, [r3, #4]
 8007784:	f003 0301 	and.w	r3, r3, #1
 8007788:	2b00      	cmp	r3, #0
 800778a:	d103      	bne.n	8007794 <OsShellCmdTaskCntGet+0x40>
            continue;
        }
        taskCnt++;
 800778c:	687b      	ldr	r3, [r7, #4]
 800778e:	3301      	adds	r3, #1
 8007790:	607b      	str	r3, [r7, #4]
 8007792:	e000      	b.n	8007796 <OsShellCmdTaskCntGet+0x42>
            continue;
 8007794:	bf00      	nop
    for (loop = 0; loop < g_taskMaxNum; loop++) {
 8007796:	683b      	ldr	r3, [r7, #0]
 8007798:	3301      	adds	r3, #1
 800779a:	603b      	str	r3, [r7, #0]
 800779c:	4b07      	ldr	r3, [pc, #28]	; (80077bc <OsShellCmdTaskCntGet+0x68>)
 800779e:	681b      	ldr	r3, [r3, #0]
 80077a0:	683a      	ldr	r2, [r7, #0]
 80077a2:	429a      	cmp	r2, r3
 80077a4:	d3e3      	bcc.n	800776e <OsShellCmdTaskCntGet+0x1a>
    }
    LOS_IntRestore(intSave);
 80077a6:	68f8      	ldr	r0, [r7, #12]
 80077a8:	f7ff ffc9 	bl	800773e <LOS_IntRestore>
    return taskCnt;
 80077ac:	687b      	ldr	r3, [r7, #4]
}
 80077ae:	4618      	mov	r0, r3
 80077b0:	3710      	adds	r7, #16
 80077b2:	46bd      	mov	sp, r7
 80077b4:	bd80      	pop	{r7, pc}
 80077b6:	bf00      	nop
 80077b8:	200036c4 	.word	0x200036c4
 80077bc:	200036d8 	.word	0x200036d8

080077c0 <OsShellCmdSemCntGet>:

#ifdef LOSCFG_BASE_IPC_SEM
UINT32 OsShellCmdSemCntGet(VOID)
{
 80077c0:	b580      	push	{r7, lr}
 80077c2:	b084      	sub	sp, #16
 80077c4:	af00      	add	r7, sp, #0
    UINT32 loop;
    UINT32 semCnt = 0;
 80077c6:	2300      	movs	r3, #0
 80077c8:	607b      	str	r3, [r7, #4]
    UINT32 intSave;
    LosSemCB *semNode = NULL;
 80077ca:	2300      	movs	r3, #0
 80077cc:	60bb      	str	r3, [r7, #8]

    intSave = LOS_IntLock();
 80077ce:	f7ff ffaf 	bl	8007730 <LOS_IntLock>
 80077d2:	60f8      	str	r0, [r7, #12]
    for (loop = 0; loop < LOSCFG_BASE_IPC_SEM_LIMIT; loop++) {
 80077d4:	2300      	movs	r3, #0
 80077d6:	603b      	str	r3, [r7, #0]
 80077d8:	e010      	b.n	80077fc <OsShellCmdSemCntGet+0x3c>
        semNode = GET_SEM(loop);
 80077da:	4b0e      	ldr	r3, [pc, #56]	; (8007814 <OsShellCmdSemCntGet+0x54>)
 80077dc:	681a      	ldr	r2, [r3, #0]
 80077de:	683b      	ldr	r3, [r7, #0]
 80077e0:	b29b      	uxth	r3, r3
 80077e2:	011b      	lsls	r3, r3, #4
 80077e4:	4413      	add	r3, r2
 80077e6:	60bb      	str	r3, [r7, #8]
        if (semNode->semStat == LOS_USED) {
 80077e8:	68bb      	ldr	r3, [r7, #8]
 80077ea:	781b      	ldrb	r3, [r3, #0]
 80077ec:	2b01      	cmp	r3, #1
 80077ee:	d102      	bne.n	80077f6 <OsShellCmdSemCntGet+0x36>
            semCnt++;
 80077f0:	687b      	ldr	r3, [r7, #4]
 80077f2:	3301      	adds	r3, #1
 80077f4:	607b      	str	r3, [r7, #4]
    for (loop = 0; loop < LOSCFG_BASE_IPC_SEM_LIMIT; loop++) {
 80077f6:	683b      	ldr	r3, [r7, #0]
 80077f8:	3301      	adds	r3, #1
 80077fa:	603b      	str	r3, [r7, #0]
 80077fc:	683b      	ldr	r3, [r7, #0]
 80077fe:	2b13      	cmp	r3, #19
 8007800:	d9eb      	bls.n	80077da <OsShellCmdSemCntGet+0x1a>
        }
    }
    LOS_IntRestore(intSave);
 8007802:	68f8      	ldr	r0, [r7, #12]
 8007804:	f7ff ff9b 	bl	800773e <LOS_IntRestore>
    return semCnt;
 8007808:	687b      	ldr	r3, [r7, #4]
}
 800780a:	4618      	mov	r0, r3
 800780c:	3710      	adds	r7, #16
 800780e:	46bd      	mov	sp, r7
 8007810:	bd80      	pop	{r7, pc}
 8007812:	bf00      	nop
 8007814:	20000790 	.word	0x20000790

08007818 <OsShellCmdMuxCntGet>:
#endif

#ifdef LOSCFG_BASE_IPC_MUX
UINT32 OsShellCmdMuxCntGet(VOID)
{
 8007818:	b580      	push	{r7, lr}
 800781a:	b084      	sub	sp, #16
 800781c:	af00      	add	r7, sp, #0
    UINT32 loop;
    UINT32 muxCnt = 0;
 800781e:	2300      	movs	r3, #0
 8007820:	607b      	str	r3, [r7, #4]
    UINT32 intSave;
    LosMuxCB *muxNode = NULL;
 8007822:	2300      	movs	r3, #0
 8007824:	60bb      	str	r3, [r7, #8]

    intSave = LOS_IntLock();
 8007826:	f7ff ff83 	bl	8007730 <LOS_IntLock>
 800782a:	60f8      	str	r0, [r7, #12]
    for (loop = 0; loop < LOSCFG_BASE_IPC_MUX_LIMIT; loop++) {
 800782c:	2300      	movs	r3, #0
 800782e:	603b      	str	r3, [r7, #0]
 8007830:	e013      	b.n	800785a <OsShellCmdMuxCntGet+0x42>
        muxNode = GET_MUX(loop);
 8007832:	4b0f      	ldr	r3, [pc, #60]	; (8007870 <OsShellCmdMuxCntGet+0x58>)
 8007834:	6819      	ldr	r1, [r3, #0]
 8007836:	683b      	ldr	r3, [r7, #0]
 8007838:	b29a      	uxth	r2, r3
 800783a:	4613      	mov	r3, r2
 800783c:	009b      	lsls	r3, r3, #2
 800783e:	4413      	add	r3, r2
 8007840:	009b      	lsls	r3, r3, #2
 8007842:	440b      	add	r3, r1
 8007844:	60bb      	str	r3, [r7, #8]
        if (muxNode->muxStat == LOS_USED) {
 8007846:	68bb      	ldr	r3, [r7, #8]
 8007848:	7b9b      	ldrb	r3, [r3, #14]
 800784a:	2b01      	cmp	r3, #1
 800784c:	d102      	bne.n	8007854 <OsShellCmdMuxCntGet+0x3c>
            muxCnt++;
 800784e:	687b      	ldr	r3, [r7, #4]
 8007850:	3301      	adds	r3, #1
 8007852:	607b      	str	r3, [r7, #4]
    for (loop = 0; loop < LOSCFG_BASE_IPC_MUX_LIMIT; loop++) {
 8007854:	683b      	ldr	r3, [r7, #0]
 8007856:	3301      	adds	r3, #1
 8007858:	603b      	str	r3, [r7, #0]
 800785a:	683b      	ldr	r3, [r7, #0]
 800785c:	2b13      	cmp	r3, #19
 800785e:	d9e8      	bls.n	8007832 <OsShellCmdMuxCntGet+0x1a>
        }
    }
    LOS_IntRestore(intSave);
 8007860:	68f8      	ldr	r0, [r7, #12]
 8007862:	f7ff ff6c 	bl	800773e <LOS_IntRestore>
    return muxCnt;
 8007866:	687b      	ldr	r3, [r7, #4]
}
 8007868:	4618      	mov	r0, r3
 800786a:	3710      	adds	r7, #16
 800786c:	46bd      	mov	sp, r7
 800786e:	bd80      	pop	{r7, pc}
 8007870:	200021c8 	.word	0x200021c8

08007874 <OsShellCmdQueueCntGet>:
#endif

#ifdef LOSCFG_BASE_IPC_QUEUE
UINT32 OsShellCmdQueueCntGet(VOID)
{
 8007874:	b580      	push	{r7, lr}
 8007876:	b084      	sub	sp, #16
 8007878:	af00      	add	r7, sp, #0
    UINT32 loop;
    UINT32 queueCnt = 0;
 800787a:	2300      	movs	r3, #0
 800787c:	607b      	str	r3, [r7, #4]
    UINT32 intSave;
    LosQueueCB *queueCB = NULL;
 800787e:	2300      	movs	r3, #0
 8007880:	60bb      	str	r3, [r7, #8]

    intSave = LOS_IntLock();
 8007882:	f7ff ff55 	bl	8007730 <LOS_IntLock>
 8007886:	60f8      	str	r0, [r7, #12]
    queueCB = g_allQueue;
 8007888:	4b0e      	ldr	r3, [pc, #56]	; (80078c4 <OsShellCmdQueueCntGet+0x50>)
 800788a:	681b      	ldr	r3, [r3, #0]
 800788c:	60bb      	str	r3, [r7, #8]
    for (loop = 0; loop < LOSCFG_BASE_IPC_QUEUE_LIMIT; loop++, queueCB++) {
 800788e:	2300      	movs	r3, #0
 8007890:	603b      	str	r3, [r7, #0]
 8007892:	e00c      	b.n	80078ae <OsShellCmdQueueCntGet+0x3a>
        if (queueCB->queueState == LOS_USED) {
 8007894:	68bb      	ldr	r3, [r7, #8]
 8007896:	791b      	ldrb	r3, [r3, #4]
 8007898:	2b01      	cmp	r3, #1
 800789a:	d102      	bne.n	80078a2 <OsShellCmdQueueCntGet+0x2e>
            queueCnt++;
 800789c:	687b      	ldr	r3, [r7, #4]
 800789e:	3301      	adds	r3, #1
 80078a0:	607b      	str	r3, [r7, #4]
    for (loop = 0; loop < LOSCFG_BASE_IPC_QUEUE_LIMIT; loop++, queueCB++) {
 80078a2:	683b      	ldr	r3, [r7, #0]
 80078a4:	3301      	adds	r3, #1
 80078a6:	603b      	str	r3, [r7, #0]
 80078a8:	68bb      	ldr	r3, [r7, #8]
 80078aa:	3330      	adds	r3, #48	; 0x30
 80078ac:	60bb      	str	r3, [r7, #8]
 80078ae:	683b      	ldr	r3, [r7, #0]
 80078b0:	2b09      	cmp	r3, #9
 80078b2:	d9ef      	bls.n	8007894 <OsShellCmdQueueCntGet+0x20>
        }
    }
    LOS_IntRestore(intSave);
 80078b4:	68f8      	ldr	r0, [r7, #12]
 80078b6:	f7ff ff42 	bl	800773e <LOS_IntRestore>
    return queueCnt;
 80078ba:	687b      	ldr	r3, [r7, #4]
}
 80078bc:	4618      	mov	r0, r3
 80078be:	3710      	adds	r7, #16
 80078c0:	46bd      	mov	sp, r7
 80078c2:	bd80      	pop	{r7, pc}
 80078c4:	200021bc 	.word	0x200021bc

080078c8 <OsShellCmdSwtmrCntGet>:
#endif

#ifdef LOSCFG_BASE_CORE_SWTMR
UINT32 OsShellCmdSwtmrCntGet(VOID)
{
 80078c8:	b580      	push	{r7, lr}
 80078ca:	b084      	sub	sp, #16
 80078cc:	af00      	add	r7, sp, #0
    UINT32 loop;
    UINT32 swtmrCnt = 0;
 80078ce:	2300      	movs	r3, #0
 80078d0:	607b      	str	r3, [r7, #4]
    UINT32 intSave;
    LosSwtmrCB *swtmrCB = NULL;
 80078d2:	2300      	movs	r3, #0
 80078d4:	60bb      	str	r3, [r7, #8]

    intSave = LOS_IntLock();
 80078d6:	f7ff ff2b 	bl	8007730 <LOS_IntLock>
 80078da:	60f8      	str	r0, [r7, #12]
    swtmrCB = g_swtmrCBArray;
 80078dc:	4b0e      	ldr	r3, [pc, #56]	; (8007918 <OsShellCmdSwtmrCntGet+0x50>)
 80078de:	681b      	ldr	r3, [r3, #0]
 80078e0:	60bb      	str	r3, [r7, #8]
    for (loop = 0; loop < LOSCFG_BASE_CORE_SWTMR_LIMIT; loop++, swtmrCB++) {
 80078e2:	2300      	movs	r3, #0
 80078e4:	603b      	str	r3, [r7, #0]
 80078e6:	e00c      	b.n	8007902 <OsShellCmdSwtmrCntGet+0x3a>
        if (swtmrCB->state != OS_SWTMR_STATUS_UNUSED) {
 80078e8:	68bb      	ldr	r3, [r7, #8]
 80078ea:	7b1b      	ldrb	r3, [r3, #12]
 80078ec:	2b00      	cmp	r3, #0
 80078ee:	d002      	beq.n	80078f6 <OsShellCmdSwtmrCntGet+0x2e>
            swtmrCnt++;
 80078f0:	687b      	ldr	r3, [r7, #4]
 80078f2:	3301      	adds	r3, #1
 80078f4:	607b      	str	r3, [r7, #4]
    for (loop = 0; loop < LOSCFG_BASE_CORE_SWTMR_LIMIT; loop++, swtmrCB++) {
 80078f6:	683b      	ldr	r3, [r7, #0]
 80078f8:	3301      	adds	r3, #1
 80078fa:	603b      	str	r3, [r7, #0]
 80078fc:	68bb      	ldr	r3, [r7, #8]
 80078fe:	3324      	adds	r3, #36	; 0x24
 8007900:	60bb      	str	r3, [r7, #8]
 8007902:	683b      	ldr	r3, [r7, #0]
 8007904:	2b0f      	cmp	r3, #15
 8007906:	d9ef      	bls.n	80078e8 <OsShellCmdSwtmrCntGet+0x20>
        }
    }
    LOS_IntRestore(intSave);
 8007908:	68f8      	ldr	r0, [r7, #12]
 800790a:	f7ff ff18 	bl	800773e <LOS_IntRestore>
    return swtmrCnt;
 800790e:	687b      	ldr	r3, [r7, #4]
}
 8007910:	4618      	mov	r0, r3
 8007912:	3710      	adds	r7, #16
 8007914:	46bd      	mov	sp, r7
 8007916:	bd80      	pop	{r7, pc}
 8007918:	20000794 	.word	0x20000794

0800791c <OsShellCmdSystemInfoGet>:
#endif

LITE_OS_SEC_TEXT_MINOR VOID OsShellCmdSystemInfoGet(VOID)
{
 800791c:	b580      	push	{r7, lr}
 800791e:	af00      	add	r7, sp, #0
    PRINTK("\n   Module    Used      Total\n");
 8007920:	4817      	ldr	r0, [pc, #92]	; (8007980 <OsShellCmdSystemInfoGet+0x64>)
 8007922:	f7fc fed3 	bl	80046cc <dprintf>
    PRINTK("--------------------------------\n");
 8007926:	4817      	ldr	r0, [pc, #92]	; (8007984 <OsShellCmdSystemInfoGet+0x68>)
 8007928:	f7fc fed0 	bl	80046cc <dprintf>
    PRINTK("   Task      %-10u%-10d\n",
 800792c:	f7ff ff12 	bl	8007754 <OsShellCmdTaskCntGet>
 8007930:	4603      	mov	r3, r0
 8007932:	2210      	movs	r2, #16
 8007934:	4619      	mov	r1, r3
 8007936:	4814      	ldr	r0, [pc, #80]	; (8007988 <OsShellCmdSystemInfoGet+0x6c>)
 8007938:	f7fc fec8 	bl	80046cc <dprintf>
           OsShellCmdTaskCntGet(),
           LOSCFG_BASE_CORE_TSK_LIMIT);
#ifdef LOSCFG_BASE_IPC_SEM
    PRINTK("   Sem       %-10u%-10d\n",
 800793c:	f7ff ff40 	bl	80077c0 <OsShellCmdSemCntGet>
 8007940:	4603      	mov	r3, r0
 8007942:	2214      	movs	r2, #20
 8007944:	4619      	mov	r1, r3
 8007946:	4811      	ldr	r0, [pc, #68]	; (800798c <OsShellCmdSystemInfoGet+0x70>)
 8007948:	f7fc fec0 	bl	80046cc <dprintf>
           OsShellCmdSemCntGet(),
           LOSCFG_BASE_IPC_SEM_LIMIT);
#endif
#ifdef LOSCFG_BASE_IPC_MUX
    PRINTK("   Mutex     %-10u%-10d\n",
 800794c:	f7ff ff64 	bl	8007818 <OsShellCmdMuxCntGet>
 8007950:	4603      	mov	r3, r0
 8007952:	2214      	movs	r2, #20
 8007954:	4619      	mov	r1, r3
 8007956:	480e      	ldr	r0, [pc, #56]	; (8007990 <OsShellCmdSystemInfoGet+0x74>)
 8007958:	f7fc feb8 	bl	80046cc <dprintf>
           OsShellCmdMuxCntGet(),
           LOSCFG_BASE_IPC_MUX_LIMIT);
#endif
#ifdef LOSCFG_BASE_IPC_QUEUE
    PRINTK("   Queue     %-10u%-10d\n",
 800795c:	f7ff ff8a 	bl	8007874 <OsShellCmdQueueCntGet>
 8007960:	4603      	mov	r3, r0
 8007962:	220a      	movs	r2, #10
 8007964:	4619      	mov	r1, r3
 8007966:	480b      	ldr	r0, [pc, #44]	; (8007994 <OsShellCmdSystemInfoGet+0x78>)
 8007968:	f7fc feb0 	bl	80046cc <dprintf>
           OsShellCmdQueueCntGet(),
           LOSCFG_BASE_IPC_QUEUE_LIMIT);
#endif
#ifdef LOSCFG_BASE_CORE_SWTMR
    PRINTK("   SwTmr     %-10u%-10d\n",
 800796c:	f7ff ffac 	bl	80078c8 <OsShellCmdSwtmrCntGet>
 8007970:	4603      	mov	r3, r0
 8007972:	2210      	movs	r2, #16
 8007974:	4619      	mov	r1, r3
 8007976:	4808      	ldr	r0, [pc, #32]	; (8007998 <OsShellCmdSystemInfoGet+0x7c>)
 8007978:	f7fc fea8 	bl	80046cc <dprintf>
           OsShellCmdSwtmrCntGet(),
           LOSCFG_BASE_CORE_SWTMR_LIMIT);
#endif
}
 800797c:	bf00      	nop
 800797e:	bd80      	pop	{r7, pc}
 8007980:	08020f04 	.word	0x08020f04
 8007984:	08020f24 	.word	0x08020f24
 8007988:	08020f48 	.word	0x08020f48
 800798c:	08020f64 	.word	0x08020f64
 8007990:	08020f80 	.word	0x08020f80
 8007994:	08020f9c 	.word	0x08020f9c
 8007998:	08020fb8 	.word	0x08020fb8

0800799c <OsShellCmdSystemInfo>:

INT32 OsShellCmdSystemInfo(INT32 argc, const CHAR **argv)
{
 800799c:	b580      	push	{r7, lr}
 800799e:	b082      	sub	sp, #8
 80079a0:	af00      	add	r7, sp, #0
 80079a2:	6078      	str	r0, [r7, #4]
 80079a4:	6039      	str	r1, [r7, #0]
    if (argc == 0) {
 80079a6:	687b      	ldr	r3, [r7, #4]
 80079a8:	2b00      	cmp	r3, #0
 80079aa:	d103      	bne.n	80079b4 <OsShellCmdSystemInfo+0x18>
        OsShellCmdSystemInfoGet();
 80079ac:	f7ff ffb6 	bl	800791c <OsShellCmdSystemInfoGet>
        return 0;
 80079b0:	2300      	movs	r3, #0
 80079b2:	e007      	b.n	80079c4 <OsShellCmdSystemInfo+0x28>
    }
    PRINTK("systeminfo: invalid option %s\n"
 80079b4:	683b      	ldr	r3, [r7, #0]
 80079b6:	681b      	ldr	r3, [r3, #0]
 80079b8:	4619      	mov	r1, r3
 80079ba:	4804      	ldr	r0, [pc, #16]	; (80079cc <OsShellCmdSystemInfo+0x30>)
 80079bc:	f7fc fe86 	bl	80046cc <dprintf>
           "Systeminfo has NO ARGS.\n",
           argv[0]);
    return -1;
 80079c0:	f04f 33ff 	mov.w	r3, #4294967295
}
 80079c4:	4618      	mov	r0, r3
 80079c6:	3708      	adds	r7, #8
 80079c8:	46bd      	mov	sp, r7
 80079ca:	bd80      	pop	{r7, pc}
 80079cc:	08020fd4 	.word	0x08020fd4

080079d0 <LOS_IntLock>:
{
 80079d0:	b580      	push	{r7, lr}
 80079d2:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80079d4:	f7f9 f978 	bl	8000cc8 <ArchIntLock>
 80079d8:	4603      	mov	r3, r0
}
 80079da:	4618      	mov	r0, r3
 80079dc:	bd80      	pop	{r7, pc}

080079de <LOS_IntRestore>:
{
 80079de:	b580      	push	{r7, lr}
 80079e0:	b082      	sub	sp, #8
 80079e2:	af00      	add	r7, sp, #0
 80079e4:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80079e6:	6878      	ldr	r0, [r7, #4]
 80079e8:	f7f9 f976 	bl	8000cd8 <ArchIntRestore>
}
 80079ec:	bf00      	nop
 80079ee:	3708      	adds	r7, #8
 80079f0:	46bd      	mov	sp, r7
 80079f2:	bd80      	pop	{r7, pc}

080079f4 <LOS_SpinLockSave>:
{
 80079f4:	b580      	push	{r7, lr}
 80079f6:	b082      	sub	sp, #8
 80079f8:	af00      	add	r7, sp, #0
 80079fa:	6078      	str	r0, [r7, #4]
 80079fc:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 80079fe:	f7ff ffe7 	bl	80079d0 <LOS_IntLock>
 8007a02:	4602      	mov	r2, r0
 8007a04:	683b      	ldr	r3, [r7, #0]
 8007a06:	601a      	str	r2, [r3, #0]
}
 8007a08:	bf00      	nop
 8007a0a:	3708      	adds	r7, #8
 8007a0c:	46bd      	mov	sp, r7
 8007a0e:	bd80      	pop	{r7, pc}

08007a10 <LOS_SpinUnlockRestore>:
{
 8007a10:	b580      	push	{r7, lr}
 8007a12:	b082      	sub	sp, #8
 8007a14:	af00      	add	r7, sp, #0
 8007a16:	6078      	str	r0, [r7, #4]
 8007a18:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8007a1a:	6838      	ldr	r0, [r7, #0]
 8007a1c:	f7ff ffdf 	bl	80079de <LOS_IntRestore>
}
 8007a20:	bf00      	nop
 8007a22:	3708      	adds	r7, #8
 8007a24:	46bd      	mov	sp, r7
 8007a26:	bd80      	pop	{r7, pc}

08007a28 <LOS_SpinHeld>:
{
 8007a28:	b480      	push	{r7}
 8007a2a:	b083      	sub	sp, #12
 8007a2c:	af00      	add	r7, sp, #0
 8007a2e:	6078      	str	r0, [r7, #4]
    return TRUE;
 8007a30:	2301      	movs	r3, #1
}
 8007a32:	4618      	mov	r0, r3
 8007a34:	370c      	adds	r7, #12
 8007a36:	46bd      	mov	sp, r7
 8007a38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a3c:	4770      	bx	lr
	...

08007a40 <OsShellCmdConvertTskStatus>:
#endif

LITE_OS_SEC_BSS STATIC UINT32 g_taskWaterLine[LOSCFG_BASE_CORE_TSK_LIMIT];

LITE_OS_SEC_TEXT_MINOR UINT8 *OsShellCmdConvertTskStatus(UINT16 taskStatus)
{
 8007a40:	b480      	push	{r7}
 8007a42:	b083      	sub	sp, #12
 8007a44:	af00      	add	r7, sp, #0
 8007a46:	4603      	mov	r3, r0
 8007a48:	80fb      	strh	r3, [r7, #6]
    if (taskStatus & OS_TASK_STATUS_RUNNING) {
 8007a4a:	88fb      	ldrh	r3, [r7, #6]
 8007a4c:	f003 0310 	and.w	r3, r3, #16
 8007a50:	2b00      	cmp	r3, #0
 8007a52:	d001      	beq.n	8007a58 <OsShellCmdConvertTskStatus+0x18>
        return (UINT8 *)"Running";
 8007a54:	4b1b      	ldr	r3, [pc, #108]	; (8007ac4 <OsShellCmdConvertTskStatus+0x84>)
 8007a56:	e02f      	b.n	8007ab8 <OsShellCmdConvertTskStatus+0x78>
    } else if (taskStatus & OS_TASK_STATUS_READY) {
 8007a58:	88fb      	ldrh	r3, [r7, #6]
 8007a5a:	f003 0304 	and.w	r3, r3, #4
 8007a5e:	2b00      	cmp	r3, #0
 8007a60:	d001      	beq.n	8007a66 <OsShellCmdConvertTskStatus+0x26>
        return (UINT8 *)"Ready";
 8007a62:	4b19      	ldr	r3, [pc, #100]	; (8007ac8 <OsShellCmdConvertTskStatus+0x88>)
 8007a64:	e028      	b.n	8007ab8 <OsShellCmdConvertTskStatus+0x78>
    } else {
        if (taskStatus & OS_TASK_STATUS_DELAY) {
 8007a66:	88fb      	ldrh	r3, [r7, #6]
 8007a68:	f003 0320 	and.w	r3, r3, #32
 8007a6c:	2b00      	cmp	r3, #0
 8007a6e:	d001      	beq.n	8007a74 <OsShellCmdConvertTskStatus+0x34>
            return (UINT8 *)"Delay";
 8007a70:	4b16      	ldr	r3, [pc, #88]	; (8007acc <OsShellCmdConvertTskStatus+0x8c>)
 8007a72:	e021      	b.n	8007ab8 <OsShellCmdConvertTskStatus+0x78>
        } else if (taskStatus & OS_TASK_STATUS_PEND_TIME) {
 8007a74:	88fb      	ldrh	r3, [r7, #6]
 8007a76:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8007a7a:	2b00      	cmp	r3, #0
 8007a7c:	d00d      	beq.n	8007a9a <OsShellCmdConvertTskStatus+0x5a>
            if (taskStatus & OS_TASK_STATUS_SUSPEND) {
 8007a7e:	88fb      	ldrh	r3, [r7, #6]
 8007a80:	f003 0302 	and.w	r3, r3, #2
 8007a84:	2b00      	cmp	r3, #0
 8007a86:	d001      	beq.n	8007a8c <OsShellCmdConvertTskStatus+0x4c>
                return (UINT8 *)"SuspendTime";
 8007a88:	4b11      	ldr	r3, [pc, #68]	; (8007ad0 <OsShellCmdConvertTskStatus+0x90>)
 8007a8a:	e015      	b.n	8007ab8 <OsShellCmdConvertTskStatus+0x78>
            } else if (taskStatus & OS_TASK_STATUS_PEND) {
 8007a8c:	88fb      	ldrh	r3, [r7, #6]
 8007a8e:	f003 0308 	and.w	r3, r3, #8
 8007a92:	2b00      	cmp	r3, #0
 8007a94:	d00f      	beq.n	8007ab6 <OsShellCmdConvertTskStatus+0x76>
                return (UINT8 *)"PendTime";
 8007a96:	4b0f      	ldr	r3, [pc, #60]	; (8007ad4 <OsShellCmdConvertTskStatus+0x94>)
 8007a98:	e00e      	b.n	8007ab8 <OsShellCmdConvertTskStatus+0x78>
            }
        } else if (taskStatus & OS_TASK_STATUS_PEND) {
 8007a9a:	88fb      	ldrh	r3, [r7, #6]
 8007a9c:	f003 0308 	and.w	r3, r3, #8
 8007aa0:	2b00      	cmp	r3, #0
 8007aa2:	d001      	beq.n	8007aa8 <OsShellCmdConvertTskStatus+0x68>
            return (UINT8 *)"Pend";
 8007aa4:	4b0c      	ldr	r3, [pc, #48]	; (8007ad8 <OsShellCmdConvertTskStatus+0x98>)
 8007aa6:	e007      	b.n	8007ab8 <OsShellCmdConvertTskStatus+0x78>
        } else if (taskStatus & OS_TASK_STATUS_SUSPEND) {
 8007aa8:	88fb      	ldrh	r3, [r7, #6]
 8007aaa:	f003 0302 	and.w	r3, r3, #2
 8007aae:	2b00      	cmp	r3, #0
 8007ab0:	d001      	beq.n	8007ab6 <OsShellCmdConvertTskStatus+0x76>
            return (UINT8 *)"Suspend";
 8007ab2:	4b0a      	ldr	r3, [pc, #40]	; (8007adc <OsShellCmdConvertTskStatus+0x9c>)
 8007ab4:	e000      	b.n	8007ab8 <OsShellCmdConvertTskStatus+0x78>
        }
    }

    return (UINT8 *)"Invalid";
 8007ab6:	4b0a      	ldr	r3, [pc, #40]	; (8007ae0 <OsShellCmdConvertTskStatus+0xa0>)
}
 8007ab8:	4618      	mov	r0, r3
 8007aba:	370c      	adds	r7, #12
 8007abc:	46bd      	mov	sp, r7
 8007abe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ac2:	4770      	bx	lr
 8007ac4:	08021018 	.word	0x08021018
 8007ac8:	08021020 	.word	0x08021020
 8007acc:	08021028 	.word	0x08021028
 8007ad0:	08021030 	.word	0x08021030
 8007ad4:	0802103c 	.word	0x0802103c
 8007ad8:	08021048 	.word	0x08021048
 8007adc:	08021050 	.word	0x08021050
 8007ae0:	08021058 	.word	0x08021058

08007ae4 <OsShellCmdTaskWaterLineGet>:

STATIC VOID OsShellCmdTaskWaterLineGet(const LosTaskCB *allTaskArray)
{
 8007ae4:	b580      	push	{r7, lr}
 8007ae6:	b084      	sub	sp, #16
 8007ae8:	af00      	add	r7, sp, #0
 8007aea:	6078      	str	r0, [r7, #4]
    const LosTaskCB *taskCB = NULL;
 8007aec:	2300      	movs	r3, #0
 8007aee:	60fb      	str	r3, [r7, #12]
    UINT32 loop;

    for (loop = 0; loop < g_taskMaxNum; ++loop) {
 8007af0:	2300      	movs	r3, #0
 8007af2:	60bb      	str	r3, [r7, #8]
 8007af4:	e024      	b.n	8007b40 <OsShellCmdTaskWaterLineGet+0x5c>
        taskCB = allTaskArray + loop;
 8007af6:	68ba      	ldr	r2, [r7, #8]
 8007af8:	4613      	mov	r3, r2
 8007afa:	009b      	lsls	r3, r3, #2
 8007afc:	4413      	add	r3, r2
 8007afe:	015b      	lsls	r3, r3, #5
 8007b00:	461a      	mov	r2, r3
 8007b02:	687b      	ldr	r3, [r7, #4]
 8007b04:	4413      	add	r3, r2
 8007b06:	60fb      	str	r3, [r7, #12]
        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 8007b08:	68fb      	ldr	r3, [r7, #12]
 8007b0a:	889b      	ldrh	r3, [r3, #4]
 8007b0c:	f003 0301 	and.w	r3, r3, #1
 8007b10:	2b00      	cmp	r3, #0
 8007b12:	d111      	bne.n	8007b38 <OsShellCmdTaskWaterLineGet+0x54>
            continue;
        }

        (VOID)OsStackWaterLineGet((const UINTPTR *)((UINTPTR)taskCB->topOfStack + taskCB->stackSize),
 8007b14:	68fb      	ldr	r3, [r7, #12]
 8007b16:	691a      	ldr	r2, [r3, #16]
 8007b18:	68fb      	ldr	r3, [r7, #12]
 8007b1a:	68db      	ldr	r3, [r3, #12]
 8007b1c:	4413      	add	r3, r2
 8007b1e:	4618      	mov	r0, r3
                                  (const UINTPTR *)taskCB->topOfStack, &g_taskWaterLine[taskCB->taskId]);
 8007b20:	68fb      	ldr	r3, [r7, #12]
 8007b22:	691b      	ldr	r3, [r3, #16]
        (VOID)OsStackWaterLineGet((const UINTPTR *)((UINTPTR)taskCB->topOfStack + taskCB->stackSize),
 8007b24:	4619      	mov	r1, r3
                                  (const UINTPTR *)taskCB->topOfStack, &g_taskWaterLine[taskCB->taskId]);
 8007b26:	68fb      	ldr	r3, [r7, #12]
 8007b28:	695b      	ldr	r3, [r3, #20]
        (VOID)OsStackWaterLineGet((const UINTPTR *)((UINTPTR)taskCB->topOfStack + taskCB->stackSize),
 8007b2a:	009b      	lsls	r3, r3, #2
 8007b2c:	4a09      	ldr	r2, [pc, #36]	; (8007b54 <OsShellCmdTaskWaterLineGet+0x70>)
 8007b2e:	4413      	add	r3, r2
 8007b30:	461a      	mov	r2, r3
 8007b32:	f001 ffb0 	bl	8009a96 <OsStackWaterLineGet>
 8007b36:	e000      	b.n	8007b3a <OsShellCmdTaskWaterLineGet+0x56>
            continue;
 8007b38:	bf00      	nop
    for (loop = 0; loop < g_taskMaxNum; ++loop) {
 8007b3a:	68bb      	ldr	r3, [r7, #8]
 8007b3c:	3301      	adds	r3, #1
 8007b3e:	60bb      	str	r3, [r7, #8]
 8007b40:	4b05      	ldr	r3, [pc, #20]	; (8007b58 <OsShellCmdTaskWaterLineGet+0x74>)
 8007b42:	681b      	ldr	r3, [r3, #0]
 8007b44:	68ba      	ldr	r2, [r7, #8]
 8007b46:	429a      	cmp	r2, r3
 8007b48:	d3d5      	bcc.n	8007af6 <OsShellCmdTaskWaterLineGet+0x12>
    }
}
 8007b4a:	bf00      	nop
 8007b4c:	bf00      	nop
 8007b4e:	3710      	adds	r7, #16
 8007b50:	46bd      	mov	sp, r7
 8007b52:	bd80      	pop	{r7, pc}
 8007b54:	20002168 	.word	0x20002168
 8007b58:	200036d8 	.word	0x200036d8

08007b5c <OsShellCmdTskInfoTitle>:
    WriteExcInfoToBuf("\n");
}
#endif

LITE_OS_SEC_TEXT_MINOR STATIC VOID OsShellCmdTskInfoTitle(VOID)
{
 8007b5c:	b580      	push	{r7, lr}
 8007b5e:	af00      	add	r7, sp, #0
    PRINTK("\r\nName                   TaskEntryAddr       TID    ");
 8007b60:	480f      	ldr	r0, [pc, #60]	; (8007ba0 <OsShellCmdTskInfoTitle+0x44>)
 8007b62:	f7fc fdb3 	bl	80046cc <dprintf>
#ifdef LOSCFG_KERNEL_SMP
    PRINTK("Affi    CPU    ");
#endif
    PRINTK("Priority   Status       "
 8007b66:	480f      	ldr	r0, [pc, #60]	; (8007ba4 <OsShellCmdTskInfoTitle+0x48>)
 8007b68:	f7fc fdb0 	bl	80046cc <dprintf>
           "StackSize    WaterLine      StackPoint   TopOfStack   SemID        EventMask");

#ifdef LOSCFG_KERNEL_CPUP
    PRINTK("  CPUUSE  CPUUSE10s  CPUUSE1s  ");
 8007b6c:	480e      	ldr	r0, [pc, #56]	; (8007ba8 <OsShellCmdTskInfoTitle+0x4c>)
 8007b6e:	f7fc fdad 	bl	80046cc <dprintf>
#endif /* LOSCFG_KERNEL_CPUP */
#ifdef LOSCFG_MEM_TASK_STAT
    PRINTK("   MEMUSE");
 8007b72:	480e      	ldr	r0, [pc, #56]	; (8007bac <OsShellCmdTskInfoTitle+0x50>)
 8007b74:	f7fc fdaa 	bl	80046cc <dprintf>
#endif
    PRINTK("\n");
 8007b78:	480d      	ldr	r0, [pc, #52]	; (8007bb0 <OsShellCmdTskInfoTitle+0x54>)
 8007b7a:	f7fc fda7 	bl	80046cc <dprintf>
    PRINTK("----                   -------------       ---    ");
 8007b7e:	480d      	ldr	r0, [pc, #52]	; (8007bb4 <OsShellCmdTskInfoTitle+0x58>)
 8007b80:	f7fc fda4 	bl	80046cc <dprintf>
#ifdef LOSCFG_KERNEL_SMP
    PRINTK("-----   ----   ");
#endif
    PRINTK("--------   --------     "
 8007b84:	480c      	ldr	r0, [pc, #48]	; (8007bb8 <OsShellCmdTskInfoTitle+0x5c>)
 8007b86:	f7fc fda1 	bl	80046cc <dprintf>
           "---------    ----------     ----------   ----------   ----------   ---------");
#ifdef LOSCFG_KERNEL_CPUP
    PRINTK("  ------  ---------  --------  ");
 8007b8a:	480c      	ldr	r0, [pc, #48]	; (8007bbc <OsShellCmdTskInfoTitle+0x60>)
 8007b8c:	f7fc fd9e 	bl	80046cc <dprintf>
#endif /* LOSCFG_KERNEL_CPUP */
#ifdef LOSCFG_MEM_TASK_STAT
    PRINTK("   ------");
 8007b90:	480b      	ldr	r0, [pc, #44]	; (8007bc0 <OsShellCmdTskInfoTitle+0x64>)
 8007b92:	f7fc fd9b 	bl	80046cc <dprintf>
#endif
    PRINTK("\n");
 8007b96:	4806      	ldr	r0, [pc, #24]	; (8007bb0 <OsShellCmdTskInfoTitle+0x54>)
 8007b98:	f7fc fd98 	bl	80046cc <dprintf>

#ifdef LOSCFG_SHELL_EXCINFO_DUMP
    OsShellCmdTskInfoTitleExc();
#endif
}
 8007b9c:	bf00      	nop
 8007b9e:	bd80      	pop	{r7, pc}
 8007ba0:	08021060 	.word	0x08021060
 8007ba4:	08021098 	.word	0x08021098
 8007ba8:	08021100 	.word	0x08021100
 8007bac:	08021120 	.word	0x08021120
 8007bb0:	0802112c 	.word	0x0802112c
 8007bb4:	08021130 	.word	0x08021130
 8007bb8:	08021164 	.word	0x08021164
 8007bbc:	080211cc 	.word	0x080211cc
 8007bc0:	080211ec 	.word	0x080211ec

08007bc4 <OsGetSemID>:

LITE_OS_SEC_TEXT_MINOR STATIC INLINE UINT32 OsGetSemID(const LosTaskCB *taskCB)
{
 8007bc4:	b480      	push	{r7}
 8007bc6:	b085      	sub	sp, #20
 8007bc8:	af00      	add	r7, sp, #0
 8007bca:	6078      	str	r0, [r7, #4]
    UINT32 semId = OS_INVALID_SEM_ID;
 8007bcc:	f04f 33ff 	mov.w	r3, #4294967295
 8007bd0:	60fb      	str	r3, [r7, #12]

    if (taskCB->taskSem != NULL) {
 8007bd2:	687b      	ldr	r3, [r7, #4]
 8007bd4:	69db      	ldr	r3, [r3, #28]
 8007bd6:	2b00      	cmp	r3, #0
 8007bd8:	d003      	beq.n	8007be2 <OsGetSemID+0x1e>
        semId = ((LosSemCB *)taskCB->taskSem)->semId;
 8007bda:	687b      	ldr	r3, [r7, #4]
 8007bdc:	69db      	ldr	r3, [r3, #28]
 8007bde:	685b      	ldr	r3, [r3, #4]
 8007be0:	60fb      	str	r3, [r7, #12]
    }

    return semId;
 8007be2:	68fb      	ldr	r3, [r7, #12]
}
 8007be4:	4618      	mov	r0, r3
 8007be6:	3714      	adds	r7, #20
 8007be8:	46bd      	mov	sp, r7
 8007bea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007bee:	4770      	bx	lr

08007bf0 <OsShellCmdTskInfoData>:
    }
}
#endif

LITE_OS_SEC_TEXT_MINOR STATIC VOID OsShellCmdTskInfoData(const LosTaskCB *allTaskArray)
{
 8007bf0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007bf2:	b08b      	sub	sp, #44	; 0x2c
 8007bf4:	af04      	add	r7, sp, #16
 8007bf6:	6078      	str	r0, [r7, #4]
    const LosTaskCB *taskCB = NULL;
 8007bf8:	2300      	movs	r3, #0
 8007bfa:	613b      	str	r3, [r7, #16]
    UINT32 loop;
    UINT32 semId;

    for (loop = 0; loop < g_taskMaxNum; ++loop) {
 8007bfc:	2300      	movs	r3, #0
 8007bfe:	60fb      	str	r3, [r7, #12]
 8007c00:	e0a8      	b.n	8007d54 <OsShellCmdTskInfoData+0x164>
        taskCB = allTaskArray + loop;
 8007c02:	68fa      	ldr	r2, [r7, #12]
 8007c04:	4613      	mov	r3, r2
 8007c06:	009b      	lsls	r3, r3, #2
 8007c08:	4413      	add	r3, r2
 8007c0a:	015b      	lsls	r3, r3, #5
 8007c0c:	461a      	mov	r2, r3
 8007c0e:	687b      	ldr	r3, [r7, #4]
 8007c10:	4413      	add	r3, r2
 8007c12:	613b      	str	r3, [r7, #16]
        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 8007c14:	693b      	ldr	r3, [r7, #16]
 8007c16:	889b      	ldrh	r3, [r3, #4]
 8007c18:	f003 0301 	and.w	r3, r3, #1
 8007c1c:	2b00      	cmp	r3, #0
 8007c1e:	f040 8095 	bne.w	8007d4c <OsShellCmdTskInfoData+0x15c>
            continue;
        }

        semId = OsGetSemID(taskCB);
 8007c22:	6938      	ldr	r0, [r7, #16]
 8007c24:	f7ff ffce 	bl	8007bc4 <OsGetSemID>
 8007c28:	6178      	str	r0, [r7, #20]

        PRINTK("%-23s0x%-18.8x0x%-5x", taskCB->taskName, taskCB->taskEntry, taskCB->taskId);
 8007c2a:	693b      	ldr	r3, [r7, #16]
 8007c2c:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8007c2e:	693b      	ldr	r3, [r7, #16]
 8007c30:	699a      	ldr	r2, [r3, #24]
 8007c32:	693b      	ldr	r3, [r7, #16]
 8007c34:	695b      	ldr	r3, [r3, #20]
 8007c36:	484d      	ldr	r0, [pc, #308]	; (8007d6c <OsShellCmdTskInfoData+0x17c>)
 8007c38:	f7fc fd48 	bl	80046cc <dprintf>

#ifdef LOSCFG_KERNEL_SMP
        PRINTK("0x%04x  %4d   ", taskCB->cpuAffiMask, (INT16)(taskCB->currCpu));
#endif
        PRINTK("%-11u%-13s0x%-11x0x%-11x  0x%-.8x   0x%-.8x   0x%-11x", taskCB->priority,
 8007c3c:	693b      	ldr	r3, [r7, #16]
 8007c3e:	88db      	ldrh	r3, [r3, #6]
 8007c40:	461e      	mov	r6, r3
 8007c42:	693b      	ldr	r3, [r7, #16]
 8007c44:	889b      	ldrh	r3, [r3, #4]
 8007c46:	4618      	mov	r0, r3
 8007c48:	f7ff fefa 	bl	8007a40 <OsShellCmdConvertTskStatus>
 8007c4c:	4605      	mov	r5, r0
 8007c4e:	693b      	ldr	r3, [r7, #16]
 8007c50:	68dc      	ldr	r4, [r3, #12]
 8007c52:	693b      	ldr	r3, [r7, #16]
 8007c54:	695b      	ldr	r3, [r3, #20]
 8007c56:	4a46      	ldr	r2, [pc, #280]	; (8007d70 <OsShellCmdTskInfoData+0x180>)
 8007c58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8007c5c:	693a      	ldr	r2, [r7, #16]
 8007c5e:	6812      	ldr	r2, [r2, #0]
 8007c60:	6939      	ldr	r1, [r7, #16]
 8007c62:	6909      	ldr	r1, [r1, #16]
 8007c64:	6978      	ldr	r0, [r7, #20]
 8007c66:	9003      	str	r0, [sp, #12]
 8007c68:	9102      	str	r1, [sp, #8]
 8007c6a:	9201      	str	r2, [sp, #4]
 8007c6c:	9300      	str	r3, [sp, #0]
 8007c6e:	4623      	mov	r3, r4
 8007c70:	462a      	mov	r2, r5
 8007c72:	4631      	mov	r1, r6
 8007c74:	483f      	ldr	r0, [pc, #252]	; (8007d74 <OsShellCmdTskInfoData+0x184>)
 8007c76:	f7fc fd29 	bl	80046cc <dprintf>
               OsShellCmdConvertTskStatus(taskCB->taskStatus), taskCB->stackSize,
               g_taskWaterLine[taskCB->taskId],
               taskCB->stackPointer, taskCB->topOfStack, semId);
#ifdef LOSCFG_BASE_IPC_EVENT
        PRINTK("0x%-6x", taskCB->eventMask);
 8007c7a:	693b      	ldr	r3, [r7, #16]
 8007c7c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8007c7e:	4619      	mov	r1, r3
 8007c80:	483d      	ldr	r0, [pc, #244]	; (8007d78 <OsShellCmdTskInfoData+0x188>)
 8007c82:	f7fc fd23 	bl	80046cc <dprintf>
#endif

#ifdef LOSCFG_KERNEL_CPUP
        PRINTK(" %4u.%1u%9u.%1u%8u.%1u   ",
 8007c86:	693b      	ldr	r3, [r7, #16]
 8007c88:	695b      	ldr	r3, [r3, #20]
 8007c8a:	4a3c      	ldr	r2, [pc, #240]	; (8007d7c <OsShellCmdTskInfoData+0x18c>)
 8007c8c:	00db      	lsls	r3, r3, #3
 8007c8e:	4413      	add	r3, r2
 8007c90:	685b      	ldr	r3, [r3, #4]
 8007c92:	4a3b      	ldr	r2, [pc, #236]	; (8007d80 <OsShellCmdTskInfoData+0x190>)
 8007c94:	fba2 2303 	umull	r2, r3, r2, r3
 8007c98:	08de      	lsrs	r6, r3, #3
 8007c9a:	693b      	ldr	r3, [r7, #16]
 8007c9c:	695b      	ldr	r3, [r3, #20]
 8007c9e:	4a37      	ldr	r2, [pc, #220]	; (8007d7c <OsShellCmdTskInfoData+0x18c>)
 8007ca0:	00db      	lsls	r3, r3, #3
 8007ca2:	4413      	add	r3, r2
 8007ca4:	685a      	ldr	r2, [r3, #4]
 8007ca6:	4b36      	ldr	r3, [pc, #216]	; (8007d80 <OsShellCmdTskInfoData+0x190>)
 8007ca8:	fba3 1302 	umull	r1, r3, r3, r2
 8007cac:	08d8      	lsrs	r0, r3, #3
 8007cae:	4603      	mov	r3, r0
 8007cb0:	009b      	lsls	r3, r3, #2
 8007cb2:	4403      	add	r3, r0
 8007cb4:	005b      	lsls	r3, r3, #1
 8007cb6:	1ad0      	subs	r0, r2, r3
 8007cb8:	693b      	ldr	r3, [r7, #16]
 8007cba:	695b      	ldr	r3, [r3, #20]
 8007cbc:	4a31      	ldr	r2, [pc, #196]	; (8007d84 <OsShellCmdTskInfoData+0x194>)
 8007cbe:	00db      	lsls	r3, r3, #3
 8007cc0:	4413      	add	r3, r2
 8007cc2:	685b      	ldr	r3, [r3, #4]
 8007cc4:	4a2e      	ldr	r2, [pc, #184]	; (8007d80 <OsShellCmdTskInfoData+0x190>)
 8007cc6:	fba2 2303 	umull	r2, r3, r2, r3
 8007cca:	ea4f 0cd3 	mov.w	ip, r3, lsr #3
 8007cce:	693b      	ldr	r3, [r7, #16]
 8007cd0:	695b      	ldr	r3, [r3, #20]
 8007cd2:	4a2c      	ldr	r2, [pc, #176]	; (8007d84 <OsShellCmdTskInfoData+0x194>)
 8007cd4:	00db      	lsls	r3, r3, #3
 8007cd6:	4413      	add	r3, r2
 8007cd8:	6859      	ldr	r1, [r3, #4]
 8007cda:	4b29      	ldr	r3, [pc, #164]	; (8007d80 <OsShellCmdTskInfoData+0x190>)
 8007cdc:	fba3 2301 	umull	r2, r3, r3, r1
 8007ce0:	08da      	lsrs	r2, r3, #3
 8007ce2:	4613      	mov	r3, r2
 8007ce4:	009b      	lsls	r3, r3, #2
 8007ce6:	4413      	add	r3, r2
 8007ce8:	005b      	lsls	r3, r3, #1
 8007cea:	1aca      	subs	r2, r1, r3
 8007cec:	693b      	ldr	r3, [r7, #16]
 8007cee:	695b      	ldr	r3, [r3, #20]
 8007cf0:	4925      	ldr	r1, [pc, #148]	; (8007d88 <OsShellCmdTskInfoData+0x198>)
 8007cf2:	00db      	lsls	r3, r3, #3
 8007cf4:	440b      	add	r3, r1
 8007cf6:	685b      	ldr	r3, [r3, #4]
 8007cf8:	4921      	ldr	r1, [pc, #132]	; (8007d80 <OsShellCmdTskInfoData+0x190>)
 8007cfa:	fba1 1303 	umull	r1, r3, r1, r3
 8007cfe:	08dd      	lsrs	r5, r3, #3
 8007d00:	693b      	ldr	r3, [r7, #16]
 8007d02:	695b      	ldr	r3, [r3, #20]
 8007d04:	4920      	ldr	r1, [pc, #128]	; (8007d88 <OsShellCmdTskInfoData+0x198>)
 8007d06:	00db      	lsls	r3, r3, #3
 8007d08:	440b      	add	r3, r1
 8007d0a:	685c      	ldr	r4, [r3, #4]
 8007d0c:	4b1c      	ldr	r3, [pc, #112]	; (8007d80 <OsShellCmdTskInfoData+0x190>)
 8007d0e:	fba3 1304 	umull	r1, r3, r3, r4
 8007d12:	08d9      	lsrs	r1, r3, #3
 8007d14:	460b      	mov	r3, r1
 8007d16:	009b      	lsls	r3, r3, #2
 8007d18:	440b      	add	r3, r1
 8007d1a:	005b      	lsls	r3, r3, #1
 8007d1c:	1ae1      	subs	r1, r4, r3
 8007d1e:	9102      	str	r1, [sp, #8]
 8007d20:	9501      	str	r5, [sp, #4]
 8007d22:	9200      	str	r2, [sp, #0]
 8007d24:	4663      	mov	r3, ip
 8007d26:	4602      	mov	r2, r0
 8007d28:	4631      	mov	r1, r6
 8007d2a:	4818      	ldr	r0, [pc, #96]	; (8007d8c <OsShellCmdTskInfoData+0x19c>)
 8007d2c:	f7fc fcce 	bl	80046cc <dprintf>
               g_taskCpup10s[taskCB->taskId].uwUsage % LOS_CPUP_PRECISION_MULT,
               g_taskCpup1s[taskCB->taskId].uwUsage / LOS_CPUP_PRECISION_MULT,
               g_taskCpup1s[taskCB->taskId].uwUsage % LOS_CPUP_PRECISION_MULT);
#endif /* LOSCFG_KERNEL_CPUP */
#ifdef LOSCFG_MEM_TASK_STAT
        PRINTK("    %-11u", OsMemTaskUsage(taskCB->taskId));
 8007d30:	693b      	ldr	r3, [r7, #16]
 8007d32:	695b      	ldr	r3, [r3, #20]
 8007d34:	4618      	mov	r0, r3
 8007d36:	f001 fc01 	bl	800953c <OsMemTaskUsage>
 8007d3a:	4603      	mov	r3, r0
 8007d3c:	4619      	mov	r1, r3
 8007d3e:	4814      	ldr	r0, [pc, #80]	; (8007d90 <OsShellCmdTskInfoData+0x1a0>)
 8007d40:	f7fc fcc4 	bl	80046cc <dprintf>
#endif
        PRINTK("\n");
 8007d44:	4813      	ldr	r0, [pc, #76]	; (8007d94 <OsShellCmdTskInfoData+0x1a4>)
 8007d46:	f7fc fcc1 	bl	80046cc <dprintf>
 8007d4a:	e000      	b.n	8007d4e <OsShellCmdTskInfoData+0x15e>
            continue;
 8007d4c:	bf00      	nop
    for (loop = 0; loop < g_taskMaxNum; ++loop) {
 8007d4e:	68fb      	ldr	r3, [r7, #12]
 8007d50:	3301      	adds	r3, #1
 8007d52:	60fb      	str	r3, [r7, #12]
 8007d54:	4b10      	ldr	r3, [pc, #64]	; (8007d98 <OsShellCmdTskInfoData+0x1a8>)
 8007d56:	681b      	ldr	r3, [r3, #0]
 8007d58:	68fa      	ldr	r2, [r7, #12]
 8007d5a:	429a      	cmp	r2, r3
 8007d5c:	f4ff af51 	bcc.w	8007c02 <OsShellCmdTskInfoData+0x12>
    }

#ifdef LOSCFG_SHELL_EXCINFO_DUMP
    OsShellCmdTskInfoDataExc(allTaskArray);
#endif
}
 8007d60:	bf00      	nop
 8007d62:	bf00      	nop
 8007d64:	371c      	adds	r7, #28
 8007d66:	46bd      	mov	sp, r7
 8007d68:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007d6a:	bf00      	nop
 8007d6c:	080211f8 	.word	0x080211f8
 8007d70:	20002168 	.word	0x20002168
 8007d74:	08021210 	.word	0x08021210
 8007d78:	08021248 	.word	0x08021248
 8007d7c:	20001fe8 	.word	0x20001fe8
 8007d80:	cccccccd 	.word	0xcccccccd
 8007d84:	20002068 	.word	0x20002068
 8007d88:	200020e8 	.word	0x200020e8
 8007d8c:	08021250 	.word	0x08021250
 8007d90:	0802126c 	.word	0x0802126c
 8007d94:	0802112c 	.word	0x0802112c
 8007d98:	200036d8 	.word	0x200036d8

08007d9c <OsShellCmdTskInfoGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdTskInfoGet(UINT32 taskId)
{
 8007d9c:	b580      	push	{r7, lr}
 8007d9e:	b08a      	sub	sp, #40	; 0x28
 8007da0:	af00      	add	r7, sp, #0
 8007da2:	6078      	str	r0, [r7, #4]
 8007da4:	4b4c      	ldr	r3, [pc, #304]	; (8007ed8 <OsShellCmdTskInfoGet+0x13c>)
 8007da6:	681b      	ldr	r3, [r3, #0]
 8007da8:	627b      	str	r3, [r7, #36]	; 0x24
 8007daa:	f04f 0300 	mov.w	r3, #0
    BOOL backupFlag = TRUE;
 8007dae:	2301      	movs	r3, #1
 8007db0:	613b      	str	r3, [r7, #16]
    BOOL lockFlag = FALSE;
 8007db2:	2300      	movs	r3, #0
 8007db4:	617b      	str	r3, [r7, #20]
    UINT32 size, intSave;
    LosTaskCB *tcbArray = NULL;
 8007db6:	2300      	movs	r3, #0
 8007db8:	61bb      	str	r3, [r7, #24]
    INT32 ret;

    if (taskId == OS_ALL_TASK_MASK) {
 8007dba:	687b      	ldr	r3, [r7, #4]
 8007dbc:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007dc0:	d17b      	bne.n	8007eba <OsShellCmdTskInfoGet+0x11e>
        size = g_taskMaxNum * sizeof(LosTaskCB);
 8007dc2:	4b46      	ldr	r3, [pc, #280]	; (8007edc <OsShellCmdTskInfoGet+0x140>)
 8007dc4:	681a      	ldr	r2, [r3, #0]
 8007dc6:	4613      	mov	r3, r2
 8007dc8:	009b      	lsls	r3, r3, #2
 8007dca:	4413      	add	r3, r2
 8007dcc:	015b      	lsls	r3, r3, #5
 8007dce:	61fb      	str	r3, [r7, #28]
        tcbArray = (LosTaskCB *)LOS_MemAlloc(m_aucSysMem1, size);
 8007dd0:	4b43      	ldr	r3, [pc, #268]	; (8007ee0 <OsShellCmdTskInfoGet+0x144>)
 8007dd2:	681b      	ldr	r3, [r3, #0]
 8007dd4:	69f9      	ldr	r1, [r7, #28]
 8007dd6:	4618      	mov	r0, r3
 8007dd8:	f000 fde6 	bl	80089a8 <LOS_MemAlloc>
 8007ddc:	61b8      	str	r0, [r7, #24]
        if (tcbArray == NULL) {
 8007dde:	69bb      	ldr	r3, [r7, #24]
 8007de0:	2b00      	cmp	r3, #0
 8007de2:	d107      	bne.n	8007df4 <OsShellCmdTskInfoGet+0x58>
            PRINTK("Memory is not enough to save task info!\n");
 8007de4:	483f      	ldr	r0, [pc, #252]	; (8007ee4 <OsShellCmdTskInfoGet+0x148>)
 8007de6:	f7fc fc71 	bl	80046cc <dprintf>
            tcbArray = g_taskCBArray;
 8007dea:	4b3f      	ldr	r3, [pc, #252]	; (8007ee8 <OsShellCmdTskInfoGet+0x14c>)
 8007dec:	681b      	ldr	r3, [r3, #0]
 8007dee:	61bb      	str	r3, [r7, #24]
            backupFlag = FALSE;
 8007df0:	2300      	movs	r3, #0
 8007df2:	613b      	str	r3, [r7, #16]
        }
#ifdef LOSCFG_KERNEL_CPUP
        (VOID)memset_s((VOID *)g_taskCpupAll, sizeof(g_taskCpupAll), 0, sizeof(g_taskCpupAll));
 8007df4:	2380      	movs	r3, #128	; 0x80
 8007df6:	2200      	movs	r2, #0
 8007df8:	2180      	movs	r1, #128	; 0x80
 8007dfa:	483c      	ldr	r0, [pc, #240]	; (8007eec <OsShellCmdTskInfoGet+0x150>)
 8007dfc:	f00e f946 	bl	801608c <memset_s>
        (VOID)memset_s((VOID *)g_taskCpup10s, sizeof(g_taskCpup10s), 0, sizeof(g_taskCpup10s));
 8007e00:	2380      	movs	r3, #128	; 0x80
 8007e02:	2200      	movs	r2, #0
 8007e04:	2180      	movs	r1, #128	; 0x80
 8007e06:	483a      	ldr	r0, [pc, #232]	; (8007ef0 <OsShellCmdTskInfoGet+0x154>)
 8007e08:	f00e f940 	bl	801608c <memset_s>
        (VOID)memset_s((VOID *)g_taskCpup1s, sizeof(g_taskCpup1s), 0, sizeof(g_taskCpup1s));
 8007e0c:	2380      	movs	r3, #128	; 0x80
 8007e0e:	2200      	movs	r2, #0
 8007e10:	2180      	movs	r1, #128	; 0x80
 8007e12:	4838      	ldr	r0, [pc, #224]	; (8007ef4 <OsShellCmdTskInfoGet+0x158>)
 8007e14:	f00e f93a 	bl	801608c <memset_s>
#endif
        (VOID)memset_s((VOID *)g_taskWaterLine, sizeof(g_taskWaterLine), 0, sizeof(g_taskWaterLine));
 8007e18:	2340      	movs	r3, #64	; 0x40
 8007e1a:	2200      	movs	r2, #0
 8007e1c:	2140      	movs	r1, #64	; 0x40
 8007e1e:	4836      	ldr	r0, [pc, #216]	; (8007ef8 <OsShellCmdTskInfoGet+0x15c>)
 8007e20:	f00e f934 	bl	801608c <memset_s>

        if (LOS_SpinHeld(&g_taskSpin) == FALSE) {
 8007e24:	4835      	ldr	r0, [pc, #212]	; (8007efc <OsShellCmdTskInfoGet+0x160>)
 8007e26:	f7ff fdff 	bl	8007a28 <LOS_SpinHeld>
 8007e2a:	4603      	mov	r3, r0
 8007e2c:	2b00      	cmp	r3, #0
 8007e2e:	d107      	bne.n	8007e40 <OsShellCmdTskInfoGet+0xa4>
            SCHEDULER_LOCK(intSave);
 8007e30:	f107 030c 	add.w	r3, r7, #12
 8007e34:	4619      	mov	r1, r3
 8007e36:	4831      	ldr	r0, [pc, #196]	; (8007efc <OsShellCmdTskInfoGet+0x160>)
 8007e38:	f7ff fddc 	bl	80079f4 <LOS_SpinLockSave>
            lockFlag = TRUE;
 8007e3c:	2301      	movs	r3, #1
 8007e3e:	617b      	str	r3, [r7, #20]
        }
        if (backupFlag == TRUE) {
 8007e40:	693b      	ldr	r3, [r7, #16]
 8007e42:	2b01      	cmp	r3, #1
 8007e44:	d10c      	bne.n	8007e60 <OsShellCmdTskInfoGet+0xc4>
            ret = memcpy_s(tcbArray, size, g_taskCBArray, size);
 8007e46:	4b28      	ldr	r3, [pc, #160]	; (8007ee8 <OsShellCmdTskInfoGet+0x14c>)
 8007e48:	681a      	ldr	r2, [r3, #0]
 8007e4a:	69fb      	ldr	r3, [r7, #28]
 8007e4c:	69f9      	ldr	r1, [r7, #28]
 8007e4e:	69b8      	ldr	r0, [r7, #24]
 8007e50:	f00e fba4 	bl	801659c <memcpy_s>
 8007e54:	6238      	str	r0, [r7, #32]
            if (ret != EOK) {
 8007e56:	6a3b      	ldr	r3, [r7, #32]
 8007e58:	2b00      	cmp	r3, #0
 8007e5a:	d001      	beq.n	8007e60 <OsShellCmdTskInfoGet+0xc4>
                return LOS_NOK;
 8007e5c:	2301      	movs	r3, #1
 8007e5e:	e030      	b.n	8007ec2 <OsShellCmdTskInfoGet+0x126>
            }
        }
#ifdef LOSCFG_KERNEL_CPUP
        (VOID)LOS_AllCpuUsage(LOSCFG_BASE_CORE_TSK_LIMIT, g_taskCpupAll, CPUP_ALL_TIME, 1);
 8007e60:	2301      	movs	r3, #1
 8007e62:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007e66:	4921      	ldr	r1, [pc, #132]	; (8007eec <OsShellCmdTskInfoGet+0x150>)
 8007e68:	2010      	movs	r0, #16
 8007e6a:	f00c f9c1 	bl	80141f0 <LOS_AllCpuUsage>
        (VOID)LOS_AllCpuUsage(LOSCFG_BASE_CORE_TSK_LIMIT, g_taskCpup10s, CPUP_LAST_TEN_SECONDS, 1);
 8007e6e:	2301      	movs	r3, #1
 8007e70:	2200      	movs	r2, #0
 8007e72:	491f      	ldr	r1, [pc, #124]	; (8007ef0 <OsShellCmdTskInfoGet+0x154>)
 8007e74:	2010      	movs	r0, #16
 8007e76:	f00c f9bb 	bl	80141f0 <LOS_AllCpuUsage>
        (VOID)LOS_AllCpuUsage(LOSCFG_BASE_CORE_TSK_LIMIT, g_taskCpup1s, CPUP_LAST_ONE_SECONDS, 1);
 8007e7a:	2301      	movs	r3, #1
 8007e7c:	2201      	movs	r2, #1
 8007e7e:	491d      	ldr	r1, [pc, #116]	; (8007ef4 <OsShellCmdTskInfoGet+0x158>)
 8007e80:	2010      	movs	r0, #16
 8007e82:	f00c f9b5 	bl	80141f0 <LOS_AllCpuUsage>
#endif
        OsShellCmdTaskWaterLineGet(tcbArray);
 8007e86:	69b8      	ldr	r0, [r7, #24]
 8007e88:	f7ff fe2c 	bl	8007ae4 <OsShellCmdTaskWaterLineGet>

        if (lockFlag == TRUE) {
 8007e8c:	697b      	ldr	r3, [r7, #20]
 8007e8e:	2b01      	cmp	r3, #1
 8007e90:	d104      	bne.n	8007e9c <OsShellCmdTskInfoGet+0x100>
            SCHEDULER_UNLOCK(intSave);
 8007e92:	68fb      	ldr	r3, [r7, #12]
 8007e94:	4619      	mov	r1, r3
 8007e96:	4819      	ldr	r0, [pc, #100]	; (8007efc <OsShellCmdTskInfoGet+0x160>)
 8007e98:	f7ff fdba 	bl	8007a10 <LOS_SpinUnlockRestore>
        }

        OsShellCmdTskInfoTitle();
 8007e9c:	f7ff fe5e 	bl	8007b5c <OsShellCmdTskInfoTitle>
        OsShellCmdTskInfoData(tcbArray);
 8007ea0:	69b8      	ldr	r0, [r7, #24]
 8007ea2:	f7ff fea5 	bl	8007bf0 <OsShellCmdTskInfoData>

        if (backupFlag == TRUE) {
 8007ea6:	693b      	ldr	r3, [r7, #16]
 8007ea8:	2b01      	cmp	r3, #1
 8007eaa:	d109      	bne.n	8007ec0 <OsShellCmdTskInfoGet+0x124>
            (VOID)LOS_MemFree(m_aucSysMem1, tcbArray);
 8007eac:	4b0c      	ldr	r3, [pc, #48]	; (8007ee0 <OsShellCmdTskInfoGet+0x144>)
 8007eae:	681b      	ldr	r3, [r3, #0]
 8007eb0:	69b9      	ldr	r1, [r7, #24]
 8007eb2:	4618      	mov	r0, r3
 8007eb4:	f000 fe30 	bl	8008b18 <LOS_MemFree>
 8007eb8:	e002      	b.n	8007ec0 <OsShellCmdTskInfoGet+0x124>
        }
    } else {
        OsTaskBackTrace(taskId);
 8007eba:	6878      	ldr	r0, [r7, #4]
 8007ebc:	f7fc fa48 	bl	8004350 <LOS_TaskBackTrace>
    }

    return LOS_OK;
 8007ec0:	2300      	movs	r3, #0
}
 8007ec2:	4a05      	ldr	r2, [pc, #20]	; (8007ed8 <OsShellCmdTskInfoGet+0x13c>)
 8007ec4:	6811      	ldr	r1, [r2, #0]
 8007ec6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007ec8:	4051      	eors	r1, r2
 8007eca:	d001      	beq.n	8007ed0 <OsShellCmdTskInfoGet+0x134>
 8007ecc:	f7fc fa8c 	bl	80043e8 <__stack_chk_fail>
 8007ed0:	4618      	mov	r0, r3
 8007ed2:	3728      	adds	r7, #40	; 0x28
 8007ed4:	46bd      	mov	sp, r7
 8007ed6:	bd80      	pop	{r7, pc}
 8007ed8:	080212a4 	.word	0x080212a4
 8007edc:	200036d8 	.word	0x200036d8
 8007ee0:	200021b8 	.word	0x200021b8
 8007ee4:	08021278 	.word	0x08021278
 8007ee8:	200036c4 	.word	0x200036c4
 8007eec:	20001fe8 	.word	0x20001fe8
 8007ef0:	20002068 	.word	0x20002068
 8007ef4:	200020e8 	.word	0x200020e8
 8007ef8:	20002168 	.word	0x20002168
 8007efc:	20000764 	.word	0x20000764

08007f00 <OsShellCmdDumpTask>:

#ifdef LOSCFG_SHELL
LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdDumpTask(INT32 argc, const CHAR **argv)
{
 8007f00:	b580      	push	{r7, lr}
 8007f02:	b086      	sub	sp, #24
 8007f04:	af00      	add	r7, sp, #0
 8007f06:	6078      	str	r0, [r7, #4]
 8007f08:	6039      	str	r1, [r7, #0]
 8007f0a:	4b20      	ldr	r3, [pc, #128]	; (8007f8c <OsShellCmdDumpTask+0x8c>)
 8007f0c:	681b      	ldr	r3, [r3, #0]
 8007f0e:	617b      	str	r3, [r7, #20]
 8007f10:	f04f 0300 	mov.w	r3, #0
    size_t taskId;
    CHAR *endPtr = NULL;
 8007f14:	2300      	movs	r3, #0
 8007f16:	60fb      	str	r3, [r7, #12]

    if (argc < 2) { /* 2:Just as number of parameters */
 8007f18:	687b      	ldr	r3, [r7, #4]
 8007f1a:	2b01      	cmp	r3, #1
 8007f1c:	dc26      	bgt.n	8007f6c <OsShellCmdDumpTask+0x6c>
        if (argc == 0) {
 8007f1e:	687b      	ldr	r3, [r7, #4]
 8007f20:	2b00      	cmp	r3, #0
 8007f22:	d103      	bne.n	8007f2c <OsShellCmdDumpTask+0x2c>
            taskId = OS_ALL_TASK_MASK;
 8007f24:	f04f 33ff 	mov.w	r3, #4294967295
 8007f28:	613b      	str	r3, [r7, #16]
 8007f2a:	e01a      	b.n	8007f62 <OsShellCmdDumpTask+0x62>
        } else {
            taskId = strtoul(argv[0], &endPtr, 0);
 8007f2c:	683b      	ldr	r3, [r7, #0]
 8007f2e:	681b      	ldr	r3, [r3, #0]
 8007f30:	f107 010c 	add.w	r1, r7, #12
 8007f34:	2200      	movs	r2, #0
 8007f36:	4618      	mov	r0, r3
 8007f38:	f006 fe2a 	bl	800eb90 <strtoul>
 8007f3c:	6138      	str	r0, [r7, #16]
            if ((*endPtr != 0) || (taskId >= g_taskMaxNum)) {
 8007f3e:	68fb      	ldr	r3, [r7, #12]
 8007f40:	781b      	ldrb	r3, [r3, #0]
 8007f42:	2b00      	cmp	r3, #0
 8007f44:	d104      	bne.n	8007f50 <OsShellCmdDumpTask+0x50>
 8007f46:	4b12      	ldr	r3, [pc, #72]	; (8007f90 <OsShellCmdDumpTask+0x90>)
 8007f48:	681b      	ldr	r3, [r3, #0]
 8007f4a:	693a      	ldr	r2, [r7, #16]
 8007f4c:	429a      	cmp	r2, r3
 8007f4e:	d308      	bcc.n	8007f62 <OsShellCmdDumpTask+0x62>
                PRINTK("\ntask ID can't access %s.\n", argv[0]);
 8007f50:	683b      	ldr	r3, [r7, #0]
 8007f52:	681b      	ldr	r3, [r3, #0]
 8007f54:	4619      	mov	r1, r3
 8007f56:	480f      	ldr	r0, [pc, #60]	; (8007f94 <OsShellCmdDumpTask+0x94>)
 8007f58:	f7fc fbb8 	bl	80046cc <dprintf>
                return OS_ERROR;
 8007f5c:	f04f 33ff 	mov.w	r3, #4294967295
 8007f60:	e009      	b.n	8007f76 <OsShellCmdDumpTask+0x76>
            }
        }

        return OsShellCmdTskInfoGet((UINT32)taskId);
 8007f62:	6938      	ldr	r0, [r7, #16]
 8007f64:	f7ff ff1a 	bl	8007d9c <OsShellCmdTskInfoGet>
 8007f68:	4603      	mov	r3, r0
 8007f6a:	e004      	b.n	8007f76 <OsShellCmdDumpTask+0x76>
    } else {
        PRINTK("\nUsage: task or task ID\n");
 8007f6c:	480a      	ldr	r0, [pc, #40]	; (8007f98 <OsShellCmdDumpTask+0x98>)
 8007f6e:	f7fc fbad 	bl	80046cc <dprintf>
        return OS_ERROR;
 8007f72:	f04f 33ff 	mov.w	r3, #4294967295
    }
}
 8007f76:	4a05      	ldr	r2, [pc, #20]	; (8007f8c <OsShellCmdDumpTask+0x8c>)
 8007f78:	6811      	ldr	r1, [r2, #0]
 8007f7a:	697a      	ldr	r2, [r7, #20]
 8007f7c:	4051      	eors	r1, r2
 8007f7e:	d001      	beq.n	8007f84 <OsShellCmdDumpTask+0x84>
 8007f80:	f7fc fa32 	bl	80043e8 <__stack_chk_fail>
 8007f84:	4618      	mov	r0, r3
 8007f86:	3718      	adds	r7, #24
 8007f88:	46bd      	mov	sp, r7
 8007f8a:	bd80      	pop	{r7, pc}
 8007f8c:	080212e0 	.word	0x080212e0
 8007f90:	200036d8 	.word	0x200036d8
 8007f94:	080212a8 	.word	0x080212a8
 8007f98:	080212c4 	.word	0x080212c4

08007f9c <ArchCurrCpuid>:
{
 8007f9c:	b480      	push	{r7}
 8007f9e:	af00      	add	r7, sp, #0
    return 0;
 8007fa0:	2300      	movs	r3, #0
}
 8007fa2:	4618      	mov	r0, r3
 8007fa4:	46bd      	mov	sp, r7
 8007fa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007faa:	4770      	bx	lr

08007fac <LOS_IntLock>:
{
 8007fac:	b580      	push	{r7, lr}
 8007fae:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8007fb0:	f7f8 fe8a 	bl	8000cc8 <ArchIntLock>
 8007fb4:	4603      	mov	r3, r0
}
 8007fb6:	4618      	mov	r0, r3
 8007fb8:	bd80      	pop	{r7, pc}

08007fba <LOS_IntRestore>:
{
 8007fba:	b580      	push	{r7, lr}
 8007fbc:	b082      	sub	sp, #8
 8007fbe:	af00      	add	r7, sp, #0
 8007fc0:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8007fc2:	6878      	ldr	r0, [r7, #4]
 8007fc4:	f7f8 fe88 	bl	8000cd8 <ArchIntRestore>
}
 8007fc8:	bf00      	nop
 8007fca:	3708      	adds	r7, #8
 8007fcc:	46bd      	mov	sp, r7
 8007fce:	bd80      	pop	{r7, pc}

08007fd0 <ArchCurrTaskGet>:
{
 8007fd0:	b480      	push	{r7}
 8007fd2:	af00      	add	r7, sp, #0
    return g_runTask;
 8007fd4:	4b03      	ldr	r3, [pc, #12]	; (8007fe4 <ArchCurrTaskGet+0x14>)
 8007fd6:	681b      	ldr	r3, [r3, #0]
}
 8007fd8:	4618      	mov	r0, r3
 8007fda:	46bd      	mov	sp, r7
 8007fdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007fe0:	4770      	bx	lr
 8007fe2:	bf00      	nop
 8007fe4:	200033bc 	.word	0x200033bc

08007fe8 <ArchCurrTaskSet>:
{
 8007fe8:	b480      	push	{r7}
 8007fea:	b083      	sub	sp, #12
 8007fec:	af00      	add	r7, sp, #0
 8007fee:	6078      	str	r0, [r7, #4]
    g_runTask = val;
 8007ff0:	4a04      	ldr	r2, [pc, #16]	; (8008004 <ArchCurrTaskSet+0x1c>)
 8007ff2:	687b      	ldr	r3, [r7, #4]
 8007ff4:	6013      	str	r3, [r2, #0]
}
 8007ff6:	bf00      	nop
 8007ff8:	370c      	adds	r7, #12
 8007ffa:	46bd      	mov	sp, r7
 8007ffc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008000:	4770      	bx	lr
 8008002:	bf00      	nop
 8008004:	200033bc 	.word	0x200033bc

08008008 <OsPercpuGet>:
{
 8008008:	b580      	push	{r7, lr}
 800800a:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 800800c:	f7ff ffc6 	bl	8007f9c <ArchCurrCpuid>
 8008010:	4602      	mov	r2, r0
 8008012:	4613      	mov	r3, r2
 8008014:	00db      	lsls	r3, r3, #3
 8008016:	4413      	add	r3, r2
 8008018:	009b      	lsls	r3, r3, #2
 800801a:	4a02      	ldr	r2, [pc, #8]	; (8008024 <OsPercpuGet+0x1c>)
 800801c:	4413      	add	r3, r2
}
 800801e:	4618      	mov	r0, r3
 8008020:	bd80      	pop	{r7, pc}
 8008022:	bf00      	nop
 8008024:	200036fc 	.word	0x200036fc

08008028 <OsPreemptable>:
{
 8008028:	b580      	push	{r7, lr}
 800802a:	b082      	sub	sp, #8
 800802c:	af00      	add	r7, sp, #0
    UINT32 intSave = LOS_IntLock();
 800802e:	f7ff ffbd 	bl	8007fac <LOS_IntLock>
 8008032:	6038      	str	r0, [r7, #0]
    BOOL preemptable = (OsPercpuGet()->taskLockCnt == 0);
 8008034:	f7ff ffe8 	bl	8008008 <OsPercpuGet>
 8008038:	4603      	mov	r3, r0
 800803a:	695b      	ldr	r3, [r3, #20]
 800803c:	2b00      	cmp	r3, #0
 800803e:	bf0c      	ite	eq
 8008040:	2301      	moveq	r3, #1
 8008042:	2300      	movne	r3, #0
 8008044:	b2db      	uxtb	r3, r3
 8008046:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 8008048:	687b      	ldr	r3, [r7, #4]
 800804a:	2b00      	cmp	r3, #0
 800804c:	d104      	bne.n	8008058 <OsPreemptable+0x30>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 800804e:	f7ff ffdb 	bl	8008008 <OsPercpuGet>
 8008052:	4603      	mov	r3, r0
 8008054:	2201      	movs	r2, #1
 8008056:	621a      	str	r2, [r3, #32]
    LOS_IntRestore(intSave);
 8008058:	6838      	ldr	r0, [r7, #0]
 800805a:	f7ff ffae 	bl	8007fba <LOS_IntRestore>
    return preemptable;
 800805e:	687b      	ldr	r3, [r7, #4]
}
 8008060:	4618      	mov	r0, r3
 8008062:	3708      	adds	r7, #8
 8008064:	46bd      	mov	sp, r7
 8008066:	bd80      	pop	{r7, pc}

08008068 <OsPreemptableInSched>:
{
 8008068:	b580      	push	{r7, lr}
 800806a:	b082      	sub	sp, #8
 800806c:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 800806e:	2300      	movs	r3, #0
 8008070:	607b      	str	r3, [r7, #4]
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 8008072:	f7ff ffc9 	bl	8008008 <OsPercpuGet>
 8008076:	4603      	mov	r3, r0
 8008078:	695b      	ldr	r3, [r3, #20]
 800807a:	2b00      	cmp	r3, #0
 800807c:	bf0c      	ite	eq
 800807e:	2301      	moveq	r3, #1
 8008080:	2300      	movne	r3, #0
 8008082:	b2db      	uxtb	r3, r3
 8008084:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 8008086:	687b      	ldr	r3, [r7, #4]
 8008088:	2b00      	cmp	r3, #0
 800808a:	d104      	bne.n	8008096 <OsPreemptableInSched+0x2e>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 800808c:	f7ff ffbc 	bl	8008008 <OsPercpuGet>
 8008090:	4603      	mov	r3, r0
 8008092:	2201      	movs	r2, #1
 8008094:	621a      	str	r2, [r3, #32]
    return preemptable;
 8008096:	687b      	ldr	r3, [r7, #4]
}
 8008098:	4618      	mov	r0, r3
 800809a:	3708      	adds	r7, #8
 800809c:	46bd      	mov	sp, r7
 800809e:	bd80      	pop	{r7, pc}

080080a0 <LOS_Schedule>:
{
 80080a0:	b580      	push	{r7, lr}
 80080a2:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 80080a4:	f7fa f9e2 	bl	800246c <IntActive>
 80080a8:	4603      	mov	r3, r0
 80080aa:	2b00      	cmp	r3, #0
 80080ac:	d005      	beq.n	80080ba <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 80080ae:	f7ff ffab 	bl	8008008 <OsPercpuGet>
 80080b2:	4603      	mov	r3, r0
 80080b4:	2201      	movs	r2, #1
 80080b6:	621a      	str	r2, [r3, #32]
        return;
 80080b8:	e001      	b.n	80080be <LOS_Schedule+0x1e>
    OsSchedPreempt();
 80080ba:	f000 f905 	bl	80082c8 <OsSchedPreempt>
}
 80080be:	bd80      	pop	{r7, pc}

080080c0 <LOS_SpinLockSave>:
{
 80080c0:	b580      	push	{r7, lr}
 80080c2:	b082      	sub	sp, #8
 80080c4:	af00      	add	r7, sp, #0
 80080c6:	6078      	str	r0, [r7, #4]
 80080c8:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 80080ca:	f7ff ff6f 	bl	8007fac <LOS_IntLock>
 80080ce:	4602      	mov	r2, r0
 80080d0:	683b      	ldr	r3, [r7, #0]
 80080d2:	601a      	str	r2, [r3, #0]
}
 80080d4:	bf00      	nop
 80080d6:	3708      	adds	r7, #8
 80080d8:	46bd      	mov	sp, r7
 80080da:	bd80      	pop	{r7, pc}

080080dc <LOS_SpinUnlockRestore>:
{
 80080dc:	b580      	push	{r7, lr}
 80080de:	b082      	sub	sp, #8
 80080e0:	af00      	add	r7, sp, #0
 80080e2:	6078      	str	r0, [r7, #4]
 80080e4:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 80080e6:	6838      	ldr	r0, [r7, #0]
 80080e8:	f7ff ff67 	bl	8007fba <LOS_IntRestore>
}
 80080ec:	bf00      	nop
 80080ee:	3708      	adds	r7, #8
 80080f0:	46bd      	mov	sp, r7
 80080f2:	bd80      	pop	{r7, pc}

080080f4 <LOS_SpinHeld>:
{
 80080f4:	b480      	push	{r7}
 80080f6:	b083      	sub	sp, #12
 80080f8:	af00      	add	r7, sp, #0
 80080fa:	6078      	str	r0, [r7, #4]
    return TRUE;
 80080fc:	2301      	movs	r3, #1
}
 80080fe:	4618      	mov	r0, r3
 8008100:	370c      	adds	r7, #12
 8008102:	46bd      	mov	sp, r7
 8008104:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008108:	4770      	bx	lr

0800810a <OsCurrTaskGet>:
{
 800810a:	b580      	push	{r7, lr}
 800810c:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 800810e:	f7ff ff5f 	bl	8007fd0 <ArchCurrTaskGet>
 8008112:	4603      	mov	r3, r0
}
 8008114:	4618      	mov	r0, r3
 8008116:	bd80      	pop	{r7, pc}

08008118 <OsCurrTaskSet>:
{
 8008118:	b580      	push	{r7, lr}
 800811a:	b082      	sub	sp, #8
 800811c:	af00      	add	r7, sp, #0
 800811e:	6078      	str	r0, [r7, #4]
    ArchCurrTaskSet(task);
 8008120:	6878      	ldr	r0, [r7, #4]
 8008122:	f7ff ff61 	bl	8007fe8 <ArchCurrTaskSet>
}
 8008126:	bf00      	nop
 8008128:	3708      	adds	r7, #8
 800812a:	46bd      	mov	sp, r7
 800812c:	bd80      	pop	{r7, pc}

0800812e <OsTaskTimeUpdateHook>:
#endif
}
/* Update the last time the task was executed */
extern VOID OsTaskTimeUpdate(UINT32 taskId, UINT64 tickCount);
STATIC INLINE VOID OsTaskTimeUpdateHook(UINT32 taskId, UINT64 tickCount)
{
 800812e:	b580      	push	{r7, lr}
 8008130:	b084      	sub	sp, #16
 8008132:	af00      	add	r7, sp, #0
 8008134:	60f8      	str	r0, [r7, #12]
 8008136:	e9c7 2300 	strd	r2, r3, [r7]
#ifdef LOSCFG_DEBUG_MUTEX_DEADLOCK
    OsTaskTimeUpdate(taskId, tickCount);
 800813a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800813e:	68f8      	ldr	r0, [r7, #12]
 8008140:	f7fd ff42 	bl	8005fc8 <OsTaskTimeUpdate>
#endif
}
 8008144:	bf00      	nop
 8008146:	3710      	adds	r7, #16
 8008148:	46bd      	mov	sp, r7
 800814a:	bd80      	pop	{r7, pc}

0800814c <OsSchedResched>:
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

VOID OsSchedResched(VOID)
{
 800814c:	b590      	push	{r4, r7, lr}
 800814e:	b08b      	sub	sp, #44	; 0x2c
 8008150:	af00      	add	r7, sp, #0
 8008152:	4b56      	ldr	r3, [pc, #344]	; (80082ac <OsSchedResched+0x160>)
 8008154:	681b      	ldr	r3, [r3, #0]
 8008156:	627b      	str	r3, [r7, #36]	; 0x24
 8008158:	f04f 0300 	mov.w	r3, #0
    LosTaskCB *runTask = NULL;
 800815c:	2300      	movs	r3, #0
 800815e:	603b      	str	r3, [r7, #0]
    LosTaskCB *newTask = NULL;
 8008160:	2300      	movs	r3, #0
 8008162:	607b      	str	r3, [r7, #4]

    LOS_ASSERT(LOS_SpinHeld(&g_taskSpin));
 8008164:	4852      	ldr	r0, [pc, #328]	; (80082b0 <OsSchedResched+0x164>)
 8008166:	f7ff ffc5 	bl	80080f4 <LOS_SpinHeld>
 800816a:	4603      	mov	r3, r0
 800816c:	2b00      	cmp	r3, #0
 800816e:	d10b      	bne.n	8008188 <OsSchedResched+0x3c>
 8008170:	f7ff ff1c 	bl	8007fac <LOS_IntLock>
 8008174:	484f      	ldr	r0, [pc, #316]	; (80082b4 <OsSchedResched+0x168>)
 8008176:	f7fc faa9 	bl	80046cc <dprintf>
 800817a:	4b4f      	ldr	r3, [pc, #316]	; (80082b8 <OsSchedResched+0x16c>)
 800817c:	2233      	movs	r2, #51	; 0x33
 800817e:	494f      	ldr	r1, [pc, #316]	; (80082bc <OsSchedResched+0x170>)
 8008180:	484f      	ldr	r0, [pc, #316]	; (80082c0 <OsSchedResched+0x174>)
 8008182:	f7fc faa3 	bl	80046cc <dprintf>
 8008186:	e7fe      	b.n	8008186 <OsSchedResched+0x3a>

    if (!OsPreemptableInSched()) {
 8008188:	f7ff ff6e 	bl	8008068 <OsPreemptableInSched>
 800818c:	4603      	mov	r3, r0
 800818e:	2b00      	cmp	r3, #0
 8008190:	d07e      	beq.n	8008290 <OsSchedResched+0x144>
        return;
    }

    runTask = OsCurrTaskGet();
 8008192:	f7ff ffba 	bl	800810a <OsCurrTaskGet>
 8008196:	6038      	str	r0, [r7, #0]
    newTask = OsGetTopTask();
 8008198:	f000 fac2 	bl	8008720 <OsGetTopTask>
 800819c:	6078      	str	r0, [r7, #4]

    /* always be able to get one task */
    LOS_ASSERT(newTask != NULL);
 800819e:	687b      	ldr	r3, [r7, #4]
 80081a0:	2b00      	cmp	r3, #0
 80081a2:	d10b      	bne.n	80081bc <OsSchedResched+0x70>
 80081a4:	f7ff ff02 	bl	8007fac <LOS_IntLock>
 80081a8:	4842      	ldr	r0, [pc, #264]	; (80082b4 <OsSchedResched+0x168>)
 80081aa:	f7fc fa8f 	bl	80046cc <dprintf>
 80081ae:	4b42      	ldr	r3, [pc, #264]	; (80082b8 <OsSchedResched+0x16c>)
 80081b0:	223d      	movs	r2, #61	; 0x3d
 80081b2:	4942      	ldr	r1, [pc, #264]	; (80082bc <OsSchedResched+0x170>)
 80081b4:	4842      	ldr	r0, [pc, #264]	; (80082c0 <OsSchedResched+0x174>)
 80081b6:	f7fc fa89 	bl	80046cc <dprintf>
 80081ba:	e7fe      	b.n	80081ba <OsSchedResched+0x6e>

    newTask->taskStatus &= ~OS_TASK_STATUS_READY;
 80081bc:	687b      	ldr	r3, [r7, #4]
 80081be:	889b      	ldrh	r3, [r3, #4]
 80081c0:	f023 0304 	bic.w	r3, r3, #4
 80081c4:	b29a      	uxth	r2, r3
 80081c6:	687b      	ldr	r3, [r7, #4]
 80081c8:	809a      	strh	r2, [r3, #4]

    if (runTask == newTask) {
 80081ca:	683a      	ldr	r2, [r7, #0]
 80081cc:	687b      	ldr	r3, [r7, #4]
 80081ce:	429a      	cmp	r2, r3
 80081d0:	d060      	beq.n	8008294 <OsSchedResched+0x148>
        return;
    }

    runTask->taskStatus &= ~OS_TASK_STATUS_RUNNING;
 80081d2:	683b      	ldr	r3, [r7, #0]
 80081d4:	889b      	ldrh	r3, [r3, #4]
 80081d6:	f023 0310 	bic.w	r3, r3, #16
 80081da:	b29a      	uxth	r2, r3
 80081dc:	683b      	ldr	r3, [r7, #0]
 80081de:	809a      	strh	r2, [r3, #4]
    newTask->taskStatus |= OS_TASK_STATUS_RUNNING;
 80081e0:	687b      	ldr	r3, [r7, #4]
 80081e2:	889b      	ldrh	r3, [r3, #4]
 80081e4:	f043 0310 	orr.w	r3, r3, #16
 80081e8:	b29a      	uxth	r2, r3
 80081ea:	687b      	ldr	r3, [r7, #4]
 80081ec:	809a      	strh	r2, [r3, #4]
    /* mask new running task's owner processor */
    runTask->currCpu = OS_TASK_INVALID_CPUID;
    newTask->currCpu = ArchCurrCpuid();
#endif

    OsTaskTimeUpdateHook(runTask->taskId, LOS_TickCountGet());
 80081ee:	683b      	ldr	r3, [r7, #0]
 80081f0:	695c      	ldr	r4, [r3, #20]
 80081f2:	f7fb ffc1 	bl	8004178 <LOS_TickCountGet>
 80081f6:	4602      	mov	r2, r0
 80081f8:	460b      	mov	r3, r1
 80081fa:	4620      	mov	r0, r4
 80081fc:	f7ff ff97 	bl	800812e <OsTaskTimeUpdateHook>

#ifdef LOSCFG_KERNEL_CPUP
    OsTaskCycleEndStart(newTask);
 8008200:	6878      	ldr	r0, [r7, #4]
 8008202:	f00b fd99 	bl	8013d38 <OsTaskCycleEndStart>
#endif

#ifdef LOSCFG_BASE_CORE_TSK_MONITOR
    OsTaskSwitchCheck(runTask, newTask);
 8008206:	6879      	ldr	r1, [r7, #4]
 8008208:	6838      	ldr	r0, [r7, #0]
 800820a:	f7fa ff5b 	bl	80030c4 <OsTaskSwitchCheck>
#endif

    LOS_TRACE(TASK_SWITCH, newTask->taskId, runTask->priority, runTask->taskStatus, newTask->priority,
 800820e:	2300      	movs	r3, #0
 8008210:	60fb      	str	r3, [r7, #12]
 8008212:	687b      	ldr	r3, [r7, #4]
 8008214:	695b      	ldr	r3, [r3, #20]
 8008216:	613b      	str	r3, [r7, #16]
 8008218:	683b      	ldr	r3, [r7, #0]
 800821a:	88db      	ldrh	r3, [r3, #6]
 800821c:	617b      	str	r3, [r7, #20]
 800821e:	683b      	ldr	r3, [r7, #0]
 8008220:	889b      	ldrh	r3, [r3, #4]
 8008222:	61bb      	str	r3, [r7, #24]
 8008224:	687b      	ldr	r3, [r7, #4]
 8008226:	88db      	ldrh	r3, [r3, #6]
 8008228:	61fb      	str	r3, [r7, #28]
 800822a:	687b      	ldr	r3, [r7, #4]
 800822c:	889b      	ldrh	r3, [r3, #4]
 800822e:	623b      	str	r3, [r7, #32]
 8008230:	2306      	movs	r3, #6
 8008232:	60bb      	str	r3, [r7, #8]
 8008234:	68bb      	ldr	r3, [r7, #8]
 8008236:	2b01      	cmp	r3, #1
 8008238:	d915      	bls.n	8008266 <OsSchedResched+0x11a>
 800823a:	4b22      	ldr	r3, [pc, #136]	; (80082c4 <OsSchedResched+0x178>)
 800823c:	681b      	ldr	r3, [r3, #0]
 800823e:	2b00      	cmp	r3, #0
 8008240:	d011      	beq.n	8008266 <OsSchedResched+0x11a>
 8008242:	4b20      	ldr	r3, [pc, #128]	; (80082c4 <OsSchedResched+0x178>)
 8008244:	681c      	ldr	r4, [r3, #0]
 8008246:	6939      	ldr	r1, [r7, #16]
 8008248:	68bb      	ldr	r3, [r7, #8]
 800824a:	2b02      	cmp	r3, #2
 800824c:	d904      	bls.n	8008258 <OsSchedResched+0x10c>
 800824e:	f107 030c 	add.w	r3, r7, #12
 8008252:	f103 0208 	add.w	r2, r3, #8
 8008256:	e000      	b.n	800825a <OsSchedResched+0x10e>
 8008258:	2200      	movs	r2, #0
 800825a:	68bb      	ldr	r3, [r7, #8]
 800825c:	b29b      	uxth	r3, r3
 800825e:	3b02      	subs	r3, #2
 8008260:	b29b      	uxth	r3, r3
 8008262:	2045      	movs	r0, #69	; 0x45
 8008264:	47a0      	blx	r4
        newTask->taskStatus);

#ifdef LOSCFG_DEBUG_SCHED_STATISTICS
    OsSchedStatistics(runTask, newTask);
 8008266:	6879      	ldr	r1, [r7, #4]
 8008268:	6838      	ldr	r0, [r7, #0]
 800826a:	f7fe fd8b 	bl	8006d84 <OsSchedStatistics>
#endif

#ifdef LOSCFG_BASE_CORE_TIMESLICE
    if (newTask->timeSlice == 0) {
 800826e:	687b      	ldr	r3, [r7, #4]
 8008270:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8008274:	2b00      	cmp	r3, #0
 8008276:	d103      	bne.n	8008280 <OsSchedResched+0x134>
        newTask->timeSlice = KERNEL_TIMESLICE_TIMEOUT;
 8008278:	687b      	ldr	r3, [r7, #4]
 800827a:	2202      	movs	r2, #2
 800827c:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
    }
#endif

    OsCurrTaskSet((VOID*)newTask);
 8008280:	6878      	ldr	r0, [r7, #4]
 8008282:	f7ff ff49 	bl	8008118 <OsCurrTaskSet>

    /* do the task context switch */
    OsTaskSchedule(newTask, runTask);
 8008286:	6839      	ldr	r1, [r7, #0]
 8008288:	6878      	ldr	r0, [r7, #4]
 800828a:	f7f8 fd28 	bl	8000cde <OsTaskSchedule>
 800828e:	e002      	b.n	8008296 <OsSchedResched+0x14a>
        return;
 8008290:	bf00      	nop
 8008292:	e000      	b.n	8008296 <OsSchedResched+0x14a>
        return;
 8008294:	bf00      	nop
}
 8008296:	4b05      	ldr	r3, [pc, #20]	; (80082ac <OsSchedResched+0x160>)
 8008298:	681a      	ldr	r2, [r3, #0]
 800829a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800829c:	405a      	eors	r2, r3
 800829e:	d001      	beq.n	80082a4 <OsSchedResched+0x158>
 80082a0:	f7fc f8a2 	bl	80043e8 <__stack_chk_fail>
 80082a4:	372c      	adds	r7, #44	; 0x2c
 80082a6:	46bd      	mov	sp, r7
 80082a8:	bd90      	pop	{r4, r7, pc}
 80082aa:	bf00      	nop
 80082ac:	0802132c 	.word	0x0802132c
 80082b0:	20000764 	.word	0x20000764
 80082b4:	080212ec 	.word	0x080212ec
 80082b8:	08023378 	.word	0x08023378
 80082bc:	080212f4 	.word	0x080212f4
 80082c0:	08021310 	.word	0x08021310
 80082c4:	2000075c 	.word	0x2000075c

080082c8 <OsSchedPreempt>:

VOID OsSchedPreempt(VOID)
{
 80082c8:	b580      	push	{r7, lr}
 80082ca:	b084      	sub	sp, #16
 80082cc:	af00      	add	r7, sp, #0
 80082ce:	4b23      	ldr	r3, [pc, #140]	; (800835c <OsSchedPreempt+0x94>)
 80082d0:	681b      	ldr	r3, [r3, #0]
 80082d2:	60fb      	str	r3, [r7, #12]
 80082d4:	f04f 0300 	mov.w	r3, #0
    LosTaskCB *runTask = NULL;
 80082d8:	2300      	movs	r3, #0
 80082da:	60bb      	str	r3, [r7, #8]
    UINT32 intSave;

    if (!OsPreemptable()) {
 80082dc:	f7ff fea4 	bl	8008028 <OsPreemptable>
 80082e0:	4603      	mov	r3, r0
 80082e2:	2b00      	cmp	r3, #0
 80082e4:	d02e      	beq.n	8008344 <OsSchedPreempt+0x7c>
        return;
    }

    SCHEDULER_LOCK(intSave);
 80082e6:	1d3b      	adds	r3, r7, #4
 80082e8:	4619      	mov	r1, r3
 80082ea:	481d      	ldr	r0, [pc, #116]	; (8008360 <OsSchedPreempt+0x98>)
 80082ec:	f7ff fee8 	bl	80080c0 <LOS_SpinLockSave>

    /* add run task back to ready queue */
    runTask = OsCurrTaskGet();
 80082f0:	f7ff ff0b 	bl	800810a <OsCurrTaskGet>
 80082f4:	60b8      	str	r0, [r7, #8]
    runTask->taskStatus |= OS_TASK_STATUS_READY;
 80082f6:	68bb      	ldr	r3, [r7, #8]
 80082f8:	889b      	ldrh	r3, [r3, #4]
 80082fa:	f043 0304 	orr.w	r3, r3, #4
 80082fe:	b29a      	uxth	r2, r3
 8008300:	68bb      	ldr	r3, [r7, #8]
 8008302:	809a      	strh	r2, [r3, #4]

#ifdef LOSCFG_BASE_CORE_TIMESLICE
    if (runTask->timeSlice == 0) {
 8008304:	68bb      	ldr	r3, [r7, #8]
 8008306:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 800830a:	2b00      	cmp	r3, #0
 800830c:	d109      	bne.n	8008322 <OsSchedPreempt+0x5a>
        OsPriQueueEnqueue(&runTask->pendList, runTask->priority);
 800830e:	68bb      	ldr	r3, [r7, #8]
 8008310:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8008314:	68bb      	ldr	r3, [r7, #8]
 8008316:	88db      	ldrh	r3, [r3, #6]
 8008318:	4619      	mov	r1, r3
 800831a:	4610      	mov	r0, r2
 800831c:	f000 f940 	bl	80085a0 <OsPriQueueEnqueue>
 8008320:	e008      	b.n	8008334 <OsSchedPreempt+0x6c>
    } else {
#endif
        OsPriQueueEnqueueHead(&runTask->pendList, runTask->priority);
 8008322:	68bb      	ldr	r3, [r7, #8]
 8008324:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8008328:	68bb      	ldr	r3, [r7, #8]
 800832a:	88db      	ldrh	r3, [r3, #6]
 800832c:	4619      	mov	r1, r3
 800832e:	4610      	mov	r0, r2
 8008330:	f000 f8f4 	bl	800851c <OsPriQueueEnqueueHead>
#ifdef LOSCFG_BASE_CORE_TIMESLICE
    }
#endif

    /* reschedule to new thread */
    OsSchedResched();
 8008334:	f7ff ff0a 	bl	800814c <OsSchedResched>

    SCHEDULER_UNLOCK(intSave);
 8008338:	687b      	ldr	r3, [r7, #4]
 800833a:	4619      	mov	r1, r3
 800833c:	4808      	ldr	r0, [pc, #32]	; (8008360 <OsSchedPreempt+0x98>)
 800833e:	f7ff fecd 	bl	80080dc <LOS_SpinUnlockRestore>
 8008342:	e000      	b.n	8008346 <OsSchedPreempt+0x7e>
        return;
 8008344:	bf00      	nop
}
 8008346:	4b05      	ldr	r3, [pc, #20]	; (800835c <OsSchedPreempt+0x94>)
 8008348:	681a      	ldr	r2, [r3, #0]
 800834a:	68fb      	ldr	r3, [r7, #12]
 800834c:	405a      	eors	r2, r3
 800834e:	d001      	beq.n	8008354 <OsSchedPreempt+0x8c>
 8008350:	f7fc f84a 	bl	80043e8 <__stack_chk_fail>
 8008354:	3710      	adds	r7, #16
 8008356:	46bd      	mov	sp, r7
 8008358:	bd80      	pop	{r7, pc}
 800835a:	bf00      	nop
 800835c:	08021330 	.word	0x08021330
 8008360:	20000764 	.word	0x20000764

08008364 <OsTimesliceCheck>:

#ifdef LOSCFG_BASE_CORE_TIMESLICE
LITE_OS_SEC_TEXT VOID OsTimesliceCheck(VOID)
{
 8008364:	b580      	push	{r7, lr}
 8008366:	b082      	sub	sp, #8
 8008368:	af00      	add	r7, sp, #0
    LosTaskCB *runTask = OsCurrTaskGet();
 800836a:	f7ff fece 	bl	800810a <OsCurrTaskGet>
 800836e:	6078      	str	r0, [r7, #4]
    if (runTask->timeSlice != 0) {
 8008370:	687b      	ldr	r3, [r7, #4]
 8008372:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8008376:	2b00      	cmp	r3, #0
 8008378:	d00e      	beq.n	8008398 <OsTimesliceCheck+0x34>
        runTask->timeSlice--;
 800837a:	687b      	ldr	r3, [r7, #4]
 800837c:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8008380:	3b01      	subs	r3, #1
 8008382:	b29a      	uxth	r2, r3
 8008384:	687b      	ldr	r3, [r7, #4]
 8008386:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
        if (runTask->timeSlice == 0) {
 800838a:	687b      	ldr	r3, [r7, #4]
 800838c:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8008390:	2b00      	cmp	r3, #0
 8008392:	d101      	bne.n	8008398 <OsTimesliceCheck+0x34>
            LOS_Schedule();
 8008394:	f7ff fe84 	bl	80080a0 <LOS_Schedule>
        }
    }
}
 8008398:	bf00      	nop
 800839a:	3708      	adds	r7, #8
 800839c:	46bd      	mov	sp, r7
 800839e:	bd80      	pop	{r7, pc}

080083a0 <LOS_ListInit>:
{
 80083a0:	b480      	push	{r7}
 80083a2:	b083      	sub	sp, #12
 80083a4:	af00      	add	r7, sp, #0
 80083a6:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 80083a8:	687b      	ldr	r3, [r7, #4]
 80083aa:	687a      	ldr	r2, [r7, #4]
 80083ac:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 80083ae:	687b      	ldr	r3, [r7, #4]
 80083b0:	687a      	ldr	r2, [r7, #4]
 80083b2:	601a      	str	r2, [r3, #0]
}
 80083b4:	bf00      	nop
 80083b6:	370c      	adds	r7, #12
 80083b8:	46bd      	mov	sp, r7
 80083ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80083be:	4770      	bx	lr

080083c0 <LOS_ListAdd>:
{
 80083c0:	b480      	push	{r7}
 80083c2:	b083      	sub	sp, #12
 80083c4:	af00      	add	r7, sp, #0
 80083c6:	6078      	str	r0, [r7, #4]
 80083c8:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 80083ca:	687b      	ldr	r3, [r7, #4]
 80083cc:	685a      	ldr	r2, [r3, #4]
 80083ce:	683b      	ldr	r3, [r7, #0]
 80083d0:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 80083d2:	683b      	ldr	r3, [r7, #0]
 80083d4:	687a      	ldr	r2, [r7, #4]
 80083d6:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 80083d8:	687b      	ldr	r3, [r7, #4]
 80083da:	685b      	ldr	r3, [r3, #4]
 80083dc:	683a      	ldr	r2, [r7, #0]
 80083de:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 80083e0:	687b      	ldr	r3, [r7, #4]
 80083e2:	683a      	ldr	r2, [r7, #0]
 80083e4:	605a      	str	r2, [r3, #4]
}
 80083e6:	bf00      	nop
 80083e8:	370c      	adds	r7, #12
 80083ea:	46bd      	mov	sp, r7
 80083ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80083f0:	4770      	bx	lr

080083f2 <LOS_ListTailInsert>:
{
 80083f2:	b580      	push	{r7, lr}
 80083f4:	b082      	sub	sp, #8
 80083f6:	af00      	add	r7, sp, #0
 80083f8:	6078      	str	r0, [r7, #4]
 80083fa:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 80083fc:	687b      	ldr	r3, [r7, #4]
 80083fe:	681b      	ldr	r3, [r3, #0]
 8008400:	6839      	ldr	r1, [r7, #0]
 8008402:	4618      	mov	r0, r3
 8008404:	f7ff ffdc 	bl	80083c0 <LOS_ListAdd>
}
 8008408:	bf00      	nop
 800840a:	3708      	adds	r7, #8
 800840c:	46bd      	mov	sp, r7
 800840e:	bd80      	pop	{r7, pc}

08008410 <LOS_ListHeadInsert>:
{
 8008410:	b580      	push	{r7, lr}
 8008412:	b082      	sub	sp, #8
 8008414:	af00      	add	r7, sp, #0
 8008416:	6078      	str	r0, [r7, #4]
 8008418:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list, node);
 800841a:	6839      	ldr	r1, [r7, #0]
 800841c:	6878      	ldr	r0, [r7, #4]
 800841e:	f7ff ffcf 	bl	80083c0 <LOS_ListAdd>
}
 8008422:	bf00      	nop
 8008424:	3708      	adds	r7, #8
 8008426:	46bd      	mov	sp, r7
 8008428:	bd80      	pop	{r7, pc}

0800842a <LOS_ListDelete>:
{
 800842a:	b480      	push	{r7}
 800842c:	b083      	sub	sp, #12
 800842e:	af00      	add	r7, sp, #0
 8008430:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8008432:	687b      	ldr	r3, [r7, #4]
 8008434:	685b      	ldr	r3, [r3, #4]
 8008436:	687a      	ldr	r2, [r7, #4]
 8008438:	6812      	ldr	r2, [r2, #0]
 800843a:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 800843c:	687b      	ldr	r3, [r7, #4]
 800843e:	681b      	ldr	r3, [r3, #0]
 8008440:	687a      	ldr	r2, [r7, #4]
 8008442:	6852      	ldr	r2, [r2, #4]
 8008444:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8008446:	687b      	ldr	r3, [r7, #4]
 8008448:	2200      	movs	r2, #0
 800844a:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 800844c:	687b      	ldr	r3, [r7, #4]
 800844e:	2200      	movs	r2, #0
 8008450:	601a      	str	r2, [r3, #0]
}
 8008452:	bf00      	nop
 8008454:	370c      	adds	r7, #12
 8008456:	46bd      	mov	sp, r7
 8008458:	f85d 7b04 	ldr.w	r7, [sp], #4
 800845c:	4770      	bx	lr

0800845e <LOS_ListEmpty>:
{
 800845e:	b480      	push	{r7}
 8008460:	b083      	sub	sp, #12
 8008462:	af00      	add	r7, sp, #0
 8008464:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8008466:	687b      	ldr	r3, [r7, #4]
 8008468:	685b      	ldr	r3, [r3, #4]
 800846a:	687a      	ldr	r2, [r7, #4]
 800846c:	429a      	cmp	r2, r3
 800846e:	bf0c      	ite	eq
 8008470:	2301      	moveq	r3, #1
 8008472:	2300      	movne	r3, #0
 8008474:	b2db      	uxtb	r3, r3
}
 8008476:	4618      	mov	r0, r3
 8008478:	370c      	adds	r7, #12
 800847a:	46bd      	mov	sp, r7
 800847c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008480:	4770      	bx	lr

08008482 <ArchIntLocked>:
extern UINT32 ArchIntLock(VOID);
extern UINT32 ArchIntUnlock(VOID);
extern VOID ArchIntRestore(UINT32 intSave);

STATIC INLINE UINT32 ArchIntLocked(VOID)
{
 8008482:	b480      	push	{r7}
 8008484:	b083      	sub	sp, #12
 8008486:	af00      	add	r7, sp, #0
    UINT32 intSave;

    __asm__ volatile("mrs %0, primask" : "=r" (intSave) : : "memory");
 8008488:	f3ef 8310 	mrs	r3, PRIMASK
 800848c:	607b      	str	r3, [r7, #4]

    return intSave;
 800848e:	687b      	ldr	r3, [r7, #4]
}
 8008490:	4618      	mov	r0, r3
 8008492:	370c      	adds	r7, #12
 8008494:	46bd      	mov	sp, r7
 8008496:	f85d 7b04 	ldr.w	r7, [sp], #4
 800849a:	4770      	bx	lr

0800849c <LOS_IntLock>:
{
 800849c:	b580      	push	{r7, lr}
 800849e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80084a0:	f7f8 fc12 	bl	8000cc8 <ArchIntLock>
 80084a4:	4603      	mov	r3, r0
}
 80084a6:	4618      	mov	r0, r3
 80084a8:	bd80      	pop	{r7, pc}

080084aa <LOS_SpinHeld>:
{
 80084aa:	b480      	push	{r7}
 80084ac:	b083      	sub	sp, #12
 80084ae:	af00      	add	r7, sp, #0
 80084b0:	6078      	str	r0, [r7, #4]
    return TRUE;
 80084b2:	2301      	movs	r3, #1
}
 80084b4:	4618      	mov	r0, r3
 80084b6:	370c      	adds	r7, #12
 80084b8:	46bd      	mov	sp, r7
 80084ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80084be:	4770      	bx	lr

080084c0 <OsPriQueueInit>:

LITE_OS_SEC_BSS LOS_DL_LIST *g_priQueueList = NULL;
STATIC LITE_OS_SEC_BSS UINT32 g_priQueueBitmap;

UINT32 OsPriQueueInit(VOID)
{
 80084c0:	b580      	push	{r7, lr}
 80084c2:	b082      	sub	sp, #8
 80084c4:	af00      	add	r7, sp, #0
    UINT32 priority;

    /* system resident resource */
    g_priQueueList = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, (OS_PRIORITY_QUEUE_NUM * sizeof(LOS_DL_LIST)));
 80084c6:	4b13      	ldr	r3, [pc, #76]	; (8008514 <OsPriQueueInit+0x54>)
 80084c8:	681b      	ldr	r3, [r3, #0]
 80084ca:	f44f 7180 	mov.w	r1, #256	; 0x100
 80084ce:	4618      	mov	r0, r3
 80084d0:	f000 fa6a 	bl	80089a8 <LOS_MemAlloc>
 80084d4:	4603      	mov	r3, r0
 80084d6:	4a10      	ldr	r2, [pc, #64]	; (8008518 <OsPriQueueInit+0x58>)
 80084d8:	6013      	str	r3, [r2, #0]
    if (g_priQueueList == NULL) {
 80084da:	4b0f      	ldr	r3, [pc, #60]	; (8008518 <OsPriQueueInit+0x58>)
 80084dc:	681b      	ldr	r3, [r3, #0]
 80084de:	2b00      	cmp	r3, #0
 80084e0:	d101      	bne.n	80084e6 <OsPriQueueInit+0x26>
        return LOS_NOK;
 80084e2:	2301      	movs	r3, #1
 80084e4:	e011      	b.n	800850a <OsPriQueueInit+0x4a>
    }

    for (priority = 0; priority < OS_PRIORITY_QUEUE_NUM; ++priority) {
 80084e6:	2300      	movs	r3, #0
 80084e8:	607b      	str	r3, [r7, #4]
 80084ea:	e00a      	b.n	8008502 <OsPriQueueInit+0x42>
        LOS_ListInit(&g_priQueueList[priority]);
 80084ec:	4b0a      	ldr	r3, [pc, #40]	; (8008518 <OsPriQueueInit+0x58>)
 80084ee:	681a      	ldr	r2, [r3, #0]
 80084f0:	687b      	ldr	r3, [r7, #4]
 80084f2:	00db      	lsls	r3, r3, #3
 80084f4:	4413      	add	r3, r2
 80084f6:	4618      	mov	r0, r3
 80084f8:	f7ff ff52 	bl	80083a0 <LOS_ListInit>
    for (priority = 0; priority < OS_PRIORITY_QUEUE_NUM; ++priority) {
 80084fc:	687b      	ldr	r3, [r7, #4]
 80084fe:	3301      	adds	r3, #1
 8008500:	607b      	str	r3, [r7, #4]
 8008502:	687b      	ldr	r3, [r7, #4]
 8008504:	2b1f      	cmp	r3, #31
 8008506:	d9f1      	bls.n	80084ec <OsPriQueueInit+0x2c>
    }

    return LOS_OK;
 8008508:	2300      	movs	r3, #0
}
 800850a:	4618      	mov	r0, r3
 800850c:	3708      	adds	r7, #8
 800850e:	46bd      	mov	sp, r7
 8008510:	bd80      	pop	{r7, pc}
 8008512:	bf00      	nop
 8008514:	200021b4 	.word	0x200021b4
 8008518:	200021a8 	.word	0x200021a8

0800851c <OsPriQueueEnqueueHead>:

VOID OsPriQueueEnqueueHead(LOS_DL_LIST *priqueueItem, UINT32 priority)
{
 800851c:	b580      	push	{r7, lr}
 800851e:	b082      	sub	sp, #8
 8008520:	af00      	add	r7, sp, #0
 8008522:	6078      	str	r0, [r7, #4]
 8008524:	6039      	str	r1, [r7, #0]
    /*
     * Task control blocks are initd as zero. And when task is deleted,
     * and at the same time would be deleted from priority queue or
     * other lists, task pend node will restored as zero.
     */
    LOS_ASSERT(priqueueItem->pstNext == NULL);
 8008526:	687b      	ldr	r3, [r7, #4]
 8008528:	685b      	ldr	r3, [r3, #4]
 800852a:	2b00      	cmp	r3, #0
 800852c:	d00b      	beq.n	8008546 <OsPriQueueEnqueueHead+0x2a>
 800852e:	f7ff ffb5 	bl	800849c <LOS_IntLock>
 8008532:	4815      	ldr	r0, [pc, #84]	; (8008588 <OsPriQueueEnqueueHead+0x6c>)
 8008534:	f7fc f8ca 	bl	80046cc <dprintf>
 8008538:	4b14      	ldr	r3, [pc, #80]	; (800858c <OsPriQueueEnqueueHead+0x70>)
 800853a:	2247      	movs	r2, #71	; 0x47
 800853c:	4914      	ldr	r1, [pc, #80]	; (8008590 <OsPriQueueEnqueueHead+0x74>)
 800853e:	4815      	ldr	r0, [pc, #84]	; (8008594 <OsPriQueueEnqueueHead+0x78>)
 8008540:	f7fc f8c4 	bl	80046cc <dprintf>
 8008544:	e7fe      	b.n	8008544 <OsPriQueueEnqueueHead+0x28>

    if (LOS_ListEmpty(&g_priQueueList[priority])) {
 8008546:	4b14      	ldr	r3, [pc, #80]	; (8008598 <OsPriQueueEnqueueHead+0x7c>)
 8008548:	681a      	ldr	r2, [r3, #0]
 800854a:	683b      	ldr	r3, [r7, #0]
 800854c:	00db      	lsls	r3, r3, #3
 800854e:	4413      	add	r3, r2
 8008550:	4618      	mov	r0, r3
 8008552:	f7ff ff84 	bl	800845e <LOS_ListEmpty>
 8008556:	4603      	mov	r3, r0
 8008558:	2b00      	cmp	r3, #0
 800855a:	d008      	beq.n	800856e <OsPriQueueEnqueueHead+0x52>
        g_priQueueBitmap |= PRIQUEUE_PRIOR0_BIT >> priority;
 800855c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8008560:	683b      	ldr	r3, [r7, #0]
 8008562:	40da      	lsrs	r2, r3
 8008564:	4b0d      	ldr	r3, [pc, #52]	; (800859c <OsPriQueueEnqueueHead+0x80>)
 8008566:	681b      	ldr	r3, [r3, #0]
 8008568:	4313      	orrs	r3, r2
 800856a:	4a0c      	ldr	r2, [pc, #48]	; (800859c <OsPriQueueEnqueueHead+0x80>)
 800856c:	6013      	str	r3, [r2, #0]
    }

    LOS_ListHeadInsert(&g_priQueueList[priority], priqueueItem);
 800856e:	4b0a      	ldr	r3, [pc, #40]	; (8008598 <OsPriQueueEnqueueHead+0x7c>)
 8008570:	681a      	ldr	r2, [r3, #0]
 8008572:	683b      	ldr	r3, [r7, #0]
 8008574:	00db      	lsls	r3, r3, #3
 8008576:	4413      	add	r3, r2
 8008578:	6879      	ldr	r1, [r7, #4]
 800857a:	4618      	mov	r0, r3
 800857c:	f7ff ff48 	bl	8008410 <LOS_ListHeadInsert>
}
 8008580:	bf00      	nop
 8008582:	3708      	adds	r7, #8
 8008584:	46bd      	mov	sp, r7
 8008586:	bd80      	pop	{r7, pc}
 8008588:	08021334 	.word	0x08021334
 800858c:	08023388 	.word	0x08023388
 8008590:	0802133c 	.word	0x0802133c
 8008594:	0802135c 	.word	0x0802135c
 8008598:	200021a8 	.word	0x200021a8
 800859c:	200021ac 	.word	0x200021ac

080085a0 <OsPriQueueEnqueue>:

VOID OsPriQueueEnqueue(LOS_DL_LIST *priqueueItem, UINT32 priority)
{
 80085a0:	b580      	push	{r7, lr}
 80085a2:	b082      	sub	sp, #8
 80085a4:	af00      	add	r7, sp, #0
 80085a6:	6078      	str	r0, [r7, #4]
 80085a8:	6039      	str	r1, [r7, #0]
    /*
     * Task control blocks are initd as zero. And when task is deleted,
     * and at the same time would be deleted from priority queue or
     * other lists, task pend node will restored as zero.
     */
    LOS_ASSERT(priqueueItem->pstNext == NULL);
 80085aa:	687b      	ldr	r3, [r7, #4]
 80085ac:	685b      	ldr	r3, [r3, #4]
 80085ae:	2b00      	cmp	r3, #0
 80085b0:	d00b      	beq.n	80085ca <OsPriQueueEnqueue+0x2a>
 80085b2:	f7ff ff73 	bl	800849c <LOS_IntLock>
 80085b6:	4815      	ldr	r0, [pc, #84]	; (800860c <OsPriQueueEnqueue+0x6c>)
 80085b8:	f7fc f888 	bl	80046cc <dprintf>
 80085bc:	4b14      	ldr	r3, [pc, #80]	; (8008610 <OsPriQueueEnqueue+0x70>)
 80085be:	2257      	movs	r2, #87	; 0x57
 80085c0:	4914      	ldr	r1, [pc, #80]	; (8008614 <OsPriQueueEnqueue+0x74>)
 80085c2:	4815      	ldr	r0, [pc, #84]	; (8008618 <OsPriQueueEnqueue+0x78>)
 80085c4:	f7fc f882 	bl	80046cc <dprintf>
 80085c8:	e7fe      	b.n	80085c8 <OsPriQueueEnqueue+0x28>

    if (LOS_ListEmpty(&g_priQueueList[priority])) {
 80085ca:	4b14      	ldr	r3, [pc, #80]	; (800861c <OsPriQueueEnqueue+0x7c>)
 80085cc:	681a      	ldr	r2, [r3, #0]
 80085ce:	683b      	ldr	r3, [r7, #0]
 80085d0:	00db      	lsls	r3, r3, #3
 80085d2:	4413      	add	r3, r2
 80085d4:	4618      	mov	r0, r3
 80085d6:	f7ff ff42 	bl	800845e <LOS_ListEmpty>
 80085da:	4603      	mov	r3, r0
 80085dc:	2b00      	cmp	r3, #0
 80085de:	d008      	beq.n	80085f2 <OsPriQueueEnqueue+0x52>
        g_priQueueBitmap |= PRIQUEUE_PRIOR0_BIT >> priority;
 80085e0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 80085e4:	683b      	ldr	r3, [r7, #0]
 80085e6:	40da      	lsrs	r2, r3
 80085e8:	4b0d      	ldr	r3, [pc, #52]	; (8008620 <OsPriQueueEnqueue+0x80>)
 80085ea:	681b      	ldr	r3, [r3, #0]
 80085ec:	4313      	orrs	r3, r2
 80085ee:	4a0c      	ldr	r2, [pc, #48]	; (8008620 <OsPriQueueEnqueue+0x80>)
 80085f0:	6013      	str	r3, [r2, #0]
    }

    LOS_ListTailInsert(&g_priQueueList[priority], priqueueItem);
 80085f2:	4b0a      	ldr	r3, [pc, #40]	; (800861c <OsPriQueueEnqueue+0x7c>)
 80085f4:	681a      	ldr	r2, [r3, #0]
 80085f6:	683b      	ldr	r3, [r7, #0]
 80085f8:	00db      	lsls	r3, r3, #3
 80085fa:	4413      	add	r3, r2
 80085fc:	6879      	ldr	r1, [r7, #4]
 80085fe:	4618      	mov	r0, r3
 8008600:	f7ff fef7 	bl	80083f2 <LOS_ListTailInsert>
}
 8008604:	bf00      	nop
 8008606:	3708      	adds	r7, #8
 8008608:	46bd      	mov	sp, r7
 800860a:	bd80      	pop	{r7, pc}
 800860c:	08021334 	.word	0x08021334
 8008610:	080233a0 	.word	0x080233a0
 8008614:	0802133c 	.word	0x0802133c
 8008618:	0802135c 	.word	0x0802135c
 800861c:	200021a8 	.word	0x200021a8
 8008620:	200021ac 	.word	0x200021ac

08008624 <OsPriQueueDequeue>:

VOID OsPriQueueDequeue(LOS_DL_LIST *priqueueItem)
{
 8008624:	b580      	push	{r7, lr}
 8008626:	b084      	sub	sp, #16
 8008628:	af00      	add	r7, sp, #0
 800862a:	6078      	str	r0, [r7, #4]
    LosTaskCB *runTask = NULL;
 800862c:	2300      	movs	r3, #0
 800862e:	60fb      	str	r3, [r7, #12]
    LOS_ListDelete(priqueueItem);
 8008630:	6878      	ldr	r0, [r7, #4]
 8008632:	f7ff fefa 	bl	800842a <LOS_ListDelete>

    runTask = LOS_DL_LIST_ENTRY(priqueueItem, LosTaskCB, pendList);
 8008636:	687b      	ldr	r3, [r7, #4]
 8008638:	3b40      	subs	r3, #64	; 0x40
 800863a:	60fb      	str	r3, [r7, #12]
    if (LOS_ListEmpty(&g_priQueueList[runTask->priority])) {
 800863c:	4b0d      	ldr	r3, [pc, #52]	; (8008674 <OsPriQueueDequeue+0x50>)
 800863e:	681a      	ldr	r2, [r3, #0]
 8008640:	68fb      	ldr	r3, [r7, #12]
 8008642:	88db      	ldrh	r3, [r3, #6]
 8008644:	00db      	lsls	r3, r3, #3
 8008646:	4413      	add	r3, r2
 8008648:	4618      	mov	r0, r3
 800864a:	f7ff ff08 	bl	800845e <LOS_ListEmpty>
 800864e:	4603      	mov	r3, r0
 8008650:	2b00      	cmp	r3, #0
 8008652:	d00b      	beq.n	800866c <OsPriQueueDequeue+0x48>
        g_priQueueBitmap &= ~(PRIQUEUE_PRIOR0_BIT >> runTask->priority);
 8008654:	68fb      	ldr	r3, [r7, #12]
 8008656:	88db      	ldrh	r3, [r3, #6]
 8008658:	461a      	mov	r2, r3
 800865a:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800865e:	40d3      	lsrs	r3, r2
 8008660:	43da      	mvns	r2, r3
 8008662:	4b05      	ldr	r3, [pc, #20]	; (8008678 <OsPriQueueDequeue+0x54>)
 8008664:	681b      	ldr	r3, [r3, #0]
 8008666:	4013      	ands	r3, r2
 8008668:	4a03      	ldr	r2, [pc, #12]	; (8008678 <OsPriQueueDequeue+0x54>)
 800866a:	6013      	str	r3, [r2, #0]
    }
}
 800866c:	bf00      	nop
 800866e:	3710      	adds	r7, #16
 8008670:	46bd      	mov	sp, r7
 8008672:	bd80      	pop	{r7, pc}
 8008674:	200021a8 	.word	0x200021a8
 8008678:	200021ac 	.word	0x200021ac

0800867c <OsPriQueueSize>:

    return NULL;
}

UINT32 OsPriQueueSize(UINT32 priority)
{
 800867c:	b580      	push	{r7, lr}
 800867e:	b084      	sub	sp, #16
 8008680:	af00      	add	r7, sp, #0
 8008682:	6078      	str	r0, [r7, #4]
    UINT32 itemCnt = 0;
 8008684:	2300      	movs	r3, #0
 8008686:	60bb      	str	r3, [r7, #8]
    LOS_DL_LIST *curNode = NULL;
 8008688:	2300      	movs	r3, #0
 800868a:	60fb      	str	r3, [r7, #12]
#ifdef LOSCFG_KERNEL_SMP
    LosTaskCB *task = NULL;
    UINT32 cpuId = ArchCurrCpuid();
#endif

    LOS_ASSERT(ArchIntLocked());
 800868c:	f7ff fef9 	bl	8008482 <ArchIntLocked>
 8008690:	4603      	mov	r3, r0
 8008692:	2b00      	cmp	r3, #0
 8008694:	d10b      	bne.n	80086ae <OsPriQueueSize+0x32>
 8008696:	f7ff ff01 	bl	800849c <LOS_IntLock>
 800869a:	481b      	ldr	r0, [pc, #108]	; (8008708 <OsPriQueueSize+0x8c>)
 800869c:	f7fc f816 	bl	80046cc <dprintf>
 80086a0:	4b1a      	ldr	r3, [pc, #104]	; (800870c <OsPriQueueSize+0x90>)
 80086a2:	2280      	movs	r2, #128	; 0x80
 80086a4:	491a      	ldr	r1, [pc, #104]	; (8008710 <OsPriQueueSize+0x94>)
 80086a6:	481b      	ldr	r0, [pc, #108]	; (8008714 <OsPriQueueSize+0x98>)
 80086a8:	f7fc f810 	bl	80046cc <dprintf>
 80086ac:	e7fe      	b.n	80086ac <OsPriQueueSize+0x30>
    LOS_ASSERT(LOS_SpinHeld(&g_taskSpin));
 80086ae:	481a      	ldr	r0, [pc, #104]	; (8008718 <OsPriQueueSize+0x9c>)
 80086b0:	f7ff fefb 	bl	80084aa <LOS_SpinHeld>
 80086b4:	4603      	mov	r3, r0
 80086b6:	2b00      	cmp	r3, #0
 80086b8:	d10b      	bne.n	80086d2 <OsPriQueueSize+0x56>
 80086ba:	f7ff feef 	bl	800849c <LOS_IntLock>
 80086be:	4812      	ldr	r0, [pc, #72]	; (8008708 <OsPriQueueSize+0x8c>)
 80086c0:	f7fc f804 	bl	80046cc <dprintf>
 80086c4:	4b11      	ldr	r3, [pc, #68]	; (800870c <OsPriQueueSize+0x90>)
 80086c6:	2281      	movs	r2, #129	; 0x81
 80086c8:	4911      	ldr	r1, [pc, #68]	; (8008710 <OsPriQueueSize+0x94>)
 80086ca:	4812      	ldr	r0, [pc, #72]	; (8008714 <OsPriQueueSize+0x98>)
 80086cc:	f7fb fffe 	bl	80046cc <dprintf>
 80086d0:	e7fe      	b.n	80086d0 <OsPriQueueSize+0x54>

    LOS_DL_LIST_FOR_EACH(curNode, &g_priQueueList[priority]) {
 80086d2:	4b12      	ldr	r3, [pc, #72]	; (800871c <OsPriQueueSize+0xa0>)
 80086d4:	681a      	ldr	r2, [r3, #0]
 80086d6:	687b      	ldr	r3, [r7, #4]
 80086d8:	00db      	lsls	r3, r3, #3
 80086da:	4413      	add	r3, r2
 80086dc:	685b      	ldr	r3, [r3, #4]
 80086de:	60fb      	str	r3, [r7, #12]
 80086e0:	e005      	b.n	80086ee <OsPriQueueSize+0x72>
        task = OS_TCB_FROM_PENDLIST(curNode);
        if (!(task->cpuAffiMask & (1U << cpuId))) {
            continue;
        }
#endif
        ++itemCnt;
 80086e2:	68bb      	ldr	r3, [r7, #8]
 80086e4:	3301      	adds	r3, #1
 80086e6:	60bb      	str	r3, [r7, #8]
    LOS_DL_LIST_FOR_EACH(curNode, &g_priQueueList[priority]) {
 80086e8:	68fb      	ldr	r3, [r7, #12]
 80086ea:	685b      	ldr	r3, [r3, #4]
 80086ec:	60fb      	str	r3, [r7, #12]
 80086ee:	4b0b      	ldr	r3, [pc, #44]	; (800871c <OsPriQueueSize+0xa0>)
 80086f0:	681a      	ldr	r2, [r3, #0]
 80086f2:	687b      	ldr	r3, [r7, #4]
 80086f4:	00db      	lsls	r3, r3, #3
 80086f6:	4413      	add	r3, r2
 80086f8:	68fa      	ldr	r2, [r7, #12]
 80086fa:	429a      	cmp	r2, r3
 80086fc:	d1f1      	bne.n	80086e2 <OsPriQueueSize+0x66>
    }

    return itemCnt;
 80086fe:	68bb      	ldr	r3, [r7, #8]
}
 8008700:	4618      	mov	r0, r3
 8008702:	3710      	adds	r7, #16
 8008704:	46bd      	mov	sp, r7
 8008706:	bd80      	pop	{r7, pc}
 8008708:	08021334 	.word	0x08021334
 800870c:	080233b4 	.word	0x080233b4
 8008710:	0802133c 	.word	0x0802133c
 8008714:	0802135c 	.word	0x0802135c
 8008718:	20000764 	.word	0x20000764
 800871c:	200021a8 	.word	0x200021a8

08008720 <OsGetTopTask>:

LITE_OS_SEC_TEXT_MINOR LosTaskCB *OsGetTopTask(VOID)
{
 8008720:	b580      	push	{r7, lr}
 8008722:	b084      	sub	sp, #16
 8008724:	af00      	add	r7, sp, #0
    UINT32 priority;
    UINT32 bitmap;
    LosTaskCB *newTask = NULL;
 8008726:	2300      	movs	r3, #0
 8008728:	60bb      	str	r3, [r7, #8]
#ifdef LOSCFG_KERNEL_SMP
    UINT32 cpuid = ArchCurrCpuid();
#endif

    bitmap = g_priQueueBitmap;
 800872a:	4b19      	ldr	r3, [pc, #100]	; (8008790 <OsGetTopTask+0x70>)
 800872c:	681b      	ldr	r3, [r3, #0]
 800872e:	607b      	str	r3, [r7, #4]

    while (bitmap) {
 8008730:	e025      	b.n	800877e <OsGetTopTask+0x5e>
        priority = CLZ(bitmap);
 8008732:	687b      	ldr	r3, [r7, #4]
 8008734:	fab3 f383 	clz	r3, r3
 8008738:	60fb      	str	r3, [r7, #12]
        LOS_DL_LIST_FOR_EACH_ENTRY(newTask, &g_priQueueList[priority], LosTaskCB, pendList) {
 800873a:	4b16      	ldr	r3, [pc, #88]	; (8008794 <OsGetTopTask+0x74>)
 800873c:	681a      	ldr	r2, [r3, #0]
 800873e:	68fb      	ldr	r3, [r7, #12]
 8008740:	00db      	lsls	r3, r3, #3
 8008742:	4413      	add	r3, r2
 8008744:	685b      	ldr	r3, [r3, #4]
 8008746:	3b40      	subs	r3, #64	; 0x40
 8008748:	60bb      	str	r3, [r7, #8]
 800874a:	bf00      	nop
 800874c:	68bb      	ldr	r3, [r7, #8]
 800874e:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8008752:	4b10      	ldr	r3, [pc, #64]	; (8008794 <OsGetTopTask+0x74>)
 8008754:	6819      	ldr	r1, [r3, #0]
 8008756:	68fb      	ldr	r3, [r7, #12]
 8008758:	00db      	lsls	r3, r3, #3
 800875a:	440b      	add	r3, r1
 800875c:	429a      	cmp	r2, r3
 800875e:	d005      	beq.n	800876c <OsGetTopTask+0x4c>
#ifdef LOSCFG_KERNEL_SMP
            if (newTask->cpuAffiMask & (1U << cpuid)) {
#endif
                OsPriQueueDequeue(&newTask->pendList);
 8008760:	68bb      	ldr	r3, [r7, #8]
 8008762:	3340      	adds	r3, #64	; 0x40
 8008764:	4618      	mov	r0, r3
 8008766:	f7ff ff5d 	bl	8008624 <OsPriQueueDequeue>
                goto OUT;
 800876a:	e00c      	b.n	8008786 <OsGetTopTask+0x66>
#ifdef LOSCFG_KERNEL_SMP
            }
#endif
        }
        bitmap &= ~(1U << (OS_PRIORITY_QUEUE_NUM - priority - 1));
 800876c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8008770:	68fb      	ldr	r3, [r7, #12]
 8008772:	fa22 f303 	lsr.w	r3, r2, r3
 8008776:	43db      	mvns	r3, r3
 8008778:	687a      	ldr	r2, [r7, #4]
 800877a:	4013      	ands	r3, r2
 800877c:	607b      	str	r3, [r7, #4]
    while (bitmap) {
 800877e:	687b      	ldr	r3, [r7, #4]
 8008780:	2b00      	cmp	r3, #0
 8008782:	d1d6      	bne.n	8008732 <OsGetTopTask+0x12>
    }

OUT:
 8008784:	bf00      	nop
    return newTask;
 8008786:	68bb      	ldr	r3, [r7, #8]
}
 8008788:	4618      	mov	r0, r3
 800878a:	3710      	adds	r7, #16
 800878c:	46bd      	mov	sp, r7
 800878e:	bd80      	pop	{r7, pc}
 8008790:	200021ac 	.word	0x200021ac
 8008794:	200021a8 	.word	0x200021a8

08008798 <OsSlabMemInit>:
extern VOID *OsSlabCtrlHdrGet(const VOID *pool);

#else /* !LOSCFG_KERNEL_MEM_SLAB_EXTENTION */

STATIC INLINE VOID OsSlabMemInit(VOID *pool, UINT32 size)
{
 8008798:	b480      	push	{r7}
 800879a:	b083      	sub	sp, #12
 800879c:	af00      	add	r7, sp, #0
 800879e:	6078      	str	r0, [r7, #4]
 80087a0:	6039      	str	r1, [r7, #0]
}
 80087a2:	bf00      	nop
 80087a4:	370c      	adds	r7, #12
 80087a6:	46bd      	mov	sp, r7
 80087a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80087ac:	4770      	bx	lr

080087ae <OsSlabMemAlloc>:
STATIC INLINE VOID OsSlabMemDeinit(VOID *pool)
{
}

STATIC INLINE VOID *OsSlabMemAlloc(VOID *pool, UINT32 size)
{
 80087ae:	b480      	push	{r7}
 80087b0:	b083      	sub	sp, #12
 80087b2:	af00      	add	r7, sp, #0
 80087b4:	6078      	str	r0, [r7, #4]
 80087b6:	6039      	str	r1, [r7, #0]
    return NULL;
 80087b8:	2300      	movs	r3, #0
}
 80087ba:	4618      	mov	r0, r3
 80087bc:	370c      	adds	r7, #12
 80087be:	46bd      	mov	sp, r7
 80087c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80087c4:	4770      	bx	lr

080087c6 <OsSlabMemFree>:

STATIC INLINE BOOL OsSlabMemFree(VOID *pool, VOID *ptr)
{
 80087c6:	b480      	push	{r7}
 80087c8:	b083      	sub	sp, #12
 80087ca:	af00      	add	r7, sp, #0
 80087cc:	6078      	str	r0, [r7, #4]
 80087ce:	6039      	str	r1, [r7, #0]
    return FALSE;
 80087d0:	2300      	movs	r3, #0
}
 80087d2:	4618      	mov	r0, r3
 80087d4:	370c      	adds	r7, #12
 80087d6:	46bd      	mov	sp, r7
 80087d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80087dc:	4770      	bx	lr

080087de <LOS_IntLock>:
{
 80087de:	b580      	push	{r7, lr}
 80087e0:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80087e2:	f7f8 fa71 	bl	8000cc8 <ArchIntLock>
 80087e6:	4603      	mov	r3, r0
}
 80087e8:	4618      	mov	r0, r3
 80087ea:	bd80      	pop	{r7, pc}

080087ec <LOS_IntRestore>:
{
 80087ec:	b580      	push	{r7, lr}
 80087ee:	b082      	sub	sp, #8
 80087f0:	af00      	add	r7, sp, #0
 80087f2:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80087f4:	6878      	ldr	r0, [r7, #4]
 80087f6:	f7f8 fa6f 	bl	8000cd8 <ArchIntRestore>
}
 80087fa:	bf00      	nop
 80087fc:	3708      	adds	r7, #8
 80087fe:	46bd      	mov	sp, r7
 8008800:	bd80      	pop	{r7, pc}

08008802 <LOS_SpinLockSave>:
{
 8008802:	b580      	push	{r7, lr}
 8008804:	b082      	sub	sp, #8
 8008806:	af00      	add	r7, sp, #0
 8008808:	6078      	str	r0, [r7, #4]
 800880a:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 800880c:	f7ff ffe7 	bl	80087de <LOS_IntLock>
 8008810:	4602      	mov	r2, r0
 8008812:	683b      	ldr	r3, [r7, #0]
 8008814:	601a      	str	r2, [r3, #0]
}
 8008816:	bf00      	nop
 8008818:	3708      	adds	r7, #8
 800881a:	46bd      	mov	sp, r7
 800881c:	bd80      	pop	{r7, pc}

0800881e <LOS_SpinUnlockRestore>:
{
 800881e:	b580      	push	{r7, lr}
 8008820:	b082      	sub	sp, #8
 8008822:	af00      	add	r7, sp, #0
 8008824:	6078      	str	r0, [r7, #4]
 8008826:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8008828:	6838      	ldr	r0, [r7, #0]
 800882a:	f7ff ffdf 	bl	80087ec <LOS_IntRestore>
}
 800882e:	bf00      	nop
 8008830:	3708      	adds	r7, #8
 8008832:	46bd      	mov	sp, r7
 8008834:	bd80      	pop	{r7, pc}

08008836 <OsMemMulPoolInit>:
extern UINT32 OsMemMulPoolInit(VOID *pool, UINT32 size);
extern UINT32 OsMemMulPoolDeinit(const VOID *pool);
extern VOID *OsMemMulPoolHeadGet(VOID);
#else /* LOSCFG_MEM_MUL_POOL */
STATIC INLINE UINT32 OsMemMulPoolInit(VOID *pool, UINT32 size)
{
 8008836:	b480      	push	{r7}
 8008838:	b083      	sub	sp, #12
 800883a:	af00      	add	r7, sp, #0
 800883c:	6078      	str	r0, [r7, #4]
 800883e:	6039      	str	r1, [r7, #0]
    return LOS_OK;
 8008840:	2300      	movs	r3, #0
}
 8008842:	4618      	mov	r0, r3
 8008844:	370c      	adds	r7, #12
 8008846:	46bd      	mov	sp, r7
 8008848:	f85d 7b04 	ldr.w	r7, [sp], #4
 800884c:	4770      	bx	lr

0800884e <OsMemMulPoolDeinit>:

STATIC INLINE UINT32 OsMemMulPoolDeinit(const VOID *pool)
{
 800884e:	b480      	push	{r7}
 8008850:	b083      	sub	sp, #12
 8008852:	af00      	add	r7, sp, #0
 8008854:	6078      	str	r0, [r7, #4]
    return LOS_OK;
 8008856:	2300      	movs	r3, #0
}
 8008858:	4618      	mov	r0, r3
 800885a:	370c      	adds	r7, #12
 800885c:	46bd      	mov	sp, r7
 800885e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008862:	4770      	bx	lr

08008864 <LOS_MemInit>:
#ifdef LOSCFG_EXC_INTERACTION
__attribute__((section(".data.init"))) UINTPTR g_excInteractMemSize = 0;
#endif

LITE_OS_SEC_TEXT_INIT UINT32 LOS_MemInit(VOID *pool, UINT32 size)
{
 8008864:	b590      	push	{r4, r7, lr}
 8008866:	b089      	sub	sp, #36	; 0x24
 8008868:	af00      	add	r7, sp, #0
 800886a:	6078      	str	r0, [r7, #4]
 800886c:	6039      	str	r1, [r7, #0]
 800886e:	4b38      	ldr	r3, [pc, #224]	; (8008950 <LOS_MemInit+0xec>)
 8008870:	681b      	ldr	r3, [r3, #0]
 8008872:	61fb      	str	r3, [r7, #28]
 8008874:	f04f 0300 	mov.w	r3, #0
    UINT32 ret = LOS_NOK;
 8008878:	2301      	movs	r3, #1
 800887a:	60fb      	str	r3, [r7, #12]
    UINT32 intSave;

    if ((pool == NULL) || (size <= sizeof(struct LosHeapManager))) {
 800887c:	687b      	ldr	r3, [r7, #4]
 800887e:	2b00      	cmp	r3, #0
 8008880:	d002      	beq.n	8008888 <LOS_MemInit+0x24>
 8008882:	683b      	ldr	r3, [r7, #0]
 8008884:	2b9c      	cmp	r3, #156	; 0x9c
 8008886:	d801      	bhi.n	800888c <LOS_MemInit+0x28>
        return ret;
 8008888:	68fb      	ldr	r3, [r7, #12]
 800888a:	e055      	b.n	8008938 <LOS_MemInit+0xd4>
    }

    if (!IS_ALIGNED(size, OS_MEM_ALIGN_SIZE) || !IS_ALIGNED(pool, OS_MEM_ALIGN_SIZE)) {
 800888c:	683b      	ldr	r3, [r7, #0]
 800888e:	f003 0303 	and.w	r3, r3, #3
 8008892:	2b00      	cmp	r3, #0
 8008894:	d104      	bne.n	80088a0 <LOS_MemInit+0x3c>
 8008896:	687b      	ldr	r3, [r7, #4]
 8008898:	f003 0303 	and.w	r3, r3, #3
 800889c:	2b00      	cmp	r3, #0
 800889e:	d005      	beq.n	80088ac <LOS_MemInit+0x48>
        PRINT_WARN("pool [%p, %p) size 0x%x should be aligned with OS_MEM_ALIGN_SIZE\n",
                   pool, (UINTPTR)pool + size, size);
        size = OS_MEM_ALIGN(size, OS_MEM_ALIGN_SIZE) - OS_MEM_ALIGN_SIZE;
 80088a0:	683b      	ldr	r3, [r7, #0]
 80088a2:	3303      	adds	r3, #3
 80088a4:	f023 0303 	bic.w	r3, r3, #3
 80088a8:	3b04      	subs	r3, #4
 80088aa:	603b      	str	r3, [r7, #0]
    }

    MEM_LOCK(intSave);
 80088ac:	f107 0308 	add.w	r3, r7, #8
 80088b0:	4619      	mov	r1, r3
 80088b2:	4828      	ldr	r0, [pc, #160]	; (8008954 <LOS_MemInit+0xf0>)
 80088b4:	f7ff ffa5 	bl	8008802 <LOS_SpinLockSave>
    if (OsMemMulPoolInit(pool, size) != LOS_OK) {
 80088b8:	6839      	ldr	r1, [r7, #0]
 80088ba:	6878      	ldr	r0, [r7, #4]
 80088bc:	f7ff ffbb 	bl	8008836 <OsMemMulPoolInit>
 80088c0:	4603      	mov	r3, r0
 80088c2:	2b00      	cmp	r3, #0
 80088c4:	d111      	bne.n	80088ea <LOS_MemInit+0x86>
        goto OUT;
    }

    if (OsHeapInit(pool, size) == FALSE) {
 80088c6:	6839      	ldr	r1, [r7, #0]
 80088c8:	6878      	ldr	r0, [r7, #4]
 80088ca:	f000 fafc 	bl	8008ec6 <OsHeapInit>
 80088ce:	4603      	mov	r3, r0
 80088d0:	2b00      	cmp	r3, #0
 80088d2:	d103      	bne.n	80088dc <LOS_MemInit+0x78>
        (VOID)OsMemMulPoolDeinit(pool);
 80088d4:	6878      	ldr	r0, [r7, #4]
 80088d6:	f7ff ffba 	bl	800884e <OsMemMulPoolDeinit>
        goto OUT;
 80088da:	e007      	b.n	80088ec <LOS_MemInit+0x88>
    }

    OsSlabMemInit(pool, size);
 80088dc:	6839      	ldr	r1, [r7, #0]
 80088de:	6878      	ldr	r0, [r7, #4]
 80088e0:	f7ff ff5a 	bl	8008798 <OsSlabMemInit>
    ret = LOS_OK;
 80088e4:	2300      	movs	r3, #0
 80088e6:	60fb      	str	r3, [r7, #12]
 80088e8:	e000      	b.n	80088ec <LOS_MemInit+0x88>
        goto OUT;
 80088ea:	bf00      	nop
OUT:
    MEM_UNLOCK(intSave);
 80088ec:	68bb      	ldr	r3, [r7, #8]
 80088ee:	4619      	mov	r1, r3
 80088f0:	4818      	ldr	r0, [pc, #96]	; (8008954 <LOS_MemInit+0xf0>)
 80088f2:	f7ff ff94 	bl	800881e <LOS_SpinUnlockRestore>

    LOS_TRACE(MEM_INFO_REQ, pool);
 80088f6:	2300      	movs	r3, #0
 80088f8:	617b      	str	r3, [r7, #20]
 80088fa:	687b      	ldr	r3, [r7, #4]
 80088fc:	61bb      	str	r3, [r7, #24]
 80088fe:	2302      	movs	r3, #2
 8008900:	613b      	str	r3, [r7, #16]
 8008902:	693b      	ldr	r3, [r7, #16]
 8008904:	2b01      	cmp	r3, #1
 8008906:	d916      	bls.n	8008936 <LOS_MemInit+0xd2>
 8008908:	4b13      	ldr	r3, [pc, #76]	; (8008958 <LOS_MemInit+0xf4>)
 800890a:	681b      	ldr	r3, [r3, #0]
 800890c:	2b00      	cmp	r3, #0
 800890e:	d012      	beq.n	8008936 <LOS_MemInit+0xd2>
 8008910:	4b11      	ldr	r3, [pc, #68]	; (8008958 <LOS_MemInit+0xf4>)
 8008912:	681c      	ldr	r4, [r3, #0]
 8008914:	69b9      	ldr	r1, [r7, #24]
 8008916:	693b      	ldr	r3, [r7, #16]
 8008918:	2b02      	cmp	r3, #2
 800891a:	d904      	bls.n	8008926 <LOS_MemInit+0xc2>
 800891c:	f107 0314 	add.w	r3, r7, #20
 8008920:	f103 0208 	add.w	r2, r3, #8
 8008924:	e000      	b.n	8008928 <LOS_MemInit+0xc4>
 8008926:	2200      	movs	r2, #0
 8008928:	693b      	ldr	r3, [r7, #16]
 800892a:	b29b      	uxth	r3, r3
 800892c:	3b02      	subs	r3, #2
 800892e:	b29b      	uxth	r3, r3
 8008930:	f44f 7082 	mov.w	r0, #260	; 0x104
 8008934:	47a0      	blx	r4
    return ret;
 8008936:	68fb      	ldr	r3, [r7, #12]
}
 8008938:	4a05      	ldr	r2, [pc, #20]	; (8008950 <LOS_MemInit+0xec>)
 800893a:	6811      	ldr	r1, [r2, #0]
 800893c:	69fa      	ldr	r2, [r7, #28]
 800893e:	4051      	eors	r1, r2
 8008940:	d001      	beq.n	8008946 <LOS_MemInit+0xe2>
 8008942:	f7fb fd51 	bl	80043e8 <__stack_chk_fail>
 8008946:	4618      	mov	r0, r3
 8008948:	3724      	adds	r7, #36	; 0x24
 800894a:	46bd      	mov	sp, r7
 800894c:	bd90      	pop	{r4, r7, pc}
 800894e:	bf00      	nop
 8008950:	08021378 	.word	0x08021378
 8008954:	200021b0 	.word	0x200021b0
 8008958:	2000075c 	.word	0x2000075c

0800895c <OsMemSystemInit>:
/*
 * Description : Initialize Dynamic Memory pool
 * Return      : LOS_OK on success or error code on failure
 */
LITE_OS_SEC_TEXT_INIT UINT32 OsMemSystemInit(UINTPTR memStart)
{
 800895c:	b580      	push	{r7, lr}
 800895e:	b084      	sub	sp, #16
 8008960:	af00      	add	r7, sp, #0
 8008962:	6078      	str	r0, [r7, #4]
    UINT32 ret;
    UINT32 memSize;

    m_aucSysMem1 = (UINT8 *)memStart;
 8008964:	687b      	ldr	r3, [r7, #4]
 8008966:	4a0c      	ldr	r2, [pc, #48]	; (8008998 <OsMemSystemInit+0x3c>)
 8008968:	6013      	str	r3, [r2, #0]
    memSize = OS_SYS_MEM_SIZE;
 800896a:	4b0c      	ldr	r3, [pc, #48]	; (800899c <OsMemSystemInit+0x40>)
 800896c:	681a      	ldr	r2, [r3, #0]
 800896e:	4b0c      	ldr	r3, [pc, #48]	; (80089a0 <OsMemSystemInit+0x44>)
 8008970:	681b      	ldr	r3, [r3, #0]
 8008972:	1ad3      	subs	r3, r2, r3
 8008974:	3301      	adds	r3, #1
 8008976:	60bb      	str	r3, [r7, #8]
    ret = LOS_MemInit((VOID *)m_aucSysMem1, memSize);
 8008978:	4b07      	ldr	r3, [pc, #28]	; (8008998 <OsMemSystemInit+0x3c>)
 800897a:	681b      	ldr	r3, [r3, #0]
 800897c:	68b9      	ldr	r1, [r7, #8]
 800897e:	4618      	mov	r0, r3
 8008980:	f7ff ff70 	bl	8008864 <LOS_MemInit>
 8008984:	60f8      	str	r0, [r7, #12]
#ifndef LOSCFG_EXC_INTERACTION
    m_aucSysMem0 = m_aucSysMem1;
 8008986:	4b04      	ldr	r3, [pc, #16]	; (8008998 <OsMemSystemInit+0x3c>)
 8008988:	681b      	ldr	r3, [r3, #0]
 800898a:	4a06      	ldr	r2, [pc, #24]	; (80089a4 <OsMemSystemInit+0x48>)
 800898c:	6013      	str	r3, [r2, #0]
#endif
    return ret;
 800898e:	68fb      	ldr	r3, [r7, #12]
}
 8008990:	4618      	mov	r0, r3
 8008992:	3710      	adds	r7, #16
 8008994:	46bd      	mov	sp, r7
 8008996:	bd80      	pop	{r7, pc}
 8008998:	200021b8 	.word	0x200021b8
 800899c:	080001f4 	.word	0x080001f4
 80089a0:	080001f0 	.word	0x080001f0
 80089a4:	200021b4 	.word	0x200021b4

080089a8 <LOS_MemAlloc>:
               pool, heapMan->size, status.totalUsedSize, status.totalFreeSize, status.maxFreeNodeSize,
               status.usedNodeNum, status.freeNodeNum);
}

LITE_OS_SEC_TEXT VOID *LOS_MemAlloc(VOID *pool, UINT32 size)
{
 80089a8:	b590      	push	{r4, r7, lr}
 80089aa:	b08b      	sub	sp, #44	; 0x2c
 80089ac:	af00      	add	r7, sp, #0
 80089ae:	6078      	str	r0, [r7, #4]
 80089b0:	6039      	str	r1, [r7, #0]
 80089b2:	4b2b      	ldr	r3, [pc, #172]	; (8008a60 <LOS_MemAlloc+0xb8>)
 80089b4:	681b      	ldr	r3, [r3, #0]
 80089b6:	627b      	str	r3, [r7, #36]	; 0x24
 80089b8:	f04f 0300 	mov.w	r3, #0
    VOID *ptr = NULL;
 80089bc:	2300      	movs	r3, #0
 80089be:	60fb      	str	r3, [r7, #12]
    UINT32 intSave;

    if ((pool == NULL) || (size == 0)) {
 80089c0:	687b      	ldr	r3, [r7, #4]
 80089c2:	2b00      	cmp	r3, #0
 80089c4:	d002      	beq.n	80089cc <LOS_MemAlloc+0x24>
 80089c6:	683b      	ldr	r3, [r7, #0]
 80089c8:	2b00      	cmp	r3, #0
 80089ca:	d101      	bne.n	80089d0 <LOS_MemAlloc+0x28>
        return ptr;
 80089cc:	68fb      	ldr	r3, [r7, #12]
 80089ce:	e03c      	b.n	8008a4a <LOS_MemAlloc+0xa2>
    }

    MEM_LOCK(intSave);
 80089d0:	f107 0308 	add.w	r3, r7, #8
 80089d4:	4619      	mov	r1, r3
 80089d6:	4823      	ldr	r0, [pc, #140]	; (8008a64 <LOS_MemAlloc+0xbc>)
 80089d8:	f7ff ff13 	bl	8008802 <LOS_SpinLockSave>

    ptr = OsSlabMemAlloc(pool, size);
 80089dc:	6839      	ldr	r1, [r7, #0]
 80089de:	6878      	ldr	r0, [r7, #4]
 80089e0:	f7ff fee5 	bl	80087ae <OsSlabMemAlloc>
 80089e4:	60f8      	str	r0, [r7, #12]
    if (ptr == NULL) {
 80089e6:	68fb      	ldr	r3, [r7, #12]
 80089e8:	2b00      	cmp	r3, #0
 80089ea:	d104      	bne.n	80089f6 <LOS_MemAlloc+0x4e>
        ptr = OsHeapAlloc(pool, size);
 80089ec:	6839      	ldr	r1, [r7, #0]
 80089ee:	6878      	ldr	r0, [r7, #4]
 80089f0:	f000 faac 	bl	8008f4c <OsHeapAlloc>
 80089f4:	60f8      	str	r0, [r7, #12]
    }

    MEM_UNLOCK(intSave);
 80089f6:	68bb      	ldr	r3, [r7, #8]
 80089f8:	4619      	mov	r1, r3
 80089fa:	481a      	ldr	r0, [pc, #104]	; (8008a64 <LOS_MemAlloc+0xbc>)
 80089fc:	f7ff ff0f 	bl	800881e <LOS_SpinUnlockRestore>

    LOS_TRACE(MEM_ALLOC, pool, (UINTPTR)ptr, size);
 8008a00:	2300      	movs	r3, #0
 8008a02:	617b      	str	r3, [r7, #20]
 8008a04:	687b      	ldr	r3, [r7, #4]
 8008a06:	61bb      	str	r3, [r7, #24]
 8008a08:	68fb      	ldr	r3, [r7, #12]
 8008a0a:	61fb      	str	r3, [r7, #28]
 8008a0c:	683b      	ldr	r3, [r7, #0]
 8008a0e:	623b      	str	r3, [r7, #32]
 8008a10:	2304      	movs	r3, #4
 8008a12:	613b      	str	r3, [r7, #16]
 8008a14:	693b      	ldr	r3, [r7, #16]
 8008a16:	2b01      	cmp	r3, #1
 8008a18:	d916      	bls.n	8008a48 <LOS_MemAlloc+0xa0>
 8008a1a:	4b13      	ldr	r3, [pc, #76]	; (8008a68 <LOS_MemAlloc+0xc0>)
 8008a1c:	681b      	ldr	r3, [r3, #0]
 8008a1e:	2b00      	cmp	r3, #0
 8008a20:	d012      	beq.n	8008a48 <LOS_MemAlloc+0xa0>
 8008a22:	4b11      	ldr	r3, [pc, #68]	; (8008a68 <LOS_MemAlloc+0xc0>)
 8008a24:	681c      	ldr	r4, [r3, #0]
 8008a26:	69b9      	ldr	r1, [r7, #24]
 8008a28:	693b      	ldr	r3, [r7, #16]
 8008a2a:	2b02      	cmp	r3, #2
 8008a2c:	d904      	bls.n	8008a38 <LOS_MemAlloc+0x90>
 8008a2e:	f107 0314 	add.w	r3, r7, #20
 8008a32:	f103 0208 	add.w	r2, r3, #8
 8008a36:	e000      	b.n	8008a3a <LOS_MemAlloc+0x92>
 8008a38:	2200      	movs	r2, #0
 8008a3a:	693b      	ldr	r3, [r7, #16]
 8008a3c:	b29b      	uxth	r3, r3
 8008a3e:	3b02      	subs	r3, #2
 8008a40:	b29b      	uxth	r3, r3
 8008a42:	f44f 7080 	mov.w	r0, #256	; 0x100
 8008a46:	47a0      	blx	r4
    return ptr;
 8008a48:	68fb      	ldr	r3, [r7, #12]
}
 8008a4a:	4a05      	ldr	r2, [pc, #20]	; (8008a60 <LOS_MemAlloc+0xb8>)
 8008a4c:	6811      	ldr	r1, [r2, #0]
 8008a4e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008a50:	4051      	eors	r1, r2
 8008a52:	d001      	beq.n	8008a58 <LOS_MemAlloc+0xb0>
 8008a54:	f7fb fcc8 	bl	80043e8 <__stack_chk_fail>
 8008a58:	4618      	mov	r0, r3
 8008a5a:	372c      	adds	r7, #44	; 0x2c
 8008a5c:	46bd      	mov	sp, r7
 8008a5e:	bd90      	pop	{r4, r7, pc}
 8008a60:	08021380 	.word	0x08021380
 8008a64:	200021b0 	.word	0x200021b0
 8008a68:	2000075c 	.word	0x2000075c

08008a6c <LOS_MemAllocAlign>:

LITE_OS_SEC_TEXT VOID *LOS_MemAllocAlign(VOID *pool, UINT32 size, UINT32 boundary)
{
 8008a6c:	b590      	push	{r4, r7, lr}
 8008a6e:	b08f      	sub	sp, #60	; 0x3c
 8008a70:	af00      	add	r7, sp, #0
 8008a72:	60f8      	str	r0, [r7, #12]
 8008a74:	60b9      	str	r1, [r7, #8]
 8008a76:	607a      	str	r2, [r7, #4]
 8008a78:	4b24      	ldr	r3, [pc, #144]	; (8008b0c <LOS_MemAllocAlign+0xa0>)
 8008a7a:	681b      	ldr	r3, [r3, #0]
 8008a7c:	637b      	str	r3, [r7, #52]	; 0x34
 8008a7e:	f04f 0300 	mov.w	r3, #0
    VOID *ptr = NULL;
 8008a82:	2300      	movs	r3, #0
 8008a84:	61bb      	str	r3, [r7, #24]
    UINT32 intSave;

    MEM_LOCK(intSave);
 8008a86:	f107 0314 	add.w	r3, r7, #20
 8008a8a:	4619      	mov	r1, r3
 8008a8c:	4820      	ldr	r0, [pc, #128]	; (8008b10 <LOS_MemAllocAlign+0xa4>)
 8008a8e:	f7ff feb8 	bl	8008802 <LOS_SpinLockSave>
    ptr = OsHeapAllocAlign(pool, size, boundary);
 8008a92:	687a      	ldr	r2, [r7, #4]
 8008a94:	68b9      	ldr	r1, [r7, #8]
 8008a96:	68f8      	ldr	r0, [r7, #12]
 8008a98:	f000 fb18 	bl	80090cc <OsHeapAllocAlign>
 8008a9c:	61b8      	str	r0, [r7, #24]
    MEM_UNLOCK(intSave);
 8008a9e:	697b      	ldr	r3, [r7, #20]
 8008aa0:	4619      	mov	r1, r3
 8008aa2:	481b      	ldr	r0, [pc, #108]	; (8008b10 <LOS_MemAllocAlign+0xa4>)
 8008aa4:	f7ff febb 	bl	800881e <LOS_SpinUnlockRestore>

    LOS_TRACE(MEM_ALLOC_ALIGN, pool, (UINTPTR)ptr, size, boundary);
 8008aa8:	2300      	movs	r3, #0
 8008aaa:	623b      	str	r3, [r7, #32]
 8008aac:	68fb      	ldr	r3, [r7, #12]
 8008aae:	627b      	str	r3, [r7, #36]	; 0x24
 8008ab0:	69bb      	ldr	r3, [r7, #24]
 8008ab2:	62bb      	str	r3, [r7, #40]	; 0x28
 8008ab4:	68bb      	ldr	r3, [r7, #8]
 8008ab6:	62fb      	str	r3, [r7, #44]	; 0x2c
 8008ab8:	687b      	ldr	r3, [r7, #4]
 8008aba:	633b      	str	r3, [r7, #48]	; 0x30
 8008abc:	2305      	movs	r3, #5
 8008abe:	61fb      	str	r3, [r7, #28]
 8008ac0:	69fb      	ldr	r3, [r7, #28]
 8008ac2:	2b01      	cmp	r3, #1
 8008ac4:	d916      	bls.n	8008af4 <LOS_MemAllocAlign+0x88>
 8008ac6:	4b13      	ldr	r3, [pc, #76]	; (8008b14 <LOS_MemAllocAlign+0xa8>)
 8008ac8:	681b      	ldr	r3, [r3, #0]
 8008aca:	2b00      	cmp	r3, #0
 8008acc:	d012      	beq.n	8008af4 <LOS_MemAllocAlign+0x88>
 8008ace:	4b11      	ldr	r3, [pc, #68]	; (8008b14 <LOS_MemAllocAlign+0xa8>)
 8008ad0:	681c      	ldr	r4, [r3, #0]
 8008ad2:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8008ad4:	69fb      	ldr	r3, [r7, #28]
 8008ad6:	2b02      	cmp	r3, #2
 8008ad8:	d904      	bls.n	8008ae4 <LOS_MemAllocAlign+0x78>
 8008ada:	f107 0320 	add.w	r3, r7, #32
 8008ade:	f103 0208 	add.w	r2, r3, #8
 8008ae2:	e000      	b.n	8008ae6 <LOS_MemAllocAlign+0x7a>
 8008ae4:	2200      	movs	r2, #0
 8008ae6:	69fb      	ldr	r3, [r7, #28]
 8008ae8:	b29b      	uxth	r3, r3
 8008aea:	3b02      	subs	r3, #2
 8008aec:	b29b      	uxth	r3, r3
 8008aee:	f240 1001 	movw	r0, #257	; 0x101
 8008af2:	47a0      	blx	r4
    return ptr;
 8008af4:	69bb      	ldr	r3, [r7, #24]
}
 8008af6:	4a05      	ldr	r2, [pc, #20]	; (8008b0c <LOS_MemAllocAlign+0xa0>)
 8008af8:	6811      	ldr	r1, [r2, #0]
 8008afa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008afc:	4051      	eors	r1, r2
 8008afe:	d001      	beq.n	8008b04 <LOS_MemAllocAlign+0x98>
 8008b00:	f7fb fc72 	bl	80043e8 <__stack_chk_fail>
 8008b04:	4618      	mov	r0, r3
 8008b06:	373c      	adds	r7, #60	; 0x3c
 8008b08:	46bd      	mov	sp, r7
 8008b0a:	bd90      	pop	{r4, r7, pc}
 8008b0c:	08021384 	.word	0x08021384
 8008b10:	200021b0 	.word	0x200021b0
 8008b14:	2000075c 	.word	0x2000075c

08008b18 <LOS_MemFree>:
    LOS_TRACE(MEM_REALLOC, pool, (UINTPTR)ptr, size);
    return retPtr;
}

LITE_OS_SEC_TEXT UINT32 LOS_MemFree(VOID *pool, VOID *mem)
{
 8008b18:	b590      	push	{r4, r7, lr}
 8008b1a:	b08b      	sub	sp, #44	; 0x2c
 8008b1c:	af00      	add	r7, sp, #0
 8008b1e:	6078      	str	r0, [r7, #4]
 8008b20:	6039      	str	r1, [r7, #0]
 8008b22:	4b2d      	ldr	r3, [pc, #180]	; (8008bd8 <LOS_MemFree+0xc0>)
 8008b24:	681b      	ldr	r3, [r3, #0]
 8008b26:	627b      	str	r3, [r7, #36]	; 0x24
 8008b28:	f04f 0300 	mov.w	r3, #0
    BOOL ret = FALSE;
 8008b2c:	2300      	movs	r3, #0
 8008b2e:	613b      	str	r3, [r7, #16]
    UINT32 intSave;

    if ((pool == NULL) || (mem == NULL)) {
 8008b30:	687b      	ldr	r3, [r7, #4]
 8008b32:	2b00      	cmp	r3, #0
 8008b34:	d002      	beq.n	8008b3c <LOS_MemFree+0x24>
 8008b36:	683b      	ldr	r3, [r7, #0]
 8008b38:	2b00      	cmp	r3, #0
 8008b3a:	d101      	bne.n	8008b40 <LOS_MemFree+0x28>
        return LOS_NOK;
 8008b3c:	2301      	movs	r3, #1
 8008b3e:	e03f      	b.n	8008bc0 <LOS_MemFree+0xa8>
    }

    MEM_LOCK(intSave);
 8008b40:	f107 030c 	add.w	r3, r7, #12
 8008b44:	4619      	mov	r1, r3
 8008b46:	4825      	ldr	r0, [pc, #148]	; (8008bdc <LOS_MemFree+0xc4>)
 8008b48:	f7ff fe5b 	bl	8008802 <LOS_SpinLockSave>

    ret = OsSlabMemFree(pool, mem);
 8008b4c:	6839      	ldr	r1, [r7, #0]
 8008b4e:	6878      	ldr	r0, [r7, #4]
 8008b50:	f7ff fe39 	bl	80087c6 <OsSlabMemFree>
 8008b54:	6138      	str	r0, [r7, #16]
    if (ret != TRUE) {
 8008b56:	693b      	ldr	r3, [r7, #16]
 8008b58:	2b01      	cmp	r3, #1
 8008b5a:	d004      	beq.n	8008b66 <LOS_MemFree+0x4e>
        ret = OsHeapFree(pool, mem);
 8008b5c:	6839      	ldr	r1, [r7, #0]
 8008b5e:	6878      	ldr	r0, [r7, #4]
 8008b60:	f000 fb5c 	bl	800921c <OsHeapFree>
 8008b64:	6138      	str	r0, [r7, #16]
    }

    MEM_UNLOCK(intSave);
 8008b66:	68fb      	ldr	r3, [r7, #12]
 8008b68:	4619      	mov	r1, r3
 8008b6a:	481c      	ldr	r0, [pc, #112]	; (8008bdc <LOS_MemFree+0xc4>)
 8008b6c:	f7ff fe57 	bl	800881e <LOS_SpinUnlockRestore>

    LOS_TRACE(MEM_FREE, pool, (UINTPTR)mem);
 8008b70:	2300      	movs	r3, #0
 8008b72:	61bb      	str	r3, [r7, #24]
 8008b74:	687b      	ldr	r3, [r7, #4]
 8008b76:	61fb      	str	r3, [r7, #28]
 8008b78:	683b      	ldr	r3, [r7, #0]
 8008b7a:	623b      	str	r3, [r7, #32]
 8008b7c:	2303      	movs	r3, #3
 8008b7e:	617b      	str	r3, [r7, #20]
 8008b80:	697b      	ldr	r3, [r7, #20]
 8008b82:	2b01      	cmp	r3, #1
 8008b84:	d916      	bls.n	8008bb4 <LOS_MemFree+0x9c>
 8008b86:	4b16      	ldr	r3, [pc, #88]	; (8008be0 <LOS_MemFree+0xc8>)
 8008b88:	681b      	ldr	r3, [r3, #0]
 8008b8a:	2b00      	cmp	r3, #0
 8008b8c:	d012      	beq.n	8008bb4 <LOS_MemFree+0x9c>
 8008b8e:	4b14      	ldr	r3, [pc, #80]	; (8008be0 <LOS_MemFree+0xc8>)
 8008b90:	681c      	ldr	r4, [r3, #0]
 8008b92:	69f9      	ldr	r1, [r7, #28]
 8008b94:	697b      	ldr	r3, [r7, #20]
 8008b96:	2b02      	cmp	r3, #2
 8008b98:	d904      	bls.n	8008ba4 <LOS_MemFree+0x8c>
 8008b9a:	f107 0318 	add.w	r3, r7, #24
 8008b9e:	f103 0208 	add.w	r2, r3, #8
 8008ba2:	e000      	b.n	8008ba6 <LOS_MemFree+0x8e>
 8008ba4:	2200      	movs	r2, #0
 8008ba6:	697b      	ldr	r3, [r7, #20]
 8008ba8:	b29b      	uxth	r3, r3
 8008baa:	3b02      	subs	r3, #2
 8008bac:	b29b      	uxth	r3, r3
 8008bae:	f240 1003 	movw	r0, #259	; 0x103
 8008bb2:	47a0      	blx	r4
    return (ret == TRUE ? LOS_OK : LOS_NOK);
 8008bb4:	693b      	ldr	r3, [r7, #16]
 8008bb6:	2b01      	cmp	r3, #1
 8008bb8:	bf14      	ite	ne
 8008bba:	2301      	movne	r3, #1
 8008bbc:	2300      	moveq	r3, #0
 8008bbe:	b2db      	uxtb	r3, r3
}
 8008bc0:	4a05      	ldr	r2, [pc, #20]	; (8008bd8 <LOS_MemFree+0xc0>)
 8008bc2:	6811      	ldr	r1, [r2, #0]
 8008bc4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008bc6:	4051      	eors	r1, r2
 8008bc8:	d001      	beq.n	8008bce <LOS_MemFree+0xb6>
 8008bca:	f7fb fc0d 	bl	80043e8 <__stack_chk_fail>
 8008bce:	4618      	mov	r0, r3
 8008bd0:	372c      	adds	r7, #44	; 0x2c
 8008bd2:	46bd      	mov	sp, r7
 8008bd4:	bd90      	pop	{r4, r7, pc}
 8008bd6:	bf00      	nop
 8008bd8:	080213e4 	.word	0x080213e4
 8008bdc:	200021b0 	.word	0x200021b0
 8008be0:	2000075c 	.word	0x2000075c

08008be4 <LOS_MemInfoGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_MemInfoGet(VOID *pool, LOS_MEM_POOL_STATUS *status)
{
 8008be4:	b580      	push	{r7, lr}
 8008be6:	b08c      	sub	sp, #48	; 0x30
 8008be8:	af00      	add	r7, sp, #0
 8008bea:	6078      	str	r0, [r7, #4]
 8008bec:	6039      	str	r1, [r7, #0]
 8008bee:	4b23      	ldr	r3, [pc, #140]	; (8008c7c <LOS_MemInfoGet+0x98>)
 8008bf0:	681b      	ldr	r3, [r3, #0]
 8008bf2:	62fb      	str	r3, [r7, #44]	; 0x2c
 8008bf4:	f04f 0300 	mov.w	r3, #0
    LosHeapStatus heapStatus;
    UINT32 err;
    UINT32 intSave;

    if ((pool == NULL) || (status == NULL)) {
 8008bf8:	687b      	ldr	r3, [r7, #4]
 8008bfa:	2b00      	cmp	r3, #0
 8008bfc:	d002      	beq.n	8008c04 <LOS_MemInfoGet+0x20>
 8008bfe:	683b      	ldr	r3, [r7, #0]
 8008c00:	2b00      	cmp	r3, #0
 8008c02:	d101      	bne.n	8008c08 <LOS_MemInfoGet+0x24>
        return LOS_NOK;
 8008c04:	2301      	movs	r3, #1
 8008c06:	e02e      	b.n	8008c66 <LOS_MemInfoGet+0x82>
    }

    MEM_LOCK(intSave);
 8008c08:	f107 030c 	add.w	r3, r7, #12
 8008c0c:	4619      	mov	r1, r3
 8008c0e:	481c      	ldr	r0, [pc, #112]	; (8008c80 <LOS_MemInfoGet+0x9c>)
 8008c10:	f7ff fdf7 	bl	8008802 <LOS_SpinLockSave>

    err = OsHeapStatisticsGet(pool, &heapStatus);
 8008c14:	f107 0314 	add.w	r3, r7, #20
 8008c18:	4619      	mov	r1, r3
 8008c1a:	6878      	ldr	r0, [r7, #4]
 8008c1c:	f000 fb76 	bl	800930c <OsHeapStatisticsGet>
 8008c20:	6138      	str	r0, [r7, #16]
    if (err != LOS_OK) {
 8008c22:	693b      	ldr	r3, [r7, #16]
 8008c24:	2b00      	cmp	r3, #0
 8008c26:	d006      	beq.n	8008c36 <LOS_MemInfoGet+0x52>
        MEM_UNLOCK(intSave);
 8008c28:	68fb      	ldr	r3, [r7, #12]
 8008c2a:	4619      	mov	r1, r3
 8008c2c:	4814      	ldr	r0, [pc, #80]	; (8008c80 <LOS_MemInfoGet+0x9c>)
 8008c2e:	f7ff fdf6 	bl	800881e <LOS_SpinUnlockRestore>
        return LOS_NOK;
 8008c32:	2301      	movs	r3, #1
 8008c34:	e017      	b.n	8008c66 <LOS_MemInfoGet+0x82>
    }

    status->uwTotalUsedSize   = heapStatus.totalUsedSize;
 8008c36:	697a      	ldr	r2, [r7, #20]
 8008c38:	683b      	ldr	r3, [r7, #0]
 8008c3a:	601a      	str	r2, [r3, #0]
    status->uwTotalFreeSize   = heapStatus.totalFreeSize;
 8008c3c:	69ba      	ldr	r2, [r7, #24]
 8008c3e:	683b      	ldr	r3, [r7, #0]
 8008c40:	605a      	str	r2, [r3, #4]
    status->uwMaxFreeNodeSize = heapStatus.maxFreeNodeSize;
 8008c42:	69fa      	ldr	r2, [r7, #28]
 8008c44:	683b      	ldr	r3, [r7, #0]
 8008c46:	609a      	str	r2, [r3, #8]
    status->uwUsedNodeNum  = heapStatus.usedNodeNum;
 8008c48:	6a3a      	ldr	r2, [r7, #32]
 8008c4a:	683b      	ldr	r3, [r7, #0]
 8008c4c:	60da      	str	r2, [r3, #12]
    status->uwFreeNodeNum  = heapStatus.freeNodeNum;
 8008c4e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008c50:	683b      	ldr	r3, [r7, #0]
 8008c52:	611a      	str	r2, [r3, #16]

#ifdef LOSCFG_MEM_TASK_STAT
    status->uwUsageWaterLine = heapStatus.usageWaterLine;
 8008c54:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008c56:	683b      	ldr	r3, [r7, #0]
 8008c58:	615a      	str	r2, [r3, #20]
#endif

    MEM_UNLOCK(intSave);
 8008c5a:	68fb      	ldr	r3, [r7, #12]
 8008c5c:	4619      	mov	r1, r3
 8008c5e:	4808      	ldr	r0, [pc, #32]	; (8008c80 <LOS_MemInfoGet+0x9c>)
 8008c60:	f7ff fddd 	bl	800881e <LOS_SpinUnlockRestore>
    return LOS_OK;
 8008c64:	2300      	movs	r3, #0
}
 8008c66:	4a05      	ldr	r2, [pc, #20]	; (8008c7c <LOS_MemInfoGet+0x98>)
 8008c68:	6811      	ldr	r1, [r2, #0]
 8008c6a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8008c6c:	4051      	eors	r1, r2
 8008c6e:	d001      	beq.n	8008c74 <LOS_MemInfoGet+0x90>
 8008c70:	f7fb fbba 	bl	80043e8 <__stack_chk_fail>
 8008c74:	4618      	mov	r0, r3
 8008c76:	3730      	adds	r7, #48	; 0x30
 8008c78:	46bd      	mov	sp, r7
 8008c7a:	bd80      	pop	{r7, pc}
 8008c7c:	080213e8 	.word	0x080213e8
 8008c80:	200021b0 	.word	0x200021b0

08008c84 <LOS_MemTotalUsedGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_MemTotalUsedGet(VOID *pool)
{
 8008c84:	b580      	push	{r7, lr}
 8008c86:	b08c      	sub	sp, #48	; 0x30
 8008c88:	af00      	add	r7, sp, #0
 8008c8a:	6078      	str	r0, [r7, #4]
 8008c8c:	4b17      	ldr	r3, [pc, #92]	; (8008cec <LOS_MemTotalUsedGet+0x68>)
 8008c8e:	681b      	ldr	r3, [r3, #0]
 8008c90:	62fb      	str	r3, [r7, #44]	; 0x2c
 8008c92:	f04f 0300 	mov.w	r3, #0
    LosHeapStatus heapStatus;
    UINT32 err;
    UINT32 intSave;

    if (pool == NULL) {
 8008c96:	687b      	ldr	r3, [r7, #4]
 8008c98:	2b00      	cmp	r3, #0
 8008c9a:	d102      	bne.n	8008ca2 <LOS_MemTotalUsedGet+0x1e>
        return OS_NULL_INT;
 8008c9c:	f04f 33ff 	mov.w	r3, #4294967295
 8008ca0:	e018      	b.n	8008cd4 <LOS_MemTotalUsedGet+0x50>
    }

    MEM_LOCK(intSave);
 8008ca2:	f107 030c 	add.w	r3, r7, #12
 8008ca6:	4619      	mov	r1, r3
 8008ca8:	4811      	ldr	r0, [pc, #68]	; (8008cf0 <LOS_MemTotalUsedGet+0x6c>)
 8008caa:	f7ff fdaa 	bl	8008802 <LOS_SpinLockSave>
    err = OsHeapStatisticsGet(pool, &heapStatus);
 8008cae:	f107 0314 	add.w	r3, r7, #20
 8008cb2:	4619      	mov	r1, r3
 8008cb4:	6878      	ldr	r0, [r7, #4]
 8008cb6:	f000 fb29 	bl	800930c <OsHeapStatisticsGet>
 8008cba:	6138      	str	r0, [r7, #16]
    MEM_UNLOCK(intSave);
 8008cbc:	68fb      	ldr	r3, [r7, #12]
 8008cbe:	4619      	mov	r1, r3
 8008cc0:	480b      	ldr	r0, [pc, #44]	; (8008cf0 <LOS_MemTotalUsedGet+0x6c>)
 8008cc2:	f7ff fdac 	bl	800881e <LOS_SpinUnlockRestore>

    if (err != LOS_OK) {
 8008cc6:	693b      	ldr	r3, [r7, #16]
 8008cc8:	2b00      	cmp	r3, #0
 8008cca:	d002      	beq.n	8008cd2 <LOS_MemTotalUsedGet+0x4e>
        return OS_NULL_INT;
 8008ccc:	f04f 33ff 	mov.w	r3, #4294967295
 8008cd0:	e000      	b.n	8008cd4 <LOS_MemTotalUsedGet+0x50>
    }

    return heapStatus.totalUsedSize;
 8008cd2:	697b      	ldr	r3, [r7, #20]
}
 8008cd4:	4a05      	ldr	r2, [pc, #20]	; (8008cec <LOS_MemTotalUsedGet+0x68>)
 8008cd6:	6811      	ldr	r1, [r2, #0]
 8008cd8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8008cda:	4051      	eors	r1, r2
 8008cdc:	d001      	beq.n	8008ce2 <LOS_MemTotalUsedGet+0x5e>
 8008cde:	f7fb fb83 	bl	80043e8 <__stack_chk_fail>
 8008ce2:	4618      	mov	r0, r3
 8008ce4:	3730      	adds	r7, #48	; 0x30
 8008ce6:	46bd      	mov	sp, r7
 8008ce8:	bd80      	pop	{r7, pc}
 8008cea:	bf00      	nop
 8008cec:	080213ec 	.word	0x080213ec
 8008cf0:	200021b0 	.word	0x200021b0

08008cf4 <LOS_MemPoolSizeGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_MemPoolSizeGet(const VOID *pool)
{
 8008cf4:	b480      	push	{r7}
 8008cf6:	b085      	sub	sp, #20
 8008cf8:	af00      	add	r7, sp, #0
 8008cfa:	6078      	str	r0, [r7, #4]
    struct LosHeapManager *heapManager = NULL;
 8008cfc:	2300      	movs	r3, #0
 8008cfe:	60fb      	str	r3, [r7, #12]

    if (pool == NULL) {
 8008d00:	687b      	ldr	r3, [r7, #4]
 8008d02:	2b00      	cmp	r3, #0
 8008d04:	d102      	bne.n	8008d0c <LOS_MemPoolSizeGet+0x18>
        return OS_NULL_INT;
 8008d06:	f04f 33ff 	mov.w	r3, #4294967295
 8008d0a:	e003      	b.n	8008d14 <LOS_MemPoolSizeGet+0x20>
    }

    heapManager = (struct LosHeapManager *)pool;
 8008d0c:	687b      	ldr	r3, [r7, #4]
 8008d0e:	60fb      	str	r3, [r7, #12]
    return heapManager->size;
 8008d10:	68fb      	ldr	r3, [r7, #12]
 8008d12:	689b      	ldr	r3, [r3, #8]
}
 8008d14:	4618      	mov	r0, r3
 8008d16:	3714      	adds	r7, #20
 8008d18:	46bd      	mov	sp, r7
 8008d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d1e:	4770      	bx	lr

08008d20 <LOS_MemIntegrityCheck>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_MemIntegrityCheck(VOID *pool)
{
 8008d20:	b580      	push	{r7, lr}
 8008d22:	b086      	sub	sp, #24
 8008d24:	af00      	add	r7, sp, #0
 8008d26:	6078      	str	r0, [r7, #4]
 8008d28:	4b12      	ldr	r3, [pc, #72]	; (8008d74 <LOS_MemIntegrityCheck+0x54>)
 8008d2a:	681b      	ldr	r3, [r3, #0]
 8008d2c:	617b      	str	r3, [r7, #20]
 8008d2e:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 ret;

    if (pool == NULL) {
 8008d32:	687b      	ldr	r3, [r7, #4]
 8008d34:	2b00      	cmp	r3, #0
 8008d36:	d102      	bne.n	8008d3e <LOS_MemIntegrityCheck+0x1e>
        return OS_NULL_INT;
 8008d38:	f04f 33ff 	mov.w	r3, #4294967295
 8008d3c:	e00f      	b.n	8008d5e <LOS_MemIntegrityCheck+0x3e>
    }

    MEM_LOCK(intSave);
 8008d3e:	f107 030c 	add.w	r3, r7, #12
 8008d42:	4619      	mov	r1, r3
 8008d44:	480c      	ldr	r0, [pc, #48]	; (8008d78 <LOS_MemIntegrityCheck+0x58>)
 8008d46:	f7ff fd5c 	bl	8008802 <LOS_SpinLockSave>
    ret = OsHeapIntegrityCheck(pool);
 8008d4a:	6878      	ldr	r0, [r7, #4]
 8008d4c:	f000 f8b0 	bl	8008eb0 <OsHeapIntegrityCheck>
 8008d50:	6138      	str	r0, [r7, #16]
    MEM_UNLOCK(intSave);
 8008d52:	68fb      	ldr	r3, [r7, #12]
 8008d54:	4619      	mov	r1, r3
 8008d56:	4808      	ldr	r0, [pc, #32]	; (8008d78 <LOS_MemIntegrityCheck+0x58>)
 8008d58:	f7ff fd61 	bl	800881e <LOS_SpinUnlockRestore>

    return ret;
 8008d5c:	693b      	ldr	r3, [r7, #16]
}
 8008d5e:	4a05      	ldr	r2, [pc, #20]	; (8008d74 <LOS_MemIntegrityCheck+0x54>)
 8008d60:	6811      	ldr	r1, [r2, #0]
 8008d62:	697a      	ldr	r2, [r7, #20]
 8008d64:	4051      	eors	r1, r2
 8008d66:	d001      	beq.n	8008d6c <LOS_MemIntegrityCheck+0x4c>
 8008d68:	f7fb fb3e 	bl	80043e8 <__stack_chk_fail>
 8008d6c:	4618      	mov	r0, r3
 8008d6e:	3718      	adds	r7, #24
 8008d70:	46bd      	mov	sp, r7
 8008d72:	bd80      	pop	{r7, pc}
 8008d74:	080213f0 	.word	0x080213f0
 8008d78:	200021b0 	.word	0x200021b0

08008d7c <OsMemIntegrityMultiCheck>:

VOID OsMemIntegrityMultiCheck(VOID)
{
 8008d7c:	b580      	push	{r7, lr}
 8008d7e:	af00      	add	r7, sp, #0
    if (LOS_MemIntegrityCheck(m_aucSysMem1) == LOS_OK) {
 8008d80:	4b06      	ldr	r3, [pc, #24]	; (8008d9c <OsMemIntegrityMultiCheck+0x20>)
 8008d82:	681b      	ldr	r3, [r3, #0]
 8008d84:	4618      	mov	r0, r3
 8008d86:	f7ff ffcb 	bl	8008d20 <LOS_MemIntegrityCheck>
 8008d8a:	4603      	mov	r3, r0
 8008d8c:	2b00      	cmp	r3, #0
 8008d8e:	d102      	bne.n	8008d96 <OsMemIntegrityMultiCheck+0x1a>
        PRINTK("system memcheck over, all passed!\n");
 8008d90:	4803      	ldr	r0, [pc, #12]	; (8008da0 <OsMemIntegrityMultiCheck+0x24>)
 8008d92:	f7fb fc9b 	bl	80046cc <dprintf>
#ifdef LOSCFG_SHELL_EXCINFO_DUMP
        WriteExcInfoToBuf("exc interaction memcheck over, all passed!\n");
#endif
    }
#endif
}
 8008d96:	bf00      	nop
 8008d98:	bd80      	pop	{r7, pc}
 8008d9a:	bf00      	nop
 8008d9c:	200021b8 	.word	0x200021b8
 8008da0:	080213f4 	.word	0x080213f4

08008da4 <ArchCurrTaskGet>:
{
 8008da4:	b480      	push	{r7}
 8008da6:	af00      	add	r7, sp, #0
    return g_runTask;
 8008da8:	4b03      	ldr	r3, [pc, #12]	; (8008db8 <ArchCurrTaskGet+0x14>)
 8008daa:	681b      	ldr	r3, [r3, #0]
}
 8008dac:	4618      	mov	r0, r3
 8008dae:	46bd      	mov	sp, r7
 8008db0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008db4:	4770      	bx	lr
 8008db6:	bf00      	nop
 8008db8:	200033bc 	.word	0x200033bc

08008dbc <OsCurrTaskGet>:
{
 8008dbc:	b580      	push	{r7, lr}
 8008dbe:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 8008dc0:	f7ff fff0 	bl	8008da4 <ArchCurrTaskGet>
 8008dc4:	4603      	mov	r3, r0
}
 8008dc6:	4618      	mov	r0, r3
 8008dc8:	bd80      	pop	{r7, pc}

08008dca <OsHeapPrvGetNext>:
 * Input       : struct LosHeapManager *heapMan --- Pointer to the manager,to distinguish heap
 *               struct LosHeapNode *node --- Size of memory in bytes to allocate
 * Return      : Pointer to next memory node
 */
struct LosHeapNode* OsHeapPrvGetNext(struct LosHeapManager *heapMan, struct LosHeapNode *node)
{
 8008dca:	b480      	push	{r7}
 8008dcc:	b083      	sub	sp, #12
 8008dce:	af00      	add	r7, sp, #0
 8008dd0:	6078      	str	r0, [r7, #4]
 8008dd2:	6039      	str	r1, [r7, #0]
    return (heapMan->tail == node) ? NULL : (struct LosHeapNode *)(UINTPTR)(node->data + node->size);
 8008dd4:	687b      	ldr	r3, [r7, #4]
 8008dd6:	685b      	ldr	r3, [r3, #4]
 8008dd8:	683a      	ldr	r2, [r7, #0]
 8008dda:	429a      	cmp	r2, r3
 8008ddc:	d007      	beq.n	8008dee <OsHeapPrvGetNext+0x24>
 8008dde:	683b      	ldr	r3, [r7, #0]
 8008de0:	330c      	adds	r3, #12
 8008de2:	683a      	ldr	r2, [r7, #0]
 8008de4:	6892      	ldr	r2, [r2, #8]
 8008de6:	f3c2 021d 	ubfx	r2, r2, #0, #30
 8008dea:	4413      	add	r3, r2
 8008dec:	e000      	b.n	8008df0 <OsHeapPrvGetNext+0x26>
 8008dee:	2300      	movs	r3, #0
}
 8008df0:	4618      	mov	r0, r3
 8008df2:	370c      	adds	r7, #12
 8008df4:	46bd      	mov	sp, r7
 8008df6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008dfa:	4770      	bx	lr

08008dfc <OsHeapStatInit>:

#ifdef LOSCFG_MEM_TASK_STAT

VOID OsHeapStatInit(struct LosHeapManager *heapMan, UINT32 size)
{
 8008dfc:	b580      	push	{r7, lr}
 8008dfe:	b082      	sub	sp, #8
 8008e00:	af00      	add	r7, sp, #0
 8008e02:	6078      	str	r0, [r7, #4]
 8008e04:	6039      	str	r1, [r7, #0]
    (VOID)memset_s(&heapMan->stat, sizeof(Memstat), 0, sizeof(Memstat));
 8008e06:	687b      	ldr	r3, [r7, #4]
 8008e08:	f103 000c 	add.w	r0, r3, #12
 8008e0c:	2390      	movs	r3, #144	; 0x90
 8008e0e:	2200      	movs	r2, #0
 8008e10:	2190      	movs	r1, #144	; 0x90
 8008e12:	f00d f93b 	bl	801608c <memset_s>

    heapMan->stat.memTotalUsed = sizeof(struct LosHeapNode) + sizeof(struct LosHeapManager);
 8008e16:	687b      	ldr	r3, [r7, #4]
 8008e18:	22a8      	movs	r2, #168	; 0xa8
 8008e1a:	60da      	str	r2, [r3, #12]
    heapMan->stat.memTotalPeak = heapMan->stat.memTotalUsed;
 8008e1c:	687b      	ldr	r3, [r7, #4]
 8008e1e:	68da      	ldr	r2, [r3, #12]
 8008e20:	687b      	ldr	r3, [r7, #4]
 8008e22:	611a      	str	r2, [r3, #16]
}
 8008e24:	bf00      	nop
 8008e26:	3708      	adds	r7, #8
 8008e28:	46bd      	mov	sp, r7
 8008e2a:	bd80      	pop	{r7, pc}

08008e2c <OsHeapStatAddUsed>:

VOID OsHeapStatAddUsed(struct LosHeapManager *heapMan, struct LosHeapNode *node)
{
 8008e2c:	b580      	push	{r7, lr}
 8008e2e:	b084      	sub	sp, #16
 8008e30:	af00      	add	r7, sp, #0
 8008e32:	6078      	str	r0, [r7, #4]
 8008e34:	6039      	str	r1, [r7, #0]
    UINT32 taskId;
    UINT32 blockSize = sizeof(struct LosHeapNode) + node->size;
 8008e36:	683b      	ldr	r3, [r7, #0]
 8008e38:	689b      	ldr	r3, [r3, #8]
 8008e3a:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8008e3e:	330c      	adds	r3, #12
 8008e40:	60fb      	str	r3, [r7, #12]

    if ((OsCurrTaskGet() != NULL) && OS_INT_INACTIVE) {
 8008e42:	f7ff ffbb 	bl	8008dbc <OsCurrTaskGet>
 8008e46:	4603      	mov	r3, r0
 8008e48:	2b00      	cmp	r3, #0
 8008e4a:	d008      	beq.n	8008e5e <OsHeapStatAddUsed+0x32>
 8008e4c:	f7f9 fb0e 	bl	800246c <IntActive>
 8008e50:	4603      	mov	r3, r0
 8008e52:	2b00      	cmp	r3, #0
 8008e54:	d103      	bne.n	8008e5e <OsHeapStatAddUsed+0x32>
        /*
         * after OsTaskInit, OsCurrTaskGet() is not null, but id is the same
         * as (LOSCFG_BASE_CORE_TSK_LIMIT + 1), so it will be recorded into
         * the last one of the array.
         */
        taskId = LOS_CurTaskIDGet();
 8008e56:	f7fa f8d5 	bl	8003004 <LOS_CurTaskIDGet>
 8008e5a:	60b8      	str	r0, [r7, #8]
 8008e5c:	e001      	b.n	8008e62 <OsHeapStatAddUsed+0x36>
    } else {
        taskId = TASK_NUM - 1;
 8008e5e:	2310      	movs	r3, #16
 8008e60:	60bb      	str	r3, [r7, #8]
    }

    node->taskId = taskId;
 8008e62:	683b      	ldr	r3, [r7, #0]
 8008e64:	68ba      	ldr	r2, [r7, #8]
 8008e66:	605a      	str	r2, [r3, #4]
    OS_MEM_ADD_USED(&heapMan->stat, blockSize, taskId);
 8008e68:	687b      	ldr	r3, [r7, #4]
 8008e6a:	330c      	adds	r3, #12
 8008e6c:	68ba      	ldr	r2, [r7, #8]
 8008e6e:	68f9      	ldr	r1, [r7, #12]
 8008e70:	4618      	mov	r0, r3
 8008e72:	f000 fabc 	bl	80093ee <OsMemstatTaskUsedInc>
}
 8008e76:	bf00      	nop
 8008e78:	3710      	adds	r7, #16
 8008e7a:	46bd      	mov	sp, r7
 8008e7c:	bd80      	pop	{r7, pc}

08008e7e <OsHeapStatDecUsed>:

VOID OsHeapStatDecUsed(struct LosHeapManager *heapMan, struct LosHeapNode *node)
{
 8008e7e:	b580      	push	{r7, lr}
 8008e80:	b084      	sub	sp, #16
 8008e82:	af00      	add	r7, sp, #0
 8008e84:	6078      	str	r0, [r7, #4]
 8008e86:	6039      	str	r1, [r7, #0]
    UINT32 taskId = node->taskId;
 8008e88:	683b      	ldr	r3, [r7, #0]
 8008e8a:	685b      	ldr	r3, [r3, #4]
 8008e8c:	60bb      	str	r3, [r7, #8]
    UINT32 blockSize = sizeof(struct LosHeapNode) + node->size;
 8008e8e:	683b      	ldr	r3, [r7, #0]
 8008e90:	689b      	ldr	r3, [r3, #8]
 8008e92:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8008e96:	330c      	adds	r3, #12
 8008e98:	60fb      	str	r3, [r7, #12]

    OS_MEM_REDUCE_USED(&heapMan->stat, blockSize, taskId);
 8008e9a:	687b      	ldr	r3, [r7, #4]
 8008e9c:	330c      	adds	r3, #12
 8008e9e:	68ba      	ldr	r2, [r7, #8]
 8008ea0:	68f9      	ldr	r1, [r7, #12]
 8008ea2:	4618      	mov	r0, r3
 8008ea4:	f000 fae4 	bl	8009470 <OsMemstatTaskUsedDec>
}
 8008ea8:	bf00      	nop
 8008eaa:	3710      	adds	r7, #16
 8008eac:	46bd      	mov	sp, r7
 8008eae:	bd80      	pop	{r7, pc}

08008eb0 <OsHeapIntegrityCheck>:
}

#else /* LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK */

UINT32 OsHeapIntegrityCheck(struct LosHeapManager *heap)
{
 8008eb0:	b480      	push	{r7}
 8008eb2:	b083      	sub	sp, #12
 8008eb4:	af00      	add	r7, sp, #0
 8008eb6:	6078      	str	r0, [r7, #4]
    return LOS_OK;
 8008eb8:	2300      	movs	r3, #0
}
 8008eba:	4618      	mov	r0, r3
 8008ebc:	370c      	adds	r7, #12
 8008ebe:	46bd      	mov	sp, r7
 8008ec0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ec4:	4770      	bx	lr

08008ec6 <OsHeapInit>:
 * Input       : VOID *pool  --- begin address of the heap memory pool
 *               UITN32 size --- size of the heap memory pool
 * Return      : 1:success 0:error
 */
BOOL OsHeapInit(VOID *pool, UINT32 size)
{
 8008ec6:	b580      	push	{r7, lr}
 8008ec8:	b084      	sub	sp, #16
 8008eca:	af00      	add	r7, sp, #0
 8008ecc:	6078      	str	r0, [r7, #4]
 8008ece:	6039      	str	r1, [r7, #0]
    struct LosHeapNode *node = NULL;
 8008ed0:	2300      	movs	r3, #0
 8008ed2:	60bb      	str	r3, [r7, #8]
    struct LosHeapManager *heapMan = HEAP_CAST(struct LosHeapManager *, pool);
 8008ed4:	687b      	ldr	r3, [r7, #4]
 8008ed6:	60fb      	str	r3, [r7, #12]

    if ((heapMan == NULL) || (size <= (sizeof(struct LosHeapNode) + sizeof(struct LosHeapManager)))) {
 8008ed8:	68fb      	ldr	r3, [r7, #12]
 8008eda:	2b00      	cmp	r3, #0
 8008edc:	d002      	beq.n	8008ee4 <OsHeapInit+0x1e>
 8008ede:	683b      	ldr	r3, [r7, #0]
 8008ee0:	2ba8      	cmp	r3, #168	; 0xa8
 8008ee2:	d801      	bhi.n	8008ee8 <OsHeapInit+0x22>
        return FALSE;
 8008ee4:	2300      	movs	r3, #0
 8008ee6:	e02c      	b.n	8008f42 <OsHeapInit+0x7c>
    }

    (VOID)memset_s(pool, size, 0, size);
 8008ee8:	683b      	ldr	r3, [r7, #0]
 8008eea:	2200      	movs	r2, #0
 8008eec:	6839      	ldr	r1, [r7, #0]
 8008eee:	6878      	ldr	r0, [r7, #4]
 8008ef0:	f00d f8cc 	bl	801608c <memset_s>

    heapMan->size = size - sizeof(struct LosHeapManager);
 8008ef4:	683b      	ldr	r3, [r7, #0]
 8008ef6:	f1a3 029c 	sub.w	r2, r3, #156	; 0x9c
 8008efa:	68fb      	ldr	r3, [r7, #12]
 8008efc:	609a      	str	r2, [r3, #8]

    node = heapMan->head = (struct LosHeapNode *)((UINT8*)pool + sizeof(struct LosHeapManager));
 8008efe:	687b      	ldr	r3, [r7, #4]
 8008f00:	f103 029c 	add.w	r2, r3, #156	; 0x9c
 8008f04:	68fb      	ldr	r3, [r7, #12]
 8008f06:	601a      	str	r2, [r3, #0]
 8008f08:	68fb      	ldr	r3, [r7, #12]
 8008f0a:	681b      	ldr	r3, [r3, #0]
 8008f0c:	60bb      	str	r3, [r7, #8]

    heapMan->tail = node;
 8008f0e:	68fb      	ldr	r3, [r7, #12]
 8008f10:	68ba      	ldr	r2, [r7, #8]
 8008f12:	605a      	str	r2, [r3, #4]

    node->used = 0;
 8008f14:	68ba      	ldr	r2, [r7, #8]
 8008f16:	7ad3      	ldrb	r3, [r2, #11]
 8008f18:	f36f 1386 	bfc	r3, #6, #1
 8008f1c:	72d3      	strb	r3, [r2, #11]
    node->prev = NULL;
 8008f1e:	68bb      	ldr	r3, [r7, #8]
 8008f20:	2200      	movs	r2, #0
 8008f22:	601a      	str	r2, [r3, #0]
    node->size = heapMan->size - sizeof(struct LosHeapNode);
 8008f24:	68fb      	ldr	r3, [r7, #12]
 8008f26:	689b      	ldr	r3, [r3, #8]
 8008f28:	3b0c      	subs	r3, #12
 8008f2a:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
 8008f2e:	68ba      	ldr	r2, [r7, #8]
 8008f30:	6893      	ldr	r3, [r2, #8]
 8008f32:	f361 031d 	bfi	r3, r1, #0, #30
 8008f36:	6093      	str	r3, [r2, #8]

    OsHeapStatInit(heapMan, size);
 8008f38:	6839      	ldr	r1, [r7, #0]
 8008f3a:	68f8      	ldr	r0, [r7, #12]
 8008f3c:	f7ff ff5e 	bl	8008dfc <OsHeapStatInit>

    return TRUE;
 8008f40:	2301      	movs	r3, #1
}
 8008f42:	4618      	mov	r0, r3
 8008f44:	3710      	adds	r7, #16
 8008f46:	46bd      	mov	sp, r7
 8008f48:	bd80      	pop	{r7, pc}
	...

08008f4c <OsHeapAlloc>:
 * Input       : VOID *pool --- Pointer to the manager,to distinguish heap
 *               UINT32 size --- size of the heap memory pool
 * Return      : NULL:error, other value:the address of the memory we alloced
 */
VOID *OsHeapAlloc(VOID *pool, UINT32 size)
{
 8008f4c:	b580      	push	{r7, lr}
 8008f4e:	b088      	sub	sp, #32
 8008f50:	af00      	add	r7, sp, #0
 8008f52:	6078      	str	r0, [r7, #4]
 8008f54:	6039      	str	r1, [r7, #0]
    struct LosHeapNode *node = NULL;
 8008f56:	2300      	movs	r3, #0
 8008f58:	60bb      	str	r3, [r7, #8]
    struct LosHeapNode *next = NULL;
 8008f5a:	2300      	movs	r3, #0
 8008f5c:	617b      	str	r3, [r7, #20]
    struct LosHeapNode *best = NULL;
 8008f5e:	2300      	movs	r3, #0
 8008f60:	60fb      	str	r3, [r7, #12]
    VOID *ptr = NULL;
 8008f62:	2300      	movs	r3, #0
 8008f64:	613b      	str	r3, [r7, #16]
    UINT32 alignSize = ALIGNE(size);
 8008f66:	683b      	ldr	r3, [r7, #0]
 8008f68:	3303      	adds	r3, #3
 8008f6a:	f023 0303 	bic.w	r3, r3, #3
 8008f6e:	61bb      	str	r3, [r7, #24]

    struct LosHeapManager *heapMan = HEAP_CAST(struct LosHeapManager *, pool);
 8008f70:	687b      	ldr	r3, [r7, #4]
 8008f72:	61fb      	str	r3, [r7, #28]
    if ((heapMan == NULL) || (size > MALLOC_MAXSIZE)) {
 8008f74:	69fb      	ldr	r3, [r7, #28]
 8008f76:	2b00      	cmp	r3, #0
 8008f78:	d003      	beq.n	8008f82 <OsHeapAlloc+0x36>
 8008f7a:	683b      	ldr	r3, [r7, #0]
 8008f7c:	f113 0f04 	cmn.w	r3, #4
 8008f80:	d901      	bls.n	8008f86 <OsHeapAlloc+0x3a>
        return NULL;
 8008f82:	2300      	movs	r3, #0
 8008f84:	e09a      	b.n	80090bc <OsHeapAlloc+0x170>
    }

    if (OsHeapIntegrityCheck(heapMan) != LOS_OK) {
 8008f86:	69f8      	ldr	r0, [r7, #28]
 8008f88:	f7ff ff92 	bl	8008eb0 <OsHeapIntegrityCheck>
 8008f8c:	4603      	mov	r3, r0
 8008f8e:	2b00      	cmp	r3, #0
 8008f90:	d001      	beq.n	8008f96 <OsHeapAlloc+0x4a>
        return NULL;
 8008f92:	2300      	movs	r3, #0
 8008f94:	e092      	b.n	80090bc <OsHeapAlloc+0x170>
    }

    node = heapMan->tail;
 8008f96:	69fb      	ldr	r3, [r7, #28]
 8008f98:	685b      	ldr	r3, [r3, #4]
 8008f9a:	60bb      	str	r3, [r7, #8]
    while (node != NULL) {
 8008f9c:	e028      	b.n	8008ff0 <OsHeapAlloc+0xa4>
        if ((node->used == 0) && (node->size >= alignSize) &&
 8008f9e:	68bb      	ldr	r3, [r7, #8]
 8008fa0:	7adb      	ldrb	r3, [r3, #11]
 8008fa2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008fa6:	b2db      	uxtb	r3, r3
 8008fa8:	2b00      	cmp	r3, #0
 8008faa:	d11e      	bne.n	8008fea <OsHeapAlloc+0x9e>
 8008fac:	68bb      	ldr	r3, [r7, #8]
 8008fae:	689b      	ldr	r3, [r3, #8]
 8008fb0:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8008fb4:	461a      	mov	r2, r3
 8008fb6:	69bb      	ldr	r3, [r7, #24]
 8008fb8:	4293      	cmp	r3, r2
 8008fba:	d816      	bhi.n	8008fea <OsHeapAlloc+0x9e>
 8008fbc:	68fb      	ldr	r3, [r7, #12]
 8008fbe:	2b00      	cmp	r3, #0
 8008fc0:	d009      	beq.n	8008fd6 <OsHeapAlloc+0x8a>
            ((best == NULL) || (best->size > node->size))) {
 8008fc2:	68fb      	ldr	r3, [r7, #12]
 8008fc4:	689b      	ldr	r3, [r3, #8]
 8008fc6:	f3c3 021d 	ubfx	r2, r3, #0, #30
 8008fca:	68bb      	ldr	r3, [r7, #8]
 8008fcc:	689b      	ldr	r3, [r3, #8]
 8008fce:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8008fd2:	429a      	cmp	r2, r3
 8008fd4:	d909      	bls.n	8008fea <OsHeapAlloc+0x9e>
            best = node;
 8008fd6:	68bb      	ldr	r3, [r7, #8]
 8008fd8:	60fb      	str	r3, [r7, #12]
            if (best->size == alignSize) {
 8008fda:	68fb      	ldr	r3, [r7, #12]
 8008fdc:	689b      	ldr	r3, [r3, #8]
 8008fde:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8008fe2:	461a      	mov	r2, r3
 8008fe4:	69bb      	ldr	r3, [r7, #24]
 8008fe6:	4293      	cmp	r3, r2
 8008fe8:	d053      	beq.n	8009092 <OsHeapAlloc+0x146>
                goto SIZE_MATCH;
            }
        }
        node = node->prev;
 8008fea:	68bb      	ldr	r3, [r7, #8]
 8008fec:	681b      	ldr	r3, [r3, #0]
 8008fee:	60bb      	str	r3, [r7, #8]
    while (node != NULL) {
 8008ff0:	68bb      	ldr	r3, [r7, #8]
 8008ff2:	2b00      	cmp	r3, #0
 8008ff4:	d1d3      	bne.n	8008f9e <OsHeapAlloc+0x52>
    }

    /* alloc failed */
    if (best == NULL) {
 8008ff6:	68fb      	ldr	r3, [r7, #12]
 8008ff8:	2b00      	cmp	r3, #0
 8008ffa:	d107      	bne.n	800900c <OsHeapAlloc+0xc0>
        PRINT_ERR("there's not enough mem to alloc 0x%x Bytes!\n", alignSize);
 8008ffc:	4831      	ldr	r0, [pc, #196]	; (80090c4 <OsHeapAlloc+0x178>)
 8008ffe:	f7fb fb65 	bl	80046cc <dprintf>
 8009002:	69b9      	ldr	r1, [r7, #24]
 8009004:	4830      	ldr	r0, [pc, #192]	; (80090c8 <OsHeapAlloc+0x17c>)
 8009006:	f7fb fb61 	bl	80046cc <dprintf>
        goto OUT;
 800900a:	e056      	b.n	80090ba <OsHeapAlloc+0x16e>
    }

    if ((best->size - alignSize) > sizeof(struct LosHeapNode)) {
 800900c:	68fb      	ldr	r3, [r7, #12]
 800900e:	689b      	ldr	r3, [r3, #8]
 8009010:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009014:	461a      	mov	r2, r3
 8009016:	69bb      	ldr	r3, [r7, #24]
 8009018:	1ad3      	subs	r3, r2, r3
 800901a:	2b0c      	cmp	r3, #12
 800901c:	d93b      	bls.n	8009096 <OsHeapAlloc+0x14a>
        /* hole divide into 2 */
        node = (struct LosHeapNode*)(UINTPTR)(best->data + alignSize);
 800901e:	68fb      	ldr	r3, [r7, #12]
 8009020:	f103 020c 	add.w	r2, r3, #12
 8009024:	69bb      	ldr	r3, [r7, #24]
 8009026:	4413      	add	r3, r2
 8009028:	60bb      	str	r3, [r7, #8]

        node->used = 0;
 800902a:	68ba      	ldr	r2, [r7, #8]
 800902c:	7ad3      	ldrb	r3, [r2, #11]
 800902e:	f36f 1386 	bfc	r3, #6, #1
 8009032:	72d3      	strb	r3, [r2, #11]
        node->size = best->size - alignSize - sizeof(struct LosHeapNode);
 8009034:	68fb      	ldr	r3, [r7, #12]
 8009036:	689b      	ldr	r3, [r3, #8]
 8009038:	f3c3 031d 	ubfx	r3, r3, #0, #30
 800903c:	461a      	mov	r2, r3
 800903e:	69bb      	ldr	r3, [r7, #24]
 8009040:	1ad3      	subs	r3, r2, r3
 8009042:	3b0c      	subs	r3, #12
 8009044:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
 8009048:	68ba      	ldr	r2, [r7, #8]
 800904a:	6893      	ldr	r3, [r2, #8]
 800904c:	f361 031d 	bfi	r3, r1, #0, #30
 8009050:	6093      	str	r3, [r2, #8]
        node->prev = best;
 8009052:	68bb      	ldr	r3, [r7, #8]
 8009054:	68fa      	ldr	r2, [r7, #12]
 8009056:	601a      	str	r2, [r3, #0]

        if (best != heapMan->tail) {
 8009058:	69fb      	ldr	r3, [r7, #28]
 800905a:	685b      	ldr	r3, [r3, #4]
 800905c:	68fa      	ldr	r2, [r7, #12]
 800905e:	429a      	cmp	r2, r3
 8009060:	d00b      	beq.n	800907a <OsHeapAlloc+0x12e>
            next = OsHeapPrvGetNext(heapMan, node);
 8009062:	68b9      	ldr	r1, [r7, #8]
 8009064:	69f8      	ldr	r0, [r7, #28]
 8009066:	f7ff feb0 	bl	8008dca <OsHeapPrvGetNext>
 800906a:	6178      	str	r0, [r7, #20]
            if (next != NULL) {
 800906c:	697b      	ldr	r3, [r7, #20]
 800906e:	2b00      	cmp	r3, #0
 8009070:	d006      	beq.n	8009080 <OsHeapAlloc+0x134>
                next->prev = node;
 8009072:	697b      	ldr	r3, [r7, #20]
 8009074:	68ba      	ldr	r2, [r7, #8]
 8009076:	601a      	str	r2, [r3, #0]
 8009078:	e002      	b.n	8009080 <OsHeapAlloc+0x134>
            }
        } else {
            heapMan->tail = node;
 800907a:	69fb      	ldr	r3, [r7, #28]
 800907c:	68ba      	ldr	r2, [r7, #8]
 800907e:	605a      	str	r2, [r3, #4]
        }

        best->size = alignSize;
 8009080:	69bb      	ldr	r3, [r7, #24]
 8009082:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
 8009086:	68fa      	ldr	r2, [r7, #12]
 8009088:	6893      	ldr	r3, [r2, #8]
 800908a:	f361 031d 	bfi	r3, r1, #0, #30
 800908e:	6093      	str	r3, [r2, #8]
 8009090:	e002      	b.n	8009098 <OsHeapAlloc+0x14c>
                goto SIZE_MATCH;
 8009092:	bf00      	nop
 8009094:	e000      	b.n	8009098 <OsHeapAlloc+0x14c>
    }

SIZE_MATCH:
 8009096:	bf00      	nop
    best->align = 0;
 8009098:	68fa      	ldr	r2, [r7, #12]
 800909a:	7ad3      	ldrb	r3, [r2, #11]
 800909c:	f36f 13c7 	bfc	r3, #7, #1
 80090a0:	72d3      	strb	r3, [r2, #11]
    best->used = 1;
 80090a2:	68fa      	ldr	r2, [r7, #12]
 80090a4:	7ad3      	ldrb	r3, [r2, #11]
 80090a6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80090aa:	72d3      	strb	r3, [r2, #11]
    ptr = best->data;
 80090ac:	68fb      	ldr	r3, [r7, #12]
 80090ae:	330c      	adds	r3, #12
 80090b0:	613b      	str	r3, [r7, #16]

    OsHeapStatAddUsed(heapMan, best);
 80090b2:	68f9      	ldr	r1, [r7, #12]
 80090b4:	69f8      	ldr	r0, [r7, #28]
 80090b6:	f7ff feb9 	bl	8008e2c <OsHeapStatAddUsed>
OUT:
    return ptr;
 80090ba:	693b      	ldr	r3, [r7, #16]
}
 80090bc:	4618      	mov	r0, r3
 80090be:	3720      	adds	r7, #32
 80090c0:	46bd      	mov	sp, r7
 80090c2:	bd80      	pop	{r7, pc}
 80090c4:	08021418 	.word	0x08021418
 80090c8:	08021420 	.word	0x08021420

080090cc <OsHeapAllocAlign>:
 *               UINT32 size   --- size of the heap memory pool
 *               UINT32 boundary --- boundary the heap needs align
 * Return      : NULL:error, other value:the address of the memory we alloced
 */
VOID* OsHeapAllocAlign(VOID *pool, UINT32 size, UINT32 boundary)
{
 80090cc:	b580      	push	{r7, lr}
 80090ce:	b088      	sub	sp, #32
 80090d0:	af00      	add	r7, sp, #0
 80090d2:	60f8      	str	r0, [r7, #12]
 80090d4:	60b9      	str	r1, [r7, #8]
 80090d6:	607a      	str	r2, [r7, #4]
    UINT32 useSize;
    UINT32 gapSize;
    VOID *ptr = NULL;
 80090d8:	2300      	movs	r3, #0
 80090da:	613b      	str	r3, [r7, #16]
    VOID *alignedPtr = NULL;
 80090dc:	2300      	movs	r3, #0
 80090de:	617b      	str	r3, [r7, #20]

    if ((pool == NULL) || (size == 0) || (boundary < sizeof(VOID *)) || !IS_ALIGNED(boundary, boundary)) {
 80090e0:	68fb      	ldr	r3, [r7, #12]
 80090e2:	2b00      	cmp	r3, #0
 80090e4:	d00b      	beq.n	80090fe <OsHeapAllocAlign+0x32>
 80090e6:	68bb      	ldr	r3, [r7, #8]
 80090e8:	2b00      	cmp	r3, #0
 80090ea:	d008      	beq.n	80090fe <OsHeapAllocAlign+0x32>
 80090ec:	687b      	ldr	r3, [r7, #4]
 80090ee:	2b03      	cmp	r3, #3
 80090f0:	d905      	bls.n	80090fe <OsHeapAllocAlign+0x32>
 80090f2:	687b      	ldr	r3, [r7, #4]
 80090f4:	1e5a      	subs	r2, r3, #1
 80090f6:	687b      	ldr	r3, [r7, #4]
 80090f8:	4013      	ands	r3, r2
 80090fa:	2b00      	cmp	r3, #0
 80090fc:	d001      	beq.n	8009102 <OsHeapAllocAlign+0x36>
        return NULL;
 80090fe:	2300      	movs	r3, #0
 8009100:	e032      	b.n	8009168 <OsHeapAllocAlign+0x9c>
    }

    /* worst case is that the node happen to be 4 bytes ahead of the boundary */
    useSize = (size + boundary) - sizeof(VOID*);
 8009102:	68ba      	ldr	r2, [r7, #8]
 8009104:	687b      	ldr	r3, [r7, #4]
 8009106:	4413      	add	r3, r2
 8009108:	3b04      	subs	r3, #4
 800910a:	61bb      	str	r3, [r7, #24]
    if (useSize < size) {
 800910c:	69ba      	ldr	r2, [r7, #24]
 800910e:	68bb      	ldr	r3, [r7, #8]
 8009110:	429a      	cmp	r2, r3
 8009112:	d201      	bcs.n	8009118 <OsHeapAllocAlign+0x4c>
        return NULL;
 8009114:	2300      	movs	r3, #0
 8009116:	e027      	b.n	8009168 <OsHeapAllocAlign+0x9c>
    }

    ptr = OsHeapAlloc(pool, useSize);
 8009118:	69b9      	ldr	r1, [r7, #24]
 800911a:	68f8      	ldr	r0, [r7, #12]
 800911c:	f7ff ff16 	bl	8008f4c <OsHeapAlloc>
 8009120:	6138      	str	r0, [r7, #16]
    if (ptr != NULL) {
 8009122:	693b      	ldr	r3, [r7, #16]
 8009124:	2b00      	cmp	r3, #0
 8009126:	d01b      	beq.n	8009160 <OsHeapAllocAlign+0x94>
        alignedPtr = (VOID *)(UINTPTR)OS_MEM_ALIGN(ptr, boundary);
 8009128:	693a      	ldr	r2, [r7, #16]
 800912a:	687b      	ldr	r3, [r7, #4]
 800912c:	4413      	add	r3, r2
 800912e:	1e5a      	subs	r2, r3, #1
 8009130:	687b      	ldr	r3, [r7, #4]
 8009132:	425b      	negs	r3, r3
 8009134:	4013      	ands	r3, r2
 8009136:	617b      	str	r3, [r7, #20]
        if (alignedPtr == ptr) {
 8009138:	697a      	ldr	r2, [r7, #20]
 800913a:	693b      	ldr	r3, [r7, #16]
 800913c:	429a      	cmp	r2, r3
 800913e:	d011      	beq.n	8009164 <OsHeapAllocAlign+0x98>
            goto OUT;
        }

        gapSize = (UINTPTR)alignedPtr - (UINTPTR)ptr;
 8009140:	697a      	ldr	r2, [r7, #20]
 8009142:	693b      	ldr	r3, [r7, #16]
 8009144:	1ad3      	subs	r3, r2, r3
 8009146:	61fb      	str	r3, [r7, #28]
        OS_MEM_SET_ALIGN_FLAG(gapSize);
 8009148:	69fb      	ldr	r3, [r7, #28]
 800914a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800914e:	61fb      	str	r3, [r7, #28]
        *((UINT32 *)((UINTPTR)alignedPtr - sizeof(UINTPTR))) = gapSize;
 8009150:	697b      	ldr	r3, [r7, #20]
 8009152:	3b04      	subs	r3, #4
 8009154:	461a      	mov	r2, r3
 8009156:	69fb      	ldr	r3, [r7, #28]
 8009158:	6013      	str	r3, [r2, #0]

        ptr = alignedPtr;
 800915a:	697b      	ldr	r3, [r7, #20]
 800915c:	613b      	str	r3, [r7, #16]
 800915e:	e002      	b.n	8009166 <OsHeapAllocAlign+0x9a>
    }
OUT:
 8009160:	bf00      	nop
 8009162:	e000      	b.n	8009166 <OsHeapAllocAlign+0x9a>
            goto OUT;
 8009164:	bf00      	nop
    return ptr;
 8009166:	693b      	ldr	r3, [r7, #16]
}
 8009168:	4618      	mov	r0, r3
 800916a:	3720      	adds	r7, #32
 800916c:	46bd      	mov	sp, r7
 800916e:	bd80      	pop	{r7, pc}

08009170 <OsHeapDoFree>:

STATIC VOID OsHeapDoFree(struct LosHeapManager *heapMan, struct LosHeapNode *curNode)
{
 8009170:	b580      	push	{r7, lr}
 8009172:	b084      	sub	sp, #16
 8009174:	af00      	add	r7, sp, #0
 8009176:	6078      	str	r0, [r7, #4]
 8009178:	6039      	str	r1, [r7, #0]
    struct LosHeapNode *node = curNode;
 800917a:	683b      	ldr	r3, [r7, #0]
 800917c:	60bb      	str	r3, [r7, #8]
    struct LosHeapNode *next = NULL;
 800917e:	2300      	movs	r3, #0
 8009180:	60fb      	str	r3, [r7, #12]
    /* set to unused status */
    node->used = 0;
 8009182:	68ba      	ldr	r2, [r7, #8]
 8009184:	7ad3      	ldrb	r3, [r2, #11]
 8009186:	f36f 1386 	bfc	r3, #6, #1
 800918a:	72d3      	strb	r3, [r2, #11]

    /* unused region before and after combination */
    while ((node->prev) && (!node->prev->used)) {
 800918c:	e002      	b.n	8009194 <OsHeapDoFree+0x24>
        node = node->prev;
 800918e:	68bb      	ldr	r3, [r7, #8]
 8009190:	681b      	ldr	r3, [r3, #0]
 8009192:	60bb      	str	r3, [r7, #8]
    while ((node->prev) && (!node->prev->used)) {
 8009194:	68bb      	ldr	r3, [r7, #8]
 8009196:	681b      	ldr	r3, [r3, #0]
 8009198:	2b00      	cmp	r3, #0
 800919a:	d007      	beq.n	80091ac <OsHeapDoFree+0x3c>
 800919c:	68bb      	ldr	r3, [r7, #8]
 800919e:	681b      	ldr	r3, [r3, #0]
 80091a0:	7adb      	ldrb	r3, [r3, #11]
 80091a2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80091a6:	b2db      	uxtb	r3, r3
 80091a8:	2b00      	cmp	r3, #0
 80091aa:	d0f0      	beq.n	800918e <OsHeapDoFree+0x1e>
    }

    next = OsHeapPrvGetNext(heapMan, node);
 80091ac:	68b9      	ldr	r1, [r7, #8]
 80091ae:	6878      	ldr	r0, [r7, #4]
 80091b0:	f7ff fe0b 	bl	8008dca <OsHeapPrvGetNext>
 80091b4:	60f8      	str	r0, [r7, #12]
    while (next != NULL) {
 80091b6:	e029      	b.n	800920c <OsHeapDoFree+0x9c>
        if (next->used) {
 80091b8:	68fb      	ldr	r3, [r7, #12]
 80091ba:	7adb      	ldrb	r3, [r3, #11]
 80091bc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80091c0:	b2db      	uxtb	r3, r3
 80091c2:	2b00      	cmp	r3, #0
 80091c4:	d003      	beq.n	80091ce <OsHeapDoFree+0x5e>
            next->prev = node;
 80091c6:	68fb      	ldr	r3, [r7, #12]
 80091c8:	68ba      	ldr	r2, [r7, #8]
 80091ca:	601a      	str	r2, [r3, #0]
            break;
 80091cc:	e022      	b.n	8009214 <OsHeapDoFree+0xa4>
        }
        node->size += (sizeof(struct LosHeapNode) + next->size);
 80091ce:	68bb      	ldr	r3, [r7, #8]
 80091d0:	689b      	ldr	r3, [r3, #8]
 80091d2:	f3c3 031d 	ubfx	r3, r3, #0, #30
 80091d6:	461a      	mov	r2, r3
 80091d8:	68fb      	ldr	r3, [r7, #12]
 80091da:	689b      	ldr	r3, [r3, #8]
 80091dc:	f3c3 031d 	ubfx	r3, r3, #0, #30
 80091e0:	4413      	add	r3, r2
 80091e2:	330c      	adds	r3, #12
 80091e4:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
 80091e8:	68ba      	ldr	r2, [r7, #8]
 80091ea:	6893      	ldr	r3, [r2, #8]
 80091ec:	f361 031d 	bfi	r3, r1, #0, #30
 80091f0:	6093      	str	r3, [r2, #8]
        if (heapMan->tail == next) {
 80091f2:	687b      	ldr	r3, [r7, #4]
 80091f4:	685b      	ldr	r3, [r3, #4]
 80091f6:	68fa      	ldr	r2, [r7, #12]
 80091f8:	429a      	cmp	r2, r3
 80091fa:	d102      	bne.n	8009202 <OsHeapDoFree+0x92>
            heapMan->tail = node;
 80091fc:	687b      	ldr	r3, [r7, #4]
 80091fe:	68ba      	ldr	r2, [r7, #8]
 8009200:	605a      	str	r2, [r3, #4]
        }
        next = OsHeapPrvGetNext(heapMan, node);
 8009202:	68b9      	ldr	r1, [r7, #8]
 8009204:	6878      	ldr	r0, [r7, #4]
 8009206:	f7ff fde0 	bl	8008dca <OsHeapPrvGetNext>
 800920a:	60f8      	str	r0, [r7, #12]
    while (next != NULL) {
 800920c:	68fb      	ldr	r3, [r7, #12]
 800920e:	2b00      	cmp	r3, #0
 8009210:	d1d2      	bne.n	80091b8 <OsHeapDoFree+0x48>
    }
}
 8009212:	bf00      	nop
 8009214:	bf00      	nop
 8009216:	3710      	adds	r7, #16
 8009218:	46bd      	mov	sp, r7
 800921a:	bd80      	pop	{r7, pc}

0800921c <OsHeapFree>:
 * Input       : VOID* pool --- Pointer to the manager,to distinguish heap
 *               VOID* ptr --- the pointer of heap memory we want to free
 * Return      : 1:success 0:error
 */
BOOL OsHeapFree(VOID *pool, const VOID *ptr)
{
 800921c:	b580      	push	{r7, lr}
 800921e:	b086      	sub	sp, #24
 8009220:	af00      	add	r7, sp, #0
 8009222:	6078      	str	r0, [r7, #4]
 8009224:	6039      	str	r1, [r7, #0]
    struct LosHeapNode *node = NULL;
 8009226:	2300      	movs	r3, #0
 8009228:	60fb      	str	r3, [r7, #12]

    UINT32 gapSize;
    BOOL ret = TRUE;
 800922a:	2301      	movs	r3, #1
 800922c:	60bb      	str	r3, [r7, #8]

    struct LosHeapManager *heapMan = HEAP_CAST(struct LosHeapManager *, pool);
 800922e:	687b      	ldr	r3, [r7, #4]
 8009230:	613b      	str	r3, [r7, #16]
    if ((heapMan == NULL) || (ptr == NULL)) {
 8009232:	693b      	ldr	r3, [r7, #16]
 8009234:	2b00      	cmp	r3, #0
 8009236:	d002      	beq.n	800923e <OsHeapFree+0x22>
 8009238:	683b      	ldr	r3, [r7, #0]
 800923a:	2b00      	cmp	r3, #0
 800923c:	d101      	bne.n	8009242 <OsHeapFree+0x26>
        return LOS_NOK;
 800923e:	2301      	movs	r3, #1
 8009240:	e05b      	b.n	80092fa <OsHeapFree+0xde>
    }

    /* find the real ptr through gap size */
    gapSize = *((UINT32 *)((UINTPTR)ptr - sizeof(UINTPTR)));
 8009242:	683b      	ldr	r3, [r7, #0]
 8009244:	3b04      	subs	r3, #4
 8009246:	681b      	ldr	r3, [r3, #0]
 8009248:	617b      	str	r3, [r7, #20]
    if (OS_MEM_GET_ALIGN_FLAG(gapSize)) {
 800924a:	697b      	ldr	r3, [r7, #20]
 800924c:	2b00      	cmp	r3, #0
 800924e:	da07      	bge.n	8009260 <OsHeapFree+0x44>
        gapSize = OS_MEM_GET_ALIGN_GAPSIZE(gapSize);
 8009250:	697b      	ldr	r3, [r7, #20]
 8009252:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009256:	617b      	str	r3, [r7, #20]
        ptr = (VOID *)((UINTPTR)ptr - gapSize);
 8009258:	683a      	ldr	r2, [r7, #0]
 800925a:	697b      	ldr	r3, [r7, #20]
 800925c:	1ad3      	subs	r3, r2, r3
 800925e:	603b      	str	r3, [r7, #0]
    }

    if (((UINTPTR)ptr < (UINTPTR)heapMan->head) ||
 8009260:	693b      	ldr	r3, [r7, #16]
 8009262:	681b      	ldr	r3, [r3, #0]
 8009264:	461a      	mov	r2, r3
 8009266:	683b      	ldr	r3, [r7, #0]
 8009268:	429a      	cmp	r2, r3
 800926a:	d806      	bhi.n	800927a <OsHeapFree+0x5e>
        ((UINTPTR)ptr > ((UINTPTR)heapMan->tail + sizeof(struct LosHeapNode)))) {
 800926c:	693b      	ldr	r3, [r7, #16]
 800926e:	685b      	ldr	r3, [r3, #4]
 8009270:	f103 020c 	add.w	r2, r3, #12
 8009274:	683b      	ldr	r3, [r7, #0]
    if (((UINTPTR)ptr < (UINTPTR)heapMan->head) ||
 8009276:	429a      	cmp	r2, r3
 8009278:	d209      	bcs.n	800928e <OsHeapFree+0x72>
        PRINT_ERR("0x%lx out of range!\n", (UINTPTR)ptr);
 800927a:	4822      	ldr	r0, [pc, #136]	; (8009304 <OsHeapFree+0xe8>)
 800927c:	f7fb fa26 	bl	80046cc <dprintf>
 8009280:	683b      	ldr	r3, [r7, #0]
 8009282:	4619      	mov	r1, r3
 8009284:	4820      	ldr	r0, [pc, #128]	; (8009308 <OsHeapFree+0xec>)
 8009286:	f7fb fa21 	bl	80046cc <dprintf>
        return FALSE;
 800928a:	2300      	movs	r3, #0
 800928c:	e035      	b.n	80092fa <OsHeapFree+0xde>
    }

    node = ((struct LosHeapNode *)ptr) - 1;
 800928e:	683b      	ldr	r3, [r7, #0]
 8009290:	3b0c      	subs	r3, #12
 8009292:	60fb      	str	r3, [r7, #12]
    /* check if the address is a node of the heap memory list */
    if ((node->used == 0) || (!((UINTPTR)node == (UINTPTR)heapMan->head) &&
 8009294:	68fb      	ldr	r3, [r7, #12]
 8009296:	7adb      	ldrb	r3, [r3, #11]
 8009298:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800929c:	b2db      	uxtb	r3, r3
 800929e:	2b00      	cmp	r3, #0
 80092a0:	d01f      	beq.n	80092e2 <OsHeapFree+0xc6>
 80092a2:	693b      	ldr	r3, [r7, #16]
 80092a4:	681b      	ldr	r3, [r3, #0]
 80092a6:	461a      	mov	r2, r3
 80092a8:	68fb      	ldr	r3, [r7, #12]
 80092aa:	429a      	cmp	r2, r3
 80092ac:	d01c      	beq.n	80092e8 <OsHeapFree+0xcc>
        (((UINTPTR)node->prev < (UINTPTR)heapMan->head) ||
 80092ae:	68fb      	ldr	r3, [r7, #12]
 80092b0:	681b      	ldr	r3, [r3, #0]
 80092b2:	461a      	mov	r2, r3
 80092b4:	693b      	ldr	r3, [r7, #16]
 80092b6:	681b      	ldr	r3, [r3, #0]
    if ((node->used == 0) || (!((UINTPTR)node == (UINTPTR)heapMan->head) &&
 80092b8:	429a      	cmp	r2, r3
 80092ba:	d312      	bcc.n	80092e2 <OsHeapFree+0xc6>
        ((UINTPTR)node->prev > ((UINTPTR)heapMan->tail + sizeof(struct LosHeapNode))) ||
 80092bc:	68fb      	ldr	r3, [r7, #12]
 80092be:	681b      	ldr	r3, [r3, #0]
 80092c0:	461a      	mov	r2, r3
 80092c2:	693b      	ldr	r3, [r7, #16]
 80092c4:	685b      	ldr	r3, [r3, #4]
 80092c6:	330c      	adds	r3, #12
        (((UINTPTR)node->prev < (UINTPTR)heapMan->head) ||
 80092c8:	429a      	cmp	r2, r3
 80092ca:	d80a      	bhi.n	80092e2 <OsHeapFree+0xc6>
        ((UINTPTR)OsHeapPrvGetNext(heapMan, node->prev) != (UINTPTR)node)))) {
 80092cc:	68fb      	ldr	r3, [r7, #12]
 80092ce:	681b      	ldr	r3, [r3, #0]
 80092d0:	4619      	mov	r1, r3
 80092d2:	6938      	ldr	r0, [r7, #16]
 80092d4:	f7ff fd79 	bl	8008dca <OsHeapPrvGetNext>
 80092d8:	4603      	mov	r3, r0
 80092da:	461a      	mov	r2, r3
 80092dc:	68fb      	ldr	r3, [r7, #12]
        ((UINTPTR)node->prev > ((UINTPTR)heapMan->tail + sizeof(struct LosHeapNode))) ||
 80092de:	429a      	cmp	r2, r3
 80092e0:	d002      	beq.n	80092e8 <OsHeapFree+0xcc>
        ret = FALSE;
 80092e2:	2300      	movs	r3, #0
 80092e4:	60bb      	str	r3, [r7, #8]
        goto OUT;
 80092e6:	e007      	b.n	80092f8 <OsHeapFree+0xdc>
    }

    OsHeapStatDecUsed(heapMan, node);
 80092e8:	68f9      	ldr	r1, [r7, #12]
 80092ea:	6938      	ldr	r0, [r7, #16]
 80092ec:	f7ff fdc7 	bl	8008e7e <OsHeapStatDecUsed>
    OsHeapDoFree(heapMan, node);
 80092f0:	68f9      	ldr	r1, [r7, #12]
 80092f2:	6938      	ldr	r0, [r7, #16]
 80092f4:	f7ff ff3c 	bl	8009170 <OsHeapDoFree>

OUT:
    return ret;
 80092f8:	68bb      	ldr	r3, [r7, #8]
}
 80092fa:	4618      	mov	r0, r3
 80092fc:	3718      	adds	r7, #24
 80092fe:	46bd      	mov	sp, r7
 8009300:	bd80      	pop	{r7, pc}
 8009302:	bf00      	nop
 8009304:	08021418 	.word	0x08021418
 8009308:	08021450 	.word	0x08021450

0800930c <OsHeapStatisticsGet>:
 * Input       : pool --- Pointer to the manager, to distinguish heap
 * Output      : status --- heap statistics
 * Return      : LOS_OK on success or error code on failure
 */
UINT32 OsHeapStatisticsGet(VOID *pool, LosHeapStatus *status)
{
 800930c:	b480      	push	{r7}
 800930e:	b089      	sub	sp, #36	; 0x24
 8009310:	af00      	add	r7, sp, #0
 8009312:	6078      	str	r0, [r7, #4]
 8009314:	6039      	str	r1, [r7, #0]
    UINT32 heapUsed = 0;
 8009316:	2300      	movs	r3, #0
 8009318:	60bb      	str	r3, [r7, #8]
    UINT32 maxFreeNodeSize = 0;
 800931a:	2300      	movs	r3, #0
 800931c:	60fb      	str	r3, [r7, #12]
    UINT32 freeNodeNum = 0;
 800931e:	2300      	movs	r3, #0
 8009320:	613b      	str	r3, [r7, #16]
    UINT32 usedNodeNum = 0;
 8009322:	2300      	movs	r3, #0
 8009324:	617b      	str	r3, [r7, #20]

    struct LosHeapNode *node = NULL;
 8009326:	2300      	movs	r3, #0
 8009328:	61bb      	str	r3, [r7, #24]
    struct LosHeapManager *ramHeap = HEAP_CAST(struct LosHeapManager *, pool);
 800932a:	687b      	ldr	r3, [r7, #4]
 800932c:	61fb      	str	r3, [r7, #28]

    if (ramHeap == NULL) {
 800932e:	69fb      	ldr	r3, [r7, #28]
 8009330:	2b00      	cmp	r3, #0
 8009332:	d101      	bne.n	8009338 <OsHeapStatisticsGet+0x2c>
        return LOS_NOK;
 8009334:	2301      	movs	r3, #1
 8009336:	e054      	b.n	80093e2 <OsHeapStatisticsGet+0xd6>
    }

    if (status == NULL) {
 8009338:	683b      	ldr	r3, [r7, #0]
 800933a:	2b00      	cmp	r3, #0
 800933c:	d101      	bne.n	8009342 <OsHeapStatisticsGet+0x36>
        return LOS_NOK;
 800933e:	2301      	movs	r3, #1
 8009340:	e04f      	b.n	80093e2 <OsHeapStatisticsGet+0xd6>
    }

    /* heap manager header use heap space */
    heapUsed += sizeof(struct LosHeapManager);
 8009342:	68bb      	ldr	r3, [r7, #8]
 8009344:	339c      	adds	r3, #156	; 0x9c
 8009346:	60bb      	str	r3, [r7, #8]

    node = ramHeap->tail;
 8009348:	69fb      	ldr	r3, [r7, #28]
 800934a:	685b      	ldr	r3, [r3, #4]
 800934c:	61bb      	str	r3, [r7, #24]
    while (node != NULL) {
 800934e:	e026      	b.n	800939e <OsHeapStatisticsGet+0x92>
        if (node->used) {
 8009350:	69bb      	ldr	r3, [r7, #24]
 8009352:	7adb      	ldrb	r3, [r3, #11]
 8009354:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009358:	b2db      	uxtb	r3, r3
 800935a:	2b00      	cmp	r3, #0
 800935c:	d00c      	beq.n	8009378 <OsHeapStatisticsGet+0x6c>
            heapUsed += (node->size + sizeof(struct LosHeapNode));
 800935e:	69bb      	ldr	r3, [r7, #24]
 8009360:	689b      	ldr	r3, [r3, #8]
 8009362:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009366:	461a      	mov	r2, r3
 8009368:	68bb      	ldr	r3, [r7, #8]
 800936a:	4413      	add	r3, r2
 800936c:	330c      	adds	r3, #12
 800936e:	60bb      	str	r3, [r7, #8]
            usedNodeNum++;
 8009370:	697b      	ldr	r3, [r7, #20]
 8009372:	3301      	adds	r3, #1
 8009374:	617b      	str	r3, [r7, #20]
 8009376:	e00f      	b.n	8009398 <OsHeapStatisticsGet+0x8c>
        } else {
            if (node->size > maxFreeNodeSize) {
 8009378:	69bb      	ldr	r3, [r7, #24]
 800937a:	689b      	ldr	r3, [r3, #8]
 800937c:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009380:	461a      	mov	r2, r3
 8009382:	68fb      	ldr	r3, [r7, #12]
 8009384:	4293      	cmp	r3, r2
 8009386:	d204      	bcs.n	8009392 <OsHeapStatisticsGet+0x86>
                maxFreeNodeSize = node->size;
 8009388:	69bb      	ldr	r3, [r7, #24]
 800938a:	689b      	ldr	r3, [r3, #8]
 800938c:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009390:	60fb      	str	r3, [r7, #12]
            }
            freeNodeNum++;
 8009392:	693b      	ldr	r3, [r7, #16]
 8009394:	3301      	adds	r3, #1
 8009396:	613b      	str	r3, [r7, #16]
        }
        node = node->prev;
 8009398:	69bb      	ldr	r3, [r7, #24]
 800939a:	681b      	ldr	r3, [r3, #0]
 800939c:	61bb      	str	r3, [r7, #24]
    while (node != NULL) {
 800939e:	69bb      	ldr	r3, [r7, #24]
 80093a0:	2b00      	cmp	r3, #0
 80093a2:	d1d5      	bne.n	8009350 <OsHeapStatisticsGet+0x44>
    }

    if (ramHeap->size < heapUsed) {
 80093a4:	69fb      	ldr	r3, [r7, #28]
 80093a6:	689b      	ldr	r3, [r3, #8]
 80093a8:	68ba      	ldr	r2, [r7, #8]
 80093aa:	429a      	cmp	r2, r3
 80093ac:	d901      	bls.n	80093b2 <OsHeapStatisticsGet+0xa6>
        return LOS_NOK;
 80093ae:	2301      	movs	r3, #1
 80093b0:	e017      	b.n	80093e2 <OsHeapStatisticsGet+0xd6>
    }

    status->totalUsedSize = heapUsed;
 80093b2:	683b      	ldr	r3, [r7, #0]
 80093b4:	68ba      	ldr	r2, [r7, #8]
 80093b6:	601a      	str	r2, [r3, #0]
    status->maxFreeNodeSize = maxFreeNodeSize;
 80093b8:	683b      	ldr	r3, [r7, #0]
 80093ba:	68fa      	ldr	r2, [r7, #12]
 80093bc:	609a      	str	r2, [r3, #8]
    status->totalFreeSize = ramHeap->size - status->totalUsedSize;
 80093be:	69fb      	ldr	r3, [r7, #28]
 80093c0:	689a      	ldr	r2, [r3, #8]
 80093c2:	683b      	ldr	r3, [r7, #0]
 80093c4:	681b      	ldr	r3, [r3, #0]
 80093c6:	1ad2      	subs	r2, r2, r3
 80093c8:	683b      	ldr	r3, [r7, #0]
 80093ca:	605a      	str	r2, [r3, #4]
    status->usedNodeNum = usedNodeNum;
 80093cc:	683b      	ldr	r3, [r7, #0]
 80093ce:	697a      	ldr	r2, [r7, #20]
 80093d0:	60da      	str	r2, [r3, #12]
    status->freeNodeNum = freeNodeNum;
 80093d2:	683b      	ldr	r3, [r7, #0]
 80093d4:	693a      	ldr	r2, [r7, #16]
 80093d6:	611a      	str	r2, [r3, #16]

#ifdef LOSCFG_MEM_TASK_STAT
    status->usageWaterLine = ramHeap->stat.memTotalPeak;
 80093d8:	69fb      	ldr	r3, [r7, #28]
 80093da:	691a      	ldr	r2, [r3, #16]
 80093dc:	683b      	ldr	r3, [r7, #0]
 80093de:	615a      	str	r2, [r3, #20]
#endif

    return LOS_OK;
 80093e0:	2300      	movs	r3, #0
}
 80093e2:	4618      	mov	r0, r3
 80093e4:	3724      	adds	r7, #36	; 0x24
 80093e6:	46bd      	mov	sp, r7
 80093e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80093ec:	4770      	bx	lr

080093ee <OsMemstatTaskUsedInc>:

#define MIN_TASK_ID(x, y)               ((x) > (y) ? (y) : (x))
#define MAX_MEM_USE(x, y)               ((x) > (y) ? (x) : (y))

LITE_OS_SEC_TEXT_MINOR VOID OsMemstatTaskUsedInc(Memstat *stat, UINT32 usedSize, UINT32 taskId)
{
 80093ee:	b480      	push	{r7}
 80093f0:	b087      	sub	sp, #28
 80093f2:	af00      	add	r7, sp, #0
 80093f4:	60f8      	str	r0, [r7, #12]
 80093f6:	60b9      	str	r1, [r7, #8]
 80093f8:	607a      	str	r2, [r7, #4]
    UINT32 record = MIN_TASK_ID(taskId, TASK_NUM - 1);
 80093fa:	687b      	ldr	r3, [r7, #4]
 80093fc:	2b10      	cmp	r3, #16
 80093fe:	bf28      	it	cs
 8009400:	2310      	movcs	r3, #16
 8009402:	613b      	str	r3, [r7, #16]
    TaskMemUsedInfo *taskMemstats = stat->taskMemstats;
 8009404:	68fb      	ldr	r3, [r7, #12]
 8009406:	3308      	adds	r3, #8
 8009408:	617b      	str	r3, [r7, #20]

    taskMemstats[record].memUsed += usedSize;
 800940a:	693b      	ldr	r3, [r7, #16]
 800940c:	00db      	lsls	r3, r3, #3
 800940e:	697a      	ldr	r2, [r7, #20]
 8009410:	4413      	add	r3, r2
 8009412:	6819      	ldr	r1, [r3, #0]
 8009414:	693b      	ldr	r3, [r7, #16]
 8009416:	00db      	lsls	r3, r3, #3
 8009418:	697a      	ldr	r2, [r7, #20]
 800941a:	4413      	add	r3, r2
 800941c:	68ba      	ldr	r2, [r7, #8]
 800941e:	440a      	add	r2, r1
 8009420:	601a      	str	r2, [r3, #0]
    taskMemstats[record].memPeak = MAX_MEM_USE(taskMemstats[record].memPeak, taskMemstats[record].memUsed);
 8009422:	693b      	ldr	r3, [r7, #16]
 8009424:	00db      	lsls	r3, r3, #3
 8009426:	697a      	ldr	r2, [r7, #20]
 8009428:	4413      	add	r3, r2
 800942a:	6819      	ldr	r1, [r3, #0]
 800942c:	693b      	ldr	r3, [r7, #16]
 800942e:	00db      	lsls	r3, r3, #3
 8009430:	697a      	ldr	r2, [r7, #20]
 8009432:	4413      	add	r3, r2
 8009434:	685a      	ldr	r2, [r3, #4]
 8009436:	693b      	ldr	r3, [r7, #16]
 8009438:	00db      	lsls	r3, r3, #3
 800943a:	6978      	ldr	r0, [r7, #20]
 800943c:	4403      	add	r3, r0
 800943e:	428a      	cmp	r2, r1
 8009440:	bf38      	it	cc
 8009442:	460a      	movcc	r2, r1
 8009444:	605a      	str	r2, [r3, #4]

    stat->memTotalUsed += usedSize;
 8009446:	68fb      	ldr	r3, [r7, #12]
 8009448:	681a      	ldr	r2, [r3, #0]
 800944a:	68bb      	ldr	r3, [r7, #8]
 800944c:	441a      	add	r2, r3
 800944e:	68fb      	ldr	r3, [r7, #12]
 8009450:	601a      	str	r2, [r3, #0]
    stat->memTotalPeak = MAX_MEM_USE(stat->memTotalPeak, stat->memTotalUsed);
 8009452:	68fb      	ldr	r3, [r7, #12]
 8009454:	681a      	ldr	r2, [r3, #0]
 8009456:	68fb      	ldr	r3, [r7, #12]
 8009458:	685b      	ldr	r3, [r3, #4]
 800945a:	429a      	cmp	r2, r3
 800945c:	bf38      	it	cc
 800945e:	461a      	movcc	r2, r3
 8009460:	68fb      	ldr	r3, [r7, #12]
 8009462:	605a      	str	r2, [r3, #4]
}
 8009464:	bf00      	nop
 8009466:	371c      	adds	r7, #28
 8009468:	46bd      	mov	sp, r7
 800946a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800946e:	4770      	bx	lr

08009470 <OsMemstatTaskUsedDec>:

LITE_OS_SEC_TEXT_MINOR VOID OsMemstatTaskUsedDec(Memstat *stat, UINT32 usedSize, UINT32 taskId)
{
 8009470:	b480      	push	{r7}
 8009472:	b087      	sub	sp, #28
 8009474:	af00      	add	r7, sp, #0
 8009476:	60f8      	str	r0, [r7, #12]
 8009478:	60b9      	str	r1, [r7, #8]
 800947a:	607a      	str	r2, [r7, #4]
    UINT32 record = MIN_TASK_ID(taskId, TASK_NUM - 1);
 800947c:	687b      	ldr	r3, [r7, #4]
 800947e:	2b10      	cmp	r3, #16
 8009480:	bf28      	it	cs
 8009482:	2310      	movcs	r3, #16
 8009484:	613b      	str	r3, [r7, #16]
    TaskMemUsedInfo *taskMemstats = stat->taskMemstats;
 8009486:	68fb      	ldr	r3, [r7, #12]
 8009488:	3308      	adds	r3, #8
 800948a:	617b      	str	r3, [r7, #20]

    if (taskMemstats[record].memUsed < usedSize) {
 800948c:	693b      	ldr	r3, [r7, #16]
 800948e:	00db      	lsls	r3, r3, #3
 8009490:	697a      	ldr	r2, [r7, #20]
 8009492:	4413      	add	r3, r2
 8009494:	681b      	ldr	r3, [r3, #0]
 8009496:	68ba      	ldr	r2, [r7, #8]
 8009498:	429a      	cmp	r2, r3
 800949a:	d812      	bhi.n	80094c2 <OsMemstatTaskUsedDec+0x52>
        PRINT_INFO("mem used of current task '%s':0x%x, decrease size:0x%x\n",
                   OsCurrTaskGet()->taskName, taskMemstats[record].memUsed, usedSize);
        return;
    }

    taskMemstats[record].memUsed -= usedSize;
 800949c:	693b      	ldr	r3, [r7, #16]
 800949e:	00db      	lsls	r3, r3, #3
 80094a0:	697a      	ldr	r2, [r7, #20]
 80094a2:	4413      	add	r3, r2
 80094a4:	6819      	ldr	r1, [r3, #0]
 80094a6:	693b      	ldr	r3, [r7, #16]
 80094a8:	00db      	lsls	r3, r3, #3
 80094aa:	697a      	ldr	r2, [r7, #20]
 80094ac:	4413      	add	r3, r2
 80094ae:	68ba      	ldr	r2, [r7, #8]
 80094b0:	1a8a      	subs	r2, r1, r2
 80094b2:	601a      	str	r2, [r3, #0]
    stat->memTotalUsed -= usedSize;
 80094b4:	68fb      	ldr	r3, [r7, #12]
 80094b6:	681a      	ldr	r2, [r3, #0]
 80094b8:	68bb      	ldr	r3, [r7, #8]
 80094ba:	1ad2      	subs	r2, r2, r3
 80094bc:	68fb      	ldr	r3, [r7, #12]
 80094be:	601a      	str	r2, [r3, #0]
 80094c0:	e000      	b.n	80094c4 <OsMemstatTaskUsedDec+0x54>
        return;
 80094c2:	bf00      	nop
}
 80094c4:	371c      	adds	r7, #28
 80094c6:	46bd      	mov	sp, r7
 80094c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80094cc:	4770      	bx	lr

080094ce <OsMemstatTaskClear>:

LITE_OS_SEC_TEXT_MINOR VOID OsMemstatTaskClear(Memstat *stat, UINT32 taskId)
{
 80094ce:	b480      	push	{r7}
 80094d0:	b085      	sub	sp, #20
 80094d2:	af00      	add	r7, sp, #0
 80094d4:	6078      	str	r0, [r7, #4]
 80094d6:	6039      	str	r1, [r7, #0]
    UINT32 record = MIN_TASK_ID(taskId, TASK_NUM - 1);
 80094d8:	683b      	ldr	r3, [r7, #0]
 80094da:	2b10      	cmp	r3, #16
 80094dc:	bf28      	it	cs
 80094de:	2310      	movcs	r3, #16
 80094e0:	60bb      	str	r3, [r7, #8]
    TaskMemUsedInfo *taskMemstats = stat->taskMemstats;
 80094e2:	687b      	ldr	r3, [r7, #4]
 80094e4:	3308      	adds	r3, #8
 80094e6:	60fb      	str	r3, [r7, #12]
    if (taskMemstats[record].memUsed != 0) {
        PRINT_INFO("mem used of task '%s' is:0x%x, not zero when task being deleted\n",
                   OsCurrTaskGet()->taskName, taskMemstats[record].memUsed);
    }

    taskMemstats[record].memUsed = 0;
 80094e8:	68bb      	ldr	r3, [r7, #8]
 80094ea:	00db      	lsls	r3, r3, #3
 80094ec:	68fa      	ldr	r2, [r7, #12]
 80094ee:	4413      	add	r3, r2
 80094f0:	2200      	movs	r2, #0
 80094f2:	601a      	str	r2, [r3, #0]
    taskMemstats[record].memPeak = 0;
 80094f4:	68bb      	ldr	r3, [r7, #8]
 80094f6:	00db      	lsls	r3, r3, #3
 80094f8:	68fa      	ldr	r2, [r7, #12]
 80094fa:	4413      	add	r3, r2
 80094fc:	2200      	movs	r2, #0
 80094fe:	605a      	str	r2, [r3, #4]
}
 8009500:	bf00      	nop
 8009502:	3714      	adds	r7, #20
 8009504:	46bd      	mov	sp, r7
 8009506:	f85d 7b04 	ldr.w	r7, [sp], #4
 800950a:	4770      	bx	lr

0800950c <OsMemstatTaskUsage>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsMemstatTaskUsage(const Memstat *stat, UINT32 taskId)
{
 800950c:	b480      	push	{r7}
 800950e:	b085      	sub	sp, #20
 8009510:	af00      	add	r7, sp, #0
 8009512:	6078      	str	r0, [r7, #4]
 8009514:	6039      	str	r1, [r7, #0]
    UINT32 record = MIN_TASK_ID(taskId, TASK_NUM - 1);
 8009516:	683b      	ldr	r3, [r7, #0]
 8009518:	2b10      	cmp	r3, #16
 800951a:	bf28      	it	cs
 800951c:	2310      	movcs	r3, #16
 800951e:	60bb      	str	r3, [r7, #8]
    const TaskMemUsedInfo *taskMemstats = stat->taskMemstats;
 8009520:	687b      	ldr	r3, [r7, #4]
 8009522:	3308      	adds	r3, #8
 8009524:	60fb      	str	r3, [r7, #12]

    return taskMemstats[record].memUsed;
 8009526:	68bb      	ldr	r3, [r7, #8]
 8009528:	00db      	lsls	r3, r3, #3
 800952a:	68fa      	ldr	r2, [r7, #12]
 800952c:	4413      	add	r3, r2
 800952e:	681b      	ldr	r3, [r3, #0]
}
 8009530:	4618      	mov	r0, r3
 8009532:	3714      	adds	r7, #20
 8009534:	46bd      	mov	sp, r7
 8009536:	f85d 7b04 	ldr.w	r7, [sp], #4
 800953a:	4770      	bx	lr

0800953c <OsMemTaskUsage>:

UINT32 OsMemTaskUsage(UINT32 taskId)
{
 800953c:	b580      	push	{r7, lr}
 800953e:	b084      	sub	sp, #16
 8009540:	af00      	add	r7, sp, #0
 8009542:	6078      	str	r0, [r7, #4]
    LosMemPoolInfo *pool = NULL;
 8009544:	2300      	movs	r3, #0
 8009546:	60bb      	str	r3, [r7, #8]
    Memstat *stat = NULL;
 8009548:	2300      	movs	r3, #0
 800954a:	60fb      	str	r3, [r7, #12]

#ifndef LOSCFG_MEM_MUL_POOL
    /* If Multi-pool is not enabled, then trace SYSTEM MEM only */
    pool = (LosMemPoolInfo *)OS_SYS_MEM_ADDR;
 800954c:	4b07      	ldr	r3, [pc, #28]	; (800956c <OsMemTaskUsage+0x30>)
 800954e:	681b      	ldr	r3, [r3, #0]
 8009550:	60bb      	str	r3, [r7, #8]
    stat = &(pool->stat);
 8009552:	68bb      	ldr	r3, [r7, #8]
 8009554:	330c      	adds	r3, #12
 8009556:	60fb      	str	r3, [r7, #12]
    return OsMemstatTaskUsage(stat, taskId);
 8009558:	6879      	ldr	r1, [r7, #4]
 800955a:	68f8      	ldr	r0, [r7, #12]
 800955c:	f7ff ffd6 	bl	800950c <OsMemstatTaskUsage>
 8009560:	4603      	mov	r3, r0
        inUse += OsMemstatTaskUsage(stat, taskId);
        pool = pool->nextPool;
    }
    return inUse;
#endif
}
 8009562:	4618      	mov	r0, r3
 8009564:	3710      	adds	r7, #16
 8009566:	46bd      	mov	sp, r7
 8009568:	bd80      	pop	{r7, pc}
 800956a:	bf00      	nop
 800956c:	080001f0 	.word	0x080001f0

08009570 <OsMemTaskClear>:

VOID OsMemTaskClear(UINT32 taskId)
{
 8009570:	b580      	push	{r7, lr}
 8009572:	b084      	sub	sp, #16
 8009574:	af00      	add	r7, sp, #0
 8009576:	6078      	str	r0, [r7, #4]
    LosMemPoolInfo *pool = NULL;
 8009578:	2300      	movs	r3, #0
 800957a:	60bb      	str	r3, [r7, #8]
    Memstat *stat = NULL;
 800957c:	2300      	movs	r3, #0
 800957e:	60fb      	str	r3, [r7, #12]

#ifndef LOSCFG_MEM_MUL_POOL
    pool = (LosMemPoolInfo *)OS_SYS_MEM_ADDR;
 8009580:	4b06      	ldr	r3, [pc, #24]	; (800959c <OsMemTaskClear+0x2c>)
 8009582:	681b      	ldr	r3, [r3, #0]
 8009584:	60bb      	str	r3, [r7, #8]
    stat = &(pool->stat);
 8009586:	68bb      	ldr	r3, [r7, #8]
 8009588:	330c      	adds	r3, #12
 800958a:	60fb      	str	r3, [r7, #12]
    OsMemstatTaskClear(stat, taskId);
 800958c:	6879      	ldr	r1, [r7, #4]
 800958e:	68f8      	ldr	r0, [r7, #12]
 8009590:	f7ff ff9d 	bl	80094ce <OsMemstatTaskClear>
        stat = &(pool->stat);
        OsMemstatTaskClear(stat, taskId);
        pool = pool->nextPool;
    }
#endif
}
 8009594:	bf00      	nop
 8009596:	3710      	adds	r7, #16
 8009598:	46bd      	mov	sp, r7
 800959a:	bd80      	pop	{r7, pc}
 800959c:	080001f0 	.word	0x080001f0

080095a0 <LOS_ErrHandle>:
/* Hook function for error handling. */
LITE_OS_SEC_BSS LOS_ERRORHANDLE_FUNC g_usrErrFunc;

LITE_OS_SEC_TEXT_INIT UINT32 LOS_ErrHandle(CHAR *fileName, UINT32 lineNo, UINT32 errorNo,
                                           UINT32 paraLen, VOID *para)
{
 80095a0:	b590      	push	{r4, r7, lr}
 80095a2:	b087      	sub	sp, #28
 80095a4:	af02      	add	r7, sp, #8
 80095a6:	60f8      	str	r0, [r7, #12]
 80095a8:	60b9      	str	r1, [r7, #8]
 80095aa:	607a      	str	r2, [r7, #4]
 80095ac:	603b      	str	r3, [r7, #0]
    if (g_usrErrFunc != NULL) {
 80095ae:	4b09      	ldr	r3, [pc, #36]	; (80095d4 <LOS_ErrHandle+0x34>)
 80095b0:	681b      	ldr	r3, [r3, #0]
 80095b2:	2b00      	cmp	r3, #0
 80095b4:	d008      	beq.n	80095c8 <LOS_ErrHandle+0x28>
        g_usrErrFunc(fileName, lineNo, errorNo, paraLen, para);
 80095b6:	4b07      	ldr	r3, [pc, #28]	; (80095d4 <LOS_ErrHandle+0x34>)
 80095b8:	681c      	ldr	r4, [r3, #0]
 80095ba:	6a3b      	ldr	r3, [r7, #32]
 80095bc:	9300      	str	r3, [sp, #0]
 80095be:	683b      	ldr	r3, [r7, #0]
 80095c0:	687a      	ldr	r2, [r7, #4]
 80095c2:	68b9      	ldr	r1, [r7, #8]
 80095c4:	68f8      	ldr	r0, [r7, #12]
 80095c6:	47a0      	blx	r4
    }

    return LOS_OK;
 80095c8:	2300      	movs	r3, #0
}
 80095ca:	4618      	mov	r0, r3
 80095cc:	3714      	adds	r7, #20
 80095ce:	46bd      	mov	sp, r7
 80095d0:	bd90      	pop	{r4, r7, pc}
 80095d2:	bf00      	nop
 80095d4:	200036f8 	.word	0x200036f8

080095d8 <LOS_ListInit>:
{
 80095d8:	b480      	push	{r7}
 80095da:	b083      	sub	sp, #12
 80095dc:	af00      	add	r7, sp, #0
 80095de:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 80095e0:	687b      	ldr	r3, [r7, #4]
 80095e2:	687a      	ldr	r2, [r7, #4]
 80095e4:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 80095e6:	687b      	ldr	r3, [r7, #4]
 80095e8:	687a      	ldr	r2, [r7, #4]
 80095ea:	601a      	str	r2, [r3, #0]
}
 80095ec:	bf00      	nop
 80095ee:	370c      	adds	r7, #12
 80095f0:	46bd      	mov	sp, r7
 80095f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80095f6:	4770      	bx	lr

080095f8 <LOS_ListAdd>:
{
 80095f8:	b480      	push	{r7}
 80095fa:	b083      	sub	sp, #12
 80095fc:	af00      	add	r7, sp, #0
 80095fe:	6078      	str	r0, [r7, #4]
 8009600:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 8009602:	687b      	ldr	r3, [r7, #4]
 8009604:	685a      	ldr	r2, [r3, #4]
 8009606:	683b      	ldr	r3, [r7, #0]
 8009608:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 800960a:	683b      	ldr	r3, [r7, #0]
 800960c:	687a      	ldr	r2, [r7, #4]
 800960e:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8009610:	687b      	ldr	r3, [r7, #4]
 8009612:	685b      	ldr	r3, [r3, #4]
 8009614:	683a      	ldr	r2, [r7, #0]
 8009616:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 8009618:	687b      	ldr	r3, [r7, #4]
 800961a:	683a      	ldr	r2, [r7, #0]
 800961c:	605a      	str	r2, [r3, #4]
}
 800961e:	bf00      	nop
 8009620:	370c      	adds	r7, #12
 8009622:	46bd      	mov	sp, r7
 8009624:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009628:	4770      	bx	lr

0800962a <LOS_ListTailInsert>:
{
 800962a:	b580      	push	{r7, lr}
 800962c:	b082      	sub	sp, #8
 800962e:	af00      	add	r7, sp, #0
 8009630:	6078      	str	r0, [r7, #4]
 8009632:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 8009634:	687b      	ldr	r3, [r7, #4]
 8009636:	681b      	ldr	r3, [r3, #0]
 8009638:	6839      	ldr	r1, [r7, #0]
 800963a:	4618      	mov	r0, r3
 800963c:	f7ff ffdc 	bl	80095f8 <LOS_ListAdd>
}
 8009640:	bf00      	nop
 8009642:	3708      	adds	r7, #8
 8009644:	46bd      	mov	sp, r7
 8009646:	bd80      	pop	{r7, pc}

08009648 <LOS_ListDelete>:
{
 8009648:	b480      	push	{r7}
 800964a:	b083      	sub	sp, #12
 800964c:	af00      	add	r7, sp, #0
 800964e:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8009650:	687b      	ldr	r3, [r7, #4]
 8009652:	685b      	ldr	r3, [r3, #4]
 8009654:	687a      	ldr	r2, [r7, #4]
 8009656:	6812      	ldr	r2, [r2, #0]
 8009658:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 800965a:	687b      	ldr	r3, [r7, #4]
 800965c:	681b      	ldr	r3, [r3, #0]
 800965e:	687a      	ldr	r2, [r7, #4]
 8009660:	6852      	ldr	r2, [r2, #4]
 8009662:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8009664:	687b      	ldr	r3, [r7, #4]
 8009666:	2200      	movs	r2, #0
 8009668:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 800966a:	687b      	ldr	r3, [r7, #4]
 800966c:	2200      	movs	r2, #0
 800966e:	601a      	str	r2, [r3, #0]
}
 8009670:	bf00      	nop
 8009672:	370c      	adds	r7, #12
 8009674:	46bd      	mov	sp, r7
 8009676:	f85d 7b04 	ldr.w	r7, [sp], #4
 800967a:	4770      	bx	lr

0800967c <LOS_ListEmpty>:
{
 800967c:	b480      	push	{r7}
 800967e:	b083      	sub	sp, #12
 8009680:	af00      	add	r7, sp, #0
 8009682:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8009684:	687b      	ldr	r3, [r7, #4]
 8009686:	685b      	ldr	r3, [r3, #4]
 8009688:	687a      	ldr	r2, [r7, #4]
 800968a:	429a      	cmp	r2, r3
 800968c:	bf0c      	ite	eq
 800968e:	2301      	moveq	r3, #1
 8009690:	2300      	movne	r3, #0
 8009692:	b2db      	uxtb	r3, r3
}
 8009694:	4618      	mov	r0, r3
 8009696:	370c      	adds	r7, #12
 8009698:	46bd      	mov	sp, r7
 800969a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800969e:	4770      	bx	lr

080096a0 <OsSortLinkInit>:
#define OS_INVALID_VALUE    0xFFFFFFFF

#ifdef LOSCFG_BASE_CORE_USE_MULTI_LIST

LITE_OS_SEC_TEXT_INIT UINT32 OsSortLinkInit(SortLinkAttribute *sortLinkHeader)
{
 80096a0:	b580      	push	{r7, lr}
 80096a2:	b086      	sub	sp, #24
 80096a4:	af00      	add	r7, sp, #0
 80096a6:	6078      	str	r0, [r7, #4]
    UINT32 size;
    LOS_DL_LIST *listObject = NULL;
 80096a8:	2300      	movs	r3, #0
 80096aa:	60fb      	str	r3, [r7, #12]
    UINT32 index;

    size = sizeof(LOS_DL_LIST) << OS_TSK_SORTLINK_LOGLEN;
 80096ac:	2340      	movs	r3, #64	; 0x40
 80096ae:	617b      	str	r3, [r7, #20]
    listObject = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, size); /* system resident resource */
 80096b0:	4b15      	ldr	r3, [pc, #84]	; (8009708 <OsSortLinkInit+0x68>)
 80096b2:	681b      	ldr	r3, [r3, #0]
 80096b4:	6979      	ldr	r1, [r7, #20]
 80096b6:	4618      	mov	r0, r3
 80096b8:	f7ff f976 	bl	80089a8 <LOS_MemAlloc>
 80096bc:	60f8      	str	r0, [r7, #12]
    if (listObject == NULL) {
 80096be:	68fb      	ldr	r3, [r7, #12]
 80096c0:	2b00      	cmp	r3, #0
 80096c2:	d101      	bne.n	80096c8 <OsSortLinkInit+0x28>
        return LOS_NOK;
 80096c4:	2301      	movs	r3, #1
 80096c6:	e01b      	b.n	8009700 <OsSortLinkInit+0x60>
    }

    (VOID)memset_s(listObject, size, 0, size);
 80096c8:	697b      	ldr	r3, [r7, #20]
 80096ca:	2200      	movs	r2, #0
 80096cc:	6979      	ldr	r1, [r7, #20]
 80096ce:	68f8      	ldr	r0, [r7, #12]
 80096d0:	f00c fcdc 	bl	801608c <memset_s>
    sortLinkHeader->sortLink = listObject;
 80096d4:	687b      	ldr	r3, [r7, #4]
 80096d6:	68fa      	ldr	r2, [r7, #12]
 80096d8:	601a      	str	r2, [r3, #0]
    sortLinkHeader->cursor = 0;
 80096da:	687b      	ldr	r3, [r7, #4]
 80096dc:	2200      	movs	r2, #0
 80096de:	809a      	strh	r2, [r3, #4]
    for (index = 0; index < OS_TSK_SORTLINK_LEN; index++, listObject++) {
 80096e0:	2300      	movs	r3, #0
 80096e2:	613b      	str	r3, [r7, #16]
 80096e4:	e008      	b.n	80096f8 <OsSortLinkInit+0x58>
        LOS_ListInit(listObject);
 80096e6:	68f8      	ldr	r0, [r7, #12]
 80096e8:	f7ff ff76 	bl	80095d8 <LOS_ListInit>
    for (index = 0; index < OS_TSK_SORTLINK_LEN; index++, listObject++) {
 80096ec:	693b      	ldr	r3, [r7, #16]
 80096ee:	3301      	adds	r3, #1
 80096f0:	613b      	str	r3, [r7, #16]
 80096f2:	68fb      	ldr	r3, [r7, #12]
 80096f4:	3308      	adds	r3, #8
 80096f6:	60fb      	str	r3, [r7, #12]
 80096f8:	693b      	ldr	r3, [r7, #16]
 80096fa:	2b07      	cmp	r3, #7
 80096fc:	d9f3      	bls.n	80096e6 <OsSortLinkInit+0x46>
    }
    return LOS_OK;
 80096fe:	2300      	movs	r3, #0
}
 8009700:	4618      	mov	r0, r3
 8009702:	3718      	adds	r7, #24
 8009704:	46bd      	mov	sp, r7
 8009706:	bd80      	pop	{r7, pc}
 8009708:	200021b4 	.word	0x200021b4

0800970c <OsAdd2SortLink>:

LITE_OS_SEC_TEXT VOID OsAdd2SortLink(const SortLinkAttribute *sortLinkHeader, SortLinkList *sortList)
{
 800970c:	b580      	push	{r7, lr}
 800970e:	b088      	sub	sp, #32
 8009710:	af00      	add	r7, sp, #0
 8009712:	6078      	str	r0, [r7, #4]
 8009714:	6039      	str	r1, [r7, #0]
    SortLinkList *listSorted = NULL;
 8009716:	2300      	movs	r3, #0
 8009718:	60fb      	str	r3, [r7, #12]
    LOS_DL_LIST *listObject = NULL;
 800971a:	2300      	movs	r3, #0
 800971c:	617b      	str	r3, [r7, #20]

    /*
     * huge rollnum could cause carry to invalid high bit
     * and eventually affect the calculation of sort index.
     */
    if (sortList->idxRollNum > OS_TSK_MAX_ROLLNUM) {
 800971e:	683b      	ldr	r3, [r7, #0]
 8009720:	689b      	ldr	r3, [r3, #8]
 8009722:	f113 0f09 	cmn.w	r3, #9
 8009726:	d903      	bls.n	8009730 <OsAdd2SortLink+0x24>
        SET_SORTLIST_VALUE(sortList, OS_TSK_MAX_ROLLNUM);
 8009728:	683b      	ldr	r3, [r7, #0]
 800972a:	f06f 0208 	mvn.w	r2, #8
 800972e:	609a      	str	r2, [r3, #8]
    }
    timeout = sortList->idxRollNum;
 8009730:	683b      	ldr	r3, [r7, #0]
 8009732:	689b      	ldr	r3, [r3, #8]
 8009734:	61bb      	str	r3, [r7, #24]
    sortIndex = timeout & OS_TSK_SORTLINK_MASK;
 8009736:	69bb      	ldr	r3, [r7, #24]
 8009738:	f003 0307 	and.w	r3, r3, #7
 800973c:	61fb      	str	r3, [r7, #28]
    rollNum = (timeout >> OS_TSK_SORTLINK_LOGLEN) + 1;
 800973e:	69bb      	ldr	r3, [r7, #24]
 8009740:	08db      	lsrs	r3, r3, #3
 8009742:	3301      	adds	r3, #1
 8009744:	613b      	str	r3, [r7, #16]
    if (sortIndex == 0) {
 8009746:	69fb      	ldr	r3, [r7, #28]
 8009748:	2b00      	cmp	r3, #0
 800974a:	d102      	bne.n	8009752 <OsAdd2SortLink+0x46>
        rollNum--;
 800974c:	693b      	ldr	r3, [r7, #16]
 800974e:	3b01      	subs	r3, #1
 8009750:	613b      	str	r3, [r7, #16]
    }
    EVALUATE_L(sortList->idxRollNum, rollNum);
 8009752:	683b      	ldr	r3, [r7, #0]
 8009754:	689b      	ldr	r3, [r3, #8]
 8009756:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 800975a:	693b      	ldr	r3, [r7, #16]
 800975c:	431a      	orrs	r2, r3
 800975e:	683b      	ldr	r3, [r7, #0]
 8009760:	609a      	str	r2, [r3, #8]
    sortIndex = sortIndex + sortLinkHeader->cursor;
 8009762:	687b      	ldr	r3, [r7, #4]
 8009764:	889b      	ldrh	r3, [r3, #4]
 8009766:	461a      	mov	r2, r3
 8009768:	69fb      	ldr	r3, [r7, #28]
 800976a:	4413      	add	r3, r2
 800976c:	61fb      	str	r3, [r7, #28]
    sortIndex = sortIndex & OS_TSK_SORTLINK_MASK;
 800976e:	69fb      	ldr	r3, [r7, #28]
 8009770:	f003 0307 	and.w	r3, r3, #7
 8009774:	61fb      	str	r3, [r7, #28]
    EVALUATE_H(sortList->idxRollNum, sortIndex);
 8009776:	683b      	ldr	r3, [r7, #0]
 8009778:	689b      	ldr	r3, [r3, #8]
 800977a:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 800977e:	69fb      	ldr	r3, [r7, #28]
 8009780:	075b      	lsls	r3, r3, #29
 8009782:	431a      	orrs	r2, r3
 8009784:	683b      	ldr	r3, [r7, #0]
 8009786:	609a      	str	r2, [r3, #8]

    listObject = sortLinkHeader->sortLink + sortIndex;
 8009788:	687b      	ldr	r3, [r7, #4]
 800978a:	681a      	ldr	r2, [r3, #0]
 800978c:	69fb      	ldr	r3, [r7, #28]
 800978e:	00db      	lsls	r3, r3, #3
 8009790:	4413      	add	r3, r2
 8009792:	617b      	str	r3, [r7, #20]
    if (listObject->pstNext == listObject) {
 8009794:	697b      	ldr	r3, [r7, #20]
 8009796:	685b      	ldr	r3, [r3, #4]
 8009798:	697a      	ldr	r2, [r7, #20]
 800979a:	429a      	cmp	r2, r3
 800979c:	d105      	bne.n	80097aa <OsAdd2SortLink+0x9e>
        LOS_ListTailInsert(listObject, &sortList->sortLinkNode);
 800979e:	683b      	ldr	r3, [r7, #0]
 80097a0:	4619      	mov	r1, r3
 80097a2:	6978      	ldr	r0, [r7, #20]
 80097a4:	f7ff ff41 	bl	800962a <LOS_ListTailInsert>
            listSorted = LOS_DL_LIST_ENTRY(listSorted->sortLinkNode.pstNext, SortLinkList, sortLinkNode);
        } while (&listSorted->sortLinkNode != listObject);

        LOS_ListTailInsert(&listSorted->sortLinkNode, &sortList->sortLinkNode);
    }
}
 80097a8:	e03b      	b.n	8009822 <OsAdd2SortLink+0x116>
        listSorted = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 80097aa:	697b      	ldr	r3, [r7, #20]
 80097ac:	685b      	ldr	r3, [r3, #4]
 80097ae:	60fb      	str	r3, [r7, #12]
            if (ROLLNUM(listSorted->idxRollNum) <= ROLLNUM(sortList->idxRollNum)) {
 80097b0:	68fb      	ldr	r3, [r7, #12]
 80097b2:	689b      	ldr	r3, [r3, #8]
 80097b4:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 80097b8:	683b      	ldr	r3, [r7, #0]
 80097ba:	689b      	ldr	r3, [r3, #8]
 80097bc:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80097c0:	429a      	cmp	r2, r3
 80097c2:	d810      	bhi.n	80097e6 <OsAdd2SortLink+0xda>
                ROLLNUM_SUB(sortList->idxRollNum, listSorted->idxRollNum);
 80097c4:	683b      	ldr	r3, [r7, #0]
 80097c6:	689b      	ldr	r3, [r3, #8]
 80097c8:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 80097cc:	683b      	ldr	r3, [r7, #0]
 80097ce:	689b      	ldr	r3, [r3, #8]
 80097d0:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 80097d4:	68fb      	ldr	r3, [r7, #12]
 80097d6:	689b      	ldr	r3, [r3, #8]
 80097d8:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80097dc:	1acb      	subs	r3, r1, r3
 80097de:	431a      	orrs	r2, r3
 80097e0:	683b      	ldr	r3, [r7, #0]
 80097e2:	609a      	str	r2, [r3, #8]
 80097e4:	e010      	b.n	8009808 <OsAdd2SortLink+0xfc>
                ROLLNUM_SUB(listSorted->idxRollNum, sortList->idxRollNum);
 80097e6:	68fb      	ldr	r3, [r7, #12]
 80097e8:	689b      	ldr	r3, [r3, #8]
 80097ea:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 80097ee:	68fb      	ldr	r3, [r7, #12]
 80097f0:	689b      	ldr	r3, [r3, #8]
 80097f2:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 80097f6:	683b      	ldr	r3, [r7, #0]
 80097f8:	689b      	ldr	r3, [r3, #8]
 80097fa:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80097fe:	1acb      	subs	r3, r1, r3
 8009800:	431a      	orrs	r2, r3
 8009802:	68fb      	ldr	r3, [r7, #12]
 8009804:	609a      	str	r2, [r3, #8]
                break;
 8009806:	e006      	b.n	8009816 <OsAdd2SortLink+0x10a>
            listSorted = LOS_DL_LIST_ENTRY(listSorted->sortLinkNode.pstNext, SortLinkList, sortLinkNode);
 8009808:	68fb      	ldr	r3, [r7, #12]
 800980a:	685b      	ldr	r3, [r3, #4]
 800980c:	60fb      	str	r3, [r7, #12]
        } while (&listSorted->sortLinkNode != listObject);
 800980e:	68fb      	ldr	r3, [r7, #12]
 8009810:	697a      	ldr	r2, [r7, #20]
 8009812:	429a      	cmp	r2, r3
 8009814:	d1cc      	bne.n	80097b0 <OsAdd2SortLink+0xa4>
        LOS_ListTailInsert(&listSorted->sortLinkNode, &sortList->sortLinkNode);
 8009816:	68fb      	ldr	r3, [r7, #12]
 8009818:	683a      	ldr	r2, [r7, #0]
 800981a:	4611      	mov	r1, r2
 800981c:	4618      	mov	r0, r3
 800981e:	f7ff ff04 	bl	800962a <LOS_ListTailInsert>
}
 8009822:	bf00      	nop
 8009824:	3720      	adds	r7, #32
 8009826:	46bd      	mov	sp, r7
 8009828:	bd80      	pop	{r7, pc}

0800982a <OsCheckSortLink>:

LITE_OS_SEC_TEXT STATIC VOID OsCheckSortLink(const LOS_DL_LIST *listHead, const LOS_DL_LIST *listNode)
{
 800982a:	b580      	push	{r7, lr}
 800982c:	b084      	sub	sp, #16
 800982e:	af00      	add	r7, sp, #0
 8009830:	6078      	str	r0, [r7, #4]
 8009832:	6039      	str	r1, [r7, #0]
    LOS_DL_LIST *tmp = listNode->pstPrev;
 8009834:	683b      	ldr	r3, [r7, #0]
 8009836:	681b      	ldr	r3, [r3, #0]
 8009838:	60fb      	str	r3, [r7, #12]

    /* recursive check until double link round to itself */
    while (tmp != listNode) {
 800983a:	e006      	b.n	800984a <OsCheckSortLink+0x20>
        if (tmp == listHead) {
 800983c:	68fa      	ldr	r2, [r7, #12]
 800983e:	687b      	ldr	r3, [r7, #4]
 8009840:	429a      	cmp	r2, r3
 8009842:	d009      	beq.n	8009858 <OsCheckSortLink+0x2e>
            return;
        }
        tmp = tmp->pstPrev;
 8009844:	68fb      	ldr	r3, [r7, #12]
 8009846:	681b      	ldr	r3, [r3, #0]
 8009848:	60fb      	str	r3, [r7, #12]
    while (tmp != listNode) {
 800984a:	68fa      	ldr	r2, [r7, #12]
 800984c:	683b      	ldr	r3, [r7, #0]
 800984e:	429a      	cmp	r2, r3
 8009850:	d1f4      	bne.n	800983c <OsCheckSortLink+0x12>
    }

    /* delete invalid sortlink node */
    OsBackTrace();
 8009852:	f7fa fd67 	bl	8004324 <LOS_BackTrace>
 8009856:	e000      	b.n	800985a <OsCheckSortLink+0x30>
            return;
 8009858:	bf00      	nop
}
 800985a:	3710      	adds	r7, #16
 800985c:	46bd      	mov	sp, r7
 800985e:	bd80      	pop	{r7, pc}

08009860 <OsDeleteSortLink>:

LITE_OS_SEC_TEXT VOID OsDeleteSortLink(const SortLinkAttribute *sortLinkHeader, SortLinkList *sortList)
{
 8009860:	b580      	push	{r7, lr}
 8009862:	b086      	sub	sp, #24
 8009864:	af00      	add	r7, sp, #0
 8009866:	6078      	str	r0, [r7, #4]
 8009868:	6039      	str	r1, [r7, #0]
    LOS_DL_LIST *listObject = NULL;
 800986a:	2300      	movs	r3, #0
 800986c:	60fb      	str	r3, [r7, #12]
    SortLinkList *nextSortList = NULL;
 800986e:	2300      	movs	r3, #0
 8009870:	613b      	str	r3, [r7, #16]
    UINT32 sortIndex;

    sortIndex = SORT_INDEX(sortList->idxRollNum);
 8009872:	683b      	ldr	r3, [r7, #0]
 8009874:	689b      	ldr	r3, [r3, #8]
 8009876:	0f5b      	lsrs	r3, r3, #29
 8009878:	617b      	str	r3, [r7, #20]
    listObject = sortLinkHeader->sortLink + sortIndex;
 800987a:	687b      	ldr	r3, [r7, #4]
 800987c:	681a      	ldr	r2, [r3, #0]
 800987e:	697b      	ldr	r3, [r7, #20]
 8009880:	00db      	lsls	r3, r3, #3
 8009882:	4413      	add	r3, r2
 8009884:	60fb      	str	r3, [r7, #12]

    /* check if pstSortList node is on the right sortlink */
    OsCheckSortLink(listObject, &sortList->sortLinkNode);
 8009886:	683b      	ldr	r3, [r7, #0]
 8009888:	4619      	mov	r1, r3
 800988a:	68f8      	ldr	r0, [r7, #12]
 800988c:	f7ff ffcd 	bl	800982a <OsCheckSortLink>

    if (listObject != sortList->sortLinkNode.pstNext) {
 8009890:	683b      	ldr	r3, [r7, #0]
 8009892:	685b      	ldr	r3, [r3, #4]
 8009894:	68fa      	ldr	r2, [r7, #12]
 8009896:	429a      	cmp	r2, r3
 8009898:	d012      	beq.n	80098c0 <OsDeleteSortLink+0x60>
        nextSortList = LOS_DL_LIST_ENTRY(sortList->sortLinkNode.pstNext, SortLinkList, sortLinkNode);
 800989a:	683b      	ldr	r3, [r7, #0]
 800989c:	685b      	ldr	r3, [r3, #4]
 800989e:	613b      	str	r3, [r7, #16]
        ROLLNUM_ADD(nextSortList->idxRollNum, sortList->idxRollNum);
 80098a0:	693b      	ldr	r3, [r7, #16]
 80098a2:	689b      	ldr	r3, [r3, #8]
 80098a4:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 80098a8:	693b      	ldr	r3, [r7, #16]
 80098aa:	689b      	ldr	r3, [r3, #8]
 80098ac:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 80098b0:	683b      	ldr	r3, [r7, #0]
 80098b2:	689b      	ldr	r3, [r3, #8]
 80098b4:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80098b8:	440b      	add	r3, r1
 80098ba:	431a      	orrs	r2, r3
 80098bc:	693b      	ldr	r3, [r7, #16]
 80098be:	609a      	str	r2, [r3, #8]
    }
    LOS_ListDelete(&sortList->sortLinkNode);
 80098c0:	683b      	ldr	r3, [r7, #0]
 80098c2:	4618      	mov	r0, r3
 80098c4:	f7ff fec0 	bl	8009648 <LOS_ListDelete>
}
 80098c8:	bf00      	nop
 80098ca:	3718      	adds	r7, #24
 80098cc:	46bd      	mov	sp, r7
 80098ce:	bd80      	pop	{r7, pc}

080098d0 <OsCalcExpierTime>:

LITE_OS_SEC_TEXT STATIC INLINE UINT32 OsCalcExpierTime(UINT32 rollNum, UINT32 sortIndex, UINT16 curSortIndex)
{
 80098d0:	b480      	push	{r7}
 80098d2:	b087      	sub	sp, #28
 80098d4:	af00      	add	r7, sp, #0
 80098d6:	60f8      	str	r0, [r7, #12]
 80098d8:	60b9      	str	r1, [r7, #8]
 80098da:	4613      	mov	r3, r2
 80098dc:	80fb      	strh	r3, [r7, #6]
    UINT32 expireTime;

    if (sortIndex > curSortIndex) {
 80098de:	88fb      	ldrh	r3, [r7, #6]
 80098e0:	68ba      	ldr	r2, [r7, #8]
 80098e2:	429a      	cmp	r2, r3
 80098e4:	d904      	bls.n	80098f0 <OsCalcExpierTime+0x20>
        sortIndex = sortIndex - curSortIndex;
 80098e6:	88fb      	ldrh	r3, [r7, #6]
 80098e8:	68ba      	ldr	r2, [r7, #8]
 80098ea:	1ad3      	subs	r3, r2, r3
 80098ec:	60bb      	str	r3, [r7, #8]
 80098ee:	e004      	b.n	80098fa <OsCalcExpierTime+0x2a>
    } else {
        sortIndex = OS_TSK_SORTLINK_LEN - curSortIndex + sortIndex;
 80098f0:	88fb      	ldrh	r3, [r7, #6]
 80098f2:	68ba      	ldr	r2, [r7, #8]
 80098f4:	1ad3      	subs	r3, r2, r3
 80098f6:	3308      	adds	r3, #8
 80098f8:	60bb      	str	r3, [r7, #8]
    }
    expireTime = ((rollNum - 1) << OS_TSK_SORTLINK_LOGLEN) + sortIndex;
 80098fa:	68fb      	ldr	r3, [r7, #12]
 80098fc:	3b01      	subs	r3, #1
 80098fe:	00db      	lsls	r3, r3, #3
 8009900:	68ba      	ldr	r2, [r7, #8]
 8009902:	4413      	add	r3, r2
 8009904:	617b      	str	r3, [r7, #20]
    return expireTime;
 8009906:	697b      	ldr	r3, [r7, #20]
}
 8009908:	4618      	mov	r0, r3
 800990a:	371c      	adds	r7, #28
 800990c:	46bd      	mov	sp, r7
 800990e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009912:	4770      	bx	lr

08009914 <OsSortLinkGetNextExpireTime>:

LITE_OS_SEC_TEXT UINT32 OsSortLinkGetNextExpireTime(const SortLinkAttribute *sortLinkHeader)
{
 8009914:	b580      	push	{r7, lr}
 8009916:	b08a      	sub	sp, #40	; 0x28
 8009918:	af00      	add	r7, sp, #0
 800991a:	6078      	str	r0, [r7, #4]
    UINT16 cursor;
    UINT32 minSortIndex = OS_INVALID_VALUE;
 800991c:	f04f 33ff 	mov.w	r3, #4294967295
 8009920:	613b      	str	r3, [r7, #16]
    UINT32 minRollNum = OS_TSK_LOW_BITS_MASK;
 8009922:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
 8009926:	617b      	str	r3, [r7, #20]
    UINT32 expireTime = OS_INVALID_VALUE;
 8009928:	f04f 33ff 	mov.w	r3, #4294967295
 800992c:	61bb      	str	r3, [r7, #24]
    LOS_DL_LIST *listObject = NULL;
 800992e:	2300      	movs	r3, #0
 8009930:	623b      	str	r3, [r7, #32]
    SortLinkList *listSorted = NULL;
 8009932:	2300      	movs	r3, #0
 8009934:	627b      	str	r3, [r7, #36]	; 0x24
    UINT32 i;

    cursor = (sortLinkHeader->cursor + 1) & OS_TSK_SORTLINK_MASK;
 8009936:	687b      	ldr	r3, [r7, #4]
 8009938:	889b      	ldrh	r3, [r3, #4]
 800993a:	3301      	adds	r3, #1
 800993c:	b29b      	uxth	r3, r3
 800993e:	f003 0307 	and.w	r3, r3, #7
 8009942:	81fb      	strh	r3, [r7, #14]

    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++) {
 8009944:	2300      	movs	r3, #0
 8009946:	61fb      	str	r3, [r7, #28]
 8009948:	e027      	b.n	800999a <OsSortLinkGetNextExpireTime+0x86>
        listObject = sortLinkHeader->sortLink + ((cursor + i) & OS_TSK_SORTLINK_MASK);
 800994a:	687b      	ldr	r3, [r7, #4]
 800994c:	681a      	ldr	r2, [r3, #0]
 800994e:	89f9      	ldrh	r1, [r7, #14]
 8009950:	69fb      	ldr	r3, [r7, #28]
 8009952:	440b      	add	r3, r1
 8009954:	f003 0307 	and.w	r3, r3, #7
 8009958:	00db      	lsls	r3, r3, #3
 800995a:	4413      	add	r3, r2
 800995c:	623b      	str	r3, [r7, #32]
        if (!LOS_ListEmpty(listObject)) {
 800995e:	6a38      	ldr	r0, [r7, #32]
 8009960:	f7ff fe8c 	bl	800967c <LOS_ListEmpty>
 8009964:	4603      	mov	r3, r0
 8009966:	2b00      	cmp	r3, #0
 8009968:	d114      	bne.n	8009994 <OsSortLinkGetNextExpireTime+0x80>
            listSorted = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 800996a:	6a3b      	ldr	r3, [r7, #32]
 800996c:	685b      	ldr	r3, [r3, #4]
 800996e:	627b      	str	r3, [r7, #36]	; 0x24
            if (minRollNum > ROLLNUM(listSorted->idxRollNum)) {
 8009970:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009972:	689b      	ldr	r3, [r3, #8]
 8009974:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8009978:	697a      	ldr	r2, [r7, #20]
 800997a:	429a      	cmp	r2, r3
 800997c:	d90a      	bls.n	8009994 <OsSortLinkGetNextExpireTime+0x80>
                minRollNum = ROLLNUM(listSorted->idxRollNum);
 800997e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009980:	689b      	ldr	r3, [r3, #8]
 8009982:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8009986:	617b      	str	r3, [r7, #20]
                minSortIndex = (cursor + i) & OS_TSK_SORTLINK_MASK;
 8009988:	89fa      	ldrh	r2, [r7, #14]
 800998a:	69fb      	ldr	r3, [r7, #28]
 800998c:	4413      	add	r3, r2
 800998e:	f003 0307 	and.w	r3, r3, #7
 8009992:	613b      	str	r3, [r7, #16]
    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++) {
 8009994:	69fb      	ldr	r3, [r7, #28]
 8009996:	3301      	adds	r3, #1
 8009998:	61fb      	str	r3, [r7, #28]
 800999a:	69fb      	ldr	r3, [r7, #28]
 800999c:	2b07      	cmp	r3, #7
 800999e:	d9d4      	bls.n	800994a <OsSortLinkGetNextExpireTime+0x36>
            }
        }
    }

    if (minRollNum != OS_TSK_LOW_BITS_MASK) {
 80099a0:	697b      	ldr	r3, [r7, #20]
 80099a2:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
 80099a6:	4293      	cmp	r3, r2
 80099a8:	d007      	beq.n	80099ba <OsSortLinkGetNextExpireTime+0xa6>
        expireTime = OsCalcExpierTime(minRollNum, minSortIndex, sortLinkHeader->cursor);
 80099aa:	687b      	ldr	r3, [r7, #4]
 80099ac:	889b      	ldrh	r3, [r3, #4]
 80099ae:	461a      	mov	r2, r3
 80099b0:	6939      	ldr	r1, [r7, #16]
 80099b2:	6978      	ldr	r0, [r7, #20]
 80099b4:	f7ff ff8c 	bl	80098d0 <OsCalcExpierTime>
 80099b8:	61b8      	str	r0, [r7, #24]
    }

    return expireTime;
 80099ba:	69bb      	ldr	r3, [r7, #24]
}
 80099bc:	4618      	mov	r0, r3
 80099be:	3728      	adds	r7, #40	; 0x28
 80099c0:	46bd      	mov	sp, r7
 80099c2:	bd80      	pop	{r7, pc}

080099c4 <OsSortLinkUpdateExpireTime>:

LITE_OS_SEC_TEXT VOID OsSortLinkUpdateExpireTime(UINT32 sleepTicks, SortLinkAttribute *sortLinkHeader)
{
 80099c4:	b480      	push	{r7}
 80099c6:	b089      	sub	sp, #36	; 0x24
 80099c8:	af00      	add	r7, sp, #0
 80099ca:	6078      	str	r0, [r7, #4]
 80099cc:	6039      	str	r1, [r7, #0]
    SortLinkList *sortList = NULL;
 80099ce:	2300      	movs	r3, #0
 80099d0:	61bb      	str	r3, [r7, #24]
    LOS_DL_LIST *listObject = NULL;
 80099d2:	2300      	movs	r3, #0
 80099d4:	61fb      	str	r3, [r7, #28]
    UINT32 i;
    UINT32 sortIndex;
    UINT32 rollNum;

    if (sleepTicks == 0) {
 80099d6:	687b      	ldr	r3, [r7, #4]
 80099d8:	2b00      	cmp	r3, #0
 80099da:	d056      	beq.n	8009a8a <OsSortLinkUpdateExpireTime+0xc6>
        return;
    }
    sortIndex = sleepTicks & OS_TSK_SORTLINK_MASK;
 80099dc:	687b      	ldr	r3, [r7, #4]
 80099de:	f003 0307 	and.w	r3, r3, #7
 80099e2:	613b      	str	r3, [r7, #16]
    rollNum = (sleepTicks >> OS_TSK_SORTLINK_LOGLEN) + 1;
 80099e4:	687b      	ldr	r3, [r7, #4]
 80099e6:	08db      	lsrs	r3, r3, #3
 80099e8:	3301      	adds	r3, #1
 80099ea:	617b      	str	r3, [r7, #20]
    if (sortIndex == 0) {
 80099ec:	693b      	ldr	r3, [r7, #16]
 80099ee:	2b00      	cmp	r3, #0
 80099f0:	d104      	bne.n	80099fc <OsSortLinkUpdateExpireTime+0x38>
        rollNum--;
 80099f2:	697b      	ldr	r3, [r7, #20]
 80099f4:	3b01      	subs	r3, #1
 80099f6:	617b      	str	r3, [r7, #20]
        sortIndex = OS_TSK_SORTLINK_LEN;
 80099f8:	2308      	movs	r3, #8
 80099fa:	613b      	str	r3, [r7, #16]
    }

    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++) {
 80099fc:	2300      	movs	r3, #0
 80099fe:	60fb      	str	r3, [r7, #12]
 8009a00:	e032      	b.n	8009a68 <OsSortLinkUpdateExpireTime+0xa4>
        listObject = sortLinkHeader->sortLink + ((sortLinkHeader->cursor + i) & OS_TSK_SORTLINK_MASK);
 8009a02:	683b      	ldr	r3, [r7, #0]
 8009a04:	681a      	ldr	r2, [r3, #0]
 8009a06:	683b      	ldr	r3, [r7, #0]
 8009a08:	889b      	ldrh	r3, [r3, #4]
 8009a0a:	4619      	mov	r1, r3
 8009a0c:	68fb      	ldr	r3, [r7, #12]
 8009a0e:	440b      	add	r3, r1
 8009a10:	f003 0307 	and.w	r3, r3, #7
 8009a14:	00db      	lsls	r3, r3, #3
 8009a16:	4413      	add	r3, r2
 8009a18:	61fb      	str	r3, [r7, #28]
        if (listObject->pstNext != listObject) {
 8009a1a:	69fb      	ldr	r3, [r7, #28]
 8009a1c:	685b      	ldr	r3, [r3, #4]
 8009a1e:	69fa      	ldr	r2, [r7, #28]
 8009a20:	429a      	cmp	r2, r3
 8009a22:	d01e      	beq.n	8009a62 <OsSortLinkUpdateExpireTime+0x9e>
            sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 8009a24:	69fb      	ldr	r3, [r7, #28]
 8009a26:	685b      	ldr	r3, [r3, #4]
 8009a28:	61bb      	str	r3, [r7, #24]
            ROLLNUM_SUB(sortList->idxRollNum, rollNum - 1);
 8009a2a:	69bb      	ldr	r3, [r7, #24]
 8009a2c:	689b      	ldr	r3, [r3, #8]
 8009a2e:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 8009a32:	69bb      	ldr	r3, [r7, #24]
 8009a34:	689b      	ldr	r3, [r3, #8]
 8009a36:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8009a3a:	697b      	ldr	r3, [r7, #20]
 8009a3c:	3b01      	subs	r3, #1
 8009a3e:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8009a42:	1acb      	subs	r3, r1, r3
 8009a44:	431a      	orrs	r2, r3
 8009a46:	69bb      	ldr	r3, [r7, #24]
 8009a48:	609a      	str	r2, [r3, #8]
            if ((i > 0) && (i < sortIndex)) {
 8009a4a:	68fb      	ldr	r3, [r7, #12]
 8009a4c:	2b00      	cmp	r3, #0
 8009a4e:	d008      	beq.n	8009a62 <OsSortLinkUpdateExpireTime+0x9e>
 8009a50:	68fa      	ldr	r2, [r7, #12]
 8009a52:	693b      	ldr	r3, [r7, #16]
 8009a54:	429a      	cmp	r2, r3
 8009a56:	d204      	bcs.n	8009a62 <OsSortLinkUpdateExpireTime+0x9e>
                ROLLNUM_DEC(sortList->idxRollNum);
 8009a58:	69bb      	ldr	r3, [r7, #24]
 8009a5a:	689b      	ldr	r3, [r3, #8]
 8009a5c:	1e5a      	subs	r2, r3, #1
 8009a5e:	69bb      	ldr	r3, [r7, #24]
 8009a60:	609a      	str	r2, [r3, #8]
    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++) {
 8009a62:	68fb      	ldr	r3, [r7, #12]
 8009a64:	3301      	adds	r3, #1
 8009a66:	60fb      	str	r3, [r7, #12]
 8009a68:	68fb      	ldr	r3, [r7, #12]
 8009a6a:	2b07      	cmp	r3, #7
 8009a6c:	d9c9      	bls.n	8009a02 <OsSortLinkUpdateExpireTime+0x3e>
            }
        }
    }
    sortLinkHeader->cursor = (sortLinkHeader->cursor + sleepTicks - 1) % OS_TSK_SORTLINK_LEN;
 8009a6e:	683b      	ldr	r3, [r7, #0]
 8009a70:	889a      	ldrh	r2, [r3, #4]
 8009a72:	687b      	ldr	r3, [r7, #4]
 8009a74:	b29b      	uxth	r3, r3
 8009a76:	4413      	add	r3, r2
 8009a78:	b29b      	uxth	r3, r3
 8009a7a:	3b01      	subs	r3, #1
 8009a7c:	b29b      	uxth	r3, r3
 8009a7e:	f003 0307 	and.w	r3, r3, #7
 8009a82:	b29a      	uxth	r2, r3
 8009a84:	683b      	ldr	r3, [r7, #0]
 8009a86:	809a      	strh	r2, [r3, #4]
 8009a88:	e000      	b.n	8009a8c <OsSortLinkUpdateExpireTime+0xc8>
        return;
 8009a8a:	bf00      	nop
}
 8009a8c:	3724      	adds	r7, #36	; 0x24
 8009a8e:	46bd      	mov	sp, r7
 8009a90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a94:	4770      	bx	lr

08009a96 <OsStackWaterLineGet>:

const StackInfo *g_stackInfo = NULL;
UINT32 g_stackNum;

UINT32 OsStackWaterLineGet(const UINTPTR *stackBottom, const UINTPTR *stackTop, UINT32 *peakUsed)
{
 8009a96:	b480      	push	{r7}
 8009a98:	b087      	sub	sp, #28
 8009a9a:	af00      	add	r7, sp, #0
 8009a9c:	60f8      	str	r0, [r7, #12]
 8009a9e:	60b9      	str	r1, [r7, #8]
 8009aa0:	607a      	str	r2, [r7, #4]
    UINT32 size;
    const UINTPTR *tmp = NULL;
 8009aa2:	2300      	movs	r3, #0
 8009aa4:	613b      	str	r3, [r7, #16]
    if (*stackTop == OS_STACK_MAGIC_WORD) {
 8009aa6:	68bb      	ldr	r3, [r7, #8]
 8009aa8:	681b      	ldr	r3, [r3, #0]
 8009aaa:	f1b3 3fcc 	cmp.w	r3, #3435973836	; 0xcccccccc
 8009aae:	d11e      	bne.n	8009aee <OsStackWaterLineGet+0x58>
        tmp = stackTop + 1;
 8009ab0:	68bb      	ldr	r3, [r7, #8]
 8009ab2:	3304      	adds	r3, #4
 8009ab4:	613b      	str	r3, [r7, #16]
        while ((tmp < stackBottom) && (*tmp == OS_STACK_INIT)) {
 8009ab6:	e002      	b.n	8009abe <OsStackWaterLineGet+0x28>
            tmp++;
 8009ab8:	693b      	ldr	r3, [r7, #16]
 8009aba:	3304      	adds	r3, #4
 8009abc:	613b      	str	r3, [r7, #16]
        while ((tmp < stackBottom) && (*tmp == OS_STACK_INIT)) {
 8009abe:	693a      	ldr	r2, [r7, #16]
 8009ac0:	68fb      	ldr	r3, [r7, #12]
 8009ac2:	429a      	cmp	r2, r3
 8009ac4:	d204      	bcs.n	8009ad0 <OsStackWaterLineGet+0x3a>
 8009ac6:	693b      	ldr	r3, [r7, #16]
 8009ac8:	681b      	ldr	r3, [r3, #0]
 8009aca:	f1b3 3fca 	cmp.w	r3, #3402287818	; 0xcacacaca
 8009ace:	d0f3      	beq.n	8009ab8 <OsStackWaterLineGet+0x22>
        }
        size = (UINT32)((UINTPTR)stackBottom - (UINTPTR)tmp);
 8009ad0:	68fa      	ldr	r2, [r7, #12]
 8009ad2:	693b      	ldr	r3, [r7, #16]
 8009ad4:	1ad3      	subs	r3, r2, r3
 8009ad6:	617b      	str	r3, [r7, #20]
        *peakUsed = (size == 0) ? size : (size + sizeof(CHAR *));
 8009ad8:	697b      	ldr	r3, [r7, #20]
 8009ada:	2b00      	cmp	r3, #0
 8009adc:	d002      	beq.n	8009ae4 <OsStackWaterLineGet+0x4e>
 8009ade:	697b      	ldr	r3, [r7, #20]
 8009ae0:	3304      	adds	r3, #4
 8009ae2:	e000      	b.n	8009ae6 <OsStackWaterLineGet+0x50>
 8009ae4:	697b      	ldr	r3, [r7, #20]
 8009ae6:	687a      	ldr	r2, [r7, #4]
 8009ae8:	6013      	str	r3, [r2, #0]
        return LOS_OK;
 8009aea:	2300      	movs	r3, #0
 8009aec:	e004      	b.n	8009af8 <OsStackWaterLineGet+0x62>
    } else {
        *peakUsed = OS_INVALID_WATERLINE;
 8009aee:	687b      	ldr	r3, [r7, #4]
 8009af0:	f04f 32ff 	mov.w	r2, #4294967295
 8009af4:	601a      	str	r2, [r3, #0]
        return LOS_NOK;
 8009af6:	2301      	movs	r3, #1
    }
}
 8009af8:	4618      	mov	r0, r3
 8009afa:	371c      	adds	r7, #28
 8009afc:	46bd      	mov	sp, r7
 8009afe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b02:	4770      	bx	lr

08009b04 <OsStackInit>:
    g_stackInfo = stackInfo;
    g_stackNum = stackNum;
}

VOID OsStackInit(VOID *stacktop, UINT32 stacksize)
{
 8009b04:	b580      	push	{r7, lr}
 8009b06:	b082      	sub	sp, #8
 8009b08:	af00      	add	r7, sp, #0
 8009b0a:	6078      	str	r0, [r7, #4]
 8009b0c:	6039      	str	r1, [r7, #0]
    /* initialize the task stack, write magic num to stack top */
    (VOID)memset_s(stacktop, stacksize, (INT32)OS_STACK_INIT, stacksize);
 8009b0e:	683b      	ldr	r3, [r7, #0]
 8009b10:	f04f 32ca 	mov.w	r2, #3402287818	; 0xcacacaca
 8009b14:	6839      	ldr	r1, [r7, #0]
 8009b16:	6878      	ldr	r0, [r7, #4]
 8009b18:	f00c fab8 	bl	801608c <memset_s>
    *((UINTPTR *)stacktop) = OS_STACK_MAGIC_WORD;
 8009b1c:	687b      	ldr	r3, [r7, #4]
 8009b1e:	f04f 32cc 	mov.w	r2, #3435973836	; 0xcccccccc
 8009b22:	601a      	str	r2, [r3, #0]
}
 8009b24:	bf00      	nop
 8009b26:	3708      	adds	r7, #8
 8009b28:	46bd      	mov	sp, r7
 8009b2a:	bd80      	pop	{r7, pc}

08009b2c <LOS_ListInit>:
{
 8009b2c:	b480      	push	{r7}
 8009b2e:	b083      	sub	sp, #12
 8009b30:	af00      	add	r7, sp, #0
 8009b32:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 8009b34:	687b      	ldr	r3, [r7, #4]
 8009b36:	687a      	ldr	r2, [r7, #4]
 8009b38:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 8009b3a:	687b      	ldr	r3, [r7, #4]
 8009b3c:	687a      	ldr	r2, [r7, #4]
 8009b3e:	601a      	str	r2, [r3, #0]
}
 8009b40:	bf00      	nop
 8009b42:	370c      	adds	r7, #12
 8009b44:	46bd      	mov	sp, r7
 8009b46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b4a:	4770      	bx	lr

08009b4c <LOS_ListAdd>:
{
 8009b4c:	b480      	push	{r7}
 8009b4e:	b083      	sub	sp, #12
 8009b50:	af00      	add	r7, sp, #0
 8009b52:	6078      	str	r0, [r7, #4]
 8009b54:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 8009b56:	687b      	ldr	r3, [r7, #4]
 8009b58:	685a      	ldr	r2, [r3, #4]
 8009b5a:	683b      	ldr	r3, [r7, #0]
 8009b5c:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 8009b5e:	683b      	ldr	r3, [r7, #0]
 8009b60:	687a      	ldr	r2, [r7, #4]
 8009b62:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8009b64:	687b      	ldr	r3, [r7, #4]
 8009b66:	685b      	ldr	r3, [r3, #4]
 8009b68:	683a      	ldr	r2, [r7, #0]
 8009b6a:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 8009b6c:	687b      	ldr	r3, [r7, #4]
 8009b6e:	683a      	ldr	r2, [r7, #0]
 8009b70:	605a      	str	r2, [r3, #4]
}
 8009b72:	bf00      	nop
 8009b74:	370c      	adds	r7, #12
 8009b76:	46bd      	mov	sp, r7
 8009b78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b7c:	4770      	bx	lr

08009b7e <LOS_ListTailInsert>:
{
 8009b7e:	b580      	push	{r7, lr}
 8009b80:	b082      	sub	sp, #8
 8009b82:	af00      	add	r7, sp, #0
 8009b84:	6078      	str	r0, [r7, #4]
 8009b86:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 8009b88:	687b      	ldr	r3, [r7, #4]
 8009b8a:	681b      	ldr	r3, [r3, #0]
 8009b8c:	6839      	ldr	r1, [r7, #0]
 8009b8e:	4618      	mov	r0, r3
 8009b90:	f7ff ffdc 	bl	8009b4c <LOS_ListAdd>
}
 8009b94:	bf00      	nop
 8009b96:	3708      	adds	r7, #8
 8009b98:	46bd      	mov	sp, r7
 8009b9a:	bd80      	pop	{r7, pc}

08009b9c <LOS_ListDelete>:
{
 8009b9c:	b480      	push	{r7}
 8009b9e:	b083      	sub	sp, #12
 8009ba0:	af00      	add	r7, sp, #0
 8009ba2:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8009ba4:	687b      	ldr	r3, [r7, #4]
 8009ba6:	685b      	ldr	r3, [r3, #4]
 8009ba8:	687a      	ldr	r2, [r7, #4]
 8009baa:	6812      	ldr	r2, [r2, #0]
 8009bac:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 8009bae:	687b      	ldr	r3, [r7, #4]
 8009bb0:	681b      	ldr	r3, [r3, #0]
 8009bb2:	687a      	ldr	r2, [r7, #4]
 8009bb4:	6852      	ldr	r2, [r2, #4]
 8009bb6:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8009bb8:	687b      	ldr	r3, [r7, #4]
 8009bba:	2200      	movs	r2, #0
 8009bbc:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 8009bbe:	687b      	ldr	r3, [r7, #4]
 8009bc0:	2200      	movs	r2, #0
 8009bc2:	601a      	str	r2, [r3, #0]
}
 8009bc4:	bf00      	nop
 8009bc6:	370c      	adds	r7, #12
 8009bc8:	46bd      	mov	sp, r7
 8009bca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009bce:	4770      	bx	lr

08009bd0 <LOS_ListEmpty>:
{
 8009bd0:	b480      	push	{r7}
 8009bd2:	b083      	sub	sp, #12
 8009bd4:	af00      	add	r7, sp, #0
 8009bd6:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8009bd8:	687b      	ldr	r3, [r7, #4]
 8009bda:	685b      	ldr	r3, [r3, #4]
 8009bdc:	687a      	ldr	r2, [r7, #4]
 8009bde:	429a      	cmp	r2, r3
 8009be0:	bf0c      	ite	eq
 8009be2:	2301      	moveq	r3, #1
 8009be4:	2300      	movne	r3, #0
 8009be6:	b2db      	uxtb	r3, r3
}
 8009be8:	4618      	mov	r0, r3
 8009bea:	370c      	adds	r7, #12
 8009bec:	46bd      	mov	sp, r7
 8009bee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009bf2:	4770      	bx	lr

08009bf4 <ArchCurrCpuid>:
{
 8009bf4:	b480      	push	{r7}
 8009bf6:	af00      	add	r7, sp, #0
    return 0;
 8009bf8:	2300      	movs	r3, #0
}
 8009bfa:	4618      	mov	r0, r3
 8009bfc:	46bd      	mov	sp, r7
 8009bfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c02:	4770      	bx	lr

08009c04 <LOS_IntLock>:
{
 8009c04:	b580      	push	{r7, lr}
 8009c06:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8009c08:	f7f7 f85e 	bl	8000cc8 <ArchIntLock>
 8009c0c:	4603      	mov	r3, r0
}
 8009c0e:	4618      	mov	r0, r3
 8009c10:	bd80      	pop	{r7, pc}

08009c12 <LOS_IntRestore>:
{
 8009c12:	b580      	push	{r7, lr}
 8009c14:	b082      	sub	sp, #8
 8009c16:	af00      	add	r7, sp, #0
 8009c18:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8009c1a:	6878      	ldr	r0, [r7, #4]
 8009c1c:	f7f7 f85c 	bl	8000cd8 <ArchIntRestore>
}
 8009c20:	bf00      	nop
 8009c22:	3708      	adds	r7, #8
 8009c24:	46bd      	mov	sp, r7
 8009c26:	bd80      	pop	{r7, pc}

08009c28 <ArchCurrTaskGet>:
{
 8009c28:	b480      	push	{r7}
 8009c2a:	af00      	add	r7, sp, #0
    return g_runTask;
 8009c2c:	4b03      	ldr	r3, [pc, #12]	; (8009c3c <ArchCurrTaskGet+0x14>)
 8009c2e:	681b      	ldr	r3, [r3, #0]
}
 8009c30:	4618      	mov	r0, r3
 8009c32:	46bd      	mov	sp, r7
 8009c34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c38:	4770      	bx	lr
 8009c3a:	bf00      	nop
 8009c3c:	200033bc 	.word	0x200033bc

08009c40 <OsPercpuGet>:
{
 8009c40:	b580      	push	{r7, lr}
 8009c42:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 8009c44:	f7ff ffd6 	bl	8009bf4 <ArchCurrCpuid>
 8009c48:	4602      	mov	r2, r0
 8009c4a:	4613      	mov	r3, r2
 8009c4c:	00db      	lsls	r3, r3, #3
 8009c4e:	4413      	add	r3, r2
 8009c50:	009b      	lsls	r3, r3, #2
 8009c52:	4a02      	ldr	r2, [pc, #8]	; (8009c5c <OsPercpuGet+0x1c>)
 8009c54:	4413      	add	r3, r2
}
 8009c56:	4618      	mov	r0, r3
 8009c58:	bd80      	pop	{r7, pc}
 8009c5a:	bf00      	nop
 8009c5c:	200036fc 	.word	0x200036fc

08009c60 <OsPreemptableInSched>:
{
 8009c60:	b580      	push	{r7, lr}
 8009c62:	b082      	sub	sp, #8
 8009c64:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 8009c66:	2300      	movs	r3, #0
 8009c68:	607b      	str	r3, [r7, #4]
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 8009c6a:	f7ff ffe9 	bl	8009c40 <OsPercpuGet>
 8009c6e:	4603      	mov	r3, r0
 8009c70:	695b      	ldr	r3, [r3, #20]
 8009c72:	2b00      	cmp	r3, #0
 8009c74:	bf0c      	ite	eq
 8009c76:	2301      	moveq	r3, #1
 8009c78:	2300      	movne	r3, #0
 8009c7a:	b2db      	uxtb	r3, r3
 8009c7c:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 8009c7e:	687b      	ldr	r3, [r7, #4]
 8009c80:	2b00      	cmp	r3, #0
 8009c82:	d104      	bne.n	8009c8e <OsPreemptableInSched+0x2e>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8009c84:	f7ff ffdc 	bl	8009c40 <OsPercpuGet>
 8009c88:	4603      	mov	r3, r0
 8009c8a:	2201      	movs	r2, #1
 8009c8c:	621a      	str	r2, [r3, #32]
    return preemptable;
 8009c8e:	687b      	ldr	r3, [r7, #4]
}
 8009c90:	4618      	mov	r0, r3
 8009c92:	3708      	adds	r7, #8
 8009c94:	46bd      	mov	sp, r7
 8009c96:	bd80      	pop	{r7, pc}

08009c98 <LOS_Schedule>:
{
 8009c98:	b580      	push	{r7, lr}
 8009c9a:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 8009c9c:	f7f8 fbe6 	bl	800246c <IntActive>
 8009ca0:	4603      	mov	r3, r0
 8009ca2:	2b00      	cmp	r3, #0
 8009ca4:	d005      	beq.n	8009cb2 <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8009ca6:	f7ff ffcb 	bl	8009c40 <OsPercpuGet>
 8009caa:	4603      	mov	r3, r0
 8009cac:	2201      	movs	r2, #1
 8009cae:	621a      	str	r2, [r3, #32]
        return;
 8009cb0:	e001      	b.n	8009cb6 <LOS_Schedule+0x1e>
    OsSchedPreempt();
 8009cb2:	f7fe fb09 	bl	80082c8 <OsSchedPreempt>
}
 8009cb6:	bd80      	pop	{r7, pc}

08009cb8 <LOS_SpinLockSave>:
{
 8009cb8:	b580      	push	{r7, lr}
 8009cba:	b082      	sub	sp, #8
 8009cbc:	af00      	add	r7, sp, #0
 8009cbe:	6078      	str	r0, [r7, #4]
 8009cc0:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8009cc2:	f7ff ff9f 	bl	8009c04 <LOS_IntLock>
 8009cc6:	4602      	mov	r2, r0
 8009cc8:	683b      	ldr	r3, [r7, #0]
 8009cca:	601a      	str	r2, [r3, #0]
}
 8009ccc:	bf00      	nop
 8009cce:	3708      	adds	r7, #8
 8009cd0:	46bd      	mov	sp, r7
 8009cd2:	bd80      	pop	{r7, pc}

08009cd4 <LOS_SpinUnlockRestore>:
{
 8009cd4:	b580      	push	{r7, lr}
 8009cd6:	b082      	sub	sp, #8
 8009cd8:	af00      	add	r7, sp, #0
 8009cda:	6078      	str	r0, [r7, #4]
 8009cdc:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8009cde:	6838      	ldr	r0, [r7, #0]
 8009ce0:	f7ff ff97 	bl	8009c12 <LOS_IntRestore>
}
 8009ce4:	bf00      	nop
 8009ce6:	3708      	adds	r7, #8
 8009ce8:	46bd      	mov	sp, r7
 8009cea:	bd80      	pop	{r7, pc}

08009cec <OsCurrTaskGet>:
{
 8009cec:	b580      	push	{r7, lr}
 8009cee:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 8009cf0:	f7ff ff9a 	bl	8009c28 <ArchCurrTaskGet>
 8009cf4:	4603      	mov	r3, r0
}
 8009cf6:	4618      	mov	r0, r3
 8009cf8:	bd80      	pop	{r7, pc}

08009cfa <OsQueueDbgInitHook>:
#endif /* __cplusplus */

/* queue debug initialization interface */
extern UINT32 OsQueueDbgInit(VOID);
STATIC INLINE UINT32 OsQueueDbgInitHook(VOID)
{
 8009cfa:	b580      	push	{r7, lr}
 8009cfc:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_QUEUE
    return OsQueueDbgInit();
 8009cfe:	f7fb fbd7 	bl	80054b0 <OsQueueDbgInit>
 8009d02:	4603      	mov	r3, r0
#else
    return LOS_OK;
#endif
}
 8009d04:	4618      	mov	r0, r3
 8009d06:	bd80      	pop	{r7, pc}

08009d08 <OsQueueDbgTimeUpdateHook>:
/* Update the last time the queue was executed */
extern VOID OsQueueDbgTimeUpdate(UINT32 queueId);
STATIC INLINE VOID OsQueueDbgTimeUpdateHook(UINT32 queueId)
{
 8009d08:	b580      	push	{r7, lr}
 8009d0a:	b082      	sub	sp, #8
 8009d0c:	af00      	add	r7, sp, #0
 8009d0e:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_DEBUG_QUEUE
    OsQueueDbgTimeUpdate(queueId);
 8009d10:	6878      	ldr	r0, [r7, #4]
 8009d12:	f7fb fbff 	bl	8005514 <OsQueueDbgTimeUpdate>
#endif
}
 8009d16:	bf00      	nop
 8009d18:	3708      	adds	r7, #8
 8009d1a:	46bd      	mov	sp, r7
 8009d1c:	bd80      	pop	{r7, pc}

08009d1e <OsQueueDbgUpdateHook>:
/* Update the task  entry of  the queue debug info when created or deleted */
extern VOID OsQueueDbgUpdate(UINT32 queueId, TSK_ENTRY_FUNC entry);
STATIC INLINE VOID OsQueueDbgUpdateHook(UINT32 queueId, TSK_ENTRY_FUNC entry)
{
 8009d1e:	b580      	push	{r7, lr}
 8009d20:	b082      	sub	sp, #8
 8009d22:	af00      	add	r7, sp, #0
 8009d24:	6078      	str	r0, [r7, #4]
 8009d26:	6039      	str	r1, [r7, #0]
#ifdef LOSCFG_DEBUG_QUEUE
    OsQueueDbgUpdate(queueId, entry);
 8009d28:	6839      	ldr	r1, [r7, #0]
 8009d2a:	6878      	ldr	r0, [r7, #4]
 8009d2c:	f7fb fc0a 	bl	8005544 <OsQueueDbgUpdate>
#endif
}
 8009d30:	bf00      	nop
 8009d32:	3708      	adds	r7, #8
 8009d34:	46bd      	mov	sp, r7
 8009d36:	bd80      	pop	{r7, pc}

08009d38 <OsQueueCheckHook>:
/* check the leak of queue */
extern VOID OsQueueCheck(VOID);
STATIC INLINE VOID OsQueueCheckHook(VOID)
{
 8009d38:	b580      	push	{r7, lr}
 8009d3a:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_QUEUE
    OsQueueCheck();
 8009d3c:	f7fb fce8 	bl	8005710 <OsQueueCheck>
#endif
}
 8009d40:	bf00      	nop
 8009d42:	bd80      	pop	{r7, pc}

08009d44 <LOS_MpSchedule>:
{
 8009d44:	b480      	push	{r7}
 8009d46:	b083      	sub	sp, #12
 8009d48:	af00      	add	r7, sp, #0
 8009d4a:	6078      	str	r0, [r7, #4]
}
 8009d4c:	bf00      	nop
 8009d4e:	370c      	adds	r7, #12
 8009d50:	46bd      	mov	sp, r7
 8009d52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d56:	4770      	bx	lr

08009d58 <OsQueueInit>:
/*
 * Description : queue initial
 * Return      : LOS_OK on success or error code on failure
 */
LITE_OS_SEC_TEXT_INIT UINT32 OsQueueInit(VOID)
{
 8009d58:	b580      	push	{r7, lr}
 8009d5a:	b084      	sub	sp, #16
 8009d5c:	af00      	add	r7, sp, #0
    LosQueueCB *queueNode = NULL;
 8009d5e:	2300      	movs	r3, #0
 8009d60:	60bb      	str	r3, [r7, #8]
    UINT32 index;
    UINT32 size;

    size = KERNEL_QUEUE_LIMIT * sizeof(LosQueueCB);
 8009d62:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8009d66:	60fb      	str	r3, [r7, #12]
    /* system resident memory, don't free */
    g_allQueue = (LosQueueCB *)LOS_MemAlloc(m_aucSysMem0, size);
 8009d68:	4b1f      	ldr	r3, [pc, #124]	; (8009de8 <OsQueueInit+0x90>)
 8009d6a:	681b      	ldr	r3, [r3, #0]
 8009d6c:	68f9      	ldr	r1, [r7, #12]
 8009d6e:	4618      	mov	r0, r3
 8009d70:	f7fe fe1a 	bl	80089a8 <LOS_MemAlloc>
 8009d74:	4603      	mov	r3, r0
 8009d76:	4a1d      	ldr	r2, [pc, #116]	; (8009dec <OsQueueInit+0x94>)
 8009d78:	6013      	str	r3, [r2, #0]
    if (g_allQueue == NULL) {
 8009d7a:	4b1c      	ldr	r3, [pc, #112]	; (8009dec <OsQueueInit+0x94>)
 8009d7c:	681b      	ldr	r3, [r3, #0]
 8009d7e:	2b00      	cmp	r3, #0
 8009d80:	d101      	bne.n	8009d86 <OsQueueInit+0x2e>
        return LOS_ERRNO_QUEUE_NO_MEMORY;
 8009d82:	4b1b      	ldr	r3, [pc, #108]	; (8009df0 <OsQueueInit+0x98>)
 8009d84:	e02c      	b.n	8009de0 <OsQueueInit+0x88>
    }
    (VOID)memset_s(g_allQueue, size, 0, size);
 8009d86:	4b19      	ldr	r3, [pc, #100]	; (8009dec <OsQueueInit+0x94>)
 8009d88:	6818      	ldr	r0, [r3, #0]
 8009d8a:	68fb      	ldr	r3, [r7, #12]
 8009d8c:	2200      	movs	r2, #0
 8009d8e:	68f9      	ldr	r1, [r7, #12]
 8009d90:	f00c f97c 	bl	801608c <memset_s>
    LOS_ListInit(&g_freeQueueList);
 8009d94:	4817      	ldr	r0, [pc, #92]	; (8009df4 <OsQueueInit+0x9c>)
 8009d96:	f7ff fec9 	bl	8009b2c <LOS_ListInit>
    for (index = 0; index < KERNEL_QUEUE_LIMIT; index++) {
 8009d9a:	2300      	movs	r3, #0
 8009d9c:	607b      	str	r3, [r7, #4]
 8009d9e:	e014      	b.n	8009dca <OsQueueInit+0x72>
        queueNode = ((LosQueueCB *)g_allQueue) + index;
 8009da0:	4b12      	ldr	r3, [pc, #72]	; (8009dec <OsQueueInit+0x94>)
 8009da2:	6819      	ldr	r1, [r3, #0]
 8009da4:	687a      	ldr	r2, [r7, #4]
 8009da6:	4613      	mov	r3, r2
 8009da8:	005b      	lsls	r3, r3, #1
 8009daa:	4413      	add	r3, r2
 8009dac:	011b      	lsls	r3, r3, #4
 8009dae:	440b      	add	r3, r1
 8009db0:	60bb      	str	r3, [r7, #8]
        queueNode->queueId = index;
 8009db2:	68bb      	ldr	r3, [r7, #8]
 8009db4:	687a      	ldr	r2, [r7, #4]
 8009db6:	60da      	str	r2, [r3, #12]
        LOS_ListTailInsert(&g_freeQueueList, &queueNode->readWriteList[OS_QUEUE_WRITE]);
 8009db8:	68bb      	ldr	r3, [r7, #8]
 8009dba:	3320      	adds	r3, #32
 8009dbc:	4619      	mov	r1, r3
 8009dbe:	480d      	ldr	r0, [pc, #52]	; (8009df4 <OsQueueInit+0x9c>)
 8009dc0:	f7ff fedd 	bl	8009b7e <LOS_ListTailInsert>
    for (index = 0; index < KERNEL_QUEUE_LIMIT; index++) {
 8009dc4:	687b      	ldr	r3, [r7, #4]
 8009dc6:	3301      	adds	r3, #1
 8009dc8:	607b      	str	r3, [r7, #4]
 8009dca:	687b      	ldr	r3, [r7, #4]
 8009dcc:	2b09      	cmp	r3, #9
 8009dce:	d9e7      	bls.n	8009da0 <OsQueueInit+0x48>
    }

    if (OsQueueDbgInitHook() != LOS_OK) {
 8009dd0:	f7ff ff93 	bl	8009cfa <OsQueueDbgInitHook>
 8009dd4:	4603      	mov	r3, r0
 8009dd6:	2b00      	cmp	r3, #0
 8009dd8:	d001      	beq.n	8009dde <OsQueueInit+0x86>
        return LOS_ERRNO_QUEUE_NO_MEMORY;
 8009dda:	4b05      	ldr	r3, [pc, #20]	; (8009df0 <OsQueueInit+0x98>)
 8009ddc:	e000      	b.n	8009de0 <OsQueueInit+0x88>
    }
    return LOS_OK;
 8009dde:	2300      	movs	r3, #0
}
 8009de0:	4618      	mov	r0, r3
 8009de2:	3710      	adds	r7, #16
 8009de4:	46bd      	mov	sp, r7
 8009de6:	bd80      	pop	{r7, pc}
 8009de8:	200021b4 	.word	0x200021b4
 8009dec:	200021bc 	.word	0x200021bc
 8009df0:	02000601 	.word	0x02000601
 8009df4:	200021c0 	.word	0x200021c0

08009df8 <OsQueueCreateParameterCheck>:

STATIC INLINE UINT32 OsQueueCreateParameterCheck(UINT16 len, const UINT32 *queueId, UINT16 maxMsgSize)
{
 8009df8:	b480      	push	{r7}
 8009dfa:	b083      	sub	sp, #12
 8009dfc:	af00      	add	r7, sp, #0
 8009dfe:	4603      	mov	r3, r0
 8009e00:	6039      	str	r1, [r7, #0]
 8009e02:	80fb      	strh	r3, [r7, #6]
 8009e04:	4613      	mov	r3, r2
 8009e06:	80bb      	strh	r3, [r7, #4]
    if (queueId == NULL) {
 8009e08:	683b      	ldr	r3, [r7, #0]
 8009e0a:	2b00      	cmp	r3, #0
 8009e0c:	d101      	bne.n	8009e12 <OsQueueCreateParameterCheck+0x1a>
        return LOS_ERRNO_QUEUE_CREAT_PTR_NULL;
 8009e0e:	4b0c      	ldr	r3, [pc, #48]	; (8009e40 <OsQueueCreateParameterCheck+0x48>)
 8009e10:	e00f      	b.n	8009e32 <OsQueueCreateParameterCheck+0x3a>
    }

    if (maxMsgSize > (OS_NULL_SHORT - sizeof(UINT32))) {
 8009e12:	88bb      	ldrh	r3, [r7, #4]
 8009e14:	f64f 72fb 	movw	r2, #65531	; 0xfffb
 8009e18:	4293      	cmp	r3, r2
 8009e1a:	d901      	bls.n	8009e20 <OsQueueCreateParameterCheck+0x28>
        return LOS_ERRNO_QUEUE_SIZE_TOO_BIG;
 8009e1c:	4b09      	ldr	r3, [pc, #36]	; (8009e44 <OsQueueCreateParameterCheck+0x4c>)
 8009e1e:	e008      	b.n	8009e32 <OsQueueCreateParameterCheck+0x3a>
    }

    if ((len == 0) || (maxMsgSize == 0)) {
 8009e20:	88fb      	ldrh	r3, [r7, #6]
 8009e22:	2b00      	cmp	r3, #0
 8009e24:	d002      	beq.n	8009e2c <OsQueueCreateParameterCheck+0x34>
 8009e26:	88bb      	ldrh	r3, [r7, #4]
 8009e28:	2b00      	cmp	r3, #0
 8009e2a:	d101      	bne.n	8009e30 <OsQueueCreateParameterCheck+0x38>
        return LOS_ERRNO_QUEUE_PARA_ISZERO;
 8009e2c:	4b06      	ldr	r3, [pc, #24]	; (8009e48 <OsQueueCreateParameterCheck+0x50>)
 8009e2e:	e000      	b.n	8009e32 <OsQueueCreateParameterCheck+0x3a>
    }
    return LOS_OK;
 8009e30:	2300      	movs	r3, #0
}
 8009e32:	4618      	mov	r0, r3
 8009e34:	370c      	adds	r7, #12
 8009e36:	46bd      	mov	sp, r7
 8009e38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e3c:	4770      	bx	lr
 8009e3e:	bf00      	nop
 8009e40:	0200060c 	.word	0x0200060c
 8009e44:	02000603 	.word	0x02000603
 8009e48:	0200060d 	.word	0x0200060d

08009e4c <OsQueueCreateInternal>:

LITE_OS_SEC_TEXT_INIT STATIC UINT32 OsQueueCreateInternal(UINT16 len, UINT32 *queueId, UINT16 msgSize,
                                                          UINT8 *queue, UINT8 queueMemType)
{
 8009e4c:	b590      	push	{r4, r7, lr}
 8009e4e:	b091      	sub	sp, #68	; 0x44
 8009e50:	af00      	add	r7, sp, #0
 8009e52:	60b9      	str	r1, [r7, #8]
 8009e54:	607b      	str	r3, [r7, #4]
 8009e56:	4603      	mov	r3, r0
 8009e58:	81fb      	strh	r3, [r7, #14]
 8009e5a:	4613      	mov	r3, r2
 8009e5c:	81bb      	strh	r3, [r7, #12]
 8009e5e:	4b4e      	ldr	r3, [pc, #312]	; (8009f98 <OsQueueCreateInternal+0x14c>)
 8009e60:	681b      	ldr	r3, [r3, #0]
 8009e62:	63fb      	str	r3, [r7, #60]	; 0x3c
 8009e64:	f04f 0300 	mov.w	r3, #0
    LosQueueCB *queueCB = NULL;
 8009e68:	2300      	movs	r3, #0
 8009e6a:	61bb      	str	r3, [r7, #24]
    LOS_DL_LIST *unusedQueue = NULL;
 8009e6c:	2300      	movs	r3, #0
 8009e6e:	61fb      	str	r3, [r7, #28]
    UINT32 intSave;

    SCHEDULER_LOCK(intSave);
 8009e70:	f107 0314 	add.w	r3, r7, #20
 8009e74:	4619      	mov	r1, r3
 8009e76:	4849      	ldr	r0, [pc, #292]	; (8009f9c <OsQueueCreateInternal+0x150>)
 8009e78:	f7ff ff1e 	bl	8009cb8 <LOS_SpinLockSave>
    if (LOS_ListEmpty(&g_freeQueueList)) {
 8009e7c:	4848      	ldr	r0, [pc, #288]	; (8009fa0 <OsQueueCreateInternal+0x154>)
 8009e7e:	f7ff fea7 	bl	8009bd0 <LOS_ListEmpty>
 8009e82:	4603      	mov	r3, r0
 8009e84:	2b00      	cmp	r3, #0
 8009e86:	d008      	beq.n	8009e9a <OsQueueCreateInternal+0x4e>
        SCHEDULER_UNLOCK(intSave);
 8009e88:	697b      	ldr	r3, [r7, #20]
 8009e8a:	4619      	mov	r1, r3
 8009e8c:	4843      	ldr	r0, [pc, #268]	; (8009f9c <OsQueueCreateInternal+0x150>)
 8009e8e:	f7ff ff21 	bl	8009cd4 <LOS_SpinUnlockRestore>
        OsQueueCheckHook();
 8009e92:	f7ff ff51 	bl	8009d38 <OsQueueCheckHook>
        return LOS_ERRNO_QUEUE_CB_UNAVAILABLE;
 8009e96:	4b43      	ldr	r3, [pc, #268]	; (8009fa4 <OsQueueCreateInternal+0x158>)
 8009e98:	e072      	b.n	8009f80 <OsQueueCreateInternal+0x134>
    }

    unusedQueue = LOS_DL_LIST_FIRST(&g_freeQueueList);
 8009e9a:	4b41      	ldr	r3, [pc, #260]	; (8009fa0 <OsQueueCreateInternal+0x154>)
 8009e9c:	685b      	ldr	r3, [r3, #4]
 8009e9e:	61fb      	str	r3, [r7, #28]
    LOS_ListDelete(unusedQueue);
 8009ea0:	69f8      	ldr	r0, [r7, #28]
 8009ea2:	f7ff fe7b 	bl	8009b9c <LOS_ListDelete>
    queueCB = GET_QUEUE_LIST(unusedQueue);
 8009ea6:	69fb      	ldr	r3, [r7, #28]
 8009ea8:	3b20      	subs	r3, #32
 8009eaa:	61bb      	str	r3, [r7, #24]
    queueCB->queueLen = len;
 8009eac:	69bb      	ldr	r3, [r7, #24]
 8009eae:	89fa      	ldrh	r2, [r7, #14]
 8009eb0:	80da      	strh	r2, [r3, #6]
    queueCB->queueSize = msgSize;
 8009eb2:	69bb      	ldr	r3, [r7, #24]
 8009eb4:	89ba      	ldrh	r2, [r7, #12]
 8009eb6:	811a      	strh	r2, [r3, #8]
    queueCB->queueHandle = queue;
 8009eb8:	69bb      	ldr	r3, [r7, #24]
 8009eba:	687a      	ldr	r2, [r7, #4]
 8009ebc:	601a      	str	r2, [r3, #0]
    queueCB->queueState = LOS_USED;
 8009ebe:	69bb      	ldr	r3, [r7, #24]
 8009ec0:	2201      	movs	r2, #1
 8009ec2:	711a      	strb	r2, [r3, #4]
    queueCB->queueMemType = queueMemType;
 8009ec4:	69bb      	ldr	r3, [r7, #24]
 8009ec6:	f897 2050 	ldrb.w	r2, [r7, #80]	; 0x50
 8009eca:	715a      	strb	r2, [r3, #5]
    queueCB->readWriteableCnt[OS_QUEUE_READ] = 0;
 8009ecc:	69bb      	ldr	r3, [r7, #24]
 8009ece:	2200      	movs	r2, #0
 8009ed0:	829a      	strh	r2, [r3, #20]
    queueCB->readWriteableCnt[OS_QUEUE_WRITE] = len;
 8009ed2:	69bb      	ldr	r3, [r7, #24]
 8009ed4:	89fa      	ldrh	r2, [r7, #14]
 8009ed6:	82da      	strh	r2, [r3, #22]
    queueCB->queueHead = 0;
 8009ed8:	69bb      	ldr	r3, [r7, #24]
 8009eda:	2200      	movs	r2, #0
 8009edc:	821a      	strh	r2, [r3, #16]
    queueCB->queueTail = 0;
 8009ede:	69bb      	ldr	r3, [r7, #24]
 8009ee0:	2200      	movs	r2, #0
 8009ee2:	825a      	strh	r2, [r3, #18]
    LOS_ListInit(&queueCB->readWriteList[OS_QUEUE_READ]);
 8009ee4:	69bb      	ldr	r3, [r7, #24]
 8009ee6:	3318      	adds	r3, #24
 8009ee8:	4618      	mov	r0, r3
 8009eea:	f7ff fe1f 	bl	8009b2c <LOS_ListInit>
    LOS_ListInit(&queueCB->readWriteList[OS_QUEUE_WRITE]);
 8009eee:	69bb      	ldr	r3, [r7, #24]
 8009ef0:	3320      	adds	r3, #32
 8009ef2:	4618      	mov	r0, r3
 8009ef4:	f7ff fe1a 	bl	8009b2c <LOS_ListInit>
    LOS_ListInit(&queueCB->memList);
 8009ef8:	69bb      	ldr	r3, [r7, #24]
 8009efa:	3328      	adds	r3, #40	; 0x28
 8009efc:	4618      	mov	r0, r3
 8009efe:	f7ff fe15 	bl	8009b2c <LOS_ListInit>

    OsQueueDbgUpdateHook(queueCB->queueId, OsCurrTaskGet()->taskEntry);
 8009f02:	69bb      	ldr	r3, [r7, #24]
 8009f04:	68dc      	ldr	r4, [r3, #12]
 8009f06:	f7ff fef1 	bl	8009cec <OsCurrTaskGet>
 8009f0a:	4603      	mov	r3, r0
 8009f0c:	699b      	ldr	r3, [r3, #24]
 8009f0e:	4619      	mov	r1, r3
 8009f10:	4620      	mov	r0, r4
 8009f12:	f7ff ff04 	bl	8009d1e <OsQueueDbgUpdateHook>
    SCHEDULER_UNLOCK(intSave);
 8009f16:	697b      	ldr	r3, [r7, #20]
 8009f18:	4619      	mov	r1, r3
 8009f1a:	4820      	ldr	r0, [pc, #128]	; (8009f9c <OsQueueCreateInternal+0x150>)
 8009f1c:	f7ff feda 	bl	8009cd4 <LOS_SpinUnlockRestore>

    *queueId = queueCB->queueId;
 8009f20:	69bb      	ldr	r3, [r7, #24]
 8009f22:	68da      	ldr	r2, [r3, #12]
 8009f24:	68bb      	ldr	r3, [r7, #8]
 8009f26:	601a      	str	r2, [r3, #0]

    LOS_TRACE(QUEUE_CREATE, *queueId, len, msgSize - sizeof(UINT32), (UINTPTR)queue, queueMemType);
 8009f28:	2300      	movs	r3, #0
 8009f2a:	627b      	str	r3, [r7, #36]	; 0x24
 8009f2c:	68bb      	ldr	r3, [r7, #8]
 8009f2e:	681b      	ldr	r3, [r3, #0]
 8009f30:	62bb      	str	r3, [r7, #40]	; 0x28
 8009f32:	89fb      	ldrh	r3, [r7, #14]
 8009f34:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009f36:	89bb      	ldrh	r3, [r7, #12]
 8009f38:	3b04      	subs	r3, #4
 8009f3a:	633b      	str	r3, [r7, #48]	; 0x30
 8009f3c:	687b      	ldr	r3, [r7, #4]
 8009f3e:	637b      	str	r3, [r7, #52]	; 0x34
 8009f40:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 8009f44:	63bb      	str	r3, [r7, #56]	; 0x38
 8009f46:	2306      	movs	r3, #6
 8009f48:	623b      	str	r3, [r7, #32]
 8009f4a:	6a3b      	ldr	r3, [r7, #32]
 8009f4c:	2b01      	cmp	r3, #1
 8009f4e:	d916      	bls.n	8009f7e <OsQueueCreateInternal+0x132>
 8009f50:	4b15      	ldr	r3, [pc, #84]	; (8009fa8 <OsQueueCreateInternal+0x15c>)
 8009f52:	681b      	ldr	r3, [r3, #0]
 8009f54:	2b00      	cmp	r3, #0
 8009f56:	d012      	beq.n	8009f7e <OsQueueCreateInternal+0x132>
 8009f58:	4b13      	ldr	r3, [pc, #76]	; (8009fa8 <OsQueueCreateInternal+0x15c>)
 8009f5a:	681c      	ldr	r4, [r3, #0]
 8009f5c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009f5e:	6a3b      	ldr	r3, [r7, #32]
 8009f60:	2b02      	cmp	r3, #2
 8009f62:	d904      	bls.n	8009f6e <OsQueueCreateInternal+0x122>
 8009f64:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009f68:	f103 0208 	add.w	r2, r3, #8
 8009f6c:	e000      	b.n	8009f70 <OsQueueCreateInternal+0x124>
 8009f6e:	2200      	movs	r2, #0
 8009f70:	6a3b      	ldr	r3, [r7, #32]
 8009f72:	b29b      	uxth	r3, r3
 8009f74:	3b02      	subs	r3, #2
 8009f76:	b29b      	uxth	r3, r3
 8009f78:	f44f 7000 	mov.w	r0, #512	; 0x200
 8009f7c:	47a0      	blx	r4
    return LOS_OK;
 8009f7e:	2300      	movs	r3, #0
}
 8009f80:	4a05      	ldr	r2, [pc, #20]	; (8009f98 <OsQueueCreateInternal+0x14c>)
 8009f82:	6811      	ldr	r1, [r2, #0]
 8009f84:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009f86:	4051      	eors	r1, r2
 8009f88:	d001      	beq.n	8009f8e <OsQueueCreateInternal+0x142>
 8009f8a:	f7fa fa2d 	bl	80043e8 <__stack_chk_fail>
 8009f8e:	4618      	mov	r0, r3
 8009f90:	3744      	adds	r7, #68	; 0x44
 8009f92:	46bd      	mov	sp, r7
 8009f94:	bd90      	pop	{r4, r7, pc}
 8009f96:	bf00      	nop
 8009f98:	08021468 	.word	0x08021468
 8009f9c:	20000764 	.word	0x20000764
 8009fa0:	200021c0 	.word	0x200021c0
 8009fa4:	02000604 	.word	0x02000604
 8009fa8:	2000075c 	.word	0x2000075c

08009fac <LOS_QueueCreate>:
}
#endif

LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueCreate(const CHAR *queueName, UINT16 len, UINT32 *queueId,
                                             UINT32 flags, UINT16 maxMsgSize)
{
 8009fac:	b580      	push	{r7, lr}
 8009fae:	b08a      	sub	sp, #40	; 0x28
 8009fb0:	af02      	add	r7, sp, #8
 8009fb2:	60f8      	str	r0, [r7, #12]
 8009fb4:	607a      	str	r2, [r7, #4]
 8009fb6:	603b      	str	r3, [r7, #0]
 8009fb8:	460b      	mov	r3, r1
 8009fba:	817b      	strh	r3, [r7, #10]
    UINT32 ret;
    UINT8 *queueMem = NULL;
 8009fbc:	2300      	movs	r3, #0
 8009fbe:	61bb      	str	r3, [r7, #24]
    UINT16 msgSize;
    (VOID)queueName;
    (VOID)flags;

    ret = OsQueueCreateParameterCheck(len, queueId, maxMsgSize);
 8009fc0:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8009fc2:	897b      	ldrh	r3, [r7, #10]
 8009fc4:	6879      	ldr	r1, [r7, #4]
 8009fc6:	4618      	mov	r0, r3
 8009fc8:	f7ff ff16 	bl	8009df8 <OsQueueCreateParameterCheck>
 8009fcc:	61f8      	str	r0, [r7, #28]
    if (ret != LOS_OK) {
 8009fce:	69fb      	ldr	r3, [r7, #28]
 8009fd0:	2b00      	cmp	r3, #0
 8009fd2:	d001      	beq.n	8009fd8 <LOS_QueueCreate+0x2c>
        return ret;
 8009fd4:	69fb      	ldr	r3, [r7, #28]
 8009fd6:	e026      	b.n	800a026 <LOS_QueueCreate+0x7a>
    }

    msgSize = maxMsgSize + sizeof(UINT32);
 8009fd8:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8009fda:	3304      	adds	r3, #4
 8009fdc:	82fb      	strh	r3, [r7, #22]
    /*
     * Memory allocation is time-consuming, to shorten the time of disable interrupt,
     * move the memory allocation to here.
     */
    queueMem = (UINT8 *)LOS_MemAlloc(m_aucSysMem1, (UINT32)len * msgSize);
 8009fde:	4b14      	ldr	r3, [pc, #80]	; (800a030 <LOS_QueueCreate+0x84>)
 8009fe0:	6818      	ldr	r0, [r3, #0]
 8009fe2:	897b      	ldrh	r3, [r7, #10]
 8009fe4:	8afa      	ldrh	r2, [r7, #22]
 8009fe6:	fb02 f303 	mul.w	r3, r2, r3
 8009fea:	4619      	mov	r1, r3
 8009fec:	f7fe fcdc 	bl	80089a8 <LOS_MemAlloc>
 8009ff0:	61b8      	str	r0, [r7, #24]
    if (queueMem == NULL) {
 8009ff2:	69bb      	ldr	r3, [r7, #24]
 8009ff4:	2b00      	cmp	r3, #0
 8009ff6:	d101      	bne.n	8009ffc <LOS_QueueCreate+0x50>
        return LOS_ERRNO_QUEUE_CREATE_NO_MEMORY;
 8009ff8:	4b0e      	ldr	r3, [pc, #56]	; (800a034 <LOS_QueueCreate+0x88>)
 8009ffa:	e014      	b.n	800a026 <LOS_QueueCreate+0x7a>
    }

    ret = OsQueueCreateInternal(len, queueId, msgSize, queueMem, OS_QUEUE_ALLOC_DYNAMIC);
 8009ffc:	8afa      	ldrh	r2, [r7, #22]
 8009ffe:	8978      	ldrh	r0, [r7, #10]
 800a000:	2300      	movs	r3, #0
 800a002:	9300      	str	r3, [sp, #0]
 800a004:	69bb      	ldr	r3, [r7, #24]
 800a006:	6879      	ldr	r1, [r7, #4]
 800a008:	f7ff ff20 	bl	8009e4c <OsQueueCreateInternal>
 800a00c:	61f8      	str	r0, [r7, #28]
    if (ret != LOS_OK) {
 800a00e:	69fb      	ldr	r3, [r7, #28]
 800a010:	2b00      	cmp	r3, #0
 800a012:	d007      	beq.n	800a024 <LOS_QueueCreate+0x78>
        (VOID)LOS_MemFree(m_aucSysMem1, queueMem);
 800a014:	4b06      	ldr	r3, [pc, #24]	; (800a030 <LOS_QueueCreate+0x84>)
 800a016:	681b      	ldr	r3, [r3, #0]
 800a018:	69b9      	ldr	r1, [r7, #24]
 800a01a:	4618      	mov	r0, r3
 800a01c:	f7fe fd7c 	bl	8008b18 <LOS_MemFree>
        return ret;
 800a020:	69fb      	ldr	r3, [r7, #28]
 800a022:	e000      	b.n	800a026 <LOS_QueueCreate+0x7a>
    }

    return LOS_OK;
 800a024:	2300      	movs	r3, #0
}
 800a026:	4618      	mov	r0, r3
 800a028:	3720      	adds	r7, #32
 800a02a:	46bd      	mov	sp, r7
 800a02c:	bd80      	pop	{r7, pc}
 800a02e:	bf00      	nop
 800a030:	200021b8 	.word	0x200021b8
 800a034:	02000602 	.word	0x02000602

0800a038 <OsQueueReadParameterCheck>:

LITE_OS_SEC_TEXT STATIC UINT32 OsQueueReadParameterCheck(UINT32 queueId, const VOID *bufferAddr,
                                                         const UINT32 *bufferSize, UINT32 timeout)
{
 800a038:	b580      	push	{r7, lr}
 800a03a:	b084      	sub	sp, #16
 800a03c:	af00      	add	r7, sp, #0
 800a03e:	60f8      	str	r0, [r7, #12]
 800a040:	60b9      	str	r1, [r7, #8]
 800a042:	607a      	str	r2, [r7, #4]
 800a044:	603b      	str	r3, [r7, #0]
    if (GET_QUEUE_INDEX(queueId) >= KERNEL_QUEUE_LIMIT) {
 800a046:	68fb      	ldr	r3, [r7, #12]
 800a048:	b29b      	uxth	r3, r3
 800a04a:	2b09      	cmp	r3, #9
 800a04c:	d901      	bls.n	800a052 <OsQueueReadParameterCheck+0x1a>
        return LOS_ERRNO_QUEUE_INVALID;
 800a04e:	4b14      	ldr	r3, [pc, #80]	; (800a0a0 <OsQueueReadParameterCheck+0x68>)
 800a050:	e021      	b.n	800a096 <OsQueueReadParameterCheck+0x5e>
    }

    if ((bufferAddr == NULL) || (bufferSize == NULL)) {
 800a052:	68bb      	ldr	r3, [r7, #8]
 800a054:	2b00      	cmp	r3, #0
 800a056:	d002      	beq.n	800a05e <OsQueueReadParameterCheck+0x26>
 800a058:	687b      	ldr	r3, [r7, #4]
 800a05a:	2b00      	cmp	r3, #0
 800a05c:	d101      	bne.n	800a062 <OsQueueReadParameterCheck+0x2a>
        return LOS_ERRNO_QUEUE_READ_PTR_NULL;
 800a05e:	4b11      	ldr	r3, [pc, #68]	; (800a0a4 <OsQueueReadParameterCheck+0x6c>)
 800a060:	e019      	b.n	800a096 <OsQueueReadParameterCheck+0x5e>
    }

    if ((*bufferSize == 0) || (*bufferSize > (OS_NULL_SHORT - sizeof(UINT32)))) {
 800a062:	687b      	ldr	r3, [r7, #4]
 800a064:	681b      	ldr	r3, [r3, #0]
 800a066:	2b00      	cmp	r3, #0
 800a068:	d005      	beq.n	800a076 <OsQueueReadParameterCheck+0x3e>
 800a06a:	687b      	ldr	r3, [r7, #4]
 800a06c:	681b      	ldr	r3, [r3, #0]
 800a06e:	f64f 72fb 	movw	r2, #65531	; 0xfffb
 800a072:	4293      	cmp	r3, r2
 800a074:	d901      	bls.n	800a07a <OsQueueReadParameterCheck+0x42>
        return LOS_ERRNO_QUEUE_READSIZE_IS_INVALID;
 800a076:	4b0c      	ldr	r3, [pc, #48]	; (800a0a8 <OsQueueReadParameterCheck+0x70>)
 800a078:	e00d      	b.n	800a096 <OsQueueReadParameterCheck+0x5e>
    }

    OsQueueDbgTimeUpdateHook(queueId);
 800a07a:	68f8      	ldr	r0, [r7, #12]
 800a07c:	f7ff fe44 	bl	8009d08 <OsQueueDbgTimeUpdateHook>

    if (timeout != LOS_NO_WAIT) {
 800a080:	683b      	ldr	r3, [r7, #0]
 800a082:	2b00      	cmp	r3, #0
 800a084:	d006      	beq.n	800a094 <OsQueueReadParameterCheck+0x5c>
        if (OS_INT_ACTIVE) {
 800a086:	f7f8 f9f1 	bl	800246c <IntActive>
 800a08a:	4603      	mov	r3, r0
 800a08c:	2b00      	cmp	r3, #0
 800a08e:	d001      	beq.n	800a094 <OsQueueReadParameterCheck+0x5c>
            return LOS_ERRNO_QUEUE_READ_IN_INTERRUPT;
 800a090:	4b06      	ldr	r3, [pc, #24]	; (800a0ac <OsQueueReadParameterCheck+0x74>)
 800a092:	e000      	b.n	800a096 <OsQueueReadParameterCheck+0x5e>
        }
    }
    return LOS_OK;
 800a094:	2300      	movs	r3, #0
}
 800a096:	4618      	mov	r0, r3
 800a098:	3710      	adds	r7, #16
 800a09a:	46bd      	mov	sp, r7
 800a09c:	bd80      	pop	{r7, pc}
 800a09e:	bf00      	nop
 800a0a0:	0200060e 	.word	0x0200060e
 800a0a4:	0200060f 	.word	0x0200060f
 800a0a8:	02000610 	.word	0x02000610
 800a0ac:	02000618 	.word	0x02000618

0800a0b0 <OsQueueWriteParameterCheck>:

LITE_OS_SEC_TEXT STATIC UINT32 OsQueueWriteParameterCheck(UINT32 queueId, const VOID *bufferAddr,
                                                          const UINT32 *bufferSize, UINT32 timeout)
{
 800a0b0:	b580      	push	{r7, lr}
 800a0b2:	b084      	sub	sp, #16
 800a0b4:	af00      	add	r7, sp, #0
 800a0b6:	60f8      	str	r0, [r7, #12]
 800a0b8:	60b9      	str	r1, [r7, #8]
 800a0ba:	607a      	str	r2, [r7, #4]
 800a0bc:	603b      	str	r3, [r7, #0]
    if (GET_QUEUE_INDEX(queueId) >= KERNEL_QUEUE_LIMIT) {
 800a0be:	68fb      	ldr	r3, [r7, #12]
 800a0c0:	b29b      	uxth	r3, r3
 800a0c2:	2b09      	cmp	r3, #9
 800a0c4:	d901      	bls.n	800a0ca <OsQueueWriteParameterCheck+0x1a>
        return LOS_ERRNO_QUEUE_INVALID;
 800a0c6:	4b0f      	ldr	r3, [pc, #60]	; (800a104 <OsQueueWriteParameterCheck+0x54>)
 800a0c8:	e018      	b.n	800a0fc <OsQueueWriteParameterCheck+0x4c>
    }

    if (bufferAddr == NULL) {
 800a0ca:	68bb      	ldr	r3, [r7, #8]
 800a0cc:	2b00      	cmp	r3, #0
 800a0ce:	d101      	bne.n	800a0d4 <OsQueueWriteParameterCheck+0x24>
        return LOS_ERRNO_QUEUE_WRITE_PTR_NULL;
 800a0d0:	4b0d      	ldr	r3, [pc, #52]	; (800a108 <OsQueueWriteParameterCheck+0x58>)
 800a0d2:	e013      	b.n	800a0fc <OsQueueWriteParameterCheck+0x4c>
    }

    if (*bufferSize == 0) {
 800a0d4:	687b      	ldr	r3, [r7, #4]
 800a0d6:	681b      	ldr	r3, [r3, #0]
 800a0d8:	2b00      	cmp	r3, #0
 800a0da:	d101      	bne.n	800a0e0 <OsQueueWriteParameterCheck+0x30>
        return LOS_ERRNO_QUEUE_WRITESIZE_ISZERO;
 800a0dc:	4b0b      	ldr	r3, [pc, #44]	; (800a10c <OsQueueWriteParameterCheck+0x5c>)
 800a0de:	e00d      	b.n	800a0fc <OsQueueWriteParameterCheck+0x4c>
    }

    OsQueueDbgTimeUpdateHook(queueId);
 800a0e0:	68f8      	ldr	r0, [r7, #12]
 800a0e2:	f7ff fe11 	bl	8009d08 <OsQueueDbgTimeUpdateHook>

    if (timeout != LOS_NO_WAIT) {
 800a0e6:	683b      	ldr	r3, [r7, #0]
 800a0e8:	2b00      	cmp	r3, #0
 800a0ea:	d006      	beq.n	800a0fa <OsQueueWriteParameterCheck+0x4a>
        if (OS_INT_ACTIVE) {
 800a0ec:	f7f8 f9be 	bl	800246c <IntActive>
 800a0f0:	4603      	mov	r3, r0
 800a0f2:	2b00      	cmp	r3, #0
 800a0f4:	d001      	beq.n	800a0fa <OsQueueWriteParameterCheck+0x4a>
            return LOS_ERRNO_QUEUE_WRITE_IN_INTERRUPT;
 800a0f6:	4b06      	ldr	r3, [pc, #24]	; (800a110 <OsQueueWriteParameterCheck+0x60>)
 800a0f8:	e000      	b.n	800a0fc <OsQueueWriteParameterCheck+0x4c>
        }
    }
    return LOS_OK;
 800a0fa:	2300      	movs	r3, #0
}
 800a0fc:	4618      	mov	r0, r3
 800a0fe:	3710      	adds	r7, #16
 800a100:	46bd      	mov	sp, r7
 800a102:	bd80      	pop	{r7, pc}
 800a104:	0200060e 	.word	0x0200060e
 800a108:	02000612 	.word	0x02000612
 800a10c:	02000613 	.word	0x02000613
 800a110:	02000609 	.word	0x02000609

0800a114 <OsQueueBufferOperate>:

STATIC UINT32 OsQueueBufferOperate(LosQueueCB *queueCB, UINT32 operateType, VOID *bufferAddr, UINT32 *bufferSize)
{
 800a114:	b580      	push	{r7, lr}
 800a116:	b088      	sub	sp, #32
 800a118:	af00      	add	r7, sp, #0
 800a11a:	60f8      	str	r0, [r7, #12]
 800a11c:	60b9      	str	r1, [r7, #8]
 800a11e:	607a      	str	r2, [r7, #4]
 800a120:	603b      	str	r3, [r7, #0]
 800a122:	4b55      	ldr	r3, [pc, #340]	; (800a278 <OsQueueBufferOperate+0x164>)
 800a124:	681b      	ldr	r3, [r3, #0]
 800a126:	61fb      	str	r3, [r7, #28]
 800a128:	f04f 0300 	mov.w	r3, #0
    UINT8 *queueNode = NULL;
 800a12c:	2300      	movs	r3, #0
 800a12e:	61bb      	str	r3, [r7, #24]
    UINT32 msgDataSize;
    UINT16 queuePosition;

    /* get the queue position */
    switch (OS_QUEUE_OPERATE_GET(operateType)) {
 800a130:	68bb      	ldr	r3, [r7, #8]
 800a132:	f003 0303 	and.w	r3, r3, #3
 800a136:	2b03      	cmp	r3, #3
 800a138:	d030      	beq.n	800a19c <OsQueueBufferOperate+0x88>
 800a13a:	2b03      	cmp	r3, #3
 800a13c:	d843      	bhi.n	800a1c6 <OsQueueBufferOperate+0xb2>
 800a13e:	2b00      	cmp	r3, #0
 800a140:	d002      	beq.n	800a148 <OsQueueBufferOperate+0x34>
 800a142:	2b01      	cmp	r3, #1
 800a144:	d015      	beq.n	800a172 <OsQueueBufferOperate+0x5e>
 800a146:	e03e      	b.n	800a1c6 <OsQueueBufferOperate+0xb2>
        case OS_QUEUE_READ_HEAD:
            queuePosition = queueCB->queueHead;
 800a148:	68fb      	ldr	r3, [r7, #12]
 800a14a:	8a1b      	ldrh	r3, [r3, #16]
 800a14c:	827b      	strh	r3, [r7, #18]
            ((queueCB->queueHead + 1) == queueCB->queueLen) ? (queueCB->queueHead = 0) : (queueCB->queueHead++);
 800a14e:	68fb      	ldr	r3, [r7, #12]
 800a150:	8a1b      	ldrh	r3, [r3, #16]
 800a152:	3301      	adds	r3, #1
 800a154:	68fa      	ldr	r2, [r7, #12]
 800a156:	88d2      	ldrh	r2, [r2, #6]
 800a158:	4293      	cmp	r3, r2
 800a15a:	d103      	bne.n	800a164 <OsQueueBufferOperate+0x50>
 800a15c:	68fb      	ldr	r3, [r7, #12]
 800a15e:	2200      	movs	r2, #0
 800a160:	821a      	strh	r2, [r3, #16]
            break;
 800a162:	e032      	b.n	800a1ca <OsQueueBufferOperate+0xb6>
            ((queueCB->queueHead + 1) == queueCB->queueLen) ? (queueCB->queueHead = 0) : (queueCB->queueHead++);
 800a164:	68fb      	ldr	r3, [r7, #12]
 800a166:	8a1b      	ldrh	r3, [r3, #16]
 800a168:	3301      	adds	r3, #1
 800a16a:	b29a      	uxth	r2, r3
 800a16c:	68fb      	ldr	r3, [r7, #12]
 800a16e:	821a      	strh	r2, [r3, #16]
            break;
 800a170:	e02b      	b.n	800a1ca <OsQueueBufferOperate+0xb6>
        case OS_QUEUE_WRITE_HEAD:
            (queueCB->queueHead == 0) ? (queueCB->queueHead = queueCB->queueLen - 1) : (--queueCB->queueHead);
 800a172:	68fb      	ldr	r3, [r7, #12]
 800a174:	8a1b      	ldrh	r3, [r3, #16]
 800a176:	2b00      	cmp	r3, #0
 800a178:	d106      	bne.n	800a188 <OsQueueBufferOperate+0x74>
 800a17a:	68fb      	ldr	r3, [r7, #12]
 800a17c:	88db      	ldrh	r3, [r3, #6]
 800a17e:	3b01      	subs	r3, #1
 800a180:	b29a      	uxth	r2, r3
 800a182:	68fb      	ldr	r3, [r7, #12]
 800a184:	821a      	strh	r2, [r3, #16]
 800a186:	e005      	b.n	800a194 <OsQueueBufferOperate+0x80>
 800a188:	68fb      	ldr	r3, [r7, #12]
 800a18a:	8a1b      	ldrh	r3, [r3, #16]
 800a18c:	3b01      	subs	r3, #1
 800a18e:	b29a      	uxth	r2, r3
 800a190:	68fb      	ldr	r3, [r7, #12]
 800a192:	821a      	strh	r2, [r3, #16]
            queuePosition = queueCB->queueHead;
 800a194:	68fb      	ldr	r3, [r7, #12]
 800a196:	8a1b      	ldrh	r3, [r3, #16]
 800a198:	827b      	strh	r3, [r7, #18]
            break;
 800a19a:	e016      	b.n	800a1ca <OsQueueBufferOperate+0xb6>
        case OS_QUEUE_WRITE_TAIL:
            queuePosition = queueCB->queueTail;
 800a19c:	68fb      	ldr	r3, [r7, #12]
 800a19e:	8a5b      	ldrh	r3, [r3, #18]
 800a1a0:	827b      	strh	r3, [r7, #18]
            ((queueCB->queueTail + 1) == queueCB->queueLen) ? (queueCB->queueTail = 0) : (queueCB->queueTail++);
 800a1a2:	68fb      	ldr	r3, [r7, #12]
 800a1a4:	8a5b      	ldrh	r3, [r3, #18]
 800a1a6:	3301      	adds	r3, #1
 800a1a8:	68fa      	ldr	r2, [r7, #12]
 800a1aa:	88d2      	ldrh	r2, [r2, #6]
 800a1ac:	4293      	cmp	r3, r2
 800a1ae:	d103      	bne.n	800a1b8 <OsQueueBufferOperate+0xa4>
 800a1b0:	68fb      	ldr	r3, [r7, #12]
 800a1b2:	2200      	movs	r2, #0
 800a1b4:	825a      	strh	r2, [r3, #18]
            break;
 800a1b6:	e008      	b.n	800a1ca <OsQueueBufferOperate+0xb6>
            ((queueCB->queueTail + 1) == queueCB->queueLen) ? (queueCB->queueTail = 0) : (queueCB->queueTail++);
 800a1b8:	68fb      	ldr	r3, [r7, #12]
 800a1ba:	8a5b      	ldrh	r3, [r3, #18]
 800a1bc:	3301      	adds	r3, #1
 800a1be:	b29a      	uxth	r2, r3
 800a1c0:	68fb      	ldr	r3, [r7, #12]
 800a1c2:	825a      	strh	r2, [r3, #18]
            break;
 800a1c4:	e001      	b.n	800a1ca <OsQueueBufferOperate+0xb6>
        default:  /* read tail, reserved. */
            return OS_QUEUE_OPERATE_ERROR_INVALID_TYPE;
 800a1c6:	2301      	movs	r3, #1
 800a1c8:	e04b      	b.n	800a262 <OsQueueBufferOperate+0x14e>
    }

    queueNode = &(queueCB->queueHandle[(queuePosition * (queueCB->queueSize))]);
 800a1ca:	68fb      	ldr	r3, [r7, #12]
 800a1cc:	681b      	ldr	r3, [r3, #0]
 800a1ce:	8a7a      	ldrh	r2, [r7, #18]
 800a1d0:	68f9      	ldr	r1, [r7, #12]
 800a1d2:	8909      	ldrh	r1, [r1, #8]
 800a1d4:	fb01 f202 	mul.w	r2, r1, r2
 800a1d8:	4413      	add	r3, r2
 800a1da:	61bb      	str	r3, [r7, #24]

    if (OS_QUEUE_IS_READ(operateType)) {
 800a1dc:	68bb      	ldr	r3, [r7, #8]
 800a1de:	f003 0301 	and.w	r3, r3, #1
 800a1e2:	2b00      	cmp	r3, #0
 800a1e4:	d11f      	bne.n	800a226 <OsQueueBufferOperate+0x112>
        if (memcpy_s(&msgDataSize, sizeof(UINT32), queueNode + queueCB->queueSize - sizeof(UINT32),
 800a1e6:	68fb      	ldr	r3, [r7, #12]
 800a1e8:	891b      	ldrh	r3, [r3, #8]
 800a1ea:	3b04      	subs	r3, #4
 800a1ec:	69ba      	ldr	r2, [r7, #24]
 800a1ee:	441a      	add	r2, r3
 800a1f0:	f107 0014 	add.w	r0, r7, #20
 800a1f4:	2304      	movs	r3, #4
 800a1f6:	2104      	movs	r1, #4
 800a1f8:	f00c f9d0 	bl	801659c <memcpy_s>
 800a1fc:	4603      	mov	r3, r0
 800a1fe:	2b00      	cmp	r3, #0
 800a200:	d001      	beq.n	800a206 <OsQueueBufferOperate+0xf2>
                     sizeof(UINT32)) != EOK) {
            return OS_QUEUE_OPERATE_ERROR_MEMCPYS_GETMSG;
 800a202:	2302      	movs	r3, #2
 800a204:	e02d      	b.n	800a262 <OsQueueBufferOperate+0x14e>
        }
        if (memcpy_s(bufferAddr, *bufferSize, queueNode, msgDataSize) != EOK) {
 800a206:	683b      	ldr	r3, [r7, #0]
 800a208:	6819      	ldr	r1, [r3, #0]
 800a20a:	697b      	ldr	r3, [r7, #20]
 800a20c:	69ba      	ldr	r2, [r7, #24]
 800a20e:	6878      	ldr	r0, [r7, #4]
 800a210:	f00c f9c4 	bl	801659c <memcpy_s>
 800a214:	4603      	mov	r3, r0
 800a216:	2b00      	cmp	r3, #0
 800a218:	d001      	beq.n	800a21e <OsQueueBufferOperate+0x10a>
            return OS_QUEUE_OPERATE_ERROR_MEMCPYS_MSG2BUF;
 800a21a:	2303      	movs	r3, #3
 800a21c:	e021      	b.n	800a262 <OsQueueBufferOperate+0x14e>
        }

        *bufferSize = msgDataSize;
 800a21e:	697a      	ldr	r2, [r7, #20]
 800a220:	683b      	ldr	r3, [r7, #0]
 800a222:	601a      	str	r2, [r3, #0]
 800a224:	e01c      	b.n	800a260 <OsQueueBufferOperate+0x14c>
    } else {
        if (memcpy_s(queueNode, queueCB->queueSize, bufferAddr, *bufferSize) != EOK) {
 800a226:	68fb      	ldr	r3, [r7, #12]
 800a228:	891b      	ldrh	r3, [r3, #8]
 800a22a:	4619      	mov	r1, r3
 800a22c:	683b      	ldr	r3, [r7, #0]
 800a22e:	681b      	ldr	r3, [r3, #0]
 800a230:	687a      	ldr	r2, [r7, #4]
 800a232:	69b8      	ldr	r0, [r7, #24]
 800a234:	f00c f9b2 	bl	801659c <memcpy_s>
 800a238:	4603      	mov	r3, r0
 800a23a:	2b00      	cmp	r3, #0
 800a23c:	d001      	beq.n	800a242 <OsQueueBufferOperate+0x12e>
            return OS_QUEUE_OPERATE_ERROR_MEMCPYS_STRMSG;
 800a23e:	2304      	movs	r3, #4
 800a240:	e00f      	b.n	800a262 <OsQueueBufferOperate+0x14e>
        }
        if (memcpy_s(queueNode + queueCB->queueSize - sizeof(UINT32), sizeof(UINT32), bufferSize,
 800a242:	68fb      	ldr	r3, [r7, #12]
 800a244:	891b      	ldrh	r3, [r3, #8]
 800a246:	3b04      	subs	r3, #4
 800a248:	69ba      	ldr	r2, [r7, #24]
 800a24a:	18d0      	adds	r0, r2, r3
 800a24c:	2304      	movs	r3, #4
 800a24e:	683a      	ldr	r2, [r7, #0]
 800a250:	2104      	movs	r1, #4
 800a252:	f00c f9a3 	bl	801659c <memcpy_s>
 800a256:	4603      	mov	r3, r0
 800a258:	2b00      	cmp	r3, #0
 800a25a:	d001      	beq.n	800a260 <OsQueueBufferOperate+0x14c>
                     sizeof(UINT32)) != EOK) {
            return OS_QUEUE_OPERATE_ERROR_MEMCPYS_STRMSGSIZE;
 800a25c:	2305      	movs	r3, #5
 800a25e:	e000      	b.n	800a262 <OsQueueBufferOperate+0x14e>
        }
    }
    return LOS_OK;
 800a260:	2300      	movs	r3, #0
}
 800a262:	4a05      	ldr	r2, [pc, #20]	; (800a278 <OsQueueBufferOperate+0x164>)
 800a264:	6811      	ldr	r1, [r2, #0]
 800a266:	69fa      	ldr	r2, [r7, #28]
 800a268:	4051      	eors	r1, r2
 800a26a:	d001      	beq.n	800a270 <OsQueueBufferOperate+0x15c>
 800a26c:	f7fa f8bc 	bl	80043e8 <__stack_chk_fail>
 800a270:	4618      	mov	r0, r3
 800a272:	3720      	adds	r7, #32
 800a274:	46bd      	mov	sp, r7
 800a276:	bd80      	pop	{r7, pc}
 800a278:	0802146c 	.word	0x0802146c

0800a27c <OsQueueBufferOperateErrProcess>:

STATIC VOID OsQueueBufferOperateErrProcess(UINT32 errorCode)
{
 800a27c:	b580      	push	{r7, lr}
 800a27e:	b082      	sub	sp, #8
 800a280:	af00      	add	r7, sp, #0
 800a282:	6078      	str	r0, [r7, #4]
 800a284:	687b      	ldr	r3, [r7, #4]
 800a286:	2b05      	cmp	r3, #5
 800a288:	d831      	bhi.n	800a2ee <OsQueueBufferOperateErrProcess+0x72>
 800a28a:	a201      	add	r2, pc, #4	; (adr r2, 800a290 <OsQueueBufferOperateErrProcess+0x14>)
 800a28c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a290:	0800a2ff 	.word	0x0800a2ff
 800a294:	0800a2a9 	.word	0x0800a2a9
 800a298:	0800a2b7 	.word	0x0800a2b7
 800a29c:	0800a2c5 	.word	0x0800a2c5
 800a2a0:	0800a2d3 	.word	0x0800a2d3
 800a2a4:	0800a2e1 	.word	0x0800a2e1
    switch (errorCode) {
        case LOS_OK: break;
        case OS_QUEUE_OPERATE_ERROR_INVALID_TYPE:
            PRINT_ERR("invalid queue operate type!\n");
 800a2a8:	4817      	ldr	r0, [pc, #92]	; (800a308 <OsQueueBufferOperateErrProcess+0x8c>)
 800a2aa:	f7fa fa0f 	bl	80046cc <dprintf>
 800a2ae:	4817      	ldr	r0, [pc, #92]	; (800a30c <OsQueueBufferOperateErrProcess+0x90>)
 800a2b0:	f7fa fa0c 	bl	80046cc <dprintf>
            break;
 800a2b4:	e024      	b.n	800a300 <OsQueueBufferOperateErrProcess+0x84>
        case OS_QUEUE_OPERATE_ERROR_MEMCPYS_GETMSG:
            PRINT_ERR("get msgdatasize failed\n");
 800a2b6:	4814      	ldr	r0, [pc, #80]	; (800a308 <OsQueueBufferOperateErrProcess+0x8c>)
 800a2b8:	f7fa fa08 	bl	80046cc <dprintf>
 800a2bc:	4814      	ldr	r0, [pc, #80]	; (800a310 <OsQueueBufferOperateErrProcess+0x94>)
 800a2be:	f7fa fa05 	bl	80046cc <dprintf>
            break;
 800a2c2:	e01d      	b.n	800a300 <OsQueueBufferOperateErrProcess+0x84>
        case OS_QUEUE_OPERATE_ERROR_MEMCPYS_MSG2BUF:
            PRINT_ERR("copy message to buffer failed\n");
 800a2c4:	4810      	ldr	r0, [pc, #64]	; (800a308 <OsQueueBufferOperateErrProcess+0x8c>)
 800a2c6:	f7fa fa01 	bl	80046cc <dprintf>
 800a2ca:	4812      	ldr	r0, [pc, #72]	; (800a314 <OsQueueBufferOperateErrProcess+0x98>)
 800a2cc:	f7fa f9fe 	bl	80046cc <dprintf>
            break;
 800a2d0:	e016      	b.n	800a300 <OsQueueBufferOperateErrProcess+0x84>
        case OS_QUEUE_OPERATE_ERROR_MEMCPYS_STRMSG:
            PRINT_ERR("store message failed\n");
 800a2d2:	480d      	ldr	r0, [pc, #52]	; (800a308 <OsQueueBufferOperateErrProcess+0x8c>)
 800a2d4:	f7fa f9fa 	bl	80046cc <dprintf>
 800a2d8:	480f      	ldr	r0, [pc, #60]	; (800a318 <OsQueueBufferOperateErrProcess+0x9c>)
 800a2da:	f7fa f9f7 	bl	80046cc <dprintf>
            break;
 800a2de:	e00f      	b.n	800a300 <OsQueueBufferOperateErrProcess+0x84>
        case OS_QUEUE_OPERATE_ERROR_MEMCPYS_STRMSGSIZE:
            PRINT_ERR("store message size failed\n");
 800a2e0:	4809      	ldr	r0, [pc, #36]	; (800a308 <OsQueueBufferOperateErrProcess+0x8c>)
 800a2e2:	f7fa f9f3 	bl	80046cc <dprintf>
 800a2e6:	480d      	ldr	r0, [pc, #52]	; (800a31c <OsQueueBufferOperateErrProcess+0xa0>)
 800a2e8:	f7fa f9f0 	bl	80046cc <dprintf>
            break;
 800a2ec:	e008      	b.n	800a300 <OsQueueBufferOperateErrProcess+0x84>
        default:
            PRINT_ERR("unknown queue operate ret %u\n", errorCode);
 800a2ee:	4806      	ldr	r0, [pc, #24]	; (800a308 <OsQueueBufferOperateErrProcess+0x8c>)
 800a2f0:	f7fa f9ec 	bl	80046cc <dprintf>
 800a2f4:	6879      	ldr	r1, [r7, #4]
 800a2f6:	480a      	ldr	r0, [pc, #40]	; (800a320 <OsQueueBufferOperateErrProcess+0xa4>)
 800a2f8:	f7fa f9e8 	bl	80046cc <dprintf>
            break;
 800a2fc:	e000      	b.n	800a300 <OsQueueBufferOperateErrProcess+0x84>
        case LOS_OK: break;
 800a2fe:	bf00      	nop
    }
}
 800a300:	bf00      	nop
 800a302:	3708      	adds	r7, #8
 800a304:	46bd      	mov	sp, r7
 800a306:	bd80      	pop	{r7, pc}
 800a308:	08021470 	.word	0x08021470
 800a30c:	08021478 	.word	0x08021478
 800a310:	08021498 	.word	0x08021498
 800a314:	080214b0 	.word	0x080214b0
 800a318:	080214d0 	.word	0x080214d0
 800a31c:	080214e8 	.word	0x080214e8
 800a320:	08021504 	.word	0x08021504

0800a324 <OsQueueOperateParamCheck>:

STATIC UINT32 OsQueueOperateParamCheck(const LosQueueCB *queueCB, UINT32 queueId,
                                       UINT32 operateType, const UINT32 *bufferSize)
{
 800a324:	b480      	push	{r7}
 800a326:	b085      	sub	sp, #20
 800a328:	af00      	add	r7, sp, #0
 800a32a:	60f8      	str	r0, [r7, #12]
 800a32c:	60b9      	str	r1, [r7, #8]
 800a32e:	607a      	str	r2, [r7, #4]
 800a330:	603b      	str	r3, [r7, #0]
    if ((queueCB->queueId != queueId) || (queueCB->queueState == LOS_UNUSED)) {
 800a332:	68fb      	ldr	r3, [r7, #12]
 800a334:	68db      	ldr	r3, [r3, #12]
 800a336:	68ba      	ldr	r2, [r7, #8]
 800a338:	429a      	cmp	r2, r3
 800a33a:	d103      	bne.n	800a344 <OsQueueOperateParamCheck+0x20>
 800a33c:	68fb      	ldr	r3, [r7, #12]
 800a33e:	791b      	ldrb	r3, [r3, #4]
 800a340:	2b00      	cmp	r3, #0
 800a342:	d101      	bne.n	800a348 <OsQueueOperateParamCheck+0x24>
        return LOS_ERRNO_QUEUE_NOT_CREATE;
 800a344:	4b12      	ldr	r3, [pc, #72]	; (800a390 <OsQueueOperateParamCheck+0x6c>)
 800a346:	e01c      	b.n	800a382 <OsQueueOperateParamCheck+0x5e>
    }

    if (OS_QUEUE_IS_READ(operateType) && (*bufferSize < (queueCB->queueSize - sizeof(UINT32)))) {
 800a348:	687b      	ldr	r3, [r7, #4]
 800a34a:	f003 0301 	and.w	r3, r3, #1
 800a34e:	2b00      	cmp	r3, #0
 800a350:	d108      	bne.n	800a364 <OsQueueOperateParamCheck+0x40>
 800a352:	683b      	ldr	r3, [r7, #0]
 800a354:	681a      	ldr	r2, [r3, #0]
 800a356:	68fb      	ldr	r3, [r7, #12]
 800a358:	891b      	ldrh	r3, [r3, #8]
 800a35a:	3b04      	subs	r3, #4
 800a35c:	429a      	cmp	r2, r3
 800a35e:	d201      	bcs.n	800a364 <OsQueueOperateParamCheck+0x40>
        return LOS_ERRNO_QUEUE_READ_SIZE_TOO_SMALL;
 800a360:	4b0c      	ldr	r3, [pc, #48]	; (800a394 <OsQueueOperateParamCheck+0x70>)
 800a362:	e00e      	b.n	800a382 <OsQueueOperateParamCheck+0x5e>
    } else if (OS_QUEUE_IS_WRITE(operateType) && (*bufferSize > (queueCB->queueSize - sizeof(UINT32)))) {
 800a364:	687b      	ldr	r3, [r7, #4]
 800a366:	f003 0301 	and.w	r3, r3, #1
 800a36a:	2b00      	cmp	r3, #0
 800a36c:	d008      	beq.n	800a380 <OsQueueOperateParamCheck+0x5c>
 800a36e:	683b      	ldr	r3, [r7, #0]
 800a370:	681a      	ldr	r2, [r3, #0]
 800a372:	68fb      	ldr	r3, [r7, #12]
 800a374:	891b      	ldrh	r3, [r3, #8]
 800a376:	3b04      	subs	r3, #4
 800a378:	429a      	cmp	r2, r3
 800a37a:	d901      	bls.n	800a380 <OsQueueOperateParamCheck+0x5c>
        return LOS_ERRNO_QUEUE_WRITE_SIZE_TOO_BIG;
 800a37c:	4b06      	ldr	r3, [pc, #24]	; (800a398 <OsQueueOperateParamCheck+0x74>)
 800a37e:	e000      	b.n	800a382 <OsQueueOperateParamCheck+0x5e>
    }
    return LOS_OK;
 800a380:	2300      	movs	r3, #0
}
 800a382:	4618      	mov	r0, r3
 800a384:	3714      	adds	r7, #20
 800a386:	46bd      	mov	sp, r7
 800a388:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a38c:	4770      	bx	lr
 800a38e:	bf00      	nop
 800a390:	0200060a 	.word	0x0200060a
 800a394:	0200061f 	.word	0x0200061f
 800a398:	02000615 	.word	0x02000615

0800a39c <OsQueueOperate>:

STATIC UINT32 OsQueueOperate(UINT32 queueId, UINT32 operateType, VOID *bufferAddr, UINT32 *bufferSize, UINT32 timeout)
{
 800a39c:	b590      	push	{r4, r7, lr}
 800a39e:	b095      	sub	sp, #84	; 0x54
 800a3a0:	af00      	add	r7, sp, #0
 800a3a2:	60f8      	str	r0, [r7, #12]
 800a3a4:	60b9      	str	r1, [r7, #8]
 800a3a6:	607a      	str	r2, [r7, #4]
 800a3a8:	603b      	str	r3, [r7, #0]
 800a3aa:	4b87      	ldr	r3, [pc, #540]	; (800a5c8 <OsQueueOperate+0x22c>)
 800a3ac:	681b      	ldr	r3, [r3, #0]
 800a3ae:	64fb      	str	r3, [r7, #76]	; 0x4c
 800a3b0:	f04f 0300 	mov.w	r3, #0
    LosQueueCB *queueCB = (LosQueueCB *)GET_QUEUE_HANDLE(queueId);
 800a3b4:	4b85      	ldr	r3, [pc, #532]	; (800a5cc <OsQueueOperate+0x230>)
 800a3b6:	6819      	ldr	r1, [r3, #0]
 800a3b8:	68fb      	ldr	r3, [r7, #12]
 800a3ba:	b29a      	uxth	r2, r3
 800a3bc:	4613      	mov	r3, r2
 800a3be:	005b      	lsls	r3, r3, #1
 800a3c0:	4413      	add	r3, r2
 800a3c2:	011b      	lsls	r3, r3, #4
 800a3c4:	440b      	add	r3, r1
 800a3c6:	61fb      	str	r3, [r7, #28]
    UINT32 readWrite = OS_QUEUE_READ_WRITE_GET(operateType);
 800a3c8:	68bb      	ldr	r3, [r7, #8]
 800a3ca:	f003 0301 	and.w	r3, r3, #1
 800a3ce:	623b      	str	r3, [r7, #32]
    UINT32 errorCode = LOS_OK;
 800a3d0:	2300      	movs	r3, #0
 800a3d2:	617b      	str	r3, [r7, #20]
    UINT32 intSave, ret;

    LOS_TRACE(QUEUE_RW, queueId, queueCB->queueSize, *bufferSize, operateType,
 800a3d4:	2300      	movs	r3, #0
 800a3d6:	62fb      	str	r3, [r7, #44]	; 0x2c
 800a3d8:	68fb      	ldr	r3, [r7, #12]
 800a3da:	633b      	str	r3, [r7, #48]	; 0x30
 800a3dc:	69fb      	ldr	r3, [r7, #28]
 800a3de:	891b      	ldrh	r3, [r3, #8]
 800a3e0:	637b      	str	r3, [r7, #52]	; 0x34
 800a3e2:	683b      	ldr	r3, [r7, #0]
 800a3e4:	681b      	ldr	r3, [r3, #0]
 800a3e6:	63bb      	str	r3, [r7, #56]	; 0x38
 800a3e8:	68bb      	ldr	r3, [r7, #8]
 800a3ea:	63fb      	str	r3, [r7, #60]	; 0x3c
 800a3ec:	69fb      	ldr	r3, [r7, #28]
 800a3ee:	8a9b      	ldrh	r3, [r3, #20]
 800a3f0:	643b      	str	r3, [r7, #64]	; 0x40
 800a3f2:	69fb      	ldr	r3, [r7, #28]
 800a3f4:	8adb      	ldrh	r3, [r3, #22]
 800a3f6:	647b      	str	r3, [r7, #68]	; 0x44
 800a3f8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800a3fa:	64bb      	str	r3, [r7, #72]	; 0x48
 800a3fc:	2308      	movs	r3, #8
 800a3fe:	627b      	str	r3, [r7, #36]	; 0x24
 800a400:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a402:	2b01      	cmp	r3, #1
 800a404:	d916      	bls.n	800a434 <OsQueueOperate+0x98>
 800a406:	4b72      	ldr	r3, [pc, #456]	; (800a5d0 <OsQueueOperate+0x234>)
 800a408:	681b      	ldr	r3, [r3, #0]
 800a40a:	2b00      	cmp	r3, #0
 800a40c:	d012      	beq.n	800a434 <OsQueueOperate+0x98>
 800a40e:	4b70      	ldr	r3, [pc, #448]	; (800a5d0 <OsQueueOperate+0x234>)
 800a410:	681c      	ldr	r4, [r3, #0]
 800a412:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800a414:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a416:	2b02      	cmp	r3, #2
 800a418:	d904      	bls.n	800a424 <OsQueueOperate+0x88>
 800a41a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800a41e:	f103 0208 	add.w	r2, r3, #8
 800a422:	e000      	b.n	800a426 <OsQueueOperate+0x8a>
 800a424:	2200      	movs	r2, #0
 800a426:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a428:	b29b      	uxth	r3, r3
 800a42a:	3b02      	subs	r3, #2
 800a42c:	b29b      	uxth	r3, r3
 800a42e:	f240 2002 	movw	r0, #514	; 0x202
 800a432:	47a0      	blx	r4
        queueCB->readWriteableCnt[OS_QUEUE_READ], queueCB->readWriteableCnt[OS_QUEUE_WRITE], timeout);

    SCHEDULER_LOCK(intSave);
 800a434:	f107 0310 	add.w	r3, r7, #16
 800a438:	4619      	mov	r1, r3
 800a43a:	4866      	ldr	r0, [pc, #408]	; (800a5d4 <OsQueueOperate+0x238>)
 800a43c:	f7ff fc3c 	bl	8009cb8 <LOS_SpinLockSave>
    ret = OsQueueOperateParamCheck(queueCB, queueId, operateType, bufferSize);
 800a440:	683b      	ldr	r3, [r7, #0]
 800a442:	68ba      	ldr	r2, [r7, #8]
 800a444:	68f9      	ldr	r1, [r7, #12]
 800a446:	69f8      	ldr	r0, [r7, #28]
 800a448:	f7ff ff6c 	bl	800a324 <OsQueueOperateParamCheck>
 800a44c:	61b8      	str	r0, [r7, #24]
    if (ret != LOS_OK) {
 800a44e:	69bb      	ldr	r3, [r7, #24]
 800a450:	2b00      	cmp	r3, #0
 800a452:	f040 80a4 	bne.w	800a59e <OsQueueOperate+0x202>
        goto QUEUE_END;
    }

    if (queueCB->readWriteableCnt[readWrite] == 0) {
 800a456:	69fa      	ldr	r2, [r7, #28]
 800a458:	6a3b      	ldr	r3, [r7, #32]
 800a45a:	3308      	adds	r3, #8
 800a45c:	005b      	lsls	r3, r3, #1
 800a45e:	4413      	add	r3, r2
 800a460:	889b      	ldrh	r3, [r3, #4]
 800a462:	2b00      	cmp	r3, #0
 800a464:	d13e      	bne.n	800a4e4 <OsQueueOperate+0x148>
        if (timeout == LOS_NO_WAIT) {
 800a466:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800a468:	2b00      	cmp	r3, #0
 800a46a:	d109      	bne.n	800a480 <OsQueueOperate+0xe4>
            ret = OS_QUEUE_IS_READ(operateType) ? LOS_ERRNO_QUEUE_ISEMPTY : LOS_ERRNO_QUEUE_ISFULL;
 800a46c:	68bb      	ldr	r3, [r7, #8]
 800a46e:	f003 0301 	and.w	r3, r3, #1
 800a472:	2b00      	cmp	r3, #0
 800a474:	d101      	bne.n	800a47a <OsQueueOperate+0xde>
 800a476:	4b58      	ldr	r3, [pc, #352]	; (800a5d8 <OsQueueOperate+0x23c>)
 800a478:	e000      	b.n	800a47c <OsQueueOperate+0xe0>
 800a47a:	4b58      	ldr	r3, [pc, #352]	; (800a5dc <OsQueueOperate+0x240>)
 800a47c:	61bb      	str	r3, [r7, #24]
            goto QUEUE_END;
 800a47e:	e08f      	b.n	800a5a0 <OsQueueOperate+0x204>
        }

        if (!OsPreemptableInSched()) {
 800a480:	f7ff fbee 	bl	8009c60 <OsPreemptableInSched>
 800a484:	4603      	mov	r3, r0
 800a486:	2b00      	cmp	r3, #0
 800a488:	d102      	bne.n	800a490 <OsQueueOperate+0xf4>
            ret = LOS_ERRNO_QUEUE_PEND_IN_LOCK;
 800a48a:	4b55      	ldr	r3, [pc, #340]	; (800a5e0 <OsQueueOperate+0x244>)
 800a48c:	61bb      	str	r3, [r7, #24]
            goto QUEUE_END;
 800a48e:	e087      	b.n	800a5a0 <OsQueueOperate+0x204>
        }

        OsTaskWait(&queueCB->readWriteList[readWrite], OS_TASK_STATUS_PEND, timeout);
 800a490:	6a3b      	ldr	r3, [r7, #32]
 800a492:	3303      	adds	r3, #3
 800a494:	00db      	lsls	r3, r3, #3
 800a496:	69fa      	ldr	r2, [r7, #28]
 800a498:	4413      	add	r3, r2
 800a49a:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800a49c:	2108      	movs	r1, #8
 800a49e:	4618      	mov	r0, r3
 800a4a0:	f7f9 fc64 	bl	8003d6c <OsTaskWait>

        OsSchedResched();
 800a4a4:	f7fd fe52 	bl	800814c <OsSchedResched>
        SCHEDULER_UNLOCK(intSave);
 800a4a8:	693b      	ldr	r3, [r7, #16]
 800a4aa:	4619      	mov	r1, r3
 800a4ac:	4849      	ldr	r0, [pc, #292]	; (800a5d4 <OsQueueOperate+0x238>)
 800a4ae:	f7ff fc11 	bl	8009cd4 <LOS_SpinUnlockRestore>
        SCHEDULER_LOCK(intSave);
 800a4b2:	f107 0310 	add.w	r3, r7, #16
 800a4b6:	4619      	mov	r1, r3
 800a4b8:	4846      	ldr	r0, [pc, #280]	; (800a5d4 <OsQueueOperate+0x238>)
 800a4ba:	f7ff fbfd 	bl	8009cb8 <LOS_SpinLockSave>

        if (OsCurrTaskGet()->taskStatus & OS_TASK_STATUS_TIMEOUT) {
 800a4be:	f7ff fc15 	bl	8009cec <OsCurrTaskGet>
 800a4c2:	4603      	mov	r3, r0
 800a4c4:	889b      	ldrh	r3, [r3, #4]
 800a4c6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a4ca:	2b00      	cmp	r3, #0
 800a4cc:	d019      	beq.n	800a502 <OsQueueOperate+0x166>
            OsCurrTaskGet()->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
 800a4ce:	f7ff fc0d 	bl	8009cec <OsCurrTaskGet>
 800a4d2:	4603      	mov	r3, r0
 800a4d4:	889a      	ldrh	r2, [r3, #4]
 800a4d6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a4da:	b292      	uxth	r2, r2
 800a4dc:	809a      	strh	r2, [r3, #4]
            ret = LOS_ERRNO_QUEUE_TIMEOUT;
 800a4de:	4b41      	ldr	r3, [pc, #260]	; (800a5e4 <OsQueueOperate+0x248>)
 800a4e0:	61bb      	str	r3, [r7, #24]
            goto QUEUE_END;
 800a4e2:	e05d      	b.n	800a5a0 <OsQueueOperate+0x204>
        }
    } else {
        queueCB->readWriteableCnt[readWrite]--;
 800a4e4:	69fa      	ldr	r2, [r7, #28]
 800a4e6:	6a3b      	ldr	r3, [r7, #32]
 800a4e8:	3308      	adds	r3, #8
 800a4ea:	005b      	lsls	r3, r3, #1
 800a4ec:	4413      	add	r3, r2
 800a4ee:	889b      	ldrh	r3, [r3, #4]
 800a4f0:	3b01      	subs	r3, #1
 800a4f2:	b299      	uxth	r1, r3
 800a4f4:	69fa      	ldr	r2, [r7, #28]
 800a4f6:	6a3b      	ldr	r3, [r7, #32]
 800a4f8:	3308      	adds	r3, #8
 800a4fa:	005b      	lsls	r3, r3, #1
 800a4fc:	4413      	add	r3, r2
 800a4fe:	460a      	mov	r2, r1
 800a500:	809a      	strh	r2, [r3, #4]
    }

    /* It will cause double lock issue that print after SCHEDULER_LOCK,
     * so handle the return value errorCode after SCHEDULER_UNLOCK */
    errorCode = OsQueueBufferOperate(queueCB, operateType, bufferAddr, bufferSize);
 800a502:	683b      	ldr	r3, [r7, #0]
 800a504:	687a      	ldr	r2, [r7, #4]
 800a506:	68b9      	ldr	r1, [r7, #8]
 800a508:	69f8      	ldr	r0, [r7, #28]
 800a50a:	f7ff fe03 	bl	800a114 <OsQueueBufferOperate>
 800a50e:	6178      	str	r0, [r7, #20]

    if (!LOS_ListEmpty(&queueCB->readWriteList[!readWrite])) {
 800a510:	6a3b      	ldr	r3, [r7, #32]
 800a512:	2b00      	cmp	r3, #0
 800a514:	bf0c      	ite	eq
 800a516:	2301      	moveq	r3, #1
 800a518:	2300      	movne	r3, #0
 800a51a:	b2db      	uxtb	r3, r3
 800a51c:	3303      	adds	r3, #3
 800a51e:	00db      	lsls	r3, r3, #3
 800a520:	69fa      	ldr	r2, [r7, #28]
 800a522:	4413      	add	r3, r2
 800a524:	4618      	mov	r0, r3
 800a526:	f7ff fb53 	bl	8009bd0 <LOS_ListEmpty>
 800a52a:	4603      	mov	r3, r0
 800a52c:	2b00      	cmp	r3, #0
 800a52e:	d11f      	bne.n	800a570 <OsQueueOperate+0x1d4>
        LosTaskCB *resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&queueCB->readWriteList[!readWrite]));
 800a530:	6a3b      	ldr	r3, [r7, #32]
 800a532:	2b00      	cmp	r3, #0
 800a534:	bf0c      	ite	eq
 800a536:	2301      	moveq	r3, #1
 800a538:	2300      	movne	r3, #0
 800a53a:	b2db      	uxtb	r3, r3
 800a53c:	69fa      	ldr	r2, [r7, #28]
 800a53e:	3303      	adds	r3, #3
 800a540:	00db      	lsls	r3, r3, #3
 800a542:	4413      	add	r3, r2
 800a544:	685b      	ldr	r3, [r3, #4]
 800a546:	3b40      	subs	r3, #64	; 0x40
 800a548:	62bb      	str	r3, [r7, #40]	; 0x28
        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
 800a54a:	2108      	movs	r1, #8
 800a54c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800a54e:	f7f9 fc43 	bl	8003dd8 <OsTaskWake>
        SCHEDULER_UNLOCK(intSave);
 800a552:	693b      	ldr	r3, [r7, #16]
 800a554:	4619      	mov	r1, r3
 800a556:	481f      	ldr	r0, [pc, #124]	; (800a5d4 <OsQueueOperate+0x238>)
 800a558:	f7ff fbbc 	bl	8009cd4 <LOS_SpinUnlockRestore>
        OsQueueBufferOperateErrProcess(errorCode);
 800a55c:	6978      	ldr	r0, [r7, #20]
 800a55e:	f7ff fe8d 	bl	800a27c <OsQueueBufferOperateErrProcess>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 800a562:	2001      	movs	r0, #1
 800a564:	f7ff fbee 	bl	8009d44 <LOS_MpSchedule>
        LOS_Schedule();
 800a568:	f7ff fb96 	bl	8009c98 <LOS_Schedule>
        return LOS_OK;
 800a56c:	2300      	movs	r3, #0
 800a56e:	e020      	b.n	800a5b2 <OsQueueOperate+0x216>
    } else {
        queueCB->readWriteableCnt[!readWrite]++;
 800a570:	6a3b      	ldr	r3, [r7, #32]
 800a572:	2b00      	cmp	r3, #0
 800a574:	bf0c      	ite	eq
 800a576:	2301      	moveq	r3, #1
 800a578:	2300      	movne	r3, #0
 800a57a:	b2db      	uxtb	r3, r3
 800a57c:	461a      	mov	r2, r3
 800a57e:	69f9      	ldr	r1, [r7, #28]
 800a580:	f102 0308 	add.w	r3, r2, #8
 800a584:	005b      	lsls	r3, r3, #1
 800a586:	440b      	add	r3, r1
 800a588:	889b      	ldrh	r3, [r3, #4]
 800a58a:	3301      	adds	r3, #1
 800a58c:	b298      	uxth	r0, r3
 800a58e:	69f9      	ldr	r1, [r7, #28]
 800a590:	f102 0308 	add.w	r3, r2, #8
 800a594:	005b      	lsls	r3, r3, #1
 800a596:	440b      	add	r3, r1
 800a598:	4602      	mov	r2, r0
 800a59a:	809a      	strh	r2, [r3, #4]
 800a59c:	e000      	b.n	800a5a0 <OsQueueOperate+0x204>
        goto QUEUE_END;
 800a59e:	bf00      	nop
    }

QUEUE_END:
    SCHEDULER_UNLOCK(intSave);
 800a5a0:	693b      	ldr	r3, [r7, #16]
 800a5a2:	4619      	mov	r1, r3
 800a5a4:	480b      	ldr	r0, [pc, #44]	; (800a5d4 <OsQueueOperate+0x238>)
 800a5a6:	f7ff fb95 	bl	8009cd4 <LOS_SpinUnlockRestore>
    OsQueueBufferOperateErrProcess(errorCode);
 800a5aa:	6978      	ldr	r0, [r7, #20]
 800a5ac:	f7ff fe66 	bl	800a27c <OsQueueBufferOperateErrProcess>
    return ret;
 800a5b0:	69bb      	ldr	r3, [r7, #24]
}
 800a5b2:	4a05      	ldr	r2, [pc, #20]	; (800a5c8 <OsQueueOperate+0x22c>)
 800a5b4:	6811      	ldr	r1, [r2, #0]
 800a5b6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800a5b8:	4051      	eors	r1, r2
 800a5ba:	d001      	beq.n	800a5c0 <OsQueueOperate+0x224>
 800a5bc:	f7f9 ff14 	bl	80043e8 <__stack_chk_fail>
 800a5c0:	4618      	mov	r0, r3
 800a5c2:	3754      	adds	r7, #84	; 0x54
 800a5c4:	46bd      	mov	sp, r7
 800a5c6:	bd90      	pop	{r4, r7, pc}
 800a5c8:	08021524 	.word	0x08021524
 800a5cc:	200021bc 	.word	0x200021bc
 800a5d0:	2000075c 	.word	0x2000075c
 800a5d4:	20000764 	.word	0x20000764
 800a5d8:	0200061d 	.word	0x0200061d
 800a5dc:	02000616 	.word	0x02000616
 800a5e0:	02000606 	.word	0x02000606
 800a5e4:	02000607 	.word	0x02000607

0800a5e8 <LOS_QueueReadCopy>:

LITE_OS_SEC_TEXT UINT32 LOS_QueueReadCopy(UINT32 queueId,
                                          VOID *bufferAddr,
                                          UINT32 *bufferSize,
                                          UINT32 timeout)
{
 800a5e8:	b580      	push	{r7, lr}
 800a5ea:	b088      	sub	sp, #32
 800a5ec:	af02      	add	r7, sp, #8
 800a5ee:	60f8      	str	r0, [r7, #12]
 800a5f0:	60b9      	str	r1, [r7, #8]
 800a5f2:	607a      	str	r2, [r7, #4]
 800a5f4:	603b      	str	r3, [r7, #0]
    UINT32 ret;
    UINT32 operateType;

    ret = OsQueueReadParameterCheck(queueId, bufferAddr, bufferSize, timeout);
 800a5f6:	683b      	ldr	r3, [r7, #0]
 800a5f8:	687a      	ldr	r2, [r7, #4]
 800a5fa:	68b9      	ldr	r1, [r7, #8]
 800a5fc:	68f8      	ldr	r0, [r7, #12]
 800a5fe:	f7ff fd1b 	bl	800a038 <OsQueueReadParameterCheck>
 800a602:	6138      	str	r0, [r7, #16]
    if (ret != LOS_OK) {
 800a604:	693b      	ldr	r3, [r7, #16]
 800a606:	2b00      	cmp	r3, #0
 800a608:	d001      	beq.n	800a60e <LOS_QueueReadCopy+0x26>
        return ret;
 800a60a:	693b      	ldr	r3, [r7, #16]
 800a60c:	e00a      	b.n	800a624 <LOS_QueueReadCopy+0x3c>
    }

    operateType = OS_QUEUE_OPERATE_TYPE(OS_QUEUE_READ, OS_QUEUE_HEAD);
 800a60e:	2300      	movs	r3, #0
 800a610:	617b      	str	r3, [r7, #20]
    return OsQueueOperate(queueId, operateType, bufferAddr, bufferSize, timeout);
 800a612:	683b      	ldr	r3, [r7, #0]
 800a614:	9300      	str	r3, [sp, #0]
 800a616:	687b      	ldr	r3, [r7, #4]
 800a618:	68ba      	ldr	r2, [r7, #8]
 800a61a:	6979      	ldr	r1, [r7, #20]
 800a61c:	68f8      	ldr	r0, [r7, #12]
 800a61e:	f7ff febd 	bl	800a39c <OsQueueOperate>
 800a622:	4603      	mov	r3, r0
}
 800a624:	4618      	mov	r0, r3
 800a626:	3718      	adds	r7, #24
 800a628:	46bd      	mov	sp, r7
 800a62a:	bd80      	pop	{r7, pc}

0800a62c <LOS_QueueWriteCopy>:

LITE_OS_SEC_TEXT UINT32 LOS_QueueWriteCopy(UINT32 queueId,
                                           VOID *bufferAddr,
                                           UINT32 bufferSize,
                                           UINT32 timeout)
{
 800a62c:	b580      	push	{r7, lr}
 800a62e:	b088      	sub	sp, #32
 800a630:	af02      	add	r7, sp, #8
 800a632:	60f8      	str	r0, [r7, #12]
 800a634:	60b9      	str	r1, [r7, #8]
 800a636:	607a      	str	r2, [r7, #4]
 800a638:	603b      	str	r3, [r7, #0]
    UINT32 ret;
    UINT32 operateType;

    ret = OsQueueWriteParameterCheck(queueId, bufferAddr, &bufferSize, timeout);
 800a63a:	1d3a      	adds	r2, r7, #4
 800a63c:	683b      	ldr	r3, [r7, #0]
 800a63e:	68b9      	ldr	r1, [r7, #8]
 800a640:	68f8      	ldr	r0, [r7, #12]
 800a642:	f7ff fd35 	bl	800a0b0 <OsQueueWriteParameterCheck>
 800a646:	6138      	str	r0, [r7, #16]
    if (ret != LOS_OK) {
 800a648:	693b      	ldr	r3, [r7, #16]
 800a64a:	2b00      	cmp	r3, #0
 800a64c:	d001      	beq.n	800a652 <LOS_QueueWriteCopy+0x26>
        return ret;
 800a64e:	693b      	ldr	r3, [r7, #16]
 800a650:	e00b      	b.n	800a66a <LOS_QueueWriteCopy+0x3e>
    }

    operateType = OS_QUEUE_OPERATE_TYPE(OS_QUEUE_WRITE, OS_QUEUE_TAIL);
 800a652:	2303      	movs	r3, #3
 800a654:	617b      	str	r3, [r7, #20]
    return OsQueueOperate(queueId, operateType, bufferAddr, &bufferSize, timeout);
 800a656:	1d3a      	adds	r2, r7, #4
 800a658:	683b      	ldr	r3, [r7, #0]
 800a65a:	9300      	str	r3, [sp, #0]
 800a65c:	4613      	mov	r3, r2
 800a65e:	68ba      	ldr	r2, [r7, #8]
 800a660:	6979      	ldr	r1, [r7, #20]
 800a662:	68f8      	ldr	r0, [r7, #12]
 800a664:	f7ff fe9a 	bl	800a39c <OsQueueOperate>
 800a668:	4603      	mov	r3, r0
}
 800a66a:	4618      	mov	r0, r3
 800a66c:	3718      	adds	r7, #24
 800a66e:	46bd      	mov	sp, r7
 800a670:	bd80      	pop	{r7, pc}

0800a672 <LOS_ListInit>:
{
 800a672:	b480      	push	{r7}
 800a674:	b083      	sub	sp, #12
 800a676:	af00      	add	r7, sp, #0
 800a678:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 800a67a:	687b      	ldr	r3, [r7, #4]
 800a67c:	687a      	ldr	r2, [r7, #4]
 800a67e:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 800a680:	687b      	ldr	r3, [r7, #4]
 800a682:	687a      	ldr	r2, [r7, #4]
 800a684:	601a      	str	r2, [r3, #0]
}
 800a686:	bf00      	nop
 800a688:	370c      	adds	r7, #12
 800a68a:	46bd      	mov	sp, r7
 800a68c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a690:	4770      	bx	lr

0800a692 <LOS_ListAdd>:
{
 800a692:	b480      	push	{r7}
 800a694:	b083      	sub	sp, #12
 800a696:	af00      	add	r7, sp, #0
 800a698:	6078      	str	r0, [r7, #4]
 800a69a:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 800a69c:	687b      	ldr	r3, [r7, #4]
 800a69e:	685a      	ldr	r2, [r3, #4]
 800a6a0:	683b      	ldr	r3, [r7, #0]
 800a6a2:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 800a6a4:	683b      	ldr	r3, [r7, #0]
 800a6a6:	687a      	ldr	r2, [r7, #4]
 800a6a8:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 800a6aa:	687b      	ldr	r3, [r7, #4]
 800a6ac:	685b      	ldr	r3, [r3, #4]
 800a6ae:	683a      	ldr	r2, [r7, #0]
 800a6b0:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 800a6b2:	687b      	ldr	r3, [r7, #4]
 800a6b4:	683a      	ldr	r2, [r7, #0]
 800a6b6:	605a      	str	r2, [r3, #4]
}
 800a6b8:	bf00      	nop
 800a6ba:	370c      	adds	r7, #12
 800a6bc:	46bd      	mov	sp, r7
 800a6be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6c2:	4770      	bx	lr

0800a6c4 <LOS_ListTailInsert>:
{
 800a6c4:	b580      	push	{r7, lr}
 800a6c6:	b082      	sub	sp, #8
 800a6c8:	af00      	add	r7, sp, #0
 800a6ca:	6078      	str	r0, [r7, #4]
 800a6cc:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 800a6ce:	687b      	ldr	r3, [r7, #4]
 800a6d0:	681b      	ldr	r3, [r3, #0]
 800a6d2:	6839      	ldr	r1, [r7, #0]
 800a6d4:	4618      	mov	r0, r3
 800a6d6:	f7ff ffdc 	bl	800a692 <LOS_ListAdd>
}
 800a6da:	bf00      	nop
 800a6dc:	3708      	adds	r7, #8
 800a6de:	46bd      	mov	sp, r7
 800a6e0:	bd80      	pop	{r7, pc}

0800a6e2 <LOS_ListDelete>:
{
 800a6e2:	b480      	push	{r7}
 800a6e4:	b083      	sub	sp, #12
 800a6e6:	af00      	add	r7, sp, #0
 800a6e8:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 800a6ea:	687b      	ldr	r3, [r7, #4]
 800a6ec:	685b      	ldr	r3, [r3, #4]
 800a6ee:	687a      	ldr	r2, [r7, #4]
 800a6f0:	6812      	ldr	r2, [r2, #0]
 800a6f2:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 800a6f4:	687b      	ldr	r3, [r7, #4]
 800a6f6:	681b      	ldr	r3, [r3, #0]
 800a6f8:	687a      	ldr	r2, [r7, #4]
 800a6fa:	6852      	ldr	r2, [r2, #4]
 800a6fc:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 800a6fe:	687b      	ldr	r3, [r7, #4]
 800a700:	2200      	movs	r2, #0
 800a702:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 800a704:	687b      	ldr	r3, [r7, #4]
 800a706:	2200      	movs	r2, #0
 800a708:	601a      	str	r2, [r3, #0]
}
 800a70a:	bf00      	nop
 800a70c:	370c      	adds	r7, #12
 800a70e:	46bd      	mov	sp, r7
 800a710:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a714:	4770      	bx	lr

0800a716 <LOS_ListEmpty>:
{
 800a716:	b480      	push	{r7}
 800a718:	b083      	sub	sp, #12
 800a71a:	af00      	add	r7, sp, #0
 800a71c:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 800a71e:	687b      	ldr	r3, [r7, #4]
 800a720:	685b      	ldr	r3, [r3, #4]
 800a722:	687a      	ldr	r2, [r7, #4]
 800a724:	429a      	cmp	r2, r3
 800a726:	bf0c      	ite	eq
 800a728:	2301      	moveq	r3, #1
 800a72a:	2300      	movne	r3, #0
 800a72c:	b2db      	uxtb	r3, r3
}
 800a72e:	4618      	mov	r0, r3
 800a730:	370c      	adds	r7, #12
 800a732:	46bd      	mov	sp, r7
 800a734:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a738:	4770      	bx	lr

0800a73a <ArchCurrCpuid>:
{
 800a73a:	b480      	push	{r7}
 800a73c:	af00      	add	r7, sp, #0
    return 0;
 800a73e:	2300      	movs	r3, #0
}
 800a740:	4618      	mov	r0, r3
 800a742:	46bd      	mov	sp, r7
 800a744:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a748:	4770      	bx	lr

0800a74a <LOS_IntLock>:
{
 800a74a:	b580      	push	{r7, lr}
 800a74c:	af00      	add	r7, sp, #0
    return ArchIntLock();
 800a74e:	f7f6 fabb 	bl	8000cc8 <ArchIntLock>
 800a752:	4603      	mov	r3, r0
}
 800a754:	4618      	mov	r0, r3
 800a756:	bd80      	pop	{r7, pc}

0800a758 <LOS_IntRestore>:
{
 800a758:	b580      	push	{r7, lr}
 800a75a:	b082      	sub	sp, #8
 800a75c:	af00      	add	r7, sp, #0
 800a75e:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800a760:	6878      	ldr	r0, [r7, #4]
 800a762:	f7f6 fab9 	bl	8000cd8 <ArchIntRestore>
}
 800a766:	bf00      	nop
 800a768:	3708      	adds	r7, #8
 800a76a:	46bd      	mov	sp, r7
 800a76c:	bd80      	pop	{r7, pc}
	...

0800a770 <ArchCurrTaskGet>:
{
 800a770:	b480      	push	{r7}
 800a772:	af00      	add	r7, sp, #0
    return g_runTask;
 800a774:	4b03      	ldr	r3, [pc, #12]	; (800a784 <ArchCurrTaskGet+0x14>)
 800a776:	681b      	ldr	r3, [r3, #0]
}
 800a778:	4618      	mov	r0, r3
 800a77a:	46bd      	mov	sp, r7
 800a77c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a780:	4770      	bx	lr
 800a782:	bf00      	nop
 800a784:	200033bc 	.word	0x200033bc

0800a788 <OsPercpuGet>:
{
 800a788:	b580      	push	{r7, lr}
 800a78a:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 800a78c:	f7ff ffd5 	bl	800a73a <ArchCurrCpuid>
 800a790:	4602      	mov	r2, r0
 800a792:	4613      	mov	r3, r2
 800a794:	00db      	lsls	r3, r3, #3
 800a796:	4413      	add	r3, r2
 800a798:	009b      	lsls	r3, r3, #2
 800a79a:	4a02      	ldr	r2, [pc, #8]	; (800a7a4 <OsPercpuGet+0x1c>)
 800a79c:	4413      	add	r3, r2
}
 800a79e:	4618      	mov	r0, r3
 800a7a0:	bd80      	pop	{r7, pc}
 800a7a2:	bf00      	nop
 800a7a4:	200036fc 	.word	0x200036fc

0800a7a8 <OsPreemptableInSched>:
{
 800a7a8:	b580      	push	{r7, lr}
 800a7aa:	b082      	sub	sp, #8
 800a7ac:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 800a7ae:	2300      	movs	r3, #0
 800a7b0:	607b      	str	r3, [r7, #4]
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 800a7b2:	f7ff ffe9 	bl	800a788 <OsPercpuGet>
 800a7b6:	4603      	mov	r3, r0
 800a7b8:	695b      	ldr	r3, [r3, #20]
 800a7ba:	2b00      	cmp	r3, #0
 800a7bc:	bf0c      	ite	eq
 800a7be:	2301      	moveq	r3, #1
 800a7c0:	2300      	movne	r3, #0
 800a7c2:	b2db      	uxtb	r3, r3
 800a7c4:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 800a7c6:	687b      	ldr	r3, [r7, #4]
 800a7c8:	2b00      	cmp	r3, #0
 800a7ca:	d104      	bne.n	800a7d6 <OsPreemptableInSched+0x2e>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 800a7cc:	f7ff ffdc 	bl	800a788 <OsPercpuGet>
 800a7d0:	4603      	mov	r3, r0
 800a7d2:	2201      	movs	r2, #1
 800a7d4:	621a      	str	r2, [r3, #32]
    return preemptable;
 800a7d6:	687b      	ldr	r3, [r7, #4]
}
 800a7d8:	4618      	mov	r0, r3
 800a7da:	3708      	adds	r7, #8
 800a7dc:	46bd      	mov	sp, r7
 800a7de:	bd80      	pop	{r7, pc}

0800a7e0 <LOS_Schedule>:
{
 800a7e0:	b580      	push	{r7, lr}
 800a7e2:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 800a7e4:	f7f7 fe42 	bl	800246c <IntActive>
 800a7e8:	4603      	mov	r3, r0
 800a7ea:	2b00      	cmp	r3, #0
 800a7ec:	d005      	beq.n	800a7fa <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 800a7ee:	f7ff ffcb 	bl	800a788 <OsPercpuGet>
 800a7f2:	4603      	mov	r3, r0
 800a7f4:	2201      	movs	r2, #1
 800a7f6:	621a      	str	r2, [r3, #32]
        return;
 800a7f8:	e001      	b.n	800a7fe <LOS_Schedule+0x1e>
    OsSchedPreempt();
 800a7fa:	f7fd fd65 	bl	80082c8 <OsSchedPreempt>
}
 800a7fe:	bd80      	pop	{r7, pc}

0800a800 <LOS_SpinLockSave>:
{
 800a800:	b580      	push	{r7, lr}
 800a802:	b082      	sub	sp, #8
 800a804:	af00      	add	r7, sp, #0
 800a806:	6078      	str	r0, [r7, #4]
 800a808:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 800a80a:	f7ff ff9e 	bl	800a74a <LOS_IntLock>
 800a80e:	4602      	mov	r2, r0
 800a810:	683b      	ldr	r3, [r7, #0]
 800a812:	601a      	str	r2, [r3, #0]
}
 800a814:	bf00      	nop
 800a816:	3708      	adds	r7, #8
 800a818:	46bd      	mov	sp, r7
 800a81a:	bd80      	pop	{r7, pc}

0800a81c <LOS_SpinUnlockRestore>:
{
 800a81c:	b580      	push	{r7, lr}
 800a81e:	b082      	sub	sp, #8
 800a820:	af00      	add	r7, sp, #0
 800a822:	6078      	str	r0, [r7, #4]
 800a824:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 800a826:	6838      	ldr	r0, [r7, #0]
 800a828:	f7ff ff96 	bl	800a758 <LOS_IntRestore>
}
 800a82c:	bf00      	nop
 800a82e:	3708      	adds	r7, #8
 800a830:	46bd      	mov	sp, r7
 800a832:	bd80      	pop	{r7, pc}

0800a834 <OsCurrTaskGet>:
{
 800a834:	b580      	push	{r7, lr}
 800a836:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 800a838:	f7ff ff9a 	bl	800a770 <ArchCurrTaskGet>
 800a83c:	4603      	mov	r3, r0
}
 800a83e:	4618      	mov	r0, r3
 800a840:	bd80      	pop	{r7, pc}

0800a842 <OsMuxDlockNodeInsertHook>:
{
 800a842:	b580      	push	{r7, lr}
 800a844:	b082      	sub	sp, #8
 800a846:	af00      	add	r7, sp, #0
 800a848:	6078      	str	r0, [r7, #4]
 800a84a:	6039      	str	r1, [r7, #0]
    OsMuxDlockNodeInsert(taskId, muxCB);
 800a84c:	6839      	ldr	r1, [r7, #0]
 800a84e:	6878      	ldr	r0, [r7, #4]
 800a850:	f7fb fb46 	bl	8005ee0 <OsMuxDlockNodeInsert>
}
 800a854:	bf00      	nop
 800a856:	3708      	adds	r7, #8
 800a858:	46bd      	mov	sp, r7
 800a85a:	bd80      	pop	{r7, pc}

0800a85c <OsMuxDlockNodeDeleteHook>:
{
 800a85c:	b580      	push	{r7, lr}
 800a85e:	b082      	sub	sp, #8
 800a860:	af00      	add	r7, sp, #0
 800a862:	6078      	str	r0, [r7, #4]
 800a864:	6039      	str	r1, [r7, #0]
    OsMuxDlockNodeDelete(taskId, muxCB);
 800a866:	6839      	ldr	r1, [r7, #0]
 800a868:	6878      	ldr	r0, [r7, #4]
 800a86a:	f7fb fb6f 	bl	8005f4c <OsMuxDlockNodeDelete>
}
 800a86e:	bf00      	nop
 800a870:	3708      	adds	r7, #8
 800a872:	46bd      	mov	sp, r7
 800a874:	bd80      	pop	{r7, pc}

0800a876 <OsMuxDbgInitHook>:

/* mutex debug initialization interface */
extern UINT32 OsMuxDbgInit(VOID);
STATIC INLINE UINT32 OsMuxDbgInitHook(VOID)
{
 800a876:	b580      	push	{r7, lr}
 800a878:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_MUTEX
    return OsMuxDbgInit();
 800a87a:	f7fb f87b 	bl	8005974 <OsMuxDbgInit>
 800a87e:	4603      	mov	r3, r0
#else
    return LOS_OK;
#endif
}
 800a880:	4618      	mov	r0, r3
 800a882:	bd80      	pop	{r7, pc}

0800a884 <OsMuxDbgTimeUpdateHook>:
/* Update the last time the mutex was executed */
extern VOID OsMuxDbgTimeUpdate(UINT32 muxId);
STATIC INLINE VOID OsMuxDbgTimeUpdateHook(UINT32 muxId)
{
 800a884:	b580      	push	{r7, lr}
 800a886:	b082      	sub	sp, #8
 800a888:	af00      	add	r7, sp, #0
 800a88a:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_DEBUG_MUTEX
    OsMuxDbgTimeUpdate(muxId);
 800a88c:	6878      	ldr	r0, [r7, #4]
 800a88e:	f7fb f8a3 	bl	80059d8 <OsMuxDbgTimeUpdate>
#endif
}
 800a892:	bf00      	nop
 800a894:	3708      	adds	r7, #8
 800a896:	46bd      	mov	sp, r7
 800a898:	bd80      	pop	{r7, pc}

0800a89a <OsMuxDbgUpdateHook>:
/* Update the MUX_DEBUG_CB of the mutex when created or deleted */
extern VOID OsMuxDbgUpdate(UINT32 muxID, TSK_ENTRY_FUNC creator);
STATIC INLINE VOID OsMuxDbgUpdateHook(UINT32 muxId, TSK_ENTRY_FUNC creator)
{
 800a89a:	b580      	push	{r7, lr}
 800a89c:	b082      	sub	sp, #8
 800a89e:	af00      	add	r7, sp, #0
 800a8a0:	6078      	str	r0, [r7, #4]
 800a8a2:	6039      	str	r1, [r7, #0]
#ifdef LOSCFG_DEBUG_MUTEX
    OsMuxDbgUpdate(muxId, creator);
 800a8a4:	6839      	ldr	r1, [r7, #0]
 800a8a6:	6878      	ldr	r0, [r7, #4]
 800a8a8:	f7fb f8ae 	bl	8005a08 <OsMuxDbgUpdate>
#endif
}
 800a8ac:	bf00      	nop
 800a8ae:	3708      	adds	r7, #8
 800a8b0:	46bd      	mov	sp, r7
 800a8b2:	bd80      	pop	{r7, pc}

0800a8b4 <OsMutexCheckHook>:
/* check the leak of mutex */
extern VOID OsMutexCheck(VOID);
STATIC INLINE VOID OsMutexCheckHook(VOID)
{
 800a8b4:	b580      	push	{r7, lr}
 800a8b6:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_MUTEX
    OsMutexCheck();
 800a8b8:	f7fb f974 	bl	8005ba4 <OsMutexCheck>
#endif
}
 800a8bc:	bf00      	nop
 800a8be:	bd80      	pop	{r7, pc}

0800a8c0 <LOS_MpSchedule>:
{
 800a8c0:	b480      	push	{r7}
 800a8c2:	b083      	sub	sp, #12
 800a8c4:	af00      	add	r7, sp, #0
 800a8c6:	6078      	str	r0, [r7, #4]
}
 800a8c8:	bf00      	nop
 800a8ca:	370c      	adds	r7, #12
 800a8cc:	46bd      	mov	sp, r7
 800a8ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a8d2:	4770      	bx	lr

0800a8d4 <OsMuxInit>:
/*
 * Description  : Initializes the mutex
 * Return       : LOS_OK on success, or error code on failure
 */
LITE_OS_SEC_TEXT UINT32 OsMuxInit(VOID)
{
 800a8d4:	b580      	push	{r7, lr}
 800a8d6:	b082      	sub	sp, #8
 800a8d8:	af00      	add	r7, sp, #0
    LosMuxCB *muxNode = NULL;
 800a8da:	2300      	movs	r3, #0
 800a8dc:	607b      	str	r3, [r7, #4]
    UINT32 index;

    LOS_ListInit(&g_unusedMuxList);
 800a8de:	481f      	ldr	r0, [pc, #124]	; (800a95c <OsMuxInit+0x88>)
 800a8e0:	f7ff fec7 	bl	800a672 <LOS_ListInit>
    /* system resident memory, don't free */
    g_allMux = (LosMuxCB *)LOS_MemAlloc(m_aucSysMem0, (KERNEL_MUX_LIMIT * sizeof(LosMuxCB)));
 800a8e4:	4b1e      	ldr	r3, [pc, #120]	; (800a960 <OsMuxInit+0x8c>)
 800a8e6:	681b      	ldr	r3, [r3, #0]
 800a8e8:	f44f 71c8 	mov.w	r1, #400	; 0x190
 800a8ec:	4618      	mov	r0, r3
 800a8ee:	f7fe f85b 	bl	80089a8 <LOS_MemAlloc>
 800a8f2:	4603      	mov	r3, r0
 800a8f4:	4a1b      	ldr	r2, [pc, #108]	; (800a964 <OsMuxInit+0x90>)
 800a8f6:	6013      	str	r3, [r2, #0]
    if (g_allMux == NULL) {
 800a8f8:	4b1a      	ldr	r3, [pc, #104]	; (800a964 <OsMuxInit+0x90>)
 800a8fa:	681b      	ldr	r3, [r3, #0]
 800a8fc:	2b00      	cmp	r3, #0
 800a8fe:	d101      	bne.n	800a904 <OsMuxInit+0x30>
        return LOS_ERRNO_MUX_NO_MEMORY;
 800a900:	4b19      	ldr	r3, [pc, #100]	; (800a968 <OsMuxInit+0x94>)
 800a902:	e027      	b.n	800a954 <OsMuxInit+0x80>
    }

    for (index = 0; index < KERNEL_MUX_LIMIT; index++) {
 800a904:	2300      	movs	r3, #0
 800a906:	603b      	str	r3, [r7, #0]
 800a908:	e019      	b.n	800a93e <OsMuxInit+0x6a>
        muxNode = g_allMux + index;
 800a90a:	4b16      	ldr	r3, [pc, #88]	; (800a964 <OsMuxInit+0x90>)
 800a90c:	6819      	ldr	r1, [r3, #0]
 800a90e:	683a      	ldr	r2, [r7, #0]
 800a910:	4613      	mov	r3, r2
 800a912:	009b      	lsls	r3, r3, #2
 800a914:	4413      	add	r3, r2
 800a916:	009b      	lsls	r3, r3, #2
 800a918:	440b      	add	r3, r1
 800a91a:	607b      	str	r3, [r7, #4]
        muxNode->muxId = index;
 800a91c:	687b      	ldr	r3, [r7, #4]
 800a91e:	683a      	ldr	r2, [r7, #0]
 800a920:	611a      	str	r2, [r3, #16]
        muxNode->owner = NULL;
 800a922:	687b      	ldr	r3, [r7, #4]
 800a924:	2200      	movs	r2, #0
 800a926:	609a      	str	r2, [r3, #8]
        muxNode->muxStat = LOS_UNUSED;
 800a928:	687b      	ldr	r3, [r7, #4]
 800a92a:	2200      	movs	r2, #0
 800a92c:	739a      	strb	r2, [r3, #14]
        LOS_ListTailInsert(&g_unusedMuxList, &muxNode->muxList);
 800a92e:	687b      	ldr	r3, [r7, #4]
 800a930:	4619      	mov	r1, r3
 800a932:	480a      	ldr	r0, [pc, #40]	; (800a95c <OsMuxInit+0x88>)
 800a934:	f7ff fec6 	bl	800a6c4 <LOS_ListTailInsert>
    for (index = 0; index < KERNEL_MUX_LIMIT; index++) {
 800a938:	683b      	ldr	r3, [r7, #0]
 800a93a:	3301      	adds	r3, #1
 800a93c:	603b      	str	r3, [r7, #0]
 800a93e:	683b      	ldr	r3, [r7, #0]
 800a940:	2b13      	cmp	r3, #19
 800a942:	d9e2      	bls.n	800a90a <OsMuxInit+0x36>
    }

    if (OsMuxDbgInitHook() != LOS_OK) {
 800a944:	f7ff ff97 	bl	800a876 <OsMuxDbgInitHook>
 800a948:	4603      	mov	r3, r0
 800a94a:	2b00      	cmp	r3, #0
 800a94c:	d001      	beq.n	800a952 <OsMuxInit+0x7e>
        return LOS_ERRNO_MUX_NO_MEMORY;
 800a94e:	4b06      	ldr	r3, [pc, #24]	; (800a968 <OsMuxInit+0x94>)
 800a950:	e000      	b.n	800a954 <OsMuxInit+0x80>
    }
    return LOS_OK;
 800a952:	2300      	movs	r3, #0
}
 800a954:	4618      	mov	r0, r3
 800a956:	3708      	adds	r7, #8
 800a958:	46bd      	mov	sp, r7
 800a95a:	bd80      	pop	{r7, pc}
 800a95c:	200021cc 	.word	0x200021cc
 800a960:	200021b4 	.word	0x200021b4
 800a964:	200021c8 	.word	0x200021c8
 800a968:	02001d00 	.word	0x02001d00

0800a96c <LOS_MuxCreate>:

LITE_OS_SEC_TEXT UINT32 LOS_MuxCreate(UINT32 *muxHandle)
{
 800a96c:	b590      	push	{r4, r7, lr}
 800a96e:	b08f      	sub	sp, #60	; 0x3c
 800a970:	af02      	add	r7, sp, #8
 800a972:	6078      	str	r0, [r7, #4]
 800a974:	4b42      	ldr	r3, [pc, #264]	; (800aa80 <LOS_MuxCreate+0x114>)
 800a976:	681b      	ldr	r3, [r3, #0]
 800a978:	62fb      	str	r3, [r7, #44]	; 0x2c
 800a97a:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosMuxCB *muxCreated = NULL;
 800a97e:	2300      	movs	r3, #0
 800a980:	613b      	str	r3, [r7, #16]
    LOS_DL_LIST *unusedMux = NULL;
 800a982:	2300      	movs	r3, #0
 800a984:	617b      	str	r3, [r7, #20]
    UINT32 errNo;
    UINT32 errLine;

    if (muxHandle == NULL) {
 800a986:	687b      	ldr	r3, [r7, #4]
 800a988:	2b00      	cmp	r3, #0
 800a98a:	d101      	bne.n	800a990 <LOS_MuxCreate+0x24>
        return LOS_ERRNO_MUX_PTR_NULL;
 800a98c:	4b3d      	ldr	r3, [pc, #244]	; (800aa84 <LOS_MuxCreate+0x118>)
 800a98e:	e06b      	b.n	800aa68 <LOS_MuxCreate+0xfc>
    }

    SCHEDULER_LOCK(intSave);
 800a990:	f107 030c 	add.w	r3, r7, #12
 800a994:	4619      	mov	r1, r3
 800a996:	483c      	ldr	r0, [pc, #240]	; (800aa88 <LOS_MuxCreate+0x11c>)
 800a998:	f7ff ff32 	bl	800a800 <LOS_SpinLockSave>
    if (LOS_ListEmpty(&g_unusedMuxList)) {
 800a99c:	483b      	ldr	r0, [pc, #236]	; (800aa8c <LOS_MuxCreate+0x120>)
 800a99e:	f7ff feba 	bl	800a716 <LOS_ListEmpty>
 800a9a2:	4603      	mov	r3, r0
 800a9a4:	2b00      	cmp	r3, #0
 800a9a6:	d015      	beq.n	800a9d4 <LOS_MuxCreate+0x68>
        SCHEDULER_UNLOCK(intSave);
 800a9a8:	68fb      	ldr	r3, [r7, #12]
 800a9aa:	4619      	mov	r1, r3
 800a9ac:	4836      	ldr	r0, [pc, #216]	; (800aa88 <LOS_MuxCreate+0x11c>)
 800a9ae:	f7ff ff35 	bl	800a81c <LOS_SpinUnlockRestore>
        OsMutexCheckHook();
 800a9b2:	f7ff ff7f 	bl	800a8b4 <OsMutexCheckHook>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_ALL_BUSY);
 800a9b6:	4b36      	ldr	r3, [pc, #216]	; (800aa90 <LOS_MuxCreate+0x124>)
 800a9b8:	61fb      	str	r3, [r7, #28]
 800a9ba:	4b36      	ldr	r3, [pc, #216]	; (800aa94 <LOS_MuxCreate+0x128>)
 800a9bc:	623b      	str	r3, [r7, #32]
 800a9be:	bf00      	nop

    LOS_TRACE(MUX_CREATE, muxCreated->muxId);
    return LOS_OK;

ERR_HANDLER:
    OS_RETURN_ERROR_P2(errLine, errNo);
 800a9c0:	2300      	movs	r3, #0
 800a9c2:	9300      	str	r3, [sp, #0]
 800a9c4:	2300      	movs	r3, #0
 800a9c6:	69fa      	ldr	r2, [r7, #28]
 800a9c8:	6a39      	ldr	r1, [r7, #32]
 800a9ca:	4833      	ldr	r0, [pc, #204]	; (800aa98 <LOS_MuxCreate+0x12c>)
 800a9cc:	f7fe fde8 	bl	80095a0 <LOS_ErrHandle>
 800a9d0:	69fb      	ldr	r3, [r7, #28]
 800a9d2:	e049      	b.n	800aa68 <LOS_MuxCreate+0xfc>
    unusedMux = LOS_DL_LIST_FIRST(&g_unusedMuxList);
 800a9d4:	4b2d      	ldr	r3, [pc, #180]	; (800aa8c <LOS_MuxCreate+0x120>)
 800a9d6:	685b      	ldr	r3, [r3, #4]
 800a9d8:	617b      	str	r3, [r7, #20]
    LOS_ListDelete(unusedMux);
 800a9da:	6978      	ldr	r0, [r7, #20]
 800a9dc:	f7ff fe81 	bl	800a6e2 <LOS_ListDelete>
    muxCreated = LOS_DL_LIST_ENTRY(unusedMux, LosMuxCB, muxList);
 800a9e0:	697b      	ldr	r3, [r7, #20]
 800a9e2:	613b      	str	r3, [r7, #16]
    muxCreated->muxCount = 0;
 800a9e4:	693b      	ldr	r3, [r7, #16]
 800a9e6:	2200      	movs	r2, #0
 800a9e8:	819a      	strh	r2, [r3, #12]
    muxCreated->muxStat = LOS_USED;
 800a9ea:	693b      	ldr	r3, [r7, #16]
 800a9ec:	2201      	movs	r2, #1
 800a9ee:	739a      	strb	r2, [r3, #14]
    muxCreated->owner = NULL;
 800a9f0:	693b      	ldr	r3, [r7, #16]
 800a9f2:	2200      	movs	r2, #0
 800a9f4:	609a      	str	r2, [r3, #8]
    LOS_ListInit(&muxCreated->muxList);
 800a9f6:	693b      	ldr	r3, [r7, #16]
 800a9f8:	4618      	mov	r0, r3
 800a9fa:	f7ff fe3a 	bl	800a672 <LOS_ListInit>
    *muxHandle = muxCreated->muxId;
 800a9fe:	693b      	ldr	r3, [r7, #16]
 800aa00:	691a      	ldr	r2, [r3, #16]
 800aa02:	687b      	ldr	r3, [r7, #4]
 800aa04:	601a      	str	r2, [r3, #0]
    OsMuxDbgUpdateHook(muxCreated->muxId, OsCurrTaskGet()->taskEntry);
 800aa06:	693b      	ldr	r3, [r7, #16]
 800aa08:	691c      	ldr	r4, [r3, #16]
 800aa0a:	f7ff ff13 	bl	800a834 <OsCurrTaskGet>
 800aa0e:	4603      	mov	r3, r0
 800aa10:	699b      	ldr	r3, [r3, #24]
 800aa12:	4619      	mov	r1, r3
 800aa14:	4620      	mov	r0, r4
 800aa16:	f7ff ff40 	bl	800a89a <OsMuxDbgUpdateHook>
    SCHEDULER_UNLOCK(intSave);
 800aa1a:	68fb      	ldr	r3, [r7, #12]
 800aa1c:	4619      	mov	r1, r3
 800aa1e:	481a      	ldr	r0, [pc, #104]	; (800aa88 <LOS_MuxCreate+0x11c>)
 800aa20:	f7ff fefc 	bl	800a81c <LOS_SpinUnlockRestore>
    LOS_TRACE(MUX_CREATE, muxCreated->muxId);
 800aa24:	2300      	movs	r3, #0
 800aa26:	627b      	str	r3, [r7, #36]	; 0x24
 800aa28:	693b      	ldr	r3, [r7, #16]
 800aa2a:	691b      	ldr	r3, [r3, #16]
 800aa2c:	62bb      	str	r3, [r7, #40]	; 0x28
 800aa2e:	2302      	movs	r3, #2
 800aa30:	61bb      	str	r3, [r7, #24]
 800aa32:	69bb      	ldr	r3, [r7, #24]
 800aa34:	2b01      	cmp	r3, #1
 800aa36:	d916      	bls.n	800aa66 <LOS_MuxCreate+0xfa>
 800aa38:	4b18      	ldr	r3, [pc, #96]	; (800aa9c <LOS_MuxCreate+0x130>)
 800aa3a:	681b      	ldr	r3, [r3, #0]
 800aa3c:	2b00      	cmp	r3, #0
 800aa3e:	d012      	beq.n	800aa66 <LOS_MuxCreate+0xfa>
 800aa40:	4b16      	ldr	r3, [pc, #88]	; (800aa9c <LOS_MuxCreate+0x130>)
 800aa42:	681c      	ldr	r4, [r3, #0]
 800aa44:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800aa46:	69bb      	ldr	r3, [r7, #24]
 800aa48:	2b02      	cmp	r3, #2
 800aa4a:	d904      	bls.n	800aa56 <LOS_MuxCreate+0xea>
 800aa4c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800aa50:	f103 0208 	add.w	r2, r3, #8
 800aa54:	e000      	b.n	800aa58 <LOS_MuxCreate+0xec>
 800aa56:	2200      	movs	r2, #0
 800aa58:	69bb      	ldr	r3, [r7, #24]
 800aa5a:	b29b      	uxth	r3, r3
 800aa5c:	3b02      	subs	r3, #2
 800aa5e:	b29b      	uxth	r3, r3
 800aa60:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800aa64:	47a0      	blx	r4
    return LOS_OK;
 800aa66:	2300      	movs	r3, #0
}
 800aa68:	4a05      	ldr	r2, [pc, #20]	; (800aa80 <LOS_MuxCreate+0x114>)
 800aa6a:	6811      	ldr	r1, [r2, #0]
 800aa6c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800aa6e:	4051      	eors	r1, r2
 800aa70:	d001      	beq.n	800aa76 <LOS_MuxCreate+0x10a>
 800aa72:	f7f9 fcb9 	bl	80043e8 <__stack_chk_fail>
 800aa76:	4618      	mov	r0, r3
 800aa78:	3734      	adds	r7, #52	; 0x34
 800aa7a:	46bd      	mov	sp, r7
 800aa7c:	bd90      	pop	{r4, r7, pc}
 800aa7e:	bf00      	nop
 800aa80:	0802154c 	.word	0x0802154c
 800aa84:	02001d02 	.word	0x02001d02
 800aa88:	20000764 	.word	0x20000764
 800aa8c:	200021cc 	.word	0x200021cc
 800aa90:	02001d03 	.word	0x02001d03
 800aa94:	a1b2c3f8 	.word	0xa1b2c3f8
 800aa98:	08021538 	.word	0x08021538
 800aa9c:	2000075c 	.word	0x2000075c

0800aaa0 <LOS_MuxDelete>:

LITE_OS_SEC_TEXT UINT32 LOS_MuxDelete(UINT32 muxHandle)
{
 800aaa0:	b590      	push	{r4, r7, lr}
 800aaa2:	b091      	sub	sp, #68	; 0x44
 800aaa4:	af02      	add	r7, sp, #8
 800aaa6:	6078      	str	r0, [r7, #4]
 800aaa8:	4b56      	ldr	r3, [pc, #344]	; (800ac04 <LOS_MuxDelete+0x164>)
 800aaaa:	681b      	ldr	r3, [r3, #0]
 800aaac:	637b      	str	r3, [r7, #52]	; 0x34
 800aaae:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosMuxCB *muxDeleted = NULL;
 800aab2:	2300      	movs	r3, #0
 800aab4:	61bb      	str	r3, [r7, #24]
    UINT32 errNo;
    UINT32 errLine;

    if (GET_MUX_INDEX(muxHandle) >= (UINT32)KERNEL_MUX_LIMIT) {
 800aab6:	687b      	ldr	r3, [r7, #4]
 800aab8:	b29b      	uxth	r3, r3
 800aaba:	2b13      	cmp	r3, #19
 800aabc:	d904      	bls.n	800aac8 <LOS_MuxDelete+0x28>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_INVALID);
 800aabe:	4b52      	ldr	r3, [pc, #328]	; (800ac08 <LOS_MuxDelete+0x168>)
 800aac0:	613b      	str	r3, [r7, #16]
 800aac2:	4b52      	ldr	r3, [pc, #328]	; (800ac0c <LOS_MuxDelete+0x16c>)
 800aac4:	617b      	str	r3, [r7, #20]
 800aac6:	e088      	b.n	800abda <LOS_MuxDelete+0x13a>
    }

    muxDeleted = GET_MUX(muxHandle);
 800aac8:	4b51      	ldr	r3, [pc, #324]	; (800ac10 <LOS_MuxDelete+0x170>)
 800aaca:	6819      	ldr	r1, [r3, #0]
 800aacc:	687b      	ldr	r3, [r7, #4]
 800aace:	b29a      	uxth	r2, r3
 800aad0:	4613      	mov	r3, r2
 800aad2:	009b      	lsls	r3, r3, #2
 800aad4:	4413      	add	r3, r2
 800aad6:	009b      	lsls	r3, r3, #2
 800aad8:	440b      	add	r3, r1
 800aada:	61bb      	str	r3, [r7, #24]

    LOS_TRACE(MUX_DELETE, muxHandle, muxDeleted->muxStat, muxDeleted->muxCount,
 800aadc:	2300      	movs	r3, #0
 800aade:	623b      	str	r3, [r7, #32]
 800aae0:	687b      	ldr	r3, [r7, #4]
 800aae2:	627b      	str	r3, [r7, #36]	; 0x24
 800aae4:	69bb      	ldr	r3, [r7, #24]
 800aae6:	7b9b      	ldrb	r3, [r3, #14]
 800aae8:	62bb      	str	r3, [r7, #40]	; 0x28
 800aaea:	69bb      	ldr	r3, [r7, #24]
 800aaec:	899b      	ldrh	r3, [r3, #12]
 800aaee:	62fb      	str	r3, [r7, #44]	; 0x2c
 800aaf0:	69bb      	ldr	r3, [r7, #24]
 800aaf2:	689b      	ldr	r3, [r3, #8]
 800aaf4:	2b00      	cmp	r3, #0
 800aaf6:	d003      	beq.n	800ab00 <LOS_MuxDelete+0x60>
 800aaf8:	69bb      	ldr	r3, [r7, #24]
 800aafa:	689b      	ldr	r3, [r3, #8]
 800aafc:	695b      	ldr	r3, [r3, #20]
 800aafe:	e001      	b.n	800ab04 <LOS_MuxDelete+0x64>
 800ab00:	f04f 33ff 	mov.w	r3, #4294967295
 800ab04:	633b      	str	r3, [r7, #48]	; 0x30
 800ab06:	2305      	movs	r3, #5
 800ab08:	61fb      	str	r3, [r7, #28]
 800ab0a:	69fb      	ldr	r3, [r7, #28]
 800ab0c:	2b01      	cmp	r3, #1
 800ab0e:	d916      	bls.n	800ab3e <LOS_MuxDelete+0x9e>
 800ab10:	4b40      	ldr	r3, [pc, #256]	; (800ac14 <LOS_MuxDelete+0x174>)
 800ab12:	681b      	ldr	r3, [r3, #0]
 800ab14:	2b00      	cmp	r3, #0
 800ab16:	d012      	beq.n	800ab3e <LOS_MuxDelete+0x9e>
 800ab18:	4b3e      	ldr	r3, [pc, #248]	; (800ac14 <LOS_MuxDelete+0x174>)
 800ab1a:	681c      	ldr	r4, [r3, #0]
 800ab1c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800ab1e:	69fb      	ldr	r3, [r7, #28]
 800ab20:	2b02      	cmp	r3, #2
 800ab22:	d904      	bls.n	800ab2e <LOS_MuxDelete+0x8e>
 800ab24:	f107 0320 	add.w	r3, r7, #32
 800ab28:	f103 0208 	add.w	r2, r3, #8
 800ab2c:	e000      	b.n	800ab30 <LOS_MuxDelete+0x90>
 800ab2e:	2200      	movs	r2, #0
 800ab30:	69fb      	ldr	r3, [r7, #28]
 800ab32:	b29b      	uxth	r3, r3
 800ab34:	3b02      	subs	r3, #2
 800ab36:	b29b      	uxth	r3, r3
 800ab38:	f241 0001 	movw	r0, #4097	; 0x1001
 800ab3c:	47a0      	blx	r4
        ((muxDeleted->owner == NULL) ? 0xFFFFFFFF : muxDeleted->owner->taskId));

    SCHEDULER_LOCK(intSave);
 800ab3e:	f107 030c 	add.w	r3, r7, #12
 800ab42:	4619      	mov	r1, r3
 800ab44:	4834      	ldr	r0, [pc, #208]	; (800ac18 <LOS_MuxDelete+0x178>)
 800ab46:	f7ff fe5b 	bl	800a800 <LOS_SpinLockSave>
    if ((muxDeleted->muxId != muxHandle) || (muxDeleted->muxStat == LOS_UNUSED)) {
 800ab4a:	69bb      	ldr	r3, [r7, #24]
 800ab4c:	691b      	ldr	r3, [r3, #16]
 800ab4e:	687a      	ldr	r2, [r7, #4]
 800ab50:	429a      	cmp	r2, r3
 800ab52:	d103      	bne.n	800ab5c <LOS_MuxDelete+0xbc>
 800ab54:	69bb      	ldr	r3, [r7, #24]
 800ab56:	7b9b      	ldrb	r3, [r3, #14]
 800ab58:	2b00      	cmp	r3, #0
 800ab5a:	d109      	bne.n	800ab70 <LOS_MuxDelete+0xd0>
        SCHEDULER_UNLOCK(intSave);
 800ab5c:	68fb      	ldr	r3, [r7, #12]
 800ab5e:	4619      	mov	r1, r3
 800ab60:	482d      	ldr	r0, [pc, #180]	; (800ac18 <LOS_MuxDelete+0x178>)
 800ab62:	f7ff fe5b 	bl	800a81c <LOS_SpinUnlockRestore>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_INVALID);
 800ab66:	4b28      	ldr	r3, [pc, #160]	; (800ac08 <LOS_MuxDelete+0x168>)
 800ab68:	613b      	str	r3, [r7, #16]
 800ab6a:	4b28      	ldr	r3, [pc, #160]	; (800ac0c <LOS_MuxDelete+0x16c>)
 800ab6c:	617b      	str	r3, [r7, #20]
 800ab6e:	e034      	b.n	800abda <LOS_MuxDelete+0x13a>
    }

    if (!LOS_ListEmpty(&muxDeleted->muxList) || muxDeleted->muxCount) {
 800ab70:	69bb      	ldr	r3, [r7, #24]
 800ab72:	4618      	mov	r0, r3
 800ab74:	f7ff fdcf 	bl	800a716 <LOS_ListEmpty>
 800ab78:	4603      	mov	r3, r0
 800ab7a:	2b00      	cmp	r3, #0
 800ab7c:	d003      	beq.n	800ab86 <LOS_MuxDelete+0xe6>
 800ab7e:	69bb      	ldr	r3, [r7, #24]
 800ab80:	899b      	ldrh	r3, [r3, #12]
 800ab82:	2b00      	cmp	r3, #0
 800ab84:	d009      	beq.n	800ab9a <LOS_MuxDelete+0xfa>
        SCHEDULER_UNLOCK(intSave);
 800ab86:	68fb      	ldr	r3, [r7, #12]
 800ab88:	4619      	mov	r1, r3
 800ab8a:	4823      	ldr	r0, [pc, #140]	; (800ac18 <LOS_MuxDelete+0x178>)
 800ab8c:	f7ff fe46 	bl	800a81c <LOS_SpinUnlockRestore>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_PENDED);
 800ab90:	4b22      	ldr	r3, [pc, #136]	; (800ac1c <LOS_MuxDelete+0x17c>)
 800ab92:	613b      	str	r3, [r7, #16]
 800ab94:	4b1d      	ldr	r3, [pc, #116]	; (800ac0c <LOS_MuxDelete+0x16c>)
 800ab96:	617b      	str	r3, [r7, #20]
 800ab98:	e01f      	b.n	800abda <LOS_MuxDelete+0x13a>
    }

    LOS_ListTailInsert(&g_unusedMuxList, &muxDeleted->muxList);
 800ab9a:	69bb      	ldr	r3, [r7, #24]
 800ab9c:	4619      	mov	r1, r3
 800ab9e:	4820      	ldr	r0, [pc, #128]	; (800ac20 <LOS_MuxDelete+0x180>)
 800aba0:	f7ff fd90 	bl	800a6c4 <LOS_ListTailInsert>
    muxDeleted->muxStat = LOS_UNUSED;
 800aba4:	69bb      	ldr	r3, [r7, #24]
 800aba6:	2200      	movs	r2, #0
 800aba8:	739a      	strb	r2, [r3, #14]
    muxDeleted->muxId = SET_MUX_ID(GET_MUX_COUNT(muxDeleted->muxId) + 1, GET_MUX_INDEX(muxDeleted->muxId));
 800abaa:	69bb      	ldr	r3, [r7, #24]
 800abac:	691b      	ldr	r3, [r3, #16]
 800abae:	0c1b      	lsrs	r3, r3, #16
 800abb0:	3301      	adds	r3, #1
 800abb2:	041a      	lsls	r2, r3, #16
 800abb4:	69bb      	ldr	r3, [r7, #24]
 800abb6:	691b      	ldr	r3, [r3, #16]
 800abb8:	b29b      	uxth	r3, r3
 800abba:	431a      	orrs	r2, r3
 800abbc:	69bb      	ldr	r3, [r7, #24]
 800abbe:	611a      	str	r2, [r3, #16]

    OsMuxDbgUpdateHook(muxDeleted->muxId, NULL);
 800abc0:	69bb      	ldr	r3, [r7, #24]
 800abc2:	691b      	ldr	r3, [r3, #16]
 800abc4:	2100      	movs	r1, #0
 800abc6:	4618      	mov	r0, r3
 800abc8:	f7ff fe67 	bl	800a89a <OsMuxDbgUpdateHook>

    SCHEDULER_UNLOCK(intSave);
 800abcc:	68fb      	ldr	r3, [r7, #12]
 800abce:	4619      	mov	r1, r3
 800abd0:	4811      	ldr	r0, [pc, #68]	; (800ac18 <LOS_MuxDelete+0x178>)
 800abd2:	f7ff fe23 	bl	800a81c <LOS_SpinUnlockRestore>

    return LOS_OK;
 800abd6:	2300      	movs	r3, #0
 800abd8:	e008      	b.n	800abec <LOS_MuxDelete+0x14c>

ERR_HANDLER:
    OS_RETURN_ERROR_P2(errLine, errNo);
 800abda:	2300      	movs	r3, #0
 800abdc:	9300      	str	r3, [sp, #0]
 800abde:	2300      	movs	r3, #0
 800abe0:	693a      	ldr	r2, [r7, #16]
 800abe2:	6979      	ldr	r1, [r7, #20]
 800abe4:	480f      	ldr	r0, [pc, #60]	; (800ac24 <LOS_MuxDelete+0x184>)
 800abe6:	f7fe fcdb 	bl	80095a0 <LOS_ErrHandle>
 800abea:	693b      	ldr	r3, [r7, #16]
}
 800abec:	4a05      	ldr	r2, [pc, #20]	; (800ac04 <LOS_MuxDelete+0x164>)
 800abee:	6811      	ldr	r1, [r2, #0]
 800abf0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800abf2:	4051      	eors	r1, r2
 800abf4:	d001      	beq.n	800abfa <LOS_MuxDelete+0x15a>
 800abf6:	f7f9 fbf7 	bl	80043e8 <__stack_chk_fail>
 800abfa:	4618      	mov	r0, r3
 800abfc:	373c      	adds	r7, #60	; 0x3c
 800abfe:	46bd      	mov	sp, r7
 800ac00:	bd90      	pop	{r4, r7, pc}
 800ac02:	bf00      	nop
 800ac04:	08021550 	.word	0x08021550
 800ac08:	02001d01 	.word	0x02001d01
 800ac0c:	a1b2c3f8 	.word	0xa1b2c3f8
 800ac10:	200021c8 	.word	0x200021c8
 800ac14:	2000075c 	.word	0x2000075c
 800ac18:	20000764 	.word	0x20000764
 800ac1c:	02001d09 	.word	0x02001d09
 800ac20:	200021cc 	.word	0x200021cc
 800ac24:	08021538 	.word	0x08021538

0800ac28 <OsMuxParaCheck>:

LITE_OS_SEC_TEXT STATIC UINT32 OsMuxParaCheck(const LosMuxCB *muxCB, UINT32 muxHandle)
{
 800ac28:	b580      	push	{r7, lr}
 800ac2a:	b084      	sub	sp, #16
 800ac2c:	af02      	add	r7, sp, #8
 800ac2e:	6078      	str	r0, [r7, #4]
 800ac30:	6039      	str	r1, [r7, #0]
    if ((muxCB->muxStat == LOS_UNUSED) || (muxCB->muxId != muxHandle)) {
 800ac32:	687b      	ldr	r3, [r7, #4]
 800ac34:	7b9b      	ldrb	r3, [r3, #14]
 800ac36:	2b00      	cmp	r3, #0
 800ac38:	d004      	beq.n	800ac44 <OsMuxParaCheck+0x1c>
 800ac3a:	687b      	ldr	r3, [r7, #4]
 800ac3c:	691b      	ldr	r3, [r3, #16]
 800ac3e:	683a      	ldr	r2, [r7, #0]
 800ac40:	429a      	cmp	r2, r3
 800ac42:	d009      	beq.n	800ac58 <OsMuxParaCheck+0x30>
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
 800ac44:	2300      	movs	r3, #0
 800ac46:	9300      	str	r3, [sp, #0]
 800ac48:	2300      	movs	r3, #0
 800ac4a:	4a0c      	ldr	r2, [pc, #48]	; (800ac7c <OsMuxParaCheck+0x54>)
 800ac4c:	490c      	ldr	r1, [pc, #48]	; (800ac80 <OsMuxParaCheck+0x58>)
 800ac4e:	480d      	ldr	r0, [pc, #52]	; (800ac84 <OsMuxParaCheck+0x5c>)
 800ac50:	f7fe fca6 	bl	80095a0 <LOS_ErrHandle>
 800ac54:	4b09      	ldr	r3, [pc, #36]	; (800ac7c <OsMuxParaCheck+0x54>)
 800ac56:	e00c      	b.n	800ac72 <OsMuxParaCheck+0x4a>
    }

    OsMuxDbgTimeUpdateHook(muxCB->muxId);
 800ac58:	687b      	ldr	r3, [r7, #4]
 800ac5a:	691b      	ldr	r3, [r3, #16]
 800ac5c:	4618      	mov	r0, r3
 800ac5e:	f7ff fe11 	bl	800a884 <OsMuxDbgTimeUpdateHook>

    if (OS_INT_ACTIVE) {
 800ac62:	f7f7 fc03 	bl	800246c <IntActive>
 800ac66:	4603      	mov	r3, r0
 800ac68:	2b00      	cmp	r3, #0
 800ac6a:	d001      	beq.n	800ac70 <OsMuxParaCheck+0x48>
        return LOS_ERRNO_MUX_PEND_INTERR;
 800ac6c:	4b06      	ldr	r3, [pc, #24]	; (800ac88 <OsMuxParaCheck+0x60>)
 800ac6e:	e000      	b.n	800ac72 <OsMuxParaCheck+0x4a>
    }
    return LOS_OK;
 800ac70:	2300      	movs	r3, #0
}
 800ac72:	4618      	mov	r0, r3
 800ac74:	3708      	adds	r7, #8
 800ac76:	46bd      	mov	sp, r7
 800ac78:	bd80      	pop	{r7, pc}
 800ac7a:	bf00      	nop
 800ac7c:	02001d01 	.word	0x02001d01
 800ac80:	a1b2c3f8 	.word	0xa1b2c3f8
 800ac84:	08021538 	.word	0x08021538
 800ac88:	02001d05 	.word	0x02001d05

0800ac8c <OsMuxBitmapSet>:

LITE_OS_SEC_TEXT STATIC VOID OsMuxBitmapSet(const LosTaskCB *runTask, const MuxBaseCB *muxPended)
{
 800ac8c:	b580      	push	{r7, lr}
 800ac8e:	b082      	sub	sp, #8
 800ac90:	af00      	add	r7, sp, #0
 800ac92:	6078      	str	r0, [r7, #4]
 800ac94:	6039      	str	r1, [r7, #0]
    if (muxPended->owner->priority > runTask->priority) {
 800ac96:	683b      	ldr	r3, [r7, #0]
 800ac98:	689b      	ldr	r3, [r3, #8]
 800ac9a:	88da      	ldrh	r2, [r3, #6]
 800ac9c:	687b      	ldr	r3, [r7, #4]
 800ac9e:	88db      	ldrh	r3, [r3, #6]
 800aca0:	429a      	cmp	r2, r3
 800aca2:	d912      	bls.n	800acca <OsMuxBitmapSet+0x3e>
        LOS_BitmapSet(&(muxPended->owner->priBitMap), muxPended->owner->priority);
 800aca4:	683b      	ldr	r3, [r7, #0]
 800aca6:	689b      	ldr	r3, [r3, #8]
 800aca8:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 800acac:	683b      	ldr	r3, [r7, #0]
 800acae:	689b      	ldr	r3, [r3, #8]
 800acb0:	88db      	ldrh	r3, [r3, #6]
 800acb2:	4619      	mov	r1, r3
 800acb4:	4610      	mov	r0, r2
 800acb6:	f000 fb41 	bl	800b33c <LOS_BitmapSet>
        OsTaskPriModify(muxPended->owner, runTask->priority);
 800acba:	683b      	ldr	r3, [r7, #0]
 800acbc:	689a      	ldr	r2, [r3, #8]
 800acbe:	687b      	ldr	r3, [r7, #4]
 800acc0:	88db      	ldrh	r3, [r3, #6]
 800acc2:	4619      	mov	r1, r3
 800acc4:	4610      	mov	r0, r2
 800acc6:	f7f7 ff63 	bl	8002b90 <OsTaskPriModify>
    }
}
 800acca:	bf00      	nop
 800accc:	3708      	adds	r7, #8
 800acce:	46bd      	mov	sp, r7
 800acd0:	bd80      	pop	{r7, pc}

0800acd2 <OsMuxBitmapRestore>:

LITE_OS_SEC_TEXT STATIC VOID OsMuxBitmapRestore(const LosTaskCB *runTask, LosTaskCB *owner)
{
 800acd2:	b580      	push	{r7, lr}
 800acd4:	b084      	sub	sp, #16
 800acd6:	af00      	add	r7, sp, #0
 800acd8:	6078      	str	r0, [r7, #4]
 800acda:	6039      	str	r1, [r7, #0]
    UINT16 bitMapPri;

    if (owner->priority >= runTask->priority) {
 800acdc:	683b      	ldr	r3, [r7, #0]
 800acde:	88da      	ldrh	r2, [r3, #6]
 800ace0:	687b      	ldr	r3, [r7, #4]
 800ace2:	88db      	ldrh	r3, [r3, #6]
 800ace4:	429a      	cmp	r2, r3
 800ace6:	d316      	bcc.n	800ad16 <OsMuxBitmapRestore+0x44>
        bitMapPri = LOS_LowBitGet(owner->priBitMap);
 800ace8:	683b      	ldr	r3, [r7, #0]
 800acea:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800acec:	4618      	mov	r0, r3
 800acee:	f000 fb72 	bl	800b3d6 <LOS_LowBitGet>
 800acf2:	4603      	mov	r3, r0
 800acf4:	81fb      	strh	r3, [r7, #14]
        if (bitMapPri != LOS_INVALID_BIT_INDEX) {
 800acf6:	89fb      	ldrh	r3, [r7, #14]
 800acf8:	2b20      	cmp	r3, #32
 800acfa:	d020      	beq.n	800ad3e <OsMuxBitmapRestore+0x6c>
            LOS_BitmapClr(&(owner->priBitMap), bitMapPri);
 800acfc:	683b      	ldr	r3, [r7, #0]
 800acfe:	336c      	adds	r3, #108	; 0x6c
 800ad00:	89fa      	ldrh	r2, [r7, #14]
 800ad02:	4611      	mov	r1, r2
 800ad04:	4618      	mov	r0, r3
 800ad06:	f000 fb34 	bl	800b372 <LOS_BitmapClr>
            OsTaskPriModify(owner, bitMapPri);
 800ad0a:	89fb      	ldrh	r3, [r7, #14]
 800ad0c:	4619      	mov	r1, r3
 800ad0e:	6838      	ldr	r0, [r7, #0]
 800ad10:	f7f7 ff3e 	bl	8002b90 <OsTaskPriModify>
    } else {
        if (LOS_HighBitGet(owner->priBitMap) != runTask->priority) {
            LOS_BitmapClr(&(owner->priBitMap), runTask->priority);
        }
    }
}
 800ad14:	e013      	b.n	800ad3e <OsMuxBitmapRestore+0x6c>
        if (LOS_HighBitGet(owner->priBitMap) != runTask->priority) {
 800ad16:	683b      	ldr	r3, [r7, #0]
 800ad18:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ad1a:	4618      	mov	r0, r3
 800ad1c:	f000 fb45 	bl	800b3aa <LOS_HighBitGet>
 800ad20:	4603      	mov	r3, r0
 800ad22:	461a      	mov	r2, r3
 800ad24:	687b      	ldr	r3, [r7, #4]
 800ad26:	88db      	ldrh	r3, [r3, #6]
 800ad28:	429a      	cmp	r2, r3
 800ad2a:	d008      	beq.n	800ad3e <OsMuxBitmapRestore+0x6c>
            LOS_BitmapClr(&(owner->priBitMap), runTask->priority);
 800ad2c:	683b      	ldr	r3, [r7, #0]
 800ad2e:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 800ad32:	687b      	ldr	r3, [r7, #4]
 800ad34:	88db      	ldrh	r3, [r3, #6]
 800ad36:	4619      	mov	r1, r3
 800ad38:	4610      	mov	r0, r2
 800ad3a:	f000 fb1a 	bl	800b372 <LOS_BitmapClr>
}
 800ad3e:	bf00      	nop
 800ad40:	3710      	adds	r7, #16
 800ad42:	46bd      	mov	sp, r7
 800ad44:	bd80      	pop	{r7, pc}

0800ad46 <OsMuxPendFindPosSub>:

#ifdef LOSCFG_MUTEX_WAITMODE_PRIO
LITE_OS_SEC_TEXT STATIC LOS_DL_LIST *OsMuxPendFindPosSub(const LosTaskCB *runTask, const MuxBaseCB *muxPended)
{
 800ad46:	b480      	push	{r7}
 800ad48:	b085      	sub	sp, #20
 800ad4a:	af00      	add	r7, sp, #0
 800ad4c:	6078      	str	r0, [r7, #4]
 800ad4e:	6039      	str	r1, [r7, #0]
    LosTaskCB *pendedTask = NULL;
 800ad50:	2300      	movs	r3, #0
 800ad52:	60bb      	str	r3, [r7, #8]
    LOS_DL_LIST *node = NULL;
 800ad54:	2300      	movs	r3, #0
 800ad56:	60fb      	str	r3, [r7, #12]

    LOS_DL_LIST_FOR_EACH_ENTRY(pendedTask, &(muxPended->muxList), LosTaskCB, pendList) {
 800ad58:	683b      	ldr	r3, [r7, #0]
 800ad5a:	685b      	ldr	r3, [r3, #4]
 800ad5c:	3b40      	subs	r3, #64	; 0x40
 800ad5e:	60bb      	str	r3, [r7, #8]
 800ad60:	e018      	b.n	800ad94 <OsMuxPendFindPosSub+0x4e>
        if (pendedTask->priority < runTask->priority) {
 800ad62:	68bb      	ldr	r3, [r7, #8]
 800ad64:	88da      	ldrh	r2, [r3, #6]
 800ad66:	687b      	ldr	r3, [r7, #4]
 800ad68:	88db      	ldrh	r3, [r3, #6]
 800ad6a:	429a      	cmp	r2, r3
 800ad6c:	d204      	bcs.n	800ad78 <OsMuxPendFindPosSub+0x32>
    LOS_DL_LIST_FOR_EACH_ENTRY(pendedTask, &(muxPended->muxList), LosTaskCB, pendList) {
 800ad6e:	68bb      	ldr	r3, [r7, #8]
 800ad70:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ad72:	3b40      	subs	r3, #64	; 0x40
 800ad74:	60bb      	str	r3, [r7, #8]
 800ad76:	e00d      	b.n	800ad94 <OsMuxPendFindPosSub+0x4e>
            continue;
        } else if (pendedTask->priority > runTask->priority) {
 800ad78:	68bb      	ldr	r3, [r7, #8]
 800ad7a:	88da      	ldrh	r2, [r3, #6]
 800ad7c:	687b      	ldr	r3, [r7, #4]
 800ad7e:	88db      	ldrh	r3, [r3, #6]
 800ad80:	429a      	cmp	r2, r3
 800ad82:	d903      	bls.n	800ad8c <OsMuxPendFindPosSub+0x46>
            node = &pendedTask->pendList;
 800ad84:	68bb      	ldr	r3, [r7, #8]
 800ad86:	3340      	adds	r3, #64	; 0x40
 800ad88:	60fb      	str	r3, [r7, #12]
            break;
 800ad8a:	e009      	b.n	800ada0 <OsMuxPendFindPosSub+0x5a>
        } else {
            node = pendedTask->pendList.pstNext;
 800ad8c:	68bb      	ldr	r3, [r7, #8]
 800ad8e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ad90:	60fb      	str	r3, [r7, #12]
            break;
 800ad92:	e005      	b.n	800ada0 <OsMuxPendFindPosSub+0x5a>
    LOS_DL_LIST_FOR_EACH_ENTRY(pendedTask, &(muxPended->muxList), LosTaskCB, pendList) {
 800ad94:	68bb      	ldr	r3, [r7, #8]
 800ad96:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800ad9a:	683b      	ldr	r3, [r7, #0]
 800ad9c:	429a      	cmp	r2, r3
 800ad9e:	d1e0      	bne.n	800ad62 <OsMuxPendFindPosSub+0x1c>
        }
    }

    return node;
 800ada0:	68fb      	ldr	r3, [r7, #12]
}
 800ada2:	4618      	mov	r0, r3
 800ada4:	3714      	adds	r7, #20
 800ada6:	46bd      	mov	sp, r7
 800ada8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800adac:	4770      	bx	lr

0800adae <OsMuxPendFindPos>:

LITE_OS_SEC_TEXT STATIC LOS_DL_LIST *OsMuxPendFindPos(const LosTaskCB *runTask, MuxBaseCB *muxPended)
{
 800adae:	b580      	push	{r7, lr}
 800adb0:	b086      	sub	sp, #24
 800adb2:	af00      	add	r7, sp, #0
 800adb4:	6078      	str	r0, [r7, #4]
 800adb6:	6039      	str	r1, [r7, #0]
    LOS_DL_LIST *node = NULL;
 800adb8:	2300      	movs	r3, #0
 800adba:	60fb      	str	r3, [r7, #12]
    LosTaskCB *pendedTask1 = NULL;
 800adbc:	2300      	movs	r3, #0
 800adbe:	613b      	str	r3, [r7, #16]
    LosTaskCB *pendedTask2 = NULL;
 800adc0:	2300      	movs	r3, #0
 800adc2:	617b      	str	r3, [r7, #20]

    if (LOS_ListEmpty(&muxPended->muxList)) {
 800adc4:	683b      	ldr	r3, [r7, #0]
 800adc6:	4618      	mov	r0, r3
 800adc8:	f7ff fca5 	bl	800a716 <LOS_ListEmpty>
 800adcc:	4603      	mov	r3, r0
 800adce:	2b00      	cmp	r3, #0
 800add0:	d002      	beq.n	800add8 <OsMuxPendFindPos+0x2a>
        node = &muxPended->muxList;
 800add2:	683b      	ldr	r3, [r7, #0]
 800add4:	60fb      	str	r3, [r7, #12]
 800add6:	e025      	b.n	800ae24 <OsMuxPendFindPos+0x76>
    } else {
        pendedTask1 = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&muxPended->muxList));
 800add8:	683b      	ldr	r3, [r7, #0]
 800adda:	685b      	ldr	r3, [r3, #4]
 800addc:	3b40      	subs	r3, #64	; 0x40
 800adde:	613b      	str	r3, [r7, #16]
        pendedTask2 = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_LAST(&muxPended->muxList));
 800ade0:	683b      	ldr	r3, [r7, #0]
 800ade2:	681b      	ldr	r3, [r3, #0]
 800ade4:	3b40      	subs	r3, #64	; 0x40
 800ade6:	617b      	str	r3, [r7, #20]
        if ((pendedTask1 != NULL) && (pendedTask1->priority > runTask->priority)) {
 800ade8:	693b      	ldr	r3, [r7, #16]
 800adea:	2b00      	cmp	r3, #0
 800adec:	d009      	beq.n	800ae02 <OsMuxPendFindPos+0x54>
 800adee:	693b      	ldr	r3, [r7, #16]
 800adf0:	88da      	ldrh	r2, [r3, #6]
 800adf2:	687b      	ldr	r3, [r7, #4]
 800adf4:	88db      	ldrh	r3, [r3, #6]
 800adf6:	429a      	cmp	r2, r3
 800adf8:	d903      	bls.n	800ae02 <OsMuxPendFindPos+0x54>
            node = muxPended->muxList.pstNext;
 800adfa:	683b      	ldr	r3, [r7, #0]
 800adfc:	685b      	ldr	r3, [r3, #4]
 800adfe:	60fb      	str	r3, [r7, #12]
 800ae00:	e010      	b.n	800ae24 <OsMuxPendFindPos+0x76>
        } else if ((pendedTask2 != NULL) && (pendedTask2->priority <= runTask->priority)) {
 800ae02:	697b      	ldr	r3, [r7, #20]
 800ae04:	2b00      	cmp	r3, #0
 800ae06:	d008      	beq.n	800ae1a <OsMuxPendFindPos+0x6c>
 800ae08:	697b      	ldr	r3, [r7, #20]
 800ae0a:	88da      	ldrh	r2, [r3, #6]
 800ae0c:	687b      	ldr	r3, [r7, #4]
 800ae0e:	88db      	ldrh	r3, [r3, #6]
 800ae10:	429a      	cmp	r2, r3
 800ae12:	d802      	bhi.n	800ae1a <OsMuxPendFindPos+0x6c>
            node = &muxPended->muxList;
 800ae14:	683b      	ldr	r3, [r7, #0]
 800ae16:	60fb      	str	r3, [r7, #12]
 800ae18:	e004      	b.n	800ae24 <OsMuxPendFindPos+0x76>
        } else {
            node = OsMuxPendFindPosSub(runTask, muxPended);
 800ae1a:	6839      	ldr	r1, [r7, #0]
 800ae1c:	6878      	ldr	r0, [r7, #4]
 800ae1e:	f7ff ff92 	bl	800ad46 <OsMuxPendFindPosSub>
 800ae22:	60f8      	str	r0, [r7, #12]
        }
    }
    return node;
 800ae24:	68fb      	ldr	r3, [r7, #12]
}
 800ae26:	4618      	mov	r0, r3
 800ae28:	3718      	adds	r7, #24
 800ae2a:	46bd      	mov	sp, r7
 800ae2c:	bd80      	pop	{r7, pc}
	...

0800ae30 <OsMuxPendOp>:
}
#endif

LITE_OS_SEC_TEXT UINT32 OsMuxPendOp(LosTaskCB *runTask, MuxBaseCB *muxPended, UINT32 timeout,
                                    UINT32 *intSave)
{
 800ae30:	b580      	push	{r7, lr}
 800ae32:	b088      	sub	sp, #32
 800ae34:	af00      	add	r7, sp, #0
 800ae36:	60f8      	str	r0, [r7, #12]
 800ae38:	60b9      	str	r1, [r7, #8]
 800ae3a:	607a      	str	r2, [r7, #4]
 800ae3c:	603b      	str	r3, [r7, #0]
    LOS_DL_LIST *node = NULL;
 800ae3e:	2300      	movs	r3, #0
 800ae40:	61bb      	str	r3, [r7, #24]
    UINT32 ret = LOS_OK;
 800ae42:	2300      	movs	r3, #0
 800ae44:	617b      	str	r3, [r7, #20]
    LosTaskCB *owner = muxPended->owner;
 800ae46:	68bb      	ldr	r3, [r7, #8]
 800ae48:	689b      	ldr	r3, [r3, #8]
 800ae4a:	61fb      	str	r3, [r7, #28]

    runTask->taskMux = (VOID *)muxPended;
 800ae4c:	68fb      	ldr	r3, [r7, #12]
 800ae4e:	68ba      	ldr	r2, [r7, #8]
 800ae50:	629a      	str	r2, [r3, #40]	; 0x28
    node = OsMuxPendFindPos(runTask, muxPended);
 800ae52:	68b9      	ldr	r1, [r7, #8]
 800ae54:	68f8      	ldr	r0, [r7, #12]
 800ae56:	f7ff ffaa 	bl	800adae <OsMuxPendFindPos>
 800ae5a:	61b8      	str	r0, [r7, #24]
    OsTaskWait(node, OS_TASK_STATUS_PEND, timeout);
 800ae5c:	687a      	ldr	r2, [r7, #4]
 800ae5e:	2108      	movs	r1, #8
 800ae60:	69b8      	ldr	r0, [r7, #24]
 800ae62:	f7f8 ff83 	bl	8003d6c <OsTaskWait>
    OsSchedResched();
 800ae66:	f7fd f971 	bl	800814c <OsSchedResched>
    SCHEDULER_UNLOCK(*intSave);
 800ae6a:	683b      	ldr	r3, [r7, #0]
 800ae6c:	681b      	ldr	r3, [r3, #0]
 800ae6e:	4619      	mov	r1, r3
 800ae70:	4811      	ldr	r0, [pc, #68]	; (800aeb8 <OsMuxPendOp+0x88>)
 800ae72:	f7ff fcd3 	bl	800a81c <LOS_SpinUnlockRestore>
    SCHEDULER_LOCK(*intSave);
 800ae76:	6839      	ldr	r1, [r7, #0]
 800ae78:	480f      	ldr	r0, [pc, #60]	; (800aeb8 <OsMuxPendOp+0x88>)
 800ae7a:	f7ff fcc1 	bl	800a800 <LOS_SpinLockSave>

    if (runTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
 800ae7e:	68fb      	ldr	r3, [r7, #12]
 800ae80:	889b      	ldrh	r3, [r3, #4]
 800ae82:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ae86:	2b00      	cmp	r3, #0
 800ae88:	d008      	beq.n	800ae9c <OsMuxPendOp+0x6c>
        runTask->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
 800ae8a:	68fb      	ldr	r3, [r7, #12]
 800ae8c:	889b      	ldrh	r3, [r3, #4]
 800ae8e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800ae92:	b29a      	uxth	r2, r3
 800ae94:	68fb      	ldr	r3, [r7, #12]
 800ae96:	809a      	strh	r2, [r3, #4]
        ret = LOS_ERRNO_MUX_TIMEOUT;
 800ae98:	4b08      	ldr	r3, [pc, #32]	; (800aebc <OsMuxPendOp+0x8c>)
 800ae9a:	617b      	str	r3, [r7, #20]
    }

    if (timeout != LOS_WAIT_FOREVER) {
 800ae9c:	687b      	ldr	r3, [r7, #4]
 800ae9e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800aea2:	d003      	beq.n	800aeac <OsMuxPendOp+0x7c>
        OsMuxBitmapRestore(runTask, owner);
 800aea4:	69f9      	ldr	r1, [r7, #28]
 800aea6:	68f8      	ldr	r0, [r7, #12]
 800aea8:	f7ff ff13 	bl	800acd2 <OsMuxBitmapRestore>
    }

    return ret;
 800aeac:	697b      	ldr	r3, [r7, #20]
}
 800aeae:	4618      	mov	r0, r3
 800aeb0:	3720      	adds	r7, #32
 800aeb2:	46bd      	mov	sp, r7
 800aeb4:	bd80      	pop	{r7, pc}
 800aeb6:	bf00      	nop
 800aeb8:	20000764 	.word	0x20000764
 800aebc:	02001d07 	.word	0x02001d07

0800aec0 <LOS_MuxPend>:

LITE_OS_SEC_TEXT UINT32 LOS_MuxPend(UINT32 muxHandle, UINT32 timeout)
{
 800aec0:	b590      	push	{r4, r7, lr}
 800aec2:	b091      	sub	sp, #68	; 0x44
 800aec4:	af02      	add	r7, sp, #8
 800aec6:	6078      	str	r0, [r7, #4]
 800aec8:	6039      	str	r1, [r7, #0]
 800aeca:	4b5d      	ldr	r3, [pc, #372]	; (800b040 <LOS_MuxPend+0x180>)
 800aecc:	681b      	ldr	r3, [r3, #0]
 800aece:	637b      	str	r3, [r7, #52]	; 0x34
 800aed0:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    UINT32 intSave;
    LosMuxCB *muxPended = NULL;
 800aed4:	2300      	movs	r3, #0
 800aed6:	617b      	str	r3, [r7, #20]
    LosTaskCB *runTask = NULL;
 800aed8:	2300      	movs	r3, #0
 800aeda:	61bb      	str	r3, [r7, #24]

    if (GET_MUX_INDEX(muxHandle) >= (UINT32)KERNEL_MUX_LIMIT) {
 800aedc:	687b      	ldr	r3, [r7, #4]
 800aede:	b29b      	uxth	r3, r3
 800aee0:	2b13      	cmp	r3, #19
 800aee2:	d909      	bls.n	800aef8 <LOS_MuxPend+0x38>
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
 800aee4:	2300      	movs	r3, #0
 800aee6:	9300      	str	r3, [sp, #0]
 800aee8:	2300      	movs	r3, #0
 800aeea:	4a56      	ldr	r2, [pc, #344]	; (800b044 <LOS_MuxPend+0x184>)
 800aeec:	4956      	ldr	r1, [pc, #344]	; (800b048 <LOS_MuxPend+0x188>)
 800aeee:	4857      	ldr	r0, [pc, #348]	; (800b04c <LOS_MuxPend+0x18c>)
 800aef0:	f7fe fb56 	bl	80095a0 <LOS_ErrHandle>
 800aef4:	4b53      	ldr	r3, [pc, #332]	; (800b044 <LOS_MuxPend+0x184>)
 800aef6:	e098      	b.n	800b02a <LOS_MuxPend+0x16a>
    }

    muxPended = GET_MUX(muxHandle);
 800aef8:	4b55      	ldr	r3, [pc, #340]	; (800b050 <LOS_MuxPend+0x190>)
 800aefa:	6819      	ldr	r1, [r3, #0]
 800aefc:	687b      	ldr	r3, [r7, #4]
 800aefe:	b29a      	uxth	r2, r3
 800af00:	4613      	mov	r3, r2
 800af02:	009b      	lsls	r3, r3, #2
 800af04:	4413      	add	r3, r2
 800af06:	009b      	lsls	r3, r3, #2
 800af08:	440b      	add	r3, r1
 800af0a:	617b      	str	r3, [r7, #20]

    LOS_TRACE(MUX_PEND, muxHandle, muxPended->muxCount,
 800af0c:	2300      	movs	r3, #0
 800af0e:	623b      	str	r3, [r7, #32]
 800af10:	687b      	ldr	r3, [r7, #4]
 800af12:	627b      	str	r3, [r7, #36]	; 0x24
 800af14:	697b      	ldr	r3, [r7, #20]
 800af16:	899b      	ldrh	r3, [r3, #12]
 800af18:	62bb      	str	r3, [r7, #40]	; 0x28
 800af1a:	697b      	ldr	r3, [r7, #20]
 800af1c:	689b      	ldr	r3, [r3, #8]
 800af1e:	2b00      	cmp	r3, #0
 800af20:	d003      	beq.n	800af2a <LOS_MuxPend+0x6a>
 800af22:	697b      	ldr	r3, [r7, #20]
 800af24:	689b      	ldr	r3, [r3, #8]
 800af26:	695b      	ldr	r3, [r3, #20]
 800af28:	e001      	b.n	800af2e <LOS_MuxPend+0x6e>
 800af2a:	f04f 33ff 	mov.w	r3, #4294967295
 800af2e:	62fb      	str	r3, [r7, #44]	; 0x2c
 800af30:	683b      	ldr	r3, [r7, #0]
 800af32:	633b      	str	r3, [r7, #48]	; 0x30
 800af34:	2305      	movs	r3, #5
 800af36:	61fb      	str	r3, [r7, #28]
 800af38:	69fb      	ldr	r3, [r7, #28]
 800af3a:	2b01      	cmp	r3, #1
 800af3c:	d916      	bls.n	800af6c <LOS_MuxPend+0xac>
 800af3e:	4b45      	ldr	r3, [pc, #276]	; (800b054 <LOS_MuxPend+0x194>)
 800af40:	681b      	ldr	r3, [r3, #0]
 800af42:	2b00      	cmp	r3, #0
 800af44:	d012      	beq.n	800af6c <LOS_MuxPend+0xac>
 800af46:	4b43      	ldr	r3, [pc, #268]	; (800b054 <LOS_MuxPend+0x194>)
 800af48:	681c      	ldr	r4, [r3, #0]
 800af4a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800af4c:	69fb      	ldr	r3, [r7, #28]
 800af4e:	2b02      	cmp	r3, #2
 800af50:	d904      	bls.n	800af5c <LOS_MuxPend+0x9c>
 800af52:	f107 0320 	add.w	r3, r7, #32
 800af56:	f103 0208 	add.w	r2, r3, #8
 800af5a:	e000      	b.n	800af5e <LOS_MuxPend+0x9e>
 800af5c:	2200      	movs	r2, #0
 800af5e:	69fb      	ldr	r3, [r7, #28]
 800af60:	b29b      	uxth	r3, r3
 800af62:	3b02      	subs	r3, #2
 800af64:	b29b      	uxth	r3, r3
 800af66:	f241 0002 	movw	r0, #4098	; 0x1002
 800af6a:	47a0      	blx	r4
        ((muxPended->owner == NULL) ? 0xFFFFFFFF : muxPended->owner->taskId), timeout);

    runTask = OsCurrTaskGet();
 800af6c:	f7ff fc62 	bl	800a834 <OsCurrTaskGet>
 800af70:	61b8      	str	r0, [r7, #24]
    if (runTask->taskFlags & OS_TASK_FLAG_SYSTEM) {
        PRINT_DEBUG("Warning: DO NOT recommend to use %s in system tasks.\n", __FUNCTION__);
    }

    SCHEDULER_LOCK(intSave);
 800af72:	f107 030c 	add.w	r3, r7, #12
 800af76:	4619      	mov	r1, r3
 800af78:	4837      	ldr	r0, [pc, #220]	; (800b058 <LOS_MuxPend+0x198>)
 800af7a:	f7ff fc41 	bl	800a800 <LOS_SpinLockSave>

    ret = OsMuxParaCheck(muxPended, muxHandle);
 800af7e:	6879      	ldr	r1, [r7, #4]
 800af80:	6978      	ldr	r0, [r7, #20]
 800af82:	f7ff fe51 	bl	800ac28 <OsMuxParaCheck>
 800af86:	6138      	str	r0, [r7, #16]
    if (ret != LOS_OK) {
 800af88:	693b      	ldr	r3, [r7, #16]
 800af8a:	2b00      	cmp	r3, #0
 800af8c:	d13c      	bne.n	800b008 <LOS_MuxPend+0x148>
        goto OUT_UNLOCK;
    }

    if (muxPended->muxCount == 0) {
 800af8e:	697b      	ldr	r3, [r7, #20]
 800af90:	899b      	ldrh	r3, [r3, #12]
 800af92:	2b00      	cmp	r3, #0
 800af94:	d10f      	bne.n	800afb6 <LOS_MuxPend+0xf6>
        OsMuxDlockNodeInsertHook(runTask->taskId, muxPended);
 800af96:	69bb      	ldr	r3, [r7, #24]
 800af98:	695b      	ldr	r3, [r3, #20]
 800af9a:	6979      	ldr	r1, [r7, #20]
 800af9c:	4618      	mov	r0, r3
 800af9e:	f7ff fc50 	bl	800a842 <OsMuxDlockNodeInsertHook>
        muxPended->muxCount++;
 800afa2:	697b      	ldr	r3, [r7, #20]
 800afa4:	899b      	ldrh	r3, [r3, #12]
 800afa6:	3301      	adds	r3, #1
 800afa8:	b29a      	uxth	r2, r3
 800afaa:	697b      	ldr	r3, [r7, #20]
 800afac:	819a      	strh	r2, [r3, #12]
        muxPended->owner = runTask;
 800afae:	697b      	ldr	r3, [r7, #20]
 800afb0:	69ba      	ldr	r2, [r7, #24]
 800afb2:	609a      	str	r2, [r3, #8]
        goto OUT_UNLOCK;
 800afb4:	e029      	b.n	800b00a <LOS_MuxPend+0x14a>
    }

    if (muxPended->owner == runTask) {
 800afb6:	697b      	ldr	r3, [r7, #20]
 800afb8:	689b      	ldr	r3, [r3, #8]
 800afba:	69ba      	ldr	r2, [r7, #24]
 800afbc:	429a      	cmp	r2, r3
 800afbe:	d106      	bne.n	800afce <LOS_MuxPend+0x10e>
        muxPended->muxCount++;
 800afc0:	697b      	ldr	r3, [r7, #20]
 800afc2:	899b      	ldrh	r3, [r3, #12]
 800afc4:	3301      	adds	r3, #1
 800afc6:	b29a      	uxth	r2, r3
 800afc8:	697b      	ldr	r3, [r7, #20]
 800afca:	819a      	strh	r2, [r3, #12]
        goto OUT_UNLOCK;
 800afcc:	e01d      	b.n	800b00a <LOS_MuxPend+0x14a>
    }

    if (!timeout) {
 800afce:	683b      	ldr	r3, [r7, #0]
 800afd0:	2b00      	cmp	r3, #0
 800afd2:	d102      	bne.n	800afda <LOS_MuxPend+0x11a>
        ret = LOS_ERRNO_MUX_UNAVAILABLE;
 800afd4:	4b21      	ldr	r3, [pc, #132]	; (800b05c <LOS_MuxPend+0x19c>)
 800afd6:	613b      	str	r3, [r7, #16]
        goto OUT_UNLOCK;
 800afd8:	e017      	b.n	800b00a <LOS_MuxPend+0x14a>
    }

    if (!OsPreemptableInSched()) {
 800afda:	f7ff fbe5 	bl	800a7a8 <OsPreemptableInSched>
 800afde:	4603      	mov	r3, r0
 800afe0:	2b00      	cmp	r3, #0
 800afe2:	d104      	bne.n	800afee <LOS_MuxPend+0x12e>
        ret = LOS_ERRNO_MUX_PEND_IN_LOCK;
 800afe4:	4b1e      	ldr	r3, [pc, #120]	; (800b060 <LOS_MuxPend+0x1a0>)
 800afe6:	613b      	str	r3, [r7, #16]
        OsBackTrace();
 800afe8:	f7f9 f99c 	bl	8004324 <LOS_BackTrace>
        goto OUT_UNLOCK;
 800afec:	e00d      	b.n	800b00a <LOS_MuxPend+0x14a>
    }

    OsMuxBitmapSet(runTask, (MuxBaseCB *)muxPended);
 800afee:	6979      	ldr	r1, [r7, #20]
 800aff0:	69b8      	ldr	r0, [r7, #24]
 800aff2:	f7ff fe4b 	bl	800ac8c <OsMuxBitmapSet>
    ret = OsMuxPendOp(runTask, (MuxBaseCB *)muxPended, timeout, &intSave);
 800aff6:	f107 030c 	add.w	r3, r7, #12
 800affa:	683a      	ldr	r2, [r7, #0]
 800affc:	6979      	ldr	r1, [r7, #20]
 800affe:	69b8      	ldr	r0, [r7, #24]
 800b000:	f7ff ff16 	bl	800ae30 <OsMuxPendOp>
 800b004:	6138      	str	r0, [r7, #16]
 800b006:	e000      	b.n	800b00a <LOS_MuxPend+0x14a>
        goto OUT_UNLOCK;
 800b008:	bf00      	nop

OUT_UNLOCK:
    SCHEDULER_UNLOCK(intSave);
 800b00a:	68fb      	ldr	r3, [r7, #12]
 800b00c:	4619      	mov	r1, r3
 800b00e:	4812      	ldr	r0, [pc, #72]	; (800b058 <LOS_MuxPend+0x198>)
 800b010:	f7ff fc04 	bl	800a81c <LOS_SpinUnlockRestore>
    if (ret == LOS_ERRNO_MUX_PEND_IN_LOCK) {
 800b014:	693b      	ldr	r3, [r7, #16]
 800b016:	4a12      	ldr	r2, [pc, #72]	; (800b060 <LOS_MuxPend+0x1a0>)
 800b018:	4293      	cmp	r3, r2
 800b01a:	d105      	bne.n	800b028 <LOS_MuxPend+0x168>
        PRINT_ERR("!!!LOS_ERRNO_MUX_PEND_IN_LOCK!!!\n");
 800b01c:	4811      	ldr	r0, [pc, #68]	; (800b064 <LOS_MuxPend+0x1a4>)
 800b01e:	f7f9 fb55 	bl	80046cc <dprintf>
 800b022:	4811      	ldr	r0, [pc, #68]	; (800b068 <LOS_MuxPend+0x1a8>)
 800b024:	f7f9 fb52 	bl	80046cc <dprintf>
    }
    return ret;
 800b028:	693b      	ldr	r3, [r7, #16]
}
 800b02a:	4a05      	ldr	r2, [pc, #20]	; (800b040 <LOS_MuxPend+0x180>)
 800b02c:	6811      	ldr	r1, [r2, #0]
 800b02e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b030:	4051      	eors	r1, r2
 800b032:	d001      	beq.n	800b038 <LOS_MuxPend+0x178>
 800b034:	f7f9 f9d8 	bl	80043e8 <__stack_chk_fail>
 800b038:	4618      	mov	r0, r3
 800b03a:	373c      	adds	r7, #60	; 0x3c
 800b03c:	46bd      	mov	sp, r7
 800b03e:	bd90      	pop	{r4, r7, pc}
 800b040:	08021580 	.word	0x08021580
 800b044:	02001d01 	.word	0x02001d01
 800b048:	a1b2c3f8 	.word	0xa1b2c3f8
 800b04c:	08021538 	.word	0x08021538
 800b050:	200021c8 	.word	0x200021c8
 800b054:	2000075c 	.word	0x2000075c
 800b058:	20000764 	.word	0x20000764
 800b05c:	02001d04 	.word	0x02001d04
 800b060:	02001d06 	.word	0x02001d06
 800b064:	08021554 	.word	0x08021554
 800b068:	0802155c 	.word	0x0802155c

0800b06c <OsMuxPostOpSub>:

LITE_OS_SEC_TEXT STATIC VOID OsMuxPostOpSub(LosTaskCB *runTask, MuxBaseCB *muxPosted)
{
 800b06c:	b580      	push	{r7, lr}
 800b06e:	b084      	sub	sp, #16
 800b070:	af00      	add	r7, sp, #0
 800b072:	6078      	str	r0, [r7, #4]
 800b074:	6039      	str	r1, [r7, #0]
    LosTaskCB *pendedTask = NULL;
 800b076:	2300      	movs	r3, #0
 800b078:	60fb      	str	r3, [r7, #12]
    UINT16 bitMapPri;

    if (!LOS_ListEmpty(&muxPosted->muxList)) {
 800b07a:	683b      	ldr	r3, [r7, #0]
 800b07c:	4618      	mov	r0, r3
 800b07e:	f7ff fb4a 	bl	800a716 <LOS_ListEmpty>
 800b082:	4603      	mov	r3, r0
 800b084:	2b00      	cmp	r3, #0
 800b086:	d123      	bne.n	800b0d0 <OsMuxPostOpSub+0x64>
        bitMapPri = LOS_HighBitGet(runTask->priBitMap);
 800b088:	687b      	ldr	r3, [r7, #4]
 800b08a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800b08c:	4618      	mov	r0, r3
 800b08e:	f000 f98c 	bl	800b3aa <LOS_HighBitGet>
 800b092:	4603      	mov	r3, r0
 800b094:	817b      	strh	r3, [r7, #10]
        LOS_DL_LIST_FOR_EACH_ENTRY(pendedTask, (&muxPosted->muxList), LosTaskCB, pendList) {
 800b096:	683b      	ldr	r3, [r7, #0]
 800b098:	685b      	ldr	r3, [r3, #4]
 800b09a:	3b40      	subs	r3, #64	; 0x40
 800b09c:	60fb      	str	r3, [r7, #12]
 800b09e:	e011      	b.n	800b0c4 <OsMuxPostOpSub+0x58>
            if (bitMapPri != pendedTask->priority) {
 800b0a0:	68fb      	ldr	r3, [r7, #12]
 800b0a2:	88db      	ldrh	r3, [r3, #6]
 800b0a4:	897a      	ldrh	r2, [r7, #10]
 800b0a6:	429a      	cmp	r2, r3
 800b0a8:	d008      	beq.n	800b0bc <OsMuxPostOpSub+0x50>
                LOS_BitmapClr(&runTask->priBitMap, pendedTask->priority);
 800b0aa:	687b      	ldr	r3, [r7, #4]
 800b0ac:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 800b0b0:	68fb      	ldr	r3, [r7, #12]
 800b0b2:	88db      	ldrh	r3, [r3, #6]
 800b0b4:	4619      	mov	r1, r3
 800b0b6:	4610      	mov	r0, r2
 800b0b8:	f000 f95b 	bl	800b372 <LOS_BitmapClr>
        LOS_DL_LIST_FOR_EACH_ENTRY(pendedTask, (&muxPosted->muxList), LosTaskCB, pendList) {
 800b0bc:	68fb      	ldr	r3, [r7, #12]
 800b0be:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800b0c0:	3b40      	subs	r3, #64	; 0x40
 800b0c2:	60fb      	str	r3, [r7, #12]
 800b0c4:	68fb      	ldr	r3, [r7, #12]
 800b0c6:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800b0ca:	683b      	ldr	r3, [r7, #0]
 800b0cc:	429a      	cmp	r2, r3
 800b0ce:	d1e7      	bne.n	800b0a0 <OsMuxPostOpSub+0x34>
            }
        }
    }
    bitMapPri = LOS_LowBitGet(runTask->priBitMap);
 800b0d0:	687b      	ldr	r3, [r7, #4]
 800b0d2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800b0d4:	4618      	mov	r0, r3
 800b0d6:	f000 f97e 	bl	800b3d6 <LOS_LowBitGet>
 800b0da:	4603      	mov	r3, r0
 800b0dc:	817b      	strh	r3, [r7, #10]
    LOS_BitmapClr(&runTask->priBitMap, bitMapPri);
 800b0de:	687b      	ldr	r3, [r7, #4]
 800b0e0:	336c      	adds	r3, #108	; 0x6c
 800b0e2:	897a      	ldrh	r2, [r7, #10]
 800b0e4:	4611      	mov	r1, r2
 800b0e6:	4618      	mov	r0, r3
 800b0e8:	f000 f943 	bl	800b372 <LOS_BitmapClr>
    OsTaskPriModify(muxPosted->owner, bitMapPri);
 800b0ec:	683b      	ldr	r3, [r7, #0]
 800b0ee:	689b      	ldr	r3, [r3, #8]
 800b0f0:	897a      	ldrh	r2, [r7, #10]
 800b0f2:	4611      	mov	r1, r2
 800b0f4:	4618      	mov	r0, r3
 800b0f6:	f7f7 fd4b 	bl	8002b90 <OsTaskPriModify>
}
 800b0fa:	bf00      	nop
 800b0fc:	3710      	adds	r7, #16
 800b0fe:	46bd      	mov	sp, r7
 800b100:	bd80      	pop	{r7, pc}

0800b102 <OsMuxPostOp>:

LITE_OS_SEC_TEXT UINT32 OsMuxPostOp(LosTaskCB *runTask, MuxBaseCB *muxPosted)
{
 800b102:	b580      	push	{r7, lr}
 800b104:	b084      	sub	sp, #16
 800b106:	af00      	add	r7, sp, #0
 800b108:	6078      	str	r0, [r7, #4]
 800b10a:	6039      	str	r1, [r7, #0]
    LosTaskCB *resumedTask = NULL;
 800b10c:	2300      	movs	r3, #0
 800b10e:	60fb      	str	r3, [r7, #12]

    if (LOS_ListEmpty(&muxPosted->muxList)) {
 800b110:	683b      	ldr	r3, [r7, #0]
 800b112:	4618      	mov	r0, r3
 800b114:	f7ff faff 	bl	800a716 <LOS_ListEmpty>
 800b118:	4603      	mov	r3, r0
 800b11a:	2b00      	cmp	r3, #0
 800b11c:	d00a      	beq.n	800b134 <OsMuxPostOp+0x32>
        muxPosted->owner = NULL;
 800b11e:	683b      	ldr	r3, [r7, #0]
 800b120:	2200      	movs	r2, #0
 800b122:	609a      	str	r2, [r3, #8]
        OsMuxDlockNodeDeleteHook(runTask->taskId, muxPosted);
 800b124:	687b      	ldr	r3, [r7, #4]
 800b126:	695b      	ldr	r3, [r3, #20]
 800b128:	6839      	ldr	r1, [r7, #0]
 800b12a:	4618      	mov	r0, r3
 800b12c:	f7ff fb96 	bl	800a85c <OsMuxDlockNodeDeleteHook>
        return MUX_NO_SCHEDULE;
 800b130:	2302      	movs	r3, #2
 800b132:	e040      	b.n	800b1b6 <OsMuxPostOp+0xb4>
    }

    resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&(muxPosted->muxList)));
 800b134:	683b      	ldr	r3, [r7, #0]
 800b136:	685b      	ldr	r3, [r3, #4]
 800b138:	3b40      	subs	r3, #64	; 0x40
 800b13a:	60fb      	str	r3, [r7, #12]
#ifdef LOSCFG_MUTEX_WAITMODE_PRIO
    if (resumedTask->priority > runTask->priority) {
 800b13c:	68fb      	ldr	r3, [r7, #12]
 800b13e:	88da      	ldrh	r2, [r3, #6]
 800b140:	687b      	ldr	r3, [r7, #4]
 800b142:	88db      	ldrh	r3, [r3, #6]
 800b144:	429a      	cmp	r2, r3
 800b146:	d914      	bls.n	800b172 <OsMuxPostOp+0x70>
        if (LOS_HighBitGet(runTask->priBitMap) != resumedTask->priority) {
 800b148:	687b      	ldr	r3, [r7, #4]
 800b14a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800b14c:	4618      	mov	r0, r3
 800b14e:	f000 f92c 	bl	800b3aa <LOS_HighBitGet>
 800b152:	4603      	mov	r3, r0
 800b154:	461a      	mov	r2, r3
 800b156:	68fb      	ldr	r3, [r7, #12]
 800b158:	88db      	ldrh	r3, [r3, #6]
 800b15a:	429a      	cmp	r2, r3
 800b15c:	d011      	beq.n	800b182 <OsMuxPostOp+0x80>
            LOS_BitmapClr(&runTask->priBitMap, resumedTask->priority);
 800b15e:	687b      	ldr	r3, [r7, #4]
 800b160:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 800b164:	68fb      	ldr	r3, [r7, #12]
 800b166:	88db      	ldrh	r3, [r3, #6]
 800b168:	4619      	mov	r1, r3
 800b16a:	4610      	mov	r0, r2
 800b16c:	f000 f901 	bl	800b372 <LOS_BitmapClr>
 800b170:	e007      	b.n	800b182 <OsMuxPostOp+0x80>
        }
    } else if (runTask->priBitMap != 0) {
 800b172:	687b      	ldr	r3, [r7, #4]
 800b174:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800b176:	2b00      	cmp	r3, #0
 800b178:	d003      	beq.n	800b182 <OsMuxPostOp+0x80>
        OsMuxPostOpSub(runTask, muxPosted);
 800b17a:	6839      	ldr	r1, [r7, #0]
 800b17c:	6878      	ldr	r0, [r7, #4]
 800b17e:	f7ff ff75 	bl	800b06c <OsMuxPostOpSub>
    if (runTask->priBitMap != 0) {
        OsMuxPostOpSub(runTask, muxPosted);
    }
#endif

    muxPosted->muxCount = 1;
 800b182:	683b      	ldr	r3, [r7, #0]
 800b184:	2201      	movs	r2, #1
 800b186:	819a      	strh	r2, [r3, #12]
    muxPosted->owner = resumedTask;
 800b188:	683b      	ldr	r3, [r7, #0]
 800b18a:	68fa      	ldr	r2, [r7, #12]
 800b18c:	609a      	str	r2, [r3, #8]
    resumedTask->taskMux = NULL;
 800b18e:	68fb      	ldr	r3, [r7, #12]
 800b190:	2200      	movs	r2, #0
 800b192:	629a      	str	r2, [r3, #40]	; 0x28
    OsMuxDlockNodeDeleteHook(runTask->taskId, muxPosted);
 800b194:	687b      	ldr	r3, [r7, #4]
 800b196:	695b      	ldr	r3, [r3, #20]
 800b198:	6839      	ldr	r1, [r7, #0]
 800b19a:	4618      	mov	r0, r3
 800b19c:	f7ff fb5e 	bl	800a85c <OsMuxDlockNodeDeleteHook>
    OsMuxDlockNodeInsertHook(resumedTask->taskId, muxPosted);
 800b1a0:	68fb      	ldr	r3, [r7, #12]
 800b1a2:	695b      	ldr	r3, [r3, #20]
 800b1a4:	6839      	ldr	r1, [r7, #0]
 800b1a6:	4618      	mov	r0, r3
 800b1a8:	f7ff fb4b 	bl	800a842 <OsMuxDlockNodeInsertHook>

    OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
 800b1ac:	2108      	movs	r1, #8
 800b1ae:	68f8      	ldr	r0, [r7, #12]
 800b1b0:	f7f8 fe12 	bl	8003dd8 <OsTaskWake>

    return MUX_SCHEDULE;
 800b1b4:	2301      	movs	r3, #1
}
 800b1b6:	4618      	mov	r0, r3
 800b1b8:	3710      	adds	r7, #16
 800b1ba:	46bd      	mov	sp, r7
 800b1bc:	bd80      	pop	{r7, pc}
	...

0800b1c0 <LOS_MuxPost>:

LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 muxHandle)
{
 800b1c0:	b590      	push	{r4, r7, lr}
 800b1c2:	b08f      	sub	sp, #60	; 0x3c
 800b1c4:	af02      	add	r7, sp, #8
 800b1c6:	6078      	str	r0, [r7, #4]
 800b1c8:	4b55      	ldr	r3, [pc, #340]	; (800b320 <LOS_MuxPost+0x160>)
 800b1ca:	681b      	ldr	r3, [r3, #0]
 800b1cc:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b1ce:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    LosTaskCB *runTask = NULL;
 800b1d2:	2300      	movs	r3, #0
 800b1d4:	60fb      	str	r3, [r7, #12]
    LosMuxCB *muxPosted = GET_MUX(muxHandle);
 800b1d6:	4b53      	ldr	r3, [pc, #332]	; (800b324 <LOS_MuxPost+0x164>)
 800b1d8:	6819      	ldr	r1, [r3, #0]
 800b1da:	687b      	ldr	r3, [r7, #4]
 800b1dc:	b29a      	uxth	r2, r3
 800b1de:	4613      	mov	r3, r2
 800b1e0:	009b      	lsls	r3, r3, #2
 800b1e2:	4413      	add	r3, r2
 800b1e4:	009b      	lsls	r3, r3, #2
 800b1e6:	440b      	add	r3, r1
 800b1e8:	613b      	str	r3, [r7, #16]
    UINT32 intSave;

    if (GET_MUX_INDEX(muxHandle) >= (UINT32)KERNEL_MUX_LIMIT) {
 800b1ea:	687b      	ldr	r3, [r7, #4]
 800b1ec:	b29b      	uxth	r3, r3
 800b1ee:	2b13      	cmp	r3, #19
 800b1f0:	d909      	bls.n	800b206 <LOS_MuxPost+0x46>
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
 800b1f2:	2300      	movs	r3, #0
 800b1f4:	9300      	str	r3, [sp, #0]
 800b1f6:	2300      	movs	r3, #0
 800b1f8:	4a4b      	ldr	r2, [pc, #300]	; (800b328 <LOS_MuxPost+0x168>)
 800b1fa:	494c      	ldr	r1, [pc, #304]	; (800b32c <LOS_MuxPost+0x16c>)
 800b1fc:	484c      	ldr	r0, [pc, #304]	; (800b330 <LOS_MuxPost+0x170>)
 800b1fe:	f7fe f9cf 	bl	80095a0 <LOS_ErrHandle>
 800b202:	4b49      	ldr	r3, [pc, #292]	; (800b328 <LOS_MuxPost+0x168>)
 800b204:	e081      	b.n	800b30a <LOS_MuxPost+0x14a>
    }

    LOS_TRACE(MUX_POST, muxHandle, muxPosted->muxCount,
 800b206:	2300      	movs	r3, #0
 800b208:	61fb      	str	r3, [r7, #28]
 800b20a:	687b      	ldr	r3, [r7, #4]
 800b20c:	623b      	str	r3, [r7, #32]
 800b20e:	693b      	ldr	r3, [r7, #16]
 800b210:	899b      	ldrh	r3, [r3, #12]
 800b212:	627b      	str	r3, [r7, #36]	; 0x24
 800b214:	693b      	ldr	r3, [r7, #16]
 800b216:	689b      	ldr	r3, [r3, #8]
 800b218:	2b00      	cmp	r3, #0
 800b21a:	d003      	beq.n	800b224 <LOS_MuxPost+0x64>
 800b21c:	693b      	ldr	r3, [r7, #16]
 800b21e:	689b      	ldr	r3, [r3, #8]
 800b220:	695b      	ldr	r3, [r3, #20]
 800b222:	e001      	b.n	800b228 <LOS_MuxPost+0x68>
 800b224:	f04f 33ff 	mov.w	r3, #4294967295
 800b228:	62bb      	str	r3, [r7, #40]	; 0x28
 800b22a:	2304      	movs	r3, #4
 800b22c:	617b      	str	r3, [r7, #20]
 800b22e:	697b      	ldr	r3, [r7, #20]
 800b230:	2b01      	cmp	r3, #1
 800b232:	d916      	bls.n	800b262 <LOS_MuxPost+0xa2>
 800b234:	4b3f      	ldr	r3, [pc, #252]	; (800b334 <LOS_MuxPost+0x174>)
 800b236:	681b      	ldr	r3, [r3, #0]
 800b238:	2b00      	cmp	r3, #0
 800b23a:	d012      	beq.n	800b262 <LOS_MuxPost+0xa2>
 800b23c:	4b3d      	ldr	r3, [pc, #244]	; (800b334 <LOS_MuxPost+0x174>)
 800b23e:	681c      	ldr	r4, [r3, #0]
 800b240:	6a39      	ldr	r1, [r7, #32]
 800b242:	697b      	ldr	r3, [r7, #20]
 800b244:	2b02      	cmp	r3, #2
 800b246:	d904      	bls.n	800b252 <LOS_MuxPost+0x92>
 800b248:	f107 031c 	add.w	r3, r7, #28
 800b24c:	f103 0208 	add.w	r2, r3, #8
 800b250:	e000      	b.n	800b254 <LOS_MuxPost+0x94>
 800b252:	2200      	movs	r2, #0
 800b254:	697b      	ldr	r3, [r7, #20]
 800b256:	b29b      	uxth	r3, r3
 800b258:	3b02      	subs	r3, #2
 800b25a:	b29b      	uxth	r3, r3
 800b25c:	f241 0003 	movw	r0, #4099	; 0x1003
 800b260:	47a0      	blx	r4
        ((muxPosted->owner == NULL) ? 0xFFFFFFFF : muxPosted->owner->taskId));

    SCHEDULER_LOCK(intSave);
 800b262:	f107 0308 	add.w	r3, r7, #8
 800b266:	4619      	mov	r1, r3
 800b268:	4833      	ldr	r0, [pc, #204]	; (800b338 <LOS_MuxPost+0x178>)
 800b26a:	f7ff fac9 	bl	800a800 <LOS_SpinLockSave>

    ret = OsMuxParaCheck(muxPosted, muxHandle);
 800b26e:	6879      	ldr	r1, [r7, #4]
 800b270:	6938      	ldr	r0, [r7, #16]
 800b272:	f7ff fcd9 	bl	800ac28 <OsMuxParaCheck>
 800b276:	61b8      	str	r0, [r7, #24]
    if (ret != LOS_OK) {
 800b278:	69bb      	ldr	r3, [r7, #24]
 800b27a:	2b00      	cmp	r3, #0
 800b27c:	d006      	beq.n	800b28c <LOS_MuxPost+0xcc>
        SCHEDULER_UNLOCK(intSave);
 800b27e:	68bb      	ldr	r3, [r7, #8]
 800b280:	4619      	mov	r1, r3
 800b282:	482d      	ldr	r0, [pc, #180]	; (800b338 <LOS_MuxPost+0x178>)
 800b284:	f7ff faca 	bl	800a81c <LOS_SpinUnlockRestore>
        return ret;
 800b288:	69bb      	ldr	r3, [r7, #24]
 800b28a:	e03e      	b.n	800b30a <LOS_MuxPost+0x14a>
    }

    runTask = OsCurrTaskGet();
 800b28c:	f7ff fad2 	bl	800a834 <OsCurrTaskGet>
 800b290:	60f8      	str	r0, [r7, #12]
    if ((muxPosted->muxCount == 0) || (muxPosted->owner != runTask)) {
 800b292:	693b      	ldr	r3, [r7, #16]
 800b294:	899b      	ldrh	r3, [r3, #12]
 800b296:	2b00      	cmp	r3, #0
 800b298:	d004      	beq.n	800b2a4 <LOS_MuxPost+0xe4>
 800b29a:	693b      	ldr	r3, [r7, #16]
 800b29c:	689b      	ldr	r3, [r3, #8]
 800b29e:	68fa      	ldr	r2, [r7, #12]
 800b2a0:	429a      	cmp	r2, r3
 800b2a2:	d00e      	beq.n	800b2c2 <LOS_MuxPost+0x102>
        SCHEDULER_UNLOCK(intSave);
 800b2a4:	68bb      	ldr	r3, [r7, #8]
 800b2a6:	4619      	mov	r1, r3
 800b2a8:	4823      	ldr	r0, [pc, #140]	; (800b338 <LOS_MuxPost+0x178>)
 800b2aa:	f7ff fab7 	bl	800a81c <LOS_SpinUnlockRestore>
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
 800b2ae:	2300      	movs	r3, #0
 800b2b0:	9300      	str	r3, [sp, #0]
 800b2b2:	2300      	movs	r3, #0
 800b2b4:	4a1c      	ldr	r2, [pc, #112]	; (800b328 <LOS_MuxPost+0x168>)
 800b2b6:	491d      	ldr	r1, [pc, #116]	; (800b32c <LOS_MuxPost+0x16c>)
 800b2b8:	481d      	ldr	r0, [pc, #116]	; (800b330 <LOS_MuxPost+0x170>)
 800b2ba:	f7fe f971 	bl	80095a0 <LOS_ErrHandle>
 800b2be:	4b1a      	ldr	r3, [pc, #104]	; (800b328 <LOS_MuxPost+0x168>)
 800b2c0:	e023      	b.n	800b30a <LOS_MuxPost+0x14a>
    }

    if (--muxPosted->muxCount != 0) {
 800b2c2:	693b      	ldr	r3, [r7, #16]
 800b2c4:	899b      	ldrh	r3, [r3, #12]
 800b2c6:	3b01      	subs	r3, #1
 800b2c8:	b29a      	uxth	r2, r3
 800b2ca:	693b      	ldr	r3, [r7, #16]
 800b2cc:	819a      	strh	r2, [r3, #12]
 800b2ce:	693b      	ldr	r3, [r7, #16]
 800b2d0:	899b      	ldrh	r3, [r3, #12]
 800b2d2:	2b00      	cmp	r3, #0
 800b2d4:	d006      	beq.n	800b2e4 <LOS_MuxPost+0x124>
        SCHEDULER_UNLOCK(intSave);
 800b2d6:	68bb      	ldr	r3, [r7, #8]
 800b2d8:	4619      	mov	r1, r3
 800b2da:	4817      	ldr	r0, [pc, #92]	; (800b338 <LOS_MuxPost+0x178>)
 800b2dc:	f7ff fa9e 	bl	800a81c <LOS_SpinUnlockRestore>
        return LOS_OK;
 800b2e0:	2300      	movs	r3, #0
 800b2e2:	e012      	b.n	800b30a <LOS_MuxPost+0x14a>
    }

    ret = OsMuxPostOp(runTask, (MuxBaseCB *)muxPosted);
 800b2e4:	6939      	ldr	r1, [r7, #16]
 800b2e6:	68f8      	ldr	r0, [r7, #12]
 800b2e8:	f7ff ff0b 	bl	800b102 <OsMuxPostOp>
 800b2ec:	61b8      	str	r0, [r7, #24]
    SCHEDULER_UNLOCK(intSave);
 800b2ee:	68bb      	ldr	r3, [r7, #8]
 800b2f0:	4619      	mov	r1, r3
 800b2f2:	4811      	ldr	r0, [pc, #68]	; (800b338 <LOS_MuxPost+0x178>)
 800b2f4:	f7ff fa92 	bl	800a81c <LOS_SpinUnlockRestore>
    if (ret == MUX_SCHEDULE) {
 800b2f8:	69bb      	ldr	r3, [r7, #24]
 800b2fa:	2b01      	cmp	r3, #1
 800b2fc:	d104      	bne.n	800b308 <LOS_MuxPost+0x148>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 800b2fe:	2001      	movs	r0, #1
 800b300:	f7ff fade 	bl	800a8c0 <LOS_MpSchedule>
        LOS_Schedule();
 800b304:	f7ff fa6c 	bl	800a7e0 <LOS_Schedule>
    }

    return LOS_OK;
 800b308:	2300      	movs	r3, #0
}
 800b30a:	4a05      	ldr	r2, [pc, #20]	; (800b320 <LOS_MuxPost+0x160>)
 800b30c:	6811      	ldr	r1, [r2, #0]
 800b30e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b310:	4051      	eors	r1, r2
 800b312:	d001      	beq.n	800b318 <LOS_MuxPost+0x158>
 800b314:	f7f9 f868 	bl	80043e8 <__stack_chk_fail>
 800b318:	4618      	mov	r0, r3
 800b31a:	3734      	adds	r7, #52	; 0x34
 800b31c:	46bd      	mov	sp, r7
 800b31e:	bd90      	pop	{r4, r7, pc}
 800b320:	08021584 	.word	0x08021584
 800b324:	200021c8 	.word	0x200021c8
 800b328:	02001d01 	.word	0x02001d01
 800b32c:	a1b2c3f8 	.word	0xa1b2c3f8
 800b330:	08021538 	.word	0x08021538
 800b334:	2000075c 	.word	0x2000075c
 800b338:	20000764 	.word	0x20000764

0800b33c <LOS_BitmapSet>:
#endif /* __cplusplus */

#define OS_BITMAP_MASK 0x1FU

VOID LOS_BitmapSet(UINT32 *bitmap, UINT16 pos)
{
 800b33c:	b480      	push	{r7}
 800b33e:	b083      	sub	sp, #12
 800b340:	af00      	add	r7, sp, #0
 800b342:	6078      	str	r0, [r7, #4]
 800b344:	460b      	mov	r3, r1
 800b346:	807b      	strh	r3, [r7, #2]
    if (bitmap == NULL) {
 800b348:	687b      	ldr	r3, [r7, #4]
 800b34a:	2b00      	cmp	r3, #0
 800b34c:	d00b      	beq.n	800b366 <LOS_BitmapSet+0x2a>
        return;
    }

    *bitmap |= 1U << (pos & OS_BITMAP_MASK);
 800b34e:	687b      	ldr	r3, [r7, #4]
 800b350:	681a      	ldr	r2, [r3, #0]
 800b352:	887b      	ldrh	r3, [r7, #2]
 800b354:	f003 031f 	and.w	r3, r3, #31
 800b358:	2101      	movs	r1, #1
 800b35a:	fa01 f303 	lsl.w	r3, r1, r3
 800b35e:	431a      	orrs	r2, r3
 800b360:	687b      	ldr	r3, [r7, #4]
 800b362:	601a      	str	r2, [r3, #0]
 800b364:	e000      	b.n	800b368 <LOS_BitmapSet+0x2c>
        return;
 800b366:	bf00      	nop
}
 800b368:	370c      	adds	r7, #12
 800b36a:	46bd      	mov	sp, r7
 800b36c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b370:	4770      	bx	lr

0800b372 <LOS_BitmapClr>:

VOID LOS_BitmapClr(UINT32 *bitmap, UINT16 pos)
{
 800b372:	b480      	push	{r7}
 800b374:	b083      	sub	sp, #12
 800b376:	af00      	add	r7, sp, #0
 800b378:	6078      	str	r0, [r7, #4]
 800b37a:	460b      	mov	r3, r1
 800b37c:	807b      	strh	r3, [r7, #2]
    if (bitmap == NULL) {
 800b37e:	687b      	ldr	r3, [r7, #4]
 800b380:	2b00      	cmp	r3, #0
 800b382:	d00c      	beq.n	800b39e <LOS_BitmapClr+0x2c>
        return;
    }

    *bitmap &= ~(1U << (pos & OS_BITMAP_MASK));
 800b384:	687b      	ldr	r3, [r7, #4]
 800b386:	681a      	ldr	r2, [r3, #0]
 800b388:	887b      	ldrh	r3, [r7, #2]
 800b38a:	f003 031f 	and.w	r3, r3, #31
 800b38e:	2101      	movs	r1, #1
 800b390:	fa01 f303 	lsl.w	r3, r1, r3
 800b394:	43db      	mvns	r3, r3
 800b396:	401a      	ands	r2, r3
 800b398:	687b      	ldr	r3, [r7, #4]
 800b39a:	601a      	str	r2, [r3, #0]
 800b39c:	e000      	b.n	800b3a0 <LOS_BitmapClr+0x2e>
        return;
 800b39e:	bf00      	nop
}
 800b3a0:	370c      	adds	r7, #12
 800b3a2:	46bd      	mov	sp, r7
 800b3a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3a8:	4770      	bx	lr

0800b3aa <LOS_HighBitGet>:

UINT16 LOS_HighBitGet(UINT32 bitmap)
{
 800b3aa:	b480      	push	{r7}
 800b3ac:	b083      	sub	sp, #12
 800b3ae:	af00      	add	r7, sp, #0
 800b3b0:	6078      	str	r0, [r7, #4]
    if (bitmap == 0) {
 800b3b2:	687b      	ldr	r3, [r7, #4]
 800b3b4:	2b00      	cmp	r3, #0
 800b3b6:	d101      	bne.n	800b3bc <LOS_HighBitGet+0x12>
        return LOS_INVALID_BIT_INDEX;
 800b3b8:	2320      	movs	r3, #32
 800b3ba:	e006      	b.n	800b3ca <LOS_HighBitGet+0x20>
    }

    return (OS_BITMAP_MASK - CLZ(bitmap));
 800b3bc:	687b      	ldr	r3, [r7, #4]
 800b3be:	fab3 f383 	clz	r3, r3
 800b3c2:	b29b      	uxth	r3, r3
 800b3c4:	f1c3 031f 	rsb	r3, r3, #31
 800b3c8:	b29b      	uxth	r3, r3
}
 800b3ca:	4618      	mov	r0, r3
 800b3cc:	370c      	adds	r7, #12
 800b3ce:	46bd      	mov	sp, r7
 800b3d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3d4:	4770      	bx	lr

0800b3d6 <LOS_LowBitGet>:

UINT16 LOS_LowBitGet(UINT32 bitmap)
{
 800b3d6:	b480      	push	{r7}
 800b3d8:	b083      	sub	sp, #12
 800b3da:	af00      	add	r7, sp, #0
 800b3dc:	6078      	str	r0, [r7, #4]
    if (bitmap == 0) {
 800b3de:	687b      	ldr	r3, [r7, #4]
 800b3e0:	2b00      	cmp	r3, #0
 800b3e2:	d101      	bne.n	800b3e8 <LOS_LowBitGet+0x12>
        return LOS_INVALID_BIT_INDEX;
 800b3e4:	2320      	movs	r3, #32
 800b3e6:	e005      	b.n	800b3f4 <LOS_LowBitGet+0x1e>
    }

    return CTZ(bitmap);
 800b3e8:	687b      	ldr	r3, [r7, #4]
 800b3ea:	fa93 f3a3 	rbit	r3, r3
 800b3ee:	fab3 f383 	clz	r3, r3
 800b3f2:	b29b      	uxth	r3, r3
}
 800b3f4:	4618      	mov	r0, r3
 800b3f6:	370c      	adds	r7, #12
 800b3f8:	46bd      	mov	sp, r7
 800b3fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3fe:	4770      	bx	lr

0800b400 <ArchCurrCpuid>:
{
 800b400:	b480      	push	{r7}
 800b402:	af00      	add	r7, sp, #0
    return 0;
 800b404:	2300      	movs	r3, #0
}
 800b406:	4618      	mov	r0, r3
 800b408:	46bd      	mov	sp, r7
 800b40a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b40e:	4770      	bx	lr

0800b410 <LOS_SpinLock>:
{
 800b410:	b480      	push	{r7}
 800b412:	b083      	sub	sp, #12
 800b414:	af00      	add	r7, sp, #0
 800b416:	6078      	str	r0, [r7, #4]
}
 800b418:	bf00      	nop
 800b41a:	370c      	adds	r7, #12
 800b41c:	46bd      	mov	sp, r7
 800b41e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b422:	4770      	bx	lr

0800b424 <OsGetMainTask>:

/* temp task blocks for booting procedure */
LITE_OS_SEC_BSS STATIC LosTaskCB                g_mainTask[LOSCFG_KERNEL_CORE_NUM];

VOID *OsGetMainTask()
{
 800b424:	b580      	push	{r7, lr}
 800b426:	af00      	add	r7, sp, #0
    return (g_mainTask + ArchCurrCpuid());
 800b428:	f7ff ffea 	bl	800b400 <ArchCurrCpuid>
 800b42c:	4602      	mov	r2, r0
 800b42e:	4613      	mov	r3, r2
 800b430:	009b      	lsls	r3, r3, #2
 800b432:	4413      	add	r3, r2
 800b434:	015b      	lsls	r3, r3, #5
 800b436:	461a      	mov	r2, r3
 800b438:	4b01      	ldr	r3, [pc, #4]	; (800b440 <OsGetMainTask+0x1c>)
 800b43a:	4413      	add	r3, r2
}
 800b43c:	4618      	mov	r0, r3
 800b43e:	bd80      	pop	{r7, pc}
 800b440:	200021d8 	.word	0x200021d8

0800b444 <OsSetMainTask>:

VOID OsSetMainTask()
{
 800b444:	b480      	push	{r7}
 800b446:	b083      	sub	sp, #12
 800b448:	af00      	add	r7, sp, #0
    UINT32 i;
    for (i = 0; i < LOSCFG_KERNEL_CORE_NUM; i++) {
 800b44a:	2300      	movs	r3, #0
 800b44c:	607b      	str	r3, [r7, #4]
 800b44e:	e02a      	b.n	800b4a6 <OsSetMainTask+0x62>
        g_mainTask[i].taskStatus = OS_TASK_STATUS_UNUSED;
 800b450:	491a      	ldr	r1, [pc, #104]	; (800b4bc <OsSetMainTask+0x78>)
 800b452:	687a      	ldr	r2, [r7, #4]
 800b454:	4613      	mov	r3, r2
 800b456:	009b      	lsls	r3, r3, #2
 800b458:	4413      	add	r3, r2
 800b45a:	015b      	lsls	r3, r3, #5
 800b45c:	440b      	add	r3, r1
 800b45e:	3304      	adds	r3, #4
 800b460:	2201      	movs	r2, #1
 800b462:	801a      	strh	r2, [r3, #0]
        g_mainTask[i].taskId = LOSCFG_BASE_CORE_TSK_LIMIT;
 800b464:	4915      	ldr	r1, [pc, #84]	; (800b4bc <OsSetMainTask+0x78>)
 800b466:	687a      	ldr	r2, [r7, #4]
 800b468:	4613      	mov	r3, r2
 800b46a:	009b      	lsls	r3, r3, #2
 800b46c:	4413      	add	r3, r2
 800b46e:	015b      	lsls	r3, r3, #5
 800b470:	440b      	add	r3, r1
 800b472:	3314      	adds	r3, #20
 800b474:	2210      	movs	r2, #16
 800b476:	601a      	str	r2, [r3, #0]
        g_mainTask[i].priority = OS_TASK_PRIORITY_LOWEST + 1;
 800b478:	4910      	ldr	r1, [pc, #64]	; (800b4bc <OsSetMainTask+0x78>)
 800b47a:	687a      	ldr	r2, [r7, #4]
 800b47c:	4613      	mov	r3, r2
 800b47e:	009b      	lsls	r3, r3, #2
 800b480:	4413      	add	r3, r2
 800b482:	015b      	lsls	r3, r3, #5
 800b484:	440b      	add	r3, r1
 800b486:	3306      	adds	r3, #6
 800b488:	2220      	movs	r2, #32
 800b48a:	801a      	strh	r2, [r3, #0]
        g_mainTask[i].taskName = "osMain";
 800b48c:	490b      	ldr	r1, [pc, #44]	; (800b4bc <OsSetMainTask+0x78>)
 800b48e:	687a      	ldr	r2, [r7, #4]
 800b490:	4613      	mov	r3, r2
 800b492:	009b      	lsls	r3, r3, #2
 800b494:	4413      	add	r3, r2
 800b496:	015b      	lsls	r3, r3, #5
 800b498:	440b      	add	r3, r1
 800b49a:	333c      	adds	r3, #60	; 0x3c
 800b49c:	4a08      	ldr	r2, [pc, #32]	; (800b4c0 <OsSetMainTask+0x7c>)
 800b49e:	601a      	str	r2, [r3, #0]
    for (i = 0; i < LOSCFG_KERNEL_CORE_NUM; i++) {
 800b4a0:	687b      	ldr	r3, [r7, #4]
 800b4a2:	3301      	adds	r3, #1
 800b4a4:	607b      	str	r3, [r7, #4]
 800b4a6:	687b      	ldr	r3, [r7, #4]
 800b4a8:	2b00      	cmp	r3, #0
 800b4aa:	d0d1      	beq.n	800b450 <OsSetMainTask+0xc>
#ifdef LOSCFG_KERNEL_SMP_LOCKDEP
        g_mainTask[i].lockDep.lockDepth = 0;
        g_mainTask[i].lockDep.waitLock = NULL;
#endif
    }
}
 800b4ac:	bf00      	nop
 800b4ae:	bf00      	nop
 800b4b0:	370c      	adds	r7, #12
 800b4b2:	46bd      	mov	sp, r7
 800b4b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4b8:	4770      	bx	lr
 800b4ba:	bf00      	nop
 800b4bc:	200021d8 	.word	0x200021d8
 800b4c0:	08021588 	.word	0x08021588

0800b4c4 <OsRegister>:

LITE_OS_SEC_TEXT_INIT STATIC VOID OsRegister(VOID)
{
 800b4c4:	b480      	push	{r7}
 800b4c6:	af00      	add	r7, sp, #0
    g_queueLimit            = LOSCFG_BASE_IPC_QUEUE_LIMIT;
#ifdef LOSCFG_BASE_CORE_TIMESLICE
    g_timeSliceTimeOut      = LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT;
#endif
#endif
    g_tickPerSecond         = LOSCFG_BASE_CORE_TICK_PER_SECOND;
 800b4c8:	4b06      	ldr	r3, [pc, #24]	; (800b4e4 <OsRegister+0x20>)
 800b4ca:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b4ce:	601a      	str	r2, [r3, #0]
    SET_SYS_CLOCK(OS_SYS_CLOCK);
 800b4d0:	4b05      	ldr	r3, [pc, #20]	; (800b4e8 <OsRegister+0x24>)
 800b4d2:	681b      	ldr	r3, [r3, #0]
 800b4d4:	4a05      	ldr	r2, [pc, #20]	; (800b4ec <OsRegister+0x28>)
 800b4d6:	6013      	str	r3, [r2, #0]
    LOS_SET_NX_CFG(false);
#endif
    LOS_SET_DL_NX_HEAP_BASE(LOS_DL_HEAP_BASE);
    LOS_SET_DL_NX_HEAP_SIZE(LOS_DL_HEAP_SIZE);

    return;
 800b4d8:	bf00      	nop
}
 800b4da:	46bd      	mov	sp, r7
 800b4dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4e0:	4770      	bx	lr
 800b4e2:	bf00      	nop
 800b4e4:	200036e4 	.word	0x200036e4
 800b4e8:	20000404 	.word	0x20000404
 800b4ec:	200036e0 	.word	0x200036e0

0800b4f0 <OsStart>:

LITE_OS_SEC_TEXT_INIT VOID OsStart(VOID)
{
 800b4f0:	b580      	push	{r7, lr}
 800b4f2:	b082      	sub	sp, #8
 800b4f4:	af00      	add	r7, sp, #0
    LosTaskCB *taskCB = NULL;
 800b4f6:	2300      	movs	r3, #0
 800b4f8:	603b      	str	r3, [r7, #0]
    UINT32 cpuid = ArchCurrCpuid();
 800b4fa:	f7ff ff81 	bl	800b400 <ArchCurrCpuid>
 800b4fe:	6078      	str	r0, [r7, #4]

    OsTickStart();
 800b500:	f7f8 fe34 	bl	800416c <OsTickStart>

    LOS_SpinLock(&g_taskSpin);
 800b504:	480d      	ldr	r0, [pc, #52]	; (800b53c <OsStart+0x4c>)
 800b506:	f7ff ff83 	bl	800b410 <LOS_SpinLock>
    taskCB = OsGetTopTask();
 800b50a:	f7fd f909 	bl	8008720 <OsGetTopTask>
 800b50e:	6038      	str	r0, [r7, #0]
     * attention: current cpu needs to be set, in case first task deletion
     * may fail because this flag mismatch with the real current cpu.
     */
    taskCB->currCpu = (UINT16)cpuid;
#endif
    OS_SCHEDULER_SET(cpuid);
 800b510:	2201      	movs	r2, #1
 800b512:	687b      	ldr	r3, [r7, #4]
 800b514:	409a      	lsls	r2, r3
 800b516:	4b0a      	ldr	r3, [pc, #40]	; (800b540 <OsStart+0x50>)
 800b518:	681b      	ldr	r3, [r3, #0]
 800b51a:	4313      	orrs	r3, r2
 800b51c:	4a08      	ldr	r2, [pc, #32]	; (800b540 <OsStart+0x50>)
 800b51e:	6013      	str	r3, [r2, #0]

    PRINTK("cpu %u entering scheduler\n", cpuid);
 800b520:	6879      	ldr	r1, [r7, #4]
 800b522:	4808      	ldr	r0, [pc, #32]	; (800b544 <OsStart+0x54>)
 800b524:	f7f9 f8d2 	bl	80046cc <dprintf>

    taskCB->taskStatus = OS_TASK_STATUS_RUNNING;
 800b528:	683b      	ldr	r3, [r7, #0]
 800b52a:	2210      	movs	r2, #16
 800b52c:	809a      	strh	r2, [r3, #4]

    OsStartToRun(taskCB);
 800b52e:	6838      	ldr	r0, [r7, #0]
 800b530:	f7f5 fbac 	bl	8000c8c <OsStartToRun>
}
 800b534:	bf00      	nop
 800b536:	3708      	adds	r7, #8
 800b538:	46bd      	mov	sp, r7
 800b53a:	bd80      	pop	{r7, pc}
 800b53c:	20000764 	.word	0x20000764
 800b540:	200036dc 	.word	0x200036dc
 800b544:	08021590 	.word	0x08021590

0800b548 <OsIpcInit>:

LITE_OS_SEC_TEXT_INIT STATIC UINT32 OsIpcInit(VOID)
{
 800b548:	b580      	push	{r7, lr}
 800b54a:	b082      	sub	sp, #8
 800b54c:	af00      	add	r7, sp, #0
    UINT32 ret = LOS_OK;
 800b54e:	2300      	movs	r3, #0
 800b550:	607b      	str	r3, [r7, #4]
#ifdef LOSCFG_BASE_IPC_SEM
    ret = OsSemInit();
 800b552:	f7f9 f9d1 	bl	80048f8 <OsSemInit>
 800b556:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b558:	687b      	ldr	r3, [r7, #4]
 800b55a:	2b00      	cmp	r3, #0
 800b55c:	d007      	beq.n	800b56e <OsIpcInit+0x26>
        PRINT_ERR("Sem init err.\n");
 800b55e:	4814      	ldr	r0, [pc, #80]	; (800b5b0 <OsIpcInit+0x68>)
 800b560:	f7f9 f8b4 	bl	80046cc <dprintf>
 800b564:	4813      	ldr	r0, [pc, #76]	; (800b5b4 <OsIpcInit+0x6c>)
 800b566:	f7f9 f8b1 	bl	80046cc <dprintf>
        return ret;
 800b56a:	687b      	ldr	r3, [r7, #4]
 800b56c:	e01c      	b.n	800b5a8 <OsIpcInit+0x60>
    }
#endif

#ifdef LOSCFG_BASE_IPC_MUX
    ret = OsMuxInit();
 800b56e:	f7ff f9b1 	bl	800a8d4 <OsMuxInit>
 800b572:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b574:	687b      	ldr	r3, [r7, #4]
 800b576:	2b00      	cmp	r3, #0
 800b578:	d007      	beq.n	800b58a <OsIpcInit+0x42>
        PRINT_ERR("Mux init err.\n");
 800b57a:	480d      	ldr	r0, [pc, #52]	; (800b5b0 <OsIpcInit+0x68>)
 800b57c:	f7f9 f8a6 	bl	80046cc <dprintf>
 800b580:	480d      	ldr	r0, [pc, #52]	; (800b5b8 <OsIpcInit+0x70>)
 800b582:	f7f9 f8a3 	bl	80046cc <dprintf>
        return ret;
 800b586:	687b      	ldr	r3, [r7, #4]
 800b588:	e00e      	b.n	800b5a8 <OsIpcInit+0x60>
    }
#endif

#ifdef LOSCFG_BASE_IPC_QUEUE
    ret = OsQueueInit();
 800b58a:	f7fe fbe5 	bl	8009d58 <OsQueueInit>
 800b58e:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b590:	687b      	ldr	r3, [r7, #4]
 800b592:	2b00      	cmp	r3, #0
 800b594:	d007      	beq.n	800b5a6 <OsIpcInit+0x5e>
        PRINT_ERR("Que init err.\n");
 800b596:	4806      	ldr	r0, [pc, #24]	; (800b5b0 <OsIpcInit+0x68>)
 800b598:	f7f9 f898 	bl	80046cc <dprintf>
 800b59c:	4807      	ldr	r0, [pc, #28]	; (800b5bc <OsIpcInit+0x74>)
 800b59e:	f7f9 f895 	bl	80046cc <dprintf>
        return ret;
 800b5a2:	687b      	ldr	r3, [r7, #4]
 800b5a4:	e000      	b.n	800b5a8 <OsIpcInit+0x60>
    }
#endif
    return ret;
 800b5a6:	687b      	ldr	r3, [r7, #4]
}
 800b5a8:	4618      	mov	r0, r3
 800b5aa:	3708      	adds	r7, #8
 800b5ac:	46bd      	mov	sp, r7
 800b5ae:	bd80      	pop	{r7, pc}
 800b5b0:	080215ac 	.word	0x080215ac
 800b5b4:	080215b4 	.word	0x080215b4
 800b5b8:	080215c4 	.word	0x080215c4
 800b5bc:	080215d4 	.word	0x080215d4

0800b5c0 <OsAppTaskCreate>:

#ifdef LOSCFG_PLATFORM_OSAPPINIT
STATIC UINT32 OsAppTaskCreate(VOID)
{
 800b5c0:	b580      	push	{r7, lr}
 800b5c2:	b08c      	sub	sp, #48	; 0x30
 800b5c4:	af00      	add	r7, sp, #0
 800b5c6:	4b15      	ldr	r3, [pc, #84]	; (800b61c <OsAppTaskCreate+0x5c>)
 800b5c8:	681b      	ldr	r3, [r3, #0]
 800b5ca:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b5cc:	f04f 0300 	mov.w	r3, #0
    UINT32 taskId;
    TSK_INIT_PARAM_S appTask;

    (VOID)memset_s(&appTask, sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
 800b5d0:	f107 0008 	add.w	r0, r7, #8
 800b5d4:	2324      	movs	r3, #36	; 0x24
 800b5d6:	2200      	movs	r2, #0
 800b5d8:	2124      	movs	r1, #36	; 0x24
 800b5da:	f00a fd57 	bl	801608c <memset_s>
    appTask.pfnTaskEntry = (TSK_ENTRY_FUNC)app_init;
 800b5de:	4b10      	ldr	r3, [pc, #64]	; (800b620 <OsAppTaskCreate+0x60>)
 800b5e0:	60bb      	str	r3, [r7, #8]
    appTask.uwStackSize = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
 800b5e2:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800b5e6:	623b      	str	r3, [r7, #32]
    appTask.pcName = "app_Task";
 800b5e8:	4b0e      	ldr	r3, [pc, #56]	; (800b624 <OsAppTaskCreate+0x64>)
 800b5ea:	627b      	str	r3, [r7, #36]	; 0x24
    appTask.usTaskPrio = LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
 800b5ec:	230a      	movs	r3, #10
 800b5ee:	81bb      	strh	r3, [r7, #12]
    appTask.uwResved = LOS_TASK_STATUS_DETACHED;
 800b5f0:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b5f4:	62bb      	str	r3, [r7, #40]	; 0x28
#ifdef LOSCFG_KERNEL_SMP
    appTask.usCpuAffiMask = CPUID_TO_AFFI_MASK(ArchCurrCpuid());
#endif
    return LOS_TaskCreate(&taskId, &appTask);
 800b5f6:	f107 0208 	add.w	r2, r7, #8
 800b5fa:	1d3b      	adds	r3, r7, #4
 800b5fc:	4611      	mov	r1, r2
 800b5fe:	4618      	mov	r0, r3
 800b600:	f7f8 f99a 	bl	8003938 <LOS_TaskCreate>
 800b604:	4603      	mov	r3, r0
}
 800b606:	4a05      	ldr	r2, [pc, #20]	; (800b61c <OsAppTaskCreate+0x5c>)
 800b608:	6811      	ldr	r1, [r2, #0]
 800b60a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b60c:	4051      	eors	r1, r2
 800b60e:	d001      	beq.n	800b614 <OsAppTaskCreate+0x54>
 800b610:	f7f8 feea 	bl	80043e8 <__stack_chk_fail>
 800b614:	4618      	mov	r0, r3
 800b616:	3730      	adds	r7, #48	; 0x30
 800b618:	46bd      	mov	sp, r7
 800b61a:	bd80      	pop	{r7, pc}
 800b61c:	080215f0 	.word	0x080215f0
 800b620:	08016035 	.word	0x08016035
 800b624:	080215e4 	.word	0x080215e4

0800b628 <OsAppInit>:

UINT32 OsAppInit(VOID)
{
 800b628:	b580      	push	{r7, lr}
 800b62a:	b082      	sub	sp, #8
 800b62c:	af00      	add	r7, sp, #0
    g_pstSystemWq = create_workqueue("system_wq");
#endif

#endif

    ret = OsAppTaskCreate();
 800b62e:	f7ff ffc7 	bl	800b5c0 <OsAppTaskCreate>
 800b632:	6078      	str	r0, [r7, #4]
    PRINTK("OsAppInit\n");
 800b634:	4807      	ldr	r0, [pc, #28]	; (800b654 <OsAppInit+0x2c>)
 800b636:	f7f9 f849 	bl	80046cc <dprintf>
    if (ret != LOS_OK) {
 800b63a:	687b      	ldr	r3, [r7, #4]
 800b63c:	2b00      	cmp	r3, #0
 800b63e:	d001      	beq.n	800b644 <OsAppInit+0x1c>
        return ret;
 800b640:	687b      	ldr	r3, [r7, #4]
 800b642:	e002      	b.n	800b64a <OsAppInit+0x22>
    }

#ifdef LOSCFG_KERNEL_TICKLESS
    LOS_TicklessEnable();
 800b644:	f007 ff20 	bl	8013488 <LOS_TicklessEnable>
#endif
    return 0;
 800b648:	2300      	movs	r3, #0
}
 800b64a:	4618      	mov	r0, r3
 800b64c:	3708      	adds	r7, #8
 800b64e:	46bd      	mov	sp, r7
 800b650:	bd80      	pop	{r7, pc}
 800b652:	bf00      	nop
 800b654:	080215f4 	.word	0x080215f4

0800b658 <OsMain>:
#endif /* LOSCFG_PLATFORM_OSAPPINIT */

LITE_OS_SEC_TEXT_INIT UINT32 OsMain(VOID)
{
 800b658:	b580      	push	{r7, lr}
 800b65a:	b082      	sub	sp, #8
 800b65c:	af00      	add	r7, sp, #0

#ifdef LOSCFG_KERNEL_LMS
    OsLmsInit();
#endif

    ret = OsMemSystemInit((UINTPTR)OS_SYS_MEM_ADDR);
 800b65e:	4b4c      	ldr	r3, [pc, #304]	; (800b790 <OsMain+0x138>)
 800b660:	681b      	ldr	r3, [r3, #0]
 800b662:	4618      	mov	r0, r3
 800b664:	f7fd f97a 	bl	800895c <OsMemSystemInit>
 800b668:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b66a:	687b      	ldr	r3, [r7, #4]
 800b66c:	2b00      	cmp	r3, #0
 800b66e:	d007      	beq.n	800b680 <OsMain+0x28>
        PRINT_ERR("Mem init err.\n");
 800b670:	4848      	ldr	r0, [pc, #288]	; (800b794 <OsMain+0x13c>)
 800b672:	f7f9 f82b 	bl	80046cc <dprintf>
 800b676:	4848      	ldr	r0, [pc, #288]	; (800b798 <OsMain+0x140>)
 800b678:	f7f9 f828 	bl	80046cc <dprintf>
        return ret;
 800b67c:	687b      	ldr	r3, [r7, #4]
 800b67e:	e083      	b.n	800b788 <OsMain+0x130>
    }

    OsRegister();
 800b680:	f7ff ff20 	bl	800b4c4 <OsRegister>
#ifdef LOSCFG_SHELL_LK
    OsLkLoggerInit(NULL);
#endif

#ifdef LOSCFG_SHELL_DMESG
    ret = OsDmesgInit();
 800b684:	f004 ff62 	bl	801054c <OsDmesgInit>
 800b688:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b68a:	687b      	ldr	r3, [r7, #4]
 800b68c:	2b00      	cmp	r3, #0
 800b68e:	d001      	beq.n	800b694 <OsMain+0x3c>
        return ret;
 800b690:	687b      	ldr	r3, [r7, #4]
 800b692:	e079      	b.n	800b788 <OsMain+0x130>
    }
#endif

    OsHwiInit();
 800b694:	f7f7 f810 	bl	80026b8 <OsHwiInit>

    ArchExcInit();
 800b698:	f00a fbe2 	bl	8015e60 <ArchExcInit>

#if defined(LOSCFG_KERNEL_TICKLESS) && !defined(LOSCFG_KERNEL_POWER_MGR)
    OsLowpowerInit(NULL);
 800b69c:	2000      	movs	r0, #0
 800b69e:	f004 fb37 	bl	800fd10 <OsLowpowerInit>
#endif

    ret = OsTickInit(GET_SYS_CLOCK(), LOSCFG_BASE_CORE_TICK_PER_SECOND);
 800b6a2:	4b3e      	ldr	r3, [pc, #248]	; (800b79c <OsMain+0x144>)
 800b6a4:	681b      	ldr	r3, [r3, #0]
 800b6a6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800b6aa:	4618      	mov	r0, r3
 800b6ac:	f7f8 fd44 	bl	8004138 <OsTickInit>
 800b6b0:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b6b2:	687b      	ldr	r3, [r7, #4]
 800b6b4:	2b00      	cmp	r3, #0
 800b6b6:	d007      	beq.n	800b6c8 <OsMain+0x70>
        PRINT_ERR("Tick init err.\n");
 800b6b8:	4836      	ldr	r0, [pc, #216]	; (800b794 <OsMain+0x13c>)
 800b6ba:	f7f9 f807 	bl	80046cc <dprintf>
 800b6be:	4838      	ldr	r0, [pc, #224]	; (800b7a0 <OsMain+0x148>)
 800b6c0:	f7f9 f804 	bl	80046cc <dprintf>
        return ret;
 800b6c4:	687b      	ldr	r3, [r7, #4]
 800b6c6:	e05f      	b.n	800b788 <OsMain+0x130>
    }

#if defined(LOSCFG_DRIVERS_UART) || defined(LOSCFG_DRIVERS_SIMPLE_UART)
    uart_init();
 800b6c8:	f004 fc6e 	bl	800ffa8 <uart_init>
#ifdef LOSCFG_SHELL
    uart_hwiCreate();
 800b6cc:	f004 fbe4 	bl	800fe98 <uart_hwiCreate>
#endif /* LOSCFG_SHELL */
#endif /* LOSCFG_DRIVERS_SIMPLE_UART */

    ret = OsTaskInit();
 800b6d0:	f7f7 fba8 	bl	8002e24 <OsTaskInit>
 800b6d4:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b6d6:	687b      	ldr	r3, [r7, #4]
 800b6d8:	2b00      	cmp	r3, #0
 800b6da:	d007      	beq.n	800b6ec <OsMain+0x94>
        PRINT_ERR("Task init err.\n");
 800b6dc:	482d      	ldr	r0, [pc, #180]	; (800b794 <OsMain+0x13c>)
 800b6de:	f7f8 fff5 	bl	80046cc <dprintf>
 800b6e2:	4830      	ldr	r0, [pc, #192]	; (800b7a4 <OsMain+0x14c>)
 800b6e4:	f7f8 fff2 	bl	80046cc <dprintf>
        return ret;
 800b6e8:	687b      	ldr	r3, [r7, #4]
 800b6ea:	e04d      	b.n	800b788 <OsMain+0x130>
    }

#ifdef LOSCFG_KERNEL_TRACE
    ret = LOS_TraceInit(NULL, LOS_TRACE_BUFFER_SIZE);
 800b6ec:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800b6f0:	2000      	movs	r0, #0
 800b6f2:	f009 f9f9 	bl	8014ae8 <LOS_TraceInit>
 800b6f6:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b6f8:	687b      	ldr	r3, [r7, #4]
 800b6fa:	2b00      	cmp	r3, #0
 800b6fc:	d007      	beq.n	800b70e <OsMain+0xb6>
        PRINT_ERR("Trace init err.\n");
 800b6fe:	4825      	ldr	r0, [pc, #148]	; (800b794 <OsMain+0x13c>)
 800b700:	f7f8 ffe4 	bl	80046cc <dprintf>
 800b704:	4828      	ldr	r0, [pc, #160]	; (800b7a8 <OsMain+0x150>)
 800b706:	f7f8 ffe1 	bl	80046cc <dprintf>
        return ret;
 800b70a:	687b      	ldr	r3, [r7, #4]
 800b70c:	e03c      	b.n	800b788 <OsMain+0x130>
    }
#endif

#ifdef LOSCFG_BASE_CORE_TSK_MONITOR
    OsTaskMonInit();
 800b70e:	f7f7 fccd 	bl	80030ac <OsTaskMonInit>
#endif

    ret = OsIpcInit();
 800b712:	f7ff ff19 	bl	800b548 <OsIpcInit>
 800b716:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b718:	687b      	ldr	r3, [r7, #4]
 800b71a:	2b00      	cmp	r3, #0
 800b71c:	d001      	beq.n	800b722 <OsMain+0xca>
        return ret;
 800b71e:	687b      	ldr	r3, [r7, #4]
 800b720:	e032      	b.n	800b788 <OsMain+0x130>
     * 1. OsIpcInit
     * 2. OsCpupInit -> has first task creation
     * 3. other inits have task creation
     */
#ifdef LOSCFG_KERNEL_CPUP
    ret = OsCpupInit();
 800b722:	f008 f997 	bl	8013a54 <OsCpupInit>
 800b726:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b728:	687b      	ldr	r3, [r7, #4]
 800b72a:	2b00      	cmp	r3, #0
 800b72c:	d007      	beq.n	800b73e <OsMain+0xe6>
        PRINT_ERR("Cpup init err.\n");
 800b72e:	4819      	ldr	r0, [pc, #100]	; (800b794 <OsMain+0x13c>)
 800b730:	f7f8 ffcc 	bl	80046cc <dprintf>
 800b734:	481d      	ldr	r0, [pc, #116]	; (800b7ac <OsMain+0x154>)
 800b736:	f7f8 ffc9 	bl	80046cc <dprintf>
        return ret;
 800b73a:	687b      	ldr	r3, [r7, #4]
 800b73c:	e024      	b.n	800b788 <OsMain+0x130>
    }
#endif

#ifdef LOSCFG_BASE_CORE_SWTMR
    ret = OsSwtmrInit();
 800b73e:	f7f9 fbc3 	bl	8004ec8 <OsSwtmrInit>
 800b742:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b744:	687b      	ldr	r3, [r7, #4]
 800b746:	2b00      	cmp	r3, #0
 800b748:	d007      	beq.n	800b75a <OsMain+0x102>
        PRINT_ERR("Swtmr init err.\n");
 800b74a:	4812      	ldr	r0, [pc, #72]	; (800b794 <OsMain+0x13c>)
 800b74c:	f7f8 ffbe 	bl	80046cc <dprintf>
 800b750:	4817      	ldr	r0, [pc, #92]	; (800b7b0 <OsMain+0x158>)
 800b752:	f7f8 ffbb 	bl	80046cc <dprintf>
        return ret;
 800b756:	687b      	ldr	r3, [r7, #4]
 800b758:	e016      	b.n	800b788 <OsMain+0x130>
    if (ret != LOS_OK) {
        return ret;
    }
#endif

    ret = OsIdleTaskCreate();
 800b75a:	f7f7 fbfb 	bl	8002f54 <OsIdleTaskCreate>
 800b75e:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800b760:	687b      	ldr	r3, [r7, #4]
 800b762:	2b00      	cmp	r3, #0
 800b764:	d007      	beq.n	800b776 <OsMain+0x11e>
        PRINT_ERR("Create idle task err.\n");
 800b766:	480b      	ldr	r0, [pc, #44]	; (800b794 <OsMain+0x13c>)
 800b768:	f7f8 ffb0 	bl	80046cc <dprintf>
 800b76c:	4811      	ldr	r0, [pc, #68]	; (800b7b4 <OsMain+0x15c>)
 800b76e:	f7f8 ffad 	bl	80046cc <dprintf>
        return ret;
 800b772:	687b      	ldr	r3, [r7, #4]
 800b774:	e008      	b.n	800b788 <OsMain+0x130>
        return ret;
    }
#endif

#ifdef LOSCFG_PLATFORM_OSAPPINIT
    ret = OsAppInit();
 800b776:	f7ff ff57 	bl	800b628 <OsAppInit>
 800b77a:	6078      	str	r0, [r7, #4]
#else /* LOSCFG_TEST */
    ret = OsTestInit();
#endif
    if (ret != LOS_OK) {
 800b77c:	687b      	ldr	r3, [r7, #4]
 800b77e:	2b00      	cmp	r3, #0
 800b780:	d001      	beq.n	800b786 <OsMain+0x12e>
        return ret;
 800b782:	687b      	ldr	r3, [r7, #4]
 800b784:	e000      	b.n	800b788 <OsMain+0x130>
    }

    return LOS_OK;
 800b786:	2300      	movs	r3, #0
}
 800b788:	4618      	mov	r0, r3
 800b78a:	3708      	adds	r7, #8
 800b78c:	46bd      	mov	sp, r7
 800b78e:	bd80      	pop	{r7, pc}
 800b790:	080001f0 	.word	0x080001f0
 800b794:	080215ac 	.word	0x080215ac
 800b798:	08021600 	.word	0x08021600
 800b79c:	200036e0 	.word	0x200036e0
 800b7a0:	08021610 	.word	0x08021610
 800b7a4:	08021620 	.word	0x08021620
 800b7a8:	08021630 	.word	0x08021630
 800b7ac:	08021644 	.word	0x08021644
 800b7b0:	08021654 	.word	0x08021654
 800b7b4:	08021668 	.word	0x08021668

0800b7b8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800b7b8:	b580      	push	{r7, lr}
 800b7ba:	af00      	add	r7, sp, #0
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800b7bc:	2003      	movs	r0, #3
 800b7be:	f001 ff6d 	bl	800d69c <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800b7c2:	200f      	movs	r0, #15
 800b7c4:	f000 f806 	bl	800b7d4 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800b7c8:	f7f6 fb84 	bl	8001ed4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800b7cc:	2300      	movs	r3, #0
}
 800b7ce:	4618      	mov	r0, r3
 800b7d0:	bd80      	pop	{r7, pc}
	...

0800b7d4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800b7d4:	b580      	push	{r7, lr}
 800b7d6:	b082      	sub	sp, #8
 800b7d8:	af00      	add	r7, sp, #0
 800b7da:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800b7dc:	4b12      	ldr	r3, [pc, #72]	; (800b828 <HAL_InitTick+0x54>)
 800b7de:	681a      	ldr	r2, [r3, #0]
 800b7e0:	4b12      	ldr	r3, [pc, #72]	; (800b82c <HAL_InitTick+0x58>)
 800b7e2:	681b      	ldr	r3, [r3, #0]
 800b7e4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800b7e8:	fbb1 f3f3 	udiv	r3, r1, r3
 800b7ec:	fbb2 f3f3 	udiv	r3, r2, r3
 800b7f0:	4618      	mov	r0, r3
 800b7f2:	f001 ff82 	bl	800d6fa <HAL_SYSTICK_Config>
 800b7f6:	4603      	mov	r3, r0
 800b7f8:	2b00      	cmp	r3, #0
 800b7fa:	d001      	beq.n	800b800 <HAL_InitTick+0x2c>
  {
    return HAL_ERROR;
 800b7fc:	2301      	movs	r3, #1
 800b7fe:	e00e      	b.n	800b81e <HAL_InitTick+0x4a>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800b800:	687b      	ldr	r3, [r7, #4]
 800b802:	2b0f      	cmp	r3, #15
 800b804:	d80a      	bhi.n	800b81c <HAL_InitTick+0x48>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800b806:	2200      	movs	r2, #0
 800b808:	6879      	ldr	r1, [r7, #4]
 800b80a:	f04f 30ff 	mov.w	r0, #4294967295
 800b80e:	f001 ff50 	bl	800d6b2 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800b812:	4a07      	ldr	r2, [pc, #28]	; (800b830 <HAL_InitTick+0x5c>)
 800b814:	687b      	ldr	r3, [r7, #4]
 800b816:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 800b818:	2300      	movs	r3, #0
 800b81a:	e000      	b.n	800b81e <HAL_InitTick+0x4a>
    return HAL_ERROR;
 800b81c:	2301      	movs	r3, #1
}
 800b81e:	4618      	mov	r0, r3
 800b820:	3708      	adds	r7, #8
 800b822:	46bd      	mov	sp, r7
 800b824:	bd80      	pop	{r7, pc}
 800b826:	bf00      	nop
 800b828:	20000404 	.word	0x20000404
 800b82c:	20000480 	.word	0x20000480
 800b830:	2000047c 	.word	0x2000047c

0800b834 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800b834:	b580      	push	{r7, lr}
 800b836:	b084      	sub	sp, #16
 800b838:	af00      	add	r7, sp, #0
 800b83a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 800b83c:	f7f6 fa9a 	bl	8001d74 <HAL_GetTick>
 800b840:	60f8      	str	r0, [r7, #12]
  uint32_t wait = Delay;
 800b842:	687b      	ldr	r3, [r7, #4]
 800b844:	60bb      	str	r3, [r7, #8]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800b846:	68bb      	ldr	r3, [r7, #8]
 800b848:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b84c:	d004      	beq.n	800b858 <HAL_Delay+0x24>
  {
    wait += (uint32_t)(uwTickFreq);
 800b84e:	4b09      	ldr	r3, [pc, #36]	; (800b874 <HAL_Delay+0x40>)
 800b850:	681b      	ldr	r3, [r3, #0]
 800b852:	68ba      	ldr	r2, [r7, #8]
 800b854:	4413      	add	r3, r2
 800b856:	60bb      	str	r3, [r7, #8]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800b858:	bf00      	nop
 800b85a:	f7f6 fa8b 	bl	8001d74 <HAL_GetTick>
 800b85e:	4602      	mov	r2, r0
 800b860:	68fb      	ldr	r3, [r7, #12]
 800b862:	1ad3      	subs	r3, r2, r3
 800b864:	68ba      	ldr	r2, [r7, #8]
 800b866:	429a      	cmp	r2, r3
 800b868:	d8f7      	bhi.n	800b85a <HAL_Delay+0x26>
  {
  }
}
 800b86a:	bf00      	nop
 800b86c:	bf00      	nop
 800b86e:	3710      	adds	r7, #16
 800b870:	46bd      	mov	sp, r7
 800b872:	bd80      	pop	{r7, pc}
 800b874:	20000480 	.word	0x20000480

0800b878 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800b878:	b580      	push	{r7, lr}
 800b87a:	b088      	sub	sp, #32
 800b87c:	af00      	add	r7, sp, #0
 800b87e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
 800b880:	2300      	movs	r3, #0
 800b882:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg0 = 0;
 800b884:	2300      	movs	r3, #0
 800b886:	61bb      	str	r3, [r7, #24]
  uint32_t tmpreg1 = 0;
 800b888:	2300      	movs	r3, #0
 800b88a:	61fb      	str	r3, [r7, #28]
  uint32_t plli2sused = 0;
 800b88c:	2300      	movs	r3, #0
 800b88e:	60fb      	str	r3, [r7, #12]
  uint32_t pllsaiused = 0;
 800b890:	2300      	movs	r3, #0
 800b892:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 800b894:	687b      	ldr	r3, [r7, #4]
 800b896:	681b      	ldr	r3, [r3, #0]
 800b898:	f003 0301 	and.w	r3, r3, #1
 800b89c:	2b00      	cmp	r3, #0
 800b89e:	d012      	beq.n	800b8c6 <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 800b8a0:	4b69      	ldr	r3, [pc, #420]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b8a2:	689b      	ldr	r3, [r3, #8]
 800b8a4:	4a68      	ldr	r2, [pc, #416]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b8a6:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800b8aa:	6093      	str	r3, [r2, #8]
 800b8ac:	4b66      	ldr	r3, [pc, #408]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b8ae:	689a      	ldr	r2, [r3, #8]
 800b8b0:	687b      	ldr	r3, [r7, #4]
 800b8b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b8b4:	4964      	ldr	r1, [pc, #400]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b8b6:	4313      	orrs	r3, r2
 800b8b8:	608b      	str	r3, [r1, #8]

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 800b8ba:	687b      	ldr	r3, [r7, #4]
 800b8bc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b8be:	2b00      	cmp	r3, #0
 800b8c0:	d101      	bne.n	800b8c6 <HAL_RCCEx_PeriphCLKConfig+0x4e>
    {
      plli2sused = 1;
 800b8c2:	2301      	movs	r3, #1
 800b8c4:	60fb      	str	r3, [r7, #12]
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 800b8c6:	687b      	ldr	r3, [r7, #4]
 800b8c8:	681b      	ldr	r3, [r3, #0]
 800b8ca:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800b8ce:	2b00      	cmp	r3, #0
 800b8d0:	d017      	beq.n	800b902 <HAL_RCCEx_PeriphCLKConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800b8d2:	4b5d      	ldr	r3, [pc, #372]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b8d4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800b8d8:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 800b8dc:	687b      	ldr	r3, [r7, #4]
 800b8de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b8e0:	4959      	ldr	r1, [pc, #356]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b8e2:	4313      	orrs	r3, r2
 800b8e4:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 800b8e8:	687b      	ldr	r3, [r7, #4]
 800b8ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b8ec:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800b8f0:	d101      	bne.n	800b8f6 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      plli2sused = 1;
 800b8f2:	2301      	movs	r3, #1
 800b8f4:	60fb      	str	r3, [r7, #12]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 800b8f6:	687b      	ldr	r3, [r7, #4]
 800b8f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b8fa:	2b00      	cmp	r3, #0
 800b8fc:	d101      	bne.n	800b902 <HAL_RCCEx_PeriphCLKConfig+0x8a>
    {
      pllsaiused = 1;
 800b8fe:	2301      	movs	r3, #1
 800b900:	613b      	str	r3, [r7, #16]
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 800b902:	687b      	ldr	r3, [r7, #4]
 800b904:	681b      	ldr	r3, [r3, #0]
 800b906:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800b90a:	2b00      	cmp	r3, #0
 800b90c:	d017      	beq.n	800b93e <HAL_RCCEx_PeriphCLKConfig+0xc6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 800b90e:	4b4e      	ldr	r3, [pc, #312]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b910:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800b914:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 800b918:	687b      	ldr	r3, [r7, #4]
 800b91a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b91c:	494a      	ldr	r1, [pc, #296]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b91e:	4313      	orrs	r3, r2
 800b920:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 800b924:	687b      	ldr	r3, [r7, #4]
 800b926:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b928:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800b92c:	d101      	bne.n	800b932 <HAL_RCCEx_PeriphCLKConfig+0xba>
    {
      plli2sused = 1;
 800b92e:	2301      	movs	r3, #1
 800b930:	60fb      	str	r3, [r7, #12]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
 800b932:	687b      	ldr	r3, [r7, #4]
 800b934:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b936:	2b00      	cmp	r3, #0
 800b938:	d101      	bne.n	800b93e <HAL_RCCEx_PeriphCLKConfig+0xc6>
    {
      pllsaiused = 1;
 800b93a:	2301      	movs	r3, #1
 800b93c:	613b      	str	r3, [r7, #16]
    }
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800b93e:	687b      	ldr	r3, [r7, #4]
 800b940:	681b      	ldr	r3, [r3, #0]
 800b942:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800b946:	2b00      	cmp	r3, #0
 800b948:	d001      	beq.n	800b94e <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
      plli2sused = 1;
 800b94a:	2301      	movs	r3, #1
 800b94c:	60fb      	str	r3, [r7, #12]
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800b94e:	687b      	ldr	r3, [r7, #4]
 800b950:	681b      	ldr	r3, [r3, #0]
 800b952:	f003 0320 	and.w	r3, r3, #32
 800b956:	2b00      	cmp	r3, #0
 800b958:	f000 808b 	beq.w	800ba72 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800b95c:	4b3a      	ldr	r3, [pc, #232]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b95e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b960:	4a39      	ldr	r2, [pc, #228]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b962:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800b966:	6413      	str	r3, [r2, #64]	; 0x40
 800b968:	4b37      	ldr	r3, [pc, #220]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b96a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b96c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800b970:	60bb      	str	r3, [r7, #8]
 800b972:	68bb      	ldr	r3, [r7, #8]

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 800b974:	4b35      	ldr	r3, [pc, #212]	; (800ba4c <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 800b976:	681b      	ldr	r3, [r3, #0]
 800b978:	4a34      	ldr	r2, [pc, #208]	; (800ba4c <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 800b97a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b97e:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800b980:	f7f6 f9f8 	bl	8001d74 <HAL_GetTick>
 800b984:	6178      	str	r0, [r7, #20]

    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 800b986:	e008      	b.n	800b99a <HAL_RCCEx_PeriphCLKConfig+0x122>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800b988:	f7f6 f9f4 	bl	8001d74 <HAL_GetTick>
 800b98c:	4602      	mov	r2, r0
 800b98e:	697b      	ldr	r3, [r7, #20]
 800b990:	1ad3      	subs	r3, r2, r3
 800b992:	2b64      	cmp	r3, #100	; 0x64
 800b994:	d901      	bls.n	800b99a <HAL_RCCEx_PeriphCLKConfig+0x122>
      {
        return HAL_TIMEOUT;
 800b996:	2303      	movs	r3, #3
 800b998:	e38f      	b.n	800c0ba <HAL_RCCEx_PeriphCLKConfig+0x842>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 800b99a:	4b2c      	ldr	r3, [pc, #176]	; (800ba4c <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 800b99c:	681b      	ldr	r3, [r3, #0]
 800b99e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800b9a2:	2b00      	cmp	r3, #0
 800b9a4:	d0f0      	beq.n	800b988 <HAL_RCCEx_PeriphCLKConfig+0x110>
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 800b9a6:	4b28      	ldr	r3, [pc, #160]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b9a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b9aa:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800b9ae:	61bb      	str	r3, [r7, #24]

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800b9b0:	69bb      	ldr	r3, [r7, #24]
 800b9b2:	2b00      	cmp	r3, #0
 800b9b4:	d035      	beq.n	800ba22 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
 800b9b6:	687b      	ldr	r3, [r7, #4]
 800b9b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b9ba:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800b9be:	69ba      	ldr	r2, [r7, #24]
 800b9c0:	429a      	cmp	r2, r3
 800b9c2:	d02e      	beq.n	800ba22 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800b9c4:	4b20      	ldr	r3, [pc, #128]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b9c6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b9c8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800b9cc:	61bb      	str	r3, [r7, #24]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800b9ce:	4b1e      	ldr	r3, [pc, #120]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b9d0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b9d2:	4a1d      	ldr	r2, [pc, #116]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b9d4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800b9d8:	6713      	str	r3, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 800b9da:	4b1b      	ldr	r3, [pc, #108]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b9dc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b9de:	4a1a      	ldr	r2, [pc, #104]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b9e0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800b9e4:	6713      	str	r3, [r2, #112]	; 0x70

      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg0;
 800b9e6:	4a18      	ldr	r2, [pc, #96]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b9e8:	69bb      	ldr	r3, [r7, #24]
 800b9ea:	6713      	str	r3, [r2, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 800b9ec:	4b16      	ldr	r3, [pc, #88]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800b9ee:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b9f0:	f003 0301 	and.w	r3, r3, #1
 800b9f4:	2b01      	cmp	r3, #1
 800b9f6:	d114      	bne.n	800ba22 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800b9f8:	f7f6 f9bc 	bl	8001d74 <HAL_GetTick>
 800b9fc:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800b9fe:	e00a      	b.n	800ba16 <HAL_RCCEx_PeriphCLKConfig+0x19e>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800ba00:	f7f6 f9b8 	bl	8001d74 <HAL_GetTick>
 800ba04:	4602      	mov	r2, r0
 800ba06:	697b      	ldr	r3, [r7, #20]
 800ba08:	1ad3      	subs	r3, r2, r3
 800ba0a:	f241 3288 	movw	r2, #5000	; 0x1388
 800ba0e:	4293      	cmp	r3, r2
 800ba10:	d901      	bls.n	800ba16 <HAL_RCCEx_PeriphCLKConfig+0x19e>
          {
            return HAL_TIMEOUT;
 800ba12:	2303      	movs	r3, #3
 800ba14:	e351      	b.n	800c0ba <HAL_RCCEx_PeriphCLKConfig+0x842>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800ba16:	4b0c      	ldr	r3, [pc, #48]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800ba18:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ba1a:	f003 0302 	and.w	r3, r3, #2
 800ba1e:	2b00      	cmp	r3, #0
 800ba20:	d0ee      	beq.n	800ba00 <HAL_RCCEx_PeriphCLKConfig+0x188>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800ba22:	687b      	ldr	r3, [r7, #4]
 800ba24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba26:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800ba2a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800ba2e:	d111      	bne.n	800ba54 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
 800ba30:	4b05      	ldr	r3, [pc, #20]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800ba32:	689b      	ldr	r3, [r3, #8]
 800ba34:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 800ba38:	687b      	ldr	r3, [r7, #4]
 800ba3a:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800ba3c:	4b04      	ldr	r3, [pc, #16]	; (800ba50 <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
 800ba3e:	400b      	ands	r3, r1
 800ba40:	4901      	ldr	r1, [pc, #4]	; (800ba48 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800ba42:	4313      	orrs	r3, r2
 800ba44:	608b      	str	r3, [r1, #8]
 800ba46:	e00b      	b.n	800ba60 <HAL_RCCEx_PeriphCLKConfig+0x1e8>
 800ba48:	40023800 	.word	0x40023800
 800ba4c:	40007000 	.word	0x40007000
 800ba50:	0ffffcff 	.word	0x0ffffcff
 800ba54:	4bb3      	ldr	r3, [pc, #716]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800ba56:	689b      	ldr	r3, [r3, #8]
 800ba58:	4ab2      	ldr	r2, [pc, #712]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800ba5a:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 800ba5e:	6093      	str	r3, [r2, #8]
 800ba60:	4bb0      	ldr	r3, [pc, #704]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800ba62:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800ba64:	687b      	ldr	r3, [r7, #4]
 800ba66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba68:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800ba6c:	49ad      	ldr	r1, [pc, #692]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800ba6e:	4313      	orrs	r3, r2
 800ba70:	670b      	str	r3, [r1, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 800ba72:	687b      	ldr	r3, [r7, #4]
 800ba74:	681b      	ldr	r3, [r3, #0]
 800ba76:	f003 0310 	and.w	r3, r3, #16
 800ba7a:	2b00      	cmp	r3, #0
 800ba7c:	d010      	beq.n	800baa0 <HAL_RCCEx_PeriphCLKConfig+0x228>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800ba7e:	4ba9      	ldr	r3, [pc, #676]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800ba80:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ba84:	4aa7      	ldr	r2, [pc, #668]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800ba86:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800ba8a:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 800ba8e:	4ba5      	ldr	r3, [pc, #660]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800ba90:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800ba94:	687b      	ldr	r3, [r7, #4]
 800ba96:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ba98:	49a2      	ldr	r1, [pc, #648]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800ba9a:	4313      	orrs	r3, r2
 800ba9c:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800baa0:	687b      	ldr	r3, [r7, #4]
 800baa2:	681b      	ldr	r3, [r3, #0]
 800baa4:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800baa8:	2b00      	cmp	r3, #0
 800baaa:	d00a      	beq.n	800bac2 <HAL_RCCEx_PeriphCLKConfig+0x24a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800baac:	4b9d      	ldr	r3, [pc, #628]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800baae:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bab2:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 800bab6:	687b      	ldr	r3, [r7, #4]
 800bab8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800baba:	499a      	ldr	r1, [pc, #616]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800babc:	4313      	orrs	r3, r2
 800babe:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 800bac2:	687b      	ldr	r3, [r7, #4]
 800bac4:	681b      	ldr	r3, [r3, #0]
 800bac6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800baca:	2b00      	cmp	r3, #0
 800bacc:	d00a      	beq.n	800bae4 <HAL_RCCEx_PeriphCLKConfig+0x26c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 800bace:	4b95      	ldr	r3, [pc, #596]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bad0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bad4:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
 800bad8:	687b      	ldr	r3, [r7, #4]
 800bada:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800badc:	4991      	ldr	r1, [pc, #580]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bade:	4313      	orrs	r3, r2
 800bae0:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800bae4:	687b      	ldr	r3, [r7, #4]
 800bae6:	681b      	ldr	r3, [r3, #0]
 800bae8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800baec:	2b00      	cmp	r3, #0
 800baee:	d00a      	beq.n	800bb06 <HAL_RCCEx_PeriphCLKConfig+0x28e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800baf0:	4b8c      	ldr	r3, [pc, #560]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800baf2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800baf6:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 800bafa:	687b      	ldr	r3, [r7, #4]
 800bafc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800bafe:	4989      	ldr	r1, [pc, #548]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bb00:	4313      	orrs	r3, r2
 800bb02:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 800bb06:	687b      	ldr	r3, [r7, #4]
 800bb08:	681b      	ldr	r3, [r3, #0]
 800bb0a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800bb0e:	2b00      	cmp	r3, #0
 800bb10:	d00a      	beq.n	800bb28 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 800bb12:	4b84      	ldr	r3, [pc, #528]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bb14:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bb18:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 800bb1c:	687b      	ldr	r3, [r7, #4]
 800bb1e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800bb20:	4980      	ldr	r1, [pc, #512]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bb22:	4313      	orrs	r3, r2
 800bb24:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800bb28:	687b      	ldr	r3, [r7, #4]
 800bb2a:	681b      	ldr	r3, [r3, #0]
 800bb2c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800bb30:	2b00      	cmp	r3, #0
 800bb32:	d00a      	beq.n	800bb4a <HAL_RCCEx_PeriphCLKConfig+0x2d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800bb34:	4b7b      	ldr	r3, [pc, #492]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bb36:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bb3a:	f023 0203 	bic.w	r2, r3, #3
 800bb3e:	687b      	ldr	r3, [r7, #4]
 800bb40:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800bb42:	4978      	ldr	r1, [pc, #480]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bb44:	4313      	orrs	r3, r2
 800bb46:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800bb4a:	687b      	ldr	r3, [r7, #4]
 800bb4c:	681b      	ldr	r3, [r3, #0]
 800bb4e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800bb52:	2b00      	cmp	r3, #0
 800bb54:	d00a      	beq.n	800bb6c <HAL_RCCEx_PeriphCLKConfig+0x2f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800bb56:	4b73      	ldr	r3, [pc, #460]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bb58:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bb5c:	f023 020c 	bic.w	r2, r3, #12
 800bb60:	687b      	ldr	r3, [r7, #4]
 800bb62:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800bb64:	496f      	ldr	r1, [pc, #444]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bb66:	4313      	orrs	r3, r2
 800bb68:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 800bb6c:	687b      	ldr	r3, [r7, #4]
 800bb6e:	681b      	ldr	r3, [r3, #0]
 800bb70:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800bb74:	2b00      	cmp	r3, #0
 800bb76:	d00a      	beq.n	800bb8e <HAL_RCCEx_PeriphCLKConfig+0x316>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800bb78:	4b6a      	ldr	r3, [pc, #424]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bb7a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bb7e:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 800bb82:	687b      	ldr	r3, [r7, #4]
 800bb84:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bb86:	4967      	ldr	r1, [pc, #412]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bb88:	4313      	orrs	r3, r2
 800bb8a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 800bb8e:	687b      	ldr	r3, [r7, #4]
 800bb90:	681b      	ldr	r3, [r3, #0]
 800bb92:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800bb96:	2b00      	cmp	r3, #0
 800bb98:	d00a      	beq.n	800bbb0 <HAL_RCCEx_PeriphCLKConfig+0x338>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 800bb9a:	4b62      	ldr	r3, [pc, #392]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bb9c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bba0:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 800bba4:	687b      	ldr	r3, [r7, #4]
 800bba6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800bba8:	495e      	ldr	r1, [pc, #376]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bbaa:	4313      	orrs	r3, r2
 800bbac:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 800bbb0:	687b      	ldr	r3, [r7, #4]
 800bbb2:	681b      	ldr	r3, [r3, #0]
 800bbb4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800bbb8:	2b00      	cmp	r3, #0
 800bbba:	d00a      	beq.n	800bbd2 <HAL_RCCEx_PeriphCLKConfig+0x35a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 800bbbc:	4b59      	ldr	r3, [pc, #356]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bbbe:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bbc2:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 800bbc6:	687b      	ldr	r3, [r7, #4]
 800bbc8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800bbca:	4956      	ldr	r1, [pc, #344]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bbcc:	4313      	orrs	r3, r2
 800bbce:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 800bbd2:	687b      	ldr	r3, [r7, #4]
 800bbd4:	681b      	ldr	r3, [r3, #0]
 800bbd6:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800bbda:	2b00      	cmp	r3, #0
 800bbdc:	d00a      	beq.n	800bbf4 <HAL_RCCEx_PeriphCLKConfig+0x37c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 800bbde:	4b51      	ldr	r3, [pc, #324]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bbe0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bbe4:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 800bbe8:	687b      	ldr	r3, [r7, #4]
 800bbea:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800bbec:	494d      	ldr	r1, [pc, #308]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bbee:	4313      	orrs	r3, r2
 800bbf0:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 800bbf4:	687b      	ldr	r3, [r7, #4]
 800bbf6:	681b      	ldr	r3, [r3, #0]
 800bbf8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800bbfc:	2b00      	cmp	r3, #0
 800bbfe:	d00a      	beq.n	800bc16 <HAL_RCCEx_PeriphCLKConfig+0x39e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 800bc00:	4b48      	ldr	r3, [pc, #288]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bc02:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bc06:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 800bc0a:	687b      	ldr	r3, [r7, #4]
 800bc0c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800bc0e:	4945      	ldr	r1, [pc, #276]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bc10:	4313      	orrs	r3, r2
 800bc12:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 800bc16:	687b      	ldr	r3, [r7, #4]
 800bc18:	681b      	ldr	r3, [r3, #0]
 800bc1a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800bc1e:	2b00      	cmp	r3, #0
 800bc20:	d00a      	beq.n	800bc38 <HAL_RCCEx_PeriphCLKConfig+0x3c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 800bc22:	4b40      	ldr	r3, [pc, #256]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bc24:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bc28:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 800bc2c:	687b      	ldr	r3, [r7, #4]
 800bc2e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800bc30:	493c      	ldr	r1, [pc, #240]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bc32:	4313      	orrs	r3, r2
 800bc34:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 800bc38:	687b      	ldr	r3, [r7, #4]
 800bc3a:	681b      	ldr	r3, [r3, #0]
 800bc3c:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800bc40:	2b00      	cmp	r3, #0
 800bc42:	d00a      	beq.n	800bc5a <HAL_RCCEx_PeriphCLKConfig+0x3e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 800bc44:	4b37      	ldr	r3, [pc, #220]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bc46:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bc4a:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
 800bc4e:	687b      	ldr	r3, [r7, #4]
 800bc50:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800bc52:	4934      	ldr	r1, [pc, #208]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bc54:	4313      	orrs	r3, r2
 800bc56:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 800bc5a:	687b      	ldr	r3, [r7, #4]
 800bc5c:	681b      	ldr	r3, [r3, #0]
 800bc5e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800bc62:	2b00      	cmp	r3, #0
 800bc64:	d011      	beq.n	800bc8a <HAL_RCCEx_PeriphCLKConfig+0x412>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 800bc66:	4b2f      	ldr	r3, [pc, #188]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bc68:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bc6c:	f023 6200 	bic.w	r2, r3, #134217728	; 0x8000000
 800bc70:	687b      	ldr	r3, [r7, #4]
 800bc72:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bc74:	492b      	ldr	r1, [pc, #172]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bc76:	4313      	orrs	r3, r2
 800bc78:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
 800bc7c:	687b      	ldr	r3, [r7, #4]
 800bc7e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bc80:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800bc84:	d101      	bne.n	800bc8a <HAL_RCCEx_PeriphCLKConfig+0x412>
    {
      pllsaiused = 1;
 800bc86:	2301      	movs	r3, #1
 800bc88:	613b      	str	r3, [r7, #16]
    }
  }

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 800bc8a:	687b      	ldr	r3, [r7, #4]
 800bc8c:	681b      	ldr	r3, [r3, #0]
 800bc8e:	f003 0308 	and.w	r3, r3, #8
 800bc92:	2b00      	cmp	r3, #0
 800bc94:	d001      	beq.n	800bc9a <HAL_RCCEx_PeriphCLKConfig+0x422>
  {
    pllsaiused = 1;
 800bc96:	2301      	movs	r3, #1
 800bc98:	613b      	str	r3, [r7, #16]
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800bc9a:	687b      	ldr	r3, [r7, #4]
 800bc9c:	681b      	ldr	r3, [r3, #0]
 800bc9e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800bca2:	2b00      	cmp	r3, #0
 800bca4:	d00a      	beq.n	800bcbc <HAL_RCCEx_PeriphCLKConfig+0x444>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 800bca6:	4b1f      	ldr	r3, [pc, #124]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bca8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bcac:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
 800bcb0:	687b      	ldr	r3, [r7, #4]
 800bcb2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bcb4:	491b      	ldr	r1, [pc, #108]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bcb6:	4313      	orrs	r3, r2
 800bcb8:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 800bcbc:	687b      	ldr	r3, [r7, #4]
 800bcbe:	681b      	ldr	r3, [r3, #0]
 800bcc0:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800bcc4:	2b00      	cmp	r3, #0
 800bcc6:	d00b      	beq.n	800bce0 <HAL_RCCEx_PeriphCLKConfig+0x468>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 800bcc8:	4b16      	ldr	r3, [pc, #88]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bcca:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bcce:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
 800bcd2:	687b      	ldr	r3, [r7, #4]
 800bcd4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800bcd8:	4912      	ldr	r1, [pc, #72]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bcda:	4313      	orrs	r3, r2
 800bcdc:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
 800bce0:	687b      	ldr	r3, [r7, #4]
 800bce2:	681b      	ldr	r3, [r3, #0]
 800bce4:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 800bce8:	2b00      	cmp	r3, #0
 800bcea:	d00b      	beq.n	800bd04 <HAL_RCCEx_PeriphCLKConfig+0x48c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    /* Configure the SDMMC2 clock source */
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
 800bcec:	4b0d      	ldr	r3, [pc, #52]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bcee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bcf2:	f023 5200 	bic.w	r2, r3, #536870912	; 0x20000000
 800bcf6:	687b      	ldr	r3, [r7, #4]
 800bcf8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800bcfc:	4909      	ldr	r1, [pc, #36]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bcfe:	4313      	orrs	r3, r2
 800bd00:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*------------------------------------- DFSDM1 Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 800bd04:	687b      	ldr	r3, [r7, #4]
 800bd06:	681b      	ldr	r3, [r3, #0]
 800bd08:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800bd0c:	2b00      	cmp	r3, #0
 800bd0e:	d00f      	beq.n	800bd30 <HAL_RCCEx_PeriphCLKConfig+0x4b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 800bd10:	4b04      	ldr	r3, [pc, #16]	; (800bd24 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800bd12:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800bd16:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
 800bd1a:	687b      	ldr	r3, [r7, #4]
 800bd1c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800bd20:	e002      	b.n	800bd28 <HAL_RCCEx_PeriphCLKConfig+0x4b0>
 800bd22:	bf00      	nop
 800bd24:	40023800 	.word	0x40023800
 800bd28:	4986      	ldr	r1, [pc, #536]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bd2a:	4313      	orrs	r3, r2
 800bd2c:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }

  /*------------------------------------- DFSDM AUDIO Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO)
 800bd30:	687b      	ldr	r3, [r7, #4]
 800bd32:	681b      	ldr	r3, [r3, #0]
 800bd34:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800bd38:	2b00      	cmp	r3, #0
 800bd3a:	d00b      	beq.n	800bd54 <HAL_RCCEx_PeriphCLKConfig+0x4dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM interface clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 800bd3c:	4b81      	ldr	r3, [pc, #516]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bd3e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800bd42:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
 800bd46:	687b      	ldr	r3, [r7, #4]
 800bd48:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800bd4c:	497d      	ldr	r1, [pc, #500]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bd4e:	4313      	orrs	r3, r2
 800bd50:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 800bd54:	68fb      	ldr	r3, [r7, #12]
 800bd56:	2b01      	cmp	r3, #1
 800bd58:	d006      	beq.n	800bd68 <HAL_RCCEx_PeriphCLKConfig+0x4f0>
 800bd5a:	687b      	ldr	r3, [r7, #4]
 800bd5c:	681b      	ldr	r3, [r3, #0]
 800bd5e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800bd62:	2b00      	cmp	r3, #0
 800bd64:	f000 80d6 	beq.w	800bf14 <HAL_RCCEx_PeriphCLKConfig+0x69c>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 800bd68:	4b76      	ldr	r3, [pc, #472]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bd6a:	681b      	ldr	r3, [r3, #0]
 800bd6c:	4a75      	ldr	r2, [pc, #468]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bd6e:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800bd72:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800bd74:	f7f5 fffe 	bl	8001d74 <HAL_GetTick>
 800bd78:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800bd7a:	e008      	b.n	800bd8e <HAL_RCCEx_PeriphCLKConfig+0x516>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 800bd7c:	f7f5 fffa 	bl	8001d74 <HAL_GetTick>
 800bd80:	4602      	mov	r2, r0
 800bd82:	697b      	ldr	r3, [r7, #20]
 800bd84:	1ad3      	subs	r3, r2, r3
 800bd86:	2b64      	cmp	r3, #100	; 0x64
 800bd88:	d901      	bls.n	800bd8e <HAL_RCCEx_PeriphCLKConfig+0x516>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800bd8a:	2303      	movs	r3, #3
 800bd8c:	e195      	b.n	800c0ba <HAL_RCCEx_PeriphCLKConfig+0x842>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800bd8e:	4b6d      	ldr	r3, [pc, #436]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bd90:	681b      	ldr	r3, [r3, #0]
 800bd92:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800bd96:	2b00      	cmp	r3, #0
 800bd98:	d1f0      	bne.n	800bd7c <HAL_RCCEx_PeriphCLKConfig+0x504>

    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 800bd9a:	687b      	ldr	r3, [r7, #4]
 800bd9c:	681b      	ldr	r3, [r3, #0]
 800bd9e:	f003 0301 	and.w	r3, r3, #1
 800bda2:	2b00      	cmp	r3, #0
 800bda4:	d021      	beq.n	800bdea <HAL_RCCEx_PeriphCLKConfig+0x572>
 800bda6:	687b      	ldr	r3, [r7, #4]
 800bda8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bdaa:	2b00      	cmp	r3, #0
 800bdac:	d11d      	bne.n	800bdea <HAL_RCCEx_PeriphCLKConfig+0x572>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 800bdae:	4b65      	ldr	r3, [pc, #404]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bdb0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800bdb4:	0c1b      	lsrs	r3, r3, #16
 800bdb6:	f003 0303 	and.w	r3, r3, #3
 800bdba:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 800bdbc:	4b61      	ldr	r3, [pc, #388]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bdbe:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800bdc2:	0e1b      	lsrs	r3, r3, #24
 800bdc4:	f003 030f 	and.w	r3, r3, #15
 800bdc8:	61fb      	str	r3, [r7, #28]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 800bdca:	687b      	ldr	r3, [r7, #4]
 800bdcc:	685b      	ldr	r3, [r3, #4]
 800bdce:	019a      	lsls	r2, r3, #6
 800bdd0:	69bb      	ldr	r3, [r7, #24]
 800bdd2:	041b      	lsls	r3, r3, #16
 800bdd4:	431a      	orrs	r2, r3
 800bdd6:	69fb      	ldr	r3, [r7, #28]
 800bdd8:	061b      	lsls	r3, r3, #24
 800bdda:	431a      	orrs	r2, r3
 800bddc:	687b      	ldr	r3, [r7, #4]
 800bdde:	689b      	ldr	r3, [r3, #8]
 800bde0:	071b      	lsls	r3, r3, #28
 800bde2:	4958      	ldr	r1, [pc, #352]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bde4:	4313      	orrs	r3, r2
 800bde6:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 800bdea:	687b      	ldr	r3, [r7, #4]
 800bdec:	681b      	ldr	r3, [r3, #0]
 800bdee:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800bdf2:	2b00      	cmp	r3, #0
 800bdf4:	d004      	beq.n	800be00 <HAL_RCCEx_PeriphCLKConfig+0x588>
 800bdf6:	687b      	ldr	r3, [r7, #4]
 800bdf8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800bdfa:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800bdfe:	d00a      	beq.n	800be16 <HAL_RCCEx_PeriphCLKConfig+0x59e>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 800be00:	687b      	ldr	r3, [r7, #4]
 800be02:	681b      	ldr	r3, [r3, #0]
 800be04:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 800be08:	2b00      	cmp	r3, #0
 800be0a:	d02e      	beq.n	800be6a <HAL_RCCEx_PeriphCLKConfig+0x5f2>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 800be0c:	687b      	ldr	r3, [r7, #4]
 800be0e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800be10:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800be14:	d129      	bne.n	800be6a <HAL_RCCEx_PeriphCLKConfig+0x5f2>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      /* Check for PLLI2S/DIVQ parameters */
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));

      /* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 800be16:	4b4b      	ldr	r3, [pc, #300]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800be18:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800be1c:	0c1b      	lsrs	r3, r3, #16
 800be1e:	f003 0303 	and.w	r3, r3, #3
 800be22:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 800be24:	4b47      	ldr	r3, [pc, #284]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800be26:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800be2a:	0f1b      	lsrs	r3, r3, #28
 800be2c:	f003 0307 	and.w	r3, r3, #7
 800be30:	61fb      	str	r3, [r7, #28]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 800be32:	687b      	ldr	r3, [r7, #4]
 800be34:	685b      	ldr	r3, [r3, #4]
 800be36:	019a      	lsls	r2, r3, #6
 800be38:	69bb      	ldr	r3, [r7, #24]
 800be3a:	041b      	lsls	r3, r3, #16
 800be3c:	431a      	orrs	r2, r3
 800be3e:	687b      	ldr	r3, [r7, #4]
 800be40:	68db      	ldr	r3, [r3, #12]
 800be42:	061b      	lsls	r3, r3, #24
 800be44:	431a      	orrs	r2, r3
 800be46:	69fb      	ldr	r3, [r7, #28]
 800be48:	071b      	lsls	r3, r3, #28
 800be4a:	493e      	ldr	r1, [pc, #248]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800be4c:	4313      	orrs	r3, r2
 800be4e:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84

      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 800be52:	4b3c      	ldr	r3, [pc, #240]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800be54:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800be58:	f023 021f 	bic.w	r2, r3, #31
 800be5c:	687b      	ldr	r3, [r7, #4]
 800be5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800be60:	3b01      	subs	r3, #1
 800be62:	4938      	ldr	r1, [pc, #224]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800be64:	4313      	orrs	r3, r2
 800be66:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800be6a:	687b      	ldr	r3, [r7, #4]
 800be6c:	681b      	ldr	r3, [r3, #0]
 800be6e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800be72:	2b00      	cmp	r3, #0
 800be74:	d01d      	beq.n	800beb2 <HAL_RCCEx_PeriphCLKConfig+0x63a>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));

     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 800be76:	4b33      	ldr	r3, [pc, #204]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800be78:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800be7c:	0e1b      	lsrs	r3, r3, #24
 800be7e:	f003 030f 	and.w	r3, r3, #15
 800be82:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 800be84:	4b2f      	ldr	r3, [pc, #188]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800be86:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800be8a:	0f1b      	lsrs	r3, r3, #28
 800be8c:	f003 0307 	and.w	r3, r3, #7
 800be90:	61fb      	str	r3, [r7, #28]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 800be92:	687b      	ldr	r3, [r7, #4]
 800be94:	685b      	ldr	r3, [r3, #4]
 800be96:	019a      	lsls	r2, r3, #6
 800be98:	687b      	ldr	r3, [r7, #4]
 800be9a:	691b      	ldr	r3, [r3, #16]
 800be9c:	041b      	lsls	r3, r3, #16
 800be9e:	431a      	orrs	r2, r3
 800bea0:	69bb      	ldr	r3, [r7, #24]
 800bea2:	061b      	lsls	r3, r3, #24
 800bea4:	431a      	orrs	r2, r3
 800bea6:	69fb      	ldr	r3, [r7, #28]
 800bea8:	071b      	lsls	r3, r3, #28
 800beaa:	4926      	ldr	r1, [pc, #152]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800beac:	4313      	orrs	r3, r2
 800beae:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 800beb2:	687b      	ldr	r3, [r7, #4]
 800beb4:	681b      	ldr	r3, [r3, #0]
 800beb6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800beba:	2b00      	cmp	r3, #0
 800bebc:	d011      	beq.n	800bee2 <HAL_RCCEx_PeriphCLKConfig+0x66a>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));

      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) */
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 800bebe:	687b      	ldr	r3, [r7, #4]
 800bec0:	685b      	ldr	r3, [r3, #4]
 800bec2:	019a      	lsls	r2, r3, #6
 800bec4:	687b      	ldr	r3, [r7, #4]
 800bec6:	691b      	ldr	r3, [r3, #16]
 800bec8:	041b      	lsls	r3, r3, #16
 800beca:	431a      	orrs	r2, r3
 800becc:	687b      	ldr	r3, [r7, #4]
 800bece:	68db      	ldr	r3, [r3, #12]
 800bed0:	061b      	lsls	r3, r3, #24
 800bed2:	431a      	orrs	r2, r3
 800bed4:	687b      	ldr	r3, [r7, #4]
 800bed6:	689b      	ldr	r3, [r3, #8]
 800bed8:	071b      	lsls	r3, r3, #28
 800beda:	491a      	ldr	r1, [pc, #104]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bedc:	4313      	orrs	r3, r2
 800bede:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 800bee2:	4b18      	ldr	r3, [pc, #96]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bee4:	681b      	ldr	r3, [r3, #0]
 800bee6:	4a17      	ldr	r2, [pc, #92]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bee8:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800beec:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800beee:	f7f5 ff41 	bl	8001d74 <HAL_GetTick>
 800bef2:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 800bef4:	e008      	b.n	800bf08 <HAL_RCCEx_PeriphCLKConfig+0x690>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 800bef6:	f7f5 ff3d 	bl	8001d74 <HAL_GetTick>
 800befa:	4602      	mov	r2, r0
 800befc:	697b      	ldr	r3, [r7, #20]
 800befe:	1ad3      	subs	r3, r2, r3
 800bf00:	2b64      	cmp	r3, #100	; 0x64
 800bf02:	d901      	bls.n	800bf08 <HAL_RCCEx_PeriphCLKConfig+0x690>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800bf04:	2303      	movs	r3, #3
 800bf06:	e0d8      	b.n	800c0ba <HAL_RCCEx_PeriphCLKConfig+0x842>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 800bf08:	4b0e      	ldr	r3, [pc, #56]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bf0a:	681b      	ldr	r3, [r3, #0]
 800bf0c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800bf10:	2b00      	cmp	r3, #0
 800bf12:	d0f0      	beq.n	800bef6 <HAL_RCCEx_PeriphCLKConfig+0x67e>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 800bf14:	693b      	ldr	r3, [r7, #16]
 800bf16:	2b01      	cmp	r3, #1
 800bf18:	f040 80ce 	bne.w	800c0b8 <HAL_RCCEx_PeriphCLKConfig+0x840>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE();
 800bf1c:	4b09      	ldr	r3, [pc, #36]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bf1e:	681b      	ldr	r3, [r3, #0]
 800bf20:	4a08      	ldr	r2, [pc, #32]	; (800bf44 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800bf22:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800bf26:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800bf28:	f7f5 ff24 	bl	8001d74 <HAL_GetTick>
 800bf2c:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 800bf2e:	e00b      	b.n	800bf48 <HAL_RCCEx_PeriphCLKConfig+0x6d0>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 800bf30:	f7f5 ff20 	bl	8001d74 <HAL_GetTick>
 800bf34:	4602      	mov	r2, r0
 800bf36:	697b      	ldr	r3, [r7, #20]
 800bf38:	1ad3      	subs	r3, r2, r3
 800bf3a:	2b64      	cmp	r3, #100	; 0x64
 800bf3c:	d904      	bls.n	800bf48 <HAL_RCCEx_PeriphCLKConfig+0x6d0>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800bf3e:	2303      	movs	r3, #3
 800bf40:	e0bb      	b.n	800c0ba <HAL_RCCEx_PeriphCLKConfig+0x842>
 800bf42:	bf00      	nop
 800bf44:	40023800 	.word	0x40023800
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 800bf48:	4b5e      	ldr	r3, [pc, #376]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800bf4a:	681b      	ldr	r3, [r3, #0]
 800bf4c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800bf50:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800bf54:	d0ec      	beq.n	800bf30 <HAL_RCCEx_PeriphCLKConfig+0x6b8>

    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));

    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 800bf56:	687b      	ldr	r3, [r7, #4]
 800bf58:	681b      	ldr	r3, [r3, #0]
 800bf5a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800bf5e:	2b00      	cmp	r3, #0
 800bf60:	d003      	beq.n	800bf6a <HAL_RCCEx_PeriphCLKConfig+0x6f2>
 800bf62:	687b      	ldr	r3, [r7, #4]
 800bf64:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800bf66:	2b00      	cmp	r3, #0
 800bf68:	d009      	beq.n	800bf7e <HAL_RCCEx_PeriphCLKConfig+0x706>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 800bf6a:	687b      	ldr	r3, [r7, #4]
 800bf6c:	681b      	ldr	r3, [r3, #0]
 800bf6e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 800bf72:	2b00      	cmp	r3, #0
 800bf74:	d02e      	beq.n	800bfd4 <HAL_RCCEx_PeriphCLKConfig+0x75c>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 800bf76:	687b      	ldr	r3, [r7, #4]
 800bf78:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800bf7a:	2b00      	cmp	r3, #0
 800bf7c:	d12a      	bne.n	800bfd4 <HAL_RCCEx_PeriphCLKConfig+0x75c>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));

      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 800bf7e:	4b51      	ldr	r3, [pc, #324]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800bf80:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800bf84:	0c1b      	lsrs	r3, r3, #16
 800bf86:	f003 0303 	and.w	r3, r3, #3
 800bf8a:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 800bf8c:	4b4d      	ldr	r3, [pc, #308]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800bf8e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800bf92:	0f1b      	lsrs	r3, r3, #28
 800bf94:	f003 0307 	and.w	r3, r3, #7
 800bf98:	61fb      	str	r3, [r7, #28]
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 800bf9a:	687b      	ldr	r3, [r7, #4]
 800bf9c:	695b      	ldr	r3, [r3, #20]
 800bf9e:	019a      	lsls	r2, r3, #6
 800bfa0:	69bb      	ldr	r3, [r7, #24]
 800bfa2:	041b      	lsls	r3, r3, #16
 800bfa4:	431a      	orrs	r2, r3
 800bfa6:	687b      	ldr	r3, [r7, #4]
 800bfa8:	699b      	ldr	r3, [r3, #24]
 800bfaa:	061b      	lsls	r3, r3, #24
 800bfac:	431a      	orrs	r2, r3
 800bfae:	69fb      	ldr	r3, [r7, #28]
 800bfb0:	071b      	lsls	r3, r3, #28
 800bfb2:	4944      	ldr	r1, [pc, #272]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800bfb4:	4313      	orrs	r3, r2
 800bfb6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 800bfba:	4b42      	ldr	r3, [pc, #264]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800bfbc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800bfc0:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
 800bfc4:	687b      	ldr	r3, [r7, #4]
 800bfc6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800bfc8:	3b01      	subs	r3, #1
 800bfca:	021b      	lsls	r3, r3, #8
 800bfcc:	493d      	ldr	r1, [pc, #244]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800bfce:	4313      	orrs	r3, r2
 800bfd0:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/
    /* In Case of PLLI2S is selected as source clock for CK48 */
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 800bfd4:	687b      	ldr	r3, [r7, #4]
 800bfd6:	681b      	ldr	r3, [r3, #0]
 800bfd8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800bfdc:	2b00      	cmp	r3, #0
 800bfde:	d022      	beq.n	800c026 <HAL_RCCEx_PeriphCLKConfig+0x7ae>
 800bfe0:	687b      	ldr	r3, [r7, #4]
 800bfe2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bfe4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800bfe8:	d11d      	bne.n	800c026 <HAL_RCCEx_PeriphCLKConfig+0x7ae>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 800bfea:	4b36      	ldr	r3, [pc, #216]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800bfec:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800bff0:	0e1b      	lsrs	r3, r3, #24
 800bff2:	f003 030f 	and.w	r3, r3, #15
 800bff6:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 800bff8:	4b32      	ldr	r3, [pc, #200]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800bffa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800bffe:	0f1b      	lsrs	r3, r3, #28
 800c000:	f003 0307 	and.w	r3, r3, #7
 800c004:	61fb      	str	r3, [r7, #28]

      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 800c006:	687b      	ldr	r3, [r7, #4]
 800c008:	695b      	ldr	r3, [r3, #20]
 800c00a:	019a      	lsls	r2, r3, #6
 800c00c:	687b      	ldr	r3, [r7, #4]
 800c00e:	6a1b      	ldr	r3, [r3, #32]
 800c010:	041b      	lsls	r3, r3, #16
 800c012:	431a      	orrs	r2, r3
 800c014:	69bb      	ldr	r3, [r7, #24]
 800c016:	061b      	lsls	r3, r3, #24
 800c018:	431a      	orrs	r2, r3
 800c01a:	69fb      	ldr	r3, [r7, #28]
 800c01c:	071b      	lsls	r3, r3, #28
 800c01e:	4929      	ldr	r1, [pc, #164]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c020:	4313      	orrs	r3, r2
 800c022:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    }

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 800c026:	687b      	ldr	r3, [r7, #4]
 800c028:	681b      	ldr	r3, [r3, #0]
 800c02a:	f003 0308 	and.w	r3, r3, #8
 800c02e:	2b00      	cmp	r3, #0
 800c030:	d028      	beq.n	800c084 <HAL_RCCEx_PeriphCLKConfig+0x80c>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));

      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 800c032:	4b24      	ldr	r3, [pc, #144]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c034:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800c038:	0e1b      	lsrs	r3, r3, #24
 800c03a:	f003 030f 	and.w	r3, r3, #15
 800c03e:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 800c040:	4b20      	ldr	r3, [pc, #128]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c042:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800c046:	0c1b      	lsrs	r3, r3, #16
 800c048:	f003 0303 	and.w	r3, r3, #3
 800c04c:	61fb      	str	r3, [r7, #28]

      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 800c04e:	687b      	ldr	r3, [r7, #4]
 800c050:	695b      	ldr	r3, [r3, #20]
 800c052:	019a      	lsls	r2, r3, #6
 800c054:	69fb      	ldr	r3, [r7, #28]
 800c056:	041b      	lsls	r3, r3, #16
 800c058:	431a      	orrs	r2, r3
 800c05a:	69bb      	ldr	r3, [r7, #24]
 800c05c:	061b      	lsls	r3, r3, #24
 800c05e:	431a      	orrs	r2, r3
 800c060:	687b      	ldr	r3, [r7, #4]
 800c062:	69db      	ldr	r3, [r3, #28]
 800c064:	071b      	lsls	r3, r3, #28
 800c066:	4917      	ldr	r1, [pc, #92]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c068:	4313      	orrs	r3, r2
 800c06a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 800c06e:	4b15      	ldr	r3, [pc, #84]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c070:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c074:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 800c078:	687b      	ldr	r3, [r7, #4]
 800c07a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c07c:	4911      	ldr	r1, [pc, #68]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c07e:	4313      	orrs	r3, r2
 800c080:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  */

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
 800c084:	4b0f      	ldr	r3, [pc, #60]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c086:	681b      	ldr	r3, [r3, #0]
 800c088:	4a0e      	ldr	r2, [pc, #56]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c08a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c08e:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800c090:	f7f5 fe70 	bl	8001d74 <HAL_GetTick>
 800c094:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800c096:	e008      	b.n	800c0aa <HAL_RCCEx_PeriphCLKConfig+0x832>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 800c098:	f7f5 fe6c 	bl	8001d74 <HAL_GetTick>
 800c09c:	4602      	mov	r2, r0
 800c09e:	697b      	ldr	r3, [r7, #20]
 800c0a0:	1ad3      	subs	r3, r2, r3
 800c0a2:	2b64      	cmp	r3, #100	; 0x64
 800c0a4:	d901      	bls.n	800c0aa <HAL_RCCEx_PeriphCLKConfig+0x832>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800c0a6:	2303      	movs	r3, #3
 800c0a8:	e007      	b.n	800c0ba <HAL_RCCEx_PeriphCLKConfig+0x842>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800c0aa:	4b06      	ldr	r3, [pc, #24]	; (800c0c4 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c0ac:	681b      	ldr	r3, [r3, #0]
 800c0ae:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800c0b2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800c0b6:	d1ef      	bne.n	800c098 <HAL_RCCEx_PeriphCLKConfig+0x820>
      }
    }
  }
  return HAL_OK;
 800c0b8:	2300      	movs	r3, #0
}
 800c0ba:	4618      	mov	r0, r3
 800c0bc:	3720      	adds	r7, #32
 800c0be:	46bd      	mov	sp, r7
 800c0c0:	bd80      	pop	{r7, pc}
 800c0c2:	bf00      	nop
 800c0c4:	40023800 	.word	0x40023800

0800c0c8 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 800c0c8:	b580      	push	{r7, lr}
 800c0ca:	b082      	sub	sp, #8
 800c0cc:	af00      	add	r7, sp, #0
 800c0ce:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800c0d0:	687b      	ldr	r3, [r7, #4]
 800c0d2:	2b00      	cmp	r3, #0
 800c0d4:	d101      	bne.n	800c0da <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 800c0d6:	2301      	movs	r3, #1
 800c0d8:	e039      	b.n	800c14e <HAL_TIM_Base_Init+0x86>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800c0da:	687b      	ldr	r3, [r7, #4]
 800c0dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c0de:	2b00      	cmp	r3, #0
 800c0e0:	d105      	bne.n	800c0ee <HAL_TIM_Base_Init+0x26>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800c0e2:	687b      	ldr	r3, [r7, #4]
 800c0e4:	2200      	movs	r2, #0
 800c0e6:	63da      	str	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 800c0e8:	6878      	ldr	r0, [r7, #4]
 800c0ea:	f7f5 fbd3 	bl	8001894 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800c0ee:	687b      	ldr	r3, [r7, #4]
 800c0f0:	2202      	movs	r2, #2
 800c0f2:	641a      	str	r2, [r3, #64]	; 0x40

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800c0f4:	687b      	ldr	r3, [r7, #4]
 800c0f6:	681a      	ldr	r2, [r3, #0]
 800c0f8:	687b      	ldr	r3, [r7, #4]
 800c0fa:	3304      	adds	r3, #4
 800c0fc:	4619      	mov	r1, r3
 800c0fe:	4610      	mov	r0, r2
 800c100:	f000 faac 	bl	800c65c <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800c104:	687b      	ldr	r3, [r7, #4]
 800c106:	2201      	movs	r2, #1
 800c108:	66da      	str	r2, [r3, #108]	; 0x6c

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800c10a:	687b      	ldr	r3, [r7, #4]
 800c10c:	2201      	movs	r2, #1
 800c10e:	645a      	str	r2, [r3, #68]	; 0x44
 800c110:	687b      	ldr	r3, [r7, #4]
 800c112:	2201      	movs	r2, #1
 800c114:	649a      	str	r2, [r3, #72]	; 0x48
 800c116:	687b      	ldr	r3, [r7, #4]
 800c118:	2201      	movs	r2, #1
 800c11a:	64da      	str	r2, [r3, #76]	; 0x4c
 800c11c:	687b      	ldr	r3, [r7, #4]
 800c11e:	2201      	movs	r2, #1
 800c120:	651a      	str	r2, [r3, #80]	; 0x50
 800c122:	687b      	ldr	r3, [r7, #4]
 800c124:	2201      	movs	r2, #1
 800c126:	655a      	str	r2, [r3, #84]	; 0x54
 800c128:	687b      	ldr	r3, [r7, #4]
 800c12a:	2201      	movs	r2, #1
 800c12c:	659a      	str	r2, [r3, #88]	; 0x58
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800c12e:	687b      	ldr	r3, [r7, #4]
 800c130:	2201      	movs	r2, #1
 800c132:	65da      	str	r2, [r3, #92]	; 0x5c
 800c134:	687b      	ldr	r3, [r7, #4]
 800c136:	2201      	movs	r2, #1
 800c138:	661a      	str	r2, [r3, #96]	; 0x60
 800c13a:	687b      	ldr	r3, [r7, #4]
 800c13c:	2201      	movs	r2, #1
 800c13e:	665a      	str	r2, [r3, #100]	; 0x64
 800c140:	687b      	ldr	r3, [r7, #4]
 800c142:	2201      	movs	r2, #1
 800c144:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800c146:	687b      	ldr	r3, [r7, #4]
 800c148:	2201      	movs	r2, #1
 800c14a:	641a      	str	r2, [r3, #64]	; 0x40

  return HAL_OK;
 800c14c:	2300      	movs	r3, #0
}
 800c14e:	4618      	mov	r0, r3
 800c150:	3708      	adds	r7, #8
 800c152:	46bd      	mov	sp, r7
 800c154:	bd80      	pop	{r7, pc}
	...

0800c158 <HAL_TIM_Base_Start>:
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
 800c158:	b480      	push	{r7}
 800c15a:	b085      	sub	sp, #20
 800c15c:	af00      	add	r7, sp, #0
 800c15e:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 800c160:	687b      	ldr	r3, [r7, #4]
 800c162:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c164:	2b01      	cmp	r3, #1
 800c166:	d001      	beq.n	800c16c <HAL_TIM_Base_Start+0x14>
  {
    return HAL_ERROR;
 800c168:	2301      	movs	r3, #1
 800c16a:	e04b      	b.n	800c204 <HAL_TIM_Base_Start+0xac>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800c16c:	687b      	ldr	r3, [r7, #4]
 800c16e:	2202      	movs	r2, #2
 800c170:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800c172:	687b      	ldr	r3, [r7, #4]
 800c174:	681b      	ldr	r3, [r3, #0]
 800c176:	4a26      	ldr	r2, [pc, #152]	; (800c210 <HAL_TIM_Base_Start+0xb8>)
 800c178:	4293      	cmp	r3, r2
 800c17a:	d022      	beq.n	800c1c2 <HAL_TIM_Base_Start+0x6a>
 800c17c:	687b      	ldr	r3, [r7, #4]
 800c17e:	681b      	ldr	r3, [r3, #0]
 800c180:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800c184:	d01d      	beq.n	800c1c2 <HAL_TIM_Base_Start+0x6a>
 800c186:	687b      	ldr	r3, [r7, #4]
 800c188:	681b      	ldr	r3, [r3, #0]
 800c18a:	4a22      	ldr	r2, [pc, #136]	; (800c214 <HAL_TIM_Base_Start+0xbc>)
 800c18c:	4293      	cmp	r3, r2
 800c18e:	d018      	beq.n	800c1c2 <HAL_TIM_Base_Start+0x6a>
 800c190:	687b      	ldr	r3, [r7, #4]
 800c192:	681b      	ldr	r3, [r3, #0]
 800c194:	4a20      	ldr	r2, [pc, #128]	; (800c218 <HAL_TIM_Base_Start+0xc0>)
 800c196:	4293      	cmp	r3, r2
 800c198:	d013      	beq.n	800c1c2 <HAL_TIM_Base_Start+0x6a>
 800c19a:	687b      	ldr	r3, [r7, #4]
 800c19c:	681b      	ldr	r3, [r3, #0]
 800c19e:	4a1f      	ldr	r2, [pc, #124]	; (800c21c <HAL_TIM_Base_Start+0xc4>)
 800c1a0:	4293      	cmp	r3, r2
 800c1a2:	d00e      	beq.n	800c1c2 <HAL_TIM_Base_Start+0x6a>
 800c1a4:	687b      	ldr	r3, [r7, #4]
 800c1a6:	681b      	ldr	r3, [r3, #0]
 800c1a8:	4a1d      	ldr	r2, [pc, #116]	; (800c220 <HAL_TIM_Base_Start+0xc8>)
 800c1aa:	4293      	cmp	r3, r2
 800c1ac:	d009      	beq.n	800c1c2 <HAL_TIM_Base_Start+0x6a>
 800c1ae:	687b      	ldr	r3, [r7, #4]
 800c1b0:	681b      	ldr	r3, [r3, #0]
 800c1b2:	4a1c      	ldr	r2, [pc, #112]	; (800c224 <HAL_TIM_Base_Start+0xcc>)
 800c1b4:	4293      	cmp	r3, r2
 800c1b6:	d004      	beq.n	800c1c2 <HAL_TIM_Base_Start+0x6a>
 800c1b8:	687b      	ldr	r3, [r7, #4]
 800c1ba:	681b      	ldr	r3, [r3, #0]
 800c1bc:	4a1a      	ldr	r2, [pc, #104]	; (800c228 <HAL_TIM_Base_Start+0xd0>)
 800c1be:	4293      	cmp	r3, r2
 800c1c0:	d115      	bne.n	800c1ee <HAL_TIM_Base_Start+0x96>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800c1c2:	687b      	ldr	r3, [r7, #4]
 800c1c4:	681b      	ldr	r3, [r3, #0]
 800c1c6:	689a      	ldr	r2, [r3, #8]
 800c1c8:	4b18      	ldr	r3, [pc, #96]	; (800c22c <HAL_TIM_Base_Start+0xd4>)
 800c1ca:	4013      	ands	r3, r2
 800c1cc:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800c1ce:	68fb      	ldr	r3, [r7, #12]
 800c1d0:	2b06      	cmp	r3, #6
 800c1d2:	d015      	beq.n	800c200 <HAL_TIM_Base_Start+0xa8>
 800c1d4:	68fb      	ldr	r3, [r7, #12]
 800c1d6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800c1da:	d011      	beq.n	800c200 <HAL_TIM_Base_Start+0xa8>
    {
      __HAL_TIM_ENABLE(htim);
 800c1dc:	687b      	ldr	r3, [r7, #4]
 800c1de:	681b      	ldr	r3, [r3, #0]
 800c1e0:	681a      	ldr	r2, [r3, #0]
 800c1e2:	687b      	ldr	r3, [r7, #4]
 800c1e4:	681b      	ldr	r3, [r3, #0]
 800c1e6:	f042 0201 	orr.w	r2, r2, #1
 800c1ea:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800c1ec:	e008      	b.n	800c200 <HAL_TIM_Base_Start+0xa8>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 800c1ee:	687b      	ldr	r3, [r7, #4]
 800c1f0:	681b      	ldr	r3, [r3, #0]
 800c1f2:	681a      	ldr	r2, [r3, #0]
 800c1f4:	687b      	ldr	r3, [r7, #4]
 800c1f6:	681b      	ldr	r3, [r3, #0]
 800c1f8:	f042 0201 	orr.w	r2, r2, #1
 800c1fc:	601a      	str	r2, [r3, #0]
 800c1fe:	e000      	b.n	800c202 <HAL_TIM_Base_Start+0xaa>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800c200:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 800c202:	2300      	movs	r3, #0
}
 800c204:	4618      	mov	r0, r3
 800c206:	3714      	adds	r7, #20
 800c208:	46bd      	mov	sp, r7
 800c20a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c20e:	4770      	bx	lr
 800c210:	40010000 	.word	0x40010000
 800c214:	40000400 	.word	0x40000400
 800c218:	40000800 	.word	0x40000800
 800c21c:	40000c00 	.word	0x40000c00
 800c220:	40010400 	.word	0x40010400
 800c224:	40014000 	.word	0x40014000
 800c228:	40001800 	.word	0x40001800
 800c22c:	00010007 	.word	0x00010007

0800c230 <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 800c230:	b580      	push	{r7, lr}
 800c232:	b082      	sub	sp, #8
 800c234:	af00      	add	r7, sp, #0
 800c236:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800c238:	687b      	ldr	r3, [r7, #4]
 800c23a:	681b      	ldr	r3, [r3, #0]
 800c23c:	691b      	ldr	r3, [r3, #16]
 800c23e:	f003 0302 	and.w	r3, r3, #2
 800c242:	2b02      	cmp	r3, #2
 800c244:	d122      	bne.n	800c28c <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800c246:	687b      	ldr	r3, [r7, #4]
 800c248:	681b      	ldr	r3, [r3, #0]
 800c24a:	68db      	ldr	r3, [r3, #12]
 800c24c:	f003 0302 	and.w	r3, r3, #2
 800c250:	2b02      	cmp	r3, #2
 800c252:	d11b      	bne.n	800c28c <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800c254:	687b      	ldr	r3, [r7, #4]
 800c256:	681b      	ldr	r3, [r3, #0]
 800c258:	f06f 0202 	mvn.w	r2, #2
 800c25c:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800c25e:	687b      	ldr	r3, [r7, #4]
 800c260:	2201      	movs	r2, #1
 800c262:	61da      	str	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800c264:	687b      	ldr	r3, [r7, #4]
 800c266:	681b      	ldr	r3, [r3, #0]
 800c268:	699b      	ldr	r3, [r3, #24]
 800c26a:	f003 0303 	and.w	r3, r3, #3
 800c26e:	2b00      	cmp	r3, #0
 800c270:	d003      	beq.n	800c27a <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 800c272:	6878      	ldr	r0, [r7, #4]
 800c274:	f000 f9d4 	bl	800c620 <HAL_TIM_IC_CaptureCallback>
 800c278:	e005      	b.n	800c286 <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800c27a:	6878      	ldr	r0, [r7, #4]
 800c27c:	f000 f9c6 	bl	800c60c <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800c280:	6878      	ldr	r0, [r7, #4]
 800c282:	f000 f9d7 	bl	800c634 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800c286:	687b      	ldr	r3, [r7, #4]
 800c288:	2200      	movs	r2, #0
 800c28a:	61da      	str	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800c28c:	687b      	ldr	r3, [r7, #4]
 800c28e:	681b      	ldr	r3, [r3, #0]
 800c290:	691b      	ldr	r3, [r3, #16]
 800c292:	f003 0304 	and.w	r3, r3, #4
 800c296:	2b04      	cmp	r3, #4
 800c298:	d122      	bne.n	800c2e0 <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 800c29a:	687b      	ldr	r3, [r7, #4]
 800c29c:	681b      	ldr	r3, [r3, #0]
 800c29e:	68db      	ldr	r3, [r3, #12]
 800c2a0:	f003 0304 	and.w	r3, r3, #4
 800c2a4:	2b04      	cmp	r3, #4
 800c2a6:	d11b      	bne.n	800c2e0 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800c2a8:	687b      	ldr	r3, [r7, #4]
 800c2aa:	681b      	ldr	r3, [r3, #0]
 800c2ac:	f06f 0204 	mvn.w	r2, #4
 800c2b0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800c2b2:	687b      	ldr	r3, [r7, #4]
 800c2b4:	2202      	movs	r2, #2
 800c2b6:	61da      	str	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800c2b8:	687b      	ldr	r3, [r7, #4]
 800c2ba:	681b      	ldr	r3, [r3, #0]
 800c2bc:	699b      	ldr	r3, [r3, #24]
 800c2be:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800c2c2:	2b00      	cmp	r3, #0
 800c2c4:	d003      	beq.n	800c2ce <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800c2c6:	6878      	ldr	r0, [r7, #4]
 800c2c8:	f000 f9aa 	bl	800c620 <HAL_TIM_IC_CaptureCallback>
 800c2cc:	e005      	b.n	800c2da <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800c2ce:	6878      	ldr	r0, [r7, #4]
 800c2d0:	f000 f99c 	bl	800c60c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800c2d4:	6878      	ldr	r0, [r7, #4]
 800c2d6:	f000 f9ad 	bl	800c634 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800c2da:	687b      	ldr	r3, [r7, #4]
 800c2dc:	2200      	movs	r2, #0
 800c2de:	61da      	str	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800c2e0:	687b      	ldr	r3, [r7, #4]
 800c2e2:	681b      	ldr	r3, [r3, #0]
 800c2e4:	691b      	ldr	r3, [r3, #16]
 800c2e6:	f003 0308 	and.w	r3, r3, #8
 800c2ea:	2b08      	cmp	r3, #8
 800c2ec:	d122      	bne.n	800c334 <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800c2ee:	687b      	ldr	r3, [r7, #4]
 800c2f0:	681b      	ldr	r3, [r3, #0]
 800c2f2:	68db      	ldr	r3, [r3, #12]
 800c2f4:	f003 0308 	and.w	r3, r3, #8
 800c2f8:	2b08      	cmp	r3, #8
 800c2fa:	d11b      	bne.n	800c334 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800c2fc:	687b      	ldr	r3, [r7, #4]
 800c2fe:	681b      	ldr	r3, [r3, #0]
 800c300:	f06f 0208 	mvn.w	r2, #8
 800c304:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800c306:	687b      	ldr	r3, [r7, #4]
 800c308:	2204      	movs	r2, #4
 800c30a:	61da      	str	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800c30c:	687b      	ldr	r3, [r7, #4]
 800c30e:	681b      	ldr	r3, [r3, #0]
 800c310:	69db      	ldr	r3, [r3, #28]
 800c312:	f003 0303 	and.w	r3, r3, #3
 800c316:	2b00      	cmp	r3, #0
 800c318:	d003      	beq.n	800c322 <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800c31a:	6878      	ldr	r0, [r7, #4]
 800c31c:	f000 f980 	bl	800c620 <HAL_TIM_IC_CaptureCallback>
 800c320:	e005      	b.n	800c32e <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800c322:	6878      	ldr	r0, [r7, #4]
 800c324:	f000 f972 	bl	800c60c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800c328:	6878      	ldr	r0, [r7, #4]
 800c32a:	f000 f983 	bl	800c634 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800c32e:	687b      	ldr	r3, [r7, #4]
 800c330:	2200      	movs	r2, #0
 800c332:	61da      	str	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800c334:	687b      	ldr	r3, [r7, #4]
 800c336:	681b      	ldr	r3, [r3, #0]
 800c338:	691b      	ldr	r3, [r3, #16]
 800c33a:	f003 0310 	and.w	r3, r3, #16
 800c33e:	2b10      	cmp	r3, #16
 800c340:	d122      	bne.n	800c388 <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 800c342:	687b      	ldr	r3, [r7, #4]
 800c344:	681b      	ldr	r3, [r3, #0]
 800c346:	68db      	ldr	r3, [r3, #12]
 800c348:	f003 0310 	and.w	r3, r3, #16
 800c34c:	2b10      	cmp	r3, #16
 800c34e:	d11b      	bne.n	800c388 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800c350:	687b      	ldr	r3, [r7, #4]
 800c352:	681b      	ldr	r3, [r3, #0]
 800c354:	f06f 0210 	mvn.w	r2, #16
 800c358:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800c35a:	687b      	ldr	r3, [r7, #4]
 800c35c:	2208      	movs	r2, #8
 800c35e:	61da      	str	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800c360:	687b      	ldr	r3, [r7, #4]
 800c362:	681b      	ldr	r3, [r3, #0]
 800c364:	69db      	ldr	r3, [r3, #28]
 800c366:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800c36a:	2b00      	cmp	r3, #0
 800c36c:	d003      	beq.n	800c376 <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800c36e:	6878      	ldr	r0, [r7, #4]
 800c370:	f000 f956 	bl	800c620 <HAL_TIM_IC_CaptureCallback>
 800c374:	e005      	b.n	800c382 <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800c376:	6878      	ldr	r0, [r7, #4]
 800c378:	f000 f948 	bl	800c60c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800c37c:	6878      	ldr	r0, [r7, #4]
 800c37e:	f000 f959 	bl	800c634 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800c382:	687b      	ldr	r3, [r7, #4]
 800c384:	2200      	movs	r2, #0
 800c386:	61da      	str	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800c388:	687b      	ldr	r3, [r7, #4]
 800c38a:	681b      	ldr	r3, [r3, #0]
 800c38c:	691b      	ldr	r3, [r3, #16]
 800c38e:	f003 0301 	and.w	r3, r3, #1
 800c392:	2b01      	cmp	r3, #1
 800c394:	d10e      	bne.n	800c3b4 <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800c396:	687b      	ldr	r3, [r7, #4]
 800c398:	681b      	ldr	r3, [r3, #0]
 800c39a:	68db      	ldr	r3, [r3, #12]
 800c39c:	f003 0301 	and.w	r3, r3, #1
 800c3a0:	2b01      	cmp	r3, #1
 800c3a2:	d107      	bne.n	800c3b4 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800c3a4:	687b      	ldr	r3, [r7, #4]
 800c3a6:	681b      	ldr	r3, [r3, #0]
 800c3a8:	f06f 0201 	mvn.w	r2, #1
 800c3ac:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800c3ae:	6878      	ldr	r0, [r7, #4]
 800c3b0:	f000 f922 	bl	800c5f8 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800c3b4:	687b      	ldr	r3, [r7, #4]
 800c3b6:	681b      	ldr	r3, [r3, #0]
 800c3b8:	691b      	ldr	r3, [r3, #16]
 800c3ba:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800c3be:	2b80      	cmp	r3, #128	; 0x80
 800c3c0:	d10e      	bne.n	800c3e0 <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800c3c2:	687b      	ldr	r3, [r7, #4]
 800c3c4:	681b      	ldr	r3, [r3, #0]
 800c3c6:	68db      	ldr	r3, [r3, #12]
 800c3c8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800c3cc:	2b80      	cmp	r3, #128	; 0x80
 800c3ce:	d107      	bne.n	800c3e0 <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800c3d0:	687b      	ldr	r3, [r7, #4]
 800c3d2:	681b      	ldr	r3, [r3, #0]
 800c3d4:	f06f 0280 	mvn.w	r2, #128	; 0x80
 800c3d8:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 800c3da:	6878      	ldr	r0, [r7, #4]
 800c3dc:	f000 fff0 	bl	800d3c0 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800c3e0:	687b      	ldr	r3, [r7, #4]
 800c3e2:	681b      	ldr	r3, [r3, #0]
 800c3e4:	691b      	ldr	r3, [r3, #16]
 800c3e6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800c3ea:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c3ee:	d10e      	bne.n	800c40e <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800c3f0:	687b      	ldr	r3, [r7, #4]
 800c3f2:	681b      	ldr	r3, [r3, #0]
 800c3f4:	68db      	ldr	r3, [r3, #12]
 800c3f6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800c3fa:	2b80      	cmp	r3, #128	; 0x80
 800c3fc:	d107      	bne.n	800c40e <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800c3fe:	687b      	ldr	r3, [r7, #4]
 800c400:	681b      	ldr	r3, [r3, #0]
 800c402:	f46f 7280 	mvn.w	r2, #256	; 0x100
 800c406:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 800c408:	6878      	ldr	r0, [r7, #4]
 800c40a:	f000 ffe3 	bl	800d3d4 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800c40e:	687b      	ldr	r3, [r7, #4]
 800c410:	681b      	ldr	r3, [r3, #0]
 800c412:	691b      	ldr	r3, [r3, #16]
 800c414:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800c418:	2b40      	cmp	r3, #64	; 0x40
 800c41a:	d10e      	bne.n	800c43a <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 800c41c:	687b      	ldr	r3, [r7, #4]
 800c41e:	681b      	ldr	r3, [r3, #0]
 800c420:	68db      	ldr	r3, [r3, #12]
 800c422:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800c426:	2b40      	cmp	r3, #64	; 0x40
 800c428:	d107      	bne.n	800c43a <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800c42a:	687b      	ldr	r3, [r7, #4]
 800c42c:	681b      	ldr	r3, [r3, #0]
 800c42e:	f06f 0240 	mvn.w	r2, #64	; 0x40
 800c432:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 800c434:	6878      	ldr	r0, [r7, #4]
 800c436:	f000 f907 	bl	800c648 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800c43a:	687b      	ldr	r3, [r7, #4]
 800c43c:	681b      	ldr	r3, [r3, #0]
 800c43e:	691b      	ldr	r3, [r3, #16]
 800c440:	f003 0320 	and.w	r3, r3, #32
 800c444:	2b20      	cmp	r3, #32
 800c446:	d10e      	bne.n	800c466 <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 800c448:	687b      	ldr	r3, [r7, #4]
 800c44a:	681b      	ldr	r3, [r3, #0]
 800c44c:	68db      	ldr	r3, [r3, #12]
 800c44e:	f003 0320 	and.w	r3, r3, #32
 800c452:	2b20      	cmp	r3, #32
 800c454:	d107      	bne.n	800c466 <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800c456:	687b      	ldr	r3, [r7, #4]
 800c458:	681b      	ldr	r3, [r3, #0]
 800c45a:	f06f 0220 	mvn.w	r2, #32
 800c45e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 800c460:	6878      	ldr	r0, [r7, #4]
 800c462:	f000 ffa3 	bl	800d3ac <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 800c466:	bf00      	nop
 800c468:	3708      	adds	r7, #8
 800c46a:	46bd      	mov	sp, r7
 800c46c:	bd80      	pop	{r7, pc}
	...

0800c470 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 800c470:	b580      	push	{r7, lr}
 800c472:	b084      	sub	sp, #16
 800c474:	af00      	add	r7, sp, #0
 800c476:	6078      	str	r0, [r7, #4]
 800c478:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800c47a:	2300      	movs	r3, #0
 800c47c:	60bb      	str	r3, [r7, #8]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 800c47e:	687b      	ldr	r3, [r7, #4]
 800c480:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c482:	2b01      	cmp	r3, #1
 800c484:	d101      	bne.n	800c48a <HAL_TIM_ConfigClockSource+0x1a>
 800c486:	2302      	movs	r3, #2
 800c488:	e0b0      	b.n	800c5ec <HAL_TIM_ConfigClockSource+0x17c>
 800c48a:	687b      	ldr	r3, [r7, #4]
 800c48c:	2201      	movs	r2, #1
 800c48e:	63da      	str	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 800c490:	687b      	ldr	r3, [r7, #4]
 800c492:	2202      	movs	r2, #2
 800c494:	641a      	str	r2, [r3, #64]	; 0x40

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 800c496:	687b      	ldr	r3, [r7, #4]
 800c498:	681b      	ldr	r3, [r3, #0]
 800c49a:	689b      	ldr	r3, [r3, #8]
 800c49c:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 800c49e:	68fa      	ldr	r2, [r7, #12]
 800c4a0:	4b54      	ldr	r3, [pc, #336]	; (800c5f4 <HAL_TIM_ConfigClockSource+0x184>)
 800c4a2:	4013      	ands	r3, r2
 800c4a4:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800c4a6:	68fb      	ldr	r3, [r7, #12]
 800c4a8:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800c4ac:	60fb      	str	r3, [r7, #12]
  htim->Instance->SMCR = tmpsmcr;
 800c4ae:	687b      	ldr	r3, [r7, #4]
 800c4b0:	681b      	ldr	r3, [r3, #0]
 800c4b2:	68fa      	ldr	r2, [r7, #12]
 800c4b4:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 800c4b6:	683b      	ldr	r3, [r7, #0]
 800c4b8:	681b      	ldr	r3, [r3, #0]
 800c4ba:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800c4be:	d03e      	beq.n	800c53e <HAL_TIM_ConfigClockSource+0xce>
 800c4c0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800c4c4:	f200 8087 	bhi.w	800c5d6 <HAL_TIM_ConfigClockSource+0x166>
 800c4c8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800c4cc:	f000 8086 	beq.w	800c5dc <HAL_TIM_ConfigClockSource+0x16c>
 800c4d0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800c4d4:	d87f      	bhi.n	800c5d6 <HAL_TIM_ConfigClockSource+0x166>
 800c4d6:	2b70      	cmp	r3, #112	; 0x70
 800c4d8:	d01a      	beq.n	800c510 <HAL_TIM_ConfigClockSource+0xa0>
 800c4da:	2b70      	cmp	r3, #112	; 0x70
 800c4dc:	d87b      	bhi.n	800c5d6 <HAL_TIM_ConfigClockSource+0x166>
 800c4de:	2b60      	cmp	r3, #96	; 0x60
 800c4e0:	d050      	beq.n	800c584 <HAL_TIM_ConfigClockSource+0x114>
 800c4e2:	2b60      	cmp	r3, #96	; 0x60
 800c4e4:	d877      	bhi.n	800c5d6 <HAL_TIM_ConfigClockSource+0x166>
 800c4e6:	2b50      	cmp	r3, #80	; 0x50
 800c4e8:	d03c      	beq.n	800c564 <HAL_TIM_ConfigClockSource+0xf4>
 800c4ea:	2b50      	cmp	r3, #80	; 0x50
 800c4ec:	d873      	bhi.n	800c5d6 <HAL_TIM_ConfigClockSource+0x166>
 800c4ee:	2b40      	cmp	r3, #64	; 0x40
 800c4f0:	d058      	beq.n	800c5a4 <HAL_TIM_ConfigClockSource+0x134>
 800c4f2:	2b40      	cmp	r3, #64	; 0x40
 800c4f4:	d86f      	bhi.n	800c5d6 <HAL_TIM_ConfigClockSource+0x166>
 800c4f6:	2b30      	cmp	r3, #48	; 0x30
 800c4f8:	d064      	beq.n	800c5c4 <HAL_TIM_ConfigClockSource+0x154>
 800c4fa:	2b30      	cmp	r3, #48	; 0x30
 800c4fc:	d86b      	bhi.n	800c5d6 <HAL_TIM_ConfigClockSource+0x166>
 800c4fe:	2b20      	cmp	r3, #32
 800c500:	d060      	beq.n	800c5c4 <HAL_TIM_ConfigClockSource+0x154>
 800c502:	2b20      	cmp	r3, #32
 800c504:	d867      	bhi.n	800c5d6 <HAL_TIM_ConfigClockSource+0x166>
 800c506:	2b00      	cmp	r3, #0
 800c508:	d05c      	beq.n	800c5c4 <HAL_TIM_ConfigClockSource+0x154>
 800c50a:	2b10      	cmp	r3, #16
 800c50c:	d05a      	beq.n	800c5c4 <HAL_TIM_ConfigClockSource+0x154>
 800c50e:	e062      	b.n	800c5d6 <HAL_TIM_ConfigClockSource+0x166>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800c510:	687b      	ldr	r3, [r7, #4]
 800c512:	6818      	ldr	r0, [r3, #0]
 800c514:	683b      	ldr	r3, [r7, #0]
 800c516:	6899      	ldr	r1, [r3, #8]
 800c518:	683b      	ldr	r3, [r7, #0]
 800c51a:	685a      	ldr	r2, [r3, #4]
 800c51c:	683b      	ldr	r3, [r7, #0]
 800c51e:	68db      	ldr	r3, [r3, #12]
 800c520:	f000 f9b6 	bl	800c890 <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
 800c524:	687b      	ldr	r3, [r7, #4]
 800c526:	681b      	ldr	r3, [r3, #0]
 800c528:	689b      	ldr	r3, [r3, #8]
 800c52a:	60fb      	str	r3, [r7, #12]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800c52c:	68fb      	ldr	r3, [r7, #12]
 800c52e:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 800c532:	60fb      	str	r3, [r7, #12]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 800c534:	687b      	ldr	r3, [r7, #4]
 800c536:	681b      	ldr	r3, [r3, #0]
 800c538:	68fa      	ldr	r2, [r7, #12]
 800c53a:	609a      	str	r2, [r3, #8]
      break;
 800c53c:	e04f      	b.n	800c5de <HAL_TIM_ConfigClockSource+0x16e>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800c53e:	687b      	ldr	r3, [r7, #4]
 800c540:	6818      	ldr	r0, [r3, #0]
 800c542:	683b      	ldr	r3, [r7, #0]
 800c544:	6899      	ldr	r1, [r3, #8]
 800c546:	683b      	ldr	r3, [r7, #0]
 800c548:	685a      	ldr	r2, [r3, #4]
 800c54a:	683b      	ldr	r3, [r7, #0]
 800c54c:	68db      	ldr	r3, [r3, #12]
 800c54e:	f000 f99f 	bl	800c890 <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800c552:	687b      	ldr	r3, [r7, #4]
 800c554:	681b      	ldr	r3, [r3, #0]
 800c556:	689a      	ldr	r2, [r3, #8]
 800c558:	687b      	ldr	r3, [r7, #4]
 800c55a:	681b      	ldr	r3, [r3, #0]
 800c55c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800c560:	609a      	str	r2, [r3, #8]
      break;
 800c562:	e03c      	b.n	800c5de <HAL_TIM_ConfigClockSource+0x16e>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800c564:	687b      	ldr	r3, [r7, #4]
 800c566:	6818      	ldr	r0, [r3, #0]
 800c568:	683b      	ldr	r3, [r7, #0]
 800c56a:	6859      	ldr	r1, [r3, #4]
 800c56c:	683b      	ldr	r3, [r7, #0]
 800c56e:	68db      	ldr	r3, [r3, #12]
 800c570:	461a      	mov	r2, r3
 800c572:	f000 f913 	bl	800c79c <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 800c576:	687b      	ldr	r3, [r7, #4]
 800c578:	681b      	ldr	r3, [r3, #0]
 800c57a:	2150      	movs	r1, #80	; 0x50
 800c57c:	4618      	mov	r0, r3
 800c57e:	f000 f96c 	bl	800c85a <TIM_ITRx_SetConfig>
      break;
 800c582:	e02c      	b.n	800c5de <HAL_TIM_ConfigClockSource+0x16e>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 800c584:	687b      	ldr	r3, [r7, #4]
 800c586:	6818      	ldr	r0, [r3, #0]
 800c588:	683b      	ldr	r3, [r7, #0]
 800c58a:	6859      	ldr	r1, [r3, #4]
 800c58c:	683b      	ldr	r3, [r7, #0]
 800c58e:	68db      	ldr	r3, [r3, #12]
 800c590:	461a      	mov	r2, r3
 800c592:	f000 f932 	bl	800c7fa <TIM_TI2_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 800c596:	687b      	ldr	r3, [r7, #4]
 800c598:	681b      	ldr	r3, [r3, #0]
 800c59a:	2160      	movs	r1, #96	; 0x60
 800c59c:	4618      	mov	r0, r3
 800c59e:	f000 f95c 	bl	800c85a <TIM_ITRx_SetConfig>
      break;
 800c5a2:	e01c      	b.n	800c5de <HAL_TIM_ConfigClockSource+0x16e>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800c5a4:	687b      	ldr	r3, [r7, #4]
 800c5a6:	6818      	ldr	r0, [r3, #0]
 800c5a8:	683b      	ldr	r3, [r7, #0]
 800c5aa:	6859      	ldr	r1, [r3, #4]
 800c5ac:	683b      	ldr	r3, [r7, #0]
 800c5ae:	68db      	ldr	r3, [r3, #12]
 800c5b0:	461a      	mov	r2, r3
 800c5b2:	f000 f8f3 	bl	800c79c <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 800c5b6:	687b      	ldr	r3, [r7, #4]
 800c5b8:	681b      	ldr	r3, [r3, #0]
 800c5ba:	2140      	movs	r1, #64	; 0x40
 800c5bc:	4618      	mov	r0, r3
 800c5be:	f000 f94c 	bl	800c85a <TIM_ITRx_SetConfig>
      break;
 800c5c2:	e00c      	b.n	800c5de <HAL_TIM_ConfigClockSource+0x16e>
    case TIM_CLOCKSOURCE_ITR3:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 800c5c4:	687b      	ldr	r3, [r7, #4]
 800c5c6:	681a      	ldr	r2, [r3, #0]
 800c5c8:	683b      	ldr	r3, [r7, #0]
 800c5ca:	681b      	ldr	r3, [r3, #0]
 800c5cc:	4619      	mov	r1, r3
 800c5ce:	4610      	mov	r0, r2
 800c5d0:	f000 f943 	bl	800c85a <TIM_ITRx_SetConfig>
      break;
 800c5d4:	e003      	b.n	800c5de <HAL_TIM_ConfigClockSource+0x16e>
    }

    default:
      status = HAL_ERROR;
 800c5d6:	2301      	movs	r3, #1
 800c5d8:	60bb      	str	r3, [r7, #8]
      break;
 800c5da:	e000      	b.n	800c5de <HAL_TIM_ConfigClockSource+0x16e>
      break;
 800c5dc:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 800c5de:	687b      	ldr	r3, [r7, #4]
 800c5e0:	2201      	movs	r2, #1
 800c5e2:	641a      	str	r2, [r3, #64]	; 0x40

  __HAL_UNLOCK(htim);
 800c5e4:	687b      	ldr	r3, [r7, #4]
 800c5e6:	2200      	movs	r2, #0
 800c5e8:	63da      	str	r2, [r3, #60]	; 0x3c

  return status;
 800c5ea:	68bb      	ldr	r3, [r7, #8]
}
 800c5ec:	4618      	mov	r0, r3
 800c5ee:	3710      	adds	r7, #16
 800c5f0:	46bd      	mov	sp, r7
 800c5f2:	bd80      	pop	{r7, pc}
 800c5f4:	fffeff88 	.word	0xfffeff88

0800c5f8 <HAL_TIM_PeriodElapsedCallback>:
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 800c5f8:	b480      	push	{r7}
 800c5fa:	b083      	sub	sp, #12
 800c5fc:	af00      	add	r7, sp, #0
 800c5fe:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   */
}
 800c600:	bf00      	nop
 800c602:	370c      	adds	r7, #12
 800c604:	46bd      	mov	sp, r7
 800c606:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c60a:	4770      	bx	lr

0800c60c <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 800c60c:	b480      	push	{r7}
 800c60e:	b083      	sub	sp, #12
 800c610:	af00      	add	r7, sp, #0
 800c612:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 800c614:	bf00      	nop
 800c616:	370c      	adds	r7, #12
 800c618:	46bd      	mov	sp, r7
 800c61a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c61e:	4770      	bx	lr

0800c620 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 800c620:	b480      	push	{r7}
 800c622:	b083      	sub	sp, #12
 800c624:	af00      	add	r7, sp, #0
 800c626:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800c628:	bf00      	nop
 800c62a:	370c      	adds	r7, #12
 800c62c:	46bd      	mov	sp, r7
 800c62e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c632:	4770      	bx	lr

0800c634 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800c634:	b480      	push	{r7}
 800c636:	b083      	sub	sp, #12
 800c638:	af00      	add	r7, sp, #0
 800c63a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 800c63c:	bf00      	nop
 800c63e:	370c      	adds	r7, #12
 800c640:	46bd      	mov	sp, r7
 800c642:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c646:	4770      	bx	lr

0800c648 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 800c648:	b480      	push	{r7}
 800c64a:	b083      	sub	sp, #12
 800c64c:	af00      	add	r7, sp, #0
 800c64e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 800c650:	bf00      	nop
 800c652:	370c      	adds	r7, #12
 800c654:	46bd      	mov	sp, r7
 800c656:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c65a:	4770      	bx	lr

0800c65c <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 800c65c:	b480      	push	{r7}
 800c65e:	b085      	sub	sp, #20
 800c660:	af00      	add	r7, sp, #0
 800c662:	6078      	str	r0, [r7, #4]
 800c664:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800c666:	687b      	ldr	r3, [r7, #4]
 800c668:	681b      	ldr	r3, [r3, #0]
 800c66a:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800c66c:	687b      	ldr	r3, [r7, #4]
 800c66e:	4a40      	ldr	r2, [pc, #256]	; (800c770 <TIM_Base_SetConfig+0x114>)
 800c670:	4293      	cmp	r3, r2
 800c672:	d013      	beq.n	800c69c <TIM_Base_SetConfig+0x40>
 800c674:	687b      	ldr	r3, [r7, #4]
 800c676:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800c67a:	d00f      	beq.n	800c69c <TIM_Base_SetConfig+0x40>
 800c67c:	687b      	ldr	r3, [r7, #4]
 800c67e:	4a3d      	ldr	r2, [pc, #244]	; (800c774 <TIM_Base_SetConfig+0x118>)
 800c680:	4293      	cmp	r3, r2
 800c682:	d00b      	beq.n	800c69c <TIM_Base_SetConfig+0x40>
 800c684:	687b      	ldr	r3, [r7, #4]
 800c686:	4a3c      	ldr	r2, [pc, #240]	; (800c778 <TIM_Base_SetConfig+0x11c>)
 800c688:	4293      	cmp	r3, r2
 800c68a:	d007      	beq.n	800c69c <TIM_Base_SetConfig+0x40>
 800c68c:	687b      	ldr	r3, [r7, #4]
 800c68e:	4a3b      	ldr	r2, [pc, #236]	; (800c77c <TIM_Base_SetConfig+0x120>)
 800c690:	4293      	cmp	r3, r2
 800c692:	d003      	beq.n	800c69c <TIM_Base_SetConfig+0x40>
 800c694:	687b      	ldr	r3, [r7, #4]
 800c696:	4a3a      	ldr	r2, [pc, #232]	; (800c780 <TIM_Base_SetConfig+0x124>)
 800c698:	4293      	cmp	r3, r2
 800c69a:	d108      	bne.n	800c6ae <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800c69c:	68fb      	ldr	r3, [r7, #12]
 800c69e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c6a2:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800c6a4:	683b      	ldr	r3, [r7, #0]
 800c6a6:	685b      	ldr	r3, [r3, #4]
 800c6a8:	68fa      	ldr	r2, [r7, #12]
 800c6aa:	4313      	orrs	r3, r2
 800c6ac:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c6ae:	687b      	ldr	r3, [r7, #4]
 800c6b0:	4a2f      	ldr	r2, [pc, #188]	; (800c770 <TIM_Base_SetConfig+0x114>)
 800c6b2:	4293      	cmp	r3, r2
 800c6b4:	d02b      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c6b6:	687b      	ldr	r3, [r7, #4]
 800c6b8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800c6bc:	d027      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c6be:	687b      	ldr	r3, [r7, #4]
 800c6c0:	4a2c      	ldr	r2, [pc, #176]	; (800c774 <TIM_Base_SetConfig+0x118>)
 800c6c2:	4293      	cmp	r3, r2
 800c6c4:	d023      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c6c6:	687b      	ldr	r3, [r7, #4]
 800c6c8:	4a2b      	ldr	r2, [pc, #172]	; (800c778 <TIM_Base_SetConfig+0x11c>)
 800c6ca:	4293      	cmp	r3, r2
 800c6cc:	d01f      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c6ce:	687b      	ldr	r3, [r7, #4]
 800c6d0:	4a2a      	ldr	r2, [pc, #168]	; (800c77c <TIM_Base_SetConfig+0x120>)
 800c6d2:	4293      	cmp	r3, r2
 800c6d4:	d01b      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c6d6:	687b      	ldr	r3, [r7, #4]
 800c6d8:	4a29      	ldr	r2, [pc, #164]	; (800c780 <TIM_Base_SetConfig+0x124>)
 800c6da:	4293      	cmp	r3, r2
 800c6dc:	d017      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c6de:	687b      	ldr	r3, [r7, #4]
 800c6e0:	4a28      	ldr	r2, [pc, #160]	; (800c784 <TIM_Base_SetConfig+0x128>)
 800c6e2:	4293      	cmp	r3, r2
 800c6e4:	d013      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c6e6:	687b      	ldr	r3, [r7, #4]
 800c6e8:	4a27      	ldr	r2, [pc, #156]	; (800c788 <TIM_Base_SetConfig+0x12c>)
 800c6ea:	4293      	cmp	r3, r2
 800c6ec:	d00f      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c6ee:	687b      	ldr	r3, [r7, #4]
 800c6f0:	4a26      	ldr	r2, [pc, #152]	; (800c78c <TIM_Base_SetConfig+0x130>)
 800c6f2:	4293      	cmp	r3, r2
 800c6f4:	d00b      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	4a25      	ldr	r2, [pc, #148]	; (800c790 <TIM_Base_SetConfig+0x134>)
 800c6fa:	4293      	cmp	r3, r2
 800c6fc:	d007      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c6fe:	687b      	ldr	r3, [r7, #4]
 800c700:	4a24      	ldr	r2, [pc, #144]	; (800c794 <TIM_Base_SetConfig+0x138>)
 800c702:	4293      	cmp	r3, r2
 800c704:	d003      	beq.n	800c70e <TIM_Base_SetConfig+0xb2>
 800c706:	687b      	ldr	r3, [r7, #4]
 800c708:	4a23      	ldr	r2, [pc, #140]	; (800c798 <TIM_Base_SetConfig+0x13c>)
 800c70a:	4293      	cmp	r3, r2
 800c70c:	d108      	bne.n	800c720 <TIM_Base_SetConfig+0xc4>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800c70e:	68fb      	ldr	r3, [r7, #12]
 800c710:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c714:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800c716:	683b      	ldr	r3, [r7, #0]
 800c718:	68db      	ldr	r3, [r3, #12]
 800c71a:	68fa      	ldr	r2, [r7, #12]
 800c71c:	4313      	orrs	r3, r2
 800c71e:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800c720:	68fb      	ldr	r3, [r7, #12]
 800c722:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800c726:	683b      	ldr	r3, [r7, #0]
 800c728:	695b      	ldr	r3, [r3, #20]
 800c72a:	4313      	orrs	r3, r2
 800c72c:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 800c72e:	687b      	ldr	r3, [r7, #4]
 800c730:	68fa      	ldr	r2, [r7, #12]
 800c732:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800c734:	683b      	ldr	r3, [r7, #0]
 800c736:	689a      	ldr	r2, [r3, #8]
 800c738:	687b      	ldr	r3, [r7, #4]
 800c73a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800c73c:	683b      	ldr	r3, [r7, #0]
 800c73e:	681a      	ldr	r2, [r3, #0]
 800c740:	687b      	ldr	r3, [r7, #4]
 800c742:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800c744:	687b      	ldr	r3, [r7, #4]
 800c746:	4a0a      	ldr	r2, [pc, #40]	; (800c770 <TIM_Base_SetConfig+0x114>)
 800c748:	4293      	cmp	r3, r2
 800c74a:	d003      	beq.n	800c754 <TIM_Base_SetConfig+0xf8>
 800c74c:	687b      	ldr	r3, [r7, #4]
 800c74e:	4a0c      	ldr	r2, [pc, #48]	; (800c780 <TIM_Base_SetConfig+0x124>)
 800c750:	4293      	cmp	r3, r2
 800c752:	d103      	bne.n	800c75c <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800c754:	683b      	ldr	r3, [r7, #0]
 800c756:	691a      	ldr	r2, [r3, #16]
 800c758:	687b      	ldr	r3, [r7, #4]
 800c75a:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800c75c:	687b      	ldr	r3, [r7, #4]
 800c75e:	2201      	movs	r2, #1
 800c760:	615a      	str	r2, [r3, #20]
}
 800c762:	bf00      	nop
 800c764:	3714      	adds	r7, #20
 800c766:	46bd      	mov	sp, r7
 800c768:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c76c:	4770      	bx	lr
 800c76e:	bf00      	nop
 800c770:	40010000 	.word	0x40010000
 800c774:	40000400 	.word	0x40000400
 800c778:	40000800 	.word	0x40000800
 800c77c:	40000c00 	.word	0x40000c00
 800c780:	40010400 	.word	0x40010400
 800c784:	40014000 	.word	0x40014000
 800c788:	40014400 	.word	0x40014400
 800c78c:	40014800 	.word	0x40014800
 800c790:	40001800 	.word	0x40001800
 800c794:	40001c00 	.word	0x40001c00
 800c798:	40002000 	.word	0x40002000

0800c79c <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800c79c:	b480      	push	{r7}
 800c79e:	b087      	sub	sp, #28
 800c7a0:	af00      	add	r7, sp, #0
 800c7a2:	60f8      	str	r0, [r7, #12]
 800c7a4:	60b9      	str	r1, [r7, #8]
 800c7a6:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 800c7a8:	68fb      	ldr	r3, [r7, #12]
 800c7aa:	6a1b      	ldr	r3, [r3, #32]
 800c7ac:	613b      	str	r3, [r7, #16]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800c7ae:	68fb      	ldr	r3, [r7, #12]
 800c7b0:	6a1b      	ldr	r3, [r3, #32]
 800c7b2:	f023 0201 	bic.w	r2, r3, #1
 800c7b6:	68fb      	ldr	r3, [r7, #12]
 800c7b8:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800c7ba:	68fb      	ldr	r3, [r7, #12]
 800c7bc:	699b      	ldr	r3, [r3, #24]
 800c7be:	617b      	str	r3, [r7, #20]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800c7c0:	697b      	ldr	r3, [r7, #20]
 800c7c2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800c7c6:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800c7c8:	687b      	ldr	r3, [r7, #4]
 800c7ca:	011b      	lsls	r3, r3, #4
 800c7cc:	697a      	ldr	r2, [r7, #20]
 800c7ce:	4313      	orrs	r3, r2
 800c7d0:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800c7d2:	693b      	ldr	r3, [r7, #16]
 800c7d4:	f023 030a 	bic.w	r3, r3, #10
 800c7d8:	613b      	str	r3, [r7, #16]
  tmpccer |= TIM_ICPolarity;
 800c7da:	693a      	ldr	r2, [r7, #16]
 800c7dc:	68bb      	ldr	r3, [r7, #8]
 800c7de:	4313      	orrs	r3, r2
 800c7e0:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 800c7e2:	68fb      	ldr	r3, [r7, #12]
 800c7e4:	697a      	ldr	r2, [r7, #20]
 800c7e6:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800c7e8:	68fb      	ldr	r3, [r7, #12]
 800c7ea:	693a      	ldr	r2, [r7, #16]
 800c7ec:	621a      	str	r2, [r3, #32]
}
 800c7ee:	bf00      	nop
 800c7f0:	371c      	adds	r7, #28
 800c7f2:	46bd      	mov	sp, r7
 800c7f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7f8:	4770      	bx	lr

0800c7fa <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800c7fa:	b480      	push	{r7}
 800c7fc:	b087      	sub	sp, #28
 800c7fe:	af00      	add	r7, sp, #0
 800c800:	60f8      	str	r0, [r7, #12]
 800c802:	60b9      	str	r1, [r7, #8]
 800c804:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800c806:	68fb      	ldr	r3, [r7, #12]
 800c808:	6a1b      	ldr	r3, [r3, #32]
 800c80a:	f023 0210 	bic.w	r2, r3, #16
 800c80e:	68fb      	ldr	r3, [r7, #12]
 800c810:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800c812:	68fb      	ldr	r3, [r7, #12]
 800c814:	699b      	ldr	r3, [r3, #24]
 800c816:	613b      	str	r3, [r7, #16]
  tmpccer = TIMx->CCER;
 800c818:	68fb      	ldr	r3, [r7, #12]
 800c81a:	6a1b      	ldr	r3, [r3, #32]
 800c81c:	617b      	str	r3, [r7, #20]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800c81e:	693b      	ldr	r3, [r7, #16]
 800c820:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 800c824:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800c826:	687b      	ldr	r3, [r7, #4]
 800c828:	031b      	lsls	r3, r3, #12
 800c82a:	693a      	ldr	r2, [r7, #16]
 800c82c:	4313      	orrs	r3, r2
 800c82e:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800c830:	697b      	ldr	r3, [r7, #20]
 800c832:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 800c836:	617b      	str	r3, [r7, #20]
  tmpccer |= (TIM_ICPolarity << 4U);
 800c838:	68bb      	ldr	r3, [r7, #8]
 800c83a:	011b      	lsls	r3, r3, #4
 800c83c:	697a      	ldr	r2, [r7, #20]
 800c83e:	4313      	orrs	r3, r2
 800c840:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800c842:	68fb      	ldr	r3, [r7, #12]
 800c844:	693a      	ldr	r2, [r7, #16]
 800c846:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800c848:	68fb      	ldr	r3, [r7, #12]
 800c84a:	697a      	ldr	r2, [r7, #20]
 800c84c:	621a      	str	r2, [r3, #32]
}
 800c84e:	bf00      	nop
 800c850:	371c      	adds	r7, #28
 800c852:	46bd      	mov	sp, r7
 800c854:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c858:	4770      	bx	lr

0800c85a <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 800c85a:	b480      	push	{r7}
 800c85c:	b085      	sub	sp, #20
 800c85e:	af00      	add	r7, sp, #0
 800c860:	6078      	str	r0, [r7, #4]
 800c862:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800c864:	687b      	ldr	r3, [r7, #4]
 800c866:	689b      	ldr	r3, [r3, #8]
 800c868:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 800c86a:	68fb      	ldr	r3, [r7, #12]
 800c86c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800c870:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800c872:	683a      	ldr	r2, [r7, #0]
 800c874:	68fb      	ldr	r3, [r7, #12]
 800c876:	4313      	orrs	r3, r2
 800c878:	f043 0307 	orr.w	r3, r3, #7
 800c87c:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800c87e:	687b      	ldr	r3, [r7, #4]
 800c880:	68fa      	ldr	r2, [r7, #12]
 800c882:	609a      	str	r2, [r3, #8]
}
 800c884:	bf00      	nop
 800c886:	3714      	adds	r7, #20
 800c888:	46bd      	mov	sp, r7
 800c88a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c88e:	4770      	bx	lr

0800c890 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 800c890:	b480      	push	{r7}
 800c892:	b087      	sub	sp, #28
 800c894:	af00      	add	r7, sp, #0
 800c896:	60f8      	str	r0, [r7, #12]
 800c898:	60b9      	str	r1, [r7, #8]
 800c89a:	607a      	str	r2, [r7, #4]
 800c89c:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 800c89e:	68fb      	ldr	r3, [r7, #12]
 800c8a0:	689b      	ldr	r3, [r3, #8]
 800c8a2:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800c8a4:	697b      	ldr	r3, [r7, #20]
 800c8a6:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800c8aa:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800c8ac:	683b      	ldr	r3, [r7, #0]
 800c8ae:	021a      	lsls	r2, r3, #8
 800c8b0:	687b      	ldr	r3, [r7, #4]
 800c8b2:	431a      	orrs	r2, r3
 800c8b4:	68bb      	ldr	r3, [r7, #8]
 800c8b6:	4313      	orrs	r3, r2
 800c8b8:	697a      	ldr	r2, [r7, #20]
 800c8ba:	4313      	orrs	r3, r2
 800c8bc:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800c8be:	68fb      	ldr	r3, [r7, #12]
 800c8c0:	697a      	ldr	r2, [r7, #20]
 800c8c2:	609a      	str	r2, [r3, #8]
}
 800c8c4:	bf00      	nop
 800c8c6:	371c      	adds	r7, #28
 800c8c8:	46bd      	mov	sp, r7
 800c8ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c8ce:	4770      	bx	lr

0800c8d0 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 800c8d0:	b580      	push	{r7, lr}
 800c8d2:	b082      	sub	sp, #8
 800c8d4:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
 800c8d6:	2300      	movs	r3, #0
 800c8d8:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
 800c8da:	4b23      	ldr	r3, [pc, #140]	; (800c968 <HAL_PWREx_EnableOverDrive+0x98>)
 800c8dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c8de:	4a22      	ldr	r2, [pc, #136]	; (800c968 <HAL_PWREx_EnableOverDrive+0x98>)
 800c8e0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c8e4:	6413      	str	r3, [r2, #64]	; 0x40
 800c8e6:	4b20      	ldr	r3, [pc, #128]	; (800c968 <HAL_PWREx_EnableOverDrive+0x98>)
 800c8e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c8ea:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800c8ee:	603b      	str	r3, [r7, #0]
 800c8f0:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 800c8f2:	4b1e      	ldr	r3, [pc, #120]	; (800c96c <HAL_PWREx_EnableOverDrive+0x9c>)
 800c8f4:	681b      	ldr	r3, [r3, #0]
 800c8f6:	4a1d      	ldr	r2, [pc, #116]	; (800c96c <HAL_PWREx_EnableOverDrive+0x9c>)
 800c8f8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800c8fc:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800c8fe:	f7f5 fa39 	bl	8001d74 <HAL_GetTick>
 800c902:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800c904:	e009      	b.n	800c91a <HAL_PWREx_EnableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800c906:	f7f5 fa35 	bl	8001d74 <HAL_GetTick>
 800c90a:	4602      	mov	r2, r0
 800c90c:	687b      	ldr	r3, [r7, #4]
 800c90e:	1ad3      	subs	r3, r2, r3
 800c910:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800c914:	d901      	bls.n	800c91a <HAL_PWREx_EnableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
 800c916:	2303      	movs	r3, #3
 800c918:	e022      	b.n	800c960 <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800c91a:	4b14      	ldr	r3, [pc, #80]	; (800c96c <HAL_PWREx_EnableOverDrive+0x9c>)
 800c91c:	685b      	ldr	r3, [r3, #4]
 800c91e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800c922:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800c926:	d1ee      	bne.n	800c906 <HAL_PWREx_EnableOverDrive+0x36>
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800c928:	4b10      	ldr	r3, [pc, #64]	; (800c96c <HAL_PWREx_EnableOverDrive+0x9c>)
 800c92a:	681b      	ldr	r3, [r3, #0]
 800c92c:	4a0f      	ldr	r2, [pc, #60]	; (800c96c <HAL_PWREx_EnableOverDrive+0x9c>)
 800c92e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800c932:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800c934:	f7f5 fa1e 	bl	8001d74 <HAL_GetTick>
 800c938:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800c93a:	e009      	b.n	800c950 <HAL_PWREx_EnableOverDrive+0x80>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800c93c:	f7f5 fa1a 	bl	8001d74 <HAL_GetTick>
 800c940:	4602      	mov	r2, r0
 800c942:	687b      	ldr	r3, [r7, #4]
 800c944:	1ad3      	subs	r3, r2, r3
 800c946:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800c94a:	d901      	bls.n	800c950 <HAL_PWREx_EnableOverDrive+0x80>
    {
      return HAL_TIMEOUT;
 800c94c:	2303      	movs	r3, #3
 800c94e:	e007      	b.n	800c960 <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800c950:	4b06      	ldr	r3, [pc, #24]	; (800c96c <HAL_PWREx_EnableOverDrive+0x9c>)
 800c952:	685b      	ldr	r3, [r3, #4]
 800c954:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800c958:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800c95c:	d1ee      	bne.n	800c93c <HAL_PWREx_EnableOverDrive+0x6c>
    }
  } 
  return HAL_OK;
 800c95e:	2300      	movs	r3, #0
}
 800c960:	4618      	mov	r0, r3
 800c962:	3708      	adds	r7, #8
 800c964:	46bd      	mov	sp, r7
 800c966:	bd80      	pop	{r7, pc}
 800c968:	40023800 	.word	0x40023800
 800c96c:	40007000 	.word	0x40007000

0800c970 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800c970:	b580      	push	{r7, lr}
 800c972:	b086      	sub	sp, #24
 800c974:	af00      	add	r7, sp, #0
 800c976:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;
 800c978:	2300      	movs	r3, #0
 800c97a:	60fb      	str	r3, [r7, #12]

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800c97c:	687b      	ldr	r3, [r7, #4]
 800c97e:	2b00      	cmp	r3, #0
 800c980:	d101      	bne.n	800c986 <HAL_RCC_OscConfig+0x16>
  {
    return HAL_ERROR;
 800c982:	2301      	movs	r3, #1
 800c984:	e29b      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800c986:	687b      	ldr	r3, [r7, #4]
 800c988:	681b      	ldr	r3, [r3, #0]
 800c98a:	f003 0301 	and.w	r3, r3, #1
 800c98e:	2b00      	cmp	r3, #0
 800c990:	f000 8087 	beq.w	800caa2 <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 800c994:	4b96      	ldr	r3, [pc, #600]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800c996:	689b      	ldr	r3, [r3, #8]
 800c998:	f003 030c 	and.w	r3, r3, #12
 800c99c:	2b04      	cmp	r3, #4
 800c99e:	d00c      	beq.n	800c9ba <HAL_RCC_OscConfig+0x4a>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800c9a0:	4b93      	ldr	r3, [pc, #588]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800c9a2:	689b      	ldr	r3, [r3, #8]
 800c9a4:	f003 030c 	and.w	r3, r3, #12
 800c9a8:	2b08      	cmp	r3, #8
 800c9aa:	d112      	bne.n	800c9d2 <HAL_RCC_OscConfig+0x62>
 800c9ac:	4b90      	ldr	r3, [pc, #576]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800c9ae:	685b      	ldr	r3, [r3, #4]
 800c9b0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800c9b4:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800c9b8:	d10b      	bne.n	800c9d2 <HAL_RCC_OscConfig+0x62>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800c9ba:	4b8d      	ldr	r3, [pc, #564]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800c9bc:	681b      	ldr	r3, [r3, #0]
 800c9be:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800c9c2:	2b00      	cmp	r3, #0
 800c9c4:	d06c      	beq.n	800caa0 <HAL_RCC_OscConfig+0x130>
 800c9c6:	687b      	ldr	r3, [r7, #4]
 800c9c8:	685b      	ldr	r3, [r3, #4]
 800c9ca:	2b00      	cmp	r3, #0
 800c9cc:	d168      	bne.n	800caa0 <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
 800c9ce:	2301      	movs	r3, #1
 800c9d0:	e275      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800c9d2:	687b      	ldr	r3, [r7, #4]
 800c9d4:	685b      	ldr	r3, [r3, #4]
 800c9d6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800c9da:	d106      	bne.n	800c9ea <HAL_RCC_OscConfig+0x7a>
 800c9dc:	4b84      	ldr	r3, [pc, #528]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800c9de:	681b      	ldr	r3, [r3, #0]
 800c9e0:	4a83      	ldr	r2, [pc, #524]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800c9e2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800c9e6:	6013      	str	r3, [r2, #0]
 800c9e8:	e02e      	b.n	800ca48 <HAL_RCC_OscConfig+0xd8>
 800c9ea:	687b      	ldr	r3, [r7, #4]
 800c9ec:	685b      	ldr	r3, [r3, #4]
 800c9ee:	2b00      	cmp	r3, #0
 800c9f0:	d10c      	bne.n	800ca0c <HAL_RCC_OscConfig+0x9c>
 800c9f2:	4b7f      	ldr	r3, [pc, #508]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800c9f4:	681b      	ldr	r3, [r3, #0]
 800c9f6:	4a7e      	ldr	r2, [pc, #504]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800c9f8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800c9fc:	6013      	str	r3, [r2, #0]
 800c9fe:	4b7c      	ldr	r3, [pc, #496]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca00:	681b      	ldr	r3, [r3, #0]
 800ca02:	4a7b      	ldr	r2, [pc, #492]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca04:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800ca08:	6013      	str	r3, [r2, #0]
 800ca0a:	e01d      	b.n	800ca48 <HAL_RCC_OscConfig+0xd8>
 800ca0c:	687b      	ldr	r3, [r7, #4]
 800ca0e:	685b      	ldr	r3, [r3, #4]
 800ca10:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800ca14:	d10c      	bne.n	800ca30 <HAL_RCC_OscConfig+0xc0>
 800ca16:	4b76      	ldr	r3, [pc, #472]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca18:	681b      	ldr	r3, [r3, #0]
 800ca1a:	4a75      	ldr	r2, [pc, #468]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca1c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800ca20:	6013      	str	r3, [r2, #0]
 800ca22:	4b73      	ldr	r3, [pc, #460]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca24:	681b      	ldr	r3, [r3, #0]
 800ca26:	4a72      	ldr	r2, [pc, #456]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca28:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800ca2c:	6013      	str	r3, [r2, #0]
 800ca2e:	e00b      	b.n	800ca48 <HAL_RCC_OscConfig+0xd8>
 800ca30:	4b6f      	ldr	r3, [pc, #444]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca32:	681b      	ldr	r3, [r3, #0]
 800ca34:	4a6e      	ldr	r2, [pc, #440]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca36:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800ca3a:	6013      	str	r3, [r2, #0]
 800ca3c:	4b6c      	ldr	r3, [pc, #432]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca3e:	681b      	ldr	r3, [r3, #0]
 800ca40:	4a6b      	ldr	r2, [pc, #428]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca42:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800ca46:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800ca48:	687b      	ldr	r3, [r7, #4]
 800ca4a:	685b      	ldr	r3, [r3, #4]
 800ca4c:	2b00      	cmp	r3, #0
 800ca4e:	d013      	beq.n	800ca78 <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800ca50:	f7f5 f990 	bl	8001d74 <HAL_GetTick>
 800ca54:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800ca56:	e008      	b.n	800ca6a <HAL_RCC_OscConfig+0xfa>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800ca58:	f7f5 f98c 	bl	8001d74 <HAL_GetTick>
 800ca5c:	4602      	mov	r2, r0
 800ca5e:	693b      	ldr	r3, [r7, #16]
 800ca60:	1ad3      	subs	r3, r2, r3
 800ca62:	2b64      	cmp	r3, #100	; 0x64
 800ca64:	d901      	bls.n	800ca6a <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800ca66:	2303      	movs	r3, #3
 800ca68:	e229      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800ca6a:	4b61      	ldr	r3, [pc, #388]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca6c:	681b      	ldr	r3, [r3, #0]
 800ca6e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800ca72:	2b00      	cmp	r3, #0
 800ca74:	d0f0      	beq.n	800ca58 <HAL_RCC_OscConfig+0xe8>
 800ca76:	e014      	b.n	800caa2 <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800ca78:	f7f5 f97c 	bl	8001d74 <HAL_GetTick>
 800ca7c:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800ca7e:	e008      	b.n	800ca92 <HAL_RCC_OscConfig+0x122>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800ca80:	f7f5 f978 	bl	8001d74 <HAL_GetTick>
 800ca84:	4602      	mov	r2, r0
 800ca86:	693b      	ldr	r3, [r7, #16]
 800ca88:	1ad3      	subs	r3, r2, r3
 800ca8a:	2b64      	cmp	r3, #100	; 0x64
 800ca8c:	d901      	bls.n	800ca92 <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
 800ca8e:	2303      	movs	r3, #3
 800ca90:	e215      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800ca92:	4b57      	ldr	r3, [pc, #348]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800ca94:	681b      	ldr	r3, [r3, #0]
 800ca96:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800ca9a:	2b00      	cmp	r3, #0
 800ca9c:	d1f0      	bne.n	800ca80 <HAL_RCC_OscConfig+0x110>
 800ca9e:	e000      	b.n	800caa2 <HAL_RCC_OscConfig+0x132>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800caa0:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800caa2:	687b      	ldr	r3, [r7, #4]
 800caa4:	681b      	ldr	r3, [r3, #0]
 800caa6:	f003 0302 	and.w	r3, r3, #2
 800caaa:	2b00      	cmp	r3, #0
 800caac:	d069      	beq.n	800cb82 <HAL_RCC_OscConfig+0x212>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 800caae:	4b50      	ldr	r3, [pc, #320]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cab0:	689b      	ldr	r3, [r3, #8]
 800cab2:	f003 030c 	and.w	r3, r3, #12
 800cab6:	2b00      	cmp	r3, #0
 800cab8:	d00b      	beq.n	800cad2 <HAL_RCC_OscConfig+0x162>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800caba:	4b4d      	ldr	r3, [pc, #308]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cabc:	689b      	ldr	r3, [r3, #8]
 800cabe:	f003 030c 	and.w	r3, r3, #12
 800cac2:	2b08      	cmp	r3, #8
 800cac4:	d11c      	bne.n	800cb00 <HAL_RCC_OscConfig+0x190>
 800cac6:	4b4a      	ldr	r3, [pc, #296]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cac8:	685b      	ldr	r3, [r3, #4]
 800caca:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800cace:	2b00      	cmp	r3, #0
 800cad0:	d116      	bne.n	800cb00 <HAL_RCC_OscConfig+0x190>
    {
      /* When HSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800cad2:	4b47      	ldr	r3, [pc, #284]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cad4:	681b      	ldr	r3, [r3, #0]
 800cad6:	f003 0302 	and.w	r3, r3, #2
 800cada:	2b00      	cmp	r3, #0
 800cadc:	d005      	beq.n	800caea <HAL_RCC_OscConfig+0x17a>
 800cade:	687b      	ldr	r3, [r7, #4]
 800cae0:	68db      	ldr	r3, [r3, #12]
 800cae2:	2b01      	cmp	r3, #1
 800cae4:	d001      	beq.n	800caea <HAL_RCC_OscConfig+0x17a>
      {
        return HAL_ERROR;
 800cae6:	2301      	movs	r3, #1
 800cae8:	e1e9      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800caea:	4b41      	ldr	r3, [pc, #260]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800caec:	681b      	ldr	r3, [r3, #0]
 800caee:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800caf2:	687b      	ldr	r3, [r7, #4]
 800caf4:	691b      	ldr	r3, [r3, #16]
 800caf6:	00db      	lsls	r3, r3, #3
 800caf8:	493d      	ldr	r1, [pc, #244]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cafa:	4313      	orrs	r3, r2
 800cafc:	600b      	str	r3, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800cafe:	e040      	b.n	800cb82 <HAL_RCC_OscConfig+0x212>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 800cb00:	687b      	ldr	r3, [r7, #4]
 800cb02:	68db      	ldr	r3, [r3, #12]
 800cb04:	2b00      	cmp	r3, #0
 800cb06:	d023      	beq.n	800cb50 <HAL_RCC_OscConfig+0x1e0>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800cb08:	4b39      	ldr	r3, [pc, #228]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cb0a:	681b      	ldr	r3, [r3, #0]
 800cb0c:	4a38      	ldr	r2, [pc, #224]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cb0e:	f043 0301 	orr.w	r3, r3, #1
 800cb12:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800cb14:	f7f5 f92e 	bl	8001d74 <HAL_GetTick>
 800cb18:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800cb1a:	e008      	b.n	800cb2e <HAL_RCC_OscConfig+0x1be>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800cb1c:	f7f5 f92a 	bl	8001d74 <HAL_GetTick>
 800cb20:	4602      	mov	r2, r0
 800cb22:	693b      	ldr	r3, [r7, #16]
 800cb24:	1ad3      	subs	r3, r2, r3
 800cb26:	2b02      	cmp	r3, #2
 800cb28:	d901      	bls.n	800cb2e <HAL_RCC_OscConfig+0x1be>
          {
            return HAL_TIMEOUT;
 800cb2a:	2303      	movs	r3, #3
 800cb2c:	e1c7      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800cb2e:	4b30      	ldr	r3, [pc, #192]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cb30:	681b      	ldr	r3, [r3, #0]
 800cb32:	f003 0302 	and.w	r3, r3, #2
 800cb36:	2b00      	cmp	r3, #0
 800cb38:	d0f0      	beq.n	800cb1c <HAL_RCC_OscConfig+0x1ac>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800cb3a:	4b2d      	ldr	r3, [pc, #180]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cb3c:	681b      	ldr	r3, [r3, #0]
 800cb3e:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800cb42:	687b      	ldr	r3, [r7, #4]
 800cb44:	691b      	ldr	r3, [r3, #16]
 800cb46:	00db      	lsls	r3, r3, #3
 800cb48:	4929      	ldr	r1, [pc, #164]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cb4a:	4313      	orrs	r3, r2
 800cb4c:	600b      	str	r3, [r1, #0]
 800cb4e:	e018      	b.n	800cb82 <HAL_RCC_OscConfig+0x212>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800cb50:	4b27      	ldr	r3, [pc, #156]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cb52:	681b      	ldr	r3, [r3, #0]
 800cb54:	4a26      	ldr	r2, [pc, #152]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cb56:	f023 0301 	bic.w	r3, r3, #1
 800cb5a:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800cb5c:	f7f5 f90a 	bl	8001d74 <HAL_GetTick>
 800cb60:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800cb62:	e008      	b.n	800cb76 <HAL_RCC_OscConfig+0x206>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800cb64:	f7f5 f906 	bl	8001d74 <HAL_GetTick>
 800cb68:	4602      	mov	r2, r0
 800cb6a:	693b      	ldr	r3, [r7, #16]
 800cb6c:	1ad3      	subs	r3, r2, r3
 800cb6e:	2b02      	cmp	r3, #2
 800cb70:	d901      	bls.n	800cb76 <HAL_RCC_OscConfig+0x206>
          {
            return HAL_TIMEOUT;
 800cb72:	2303      	movs	r3, #3
 800cb74:	e1a3      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800cb76:	4b1e      	ldr	r3, [pc, #120]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cb78:	681b      	ldr	r3, [r3, #0]
 800cb7a:	f003 0302 	and.w	r3, r3, #2
 800cb7e:	2b00      	cmp	r3, #0
 800cb80:	d1f0      	bne.n	800cb64 <HAL_RCC_OscConfig+0x1f4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800cb82:	687b      	ldr	r3, [r7, #4]
 800cb84:	681b      	ldr	r3, [r3, #0]
 800cb86:	f003 0308 	and.w	r3, r3, #8
 800cb8a:	2b00      	cmp	r3, #0
 800cb8c:	d038      	beq.n	800cc00 <HAL_RCC_OscConfig+0x290>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 800cb8e:	687b      	ldr	r3, [r7, #4]
 800cb90:	695b      	ldr	r3, [r3, #20]
 800cb92:	2b00      	cmp	r3, #0
 800cb94:	d019      	beq.n	800cbca <HAL_RCC_OscConfig+0x25a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800cb96:	4b16      	ldr	r3, [pc, #88]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cb98:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800cb9a:	4a15      	ldr	r2, [pc, #84]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cb9c:	f043 0301 	orr.w	r3, r3, #1
 800cba0:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800cba2:	f7f5 f8e7 	bl	8001d74 <HAL_GetTick>
 800cba6:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800cba8:	e008      	b.n	800cbbc <HAL_RCC_OscConfig+0x24c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800cbaa:	f7f5 f8e3 	bl	8001d74 <HAL_GetTick>
 800cbae:	4602      	mov	r2, r0
 800cbb0:	693b      	ldr	r3, [r7, #16]
 800cbb2:	1ad3      	subs	r3, r2, r3
 800cbb4:	2b02      	cmp	r3, #2
 800cbb6:	d901      	bls.n	800cbbc <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
 800cbb8:	2303      	movs	r3, #3
 800cbba:	e180      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800cbbc:	4b0c      	ldr	r3, [pc, #48]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cbbe:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800cbc0:	f003 0302 	and.w	r3, r3, #2
 800cbc4:	2b00      	cmp	r3, #0
 800cbc6:	d0f0      	beq.n	800cbaa <HAL_RCC_OscConfig+0x23a>
 800cbc8:	e01a      	b.n	800cc00 <HAL_RCC_OscConfig+0x290>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800cbca:	4b09      	ldr	r3, [pc, #36]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cbcc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800cbce:	4a08      	ldr	r2, [pc, #32]	; (800cbf0 <HAL_RCC_OscConfig+0x280>)
 800cbd0:	f023 0301 	bic.w	r3, r3, #1
 800cbd4:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800cbd6:	f7f5 f8cd 	bl	8001d74 <HAL_GetTick>
 800cbda:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800cbdc:	e00a      	b.n	800cbf4 <HAL_RCC_OscConfig+0x284>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800cbde:	f7f5 f8c9 	bl	8001d74 <HAL_GetTick>
 800cbe2:	4602      	mov	r2, r0
 800cbe4:	693b      	ldr	r3, [r7, #16]
 800cbe6:	1ad3      	subs	r3, r2, r3
 800cbe8:	2b02      	cmp	r3, #2
 800cbea:	d903      	bls.n	800cbf4 <HAL_RCC_OscConfig+0x284>
        {
          return HAL_TIMEOUT;
 800cbec:	2303      	movs	r3, #3
 800cbee:	e166      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
 800cbf0:	40023800 	.word	0x40023800
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800cbf4:	4b92      	ldr	r3, [pc, #584]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cbf6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800cbf8:	f003 0302 	and.w	r3, r3, #2
 800cbfc:	2b00      	cmp	r3, #0
 800cbfe:	d1ee      	bne.n	800cbde <HAL_RCC_OscConfig+0x26e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800cc00:	687b      	ldr	r3, [r7, #4]
 800cc02:	681b      	ldr	r3, [r3, #0]
 800cc04:	f003 0304 	and.w	r3, r3, #4
 800cc08:	2b00      	cmp	r3, #0
 800cc0a:	f000 80a4 	beq.w	800cd56 <HAL_RCC_OscConfig+0x3e6>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 800cc0e:	4b8c      	ldr	r3, [pc, #560]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cc10:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800cc12:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800cc16:	2b00      	cmp	r3, #0
 800cc18:	d10d      	bne.n	800cc36 <HAL_RCC_OscConfig+0x2c6>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 800cc1a:	4b89      	ldr	r3, [pc, #548]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cc1c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800cc1e:	4a88      	ldr	r2, [pc, #544]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cc20:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800cc24:	6413      	str	r3, [r2, #64]	; 0x40
 800cc26:	4b86      	ldr	r3, [pc, #536]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cc28:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800cc2a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800cc2e:	60bb      	str	r3, [r7, #8]
 800cc30:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800cc32:	2301      	movs	r3, #1
 800cc34:	60fb      	str	r3, [r7, #12]
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800cc36:	4b83      	ldr	r3, [pc, #524]	; (800ce44 <HAL_RCC_OscConfig+0x4d4>)
 800cc38:	681b      	ldr	r3, [r3, #0]
 800cc3a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800cc3e:	2b00      	cmp	r3, #0
 800cc40:	d118      	bne.n	800cc74 <HAL_RCC_OscConfig+0x304>
    {
      /* Enable write access to Backup domain */
      PWR->CR1 |= PWR_CR1_DBP;
 800cc42:	4b80      	ldr	r3, [pc, #512]	; (800ce44 <HAL_RCC_OscConfig+0x4d4>)
 800cc44:	681b      	ldr	r3, [r3, #0]
 800cc46:	4a7f      	ldr	r2, [pc, #508]	; (800ce44 <HAL_RCC_OscConfig+0x4d4>)
 800cc48:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800cc4c:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800cc4e:	f7f5 f891 	bl	8001d74 <HAL_GetTick>
 800cc52:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800cc54:	e008      	b.n	800cc68 <HAL_RCC_OscConfig+0x2f8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800cc56:	f7f5 f88d 	bl	8001d74 <HAL_GetTick>
 800cc5a:	4602      	mov	r2, r0
 800cc5c:	693b      	ldr	r3, [r7, #16]
 800cc5e:	1ad3      	subs	r3, r2, r3
 800cc60:	2b64      	cmp	r3, #100	; 0x64
 800cc62:	d901      	bls.n	800cc68 <HAL_RCC_OscConfig+0x2f8>
        {
          return HAL_TIMEOUT;
 800cc64:	2303      	movs	r3, #3
 800cc66:	e12a      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800cc68:	4b76      	ldr	r3, [pc, #472]	; (800ce44 <HAL_RCC_OscConfig+0x4d4>)
 800cc6a:	681b      	ldr	r3, [r3, #0]
 800cc6c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800cc70:	2b00      	cmp	r3, #0
 800cc72:	d0f0      	beq.n	800cc56 <HAL_RCC_OscConfig+0x2e6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800cc74:	687b      	ldr	r3, [r7, #4]
 800cc76:	689b      	ldr	r3, [r3, #8]
 800cc78:	2b01      	cmp	r3, #1
 800cc7a:	d106      	bne.n	800cc8a <HAL_RCC_OscConfig+0x31a>
 800cc7c:	4b70      	ldr	r3, [pc, #448]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cc7e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800cc80:	4a6f      	ldr	r2, [pc, #444]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cc82:	f043 0301 	orr.w	r3, r3, #1
 800cc86:	6713      	str	r3, [r2, #112]	; 0x70
 800cc88:	e02d      	b.n	800cce6 <HAL_RCC_OscConfig+0x376>
 800cc8a:	687b      	ldr	r3, [r7, #4]
 800cc8c:	689b      	ldr	r3, [r3, #8]
 800cc8e:	2b00      	cmp	r3, #0
 800cc90:	d10c      	bne.n	800ccac <HAL_RCC_OscConfig+0x33c>
 800cc92:	4b6b      	ldr	r3, [pc, #428]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cc94:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800cc96:	4a6a      	ldr	r2, [pc, #424]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cc98:	f023 0301 	bic.w	r3, r3, #1
 800cc9c:	6713      	str	r3, [r2, #112]	; 0x70
 800cc9e:	4b68      	ldr	r3, [pc, #416]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cca0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800cca2:	4a67      	ldr	r2, [pc, #412]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cca4:	f023 0304 	bic.w	r3, r3, #4
 800cca8:	6713      	str	r3, [r2, #112]	; 0x70
 800ccaa:	e01c      	b.n	800cce6 <HAL_RCC_OscConfig+0x376>
 800ccac:	687b      	ldr	r3, [r7, #4]
 800ccae:	689b      	ldr	r3, [r3, #8]
 800ccb0:	2b05      	cmp	r3, #5
 800ccb2:	d10c      	bne.n	800ccce <HAL_RCC_OscConfig+0x35e>
 800ccb4:	4b62      	ldr	r3, [pc, #392]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ccb6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ccb8:	4a61      	ldr	r2, [pc, #388]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ccba:	f043 0304 	orr.w	r3, r3, #4
 800ccbe:	6713      	str	r3, [r2, #112]	; 0x70
 800ccc0:	4b5f      	ldr	r3, [pc, #380]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ccc2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ccc4:	4a5e      	ldr	r2, [pc, #376]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ccc6:	f043 0301 	orr.w	r3, r3, #1
 800ccca:	6713      	str	r3, [r2, #112]	; 0x70
 800cccc:	e00b      	b.n	800cce6 <HAL_RCC_OscConfig+0x376>
 800ccce:	4b5c      	ldr	r3, [pc, #368]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ccd0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ccd2:	4a5b      	ldr	r2, [pc, #364]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ccd4:	f023 0301 	bic.w	r3, r3, #1
 800ccd8:	6713      	str	r3, [r2, #112]	; 0x70
 800ccda:	4b59      	ldr	r3, [pc, #356]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ccdc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ccde:	4a58      	ldr	r2, [pc, #352]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cce0:	f023 0304 	bic.w	r3, r3, #4
 800cce4:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800cce6:	687b      	ldr	r3, [r7, #4]
 800cce8:	689b      	ldr	r3, [r3, #8]
 800ccea:	2b00      	cmp	r3, #0
 800ccec:	d015      	beq.n	800cd1a <HAL_RCC_OscConfig+0x3aa>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800ccee:	f7f5 f841 	bl	8001d74 <HAL_GetTick>
 800ccf2:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800ccf4:	e00a      	b.n	800cd0c <HAL_RCC_OscConfig+0x39c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800ccf6:	f7f5 f83d 	bl	8001d74 <HAL_GetTick>
 800ccfa:	4602      	mov	r2, r0
 800ccfc:	693b      	ldr	r3, [r7, #16]
 800ccfe:	1ad3      	subs	r3, r2, r3
 800cd00:	f241 3288 	movw	r2, #5000	; 0x1388
 800cd04:	4293      	cmp	r3, r2
 800cd06:	d901      	bls.n	800cd0c <HAL_RCC_OscConfig+0x39c>
        {
          return HAL_TIMEOUT;
 800cd08:	2303      	movs	r3, #3
 800cd0a:	e0d8      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800cd0c:	4b4c      	ldr	r3, [pc, #304]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cd0e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800cd10:	f003 0302 	and.w	r3, r3, #2
 800cd14:	2b00      	cmp	r3, #0
 800cd16:	d0ee      	beq.n	800ccf6 <HAL_RCC_OscConfig+0x386>
 800cd18:	e014      	b.n	800cd44 <HAL_RCC_OscConfig+0x3d4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800cd1a:	f7f5 f82b 	bl	8001d74 <HAL_GetTick>
 800cd1e:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800cd20:	e00a      	b.n	800cd38 <HAL_RCC_OscConfig+0x3c8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800cd22:	f7f5 f827 	bl	8001d74 <HAL_GetTick>
 800cd26:	4602      	mov	r2, r0
 800cd28:	693b      	ldr	r3, [r7, #16]
 800cd2a:	1ad3      	subs	r3, r2, r3
 800cd2c:	f241 3288 	movw	r2, #5000	; 0x1388
 800cd30:	4293      	cmp	r3, r2
 800cd32:	d901      	bls.n	800cd38 <HAL_RCC_OscConfig+0x3c8>
        {
          return HAL_TIMEOUT;
 800cd34:	2303      	movs	r3, #3
 800cd36:	e0c2      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800cd38:	4b41      	ldr	r3, [pc, #260]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cd3a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800cd3c:	f003 0302 	and.w	r3, r3, #2
 800cd40:	2b00      	cmp	r3, #0
 800cd42:	d1ee      	bne.n	800cd22 <HAL_RCC_OscConfig+0x3b2>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 800cd44:	68fb      	ldr	r3, [r7, #12]
 800cd46:	2b01      	cmp	r3, #1
 800cd48:	d105      	bne.n	800cd56 <HAL_RCC_OscConfig+0x3e6>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800cd4a:	4b3d      	ldr	r3, [pc, #244]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cd4c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800cd4e:	4a3c      	ldr	r2, [pc, #240]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cd50:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800cd54:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800cd56:	687b      	ldr	r3, [r7, #4]
 800cd58:	699b      	ldr	r3, [r3, #24]
 800cd5a:	2b00      	cmp	r3, #0
 800cd5c:	f000 80ae 	beq.w	800cebc <HAL_RCC_OscConfig+0x54c>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800cd60:	4b37      	ldr	r3, [pc, #220]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cd62:	689b      	ldr	r3, [r3, #8]
 800cd64:	f003 030c 	and.w	r3, r3, #12
 800cd68:	2b08      	cmp	r3, #8
 800cd6a:	d06d      	beq.n	800ce48 <HAL_RCC_OscConfig+0x4d8>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800cd6c:	687b      	ldr	r3, [r7, #4]
 800cd6e:	699b      	ldr	r3, [r3, #24]
 800cd70:	2b02      	cmp	r3, #2
 800cd72:	d14b      	bne.n	800ce0c <HAL_RCC_OscConfig+0x49c>
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800cd74:	4b32      	ldr	r3, [pc, #200]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cd76:	681b      	ldr	r3, [r3, #0]
 800cd78:	4a31      	ldr	r2, [pc, #196]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cd7a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800cd7e:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800cd80:	f7f4 fff8 	bl	8001d74 <HAL_GetTick>
 800cd84:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800cd86:	e008      	b.n	800cd9a <HAL_RCC_OscConfig+0x42a>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800cd88:	f7f4 fff4 	bl	8001d74 <HAL_GetTick>
 800cd8c:	4602      	mov	r2, r0
 800cd8e:	693b      	ldr	r3, [r7, #16]
 800cd90:	1ad3      	subs	r3, r2, r3
 800cd92:	2b02      	cmp	r3, #2
 800cd94:	d901      	bls.n	800cd9a <HAL_RCC_OscConfig+0x42a>
          {
            return HAL_TIMEOUT;
 800cd96:	2303      	movs	r3, #3
 800cd98:	e091      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800cd9a:	4b29      	ldr	r3, [pc, #164]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cd9c:	681b      	ldr	r3, [r3, #0]
 800cd9e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800cda2:	2b00      	cmp	r3, #0
 800cda4:	d1f0      	bne.n	800cd88 <HAL_RCC_OscConfig+0x418>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
#if defined (RCC_PLLCFGR_PLLR)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800cda6:	687b      	ldr	r3, [r7, #4]
 800cda8:	69da      	ldr	r2, [r3, #28]
 800cdaa:	687b      	ldr	r3, [r7, #4]
 800cdac:	6a1b      	ldr	r3, [r3, #32]
 800cdae:	431a      	orrs	r2, r3
 800cdb0:	687b      	ldr	r3, [r7, #4]
 800cdb2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800cdb4:	019b      	lsls	r3, r3, #6
 800cdb6:	431a      	orrs	r2, r3
 800cdb8:	687b      	ldr	r3, [r7, #4]
 800cdba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800cdbc:	085b      	lsrs	r3, r3, #1
 800cdbe:	3b01      	subs	r3, #1
 800cdc0:	041b      	lsls	r3, r3, #16
 800cdc2:	431a      	orrs	r2, r3
 800cdc4:	687b      	ldr	r3, [r7, #4]
 800cdc6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800cdc8:	061b      	lsls	r3, r3, #24
 800cdca:	431a      	orrs	r2, r3
 800cdcc:	687b      	ldr	r3, [r7, #4]
 800cdce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800cdd0:	071b      	lsls	r3, r3, #28
 800cdd2:	491b      	ldr	r1, [pc, #108]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cdd4:	4313      	orrs	r3, r2
 800cdd6:	604b      	str	r3, [r1, #4]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
#endif

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800cdd8:	4b19      	ldr	r3, [pc, #100]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cdda:	681b      	ldr	r3, [r3, #0]
 800cddc:	4a18      	ldr	r2, [pc, #96]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800cdde:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800cde2:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800cde4:	f7f4 ffc6 	bl	8001d74 <HAL_GetTick>
 800cde8:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800cdea:	e008      	b.n	800cdfe <HAL_RCC_OscConfig+0x48e>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800cdec:	f7f4 ffc2 	bl	8001d74 <HAL_GetTick>
 800cdf0:	4602      	mov	r2, r0
 800cdf2:	693b      	ldr	r3, [r7, #16]
 800cdf4:	1ad3      	subs	r3, r2, r3
 800cdf6:	2b02      	cmp	r3, #2
 800cdf8:	d901      	bls.n	800cdfe <HAL_RCC_OscConfig+0x48e>
          {
            return HAL_TIMEOUT;
 800cdfa:	2303      	movs	r3, #3
 800cdfc:	e05f      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800cdfe:	4b10      	ldr	r3, [pc, #64]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ce00:	681b      	ldr	r3, [r3, #0]
 800ce02:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800ce06:	2b00      	cmp	r3, #0
 800ce08:	d0f0      	beq.n	800cdec <HAL_RCC_OscConfig+0x47c>
 800ce0a:	e057      	b.n	800cebc <HAL_RCC_OscConfig+0x54c>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800ce0c:	4b0c      	ldr	r3, [pc, #48]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ce0e:	681b      	ldr	r3, [r3, #0]
 800ce10:	4a0b      	ldr	r2, [pc, #44]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ce12:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800ce16:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800ce18:	f7f4 ffac 	bl	8001d74 <HAL_GetTick>
 800ce1c:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800ce1e:	e008      	b.n	800ce32 <HAL_RCC_OscConfig+0x4c2>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800ce20:	f7f4 ffa8 	bl	8001d74 <HAL_GetTick>
 800ce24:	4602      	mov	r2, r0
 800ce26:	693b      	ldr	r3, [r7, #16]
 800ce28:	1ad3      	subs	r3, r2, r3
 800ce2a:	2b02      	cmp	r3, #2
 800ce2c:	d901      	bls.n	800ce32 <HAL_RCC_OscConfig+0x4c2>
          {
            return HAL_TIMEOUT;
 800ce2e:	2303      	movs	r3, #3
 800ce30:	e045      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800ce32:	4b03      	ldr	r3, [pc, #12]	; (800ce40 <HAL_RCC_OscConfig+0x4d0>)
 800ce34:	681b      	ldr	r3, [r3, #0]
 800ce36:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800ce3a:	2b00      	cmp	r3, #0
 800ce3c:	d1f0      	bne.n	800ce20 <HAL_RCC_OscConfig+0x4b0>
 800ce3e:	e03d      	b.n	800cebc <HAL_RCC_OscConfig+0x54c>
 800ce40:	40023800 	.word	0x40023800
 800ce44:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      pll_config = RCC->PLLCFGR;
 800ce48:	4b1f      	ldr	r3, [pc, #124]	; (800cec8 <HAL_RCC_OscConfig+0x558>)
 800ce4a:	685b      	ldr	r3, [r3, #4]
 800ce4c:	617b      	str	r3, [r7, #20]
#if defined (RCC_PLLCFGR_PLLR)
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800ce4e:	687b      	ldr	r3, [r7, #4]
 800ce50:	699b      	ldr	r3, [r3, #24]
 800ce52:	2b01      	cmp	r3, #1
 800ce54:	d030      	beq.n	800ceb8 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800ce56:	697b      	ldr	r3, [r7, #20]
 800ce58:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
 800ce5c:	687b      	ldr	r3, [r7, #4]
 800ce5e:	69db      	ldr	r3, [r3, #28]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800ce60:	429a      	cmp	r2, r3
 800ce62:	d129      	bne.n	800ceb8 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800ce64:	697b      	ldr	r3, [r7, #20]
 800ce66:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 800ce6a:	687b      	ldr	r3, [r7, #4]
 800ce6c:	6a1b      	ldr	r3, [r3, #32]
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800ce6e:	429a      	cmp	r2, r3
 800ce70:	d122      	bne.n	800ceb8 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 800ce72:	697a      	ldr	r2, [r7, #20]
 800ce74:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800ce78:	4013      	ands	r3, r2
 800ce7a:	687a      	ldr	r2, [r7, #4]
 800ce7c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800ce7e:	0192      	lsls	r2, r2, #6
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800ce80:	4293      	cmp	r3, r2
 800ce82:	d119      	bne.n	800ceb8 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 800ce84:	697b      	ldr	r3, [r7, #20]
 800ce86:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 800ce8a:	687b      	ldr	r3, [r7, #4]
 800ce8c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ce8e:	085b      	lsrs	r3, r3, #1
 800ce90:	3b01      	subs	r3, #1
 800ce92:	041b      	lsls	r3, r3, #16
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 800ce94:	429a      	cmp	r2, r3
 800ce96:	d10f      	bne.n	800ceb8 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
 800ce98:	697b      	ldr	r3, [r7, #20]
 800ce9a:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 800ce9e:	687b      	ldr	r3, [r7, #4]
 800cea0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800cea2:	061b      	lsls	r3, r3, #24
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 800cea4:	429a      	cmp	r2, r3
 800cea6:	d107      	bne.n	800ceb8 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
 800cea8:	697b      	ldr	r3, [r7, #20]
 800ceaa:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
 800ceae:	687b      	ldr	r3, [r7, #4]
 800ceb0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ceb2:	071b      	lsls	r3, r3, #28
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
 800ceb4:	429a      	cmp	r2, r3
 800ceb6:	d001      	beq.n	800cebc <HAL_RCC_OscConfig+0x54c>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
#endif
      {
        return HAL_ERROR;
 800ceb8:	2301      	movs	r3, #1
 800ceba:	e000      	b.n	800cebe <HAL_RCC_OscConfig+0x54e>
      }
    }
  }
  return HAL_OK;
 800cebc:	2300      	movs	r3, #0
}
 800cebe:	4618      	mov	r0, r3
 800cec0:	3718      	adds	r7, #24
 800cec2:	46bd      	mov	sp, r7
 800cec4:	bd80      	pop	{r7, pc}
 800cec6:	bf00      	nop
 800cec8:	40023800 	.word	0x40023800

0800cecc <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800cecc:	b580      	push	{r7, lr}
 800cece:	b084      	sub	sp, #16
 800ced0:	af00      	add	r7, sp, #0
 800ced2:	6078      	str	r0, [r7, #4]
 800ced4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 800ced6:	2300      	movs	r3, #0
 800ced8:	60fb      	str	r3, [r7, #12]

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 800ceda:	687b      	ldr	r3, [r7, #4]
 800cedc:	2b00      	cmp	r3, #0
 800cede:	d101      	bne.n	800cee4 <HAL_RCC_ClockConfig+0x18>
  {
    return HAL_ERROR;
 800cee0:	2301      	movs	r3, #1
 800cee2:	e0d0      	b.n	800d086 <HAL_RCC_ClockConfig+0x1ba>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800cee4:	4b6a      	ldr	r3, [pc, #424]	; (800d090 <HAL_RCC_ClockConfig+0x1c4>)
 800cee6:	681b      	ldr	r3, [r3, #0]
 800cee8:	f003 030f 	and.w	r3, r3, #15
 800ceec:	683a      	ldr	r2, [r7, #0]
 800ceee:	429a      	cmp	r2, r3
 800cef0:	d910      	bls.n	800cf14 <HAL_RCC_ClockConfig+0x48>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800cef2:	4b67      	ldr	r3, [pc, #412]	; (800d090 <HAL_RCC_ClockConfig+0x1c4>)
 800cef4:	681b      	ldr	r3, [r3, #0]
 800cef6:	f023 020f 	bic.w	r2, r3, #15
 800cefa:	4965      	ldr	r1, [pc, #404]	; (800d090 <HAL_RCC_ClockConfig+0x1c4>)
 800cefc:	683b      	ldr	r3, [r7, #0]
 800cefe:	4313      	orrs	r3, r2
 800cf00:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800cf02:	4b63      	ldr	r3, [pc, #396]	; (800d090 <HAL_RCC_ClockConfig+0x1c4>)
 800cf04:	681b      	ldr	r3, [r3, #0]
 800cf06:	f003 030f 	and.w	r3, r3, #15
 800cf0a:	683a      	ldr	r2, [r7, #0]
 800cf0c:	429a      	cmp	r2, r3
 800cf0e:	d001      	beq.n	800cf14 <HAL_RCC_ClockConfig+0x48>
    {
      return HAL_ERROR;
 800cf10:	2301      	movs	r3, #1
 800cf12:	e0b8      	b.n	800d086 <HAL_RCC_ClockConfig+0x1ba>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800cf14:	687b      	ldr	r3, [r7, #4]
 800cf16:	681b      	ldr	r3, [r3, #0]
 800cf18:	f003 0302 	and.w	r3, r3, #2
 800cf1c:	2b00      	cmp	r3, #0
 800cf1e:	d020      	beq.n	800cf62 <HAL_RCC_ClockConfig+0x96>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800cf20:	687b      	ldr	r3, [r7, #4]
 800cf22:	681b      	ldr	r3, [r3, #0]
 800cf24:	f003 0304 	and.w	r3, r3, #4
 800cf28:	2b00      	cmp	r3, #0
 800cf2a:	d005      	beq.n	800cf38 <HAL_RCC_ClockConfig+0x6c>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800cf2c:	4b59      	ldr	r3, [pc, #356]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cf2e:	689b      	ldr	r3, [r3, #8]
 800cf30:	4a58      	ldr	r2, [pc, #352]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cf32:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 800cf36:	6093      	str	r3, [r2, #8]
    }

    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800cf38:	687b      	ldr	r3, [r7, #4]
 800cf3a:	681b      	ldr	r3, [r3, #0]
 800cf3c:	f003 0308 	and.w	r3, r3, #8
 800cf40:	2b00      	cmp	r3, #0
 800cf42:	d005      	beq.n	800cf50 <HAL_RCC_ClockConfig+0x84>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800cf44:	4b53      	ldr	r3, [pc, #332]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cf46:	689b      	ldr	r3, [r3, #8]
 800cf48:	4a52      	ldr	r2, [pc, #328]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cf4a:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 800cf4e:	6093      	str	r3, [r2, #8]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800cf50:	4b50      	ldr	r3, [pc, #320]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cf52:	689b      	ldr	r3, [r3, #8]
 800cf54:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800cf58:	687b      	ldr	r3, [r7, #4]
 800cf5a:	689b      	ldr	r3, [r3, #8]
 800cf5c:	494d      	ldr	r1, [pc, #308]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cf5e:	4313      	orrs	r3, r2
 800cf60:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800cf62:	687b      	ldr	r3, [r7, #4]
 800cf64:	681b      	ldr	r3, [r3, #0]
 800cf66:	f003 0301 	and.w	r3, r3, #1
 800cf6a:	2b00      	cmp	r3, #0
 800cf6c:	d040      	beq.n	800cff0 <HAL_RCC_ClockConfig+0x124>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800cf6e:	687b      	ldr	r3, [r7, #4]
 800cf70:	685b      	ldr	r3, [r3, #4]
 800cf72:	2b01      	cmp	r3, #1
 800cf74:	d107      	bne.n	800cf86 <HAL_RCC_ClockConfig+0xba>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800cf76:	4b47      	ldr	r3, [pc, #284]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cf78:	681b      	ldr	r3, [r3, #0]
 800cf7a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800cf7e:	2b00      	cmp	r3, #0
 800cf80:	d115      	bne.n	800cfae <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
 800cf82:	2301      	movs	r3, #1
 800cf84:	e07f      	b.n	800d086 <HAL_RCC_ClockConfig+0x1ba>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800cf86:	687b      	ldr	r3, [r7, #4]
 800cf88:	685b      	ldr	r3, [r3, #4]
 800cf8a:	2b02      	cmp	r3, #2
 800cf8c:	d107      	bne.n	800cf9e <HAL_RCC_ClockConfig+0xd2>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800cf8e:	4b41      	ldr	r3, [pc, #260]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cf90:	681b      	ldr	r3, [r3, #0]
 800cf92:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800cf96:	2b00      	cmp	r3, #0
 800cf98:	d109      	bne.n	800cfae <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
 800cf9a:	2301      	movs	r3, #1
 800cf9c:	e073      	b.n	800d086 <HAL_RCC_ClockConfig+0x1ba>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800cf9e:	4b3d      	ldr	r3, [pc, #244]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cfa0:	681b      	ldr	r3, [r3, #0]
 800cfa2:	f003 0302 	and.w	r3, r3, #2
 800cfa6:	2b00      	cmp	r3, #0
 800cfa8:	d101      	bne.n	800cfae <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
 800cfaa:	2301      	movs	r3, #1
 800cfac:	e06b      	b.n	800d086 <HAL_RCC_ClockConfig+0x1ba>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800cfae:	4b39      	ldr	r3, [pc, #228]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cfb0:	689b      	ldr	r3, [r3, #8]
 800cfb2:	f023 0203 	bic.w	r2, r3, #3
 800cfb6:	687b      	ldr	r3, [r7, #4]
 800cfb8:	685b      	ldr	r3, [r3, #4]
 800cfba:	4936      	ldr	r1, [pc, #216]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cfbc:	4313      	orrs	r3, r2
 800cfbe:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800cfc0:	f7f4 fed8 	bl	8001d74 <HAL_GetTick>
 800cfc4:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800cfc6:	e00a      	b.n	800cfde <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800cfc8:	f7f4 fed4 	bl	8001d74 <HAL_GetTick>
 800cfcc:	4602      	mov	r2, r0
 800cfce:	68fb      	ldr	r3, [r7, #12]
 800cfd0:	1ad3      	subs	r3, r2, r3
 800cfd2:	f241 3288 	movw	r2, #5000	; 0x1388
 800cfd6:	4293      	cmp	r3, r2
 800cfd8:	d901      	bls.n	800cfde <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
 800cfda:	2303      	movs	r3, #3
 800cfdc:	e053      	b.n	800d086 <HAL_RCC_ClockConfig+0x1ba>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800cfde:	4b2d      	ldr	r3, [pc, #180]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800cfe0:	689b      	ldr	r3, [r3, #8]
 800cfe2:	f003 020c 	and.w	r2, r3, #12
 800cfe6:	687b      	ldr	r3, [r7, #4]
 800cfe8:	685b      	ldr	r3, [r3, #4]
 800cfea:	009b      	lsls	r3, r3, #2
 800cfec:	429a      	cmp	r2, r3
 800cfee:	d1eb      	bne.n	800cfc8 <HAL_RCC_ClockConfig+0xfc>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800cff0:	4b27      	ldr	r3, [pc, #156]	; (800d090 <HAL_RCC_ClockConfig+0x1c4>)
 800cff2:	681b      	ldr	r3, [r3, #0]
 800cff4:	f003 030f 	and.w	r3, r3, #15
 800cff8:	683a      	ldr	r2, [r7, #0]
 800cffa:	429a      	cmp	r2, r3
 800cffc:	d210      	bcs.n	800d020 <HAL_RCC_ClockConfig+0x154>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800cffe:	4b24      	ldr	r3, [pc, #144]	; (800d090 <HAL_RCC_ClockConfig+0x1c4>)
 800d000:	681b      	ldr	r3, [r3, #0]
 800d002:	f023 020f 	bic.w	r2, r3, #15
 800d006:	4922      	ldr	r1, [pc, #136]	; (800d090 <HAL_RCC_ClockConfig+0x1c4>)
 800d008:	683b      	ldr	r3, [r7, #0]
 800d00a:	4313      	orrs	r3, r2
 800d00c:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800d00e:	4b20      	ldr	r3, [pc, #128]	; (800d090 <HAL_RCC_ClockConfig+0x1c4>)
 800d010:	681b      	ldr	r3, [r3, #0]
 800d012:	f003 030f 	and.w	r3, r3, #15
 800d016:	683a      	ldr	r2, [r7, #0]
 800d018:	429a      	cmp	r2, r3
 800d01a:	d001      	beq.n	800d020 <HAL_RCC_ClockConfig+0x154>
    {
      return HAL_ERROR;
 800d01c:	2301      	movs	r3, #1
 800d01e:	e032      	b.n	800d086 <HAL_RCC_ClockConfig+0x1ba>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800d020:	687b      	ldr	r3, [r7, #4]
 800d022:	681b      	ldr	r3, [r3, #0]
 800d024:	f003 0304 	and.w	r3, r3, #4
 800d028:	2b00      	cmp	r3, #0
 800d02a:	d008      	beq.n	800d03e <HAL_RCC_ClockConfig+0x172>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800d02c:	4b19      	ldr	r3, [pc, #100]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800d02e:	689b      	ldr	r3, [r3, #8]
 800d030:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 800d034:	687b      	ldr	r3, [r7, #4]
 800d036:	68db      	ldr	r3, [r3, #12]
 800d038:	4916      	ldr	r1, [pc, #88]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800d03a:	4313      	orrs	r3, r2
 800d03c:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800d03e:	687b      	ldr	r3, [r7, #4]
 800d040:	681b      	ldr	r3, [r3, #0]
 800d042:	f003 0308 	and.w	r3, r3, #8
 800d046:	2b00      	cmp	r3, #0
 800d048:	d009      	beq.n	800d05e <HAL_RCC_ClockConfig+0x192>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800d04a:	4b12      	ldr	r3, [pc, #72]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800d04c:	689b      	ldr	r3, [r3, #8]
 800d04e:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 800d052:	687b      	ldr	r3, [r7, #4]
 800d054:	691b      	ldr	r3, [r3, #16]
 800d056:	00db      	lsls	r3, r3, #3
 800d058:	490e      	ldr	r1, [pc, #56]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800d05a:	4313      	orrs	r3, r2
 800d05c:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800d05e:	f000 f831 	bl	800d0c4 <HAL_RCC_GetSysClockFreq>
 800d062:	4602      	mov	r2, r0
 800d064:	4b0b      	ldr	r3, [pc, #44]	; (800d094 <HAL_RCC_ClockConfig+0x1c8>)
 800d066:	689b      	ldr	r3, [r3, #8]
 800d068:	091b      	lsrs	r3, r3, #4
 800d06a:	f003 030f 	and.w	r3, r3, #15
 800d06e:	490a      	ldr	r1, [pc, #40]	; (800d098 <HAL_RCC_ClockConfig+0x1cc>)
 800d070:	5ccb      	ldrb	r3, [r1, r3]
 800d072:	fa22 f303 	lsr.w	r3, r2, r3
 800d076:	4a09      	ldr	r2, [pc, #36]	; (800d09c <HAL_RCC_ClockConfig+0x1d0>)
 800d078:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);
 800d07a:	4b09      	ldr	r3, [pc, #36]	; (800d0a0 <HAL_RCC_ClockConfig+0x1d4>)
 800d07c:	681b      	ldr	r3, [r3, #0]
 800d07e:	4618      	mov	r0, r3
 800d080:	f7fe fba8 	bl	800b7d4 <HAL_InitTick>

  return HAL_OK;
 800d084:	2300      	movs	r3, #0
}
 800d086:	4618      	mov	r0, r3
 800d088:	3710      	adds	r7, #16
 800d08a:	46bd      	mov	sp, r7
 800d08c:	bd80      	pop	{r7, pc}
 800d08e:	bf00      	nop
 800d090:	40023c00 	.word	0x40023c00
 800d094:	40023800 	.word	0x40023800
 800d098:	080232d4 	.word	0x080232d4
 800d09c:	20000404 	.word	0x20000404
 800d0a0:	2000047c 	.word	0x2000047c

0800d0a4 <HAL_RCC_EnableCSS>:
  *         allowing the MCU to perform rescue operations. The CSSI is linked to
  *         the Cortex-M7 NMI (Non-Maskable Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
 800d0a4:	b480      	push	{r7}
 800d0a6:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_CSSON);
 800d0a8:	4b05      	ldr	r3, [pc, #20]	; (800d0c0 <HAL_RCC_EnableCSS+0x1c>)
 800d0aa:	681b      	ldr	r3, [r3, #0]
 800d0ac:	4a04      	ldr	r2, [pc, #16]	; (800d0c0 <HAL_RCC_EnableCSS+0x1c>)
 800d0ae:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800d0b2:	6013      	str	r3, [r2, #0]
}
 800d0b4:	bf00      	nop
 800d0b6:	46bd      	mov	sp, r7
 800d0b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0bc:	4770      	bx	lr
 800d0be:	bf00      	nop
 800d0c0:	40023800 	.word	0x40023800

0800d0c4 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800d0c4:	b5b0      	push	{r4, r5, r7, lr}
 800d0c6:	b084      	sub	sp, #16
 800d0c8:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
 800d0ca:	2100      	movs	r1, #0
 800d0cc:	60b9      	str	r1, [r7, #8]
 800d0ce:	2100      	movs	r1, #0
 800d0d0:	6039      	str	r1, [r7, #0]
 800d0d2:	2100      	movs	r1, #0
 800d0d4:	60f9      	str	r1, [r7, #12]
  uint32_t sysclockfreq = 0;
 800d0d6:	2100      	movs	r1, #0
 800d0d8:	6079      	str	r1, [r7, #4]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800d0da:	4952      	ldr	r1, [pc, #328]	; (800d224 <HAL_RCC_GetSysClockFreq+0x160>)
 800d0dc:	6889      	ldr	r1, [r1, #8]
 800d0de:	f001 010c 	and.w	r1, r1, #12
 800d0e2:	2908      	cmp	r1, #8
 800d0e4:	d00d      	beq.n	800d102 <HAL_RCC_GetSysClockFreq+0x3e>
 800d0e6:	2908      	cmp	r1, #8
 800d0e8:	f200 8094 	bhi.w	800d214 <HAL_RCC_GetSysClockFreq+0x150>
 800d0ec:	2900      	cmp	r1, #0
 800d0ee:	d002      	beq.n	800d0f6 <HAL_RCC_GetSysClockFreq+0x32>
 800d0f0:	2904      	cmp	r1, #4
 800d0f2:	d003      	beq.n	800d0fc <HAL_RCC_GetSysClockFreq+0x38>
 800d0f4:	e08e      	b.n	800d214 <HAL_RCC_GetSysClockFreq+0x150>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800d0f6:	4b4c      	ldr	r3, [pc, #304]	; (800d228 <HAL_RCC_GetSysClockFreq+0x164>)
 800d0f8:	607b      	str	r3, [r7, #4]
      break;
 800d0fa:	e08e      	b.n	800d21a <HAL_RCC_GetSysClockFreq+0x156>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 800d0fc:	4b4b      	ldr	r3, [pc, #300]	; (800d22c <HAL_RCC_GetSysClockFreq+0x168>)
 800d0fe:	607b      	str	r3, [r7, #4]
      break;
 800d100:	e08b      	b.n	800d21a <HAL_RCC_GetSysClockFreq+0x156>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800d102:	4948      	ldr	r1, [pc, #288]	; (800d224 <HAL_RCC_GetSysClockFreq+0x160>)
 800d104:	6849      	ldr	r1, [r1, #4]
 800d106:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 800d10a:	60b9      	str	r1, [r7, #8]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800d10c:	4945      	ldr	r1, [pc, #276]	; (800d224 <HAL_RCC_GetSysClockFreq+0x160>)
 800d10e:	6849      	ldr	r1, [r1, #4]
 800d110:	f401 0180 	and.w	r1, r1, #4194304	; 0x400000
 800d114:	2900      	cmp	r1, #0
 800d116:	d024      	beq.n	800d162 <HAL_RCC_GetSysClockFreq+0x9e>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800d118:	4942      	ldr	r1, [pc, #264]	; (800d224 <HAL_RCC_GetSysClockFreq+0x160>)
 800d11a:	6849      	ldr	r1, [r1, #4]
 800d11c:	0989      	lsrs	r1, r1, #6
 800d11e:	4608      	mov	r0, r1
 800d120:	f04f 0100 	mov.w	r1, #0
 800d124:	f240 14ff 	movw	r4, #511	; 0x1ff
 800d128:	f04f 0500 	mov.w	r5, #0
 800d12c:	ea00 0204 	and.w	r2, r0, r4
 800d130:	ea01 0305 	and.w	r3, r1, r5
 800d134:	493d      	ldr	r1, [pc, #244]	; (800d22c <HAL_RCC_GetSysClockFreq+0x168>)
 800d136:	fb01 f003 	mul.w	r0, r1, r3
 800d13a:	2100      	movs	r1, #0
 800d13c:	fb01 f102 	mul.w	r1, r1, r2
 800d140:	1844      	adds	r4, r0, r1
 800d142:	493a      	ldr	r1, [pc, #232]	; (800d22c <HAL_RCC_GetSysClockFreq+0x168>)
 800d144:	fba2 0101 	umull	r0, r1, r2, r1
 800d148:	1863      	adds	r3, r4, r1
 800d14a:	4619      	mov	r1, r3
 800d14c:	68bb      	ldr	r3, [r7, #8]
 800d14e:	461a      	mov	r2, r3
 800d150:	f04f 0300 	mov.w	r3, #0
 800d154:	f7f3 fc1e 	bl	8000994 <__aeabi_uldivmod>
 800d158:	4602      	mov	r2, r0
 800d15a:	460b      	mov	r3, r1
 800d15c:	4613      	mov	r3, r2
 800d15e:	603b      	str	r3, [r7, #0]
 800d160:	e04a      	b.n	800d1f8 <HAL_RCC_GetSysClockFreq+0x134>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800d162:	4b30      	ldr	r3, [pc, #192]	; (800d224 <HAL_RCC_GetSysClockFreq+0x160>)
 800d164:	685b      	ldr	r3, [r3, #4]
 800d166:	099b      	lsrs	r3, r3, #6
 800d168:	461a      	mov	r2, r3
 800d16a:	f04f 0300 	mov.w	r3, #0
 800d16e:	f240 10ff 	movw	r0, #511	; 0x1ff
 800d172:	f04f 0100 	mov.w	r1, #0
 800d176:	ea02 0400 	and.w	r4, r2, r0
 800d17a:	ea03 0501 	and.w	r5, r3, r1
 800d17e:	4620      	mov	r0, r4
 800d180:	4629      	mov	r1, r5
 800d182:	f04f 0200 	mov.w	r2, #0
 800d186:	f04f 0300 	mov.w	r3, #0
 800d18a:	014b      	lsls	r3, r1, #5
 800d18c:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 800d190:	0142      	lsls	r2, r0, #5
 800d192:	4610      	mov	r0, r2
 800d194:	4619      	mov	r1, r3
 800d196:	1b00      	subs	r0, r0, r4
 800d198:	eb61 0105 	sbc.w	r1, r1, r5
 800d19c:	f04f 0200 	mov.w	r2, #0
 800d1a0:	f04f 0300 	mov.w	r3, #0
 800d1a4:	018b      	lsls	r3, r1, #6
 800d1a6:	ea43 6390 	orr.w	r3, r3, r0, lsr #26
 800d1aa:	0182      	lsls	r2, r0, #6
 800d1ac:	1a12      	subs	r2, r2, r0
 800d1ae:	eb63 0301 	sbc.w	r3, r3, r1
 800d1b2:	f04f 0000 	mov.w	r0, #0
 800d1b6:	f04f 0100 	mov.w	r1, #0
 800d1ba:	00d9      	lsls	r1, r3, #3
 800d1bc:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 800d1c0:	00d0      	lsls	r0, r2, #3
 800d1c2:	4602      	mov	r2, r0
 800d1c4:	460b      	mov	r3, r1
 800d1c6:	1912      	adds	r2, r2, r4
 800d1c8:	eb45 0303 	adc.w	r3, r5, r3
 800d1cc:	f04f 0000 	mov.w	r0, #0
 800d1d0:	f04f 0100 	mov.w	r1, #0
 800d1d4:	0299      	lsls	r1, r3, #10
 800d1d6:	ea41 5192 	orr.w	r1, r1, r2, lsr #22
 800d1da:	0290      	lsls	r0, r2, #10
 800d1dc:	4602      	mov	r2, r0
 800d1de:	460b      	mov	r3, r1
 800d1e0:	4610      	mov	r0, r2
 800d1e2:	4619      	mov	r1, r3
 800d1e4:	68bb      	ldr	r3, [r7, #8]
 800d1e6:	461a      	mov	r2, r3
 800d1e8:	f04f 0300 	mov.w	r3, #0
 800d1ec:	f7f3 fbd2 	bl	8000994 <__aeabi_uldivmod>
 800d1f0:	4602      	mov	r2, r0
 800d1f2:	460b      	mov	r3, r1
 800d1f4:	4613      	mov	r3, r2
 800d1f6:	603b      	str	r3, [r7, #0]
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 800d1f8:	4b0a      	ldr	r3, [pc, #40]	; (800d224 <HAL_RCC_GetSysClockFreq+0x160>)
 800d1fa:	685b      	ldr	r3, [r3, #4]
 800d1fc:	0c1b      	lsrs	r3, r3, #16
 800d1fe:	f003 0303 	and.w	r3, r3, #3
 800d202:	3301      	adds	r3, #1
 800d204:	005b      	lsls	r3, r3, #1
 800d206:	60fb      	str	r3, [r7, #12]

      sysclockfreq = pllvco / pllp;
 800d208:	683a      	ldr	r2, [r7, #0]
 800d20a:	68fb      	ldr	r3, [r7, #12]
 800d20c:	fbb2 f3f3 	udiv	r3, r2, r3
 800d210:	607b      	str	r3, [r7, #4]
      break;
 800d212:	e002      	b.n	800d21a <HAL_RCC_GetSysClockFreq+0x156>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 800d214:	4b04      	ldr	r3, [pc, #16]	; (800d228 <HAL_RCC_GetSysClockFreq+0x164>)
 800d216:	607b      	str	r3, [r7, #4]
      break;
 800d218:	bf00      	nop
    }
  }
  return sysclockfreq;
 800d21a:	687b      	ldr	r3, [r7, #4]
}
 800d21c:	4618      	mov	r0, r3
 800d21e:	3710      	adds	r7, #16
 800d220:	46bd      	mov	sp, r7
 800d222:	bdb0      	pop	{r4, r5, r7, pc}
 800d224:	40023800 	.word	0x40023800
 800d228:	00f42400 	.word	0x00f42400
 800d22c:	017d7840 	.word	0x017d7840

0800d230 <HAL_RCC_GetHCLKFreq>:
  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800d230:	b480      	push	{r7}
 800d232:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800d234:	4b03      	ldr	r3, [pc, #12]	; (800d244 <HAL_RCC_GetHCLKFreq+0x14>)
 800d236:	681b      	ldr	r3, [r3, #0]
}
 800d238:	4618      	mov	r0, r3
 800d23a:	46bd      	mov	sp, r7
 800d23c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d240:	4770      	bx	lr
 800d242:	bf00      	nop
 800d244:	20000404 	.word	0x20000404

0800d248 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800d248:	b580      	push	{r7, lr}
 800d24a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800d24c:	f7ff fff0 	bl	800d230 <HAL_RCC_GetHCLKFreq>
 800d250:	4602      	mov	r2, r0
 800d252:	4b05      	ldr	r3, [pc, #20]	; (800d268 <HAL_RCC_GetPCLK1Freq+0x20>)
 800d254:	689b      	ldr	r3, [r3, #8]
 800d256:	0a9b      	lsrs	r3, r3, #10
 800d258:	f003 0307 	and.w	r3, r3, #7
 800d25c:	4903      	ldr	r1, [pc, #12]	; (800d26c <HAL_RCC_GetPCLK1Freq+0x24>)
 800d25e:	5ccb      	ldrb	r3, [r1, r3]
 800d260:	fa22 f303 	lsr.w	r3, r2, r3
}
 800d264:	4618      	mov	r0, r3
 800d266:	bd80      	pop	{r7, pc}
 800d268:	40023800 	.word	0x40023800
 800d26c:	080232e4 	.word	0x080232e4

0800d270 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800d270:	b580      	push	{r7, lr}
 800d272:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800d274:	f7ff ffdc 	bl	800d230 <HAL_RCC_GetHCLKFreq>
 800d278:	4602      	mov	r2, r0
 800d27a:	4b05      	ldr	r3, [pc, #20]	; (800d290 <HAL_RCC_GetPCLK2Freq+0x20>)
 800d27c:	689b      	ldr	r3, [r3, #8]
 800d27e:	0b5b      	lsrs	r3, r3, #13
 800d280:	f003 0307 	and.w	r3, r3, #7
 800d284:	4903      	ldr	r1, [pc, #12]	; (800d294 <HAL_RCC_GetPCLK2Freq+0x24>)
 800d286:	5ccb      	ldrb	r3, [r1, r3]
 800d288:	fa22 f303 	lsr.w	r3, r2, r3
}
 800d28c:	4618      	mov	r0, r3
 800d28e:	bd80      	pop	{r7, pc}
 800d290:	40023800 	.word	0x40023800
 800d294:	080232e4 	.word	0x080232e4

0800d298 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 800d298:	b480      	push	{r7}
 800d29a:	b085      	sub	sp, #20
 800d29c:	af00      	add	r7, sp, #0
 800d29e:	6078      	str	r0, [r7, #4]
 800d2a0:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 800d2a2:	687b      	ldr	r3, [r7, #4]
 800d2a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d2a6:	2b01      	cmp	r3, #1
 800d2a8:	d101      	bne.n	800d2ae <HAL_TIMEx_MasterConfigSynchronization+0x16>
 800d2aa:	2302      	movs	r3, #2
 800d2ac:	e069      	b.n	800d382 <HAL_TIMEx_MasterConfigSynchronization+0xea>
 800d2ae:	687b      	ldr	r3, [r7, #4]
 800d2b0:	2201      	movs	r2, #1
 800d2b2:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 800d2b4:	687b      	ldr	r3, [r7, #4]
 800d2b6:	2202      	movs	r2, #2
 800d2b8:	641a      	str	r2, [r3, #64]	; 0x40

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800d2ba:	687b      	ldr	r3, [r7, #4]
 800d2bc:	681b      	ldr	r3, [r3, #0]
 800d2be:	685b      	ldr	r3, [r3, #4]
 800d2c0:	60bb      	str	r3, [r7, #8]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800d2c2:	687b      	ldr	r3, [r7, #4]
 800d2c4:	681b      	ldr	r3, [r3, #0]
 800d2c6:	689b      	ldr	r3, [r3, #8]
 800d2c8:	60fb      	str	r3, [r7, #12]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800d2ca:	687b      	ldr	r3, [r7, #4]
 800d2cc:	681b      	ldr	r3, [r3, #0]
 800d2ce:	4a30      	ldr	r2, [pc, #192]	; (800d390 <HAL_TIMEx_MasterConfigSynchronization+0xf8>)
 800d2d0:	4293      	cmp	r3, r2
 800d2d2:	d004      	beq.n	800d2de <HAL_TIMEx_MasterConfigSynchronization+0x46>
 800d2d4:	687b      	ldr	r3, [r7, #4]
 800d2d6:	681b      	ldr	r3, [r3, #0]
 800d2d8:	4a2e      	ldr	r2, [pc, #184]	; (800d394 <HAL_TIMEx_MasterConfigSynchronization+0xfc>)
 800d2da:	4293      	cmp	r3, r2
 800d2dc:	d108      	bne.n	800d2f0 <HAL_TIMEx_MasterConfigSynchronization+0x58>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 800d2de:	68bb      	ldr	r3, [r7, #8]
 800d2e0:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800d2e4:	60bb      	str	r3, [r7, #8]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800d2e6:	683b      	ldr	r3, [r7, #0]
 800d2e8:	685b      	ldr	r3, [r3, #4]
 800d2ea:	68ba      	ldr	r2, [r7, #8]
 800d2ec:	4313      	orrs	r3, r2
 800d2ee:	60bb      	str	r3, [r7, #8]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800d2f0:	68bb      	ldr	r3, [r7, #8]
 800d2f2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800d2f6:	60bb      	str	r3, [r7, #8]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800d2f8:	683b      	ldr	r3, [r7, #0]
 800d2fa:	681b      	ldr	r3, [r3, #0]
 800d2fc:	68ba      	ldr	r2, [r7, #8]
 800d2fe:	4313      	orrs	r3, r2
 800d300:	60bb      	str	r3, [r7, #8]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800d302:	687b      	ldr	r3, [r7, #4]
 800d304:	681b      	ldr	r3, [r3, #0]
 800d306:	68ba      	ldr	r2, [r7, #8]
 800d308:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800d30a:	687b      	ldr	r3, [r7, #4]
 800d30c:	681b      	ldr	r3, [r3, #0]
 800d30e:	4a20      	ldr	r2, [pc, #128]	; (800d390 <HAL_TIMEx_MasterConfigSynchronization+0xf8>)
 800d310:	4293      	cmp	r3, r2
 800d312:	d022      	beq.n	800d35a <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800d314:	687b      	ldr	r3, [r7, #4]
 800d316:	681b      	ldr	r3, [r3, #0]
 800d318:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800d31c:	d01d      	beq.n	800d35a <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800d31e:	687b      	ldr	r3, [r7, #4]
 800d320:	681b      	ldr	r3, [r3, #0]
 800d322:	4a1d      	ldr	r2, [pc, #116]	; (800d398 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 800d324:	4293      	cmp	r3, r2
 800d326:	d018      	beq.n	800d35a <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800d328:	687b      	ldr	r3, [r7, #4]
 800d32a:	681b      	ldr	r3, [r3, #0]
 800d32c:	4a1b      	ldr	r2, [pc, #108]	; (800d39c <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 800d32e:	4293      	cmp	r3, r2
 800d330:	d013      	beq.n	800d35a <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800d332:	687b      	ldr	r3, [r7, #4]
 800d334:	681b      	ldr	r3, [r3, #0]
 800d336:	4a1a      	ldr	r2, [pc, #104]	; (800d3a0 <HAL_TIMEx_MasterConfigSynchronization+0x108>)
 800d338:	4293      	cmp	r3, r2
 800d33a:	d00e      	beq.n	800d35a <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800d33c:	687b      	ldr	r3, [r7, #4]
 800d33e:	681b      	ldr	r3, [r3, #0]
 800d340:	4a14      	ldr	r2, [pc, #80]	; (800d394 <HAL_TIMEx_MasterConfigSynchronization+0xfc>)
 800d342:	4293      	cmp	r3, r2
 800d344:	d009      	beq.n	800d35a <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800d346:	687b      	ldr	r3, [r7, #4]
 800d348:	681b      	ldr	r3, [r3, #0]
 800d34a:	4a16      	ldr	r2, [pc, #88]	; (800d3a4 <HAL_TIMEx_MasterConfigSynchronization+0x10c>)
 800d34c:	4293      	cmp	r3, r2
 800d34e:	d004      	beq.n	800d35a <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800d350:	687b      	ldr	r3, [r7, #4]
 800d352:	681b      	ldr	r3, [r3, #0]
 800d354:	4a14      	ldr	r2, [pc, #80]	; (800d3a8 <HAL_TIMEx_MasterConfigSynchronization+0x110>)
 800d356:	4293      	cmp	r3, r2
 800d358:	d10c      	bne.n	800d374 <HAL_TIMEx_MasterConfigSynchronization+0xdc>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 800d35a:	68fb      	ldr	r3, [r7, #12]
 800d35c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800d360:	60fb      	str	r3, [r7, #12]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800d362:	683b      	ldr	r3, [r7, #0]
 800d364:	689b      	ldr	r3, [r3, #8]
 800d366:	68fa      	ldr	r2, [r7, #12]
 800d368:	4313      	orrs	r3, r2
 800d36a:	60fb      	str	r3, [r7, #12]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800d36c:	687b      	ldr	r3, [r7, #4]
 800d36e:	681b      	ldr	r3, [r3, #0]
 800d370:	68fa      	ldr	r2, [r7, #12]
 800d372:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800d374:	687b      	ldr	r3, [r7, #4]
 800d376:	2201      	movs	r2, #1
 800d378:	641a      	str	r2, [r3, #64]	; 0x40

  __HAL_UNLOCK(htim);
 800d37a:	687b      	ldr	r3, [r7, #4]
 800d37c:	2200      	movs	r2, #0
 800d37e:	63da      	str	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 800d380:	2300      	movs	r3, #0
}
 800d382:	4618      	mov	r0, r3
 800d384:	3714      	adds	r7, #20
 800d386:	46bd      	mov	sp, r7
 800d388:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d38c:	4770      	bx	lr
 800d38e:	bf00      	nop
 800d390:	40010000 	.word	0x40010000
 800d394:	40010400 	.word	0x40010400
 800d398:	40000400 	.word	0x40000400
 800d39c:	40000800 	.word	0x40000800
 800d3a0:	40000c00 	.word	0x40000c00
 800d3a4:	40014000 	.word	0x40014000
 800d3a8:	40001800 	.word	0x40001800

0800d3ac <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 800d3ac:	b480      	push	{r7}
 800d3ae:	b083      	sub	sp, #12
 800d3b0:	af00      	add	r7, sp, #0
 800d3b2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 800d3b4:	bf00      	nop
 800d3b6:	370c      	adds	r7, #12
 800d3b8:	46bd      	mov	sp, r7
 800d3ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d3be:	4770      	bx	lr

0800d3c0 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 800d3c0:	b480      	push	{r7}
 800d3c2:	b083      	sub	sp, #12
 800d3c4:	af00      	add	r7, sp, #0
 800d3c6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 800d3c8:	bf00      	nop
 800d3ca:	370c      	adds	r7, #12
 800d3cc:	46bd      	mov	sp, r7
 800d3ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d3d2:	4770      	bx	lr

0800d3d4 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 800d3d4:	b480      	push	{r7}
 800d3d6:	b083      	sub	sp, #12
 800d3d8:	af00      	add	r7, sp, #0
 800d3da:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 800d3dc:	bf00      	nop
 800d3de:	370c      	adds	r7, #12
 800d3e0:	46bd      	mov	sp, r7
 800d3e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d3e6:	4770      	bx	lr

0800d3e8 <HAL_PWR_EnableBkUpAccess>:
  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
  *         Backup Domain Access should be kept enabled.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 800d3e8:	b480      	push	{r7}
 800d3ea:	af00      	add	r7, sp, #0
  /* Enable access to RTC and backup registers */
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800d3ec:	4b05      	ldr	r3, [pc, #20]	; (800d404 <HAL_PWR_EnableBkUpAccess+0x1c>)
 800d3ee:	681b      	ldr	r3, [r3, #0]
 800d3f0:	4a04      	ldr	r2, [pc, #16]	; (800d404 <HAL_PWR_EnableBkUpAccess+0x1c>)
 800d3f2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800d3f6:	6013      	str	r3, [r2, #0]
}
 800d3f8:	bf00      	nop
 800d3fa:	46bd      	mov	sp, r7
 800d3fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d400:	4770      	bx	lr
 800d402:	bf00      	nop
 800d404:	40007000 	.word	0x40007000

0800d408 <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing Pointer to SDRAM control timing structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{
 800d408:	b580      	push	{r7, lr}
 800d40a:	b082      	sub	sp, #8
 800d40c:	af00      	add	r7, sp, #0
 800d40e:	6078      	str	r0, [r7, #4]
 800d410:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if (hsdram == NULL)
 800d412:	687b      	ldr	r3, [r7, #4]
 800d414:	2b00      	cmp	r3, #0
 800d416:	d101      	bne.n	800d41c <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
 800d418:	2301      	movs	r3, #1
 800d41a:	e020      	b.n	800d45e <HAL_SDRAM_Init+0x56>
  }

  if (hsdram->State == HAL_SDRAM_STATE_RESET)
 800d41c:	687b      	ldr	r3, [r7, #4]
 800d41e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d420:	2b00      	cmp	r3, #0
 800d422:	d105      	bne.n	800d430 <HAL_SDRAM_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
 800d424:	687b      	ldr	r3, [r7, #4]
 800d426:	2200      	movs	r2, #0
 800d428:	631a      	str	r2, [r3, #48]	; 0x30

    /* Init the low level hardware */
    hsdram->MspInitCallback(hsdram);
#else
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
 800d42a:	6878      	ldr	r0, [r7, #4]
 800d42c:	f7f4 f9c2 	bl	80017b4 <HAL_SDRAM_MspInit>
#endif /* USE_HAL_SDRAM_REGISTER_CALLBACKS */
  }

  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800d430:	687b      	ldr	r3, [r7, #4]
 800d432:	2202      	movs	r2, #2
 800d434:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Initialize SDRAM control Interface */
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800d436:	687b      	ldr	r3, [r7, #4]
 800d438:	681a      	ldr	r2, [r3, #0]
 800d43a:	687b      	ldr	r3, [r7, #4]
 800d43c:	3304      	adds	r3, #4
 800d43e:	4619      	mov	r1, r3
 800d440:	4610      	mov	r0, r2
 800d442:	f001 f8fd 	bl	800e640 <FMC_SDRAM_Init>

  /* Initialize SDRAM timing Interface */
  (void)FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
 800d446:	687b      	ldr	r3, [r7, #4]
 800d448:	6818      	ldr	r0, [r3, #0]
 800d44a:	687b      	ldr	r3, [r7, #4]
 800d44c:	685b      	ldr	r3, [r3, #4]
 800d44e:	461a      	mov	r2, r3
 800d450:	6839      	ldr	r1, [r7, #0]
 800d452:	f001 f951 	bl	800e6f8 <FMC_SDRAM_Timing_Init>
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 800d456:	687b      	ldr	r3, [r7, #4]
 800d458:	2201      	movs	r2, #1
 800d45a:	62da      	str	r2, [r3, #44]	; 0x2c

  return HAL_OK;
 800d45c:	2300      	movs	r3, #0
}
 800d45e:	4618      	mov	r0, r3
 800d460:	3708      	adds	r7, #8
 800d462:	46bd      	mov	sp, r7
 800d464:	bd80      	pop	{r7, pc}

0800d466 <HAL_SDRAM_SendCommand>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command,
                                        uint32_t Timeout)
{
 800d466:	b580      	push	{r7, lr}
 800d468:	b086      	sub	sp, #24
 800d46a:	af00      	add	r7, sp, #0
 800d46c:	60f8      	str	r0, [r7, #12]
 800d46e:	60b9      	str	r1, [r7, #8]
 800d470:	607a      	str	r2, [r7, #4]
  HAL_SDRAM_StateTypeDef state = hsdram->State;
 800d472:	68fb      	ldr	r3, [r7, #12]
 800d474:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d476:	617b      	str	r3, [r7, #20]

  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
 800d478:	697b      	ldr	r3, [r7, #20]
 800d47a:	2b02      	cmp	r3, #2
 800d47c:	d101      	bne.n	800d482 <HAL_SDRAM_SendCommand+0x1c>
  {
    return HAL_BUSY;
 800d47e:	2302      	movs	r3, #2
 800d480:	e01e      	b.n	800d4c0 <HAL_SDRAM_SendCommand+0x5a>
  }
  else if ((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_PRECHARGED))
 800d482:	697b      	ldr	r3, [r7, #20]
 800d484:	2b01      	cmp	r3, #1
 800d486:	d002      	beq.n	800d48e <HAL_SDRAM_SendCommand+0x28>
 800d488:	697b      	ldr	r3, [r7, #20]
 800d48a:	2b05      	cmp	r3, #5
 800d48c:	d115      	bne.n	800d4ba <HAL_SDRAM_SendCommand+0x54>
  {
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800d48e:	68fb      	ldr	r3, [r7, #12]
 800d490:	2202      	movs	r2, #2
 800d492:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Send SDRAM command */
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800d494:	68fb      	ldr	r3, [r7, #12]
 800d496:	681b      	ldr	r3, [r3, #0]
 800d498:	687a      	ldr	r2, [r7, #4]
 800d49a:	68b9      	ldr	r1, [r7, #8]
 800d49c:	4618      	mov	r0, r3
 800d49e:	f001 f995 	bl	800e7cc <FMC_SDRAM_SendCommand>

    /* Update the SDRAM controller state state */
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800d4a2:	68bb      	ldr	r3, [r7, #8]
 800d4a4:	681b      	ldr	r3, [r3, #0]
 800d4a6:	2b02      	cmp	r3, #2
 800d4a8:	d103      	bne.n	800d4b2 <HAL_SDRAM_SendCommand+0x4c>
    {
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800d4aa:	68fb      	ldr	r3, [r7, #12]
 800d4ac:	2205      	movs	r2, #5
 800d4ae:	62da      	str	r2, [r3, #44]	; 0x2c
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800d4b0:	e005      	b.n	800d4be <HAL_SDRAM_SendCommand+0x58>
    }
    else
    {
      hsdram->State = HAL_SDRAM_STATE_READY;
 800d4b2:	68fb      	ldr	r3, [r7, #12]
 800d4b4:	2201      	movs	r2, #1
 800d4b6:	62da      	str	r2, [r3, #44]	; 0x2c
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800d4b8:	e001      	b.n	800d4be <HAL_SDRAM_SendCommand+0x58>
    }
  }
  else
  {
    return HAL_ERROR;
 800d4ba:	2301      	movs	r3, #1
 800d4bc:	e000      	b.n	800d4c0 <HAL_SDRAM_SendCommand+0x5a>
  }

  return HAL_OK;
 800d4be:	2300      	movs	r3, #0
}
 800d4c0:	4618      	mov	r0, r3
 800d4c2:	3718      	adds	r7, #24
 800d4c4:	46bd      	mov	sp, r7
 800d4c6:	bd80      	pop	{r7, pc}

0800d4c8 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 800d4c8:	b580      	push	{r7, lr}
 800d4ca:	b082      	sub	sp, #8
 800d4cc:	af00      	add	r7, sp, #0
 800d4ce:	6078      	str	r0, [r7, #4]
 800d4d0:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
 800d4d2:	687b      	ldr	r3, [r7, #4]
 800d4d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d4d6:	2b02      	cmp	r3, #2
 800d4d8:	d101      	bne.n	800d4de <HAL_SDRAM_ProgramRefreshRate+0x16>
  {
    return HAL_BUSY;
 800d4da:	2302      	movs	r3, #2
 800d4dc:	e012      	b.n	800d504 <HAL_SDRAM_ProgramRefreshRate+0x3c>
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
 800d4de:	687b      	ldr	r3, [r7, #4]
 800d4e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d4e2:	2b01      	cmp	r3, #1
 800d4e4:	d10d      	bne.n	800d502 <HAL_SDRAM_ProgramRefreshRate+0x3a>
  {
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800d4e6:	687b      	ldr	r3, [r7, #4]
 800d4e8:	2202      	movs	r2, #2
 800d4ea:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Program the refresh rate */
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
 800d4ec:	687b      	ldr	r3, [r7, #4]
 800d4ee:	681b      	ldr	r3, [r3, #0]
 800d4f0:	6839      	ldr	r1, [r7, #0]
 800d4f2:	4618      	mov	r0, r3
 800d4f4:	f001 f98e 	bl	800e814 <FMC_SDRAM_ProgramRefreshRate>

    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_READY;
 800d4f8:	687b      	ldr	r3, [r7, #4]
 800d4fa:	2201      	movs	r2, #1
 800d4fc:	62da      	str	r2, [r3, #44]	; 0x2c
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
 800d4fe:	2300      	movs	r3, #0
 800d500:	e000      	b.n	800d504 <HAL_SDRAM_ProgramRefreshRate+0x3c>
    return HAL_ERROR;
 800d502:	2301      	movs	r3, #1
}
 800d504:	4618      	mov	r0, r3
 800d506:	3708      	adds	r7, #8
 800d508:	46bd      	mov	sp, r7
 800d50a:	bd80      	pop	{r7, pc}

0800d50c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800d50c:	b480      	push	{r7}
 800d50e:	b085      	sub	sp, #20
 800d510:	af00      	add	r7, sp, #0
 800d512:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800d514:	687b      	ldr	r3, [r7, #4]
 800d516:	f003 0307 	and.w	r3, r3, #7
 800d51a:	60bb      	str	r3, [r7, #8]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800d51c:	4b0b      	ldr	r3, [pc, #44]	; (800d54c <__NVIC_SetPriorityGrouping+0x40>)
 800d51e:	68db      	ldr	r3, [r3, #12]
 800d520:	60fb      	str	r3, [r7, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800d522:	68fa      	ldr	r2, [r7, #12]
 800d524:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800d528:	4013      	ands	r3, r2
 800d52a:	60fb      	str	r3, [r7, #12]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800d52c:	68bb      	ldr	r3, [r7, #8]
 800d52e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800d530:	68fb      	ldr	r3, [r7, #12]
 800d532:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
 800d534:	4b06      	ldr	r3, [pc, #24]	; (800d550 <__NVIC_SetPriorityGrouping+0x44>)
 800d536:	4313      	orrs	r3, r2
 800d538:	60fb      	str	r3, [r7, #12]
  SCB->AIRCR =  reg_value;
 800d53a:	4a04      	ldr	r2, [pc, #16]	; (800d54c <__NVIC_SetPriorityGrouping+0x40>)
 800d53c:	68fb      	ldr	r3, [r7, #12]
 800d53e:	60d3      	str	r3, [r2, #12]
}
 800d540:	bf00      	nop
 800d542:	3714      	adds	r7, #20
 800d544:	46bd      	mov	sp, r7
 800d546:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d54a:	4770      	bx	lr
 800d54c:	e000ed00 	.word	0xe000ed00
 800d550:	05fa0000 	.word	0x05fa0000

0800d554 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 800d554:	b480      	push	{r7}
 800d556:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800d558:	4b04      	ldr	r3, [pc, #16]	; (800d56c <__NVIC_GetPriorityGrouping+0x18>)
 800d55a:	68db      	ldr	r3, [r3, #12]
 800d55c:	0a1b      	lsrs	r3, r3, #8
 800d55e:	f003 0307 	and.w	r3, r3, #7
}
 800d562:	4618      	mov	r0, r3
 800d564:	46bd      	mov	sp, r7
 800d566:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d56a:	4770      	bx	lr
 800d56c:	e000ed00 	.word	0xe000ed00

0800d570 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800d570:	b480      	push	{r7}
 800d572:	b083      	sub	sp, #12
 800d574:	af00      	add	r7, sp, #0
 800d576:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 800d578:	687b      	ldr	r3, [r7, #4]
 800d57a:	2b00      	cmp	r3, #0
 800d57c:	db0a      	blt.n	800d594 <__NVIC_EnableIRQ+0x24>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800d57e:	687b      	ldr	r3, [r7, #4]
 800d580:	f003 021f 	and.w	r2, r3, #31
 800d584:	4906      	ldr	r1, [pc, #24]	; (800d5a0 <__NVIC_EnableIRQ+0x30>)
 800d586:	687b      	ldr	r3, [r7, #4]
 800d588:	095b      	lsrs	r3, r3, #5
 800d58a:	2001      	movs	r0, #1
 800d58c:	fa00 f202 	lsl.w	r2, r0, r2
 800d590:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 800d594:	bf00      	nop
 800d596:	370c      	adds	r7, #12
 800d598:	46bd      	mov	sp, r7
 800d59a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d59e:	4770      	bx	lr
 800d5a0:	e000e100 	.word	0xe000e100

0800d5a4 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800d5a4:	b480      	push	{r7}
 800d5a6:	b083      	sub	sp, #12
 800d5a8:	af00      	add	r7, sp, #0
 800d5aa:	6078      	str	r0, [r7, #4]
 800d5ac:	6039      	str	r1, [r7, #0]
  if ((int32_t)(IRQn) >= 0)
 800d5ae:	687b      	ldr	r3, [r7, #4]
 800d5b0:	2b00      	cmp	r3, #0
 800d5b2:	db09      	blt.n	800d5c8 <__NVIC_SetPriority+0x24>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d5b4:	683b      	ldr	r3, [r7, #0]
 800d5b6:	b2da      	uxtb	r2, r3
 800d5b8:	490c      	ldr	r1, [pc, #48]	; (800d5ec <__NVIC_SetPriority+0x48>)
 800d5ba:	687b      	ldr	r3, [r7, #4]
 800d5bc:	0112      	lsls	r2, r2, #4
 800d5be:	b2d2      	uxtb	r2, r2
 800d5c0:	440b      	add	r3, r1
 800d5c2:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 800d5c6:	e00a      	b.n	800d5de <__NVIC_SetPriority+0x3a>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d5c8:	683b      	ldr	r3, [r7, #0]
 800d5ca:	b2da      	uxtb	r2, r3
 800d5cc:	4908      	ldr	r1, [pc, #32]	; (800d5f0 <__NVIC_SetPriority+0x4c>)
 800d5ce:	687b      	ldr	r3, [r7, #4]
 800d5d0:	f003 030f 	and.w	r3, r3, #15
 800d5d4:	3b04      	subs	r3, #4
 800d5d6:	0112      	lsls	r2, r2, #4
 800d5d8:	b2d2      	uxtb	r2, r2
 800d5da:	440b      	add	r3, r1
 800d5dc:	761a      	strb	r2, [r3, #24]
}
 800d5de:	bf00      	nop
 800d5e0:	370c      	adds	r7, #12
 800d5e2:	46bd      	mov	sp, r7
 800d5e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d5e8:	4770      	bx	lr
 800d5ea:	bf00      	nop
 800d5ec:	e000e100 	.word	0xe000e100
 800d5f0:	e000ed00 	.word	0xe000ed00

0800d5f4 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800d5f4:	b480      	push	{r7}
 800d5f6:	b089      	sub	sp, #36	; 0x24
 800d5f8:	af00      	add	r7, sp, #0
 800d5fa:	60f8      	str	r0, [r7, #12]
 800d5fc:	60b9      	str	r1, [r7, #8]
 800d5fe:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800d600:	68fb      	ldr	r3, [r7, #12]
 800d602:	f003 0307 	and.w	r3, r3, #7
 800d606:	617b      	str	r3, [r7, #20]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800d608:	697b      	ldr	r3, [r7, #20]
 800d60a:	f1c3 0307 	rsb	r3, r3, #7
 800d60e:	2b04      	cmp	r3, #4
 800d610:	bf28      	it	cs
 800d612:	2304      	movcs	r3, #4
 800d614:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800d616:	697b      	ldr	r3, [r7, #20]
 800d618:	3304      	adds	r3, #4
 800d61a:	2b06      	cmp	r3, #6
 800d61c:	d902      	bls.n	800d624 <NVIC_EncodePriority+0x30>
 800d61e:	697b      	ldr	r3, [r7, #20]
 800d620:	3b03      	subs	r3, #3
 800d622:	e000      	b.n	800d626 <NVIC_EncodePriority+0x32>
 800d624:	2300      	movs	r3, #0
 800d626:	61fb      	str	r3, [r7, #28]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800d628:	2201      	movs	r2, #1
 800d62a:	69bb      	ldr	r3, [r7, #24]
 800d62c:	fa02 f303 	lsl.w	r3, r2, r3
 800d630:	1e5a      	subs	r2, r3, #1
 800d632:	68bb      	ldr	r3, [r7, #8]
 800d634:	401a      	ands	r2, r3
 800d636:	69fb      	ldr	r3, [r7, #28]
 800d638:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800d63a:	2101      	movs	r1, #1
 800d63c:	69fb      	ldr	r3, [r7, #28]
 800d63e:	fa01 f303 	lsl.w	r3, r1, r3
 800d642:	1e59      	subs	r1, r3, #1
 800d644:	687b      	ldr	r3, [r7, #4]
 800d646:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800d648:	4313      	orrs	r3, r2
         );
}
 800d64a:	4618      	mov	r0, r3
 800d64c:	3724      	adds	r7, #36	; 0x24
 800d64e:	46bd      	mov	sp, r7
 800d650:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d654:	4770      	bx	lr
	...

0800d658 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800d658:	b580      	push	{r7, lr}
 800d65a:	b082      	sub	sp, #8
 800d65c:	af00      	add	r7, sp, #0
 800d65e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800d660:	687b      	ldr	r3, [r7, #4]
 800d662:	3b01      	subs	r3, #1
 800d664:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800d668:	d301      	bcc.n	800d66e <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800d66a:	2301      	movs	r3, #1
 800d66c:	e00f      	b.n	800d68e <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800d66e:	4a0a      	ldr	r2, [pc, #40]	; (800d698 <SysTick_Config+0x40>)
 800d670:	687b      	ldr	r3, [r7, #4]
 800d672:	3b01      	subs	r3, #1
 800d674:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800d676:	210f      	movs	r1, #15
 800d678:	f04f 30ff 	mov.w	r0, #4294967295
 800d67c:	f7ff ff92 	bl	800d5a4 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800d680:	4b05      	ldr	r3, [pc, #20]	; (800d698 <SysTick_Config+0x40>)
 800d682:	2200      	movs	r2, #0
 800d684:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800d686:	4b04      	ldr	r3, [pc, #16]	; (800d698 <SysTick_Config+0x40>)
 800d688:	2207      	movs	r2, #7
 800d68a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800d68c:	2300      	movs	r3, #0
}
 800d68e:	4618      	mov	r0, r3
 800d690:	3708      	adds	r7, #8
 800d692:	46bd      	mov	sp, r7
 800d694:	bd80      	pop	{r7, pc}
 800d696:	bf00      	nop
 800d698:	e000e010 	.word	0xe000e010

0800d69c <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800d69c:	b580      	push	{r7, lr}
 800d69e:	b082      	sub	sp, #8
 800d6a0:	af00      	add	r7, sp, #0
 800d6a2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800d6a4:	6878      	ldr	r0, [r7, #4]
 800d6a6:	f7ff ff31 	bl	800d50c <__NVIC_SetPriorityGrouping>
}
 800d6aa:	bf00      	nop
 800d6ac:	3708      	adds	r7, #8
 800d6ae:	46bd      	mov	sp, r7
 800d6b0:	bd80      	pop	{r7, pc}

0800d6b2 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800d6b2:	b580      	push	{r7, lr}
 800d6b4:	b086      	sub	sp, #24
 800d6b6:	af00      	add	r7, sp, #0
 800d6b8:	60f8      	str	r0, [r7, #12]
 800d6ba:	60b9      	str	r1, [r7, #8]
 800d6bc:	607a      	str	r2, [r7, #4]
  uint32_t prioritygroup = 0x00;
 800d6be:	2300      	movs	r3, #0
 800d6c0:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800d6c2:	f7ff ff47 	bl	800d554 <__NVIC_GetPriorityGrouping>
 800d6c6:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800d6c8:	687a      	ldr	r2, [r7, #4]
 800d6ca:	68b9      	ldr	r1, [r7, #8]
 800d6cc:	6978      	ldr	r0, [r7, #20]
 800d6ce:	f7ff ff91 	bl	800d5f4 <NVIC_EncodePriority>
 800d6d2:	4603      	mov	r3, r0
 800d6d4:	4619      	mov	r1, r3
 800d6d6:	68f8      	ldr	r0, [r7, #12]
 800d6d8:	f7ff ff64 	bl	800d5a4 <__NVIC_SetPriority>
}
 800d6dc:	bf00      	nop
 800d6de:	3718      	adds	r7, #24
 800d6e0:	46bd      	mov	sp, r7
 800d6e2:	bd80      	pop	{r7, pc}

0800d6e4 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800d6e4:	b580      	push	{r7, lr}
 800d6e6:	b082      	sub	sp, #8
 800d6e8:	af00      	add	r7, sp, #0
 800d6ea:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800d6ec:	6878      	ldr	r0, [r7, #4]
 800d6ee:	f7ff ff3f 	bl	800d570 <__NVIC_EnableIRQ>
}
 800d6f2:	bf00      	nop
 800d6f4:	3708      	adds	r7, #8
 800d6f6:	46bd      	mov	sp, r7
 800d6f8:	bd80      	pop	{r7, pc}

0800d6fa <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800d6fa:	b580      	push	{r7, lr}
 800d6fc:	b082      	sub	sp, #8
 800d6fe:	af00      	add	r7, sp, #0
 800d700:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800d702:	6878      	ldr	r0, [r7, #4]
 800d704:	f7ff ffa8 	bl	800d658 <SysTick_Config>
 800d708:	4603      	mov	r3, r0
}
 800d70a:	4618      	mov	r0, r3
 800d70c:	3708      	adds	r7, #8
 800d70e:	46bd      	mov	sp, r7
 800d710:	bd80      	pop	{r7, pc}
	...

0800d714 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800d714:	b480      	push	{r7}
 800d716:	b089      	sub	sp, #36	; 0x24
 800d718:	af00      	add	r7, sp, #0
 800d71a:	6078      	str	r0, [r7, #4]
 800d71c:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00;
 800d71e:	2300      	movs	r3, #0
 800d720:	613b      	str	r3, [r7, #16]
  uint32_t ioposition = 0x00;
 800d722:	2300      	movs	r3, #0
 800d724:	61bb      	str	r3, [r7, #24]
  uint32_t iocurrent = 0x00;
 800d726:	2300      	movs	r3, #0
 800d728:	61fb      	str	r3, [r7, #28]
  uint32_t temp = 0x00;
 800d72a:	2300      	movs	r3, #0
 800d72c:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800d72e:	2300      	movs	r3, #0
 800d730:	613b      	str	r3, [r7, #16]
 800d732:	e175      	b.n	800da20 <HAL_GPIO_Init+0x30c>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 800d734:	2201      	movs	r2, #1
 800d736:	693b      	ldr	r3, [r7, #16]
 800d738:	fa02 f303 	lsl.w	r3, r2, r3
 800d73c:	61bb      	str	r3, [r7, #24]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800d73e:	683b      	ldr	r3, [r7, #0]
 800d740:	681b      	ldr	r3, [r3, #0]
 800d742:	69ba      	ldr	r2, [r7, #24]
 800d744:	4013      	ands	r3, r2
 800d746:	61fb      	str	r3, [r7, #28]

    if(iocurrent == ioposition)
 800d748:	69fa      	ldr	r2, [r7, #28]
 800d74a:	69bb      	ldr	r3, [r7, #24]
 800d74c:	429a      	cmp	r2, r3
 800d74e:	f040 8164 	bne.w	800da1a <HAL_GPIO_Init+0x306>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800d752:	683b      	ldr	r3, [r7, #0]
 800d754:	685b      	ldr	r3, [r3, #4]
 800d756:	f003 0303 	and.w	r3, r3, #3
 800d75a:	2b01      	cmp	r3, #1
 800d75c:	d005      	beq.n	800d76a <HAL_GPIO_Init+0x56>
 800d75e:	683b      	ldr	r3, [r7, #0]
 800d760:	685b      	ldr	r3, [r3, #4]
 800d762:	f003 0303 	and.w	r3, r3, #3
 800d766:	2b02      	cmp	r3, #2
 800d768:	d130      	bne.n	800d7cc <HAL_GPIO_Init+0xb8>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 800d76a:	687b      	ldr	r3, [r7, #4]
 800d76c:	689b      	ldr	r3, [r3, #8]
 800d76e:	617b      	str	r3, [r7, #20]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800d770:	693b      	ldr	r3, [r7, #16]
 800d772:	005b      	lsls	r3, r3, #1
 800d774:	2203      	movs	r2, #3
 800d776:	fa02 f303 	lsl.w	r3, r2, r3
 800d77a:	43db      	mvns	r3, r3
 800d77c:	697a      	ldr	r2, [r7, #20]
 800d77e:	4013      	ands	r3, r2
 800d780:	617b      	str	r3, [r7, #20]
        temp |= (GPIO_Init->Speed << (position * 2));
 800d782:	683b      	ldr	r3, [r7, #0]
 800d784:	68da      	ldr	r2, [r3, #12]
 800d786:	693b      	ldr	r3, [r7, #16]
 800d788:	005b      	lsls	r3, r3, #1
 800d78a:	fa02 f303 	lsl.w	r3, r2, r3
 800d78e:	697a      	ldr	r2, [r7, #20]
 800d790:	4313      	orrs	r3, r2
 800d792:	617b      	str	r3, [r7, #20]
        GPIOx->OSPEEDR = temp;
 800d794:	687b      	ldr	r3, [r7, #4]
 800d796:	697a      	ldr	r2, [r7, #20]
 800d798:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800d79a:	687b      	ldr	r3, [r7, #4]
 800d79c:	685b      	ldr	r3, [r3, #4]
 800d79e:	617b      	str	r3, [r7, #20]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800d7a0:	2201      	movs	r2, #1
 800d7a2:	693b      	ldr	r3, [r7, #16]
 800d7a4:	fa02 f303 	lsl.w	r3, r2, r3
 800d7a8:	43db      	mvns	r3, r3
 800d7aa:	697a      	ldr	r2, [r7, #20]
 800d7ac:	4013      	ands	r3, r2
 800d7ae:	617b      	str	r3, [r7, #20]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800d7b0:	683b      	ldr	r3, [r7, #0]
 800d7b2:	685b      	ldr	r3, [r3, #4]
 800d7b4:	091b      	lsrs	r3, r3, #4
 800d7b6:	f003 0201 	and.w	r2, r3, #1
 800d7ba:	693b      	ldr	r3, [r7, #16]
 800d7bc:	fa02 f303 	lsl.w	r3, r2, r3
 800d7c0:	697a      	ldr	r2, [r7, #20]
 800d7c2:	4313      	orrs	r3, r2
 800d7c4:	617b      	str	r3, [r7, #20]
        GPIOx->OTYPER = temp;
 800d7c6:	687b      	ldr	r3, [r7, #4]
 800d7c8:	697a      	ldr	r2, [r7, #20]
 800d7ca:	605a      	str	r2, [r3, #4]
      }
      
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800d7cc:	683b      	ldr	r3, [r7, #0]
 800d7ce:	685b      	ldr	r3, [r3, #4]
 800d7d0:	f003 0303 	and.w	r3, r3, #3
 800d7d4:	2b03      	cmp	r3, #3
 800d7d6:	d017      	beq.n	800d808 <HAL_GPIO_Init+0xf4>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 800d7d8:	687b      	ldr	r3, [r7, #4]
 800d7da:	68db      	ldr	r3, [r3, #12]
 800d7dc:	617b      	str	r3, [r7, #20]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 800d7de:	693b      	ldr	r3, [r7, #16]
 800d7e0:	005b      	lsls	r3, r3, #1
 800d7e2:	2203      	movs	r2, #3
 800d7e4:	fa02 f303 	lsl.w	r3, r2, r3
 800d7e8:	43db      	mvns	r3, r3
 800d7ea:	697a      	ldr	r2, [r7, #20]
 800d7ec:	4013      	ands	r3, r2
 800d7ee:	617b      	str	r3, [r7, #20]
        temp |= ((GPIO_Init->Pull) << (position * 2));
 800d7f0:	683b      	ldr	r3, [r7, #0]
 800d7f2:	689a      	ldr	r2, [r3, #8]
 800d7f4:	693b      	ldr	r3, [r7, #16]
 800d7f6:	005b      	lsls	r3, r3, #1
 800d7f8:	fa02 f303 	lsl.w	r3, r2, r3
 800d7fc:	697a      	ldr	r2, [r7, #20]
 800d7fe:	4313      	orrs	r3, r2
 800d800:	617b      	str	r3, [r7, #20]
        GPIOx->PUPDR = temp;
 800d802:	687b      	ldr	r3, [r7, #4]
 800d804:	697a      	ldr	r2, [r7, #20]
 800d806:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800d808:	683b      	ldr	r3, [r7, #0]
 800d80a:	685b      	ldr	r3, [r3, #4]
 800d80c:	f003 0303 	and.w	r3, r3, #3
 800d810:	2b02      	cmp	r3, #2
 800d812:	d123      	bne.n	800d85c <HAL_GPIO_Init+0x148>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 800d814:	693b      	ldr	r3, [r7, #16]
 800d816:	08da      	lsrs	r2, r3, #3
 800d818:	687b      	ldr	r3, [r7, #4]
 800d81a:	3208      	adds	r2, #8
 800d81c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d820:	617b      	str	r3, [r7, #20]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800d822:	693b      	ldr	r3, [r7, #16]
 800d824:	f003 0307 	and.w	r3, r3, #7
 800d828:	009b      	lsls	r3, r3, #2
 800d82a:	220f      	movs	r2, #15
 800d82c:	fa02 f303 	lsl.w	r3, r2, r3
 800d830:	43db      	mvns	r3, r3
 800d832:	697a      	ldr	r2, [r7, #20]
 800d834:	4013      	ands	r3, r2
 800d836:	617b      	str	r3, [r7, #20]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800d838:	683b      	ldr	r3, [r7, #0]
 800d83a:	691a      	ldr	r2, [r3, #16]
 800d83c:	693b      	ldr	r3, [r7, #16]
 800d83e:	f003 0307 	and.w	r3, r3, #7
 800d842:	009b      	lsls	r3, r3, #2
 800d844:	fa02 f303 	lsl.w	r3, r2, r3
 800d848:	697a      	ldr	r2, [r7, #20]
 800d84a:	4313      	orrs	r3, r2
 800d84c:	617b      	str	r3, [r7, #20]
        GPIOx->AFR[position >> 3] = temp;
 800d84e:	693b      	ldr	r3, [r7, #16]
 800d850:	08da      	lsrs	r2, r3, #3
 800d852:	687b      	ldr	r3, [r7, #4]
 800d854:	3208      	adds	r2, #8
 800d856:	6979      	ldr	r1, [r7, #20]
 800d858:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }
      
      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800d85c:	687b      	ldr	r3, [r7, #4]
 800d85e:	681b      	ldr	r3, [r3, #0]
 800d860:	617b      	str	r3, [r7, #20]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 800d862:	693b      	ldr	r3, [r7, #16]
 800d864:	005b      	lsls	r3, r3, #1
 800d866:	2203      	movs	r2, #3
 800d868:	fa02 f303 	lsl.w	r3, r2, r3
 800d86c:	43db      	mvns	r3, r3
 800d86e:	697a      	ldr	r2, [r7, #20]
 800d870:	4013      	ands	r3, r2
 800d872:	617b      	str	r3, [r7, #20]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800d874:	683b      	ldr	r3, [r7, #0]
 800d876:	685b      	ldr	r3, [r3, #4]
 800d878:	f003 0203 	and.w	r2, r3, #3
 800d87c:	693b      	ldr	r3, [r7, #16]
 800d87e:	005b      	lsls	r3, r3, #1
 800d880:	fa02 f303 	lsl.w	r3, r2, r3
 800d884:	697a      	ldr	r2, [r7, #20]
 800d886:	4313      	orrs	r3, r2
 800d888:	617b      	str	r3, [r7, #20]
      GPIOx->MODER = temp;
 800d88a:	687b      	ldr	r3, [r7, #4]
 800d88c:	697a      	ldr	r2, [r7, #20]
 800d88e:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 800d890:	683b      	ldr	r3, [r7, #0]
 800d892:	685b      	ldr	r3, [r3, #4]
 800d894:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800d898:	2b00      	cmp	r3, #0
 800d89a:	f000 80be 	beq.w	800da1a <HAL_GPIO_Init+0x306>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800d89e:	4b66      	ldr	r3, [pc, #408]	; (800da38 <HAL_GPIO_Init+0x324>)
 800d8a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d8a2:	4a65      	ldr	r2, [pc, #404]	; (800da38 <HAL_GPIO_Init+0x324>)
 800d8a4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800d8a8:	6453      	str	r3, [r2, #68]	; 0x44
 800d8aa:	4b63      	ldr	r3, [pc, #396]	; (800da38 <HAL_GPIO_Init+0x324>)
 800d8ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d8ae:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800d8b2:	60fb      	str	r3, [r7, #12]
 800d8b4:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 800d8b6:	4a61      	ldr	r2, [pc, #388]	; (800da3c <HAL_GPIO_Init+0x328>)
 800d8b8:	693b      	ldr	r3, [r7, #16]
 800d8ba:	089b      	lsrs	r3, r3, #2
 800d8bc:	3302      	adds	r3, #2
 800d8be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d8c2:	617b      	str	r3, [r7, #20]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800d8c4:	693b      	ldr	r3, [r7, #16]
 800d8c6:	f003 0303 	and.w	r3, r3, #3
 800d8ca:	009b      	lsls	r3, r3, #2
 800d8cc:	220f      	movs	r2, #15
 800d8ce:	fa02 f303 	lsl.w	r3, r2, r3
 800d8d2:	43db      	mvns	r3, r3
 800d8d4:	697a      	ldr	r2, [r7, #20]
 800d8d6:	4013      	ands	r3, r2
 800d8d8:	617b      	str	r3, [r7, #20]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800d8da:	687b      	ldr	r3, [r7, #4]
 800d8dc:	4a58      	ldr	r2, [pc, #352]	; (800da40 <HAL_GPIO_Init+0x32c>)
 800d8de:	4293      	cmp	r3, r2
 800d8e0:	d037      	beq.n	800d952 <HAL_GPIO_Init+0x23e>
 800d8e2:	687b      	ldr	r3, [r7, #4]
 800d8e4:	4a57      	ldr	r2, [pc, #348]	; (800da44 <HAL_GPIO_Init+0x330>)
 800d8e6:	4293      	cmp	r3, r2
 800d8e8:	d031      	beq.n	800d94e <HAL_GPIO_Init+0x23a>
 800d8ea:	687b      	ldr	r3, [r7, #4]
 800d8ec:	4a56      	ldr	r2, [pc, #344]	; (800da48 <HAL_GPIO_Init+0x334>)
 800d8ee:	4293      	cmp	r3, r2
 800d8f0:	d02b      	beq.n	800d94a <HAL_GPIO_Init+0x236>
 800d8f2:	687b      	ldr	r3, [r7, #4]
 800d8f4:	4a55      	ldr	r2, [pc, #340]	; (800da4c <HAL_GPIO_Init+0x338>)
 800d8f6:	4293      	cmp	r3, r2
 800d8f8:	d025      	beq.n	800d946 <HAL_GPIO_Init+0x232>
 800d8fa:	687b      	ldr	r3, [r7, #4]
 800d8fc:	4a54      	ldr	r2, [pc, #336]	; (800da50 <HAL_GPIO_Init+0x33c>)
 800d8fe:	4293      	cmp	r3, r2
 800d900:	d01f      	beq.n	800d942 <HAL_GPIO_Init+0x22e>
 800d902:	687b      	ldr	r3, [r7, #4]
 800d904:	4a53      	ldr	r2, [pc, #332]	; (800da54 <HAL_GPIO_Init+0x340>)
 800d906:	4293      	cmp	r3, r2
 800d908:	d019      	beq.n	800d93e <HAL_GPIO_Init+0x22a>
 800d90a:	687b      	ldr	r3, [r7, #4]
 800d90c:	4a52      	ldr	r2, [pc, #328]	; (800da58 <HAL_GPIO_Init+0x344>)
 800d90e:	4293      	cmp	r3, r2
 800d910:	d013      	beq.n	800d93a <HAL_GPIO_Init+0x226>
 800d912:	687b      	ldr	r3, [r7, #4]
 800d914:	4a51      	ldr	r2, [pc, #324]	; (800da5c <HAL_GPIO_Init+0x348>)
 800d916:	4293      	cmp	r3, r2
 800d918:	d00d      	beq.n	800d936 <HAL_GPIO_Init+0x222>
 800d91a:	687b      	ldr	r3, [r7, #4]
 800d91c:	4a50      	ldr	r2, [pc, #320]	; (800da60 <HAL_GPIO_Init+0x34c>)
 800d91e:	4293      	cmp	r3, r2
 800d920:	d007      	beq.n	800d932 <HAL_GPIO_Init+0x21e>
 800d922:	687b      	ldr	r3, [r7, #4]
 800d924:	4a4f      	ldr	r2, [pc, #316]	; (800da64 <HAL_GPIO_Init+0x350>)
 800d926:	4293      	cmp	r3, r2
 800d928:	d101      	bne.n	800d92e <HAL_GPIO_Init+0x21a>
 800d92a:	2309      	movs	r3, #9
 800d92c:	e012      	b.n	800d954 <HAL_GPIO_Init+0x240>
 800d92e:	230a      	movs	r3, #10
 800d930:	e010      	b.n	800d954 <HAL_GPIO_Init+0x240>
 800d932:	2308      	movs	r3, #8
 800d934:	e00e      	b.n	800d954 <HAL_GPIO_Init+0x240>
 800d936:	2307      	movs	r3, #7
 800d938:	e00c      	b.n	800d954 <HAL_GPIO_Init+0x240>
 800d93a:	2306      	movs	r3, #6
 800d93c:	e00a      	b.n	800d954 <HAL_GPIO_Init+0x240>
 800d93e:	2305      	movs	r3, #5
 800d940:	e008      	b.n	800d954 <HAL_GPIO_Init+0x240>
 800d942:	2304      	movs	r3, #4
 800d944:	e006      	b.n	800d954 <HAL_GPIO_Init+0x240>
 800d946:	2303      	movs	r3, #3
 800d948:	e004      	b.n	800d954 <HAL_GPIO_Init+0x240>
 800d94a:	2302      	movs	r3, #2
 800d94c:	e002      	b.n	800d954 <HAL_GPIO_Init+0x240>
 800d94e:	2301      	movs	r3, #1
 800d950:	e000      	b.n	800d954 <HAL_GPIO_Init+0x240>
 800d952:	2300      	movs	r3, #0
 800d954:	693a      	ldr	r2, [r7, #16]
 800d956:	f002 0203 	and.w	r2, r2, #3
 800d95a:	0092      	lsls	r2, r2, #2
 800d95c:	4093      	lsls	r3, r2
 800d95e:	697a      	ldr	r2, [r7, #20]
 800d960:	4313      	orrs	r3, r2
 800d962:	617b      	str	r3, [r7, #20]
        SYSCFG->EXTICR[position >> 2] = temp;
 800d964:	4935      	ldr	r1, [pc, #212]	; (800da3c <HAL_GPIO_Init+0x328>)
 800d966:	693b      	ldr	r3, [r7, #16]
 800d968:	089b      	lsrs	r3, r3, #2
 800d96a:	3302      	adds	r3, #2
 800d96c:	697a      	ldr	r2, [r7, #20]
 800d96e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800d972:	4b3d      	ldr	r3, [pc, #244]	; (800da68 <HAL_GPIO_Init+0x354>)
 800d974:	689b      	ldr	r3, [r3, #8]
 800d976:	617b      	str	r3, [r7, #20]
        temp &= ~((uint32_t)iocurrent);
 800d978:	69fb      	ldr	r3, [r7, #28]
 800d97a:	43db      	mvns	r3, r3
 800d97c:	697a      	ldr	r2, [r7, #20]
 800d97e:	4013      	ands	r3, r2
 800d980:	617b      	str	r3, [r7, #20]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 800d982:	683b      	ldr	r3, [r7, #0]
 800d984:	685b      	ldr	r3, [r3, #4]
 800d986:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800d98a:	2b00      	cmp	r3, #0
 800d98c:	d003      	beq.n	800d996 <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
 800d98e:	697a      	ldr	r2, [r7, #20]
 800d990:	69fb      	ldr	r3, [r7, #28]
 800d992:	4313      	orrs	r3, r2
 800d994:	617b      	str	r3, [r7, #20]
        }
        EXTI->RTSR = temp;
 800d996:	4a34      	ldr	r2, [pc, #208]	; (800da68 <HAL_GPIO_Init+0x354>)
 800d998:	697b      	ldr	r3, [r7, #20]
 800d99a:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 800d99c:	4b32      	ldr	r3, [pc, #200]	; (800da68 <HAL_GPIO_Init+0x354>)
 800d99e:	68db      	ldr	r3, [r3, #12]
 800d9a0:	617b      	str	r3, [r7, #20]
        temp &= ~((uint32_t)iocurrent);
 800d9a2:	69fb      	ldr	r3, [r7, #28]
 800d9a4:	43db      	mvns	r3, r3
 800d9a6:	697a      	ldr	r2, [r7, #20]
 800d9a8:	4013      	ands	r3, r2
 800d9aa:	617b      	str	r3, [r7, #20]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 800d9ac:	683b      	ldr	r3, [r7, #0]
 800d9ae:	685b      	ldr	r3, [r3, #4]
 800d9b0:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800d9b4:	2b00      	cmp	r3, #0
 800d9b6:	d003      	beq.n	800d9c0 <HAL_GPIO_Init+0x2ac>
        {
          temp |= iocurrent;
 800d9b8:	697a      	ldr	r2, [r7, #20]
 800d9ba:	69fb      	ldr	r3, [r7, #28]
 800d9bc:	4313      	orrs	r3, r2
 800d9be:	617b      	str	r3, [r7, #20]
        }
        EXTI->FTSR = temp;
 800d9c0:	4a29      	ldr	r2, [pc, #164]	; (800da68 <HAL_GPIO_Init+0x354>)
 800d9c2:	697b      	ldr	r3, [r7, #20]
 800d9c4:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 800d9c6:	4b28      	ldr	r3, [pc, #160]	; (800da68 <HAL_GPIO_Init+0x354>)
 800d9c8:	685b      	ldr	r3, [r3, #4]
 800d9ca:	617b      	str	r3, [r7, #20]
        temp &= ~((uint32_t)iocurrent);
 800d9cc:	69fb      	ldr	r3, [r7, #28]
 800d9ce:	43db      	mvns	r3, r3
 800d9d0:	697a      	ldr	r2, [r7, #20]
 800d9d2:	4013      	ands	r3, r2
 800d9d4:	617b      	str	r3, [r7, #20]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 800d9d6:	683b      	ldr	r3, [r7, #0]
 800d9d8:	685b      	ldr	r3, [r3, #4]
 800d9da:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d9de:	2b00      	cmp	r3, #0
 800d9e0:	d003      	beq.n	800d9ea <HAL_GPIO_Init+0x2d6>
        {
          temp |= iocurrent;
 800d9e2:	697a      	ldr	r2, [r7, #20]
 800d9e4:	69fb      	ldr	r3, [r7, #28]
 800d9e6:	4313      	orrs	r3, r2
 800d9e8:	617b      	str	r3, [r7, #20]
        }
        EXTI->EMR = temp;
 800d9ea:	4a1f      	ldr	r2, [pc, #124]	; (800da68 <HAL_GPIO_Init+0x354>)
 800d9ec:	697b      	ldr	r3, [r7, #20]
 800d9ee:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800d9f0:	4b1d      	ldr	r3, [pc, #116]	; (800da68 <HAL_GPIO_Init+0x354>)
 800d9f2:	681b      	ldr	r3, [r3, #0]
 800d9f4:	617b      	str	r3, [r7, #20]
        temp &= ~((uint32_t)iocurrent);
 800d9f6:	69fb      	ldr	r3, [r7, #28]
 800d9f8:	43db      	mvns	r3, r3
 800d9fa:	697a      	ldr	r2, [r7, #20]
 800d9fc:	4013      	ands	r3, r2
 800d9fe:	617b      	str	r3, [r7, #20]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800da00:	683b      	ldr	r3, [r7, #0]
 800da02:	685b      	ldr	r3, [r3, #4]
 800da04:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800da08:	2b00      	cmp	r3, #0
 800da0a:	d003      	beq.n	800da14 <HAL_GPIO_Init+0x300>
        {
          temp |= iocurrent;
 800da0c:	697a      	ldr	r2, [r7, #20]
 800da0e:	69fb      	ldr	r3, [r7, #28]
 800da10:	4313      	orrs	r3, r2
 800da12:	617b      	str	r3, [r7, #20]
        }
        EXTI->IMR = temp;
 800da14:	4a14      	ldr	r2, [pc, #80]	; (800da68 <HAL_GPIO_Init+0x354>)
 800da16:	697b      	ldr	r3, [r7, #20]
 800da18:	6013      	str	r3, [r2, #0]
  for(position = 0; position < GPIO_NUMBER; position++)
 800da1a:	693b      	ldr	r3, [r7, #16]
 800da1c:	3301      	adds	r3, #1
 800da1e:	613b      	str	r3, [r7, #16]
 800da20:	693b      	ldr	r3, [r7, #16]
 800da22:	2b0f      	cmp	r3, #15
 800da24:	f67f ae86 	bls.w	800d734 <HAL_GPIO_Init+0x20>
      }
    }
  }
}
 800da28:	bf00      	nop
 800da2a:	bf00      	nop
 800da2c:	3724      	adds	r7, #36	; 0x24
 800da2e:	46bd      	mov	sp, r7
 800da30:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da34:	4770      	bx	lr
 800da36:	bf00      	nop
 800da38:	40023800 	.word	0x40023800
 800da3c:	40013800 	.word	0x40013800
 800da40:	40020000 	.word	0x40020000
 800da44:	40020400 	.word	0x40020400
 800da48:	40020800 	.word	0x40020800
 800da4c:	40020c00 	.word	0x40020c00
 800da50:	40021000 	.word	0x40021000
 800da54:	40021400 	.word	0x40021400
 800da58:	40021800 	.word	0x40021800
 800da5c:	40021c00 	.word	0x40021c00
 800da60:	40022000 	.word	0x40022000
 800da64:	40022400 	.word	0x40022400
 800da68:	40013c00 	.word	0x40013c00

0800da6c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800da6c:	b480      	push	{r7}
 800da6e:	b085      	sub	sp, #20
 800da70:	af00      	add	r7, sp, #0
 800da72:	60f8      	str	r0, [r7, #12]
 800da74:	460b      	mov	r3, r1
 800da76:	607a      	str	r2, [r7, #4]
 800da78:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800da7a:	687b      	ldr	r3, [r7, #4]
 800da7c:	2b00      	cmp	r3, #0
 800da7e:	d003      	beq.n	800da88 <HAL_GPIO_WritePin+0x1c>
  {
    GPIOx->BSRR = GPIO_Pin;
 800da80:	897a      	ldrh	r2, [r7, #10]
 800da82:	68fb      	ldr	r3, [r7, #12]
 800da84:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
  }
}
 800da86:	e003      	b.n	800da90 <HAL_GPIO_WritePin+0x24>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 800da88:	897b      	ldrh	r3, [r7, #10]
 800da8a:	041a      	lsls	r2, r3, #16
 800da8c:	68fb      	ldr	r3, [r7, #12]
 800da8e:	619a      	str	r2, [r3, #24]
}
 800da90:	bf00      	nop
 800da92:	3714      	adds	r7, #20
 800da94:	46bd      	mov	sp, r7
 800da96:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da9a:	4770      	bx	lr

0800da9c <HAL_GPIO_TogglePin>:
  * @param  GPIOx Where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_Pin Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800da9c:	b480      	push	{r7}
 800da9e:	b085      	sub	sp, #20
 800daa0:	af00      	add	r7, sp, #0
 800daa2:	6078      	str	r0, [r7, #4]
 800daa4:	460b      	mov	r3, r1
 800daa6:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 800daa8:	687b      	ldr	r3, [r7, #4]
 800daaa:	695b      	ldr	r3, [r3, #20]
 800daac:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 800daae:	887a      	ldrh	r2, [r7, #2]
 800dab0:	68fb      	ldr	r3, [r7, #12]
 800dab2:	4013      	ands	r3, r2
 800dab4:	041a      	lsls	r2, r3, #16
 800dab6:	68fb      	ldr	r3, [r7, #12]
 800dab8:	43d9      	mvns	r1, r3
 800daba:	887b      	ldrh	r3, [r7, #2]
 800dabc:	400b      	ands	r3, r1
 800dabe:	431a      	orrs	r2, r3
 800dac0:	687b      	ldr	r3, [r7, #4]
 800dac2:	619a      	str	r2, [r3, #24]
}
 800dac4:	bf00      	nop
 800dac6:	3714      	adds	r7, #20
 800dac8:	46bd      	mov	sp, r7
 800daca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dace:	4770      	bx	lr

0800dad0 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800dad0:	b580      	push	{r7, lr}
 800dad2:	b082      	sub	sp, #8
 800dad4:	af00      	add	r7, sp, #0
 800dad6:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 800dad8:	687b      	ldr	r3, [r7, #4]
 800dada:	2b00      	cmp	r3, #0
 800dadc:	d101      	bne.n	800dae2 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800dade:	2301      	movs	r3, #1
 800dae0:	e03f      	b.n	800db62 <HAL_UART_Init+0x92>
  {
    /* Check the parameters */
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 800dae2:	687b      	ldr	r3, [r7, #4]
 800dae4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800dae6:	2b00      	cmp	r3, #0
 800dae8:	d105      	bne.n	800daf6 <HAL_UART_Init+0x26>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800daea:	687b      	ldr	r3, [r7, #4]
 800daec:	2200      	movs	r2, #0
 800daee:	675a      	str	r2, [r3, #116]	; 0x74

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800daf0:	6878      	ldr	r0, [r7, #4]
 800daf2:	f7f3 ffe9 	bl	8001ac8 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800daf6:	687b      	ldr	r3, [r7, #4]
 800daf8:	2224      	movs	r2, #36	; 0x24
 800dafa:	679a      	str	r2, [r3, #120]	; 0x78

  __HAL_UART_DISABLE(huart);
 800dafc:	687b      	ldr	r3, [r7, #4]
 800dafe:	681b      	ldr	r3, [r3, #0]
 800db00:	681a      	ldr	r2, [r3, #0]
 800db02:	687b      	ldr	r3, [r7, #4]
 800db04:	681b      	ldr	r3, [r3, #0]
 800db06:	f022 0201 	bic.w	r2, r2, #1
 800db0a:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800db0c:	6878      	ldr	r0, [r7, #4]
 800db0e:	f000 f989 	bl	800de24 <UART_SetConfig>
 800db12:	4603      	mov	r3, r0
 800db14:	2b01      	cmp	r3, #1
 800db16:	d101      	bne.n	800db1c <HAL_UART_Init+0x4c>
  {
    return HAL_ERROR;
 800db18:	2301      	movs	r3, #1
 800db1a:	e022      	b.n	800db62 <HAL_UART_Init+0x92>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800db1c:	687b      	ldr	r3, [r7, #4]
 800db1e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800db20:	2b00      	cmp	r3, #0
 800db22:	d002      	beq.n	800db2a <HAL_UART_Init+0x5a>
  {
    UART_AdvFeatureConfig(huart);
 800db24:	6878      	ldr	r0, [r7, #4]
 800db26:	f000 fbe1 	bl	800e2ec <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800db2a:	687b      	ldr	r3, [r7, #4]
 800db2c:	681b      	ldr	r3, [r3, #0]
 800db2e:	685a      	ldr	r2, [r3, #4]
 800db30:	687b      	ldr	r3, [r7, #4]
 800db32:	681b      	ldr	r3, [r3, #0]
 800db34:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800db38:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800db3a:	687b      	ldr	r3, [r7, #4]
 800db3c:	681b      	ldr	r3, [r3, #0]
 800db3e:	689a      	ldr	r2, [r3, #8]
 800db40:	687b      	ldr	r3, [r7, #4]
 800db42:	681b      	ldr	r3, [r3, #0]
 800db44:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800db48:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 800db4a:	687b      	ldr	r3, [r7, #4]
 800db4c:	681b      	ldr	r3, [r3, #0]
 800db4e:	681a      	ldr	r2, [r3, #0]
 800db50:	687b      	ldr	r3, [r7, #4]
 800db52:	681b      	ldr	r3, [r3, #0]
 800db54:	f042 0201 	orr.w	r2, r2, #1
 800db58:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 800db5a:	6878      	ldr	r0, [r7, #4]
 800db5c:	f000 fc68 	bl	800e430 <UART_CheckIdleState>
 800db60:	4603      	mov	r3, r0
}
 800db62:	4618      	mov	r0, r3
 800db64:	3708      	adds	r7, #8
 800db66:	46bd      	mov	sp, r7
 800db68:	bd80      	pop	{r7, pc}

0800db6a <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800db6a:	b580      	push	{r7, lr}
 800db6c:	b08a      	sub	sp, #40	; 0x28
 800db6e:	af02      	add	r7, sp, #8
 800db70:	60f8      	str	r0, [r7, #12]
 800db72:	60b9      	str	r1, [r7, #8]
 800db74:	603b      	str	r3, [r7, #0]
 800db76:	4613      	mov	r3, r2
 800db78:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800db7a:	68fb      	ldr	r3, [r7, #12]
 800db7c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800db7e:	2b20      	cmp	r3, #32
 800db80:	d17d      	bne.n	800dc7e <HAL_UART_Transmit+0x114>
  {
    if ((pData == NULL) || (Size == 0U))
 800db82:	68bb      	ldr	r3, [r7, #8]
 800db84:	2b00      	cmp	r3, #0
 800db86:	d002      	beq.n	800db8e <HAL_UART_Transmit+0x24>
 800db88:	88fb      	ldrh	r3, [r7, #6]
 800db8a:	2b00      	cmp	r3, #0
 800db8c:	d101      	bne.n	800db92 <HAL_UART_Transmit+0x28>
    {
      return  HAL_ERROR;
 800db8e:	2301      	movs	r3, #1
 800db90:	e076      	b.n	800dc80 <HAL_UART_Transmit+0x116>
    }

    __HAL_LOCK(huart);
 800db92:	68fb      	ldr	r3, [r7, #12]
 800db94:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800db96:	2b01      	cmp	r3, #1
 800db98:	d101      	bne.n	800db9e <HAL_UART_Transmit+0x34>
 800db9a:	2302      	movs	r3, #2
 800db9c:	e070      	b.n	800dc80 <HAL_UART_Transmit+0x116>
 800db9e:	68fb      	ldr	r3, [r7, #12]
 800dba0:	2201      	movs	r2, #1
 800dba2:	675a      	str	r2, [r3, #116]	; 0x74

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800dba4:	68fb      	ldr	r3, [r7, #12]
 800dba6:	2200      	movs	r2, #0
 800dba8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800dbac:	68fb      	ldr	r3, [r7, #12]
 800dbae:	2221      	movs	r2, #33	; 0x21
 800dbb0:	679a      	str	r2, [r3, #120]	; 0x78

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800dbb2:	f7f4 f8df 	bl	8001d74 <HAL_GetTick>
 800dbb6:	61f8      	str	r0, [r7, #28]

    huart->TxXferSize  = Size;
 800dbb8:	68fb      	ldr	r3, [r7, #12]
 800dbba:	88fa      	ldrh	r2, [r7, #6]
 800dbbc:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    huart->TxXferCount = Size;
 800dbc0:	68fb      	ldr	r3, [r7, #12]
 800dbc2:	88fa      	ldrh	r2, [r7, #6]
 800dbc4:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800dbc8:	68fb      	ldr	r3, [r7, #12]
 800dbca:	689b      	ldr	r3, [r3, #8]
 800dbcc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800dbd0:	d108      	bne.n	800dbe4 <HAL_UART_Transmit+0x7a>
 800dbd2:	68fb      	ldr	r3, [r7, #12]
 800dbd4:	691b      	ldr	r3, [r3, #16]
 800dbd6:	2b00      	cmp	r3, #0
 800dbd8:	d104      	bne.n	800dbe4 <HAL_UART_Transmit+0x7a>
    {
      pdata8bits  = NULL;
 800dbda:	2300      	movs	r3, #0
 800dbdc:	617b      	str	r3, [r7, #20]
      pdata16bits = (const uint16_t *) pData;
 800dbde:	68bb      	ldr	r3, [r7, #8]
 800dbe0:	61bb      	str	r3, [r7, #24]
 800dbe2:	e003      	b.n	800dbec <HAL_UART_Transmit+0x82>
    }
    else
    {
      pdata8bits  = pData;
 800dbe4:	68bb      	ldr	r3, [r7, #8]
 800dbe6:	617b      	str	r3, [r7, #20]
      pdata16bits = NULL;
 800dbe8:	2300      	movs	r3, #0
 800dbea:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 800dbec:	68fb      	ldr	r3, [r7, #12]
 800dbee:	2200      	movs	r2, #0
 800dbf0:	675a      	str	r2, [r3, #116]	; 0x74

    while (huart->TxXferCount > 0U)
 800dbf2:	e02c      	b.n	800dc4e <HAL_UART_Transmit+0xe4>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800dbf4:	683b      	ldr	r3, [r7, #0]
 800dbf6:	9300      	str	r3, [sp, #0]
 800dbf8:	69fb      	ldr	r3, [r7, #28]
 800dbfa:	2200      	movs	r2, #0
 800dbfc:	2180      	movs	r1, #128	; 0x80
 800dbfe:	68f8      	ldr	r0, [r7, #12]
 800dc00:	f000 fc5e 	bl	800e4c0 <UART_WaitOnFlagUntilTimeout>
 800dc04:	4603      	mov	r3, r0
 800dc06:	2b00      	cmp	r3, #0
 800dc08:	d001      	beq.n	800dc0e <HAL_UART_Transmit+0xa4>
      {
        return HAL_TIMEOUT;
 800dc0a:	2303      	movs	r3, #3
 800dc0c:	e038      	b.n	800dc80 <HAL_UART_Transmit+0x116>
      }
      if (pdata8bits == NULL)
 800dc0e:	697b      	ldr	r3, [r7, #20]
 800dc10:	2b00      	cmp	r3, #0
 800dc12:	d10b      	bne.n	800dc2c <HAL_UART_Transmit+0xc2>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800dc14:	69bb      	ldr	r3, [r7, #24]
 800dc16:	881b      	ldrh	r3, [r3, #0]
 800dc18:	461a      	mov	r2, r3
 800dc1a:	68fb      	ldr	r3, [r7, #12]
 800dc1c:	681b      	ldr	r3, [r3, #0]
 800dc1e:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800dc22:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 800dc24:	69bb      	ldr	r3, [r7, #24]
 800dc26:	3302      	adds	r3, #2
 800dc28:	61bb      	str	r3, [r7, #24]
 800dc2a:	e007      	b.n	800dc3c <HAL_UART_Transmit+0xd2>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800dc2c:	697b      	ldr	r3, [r7, #20]
 800dc2e:	781a      	ldrb	r2, [r3, #0]
 800dc30:	68fb      	ldr	r3, [r7, #12]
 800dc32:	681b      	ldr	r3, [r3, #0]
 800dc34:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 800dc36:	697b      	ldr	r3, [r7, #20]
 800dc38:	3301      	adds	r3, #1
 800dc3a:	617b      	str	r3, [r7, #20]
      }
      huart->TxXferCount--;
 800dc3c:	68fb      	ldr	r3, [r7, #12]
 800dc3e:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800dc42:	b29b      	uxth	r3, r3
 800dc44:	3b01      	subs	r3, #1
 800dc46:	b29a      	uxth	r2, r3
 800dc48:	68fb      	ldr	r3, [r7, #12]
 800dc4a:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    while (huart->TxXferCount > 0U)
 800dc4e:	68fb      	ldr	r3, [r7, #12]
 800dc50:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800dc54:	b29b      	uxth	r3, r3
 800dc56:	2b00      	cmp	r3, #0
 800dc58:	d1cc      	bne.n	800dbf4 <HAL_UART_Transmit+0x8a>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800dc5a:	683b      	ldr	r3, [r7, #0]
 800dc5c:	9300      	str	r3, [sp, #0]
 800dc5e:	69fb      	ldr	r3, [r7, #28]
 800dc60:	2200      	movs	r2, #0
 800dc62:	2140      	movs	r1, #64	; 0x40
 800dc64:	68f8      	ldr	r0, [r7, #12]
 800dc66:	f000 fc2b 	bl	800e4c0 <UART_WaitOnFlagUntilTimeout>
 800dc6a:	4603      	mov	r3, r0
 800dc6c:	2b00      	cmp	r3, #0
 800dc6e:	d001      	beq.n	800dc74 <HAL_UART_Transmit+0x10a>
    {
      return HAL_TIMEOUT;
 800dc70:	2303      	movs	r3, #3
 800dc72:	e005      	b.n	800dc80 <HAL_UART_Transmit+0x116>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 800dc74:	68fb      	ldr	r3, [r7, #12]
 800dc76:	2220      	movs	r2, #32
 800dc78:	679a      	str	r2, [r3, #120]	; 0x78

    return HAL_OK;
 800dc7a:	2300      	movs	r3, #0
 800dc7c:	e000      	b.n	800dc80 <HAL_UART_Transmit+0x116>
  }
  else
  {
    return HAL_BUSY;
 800dc7e:	2302      	movs	r3, #2
  }
}
 800dc80:	4618      	mov	r0, r3
 800dc82:	3720      	adds	r7, #32
 800dc84:	46bd      	mov	sp, r7
 800dc86:	bd80      	pop	{r7, pc}

0800dc88 <HAL_UART_Receive>:
  * @param Size    Amount of data elements (u8 or u16) to be received.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800dc88:	b580      	push	{r7, lr}
 800dc8a:	b08a      	sub	sp, #40	; 0x28
 800dc8c:	af02      	add	r7, sp, #8
 800dc8e:	60f8      	str	r0, [r7, #12]
 800dc90:	60b9      	str	r1, [r7, #8]
 800dc92:	603b      	str	r3, [r7, #0]
 800dc94:	4613      	mov	r3, r2
 800dc96:	80fb      	strh	r3, [r7, #6]
  uint16_t *pdata16bits;
  uint16_t uhMask;
  uint32_t tickstart;

  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 800dc98:	68fb      	ldr	r3, [r7, #12]
 800dc9a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800dc9c:	2b20      	cmp	r3, #32
 800dc9e:	f040 80bb 	bne.w	800de18 <HAL_UART_Receive+0x190>
  {
    if ((pData == NULL) || (Size == 0U))
 800dca2:	68bb      	ldr	r3, [r7, #8]
 800dca4:	2b00      	cmp	r3, #0
 800dca6:	d002      	beq.n	800dcae <HAL_UART_Receive+0x26>
 800dca8:	88fb      	ldrh	r3, [r7, #6]
 800dcaa:	2b00      	cmp	r3, #0
 800dcac:	d101      	bne.n	800dcb2 <HAL_UART_Receive+0x2a>
    {
      return  HAL_ERROR;
 800dcae:	2301      	movs	r3, #1
 800dcb0:	e0b3      	b.n	800de1a <HAL_UART_Receive+0x192>
    }

    __HAL_LOCK(huart);
 800dcb2:	68fb      	ldr	r3, [r7, #12]
 800dcb4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dcb6:	2b01      	cmp	r3, #1
 800dcb8:	d101      	bne.n	800dcbe <HAL_UART_Receive+0x36>
 800dcba:	2302      	movs	r3, #2
 800dcbc:	e0ad      	b.n	800de1a <HAL_UART_Receive+0x192>
 800dcbe:	68fb      	ldr	r3, [r7, #12]
 800dcc0:	2201      	movs	r2, #1
 800dcc2:	675a      	str	r2, [r3, #116]	; 0x74

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800dcc4:	68fb      	ldr	r3, [r7, #12]
 800dcc6:	2200      	movs	r2, #0
 800dcc8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800dccc:	68fb      	ldr	r3, [r7, #12]
 800dcce:	2222      	movs	r2, #34	; 0x22
 800dcd0:	67da      	str	r2, [r3, #124]	; 0x7c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800dcd2:	68fb      	ldr	r3, [r7, #12]
 800dcd4:	2200      	movs	r2, #0
 800dcd6:	661a      	str	r2, [r3, #96]	; 0x60

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800dcd8:	f7f4 f84c 	bl	8001d74 <HAL_GetTick>
 800dcdc:	61f8      	str	r0, [r7, #28]

    huart->RxXferSize  = Size;
 800dcde:	68fb      	ldr	r3, [r7, #12]
 800dce0:	88fa      	ldrh	r2, [r7, #6]
 800dce2:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
    huart->RxXferCount = Size;
 800dce6:	68fb      	ldr	r3, [r7, #12]
 800dce8:	88fa      	ldrh	r2, [r7, #6]
 800dcea:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
 800dcee:	68fb      	ldr	r3, [r7, #12]
 800dcf0:	689b      	ldr	r3, [r3, #8]
 800dcf2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800dcf6:	d10e      	bne.n	800dd16 <HAL_UART_Receive+0x8e>
 800dcf8:	68fb      	ldr	r3, [r7, #12]
 800dcfa:	691b      	ldr	r3, [r3, #16]
 800dcfc:	2b00      	cmp	r3, #0
 800dcfe:	d105      	bne.n	800dd0c <HAL_UART_Receive+0x84>
 800dd00:	68fb      	ldr	r3, [r7, #12]
 800dd02:	f240 12ff 	movw	r2, #511	; 0x1ff
 800dd06:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800dd0a:	e02d      	b.n	800dd68 <HAL_UART_Receive+0xe0>
 800dd0c:	68fb      	ldr	r3, [r7, #12]
 800dd0e:	22ff      	movs	r2, #255	; 0xff
 800dd10:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800dd14:	e028      	b.n	800dd68 <HAL_UART_Receive+0xe0>
 800dd16:	68fb      	ldr	r3, [r7, #12]
 800dd18:	689b      	ldr	r3, [r3, #8]
 800dd1a:	2b00      	cmp	r3, #0
 800dd1c:	d10d      	bne.n	800dd3a <HAL_UART_Receive+0xb2>
 800dd1e:	68fb      	ldr	r3, [r7, #12]
 800dd20:	691b      	ldr	r3, [r3, #16]
 800dd22:	2b00      	cmp	r3, #0
 800dd24:	d104      	bne.n	800dd30 <HAL_UART_Receive+0xa8>
 800dd26:	68fb      	ldr	r3, [r7, #12]
 800dd28:	22ff      	movs	r2, #255	; 0xff
 800dd2a:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800dd2e:	e01b      	b.n	800dd68 <HAL_UART_Receive+0xe0>
 800dd30:	68fb      	ldr	r3, [r7, #12]
 800dd32:	227f      	movs	r2, #127	; 0x7f
 800dd34:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800dd38:	e016      	b.n	800dd68 <HAL_UART_Receive+0xe0>
 800dd3a:	68fb      	ldr	r3, [r7, #12]
 800dd3c:	689b      	ldr	r3, [r3, #8]
 800dd3e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800dd42:	d10d      	bne.n	800dd60 <HAL_UART_Receive+0xd8>
 800dd44:	68fb      	ldr	r3, [r7, #12]
 800dd46:	691b      	ldr	r3, [r3, #16]
 800dd48:	2b00      	cmp	r3, #0
 800dd4a:	d104      	bne.n	800dd56 <HAL_UART_Receive+0xce>
 800dd4c:	68fb      	ldr	r3, [r7, #12]
 800dd4e:	227f      	movs	r2, #127	; 0x7f
 800dd50:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800dd54:	e008      	b.n	800dd68 <HAL_UART_Receive+0xe0>
 800dd56:	68fb      	ldr	r3, [r7, #12]
 800dd58:	223f      	movs	r2, #63	; 0x3f
 800dd5a:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800dd5e:	e003      	b.n	800dd68 <HAL_UART_Receive+0xe0>
 800dd60:	68fb      	ldr	r3, [r7, #12]
 800dd62:	2200      	movs	r2, #0
 800dd64:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
    uhMask = huart->Mask;
 800dd68:	68fb      	ldr	r3, [r7, #12]
 800dd6a:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800dd6e:	827b      	strh	r3, [r7, #18]

    /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800dd70:	68fb      	ldr	r3, [r7, #12]
 800dd72:	689b      	ldr	r3, [r3, #8]
 800dd74:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800dd78:	d108      	bne.n	800dd8c <HAL_UART_Receive+0x104>
 800dd7a:	68fb      	ldr	r3, [r7, #12]
 800dd7c:	691b      	ldr	r3, [r3, #16]
 800dd7e:	2b00      	cmp	r3, #0
 800dd80:	d104      	bne.n	800dd8c <HAL_UART_Receive+0x104>
    {
      pdata8bits  = NULL;
 800dd82:	2300      	movs	r3, #0
 800dd84:	617b      	str	r3, [r7, #20]
      pdata16bits = (uint16_t *) pData;
 800dd86:	68bb      	ldr	r3, [r7, #8]
 800dd88:	61bb      	str	r3, [r7, #24]
 800dd8a:	e003      	b.n	800dd94 <HAL_UART_Receive+0x10c>
    }
    else
    {
      pdata8bits  = pData;
 800dd8c:	68bb      	ldr	r3, [r7, #8]
 800dd8e:	617b      	str	r3, [r7, #20]
      pdata16bits = NULL;
 800dd90:	2300      	movs	r3, #0
 800dd92:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 800dd94:	68fb      	ldr	r3, [r7, #12]
 800dd96:	2200      	movs	r2, #0
 800dd98:	675a      	str	r2, [r3, #116]	; 0x74

    /* as long as data have to be received */
    while (huart->RxXferCount > 0U)
 800dd9a:	e032      	b.n	800de02 <HAL_UART_Receive+0x17a>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 800dd9c:	683b      	ldr	r3, [r7, #0]
 800dd9e:	9300      	str	r3, [sp, #0]
 800dda0:	69fb      	ldr	r3, [r7, #28]
 800dda2:	2200      	movs	r2, #0
 800dda4:	2120      	movs	r1, #32
 800dda6:	68f8      	ldr	r0, [r7, #12]
 800dda8:	f000 fb8a 	bl	800e4c0 <UART_WaitOnFlagUntilTimeout>
 800ddac:	4603      	mov	r3, r0
 800ddae:	2b00      	cmp	r3, #0
 800ddb0:	d001      	beq.n	800ddb6 <HAL_UART_Receive+0x12e>
      {
        return HAL_TIMEOUT;
 800ddb2:	2303      	movs	r3, #3
 800ddb4:	e031      	b.n	800de1a <HAL_UART_Receive+0x192>
      }
      if (pdata8bits == NULL)
 800ddb6:	697b      	ldr	r3, [r7, #20]
 800ddb8:	2b00      	cmp	r3, #0
 800ddba:	d10c      	bne.n	800ddd6 <HAL_UART_Receive+0x14e>
      {
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 800ddbc:	68fb      	ldr	r3, [r7, #12]
 800ddbe:	681b      	ldr	r3, [r3, #0]
 800ddc0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ddc2:	b29a      	uxth	r2, r3
 800ddc4:	8a7b      	ldrh	r3, [r7, #18]
 800ddc6:	4013      	ands	r3, r2
 800ddc8:	b29a      	uxth	r2, r3
 800ddca:	69bb      	ldr	r3, [r7, #24]
 800ddcc:	801a      	strh	r2, [r3, #0]
        pdata16bits++;
 800ddce:	69bb      	ldr	r3, [r7, #24]
 800ddd0:	3302      	adds	r3, #2
 800ddd2:	61bb      	str	r3, [r7, #24]
 800ddd4:	e00c      	b.n	800ddf0 <HAL_UART_Receive+0x168>
      }
      else
      {
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 800ddd6:	68fb      	ldr	r3, [r7, #12]
 800ddd8:	681b      	ldr	r3, [r3, #0]
 800ddda:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800dddc:	b2da      	uxtb	r2, r3
 800ddde:	8a7b      	ldrh	r3, [r7, #18]
 800dde0:	b2db      	uxtb	r3, r3
 800dde2:	4013      	ands	r3, r2
 800dde4:	b2da      	uxtb	r2, r3
 800dde6:	697b      	ldr	r3, [r7, #20]
 800dde8:	701a      	strb	r2, [r3, #0]
        pdata8bits++;
 800ddea:	697b      	ldr	r3, [r7, #20]
 800ddec:	3301      	adds	r3, #1
 800ddee:	617b      	str	r3, [r7, #20]
      }
      huart->RxXferCount--;
 800ddf0:	68fb      	ldr	r3, [r7, #12]
 800ddf2:	f8b3 305a 	ldrh.w	r3, [r3, #90]	; 0x5a
 800ddf6:	b29b      	uxth	r3, r3
 800ddf8:	3b01      	subs	r3, #1
 800ddfa:	b29a      	uxth	r2, r3
 800ddfc:	68fb      	ldr	r3, [r7, #12]
 800ddfe:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
    while (huart->RxXferCount > 0U)
 800de02:	68fb      	ldr	r3, [r7, #12]
 800de04:	f8b3 305a 	ldrh.w	r3, [r3, #90]	; 0x5a
 800de08:	b29b      	uxth	r3, r3
 800de0a:	2b00      	cmp	r3, #0
 800de0c:	d1c6      	bne.n	800dd9c <HAL_UART_Receive+0x114>
    }

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
 800de0e:	68fb      	ldr	r3, [r7, #12]
 800de10:	2220      	movs	r2, #32
 800de12:	67da      	str	r2, [r3, #124]	; 0x7c

    return HAL_OK;
 800de14:	2300      	movs	r3, #0
 800de16:	e000      	b.n	800de1a <HAL_UART_Receive+0x192>
  }
  else
  {
    return HAL_BUSY;
 800de18:	2302      	movs	r3, #2
  }
}
 800de1a:	4618      	mov	r0, r3
 800de1c:	3720      	adds	r7, #32
 800de1e:	46bd      	mov	sp, r7
 800de20:	bd80      	pop	{r7, pc}
	...

0800de24 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 800de24:	b580      	push	{r7, lr}
 800de26:	b088      	sub	sp, #32
 800de28:	af00      	add	r7, sp, #0
 800de2a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 800de2c:	2300      	movs	r3, #0
 800de2e:	613b      	str	r3, [r7, #16]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800de30:	687b      	ldr	r3, [r7, #4]
 800de32:	689a      	ldr	r2, [r3, #8]
 800de34:	687b      	ldr	r3, [r7, #4]
 800de36:	691b      	ldr	r3, [r3, #16]
 800de38:	431a      	orrs	r2, r3
 800de3a:	687b      	ldr	r3, [r7, #4]
 800de3c:	695b      	ldr	r3, [r3, #20]
 800de3e:	431a      	orrs	r2, r3
 800de40:	687b      	ldr	r3, [r7, #4]
 800de42:	69db      	ldr	r3, [r3, #28]
 800de44:	4313      	orrs	r3, r2
 800de46:	61bb      	str	r3, [r7, #24]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800de48:	687b      	ldr	r3, [r7, #4]
 800de4a:	681b      	ldr	r3, [r3, #0]
 800de4c:	681a      	ldr	r2, [r3, #0]
 800de4e:	4ba6      	ldr	r3, [pc, #664]	; (800e0e8 <UART_SetConfig+0x2c4>)
 800de50:	4013      	ands	r3, r2
 800de52:	687a      	ldr	r2, [r7, #4]
 800de54:	6812      	ldr	r2, [r2, #0]
 800de56:	69b9      	ldr	r1, [r7, #24]
 800de58:	430b      	orrs	r3, r1
 800de5a:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800de5c:	687b      	ldr	r3, [r7, #4]
 800de5e:	681b      	ldr	r3, [r3, #0]
 800de60:	685b      	ldr	r3, [r3, #4]
 800de62:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 800de66:	687b      	ldr	r3, [r7, #4]
 800de68:	68da      	ldr	r2, [r3, #12]
 800de6a:	687b      	ldr	r3, [r7, #4]
 800de6c:	681b      	ldr	r3, [r3, #0]
 800de6e:	430a      	orrs	r2, r1
 800de70:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800de72:	687b      	ldr	r3, [r7, #4]
 800de74:	699b      	ldr	r3, [r3, #24]
 800de76:	61bb      	str	r3, [r7, #24]

  tmpreg |= huart->Init.OneBitSampling;
 800de78:	687b      	ldr	r3, [r7, #4]
 800de7a:	6a1b      	ldr	r3, [r3, #32]
 800de7c:	69ba      	ldr	r2, [r7, #24]
 800de7e:	4313      	orrs	r3, r2
 800de80:	61bb      	str	r3, [r7, #24]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800de82:	687b      	ldr	r3, [r7, #4]
 800de84:	681b      	ldr	r3, [r3, #0]
 800de86:	689b      	ldr	r3, [r3, #8]
 800de88:	f423 6130 	bic.w	r1, r3, #2816	; 0xb00
 800de8c:	687b      	ldr	r3, [r7, #4]
 800de8e:	681b      	ldr	r3, [r3, #0]
 800de90:	69ba      	ldr	r2, [r7, #24]
 800de92:	430a      	orrs	r2, r1
 800de94:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800de96:	687b      	ldr	r3, [r7, #4]
 800de98:	681b      	ldr	r3, [r3, #0]
 800de9a:	4a94      	ldr	r2, [pc, #592]	; (800e0ec <UART_SetConfig+0x2c8>)
 800de9c:	4293      	cmp	r3, r2
 800de9e:	d120      	bne.n	800dee2 <UART_SetConfig+0xbe>
 800dea0:	4b93      	ldr	r3, [pc, #588]	; (800e0f0 <UART_SetConfig+0x2cc>)
 800dea2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800dea6:	f003 0303 	and.w	r3, r3, #3
 800deaa:	2b03      	cmp	r3, #3
 800deac:	d816      	bhi.n	800dedc <UART_SetConfig+0xb8>
 800deae:	a201      	add	r2, pc, #4	; (adr r2, 800deb4 <UART_SetConfig+0x90>)
 800deb0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800deb4:	0800dec5 	.word	0x0800dec5
 800deb8:	0800ded1 	.word	0x0800ded1
 800debc:	0800decb 	.word	0x0800decb
 800dec0:	0800ded7 	.word	0x0800ded7
 800dec4:	2301      	movs	r3, #1
 800dec6:	60fb      	str	r3, [r7, #12]
 800dec8:	e150      	b.n	800e16c <UART_SetConfig+0x348>
 800deca:	2302      	movs	r3, #2
 800decc:	60fb      	str	r3, [r7, #12]
 800dece:	e14d      	b.n	800e16c <UART_SetConfig+0x348>
 800ded0:	2304      	movs	r3, #4
 800ded2:	60fb      	str	r3, [r7, #12]
 800ded4:	e14a      	b.n	800e16c <UART_SetConfig+0x348>
 800ded6:	2308      	movs	r3, #8
 800ded8:	60fb      	str	r3, [r7, #12]
 800deda:	e147      	b.n	800e16c <UART_SetConfig+0x348>
 800dedc:	2310      	movs	r3, #16
 800dede:	60fb      	str	r3, [r7, #12]
 800dee0:	e144      	b.n	800e16c <UART_SetConfig+0x348>
 800dee2:	687b      	ldr	r3, [r7, #4]
 800dee4:	681b      	ldr	r3, [r3, #0]
 800dee6:	4a83      	ldr	r2, [pc, #524]	; (800e0f4 <UART_SetConfig+0x2d0>)
 800dee8:	4293      	cmp	r3, r2
 800deea:	d132      	bne.n	800df52 <UART_SetConfig+0x12e>
 800deec:	4b80      	ldr	r3, [pc, #512]	; (800e0f0 <UART_SetConfig+0x2cc>)
 800deee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800def2:	f003 030c 	and.w	r3, r3, #12
 800def6:	2b0c      	cmp	r3, #12
 800def8:	d828      	bhi.n	800df4c <UART_SetConfig+0x128>
 800defa:	a201      	add	r2, pc, #4	; (adr r2, 800df00 <UART_SetConfig+0xdc>)
 800defc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800df00:	0800df35 	.word	0x0800df35
 800df04:	0800df4d 	.word	0x0800df4d
 800df08:	0800df4d 	.word	0x0800df4d
 800df0c:	0800df4d 	.word	0x0800df4d
 800df10:	0800df41 	.word	0x0800df41
 800df14:	0800df4d 	.word	0x0800df4d
 800df18:	0800df4d 	.word	0x0800df4d
 800df1c:	0800df4d 	.word	0x0800df4d
 800df20:	0800df3b 	.word	0x0800df3b
 800df24:	0800df4d 	.word	0x0800df4d
 800df28:	0800df4d 	.word	0x0800df4d
 800df2c:	0800df4d 	.word	0x0800df4d
 800df30:	0800df47 	.word	0x0800df47
 800df34:	2300      	movs	r3, #0
 800df36:	60fb      	str	r3, [r7, #12]
 800df38:	e118      	b.n	800e16c <UART_SetConfig+0x348>
 800df3a:	2302      	movs	r3, #2
 800df3c:	60fb      	str	r3, [r7, #12]
 800df3e:	e115      	b.n	800e16c <UART_SetConfig+0x348>
 800df40:	2304      	movs	r3, #4
 800df42:	60fb      	str	r3, [r7, #12]
 800df44:	e112      	b.n	800e16c <UART_SetConfig+0x348>
 800df46:	2308      	movs	r3, #8
 800df48:	60fb      	str	r3, [r7, #12]
 800df4a:	e10f      	b.n	800e16c <UART_SetConfig+0x348>
 800df4c:	2310      	movs	r3, #16
 800df4e:	60fb      	str	r3, [r7, #12]
 800df50:	e10c      	b.n	800e16c <UART_SetConfig+0x348>
 800df52:	687b      	ldr	r3, [r7, #4]
 800df54:	681b      	ldr	r3, [r3, #0]
 800df56:	4a68      	ldr	r2, [pc, #416]	; (800e0f8 <UART_SetConfig+0x2d4>)
 800df58:	4293      	cmp	r3, r2
 800df5a:	d120      	bne.n	800df9e <UART_SetConfig+0x17a>
 800df5c:	4b64      	ldr	r3, [pc, #400]	; (800e0f0 <UART_SetConfig+0x2cc>)
 800df5e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800df62:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800df66:	2b30      	cmp	r3, #48	; 0x30
 800df68:	d013      	beq.n	800df92 <UART_SetConfig+0x16e>
 800df6a:	2b30      	cmp	r3, #48	; 0x30
 800df6c:	d814      	bhi.n	800df98 <UART_SetConfig+0x174>
 800df6e:	2b20      	cmp	r3, #32
 800df70:	d009      	beq.n	800df86 <UART_SetConfig+0x162>
 800df72:	2b20      	cmp	r3, #32
 800df74:	d810      	bhi.n	800df98 <UART_SetConfig+0x174>
 800df76:	2b00      	cmp	r3, #0
 800df78:	d002      	beq.n	800df80 <UART_SetConfig+0x15c>
 800df7a:	2b10      	cmp	r3, #16
 800df7c:	d006      	beq.n	800df8c <UART_SetConfig+0x168>
 800df7e:	e00b      	b.n	800df98 <UART_SetConfig+0x174>
 800df80:	2300      	movs	r3, #0
 800df82:	60fb      	str	r3, [r7, #12]
 800df84:	e0f2      	b.n	800e16c <UART_SetConfig+0x348>
 800df86:	2302      	movs	r3, #2
 800df88:	60fb      	str	r3, [r7, #12]
 800df8a:	e0ef      	b.n	800e16c <UART_SetConfig+0x348>
 800df8c:	2304      	movs	r3, #4
 800df8e:	60fb      	str	r3, [r7, #12]
 800df90:	e0ec      	b.n	800e16c <UART_SetConfig+0x348>
 800df92:	2308      	movs	r3, #8
 800df94:	60fb      	str	r3, [r7, #12]
 800df96:	e0e9      	b.n	800e16c <UART_SetConfig+0x348>
 800df98:	2310      	movs	r3, #16
 800df9a:	60fb      	str	r3, [r7, #12]
 800df9c:	e0e6      	b.n	800e16c <UART_SetConfig+0x348>
 800df9e:	687b      	ldr	r3, [r7, #4]
 800dfa0:	681b      	ldr	r3, [r3, #0]
 800dfa2:	4a56      	ldr	r2, [pc, #344]	; (800e0fc <UART_SetConfig+0x2d8>)
 800dfa4:	4293      	cmp	r3, r2
 800dfa6:	d120      	bne.n	800dfea <UART_SetConfig+0x1c6>
 800dfa8:	4b51      	ldr	r3, [pc, #324]	; (800e0f0 <UART_SetConfig+0x2cc>)
 800dfaa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800dfae:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800dfb2:	2bc0      	cmp	r3, #192	; 0xc0
 800dfb4:	d013      	beq.n	800dfde <UART_SetConfig+0x1ba>
 800dfb6:	2bc0      	cmp	r3, #192	; 0xc0
 800dfb8:	d814      	bhi.n	800dfe4 <UART_SetConfig+0x1c0>
 800dfba:	2b80      	cmp	r3, #128	; 0x80
 800dfbc:	d009      	beq.n	800dfd2 <UART_SetConfig+0x1ae>
 800dfbe:	2b80      	cmp	r3, #128	; 0x80
 800dfc0:	d810      	bhi.n	800dfe4 <UART_SetConfig+0x1c0>
 800dfc2:	2b00      	cmp	r3, #0
 800dfc4:	d002      	beq.n	800dfcc <UART_SetConfig+0x1a8>
 800dfc6:	2b40      	cmp	r3, #64	; 0x40
 800dfc8:	d006      	beq.n	800dfd8 <UART_SetConfig+0x1b4>
 800dfca:	e00b      	b.n	800dfe4 <UART_SetConfig+0x1c0>
 800dfcc:	2300      	movs	r3, #0
 800dfce:	60fb      	str	r3, [r7, #12]
 800dfd0:	e0cc      	b.n	800e16c <UART_SetConfig+0x348>
 800dfd2:	2302      	movs	r3, #2
 800dfd4:	60fb      	str	r3, [r7, #12]
 800dfd6:	e0c9      	b.n	800e16c <UART_SetConfig+0x348>
 800dfd8:	2304      	movs	r3, #4
 800dfda:	60fb      	str	r3, [r7, #12]
 800dfdc:	e0c6      	b.n	800e16c <UART_SetConfig+0x348>
 800dfde:	2308      	movs	r3, #8
 800dfe0:	60fb      	str	r3, [r7, #12]
 800dfe2:	e0c3      	b.n	800e16c <UART_SetConfig+0x348>
 800dfe4:	2310      	movs	r3, #16
 800dfe6:	60fb      	str	r3, [r7, #12]
 800dfe8:	e0c0      	b.n	800e16c <UART_SetConfig+0x348>
 800dfea:	687b      	ldr	r3, [r7, #4]
 800dfec:	681b      	ldr	r3, [r3, #0]
 800dfee:	4a44      	ldr	r2, [pc, #272]	; (800e100 <UART_SetConfig+0x2dc>)
 800dff0:	4293      	cmp	r3, r2
 800dff2:	d125      	bne.n	800e040 <UART_SetConfig+0x21c>
 800dff4:	4b3e      	ldr	r3, [pc, #248]	; (800e0f0 <UART_SetConfig+0x2cc>)
 800dff6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800dffa:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800dffe:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800e002:	d017      	beq.n	800e034 <UART_SetConfig+0x210>
 800e004:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800e008:	d817      	bhi.n	800e03a <UART_SetConfig+0x216>
 800e00a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800e00e:	d00b      	beq.n	800e028 <UART_SetConfig+0x204>
 800e010:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800e014:	d811      	bhi.n	800e03a <UART_SetConfig+0x216>
 800e016:	2b00      	cmp	r3, #0
 800e018:	d003      	beq.n	800e022 <UART_SetConfig+0x1fe>
 800e01a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800e01e:	d006      	beq.n	800e02e <UART_SetConfig+0x20a>
 800e020:	e00b      	b.n	800e03a <UART_SetConfig+0x216>
 800e022:	2300      	movs	r3, #0
 800e024:	60fb      	str	r3, [r7, #12]
 800e026:	e0a1      	b.n	800e16c <UART_SetConfig+0x348>
 800e028:	2302      	movs	r3, #2
 800e02a:	60fb      	str	r3, [r7, #12]
 800e02c:	e09e      	b.n	800e16c <UART_SetConfig+0x348>
 800e02e:	2304      	movs	r3, #4
 800e030:	60fb      	str	r3, [r7, #12]
 800e032:	e09b      	b.n	800e16c <UART_SetConfig+0x348>
 800e034:	2308      	movs	r3, #8
 800e036:	60fb      	str	r3, [r7, #12]
 800e038:	e098      	b.n	800e16c <UART_SetConfig+0x348>
 800e03a:	2310      	movs	r3, #16
 800e03c:	60fb      	str	r3, [r7, #12]
 800e03e:	e095      	b.n	800e16c <UART_SetConfig+0x348>
 800e040:	687b      	ldr	r3, [r7, #4]
 800e042:	681b      	ldr	r3, [r3, #0]
 800e044:	4a2f      	ldr	r2, [pc, #188]	; (800e104 <UART_SetConfig+0x2e0>)
 800e046:	4293      	cmp	r3, r2
 800e048:	d125      	bne.n	800e096 <UART_SetConfig+0x272>
 800e04a:	4b29      	ldr	r3, [pc, #164]	; (800e0f0 <UART_SetConfig+0x2cc>)
 800e04c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e050:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800e054:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800e058:	d017      	beq.n	800e08a <UART_SetConfig+0x266>
 800e05a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800e05e:	d817      	bhi.n	800e090 <UART_SetConfig+0x26c>
 800e060:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800e064:	d00b      	beq.n	800e07e <UART_SetConfig+0x25a>
 800e066:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800e06a:	d811      	bhi.n	800e090 <UART_SetConfig+0x26c>
 800e06c:	2b00      	cmp	r3, #0
 800e06e:	d003      	beq.n	800e078 <UART_SetConfig+0x254>
 800e070:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800e074:	d006      	beq.n	800e084 <UART_SetConfig+0x260>
 800e076:	e00b      	b.n	800e090 <UART_SetConfig+0x26c>
 800e078:	2301      	movs	r3, #1
 800e07a:	60fb      	str	r3, [r7, #12]
 800e07c:	e076      	b.n	800e16c <UART_SetConfig+0x348>
 800e07e:	2302      	movs	r3, #2
 800e080:	60fb      	str	r3, [r7, #12]
 800e082:	e073      	b.n	800e16c <UART_SetConfig+0x348>
 800e084:	2304      	movs	r3, #4
 800e086:	60fb      	str	r3, [r7, #12]
 800e088:	e070      	b.n	800e16c <UART_SetConfig+0x348>
 800e08a:	2308      	movs	r3, #8
 800e08c:	60fb      	str	r3, [r7, #12]
 800e08e:	e06d      	b.n	800e16c <UART_SetConfig+0x348>
 800e090:	2310      	movs	r3, #16
 800e092:	60fb      	str	r3, [r7, #12]
 800e094:	e06a      	b.n	800e16c <UART_SetConfig+0x348>
 800e096:	687b      	ldr	r3, [r7, #4]
 800e098:	681b      	ldr	r3, [r3, #0]
 800e09a:	4a1b      	ldr	r2, [pc, #108]	; (800e108 <UART_SetConfig+0x2e4>)
 800e09c:	4293      	cmp	r3, r2
 800e09e:	d138      	bne.n	800e112 <UART_SetConfig+0x2ee>
 800e0a0:	4b13      	ldr	r3, [pc, #76]	; (800e0f0 <UART_SetConfig+0x2cc>)
 800e0a2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e0a6:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 800e0aa:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800e0ae:	d017      	beq.n	800e0e0 <UART_SetConfig+0x2bc>
 800e0b0:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800e0b4:	d82a      	bhi.n	800e10c <UART_SetConfig+0x2e8>
 800e0b6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800e0ba:	d00b      	beq.n	800e0d4 <UART_SetConfig+0x2b0>
 800e0bc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800e0c0:	d824      	bhi.n	800e10c <UART_SetConfig+0x2e8>
 800e0c2:	2b00      	cmp	r3, #0
 800e0c4:	d003      	beq.n	800e0ce <UART_SetConfig+0x2aa>
 800e0c6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800e0ca:	d006      	beq.n	800e0da <UART_SetConfig+0x2b6>
 800e0cc:	e01e      	b.n	800e10c <UART_SetConfig+0x2e8>
 800e0ce:	2300      	movs	r3, #0
 800e0d0:	60fb      	str	r3, [r7, #12]
 800e0d2:	e04b      	b.n	800e16c <UART_SetConfig+0x348>
 800e0d4:	2302      	movs	r3, #2
 800e0d6:	60fb      	str	r3, [r7, #12]
 800e0d8:	e048      	b.n	800e16c <UART_SetConfig+0x348>
 800e0da:	2304      	movs	r3, #4
 800e0dc:	60fb      	str	r3, [r7, #12]
 800e0de:	e045      	b.n	800e16c <UART_SetConfig+0x348>
 800e0e0:	2308      	movs	r3, #8
 800e0e2:	60fb      	str	r3, [r7, #12]
 800e0e4:	e042      	b.n	800e16c <UART_SetConfig+0x348>
 800e0e6:	bf00      	nop
 800e0e8:	efff69f3 	.word	0xefff69f3
 800e0ec:	40011000 	.word	0x40011000
 800e0f0:	40023800 	.word	0x40023800
 800e0f4:	40004400 	.word	0x40004400
 800e0f8:	40004800 	.word	0x40004800
 800e0fc:	40004c00 	.word	0x40004c00
 800e100:	40005000 	.word	0x40005000
 800e104:	40011400 	.word	0x40011400
 800e108:	40007800 	.word	0x40007800
 800e10c:	2310      	movs	r3, #16
 800e10e:	60fb      	str	r3, [r7, #12]
 800e110:	e02c      	b.n	800e16c <UART_SetConfig+0x348>
 800e112:	687b      	ldr	r3, [r7, #4]
 800e114:	681b      	ldr	r3, [r3, #0]
 800e116:	4a72      	ldr	r2, [pc, #456]	; (800e2e0 <UART_SetConfig+0x4bc>)
 800e118:	4293      	cmp	r3, r2
 800e11a:	d125      	bne.n	800e168 <UART_SetConfig+0x344>
 800e11c:	4b71      	ldr	r3, [pc, #452]	; (800e2e4 <UART_SetConfig+0x4c0>)
 800e11e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e122:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800e126:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800e12a:	d017      	beq.n	800e15c <UART_SetConfig+0x338>
 800e12c:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800e130:	d817      	bhi.n	800e162 <UART_SetConfig+0x33e>
 800e132:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800e136:	d00b      	beq.n	800e150 <UART_SetConfig+0x32c>
 800e138:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800e13c:	d811      	bhi.n	800e162 <UART_SetConfig+0x33e>
 800e13e:	2b00      	cmp	r3, #0
 800e140:	d003      	beq.n	800e14a <UART_SetConfig+0x326>
 800e142:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800e146:	d006      	beq.n	800e156 <UART_SetConfig+0x332>
 800e148:	e00b      	b.n	800e162 <UART_SetConfig+0x33e>
 800e14a:	2300      	movs	r3, #0
 800e14c:	60fb      	str	r3, [r7, #12]
 800e14e:	e00d      	b.n	800e16c <UART_SetConfig+0x348>
 800e150:	2302      	movs	r3, #2
 800e152:	60fb      	str	r3, [r7, #12]
 800e154:	e00a      	b.n	800e16c <UART_SetConfig+0x348>
 800e156:	2304      	movs	r3, #4
 800e158:	60fb      	str	r3, [r7, #12]
 800e15a:	e007      	b.n	800e16c <UART_SetConfig+0x348>
 800e15c:	2308      	movs	r3, #8
 800e15e:	60fb      	str	r3, [r7, #12]
 800e160:	e004      	b.n	800e16c <UART_SetConfig+0x348>
 800e162:	2310      	movs	r3, #16
 800e164:	60fb      	str	r3, [r7, #12]
 800e166:	e001      	b.n	800e16c <UART_SetConfig+0x348>
 800e168:	2310      	movs	r3, #16
 800e16a:	60fb      	str	r3, [r7, #12]

  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800e16c:	687b      	ldr	r3, [r7, #4]
 800e16e:	69db      	ldr	r3, [r3, #28]
 800e170:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800e174:	d15b      	bne.n	800e22e <UART_SetConfig+0x40a>
 800e176:	68fb      	ldr	r3, [r7, #12]
 800e178:	2b08      	cmp	r3, #8
 800e17a:	d828      	bhi.n	800e1ce <UART_SetConfig+0x3aa>
 800e17c:	a201      	add	r2, pc, #4	; (adr r2, 800e184 <UART_SetConfig+0x360>)
 800e17e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e182:	bf00      	nop
 800e184:	0800e1a9 	.word	0x0800e1a9
 800e188:	0800e1b1 	.word	0x0800e1b1
 800e18c:	0800e1b9 	.word	0x0800e1b9
 800e190:	0800e1cf 	.word	0x0800e1cf
 800e194:	0800e1bf 	.word	0x0800e1bf
 800e198:	0800e1cf 	.word	0x0800e1cf
 800e19c:	0800e1cf 	.word	0x0800e1cf
 800e1a0:	0800e1cf 	.word	0x0800e1cf
 800e1a4:	0800e1c7 	.word	0x0800e1c7
  {
    switch (clocksource)
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800e1a8:	f7ff f84e 	bl	800d248 <HAL_RCC_GetPCLK1Freq>
 800e1ac:	6178      	str	r0, [r7, #20]
        break;
 800e1ae:	e013      	b.n	800e1d8 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800e1b0:	f7ff f85e 	bl	800d270 <HAL_RCC_GetPCLK2Freq>
 800e1b4:	6178      	str	r0, [r7, #20]
        break;
 800e1b6:	e00f      	b.n	800e1d8 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 800e1b8:	4b4b      	ldr	r3, [pc, #300]	; (800e2e8 <UART_SetConfig+0x4c4>)
 800e1ba:	617b      	str	r3, [r7, #20]
        break;
 800e1bc:	e00c      	b.n	800e1d8 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800e1be:	f7fe ff81 	bl	800d0c4 <HAL_RCC_GetSysClockFreq>
 800e1c2:	6178      	str	r0, [r7, #20]
        break;
 800e1c4:	e008      	b.n	800e1d8 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800e1c6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800e1ca:	617b      	str	r3, [r7, #20]
        break;
 800e1cc:	e004      	b.n	800e1d8 <UART_SetConfig+0x3b4>
      default:
        pclk = 0U;
 800e1ce:	2300      	movs	r3, #0
 800e1d0:	617b      	str	r3, [r7, #20]
        ret = HAL_ERROR;
 800e1d2:	2301      	movs	r3, #1
 800e1d4:	613b      	str	r3, [r7, #16]
        break;
 800e1d6:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 800e1d8:	697b      	ldr	r3, [r7, #20]
 800e1da:	2b00      	cmp	r3, #0
 800e1dc:	d074      	beq.n	800e2c8 <UART_SetConfig+0x4a4>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 800e1de:	697b      	ldr	r3, [r7, #20]
 800e1e0:	005a      	lsls	r2, r3, #1
 800e1e2:	687b      	ldr	r3, [r7, #4]
 800e1e4:	685b      	ldr	r3, [r3, #4]
 800e1e6:	085b      	lsrs	r3, r3, #1
 800e1e8:	441a      	add	r2, r3
 800e1ea:	687b      	ldr	r3, [r7, #4]
 800e1ec:	685b      	ldr	r3, [r3, #4]
 800e1ee:	fbb2 f3f3 	udiv	r3, r2, r3
 800e1f2:	61fb      	str	r3, [r7, #28]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800e1f4:	69fb      	ldr	r3, [r7, #28]
 800e1f6:	2b0f      	cmp	r3, #15
 800e1f8:	d916      	bls.n	800e228 <UART_SetConfig+0x404>
 800e1fa:	69fb      	ldr	r3, [r7, #28]
 800e1fc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e200:	d212      	bcs.n	800e228 <UART_SetConfig+0x404>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800e202:	69fb      	ldr	r3, [r7, #28]
 800e204:	b29b      	uxth	r3, r3
 800e206:	f023 030f 	bic.w	r3, r3, #15
 800e20a:	817b      	strh	r3, [r7, #10]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800e20c:	69fb      	ldr	r3, [r7, #28]
 800e20e:	085b      	lsrs	r3, r3, #1
 800e210:	b29b      	uxth	r3, r3
 800e212:	f003 0307 	and.w	r3, r3, #7
 800e216:	b29a      	uxth	r2, r3
 800e218:	897b      	ldrh	r3, [r7, #10]
 800e21a:	4313      	orrs	r3, r2
 800e21c:	817b      	strh	r3, [r7, #10]
        huart->Instance->BRR = brrtemp;
 800e21e:	687b      	ldr	r3, [r7, #4]
 800e220:	681b      	ldr	r3, [r3, #0]
 800e222:	897a      	ldrh	r2, [r7, #10]
 800e224:	60da      	str	r2, [r3, #12]
 800e226:	e04f      	b.n	800e2c8 <UART_SetConfig+0x4a4>
      }
      else
      {
        ret = HAL_ERROR;
 800e228:	2301      	movs	r3, #1
 800e22a:	613b      	str	r3, [r7, #16]
 800e22c:	e04c      	b.n	800e2c8 <UART_SetConfig+0x4a4>
 800e22e:	68fb      	ldr	r3, [r7, #12]
 800e230:	2b08      	cmp	r3, #8
 800e232:	d828      	bhi.n	800e286 <UART_SetConfig+0x462>
 800e234:	a201      	add	r2, pc, #4	; (adr r2, 800e23c <UART_SetConfig+0x418>)
 800e236:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e23a:	bf00      	nop
 800e23c:	0800e261 	.word	0x0800e261
 800e240:	0800e269 	.word	0x0800e269
 800e244:	0800e271 	.word	0x0800e271
 800e248:	0800e287 	.word	0x0800e287
 800e24c:	0800e277 	.word	0x0800e277
 800e250:	0800e287 	.word	0x0800e287
 800e254:	0800e287 	.word	0x0800e287
 800e258:	0800e287 	.word	0x0800e287
 800e25c:	0800e27f 	.word	0x0800e27f
  else
  {
    switch (clocksource)
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800e260:	f7fe fff2 	bl	800d248 <HAL_RCC_GetPCLK1Freq>
 800e264:	6178      	str	r0, [r7, #20]
        break;
 800e266:	e013      	b.n	800e290 <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800e268:	f7ff f802 	bl	800d270 <HAL_RCC_GetPCLK2Freq>
 800e26c:	6178      	str	r0, [r7, #20]
        break;
 800e26e:	e00f      	b.n	800e290 <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 800e270:	4b1d      	ldr	r3, [pc, #116]	; (800e2e8 <UART_SetConfig+0x4c4>)
 800e272:	617b      	str	r3, [r7, #20]
        break;
 800e274:	e00c      	b.n	800e290 <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800e276:	f7fe ff25 	bl	800d0c4 <HAL_RCC_GetSysClockFreq>
 800e27a:	6178      	str	r0, [r7, #20]
        break;
 800e27c:	e008      	b.n	800e290 <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800e27e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800e282:	617b      	str	r3, [r7, #20]
        break;
 800e284:	e004      	b.n	800e290 <UART_SetConfig+0x46c>
      default:
        pclk = 0U;
 800e286:	2300      	movs	r3, #0
 800e288:	617b      	str	r3, [r7, #20]
        ret = HAL_ERROR;
 800e28a:	2301      	movs	r3, #1
 800e28c:	613b      	str	r3, [r7, #16]
        break;
 800e28e:	bf00      	nop
    }

    if (pclk != 0U)
 800e290:	697b      	ldr	r3, [r7, #20]
 800e292:	2b00      	cmp	r3, #0
 800e294:	d018      	beq.n	800e2c8 <UART_SetConfig+0x4a4>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800e296:	687b      	ldr	r3, [r7, #4]
 800e298:	685b      	ldr	r3, [r3, #4]
 800e29a:	085a      	lsrs	r2, r3, #1
 800e29c:	697b      	ldr	r3, [r7, #20]
 800e29e:	441a      	add	r2, r3
 800e2a0:	687b      	ldr	r3, [r7, #4]
 800e2a2:	685b      	ldr	r3, [r3, #4]
 800e2a4:	fbb2 f3f3 	udiv	r3, r2, r3
 800e2a8:	61fb      	str	r3, [r7, #28]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800e2aa:	69fb      	ldr	r3, [r7, #28]
 800e2ac:	2b0f      	cmp	r3, #15
 800e2ae:	d909      	bls.n	800e2c4 <UART_SetConfig+0x4a0>
 800e2b0:	69fb      	ldr	r3, [r7, #28]
 800e2b2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800e2b6:	d205      	bcs.n	800e2c4 <UART_SetConfig+0x4a0>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 800e2b8:	69fb      	ldr	r3, [r7, #28]
 800e2ba:	b29a      	uxth	r2, r3
 800e2bc:	687b      	ldr	r3, [r7, #4]
 800e2be:	681b      	ldr	r3, [r3, #0]
 800e2c0:	60da      	str	r2, [r3, #12]
 800e2c2:	e001      	b.n	800e2c8 <UART_SetConfig+0x4a4>
      }
      else
      {
        ret = HAL_ERROR;
 800e2c4:	2301      	movs	r3, #1
 800e2c6:	613b      	str	r3, [r7, #16]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 800e2c8:	687b      	ldr	r3, [r7, #4]
 800e2ca:	2200      	movs	r2, #0
 800e2cc:	665a      	str	r2, [r3, #100]	; 0x64
  huart->TxISR = NULL;
 800e2ce:	687b      	ldr	r3, [r7, #4]
 800e2d0:	2200      	movs	r2, #0
 800e2d2:	669a      	str	r2, [r3, #104]	; 0x68

  return ret;
 800e2d4:	693b      	ldr	r3, [r7, #16]
}
 800e2d6:	4618      	mov	r0, r3
 800e2d8:	3720      	adds	r7, #32
 800e2da:	46bd      	mov	sp, r7
 800e2dc:	bd80      	pop	{r7, pc}
 800e2de:	bf00      	nop
 800e2e0:	40007c00 	.word	0x40007c00
 800e2e4:	40023800 	.word	0x40023800
 800e2e8:	00f42400 	.word	0x00f42400

0800e2ec <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 800e2ec:	b480      	push	{r7}
 800e2ee:	b083      	sub	sp, #12
 800e2f0:	af00      	add	r7, sp, #0
 800e2f2:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800e2f4:	687b      	ldr	r3, [r7, #4]
 800e2f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e2f8:	f003 0301 	and.w	r3, r3, #1
 800e2fc:	2b00      	cmp	r3, #0
 800e2fe:	d00a      	beq.n	800e316 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800e300:	687b      	ldr	r3, [r7, #4]
 800e302:	681b      	ldr	r3, [r3, #0]
 800e304:	685b      	ldr	r3, [r3, #4]
 800e306:	f423 3100 	bic.w	r1, r3, #131072	; 0x20000
 800e30a:	687b      	ldr	r3, [r7, #4]
 800e30c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e30e:	687b      	ldr	r3, [r7, #4]
 800e310:	681b      	ldr	r3, [r3, #0]
 800e312:	430a      	orrs	r2, r1
 800e314:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800e316:	687b      	ldr	r3, [r7, #4]
 800e318:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e31a:	f003 0302 	and.w	r3, r3, #2
 800e31e:	2b00      	cmp	r3, #0
 800e320:	d00a      	beq.n	800e338 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800e322:	687b      	ldr	r3, [r7, #4]
 800e324:	681b      	ldr	r3, [r3, #0]
 800e326:	685b      	ldr	r3, [r3, #4]
 800e328:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 800e32c:	687b      	ldr	r3, [r7, #4]
 800e32e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800e330:	687b      	ldr	r3, [r7, #4]
 800e332:	681b      	ldr	r3, [r3, #0]
 800e334:	430a      	orrs	r2, r1
 800e336:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800e338:	687b      	ldr	r3, [r7, #4]
 800e33a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e33c:	f003 0304 	and.w	r3, r3, #4
 800e340:	2b00      	cmp	r3, #0
 800e342:	d00a      	beq.n	800e35a <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800e344:	687b      	ldr	r3, [r7, #4]
 800e346:	681b      	ldr	r3, [r3, #0]
 800e348:	685b      	ldr	r3, [r3, #4]
 800e34a:	f423 2180 	bic.w	r1, r3, #262144	; 0x40000
 800e34e:	687b      	ldr	r3, [r7, #4]
 800e350:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800e352:	687b      	ldr	r3, [r7, #4]
 800e354:	681b      	ldr	r3, [r3, #0]
 800e356:	430a      	orrs	r2, r1
 800e358:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800e35a:	687b      	ldr	r3, [r7, #4]
 800e35c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e35e:	f003 0308 	and.w	r3, r3, #8
 800e362:	2b00      	cmp	r3, #0
 800e364:	d00a      	beq.n	800e37c <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800e366:	687b      	ldr	r3, [r7, #4]
 800e368:	681b      	ldr	r3, [r3, #0]
 800e36a:	685b      	ldr	r3, [r3, #4]
 800e36c:	f423 4100 	bic.w	r1, r3, #32768	; 0x8000
 800e370:	687b      	ldr	r3, [r7, #4]
 800e372:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800e374:	687b      	ldr	r3, [r7, #4]
 800e376:	681b      	ldr	r3, [r3, #0]
 800e378:	430a      	orrs	r2, r1
 800e37a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800e37c:	687b      	ldr	r3, [r7, #4]
 800e37e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e380:	f003 0310 	and.w	r3, r3, #16
 800e384:	2b00      	cmp	r3, #0
 800e386:	d00a      	beq.n	800e39e <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800e388:	687b      	ldr	r3, [r7, #4]
 800e38a:	681b      	ldr	r3, [r3, #0]
 800e38c:	689b      	ldr	r3, [r3, #8]
 800e38e:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 800e392:	687b      	ldr	r3, [r7, #4]
 800e394:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800e396:	687b      	ldr	r3, [r7, #4]
 800e398:	681b      	ldr	r3, [r3, #0]
 800e39a:	430a      	orrs	r2, r1
 800e39c:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800e39e:	687b      	ldr	r3, [r7, #4]
 800e3a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e3a2:	f003 0320 	and.w	r3, r3, #32
 800e3a6:	2b00      	cmp	r3, #0
 800e3a8:	d00a      	beq.n	800e3c0 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800e3aa:	687b      	ldr	r3, [r7, #4]
 800e3ac:	681b      	ldr	r3, [r3, #0]
 800e3ae:	689b      	ldr	r3, [r3, #8]
 800e3b0:	f423 5100 	bic.w	r1, r3, #8192	; 0x2000
 800e3b4:	687b      	ldr	r3, [r7, #4]
 800e3b6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800e3b8:	687b      	ldr	r3, [r7, #4]
 800e3ba:	681b      	ldr	r3, [r3, #0]
 800e3bc:	430a      	orrs	r2, r1
 800e3be:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800e3c0:	687b      	ldr	r3, [r7, #4]
 800e3c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e3c4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e3c8:	2b00      	cmp	r3, #0
 800e3ca:	d01a      	beq.n	800e402 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800e3cc:	687b      	ldr	r3, [r7, #4]
 800e3ce:	681b      	ldr	r3, [r3, #0]
 800e3d0:	685b      	ldr	r3, [r3, #4]
 800e3d2:	f423 1180 	bic.w	r1, r3, #1048576	; 0x100000
 800e3d6:	687b      	ldr	r3, [r7, #4]
 800e3d8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800e3da:	687b      	ldr	r3, [r7, #4]
 800e3dc:	681b      	ldr	r3, [r3, #0]
 800e3de:	430a      	orrs	r2, r1
 800e3e0:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800e3e2:	687b      	ldr	r3, [r7, #4]
 800e3e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e3e6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800e3ea:	d10a      	bne.n	800e402 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800e3ec:	687b      	ldr	r3, [r7, #4]
 800e3ee:	681b      	ldr	r3, [r3, #0]
 800e3f0:	685b      	ldr	r3, [r3, #4]
 800e3f2:	f423 01c0 	bic.w	r1, r3, #6291456	; 0x600000
 800e3f6:	687b      	ldr	r3, [r7, #4]
 800e3f8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800e3fa:	687b      	ldr	r3, [r7, #4]
 800e3fc:	681b      	ldr	r3, [r3, #0]
 800e3fe:	430a      	orrs	r2, r1
 800e400:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800e402:	687b      	ldr	r3, [r7, #4]
 800e404:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e406:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e40a:	2b00      	cmp	r3, #0
 800e40c:	d00a      	beq.n	800e424 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800e40e:	687b      	ldr	r3, [r7, #4]
 800e410:	681b      	ldr	r3, [r3, #0]
 800e412:	685b      	ldr	r3, [r3, #4]
 800e414:	f423 2100 	bic.w	r1, r3, #524288	; 0x80000
 800e418:	687b      	ldr	r3, [r7, #4]
 800e41a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800e41c:	687b      	ldr	r3, [r7, #4]
 800e41e:	681b      	ldr	r3, [r3, #0]
 800e420:	430a      	orrs	r2, r1
 800e422:	605a      	str	r2, [r3, #4]
  }
}
 800e424:	bf00      	nop
 800e426:	370c      	adds	r7, #12
 800e428:	46bd      	mov	sp, r7
 800e42a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e42e:	4770      	bx	lr

0800e430 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800e430:	b580      	push	{r7, lr}
 800e432:	b086      	sub	sp, #24
 800e434:	af02      	add	r7, sp, #8
 800e436:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800e438:	687b      	ldr	r3, [r7, #4]
 800e43a:	2200      	movs	r2, #0
 800e43c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 800e440:	f7f3 fc98 	bl	8001d74 <HAL_GetTick>
 800e444:	60f8      	str	r0, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800e446:	687b      	ldr	r3, [r7, #4]
 800e448:	681b      	ldr	r3, [r3, #0]
 800e44a:	681b      	ldr	r3, [r3, #0]
 800e44c:	f003 0308 	and.w	r3, r3, #8
 800e450:	2b08      	cmp	r3, #8
 800e452:	d10e      	bne.n	800e472 <UART_CheckIdleState+0x42>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800e454:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800e458:	9300      	str	r3, [sp, #0]
 800e45a:	68fb      	ldr	r3, [r7, #12]
 800e45c:	2200      	movs	r2, #0
 800e45e:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 800e462:	6878      	ldr	r0, [r7, #4]
 800e464:	f000 f82c 	bl	800e4c0 <UART_WaitOnFlagUntilTimeout>
 800e468:	4603      	mov	r3, r0
 800e46a:	2b00      	cmp	r3, #0
 800e46c:	d001      	beq.n	800e472 <UART_CheckIdleState+0x42>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800e46e:	2303      	movs	r3, #3
 800e470:	e022      	b.n	800e4b8 <UART_CheckIdleState+0x88>
    }
  }
#if defined(USART_ISR_REACK)

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800e472:	687b      	ldr	r3, [r7, #4]
 800e474:	681b      	ldr	r3, [r3, #0]
 800e476:	681b      	ldr	r3, [r3, #0]
 800e478:	f003 0304 	and.w	r3, r3, #4
 800e47c:	2b04      	cmp	r3, #4
 800e47e:	d10e      	bne.n	800e49e <UART_CheckIdleState+0x6e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800e480:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800e484:	9300      	str	r3, [sp, #0]
 800e486:	68fb      	ldr	r3, [r7, #12]
 800e488:	2200      	movs	r2, #0
 800e48a:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 800e48e:	6878      	ldr	r0, [r7, #4]
 800e490:	f000 f816 	bl	800e4c0 <UART_WaitOnFlagUntilTimeout>
 800e494:	4603      	mov	r3, r0
 800e496:	2b00      	cmp	r3, #0
 800e498:	d001      	beq.n	800e49e <UART_CheckIdleState+0x6e>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800e49a:	2303      	movs	r3, #3
 800e49c:	e00c      	b.n	800e4b8 <UART_CheckIdleState+0x88>
    }
  }
#endif

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 800e49e:	687b      	ldr	r3, [r7, #4]
 800e4a0:	2220      	movs	r2, #32
 800e4a2:	679a      	str	r2, [r3, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
 800e4a4:	687b      	ldr	r3, [r7, #4]
 800e4a6:	2220      	movs	r2, #32
 800e4a8:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800e4aa:	687b      	ldr	r3, [r7, #4]
 800e4ac:	2200      	movs	r2, #0
 800e4ae:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(huart);
 800e4b0:	687b      	ldr	r3, [r7, #4]
 800e4b2:	2200      	movs	r2, #0
 800e4b4:	675a      	str	r2, [r3, #116]	; 0x74

  return HAL_OK;
 800e4b6:	2300      	movs	r3, #0
}
 800e4b8:	4618      	mov	r0, r3
 800e4ba:	3710      	adds	r7, #16
 800e4bc:	46bd      	mov	sp, r7
 800e4be:	bd80      	pop	{r7, pc}

0800e4c0 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 800e4c0:	b580      	push	{r7, lr}
 800e4c2:	b09c      	sub	sp, #112	; 0x70
 800e4c4:	af00      	add	r7, sp, #0
 800e4c6:	60f8      	str	r0, [r7, #12]
 800e4c8:	60b9      	str	r1, [r7, #8]
 800e4ca:	607a      	str	r2, [r7, #4]
 800e4cc:	603b      	str	r3, [r7, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800e4ce:	e0a3      	b.n	800e618 <UART_WaitOnFlagUntilTimeout+0x158>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800e4d0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800e4d2:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e4d6:	f000 809f 	beq.w	800e618 <UART_WaitOnFlagUntilTimeout+0x158>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800e4da:	f7f3 fc4b 	bl	8001d74 <HAL_GetTick>
 800e4de:	4602      	mov	r2, r0
 800e4e0:	683b      	ldr	r3, [r7, #0]
 800e4e2:	1ad3      	subs	r3, r2, r3
 800e4e4:	6fba      	ldr	r2, [r7, #120]	; 0x78
 800e4e6:	429a      	cmp	r2, r3
 800e4e8:	d302      	bcc.n	800e4f0 <UART_WaitOnFlagUntilTimeout+0x30>
 800e4ea:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800e4ec:	2b00      	cmp	r3, #0
 800e4ee:	d13d      	bne.n	800e56c <UART_WaitOnFlagUntilTimeout+0xac>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800e4f0:	68fb      	ldr	r3, [r7, #12]
 800e4f2:	681b      	ldr	r3, [r3, #0]
 800e4f4:	62fb      	str	r3, [r7, #44]	; 0x2c
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e4f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e4f8:	e853 3f00 	ldrex	r3, [r3]
 800e4fc:	633b      	str	r3, [r7, #48]	; 0x30
   return(result);
 800e4fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e500:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800e504:	61bb      	str	r3, [r7, #24]
 800e506:	68fb      	ldr	r3, [r7, #12]
 800e508:	681b      	ldr	r3, [r3, #0]
 800e50a:	461a      	mov	r2, r3
 800e50c:	69bb      	ldr	r3, [r7, #24]
 800e50e:	623b      	str	r3, [r7, #32]
 800e510:	627a      	str	r2, [r7, #36]	; 0x24
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e512:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800e514:	6a3a      	ldr	r2, [r7, #32]
 800e516:	e841 2300 	strex	r3, r2, [r1]
 800e51a:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 800e51c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e51e:	2b00      	cmp	r3, #0
 800e520:	d1e6      	bne.n	800e4f0 <UART_WaitOnFlagUntilTimeout+0x30>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800e522:	68fb      	ldr	r3, [r7, #12]
 800e524:	681b      	ldr	r3, [r3, #0]
 800e526:	3308      	adds	r3, #8
 800e528:	643b      	str	r3, [r7, #64]	; 0x40
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e52a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e52c:	e853 3f00 	ldrex	r3, [r3]
 800e530:	647b      	str	r3, [r7, #68]	; 0x44
   return(result);
 800e532:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e534:	f023 0301 	bic.w	r3, r3, #1
 800e538:	61fb      	str	r3, [r7, #28]
 800e53a:	68fb      	ldr	r3, [r7, #12]
 800e53c:	681b      	ldr	r3, [r3, #0]
 800e53e:	3308      	adds	r3, #8
 800e540:	69fa      	ldr	r2, [r7, #28]
 800e542:	637a      	str	r2, [r7, #52]	; 0x34
 800e544:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e546:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800e548:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800e54a:	e841 2300 	strex	r3, r2, [r1]
 800e54e:	63fb      	str	r3, [r7, #60]	; 0x3c
   return(result);
 800e550:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e552:	2b00      	cmp	r3, #0
 800e554:	d1e5      	bne.n	800e522 <UART_WaitOnFlagUntilTimeout+0x62>

        huart->gState = HAL_UART_STATE_READY;
 800e556:	68fb      	ldr	r3, [r7, #12]
 800e558:	2220      	movs	r2, #32
 800e55a:	679a      	str	r2, [r3, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 800e55c:	68fb      	ldr	r3, [r7, #12]
 800e55e:	2220      	movs	r2, #32
 800e560:	67da      	str	r2, [r3, #124]	; 0x7c

        __HAL_UNLOCK(huart);
 800e562:	68fb      	ldr	r3, [r7, #12]
 800e564:	2200      	movs	r2, #0
 800e566:	675a      	str	r2, [r3, #116]	; 0x74

        return HAL_TIMEOUT;
 800e568:	2303      	movs	r3, #3
 800e56a:	e065      	b.n	800e638 <UART_WaitOnFlagUntilTimeout+0x178>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800e56c:	68fb      	ldr	r3, [r7, #12]
 800e56e:	681b      	ldr	r3, [r3, #0]
 800e570:	681b      	ldr	r3, [r3, #0]
 800e572:	f003 0304 	and.w	r3, r3, #4
 800e576:	2b00      	cmp	r3, #0
 800e578:	d04e      	beq.n	800e618 <UART_WaitOnFlagUntilTimeout+0x158>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800e57a:	68fb      	ldr	r3, [r7, #12]
 800e57c:	681b      	ldr	r3, [r3, #0]
 800e57e:	69db      	ldr	r3, [r3, #28]
 800e580:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800e584:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800e588:	d146      	bne.n	800e618 <UART_WaitOnFlagUntilTimeout+0x158>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800e58a:	68fb      	ldr	r3, [r7, #12]
 800e58c:	681b      	ldr	r3, [r3, #0]
 800e58e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800e592:	621a      	str	r2, [r3, #32]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800e594:	68fb      	ldr	r3, [r7, #12]
 800e596:	681b      	ldr	r3, [r3, #0]
 800e598:	657b      	str	r3, [r7, #84]	; 0x54
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e59a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e59c:	e853 3f00 	ldrex	r3, [r3]
 800e5a0:	65bb      	str	r3, [r7, #88]	; 0x58
   return(result);
 800e5a2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e5a4:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800e5a8:	613b      	str	r3, [r7, #16]
 800e5aa:	68fb      	ldr	r3, [r7, #12]
 800e5ac:	681b      	ldr	r3, [r3, #0]
 800e5ae:	461a      	mov	r2, r3
 800e5b0:	693b      	ldr	r3, [r7, #16]
 800e5b2:	64bb      	str	r3, [r7, #72]	; 0x48
 800e5b4:	64fa      	str	r2, [r7, #76]	; 0x4c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e5b6:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800e5b8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800e5ba:	e841 2300 	strex	r3, r2, [r1]
 800e5be:	653b      	str	r3, [r7, #80]	; 0x50
   return(result);
 800e5c0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e5c2:	2b00      	cmp	r3, #0
 800e5c4:	d1e6      	bne.n	800e594 <UART_WaitOnFlagUntilTimeout+0xd4>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800e5c6:	68fb      	ldr	r3, [r7, #12]
 800e5c8:	681b      	ldr	r3, [r3, #0]
 800e5ca:	3308      	adds	r3, #8
 800e5cc:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e5ce:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e5d0:	e853 3f00 	ldrex	r3, [r3]
 800e5d4:	66fb      	str	r3, [r7, #108]	; 0x6c
   return(result);
 800e5d6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e5d8:	f023 0301 	bic.w	r3, r3, #1
 800e5dc:	617b      	str	r3, [r7, #20]
 800e5de:	68fb      	ldr	r3, [r7, #12]
 800e5e0:	681b      	ldr	r3, [r3, #0]
 800e5e2:	3308      	adds	r3, #8
 800e5e4:	697a      	ldr	r2, [r7, #20]
 800e5e6:	65fa      	str	r2, [r7, #92]	; 0x5c
 800e5e8:	663b      	str	r3, [r7, #96]	; 0x60
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e5ea:	6e39      	ldr	r1, [r7, #96]	; 0x60
 800e5ec:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800e5ee:	e841 2300 	strex	r3, r2, [r1]
 800e5f2:	667b      	str	r3, [r7, #100]	; 0x64
   return(result);
 800e5f4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e5f6:	2b00      	cmp	r3, #0
 800e5f8:	d1e5      	bne.n	800e5c6 <UART_WaitOnFlagUntilTimeout+0x106>

          huart->gState = HAL_UART_STATE_READY;
 800e5fa:	68fb      	ldr	r3, [r7, #12]
 800e5fc:	2220      	movs	r2, #32
 800e5fe:	679a      	str	r2, [r3, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 800e600:	68fb      	ldr	r3, [r7, #12]
 800e602:	2220      	movs	r2, #32
 800e604:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800e606:	68fb      	ldr	r3, [r7, #12]
 800e608:	2220      	movs	r2, #32
 800e60a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800e60e:	68fb      	ldr	r3, [r7, #12]
 800e610:	2200      	movs	r2, #0
 800e612:	675a      	str	r2, [r3, #116]	; 0x74

          return HAL_TIMEOUT;
 800e614:	2303      	movs	r3, #3
 800e616:	e00f      	b.n	800e638 <UART_WaitOnFlagUntilTimeout+0x178>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800e618:	68fb      	ldr	r3, [r7, #12]
 800e61a:	681b      	ldr	r3, [r3, #0]
 800e61c:	69da      	ldr	r2, [r3, #28]
 800e61e:	68bb      	ldr	r3, [r7, #8]
 800e620:	4013      	ands	r3, r2
 800e622:	68ba      	ldr	r2, [r7, #8]
 800e624:	429a      	cmp	r2, r3
 800e626:	d101      	bne.n	800e62c <UART_WaitOnFlagUntilTimeout+0x16c>
 800e628:	2201      	movs	r2, #1
 800e62a:	e000      	b.n	800e62e <UART_WaitOnFlagUntilTimeout+0x16e>
 800e62c:	2200      	movs	r2, #0
 800e62e:	687b      	ldr	r3, [r7, #4]
 800e630:	429a      	cmp	r2, r3
 800e632:	f43f af4d 	beq.w	800e4d0 <UART_WaitOnFlagUntilTimeout+0x10>
        }
      }
    }
  }
  return HAL_OK;
 800e636:	2300      	movs	r3, #0
}
 800e638:	4618      	mov	r0, r3
 800e63a:	3770      	adds	r7, #112	; 0x70
 800e63c:	46bd      	mov	sp, r7
 800e63e:	bd80      	pop	{r7, pc}

0800e640 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 800e640:	b480      	push	{r7}
 800e642:	b083      	sub	sp, #12
 800e644:	af00      	add	r7, sp, #0
 800e646:	6078      	str	r0, [r7, #4]
 800e648:	6039      	str	r1, [r7, #0]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank == FMC_SDRAM_BANK1)
 800e64a:	683b      	ldr	r3, [r7, #0]
 800e64c:	681b      	ldr	r3, [r3, #0]
 800e64e:	2b00      	cmp	r3, #0
 800e650:	d121      	bne.n	800e696 <FMC_SDRAM_Init+0x56>
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800e652:	687b      	ldr	r3, [r7, #4]
 800e654:	681a      	ldr	r2, [r3, #0]
 800e656:	4b27      	ldr	r3, [pc, #156]	; (800e6f4 <FMC_SDRAM_Init+0xb4>)
 800e658:	4013      	ands	r3, r2
 800e65a:	683a      	ldr	r2, [r7, #0]
 800e65c:	6851      	ldr	r1, [r2, #4]
 800e65e:	683a      	ldr	r2, [r7, #0]
 800e660:	6892      	ldr	r2, [r2, #8]
 800e662:	4311      	orrs	r1, r2
 800e664:	683a      	ldr	r2, [r7, #0]
 800e666:	68d2      	ldr	r2, [r2, #12]
 800e668:	4311      	orrs	r1, r2
 800e66a:	683a      	ldr	r2, [r7, #0]
 800e66c:	6912      	ldr	r2, [r2, #16]
 800e66e:	4311      	orrs	r1, r2
 800e670:	683a      	ldr	r2, [r7, #0]
 800e672:	6952      	ldr	r2, [r2, #20]
 800e674:	4311      	orrs	r1, r2
 800e676:	683a      	ldr	r2, [r7, #0]
 800e678:	6992      	ldr	r2, [r2, #24]
 800e67a:	4311      	orrs	r1, r2
 800e67c:	683a      	ldr	r2, [r7, #0]
 800e67e:	69d2      	ldr	r2, [r2, #28]
 800e680:	4311      	orrs	r1, r2
 800e682:	683a      	ldr	r2, [r7, #0]
 800e684:	6a12      	ldr	r2, [r2, #32]
 800e686:	4311      	orrs	r1, r2
 800e688:	683a      	ldr	r2, [r7, #0]
 800e68a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800e68c:	430a      	orrs	r2, r1
 800e68e:	431a      	orrs	r2, r3
 800e690:	687b      	ldr	r3, [r7, #4]
 800e692:	601a      	str	r2, [r3, #0]
 800e694:	e026      	b.n	800e6e4 <FMC_SDRAM_Init+0xa4>
                Init->ReadBurst          |
                Init->ReadPipeDelay));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800e696:	687b      	ldr	r3, [r7, #4]
 800e698:	681b      	ldr	r3, [r3, #0]
 800e69a:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
 800e69e:	683b      	ldr	r3, [r7, #0]
 800e6a0:	69d9      	ldr	r1, [r3, #28]
 800e6a2:	683b      	ldr	r3, [r7, #0]
 800e6a4:	6a1b      	ldr	r3, [r3, #32]
 800e6a6:	4319      	orrs	r1, r3
 800e6a8:	683b      	ldr	r3, [r7, #0]
 800e6aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e6ac:	430b      	orrs	r3, r1
 800e6ae:	431a      	orrs	r2, r3
 800e6b0:	687b      	ldr	r3, [r7, #4]
 800e6b2:	601a      	str	r2, [r3, #0]
               FMC_SDCR1_RPIPE,
               (Init->SDClockPeriod      |
                Init->ReadBurst          |
                Init->ReadPipeDelay));

    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 800e6b4:	687b      	ldr	r3, [r7, #4]
 800e6b6:	685a      	ldr	r2, [r3, #4]
 800e6b8:	4b0e      	ldr	r3, [pc, #56]	; (800e6f4 <FMC_SDRAM_Init+0xb4>)
 800e6ba:	4013      	ands	r3, r2
 800e6bc:	683a      	ldr	r2, [r7, #0]
 800e6be:	6851      	ldr	r1, [r2, #4]
 800e6c0:	683a      	ldr	r2, [r7, #0]
 800e6c2:	6892      	ldr	r2, [r2, #8]
 800e6c4:	4311      	orrs	r1, r2
 800e6c6:	683a      	ldr	r2, [r7, #0]
 800e6c8:	68d2      	ldr	r2, [r2, #12]
 800e6ca:	4311      	orrs	r1, r2
 800e6cc:	683a      	ldr	r2, [r7, #0]
 800e6ce:	6912      	ldr	r2, [r2, #16]
 800e6d0:	4311      	orrs	r1, r2
 800e6d2:	683a      	ldr	r2, [r7, #0]
 800e6d4:	6952      	ldr	r2, [r2, #20]
 800e6d6:	4311      	orrs	r1, r2
 800e6d8:	683a      	ldr	r2, [r7, #0]
 800e6da:	6992      	ldr	r2, [r2, #24]
 800e6dc:	430a      	orrs	r2, r1
 800e6de:	431a      	orrs	r2, r3
 800e6e0:	687b      	ldr	r3, [r7, #4]
 800e6e2:	605a      	str	r2, [r3, #4]
                Init->InternalBankNumber |
                Init->CASLatency         |
                Init->WriteProtection));
  }

  return HAL_OK;
 800e6e4:	2300      	movs	r3, #0
}
 800e6e6:	4618      	mov	r0, r3
 800e6e8:	370c      	adds	r7, #12
 800e6ea:	46bd      	mov	sp, r7
 800e6ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e6f0:	4770      	bx	lr
 800e6f2:	bf00      	nop
 800e6f4:	ffff8000 	.word	0xffff8000

0800e6f8 <FMC_SDRAM_Timing_Init>:
  * @param  Bank SDRAM bank number
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device,
                                        FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 800e6f8:	b480      	push	{r7}
 800e6fa:	b085      	sub	sp, #20
 800e6fc:	af00      	add	r7, sp, #0
 800e6fe:	60f8      	str	r0, [r7, #12]
 800e700:	60b9      	str	r1, [r7, #8]
 800e702:	607a      	str	r2, [r7, #4]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));

  /* Set SDRAM device timing parameters */
  if (Bank == FMC_SDRAM_BANK1)
 800e704:	687b      	ldr	r3, [r7, #4]
 800e706:	2b00      	cmp	r3, #0
 800e708:	d128      	bne.n	800e75c <FMC_SDRAM_Timing_Init+0x64>
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 800e70a:	68fb      	ldr	r3, [r7, #12]
 800e70c:	689b      	ldr	r3, [r3, #8]
 800e70e:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
 800e712:	68bb      	ldr	r3, [r7, #8]
 800e714:	681b      	ldr	r3, [r3, #0]
 800e716:	1e59      	subs	r1, r3, #1
 800e718:	68bb      	ldr	r3, [r7, #8]
 800e71a:	685b      	ldr	r3, [r3, #4]
 800e71c:	3b01      	subs	r3, #1
 800e71e:	011b      	lsls	r3, r3, #4
 800e720:	4319      	orrs	r1, r3
 800e722:	68bb      	ldr	r3, [r7, #8]
 800e724:	689b      	ldr	r3, [r3, #8]
 800e726:	3b01      	subs	r3, #1
 800e728:	021b      	lsls	r3, r3, #8
 800e72a:	4319      	orrs	r1, r3
 800e72c:	68bb      	ldr	r3, [r7, #8]
 800e72e:	68db      	ldr	r3, [r3, #12]
 800e730:	3b01      	subs	r3, #1
 800e732:	031b      	lsls	r3, r3, #12
 800e734:	4319      	orrs	r1, r3
 800e736:	68bb      	ldr	r3, [r7, #8]
 800e738:	691b      	ldr	r3, [r3, #16]
 800e73a:	3b01      	subs	r3, #1
 800e73c:	041b      	lsls	r3, r3, #16
 800e73e:	4319      	orrs	r1, r3
 800e740:	68bb      	ldr	r3, [r7, #8]
 800e742:	695b      	ldr	r3, [r3, #20]
 800e744:	3b01      	subs	r3, #1
 800e746:	051b      	lsls	r3, r3, #20
 800e748:	4319      	orrs	r1, r3
 800e74a:	68bb      	ldr	r3, [r7, #8]
 800e74c:	699b      	ldr	r3, [r3, #24]
 800e74e:	3b01      	subs	r3, #1
 800e750:	061b      	lsls	r3, r3, #24
 800e752:	430b      	orrs	r3, r1
 800e754:	431a      	orrs	r2, r3
 800e756:	68fb      	ldr	r3, [r7, #12]
 800e758:	609a      	str	r2, [r3, #8]
 800e75a:	e02d      	b.n	800e7b8 <FMC_SDRAM_Timing_Init+0xc0>
                (((Timing->RPDelay) - 1U)              << FMC_SDTR1_TRP_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTR1_TRCD_Pos)));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 800e75c:	68fb      	ldr	r3, [r7, #12]
 800e75e:	689a      	ldr	r2, [r3, #8]
 800e760:	4b19      	ldr	r3, [pc, #100]	; (800e7c8 <FMC_SDRAM_Timing_Init+0xd0>)
 800e762:	4013      	ands	r3, r2
 800e764:	68ba      	ldr	r2, [r7, #8]
 800e766:	68d2      	ldr	r2, [r2, #12]
 800e768:	3a01      	subs	r2, #1
 800e76a:	0311      	lsls	r1, r2, #12
 800e76c:	68ba      	ldr	r2, [r7, #8]
 800e76e:	6952      	ldr	r2, [r2, #20]
 800e770:	3a01      	subs	r2, #1
 800e772:	0512      	lsls	r2, r2, #20
 800e774:	430a      	orrs	r2, r1
 800e776:	431a      	orrs	r2, r3
 800e778:	68fb      	ldr	r3, [r7, #12]
 800e77a:	609a      	str	r2, [r3, #8]
               FMC_SDTR1_TRC |
               FMC_SDTR1_TRP,
               (((Timing->RowCycleDelay) - 1U)         << FMC_SDTR1_TRC_Pos)  |
               (((Timing->RPDelay) - 1U)               << FMC_SDTR1_TRP_Pos));

    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
 800e77c:	68fb      	ldr	r3, [r7, #12]
 800e77e:	68db      	ldr	r3, [r3, #12]
 800e780:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
 800e784:	68bb      	ldr	r3, [r7, #8]
 800e786:	681b      	ldr	r3, [r3, #0]
 800e788:	1e59      	subs	r1, r3, #1
 800e78a:	68bb      	ldr	r3, [r7, #8]
 800e78c:	685b      	ldr	r3, [r3, #4]
 800e78e:	3b01      	subs	r3, #1
 800e790:	011b      	lsls	r3, r3, #4
 800e792:	4319      	orrs	r1, r3
 800e794:	68bb      	ldr	r3, [r7, #8]
 800e796:	689b      	ldr	r3, [r3, #8]
 800e798:	3b01      	subs	r3, #1
 800e79a:	021b      	lsls	r3, r3, #8
 800e79c:	4319      	orrs	r1, r3
 800e79e:	68bb      	ldr	r3, [r7, #8]
 800e7a0:	691b      	ldr	r3, [r3, #16]
 800e7a2:	3b01      	subs	r3, #1
 800e7a4:	041b      	lsls	r3, r3, #16
 800e7a6:	4319      	orrs	r1, r3
 800e7a8:	68bb      	ldr	r3, [r7, #8]
 800e7aa:	699b      	ldr	r3, [r3, #24]
 800e7ac:	3b01      	subs	r3, #1
 800e7ae:	061b      	lsls	r3, r3, #24
 800e7b0:	430b      	orrs	r3, r1
 800e7b2:	431a      	orrs	r2, r3
 800e7b4:	68fb      	ldr	r3, [r7, #12]
 800e7b6:	60da      	str	r2, [r3, #12]
                (((Timing->SelfRefreshTime) - 1U)      << FMC_SDTR1_TRAS_Pos) |
                (((Timing->WriteRecoveryTime) - 1U)    << FMC_SDTR1_TWR_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTR1_TRCD_Pos)));
  }

  return HAL_OK;
 800e7b8:	2300      	movs	r3, #0
}
 800e7ba:	4618      	mov	r0, r3
 800e7bc:	3714      	adds	r7, #20
 800e7be:	46bd      	mov	sp, r7
 800e7c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e7c4:	4770      	bx	lr
 800e7c6:	bf00      	nop
 800e7c8:	ff0f0fff 	.word	0xff0f0fff

0800e7cc <FMC_SDRAM_SendCommand>:
  * @param  Timeout Timeout wait value
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device,
                                        FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 800e7cc:	b480      	push	{r7}
 800e7ce:	b085      	sub	sp, #20
 800e7d0:	af00      	add	r7, sp, #0
 800e7d2:	60f8      	str	r0, [r7, #12]
 800e7d4:	60b9      	str	r1, [r7, #8]
 800e7d6:	607a      	str	r2, [r7, #4]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));

  /* Set command register */
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | FMC_SDCMR_NRFS | FMC_SDCMR_MRD),
 800e7d8:	68fb      	ldr	r3, [r7, #12]
 800e7da:	691a      	ldr	r2, [r3, #16]
 800e7dc:	4b0c      	ldr	r3, [pc, #48]	; (800e810 <FMC_SDRAM_SendCommand+0x44>)
 800e7de:	4013      	ands	r3, r2
 800e7e0:	68ba      	ldr	r2, [r7, #8]
 800e7e2:	6811      	ldr	r1, [r2, #0]
 800e7e4:	68ba      	ldr	r2, [r7, #8]
 800e7e6:	6852      	ldr	r2, [r2, #4]
 800e7e8:	4311      	orrs	r1, r2
 800e7ea:	68ba      	ldr	r2, [r7, #8]
 800e7ec:	6892      	ldr	r2, [r2, #8]
 800e7ee:	3a01      	subs	r2, #1
 800e7f0:	0152      	lsls	r2, r2, #5
 800e7f2:	4311      	orrs	r1, r2
 800e7f4:	68ba      	ldr	r2, [r7, #8]
 800e7f6:	68d2      	ldr	r2, [r2, #12]
 800e7f8:	0252      	lsls	r2, r2, #9
 800e7fa:	430a      	orrs	r2, r1
 800e7fc:	431a      	orrs	r2, r3
 800e7fe:	68fb      	ldr	r3, [r7, #12]
 800e800:	611a      	str	r2, [r3, #16]
             ((Command->CommandMode) | (Command->CommandTarget) |
              (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos) |
              ((Command->ModeRegisterDefinition) << FMC_SDCMR_MRD_Pos)));
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Timeout);
  return HAL_OK;
 800e802:	2300      	movs	r3, #0
}
 800e804:	4618      	mov	r0, r3
 800e806:	3714      	adds	r7, #20
 800e808:	46bd      	mov	sp, r7
 800e80a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e80e:	4770      	bx	lr
 800e810:	ffc00000 	.word	0xffc00000

0800e814 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 800e814:	b480      	push	{r7}
 800e816:	b083      	sub	sp, #12
 800e818:	af00      	add	r7, sp, #0
 800e81a:	6078      	str	r0, [r7, #4]
 800e81c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));

  /* Set the refresh rate in command register */
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
 800e81e:	687b      	ldr	r3, [r7, #4]
 800e820:	695a      	ldr	r2, [r3, #20]
 800e822:	4b07      	ldr	r3, [pc, #28]	; (800e840 <FMC_SDRAM_ProgramRefreshRate+0x2c>)
 800e824:	4013      	ands	r3, r2
 800e826:	683a      	ldr	r2, [r7, #0]
 800e828:	0052      	lsls	r2, r2, #1
 800e82a:	431a      	orrs	r2, r3
 800e82c:	687b      	ldr	r3, [r7, #4]
 800e82e:	615a      	str	r2, [r3, #20]

  return HAL_OK;
 800e830:	2300      	movs	r3, #0
}
 800e832:	4618      	mov	r0, r3
 800e834:	370c      	adds	r7, #12
 800e836:	46bd      	mov	sp, r7
 800e838:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e83c:	4770      	bx	lr
 800e83e:	bf00      	nop
 800e840:	ffffc001 	.word	0xffffc001

0800e844 <memset>:
	return 0;
}
#endif

void *memset(void *dest, int c, size_t n)
{
 800e844:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
 800e848:	b08b      	sub	sp, #44	; 0x2c
 800e84a:	af00      	add	r7, sp, #0
 800e84c:	60f8      	str	r0, [r7, #12]
 800e84e:	60b9      	str	r1, [r7, #8]
 800e850:	607a      	str	r2, [r7, #4]
	unsigned char *s = dest;
 800e852:	68fb      	ldr	r3, [r7, #12]
 800e854:	617b      	str	r3, [r7, #20]

	/* Fill head and tail with minimal branching. Each
	 * conditional ensures that all the subsequently used
	 * offsets are well-defined and in the dest region. */

	if (!n) return dest;
 800e856:	687b      	ldr	r3, [r7, #4]
 800e858:	2b00      	cmp	r3, #0
 800e85a:	d101      	bne.n	800e860 <memset+0x1c>
 800e85c:	68fb      	ldr	r3, [r7, #12]
 800e85e:	e0ec      	b.n	800ea3a <memset+0x1f6>
	s[0] = c;
 800e860:	68bb      	ldr	r3, [r7, #8]
 800e862:	b2da      	uxtb	r2, r3
 800e864:	697b      	ldr	r3, [r7, #20]
 800e866:	701a      	strb	r2, [r3, #0]
	s[n-1] = c;
 800e868:	687b      	ldr	r3, [r7, #4]
 800e86a:	3b01      	subs	r3, #1
 800e86c:	697a      	ldr	r2, [r7, #20]
 800e86e:	4413      	add	r3, r2
 800e870:	68ba      	ldr	r2, [r7, #8]
 800e872:	b2d2      	uxtb	r2, r2
 800e874:	701a      	strb	r2, [r3, #0]
	if (n <= 2) return dest;
 800e876:	687b      	ldr	r3, [r7, #4]
 800e878:	2b02      	cmp	r3, #2
 800e87a:	d801      	bhi.n	800e880 <memset+0x3c>
 800e87c:	68fb      	ldr	r3, [r7, #12]
 800e87e:	e0dc      	b.n	800ea3a <memset+0x1f6>
	s[1] = c;
 800e880:	697b      	ldr	r3, [r7, #20]
 800e882:	3301      	adds	r3, #1
 800e884:	68ba      	ldr	r2, [r7, #8]
 800e886:	b2d2      	uxtb	r2, r2
 800e888:	701a      	strb	r2, [r3, #0]
	s[2] = c;
 800e88a:	697b      	ldr	r3, [r7, #20]
 800e88c:	3302      	adds	r3, #2
 800e88e:	68ba      	ldr	r2, [r7, #8]
 800e890:	b2d2      	uxtb	r2, r2
 800e892:	701a      	strb	r2, [r3, #0]
	s[n-2] = c;
 800e894:	687b      	ldr	r3, [r7, #4]
 800e896:	3b02      	subs	r3, #2
 800e898:	697a      	ldr	r2, [r7, #20]
 800e89a:	4413      	add	r3, r2
 800e89c:	68ba      	ldr	r2, [r7, #8]
 800e89e:	b2d2      	uxtb	r2, r2
 800e8a0:	701a      	strb	r2, [r3, #0]
	s[n-3] = c;
 800e8a2:	687b      	ldr	r3, [r7, #4]
 800e8a4:	3b03      	subs	r3, #3
 800e8a6:	697a      	ldr	r2, [r7, #20]
 800e8a8:	4413      	add	r3, r2
 800e8aa:	68ba      	ldr	r2, [r7, #8]
 800e8ac:	b2d2      	uxtb	r2, r2
 800e8ae:	701a      	strb	r2, [r3, #0]
	if (n <= 6) return dest;
 800e8b0:	687b      	ldr	r3, [r7, #4]
 800e8b2:	2b06      	cmp	r3, #6
 800e8b4:	d801      	bhi.n	800e8ba <memset+0x76>
 800e8b6:	68fb      	ldr	r3, [r7, #12]
 800e8b8:	e0bf      	b.n	800ea3a <memset+0x1f6>
	s[3] = c;
 800e8ba:	697b      	ldr	r3, [r7, #20]
 800e8bc:	3303      	adds	r3, #3
 800e8be:	68ba      	ldr	r2, [r7, #8]
 800e8c0:	b2d2      	uxtb	r2, r2
 800e8c2:	701a      	strb	r2, [r3, #0]
	s[n-4] = c;
 800e8c4:	687b      	ldr	r3, [r7, #4]
 800e8c6:	3b04      	subs	r3, #4
 800e8c8:	697a      	ldr	r2, [r7, #20]
 800e8ca:	4413      	add	r3, r2
 800e8cc:	68ba      	ldr	r2, [r7, #8]
 800e8ce:	b2d2      	uxtb	r2, r2
 800e8d0:	701a      	strb	r2, [r3, #0]
	if (n <= 8) return dest;
 800e8d2:	687b      	ldr	r3, [r7, #4]
 800e8d4:	2b08      	cmp	r3, #8
 800e8d6:	d801      	bhi.n	800e8dc <memset+0x98>
 800e8d8:	68fb      	ldr	r3, [r7, #12]
 800e8da:	e0ae      	b.n	800ea3a <memset+0x1f6>
	/* Advance pointer to align it at a 4-byte boundary,
	 * and truncate n to a multiple of 4. The previous code
	 * already took care of any head/tail that get cut off
	 * by the alignment. */

	k = -(uintptr_t)s & 3;
 800e8dc:	697b      	ldr	r3, [r7, #20]
 800e8de:	425b      	negs	r3, r3
 800e8e0:	f003 0303 	and.w	r3, r3, #3
 800e8e4:	61bb      	str	r3, [r7, #24]
	s += k;
 800e8e6:	697a      	ldr	r2, [r7, #20]
 800e8e8:	69bb      	ldr	r3, [r7, #24]
 800e8ea:	4413      	add	r3, r2
 800e8ec:	617b      	str	r3, [r7, #20]
	n -= k;
 800e8ee:	687a      	ldr	r2, [r7, #4]
 800e8f0:	69bb      	ldr	r3, [r7, #24]
 800e8f2:	1ad3      	subs	r3, r2, r3
 800e8f4:	607b      	str	r3, [r7, #4]
	n &= -4;
 800e8f6:	687b      	ldr	r3, [r7, #4]
 800e8f8:	f023 0303 	bic.w	r3, r3, #3
 800e8fc:	607b      	str	r3, [r7, #4]

#ifdef __GNUC__
	typedef uint32_t __attribute__((__may_alias__)) u32;
	typedef uint64_t __attribute__((__may_alias__)) u64;

	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
 800e8fe:	68bb      	ldr	r3, [r7, #8]
 800e900:	b2db      	uxtb	r3, r3
 800e902:	461a      	mov	r2, r3
 800e904:	4613      	mov	r3, r2
 800e906:	021b      	lsls	r3, r3, #8
 800e908:	4413      	add	r3, r2
 800e90a:	041a      	lsls	r2, r3, #16
 800e90c:	4413      	add	r3, r2
 800e90e:	61fb      	str	r3, [r7, #28]
	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
	 * As in the initial byte-based head/tail fill, each
	 * conditional below ensures that the subsequent offsets
	 * are valid (e.g. !(n<=24) implies n>=28). */

	*(u32 *)(s+0) = c32;
 800e910:	697b      	ldr	r3, [r7, #20]
 800e912:	69fa      	ldr	r2, [r7, #28]
 800e914:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-4) = c32;
 800e916:	687b      	ldr	r3, [r7, #4]
 800e918:	3b04      	subs	r3, #4
 800e91a:	697a      	ldr	r2, [r7, #20]
 800e91c:	4413      	add	r3, r2
 800e91e:	69fa      	ldr	r2, [r7, #28]
 800e920:	601a      	str	r2, [r3, #0]
	if (n <= 8) return dest;
 800e922:	687b      	ldr	r3, [r7, #4]
 800e924:	2b08      	cmp	r3, #8
 800e926:	d801      	bhi.n	800e92c <memset+0xe8>
 800e928:	68fb      	ldr	r3, [r7, #12]
 800e92a:	e086      	b.n	800ea3a <memset+0x1f6>
	*(u32 *)(s+4) = c32;
 800e92c:	697b      	ldr	r3, [r7, #20]
 800e92e:	3304      	adds	r3, #4
 800e930:	69fa      	ldr	r2, [r7, #28]
 800e932:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+8) = c32;
 800e934:	697b      	ldr	r3, [r7, #20]
 800e936:	3308      	adds	r3, #8
 800e938:	69fa      	ldr	r2, [r7, #28]
 800e93a:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-12) = c32;
 800e93c:	687b      	ldr	r3, [r7, #4]
 800e93e:	3b0c      	subs	r3, #12
 800e940:	697a      	ldr	r2, [r7, #20]
 800e942:	4413      	add	r3, r2
 800e944:	69fa      	ldr	r2, [r7, #28]
 800e946:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-8) = c32;
 800e948:	687b      	ldr	r3, [r7, #4]
 800e94a:	3b08      	subs	r3, #8
 800e94c:	697a      	ldr	r2, [r7, #20]
 800e94e:	4413      	add	r3, r2
 800e950:	69fa      	ldr	r2, [r7, #28]
 800e952:	601a      	str	r2, [r3, #0]
	if (n <= 24) return dest;
 800e954:	687b      	ldr	r3, [r7, #4]
 800e956:	2b18      	cmp	r3, #24
 800e958:	d801      	bhi.n	800e95e <memset+0x11a>
 800e95a:	68fb      	ldr	r3, [r7, #12]
 800e95c:	e06d      	b.n	800ea3a <memset+0x1f6>
	*(u32 *)(s+12) = c32;
 800e95e:	697b      	ldr	r3, [r7, #20]
 800e960:	330c      	adds	r3, #12
 800e962:	69fa      	ldr	r2, [r7, #28]
 800e964:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+16) = c32;
 800e966:	697b      	ldr	r3, [r7, #20]
 800e968:	3310      	adds	r3, #16
 800e96a:	69fa      	ldr	r2, [r7, #28]
 800e96c:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+20) = c32;
 800e96e:	697b      	ldr	r3, [r7, #20]
 800e970:	3314      	adds	r3, #20
 800e972:	69fa      	ldr	r2, [r7, #28]
 800e974:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+24) = c32;
 800e976:	697b      	ldr	r3, [r7, #20]
 800e978:	3318      	adds	r3, #24
 800e97a:	69fa      	ldr	r2, [r7, #28]
 800e97c:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-28) = c32;
 800e97e:	687b      	ldr	r3, [r7, #4]
 800e980:	3b1c      	subs	r3, #28
 800e982:	697a      	ldr	r2, [r7, #20]
 800e984:	4413      	add	r3, r2
 800e986:	69fa      	ldr	r2, [r7, #28]
 800e988:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-24) = c32;
 800e98a:	687b      	ldr	r3, [r7, #4]
 800e98c:	3b18      	subs	r3, #24
 800e98e:	697a      	ldr	r2, [r7, #20]
 800e990:	4413      	add	r3, r2
 800e992:	69fa      	ldr	r2, [r7, #28]
 800e994:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-20) = c32;
 800e996:	687b      	ldr	r3, [r7, #4]
 800e998:	3b14      	subs	r3, #20
 800e99a:	697a      	ldr	r2, [r7, #20]
 800e99c:	4413      	add	r3, r2
 800e99e:	69fa      	ldr	r2, [r7, #28]
 800e9a0:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-16) = c32;
 800e9a2:	687b      	ldr	r3, [r7, #4]
 800e9a4:	3b10      	subs	r3, #16
 800e9a6:	697a      	ldr	r2, [r7, #20]
 800e9a8:	4413      	add	r3, r2
 800e9aa:	69fa      	ldr	r2, [r7, #28]
 800e9ac:	601a      	str	r2, [r3, #0]

	/* Align to a multiple of 8 so we can fill 64 bits at a time,
	 * and avoid writing the same bytes twice as much as is
	 * practical without introducing additional branching. */

	k = 24 + ((uintptr_t)s & 4);
 800e9ae:	697b      	ldr	r3, [r7, #20]
 800e9b0:	f003 0304 	and.w	r3, r3, #4
 800e9b4:	3318      	adds	r3, #24
 800e9b6:	61bb      	str	r3, [r7, #24]
	s += k;
 800e9b8:	697a      	ldr	r2, [r7, #20]
 800e9ba:	69bb      	ldr	r3, [r7, #24]
 800e9bc:	4413      	add	r3, r2
 800e9be:	617b      	str	r3, [r7, #20]
	n -= k;
 800e9c0:	687a      	ldr	r2, [r7, #4]
 800e9c2:	69bb      	ldr	r3, [r7, #24]
 800e9c4:	1ad3      	subs	r3, r2, r3
 800e9c6:	607b      	str	r3, [r7, #4]

	/* If this loop is reached, 28 tail bytes have already been
	 * filled, so any remainder when n drops below 32 can be
	 * safely ignored. */

	u64 c64 = c32 | ((u64)c32 << 32);
 800e9c8:	69fb      	ldr	r3, [r7, #28]
 800e9ca:	4618      	mov	r0, r3
 800e9cc:	f04f 0100 	mov.w	r1, #0
 800e9d0:	69fb      	ldr	r3, [r7, #28]
 800e9d2:	4698      	mov	r8, r3
 800e9d4:	f04f 0900 	mov.w	r9, #0
 800e9d8:	f04f 0200 	mov.w	r2, #0
 800e9dc:	f04f 0300 	mov.w	r3, #0
 800e9e0:	4643      	mov	r3, r8
 800e9e2:	2200      	movs	r2, #0
 800e9e4:	ea40 0402 	orr.w	r4, r0, r2
 800e9e8:	ea41 0503 	orr.w	r5, r1, r3
 800e9ec:	e9c7 4508 	strd	r4, r5, [r7, #32]
	for (; n >= 32; n-=32, s+=32) {
 800e9f0:	e01f      	b.n	800ea32 <memset+0x1ee>
		*(u64 *)(s+0) = c64;
 800e9f2:	6979      	ldr	r1, [r7, #20]
 800e9f4:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800e9f8:	e9c1 2300 	strd	r2, r3, [r1]
		*(u64 *)(s+8) = c64;
 800e9fc:	697b      	ldr	r3, [r7, #20]
 800e9fe:	f103 0108 	add.w	r1, r3, #8
 800ea02:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800ea06:	e9c1 2300 	strd	r2, r3, [r1]
		*(u64 *)(s+16) = c64;
 800ea0a:	697b      	ldr	r3, [r7, #20]
 800ea0c:	f103 0110 	add.w	r1, r3, #16
 800ea10:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800ea14:	e9c1 2300 	strd	r2, r3, [r1]
		*(u64 *)(s+24) = c64;
 800ea18:	697b      	ldr	r3, [r7, #20]
 800ea1a:	f103 0118 	add.w	r1, r3, #24
 800ea1e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800ea22:	e9c1 2300 	strd	r2, r3, [r1]
	for (; n >= 32; n-=32, s+=32) {
 800ea26:	687b      	ldr	r3, [r7, #4]
 800ea28:	3b20      	subs	r3, #32
 800ea2a:	607b      	str	r3, [r7, #4]
 800ea2c:	697b      	ldr	r3, [r7, #20]
 800ea2e:	3320      	adds	r3, #32
 800ea30:	617b      	str	r3, [r7, #20]
 800ea32:	687b      	ldr	r3, [r7, #4]
 800ea34:	2b1f      	cmp	r3, #31
 800ea36:	d8dc      	bhi.n	800e9f2 <memset+0x1ae>
#else
	/* Pure C fallback with no aliasing violations. */
	for (; n; n--, s++) *s = c;
#endif

	return dest;
 800ea38:	68fb      	ldr	r3, [r7, #12]
}
 800ea3a:	4618      	mov	r0, r3
 800ea3c:	372c      	adds	r7, #44	; 0x2c
 800ea3e:	46bd      	mov	sp, r7
 800ea40:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
 800ea44:	4770      	bx	lr

0800ea46 <strcmp>:
#include <string.h>

int strcmp(const char *l, const char *r)
{
 800ea46:	b480      	push	{r7}
 800ea48:	b083      	sub	sp, #12
 800ea4a:	af00      	add	r7, sp, #0
 800ea4c:	6078      	str	r0, [r7, #4]
 800ea4e:	6039      	str	r1, [r7, #0]
	for (; *l==*r && *l; l++, r++);
 800ea50:	e005      	b.n	800ea5e <strcmp+0x18>
 800ea52:	687b      	ldr	r3, [r7, #4]
 800ea54:	3301      	adds	r3, #1
 800ea56:	607b      	str	r3, [r7, #4]
 800ea58:	683b      	ldr	r3, [r7, #0]
 800ea5a:	3301      	adds	r3, #1
 800ea5c:	603b      	str	r3, [r7, #0]
 800ea5e:	687b      	ldr	r3, [r7, #4]
 800ea60:	781a      	ldrb	r2, [r3, #0]
 800ea62:	683b      	ldr	r3, [r7, #0]
 800ea64:	781b      	ldrb	r3, [r3, #0]
 800ea66:	429a      	cmp	r2, r3
 800ea68:	d103      	bne.n	800ea72 <strcmp+0x2c>
 800ea6a:	687b      	ldr	r3, [r7, #4]
 800ea6c:	781b      	ldrb	r3, [r3, #0]
 800ea6e:	2b00      	cmp	r3, #0
 800ea70:	d1ef      	bne.n	800ea52 <strcmp+0xc>
	return *(unsigned char *)l - *(unsigned char *)r;
 800ea72:	687b      	ldr	r3, [r7, #4]
 800ea74:	781b      	ldrb	r3, [r3, #0]
 800ea76:	461a      	mov	r2, r3
 800ea78:	683b      	ldr	r3, [r7, #0]
 800ea7a:	781b      	ldrb	r3, [r3, #0]
 800ea7c:	1ad3      	subs	r3, r2, r3
}
 800ea7e:	4618      	mov	r0, r3
 800ea80:	370c      	adds	r7, #12
 800ea82:	46bd      	mov	sp, r7
 800ea84:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ea88:	4770      	bx	lr

0800ea8a <strlen>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) (((x)-ONES) & ~(x) & HIGHS)

size_t strlen(const char *s)
{
 800ea8a:	b480      	push	{r7}
 800ea8c:	b085      	sub	sp, #20
 800ea8e:	af00      	add	r7, sp, #0
 800ea90:	6078      	str	r0, [r7, #4]
	const char *a = s;
 800ea92:	687b      	ldr	r3, [r7, #4]
 800ea94:	60fb      	str	r3, [r7, #12]
#ifdef __GNUC__
	typedef size_t __attribute__((__may_alias__)) word;
	const word *w;
	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
 800ea96:	e00a      	b.n	800eaae <strlen+0x24>
 800ea98:	687b      	ldr	r3, [r7, #4]
 800ea9a:	781b      	ldrb	r3, [r3, #0]
 800ea9c:	2b00      	cmp	r3, #0
 800ea9e:	d103      	bne.n	800eaa8 <strlen+0x1e>
 800eaa0:	687a      	ldr	r2, [r7, #4]
 800eaa2:	68fb      	ldr	r3, [r7, #12]
 800eaa4:	1ad3      	subs	r3, r2, r3
 800eaa6:	e026      	b.n	800eaf6 <strlen+0x6c>
 800eaa8:	687b      	ldr	r3, [r7, #4]
 800eaaa:	3301      	adds	r3, #1
 800eaac:	607b      	str	r3, [r7, #4]
 800eaae:	687b      	ldr	r3, [r7, #4]
 800eab0:	f003 0303 	and.w	r3, r3, #3
 800eab4:	2b00      	cmp	r3, #0
 800eab6:	d1ef      	bne.n	800ea98 <strlen+0xe>
	for (w = (const void *)s; !HASZERO(*w); w++);
 800eab8:	687b      	ldr	r3, [r7, #4]
 800eaba:	60bb      	str	r3, [r7, #8]
 800eabc:	e002      	b.n	800eac4 <strlen+0x3a>
 800eabe:	68bb      	ldr	r3, [r7, #8]
 800eac0:	3304      	adds	r3, #4
 800eac2:	60bb      	str	r3, [r7, #8]
 800eac4:	68bb      	ldr	r3, [r7, #8]
 800eac6:	681b      	ldr	r3, [r3, #0]
 800eac8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 800eacc:	68bb      	ldr	r3, [r7, #8]
 800eace:	681b      	ldr	r3, [r3, #0]
 800ead0:	43db      	mvns	r3, r3
 800ead2:	4013      	ands	r3, r2
 800ead4:	f003 3380 	and.w	r3, r3, #2155905152	; 0x80808080
 800ead8:	2b00      	cmp	r3, #0
 800eada:	d0f0      	beq.n	800eabe <strlen+0x34>
	s = (const void *)w;
 800eadc:	68bb      	ldr	r3, [r7, #8]
 800eade:	607b      	str	r3, [r7, #4]
#endif
	for (; *s; s++);
 800eae0:	e002      	b.n	800eae8 <strlen+0x5e>
 800eae2:	687b      	ldr	r3, [r7, #4]
 800eae4:	3301      	adds	r3, #1
 800eae6:	607b      	str	r3, [r7, #4]
 800eae8:	687b      	ldr	r3, [r7, #4]
 800eaea:	781b      	ldrb	r3, [r3, #0]
 800eaec:	2b00      	cmp	r3, #0
 800eaee:	d1f8      	bne.n	800eae2 <strlen+0x58>
	return s-a;
 800eaf0:	687a      	ldr	r2, [r7, #4]
 800eaf2:	68fb      	ldr	r3, [r7, #12]
 800eaf4:	1ad3      	subs	r3, r2, r3
}
 800eaf6:	4618      	mov	r0, r3
 800eaf8:	3714      	adds	r7, #20
 800eafa:	46bd      	mov	sp, r7
 800eafc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb00:	4770      	bx	lr
	...

0800eb04 <strtox>:
#include <inttypes.h>
#include <limits.h>
#include <ctype.h>

static unsigned long long strtox(const char *s, char **p, int base, unsigned long long lim)
{
 800eb04:	b580      	push	{r7, lr}
 800eb06:	b0b0      	sub	sp, #192	; 0xc0
 800eb08:	af02      	add	r7, sp, #8
 800eb0a:	60f8      	str	r0, [r7, #12]
 800eb0c:	60b9      	str	r1, [r7, #8]
 800eb0e:	607a      	str	r2, [r7, #4]
 800eb10:	4b1e      	ldr	r3, [pc, #120]	; (800eb8c <strtox+0x88>)
 800eb12:	681b      	ldr	r3, [r3, #0]
 800eb14:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800eb18:	f04f 0300 	mov.w	r3, #0
	FILE f;
	sh_fromstring(&f, s);
 800eb1c:	68fb      	ldr	r3, [r7, #12]
 800eb1e:	627b      	str	r3, [r7, #36]	; 0x24
 800eb20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eb22:	653b      	str	r3, [r7, #80]	; 0x50
 800eb24:	f04f 33ff 	mov.w	r3, #4294967295
 800eb28:	62bb      	str	r3, [r7, #40]	; 0x28
	shlim(&f, 0);
 800eb2a:	f107 0320 	add.w	r3, r7, #32
 800eb2e:	2100      	movs	r1, #0
 800eb30:	4618      	mov	r0, r3
 800eb32:	f000 fc35 	bl	800f3a0 <__shlim>
	unsigned long long y = __intscan(&f, base, 1, lim);
 800eb36:	6879      	ldr	r1, [r7, #4]
 800eb38:	f107 0020 	add.w	r0, r7, #32
 800eb3c:	e9d7 2330 	ldrd	r2, r3, [r7, #192]	; 0xc0
 800eb40:	e9cd 2300 	strd	r2, r3, [sp]
 800eb44:	2201      	movs	r2, #1
 800eb46:	f000 f84f 	bl	800ebe8 <__intscan>
 800eb4a:	e9c7 0106 	strd	r0, r1, [r7, #24]
	if (p) {
 800eb4e:	68bb      	ldr	r3, [r7, #8]
 800eb50:	2b00      	cmp	r3, #0
 800eb52:	d00b      	beq.n	800eb6c <strtox+0x68>
		size_t cnt = shcnt(&f);
 800eb54:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 800eb58:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800eb5a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800eb5c:	1acb      	subs	r3, r1, r3
 800eb5e:	4413      	add	r3, r2
 800eb60:	617b      	str	r3, [r7, #20]
		*p = (char *)s + cnt;
 800eb62:	68fa      	ldr	r2, [r7, #12]
 800eb64:	697b      	ldr	r3, [r7, #20]
 800eb66:	441a      	add	r2, r3
 800eb68:	68bb      	ldr	r3, [r7, #8]
 800eb6a:	601a      	str	r2, [r3, #0]
	}
	return y;
 800eb6c:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
}
 800eb70:	4906      	ldr	r1, [pc, #24]	; (800eb8c <strtox+0x88>)
 800eb72:	6808      	ldr	r0, [r1, #0]
 800eb74:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
 800eb78:	4048      	eors	r0, r1
 800eb7a:	d001      	beq.n	800eb80 <strtox+0x7c>
 800eb7c:	f7f5 fc34 	bl	80043e8 <__stack_chk_fail>
 800eb80:	4610      	mov	r0, r2
 800eb82:	4619      	mov	r1, r3
 800eb84:	37b8      	adds	r7, #184	; 0xb8
 800eb86:	46bd      	mov	sp, r7
 800eb88:	bd80      	pop	{r7, pc}
 800eb8a:	bf00      	nop
 800eb8c:	08021680 	.word	0x08021680

0800eb90 <strtoul>:
{
	return strtox(s, p, base, LLONG_MIN);
}

unsigned long strtoul(const char *restrict s, char **restrict p, int base)
{
 800eb90:	b580      	push	{r7, lr}
 800eb92:	b086      	sub	sp, #24
 800eb94:	af02      	add	r7, sp, #8
 800eb96:	60f8      	str	r0, [r7, #12]
 800eb98:	60b9      	str	r1, [r7, #8]
 800eb9a:	607a      	str	r2, [r7, #4]
	return strtox(s, p, base, ULONG_MAX);
 800eb9c:	f04f 32ff 	mov.w	r2, #4294967295
 800eba0:	f04f 0300 	mov.w	r3, #0
 800eba4:	e9cd 2300 	strd	r2, r3, [sp]
 800eba8:	687a      	ldr	r2, [r7, #4]
 800ebaa:	68b9      	ldr	r1, [r7, #8]
 800ebac:	68f8      	ldr	r0, [r7, #12]
 800ebae:	f7ff ffa9 	bl	800eb04 <strtox>
 800ebb2:	4602      	mov	r2, r0
 800ebb4:	460b      	mov	r3, r1
 800ebb6:	4613      	mov	r3, r2
}
 800ebb8:	4618      	mov	r0, r3
 800ebba:	3710      	adds	r7, #16
 800ebbc:	46bd      	mov	sp, r7
 800ebbe:	bd80      	pop	{r7, pc}

0800ebc0 <__isspace>:
 */
int   toupper(int);

#ifndef __cplusplus
static __inline int __isspace(int _c)
{
 800ebc0:	b480      	push	{r7}
 800ebc2:	b083      	sub	sp, #12
 800ebc4:	af00      	add	r7, sp, #0
 800ebc6:	6078      	str	r0, [r7, #4]
	return _c == ' ' || (unsigned)_c-'\t' < 5;
 800ebc8:	687b      	ldr	r3, [r7, #4]
 800ebca:	2b20      	cmp	r3, #32
 800ebcc:	d003      	beq.n	800ebd6 <__isspace+0x16>
 800ebce:	687b      	ldr	r3, [r7, #4]
 800ebd0:	3b09      	subs	r3, #9
 800ebd2:	2b04      	cmp	r3, #4
 800ebd4:	d801      	bhi.n	800ebda <__isspace+0x1a>
 800ebd6:	2301      	movs	r3, #1
 800ebd8:	e000      	b.n	800ebdc <__isspace+0x1c>
 800ebda:	2300      	movs	r3, #0
}
 800ebdc:	4618      	mov	r0, r3
 800ebde:	370c      	adds	r7, #12
 800ebe0:	46bd      	mov	sp, r7
 800ebe2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ebe6:	4770      	bx	lr

0800ebe8 <__intscan>:
-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
};

unsigned long long __intscan(FILE *f, unsigned base, int pok, unsigned long long lim)
{
 800ebe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ebec:	b0a5      	sub	sp, #148	; 0x94
 800ebee:	af00      	add	r7, sp, #0
 800ebf0:	66f8      	str	r0, [r7, #108]	; 0x6c
 800ebf2:	66b9      	str	r1, [r7, #104]	; 0x68
 800ebf4:	667a      	str	r2, [r7, #100]	; 0x64
	const unsigned char *val = table+1;
 800ebf6:	4ba0      	ldr	r3, [pc, #640]	; (800ee78 <__intscan+0x290>)
 800ebf8:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
	int c, neg=0;
 800ebfc:	2300      	movs	r3, #0
 800ebfe:	67bb      	str	r3, [r7, #120]	; 0x78
	unsigned x;
	unsigned long long y;
	if (base > 36 || base == 1) {
 800ec00:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ec02:	2b24      	cmp	r3, #36	; 0x24
 800ec04:	d802      	bhi.n	800ec0c <__intscan+0x24>
 800ec06:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ec08:	2b01      	cmp	r3, #1
 800ec0a:	d10b      	bne.n	800ec24 <__intscan+0x3c>
		errno = EINVAL;
 800ec0c:	f000 fc62 	bl	800f4d4 <__errno_location>
 800ec10:	4603      	mov	r3, r0
 800ec12:	2216      	movs	r2, #22
 800ec14:	601a      	str	r2, [r3, #0]
		return 0;
 800ec16:	f04f 0300 	mov.w	r3, #0
 800ec1a:	f04f 0400 	mov.w	r4, #0
 800ec1e:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
 800ec22:	e3b4      	b.n	800f38e <__intscan+0x7a6>
	}
	while (isspace((c=shgetc(f))));
 800ec24:	bf00      	nop
 800ec26:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ec28:	685a      	ldr	r2, [r3, #4]
 800ec2a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ec2c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ec2e:	429a      	cmp	r2, r3
 800ec30:	d006      	beq.n	800ec40 <__intscan+0x58>
 800ec32:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ec34:	6859      	ldr	r1, [r3, #4]
 800ec36:	1c4a      	adds	r2, r1, #1
 800ec38:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ec3a:	605a      	str	r2, [r3, #4]
 800ec3c:	780b      	ldrb	r3, [r1, #0]
 800ec3e:	e003      	b.n	800ec48 <__intscan+0x60>
 800ec40:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800ec42:	f000 fbd9 	bl	800f3f8 <__shgetc>
 800ec46:	4603      	mov	r3, r0
 800ec48:	677b      	str	r3, [r7, #116]	; 0x74
 800ec4a:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800ec4c:	f7ff ffb8 	bl	800ebc0 <__isspace>
 800ec50:	4603      	mov	r3, r0
 800ec52:	2b00      	cmp	r3, #0
 800ec54:	d1e7      	bne.n	800ec26 <__intscan+0x3e>
	if (c=='+' || c=='-') {
 800ec56:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ec58:	2b2b      	cmp	r3, #43	; 0x2b
 800ec5a:	d002      	beq.n	800ec62 <__intscan+0x7a>
 800ec5c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ec5e:	2b2d      	cmp	r3, #45	; 0x2d
 800ec60:	d119      	bne.n	800ec96 <__intscan+0xae>
		neg = -(c=='-');
 800ec62:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ec64:	2b2d      	cmp	r3, #45	; 0x2d
 800ec66:	bf0c      	ite	eq
 800ec68:	2301      	moveq	r3, #1
 800ec6a:	2300      	movne	r3, #0
 800ec6c:	b2db      	uxtb	r3, r3
 800ec6e:	425b      	negs	r3, r3
 800ec70:	67bb      	str	r3, [r7, #120]	; 0x78
		c = shgetc(f);
 800ec72:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ec74:	685a      	ldr	r2, [r3, #4]
 800ec76:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ec78:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ec7a:	429a      	cmp	r2, r3
 800ec7c:	d006      	beq.n	800ec8c <__intscan+0xa4>
 800ec7e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ec80:	6859      	ldr	r1, [r3, #4]
 800ec82:	1c4a      	adds	r2, r1, #1
 800ec84:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ec86:	605a      	str	r2, [r3, #4]
 800ec88:	780b      	ldrb	r3, [r1, #0]
 800ec8a:	e003      	b.n	800ec94 <__intscan+0xac>
 800ec8c:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800ec8e:	f000 fbb3 	bl	800f3f8 <__shgetc>
 800ec92:	4603      	mov	r3, r0
 800ec94:	677b      	str	r3, [r7, #116]	; 0x74
	}
	if ((base == 0 || base == 16) && c=='0') {
 800ec96:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ec98:	2b00      	cmp	r3, #0
 800ec9a:	d002      	beq.n	800eca2 <__intscan+0xba>
 800ec9c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ec9e:	2b10      	cmp	r3, #16
 800eca0:	d15c      	bne.n	800ed5c <__intscan+0x174>
 800eca2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800eca4:	2b30      	cmp	r3, #48	; 0x30
 800eca6:	d159      	bne.n	800ed5c <__intscan+0x174>
		c = shgetc(f);
 800eca8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ecaa:	685a      	ldr	r2, [r3, #4]
 800ecac:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ecae:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ecb0:	429a      	cmp	r2, r3
 800ecb2:	d006      	beq.n	800ecc2 <__intscan+0xda>
 800ecb4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ecb6:	6859      	ldr	r1, [r3, #4]
 800ecb8:	1c4a      	adds	r2, r1, #1
 800ecba:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ecbc:	605a      	str	r2, [r3, #4]
 800ecbe:	780b      	ldrb	r3, [r1, #0]
 800ecc0:	e003      	b.n	800ecca <__intscan+0xe2>
 800ecc2:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800ecc4:	f000 fb98 	bl	800f3f8 <__shgetc>
 800ecc8:	4603      	mov	r3, r0
 800ecca:	677b      	str	r3, [r7, #116]	; 0x74
		if ((c|32)=='x') {
 800eccc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ecce:	f043 0320 	orr.w	r3, r3, #32
 800ecd2:	2b78      	cmp	r3, #120	; 0x78
 800ecd4:	d13c      	bne.n	800ed50 <__intscan+0x168>
			c = shgetc(f);
 800ecd6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ecd8:	685a      	ldr	r2, [r3, #4]
 800ecda:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ecdc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ecde:	429a      	cmp	r2, r3
 800ece0:	d006      	beq.n	800ecf0 <__intscan+0x108>
 800ece2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ece4:	6859      	ldr	r1, [r3, #4]
 800ece6:	1c4a      	adds	r2, r1, #1
 800ece8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ecea:	605a      	str	r2, [r3, #4]
 800ecec:	780b      	ldrb	r3, [r1, #0]
 800ecee:	e003      	b.n	800ecf8 <__intscan+0x110>
 800ecf0:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800ecf2:	f000 fb81 	bl	800f3f8 <__shgetc>
 800ecf6:	4603      	mov	r3, r0
 800ecf8:	677b      	str	r3, [r7, #116]	; 0x74
			if (val[c]>=16) {
 800ecfa:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800ecfc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ed00:	4413      	add	r3, r2
 800ed02:	781b      	ldrb	r3, [r3, #0]
 800ed04:	2b0f      	cmp	r3, #15
 800ed06:	d920      	bls.n	800ed4a <__intscan+0x162>
				shunget(f);
 800ed08:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ed0a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ed0c:	2b00      	cmp	r3, #0
 800ed0e:	db04      	blt.n	800ed1a <__intscan+0x132>
 800ed10:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ed12:	685b      	ldr	r3, [r3, #4]
 800ed14:	1e5a      	subs	r2, r3, #1
 800ed16:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ed18:	605a      	str	r2, [r3, #4]
				if (pok) shunget(f);
 800ed1a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800ed1c:	2b00      	cmp	r3, #0
 800ed1e:	d009      	beq.n	800ed34 <__intscan+0x14c>
 800ed20:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ed22:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ed24:	2b00      	cmp	r3, #0
 800ed26:	db09      	blt.n	800ed3c <__intscan+0x154>
 800ed28:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ed2a:	685b      	ldr	r3, [r3, #4]
 800ed2c:	1e5a      	subs	r2, r3, #1
 800ed2e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ed30:	605a      	str	r2, [r3, #4]
 800ed32:	e003      	b.n	800ed3c <__intscan+0x154>
				else shlim(f, 0);
 800ed34:	2100      	movs	r1, #0
 800ed36:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800ed38:	f000 fb32 	bl	800f3a0 <__shlim>
				return 0;
 800ed3c:	f04f 0300 	mov.w	r3, #0
 800ed40:	f04f 0400 	mov.w	r4, #0
 800ed44:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
 800ed48:	e321      	b.n	800f38e <__intscan+0x7a6>
			}
			base = 16;
 800ed4a:	2310      	movs	r3, #16
 800ed4c:	66bb      	str	r3, [r7, #104]	; 0x68
		if ((c|32)=='x') {
 800ed4e:	e02c      	b.n	800edaa <__intscan+0x1c2>
		} else if (base == 0) {
 800ed50:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ed52:	2b00      	cmp	r3, #0
 800ed54:	d129      	bne.n	800edaa <__intscan+0x1c2>
			base = 8;
 800ed56:	2308      	movs	r3, #8
 800ed58:	66bb      	str	r3, [r7, #104]	; 0x68
		if ((c|32)=='x') {
 800ed5a:	e026      	b.n	800edaa <__intscan+0x1c2>
		}
	} else {
		if (base == 0) base = 10;
 800ed5c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ed5e:	2b00      	cmp	r3, #0
 800ed60:	d101      	bne.n	800ed66 <__intscan+0x17e>
 800ed62:	230a      	movs	r3, #10
 800ed64:	66bb      	str	r3, [r7, #104]	; 0x68
		if (val[c] >= base) {
 800ed66:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800ed68:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ed6c:	4413      	add	r3, r2
 800ed6e:	781b      	ldrb	r3, [r3, #0]
 800ed70:	461a      	mov	r2, r3
 800ed72:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ed74:	4293      	cmp	r3, r2
 800ed76:	d819      	bhi.n	800edac <__intscan+0x1c4>
			shunget(f);
 800ed78:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ed7a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ed7c:	2b00      	cmp	r3, #0
 800ed7e:	db04      	blt.n	800ed8a <__intscan+0x1a2>
 800ed80:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ed82:	685b      	ldr	r3, [r3, #4]
 800ed84:	1e5a      	subs	r2, r3, #1
 800ed86:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ed88:	605a      	str	r2, [r3, #4]
			shlim(f, 0);
 800ed8a:	2100      	movs	r1, #0
 800ed8c:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800ed8e:	f000 fb07 	bl	800f3a0 <__shlim>
			errno = EINVAL;
 800ed92:	f000 fb9f 	bl	800f4d4 <__errno_location>
 800ed96:	4603      	mov	r3, r0
 800ed98:	2216      	movs	r2, #22
 800ed9a:	601a      	str	r2, [r3, #0]
			return 0;
 800ed9c:	f04f 0300 	mov.w	r3, #0
 800eda0:	f04f 0400 	mov.w	r4, #0
 800eda4:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
 800eda8:	e2f1      	b.n	800f38e <__intscan+0x7a6>
		if ((c|32)=='x') {
 800edaa:	bf00      	nop
		}
	}
	if (base == 10) {
 800edac:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800edae:	2b0a      	cmp	r3, #10
 800edb0:	f040 80a6 	bne.w	800ef00 <__intscan+0x318>
		for (x=0; c-'0'<10U && x<=UINT_MAX/10-1; c=shgetc(f))
 800edb4:	2300      	movs	r3, #0
 800edb6:	67fb      	str	r3, [r7, #124]	; 0x7c
 800edb8:	e01b      	b.n	800edf2 <__intscan+0x20a>
			x = x*10 + (c-'0');
 800edba:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800edbc:	4613      	mov	r3, r2
 800edbe:	009b      	lsls	r3, r3, #2
 800edc0:	4413      	add	r3, r2
 800edc2:	005b      	lsls	r3, r3, #1
 800edc4:	461a      	mov	r2, r3
 800edc6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800edc8:	4413      	add	r3, r2
 800edca:	3b30      	subs	r3, #48	; 0x30
 800edcc:	67fb      	str	r3, [r7, #124]	; 0x7c
		for (x=0; c-'0'<10U && x<=UINT_MAX/10-1; c=shgetc(f))
 800edce:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800edd0:	685a      	ldr	r2, [r3, #4]
 800edd2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800edd4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800edd6:	429a      	cmp	r2, r3
 800edd8:	d006      	beq.n	800ede8 <__intscan+0x200>
 800edda:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800eddc:	6859      	ldr	r1, [r3, #4]
 800edde:	1c4a      	adds	r2, r1, #1
 800ede0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ede2:	605a      	str	r2, [r3, #4]
 800ede4:	780b      	ldrb	r3, [r1, #0]
 800ede6:	e003      	b.n	800edf0 <__intscan+0x208>
 800ede8:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800edea:	f000 fb05 	bl	800f3f8 <__shgetc>
 800edee:	4603      	mov	r3, r0
 800edf0:	677b      	str	r3, [r7, #116]	; 0x74
 800edf2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800edf4:	3b30      	subs	r3, #48	; 0x30
 800edf6:	2b09      	cmp	r3, #9
 800edf8:	d803      	bhi.n	800ee02 <__intscan+0x21a>
 800edfa:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800edfc:	4b1f      	ldr	r3, [pc, #124]	; (800ee7c <__intscan+0x294>)
 800edfe:	429a      	cmp	r2, r3
 800ee00:	d3db      	bcc.n	800edba <__intscan+0x1d2>
		for (y=x; c-'0'<10U && y<=ULLONG_MAX/10 && 10*y<=ULLONG_MAX-(c-'0'); c=shgetc(f))
 800ee02:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ee04:	461a      	mov	r2, r3
 800ee06:	f04f 0300 	mov.w	r3, #0
 800ee0a:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88
 800ee0e:	e03c      	b.n	800ee8a <__intscan+0x2a2>
			y = y*10 + (c-'0');
 800ee10:	e9d7 4522 	ldrd	r4, r5, [r7, #136]	; 0x88
 800ee14:	4622      	mov	r2, r4
 800ee16:	462b      	mov	r3, r5
 800ee18:	f04f 0000 	mov.w	r0, #0
 800ee1c:	f04f 0100 	mov.w	r1, #0
 800ee20:	0099      	lsls	r1, r3, #2
 800ee22:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 800ee26:	0090      	lsls	r0, r2, #2
 800ee28:	4602      	mov	r2, r0
 800ee2a:	460b      	mov	r3, r1
 800ee2c:	1912      	adds	r2, r2, r4
 800ee2e:	eb45 0303 	adc.w	r3, r5, r3
 800ee32:	1891      	adds	r1, r2, r2
 800ee34:	6239      	str	r1, [r7, #32]
 800ee36:	415b      	adcs	r3, r3
 800ee38:	627b      	str	r3, [r7, #36]	; 0x24
 800ee3a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800ee3e:	4610      	mov	r0, r2
 800ee40:	4619      	mov	r1, r3
 800ee42:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ee44:	3b30      	subs	r3, #48	; 0x30
 800ee46:	461a      	mov	r2, r3
 800ee48:	ea4f 73e2 	mov.w	r3, r2, asr #31
 800ee4c:	1884      	adds	r4, r0, r2
 800ee4e:	61bc      	str	r4, [r7, #24]
 800ee50:	eb41 0303 	adc.w	r3, r1, r3
 800ee54:	61fb      	str	r3, [r7, #28]
 800ee56:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 800ee5a:	e9c7 3422 	strd	r3, r4, [r7, #136]	; 0x88
		for (y=x; c-'0'<10U && y<=ULLONG_MAX/10 && 10*y<=ULLONG_MAX-(c-'0'); c=shgetc(f))
 800ee5e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ee60:	685a      	ldr	r2, [r3, #4]
 800ee62:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ee64:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ee66:	429a      	cmp	r2, r3
 800ee68:	d00a      	beq.n	800ee80 <__intscan+0x298>
 800ee6a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ee6c:	6859      	ldr	r1, [r3, #4]
 800ee6e:	1c4a      	adds	r2, r1, #1
 800ee70:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ee72:	605a      	str	r2, [r3, #4]
 800ee74:	780b      	ldrb	r3, [r1, #0]
 800ee76:	e007      	b.n	800ee88 <__intscan+0x2a0>
 800ee78:	080233c5 	.word	0x080233c5
 800ee7c:	19999999 	.word	0x19999999
 800ee80:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800ee82:	f000 fab9 	bl	800f3f8 <__shgetc>
 800ee86:	4603      	mov	r3, r0
 800ee88:	677b      	str	r3, [r7, #116]	; 0x74
 800ee8a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ee8c:	3b30      	subs	r3, #48	; 0x30
 800ee8e:	2b09      	cmp	r3, #9
 800ee90:	d830      	bhi.n	800eef4 <__intscan+0x30c>
 800ee92:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	; 0x88
 800ee96:	f04f 3299 	mov.w	r2, #2576980377	; 0x99999999
 800ee9a:	4bb5      	ldr	r3, [pc, #724]	; (800f170 <__intscan+0x588>)
 800ee9c:	428b      	cmp	r3, r1
 800ee9e:	bf08      	it	eq
 800eea0:	4282      	cmpeq	r2, r0
 800eea2:	d327      	bcc.n	800eef4 <__intscan+0x30c>
 800eea4:	e9d7 4522 	ldrd	r4, r5, [r7, #136]	; 0x88
 800eea8:	4622      	mov	r2, r4
 800eeaa:	462b      	mov	r3, r5
 800eeac:	f04f 0000 	mov.w	r0, #0
 800eeb0:	f04f 0100 	mov.w	r1, #0
 800eeb4:	0099      	lsls	r1, r3, #2
 800eeb6:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 800eeba:	0090      	lsls	r0, r2, #2
 800eebc:	4602      	mov	r2, r0
 800eebe:	460b      	mov	r3, r1
 800eec0:	1912      	adds	r2, r2, r4
 800eec2:	eb45 0303 	adc.w	r3, r5, r3
 800eec6:	1891      	adds	r1, r2, r2
 800eec8:	6139      	str	r1, [r7, #16]
 800eeca:	415b      	adcs	r3, r3
 800eecc:	617b      	str	r3, [r7, #20]
 800eece:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800eed2:	4610      	mov	r0, r2
 800eed4:	4619      	mov	r1, r3
 800eed6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800eed8:	3b30      	subs	r3, #48	; 0x30
 800eeda:	461a      	mov	r2, r3
 800eedc:	ea4f 73e2 	mov.w	r3, r2, asr #31
 800eee0:	43d4      	mvns	r4, r2
 800eee2:	64bc      	str	r4, [r7, #72]	; 0x48
 800eee4:	43db      	mvns	r3, r3
 800eee6:	64fb      	str	r3, [r7, #76]	; 0x4c
 800eee8:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
 800eeec:	428c      	cmp	r4, r1
 800eeee:	bf08      	it	eq
 800eef0:	4283      	cmpeq	r3, r0
 800eef2:	d28d      	bcs.n	800ee10 <__intscan+0x228>
		if (c-'0'>=10U) goto done;
 800eef4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800eef6:	3b30      	subs	r3, #48	; 0x30
 800eef8:	2b09      	cmp	r3, #9
 800eefa:	f240 81ac 	bls.w	800f256 <__intscan+0x66e>
 800eefe:	e1eb      	b.n	800f2d8 <__intscan+0x6f0>
	} else if (!(base & (base-1))) {
 800ef00:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ef02:	1e5a      	subs	r2, r3, #1
 800ef04:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ef06:	4013      	ands	r3, r2
 800ef08:	2b00      	cmp	r3, #0
 800ef0a:	f040 809d 	bne.w	800f048 <__intscan+0x460>
		int bs = "\0\1\2\4\7\3\6\5"[(0x17*base)>>5&7];
 800ef0e:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800ef10:	4613      	mov	r3, r2
 800ef12:	005b      	lsls	r3, r3, #1
 800ef14:	4413      	add	r3, r2
 800ef16:	00db      	lsls	r3, r3, #3
 800ef18:	1a9b      	subs	r3, r3, r2
 800ef1a:	095b      	lsrs	r3, r3, #5
 800ef1c:	f003 0207 	and.w	r2, r3, #7
 800ef20:	4b94      	ldr	r3, [pc, #592]	; (800f174 <__intscan+0x58c>)
 800ef22:	5c9b      	ldrb	r3, [r3, r2]
 800ef24:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
		for (x=0; val[c]<base && x<=UINT_MAX/32; c=shgetc(f))
 800ef28:	2300      	movs	r3, #0
 800ef2a:	67fb      	str	r3, [r7, #124]	; 0x7c
 800ef2c:	e01d      	b.n	800ef6a <__intscan+0x382>
			x = x<<bs | val[c];
 800ef2e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800ef30:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ef34:	fa02 f103 	lsl.w	r1, r2, r3
 800ef38:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800ef3a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ef3e:	4413      	add	r3, r2
 800ef40:	781b      	ldrb	r3, [r3, #0]
 800ef42:	430b      	orrs	r3, r1
 800ef44:	67fb      	str	r3, [r7, #124]	; 0x7c
		for (x=0; val[c]<base && x<=UINT_MAX/32; c=shgetc(f))
 800ef46:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ef48:	685a      	ldr	r2, [r3, #4]
 800ef4a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ef4c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ef4e:	429a      	cmp	r2, r3
 800ef50:	d006      	beq.n	800ef60 <__intscan+0x378>
 800ef52:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ef54:	6859      	ldr	r1, [r3, #4]
 800ef56:	1c4a      	adds	r2, r1, #1
 800ef58:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ef5a:	605a      	str	r2, [r3, #4]
 800ef5c:	780b      	ldrb	r3, [r1, #0]
 800ef5e:	e003      	b.n	800ef68 <__intscan+0x380>
 800ef60:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800ef62:	f000 fa49 	bl	800f3f8 <__shgetc>
 800ef66:	4603      	mov	r3, r0
 800ef68:	677b      	str	r3, [r7, #116]	; 0x74
 800ef6a:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800ef6c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ef70:	4413      	add	r3, r2
 800ef72:	781b      	ldrb	r3, [r3, #0]
 800ef74:	461a      	mov	r2, r3
 800ef76:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ef78:	4293      	cmp	r3, r2
 800ef7a:	d903      	bls.n	800ef84 <__intscan+0x39c>
 800ef7c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ef7e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800ef82:	d3d4      	bcc.n	800ef2e <__intscan+0x346>
		for (y=x; val[c]<base && y<=ULLONG_MAX>>bs; c=shgetc(f))
 800ef84:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ef86:	461a      	mov	r2, r3
 800ef88:	f04f 0300 	mov.w	r3, #0
 800ef8c:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88
 800ef90:	e033      	b.n	800effa <__intscan+0x412>
			y = y<<bs | val[c];
 800ef92:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800ef96:	f8d7 4084 	ldr.w	r4, [r7, #132]	; 0x84
 800ef9a:	f1a4 0120 	sub.w	r1, r4, #32
 800ef9e:	f1c4 0020 	rsb	r0, r4, #32
 800efa2:	fa03 f904 	lsl.w	r9, r3, r4
 800efa6:	fa02 f101 	lsl.w	r1, r2, r1
 800efaa:	ea49 0901 	orr.w	r9, r9, r1
 800efae:	fa22 f000 	lsr.w	r0, r2, r0
 800efb2:	ea49 0900 	orr.w	r9, r9, r0
 800efb6:	fa02 f804 	lsl.w	r8, r2, r4
 800efba:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800efbc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800efc0:	4413      	add	r3, r2
 800efc2:	781b      	ldrb	r3, [r3, #0]
 800efc4:	b2da      	uxtb	r2, r3
 800efc6:	f04f 0300 	mov.w	r3, #0
 800efca:	ea48 0502 	orr.w	r5, r8, r2
 800efce:	ea49 0603 	orr.w	r6, r9, r3
 800efd2:	e9c7 5622 	strd	r5, r6, [r7, #136]	; 0x88
		for (y=x; val[c]<base && y<=ULLONG_MAX>>bs; c=shgetc(f))
 800efd6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800efd8:	685a      	ldr	r2, [r3, #4]
 800efda:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800efdc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800efde:	429a      	cmp	r2, r3
 800efe0:	d006      	beq.n	800eff0 <__intscan+0x408>
 800efe2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800efe4:	6859      	ldr	r1, [r3, #4]
 800efe6:	1c4a      	adds	r2, r1, #1
 800efe8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800efea:	605a      	str	r2, [r3, #4]
 800efec:	780b      	ldrb	r3, [r1, #0]
 800efee:	e003      	b.n	800eff8 <__intscan+0x410>
 800eff0:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800eff2:	f000 fa01 	bl	800f3f8 <__shgetc>
 800eff6:	4603      	mov	r3, r0
 800eff8:	677b      	str	r3, [r7, #116]	; 0x74
 800effa:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800effc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f000:	4413      	add	r3, r2
 800f002:	781b      	ldrb	r3, [r3, #0]
 800f004:	461a      	mov	r2, r3
 800f006:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f008:	4293      	cmp	r3, r2
 800f00a:	f240 8124 	bls.w	800f256 <__intscan+0x66e>
 800f00e:	f04f 32ff 	mov.w	r2, #4294967295
 800f012:	f04f 33ff 	mov.w	r3, #4294967295
 800f016:	f8d7 4084 	ldr.w	r4, [r7, #132]	; 0x84
 800f01a:	f1c4 0120 	rsb	r1, r4, #32
 800f01e:	f1a4 0020 	sub.w	r0, r4, #32
 800f022:	fa22 fa04 	lsr.w	sl, r2, r4
 800f026:	fa03 f101 	lsl.w	r1, r3, r1
 800f02a:	ea4a 0a01 	orr.w	sl, sl, r1
 800f02e:	fa23 f000 	lsr.w	r0, r3, r0
 800f032:	ea4a 0a00 	orr.w	sl, sl, r0
 800f036:	fa23 fb04 	lsr.w	fp, r3, r4
 800f03a:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800f03e:	459b      	cmp	fp, r3
 800f040:	bf08      	it	eq
 800f042:	4592      	cmpeq	sl, r2
 800f044:	d2a5      	bcs.n	800ef92 <__intscan+0x3aa>
 800f046:	e106      	b.n	800f256 <__intscan+0x66e>
	} else {
		for (x=0; val[c]<base && x<=UINT_MAX/36-1; c=shgetc(f))
 800f048:	2300      	movs	r3, #0
 800f04a:	67fb      	str	r3, [r7, #124]	; 0x7c
 800f04c:	e01c      	b.n	800f088 <__intscan+0x4a0>
			x = x*base + val[c];
 800f04e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800f050:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f052:	fb03 f102 	mul.w	r1, r3, r2
 800f056:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800f058:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f05c:	4413      	add	r3, r2
 800f05e:	781b      	ldrb	r3, [r3, #0]
 800f060:	440b      	add	r3, r1
 800f062:	67fb      	str	r3, [r7, #124]	; 0x7c
		for (x=0; val[c]<base && x<=UINT_MAX/36-1; c=shgetc(f))
 800f064:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f066:	685a      	ldr	r2, [r3, #4]
 800f068:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f06a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f06c:	429a      	cmp	r2, r3
 800f06e:	d006      	beq.n	800f07e <__intscan+0x496>
 800f070:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f072:	6859      	ldr	r1, [r3, #4]
 800f074:	1c4a      	adds	r2, r1, #1
 800f076:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f078:	605a      	str	r2, [r3, #4]
 800f07a:	780b      	ldrb	r3, [r1, #0]
 800f07c:	e003      	b.n	800f086 <__intscan+0x49e>
 800f07e:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f080:	f000 f9ba 	bl	800f3f8 <__shgetc>
 800f084:	4603      	mov	r3, r0
 800f086:	677b      	str	r3, [r7, #116]	; 0x74
 800f088:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800f08a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f08e:	4413      	add	r3, r2
 800f090:	781b      	ldrb	r3, [r3, #0]
 800f092:	461a      	mov	r2, r3
 800f094:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f096:	4293      	cmp	r3, r2
 800f098:	d903      	bls.n	800f0a2 <__intscan+0x4ba>
 800f09a:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800f09c:	4b36      	ldr	r3, [pc, #216]	; (800f178 <__intscan+0x590>)
 800f09e:	429a      	cmp	r2, r3
 800f0a0:	d9d5      	bls.n	800f04e <__intscan+0x466>
		for (y=x; val[c]<base && y<=ULLONG_MAX/base && base*y<=ULLONG_MAX-val[c]; c=shgetc(f))
 800f0a2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800f0a4:	461a      	mov	r2, r3
 800f0a6:	f04f 0300 	mov.w	r3, #0
 800f0aa:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88
 800f0ae:	e035      	b.n	800f11c <__intscan+0x534>
			y = y*base + val[c];
 800f0b0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f0b2:	461a      	mov	r2, r3
 800f0b4:	f04f 0300 	mov.w	r3, #0
 800f0b8:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800f0bc:	fb03 f001 	mul.w	r0, r3, r1
 800f0c0:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 800f0c4:	fb02 f101 	mul.w	r1, r2, r1
 800f0c8:	1844      	adds	r4, r0, r1
 800f0ca:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800f0ce:	fba1 0102 	umull	r0, r1, r1, r2
 800f0d2:	1863      	adds	r3, r4, r1
 800f0d4:	4619      	mov	r1, r3
 800f0d6:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800f0d8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f0dc:	4413      	add	r3, r2
 800f0de:	781b      	ldrb	r3, [r3, #0]
 800f0e0:	b2da      	uxtb	r2, r3
 800f0e2:	f04f 0300 	mov.w	r3, #0
 800f0e6:	1884      	adds	r4, r0, r2
 800f0e8:	60bc      	str	r4, [r7, #8]
 800f0ea:	eb41 0303 	adc.w	r3, r1, r3
 800f0ee:	60fb      	str	r3, [r7, #12]
 800f0f0:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800f0f4:	e9c7 3422 	strd	r3, r4, [r7, #136]	; 0x88
		for (y=x; val[c]<base && y<=ULLONG_MAX/base && base*y<=ULLONG_MAX-val[c]; c=shgetc(f))
 800f0f8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f0fa:	685a      	ldr	r2, [r3, #4]
 800f0fc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f0fe:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f100:	429a      	cmp	r2, r3
 800f102:	d006      	beq.n	800f112 <__intscan+0x52a>
 800f104:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f106:	6859      	ldr	r1, [r3, #4]
 800f108:	1c4a      	adds	r2, r1, #1
 800f10a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f10c:	605a      	str	r2, [r3, #4]
 800f10e:	780b      	ldrb	r3, [r1, #0]
 800f110:	e003      	b.n	800f11a <__intscan+0x532>
 800f112:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f114:	f000 f970 	bl	800f3f8 <__shgetc>
 800f118:	4603      	mov	r3, r0
 800f11a:	677b      	str	r3, [r7, #116]	; 0x74
 800f11c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800f11e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f122:	4413      	add	r3, r2
 800f124:	781b      	ldrb	r3, [r3, #0]
 800f126:	461a      	mov	r2, r3
 800f128:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f12a:	4293      	cmp	r3, r2
 800f12c:	f240 8093 	bls.w	800f256 <__intscan+0x66e>
 800f130:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f132:	461c      	mov	r4, r3
 800f134:	f04f 0500 	mov.w	r5, #0
 800f138:	f04f 0a00 	mov.w	sl, #0
 800f13c:	f04f 0b00 	mov.w	fp, #0
 800f140:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800f144:	f04f 0000 	mov.w	r0, #0
 800f148:	f04f 0100 	mov.w	r1, #0
 800f14c:	0018      	movs	r0, r3
 800f14e:	2100      	movs	r1, #0
 800f150:	f04f 0200 	mov.w	r2, #0
 800f154:	f04f 0300 	mov.w	r3, #0
 800f158:	002a      	movs	r2, r5
 800f15a:	2300      	movs	r3, #0
 800f15c:	2800      	cmp	r0, #0
 800f15e:	d10d      	bne.n	800f17c <__intscan+0x594>
 800f160:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800f164:	fba3 2304 	umull	r2, r3, r3, r4
 800f168:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50
 800f16c:	e049      	b.n	800f202 <__intscan+0x61a>
 800f16e:	bf00      	nop
 800f170:	19999999 	.word	0x19999999
 800f174:	08021684 	.word	0x08021684
 800f178:	071c71c6 	.word	0x071c71c6
 800f17c:	4601      	mov	r1, r0
 800f17e:	4622      	mov	r2, r4
 800f180:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800f184:	fba3 8904 	umull	r8, r9, r3, r4
 800f188:	fba2 2301 	umull	r2, r3, r2, r1
 800f18c:	4610      	mov	r0, r2
 800f18e:	4619      	mov	r1, r3
 800f190:	f04f 0200 	mov.w	r2, #0
 800f194:	f04f 0300 	mov.w	r3, #0
 800f198:	464a      	mov	r2, r9
 800f19a:	2300      	movs	r3, #0
 800f19c:	1886      	adds	r6, r0, r2
 800f19e:	603e      	str	r6, [r7, #0]
 800f1a0:	eb41 0303 	adc.w	r3, r1, r3
 800f1a4:	607b      	str	r3, [r7, #4]
 800f1a6:	e9d7 0100 	ldrd	r0, r1, [r7]
 800f1aa:	f04f 0200 	mov.w	r2, #0
 800f1ae:	f04f 0300 	mov.w	r3, #0
 800f1b2:	000a      	movs	r2, r1
 800f1b4:	17cb      	asrs	r3, r1, #31
 800f1b6:	2a00      	cmp	r2, #0
 800f1b8:	d10e      	bne.n	800f1d8 <__intscan+0x5f0>
 800f1ba:	f04f 0400 	mov.w	r4, #0
 800f1be:	f04f 0500 	mov.w	r5, #0
 800f1c2:	0005      	movs	r5, r0
 800f1c4:	2400      	movs	r4, #0
 800f1c6:	4642      	mov	r2, r8
 800f1c8:	f04f 0300 	mov.w	r3, #0
 800f1cc:	ea44 0102 	orr.w	r1, r4, r2
 800f1d0:	6539      	str	r1, [r7, #80]	; 0x50
 800f1d2:	432b      	orrs	r3, r5
 800f1d4:	657b      	str	r3, [r7, #84]	; 0x54
 800f1d6:	e014      	b.n	800f202 <__intscan+0x61a>
 800f1d8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800f1dc:	fb05 f203 	mul.w	r2, r5, r3
 800f1e0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800f1e4:	fb04 f303 	mul.w	r3, r4, r3
 800f1e8:	18d1      	adds	r1, r2, r3
 800f1ea:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800f1ee:	fba3 2304 	umull	r2, r3, r3, r4
 800f1f2:	4419      	add	r1, r3
 800f1f4:	460b      	mov	r3, r1
 800f1f6:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50
 800f1fa:	f04f 0a01 	mov.w	sl, #1
 800f1fe:	f04f 0b00 	mov.w	fp, #0
 800f202:	4652      	mov	r2, sl
 800f204:	465b      	mov	r3, fp
 800f206:	4313      	orrs	r3, r2
 800f208:	d125      	bne.n	800f256 <__intscan+0x66e>
 800f20a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f20c:	461a      	mov	r2, r3
 800f20e:	f04f 0300 	mov.w	r3, #0
 800f212:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800f216:	fb03 f001 	mul.w	r0, r3, r1
 800f21a:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 800f21e:	fb02 f101 	mul.w	r1, r2, r1
 800f222:	4408      	add	r0, r1
 800f224:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800f228:	fba1 4502 	umull	r4, r5, r1, r2
 800f22c:	1943      	adds	r3, r0, r5
 800f22e:	461d      	mov	r5, r3
 800f230:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800f232:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f236:	4413      	add	r3, r2
 800f238:	781b      	ldrb	r3, [r3, #0]
 800f23a:	b2da      	uxtb	r2, r3
 800f23c:	f04f 0300 	mov.w	r3, #0
 800f240:	43d1      	mvns	r1, r2
 800f242:	6439      	str	r1, [r7, #64]	; 0x40
 800f244:	43db      	mvns	r3, r3
 800f246:	647b      	str	r3, [r7, #68]	; 0x44
 800f248:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800f24c:	42ab      	cmp	r3, r5
 800f24e:	bf08      	it	eq
 800f250:	42a2      	cmpeq	r2, r4
 800f252:	f4bf af2d 	bcs.w	800f0b0 <__intscan+0x4c8>
	}
	if (val[c]<base) {
 800f256:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f258:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800f25c:	4413      	add	r3, r2
 800f25e:	781b      	ldrb	r3, [r3, #0]
 800f260:	461a      	mov	r2, r3
 800f262:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f264:	4293      	cmp	r3, r2
 800f266:	d936      	bls.n	800f2d6 <__intscan+0x6ee>
		for (; val[c]<base; c=shgetc(f));
 800f268:	e011      	b.n	800f28e <__intscan+0x6a6>
 800f26a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f26c:	685a      	ldr	r2, [r3, #4]
 800f26e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f270:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f272:	429a      	cmp	r2, r3
 800f274:	d006      	beq.n	800f284 <__intscan+0x69c>
 800f276:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f278:	685b      	ldr	r3, [r3, #4]
 800f27a:	1c59      	adds	r1, r3, #1
 800f27c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800f27e:	6051      	str	r1, [r2, #4]
 800f280:	781b      	ldrb	r3, [r3, #0]
 800f282:	e003      	b.n	800f28c <__intscan+0x6a4>
 800f284:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f286:	f000 f8b7 	bl	800f3f8 <__shgetc>
 800f28a:	4603      	mov	r3, r0
 800f28c:	677b      	str	r3, [r7, #116]	; 0x74
 800f28e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f290:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800f294:	4413      	add	r3, r2
 800f296:	781b      	ldrb	r3, [r3, #0]
 800f298:	461a      	mov	r2, r3
 800f29a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f29c:	4293      	cmp	r3, r2
 800f29e:	d8e4      	bhi.n	800f26a <__intscan+0x682>
		errno = ERANGE;
 800f2a0:	f000 f918 	bl	800f4d4 <__errno_location>
 800f2a4:	4603      	mov	r3, r0
 800f2a6:	2222      	movs	r2, #34	; 0x22
 800f2a8:	601a      	str	r2, [r3, #0]
		y = lim;
 800f2aa:	e9d7 232e 	ldrd	r2, r3, [r7, #184]	; 0xb8
 800f2ae:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88
		if (lim&1) neg = 0;
 800f2b2:	e9d7 232e 	ldrd	r2, r3, [r7, #184]	; 0xb8
 800f2b6:	f04f 0001 	mov.w	r0, #1
 800f2ba:	f04f 0100 	mov.w	r1, #0
 800f2be:	ea02 0400 	and.w	r4, r2, r0
 800f2c2:	63bc      	str	r4, [r7, #56]	; 0x38
 800f2c4:	400b      	ands	r3, r1
 800f2c6:	63fb      	str	r3, [r7, #60]	; 0x3c
 800f2c8:	e9d7 340e 	ldrd	r3, r4, [r7, #56]	; 0x38
 800f2cc:	4323      	orrs	r3, r4
 800f2ce:	d002      	beq.n	800f2d6 <__intscan+0x6ee>
 800f2d0:	2300      	movs	r3, #0
 800f2d2:	67bb      	str	r3, [r7, #120]	; 0x78
 800f2d4:	e000      	b.n	800f2d8 <__intscan+0x6f0>
	}
done:
 800f2d6:	bf00      	nop
	shunget(f);
 800f2d8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f2da:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800f2dc:	2b00      	cmp	r3, #0
 800f2de:	db04      	blt.n	800f2ea <__intscan+0x702>
 800f2e0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f2e2:	685b      	ldr	r3, [r3, #4]
 800f2e4:	1e5a      	subs	r2, r3, #1
 800f2e6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f2e8:	605a      	str	r2, [r3, #4]
	if (y>=lim) {
 800f2ea:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	; 0x88
 800f2ee:	e9d7 232e 	ldrd	r2, r3, [r7, #184]	; 0xb8
 800f2f2:	4299      	cmp	r1, r3
 800f2f4:	bf08      	it	eq
 800f2f6:	4290      	cmpeq	r0, r2
 800f2f8:	d331      	bcc.n	800f35e <__intscan+0x776>
		if (!(lim&1) && !neg) {
 800f2fa:	e9d7 232e 	ldrd	r2, r3, [r7, #184]	; 0xb8
 800f2fe:	f04f 0001 	mov.w	r0, #1
 800f302:	f04f 0100 	mov.w	r1, #0
 800f306:	ea02 0400 	and.w	r4, r2, r0
 800f30a:	633c      	str	r4, [r7, #48]	; 0x30
 800f30c:	400b      	ands	r3, r1
 800f30e:	637b      	str	r3, [r7, #52]	; 0x34
 800f310:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
 800f314:	4323      	orrs	r3, r4
 800f316:	d110      	bne.n	800f33a <__intscan+0x752>
 800f318:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f31a:	2b00      	cmp	r3, #0
 800f31c:	d10d      	bne.n	800f33a <__intscan+0x752>
			errno = ERANGE;
 800f31e:	f000 f8d9 	bl	800f4d4 <__errno_location>
 800f322:	4603      	mov	r3, r0
 800f324:	2222      	movs	r2, #34	; 0x22
 800f326:	601a      	str	r2, [r3, #0]
			return lim-1;
 800f328:	e9d7 232e 	ldrd	r2, r3, [r7, #184]	; 0xb8
 800f32c:	f112 31ff 	adds.w	r1, r2, #4294967295
 800f330:	65b9      	str	r1, [r7, #88]	; 0x58
 800f332:	f143 33ff 	adc.w	r3, r3, #4294967295
 800f336:	65fb      	str	r3, [r7, #92]	; 0x5c
 800f338:	e029      	b.n	800f38e <__intscan+0x7a6>
		} else if (y>lim) {
 800f33a:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800f33e:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	; 0xb8
 800f342:	4299      	cmp	r1, r3
 800f344:	bf08      	it	eq
 800f346:	4290      	cmpeq	r0, r2
 800f348:	d209      	bcs.n	800f35e <__intscan+0x776>
			errno = ERANGE;
 800f34a:	f000 f8c3 	bl	800f4d4 <__errno_location>
 800f34e:	4603      	mov	r3, r0
 800f350:	2222      	movs	r2, #34	; 0x22
 800f352:	601a      	str	r2, [r3, #0]
			return lim;
 800f354:	e9d7 342e 	ldrd	r3, r4, [r7, #184]	; 0xb8
 800f358:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
 800f35c:	e017      	b.n	800f38e <__intscan+0x7a6>
		}
	}
	return (y^neg)-neg;
 800f35e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f360:	4618      	mov	r0, r3
 800f362:	ea4f 71e0 	mov.w	r1, r0, asr #31
 800f366:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800f36a:	ea80 0402 	eor.w	r4, r0, r2
 800f36e:	62bc      	str	r4, [r7, #40]	; 0x28
 800f370:	404b      	eors	r3, r1
 800f372:	62fb      	str	r3, [r7, #44]	; 0x2c
 800f374:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800f376:	461a      	mov	r2, r3
 800f378:	ea4f 73e2 	mov.w	r3, r2, asr #31
 800f37c:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	; 0x28
 800f380:	4621      	mov	r1, r4
 800f382:	1a89      	subs	r1, r1, r2
 800f384:	65b9      	str	r1, [r7, #88]	; 0x58
 800f386:	4629      	mov	r1, r5
 800f388:	eb61 0303 	sbc.w	r3, r1, r3
 800f38c:	65fb      	str	r3, [r7, #92]	; 0x5c
 800f38e:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
}
 800f392:	4610      	mov	r0, r2
 800f394:	4619      	mov	r1, r3
 800f396:	3794      	adds	r7, #148	; 0x94
 800f398:	46bd      	mov	sp, r7
 800f39a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f39e:	bf00      	nop

0800f3a0 <__shlim>:
 * the value of buf-rpos at the last function call (__shlim or __shgetc),
 * so that between calls the inline shcnt macro can add rpos-buf to get
 * the actual count. */

void __shlim(FILE *f, off_t lim)
{
 800f3a0:	b480      	push	{r7}
 800f3a2:	b083      	sub	sp, #12
 800f3a4:	af00      	add	r7, sp, #0
 800f3a6:	6078      	str	r0, [r7, #4]
 800f3a8:	6039      	str	r1, [r7, #0]
	f->shlim = lim;
 800f3aa:	687b      	ldr	r3, [r7, #4]
 800f3ac:	683a      	ldr	r2, [r7, #0]
 800f3ae:	66da      	str	r2, [r3, #108]	; 0x6c
	f->shcnt = f->buf - f->rpos;
 800f3b0:	687b      	ldr	r3, [r7, #4]
 800f3b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800f3b4:	687b      	ldr	r3, [r7, #4]
 800f3b6:	685b      	ldr	r3, [r3, #4]
 800f3b8:	1ad2      	subs	r2, r2, r3
 800f3ba:	687b      	ldr	r3, [r7, #4]
 800f3bc:	671a      	str	r2, [r3, #112]	; 0x70
	/* If lim is nonzero, rend must be a valid pointer. */
	if (lim && f->rend - f->rpos > lim)
 800f3be:	683b      	ldr	r3, [r7, #0]
 800f3c0:	2b00      	cmp	r3, #0
 800f3c2:	d00e      	beq.n	800f3e2 <__shlim+0x42>
 800f3c4:	687b      	ldr	r3, [r7, #4]
 800f3c6:	689a      	ldr	r2, [r3, #8]
 800f3c8:	687b      	ldr	r3, [r7, #4]
 800f3ca:	685b      	ldr	r3, [r3, #4]
 800f3cc:	1ad3      	subs	r3, r2, r3
 800f3ce:	683a      	ldr	r2, [r7, #0]
 800f3d0:	429a      	cmp	r2, r3
 800f3d2:	da06      	bge.n	800f3e2 <__shlim+0x42>
		f->shend = f->rpos + lim;
 800f3d4:	687b      	ldr	r3, [r7, #4]
 800f3d6:	685a      	ldr	r2, [r3, #4]
 800f3d8:	683b      	ldr	r3, [r7, #0]
 800f3da:	441a      	add	r2, r3
 800f3dc:	687b      	ldr	r3, [r7, #4]
 800f3de:	669a      	str	r2, [r3, #104]	; 0x68
 800f3e0:	e004      	b.n	800f3ec <__shlim+0x4c>
	else
		f->shend = f->rend;
 800f3e2:	687b      	ldr	r3, [r7, #4]
 800f3e4:	689a      	ldr	r2, [r3, #8]
 800f3e6:	687b      	ldr	r3, [r7, #4]
 800f3e8:	669a      	str	r2, [r3, #104]	; 0x68
}
 800f3ea:	bf00      	nop
 800f3ec:	bf00      	nop
 800f3ee:	370c      	adds	r7, #12
 800f3f0:	46bd      	mov	sp, r7
 800f3f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3f6:	4770      	bx	lr

0800f3f8 <__shgetc>:

int __shgetc(FILE *f)
{
 800f3f8:	b580      	push	{r7, lr}
 800f3fa:	b084      	sub	sp, #16
 800f3fc:	af00      	add	r7, sp, #0
 800f3fe:	6078      	str	r0, [r7, #4]
	int c;
	off_t cnt = shcnt(f);
 800f400:	687b      	ldr	r3, [r7, #4]
 800f402:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800f404:	687b      	ldr	r3, [r7, #4]
 800f406:	6859      	ldr	r1, [r3, #4]
 800f408:	687b      	ldr	r3, [r7, #4]
 800f40a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f40c:	1acb      	subs	r3, r1, r3
 800f40e:	4413      	add	r3, r2
 800f410:	60bb      	str	r3, [r7, #8]
	if ((f->shlim && cnt >= f->shlim) || (c=__uflow(f)) < 0) {
 800f412:	687b      	ldr	r3, [r7, #4]
 800f414:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800f416:	2b00      	cmp	r3, #0
 800f418:	d004      	beq.n	800f424 <__shgetc+0x2c>
 800f41a:	687b      	ldr	r3, [r7, #4]
 800f41c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800f41e:	68ba      	ldr	r2, [r7, #8]
 800f420:	429a      	cmp	r2, r3
 800f422:	da06      	bge.n	800f432 <__shgetc+0x3a>
 800f424:	6878      	ldr	r0, [r7, #4]
 800f426:	f000 f86b 	bl	800f500 <__uflow>
 800f42a:	60f8      	str	r0, [r7, #12]
 800f42c:	68fb      	ldr	r3, [r7, #12]
 800f42e:	2b00      	cmp	r3, #0
 800f430:	da13      	bge.n	800f45a <__shgetc+0x62>
		f->shcnt = f->buf - f->rpos + cnt;
 800f432:	687b      	ldr	r3, [r7, #4]
 800f434:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800f436:	687b      	ldr	r3, [r7, #4]
 800f438:	685b      	ldr	r3, [r3, #4]
 800f43a:	1ad2      	subs	r2, r2, r3
 800f43c:	68bb      	ldr	r3, [r7, #8]
 800f43e:	441a      	add	r2, r3
 800f440:	687b      	ldr	r3, [r7, #4]
 800f442:	671a      	str	r2, [r3, #112]	; 0x70
		f->shend = f->rpos;
 800f444:	687b      	ldr	r3, [r7, #4]
 800f446:	685a      	ldr	r2, [r3, #4]
 800f448:	687b      	ldr	r3, [r7, #4]
 800f44a:	669a      	str	r2, [r3, #104]	; 0x68
		f->shlim = -1;
 800f44c:	687b      	ldr	r3, [r7, #4]
 800f44e:	f04f 32ff 	mov.w	r2, #4294967295
 800f452:	66da      	str	r2, [r3, #108]	; 0x6c
		return EOF;
 800f454:	f04f 33ff 	mov.w	r3, #4294967295
 800f458:	e037      	b.n	800f4ca <__shgetc+0xd2>
	}
	cnt++;
 800f45a:	68bb      	ldr	r3, [r7, #8]
 800f45c:	3301      	adds	r3, #1
 800f45e:	60bb      	str	r3, [r7, #8]
	if (f->shlim && f->rend - f->rpos > f->shlim - cnt)
 800f460:	687b      	ldr	r3, [r7, #4]
 800f462:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800f464:	2b00      	cmp	r3, #0
 800f466:	d014      	beq.n	800f492 <__shgetc+0x9a>
 800f468:	687b      	ldr	r3, [r7, #4]
 800f46a:	689a      	ldr	r2, [r3, #8]
 800f46c:	687b      	ldr	r3, [r7, #4]
 800f46e:	685b      	ldr	r3, [r3, #4]
 800f470:	1ad2      	subs	r2, r2, r3
 800f472:	687b      	ldr	r3, [r7, #4]
 800f474:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800f476:	68bb      	ldr	r3, [r7, #8]
 800f478:	1acb      	subs	r3, r1, r3
 800f47a:	429a      	cmp	r2, r3
 800f47c:	dd09      	ble.n	800f492 <__shgetc+0x9a>
		f->shend = f->rpos + (f->shlim - cnt);
 800f47e:	687b      	ldr	r3, [r7, #4]
 800f480:	685b      	ldr	r3, [r3, #4]
 800f482:	687a      	ldr	r2, [r7, #4]
 800f484:	6ed1      	ldr	r1, [r2, #108]	; 0x6c
 800f486:	68ba      	ldr	r2, [r7, #8]
 800f488:	1a8a      	subs	r2, r1, r2
 800f48a:	441a      	add	r2, r3
 800f48c:	687b      	ldr	r3, [r7, #4]
 800f48e:	669a      	str	r2, [r3, #104]	; 0x68
 800f490:	e003      	b.n	800f49a <__shgetc+0xa2>
	else
		f->shend = f->rend;
 800f492:	687b      	ldr	r3, [r7, #4]
 800f494:	689a      	ldr	r2, [r3, #8]
 800f496:	687b      	ldr	r3, [r7, #4]
 800f498:	669a      	str	r2, [r3, #104]	; 0x68
	f->shcnt = f->buf - f->rpos + cnt;
 800f49a:	687b      	ldr	r3, [r7, #4]
 800f49c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800f49e:	687b      	ldr	r3, [r7, #4]
 800f4a0:	685b      	ldr	r3, [r3, #4]
 800f4a2:	1ad2      	subs	r2, r2, r3
 800f4a4:	68bb      	ldr	r3, [r7, #8]
 800f4a6:	441a      	add	r2, r3
 800f4a8:	687b      	ldr	r3, [r7, #4]
 800f4aa:	671a      	str	r2, [r3, #112]	; 0x70
	if (f->rpos[-1] != c) f->rpos[-1] = c;
 800f4ac:	687b      	ldr	r3, [r7, #4]
 800f4ae:	685b      	ldr	r3, [r3, #4]
 800f4b0:	3b01      	subs	r3, #1
 800f4b2:	781b      	ldrb	r3, [r3, #0]
 800f4b4:	461a      	mov	r2, r3
 800f4b6:	68fb      	ldr	r3, [r7, #12]
 800f4b8:	4293      	cmp	r3, r2
 800f4ba:	d005      	beq.n	800f4c8 <__shgetc+0xd0>
 800f4bc:	687b      	ldr	r3, [r7, #4]
 800f4be:	685b      	ldr	r3, [r3, #4]
 800f4c0:	3b01      	subs	r3, #1
 800f4c2:	68fa      	ldr	r2, [r7, #12]
 800f4c4:	b2d2      	uxtb	r2, r2
 800f4c6:	701a      	strb	r2, [r3, #0]
	return c;
 800f4c8:	68fb      	ldr	r3, [r7, #12]
}
 800f4ca:	4618      	mov	r0, r3
 800f4cc:	3710      	adds	r7, #16
 800f4ce:	46bd      	mov	sp, r7
 800f4d0:	bd80      	pop	{r7, pc}
	...

0800f4d4 <__errno_location>:
        return g_errnoIsr;
    }
}

int *__errno_location(void)
{
 800f4d4:	b580      	push	{r7, lr}
 800f4d6:	af00      	add	r7, sp, #0
    if (OS_INT_INACTIVE) {
 800f4d8:	f7f2 ffc8 	bl	800246c <IntActive>
 800f4dc:	4603      	mov	r3, r0
 800f4de:	2b00      	cmp	r3, #0
 800f4e0:	d106      	bne.n	800f4f0 <__errno_location+0x1c>
        return &g_errnoArray[LOS_CurTaskIDGet()];
 800f4e2:	f7f3 fd8f 	bl	8003004 <LOS_CurTaskIDGet>
 800f4e6:	4603      	mov	r3, r0
 800f4e8:	009b      	lsls	r3, r3, #2
 800f4ea:	4a03      	ldr	r2, [pc, #12]	; (800f4f8 <__errno_location+0x24>)
 800f4ec:	4413      	add	r3, r2
 800f4ee:	e000      	b.n	800f4f2 <__errno_location+0x1e>
    } else {
        return &g_errnoIsr;
 800f4f0:	4b02      	ldr	r3, [pc, #8]	; (800f4fc <__errno_location+0x28>)
    }
}
 800f4f2:	4618      	mov	r0, r3
 800f4f4:	bd80      	pop	{r7, pc}
 800f4f6:	bf00      	nop
 800f4f8:	20003720 	.word	0x20003720
 800f4fc:	20002278 	.word	0x20002278

0800f500 <__uflow>:

/* This function assumes it will never be called if there is already
 * data buffered for reading. */

int __uflow(FILE *f)
{
 800f500:	b580      	push	{r7, lr}
 800f502:	b084      	sub	sp, #16
 800f504:	af00      	add	r7, sp, #0
 800f506:	6078      	str	r0, [r7, #4]
 800f508:	4b11      	ldr	r3, [pc, #68]	; (800f550 <__uflow+0x50>)
 800f50a:	681b      	ldr	r3, [r3, #0]
 800f50c:	60fb      	str	r3, [r7, #12]
 800f50e:	f04f 0300 	mov.w	r3, #0
	unsigned char c;
	if (!__toread(f) && f->read(f, &c, 1)==1) return c;
 800f512:	6878      	ldr	r0, [r7, #4]
 800f514:	f000 f81e 	bl	800f554 <__toread>
 800f518:	4603      	mov	r3, r0
 800f51a:	2b00      	cmp	r3, #0
 800f51c:	d10b      	bne.n	800f536 <__uflow+0x36>
 800f51e:	687b      	ldr	r3, [r7, #4]
 800f520:	6a1b      	ldr	r3, [r3, #32]
 800f522:	f107 010b 	add.w	r1, r7, #11
 800f526:	2201      	movs	r2, #1
 800f528:	6878      	ldr	r0, [r7, #4]
 800f52a:	4798      	blx	r3
 800f52c:	4603      	mov	r3, r0
 800f52e:	2b01      	cmp	r3, #1
 800f530:	d101      	bne.n	800f536 <__uflow+0x36>
 800f532:	7afb      	ldrb	r3, [r7, #11]
 800f534:	e001      	b.n	800f53a <__uflow+0x3a>
	return EOF;
 800f536:	f04f 33ff 	mov.w	r3, #4294967295
}
 800f53a:	4a05      	ldr	r2, [pc, #20]	; (800f550 <__uflow+0x50>)
 800f53c:	6811      	ldr	r1, [r2, #0]
 800f53e:	68fa      	ldr	r2, [r7, #12]
 800f540:	4051      	eors	r1, r2
 800f542:	d001      	beq.n	800f548 <__uflow+0x48>
 800f544:	f7f4 ff50 	bl	80043e8 <__stack_chk_fail>
 800f548:	4618      	mov	r0, r3
 800f54a:	3710      	adds	r7, #16
 800f54c:	46bd      	mov	sp, r7
 800f54e:	bd80      	pop	{r7, pc}
 800f550:	08021690 	.word	0x08021690

0800f554 <__toread>:
#include <stdio_impl.h>

int __toread(FILE *f)
{
 800f554:	b580      	push	{r7, lr}
 800f556:	b082      	sub	sp, #8
 800f558:	af00      	add	r7, sp, #0
 800f55a:	6078      	str	r0, [r7, #4]
	f->mode |= f->mode-1;
 800f55c:	687b      	ldr	r3, [r7, #4]
 800f55e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f560:	687b      	ldr	r3, [r7, #4]
 800f562:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800f564:	3b01      	subs	r3, #1
 800f566:	431a      	orrs	r2, r3
 800f568:	687b      	ldr	r3, [r7, #4]
 800f56a:	64da      	str	r2, [r3, #76]	; 0x4c
	if (f->wpos != f->wbase) f->write(f, 0, 0);
 800f56c:	687b      	ldr	r3, [r7, #4]
 800f56e:	695a      	ldr	r2, [r3, #20]
 800f570:	687b      	ldr	r3, [r7, #4]
 800f572:	69db      	ldr	r3, [r3, #28]
 800f574:	429a      	cmp	r2, r3
 800f576:	d005      	beq.n	800f584 <__toread+0x30>
 800f578:	687b      	ldr	r3, [r7, #4]
 800f57a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f57c:	2200      	movs	r2, #0
 800f57e:	2100      	movs	r1, #0
 800f580:	6878      	ldr	r0, [r7, #4]
 800f582:	4798      	blx	r3
	f->wpos = f->wbase = f->wend = 0;
 800f584:	687b      	ldr	r3, [r7, #4]
 800f586:	2200      	movs	r2, #0
 800f588:	611a      	str	r2, [r3, #16]
 800f58a:	687b      	ldr	r3, [r7, #4]
 800f58c:	691a      	ldr	r2, [r3, #16]
 800f58e:	687b      	ldr	r3, [r7, #4]
 800f590:	61da      	str	r2, [r3, #28]
 800f592:	687b      	ldr	r3, [r7, #4]
 800f594:	69da      	ldr	r2, [r3, #28]
 800f596:	687b      	ldr	r3, [r7, #4]
 800f598:	615a      	str	r2, [r3, #20]
	if (f->flags & F_NORD) {
 800f59a:	687b      	ldr	r3, [r7, #4]
 800f59c:	681b      	ldr	r3, [r3, #0]
 800f59e:	f003 0304 	and.w	r3, r3, #4
 800f5a2:	2b00      	cmp	r3, #0
 800f5a4:	d008      	beq.n	800f5b8 <__toread+0x64>
		f->flags |= F_ERR;
 800f5a6:	687b      	ldr	r3, [r7, #4]
 800f5a8:	681b      	ldr	r3, [r3, #0]
 800f5aa:	f043 0220 	orr.w	r2, r3, #32
 800f5ae:	687b      	ldr	r3, [r7, #4]
 800f5b0:	601a      	str	r2, [r3, #0]
		return EOF;
 800f5b2:	f04f 33ff 	mov.w	r3, #4294967295
 800f5b6:	e01d      	b.n	800f5f4 <__toread+0xa0>
	}
#ifdef __LITEOS__
	if (f->flags & F_CLS) {
 800f5b8:	687b      	ldr	r3, [r7, #4]
 800f5ba:	681b      	ldr	r3, [r3, #0]
 800f5bc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800f5c0:	2b00      	cmp	r3, #0
 800f5c2:	d002      	beq.n	800f5ca <__toread+0x76>
		return EOF;
 800f5c4:	f04f 33ff 	mov.w	r3, #4294967295
 800f5c8:	e014      	b.n	800f5f4 <__toread+0xa0>
	}
#endif
	f->rpos = f->rend = f->buf + f->buf_size;
 800f5ca:	687b      	ldr	r3, [r7, #4]
 800f5cc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800f5ce:	687b      	ldr	r3, [r7, #4]
 800f5d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f5d2:	441a      	add	r2, r3
 800f5d4:	687b      	ldr	r3, [r7, #4]
 800f5d6:	609a      	str	r2, [r3, #8]
 800f5d8:	687b      	ldr	r3, [r7, #4]
 800f5da:	689a      	ldr	r2, [r3, #8]
 800f5dc:	687b      	ldr	r3, [r7, #4]
 800f5de:	605a      	str	r2, [r3, #4]
	return (f->flags & F_EOF) ? EOF : 0;
 800f5e0:	687b      	ldr	r3, [r7, #4]
 800f5e2:	681b      	ldr	r3, [r3, #0]
 800f5e4:	f003 0310 	and.w	r3, r3, #16
 800f5e8:	2b00      	cmp	r3, #0
 800f5ea:	d002      	beq.n	800f5f2 <__toread+0x9e>
 800f5ec:	f04f 33ff 	mov.w	r3, #4294967295
 800f5f0:	e000      	b.n	800f5f4 <__toread+0xa0>
 800f5f2:	2300      	movs	r3, #0
}
 800f5f4:	4618      	mov	r0, r3
 800f5f6:	3708      	adds	r7, #8
 800f5f8:	46bd      	mov	sp, r7
 800f5fa:	bd80      	pop	{r7, pc}

0800f5fc <printf>:
#include <stdio.h>
#include <stdarg.h>
#include "los_printf_pri.h"

int printf(const char *restrict fmt, ...)
{
 800f5fc:	b40f      	push	{r0, r1, r2, r3}
 800f5fe:	b580      	push	{r7, lr}
 800f600:	b086      	sub	sp, #24
 800f602:	af00      	add	r7, sp, #0
 800f604:	6a3b      	ldr	r3, [r7, #32]
 800f606:	607b      	str	r3, [r7, #4]
 800f608:	4b0e      	ldr	r3, [pc, #56]	; (800f644 <printf+0x48>)
 800f60a:	681b      	ldr	r3, [r3, #0]
 800f60c:	617b      	str	r3, [r7, #20]
 800f60e:	f04f 0300 	mov.w	r3, #0
	int ret = 0;
 800f612:	2300      	movs	r3, #0
 800f614:	613b      	str	r3, [r7, #16]
	va_list ap;
	va_start(ap, fmt);
 800f616:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800f61a:	60fb      	str	r3, [r7, #12]
#if defined(LOSCFG_FS_VFS)
	ret = vfprintf(stdout, fmt, ap);
#elif defined(LOSCFG_DRIVERS_UART) || defined(LOSCFG_DRIVERS_SIMPLE_UART)
	UartVprintf(fmt, ap);
 800f61c:	68f9      	ldr	r1, [r7, #12]
 800f61e:	6878      	ldr	r0, [r7, #4]
 800f620:	f7f5 f846 	bl	80046b0 <UartVprintf>
#else
	ret = -1;
#endif
	va_end(ap);
	return ret;
 800f624:	693b      	ldr	r3, [r7, #16]
}
 800f626:	4a07      	ldr	r2, [pc, #28]	; (800f644 <printf+0x48>)
 800f628:	6811      	ldr	r1, [r2, #0]
 800f62a:	697a      	ldr	r2, [r7, #20]
 800f62c:	4051      	eors	r1, r2
 800f62e:	d001      	beq.n	800f634 <printf+0x38>
 800f630:	f7f4 feda 	bl	80043e8 <__stack_chk_fail>
 800f634:	4618      	mov	r0, r3
 800f636:	3718      	adds	r7, #24
 800f638:	46bd      	mov	sp, r7
 800f63a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800f63e:	b004      	add	sp, #16
 800f640:	4770      	bx	lr
 800f642:	bf00      	nop
 800f644:	08021694 	.word	0x08021694

0800f648 <__NVIC_SetPriorityGrouping>:
{
 800f648:	b480      	push	{r7}
 800f64a:	b085      	sub	sp, #20
 800f64c:	af00      	add	r7, sp, #0
 800f64e:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800f650:	687b      	ldr	r3, [r7, #4]
 800f652:	f003 0307 	and.w	r3, r3, #7
 800f656:	60bb      	str	r3, [r7, #8]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800f658:	4b0b      	ldr	r3, [pc, #44]	; (800f688 <__NVIC_SetPriorityGrouping+0x40>)
 800f65a:	68db      	ldr	r3, [r3, #12]
 800f65c:	60fb      	str	r3, [r7, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800f65e:	68fa      	ldr	r2, [r7, #12]
 800f660:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800f664:	4013      	ands	r3, r2
 800f666:	60fb      	str	r3, [r7, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800f668:	68bb      	ldr	r3, [r7, #8]
 800f66a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800f66c:	68fb      	ldr	r3, [r7, #12]
 800f66e:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
 800f670:	4b06      	ldr	r3, [pc, #24]	; (800f68c <__NVIC_SetPriorityGrouping+0x44>)
 800f672:	4313      	orrs	r3, r2
 800f674:	60fb      	str	r3, [r7, #12]
  SCB->AIRCR =  reg_value;
 800f676:	4a04      	ldr	r2, [pc, #16]	; (800f688 <__NVIC_SetPriorityGrouping+0x40>)
 800f678:	68fb      	ldr	r3, [r7, #12]
 800f67a:	60d3      	str	r3, [r2, #12]
}
 800f67c:	bf00      	nop
 800f67e:	3714      	adds	r7, #20
 800f680:	46bd      	mov	sp, r7
 800f682:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f686:	4770      	bx	lr
 800f688:	e000ed00 	.word	0xe000ed00
 800f68c:	05fa0000 	.word	0x05fa0000

0800f690 <__NVIC_EnableIRQ>:
{
 800f690:	b480      	push	{r7}
 800f692:	b083      	sub	sp, #12
 800f694:	af00      	add	r7, sp, #0
 800f696:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 800f698:	687b      	ldr	r3, [r7, #4]
 800f69a:	2b00      	cmp	r3, #0
 800f69c:	db0a      	blt.n	800f6b4 <__NVIC_EnableIRQ+0x24>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f69e:	687b      	ldr	r3, [r7, #4]
 800f6a0:	f003 021f 	and.w	r2, r3, #31
 800f6a4:	4906      	ldr	r1, [pc, #24]	; (800f6c0 <__NVIC_EnableIRQ+0x30>)
 800f6a6:	687b      	ldr	r3, [r7, #4]
 800f6a8:	095b      	lsrs	r3, r3, #5
 800f6aa:	2001      	movs	r0, #1
 800f6ac:	fa00 f202 	lsl.w	r2, r0, r2
 800f6b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800f6b4:	bf00      	nop
 800f6b6:	370c      	adds	r7, #12
 800f6b8:	46bd      	mov	sp, r7
 800f6ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6be:	4770      	bx	lr
 800f6c0:	e000e100 	.word	0xe000e100

0800f6c4 <__NVIC_DisableIRQ>:
{
 800f6c4:	b480      	push	{r7}
 800f6c6:	b083      	sub	sp, #12
 800f6c8:	af00      	add	r7, sp, #0
 800f6ca:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 800f6cc:	687b      	ldr	r3, [r7, #4]
 800f6ce:	2b00      	cmp	r3, #0
 800f6d0:	db11      	blt.n	800f6f6 <__NVIC_DisableIRQ+0x32>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f6d2:	687b      	ldr	r3, [r7, #4]
 800f6d4:	f003 021f 	and.w	r2, r3, #31
 800f6d8:	490a      	ldr	r1, [pc, #40]	; (800f704 <__NVIC_DisableIRQ+0x40>)
 800f6da:	687b      	ldr	r3, [r7, #4]
 800f6dc:	095b      	lsrs	r3, r3, #5
 800f6de:	2001      	movs	r0, #1
 800f6e0:	fa00 f202 	lsl.w	r2, r0, r2
 800f6e4:	3320      	adds	r3, #32
 800f6e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 800f6ea:	f3bf 8f4f 	dsb	sy
}
 800f6ee:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800f6f0:	f3bf 8f6f 	isb	sy
}
 800f6f4:	bf00      	nop
}
 800f6f6:	bf00      	nop
 800f6f8:	370c      	adds	r7, #12
 800f6fa:	46bd      	mov	sp, r7
 800f6fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f700:	4770      	bx	lr
 800f702:	bf00      	nop
 800f704:	e000e100 	.word	0xe000e100

0800f708 <__NVIC_SetPendingIRQ>:
{
 800f708:	b480      	push	{r7}
 800f70a:	b083      	sub	sp, #12
 800f70c:	af00      	add	r7, sp, #0
 800f70e:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 800f710:	687b      	ldr	r3, [r7, #4]
 800f712:	2b00      	cmp	r3, #0
 800f714:	db0b      	blt.n	800f72e <__NVIC_SetPendingIRQ+0x26>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f716:	687b      	ldr	r3, [r7, #4]
 800f718:	f003 021f 	and.w	r2, r3, #31
 800f71c:	4907      	ldr	r1, [pc, #28]	; (800f73c <__NVIC_SetPendingIRQ+0x34>)
 800f71e:	687b      	ldr	r3, [r7, #4]
 800f720:	095b      	lsrs	r3, r3, #5
 800f722:	2001      	movs	r0, #1
 800f724:	fa00 f202 	lsl.w	r2, r0, r2
 800f728:	3340      	adds	r3, #64	; 0x40
 800f72a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800f72e:	bf00      	nop
 800f730:	370c      	adds	r7, #12
 800f732:	46bd      	mov	sp, r7
 800f734:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f738:	4770      	bx	lr
 800f73a:	bf00      	nop
 800f73c:	e000e100 	.word	0xe000e100

0800f740 <__NVIC_ClearPendingIRQ>:
{
 800f740:	b480      	push	{r7}
 800f742:	b083      	sub	sp, #12
 800f744:	af00      	add	r7, sp, #0
 800f746:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 800f748:	687b      	ldr	r3, [r7, #4]
 800f74a:	2b00      	cmp	r3, #0
 800f74c:	db0b      	blt.n	800f766 <__NVIC_ClearPendingIRQ+0x26>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f74e:	687b      	ldr	r3, [r7, #4]
 800f750:	f003 021f 	and.w	r2, r3, #31
 800f754:	4907      	ldr	r1, [pc, #28]	; (800f774 <__NVIC_ClearPendingIRQ+0x34>)
 800f756:	687b      	ldr	r3, [r7, #4]
 800f758:	095b      	lsrs	r3, r3, #5
 800f75a:	2001      	movs	r0, #1
 800f75c:	fa00 f202 	lsl.w	r2, r0, r2
 800f760:	3360      	adds	r3, #96	; 0x60
 800f762:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800f766:	bf00      	nop
 800f768:	370c      	adds	r7, #12
 800f76a:	46bd      	mov	sp, r7
 800f76c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f770:	4770      	bx	lr
 800f772:	bf00      	nop
 800f774:	e000e100 	.word	0xe000e100

0800f778 <__NVIC_SetPriority>:
{
 800f778:	b480      	push	{r7}
 800f77a:	b083      	sub	sp, #12
 800f77c:	af00      	add	r7, sp, #0
 800f77e:	6078      	str	r0, [r7, #4]
 800f780:	6039      	str	r1, [r7, #0]
  if ((int32_t)(IRQn) >= 0)
 800f782:	687b      	ldr	r3, [r7, #4]
 800f784:	2b00      	cmp	r3, #0
 800f786:	db09      	blt.n	800f79c <__NVIC_SetPriority+0x24>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f788:	683b      	ldr	r3, [r7, #0]
 800f78a:	b2da      	uxtb	r2, r3
 800f78c:	490c      	ldr	r1, [pc, #48]	; (800f7c0 <__NVIC_SetPriority+0x48>)
 800f78e:	687b      	ldr	r3, [r7, #4]
 800f790:	0112      	lsls	r2, r2, #4
 800f792:	b2d2      	uxtb	r2, r2
 800f794:	440b      	add	r3, r1
 800f796:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 800f79a:	e00a      	b.n	800f7b2 <__NVIC_SetPriority+0x3a>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f79c:	683b      	ldr	r3, [r7, #0]
 800f79e:	b2da      	uxtb	r2, r3
 800f7a0:	4908      	ldr	r1, [pc, #32]	; (800f7c4 <__NVIC_SetPriority+0x4c>)
 800f7a2:	687b      	ldr	r3, [r7, #4]
 800f7a4:	f003 030f 	and.w	r3, r3, #15
 800f7a8:	3b04      	subs	r3, #4
 800f7aa:	0112      	lsls	r2, r2, #4
 800f7ac:	b2d2      	uxtb	r2, r2
 800f7ae:	440b      	add	r3, r1
 800f7b0:	761a      	strb	r2, [r3, #24]
}
 800f7b2:	bf00      	nop
 800f7b4:	370c      	adds	r7, #12
 800f7b6:	46bd      	mov	sp, r7
 800f7b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f7bc:	4770      	bx	lr
 800f7be:	bf00      	nop
 800f7c0:	e000e100 	.word	0xe000e100
 800f7c4:	e000ed00 	.word	0xe000ed00

0800f7c8 <LOS_IntLock>:
{
 800f7c8:	b580      	push	{r7, lr}
 800f7ca:	af00      	add	r7, sp, #0
    return ArchIntLock();
 800f7cc:	f7f1 fa7c 	bl	8000cc8 <ArchIntLock>
 800f7d0:	4603      	mov	r3, r0
}
 800f7d2:	4618      	mov	r0, r3
 800f7d4:	bd80      	pop	{r7, pc}

0800f7d6 <LOS_IntRestore>:
{
 800f7d6:	b580      	push	{r7, lr}
 800f7d8:	b082      	sub	sp, #8
 800f7da:	af00      	add	r7, sp, #0
 800f7dc:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800f7de:	6878      	ldr	r0, [r7, #4]
 800f7e0:	f7f1 fa7a 	bl	8000cd8 <ArchIntRestore>
}
 800f7e4:	bf00      	nop
 800f7e6:	3708      	adds	r7, #8
 800f7e8:	46bd      	mov	sp, r7
 800f7ea:	bd80      	pop	{r7, pc}

0800f7ec <OsHwiControllerReg>:
 * registered;Because the function pointer is not judged in the abstraction layer, all function members defined in
 * HwiControllerOps need to be registered. If this function is not supported, you can call the LOS_Panic interface in
 * the implementation of the stub function to report an error in time.
 */
STATIC INLINE VOID OsHwiControllerReg(const HwiControllerOps *ops)
{
 800f7ec:	b480      	push	{r7}
 800f7ee:	b083      	sub	sp, #12
 800f7f0:	af00      	add	r7, sp, #0
 800f7f2:	6078      	str	r0, [r7, #4]
    g_hwiOps = ops;
 800f7f4:	4a04      	ldr	r2, [pc, #16]	; (800f808 <OsHwiControllerReg+0x1c>)
 800f7f6:	687b      	ldr	r3, [r7, #4]
 800f7f8:	6013      	str	r3, [r2, #0]
}
 800f7fa:	bf00      	nop
 800f7fc:	370c      	adds	r7, #12
 800f7fe:	46bd      	mov	sp, r7
 800f800:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f804:	4770      	bx	lr
 800f806:	bf00      	nop
 800f808:	20000758 	.word	0x20000758

0800f80c <IrqEntryV7M>:
    (HWI_PROC_FUNC)osPendSV,      /* [14] PendSV Handler */
    (HWI_PROC_FUNC)IrqEntryV7M,   /* [15] SysTick Handler */
};
#endif
LITE_OS_SEC_TEXT_MINOR VOID IrqEntryV7M(VOID)
{
 800f80c:	b580      	push	{r7, lr}
 800f80e:	b082      	sub	sp, #8
 800f810:	af00      	add	r7, sp, #0
#ifdef LOSCFG_PLATFORM_STM32F767_FIRE
        // Fire_LED_BLUE_ON(1);
    Fire_DEBUG_GPIOB6(1);
 800f812:	2001      	movs	r0, #1
 800f814:	f7f2 fa84 	bl	8001d20 <Fire_DEBUG_GPIOB6>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800f818:	f3ef 8305 	mrs	r3, IPSR
 800f81c:	607b      	str	r3, [r7, #4]
  return(result);
 800f81e:	687b      	ldr	r3, [r7, #4]
    // DEBUG_INT_PC
#endif    
    g_curIrqNum = __get_IPSR();
 800f820:	4a0d      	ldr	r2, [pc, #52]	; (800f858 <IrqEntryV7M+0x4c>)
 800f822:	6013      	str	r3, [r2, #0]
    OsIntHandle(g_curIrqNum, &g_hwiForm[g_curIrqNum]);
 800f824:	4b0c      	ldr	r3, [pc, #48]	; (800f858 <IrqEntryV7M+0x4c>)
 800f826:	681a      	ldr	r2, [r3, #0]
 800f828:	4b0b      	ldr	r3, [pc, #44]	; (800f858 <IrqEntryV7M+0x4c>)
 800f82a:	681b      	ldr	r3, [r3, #0]
 800f82c:	011b      	lsls	r3, r3, #4
 800f82e:	490b      	ldr	r1, [pc, #44]	; (800f85c <IrqEntryV7M+0x50>)
 800f830:	440b      	add	r3, r1
 800f832:	4619      	mov	r1, r3
 800f834:	4610      	mov	r0, r2
 800f836:	f7f2 fbef 	bl	8002018 <OsIntHandle>

    if (OsTaskProcSignal() != 0) {
 800f83a:	f7f4 fb7d 	bl	8003f38 <OsTaskProcSignal>
 800f83e:	4603      	mov	r3, r0
 800f840:	2b00      	cmp	r3, #0
 800f842:	d001      	beq.n	800f848 <IrqEntryV7M+0x3c>
        OsSchedPreempt();
 800f844:	f7f8 fd40 	bl	80082c8 <OsSchedPreempt>
    }
#ifdef LOSCFG_PLATFORM_STM32F767_FIRE    
   Fire_DEBUG_GPIOB6(0);
 800f848:	2000      	movs	r0, #0
 800f84a:	f7f2 fa69 	bl	8001d20 <Fire_DEBUG_GPIOB6>
    // Fire_LED_BLUE_ON(0);
#endif  
}
 800f84e:	bf00      	nop
 800f850:	3708      	adds	r7, #8
 800f852:	46bd      	mov	sp, r7
 800f854:	bd80      	pop	{r7, pc}
 800f856:	bf00      	nop
 800f858:	2000227c 	.word	0x2000227c
 800f85c:	20002280 	.word	0x20002280

0800f860 <ArchIrqUnmask>:

UINT32 ArchIrqUnmask(UINT32 hwiNum)
{
 800f860:	b580      	push	{r7, lr}
 800f862:	b084      	sub	sp, #16
 800f864:	af00      	add	r7, sp, #0
 800f866:	6078      	str	r0, [r7, #4]
    UINT32 intSave;

    if (!HWI_NUM_VALID(hwiNum)) {
 800f868:	687b      	ldr	r3, [r7, #4]
 800f86a:	2b0e      	cmp	r3, #14
 800f86c:	d902      	bls.n	800f874 <ArchIrqUnmask+0x14>
 800f86e:	687b      	ldr	r3, [r7, #4]
 800f870:	2bff      	cmp	r3, #255	; 0xff
 800f872:	d901      	bls.n	800f878 <ArchIrqUnmask+0x18>
        return LOS_ERRNO_HWI_NUM_INVALID;
 800f874:	4b09      	ldr	r3, [pc, #36]	; (800f89c <ArchIrqUnmask+0x3c>)
 800f876:	e00d      	b.n	800f894 <ArchIrqUnmask+0x34>
    }

    hwiNum -= OS_SYS_VECTOR_CNT;
 800f878:	687b      	ldr	r3, [r7, #4]
 800f87a:	3b10      	subs	r3, #16
 800f87c:	607b      	str	r3, [r7, #4]
    intSave = LOS_IntLock();
 800f87e:	f7ff ffa3 	bl	800f7c8 <LOS_IntLock>
 800f882:	60f8      	str	r0, [r7, #12]
    NVIC_EnableIRQ((IRQn_Type)hwiNum);
 800f884:	687b      	ldr	r3, [r7, #4]
 800f886:	4618      	mov	r0, r3
 800f888:	f7ff ff02 	bl	800f690 <__NVIC_EnableIRQ>
    LOS_IntRestore(intSave);
 800f88c:	68f8      	ldr	r0, [r7, #12]
 800f88e:	f7ff ffa2 	bl	800f7d6 <LOS_IntRestore>
    return LOS_OK;
 800f892:	2300      	movs	r3, #0
}
 800f894:	4618      	mov	r0, r3
 800f896:	3710      	adds	r7, #16
 800f898:	46bd      	mov	sp, r7
 800f89a:	bd80      	pop	{r7, pc}
 800f89c:	02000900 	.word	0x02000900

0800f8a0 <HalIrqSetPriority>:

UINT32 HalIrqSetPriority(UINT32 hwiNum, UINT8 priority)
{
 800f8a0:	b580      	push	{r7, lr}
 800f8a2:	b084      	sub	sp, #16
 800f8a4:	af00      	add	r7, sp, #0
 800f8a6:	6078      	str	r0, [r7, #4]
 800f8a8:	460b      	mov	r3, r1
 800f8aa:	70fb      	strb	r3, [r7, #3]
    UINT32 intSave;

    if (!HWI_NUM_VALID(hwiNum)) {
 800f8ac:	687b      	ldr	r3, [r7, #4]
 800f8ae:	2b0e      	cmp	r3, #14
 800f8b0:	d902      	bls.n	800f8b8 <HalIrqSetPriority+0x18>
 800f8b2:	687b      	ldr	r3, [r7, #4]
 800f8b4:	2bff      	cmp	r3, #255	; 0xff
 800f8b6:	d901      	bls.n	800f8bc <HalIrqSetPriority+0x1c>
        return LOS_ERRNO_HWI_NUM_INVALID;
 800f8b8:	4b0d      	ldr	r3, [pc, #52]	; (800f8f0 <HalIrqSetPriority+0x50>)
 800f8ba:	e014      	b.n	800f8e6 <HalIrqSetPriority+0x46>
    }

    if (!HWI_PRI_VALID(priority)) {
 800f8bc:	78fb      	ldrb	r3, [r7, #3]
 800f8be:	2b1f      	cmp	r3, #31
 800f8c0:	d901      	bls.n	800f8c6 <HalIrqSetPriority+0x26>
        return OS_ERRNO_HWI_PRIO_INVALID;
 800f8c2:	4b0c      	ldr	r3, [pc, #48]	; (800f8f4 <HalIrqSetPriority+0x54>)
 800f8c4:	e00f      	b.n	800f8e6 <HalIrqSetPriority+0x46>
    }

    hwiNum -= OS_SYS_VECTOR_CNT;
 800f8c6:	687b      	ldr	r3, [r7, #4]
 800f8c8:	3b10      	subs	r3, #16
 800f8ca:	607b      	str	r3, [r7, #4]
    intSave = LOS_IntLock();
 800f8cc:	f7ff ff7c 	bl	800f7c8 <LOS_IntLock>
 800f8d0:	60f8      	str	r0, [r7, #12]
    NVIC_SetPriority((IRQn_Type)hwiNum, priority);
 800f8d2:	687b      	ldr	r3, [r7, #4]
 800f8d4:	78fa      	ldrb	r2, [r7, #3]
 800f8d6:	4611      	mov	r1, r2
 800f8d8:	4618      	mov	r0, r3
 800f8da:	f7ff ff4d 	bl	800f778 <__NVIC_SetPriority>
    LOS_IntRestore(intSave);
 800f8de:	68f8      	ldr	r0, [r7, #12]
 800f8e0:	f7ff ff79 	bl	800f7d6 <LOS_IntRestore>

    return LOS_OK;
 800f8e4:	2300      	movs	r3, #0
}
 800f8e6:	4618      	mov	r0, r3
 800f8e8:	3710      	adds	r7, #16
 800f8ea:	46bd      	mov	sp, r7
 800f8ec:	bd80      	pop	{r7, pc}
 800f8ee:	bf00      	nop
 800f8f0:	02000900 	.word	0x02000900
 800f8f4:	02000905 	.word	0x02000905

0800f8f8 <ArchIrqMask>:

UINT32 ArchIrqMask(HWI_HANDLE_T hwiNum)
{
 800f8f8:	b580      	push	{r7, lr}
 800f8fa:	b084      	sub	sp, #16
 800f8fc:	af00      	add	r7, sp, #0
 800f8fe:	6078      	str	r0, [r7, #4]
    UINT32 intSave;

    if (!HWI_NUM_VALID(hwiNum)) {
 800f900:	687b      	ldr	r3, [r7, #4]
 800f902:	2b0e      	cmp	r3, #14
 800f904:	d902      	bls.n	800f90c <ArchIrqMask+0x14>
 800f906:	687b      	ldr	r3, [r7, #4]
 800f908:	2bff      	cmp	r3, #255	; 0xff
 800f90a:	d901      	bls.n	800f910 <ArchIrqMask+0x18>
        return LOS_ERRNO_HWI_NUM_INVALID;
 800f90c:	4b09      	ldr	r3, [pc, #36]	; (800f934 <ArchIrqMask+0x3c>)
 800f90e:	e00d      	b.n	800f92c <ArchIrqMask+0x34>
    }

    hwiNum -= OS_SYS_VECTOR_CNT;
 800f910:	687b      	ldr	r3, [r7, #4]
 800f912:	3b10      	subs	r3, #16
 800f914:	607b      	str	r3, [r7, #4]
    intSave = LOS_IntLock();
 800f916:	f7ff ff57 	bl	800f7c8 <LOS_IntLock>
 800f91a:	60f8      	str	r0, [r7, #12]
    NVIC_DisableIRQ((IRQn_Type)hwiNum);
 800f91c:	687b      	ldr	r3, [r7, #4]
 800f91e:	4618      	mov	r0, r3
 800f920:	f7ff fed0 	bl	800f6c4 <__NVIC_DisableIRQ>
    LOS_IntRestore(intSave);
 800f924:	68f8      	ldr	r0, [r7, #12]
 800f926:	f7ff ff56 	bl	800f7d6 <LOS_IntRestore>
    return LOS_OK;
 800f92a:	2300      	movs	r3, #0
}
 800f92c:	4618      	mov	r0, r3
 800f92e:	3710      	adds	r7, #16
 800f930:	46bd      	mov	sp, r7
 800f932:	bd80      	pop	{r7, pc}
 800f934:	02000900 	.word	0x02000900

0800f938 <ArchIrqPending>:

UINT32 ArchIrqPending(UINT32 hwiNum)
{
 800f938:	b580      	push	{r7, lr}
 800f93a:	b084      	sub	sp, #16
 800f93c:	af00      	add	r7, sp, #0
 800f93e:	6078      	str	r0, [r7, #4]
    UINT32 intSave;

    if (!HWI_NUM_VALID(hwiNum)) {
 800f940:	687b      	ldr	r3, [r7, #4]
 800f942:	2b0e      	cmp	r3, #14
 800f944:	d902      	bls.n	800f94c <ArchIrqPending+0x14>
 800f946:	687b      	ldr	r3, [r7, #4]
 800f948:	2bff      	cmp	r3, #255	; 0xff
 800f94a:	d901      	bls.n	800f950 <ArchIrqPending+0x18>
        return LOS_ERRNO_HWI_NUM_INVALID;
 800f94c:	4b09      	ldr	r3, [pc, #36]	; (800f974 <ArchIrqPending+0x3c>)
 800f94e:	e00d      	b.n	800f96c <ArchIrqPending+0x34>
    }

    hwiNum -= OS_SYS_VECTOR_CNT;
 800f950:	687b      	ldr	r3, [r7, #4]
 800f952:	3b10      	subs	r3, #16
 800f954:	607b      	str	r3, [r7, #4]
    intSave = LOS_IntLock();
 800f956:	f7ff ff37 	bl	800f7c8 <LOS_IntLock>
 800f95a:	60f8      	str	r0, [r7, #12]
    NVIC_SetPendingIRQ((IRQn_Type)hwiNum);
 800f95c:	687b      	ldr	r3, [r7, #4]
 800f95e:	4618      	mov	r0, r3
 800f960:	f7ff fed2 	bl	800f708 <__NVIC_SetPendingIRQ>
    LOS_IntRestore(intSave);
 800f964:	68f8      	ldr	r0, [r7, #12]
 800f966:	f7ff ff36 	bl	800f7d6 <LOS_IntRestore>
    return LOS_OK;
 800f96a:	2300      	movs	r3, #0
}
 800f96c:	4618      	mov	r0, r3
 800f96e:	3710      	adds	r7, #16
 800f970:	46bd      	mov	sp, r7
 800f972:	bd80      	pop	{r7, pc}
 800f974:	02000900 	.word	0x02000900

0800f978 <ArchIrqClear>:

UINT32 ArchIrqClear(UINT32 hwiNum)
{
 800f978:	b580      	push	{r7, lr}
 800f97a:	b082      	sub	sp, #8
 800f97c:	af00      	add	r7, sp, #0
 800f97e:	6078      	str	r0, [r7, #4]
    if (!HWI_NUM_VALID(hwiNum)) {
 800f980:	687b      	ldr	r3, [r7, #4]
 800f982:	2b0e      	cmp	r3, #14
 800f984:	d902      	bls.n	800f98c <ArchIrqClear+0x14>
 800f986:	687b      	ldr	r3, [r7, #4]
 800f988:	2bff      	cmp	r3, #255	; 0xff
 800f98a:	d901      	bls.n	800f990 <ArchIrqClear+0x18>
        return LOS_ERRNO_HWI_NUM_INVALID;
 800f98c:	4b06      	ldr	r3, [pc, #24]	; (800f9a8 <ArchIrqClear+0x30>)
 800f98e:	e007      	b.n	800f9a0 <ArchIrqClear+0x28>
    }

    hwiNum -= OS_SYS_VECTOR_CNT;
 800f990:	687b      	ldr	r3, [r7, #4]
 800f992:	3b10      	subs	r3, #16
 800f994:	607b      	str	r3, [r7, #4]
    NVIC_ClearPendingIRQ((IRQn_Type)hwiNum);
 800f996:	687b      	ldr	r3, [r7, #4]
 800f998:	4618      	mov	r0, r3
 800f99a:	f7ff fed1 	bl	800f740 <__NVIC_ClearPendingIRQ>
    return LOS_OK;
 800f99e:	2300      	movs	r3, #0
}
 800f9a0:	4618      	mov	r0, r3
 800f9a2:	3708      	adds	r7, #8
 800f9a4:	46bd      	mov	sp, r7
 800f9a6:	bd80      	pop	{r7, pc}
 800f9a8:	02000900 	.word	0x02000900

0800f9ac <HalCurIrqGet>:

UINT32 HalCurIrqGet(VOID)
{
 800f9ac:	b480      	push	{r7}
 800f9ae:	b083      	sub	sp, #12
 800f9b0:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800f9b2:	f3ef 8305 	mrs	r3, IPSR
 800f9b6:	607b      	str	r3, [r7, #4]
  return(result);
 800f9b8:	687b      	ldr	r3, [r7, #4]
    g_curIrqNum = __get_IPSR();
 800f9ba:	4a05      	ldr	r2, [pc, #20]	; (800f9d0 <HalCurIrqGet+0x24>)
 800f9bc:	6013      	str	r3, [r2, #0]
    return g_curIrqNum;
 800f9be:	4b04      	ldr	r3, [pc, #16]	; (800f9d0 <HalCurIrqGet+0x24>)
 800f9c0:	681b      	ldr	r3, [r3, #0]
}
 800f9c2:	4618      	mov	r0, r3
 800f9c4:	370c      	adds	r7, #12
 800f9c6:	46bd      	mov	sp, r7
 800f9c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9cc:	4770      	bx	lr
 800f9ce:	bf00      	nop
 800f9d0:	2000227c 	.word	0x2000227c

0800f9d4 <HalIrqVersion>:

CHAR *HalIrqVersion(VOID)
{
 800f9d4:	b480      	push	{r7}
 800f9d6:	af00      	add	r7, sp, #0
    return "NVIC";
 800f9d8:	4b02      	ldr	r3, [pc, #8]	; (800f9e4 <HalIrqVersion+0x10>)
}
 800f9da:	4618      	mov	r0, r3
 800f9dc:	46bd      	mov	sp, r7
 800f9de:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9e2:	4770      	bx	lr
 800f9e4:	08021698 	.word	0x08021698

0800f9e8 <ArchIrqGetHandleForm>:

HwiHandleInfo *ArchIrqGetHandleForm(HWI_HANDLE_T hwiNum)
{
 800f9e8:	b480      	push	{r7}
 800f9ea:	b083      	sub	sp, #12
 800f9ec:	af00      	add	r7, sp, #0
 800f9ee:	6078      	str	r0, [r7, #4]
    if (!HWI_NUM_VALID(hwiNum)) {
 800f9f0:	687b      	ldr	r3, [r7, #4]
 800f9f2:	2b0e      	cmp	r3, #14
 800f9f4:	d902      	bls.n	800f9fc <ArchIrqGetHandleForm+0x14>
 800f9f6:	687b      	ldr	r3, [r7, #4]
 800f9f8:	2bff      	cmp	r3, #255	; 0xff
 800f9fa:	d901      	bls.n	800fa00 <ArchIrqGetHandleForm+0x18>
        return NULL;
 800f9fc:	2300      	movs	r3, #0
 800f9fe:	e003      	b.n	800fa08 <ArchIrqGetHandleForm+0x20>
    }

    return &g_hwiForm[hwiNum];
 800fa00:	687b      	ldr	r3, [r7, #4]
 800fa02:	011b      	lsls	r3, r3, #4
 800fa04:	4a03      	ldr	r2, [pc, #12]	; (800fa14 <ArchIrqGetHandleForm+0x2c>)
 800fa06:	4413      	add	r3, r2
}
 800fa08:	4618      	mov	r0, r3
 800fa0a:	370c      	adds	r7, #12
 800fa0c:	46bd      	mov	sp, r7
 800fa0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa12:	4770      	bx	lr
 800fa14:	20002280 	.word	0x20002280

0800fa18 <ArchIrqInit>:
    .getHandleForm  = ArchIrqGetHandleForm,
    .clearIrq       = ArchIrqClear,
};

VOID ArchIrqInit(VOID)
{
 800fa18:	b580      	push	{r7, lr}
 800fa1a:	b082      	sub	sp, #8
 800fa1c:	af00      	add	r7, sp, #0
    UINT32 i;

    for (i = OS_SYS_VECTOR_CNT; i < LOSCFG_PLATFORM_HWI_LIMIT; i++) {
 800fa1e:	2310      	movs	r3, #16
 800fa20:	607b      	str	r3, [r7, #4]
 800fa22:	e007      	b.n	800fa34 <ArchIrqInit+0x1c>
        g_hwiVec[i] = (HWI_PROC_FUNC)IrqEntryV7M;
 800fa24:	4a0b      	ldr	r2, [pc, #44]	; (800fa54 <ArchIrqInit+0x3c>)
 800fa26:	687b      	ldr	r3, [r7, #4]
 800fa28:	490b      	ldr	r1, [pc, #44]	; (800fa58 <ArchIrqInit+0x40>)
 800fa2a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for (i = OS_SYS_VECTOR_CNT; i < LOSCFG_PLATFORM_HWI_LIMIT; i++) {
 800fa2e:	687b      	ldr	r3, [r7, #4]
 800fa30:	3301      	adds	r3, #1
 800fa32:	607b      	str	r3, [r7, #4]
 800fa34:	687b      	ldr	r3, [r7, #4]
 800fa36:	2bff      	cmp	r3, #255	; 0xff
 800fa38:	d9f4      	bls.n	800fa24 <ArchIrqInit+0xc>
    __HAL_RCC_SYSCFG_CLK_ENABLE();
    /* Remap SRAM at 0x00000000 */
    __HAL_SYSCFG_REMAPMEMORY_SRAM();
#else
    /* Interrupt vector table location */
    SCB->VTOR = (UINT32)g_hwiVec;
 800fa3a:	4b08      	ldr	r3, [pc, #32]	; (800fa5c <ArchIrqInit+0x44>)
 800fa3c:	4a05      	ldr	r2, [pc, #20]	; (800fa54 <ArchIrqInit+0x3c>)
 800fa3e:	609a      	str	r2, [r3, #8]
#endif
#if (__CORTEX_M >= 0x03U) /* only for Cortex-M3 and above */
    NVIC_SetPriorityGrouping(OS_NVIC_AIRCR_PRIGROUP);
 800fa40:	2007      	movs	r0, #7
 800fa42:	f7ff fe01 	bl	800f648 <__NVIC_SetPriorityGrouping>
#endif

    /* register interrupt controller's operations */
    OsHwiControllerReg(&g_nvicOps);
 800fa46:	4806      	ldr	r0, [pc, #24]	; (800fa60 <ArchIrqInit+0x48>)
 800fa48:	f7ff fed0 	bl	800f7ec <OsHwiControllerReg>
    return;
 800fa4c:	bf00      	nop
}
 800fa4e:	3708      	adds	r7, #8
 800fa50:	46bd      	mov	sp, r7
 800fa52:	bd80      	pop	{r7, pc}
 800fa54:	20000000 	.word	0x20000000
 800fa58:	0800f80d 	.word	0x0800f80d
 800fa5c:	e000ed00 	.word	0xe000ed00
 800fa60:	080234c8 	.word	0x080234c8

0800fa64 <__NVIC_SetPriority>:
{
 800fa64:	b480      	push	{r7}
 800fa66:	b083      	sub	sp, #12
 800fa68:	af00      	add	r7, sp, #0
 800fa6a:	6078      	str	r0, [r7, #4]
 800fa6c:	6039      	str	r1, [r7, #0]
  if ((int32_t)(IRQn) >= 0)
 800fa6e:	687b      	ldr	r3, [r7, #4]
 800fa70:	2b00      	cmp	r3, #0
 800fa72:	db09      	blt.n	800fa88 <__NVIC_SetPriority+0x24>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800fa74:	683b      	ldr	r3, [r7, #0]
 800fa76:	b2da      	uxtb	r2, r3
 800fa78:	490c      	ldr	r1, [pc, #48]	; (800faac <__NVIC_SetPriority+0x48>)
 800fa7a:	687b      	ldr	r3, [r7, #4]
 800fa7c:	0112      	lsls	r2, r2, #4
 800fa7e:	b2d2      	uxtb	r2, r2
 800fa80:	440b      	add	r3, r1
 800fa82:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 800fa86:	e00a      	b.n	800fa9e <__NVIC_SetPriority+0x3a>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800fa88:	683b      	ldr	r3, [r7, #0]
 800fa8a:	b2da      	uxtb	r2, r3
 800fa8c:	4908      	ldr	r1, [pc, #32]	; (800fab0 <__NVIC_SetPriority+0x4c>)
 800fa8e:	687b      	ldr	r3, [r7, #4]
 800fa90:	f003 030f 	and.w	r3, r3, #15
 800fa94:	3b04      	subs	r3, #4
 800fa96:	0112      	lsls	r2, r2, #4
 800fa98:	b2d2      	uxtb	r2, r2
 800fa9a:	440b      	add	r3, r1
 800fa9c:	761a      	strb	r2, [r3, #24]
}
 800fa9e:	bf00      	nop
 800faa0:	370c      	adds	r7, #12
 800faa2:	46bd      	mov	sp, r7
 800faa4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800faa8:	4770      	bx	lr
 800faaa:	bf00      	nop
 800faac:	e000e100 	.word	0xe000e100
 800fab0:	e000ed00 	.word	0xe000ed00

0800fab4 <SysTick_Config>:
{
 800fab4:	b580      	push	{r7, lr}
 800fab6:	b082      	sub	sp, #8
 800fab8:	af00      	add	r7, sp, #0
 800faba:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800fabc:	687b      	ldr	r3, [r7, #4]
 800fabe:	3b01      	subs	r3, #1
 800fac0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800fac4:	d301      	bcc.n	800faca <SysTick_Config+0x16>
    return (1UL);                                                   /* Reload value impossible */
 800fac6:	2301      	movs	r3, #1
 800fac8:	e00f      	b.n	800faea <SysTick_Config+0x36>
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800faca:	4a0a      	ldr	r2, [pc, #40]	; (800faf4 <SysTick_Config+0x40>)
 800facc:	687b      	ldr	r3, [r7, #4]
 800face:	3b01      	subs	r3, #1
 800fad0:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800fad2:	210f      	movs	r1, #15
 800fad4:	f04f 30ff 	mov.w	r0, #4294967295
 800fad8:	f7ff ffc4 	bl	800fa64 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800fadc:	4b05      	ldr	r3, [pc, #20]	; (800faf4 <SysTick_Config+0x40>)
 800fade:	2200      	movs	r2, #0
 800fae0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800fae2:	4b04      	ldr	r3, [pc, #16]	; (800faf4 <SysTick_Config+0x40>)
 800fae4:	2207      	movs	r2, #7
 800fae6:	601a      	str	r2, [r3, #0]
  return (0UL);                                                     /* Function successful */
 800fae8:	2300      	movs	r3, #0
}
 800faea:	4618      	mov	r0, r3
 800faec:	3708      	adds	r7, #8
 800faee:	46bd      	mov	sp, r7
 800faf0:	bd80      	pop	{r7, pc}
 800faf2:	bf00      	nop
 800faf4:	e000e010 	.word	0xe000e010

0800faf8 <LOS_IntLock>:
{
 800faf8:	b580      	push	{r7, lr}
 800fafa:	af00      	add	r7, sp, #0
    return ArchIntLock();
 800fafc:	f7f1 f8e4 	bl	8000cc8 <ArchIntLock>
 800fb00:	4603      	mov	r3, r0
}
 800fb02:	4618      	mov	r0, r3
 800fb04:	bd80      	pop	{r7, pc}

0800fb06 <LOS_IntRestore>:
{
 800fb06:	b580      	push	{r7, lr}
 800fb08:	b082      	sub	sp, #8
 800fb0a:	af00      	add	r7, sp, #0
 800fb0c:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800fb0e:	6878      	ldr	r0, [r7, #4]
 800fb10:	f7f1 f8e2 	bl	8000cd8 <ArchIntRestore>
}
 800fb14:	bf00      	nop
 800fb16:	3708      	adds	r7, #8
 800fb18:	46bd      	mov	sp, r7
 800fb1a:	bd80      	pop	{r7, pc}

0800fb1c <HalClockInit>:
LITE_OS_SEC_BSS UINT32     g_cyclesPerTick;

#define M_INT_NUM  15 /* SysTick_IRQn + OS_SYS_VECOTRE */

VOID HalClockInit(VOID)
{
 800fb1c:	b580      	push	{r7, lr}
 800fb1e:	b084      	sub	sp, #16
 800fb20:	af02      	add	r7, sp, #8
    UINT32 ret = LOS_HwiCreate(M_INT_NUM, 0, 0, OsTickHandler, 0);
 800fb22:	2300      	movs	r3, #0
 800fb24:	9300      	str	r3, [sp, #0]
 800fb26:	4b0c      	ldr	r3, [pc, #48]	; (800fb58 <HalClockInit+0x3c>)
 800fb28:	2200      	movs	r2, #0
 800fb2a:	2100      	movs	r1, #0
 800fb2c:	200f      	movs	r0, #15
 800fb2e:	f7f2 fcb5 	bl	800249c <LOS_HwiCreate>
 800fb32:	6078      	str	r0, [r7, #4]
    if (ret != 0) {
 800fb34:	687b      	ldr	r3, [r7, #4]
 800fb36:	2b00      	cmp	r3, #0
 800fb38:	d003      	beq.n	800fb42 <HalClockInit+0x26>
        PRINTK("ret of LOS_HwiCreate = %#x\n", ret);
 800fb3a:	6879      	ldr	r1, [r7, #4]
 800fb3c:	4807      	ldr	r0, [pc, #28]	; (800fb5c <HalClockInit+0x40>)
 800fb3e:	f7f4 fdc5 	bl	80046cc <dprintf>
    }
#ifdef LOSCFG_KERNEL_CPUP
    if (g_cpupTimerOps.timHwiCreate != NULL) {
 800fb42:	4b07      	ldr	r3, [pc, #28]	; (800fb60 <HalClockInit+0x44>)
 800fb44:	685b      	ldr	r3, [r3, #4]
 800fb46:	2b00      	cmp	r3, #0
 800fb48:	d002      	beq.n	800fb50 <HalClockInit+0x34>
        g_cpupTimerOps.timHwiCreate();
 800fb4a:	4b05      	ldr	r3, [pc, #20]	; (800fb60 <HalClockInit+0x44>)
 800fb4c:	685b      	ldr	r3, [r3, #4]
 800fb4e:	4798      	blx	r3
    }
#endif
}
 800fb50:	bf00      	nop
 800fb52:	3708      	adds	r7, #8
 800fb54:	46bd      	mov	sp, r7
 800fb56:	bd80      	pop	{r7, pc}
 800fb58:	080040b1 	.word	0x080040b1
 800fb5c:	080216a0 	.word	0x080216a0
 800fb60:	20000408 	.word	0x20000408

0800fb64 <HalClockStart>:

VOID HalClockStart(VOID)
{
 800fb64:	b580      	push	{r7, lr}
 800fb66:	b082      	sub	sp, #8
 800fb68:	af00      	add	r7, sp, #0
    if ((OS_SYS_CLOCK == 0) ||
 800fb6a:	4b15      	ldr	r3, [pc, #84]	; (800fbc0 <HalClockStart+0x5c>)
 800fb6c:	681b      	ldr	r3, [r3, #0]
 800fb6e:	2b00      	cmp	r3, #0
 800fb70:	d021      	beq.n	800fbb6 <HalClockStart+0x52>
        (LOSCFG_BASE_CORE_TICK_PER_SECOND == 0) ||
        (LOSCFG_BASE_CORE_TICK_PER_SECOND > OS_SYS_CLOCK)) {
 800fb72:	4b13      	ldr	r3, [pc, #76]	; (800fbc0 <HalClockStart+0x5c>)
 800fb74:	681b      	ldr	r3, [r3, #0]
        (LOSCFG_BASE_CORE_TICK_PER_SECOND == 0) ||
 800fb76:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800fb7a:	d31c      	bcc.n	800fbb6 <HalClockStart+0x52>
        return;
    }

    g_cyclesPerTick = OS_CYCLE_PER_TICK;
 800fb7c:	4b10      	ldr	r3, [pc, #64]	; (800fbc0 <HalClockStart+0x5c>)
 800fb7e:	681b      	ldr	r3, [r3, #0]
 800fb80:	4a10      	ldr	r2, [pc, #64]	; (800fbc4 <HalClockStart+0x60>)
 800fb82:	fba2 2303 	umull	r2, r3, r2, r3
 800fb86:	099b      	lsrs	r3, r3, #6
 800fb88:	4a0f      	ldr	r2, [pc, #60]	; (800fbc8 <HalClockStart+0x64>)
 800fb8a:	6013      	str	r3, [r2, #0]

    (VOID)SysTick_Config(OS_CYCLE_PER_TICK);
 800fb8c:	4b0c      	ldr	r3, [pc, #48]	; (800fbc0 <HalClockStart+0x5c>)
 800fb8e:	681b      	ldr	r3, [r3, #0]
 800fb90:	4a0c      	ldr	r2, [pc, #48]	; (800fbc4 <HalClockStart+0x60>)
 800fb92:	fba2 2303 	umull	r2, r3, r2, r3
 800fb96:	099b      	lsrs	r3, r3, #6
 800fb98:	4618      	mov	r0, r3
 800fb9a:	f7ff ff8b 	bl	800fab4 <SysTick_Config>

    UINT32 ret = LOS_HwiEnable(M_INT_NUM);
 800fb9e:	200f      	movs	r0, #15
 800fba0:	f7f2 fd2e 	bl	8002600 <LOS_HwiEnable>
 800fba4:	6078      	str	r0, [r7, #4]
    if (ret != 0) {
 800fba6:	687b      	ldr	r3, [r7, #4]
 800fba8:	2b00      	cmp	r3, #0
 800fbaa:	d005      	beq.n	800fbb8 <HalClockStart+0x54>
        PRINTK("LOS_HwiEnable failed. ret = %#x\n", ret);
 800fbac:	6879      	ldr	r1, [r7, #4]
 800fbae:	4807      	ldr	r0, [pc, #28]	; (800fbcc <HalClockStart+0x68>)
 800fbb0:	f7f4 fd8c 	bl	80046cc <dprintf>
 800fbb4:	e000      	b.n	800fbb8 <HalClockStart+0x54>
        return;
 800fbb6:	bf00      	nop
    }
}
 800fbb8:	3708      	adds	r7, #8
 800fbba:	46bd      	mov	sp, r7
 800fbbc:	bd80      	pop	{r7, pc}
 800fbbe:	bf00      	nop
 800fbc0:	20000404 	.word	0x20000404
 800fbc4:	10624dd3 	.word	0x10624dd3
 800fbc8:	20003768 	.word	0x20003768
 800fbcc:	080216bc 	.word	0x080216bc

0800fbd0 <HalClockGetCycles>:

UINT64 HalClockGetCycles(VOID)
{
 800fbd0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800fbd4:	b086      	sub	sp, #24
 800fbd6:	af00      	add	r7, sp, #0
    UINT32 hwCycle;
    UINT32 intSave;


#ifdef LOSCFG_PLATFORM_STM32F767_FIRE
    if (g_cpupTimerOps.timGetTimerCycles != NULL) {
 800fbd8:	4b35      	ldr	r3, [pc, #212]	; (800fcb0 <HalClockGetCycles+0xe0>)
 800fbda:	689b      	ldr	r3, [r3, #8]
 800fbdc:	2b00      	cmp	r3, #0
 800fbde:	d007      	beq.n	800fbf0 <HalClockGetCycles+0x20>
        cycle = g_cpupTimerOps.timGetTimerCycles();
 800fbe0:	4b33      	ldr	r3, [pc, #204]	; (800fcb0 <HalClockGetCycles+0xe0>)
 800fbe2:	689b      	ldr	r3, [r3, #8]
 800fbe4:	4798      	blx	r3
 800fbe6:	e9c7 0104 	strd	r0, r1, [r7, #16]
        return cycle;
 800fbea:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800fbee:	e059      	b.n	800fca4 <HalClockGetCycles+0xd4>
    }
#endif
    intSave = LOS_IntLock();
 800fbf0:	f7ff ff82 	bl	800faf8 <LOS_IntLock>
 800fbf4:	6078      	str	r0, [r7, #4]

    swTick = LOS_TickCountGet();
 800fbf6:	f7f4 fabf 	bl	8004178 <LOS_TickCountGet>
 800fbfa:	e9c7 0102 	strd	r0, r1, [r7, #8]
    hwCycle = SysTick->VAL;
 800fbfe:	4b2d      	ldr	r3, [pc, #180]	; (800fcb4 <HalClockGetCycles+0xe4>)
 800fc00:	689b      	ldr	r3, [r3, #8]
 800fc02:	603b      	str	r3, [r7, #0]

    /* tick has come, but may interrupt environment, not counting the Tick interrupt response */
    // 2022-03-31 tanzhongqiang systick 
    if ((SCB->ICSR & TICK_INTR_CHECK) != 0) {
 800fc04:	4b2c      	ldr	r3, [pc, #176]	; (800fcb8 <HalClockGetCycles+0xe8>)
 800fc06:	685b      	ldr	r3, [r3, #4]
 800fc08:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 800fc0c:	2b00      	cmp	r3, #0
 800fc0e:	d00a      	beq.n	800fc26 <HalClockGetCycles+0x56>
        hwCycle = SysTick->VAL;
 800fc10:	4b28      	ldr	r3, [pc, #160]	; (800fcb4 <HalClockGetCycles+0xe4>)
 800fc12:	689b      	ldr	r3, [r3, #8]
 800fc14:	603b      	str	r3, [r7, #0]
        swTick++;
 800fc16:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800fc1a:	f112 0801 	adds.w	r8, r2, #1
 800fc1e:	f143 0900 	adc.w	r9, r3, #0
 800fc22:	e9c7 8902 	strd	r8, r9, [r7, #8]
    }

    cycle = (swTick * g_cyclesPerTick) + (g_cyclesPerTick - hwCycle);
 800fc26:	4b25      	ldr	r3, [pc, #148]	; (800fcbc <HalClockGetCycles+0xec>)
 800fc28:	681b      	ldr	r3, [r3, #0]
 800fc2a:	461a      	mov	r2, r3
 800fc2c:	f04f 0300 	mov.w	r3, #0
 800fc30:	68b9      	ldr	r1, [r7, #8]
 800fc32:	fb03 f001 	mul.w	r0, r3, r1
 800fc36:	68f9      	ldr	r1, [r7, #12]
 800fc38:	fb02 f101 	mul.w	r1, r2, r1
 800fc3c:	4401      	add	r1, r0
 800fc3e:	68b8      	ldr	r0, [r7, #8]
 800fc40:	fba0 2302 	umull	r2, r3, r0, r2
 800fc44:	4419      	add	r1, r3
 800fc46:	460b      	mov	r3, r1
 800fc48:	491c      	ldr	r1, [pc, #112]	; (800fcbc <HalClockGetCycles+0xec>)
 800fc4a:	6808      	ldr	r0, [r1, #0]
 800fc4c:	6839      	ldr	r1, [r7, #0]
 800fc4e:	1a41      	subs	r1, r0, r1
 800fc50:	4608      	mov	r0, r1
 800fc52:	f04f 0100 	mov.w	r1, #0
 800fc56:	1814      	adds	r4, r2, r0
 800fc58:	eb43 0501 	adc.w	r5, r3, r1
 800fc5c:	e9c7 4504 	strd	r4, r5, [r7, #16]
    LOS_IntRestore(intSave);
 800fc60:	6878      	ldr	r0, [r7, #4]
 800fc62:	f7ff ff50 	bl	800fb06 <LOS_IntRestore>

#ifdef LOSCFG_KERNEL_CPUP
    if (g_cpupTimerOps.timGetTimerCycles != NULL) {
 800fc66:	4b12      	ldr	r3, [pc, #72]	; (800fcb0 <HalClockGetCycles+0xe0>)
 800fc68:	689b      	ldr	r3, [r3, #8]
 800fc6a:	2b00      	cmp	r3, #0
 800fc6c:	d018      	beq.n	800fca0 <HalClockGetCycles+0xd0>
        cycle = g_cpupTimerOps.timGetTimerCycles() * TIMER_CYCLE_SWITCH;
 800fc6e:	4b10      	ldr	r3, [pc, #64]	; (800fcb0 <HalClockGetCycles+0xe0>)
 800fc70:	689b      	ldr	r3, [r3, #8]
 800fc72:	4798      	blx	r3
 800fc74:	4b12      	ldr	r3, [pc, #72]	; (800fcc0 <HalClockGetCycles+0xf0>)
 800fc76:	681b      	ldr	r3, [r3, #0]
 800fc78:	4a12      	ldr	r2, [pc, #72]	; (800fcc4 <HalClockGetCycles+0xf4>)
 800fc7a:	fba2 2303 	umull	r2, r3, r2, r3
 800fc7e:	0b5b      	lsrs	r3, r3, #13
 800fc80:	461a      	mov	r2, r3
 800fc82:	f04f 0300 	mov.w	r3, #0
 800fc86:	fb02 f501 	mul.w	r5, r2, r1
 800fc8a:	fb00 f403 	mul.w	r4, r0, r3
 800fc8e:	442c      	add	r4, r5
 800fc90:	fba0 2302 	umull	r2, r3, r0, r2
 800fc94:	18e1      	adds	r1, r4, r3
 800fc96:	460b      	mov	r3, r1
 800fc98:	e9c7 2304 	strd	r2, r3, [r7, #16]
 800fc9c:	e9c7 2304 	strd	r2, r3, [r7, #16]
    }
#endif

    return cycle;
 800fca0:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
}
 800fca4:	4610      	mov	r0, r2
 800fca6:	4619      	mov	r1, r3
 800fca8:	3718      	adds	r7, #24
 800fcaa:	46bd      	mov	sp, r7
 800fcac:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 800fcb0:	20000408 	.word	0x20000408
 800fcb4:	e000e010 	.word	0xe000e010
 800fcb8:	e000ed00 	.word	0xe000ed00
 800fcbc:	20003768 	.word	0x20003768
 800fcc0:	20000404 	.word	0x20000404
 800fcc4:	d1b71759 	.word	0xd1b71759

0800fcc8 <HalClockGetTickTimerCycles>:
    return LOS_CurrNanosec();
}

/* just stub api for tickless */
UINT32 HalClockGetTickTimerCycles(VOID)
{
 800fcc8:	b480      	push	{r7}
 800fcca:	af00      	add	r7, sp, #0
    return SysTick->VAL;
 800fccc:	4b03      	ldr	r3, [pc, #12]	; (800fcdc <HalClockGetTickTimerCycles+0x14>)
 800fcce:	689b      	ldr	r3, [r3, #8]
}
 800fcd0:	4618      	mov	r0, r3
 800fcd2:	46bd      	mov	sp, r7
 800fcd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fcd8:	4770      	bx	lr
 800fcda:	bf00      	nop
 800fcdc:	e000e010 	.word	0xe000e010

0800fce0 <HalClockTickTimerReload>:

/* just stub api for tickless */
VOID HalClockTickTimerReload(UINT32 cycles)
{
 800fce0:	b480      	push	{r7}
 800fce2:	b083      	sub	sp, #12
 800fce4:	af00      	add	r7, sp, #0
 800fce6:	6078      	str	r0, [r7, #4]
    SysTick->VAL = (cycles == 0) ? 0 : (cycles - 1U);
 800fce8:	687b      	ldr	r3, [r7, #4]
 800fcea:	2b00      	cmp	r3, #0
 800fcec:	d002      	beq.n	800fcf4 <HalClockTickTimerReload+0x14>
 800fcee:	687b      	ldr	r3, [r7, #4]
 800fcf0:	3b01      	subs	r3, #1
 800fcf2:	e000      	b.n	800fcf6 <HalClockTickTimerReload+0x16>
 800fcf4:	2300      	movs	r3, #0
 800fcf6:	4a05      	ldr	r2, [pc, #20]	; (800fd0c <HalClockTickTimerReload+0x2c>)
 800fcf8:	6093      	str	r3, [r2, #8]
    SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800fcfa:	4b04      	ldr	r3, [pc, #16]	; (800fd0c <HalClockTickTimerReload+0x2c>)
 800fcfc:	2207      	movs	r2, #7
 800fcfe:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;        /* Enable SysTick IRQ and SysTick Timer */
}
 800fd00:	bf00      	nop
 800fd02:	370c      	adds	r7, #12
 800fd04:	46bd      	mov	sp, r7
 800fd06:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd0a:	4770      	bx	lr
 800fd0c:	e000e010 	.word	0xe000e010

0800fd10 <OsLowpowerInit>:
#define CALL_PMOPS_FUNC_RET(func, ret, ...) CALL_FUNC_WITH_RETURN_FROM_PTR(g_pmOps, ret, func, __VA_ARGS__)

__attribute__((section(".data"))) STATIC const PowerMgrOps *g_pmOps = NULL;

VOID OsLowpowerInit(const PowerMgrOps *pmOps)
{
 800fd10:	b580      	push	{r7, lr}
 800fd12:	b082      	sub	sp, #8
 800fd14:	af00      	add	r7, sp, #0
 800fd16:	6078      	str	r0, [r7, #4]
    if (pmOps == NULL) {
 800fd18:	687b      	ldr	r3, [r7, #4]
 800fd1a:	2b00      	cmp	r3, #0
 800fd1c:	d00b      	beq.n	800fd36 <OsLowpowerInit+0x26>
#ifdef LOSCFG_KERNEL_POWER_MGR
        PRINT_ERR("\r\n [PM] PowerMgrOps must be non-null.\n");
        return;
#endif
    } else if (pmOps->process == NULL) {
 800fd1e:	687b      	ldr	r3, [r7, #4]
 800fd20:	681b      	ldr	r3, [r3, #0]
 800fd22:	2b00      	cmp	r3, #0
 800fd24:	d107      	bne.n	800fd36 <OsLowpowerInit+0x26>
        PRINT_ERR("\r\n [PM] %s must be non-null.\n", __FUNCTION__);
 800fd26:	480f      	ldr	r0, [pc, #60]	; (800fd64 <OsLowpowerInit+0x54>)
 800fd28:	f7f4 fcd0 	bl	80046cc <dprintf>
 800fd2c:	490e      	ldr	r1, [pc, #56]	; (800fd68 <OsLowpowerInit+0x58>)
 800fd2e:	480f      	ldr	r0, [pc, #60]	; (800fd6c <OsLowpowerInit+0x5c>)
 800fd30:	f7f4 fccc 	bl	80046cc <dprintf>
        return;
 800fd34:	e013      	b.n	800fd5e <OsLowpowerInit+0x4e>
    }

    if (g_pmOps != NULL) {
 800fd36:	4b0e      	ldr	r3, [pc, #56]	; (800fd70 <OsLowpowerInit+0x60>)
 800fd38:	681b      	ldr	r3, [r3, #0]
 800fd3a:	2b00      	cmp	r3, #0
 800fd3c:	d006      	beq.n	800fd4c <OsLowpowerInit+0x3c>
        PRINT_ERR("\r\n [PM] Reassignment of PowerMgrOps is forbidden.\n");
 800fd3e:	4809      	ldr	r0, [pc, #36]	; (800fd64 <OsLowpowerInit+0x54>)
 800fd40:	f7f4 fcc4 	bl	80046cc <dprintf>
 800fd44:	480b      	ldr	r0, [pc, #44]	; (800fd74 <OsLowpowerInit+0x64>)
 800fd46:	f7f4 fcc1 	bl	80046cc <dprintf>
        return;
 800fd4a:	e008      	b.n	800fd5e <OsLowpowerInit+0x4e>
    }
    g_pmOps = pmOps;
 800fd4c:	4a08      	ldr	r2, [pc, #32]	; (800fd70 <OsLowpowerInit+0x60>)
 800fd4e:	687b      	ldr	r3, [r7, #4]
 800fd50:	6013      	str	r3, [r2, #0]

    LOS_LowpowerHookReg(OsPowerMgrProcess);
 800fd52:	4809      	ldr	r0, [pc, #36]	; (800fd78 <OsLowpowerInit+0x68>)
 800fd54:	f7f3 f9cc 	bl	80030f0 <LOS_LowpowerHookReg>

    LOS_IntWakeupHookReg(OsPowerMgrWakeUpFromInterrupt);
 800fd58:	4808      	ldr	r0, [pc, #32]	; (800fd7c <OsLowpowerInit+0x6c>)
 800fd5a:	f7f2 fc9d 	bl	8002698 <LOS_IntWakeupHookReg>
}
 800fd5e:	3708      	adds	r7, #8
 800fd60:	46bd      	mov	sp, r7
 800fd62:	bd80      	pop	{r7, pc}
 800fd64:	080216e0 	.word	0x080216e0
 800fd68:	080234ec 	.word	0x080234ec
 800fd6c:	080216e8 	.word	0x080216e8
 800fd70:	20000400 	.word	0x20000400
 800fd74:	08021708 	.word	0x08021708
 800fd78:	0800fd81 	.word	0x0800fd81
 800fd7c:	0800fdb9 	.word	0x0800fdb9

0800fd80 <OsPowerMgrProcess>:
#ifdef LOSCFG_PLATFORM_STM32F767_FIRE
extern void Fire_DEBUG_GPIOB6(int on);
#endif
VOID OsPowerMgrProcess(VOID)
{
 800fd80:	b580      	push	{r7, lr}
 800fd82:	af00      	add	r7, sp, #0
#ifdef LOSCFG_KERNEL_POWER_MGR
    CALL_PMOPS_FUNC_VOID(process);
#else
    if (g_pmOps == NULL) {
 800fd84:	4b0b      	ldr	r3, [pc, #44]	; (800fdb4 <OsPowerMgrProcess+0x34>)
 800fd86:	681b      	ldr	r3, [r3, #0]
 800fd88:	2b00      	cmp	r3, #0
 800fd8a:	d103      	bne.n	800fd94 <OsPowerMgrProcess+0x14>
#ifdef LOSCFG_KERNEL_TICKLESS
        OsTicklessOpen();
 800fd8c:	f003 fcf4 	bl	8013778 <OsTicklessOpen>
    // 2022-03-31 tanzhongqiang 
    //Fire_DEBUG_GPIOB6(1);
   // __asm__ volatile("nop" );
   // Fire_DEBUG_GPIOB6(0);
#endif
        wfi();
 800fd90:	bf30      	wfi
#endif
    } else {
        CALL_PMOPS_FUNC_VOID(process);
    }
#endif
}
 800fd92:	e00c      	b.n	800fdae <OsPowerMgrProcess+0x2e>
        CALL_PMOPS_FUNC_VOID(process);
 800fd94:	4b07      	ldr	r3, [pc, #28]	; (800fdb4 <OsPowerMgrProcess+0x34>)
 800fd96:	681b      	ldr	r3, [r3, #0]
 800fd98:	2b00      	cmp	r3, #0
 800fd9a:	d008      	beq.n	800fdae <OsPowerMgrProcess+0x2e>
 800fd9c:	4b05      	ldr	r3, [pc, #20]	; (800fdb4 <OsPowerMgrProcess+0x34>)
 800fd9e:	681b      	ldr	r3, [r3, #0]
 800fda0:	681b      	ldr	r3, [r3, #0]
 800fda2:	2b00      	cmp	r3, #0
 800fda4:	d003      	beq.n	800fdae <OsPowerMgrProcess+0x2e>
 800fda6:	4b03      	ldr	r3, [pc, #12]	; (800fdb4 <OsPowerMgrProcess+0x34>)
 800fda8:	681b      	ldr	r3, [r3, #0]
 800fdaa:	681b      	ldr	r3, [r3, #0]
 800fdac:	4798      	blx	r3
}
 800fdae:	bf00      	nop
 800fdb0:	bd80      	pop	{r7, pc}
 800fdb2:	bf00      	nop
 800fdb4:	20000400 	.word	0x20000400

0800fdb8 <OsPowerMgrWakeUpFromInterrupt>:

VOID OsPowerMgrWakeUpFromInterrupt(UINT32 intNum)
{
 800fdb8:	b580      	push	{r7, lr}
 800fdba:	b082      	sub	sp, #8
 800fdbc:	af00      	add	r7, sp, #0
 800fdbe:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_KERNEL_POWER_MGR
    CALL_PMOPS_FUNC_VOID(resumeFromInterrupt, intNum);
#else
    if (g_pmOps == NULL) {
 800fdc0:	4b0c      	ldr	r3, [pc, #48]	; (800fdf4 <OsPowerMgrWakeUpFromInterrupt+0x3c>)
 800fdc2:	681b      	ldr	r3, [r3, #0]
 800fdc4:	2b00      	cmp	r3, #0
 800fdc6:	d103      	bne.n	800fdd0 <OsPowerMgrWakeUpFromInterrupt+0x18>
#ifdef LOSCFG_KERNEL_TICKLESS
        OsTicklessUpdate(intNum);
 800fdc8:	6878      	ldr	r0, [r7, #4]
 800fdca:	f003 fc21 	bl	8013610 <OsTicklessUpdate>
#endif
    } else {
        CALL_PMOPS_FUNC_VOID(resumeFromInterrupt, intNum);
    }
#endif
}
 800fdce:	e00d      	b.n	800fdec <OsPowerMgrWakeUpFromInterrupt+0x34>
        CALL_PMOPS_FUNC_VOID(resumeFromInterrupt, intNum);
 800fdd0:	4b08      	ldr	r3, [pc, #32]	; (800fdf4 <OsPowerMgrWakeUpFromInterrupt+0x3c>)
 800fdd2:	681b      	ldr	r3, [r3, #0]
 800fdd4:	2b00      	cmp	r3, #0
 800fdd6:	d009      	beq.n	800fdec <OsPowerMgrWakeUpFromInterrupt+0x34>
 800fdd8:	4b06      	ldr	r3, [pc, #24]	; (800fdf4 <OsPowerMgrWakeUpFromInterrupt+0x3c>)
 800fdda:	681b      	ldr	r3, [r3, #0]
 800fddc:	689b      	ldr	r3, [r3, #8]
 800fdde:	2b00      	cmp	r3, #0
 800fde0:	d004      	beq.n	800fdec <OsPowerMgrWakeUpFromInterrupt+0x34>
 800fde2:	4b04      	ldr	r3, [pc, #16]	; (800fdf4 <OsPowerMgrWakeUpFromInterrupt+0x3c>)
 800fde4:	681b      	ldr	r3, [r3, #0]
 800fde6:	689b      	ldr	r3, [r3, #8]
 800fde8:	6878      	ldr	r0, [r7, #4]
 800fdea:	4798      	blx	r3
}
 800fdec:	bf00      	nop
 800fdee:	3708      	adds	r7, #8
 800fdf0:	46bd      	mov	sp, r7
 800fdf2:	bd80      	pop	{r7, pc}
 800fdf4:	20000400 	.word	0x20000400

0800fdf8 <uart_putc>:
#define UART_QUEUE_REC_DELAY   5

STATIC UINT32 g_uartQueue;

INT32 uart_putc(CHAR c)
{
 800fdf8:	b580      	push	{r7, lr}
 800fdfa:	b082      	sub	sp, #8
 800fdfc:	af00      	add	r7, sp, #0
 800fdfe:	4603      	mov	r3, r0
 800fe00:	71fb      	strb	r3, [r7, #7]
    return uart_write(&c, 1, 0);
 800fe02:	1dfb      	adds	r3, r7, #7
 800fe04:	2200      	movs	r2, #0
 800fe06:	2101      	movs	r1, #1
 800fe08:	4618      	mov	r0, r3
 800fe0a:	f000 f881 	bl	800ff10 <uart_write>
 800fe0e:	4603      	mov	r3, r0
}
 800fe10:	4618      	mov	r0, r3
 800fe12:	3708      	adds	r7, #8
 800fe14:	46bd      	mov	sp, r7
 800fe16:	bd80      	pop	{r7, pc}

0800fe18 <uart_getc>:

UINT8 uart_getc(VOID)
{
 800fe18:	b580      	push	{r7, lr}
 800fe1a:	b082      	sub	sp, #8
 800fe1c:	af00      	add	r7, sp, #0
 800fe1e:	4b11      	ldr	r3, [pc, #68]	; (800fe64 <uart_getc+0x4c>)
 800fe20:	681b      	ldr	r3, [r3, #0]
 800fe22:	607b      	str	r3, [r7, #4]
 800fe24:	f04f 0300 	mov.w	r3, #0
    UINT8 ch = 0;
 800fe28:	2300      	movs	r3, #0
 800fe2a:	70fb      	strb	r3, [r7, #3]
    if (g_genericUart.uartReadChar != NULL) {
 800fe2c:	4b0e      	ldr	r3, [pc, #56]	; (800fe68 <uart_getc+0x50>)
 800fe2e:	689b      	ldr	r3, [r3, #8]
 800fe30:	2b00      	cmp	r3, #0
 800fe32:	d004      	beq.n	800fe3e <uart_getc+0x26>
        ch = g_genericUart.uartReadChar();
 800fe34:	4b0c      	ldr	r3, [pc, #48]	; (800fe68 <uart_getc+0x50>)
 800fe36:	689b      	ldr	r3, [r3, #8]
 800fe38:	4798      	blx	r3
 800fe3a:	4603      	mov	r3, r0
 800fe3c:	70fb      	strb	r3, [r7, #3]
    }
    (VOID)LOS_QueueWriteCopy(g_uartQueue, &ch, sizeof(UINT8), 0);
 800fe3e:	4b0b      	ldr	r3, [pc, #44]	; (800fe6c <uart_getc+0x54>)
 800fe40:	6818      	ldr	r0, [r3, #0]
 800fe42:	1cf9      	adds	r1, r7, #3
 800fe44:	2300      	movs	r3, #0
 800fe46:	2201      	movs	r2, #1
 800fe48:	f7fa fbf0 	bl	800a62c <LOS_QueueWriteCopy>
    return ch;
 800fe4c:	78fb      	ldrb	r3, [r7, #3]
}
 800fe4e:	4a05      	ldr	r2, [pc, #20]	; (800fe64 <uart_getc+0x4c>)
 800fe50:	6811      	ldr	r1, [r2, #0]
 800fe52:	687a      	ldr	r2, [r7, #4]
 800fe54:	4051      	eors	r1, r2
 800fe56:	d001      	beq.n	800fe5c <uart_getc+0x44>
 800fe58:	f7f4 fac6 	bl	80043e8 <__stack_chk_fail>
 800fe5c:	4618      	mov	r0, r3
 800fe5e:	3708      	adds	r7, #8
 800fe60:	46bd      	mov	sp, r7
 800fe62:	bd80      	pop	{r7, pc}
 800fe64:	0802173c 	.word	0x0802173c
 800fe68:	20000414 	.word	0x20000414
 800fe6c:	20003280 	.word	0x20003280

0800fe70 <ShellQueueCreat>:
        g_genericUart.uartInit();
    }
}

INT32 ShellQueueCreat(VOID)
{
 800fe70:	b580      	push	{r7, lr}
 800fe72:	b082      	sub	sp, #8
 800fe74:	af02      	add	r7, sp, #8
    return (INT32)LOS_QueueCreate("uartQueue", UART_QUEUE_SIZE, &g_uartQueue, 0, UART_QUEUE_BUF_MAX_LEN);
 800fe76:	2301      	movs	r3, #1
 800fe78:	9300      	str	r3, [sp, #0]
 800fe7a:	2300      	movs	r3, #0
 800fe7c:	4a04      	ldr	r2, [pc, #16]	; (800fe90 <ShellQueueCreat+0x20>)
 800fe7e:	2140      	movs	r1, #64	; 0x40
 800fe80:	4804      	ldr	r0, [pc, #16]	; (800fe94 <ShellQueueCreat+0x24>)
 800fe82:	f7fa f893 	bl	8009fac <LOS_QueueCreate>
 800fe86:	4603      	mov	r3, r0
}
 800fe88:	4618      	mov	r0, r3
 800fe8a:	46bd      	mov	sp, r7
 800fe8c:	bd80      	pop	{r7, pc}
 800fe8e:	bf00      	nop
 800fe90:	20003280 	.word	0x20003280
 800fe94:	08021740 	.word	0x08021740

0800fe98 <uart_hwiCreate>:

INT32 uart_hwiCreate(VOID)
{
 800fe98:	b580      	push	{r7, lr}
 800fe9a:	af00      	add	r7, sp, #0
    if (g_genericUart.uartHwiCreate != NULL) {
 800fe9c:	4b04      	ldr	r3, [pc, #16]	; (800feb0 <uart_hwiCreate+0x18>)
 800fe9e:	68db      	ldr	r3, [r3, #12]
 800fea0:	2b00      	cmp	r3, #0
 800fea2:	d002      	beq.n	800feaa <uart_hwiCreate+0x12>
        g_genericUart.uartHwiCreate();
 800fea4:	4b02      	ldr	r3, [pc, #8]	; (800feb0 <uart_hwiCreate+0x18>)
 800fea6:	68db      	ldr	r3, [r3, #12]
 800fea8:	4798      	blx	r3
    }
    return LOS_OK;
 800feaa:	2300      	movs	r3, #0
}
 800feac:	4618      	mov	r0, r3
 800feae:	bd80      	pop	{r7, pc}
 800feb0:	20000414 	.word	0x20000414

0800feb4 <uart_read>:

UINT8 uart_read(VOID)
{
 800feb4:	b580      	push	{r7, lr}
 800feb6:	b084      	sub	sp, #16
 800feb8:	af00      	add	r7, sp, #0
 800feba:	4b13      	ldr	r3, [pc, #76]	; (800ff08 <uart_read+0x54>)
 800febc:	681b      	ldr	r3, [r3, #0]
 800febe:	60fb      	str	r3, [r7, #12]
 800fec0:	f04f 0300 	mov.w	r3, #0
    UINT8 rec = 0;
 800fec4:	2300      	movs	r3, #0
 800fec6:	70fb      	strb	r3, [r7, #3]
    UINT32 ret;
    UINT32 len;
    len = UART_QUEUE_BUF_MAX_LEN;
 800fec8:	2301      	movs	r3, #1
 800feca:	607b      	str	r3, [r7, #4]
    ret = LOS_QueueReadCopy(g_uartQueue, &rec, &len, LOS_WAIT_FOREVER);
 800fecc:	4b0f      	ldr	r3, [pc, #60]	; (800ff0c <uart_read+0x58>)
 800fece:	6818      	ldr	r0, [r3, #0]
 800fed0:	1d3a      	adds	r2, r7, #4
 800fed2:	1cf9      	adds	r1, r7, #3
 800fed4:	f04f 33ff 	mov.w	r3, #4294967295
 800fed8:	f7fa fb86 	bl	800a5e8 <LOS_QueueReadCopy>
 800fedc:	60b8      	str	r0, [r7, #8]
    if (ret == LOS_OK) {
 800fede:	68bb      	ldr	r3, [r7, #8]
 800fee0:	2b00      	cmp	r3, #0
 800fee2:	d104      	bne.n	800feee <uart_read+0x3a>
        (VOID)LOS_TaskDelay(UART_QUEUE_REC_DELAY);
 800fee4:	2005      	movs	r0, #5
 800fee6:	f7f3 fee3 	bl	8003cb0 <LOS_TaskDelay>
        return rec;
 800feea:	78fb      	ldrb	r3, [r7, #3]
 800feec:	e000      	b.n	800fef0 <uart_read+0x3c>
    }
    return rec;
 800feee:	78fb      	ldrb	r3, [r7, #3]
}
 800fef0:	4a05      	ldr	r2, [pc, #20]	; (800ff08 <uart_read+0x54>)
 800fef2:	6811      	ldr	r1, [r2, #0]
 800fef4:	68fa      	ldr	r2, [r7, #12]
 800fef6:	4051      	eors	r1, r2
 800fef8:	d001      	beq.n	800fefe <uart_read+0x4a>
 800fefa:	f7f4 fa75 	bl	80043e8 <__stack_chk_fail>
 800fefe:	4618      	mov	r0, r3
 800ff00:	3710      	adds	r7, #16
 800ff02:	46bd      	mov	sp, r7
 800ff04:	bd80      	pop	{r7, pc}
 800ff06:	bf00      	nop
 800ff08:	0802174c 	.word	0x0802174c
 800ff0c:	20003280 	.word	0x20003280

0800ff10 <uart_write>:

INT32 uart_write(const CHAR *buf, INT32 len, INT32 timeout)
{
 800ff10:	b580      	push	{r7, lr}
 800ff12:	b086      	sub	sp, #24
 800ff14:	af00      	add	r7, sp, #0
 800ff16:	60f8      	str	r0, [r7, #12]
 800ff18:	60b9      	str	r1, [r7, #8]
 800ff1a:	607a      	str	r2, [r7, #4]
    (VOID)timeout;
    UINT32 i;
    for (i = 0; i < len; i++) {  
 800ff1c:	2300      	movs	r3, #0
 800ff1e:	617b      	str	r3, [r7, #20]
 800ff20:	e00e      	b.n	800ff40 <uart_write+0x30>
        if (g_genericUart.uartWriteChar != NULL) {
 800ff22:	4b0c      	ldr	r3, [pc, #48]	; (800ff54 <uart_write+0x44>)
 800ff24:	685b      	ldr	r3, [r3, #4]
 800ff26:	2b00      	cmp	r3, #0
 800ff28:	d007      	beq.n	800ff3a <uart_write+0x2a>
            g_genericUart.uartWriteChar(buf[i]);
 800ff2a:	4b0a      	ldr	r3, [pc, #40]	; (800ff54 <uart_write+0x44>)
 800ff2c:	685b      	ldr	r3, [r3, #4]
 800ff2e:	68f9      	ldr	r1, [r7, #12]
 800ff30:	697a      	ldr	r2, [r7, #20]
 800ff32:	440a      	add	r2, r1
 800ff34:	7812      	ldrb	r2, [r2, #0]
 800ff36:	4610      	mov	r0, r2
 800ff38:	4798      	blx	r3
    for (i = 0; i < len; i++) {  
 800ff3a:	697b      	ldr	r3, [r7, #20]
 800ff3c:	3301      	adds	r3, #1
 800ff3e:	617b      	str	r3, [r7, #20]
 800ff40:	68bb      	ldr	r3, [r7, #8]
 800ff42:	697a      	ldr	r2, [r7, #20]
 800ff44:	429a      	cmp	r2, r3
 800ff46:	d3ec      	bcc.n	800ff22 <uart_write+0x12>
        }
    }
    return len;
 800ff48:	68bb      	ldr	r3, [r7, #8]
}
 800ff4a:	4618      	mov	r0, r3
 800ff4c:	3718      	adds	r7, #24
 800ff4e:	46bd      	mov	sp, r7
 800ff50:	bd80      	pop	{r7, pc}
 800ff52:	bf00      	nop
 800ff54:	20000414 	.word	0x20000414

0800ff58 <UartPuts>:

VOID UartPuts(const CHAR *s, UINT32 len, BOOL isLock)
{
 800ff58:	b580      	push	{r7, lr}
 800ff5a:	b086      	sub	sp, #24
 800ff5c:	af00      	add	r7, sp, #0
 800ff5e:	60f8      	str	r0, [r7, #12]
 800ff60:	60b9      	str	r1, [r7, #8]
 800ff62:	607a      	str	r2, [r7, #4]
    UINT32 i;
    (VOID)isLock;
    if (s == NULL) {
 800ff64:	68fb      	ldr	r3, [r7, #12]
 800ff66:	2b00      	cmp	r3, #0
 800ff68:	d01a      	beq.n	800ffa0 <UartPuts+0x48>
        return;
    }
    for (i = 0; i < len; i++) {
 800ff6a:	2300      	movs	r3, #0
 800ff6c:	617b      	str	r3, [r7, #20]
 800ff6e:	e012      	b.n	800ff96 <UartPuts+0x3e>
        /*
         * Only system uart output needs to add extra '\r' to improve
         * the compatibility.
         */
        if (*(s + i) == '\n') {
 800ff70:	68fa      	ldr	r2, [r7, #12]
 800ff72:	697b      	ldr	r3, [r7, #20]
 800ff74:	4413      	add	r3, r2
 800ff76:	781b      	ldrb	r3, [r3, #0]
 800ff78:	2b0a      	cmp	r3, #10
 800ff7a:	d102      	bne.n	800ff82 <UartPuts+0x2a>
            (VOID)uart_putc('\r');
 800ff7c:	200d      	movs	r0, #13
 800ff7e:	f7ff ff3b 	bl	800fdf8 <uart_putc>
        }
        (VOID)uart_putc(*(s + i));
 800ff82:	68fa      	ldr	r2, [r7, #12]
 800ff84:	697b      	ldr	r3, [r7, #20]
 800ff86:	4413      	add	r3, r2
 800ff88:	781b      	ldrb	r3, [r3, #0]
 800ff8a:	4618      	mov	r0, r3
 800ff8c:	f7ff ff34 	bl	800fdf8 <uart_putc>
    for (i = 0; i < len; i++) {
 800ff90:	697b      	ldr	r3, [r7, #20]
 800ff92:	3301      	adds	r3, #1
 800ff94:	617b      	str	r3, [r7, #20]
 800ff96:	697a      	ldr	r2, [r7, #20]
 800ff98:	68bb      	ldr	r3, [r7, #8]
 800ff9a:	429a      	cmp	r2, r3
 800ff9c:	d3e8      	bcc.n	800ff70 <UartPuts+0x18>
 800ff9e:	e000      	b.n	800ffa2 <UartPuts+0x4a>
        return;
 800ffa0:	bf00      	nop
    }
}
 800ffa2:	3718      	adds	r7, #24
 800ffa4:	46bd      	mov	sp, r7
 800ffa6:	bd80      	pop	{r7, pc}

0800ffa8 <uart_init>:

VOID uart_init(VOID) 
{
 800ffa8:	b480      	push	{r7}
 800ffaa:	af00      	add	r7, sp, #0
}
 800ffac:	bf00      	nop
 800ffae:	46bd      	mov	sp, r7
 800ffb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ffb4:	4770      	bx	lr

0800ffb6 <LOS_IntLock>:
{
 800ffb6:	b580      	push	{r7, lr}
 800ffb8:	af00      	add	r7, sp, #0
    return ArchIntLock();
 800ffba:	f7f0 fe85 	bl	8000cc8 <ArchIntLock>
 800ffbe:	4603      	mov	r3, r0
}
 800ffc0:	4618      	mov	r0, r3
 800ffc2:	bd80      	pop	{r7, pc}

0800ffc4 <LOS_IntRestore>:
{
 800ffc4:	b580      	push	{r7, lr}
 800ffc6:	b082      	sub	sp, #8
 800ffc8:	af00      	add	r7, sp, #0
 800ffca:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800ffcc:	6878      	ldr	r0, [r7, #4]
 800ffce:	f7f0 fe83 	bl	8000cd8 <ArchIntRestore>
}
 800ffd2:	bf00      	nop
 800ffd4:	3708      	adds	r7, #8
 800ffd6:	46bd      	mov	sp, r7
 800ffd8:	bd80      	pop	{r7, pc}

0800ffda <LOS_SpinLockSave>:
{
 800ffda:	b580      	push	{r7, lr}
 800ffdc:	b082      	sub	sp, #8
 800ffde:	af00      	add	r7, sp, #0
 800ffe0:	6078      	str	r0, [r7, #4]
 800ffe2:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 800ffe4:	f7ff ffe7 	bl	800ffb6 <LOS_IntLock>
 800ffe8:	4602      	mov	r2, r0
 800ffea:	683b      	ldr	r3, [r7, #0]
 800ffec:	601a      	str	r2, [r3, #0]
}
 800ffee:	bf00      	nop
 800fff0:	3708      	adds	r7, #8
 800fff2:	46bd      	mov	sp, r7
 800fff4:	bd80      	pop	{r7, pc}

0800fff6 <LOS_SpinUnlockRestore>:
{
 800fff6:	b580      	push	{r7, lr}
 800fff8:	b082      	sub	sp, #8
 800fffa:	af00      	add	r7, sp, #0
 800fffc:	6078      	str	r0, [r7, #4]
 800fffe:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8010000:	6838      	ldr	r0, [r7, #0]
 8010002:	f7ff ffdf 	bl	800ffc4 <LOS_IntRestore>
}
 8010006:	bf00      	nop
 8010008:	3708      	adds	r7, #8
 801000a:	46bd      	mov	sp, r7
 801000c:	bd80      	pop	{r7, pc}
	...

08010010 <OsLockConsole>:
    "INFO",
    "DEBUG"
};

STATIC VOID OsLockConsole(VOID)
{
 8010010:	b480      	push	{r7}
 8010012:	af00      	add	r7, sp, #0
    g_consoleLock = 1;
 8010014:	4b03      	ldr	r3, [pc, #12]	; (8010024 <OsLockConsole+0x14>)
 8010016:	2201      	movs	r2, #1
 8010018:	601a      	str	r2, [r3, #0]
}
 801001a:	bf00      	nop
 801001c:	46bd      	mov	sp, r7
 801001e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010022:	4770      	bx	lr
 8010024:	20003294 	.word	0x20003294

08010028 <OsUnlockConsole>:

STATIC VOID OsUnlockConsole(VOID)
{
 8010028:	b480      	push	{r7}
 801002a:	af00      	add	r7, sp, #0
    g_consoleLock = 0;
 801002c:	4b03      	ldr	r3, [pc, #12]	; (801003c <OsUnlockConsole+0x14>)
 801002e:	2200      	movs	r2, #0
 8010030:	601a      	str	r2, [r3, #0]
}
 8010032:	bf00      	nop
 8010034:	46bd      	mov	sp, r7
 8010036:	f85d 7b04 	ldr.w	r7, [sp], #4
 801003a:	4770      	bx	lr
 801003c:	20003294 	.word	0x20003294

08010040 <OsLockUart>:

STATIC VOID OsLockUart(VOID)
{
 8010040:	b480      	push	{r7}
 8010042:	af00      	add	r7, sp, #0
    g_uartLock = 1;
 8010044:	4b03      	ldr	r3, [pc, #12]	; (8010054 <OsLockUart+0x14>)
 8010046:	2201      	movs	r2, #1
 8010048:	601a      	str	r2, [r3, #0]
}
 801004a:	bf00      	nop
 801004c:	46bd      	mov	sp, r7
 801004e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010052:	4770      	bx	lr
 8010054:	20003298 	.word	0x20003298

08010058 <OsUnlockUart>:

STATIC VOID OsUnlockUart(VOID)
{
 8010058:	b480      	push	{r7}
 801005a:	af00      	add	r7, sp, #0
    g_uartLock = 0;
 801005c:	4b03      	ldr	r3, [pc, #12]	; (801006c <OsUnlockUart+0x14>)
 801005e:	2200      	movs	r2, #0
 8010060:	601a      	str	r2, [r3, #0]
}
 8010062:	bf00      	nop
 8010064:	46bd      	mov	sp, r7
 8010066:	f85d 7b04 	ldr.w	r7, [sp], #4
 801006a:	4770      	bx	lr
 801006c:	20003298 	.word	0x20003298

08010070 <OsCheckError>:

STATIC UINT32 OsCheckError(VOID)
{
 8010070:	b480      	push	{r7}
 8010072:	af00      	add	r7, sp, #0
    if (g_dmesgInfo == NULL) {
 8010074:	4b15      	ldr	r3, [pc, #84]	; (80100cc <OsCheckError+0x5c>)
 8010076:	681b      	ldr	r3, [r3, #0]
 8010078:	2b00      	cmp	r3, #0
 801007a:	d101      	bne.n	8010080 <OsCheckError+0x10>
        return LOS_NOK;
 801007c:	2301      	movs	r3, #1
 801007e:	e01f      	b.n	80100c0 <OsCheckError+0x50>
    }

    if (g_dmesgInfo->logSize > g_logBufSize) {
 8010080:	4b12      	ldr	r3, [pc, #72]	; (80100cc <OsCheckError+0x5c>)
 8010082:	681b      	ldr	r3, [r3, #0]
 8010084:	681a      	ldr	r2, [r3, #0]
 8010086:	4b12      	ldr	r3, [pc, #72]	; (80100d0 <OsCheckError+0x60>)
 8010088:	681b      	ldr	r3, [r3, #0]
 801008a:	429a      	cmp	r2, r3
 801008c:	d901      	bls.n	8010092 <OsCheckError+0x22>
        return LOS_NOK;
 801008e:	2301      	movs	r3, #1
 8010090:	e016      	b.n	80100c0 <OsCheckError+0x50>
    }

    if (((g_dmesgInfo->logSize == g_logBufSize) || (g_dmesgInfo->logSize == 0)) &&
 8010092:	4b0e      	ldr	r3, [pc, #56]	; (80100cc <OsCheckError+0x5c>)
 8010094:	681b      	ldr	r3, [r3, #0]
 8010096:	681a      	ldr	r2, [r3, #0]
 8010098:	4b0d      	ldr	r3, [pc, #52]	; (80100d0 <OsCheckError+0x60>)
 801009a:	681b      	ldr	r3, [r3, #0]
 801009c:	429a      	cmp	r2, r3
 801009e:	d004      	beq.n	80100aa <OsCheckError+0x3a>
 80100a0:	4b0a      	ldr	r3, [pc, #40]	; (80100cc <OsCheckError+0x5c>)
 80100a2:	681b      	ldr	r3, [r3, #0]
 80100a4:	681b      	ldr	r3, [r3, #0]
 80100a6:	2b00      	cmp	r3, #0
 80100a8:	d109      	bne.n	80100be <OsCheckError+0x4e>
        (g_dmesgInfo->logTail != g_dmesgInfo->logHead)) {
 80100aa:	4b08      	ldr	r3, [pc, #32]	; (80100cc <OsCheckError+0x5c>)
 80100ac:	681b      	ldr	r3, [r3, #0]
 80100ae:	689a      	ldr	r2, [r3, #8]
 80100b0:	4b06      	ldr	r3, [pc, #24]	; (80100cc <OsCheckError+0x5c>)
 80100b2:	681b      	ldr	r3, [r3, #0]
 80100b4:	685b      	ldr	r3, [r3, #4]
    if (((g_dmesgInfo->logSize == g_logBufSize) || (g_dmesgInfo->logSize == 0)) &&
 80100b6:	429a      	cmp	r2, r3
 80100b8:	d001      	beq.n	80100be <OsCheckError+0x4e>
        return LOS_NOK;
 80100ba:	2301      	movs	r3, #1
 80100bc:	e000      	b.n	80100c0 <OsCheckError+0x50>
    }

    return LOS_OK;
 80100be:	2300      	movs	r3, #0
}
 80100c0:	4618      	mov	r0, r3
 80100c2:	46bd      	mov	sp, r7
 80100c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80100c8:	4770      	bx	lr
 80100ca:	bf00      	nop
 80100cc:	20003288 	.word	0x20003288
 80100d0:	2000328c 	.word	0x2000328c

080100d4 <OsDmesgRead>:

STATIC INT32 OsDmesgRead(CHAR *buf, UINT32 len)
{
 80100d4:	b580      	push	{r7, lr}
 80100d6:	b088      	sub	sp, #32
 80100d8:	af00      	add	r7, sp, #0
 80100da:	6078      	str	r0, [r7, #4]
 80100dc:	6039      	str	r1, [r7, #0]
    UINT32 readLen;
    UINT32 logSize = g_dmesgInfo->logSize;
 80100de:	4b59      	ldr	r3, [pc, #356]	; (8010244 <OsDmesgRead+0x170>)
 80100e0:	681b      	ldr	r3, [r3, #0]
 80100e2:	681b      	ldr	r3, [r3, #0]
 80100e4:	60bb      	str	r3, [r7, #8]
    UINT32 head = g_dmesgInfo->logHead;
 80100e6:	4b57      	ldr	r3, [pc, #348]	; (8010244 <OsDmesgRead+0x170>)
 80100e8:	681b      	ldr	r3, [r3, #0]
 80100ea:	685b      	ldr	r3, [r3, #4]
 80100ec:	60fb      	str	r3, [r7, #12]
    UINT32 tail = g_dmesgInfo->logTail;
 80100ee:	4b55      	ldr	r3, [pc, #340]	; (8010244 <OsDmesgRead+0x170>)
 80100f0:	681b      	ldr	r3, [r3, #0]
 80100f2:	689b      	ldr	r3, [r3, #8]
 80100f4:	613b      	str	r3, [r7, #16]
    CHAR *logBuf = g_dmesgInfo->logBuf;
 80100f6:	4b53      	ldr	r3, [pc, #332]	; (8010244 <OsDmesgRead+0x170>)
 80100f8:	681b      	ldr	r3, [r3, #0]
 80100fa:	68db      	ldr	r3, [r3, #12]
 80100fc:	617b      	str	r3, [r7, #20]
    errno_t ret;

    if (OsCheckError()) {
 80100fe:	f7ff ffb7 	bl	8010070 <OsCheckError>
 8010102:	4603      	mov	r3, r0
 8010104:	2b00      	cmp	r3, #0
 8010106:	d002      	beq.n	801010e <OsDmesgRead+0x3a>
        return -1;
 8010108:	f04f 33ff 	mov.w	r3, #4294967295
 801010c:	e096      	b.n	801023c <OsDmesgRead+0x168>
    }
    if (logSize == 0) {
 801010e:	68bb      	ldr	r3, [r7, #8]
 8010110:	2b00      	cmp	r3, #0
 8010112:	d101      	bne.n	8010118 <OsDmesgRead+0x44>
        return 0;
 8010114:	2300      	movs	r3, #0
 8010116:	e091      	b.n	801023c <OsDmesgRead+0x168>
    }

    readLen = len < logSize ? len : logSize;
 8010118:	68ba      	ldr	r2, [r7, #8]
 801011a:	683b      	ldr	r3, [r7, #0]
 801011c:	4293      	cmp	r3, r2
 801011e:	bf28      	it	cs
 8010120:	4613      	movcs	r3, r2
 8010122:	61bb      	str	r3, [r7, #24]

    if (head < tail) { /* Case A */
 8010124:	68fa      	ldr	r2, [r7, #12]
 8010126:	693b      	ldr	r3, [r7, #16]
 8010128:	429a      	cmp	r2, r3
 801012a:	d21f      	bcs.n	801016c <OsDmesgRead+0x98>
        ret = memcpy_s(buf, len, logBuf + head, readLen);
 801012c:	697a      	ldr	r2, [r7, #20]
 801012e:	68fb      	ldr	r3, [r7, #12]
 8010130:	441a      	add	r2, r3
 8010132:	69bb      	ldr	r3, [r7, #24]
 8010134:	6839      	ldr	r1, [r7, #0]
 8010136:	6878      	ldr	r0, [r7, #4]
 8010138:	f006 fa30 	bl	801659c <memcpy_s>
 801013c:	61f8      	str	r0, [r7, #28]
        if (ret != EOK) {
 801013e:	69fb      	ldr	r3, [r7, #28]
 8010140:	2b00      	cmp	r3, #0
 8010142:	d002      	beq.n	801014a <OsDmesgRead+0x76>
            return -1;
 8010144:	f04f 33ff 	mov.w	r3, #4294967295
 8010148:	e078      	b.n	801023c <OsDmesgRead+0x168>
        }
        g_dmesgInfo->logHead += readLen;
 801014a:	4b3e      	ldr	r3, [pc, #248]	; (8010244 <OsDmesgRead+0x170>)
 801014c:	681b      	ldr	r3, [r3, #0]
 801014e:	6859      	ldr	r1, [r3, #4]
 8010150:	4b3c      	ldr	r3, [pc, #240]	; (8010244 <OsDmesgRead+0x170>)
 8010152:	681b      	ldr	r3, [r3, #0]
 8010154:	69ba      	ldr	r2, [r7, #24]
 8010156:	440a      	add	r2, r1
 8010158:	605a      	str	r2, [r3, #4]
        g_dmesgInfo->logSize -= readLen;
 801015a:	4b3a      	ldr	r3, [pc, #232]	; (8010244 <OsDmesgRead+0x170>)
 801015c:	681b      	ldr	r3, [r3, #0]
 801015e:	6819      	ldr	r1, [r3, #0]
 8010160:	4b38      	ldr	r3, [pc, #224]	; (8010244 <OsDmesgRead+0x170>)
 8010162:	681b      	ldr	r3, [r3, #0]
 8010164:	69ba      	ldr	r2, [r7, #24]
 8010166:	1a8a      	subs	r2, r1, r2
 8010168:	601a      	str	r2, [r3, #0]
 801016a:	e066      	b.n	801023a <OsDmesgRead+0x166>
    } else { /* Case B */
        if (readLen <= (g_logBufSize - head)) {
 801016c:	4b36      	ldr	r3, [pc, #216]	; (8010248 <OsDmesgRead+0x174>)
 801016e:	681a      	ldr	r2, [r3, #0]
 8010170:	68fb      	ldr	r3, [r7, #12]
 8010172:	1ad3      	subs	r3, r2, r3
 8010174:	69ba      	ldr	r2, [r7, #24]
 8010176:	429a      	cmp	r2, r3
 8010178:	d81f      	bhi.n	80101ba <OsDmesgRead+0xe6>
            ret = memcpy_s(buf, len, logBuf + head, readLen);
 801017a:	697a      	ldr	r2, [r7, #20]
 801017c:	68fb      	ldr	r3, [r7, #12]
 801017e:	441a      	add	r2, r3
 8010180:	69bb      	ldr	r3, [r7, #24]
 8010182:	6839      	ldr	r1, [r7, #0]
 8010184:	6878      	ldr	r0, [r7, #4]
 8010186:	f006 fa09 	bl	801659c <memcpy_s>
 801018a:	61f8      	str	r0, [r7, #28]
            if (ret != EOK) {
 801018c:	69fb      	ldr	r3, [r7, #28]
 801018e:	2b00      	cmp	r3, #0
 8010190:	d002      	beq.n	8010198 <OsDmesgRead+0xc4>
                return -1;
 8010192:	f04f 33ff 	mov.w	r3, #4294967295
 8010196:	e051      	b.n	801023c <OsDmesgRead+0x168>
            }
            g_dmesgInfo->logHead += readLen;
 8010198:	4b2a      	ldr	r3, [pc, #168]	; (8010244 <OsDmesgRead+0x170>)
 801019a:	681b      	ldr	r3, [r3, #0]
 801019c:	6859      	ldr	r1, [r3, #4]
 801019e:	4b29      	ldr	r3, [pc, #164]	; (8010244 <OsDmesgRead+0x170>)
 80101a0:	681b      	ldr	r3, [r3, #0]
 80101a2:	69ba      	ldr	r2, [r7, #24]
 80101a4:	440a      	add	r2, r1
 80101a6:	605a      	str	r2, [r3, #4]
            g_dmesgInfo->logSize -= readLen;
 80101a8:	4b26      	ldr	r3, [pc, #152]	; (8010244 <OsDmesgRead+0x170>)
 80101aa:	681b      	ldr	r3, [r3, #0]
 80101ac:	6819      	ldr	r1, [r3, #0]
 80101ae:	4b25      	ldr	r3, [pc, #148]	; (8010244 <OsDmesgRead+0x170>)
 80101b0:	681b      	ldr	r3, [r3, #0]
 80101b2:	69ba      	ldr	r2, [r7, #24]
 80101b4:	1a8a      	subs	r2, r1, r2
 80101b6:	601a      	str	r2, [r3, #0]
 80101b8:	e03f      	b.n	801023a <OsDmesgRead+0x166>
        } else {
            ret = memcpy_s(buf, len, logBuf + head, g_logBufSize - head);
 80101ba:	697a      	ldr	r2, [r7, #20]
 80101bc:	68fb      	ldr	r3, [r7, #12]
 80101be:	18d1      	adds	r1, r2, r3
 80101c0:	4b21      	ldr	r3, [pc, #132]	; (8010248 <OsDmesgRead+0x174>)
 80101c2:	681a      	ldr	r2, [r3, #0]
 80101c4:	68fb      	ldr	r3, [r7, #12]
 80101c6:	1ad3      	subs	r3, r2, r3
 80101c8:	460a      	mov	r2, r1
 80101ca:	6839      	ldr	r1, [r7, #0]
 80101cc:	6878      	ldr	r0, [r7, #4]
 80101ce:	f006 f9e5 	bl	801659c <memcpy_s>
 80101d2:	61f8      	str	r0, [r7, #28]
            if (ret != EOK) {
 80101d4:	69fb      	ldr	r3, [r7, #28]
 80101d6:	2b00      	cmp	r3, #0
 80101d8:	d002      	beq.n	80101e0 <OsDmesgRead+0x10c>
                return -1;
 80101da:	f04f 33ff 	mov.w	r3, #4294967295
 80101de:	e02d      	b.n	801023c <OsDmesgRead+0x168>
            }

            ret = memcpy_s(buf + g_logBufSize - head, len - (g_logBufSize - head),
 80101e0:	4b19      	ldr	r3, [pc, #100]	; (8010248 <OsDmesgRead+0x174>)
 80101e2:	681a      	ldr	r2, [r3, #0]
 80101e4:	68fb      	ldr	r3, [r7, #12]
 80101e6:	1ad3      	subs	r3, r2, r3
 80101e8:	687a      	ldr	r2, [r7, #4]
 80101ea:	18d0      	adds	r0, r2, r3
 80101ec:	4b16      	ldr	r3, [pc, #88]	; (8010248 <OsDmesgRead+0x174>)
 80101ee:	681b      	ldr	r3, [r3, #0]
 80101f0:	68fa      	ldr	r2, [r7, #12]
 80101f2:	1ad2      	subs	r2, r2, r3
 80101f4:	683b      	ldr	r3, [r7, #0]
 80101f6:	18d1      	adds	r1, r2, r3
                           logBuf, readLen - (g_logBufSize - head));
 80101f8:	4b13      	ldr	r3, [pc, #76]	; (8010248 <OsDmesgRead+0x174>)
 80101fa:	681b      	ldr	r3, [r3, #0]
 80101fc:	68fa      	ldr	r2, [r7, #12]
 80101fe:	1ad2      	subs	r2, r2, r3
            ret = memcpy_s(buf + g_logBufSize - head, len - (g_logBufSize - head),
 8010200:	69bb      	ldr	r3, [r7, #24]
 8010202:	4413      	add	r3, r2
 8010204:	697a      	ldr	r2, [r7, #20]
 8010206:	f006 f9c9 	bl	801659c <memcpy_s>
 801020a:	61f8      	str	r0, [r7, #28]
            if (ret != EOK) {
 801020c:	69fb      	ldr	r3, [r7, #28]
 801020e:	2b00      	cmp	r3, #0
 8010210:	d002      	beq.n	8010218 <OsDmesgRead+0x144>
                return -1;
 8010212:	f04f 33ff 	mov.w	r3, #4294967295
 8010216:	e011      	b.n	801023c <OsDmesgRead+0x168>
            }
            g_dmesgInfo->logHead = readLen - (g_logBufSize - head);
 8010218:	4b0b      	ldr	r3, [pc, #44]	; (8010248 <OsDmesgRead+0x174>)
 801021a:	681b      	ldr	r3, [r3, #0]
 801021c:	68fa      	ldr	r2, [r7, #12]
 801021e:	1ad1      	subs	r1, r2, r3
 8010220:	4b08      	ldr	r3, [pc, #32]	; (8010244 <OsDmesgRead+0x170>)
 8010222:	681b      	ldr	r3, [r3, #0]
 8010224:	69ba      	ldr	r2, [r7, #24]
 8010226:	440a      	add	r2, r1
 8010228:	605a      	str	r2, [r3, #4]
            g_dmesgInfo->logSize -= readLen;
 801022a:	4b06      	ldr	r3, [pc, #24]	; (8010244 <OsDmesgRead+0x170>)
 801022c:	681b      	ldr	r3, [r3, #0]
 801022e:	6819      	ldr	r1, [r3, #0]
 8010230:	4b04      	ldr	r3, [pc, #16]	; (8010244 <OsDmesgRead+0x170>)
 8010232:	681b      	ldr	r3, [r3, #0]
 8010234:	69ba      	ldr	r2, [r7, #24]
 8010236:	1a8a      	subs	r2, r1, r2
 8010238:	601a      	str	r2, [r3, #0]
        }
    }
    return (INT32)readLen;
 801023a:	69bb      	ldr	r3, [r7, #24]
}
 801023c:	4618      	mov	r0, r3
 801023e:	3720      	adds	r7, #32
 8010240:	46bd      	mov	sp, r7
 8010242:	bd80      	pop	{r7, pc}
 8010244:	20003288 	.word	0x20003288
 8010248:	2000328c 	.word	0x2000328c

0801024c <OsCopyToNew>:

STATIC INT32 OsCopyToNew(VOID *addr, UINT32 size)
{
 801024c:	b580      	push	{r7, lr}
 801024e:	b088      	sub	sp, #32
 8010250:	af00      	add	r7, sp, #0
 8010252:	6078      	str	r0, [r7, #4]
 8010254:	6039      	str	r1, [r7, #0]
    UINT32 copyStart = 0;
 8010256:	2300      	movs	r3, #0
 8010258:	60bb      	str	r3, [r7, #8]
    UINT32 copyLen;
    CHAR *temp = NULL;
 801025a:	2300      	movs	r3, #0
 801025c:	60fb      	str	r3, [r7, #12]
    CHAR *newBuf = (CHAR *)addr + sizeof(DmesgInfo);
 801025e:	687b      	ldr	r3, [r7, #4]
 8010260:	3310      	adds	r3, #16
 8010262:	613b      	str	r3, [r7, #16]
    UINT32 bufSize = size - sizeof(DmesgInfo);
 8010264:	683b      	ldr	r3, [r7, #0]
 8010266:	3b10      	subs	r3, #16
 8010268:	617b      	str	r3, [r7, #20]
    INT32 ret;

    if (g_dmesgInfo->logSize == 0) {
 801026a:	4b37      	ldr	r3, [pc, #220]	; (8010348 <OsCopyToNew+0xfc>)
 801026c:	681b      	ldr	r3, [r3, #0]
 801026e:	681b      	ldr	r3, [r3, #0]
 8010270:	2b00      	cmp	r3, #0
 8010272:	d101      	bne.n	8010278 <OsCopyToNew+0x2c>
        return 0;
 8010274:	2300      	movs	r3, #0
 8010276:	e063      	b.n	8010340 <OsCopyToNew+0xf4>
    }

    temp = (CHAR *)malloc(g_dmesgInfo->logSize);
 8010278:	4b33      	ldr	r3, [pc, #204]	; (8010348 <OsCopyToNew+0xfc>)
 801027a:	681b      	ldr	r3, [r3, #0]
 801027c:	681b      	ldr	r3, [r3, #0]
 801027e:	4618      	mov	r0, r3
 8010280:	f00a fabc 	bl	801a7fc <malloc>
 8010284:	60f8      	str	r0, [r7, #12]
    if (temp == NULL) {
 8010286:	68fb      	ldr	r3, [r7, #12]
 8010288:	2b00      	cmp	r3, #0
 801028a:	d102      	bne.n	8010292 <OsCopyToNew+0x46>
        return -1;
 801028c:	f04f 33ff 	mov.w	r3, #4294967295
 8010290:	e056      	b.n	8010340 <OsCopyToNew+0xf4>
    }

    (VOID)memset_s(temp, g_dmesgInfo->logSize, 0, g_dmesgInfo->logSize);
 8010292:	4b2d      	ldr	r3, [pc, #180]	; (8010348 <OsCopyToNew+0xfc>)
 8010294:	681b      	ldr	r3, [r3, #0]
 8010296:	6819      	ldr	r1, [r3, #0]
 8010298:	4b2b      	ldr	r3, [pc, #172]	; (8010348 <OsCopyToNew+0xfc>)
 801029a:	681b      	ldr	r3, [r3, #0]
 801029c:	681b      	ldr	r3, [r3, #0]
 801029e:	2200      	movs	r2, #0
 80102a0:	68f8      	ldr	r0, [r7, #12]
 80102a2:	f005 fef3 	bl	801608c <memset_s>
    copyLen = ((bufSize < g_dmesgInfo->logSize) ? bufSize : g_dmesgInfo->logSize);
 80102a6:	4b28      	ldr	r3, [pc, #160]	; (8010348 <OsCopyToNew+0xfc>)
 80102a8:	681b      	ldr	r3, [r3, #0]
 80102aa:	681b      	ldr	r3, [r3, #0]
 80102ac:	697a      	ldr	r2, [r7, #20]
 80102ae:	4293      	cmp	r3, r2
 80102b0:	bf28      	it	cs
 80102b2:	4613      	movcs	r3, r2
 80102b4:	61bb      	str	r3, [r7, #24]
    if (bufSize < g_dmesgInfo->logSize) {
 80102b6:	4b24      	ldr	r3, [pc, #144]	; (8010348 <OsCopyToNew+0xfc>)
 80102b8:	681b      	ldr	r3, [r3, #0]
 80102ba:	681b      	ldr	r3, [r3, #0]
 80102bc:	697a      	ldr	r2, [r7, #20]
 80102be:	429a      	cmp	r2, r3
 80102c0:	d205      	bcs.n	80102ce <OsCopyToNew+0x82>
        copyStart = g_dmesgInfo->logSize - bufSize;
 80102c2:	4b21      	ldr	r3, [pc, #132]	; (8010348 <OsCopyToNew+0xfc>)
 80102c4:	681b      	ldr	r3, [r3, #0]
 80102c6:	681a      	ldr	r2, [r3, #0]
 80102c8:	697b      	ldr	r3, [r7, #20]
 80102ca:	1ad3      	subs	r3, r2, r3
 80102cc:	60bb      	str	r3, [r7, #8]
    }

    ret = OsDmesgRead(temp, g_dmesgInfo->logSize);
 80102ce:	4b1e      	ldr	r3, [pc, #120]	; (8010348 <OsCopyToNew+0xfc>)
 80102d0:	681b      	ldr	r3, [r3, #0]
 80102d2:	681b      	ldr	r3, [r3, #0]
 80102d4:	4619      	mov	r1, r3
 80102d6:	68f8      	ldr	r0, [r7, #12]
 80102d8:	f7ff fefc 	bl	80100d4 <OsDmesgRead>
 80102dc:	61f8      	str	r0, [r7, #28]
    if (ret <= 0) {
 80102de:	69fb      	ldr	r3, [r7, #28]
 80102e0:	2b00      	cmp	r3, #0
 80102e2:	dc0e      	bgt.n	8010302 <OsCopyToNew+0xb6>
        PRINT_ERR("%s,%d failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 80102e4:	4819      	ldr	r0, [pc, #100]	; (801034c <OsCopyToNew+0x100>)
 80102e6:	f7f4 f9f1 	bl	80046cc <dprintf>
 80102ea:	69fb      	ldr	r3, [r7, #28]
 80102ec:	22cd      	movs	r2, #205	; 0xcd
 80102ee:	4918      	ldr	r1, [pc, #96]	; (8010350 <OsCopyToNew+0x104>)
 80102f0:	4818      	ldr	r0, [pc, #96]	; (8010354 <OsCopyToNew+0x108>)
 80102f2:	f7f4 f9eb 	bl	80046cc <dprintf>
        free(temp);
 80102f6:	68f8      	ldr	r0, [r7, #12]
 80102f8:	f00a fa6c 	bl	801a7d4 <free>
        return -1;
 80102fc:	f04f 33ff 	mov.w	r3, #4294967295
 8010300:	e01e      	b.n	8010340 <OsCopyToNew+0xf4>
    }

    /* if new buf size smaller than logSize */
    ret = memcpy_s(newBuf, bufSize, temp + copyStart, copyLen);
 8010302:	68fa      	ldr	r2, [r7, #12]
 8010304:	68bb      	ldr	r3, [r7, #8]
 8010306:	441a      	add	r2, r3
 8010308:	69bb      	ldr	r3, [r7, #24]
 801030a:	6979      	ldr	r1, [r7, #20]
 801030c:	6938      	ldr	r0, [r7, #16]
 801030e:	f006 f945 	bl	801659c <memcpy_s>
 8010312:	61f8      	str	r0, [r7, #28]
    if (ret != EOK) {
 8010314:	69fb      	ldr	r3, [r7, #28]
 8010316:	2b00      	cmp	r3, #0
 8010318:	d00e      	beq.n	8010338 <OsCopyToNew+0xec>
        PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 801031a:	480c      	ldr	r0, [pc, #48]	; (801034c <OsCopyToNew+0x100>)
 801031c:	f7f4 f9d6 	bl	80046cc <dprintf>
 8010320:	69fb      	ldr	r3, [r7, #28]
 8010322:	22d5      	movs	r2, #213	; 0xd5
 8010324:	490a      	ldr	r1, [pc, #40]	; (8010350 <OsCopyToNew+0x104>)
 8010326:	480c      	ldr	r0, [pc, #48]	; (8010358 <OsCopyToNew+0x10c>)
 8010328:	f7f4 f9d0 	bl	80046cc <dprintf>
        free(temp);
 801032c:	68f8      	ldr	r0, [r7, #12]
 801032e:	f00a fa51 	bl	801a7d4 <free>
        return -1;
 8010332:	f04f 33ff 	mov.w	r3, #4294967295
 8010336:	e003      	b.n	8010340 <OsCopyToNew+0xf4>
    }
    free(temp);
 8010338:	68f8      	ldr	r0, [r7, #12]
 801033a:	f00a fa4b 	bl	801a7d4 <free>

    return (INT32)copyLen;
 801033e:	69bb      	ldr	r3, [r7, #24]
}
 8010340:	4618      	mov	r0, r3
 8010342:	3720      	adds	r7, #32
 8010344:	46bd      	mov	sp, r7
 8010346:	bd80      	pop	{r7, pc}
 8010348:	20003288 	.word	0x20003288
 801034c:	08021778 	.word	0x08021778
 8010350:	080234fc 	.word	0x080234fc
 8010354:	08021780 	.word	0x08021780
 8010358:	08021798 	.word	0x08021798

0801035c <OsDmesgResetMem>:

STATIC UINT32 OsDmesgResetMem(VOID *addr, UINT32 size)
{
 801035c:	b580      	push	{r7, lr}
 801035e:	b086      	sub	sp, #24
 8010360:	af00      	add	r7, sp, #0
 8010362:	6078      	str	r0, [r7, #4]
 8010364:	6039      	str	r1, [r7, #0]
 8010366:	4b2f      	ldr	r3, [pc, #188]	; (8010424 <OsDmesgResetMem+0xc8>)
 8010368:	681b      	ldr	r3, [r3, #0]
 801036a:	617b      	str	r3, [r7, #20]
 801036c:	f04f 0300 	mov.w	r3, #0
    VOID *temp = NULL;
 8010370:	2300      	movs	r3, #0
 8010372:	60fb      	str	r3, [r7, #12]
    INT32 copyLen;
    UINT32 intSave;

    if (size <= sizeof(DmesgInfo)) {
 8010374:	683b      	ldr	r3, [r7, #0]
 8010376:	2b10      	cmp	r3, #16
 8010378:	d801      	bhi.n	801037e <OsDmesgResetMem+0x22>
        return LOS_NOK;
 801037a:	2301      	movs	r3, #1
 801037c:	e047      	b.n	801040e <OsDmesgResetMem+0xb2>
    }

    LOS_SpinLockSave(&g_dmesgSpin, &intSave);
 801037e:	f107 0308 	add.w	r3, r7, #8
 8010382:	4619      	mov	r1, r3
 8010384:	4828      	ldr	r0, [pc, #160]	; (8010428 <OsDmesgResetMem+0xcc>)
 8010386:	f7ff fe28 	bl	800ffda <LOS_SpinLockSave>
    temp = g_dmesgInfo;
 801038a:	4b28      	ldr	r3, [pc, #160]	; (801042c <OsDmesgResetMem+0xd0>)
 801038c:	681b      	ldr	r3, [r3, #0]
 801038e:	60fb      	str	r3, [r7, #12]
    copyLen = OsCopyToNew(addr, size);
 8010390:	6839      	ldr	r1, [r7, #0]
 8010392:	6878      	ldr	r0, [r7, #4]
 8010394:	f7ff ff5a 	bl	801024c <OsCopyToNew>
 8010398:	6138      	str	r0, [r7, #16]
    if (copyLen < 0) {
 801039a:	693b      	ldr	r3, [r7, #16]
 801039c:	2b00      	cmp	r3, #0
 801039e:	da06      	bge.n	80103ae <OsDmesgResetMem+0x52>
        LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 80103a0:	68bb      	ldr	r3, [r7, #8]
 80103a2:	4619      	mov	r1, r3
 80103a4:	4820      	ldr	r0, [pc, #128]	; (8010428 <OsDmesgResetMem+0xcc>)
 80103a6:	f7ff fe26 	bl	800fff6 <LOS_SpinUnlockRestore>
        return LOS_NOK;
 80103aa:	2301      	movs	r3, #1
 80103ac:	e02f      	b.n	801040e <OsDmesgResetMem+0xb2>
    }

    g_logBufSize = size - sizeof(DmesgInfo);
 80103ae:	683b      	ldr	r3, [r7, #0]
 80103b0:	3b10      	subs	r3, #16
 80103b2:	4a1f      	ldr	r2, [pc, #124]	; (8010430 <OsDmesgResetMem+0xd4>)
 80103b4:	6013      	str	r3, [r2, #0]
    g_dmesgInfo = (DmesgInfo *)addr;
 80103b6:	4a1d      	ldr	r2, [pc, #116]	; (801042c <OsDmesgResetMem+0xd0>)
 80103b8:	687b      	ldr	r3, [r7, #4]
 80103ba:	6013      	str	r3, [r2, #0]
    g_dmesgInfo->logBuf = (CHAR *)addr + sizeof(DmesgInfo);
 80103bc:	4b1b      	ldr	r3, [pc, #108]	; (801042c <OsDmesgResetMem+0xd0>)
 80103be:	681b      	ldr	r3, [r3, #0]
 80103c0:	687a      	ldr	r2, [r7, #4]
 80103c2:	3210      	adds	r2, #16
 80103c4:	60da      	str	r2, [r3, #12]
    g_dmesgInfo->logSize = copyLen;
 80103c6:	4b19      	ldr	r3, [pc, #100]	; (801042c <OsDmesgResetMem+0xd0>)
 80103c8:	681b      	ldr	r3, [r3, #0]
 80103ca:	693a      	ldr	r2, [r7, #16]
 80103cc:	601a      	str	r2, [r3, #0]
    g_dmesgInfo->logTail = ((copyLen == g_logBufSize) ? 0 : copyLen);
 80103ce:	693a      	ldr	r2, [r7, #16]
 80103d0:	4b17      	ldr	r3, [pc, #92]	; (8010430 <OsDmesgResetMem+0xd4>)
 80103d2:	681b      	ldr	r3, [r3, #0]
 80103d4:	429a      	cmp	r2, r3
 80103d6:	d001      	beq.n	80103dc <OsDmesgResetMem+0x80>
 80103d8:	693b      	ldr	r3, [r7, #16]
 80103da:	e000      	b.n	80103de <OsDmesgResetMem+0x82>
 80103dc:	2300      	movs	r3, #0
 80103de:	4a13      	ldr	r2, [pc, #76]	; (801042c <OsDmesgResetMem+0xd0>)
 80103e0:	6812      	ldr	r2, [r2, #0]
 80103e2:	6093      	str	r3, [r2, #8]
    g_dmesgInfo->logHead = 0;
 80103e4:	4b11      	ldr	r3, [pc, #68]	; (801042c <OsDmesgResetMem+0xd0>)
 80103e6:	681b      	ldr	r3, [r3, #0]
 80103e8:	2200      	movs	r2, #0
 80103ea:	605a      	str	r2, [r3, #4]

    /* if old mem came from malloc */
    if (temp == g_mallocAddr) {
 80103ec:	4b11      	ldr	r3, [pc, #68]	; (8010434 <OsDmesgResetMem+0xd8>)
 80103ee:	681b      	ldr	r3, [r3, #0]
 80103f0:	68fa      	ldr	r2, [r7, #12]
 80103f2:	429a      	cmp	r2, r3
 80103f4:	d105      	bne.n	8010402 <OsDmesgResetMem+0xa6>
        free(temp);
 80103f6:	68f8      	ldr	r0, [r7, #12]
 80103f8:	f00a f9ec 	bl	801a7d4 <free>
        g_mallocAddr = NULL;
 80103fc:	4b0d      	ldr	r3, [pc, #52]	; (8010434 <OsDmesgResetMem+0xd8>)
 80103fe:	2200      	movs	r2, #0
 8010400:	601a      	str	r2, [r3, #0]
    }
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8010402:	68bb      	ldr	r3, [r7, #8]
 8010404:	4619      	mov	r1, r3
 8010406:	4808      	ldr	r0, [pc, #32]	; (8010428 <OsDmesgResetMem+0xcc>)
 8010408:	f7ff fdf5 	bl	800fff6 <LOS_SpinUnlockRestore>

    return LOS_OK;
 801040c:	2300      	movs	r3, #0
}
 801040e:	4a05      	ldr	r2, [pc, #20]	; (8010424 <OsDmesgResetMem+0xc8>)
 8010410:	6811      	ldr	r1, [r2, #0]
 8010412:	697a      	ldr	r2, [r7, #20]
 8010414:	4051      	eors	r1, r2
 8010416:	d001      	beq.n	801041c <OsDmesgResetMem+0xc0>
 8010418:	f7f3 ffe6 	bl	80043e8 <__stack_chk_fail>
 801041c:	4618      	mov	r0, r3
 801041e:	3718      	adds	r7, #24
 8010420:	46bd      	mov	sp, r7
 8010422:	bd80      	pop	{r7, pc}
 8010424:	080217b8 	.word	0x080217b8
 8010428:	20003284 	.word	0x20003284
 801042c:	20003288 	.word	0x20003288
 8010430:	2000328c 	.word	0x2000328c
 8010434:	20003290 	.word	0x20003290

08010438 <OsDmesgChangeSize>:

STATIC UINT32 OsDmesgChangeSize(UINT32 size)
{
 8010438:	b580      	push	{r7, lr}
 801043a:	b088      	sub	sp, #32
 801043c:	af00      	add	r7, sp, #0
 801043e:	6078      	str	r0, [r7, #4]
 8010440:	4b37      	ldr	r3, [pc, #220]	; (8010520 <OsDmesgChangeSize+0xe8>)
 8010442:	681b      	ldr	r3, [r3, #0]
 8010444:	61fb      	str	r3, [r7, #28]
 8010446:	f04f 0300 	mov.w	r3, #0
    VOID *temp = NULL;
 801044a:	2300      	movs	r3, #0
 801044c:	613b      	str	r3, [r7, #16]
    INT32 copyLen;
    CHAR *newString = NULL;
 801044e:	2300      	movs	r3, #0
 8010450:	617b      	str	r3, [r7, #20]
    UINT32 intSave;

    if (size == 0) {
 8010452:	687b      	ldr	r3, [r7, #4]
 8010454:	2b00      	cmp	r3, #0
 8010456:	d101      	bne.n	801045c <OsDmesgChangeSize+0x24>
        return LOS_NOK;
 8010458:	2301      	movs	r3, #1
 801045a:	e056      	b.n	801050a <OsDmesgChangeSize+0xd2>
    }

    newString = (CHAR *)malloc(size + sizeof(DmesgInfo));
 801045c:	687b      	ldr	r3, [r7, #4]
 801045e:	3310      	adds	r3, #16
 8010460:	4618      	mov	r0, r3
 8010462:	f00a f9cb 	bl	801a7fc <malloc>
 8010466:	6178      	str	r0, [r7, #20]
    if (newString == NULL) {
 8010468:	697b      	ldr	r3, [r7, #20]
 801046a:	2b00      	cmp	r3, #0
 801046c:	d101      	bne.n	8010472 <OsDmesgChangeSize+0x3a>
        return LOS_NOK;
 801046e:	2301      	movs	r3, #1
 8010470:	e04b      	b.n	801050a <OsDmesgChangeSize+0xd2>
    }

    LOS_SpinLockSave(&g_dmesgSpin, &intSave);
 8010472:	f107 030c 	add.w	r3, r7, #12
 8010476:	4619      	mov	r1, r3
 8010478:	482a      	ldr	r0, [pc, #168]	; (8010524 <OsDmesgChangeSize+0xec>)
 801047a:	f7ff fdae 	bl	800ffda <LOS_SpinLockSave>
    temp = g_dmesgInfo;
 801047e:	4b2a      	ldr	r3, [pc, #168]	; (8010528 <OsDmesgChangeSize+0xf0>)
 8010480:	681b      	ldr	r3, [r3, #0]
 8010482:	613b      	str	r3, [r7, #16]

    copyLen = OsCopyToNew(newString, size + sizeof(DmesgInfo));
 8010484:	687b      	ldr	r3, [r7, #4]
 8010486:	3310      	adds	r3, #16
 8010488:	4619      	mov	r1, r3
 801048a:	6978      	ldr	r0, [r7, #20]
 801048c:	f7ff fede 	bl	801024c <OsCopyToNew>
 8010490:	61b8      	str	r0, [r7, #24]
    if (copyLen < 0) {
 8010492:	69bb      	ldr	r3, [r7, #24]
 8010494:	2b00      	cmp	r3, #0
 8010496:	da09      	bge.n	80104ac <OsDmesgChangeSize+0x74>
        LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8010498:	68fb      	ldr	r3, [r7, #12]
 801049a:	4619      	mov	r1, r3
 801049c:	4821      	ldr	r0, [pc, #132]	; (8010524 <OsDmesgChangeSize+0xec>)
 801049e:	f7ff fdaa 	bl	800fff6 <LOS_SpinUnlockRestore>
        free(newString);
 80104a2:	6978      	ldr	r0, [r7, #20]
 80104a4:	f00a f996 	bl	801a7d4 <free>
        return LOS_NOK;
 80104a8:	2301      	movs	r3, #1
 80104aa:	e02e      	b.n	801050a <OsDmesgChangeSize+0xd2>
    }

    g_logBufSize = size;
 80104ac:	4a1f      	ldr	r2, [pc, #124]	; (801052c <OsDmesgChangeSize+0xf4>)
 80104ae:	687b      	ldr	r3, [r7, #4]
 80104b0:	6013      	str	r3, [r2, #0]
    g_dmesgInfo = (DmesgInfo *)newString;
 80104b2:	4a1d      	ldr	r2, [pc, #116]	; (8010528 <OsDmesgChangeSize+0xf0>)
 80104b4:	697b      	ldr	r3, [r7, #20]
 80104b6:	6013      	str	r3, [r2, #0]
    g_dmesgInfo->logBuf = (CHAR *)newString + sizeof(DmesgInfo);
 80104b8:	4b1b      	ldr	r3, [pc, #108]	; (8010528 <OsDmesgChangeSize+0xf0>)
 80104ba:	681b      	ldr	r3, [r3, #0]
 80104bc:	697a      	ldr	r2, [r7, #20]
 80104be:	3210      	adds	r2, #16
 80104c0:	60da      	str	r2, [r3, #12]
    g_dmesgInfo->logSize = copyLen;
 80104c2:	4b19      	ldr	r3, [pc, #100]	; (8010528 <OsDmesgChangeSize+0xf0>)
 80104c4:	681b      	ldr	r3, [r3, #0]
 80104c6:	69ba      	ldr	r2, [r7, #24]
 80104c8:	601a      	str	r2, [r3, #0]
    g_dmesgInfo->logTail = ((copyLen == g_logBufSize) ? 0 : copyLen);
 80104ca:	69ba      	ldr	r2, [r7, #24]
 80104cc:	4b17      	ldr	r3, [pc, #92]	; (801052c <OsDmesgChangeSize+0xf4>)
 80104ce:	681b      	ldr	r3, [r3, #0]
 80104d0:	429a      	cmp	r2, r3
 80104d2:	d001      	beq.n	80104d8 <OsDmesgChangeSize+0xa0>
 80104d4:	69bb      	ldr	r3, [r7, #24]
 80104d6:	e000      	b.n	80104da <OsDmesgChangeSize+0xa2>
 80104d8:	2300      	movs	r3, #0
 80104da:	4a13      	ldr	r2, [pc, #76]	; (8010528 <OsDmesgChangeSize+0xf0>)
 80104dc:	6812      	ldr	r2, [r2, #0]
 80104de:	6093      	str	r3, [r2, #8]
    g_dmesgInfo->logHead = 0;
 80104e0:	4b11      	ldr	r3, [pc, #68]	; (8010528 <OsDmesgChangeSize+0xf0>)
 80104e2:	681b      	ldr	r3, [r3, #0]
 80104e4:	2200      	movs	r2, #0
 80104e6:	605a      	str	r2, [r3, #4]

    if (temp == g_mallocAddr) {
 80104e8:	4b11      	ldr	r3, [pc, #68]	; (8010530 <OsDmesgChangeSize+0xf8>)
 80104ea:	681b      	ldr	r3, [r3, #0]
 80104ec:	693a      	ldr	r2, [r7, #16]
 80104ee:	429a      	cmp	r2, r3
 80104f0:	d102      	bne.n	80104f8 <OsDmesgChangeSize+0xc0>
        free(temp);
 80104f2:	6938      	ldr	r0, [r7, #16]
 80104f4:	f00a f96e 	bl	801a7d4 <free>
    }
    g_mallocAddr = newString;
 80104f8:	4a0d      	ldr	r2, [pc, #52]	; (8010530 <OsDmesgChangeSize+0xf8>)
 80104fa:	697b      	ldr	r3, [r7, #20]
 80104fc:	6013      	str	r3, [r2, #0]
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 80104fe:	68fb      	ldr	r3, [r7, #12]
 8010500:	4619      	mov	r1, r3
 8010502:	4808      	ldr	r0, [pc, #32]	; (8010524 <OsDmesgChangeSize+0xec>)
 8010504:	f7ff fd77 	bl	800fff6 <LOS_SpinUnlockRestore>

    return LOS_OK;
 8010508:	2300      	movs	r3, #0
}
 801050a:	4a05      	ldr	r2, [pc, #20]	; (8010520 <OsDmesgChangeSize+0xe8>)
 801050c:	6811      	ldr	r1, [r2, #0]
 801050e:	69fa      	ldr	r2, [r7, #28]
 8010510:	4051      	eors	r1, r2
 8010512:	d001      	beq.n	8010518 <OsDmesgChangeSize+0xe0>
 8010514:	f7f3 ff68 	bl	80043e8 <__stack_chk_fail>
 8010518:	4618      	mov	r0, r3
 801051a:	3720      	adds	r7, #32
 801051c:	46bd      	mov	sp, r7
 801051e:	bd80      	pop	{r7, pc}
 8010520:	080217bc 	.word	0x080217bc
 8010524:	20003284 	.word	0x20003284
 8010528:	20003288 	.word	0x20003288
 801052c:	2000328c 	.word	0x2000328c
 8010530:	20003290 	.word	0x20003290

08010534 <OsCheckUartLock>:
{
    return g_consoleLock;
}

UINT32 OsCheckUartLock(VOID)
{
 8010534:	b480      	push	{r7}
 8010536:	af00      	add	r7, sp, #0
    return g_uartLock;
 8010538:	4b03      	ldr	r3, [pc, #12]	; (8010548 <OsCheckUartLock+0x14>)
 801053a:	681b      	ldr	r3, [r3, #0]
}
 801053c:	4618      	mov	r0, r3
 801053e:	46bd      	mov	sp, r7
 8010540:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010544:	4770      	bx	lr
 8010546:	bf00      	nop
 8010548:	20003298 	.word	0x20003298

0801054c <OsDmesgInit>:

UINT32 OsDmesgInit(VOID)
{
 801054c:	b580      	push	{r7, lr}
 801054e:	b082      	sub	sp, #8
 8010550:	af00      	add	r7, sp, #0
    CHAR* buffer = NULL;
 8010552:	2300      	movs	r3, #0
 8010554:	607b      	str	r3, [r7, #4]

    buffer = (CHAR *)malloc(KERNEL_LOG_BUF_SIZE + sizeof(DmesgInfo));
 8010556:	f242 0010 	movw	r0, #8208	; 0x2010
 801055a:	f00a f94f 	bl	801a7fc <malloc>
 801055e:	6078      	str	r0, [r7, #4]
    if (buffer == NULL) {
 8010560:	687b      	ldr	r3, [r7, #4]
 8010562:	2b00      	cmp	r3, #0
 8010564:	d101      	bne.n	801056a <OsDmesgInit+0x1e>
        return LOS_NOK;
 8010566:	2301      	movs	r3, #1
 8010568:	e01b      	b.n	80105a2 <OsDmesgInit+0x56>
    }
    g_mallocAddr = buffer;
 801056a:	4a10      	ldr	r2, [pc, #64]	; (80105ac <OsDmesgInit+0x60>)
 801056c:	687b      	ldr	r3, [r7, #4]
 801056e:	6013      	str	r3, [r2, #0]
    g_dmesgInfo = (DmesgInfo *)buffer;
 8010570:	4a0f      	ldr	r2, [pc, #60]	; (80105b0 <OsDmesgInit+0x64>)
 8010572:	687b      	ldr	r3, [r7, #4]
 8010574:	6013      	str	r3, [r2, #0]
    g_dmesgInfo->logHead = 0;
 8010576:	4b0e      	ldr	r3, [pc, #56]	; (80105b0 <OsDmesgInit+0x64>)
 8010578:	681b      	ldr	r3, [r3, #0]
 801057a:	2200      	movs	r2, #0
 801057c:	605a      	str	r2, [r3, #4]
    g_dmesgInfo->logTail = 0;
 801057e:	4b0c      	ldr	r3, [pc, #48]	; (80105b0 <OsDmesgInit+0x64>)
 8010580:	681b      	ldr	r3, [r3, #0]
 8010582:	2200      	movs	r2, #0
 8010584:	609a      	str	r2, [r3, #8]
    g_dmesgInfo->logSize = 0;
 8010586:	4b0a      	ldr	r3, [pc, #40]	; (80105b0 <OsDmesgInit+0x64>)
 8010588:	681b      	ldr	r3, [r3, #0]
 801058a:	2200      	movs	r2, #0
 801058c:	601a      	str	r2, [r3, #0]
    g_dmesgInfo->logBuf = buffer + sizeof(DmesgInfo);
 801058e:	4b08      	ldr	r3, [pc, #32]	; (80105b0 <OsDmesgInit+0x64>)
 8010590:	681b      	ldr	r3, [r3, #0]
 8010592:	687a      	ldr	r2, [r7, #4]
 8010594:	3210      	adds	r2, #16
 8010596:	60da      	str	r2, [r3, #12]
    g_logBufSize = KERNEL_LOG_BUF_SIZE;
 8010598:	4b06      	ldr	r3, [pc, #24]	; (80105b4 <OsDmesgInit+0x68>)
 801059a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 801059e:	601a      	str	r2, [r3, #0]

    return LOS_OK;
 80105a0:	2300      	movs	r3, #0
}
 80105a2:	4618      	mov	r0, r3
 80105a4:	3708      	adds	r7, #8
 80105a6:	46bd      	mov	sp, r7
 80105a8:	bd80      	pop	{r7, pc}
 80105aa:	bf00      	nop
 80105ac:	20003290 	.word	0x20003290
 80105b0:	20003288 	.word	0x20003288
 80105b4:	2000328c 	.word	0x2000328c

080105b8 <OsBufFullWrite>:
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
    return i;
}

STATIC VOID OsBufFullWrite(const CHAR *dst, UINT32 logLen)
{
 80105b8:	b580      	push	{r7, lr}
 80105ba:	b086      	sub	sp, #24
 80105bc:	af00      	add	r7, sp, #0
 80105be:	6078      	str	r0, [r7, #4]
 80105c0:	6039      	str	r1, [r7, #0]
    UINT32 bufSize = g_logBufSize;
 80105c2:	4b6d      	ldr	r3, [pc, #436]	; (8010778 <OsBufFullWrite+0x1c0>)
 80105c4:	681b      	ldr	r3, [r3, #0]
 80105c6:	60bb      	str	r3, [r7, #8]
    UINT32 tail = g_dmesgInfo->logTail;
 80105c8:	4b6c      	ldr	r3, [pc, #432]	; (801077c <OsBufFullWrite+0x1c4>)
 80105ca:	681b      	ldr	r3, [r3, #0]
 80105cc:	689b      	ldr	r3, [r3, #8]
 80105ce:	60fb      	str	r3, [r7, #12]
    CHAR *buf = g_dmesgInfo->logBuf;
 80105d0:	4b6a      	ldr	r3, [pc, #424]	; (801077c <OsBufFullWrite+0x1c4>)
 80105d2:	681b      	ldr	r3, [r3, #0]
 80105d4:	68db      	ldr	r3, [r3, #12]
 80105d6:	613b      	str	r3, [r7, #16]
    errno_t ret;

    if ((logLen == 0) || (dst == NULL)) {
 80105d8:	683b      	ldr	r3, [r7, #0]
 80105da:	2b00      	cmp	r3, #0
 80105dc:	f000 80c8 	beq.w	8010770 <OsBufFullWrite+0x1b8>
 80105e0:	687b      	ldr	r3, [r7, #4]
 80105e2:	2b00      	cmp	r3, #0
 80105e4:	f000 80c4 	beq.w	8010770 <OsBufFullWrite+0x1b8>
        return;
    }
    if (logLen > bufSize) { /* full re-write */
 80105e8:	683a      	ldr	r2, [r7, #0]
 80105ea:	68bb      	ldr	r3, [r7, #8]
 80105ec:	429a      	cmp	r2, r3
 80105ee:	d93d      	bls.n	801066c <OsBufFullWrite+0xb4>
        ret = memcpy_s(buf + tail, bufSize - tail, dst, bufSize - tail);
 80105f0:	693a      	ldr	r2, [r7, #16]
 80105f2:	68fb      	ldr	r3, [r7, #12]
 80105f4:	18d0      	adds	r0, r2, r3
 80105f6:	68ba      	ldr	r2, [r7, #8]
 80105f8:	68fb      	ldr	r3, [r7, #12]
 80105fa:	1ad1      	subs	r1, r2, r3
 80105fc:	68ba      	ldr	r2, [r7, #8]
 80105fe:	68fb      	ldr	r3, [r7, #12]
 8010600:	1ad3      	subs	r3, r2, r3
 8010602:	687a      	ldr	r2, [r7, #4]
 8010604:	f005 ffca 	bl	801659c <memcpy_s>
 8010608:	6178      	str	r0, [r7, #20]
        if (ret != EOK) {
 801060a:	697b      	ldr	r3, [r7, #20]
 801060c:	2b00      	cmp	r3, #0
 801060e:	d00a      	beq.n	8010626 <OsBufFullWrite+0x6e>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8010610:	485b      	ldr	r0, [pc, #364]	; (8010780 <OsBufFullWrite+0x1c8>)
 8010612:	f7f4 f85b 	bl	80046cc <dprintf>
 8010616:	697b      	ldr	r3, [r7, #20]
 8010618:	f240 1273 	movw	r2, #371	; 0x173
 801061c:	4959      	ldr	r1, [pc, #356]	; (8010784 <OsBufFullWrite+0x1cc>)
 801061e:	485a      	ldr	r0, [pc, #360]	; (8010788 <OsBufFullWrite+0x1d0>)
 8010620:	f7f4 f854 	bl	80046cc <dprintf>
            return;
 8010624:	e0a5      	b.n	8010772 <OsBufFullWrite+0x1ba>
        }
        ret = memcpy_s(buf, bufSize, dst + bufSize - tail, tail);
 8010626:	68ba      	ldr	r2, [r7, #8]
 8010628:	68fb      	ldr	r3, [r7, #12]
 801062a:	1ad3      	subs	r3, r2, r3
 801062c:	687a      	ldr	r2, [r7, #4]
 801062e:	441a      	add	r2, r3
 8010630:	68fb      	ldr	r3, [r7, #12]
 8010632:	68b9      	ldr	r1, [r7, #8]
 8010634:	6938      	ldr	r0, [r7, #16]
 8010636:	f005 ffb1 	bl	801659c <memcpy_s>
 801063a:	6178      	str	r0, [r7, #20]
        if (ret != EOK) {
 801063c:	697b      	ldr	r3, [r7, #20]
 801063e:	2b00      	cmp	r3, #0
 8010640:	d00a      	beq.n	8010658 <OsBufFullWrite+0xa0>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8010642:	484f      	ldr	r0, [pc, #316]	; (8010780 <OsBufFullWrite+0x1c8>)
 8010644:	f7f4 f842 	bl	80046cc <dprintf>
 8010648:	697b      	ldr	r3, [r7, #20]
 801064a:	f44f 72bc 	mov.w	r2, #376	; 0x178
 801064e:	494d      	ldr	r1, [pc, #308]	; (8010784 <OsBufFullWrite+0x1cc>)
 8010650:	484d      	ldr	r0, [pc, #308]	; (8010788 <OsBufFullWrite+0x1d0>)
 8010652:	f7f4 f83b 	bl	80046cc <dprintf>
            return;
 8010656:	e08c      	b.n	8010772 <OsBufFullWrite+0x1ba>
        }

        OsBufFullWrite(dst + bufSize, logLen - bufSize);
 8010658:	687a      	ldr	r2, [r7, #4]
 801065a:	68bb      	ldr	r3, [r7, #8]
 801065c:	18d0      	adds	r0, r2, r3
 801065e:	683a      	ldr	r2, [r7, #0]
 8010660:	68bb      	ldr	r3, [r7, #8]
 8010662:	1ad3      	subs	r3, r2, r3
 8010664:	4619      	mov	r1, r3
 8010666:	f7ff ffa7 	bl	80105b8 <OsBufFullWrite>
 801066a:	e082      	b.n	8010772 <OsBufFullWrite+0x1ba>
    } else {
        if (logLen > (bufSize - tail)) { /* need cycle back to start */
 801066c:	68ba      	ldr	r2, [r7, #8]
 801066e:	68fb      	ldr	r3, [r7, #12]
 8010670:	1ad3      	subs	r3, r2, r3
 8010672:	683a      	ldr	r2, [r7, #0]
 8010674:	429a      	cmp	r2, r3
 8010676:	d947      	bls.n	8010708 <OsBufFullWrite+0x150>
            ret = memcpy_s(buf + tail, bufSize - tail, dst, bufSize - tail);
 8010678:	693a      	ldr	r2, [r7, #16]
 801067a:	68fb      	ldr	r3, [r7, #12]
 801067c:	18d0      	adds	r0, r2, r3
 801067e:	68ba      	ldr	r2, [r7, #8]
 8010680:	68fb      	ldr	r3, [r7, #12]
 8010682:	1ad1      	subs	r1, r2, r3
 8010684:	68ba      	ldr	r2, [r7, #8]
 8010686:	68fb      	ldr	r3, [r7, #12]
 8010688:	1ad3      	subs	r3, r2, r3
 801068a:	687a      	ldr	r2, [r7, #4]
 801068c:	f005 ff86 	bl	801659c <memcpy_s>
 8010690:	6178      	str	r0, [r7, #20]
            if (ret != EOK) {
 8010692:	697b      	ldr	r3, [r7, #20]
 8010694:	2b00      	cmp	r3, #0
 8010696:	d00a      	beq.n	80106ae <OsBufFullWrite+0xf6>
                PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8010698:	4839      	ldr	r0, [pc, #228]	; (8010780 <OsBufFullWrite+0x1c8>)
 801069a:	f7f4 f817 	bl	80046cc <dprintf>
 801069e:	697b      	ldr	r3, [r7, #20]
 80106a0:	f240 1281 	movw	r2, #385	; 0x181
 80106a4:	4937      	ldr	r1, [pc, #220]	; (8010784 <OsBufFullWrite+0x1cc>)
 80106a6:	4838      	ldr	r0, [pc, #224]	; (8010788 <OsBufFullWrite+0x1d0>)
 80106a8:	f7f4 f810 	bl	80046cc <dprintf>
                return;
 80106ac:	e061      	b.n	8010772 <OsBufFullWrite+0x1ba>
            }
            ret = memcpy_s(buf, bufSize, dst + bufSize - tail, logLen - (bufSize - tail));
 80106ae:	68ba      	ldr	r2, [r7, #8]
 80106b0:	68fb      	ldr	r3, [r7, #12]
 80106b2:	1ad3      	subs	r3, r2, r3
 80106b4:	687a      	ldr	r2, [r7, #4]
 80106b6:	18d1      	adds	r1, r2, r3
 80106b8:	68fa      	ldr	r2, [r7, #12]
 80106ba:	68bb      	ldr	r3, [r7, #8]
 80106bc:	1ad2      	subs	r2, r2, r3
 80106be:	683b      	ldr	r3, [r7, #0]
 80106c0:	4413      	add	r3, r2
 80106c2:	460a      	mov	r2, r1
 80106c4:	68b9      	ldr	r1, [r7, #8]
 80106c6:	6938      	ldr	r0, [r7, #16]
 80106c8:	f005 ff68 	bl	801659c <memcpy_s>
 80106cc:	6178      	str	r0, [r7, #20]
            if (ret != EOK) {
 80106ce:	697b      	ldr	r3, [r7, #20]
 80106d0:	2b00      	cmp	r3, #0
 80106d2:	d00a      	beq.n	80106ea <OsBufFullWrite+0x132>
                PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 80106d4:	482a      	ldr	r0, [pc, #168]	; (8010780 <OsBufFullWrite+0x1c8>)
 80106d6:	f7f3 fff9 	bl	80046cc <dprintf>
 80106da:	697b      	ldr	r3, [r7, #20]
 80106dc:	f44f 72c3 	mov.w	r2, #390	; 0x186
 80106e0:	4928      	ldr	r1, [pc, #160]	; (8010784 <OsBufFullWrite+0x1cc>)
 80106e2:	4829      	ldr	r0, [pc, #164]	; (8010788 <OsBufFullWrite+0x1d0>)
 80106e4:	f7f3 fff2 	bl	80046cc <dprintf>
                return;
 80106e8:	e043      	b.n	8010772 <OsBufFullWrite+0x1ba>
            }

            g_dmesgInfo->logTail = logLen - (bufSize - tail);
 80106ea:	68fa      	ldr	r2, [r7, #12]
 80106ec:	68bb      	ldr	r3, [r7, #8]
 80106ee:	1ad1      	subs	r1, r2, r3
 80106f0:	4b22      	ldr	r3, [pc, #136]	; (801077c <OsBufFullWrite+0x1c4>)
 80106f2:	681b      	ldr	r3, [r3, #0]
 80106f4:	683a      	ldr	r2, [r7, #0]
 80106f6:	440a      	add	r2, r1
 80106f8:	609a      	str	r2, [r3, #8]
            g_dmesgInfo->logHead = g_dmesgInfo->logTail;
 80106fa:	4b20      	ldr	r3, [pc, #128]	; (801077c <OsBufFullWrite+0x1c4>)
 80106fc:	681a      	ldr	r2, [r3, #0]
 80106fe:	4b1f      	ldr	r3, [pc, #124]	; (801077c <OsBufFullWrite+0x1c4>)
 8010700:	681b      	ldr	r3, [r3, #0]
 8010702:	6892      	ldr	r2, [r2, #8]
 8010704:	605a      	str	r2, [r3, #4]
 8010706:	e034      	b.n	8010772 <OsBufFullWrite+0x1ba>
        } else { /* no need cycle back to start */
            ret = memcpy_s(buf + tail, bufSize - tail, dst, logLen);
 8010708:	693a      	ldr	r2, [r7, #16]
 801070a:	68fb      	ldr	r3, [r7, #12]
 801070c:	18d0      	adds	r0, r2, r3
 801070e:	68ba      	ldr	r2, [r7, #8]
 8010710:	68fb      	ldr	r3, [r7, #12]
 8010712:	1ad1      	subs	r1, r2, r3
 8010714:	683b      	ldr	r3, [r7, #0]
 8010716:	687a      	ldr	r2, [r7, #4]
 8010718:	f005 ff40 	bl	801659c <memcpy_s>
 801071c:	6178      	str	r0, [r7, #20]
            if (ret != EOK) {
 801071e:	697b      	ldr	r3, [r7, #20]
 8010720:	2b00      	cmp	r3, #0
 8010722:	d00a      	beq.n	801073a <OsBufFullWrite+0x182>
                PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8010724:	4816      	ldr	r0, [pc, #88]	; (8010780 <OsBufFullWrite+0x1c8>)
 8010726:	f7f3 ffd1 	bl	80046cc <dprintf>
 801072a:	697b      	ldr	r3, [r7, #20]
 801072c:	f240 128f 	movw	r2, #399	; 0x18f
 8010730:	4914      	ldr	r1, [pc, #80]	; (8010784 <OsBufFullWrite+0x1cc>)
 8010732:	4815      	ldr	r0, [pc, #84]	; (8010788 <OsBufFullWrite+0x1d0>)
 8010734:	f7f3 ffca 	bl	80046cc <dprintf>
                return;
 8010738:	e01b      	b.n	8010772 <OsBufFullWrite+0x1ba>
            }
            g_dmesgInfo->logTail += logLen;
 801073a:	4b10      	ldr	r3, [pc, #64]	; (801077c <OsBufFullWrite+0x1c4>)
 801073c:	681b      	ldr	r3, [r3, #0]
 801073e:	6899      	ldr	r1, [r3, #8]
 8010740:	4b0e      	ldr	r3, [pc, #56]	; (801077c <OsBufFullWrite+0x1c4>)
 8010742:	681b      	ldr	r3, [r3, #0]
 8010744:	683a      	ldr	r2, [r7, #0]
 8010746:	440a      	add	r2, r1
 8010748:	609a      	str	r2, [r3, #8]
            if (g_dmesgInfo->logTail > BUF_MAX_INDEX) {
 801074a:	4b0c      	ldr	r3, [pc, #48]	; (801077c <OsBufFullWrite+0x1c4>)
 801074c:	681b      	ldr	r3, [r3, #0]
 801074e:	689a      	ldr	r2, [r3, #8]
 8010750:	4b09      	ldr	r3, [pc, #36]	; (8010778 <OsBufFullWrite+0x1c0>)
 8010752:	681b      	ldr	r3, [r3, #0]
 8010754:	3b01      	subs	r3, #1
 8010756:	429a      	cmp	r2, r3
 8010758:	d903      	bls.n	8010762 <OsBufFullWrite+0x1aa>
                g_dmesgInfo->logTail = 0;
 801075a:	4b08      	ldr	r3, [pc, #32]	; (801077c <OsBufFullWrite+0x1c4>)
 801075c:	681b      	ldr	r3, [r3, #0]
 801075e:	2200      	movs	r2, #0
 8010760:	609a      	str	r2, [r3, #8]
            }
            g_dmesgInfo->logHead = g_dmesgInfo->logTail;
 8010762:	4b06      	ldr	r3, [pc, #24]	; (801077c <OsBufFullWrite+0x1c4>)
 8010764:	681a      	ldr	r2, [r3, #0]
 8010766:	4b05      	ldr	r3, [pc, #20]	; (801077c <OsBufFullWrite+0x1c4>)
 8010768:	681b      	ldr	r3, [r3, #0]
 801076a:	6892      	ldr	r2, [r2, #8]
 801076c:	605a      	str	r2, [r3, #4]
 801076e:	e000      	b.n	8010772 <OsBufFullWrite+0x1ba>
        return;
 8010770:	bf00      	nop
        }
    }
}
 8010772:	3718      	adds	r7, #24
 8010774:	46bd      	mov	sp, r7
 8010776:	bd80      	pop	{r7, pc}
 8010778:	2000328c 	.word	0x2000328c
 801077c:	20003288 	.word	0x20003288
 8010780:	08021778 	.word	0x08021778
 8010784:	08023508 	.word	0x08023508
 8010788:	08021798 	.word	0x08021798

0801078c <OsWriteTailToHead>:

STATIC VOID OsWriteTailToHead(const CHAR *dst, UINT32 logLen)
{
 801078c:	b580      	push	{r7, lr}
 801078e:	b088      	sub	sp, #32
 8010790:	af00      	add	r7, sp, #0
 8010792:	6078      	str	r0, [r7, #4]
 8010794:	6039      	str	r1, [r7, #0]
    UINT32 writeLen;
    UINT32 bufSize = g_logBufSize;
 8010796:	4b3d      	ldr	r3, [pc, #244]	; (801088c <OsWriteTailToHead+0x100>)
 8010798:	681b      	ldr	r3, [r3, #0]
 801079a:	60bb      	str	r3, [r7, #8]
    UINT32 logSize = g_dmesgInfo->logSize;
 801079c:	4b3c      	ldr	r3, [pc, #240]	; (8010890 <OsWriteTailToHead+0x104>)
 801079e:	681b      	ldr	r3, [r3, #0]
 80107a0:	681b      	ldr	r3, [r3, #0]
 80107a2:	60fb      	str	r3, [r7, #12]
    UINT32 tail = g_dmesgInfo->logTail;
 80107a4:	4b3a      	ldr	r3, [pc, #232]	; (8010890 <OsWriteTailToHead+0x104>)
 80107a6:	681b      	ldr	r3, [r3, #0]
 80107a8:	689b      	ldr	r3, [r3, #8]
 80107aa:	613b      	str	r3, [r7, #16]
    CHAR *buf = g_dmesgInfo->logBuf;
 80107ac:	4b38      	ldr	r3, [pc, #224]	; (8010890 <OsWriteTailToHead+0x104>)
 80107ae:	681b      	ldr	r3, [r3, #0]
 80107b0:	68db      	ldr	r3, [r3, #12]
 80107b2:	617b      	str	r3, [r7, #20]
    errno_t ret;

    if ((logLen == 0) || (dst == NULL)) {
 80107b4:	683b      	ldr	r3, [r7, #0]
 80107b6:	2b00      	cmp	r3, #0
 80107b8:	d064      	beq.n	8010884 <OsWriteTailToHead+0xf8>
 80107ba:	687b      	ldr	r3, [r7, #4]
 80107bc:	2b00      	cmp	r3, #0
 80107be:	d061      	beq.n	8010884 <OsWriteTailToHead+0xf8>
        return;
    }
    if (logLen > (bufSize - logSize)) { /* space-need > space-remain */
 80107c0:	68ba      	ldr	r2, [r7, #8]
 80107c2:	68fb      	ldr	r3, [r7, #12]
 80107c4:	1ad3      	subs	r3, r2, r3
 80107c6:	683a      	ldr	r2, [r7, #0]
 80107c8:	429a      	cmp	r2, r3
 80107ca:	d931      	bls.n	8010830 <OsWriteTailToHead+0xa4>
        writeLen = bufSize - logSize;
 80107cc:	68ba      	ldr	r2, [r7, #8]
 80107ce:	68fb      	ldr	r3, [r7, #12]
 80107d0:	1ad3      	subs	r3, r2, r3
 80107d2:	61fb      	str	r3, [r7, #28]
        ret = memcpy_s(buf + tail, bufSize - tail, dst, writeLen);
 80107d4:	697a      	ldr	r2, [r7, #20]
 80107d6:	693b      	ldr	r3, [r7, #16]
 80107d8:	18d0      	adds	r0, r2, r3
 80107da:	68ba      	ldr	r2, [r7, #8]
 80107dc:	693b      	ldr	r3, [r7, #16]
 80107de:	1ad1      	subs	r1, r2, r3
 80107e0:	69fb      	ldr	r3, [r7, #28]
 80107e2:	687a      	ldr	r2, [r7, #4]
 80107e4:	f005 feda 	bl	801659c <memcpy_s>
 80107e8:	61b8      	str	r0, [r7, #24]
        if (ret != EOK) {
 80107ea:	69bb      	ldr	r3, [r7, #24]
 80107ec:	2b00      	cmp	r3, #0
 80107ee:	d00a      	beq.n	8010806 <OsWriteTailToHead+0x7a>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 80107f0:	4828      	ldr	r0, [pc, #160]	; (8010894 <OsWriteTailToHead+0x108>)
 80107f2:	f7f3 ff6b 	bl	80046cc <dprintf>
 80107f6:	69bb      	ldr	r3, [r7, #24]
 80107f8:	f240 12ab 	movw	r2, #427	; 0x1ab
 80107fc:	4926      	ldr	r1, [pc, #152]	; (8010898 <OsWriteTailToHead+0x10c>)
 80107fe:	4827      	ldr	r0, [pc, #156]	; (801089c <OsWriteTailToHead+0x110>)
 8010800:	f7f3 ff64 	bl	80046cc <dprintf>
            return;
 8010804:	e03f      	b.n	8010886 <OsWriteTailToHead+0xfa>
        }

        g_dmesgInfo->logTail = g_dmesgInfo->logHead;
 8010806:	4b22      	ldr	r3, [pc, #136]	; (8010890 <OsWriteTailToHead+0x104>)
 8010808:	681a      	ldr	r2, [r3, #0]
 801080a:	4b21      	ldr	r3, [pc, #132]	; (8010890 <OsWriteTailToHead+0x104>)
 801080c:	681b      	ldr	r3, [r3, #0]
 801080e:	6852      	ldr	r2, [r2, #4]
 8010810:	609a      	str	r2, [r3, #8]
        g_dmesgInfo->logSize = g_logBufSize;
 8010812:	4b1f      	ldr	r3, [pc, #124]	; (8010890 <OsWriteTailToHead+0x104>)
 8010814:	681b      	ldr	r3, [r3, #0]
 8010816:	4a1d      	ldr	r2, [pc, #116]	; (801088c <OsWriteTailToHead+0x100>)
 8010818:	6812      	ldr	r2, [r2, #0]
 801081a:	601a      	str	r2, [r3, #0]
        OsBufFullWrite(dst + writeLen, logLen - writeLen);
 801081c:	687a      	ldr	r2, [r7, #4]
 801081e:	69fb      	ldr	r3, [r7, #28]
 8010820:	18d0      	adds	r0, r2, r3
 8010822:	683a      	ldr	r2, [r7, #0]
 8010824:	69fb      	ldr	r3, [r7, #28]
 8010826:	1ad3      	subs	r3, r2, r3
 8010828:	4619      	mov	r1, r3
 801082a:	f7ff fec5 	bl	80105b8 <OsBufFullWrite>
 801082e:	e02a      	b.n	8010886 <OsWriteTailToHead+0xfa>
    } else {
        ret = memcpy_s(buf + tail, bufSize - tail, dst, logLen);
 8010830:	697a      	ldr	r2, [r7, #20]
 8010832:	693b      	ldr	r3, [r7, #16]
 8010834:	18d0      	adds	r0, r2, r3
 8010836:	68ba      	ldr	r2, [r7, #8]
 8010838:	693b      	ldr	r3, [r7, #16]
 801083a:	1ad1      	subs	r1, r2, r3
 801083c:	683b      	ldr	r3, [r7, #0]
 801083e:	687a      	ldr	r2, [r7, #4]
 8010840:	f005 feac 	bl	801659c <memcpy_s>
 8010844:	61b8      	str	r0, [r7, #24]
        if (ret != EOK) {
 8010846:	69bb      	ldr	r3, [r7, #24]
 8010848:	2b00      	cmp	r3, #0
 801084a:	d00a      	beq.n	8010862 <OsWriteTailToHead+0xd6>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 801084c:	4811      	ldr	r0, [pc, #68]	; (8010894 <OsWriteTailToHead+0x108>)
 801084e:	f7f3 ff3d 	bl	80046cc <dprintf>
 8010852:	69bb      	ldr	r3, [r7, #24]
 8010854:	f240 12b5 	movw	r2, #437	; 0x1b5
 8010858:	490f      	ldr	r1, [pc, #60]	; (8010898 <OsWriteTailToHead+0x10c>)
 801085a:	4810      	ldr	r0, [pc, #64]	; (801089c <OsWriteTailToHead+0x110>)
 801085c:	f7f3 ff36 	bl	80046cc <dprintf>
            return;
 8010860:	e011      	b.n	8010886 <OsWriteTailToHead+0xfa>
        }

        g_dmesgInfo->logTail += logLen;
 8010862:	4b0b      	ldr	r3, [pc, #44]	; (8010890 <OsWriteTailToHead+0x104>)
 8010864:	681b      	ldr	r3, [r3, #0]
 8010866:	6899      	ldr	r1, [r3, #8]
 8010868:	4b09      	ldr	r3, [pc, #36]	; (8010890 <OsWriteTailToHead+0x104>)
 801086a:	681b      	ldr	r3, [r3, #0]
 801086c:	683a      	ldr	r2, [r7, #0]
 801086e:	440a      	add	r2, r1
 8010870:	609a      	str	r2, [r3, #8]
        g_dmesgInfo->logSize += logLen;
 8010872:	4b07      	ldr	r3, [pc, #28]	; (8010890 <OsWriteTailToHead+0x104>)
 8010874:	681b      	ldr	r3, [r3, #0]
 8010876:	6819      	ldr	r1, [r3, #0]
 8010878:	4b05      	ldr	r3, [pc, #20]	; (8010890 <OsWriteTailToHead+0x104>)
 801087a:	681b      	ldr	r3, [r3, #0]
 801087c:	683a      	ldr	r2, [r7, #0]
 801087e:	440a      	add	r2, r1
 8010880:	601a      	str	r2, [r3, #0]
 8010882:	e000      	b.n	8010886 <OsWriteTailToHead+0xfa>
        return;
 8010884:	bf00      	nop
    }
}
 8010886:	3720      	adds	r7, #32
 8010888:	46bd      	mov	sp, r7
 801088a:	bd80      	pop	{r7, pc}
 801088c:	2000328c 	.word	0x2000328c
 8010890:	20003288 	.word	0x20003288
 8010894:	08021778 	.word	0x08021778
 8010898:	08023518 	.word	0x08023518
 801089c:	08021798 	.word	0x08021798

080108a0 <OsWriteTailToEnd>:

STATIC VOID OsWriteTailToEnd(const CHAR *dst, UINT32 logLen)
{
 80108a0:	b580      	push	{r7, lr}
 80108a2:	b088      	sub	sp, #32
 80108a4:	af00      	add	r7, sp, #0
 80108a6:	6078      	str	r0, [r7, #4]
 80108a8:	6039      	str	r1, [r7, #0]
    UINT32 writeLen;
    UINT32 bufSize = g_logBufSize;
 80108aa:	4b43      	ldr	r3, [pc, #268]	; (80109b8 <OsWriteTailToEnd+0x118>)
 80108ac:	681b      	ldr	r3, [r3, #0]
 80108ae:	60fb      	str	r3, [r7, #12]
    UINT32 tail = g_dmesgInfo->logTail;
 80108b0:	4b42      	ldr	r3, [pc, #264]	; (80109bc <OsWriteTailToEnd+0x11c>)
 80108b2:	681b      	ldr	r3, [r3, #0]
 80108b4:	689b      	ldr	r3, [r3, #8]
 80108b6:	613b      	str	r3, [r7, #16]
    CHAR *buf = g_dmesgInfo->logBuf;
 80108b8:	4b40      	ldr	r3, [pc, #256]	; (80109bc <OsWriteTailToEnd+0x11c>)
 80108ba:	681b      	ldr	r3, [r3, #0]
 80108bc:	68db      	ldr	r3, [r3, #12]
 80108be:	617b      	str	r3, [r7, #20]
    errno_t ret;

    if ((logLen == 0) || (dst == NULL)) {
 80108c0:	683b      	ldr	r3, [r7, #0]
 80108c2:	2b00      	cmp	r3, #0
 80108c4:	d074      	beq.n	80109b0 <OsWriteTailToEnd+0x110>
 80108c6:	687b      	ldr	r3, [r7, #4]
 80108c8:	2b00      	cmp	r3, #0
 80108ca:	d071      	beq.n	80109b0 <OsWriteTailToEnd+0x110>
        return;
    }
    if (logLen >= (bufSize - tail)) { /* need cycle to start ,then became B */
 80108cc:	68fa      	ldr	r2, [r7, #12]
 80108ce:	693b      	ldr	r3, [r7, #16]
 80108d0:	1ad3      	subs	r3, r2, r3
 80108d2:	683a      	ldr	r2, [r7, #0]
 80108d4:	429a      	cmp	r2, r3
 80108d6:	d341      	bcc.n	801095c <OsWriteTailToEnd+0xbc>
        writeLen = bufSize - tail;
 80108d8:	68fa      	ldr	r2, [r7, #12]
 80108da:	693b      	ldr	r3, [r7, #16]
 80108dc:	1ad3      	subs	r3, r2, r3
 80108de:	61fb      	str	r3, [r7, #28]
        ret = memcpy_s(buf + tail, writeLen, dst, writeLen);
 80108e0:	697a      	ldr	r2, [r7, #20]
 80108e2:	693b      	ldr	r3, [r7, #16]
 80108e4:	18d0      	adds	r0, r2, r3
 80108e6:	69fb      	ldr	r3, [r7, #28]
 80108e8:	687a      	ldr	r2, [r7, #4]
 80108ea:	69f9      	ldr	r1, [r7, #28]
 80108ec:	f005 fe56 	bl	801659c <memcpy_s>
 80108f0:	61b8      	str	r0, [r7, #24]
        if (ret != EOK) {
 80108f2:	69bb      	ldr	r3, [r7, #24]
 80108f4:	2b00      	cmp	r3, #0
 80108f6:	d00a      	beq.n	801090e <OsWriteTailToEnd+0x6e>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 80108f8:	4831      	ldr	r0, [pc, #196]	; (80109c0 <OsWriteTailToEnd+0x120>)
 80108fa:	f7f3 fee7 	bl	80046cc <dprintf>
 80108fe:	69bb      	ldr	r3, [r7, #24]
 8010900:	f240 12cd 	movw	r2, #461	; 0x1cd
 8010904:	492f      	ldr	r1, [pc, #188]	; (80109c4 <OsWriteTailToEnd+0x124>)
 8010906:	4830      	ldr	r0, [pc, #192]	; (80109c8 <OsWriteTailToEnd+0x128>)
 8010908:	f7f3 fee0 	bl	80046cc <dprintf>
            return;
 801090c:	e051      	b.n	80109b2 <OsWriteTailToEnd+0x112>
        }

        g_dmesgInfo->logSize += writeLen;
 801090e:	4b2b      	ldr	r3, [pc, #172]	; (80109bc <OsWriteTailToEnd+0x11c>)
 8010910:	681b      	ldr	r3, [r3, #0]
 8010912:	6819      	ldr	r1, [r3, #0]
 8010914:	4b29      	ldr	r3, [pc, #164]	; (80109bc <OsWriteTailToEnd+0x11c>)
 8010916:	681b      	ldr	r3, [r3, #0]
 8010918:	69fa      	ldr	r2, [r7, #28]
 801091a:	440a      	add	r2, r1
 801091c:	601a      	str	r2, [r3, #0]
        g_dmesgInfo->logTail = 0;
 801091e:	4b27      	ldr	r3, [pc, #156]	; (80109bc <OsWriteTailToEnd+0x11c>)
 8010920:	681b      	ldr	r3, [r3, #0]
 8010922:	2200      	movs	r2, #0
 8010924:	609a      	str	r2, [r3, #8]
        if (g_dmesgInfo->logSize == g_logBufSize) { /* Tail = Head is 0 */
 8010926:	4b25      	ldr	r3, [pc, #148]	; (80109bc <OsWriteTailToEnd+0x11c>)
 8010928:	681b      	ldr	r3, [r3, #0]
 801092a:	681a      	ldr	r2, [r3, #0]
 801092c:	4b22      	ldr	r3, [pc, #136]	; (80109b8 <OsWriteTailToEnd+0x118>)
 801092e:	681b      	ldr	r3, [r3, #0]
 8010930:	429a      	cmp	r2, r3
 8010932:	d109      	bne.n	8010948 <OsWriteTailToEnd+0xa8>
            OsBufFullWrite(dst + writeLen, logLen - writeLen);
 8010934:	687a      	ldr	r2, [r7, #4]
 8010936:	69fb      	ldr	r3, [r7, #28]
 8010938:	18d0      	adds	r0, r2, r3
 801093a:	683a      	ldr	r2, [r7, #0]
 801093c:	69fb      	ldr	r3, [r7, #28]
 801093e:	1ad3      	subs	r3, r2, r3
 8010940:	4619      	mov	r1, r3
 8010942:	f7ff fe39 	bl	80105b8 <OsBufFullWrite>
 8010946:	e034      	b.n	80109b2 <OsWriteTailToEnd+0x112>
        } else {
            OsWriteTailToHead(dst + writeLen, logLen - writeLen);
 8010948:	687a      	ldr	r2, [r7, #4]
 801094a:	69fb      	ldr	r3, [r7, #28]
 801094c:	18d0      	adds	r0, r2, r3
 801094e:	683a      	ldr	r2, [r7, #0]
 8010950:	69fb      	ldr	r3, [r7, #28]
 8010952:	1ad3      	subs	r3, r2, r3
 8010954:	4619      	mov	r1, r3
 8010956:	f7ff ff19 	bl	801078c <OsWriteTailToHead>
 801095a:	e02a      	b.n	80109b2 <OsWriteTailToEnd+0x112>
        }
    } else { /* just do serial copy */
        ret = memcpy_s(buf + tail, bufSize - tail, dst, logLen);
 801095c:	697a      	ldr	r2, [r7, #20]
 801095e:	693b      	ldr	r3, [r7, #16]
 8010960:	18d0      	adds	r0, r2, r3
 8010962:	68fa      	ldr	r2, [r7, #12]
 8010964:	693b      	ldr	r3, [r7, #16]
 8010966:	1ad1      	subs	r1, r2, r3
 8010968:	683b      	ldr	r3, [r7, #0]
 801096a:	687a      	ldr	r2, [r7, #4]
 801096c:	f005 fe16 	bl	801659c <memcpy_s>
 8010970:	61b8      	str	r0, [r7, #24]
        if (ret != EOK) {
 8010972:	69bb      	ldr	r3, [r7, #24]
 8010974:	2b00      	cmp	r3, #0
 8010976:	d00a      	beq.n	801098e <OsWriteTailToEnd+0xee>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8010978:	4811      	ldr	r0, [pc, #68]	; (80109c0 <OsWriteTailToEnd+0x120>)
 801097a:	f7f3 fea7 	bl	80046cc <dprintf>
 801097e:	69bb      	ldr	r3, [r7, #24]
 8010980:	f240 12db 	movw	r2, #475	; 0x1db
 8010984:	490f      	ldr	r1, [pc, #60]	; (80109c4 <OsWriteTailToEnd+0x124>)
 8010986:	4810      	ldr	r0, [pc, #64]	; (80109c8 <OsWriteTailToEnd+0x128>)
 8010988:	f7f3 fea0 	bl	80046cc <dprintf>
            return;
 801098c:	e011      	b.n	80109b2 <OsWriteTailToEnd+0x112>
        }

        g_dmesgInfo->logTail += logLen;
 801098e:	4b0b      	ldr	r3, [pc, #44]	; (80109bc <OsWriteTailToEnd+0x11c>)
 8010990:	681b      	ldr	r3, [r3, #0]
 8010992:	6899      	ldr	r1, [r3, #8]
 8010994:	4b09      	ldr	r3, [pc, #36]	; (80109bc <OsWriteTailToEnd+0x11c>)
 8010996:	681b      	ldr	r3, [r3, #0]
 8010998:	683a      	ldr	r2, [r7, #0]
 801099a:	440a      	add	r2, r1
 801099c:	609a      	str	r2, [r3, #8]
        g_dmesgInfo->logSize += logLen;
 801099e:	4b07      	ldr	r3, [pc, #28]	; (80109bc <OsWriteTailToEnd+0x11c>)
 80109a0:	681b      	ldr	r3, [r3, #0]
 80109a2:	6819      	ldr	r1, [r3, #0]
 80109a4:	4b05      	ldr	r3, [pc, #20]	; (80109bc <OsWriteTailToEnd+0x11c>)
 80109a6:	681b      	ldr	r3, [r3, #0]
 80109a8:	683a      	ldr	r2, [r7, #0]
 80109aa:	440a      	add	r2, r1
 80109ac:	601a      	str	r2, [r3, #0]
 80109ae:	e000      	b.n	80109b2 <OsWriteTailToEnd+0x112>
        return;
 80109b0:	bf00      	nop
    }
}
 80109b2:	3720      	adds	r7, #32
 80109b4:	46bd      	mov	sp, r7
 80109b6:	bd80      	pop	{r7, pc}
 80109b8:	2000328c 	.word	0x2000328c
 80109bc:	20003288 	.word	0x20003288
 80109c0:	08021778 	.word	0x08021778
 80109c4:	0802352c 	.word	0x0802352c
 80109c8:	08021798 	.word	0x08021798

080109cc <OsLogMemcpyRecord>:

INT32 OsLogMemcpyRecord(const CHAR *buf, UINT32 logLen)
{
 80109cc:	b580      	push	{r7, lr}
 80109ce:	b084      	sub	sp, #16
 80109d0:	af00      	add	r7, sp, #0
 80109d2:	6078      	str	r0, [r7, #4]
 80109d4:	6039      	str	r1, [r7, #0]
 80109d6:	4b23      	ldr	r3, [pc, #140]	; (8010a64 <OsLogMemcpyRecord+0x98>)
 80109d8:	681b      	ldr	r3, [r3, #0]
 80109da:	60fb      	str	r3, [r7, #12]
 80109dc:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    LOS_SpinLockSave(&g_dmesgSpin, &intSave);
 80109e0:	f107 0308 	add.w	r3, r7, #8
 80109e4:	4619      	mov	r1, r3
 80109e6:	4820      	ldr	r0, [pc, #128]	; (8010a68 <OsLogMemcpyRecord+0x9c>)
 80109e8:	f7ff faf7 	bl	800ffda <LOS_SpinLockSave>
    if (OsCheckError()) {
 80109ec:	f7ff fb40 	bl	8010070 <OsCheckError>
 80109f0:	4603      	mov	r3, r0
 80109f2:	2b00      	cmp	r3, #0
 80109f4:	d007      	beq.n	8010a06 <OsLogMemcpyRecord+0x3a>
        LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 80109f6:	68bb      	ldr	r3, [r7, #8]
 80109f8:	4619      	mov	r1, r3
 80109fa:	481b      	ldr	r0, [pc, #108]	; (8010a68 <OsLogMemcpyRecord+0x9c>)
 80109fc:	f7ff fafb 	bl	800fff6 <LOS_SpinUnlockRestore>
        return -1;
 8010a00:	f04f 33ff 	mov.w	r3, #4294967295
 8010a04:	e022      	b.n	8010a4c <OsLogMemcpyRecord+0x80>
    }
    if (g_dmesgInfo->logSize < g_logBufSize) {
 8010a06:	4b19      	ldr	r3, [pc, #100]	; (8010a6c <OsLogMemcpyRecord+0xa0>)
 8010a08:	681b      	ldr	r3, [r3, #0]
 8010a0a:	681a      	ldr	r2, [r3, #0]
 8010a0c:	4b18      	ldr	r3, [pc, #96]	; (8010a70 <OsLogMemcpyRecord+0xa4>)
 8010a0e:	681b      	ldr	r3, [r3, #0]
 8010a10:	429a      	cmp	r2, r3
 8010a12:	d211      	bcs.n	8010a38 <OsLogMemcpyRecord+0x6c>
        if (g_dmesgInfo->logHead <= g_dmesgInfo->logTail) {
 8010a14:	4b15      	ldr	r3, [pc, #84]	; (8010a6c <OsLogMemcpyRecord+0xa0>)
 8010a16:	681b      	ldr	r3, [r3, #0]
 8010a18:	685a      	ldr	r2, [r3, #4]
 8010a1a:	4b14      	ldr	r3, [pc, #80]	; (8010a6c <OsLogMemcpyRecord+0xa0>)
 8010a1c:	681b      	ldr	r3, [r3, #0]
 8010a1e:	689b      	ldr	r3, [r3, #8]
 8010a20:	429a      	cmp	r2, r3
 8010a22:	d804      	bhi.n	8010a2e <OsLogMemcpyRecord+0x62>
            OsWriteTailToEnd(buf, logLen);
 8010a24:	6839      	ldr	r1, [r7, #0]
 8010a26:	6878      	ldr	r0, [r7, #4]
 8010a28:	f7ff ff3a 	bl	80108a0 <OsWriteTailToEnd>
 8010a2c:	e008      	b.n	8010a40 <OsLogMemcpyRecord+0x74>
        } else {
            OsWriteTailToHead(buf, logLen);
 8010a2e:	6839      	ldr	r1, [r7, #0]
 8010a30:	6878      	ldr	r0, [r7, #4]
 8010a32:	f7ff feab 	bl	801078c <OsWriteTailToHead>
 8010a36:	e003      	b.n	8010a40 <OsLogMemcpyRecord+0x74>
        }
    } else {
        OsBufFullWrite(buf, logLen);
 8010a38:	6839      	ldr	r1, [r7, #0]
 8010a3a:	6878      	ldr	r0, [r7, #4]
 8010a3c:	f7ff fdbc 	bl	80105b8 <OsBufFullWrite>
    }
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8010a40:	68bb      	ldr	r3, [r7, #8]
 8010a42:	4619      	mov	r1, r3
 8010a44:	4808      	ldr	r0, [pc, #32]	; (8010a68 <OsLogMemcpyRecord+0x9c>)
 8010a46:	f7ff fad6 	bl	800fff6 <LOS_SpinUnlockRestore>

    return LOS_OK;
 8010a4a:	2300      	movs	r3, #0
}
 8010a4c:	4a05      	ldr	r2, [pc, #20]	; (8010a64 <OsLogMemcpyRecord+0x98>)
 8010a4e:	6811      	ldr	r1, [r2, #0]
 8010a50:	68fa      	ldr	r2, [r7, #12]
 8010a52:	4051      	eors	r1, r2
 8010a54:	d001      	beq.n	8010a5a <OsLogMemcpyRecord+0x8e>
 8010a56:	f7f3 fcc7 	bl	80043e8 <__stack_chk_fail>
 8010a5a:	4618      	mov	r0, r3
 8010a5c:	3710      	adds	r7, #16
 8010a5e:	46bd      	mov	sp, r7
 8010a60:	bd80      	pop	{r7, pc}
 8010a62:	bf00      	nop
 8010a64:	080217c4 	.word	0x080217c4
 8010a68:	20003284 	.word	0x20003284
 8010a6c:	20003288 	.word	0x20003288
 8010a70:	2000328c 	.word	0x2000328c

08010a74 <OsLogShow>:

VOID OsLogShow(VOID)
{
 8010a74:	b580      	push	{r7, lr}
 8010a76:	b086      	sub	sp, #24
 8010a78:	af00      	add	r7, sp, #0
 8010a7a:	4b36      	ldr	r3, [pc, #216]	; (8010b54 <OsLogShow+0xe0>)
 8010a7c:	681b      	ldr	r3, [r3, #0]
 8010a7e:	617b      	str	r3, [r7, #20]
 8010a80:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 index;
    UINT32 i = 0;
 8010a84:	2300      	movs	r3, #0
 8010a86:	60fb      	str	r3, [r7, #12]
    CHAR *p = NULL;
 8010a88:	2300      	movs	r3, #0
 8010a8a:	613b      	str	r3, [r7, #16]

    LOS_SpinLockSave(&g_dmesgSpin, &intSave);
 8010a8c:	1d3b      	adds	r3, r7, #4
 8010a8e:	4619      	mov	r1, r3
 8010a90:	4831      	ldr	r0, [pc, #196]	; (8010b58 <OsLogShow+0xe4>)
 8010a92:	f7ff faa2 	bl	800ffda <LOS_SpinLockSave>
    index = g_dmesgInfo->logHead;
 8010a96:	4b31      	ldr	r3, [pc, #196]	; (8010b5c <OsLogShow+0xe8>)
 8010a98:	681b      	ldr	r3, [r3, #0]
 8010a9a:	685b      	ldr	r3, [r3, #4]
 8010a9c:	60bb      	str	r3, [r7, #8]
    p = (CHAR *)malloc(g_dmesgInfo->logSize + 1);
 8010a9e:	4b2f      	ldr	r3, [pc, #188]	; (8010b5c <OsLogShow+0xe8>)
 8010aa0:	681b      	ldr	r3, [r3, #0]
 8010aa2:	681b      	ldr	r3, [r3, #0]
 8010aa4:	3301      	adds	r3, #1
 8010aa6:	4618      	mov	r0, r3
 8010aa8:	f009 fea8 	bl	801a7fc <malloc>
 8010aac:	6138      	str	r0, [r7, #16]
    if (p == NULL) {
 8010aae:	693b      	ldr	r3, [r7, #16]
 8010ab0:	2b00      	cmp	r3, #0
 8010ab2:	d105      	bne.n	8010ac0 <OsLogShow+0x4c>
        LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8010ab4:	687b      	ldr	r3, [r7, #4]
 8010ab6:	4619      	mov	r1, r3
 8010ab8:	4827      	ldr	r0, [pc, #156]	; (8010b58 <OsLogShow+0xe4>)
 8010aba:	f7ff fa9c 	bl	800fff6 <LOS_SpinUnlockRestore>
 8010abe:	e03e      	b.n	8010b3e <OsLogShow+0xca>
        return;
    }
    (VOID)memset_s(p, g_dmesgInfo->logSize + 1, 0, g_dmesgInfo->logSize + 1);
 8010ac0:	4b26      	ldr	r3, [pc, #152]	; (8010b5c <OsLogShow+0xe8>)
 8010ac2:	681b      	ldr	r3, [r3, #0]
 8010ac4:	681b      	ldr	r3, [r3, #0]
 8010ac6:	1c59      	adds	r1, r3, #1
 8010ac8:	4b24      	ldr	r3, [pc, #144]	; (8010b5c <OsLogShow+0xe8>)
 8010aca:	681b      	ldr	r3, [r3, #0]
 8010acc:	681b      	ldr	r3, [r3, #0]
 8010ace:	3301      	adds	r3, #1
 8010ad0:	2200      	movs	r2, #0
 8010ad2:	6938      	ldr	r0, [r7, #16]
 8010ad4:	f005 fada 	bl	801608c <memset_s>

    while (i < g_dmesgInfo->logSize) {
 8010ad8:	e01c      	b.n	8010b14 <OsLogShow+0xa0>
        *(p + i) = *(g_dmesgInfo->logBuf + index++);
 8010ada:	4b20      	ldr	r3, [pc, #128]	; (8010b5c <OsLogShow+0xe8>)
 8010adc:	681b      	ldr	r3, [r3, #0]
 8010ade:	68da      	ldr	r2, [r3, #12]
 8010ae0:	68bb      	ldr	r3, [r7, #8]
 8010ae2:	1c59      	adds	r1, r3, #1
 8010ae4:	60b9      	str	r1, [r7, #8]
 8010ae6:	441a      	add	r2, r3
 8010ae8:	6939      	ldr	r1, [r7, #16]
 8010aea:	68fb      	ldr	r3, [r7, #12]
 8010aec:	440b      	add	r3, r1
 8010aee:	7812      	ldrb	r2, [r2, #0]
 8010af0:	701a      	strb	r2, [r3, #0]
        if (index > BUF_MAX_INDEX) {
 8010af2:	4b1b      	ldr	r3, [pc, #108]	; (8010b60 <OsLogShow+0xec>)
 8010af4:	681b      	ldr	r3, [r3, #0]
 8010af6:	3b01      	subs	r3, #1
 8010af8:	68ba      	ldr	r2, [r7, #8]
 8010afa:	429a      	cmp	r2, r3
 8010afc:	d901      	bls.n	8010b02 <OsLogShow+0x8e>
            index = 0;
 8010afe:	2300      	movs	r3, #0
 8010b00:	60bb      	str	r3, [r7, #8]
        }
        i++;
 8010b02:	68fb      	ldr	r3, [r7, #12]
 8010b04:	3301      	adds	r3, #1
 8010b06:	60fb      	str	r3, [r7, #12]
        if (index == g_dmesgInfo->logTail) {
 8010b08:	4b14      	ldr	r3, [pc, #80]	; (8010b5c <OsLogShow+0xe8>)
 8010b0a:	681b      	ldr	r3, [r3, #0]
 8010b0c:	689b      	ldr	r3, [r3, #8]
 8010b0e:	68ba      	ldr	r2, [r7, #8]
 8010b10:	429a      	cmp	r2, r3
 8010b12:	d006      	beq.n	8010b22 <OsLogShow+0xae>
    while (i < g_dmesgInfo->logSize) {
 8010b14:	4b11      	ldr	r3, [pc, #68]	; (8010b5c <OsLogShow+0xe8>)
 8010b16:	681b      	ldr	r3, [r3, #0]
 8010b18:	681b      	ldr	r3, [r3, #0]
 8010b1a:	68fa      	ldr	r2, [r7, #12]
 8010b1c:	429a      	cmp	r2, r3
 8010b1e:	d3dc      	bcc.n	8010ada <OsLogShow+0x66>
 8010b20:	e000      	b.n	8010b24 <OsLogShow+0xb0>
            break;
 8010b22:	bf00      	nop
        }
    }
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8010b24:	687b      	ldr	r3, [r7, #4]
 8010b26:	4619      	mov	r1, r3
 8010b28:	480b      	ldr	r0, [pc, #44]	; (8010b58 <OsLogShow+0xe4>)
 8010b2a:	f7ff fa64 	bl	800fff6 <LOS_SpinUnlockRestore>
    UartPuts(p, i, UART_WITH_LOCK);
 8010b2e:	2201      	movs	r2, #1
 8010b30:	68f9      	ldr	r1, [r7, #12]
 8010b32:	6938      	ldr	r0, [r7, #16]
 8010b34:	f7ff fa10 	bl	800ff58 <UartPuts>
    free(p);
 8010b38:	6938      	ldr	r0, [r7, #16]
 8010b3a:	f009 fe4b 	bl	801a7d4 <free>
}
 8010b3e:	4b05      	ldr	r3, [pc, #20]	; (8010b54 <OsLogShow+0xe0>)
 8010b40:	681a      	ldr	r2, [r3, #0]
 8010b42:	697b      	ldr	r3, [r7, #20]
 8010b44:	405a      	eors	r2, r3
 8010b46:	d001      	beq.n	8010b4c <OsLogShow+0xd8>
 8010b48:	f7f3 fc4e 	bl	80043e8 <__stack_chk_fail>
 8010b4c:	3718      	adds	r7, #24
 8010b4e:	46bd      	mov	sp, r7
 8010b50:	bd80      	pop	{r7, pc}
 8010b52:	bf00      	nop
 8010b54:	080217c8 	.word	0x080217c8
 8010b58:	20003284 	.word	0x20003284
 8010b5c:	20003288 	.word	0x20003288
 8010b60:	2000328c 	.word	0x2000328c

08010b64 <OsDmesgLvSet>:

STATIC INT32 OsDmesgLvSet(const CHAR *level)
{
 8010b64:	b580      	push	{r7, lr}
 8010b66:	b086      	sub	sp, #24
 8010b68:	af00      	add	r7, sp, #0
 8010b6a:	6078      	str	r0, [r7, #4]
 8010b6c:	4b21      	ldr	r3, [pc, #132]	; (8010bf4 <OsDmesgLvSet+0x90>)
 8010b6e:	681b      	ldr	r3, [r3, #0]
 8010b70:	617b      	str	r3, [r7, #20]
 8010b72:	f04f 0300 	mov.w	r3, #0
    UINT32 levelNum, ret;
    CHAR *p = NULL;
 8010b76:	2300      	movs	r3, #0
 8010b78:	60bb      	str	r3, [r7, #8]

    levelNum = strtoul(level, &p, 0);
 8010b7a:	f107 0308 	add.w	r3, r7, #8
 8010b7e:	2200      	movs	r2, #0
 8010b80:	4619      	mov	r1, r3
 8010b82:	6878      	ldr	r0, [r7, #4]
 8010b84:	f7fe f804 	bl	800eb90 <strtoul>
 8010b88:	60f8      	str	r0, [r7, #12]
    if (*p != 0) {
 8010b8a:	68bb      	ldr	r3, [r7, #8]
 8010b8c:	781b      	ldrb	r3, [r3, #0]
 8010b8e:	2b00      	cmp	r3, #0
 8010b90:	d005      	beq.n	8010b9e <OsDmesgLvSet+0x3a>
        PRINTK("dmesg: invalid option or parameter.\n");
 8010b92:	4819      	ldr	r0, [pc, #100]	; (8010bf8 <OsDmesgLvSet+0x94>)
 8010b94:	f7f3 fd9a 	bl	80046cc <dprintf>
        return -1;
 8010b98:	f04f 33ff 	mov.w	r3, #4294967295
 8010b9c:	e01f      	b.n	8010bde <OsDmesgLvSet+0x7a>
    }

    ret = LOS_DmesgLvSet(levelNum);
 8010b9e:	68f8      	ldr	r0, [r7, #12]
 8010ba0:	f000 f86c 	bl	8010c7c <LOS_DmesgLvSet>
 8010ba4:	6138      	str	r0, [r7, #16]
    if (ret == LOS_OK) {
 8010ba6:	693b      	ldr	r3, [r7, #16]
 8010ba8:	2b00      	cmp	r3, #0
 8010baa:	d10a      	bne.n	8010bc2 <OsDmesgLvSet+0x5e>
        PRINTK("Set current dmesg log level %s\n", g_levelString[g_dmesgLogLevel]);
 8010bac:	4b13      	ldr	r3, [pc, #76]	; (8010bfc <OsDmesgLvSet+0x98>)
 8010bae:	681b      	ldr	r3, [r3, #0]
 8010bb0:	4a13      	ldr	r2, [pc, #76]	; (8010c00 <OsDmesgLvSet+0x9c>)
 8010bb2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010bb6:	4619      	mov	r1, r3
 8010bb8:	4812      	ldr	r0, [pc, #72]	; (8010c04 <OsDmesgLvSet+0xa0>)
 8010bba:	f7f3 fd87 	bl	80046cc <dprintf>
        return LOS_OK;
 8010bbe:	2300      	movs	r3, #0
 8010bc0:	e00d      	b.n	8010bde <OsDmesgLvSet+0x7a>
    } else {
        PRINTK("current dmesg log level %s\n", g_levelString[g_dmesgLogLevel]);
 8010bc2:	4b0e      	ldr	r3, [pc, #56]	; (8010bfc <OsDmesgLvSet+0x98>)
 8010bc4:	681b      	ldr	r3, [r3, #0]
 8010bc6:	4a0e      	ldr	r2, [pc, #56]	; (8010c00 <OsDmesgLvSet+0x9c>)
 8010bc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010bcc:	4619      	mov	r1, r3
 8010bce:	480e      	ldr	r0, [pc, #56]	; (8010c08 <OsDmesgLvSet+0xa4>)
 8010bd0:	f7f3 fd7c 	bl	80046cc <dprintf>
        PRINTK("dmesg -l [num] can access as 0:EMG 1:COMMOM 2:ERROR 3:WARN 4:INFO 5:DEBUG\n");
 8010bd4:	480d      	ldr	r0, [pc, #52]	; (8010c0c <OsDmesgLvSet+0xa8>)
 8010bd6:	f7f3 fd79 	bl	80046cc <dprintf>
        return -1;
 8010bda:	f04f 33ff 	mov.w	r3, #4294967295
    }
}
 8010bde:	4a05      	ldr	r2, [pc, #20]	; (8010bf4 <OsDmesgLvSet+0x90>)
 8010be0:	6811      	ldr	r1, [r2, #0]
 8010be2:	697a      	ldr	r2, [r7, #20]
 8010be4:	4051      	eors	r1, r2
 8010be6:	d001      	beq.n	8010bec <OsDmesgLvSet+0x88>
 8010be8:	f7f3 fbfe 	bl	80043e8 <__stack_chk_fail>
 8010bec:	4618      	mov	r0, r3
 8010bee:	3718      	adds	r7, #24
 8010bf0:	46bd      	mov	sp, r7
 8010bf2:	bd80      	pop	{r7, pc}
 8010bf4:	0802187c 	.word	0x0802187c
 8010bf8:	080217cc 	.word	0x080217cc
 8010bfc:	20000484 	.word	0x20000484
 8010c00:	20000488 	.word	0x20000488
 8010c04:	080217f4 	.word	0x080217f4
 8010c08:	08021814 	.word	0x08021814
 8010c0c:	08021830 	.word	0x08021830

08010c10 <OsDmesgMemSizeSet>:

STATIC INT32 OsDmesgMemSizeSet(const CHAR *size)
{
 8010c10:	b580      	push	{r7, lr}
 8010c12:	b086      	sub	sp, #24
 8010c14:	af00      	add	r7, sp, #0
 8010c16:	6078      	str	r0, [r7, #4]
 8010c18:	4b15      	ldr	r3, [pc, #84]	; (8010c70 <OsDmesgMemSizeSet+0x60>)
 8010c1a:	681b      	ldr	r3, [r3, #0]
 8010c1c:	617b      	str	r3, [r7, #20]
 8010c1e:	f04f 0300 	mov.w	r3, #0
    UINT32 sizeVal;
    CHAR *p = NULL;
 8010c22:	2300      	movs	r3, #0
 8010c24:	60fb      	str	r3, [r7, #12]

    sizeVal = strtoul(size, &p, 0);
 8010c26:	f107 030c 	add.w	r3, r7, #12
 8010c2a:	2200      	movs	r2, #0
 8010c2c:	4619      	mov	r1, r3
 8010c2e:	6878      	ldr	r0, [r7, #4]
 8010c30:	f7fd ffae 	bl	800eb90 <strtoul>
 8010c34:	6138      	str	r0, [r7, #16]
    if (!(LOS_DmesgMemSet(NULL, sizeVal))) {
 8010c36:	6939      	ldr	r1, [r7, #16]
 8010c38:	2000      	movs	r0, #0
 8010c3a:	f000 f871 	bl	8010d20 <LOS_DmesgMemSet>
 8010c3e:	4603      	mov	r3, r0
 8010c40:	2b00      	cmp	r3, #0
 8010c42:	d105      	bne.n	8010c50 <OsDmesgMemSizeSet+0x40>
        PRINTK("Set dmesg buf size %u success\n", sizeVal);
 8010c44:	6939      	ldr	r1, [r7, #16]
 8010c46:	480b      	ldr	r0, [pc, #44]	; (8010c74 <OsDmesgMemSizeSet+0x64>)
 8010c48:	f7f3 fd40 	bl	80046cc <dprintf>
        return LOS_OK;
 8010c4c:	2300      	movs	r3, #0
 8010c4e:	e004      	b.n	8010c5a <OsDmesgMemSizeSet+0x4a>
    } else {
        PRINTK("Set dmesg buf size %u fail\n", sizeVal);
 8010c50:	6939      	ldr	r1, [r7, #16]
 8010c52:	4809      	ldr	r0, [pc, #36]	; (8010c78 <OsDmesgMemSizeSet+0x68>)
 8010c54:	f7f3 fd3a 	bl	80046cc <dprintf>
        return LOS_NOK;
 8010c58:	2301      	movs	r3, #1
    }
}
 8010c5a:	4a05      	ldr	r2, [pc, #20]	; (8010c70 <OsDmesgMemSizeSet+0x60>)
 8010c5c:	6811      	ldr	r1, [r2, #0]
 8010c5e:	697a      	ldr	r2, [r7, #20]
 8010c60:	4051      	eors	r1, r2
 8010c62:	d001      	beq.n	8010c68 <OsDmesgMemSizeSet+0x58>
 8010c64:	f7f3 fbc0 	bl	80043e8 <__stack_chk_fail>
 8010c68:	4618      	mov	r0, r3
 8010c6a:	3718      	adds	r7, #24
 8010c6c:	46bd      	mov	sp, r7
 8010c6e:	bd80      	pop	{r7, pc}
 8010c70:	080218bc 	.word	0x080218bc
 8010c74:	08021880 	.word	0x08021880
 8010c78:	080218a0 	.word	0x080218a0

08010c7c <LOS_DmesgLvSet>:
{
    return g_dmesgLogLevel;
}

UINT32 LOS_DmesgLvSet(UINT32 level)
{
 8010c7c:	b480      	push	{r7}
 8010c7e:	b083      	sub	sp, #12
 8010c80:	af00      	add	r7, sp, #0
 8010c82:	6078      	str	r0, [r7, #4]
    if (level > 5) { /* 5: count of level */
 8010c84:	687b      	ldr	r3, [r7, #4]
 8010c86:	2b05      	cmp	r3, #5
 8010c88:	d901      	bls.n	8010c8e <LOS_DmesgLvSet+0x12>
        return LOS_NOK;
 8010c8a:	2301      	movs	r3, #1
 8010c8c:	e003      	b.n	8010c96 <LOS_DmesgLvSet+0x1a>
    }

    g_dmesgLogLevel = level;
 8010c8e:	4a05      	ldr	r2, [pc, #20]	; (8010ca4 <LOS_DmesgLvSet+0x28>)
 8010c90:	687b      	ldr	r3, [r7, #4]
 8010c92:	6013      	str	r3, [r2, #0]
    return LOS_OK;
 8010c94:	2300      	movs	r3, #0
}
 8010c96:	4618      	mov	r0, r3
 8010c98:	370c      	adds	r7, #12
 8010c9a:	46bd      	mov	sp, r7
 8010c9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ca0:	4770      	bx	lr
 8010ca2:	bf00      	nop
 8010ca4:	20000484 	.word	0x20000484

08010ca8 <LOS_DmesgClear>:

VOID LOS_DmesgClear(VOID)
{
 8010ca8:	b580      	push	{r7, lr}
 8010caa:	b082      	sub	sp, #8
 8010cac:	af00      	add	r7, sp, #0
 8010cae:	4b18      	ldr	r3, [pc, #96]	; (8010d10 <LOS_DmesgClear+0x68>)
 8010cb0:	681b      	ldr	r3, [r3, #0]
 8010cb2:	607b      	str	r3, [r7, #4]
 8010cb4:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    LOS_SpinLockSave(&g_dmesgSpin, &intSave);
 8010cb8:	463b      	mov	r3, r7
 8010cba:	4619      	mov	r1, r3
 8010cbc:	4815      	ldr	r0, [pc, #84]	; (8010d14 <LOS_DmesgClear+0x6c>)
 8010cbe:	f7ff f98c 	bl	800ffda <LOS_SpinLockSave>
    (VOID)memset_s(g_dmesgInfo->logBuf, g_logBufSize, 0, g_logBufSize);
 8010cc2:	4b15      	ldr	r3, [pc, #84]	; (8010d18 <LOS_DmesgClear+0x70>)
 8010cc4:	681b      	ldr	r3, [r3, #0]
 8010cc6:	68d8      	ldr	r0, [r3, #12]
 8010cc8:	4b14      	ldr	r3, [pc, #80]	; (8010d1c <LOS_DmesgClear+0x74>)
 8010cca:	6819      	ldr	r1, [r3, #0]
 8010ccc:	4b13      	ldr	r3, [pc, #76]	; (8010d1c <LOS_DmesgClear+0x74>)
 8010cce:	681b      	ldr	r3, [r3, #0]
 8010cd0:	2200      	movs	r2, #0
 8010cd2:	f005 f9db 	bl	801608c <memset_s>
    g_dmesgInfo->logHead = 0;
 8010cd6:	4b10      	ldr	r3, [pc, #64]	; (8010d18 <LOS_DmesgClear+0x70>)
 8010cd8:	681b      	ldr	r3, [r3, #0]
 8010cda:	2200      	movs	r2, #0
 8010cdc:	605a      	str	r2, [r3, #4]
    g_dmesgInfo->logTail = 0;
 8010cde:	4b0e      	ldr	r3, [pc, #56]	; (8010d18 <LOS_DmesgClear+0x70>)
 8010ce0:	681b      	ldr	r3, [r3, #0]
 8010ce2:	2200      	movs	r2, #0
 8010ce4:	609a      	str	r2, [r3, #8]
    g_dmesgInfo->logSize = 0;
 8010ce6:	4b0c      	ldr	r3, [pc, #48]	; (8010d18 <LOS_DmesgClear+0x70>)
 8010ce8:	681b      	ldr	r3, [r3, #0]
 8010cea:	2200      	movs	r2, #0
 8010cec:	601a      	str	r2, [r3, #0]
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8010cee:	683b      	ldr	r3, [r7, #0]
 8010cf0:	4619      	mov	r1, r3
 8010cf2:	4808      	ldr	r0, [pc, #32]	; (8010d14 <LOS_DmesgClear+0x6c>)
 8010cf4:	f7ff f97f 	bl	800fff6 <LOS_SpinUnlockRestore>
}
 8010cf8:	bf00      	nop
 8010cfa:	4b05      	ldr	r3, [pc, #20]	; (8010d10 <LOS_DmesgClear+0x68>)
 8010cfc:	681a      	ldr	r2, [r3, #0]
 8010cfe:	687b      	ldr	r3, [r7, #4]
 8010d00:	405a      	eors	r2, r3
 8010d02:	d001      	beq.n	8010d08 <LOS_DmesgClear+0x60>
 8010d04:	f7f3 fb70 	bl	80043e8 <__stack_chk_fail>
 8010d08:	3708      	adds	r7, #8
 8010d0a:	46bd      	mov	sp, r7
 8010d0c:	bd80      	pop	{r7, pc}
 8010d0e:	bf00      	nop
 8010d10:	080218c0 	.word	0x080218c0
 8010d14:	20003284 	.word	0x20003284
 8010d18:	20003288 	.word	0x20003288
 8010d1c:	2000328c 	.word	0x2000328c

08010d20 <LOS_DmesgMemSet>:

UINT32 LOS_DmesgMemSet(VOID *addr, UINT32 size)
{
 8010d20:	b580      	push	{r7, lr}
 8010d22:	b084      	sub	sp, #16
 8010d24:	af00      	add	r7, sp, #0
 8010d26:	6078      	str	r0, [r7, #4]
 8010d28:	6039      	str	r1, [r7, #0]
    UINT32 ret;

    if (addr == NULL) {
 8010d2a:	687b      	ldr	r3, [r7, #4]
 8010d2c:	2b00      	cmp	r3, #0
 8010d2e:	d104      	bne.n	8010d3a <LOS_DmesgMemSet+0x1a>
        ret = OsDmesgChangeSize(size);
 8010d30:	6838      	ldr	r0, [r7, #0]
 8010d32:	f7ff fb81 	bl	8010438 <OsDmesgChangeSize>
 8010d36:	60f8      	str	r0, [r7, #12]
 8010d38:	e004      	b.n	8010d44 <LOS_DmesgMemSet+0x24>
    } else {
        ret = OsDmesgResetMem(addr, size);
 8010d3a:	6839      	ldr	r1, [r7, #0]
 8010d3c:	6878      	ldr	r0, [r7, #4]
 8010d3e:	f7ff fb0d 	bl	801035c <OsDmesgResetMem>
 8010d42:	60f8      	str	r0, [r7, #12]
    }
    return ret;
 8010d44:	68fb      	ldr	r3, [r7, #12]
}
 8010d46:	4618      	mov	r0, r3
 8010d48:	3710      	adds	r7, #16
 8010d4a:	46bd      	mov	sp, r7
 8010d4c:	bd80      	pop	{r7, pc}
	...

08010d50 <LOS_DmesgToFile>:
    free(fullpath);
    return ret;
}
#else
INT32 LOS_DmesgToFile(CHAR *filename)
{
 8010d50:	b580      	push	{r7, lr}
 8010d52:	b082      	sub	sp, #8
 8010d54:	af00      	add	r7, sp, #0
 8010d56:	6078      	str	r0, [r7, #4]
    (VOID)filename;
    PRINTK("File operation need VFS\n");
 8010d58:	4804      	ldr	r0, [pc, #16]	; (8010d6c <LOS_DmesgToFile+0x1c>)
 8010d5a:	f7f3 fcb7 	bl	80046cc <dprintf>
    return -1;
 8010d5e:	f04f 33ff 	mov.w	r3, #4294967295
}
 8010d62:	4618      	mov	r0, r3
 8010d64:	3708      	adds	r7, #8
 8010d66:	46bd      	mov	sp, r7
 8010d68:	bd80      	pop	{r7, pc}
 8010d6a:	bf00      	nop
 8010d6c:	080218c8 	.word	0x080218c8

08010d70 <OsShellCmdDmesg>:
#endif

INT32 OsShellCmdDmesg(INT32 argc, const CHAR **argv)
{
 8010d70:	b580      	push	{r7, lr}
 8010d72:	b082      	sub	sp, #8
 8010d74:	af00      	add	r7, sp, #0
 8010d76:	6078      	str	r0, [r7, #4]
 8010d78:	6039      	str	r1, [r7, #0]
    if (argc == 1) {
 8010d7a:	687b      	ldr	r3, [r7, #4]
 8010d7c:	2b01      	cmp	r3, #1
 8010d7e:	d106      	bne.n	8010d8e <OsShellCmdDmesg+0x1e>
        PRINTK("\n");
 8010d80:	485c      	ldr	r0, [pc, #368]	; (8010ef4 <OsShellCmdDmesg+0x184>)
 8010d82:	f7f3 fca3 	bl	80046cc <dprintf>
        OsLogShow();
 8010d86:	f7ff fe75 	bl	8010a74 <OsLogShow>
        return LOS_OK;
 8010d8a:	2300      	movs	r3, #0
 8010d8c:	e0ad      	b.n	8010eea <OsShellCmdDmesg+0x17a>
    } else if (argc == 2) { /* 2: count of parameters */
 8010d8e:	687b      	ldr	r3, [r7, #4]
 8010d90:	2b02      	cmp	r3, #2
 8010d92:	d158      	bne.n	8010e46 <OsShellCmdDmesg+0xd6>
        if (!strcmp(argv[1], "-c")) {
 8010d94:	683b      	ldr	r3, [r7, #0]
 8010d96:	3304      	adds	r3, #4
 8010d98:	681b      	ldr	r3, [r3, #0]
 8010d9a:	4957      	ldr	r1, [pc, #348]	; (8010ef8 <OsShellCmdDmesg+0x188>)
 8010d9c:	4618      	mov	r0, r3
 8010d9e:	f7fd fe52 	bl	800ea46 <strcmp>
 8010da2:	4603      	mov	r3, r0
 8010da4:	2b00      	cmp	r3, #0
 8010da6:	d108      	bne.n	8010dba <OsShellCmdDmesg+0x4a>
            PRINTK("\n");
 8010da8:	4852      	ldr	r0, [pc, #328]	; (8010ef4 <OsShellCmdDmesg+0x184>)
 8010daa:	f7f3 fc8f 	bl	80046cc <dprintf>
            OsLogShow();
 8010dae:	f7ff fe61 	bl	8010a74 <OsLogShow>
            LOS_DmesgClear();
 8010db2:	f7ff ff79 	bl	8010ca8 <LOS_DmesgClear>
            return LOS_OK;
 8010db6:	2300      	movs	r3, #0
 8010db8:	e097      	b.n	8010eea <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-C")) {
 8010dba:	683b      	ldr	r3, [r7, #0]
 8010dbc:	3304      	adds	r3, #4
 8010dbe:	681b      	ldr	r3, [r3, #0]
 8010dc0:	494e      	ldr	r1, [pc, #312]	; (8010efc <OsShellCmdDmesg+0x18c>)
 8010dc2:	4618      	mov	r0, r3
 8010dc4:	f7fd fe3f 	bl	800ea46 <strcmp>
 8010dc8:	4603      	mov	r3, r0
 8010dca:	2b00      	cmp	r3, #0
 8010dcc:	d103      	bne.n	8010dd6 <OsShellCmdDmesg+0x66>
            LOS_DmesgClear();
 8010dce:	f7ff ff6b 	bl	8010ca8 <LOS_DmesgClear>
            return LOS_OK;
 8010dd2:	2300      	movs	r3, #0
 8010dd4:	e089      	b.n	8010eea <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-D")) {
 8010dd6:	683b      	ldr	r3, [r7, #0]
 8010dd8:	3304      	adds	r3, #4
 8010dda:	681b      	ldr	r3, [r3, #0]
 8010ddc:	4948      	ldr	r1, [pc, #288]	; (8010f00 <OsShellCmdDmesg+0x190>)
 8010dde:	4618      	mov	r0, r3
 8010de0:	f7fd fe31 	bl	800ea46 <strcmp>
 8010de4:	4603      	mov	r3, r0
 8010de6:	2b00      	cmp	r3, #0
 8010de8:	d103      	bne.n	8010df2 <OsShellCmdDmesg+0x82>
            OsLockConsole();
 8010dea:	f7ff f911 	bl	8010010 <OsLockConsole>
            return LOS_OK;
 8010dee:	2300      	movs	r3, #0
 8010df0:	e07b      	b.n	8010eea <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-E")) {
 8010df2:	683b      	ldr	r3, [r7, #0]
 8010df4:	3304      	adds	r3, #4
 8010df6:	681b      	ldr	r3, [r3, #0]
 8010df8:	4942      	ldr	r1, [pc, #264]	; (8010f04 <OsShellCmdDmesg+0x194>)
 8010dfa:	4618      	mov	r0, r3
 8010dfc:	f7fd fe23 	bl	800ea46 <strcmp>
 8010e00:	4603      	mov	r3, r0
 8010e02:	2b00      	cmp	r3, #0
 8010e04:	d103      	bne.n	8010e0e <OsShellCmdDmesg+0x9e>
            OsUnlockConsole();
 8010e06:	f7ff f90f 	bl	8010028 <OsUnlockConsole>
            return LOS_OK;
 8010e0a:	2300      	movs	r3, #0
 8010e0c:	e06d      	b.n	8010eea <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-L")) {
 8010e0e:	683b      	ldr	r3, [r7, #0]
 8010e10:	3304      	adds	r3, #4
 8010e12:	681b      	ldr	r3, [r3, #0]
 8010e14:	493c      	ldr	r1, [pc, #240]	; (8010f08 <OsShellCmdDmesg+0x198>)
 8010e16:	4618      	mov	r0, r3
 8010e18:	f7fd fe15 	bl	800ea46 <strcmp>
 8010e1c:	4603      	mov	r3, r0
 8010e1e:	2b00      	cmp	r3, #0
 8010e20:	d103      	bne.n	8010e2a <OsShellCmdDmesg+0xba>
            OsLockUart();
 8010e22:	f7ff f90d 	bl	8010040 <OsLockUart>
            return LOS_OK;
 8010e26:	2300      	movs	r3, #0
 8010e28:	e05f      	b.n	8010eea <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-U")) {
 8010e2a:	683b      	ldr	r3, [r7, #0]
 8010e2c:	3304      	adds	r3, #4
 8010e2e:	681b      	ldr	r3, [r3, #0]
 8010e30:	4936      	ldr	r1, [pc, #216]	; (8010f0c <OsShellCmdDmesg+0x19c>)
 8010e32:	4618      	mov	r0, r3
 8010e34:	f7fd fe07 	bl	800ea46 <strcmp>
 8010e38:	4603      	mov	r3, r0
 8010e3a:	2b00      	cmp	r3, #0
 8010e3c:	d150      	bne.n	8010ee0 <OsShellCmdDmesg+0x170>
            OsUnlockUart();
 8010e3e:	f7ff f90b 	bl	8010058 <OsUnlockUart>
            return LOS_OK;
 8010e42:	2300      	movs	r3, #0
 8010e44:	e051      	b.n	8010eea <OsShellCmdDmesg+0x17a>
        }
    } else if (argc == 3) { /* 3: count of parameters */
 8010e46:	687b      	ldr	r3, [r7, #4]
 8010e48:	2b03      	cmp	r3, #3
 8010e4a:	d149      	bne.n	8010ee0 <OsShellCmdDmesg+0x170>
        if (!strcmp(argv[1], ">")) {
 8010e4c:	683b      	ldr	r3, [r7, #0]
 8010e4e:	3304      	adds	r3, #4
 8010e50:	681b      	ldr	r3, [r3, #0]
 8010e52:	492f      	ldr	r1, [pc, #188]	; (8010f10 <OsShellCmdDmesg+0x1a0>)
 8010e54:	4618      	mov	r0, r3
 8010e56:	f7fd fdf6 	bl	800ea46 <strcmp>
 8010e5a:	4603      	mov	r3, r0
 8010e5c:	2b00      	cmp	r3, #0
 8010e5e:	d11b      	bne.n	8010e98 <OsShellCmdDmesg+0x128>
            if (LOS_DmesgToFile((CHAR *)argv[2]) < 0) { /* 2:index of parameters */
 8010e60:	683b      	ldr	r3, [r7, #0]
 8010e62:	3308      	adds	r3, #8
 8010e64:	681b      	ldr	r3, [r3, #0]
 8010e66:	4618      	mov	r0, r3
 8010e68:	f7ff ff72 	bl	8010d50 <LOS_DmesgToFile>
 8010e6c:	4603      	mov	r3, r0
 8010e6e:	2b00      	cmp	r3, #0
 8010e70:	da09      	bge.n	8010e86 <OsShellCmdDmesg+0x116>
                PRINTK("Dmesg write log to %s fail \n", argv[2]); /* 2:index of parameters */
 8010e72:	683b      	ldr	r3, [r7, #0]
 8010e74:	3308      	adds	r3, #8
 8010e76:	681b      	ldr	r3, [r3, #0]
 8010e78:	4619      	mov	r1, r3
 8010e7a:	4826      	ldr	r0, [pc, #152]	; (8010f14 <OsShellCmdDmesg+0x1a4>)
 8010e7c:	f7f3 fc26 	bl	80046cc <dprintf>
                return -1;
 8010e80:	f04f 33ff 	mov.w	r3, #4294967295
 8010e84:	e031      	b.n	8010eea <OsShellCmdDmesg+0x17a>
            } else {
                PRINTK("Dmesg write log to %s success \n", argv[2]); /* 2:index of parameters */
 8010e86:	683b      	ldr	r3, [r7, #0]
 8010e88:	3308      	adds	r3, #8
 8010e8a:	681b      	ldr	r3, [r3, #0]
 8010e8c:	4619      	mov	r1, r3
 8010e8e:	4822      	ldr	r0, [pc, #136]	; (8010f18 <OsShellCmdDmesg+0x1a8>)
 8010e90:	f7f3 fc1c 	bl	80046cc <dprintf>
                return LOS_OK;
 8010e94:	2300      	movs	r3, #0
 8010e96:	e028      	b.n	8010eea <OsShellCmdDmesg+0x17a>
            }
        } else if (!strcmp(argv[1], "-l")) {
 8010e98:	683b      	ldr	r3, [r7, #0]
 8010e9a:	3304      	adds	r3, #4
 8010e9c:	681b      	ldr	r3, [r3, #0]
 8010e9e:	491f      	ldr	r1, [pc, #124]	; (8010f1c <OsShellCmdDmesg+0x1ac>)
 8010ea0:	4618      	mov	r0, r3
 8010ea2:	f7fd fdd0 	bl	800ea46 <strcmp>
 8010ea6:	4603      	mov	r3, r0
 8010ea8:	2b00      	cmp	r3, #0
 8010eaa:	d107      	bne.n	8010ebc <OsShellCmdDmesg+0x14c>
            return OsDmesgLvSet(argv[2]); /* 2:index of parameters */
 8010eac:	683b      	ldr	r3, [r7, #0]
 8010eae:	3308      	adds	r3, #8
 8010eb0:	681b      	ldr	r3, [r3, #0]
 8010eb2:	4618      	mov	r0, r3
 8010eb4:	f7ff fe56 	bl	8010b64 <OsDmesgLvSet>
 8010eb8:	4603      	mov	r3, r0
 8010eba:	e016      	b.n	8010eea <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-s")) {
 8010ebc:	683b      	ldr	r3, [r7, #0]
 8010ebe:	3304      	adds	r3, #4
 8010ec0:	681b      	ldr	r3, [r3, #0]
 8010ec2:	4917      	ldr	r1, [pc, #92]	; (8010f20 <OsShellCmdDmesg+0x1b0>)
 8010ec4:	4618      	mov	r0, r3
 8010ec6:	f7fd fdbe 	bl	800ea46 <strcmp>
 8010eca:	4603      	mov	r3, r0
 8010ecc:	2b00      	cmp	r3, #0
 8010ece:	d107      	bne.n	8010ee0 <OsShellCmdDmesg+0x170>
            return OsDmesgMemSizeSet(argv[2]); /* 2:index of parameters */
 8010ed0:	683b      	ldr	r3, [r7, #0]
 8010ed2:	3308      	adds	r3, #8
 8010ed4:	681b      	ldr	r3, [r3, #0]
 8010ed6:	4618      	mov	r0, r3
 8010ed8:	f7ff fe9a 	bl	8010c10 <OsDmesgMemSizeSet>
 8010edc:	4603      	mov	r3, r0
 8010ede:	e004      	b.n	8010eea <OsShellCmdDmesg+0x17a>
        }
    }

    PRINTK("dmesg: invalid option or parameter.\n");
 8010ee0:	4810      	ldr	r0, [pc, #64]	; (8010f24 <OsShellCmdDmesg+0x1b4>)
 8010ee2:	f7f3 fbf3 	bl	80046cc <dprintf>
    return -1;
 8010ee6:	f04f 33ff 	mov.w	r3, #4294967295
}
 8010eea:	4618      	mov	r0, r3
 8010eec:	3708      	adds	r7, #8
 8010eee:	46bd      	mov	sp, r7
 8010ef0:	bd80      	pop	{r7, pc}
 8010ef2:	bf00      	nop
 8010ef4:	080218e4 	.word	0x080218e4
 8010ef8:	080218e8 	.word	0x080218e8
 8010efc:	080218ec 	.word	0x080218ec
 8010f00:	080218f0 	.word	0x080218f0
 8010f04:	080218f4 	.word	0x080218f4
 8010f08:	080218f8 	.word	0x080218f8
 8010f0c:	080218fc 	.word	0x080218fc
 8010f10:	08021900 	.word	0x08021900
 8010f14:	08021904 	.word	0x08021904
 8010f18:	08021924 	.word	0x08021924
 8010f1c:	08021944 	.word	0x08021944
 8010f20:	08021948 	.word	0x08021948
 8010f24:	080217cc 	.word	0x080217cc

08010f28 <OsShellCmdHelp>:

#include "shcmd.h"
#include "shell_pri.h"

UINT32 OsShellCmdHelp(UINT32 argc, const CHAR **argv)
{
 8010f28:	b580      	push	{r7, lr}
 8010f2a:	b086      	sub	sp, #24
 8010f2c:	af00      	add	r7, sp, #0
 8010f2e:	6078      	str	r0, [r7, #4]
 8010f30:	6039      	str	r1, [r7, #0]
    UINT32 loop = 0;
 8010f32:	2300      	movs	r3, #0
 8010f34:	60fb      	str	r3, [r7, #12]
    CmdItemNode *curCmdItem = NULL;
 8010f36:	2300      	movs	r3, #0
 8010f38:	613b      	str	r3, [r7, #16]
    CmdModInfo *cmdInfo = OsCmdInfoGet();
 8010f3a:	f000 f89f 	bl	801107c <OsCmdInfoGet>
 8010f3e:	6178      	str	r0, [r7, #20]

    (VOID)argv;
    if (argc > 0) {
 8010f40:	687b      	ldr	r3, [r7, #4]
 8010f42:	2b00      	cmp	r3, #0
 8010f44:	d005      	beq.n	8010f52 <OsShellCmdHelp+0x2a>
        PRINTK("\nUsage: help\n");
 8010f46:	4817      	ldr	r0, [pc, #92]	; (8010fa4 <OsShellCmdHelp+0x7c>)
 8010f48:	f7f3 fbc0 	bl	80046cc <dprintf>
        return OS_ERROR;
 8010f4c:	f04f 33ff 	mov.w	r3, #4294967295
 8010f50:	e023      	b.n	8010f9a <OsShellCmdHelp+0x72>
    }

    PRINTK("*******************shell commands:*************************\n");
 8010f52:	4815      	ldr	r0, [pc, #84]	; (8010fa8 <OsShellCmdHelp+0x80>)
 8010f54:	f7f3 fbba 	bl	80046cc <dprintf>
    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &cmdInfo->cmdList.list, CmdItemNode, list) {
 8010f58:	697b      	ldr	r3, [r7, #20]
 8010f5a:	685b      	ldr	r3, [r3, #4]
 8010f5c:	613b      	str	r3, [r7, #16]
 8010f5e:	e014      	b.n	8010f8a <OsShellCmdHelp+0x62>
        if ((loop & (8 - 1)) == 0) { /* 8 - 1:just align print */
 8010f60:	68fb      	ldr	r3, [r7, #12]
 8010f62:	f003 0307 	and.w	r3, r3, #7
 8010f66:	2b00      	cmp	r3, #0
 8010f68:	d102      	bne.n	8010f70 <OsShellCmdHelp+0x48>
            PRINTK("\n");
 8010f6a:	4810      	ldr	r0, [pc, #64]	; (8010fac <OsShellCmdHelp+0x84>)
 8010f6c:	f7f3 fbae 	bl	80046cc <dprintf>
        }
        PRINTK("%-12s  ", curCmdItem->cmd->cmdKey);
 8010f70:	693b      	ldr	r3, [r7, #16]
 8010f72:	689b      	ldr	r3, [r3, #8]
 8010f74:	685b      	ldr	r3, [r3, #4]
 8010f76:	4619      	mov	r1, r3
 8010f78:	480d      	ldr	r0, [pc, #52]	; (8010fb0 <OsShellCmdHelp+0x88>)
 8010f7a:	f7f3 fba7 	bl	80046cc <dprintf>

        loop++;
 8010f7e:	68fb      	ldr	r3, [r7, #12]
 8010f80:	3301      	adds	r3, #1
 8010f82:	60fb      	str	r3, [r7, #12]
    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &cmdInfo->cmdList.list, CmdItemNode, list) {
 8010f84:	693b      	ldr	r3, [r7, #16]
 8010f86:	685b      	ldr	r3, [r3, #4]
 8010f88:	613b      	str	r3, [r7, #16]
 8010f8a:	693a      	ldr	r2, [r7, #16]
 8010f8c:	697b      	ldr	r3, [r7, #20]
 8010f8e:	429a      	cmp	r2, r3
 8010f90:	d1e6      	bne.n	8010f60 <OsShellCmdHelp+0x38>
    }

    PRINTK("\n");
 8010f92:	4806      	ldr	r0, [pc, #24]	; (8010fac <OsShellCmdHelp+0x84>)
 8010f94:	f7f3 fb9a 	bl	80046cc <dprintf>
    return 0;
 8010f98:	2300      	movs	r3, #0
}
 8010f9a:	4618      	mov	r0, r3
 8010f9c:	3718      	adds	r7, #24
 8010f9e:	46bd      	mov	sp, r7
 8010fa0:	bd80      	pop	{r7, pc}
 8010fa2:	bf00      	nop
 8010fa4:	08021954 	.word	0x08021954
 8010fa8:	08021964 	.word	0x08021964
 8010fac:	080219a4 	.word	0x080219a4
 8010fb0:	080219a8 	.word	0x080219a8

08010fb4 <LOS_ListInit>:
{
 8010fb4:	b480      	push	{r7}
 8010fb6:	b083      	sub	sp, #12
 8010fb8:	af00      	add	r7, sp, #0
 8010fba:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 8010fbc:	687b      	ldr	r3, [r7, #4]
 8010fbe:	687a      	ldr	r2, [r7, #4]
 8010fc0:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 8010fc2:	687b      	ldr	r3, [r7, #4]
 8010fc4:	687a      	ldr	r2, [r7, #4]
 8010fc6:	601a      	str	r2, [r3, #0]
}
 8010fc8:	bf00      	nop
 8010fca:	370c      	adds	r7, #12
 8010fcc:	46bd      	mov	sp, r7
 8010fce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fd2:	4770      	bx	lr

08010fd4 <LOS_ListAdd>:
{
 8010fd4:	b480      	push	{r7}
 8010fd6:	b083      	sub	sp, #12
 8010fd8:	af00      	add	r7, sp, #0
 8010fda:	6078      	str	r0, [r7, #4]
 8010fdc:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 8010fde:	687b      	ldr	r3, [r7, #4]
 8010fe0:	685a      	ldr	r2, [r3, #4]
 8010fe2:	683b      	ldr	r3, [r7, #0]
 8010fe4:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 8010fe6:	683b      	ldr	r3, [r7, #0]
 8010fe8:	687a      	ldr	r2, [r7, #4]
 8010fea:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8010fec:	687b      	ldr	r3, [r7, #4]
 8010fee:	685b      	ldr	r3, [r3, #4]
 8010ff0:	683a      	ldr	r2, [r7, #0]
 8010ff2:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 8010ff4:	687b      	ldr	r3, [r7, #4]
 8010ff6:	683a      	ldr	r2, [r7, #0]
 8010ff8:	605a      	str	r2, [r3, #4]
}
 8010ffa:	bf00      	nop
 8010ffc:	370c      	adds	r7, #12
 8010ffe:	46bd      	mov	sp, r7
 8011000:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011004:	4770      	bx	lr

08011006 <LOS_ListTailInsert>:
{
 8011006:	b580      	push	{r7, lr}
 8011008:	b082      	sub	sp, #8
 801100a:	af00      	add	r7, sp, #0
 801100c:	6078      	str	r0, [r7, #4]
 801100e:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 8011010:	687b      	ldr	r3, [r7, #4]
 8011012:	681b      	ldr	r3, [r3, #0]
 8011014:	6839      	ldr	r1, [r7, #0]
 8011016:	4618      	mov	r0, r3
 8011018:	f7ff ffdc 	bl	8010fd4 <LOS_ListAdd>
}
 801101c:	bf00      	nop
 801101e:	3708      	adds	r7, #8
 8011020:	46bd      	mov	sp, r7
 8011022:	bd80      	pop	{r7, pc}

08011024 <LOS_ListDelete>:
{
 8011024:	b480      	push	{r7}
 8011026:	b083      	sub	sp, #12
 8011028:	af00      	add	r7, sp, #0
 801102a:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 801102c:	687b      	ldr	r3, [r7, #4]
 801102e:	685b      	ldr	r3, [r3, #4]
 8011030:	687a      	ldr	r2, [r7, #4]
 8011032:	6812      	ldr	r2, [r2, #0]
 8011034:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 8011036:	687b      	ldr	r3, [r7, #4]
 8011038:	681b      	ldr	r3, [r3, #0]
 801103a:	687a      	ldr	r2, [r7, #4]
 801103c:	6852      	ldr	r2, [r2, #4]
 801103e:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8011040:	687b      	ldr	r3, [r7, #4]
 8011042:	2200      	movs	r2, #0
 8011044:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 8011046:	687b      	ldr	r3, [r7, #4]
 8011048:	2200      	movs	r2, #0
 801104a:	601a      	str	r2, [r3, #0]
}
 801104c:	bf00      	nop
 801104e:	370c      	adds	r7, #12
 8011050:	46bd      	mov	sp, r7
 8011052:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011056:	4770      	bx	lr

08011058 <LOS_ListEmpty>:
{
 8011058:	b480      	push	{r7}
 801105a:	b083      	sub	sp, #12
 801105c:	af00      	add	r7, sp, #0
 801105e:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8011060:	687b      	ldr	r3, [r7, #4]
 8011062:	685b      	ldr	r3, [r3, #4]
 8011064:	687a      	ldr	r2, [r7, #4]
 8011066:	429a      	cmp	r2, r3
 8011068:	bf0c      	ite	eq
 801106a:	2301      	moveq	r3, #1
 801106c:	2300      	movne	r3, #0
 801106e:	b2db      	uxtb	r3, r3
}
 8011070:	4618      	mov	r0, r3
 8011072:	370c      	adds	r7, #12
 8011074:	46bd      	mov	sp, r7
 8011076:	f85d 7b04 	ldr.w	r7, [sp], #4
 801107a:	4770      	bx	lr

0801107c <OsCmdInfoGet>:

LOS_HAL_TABLE_BEGIN(g_shellcmd, shellcmd);
LOS_HAL_TABLE_END(g_shellcmdEnd, shellcmd);

CmdModInfo *OsCmdInfoGet(VOID)
{
 801107c:	b480      	push	{r7}
 801107e:	af00      	add	r7, sp, #0
    return &g_cmdInfo;
 8011080:	4b02      	ldr	r3, [pc, #8]	; (801108c <OsCmdInfoGet+0x10>)
}
 8011082:	4618      	mov	r0, r3
 8011084:	46bd      	mov	sp, r7
 8011086:	f85d 7b04 	ldr.w	r7, [sp], #4
 801108a:	4770      	bx	lr
 801108c:	2000329c 	.word	0x2000329c

08011090 <OsFreeCmdPara>:

STATIC VOID OsFreeCmdPara(CmdParsed *cmdParsed)
{
 8011090:	b580      	push	{r7, lr}
 8011092:	b084      	sub	sp, #16
 8011094:	af00      	add	r7, sp, #0
 8011096:	6078      	str	r0, [r7, #4]
    UINT32 i;
    for (i = 0; i < cmdParsed->paramCnt; i++) {
 8011098:	2300      	movs	r3, #0
 801109a:	60fb      	str	r3, [r7, #12]
 801109c:	e019      	b.n	80110d2 <OsFreeCmdPara+0x42>
        if (cmdParsed->paramArray[i] != NULL) {
 801109e:	687b      	ldr	r3, [r7, #4]
 80110a0:	68fa      	ldr	r2, [r7, #12]
 80110a2:	3206      	adds	r2, #6
 80110a4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80110a8:	2b00      	cmp	r3, #0
 80110aa:	d00f      	beq.n	80110cc <OsFreeCmdPara+0x3c>
            (VOID)LOS_MemFree(m_aucSysMem0, cmdParsed->paramArray[i]);
 80110ac:	4b0e      	ldr	r3, [pc, #56]	; (80110e8 <OsFreeCmdPara+0x58>)
 80110ae:	6818      	ldr	r0, [r3, #0]
 80110b0:	687b      	ldr	r3, [r7, #4]
 80110b2:	68fa      	ldr	r2, [r7, #12]
 80110b4:	3206      	adds	r2, #6
 80110b6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80110ba:	4619      	mov	r1, r3
 80110bc:	f7f7 fd2c 	bl	8008b18 <LOS_MemFree>
            cmdParsed->paramArray[i] = NULL;
 80110c0:	687b      	ldr	r3, [r7, #4]
 80110c2:	68fa      	ldr	r2, [r7, #12]
 80110c4:	3206      	adds	r2, #6
 80110c6:	2100      	movs	r1, #0
 80110c8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i = 0; i < cmdParsed->paramCnt; i++) {
 80110cc:	68fb      	ldr	r3, [r7, #12]
 80110ce:	3301      	adds	r3, #1
 80110d0:	60fb      	str	r3, [r7, #12]
 80110d2:	687b      	ldr	r3, [r7, #4]
 80110d4:	681b      	ldr	r3, [r3, #0]
 80110d6:	68fa      	ldr	r2, [r7, #12]
 80110d8:	429a      	cmp	r2, r3
 80110da:	d3e0      	bcc.n	801109e <OsFreeCmdPara+0xe>
        }
    }
}
 80110dc:	bf00      	nop
 80110de:	bf00      	nop
 80110e0:	3710      	adds	r7, #16
 80110e2:	46bd      	mov	sp, r7
 80110e4:	bd80      	pop	{r7, pc}
 80110e6:	bf00      	nop
 80110e8:	200021b4 	.word	0x200021b4

080110ec <OsCompleteStr>:

STATIC VOID OsCompleteStr(CHAR *result, const CHAR *target, CHAR *cmdKey, UINT32 *len)
{
 80110ec:	b590      	push	{r4, r7, lr}
 80110ee:	b089      	sub	sp, #36	; 0x24
 80110f0:	af00      	add	r7, sp, #0
 80110f2:	60f8      	str	r0, [r7, #12]
 80110f4:	60b9      	str	r1, [r7, #8]
 80110f6:	607a      	str	r2, [r7, #4]
 80110f8:	603b      	str	r3, [r7, #0]
    UINT32 size = strlen(result) - strlen(target);
 80110fa:	68f8      	ldr	r0, [r7, #12]
 80110fc:	f7fd fcc5 	bl	800ea8a <strlen>
 8011100:	4604      	mov	r4, r0
 8011102:	68b8      	ldr	r0, [r7, #8]
 8011104:	f7fd fcc1 	bl	800ea8a <strlen>
 8011108:	4603      	mov	r3, r0
 801110a:	1ae3      	subs	r3, r4, r3
 801110c:	617b      	str	r3, [r7, #20]
    CHAR *des = cmdKey + *len;
 801110e:	683b      	ldr	r3, [r7, #0]
 8011110:	681b      	ldr	r3, [r3, #0]
 8011112:	687a      	ldr	r2, [r7, #4]
 8011114:	4413      	add	r3, r2
 8011116:	61bb      	str	r3, [r7, #24]
    CHAR *src = result + strlen(target);
 8011118:	68b8      	ldr	r0, [r7, #8]
 801111a:	f7fd fcb6 	bl	800ea8a <strlen>
 801111e:	4602      	mov	r2, r0
 8011120:	68fb      	ldr	r3, [r7, #12]
 8011122:	4413      	add	r3, r2
 8011124:	61fb      	str	r3, [r7, #28]

    while (size-- > 0) {
 8011126:	e01c      	b.n	8011162 <OsCompleteStr+0x76>
        PRINTK("%c", *src);
 8011128:	69fb      	ldr	r3, [r7, #28]
 801112a:	781b      	ldrb	r3, [r3, #0]
 801112c:	4619      	mov	r1, r3
 801112e:	4812      	ldr	r0, [pc, #72]	; (8011178 <OsCompleteStr+0x8c>)
 8011130:	f7f3 facc 	bl	80046cc <dprintf>
        if (*len == (SHOW_MAX_LEN - 1)) {
 8011134:	683b      	ldr	r3, [r7, #0]
 8011136:	681b      	ldr	r3, [r3, #0]
 8011138:	f240 120f 	movw	r2, #271	; 0x10f
 801113c:	4293      	cmp	r3, r2
 801113e:	d103      	bne.n	8011148 <OsCompleteStr+0x5c>
            *des = '\0';
 8011140:	69bb      	ldr	r3, [r7, #24]
 8011142:	2200      	movs	r2, #0
 8011144:	701a      	strb	r2, [r3, #0]
            break;
 8011146:	e012      	b.n	801116e <OsCompleteStr+0x82>
        }
        *des++ = *src++;
 8011148:	69fa      	ldr	r2, [r7, #28]
 801114a:	1c53      	adds	r3, r2, #1
 801114c:	61fb      	str	r3, [r7, #28]
 801114e:	69bb      	ldr	r3, [r7, #24]
 8011150:	1c59      	adds	r1, r3, #1
 8011152:	61b9      	str	r1, [r7, #24]
 8011154:	7812      	ldrb	r2, [r2, #0]
 8011156:	701a      	strb	r2, [r3, #0]
        (*len)++;
 8011158:	683b      	ldr	r3, [r7, #0]
 801115a:	681b      	ldr	r3, [r3, #0]
 801115c:	1c5a      	adds	r2, r3, #1
 801115e:	683b      	ldr	r3, [r7, #0]
 8011160:	601a      	str	r2, [r3, #0]
    while (size-- > 0) {
 8011162:	697b      	ldr	r3, [r7, #20]
 8011164:	1e5a      	subs	r2, r3, #1
 8011166:	617a      	str	r2, [r7, #20]
 8011168:	2b00      	cmp	r3, #0
 801116a:	d1dd      	bne.n	8011128 <OsCompleteStr+0x3c>
    }
}
 801116c:	bf00      	nop
 801116e:	bf00      	nop
 8011170:	3724      	adds	r7, #36	; 0x24
 8011172:	46bd      	mov	sp, r7
 8011174:	bd90      	pop	{r4, r7, pc}
 8011176:	bf00      	nop
 8011178:	080219b8 	.word	0x080219b8

0801117c <OsTabMatchFile>:
    (VOID)LOS_MemFree(m_aucSysMem0, dirOpen);
    return count;
}
#else
STATIC INT32 OsTabMatchFile(CHAR *cmdKey, UINT32 *len)
{
 801117c:	b480      	push	{r7}
 801117e:	b083      	sub	sp, #12
 8011180:	af00      	add	r7, sp, #0
 8011182:	6078      	str	r0, [r7, #4]
 8011184:	6039      	str	r1, [r7, #0]
    return 0;
 8011186:	2300      	movs	r3, #0
}
 8011188:	4618      	mov	r0, r3
 801118a:	370c      	adds	r7, #12
 801118c:	46bd      	mov	sp, r7
 801118e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011192:	4770      	bx	lr

08011194 <OsTabMatchCmd>:
#endif

STATIC INT32 OsTabMatchCmd(CHAR *cmdKey, UINT32 *len)
{
 8011194:	b590      	push	{r4, r7, lr}
 8011196:	b089      	sub	sp, #36	; 0x24
 8011198:	af00      	add	r7, sp, #0
 801119a:	6078      	str	r0, [r7, #4]
 801119c:	6039      	str	r1, [r7, #0]
    INT32 count = 0;
 801119e:	2300      	movs	r3, #0
 80111a0:	60fb      	str	r3, [r7, #12]
    INT32 ret;
    CmdItemNode *cmdItemGuard = NULL;
 80111a2:	2300      	movs	r3, #0
 80111a4:	613b      	str	r3, [r7, #16]
    CmdItemNode *curCmdItem = NULL;
 80111a6:	2300      	movs	r3, #0
 80111a8:	617b      	str	r3, [r7, #20]
    CHAR *cmdMajor = cmdKey;
 80111aa:	687b      	ldr	r3, [r7, #4]
 80111ac:	61bb      	str	r3, [r7, #24]

    while (*cmdMajor == SPACE) { /* cut left space */
 80111ae:	e002      	b.n	80111b6 <OsTabMatchCmd+0x22>
        cmdMajor++;
 80111b0:	69bb      	ldr	r3, [r7, #24]
 80111b2:	3301      	adds	r3, #1
 80111b4:	61bb      	str	r3, [r7, #24]
    while (*cmdMajor == SPACE) { /* cut left space */
 80111b6:	69bb      	ldr	r3, [r7, #24]
 80111b8:	781b      	ldrb	r3, [r3, #0]
 80111ba:	2b20      	cmp	r3, #32
 80111bc:	d0f8      	beq.n	80111b0 <OsTabMatchCmd+0x1c>
    }

    if (LOS_ListEmpty(&g_cmdInfo.cmdList.list)) {
 80111be:	4831      	ldr	r0, [pc, #196]	; (8011284 <OsTabMatchCmd+0xf0>)
 80111c0:	f7ff ff4a 	bl	8011058 <LOS_ListEmpty>
 80111c4:	4603      	mov	r3, r0
 80111c6:	2b00      	cmp	r3, #0
 80111c8:	d002      	beq.n	80111d0 <OsTabMatchCmd+0x3c>
        return (INT32)OS_ERROR;
 80111ca:	f04f 33ff 	mov.w	r3, #4294967295
 80111ce:	e055      	b.n	801127c <OsTabMatchCmd+0xe8>
    }

    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &g_cmdInfo.cmdList.list, CmdItemNode, list) {
 80111d0:	4b2c      	ldr	r3, [pc, #176]	; (8011284 <OsTabMatchCmd+0xf0>)
 80111d2:	685b      	ldr	r3, [r3, #4]
 80111d4:	617b      	str	r3, [r7, #20]
 80111d6:	e01f      	b.n	8011218 <OsTabMatchCmd+0x84>
        ret = strncmp(cmdMajor, curCmdItem->cmd->cmdKey, strlen(cmdMajor));
 80111d8:	697b      	ldr	r3, [r7, #20]
 80111da:	689b      	ldr	r3, [r3, #8]
 80111dc:	685c      	ldr	r4, [r3, #4]
 80111de:	69b8      	ldr	r0, [r7, #24]
 80111e0:	f7fd fc53 	bl	800ea8a <strlen>
 80111e4:	4603      	mov	r3, r0
 80111e6:	461a      	mov	r2, r3
 80111e8:	4621      	mov	r1, r4
 80111ea:	69b8      	ldr	r0, [r7, #24]
 80111ec:	f008 f91c 	bl	8019428 <strncmp>
 80111f0:	61f8      	str	r0, [r7, #28]
        if (ret > 0) {
 80111f2:	69fb      	ldr	r3, [r7, #28]
 80111f4:	2b00      	cmp	r3, #0
 80111f6:	dc0b      	bgt.n	8011210 <OsTabMatchCmd+0x7c>
            continue;
        } else if (ret != 0) {
 80111f8:	69fb      	ldr	r3, [r7, #28]
 80111fa:	2b00      	cmp	r3, #0
 80111fc:	d111      	bne.n	8011222 <OsTabMatchCmd+0x8e>
            break;
        }

        if (count == 0) {
 80111fe:	68fb      	ldr	r3, [r7, #12]
 8011200:	2b00      	cmp	r3, #0
 8011202:	d101      	bne.n	8011208 <OsTabMatchCmd+0x74>
            cmdItemGuard = curCmdItem;
 8011204:	697b      	ldr	r3, [r7, #20]
 8011206:	613b      	str	r3, [r7, #16]
        }
        ++count;
 8011208:	68fb      	ldr	r3, [r7, #12]
 801120a:	3301      	adds	r3, #1
 801120c:	60fb      	str	r3, [r7, #12]
 801120e:	e000      	b.n	8011212 <OsTabMatchCmd+0x7e>
            continue;
 8011210:	bf00      	nop
    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &g_cmdInfo.cmdList.list, CmdItemNode, list) {
 8011212:	697b      	ldr	r3, [r7, #20]
 8011214:	685b      	ldr	r3, [r3, #4]
 8011216:	617b      	str	r3, [r7, #20]
 8011218:	697b      	ldr	r3, [r7, #20]
 801121a:	4a1a      	ldr	r2, [pc, #104]	; (8011284 <OsTabMatchCmd+0xf0>)
 801121c:	4293      	cmp	r3, r2
 801121e:	d1db      	bne.n	80111d8 <OsTabMatchCmd+0x44>
 8011220:	e000      	b.n	8011224 <OsTabMatchCmd+0x90>
            break;
 8011222:	bf00      	nop
    }

    if (cmdItemGuard == NULL) {
 8011224:	693b      	ldr	r3, [r7, #16]
 8011226:	2b00      	cmp	r3, #0
 8011228:	d101      	bne.n	801122e <OsTabMatchCmd+0x9a>
        return 0;
 801122a:	2300      	movs	r3, #0
 801122c:	e026      	b.n	801127c <OsTabMatchCmd+0xe8>
    }

    if (count == 1) {
 801122e:	68fb      	ldr	r3, [r7, #12]
 8011230:	2b01      	cmp	r3, #1
 8011232:	d107      	bne.n	8011244 <OsTabMatchCmd+0xb0>
        OsCompleteStr(cmdItemGuard->cmd->cmdKey, cmdMajor, cmdKey, len);
 8011234:	693b      	ldr	r3, [r7, #16]
 8011236:	689b      	ldr	r3, [r3, #8]
 8011238:	6858      	ldr	r0, [r3, #4]
 801123a:	683b      	ldr	r3, [r7, #0]
 801123c:	687a      	ldr	r2, [r7, #4]
 801123e:	69b9      	ldr	r1, [r7, #24]
 8011240:	f7ff ff54 	bl	80110ec <OsCompleteStr>
    }

    ret = count;
 8011244:	68fb      	ldr	r3, [r7, #12]
 8011246:	61fb      	str	r3, [r7, #28]
    if (count > 1) {
 8011248:	68fb      	ldr	r3, [r7, #12]
 801124a:	2b01      	cmp	r3, #1
 801124c:	dd15      	ble.n	801127a <OsTabMatchCmd+0xe6>
        PRINTK("\n");
 801124e:	480e      	ldr	r0, [pc, #56]	; (8011288 <OsTabMatchCmd+0xf4>)
 8011250:	f7f3 fa3c 	bl	80046cc <dprintf>
        while (count--) {
 8011254:	e009      	b.n	801126a <OsTabMatchCmd+0xd6>
            PRINTK("%s  ", cmdItemGuard->cmd->cmdKey);
 8011256:	693b      	ldr	r3, [r7, #16]
 8011258:	689b      	ldr	r3, [r3, #8]
 801125a:	685b      	ldr	r3, [r3, #4]
 801125c:	4619      	mov	r1, r3
 801125e:	480b      	ldr	r0, [pc, #44]	; (801128c <OsTabMatchCmd+0xf8>)
 8011260:	f7f3 fa34 	bl	80046cc <dprintf>
            cmdItemGuard = LOS_DL_LIST_ENTRY(cmdItemGuard->list.pstNext, CmdItemNode, list);
 8011264:	693b      	ldr	r3, [r7, #16]
 8011266:	685b      	ldr	r3, [r3, #4]
 8011268:	613b      	str	r3, [r7, #16]
        while (count--) {
 801126a:	68fb      	ldr	r3, [r7, #12]
 801126c:	1e5a      	subs	r2, r3, #1
 801126e:	60fa      	str	r2, [r7, #12]
 8011270:	2b00      	cmp	r3, #0
 8011272:	d1f0      	bne.n	8011256 <OsTabMatchCmd+0xc2>
        }
        PRINTK("\n");
 8011274:	4804      	ldr	r0, [pc, #16]	; (8011288 <OsTabMatchCmd+0xf4>)
 8011276:	f7f3 fa29 	bl	80046cc <dprintf>
    }

    return ret;
 801127a:	69fb      	ldr	r3, [r7, #28]
}
 801127c:	4618      	mov	r0, r3
 801127e:	3724      	adds	r7, #36	; 0x24
 8011280:	46bd      	mov	sp, r7
 8011282:	bd90      	pop	{r4, r7, pc}
 8011284:	2000329c 	.word	0x2000329c
 8011288:	080219bc 	.word	0x080219bc
 801128c:	080219c0 	.word	0x080219c0

08011290 <OsCmdKeyShift>:
 * Input:       cmdKey : Pass in the buff string, which is ready to be operated
 *              cmdOut : Pass out the buffer string, which has already been operated
 *              size : cmdKey length
 */
LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdKeyShift(const CHAR *cmdKey, CHAR *cmdOut, UINT32 size)
{
 8011290:	b580      	push	{r7, lr}
 8011292:	b08a      	sub	sp, #40	; 0x28
 8011294:	af00      	add	r7, sp, #0
 8011296:	60f8      	str	r0, [r7, #12]
 8011298:	60b9      	str	r1, [r7, #8]
 801129a:	607a      	str	r2, [r7, #4]
    CHAR *output = NULL;
 801129c:	2300      	movs	r3, #0
 801129e:	617b      	str	r3, [r7, #20]
    CHAR *outputBak = NULL;
 80112a0:	2300      	movs	r3, #0
 80112a2:	623b      	str	r3, [r7, #32]
    UINT32 len;
    INT32 ret;
    BOOL quotes = FALSE;
 80112a4:	2300      	movs	r3, #0
 80112a6:	61fb      	str	r3, [r7, #28]

    if ((cmdKey == NULL) || (cmdOut == NULL)) {
 80112a8:	68fb      	ldr	r3, [r7, #12]
 80112aa:	2b00      	cmp	r3, #0
 80112ac:	d002      	beq.n	80112b4 <OsCmdKeyShift+0x24>
 80112ae:	68bb      	ldr	r3, [r7, #8]
 80112b0:	2b00      	cmp	r3, #0
 80112b2:	d102      	bne.n	80112ba <OsCmdKeyShift+0x2a>
        return OS_ERROR;
 80112b4:	f04f 33ff 	mov.w	r3, #4294967295
 80112b8:	e08c      	b.n	80113d4 <OsCmdKeyShift+0x144>
    }

    len = strlen(cmdKey);
 80112ba:	68f8      	ldr	r0, [r7, #12]
 80112bc:	f7fd fbe5 	bl	800ea8a <strlen>
 80112c0:	61b8      	str	r0, [r7, #24]
    if (len >= size) {
 80112c2:	69ba      	ldr	r2, [r7, #24]
 80112c4:	687b      	ldr	r3, [r7, #4]
 80112c6:	429a      	cmp	r2, r3
 80112c8:	d302      	bcc.n	80112d0 <OsCmdKeyShift+0x40>
        return OS_ERROR;
 80112ca:	f04f 33ff 	mov.w	r3, #4294967295
 80112ce:	e081      	b.n	80113d4 <OsCmdKeyShift+0x144>
    }
    output = (CHAR*)LOS_MemAlloc(m_aucSysMem0, len + 1);
 80112d0:	4b42      	ldr	r3, [pc, #264]	; (80113dc <OsCmdKeyShift+0x14c>)
 80112d2:	681a      	ldr	r2, [r3, #0]
 80112d4:	69bb      	ldr	r3, [r7, #24]
 80112d6:	3301      	adds	r3, #1
 80112d8:	4619      	mov	r1, r3
 80112da:	4610      	mov	r0, r2
 80112dc:	f7f7 fb64 	bl	80089a8 <LOS_MemAlloc>
 80112e0:	6178      	str	r0, [r7, #20]
    if (output == NULL) {
 80112e2:	697b      	ldr	r3, [r7, #20]
 80112e4:	2b00      	cmp	r3, #0
 80112e6:	d108      	bne.n	80112fa <OsCmdKeyShift+0x6a>
        PRINTK("malloc failure in %s[%d]", __FUNCTION__, __LINE__);
 80112e8:	f44f 72e5 	mov.w	r2, #458	; 0x1ca
 80112ec:	493c      	ldr	r1, [pc, #240]	; (80113e0 <OsCmdKeyShift+0x150>)
 80112ee:	483d      	ldr	r0, [pc, #244]	; (80113e4 <OsCmdKeyShift+0x154>)
 80112f0:	f7f3 f9ec 	bl	80046cc <dprintf>
        return OS_ERROR;
 80112f4:	f04f 33ff 	mov.w	r3, #4294967295
 80112f8:	e06c      	b.n	80113d4 <OsCmdKeyShift+0x144>
    }
    /* backup the 'output' start address */
    outputBak = output;
 80112fa:	697b      	ldr	r3, [r7, #20]
 80112fc:	623b      	str	r3, [r7, #32]
    /* scan each character in 'cmdKey',and squeeze the overmuch space and ignore Invalid character */
    for (; *cmdKey != '\0'; cmdKey++) {
 80112fe:	e02e      	b.n	801135e <OsCmdKeyShift+0xce>
        /* detected a Double Quotes, switch the matching status */
        if (*cmdKey == '\"') {
 8011300:	68fb      	ldr	r3, [r7, #12]
 8011302:	781b      	ldrb	r3, [r3, #0]
 8011304:	2b22      	cmp	r3, #34	; 0x22
 8011306:	d107      	bne.n	8011318 <OsCmdKeyShift+0x88>
            SWITCH_QUOTES_STATUS(quotes);
 8011308:	69fb      	ldr	r3, [r7, #28]
 801130a:	2b01      	cmp	r3, #1
 801130c:	d102      	bne.n	8011314 <OsCmdKeyShift+0x84>
 801130e:	2300      	movs	r3, #0
 8011310:	61fb      	str	r3, [r7, #28]
 8011312:	e001      	b.n	8011318 <OsCmdKeyShift+0x88>
 8011314:	2301      	movs	r3, #1
 8011316:	61fb      	str	r3, [r7, #28]
        /* Ignore the current character in following situation */
        /* 1) Quotes matching status is FALSE (which said that the space is not been marked by double quotes) */
        /* 2) Current character is a space */
        /* 3) Next character is a space too, or the string is been seeked to the end already(\0) */
        /* 4) Invalid character, such as single quotes */
        if ((*cmdKey == ' ') && ((*(cmdKey + 1) == ' ') || (*(cmdKey + 1) == '\0')) && QUOTES_STATUS_CLOSE(quotes)) {
 8011318:	68fb      	ldr	r3, [r7, #12]
 801131a:	781b      	ldrb	r3, [r3, #0]
 801131c:	2b20      	cmp	r3, #32
 801131e:	d10c      	bne.n	801133a <OsCmdKeyShift+0xaa>
 8011320:	68fb      	ldr	r3, [r7, #12]
 8011322:	3301      	adds	r3, #1
 8011324:	781b      	ldrb	r3, [r3, #0]
 8011326:	2b20      	cmp	r3, #32
 8011328:	d004      	beq.n	8011334 <OsCmdKeyShift+0xa4>
 801132a:	68fb      	ldr	r3, [r7, #12]
 801132c:	3301      	adds	r3, #1
 801132e:	781b      	ldrb	r3, [r3, #0]
 8011330:	2b00      	cmp	r3, #0
 8011332:	d102      	bne.n	801133a <OsCmdKeyShift+0xaa>
 8011334:	69fb      	ldr	r3, [r7, #28]
 8011336:	2b00      	cmp	r3, #0
 8011338:	d00b      	beq.n	8011352 <OsCmdKeyShift+0xc2>
            continue;
        }
        if (*cmdKey == '\'') {
 801133a:	68fb      	ldr	r3, [r7, #12]
 801133c:	781b      	ldrb	r3, [r3, #0]
 801133e:	2b27      	cmp	r3, #39	; 0x27
 8011340:	d009      	beq.n	8011356 <OsCmdKeyShift+0xc6>
            continue;
        }
        *output = *cmdKey;
 8011342:	68fb      	ldr	r3, [r7, #12]
 8011344:	781a      	ldrb	r2, [r3, #0]
 8011346:	697b      	ldr	r3, [r7, #20]
 8011348:	701a      	strb	r2, [r3, #0]
        output++;
 801134a:	697b      	ldr	r3, [r7, #20]
 801134c:	3301      	adds	r3, #1
 801134e:	617b      	str	r3, [r7, #20]
 8011350:	e002      	b.n	8011358 <OsCmdKeyShift+0xc8>
            continue;
 8011352:	bf00      	nop
 8011354:	e000      	b.n	8011358 <OsCmdKeyShift+0xc8>
            continue;
 8011356:	bf00      	nop
    for (; *cmdKey != '\0'; cmdKey++) {
 8011358:	68fb      	ldr	r3, [r7, #12]
 801135a:	3301      	adds	r3, #1
 801135c:	60fb      	str	r3, [r7, #12]
 801135e:	68fb      	ldr	r3, [r7, #12]
 8011360:	781b      	ldrb	r3, [r3, #0]
 8011362:	2b00      	cmp	r3, #0
 8011364:	d1cc      	bne.n	8011300 <OsCmdKeyShift+0x70>
    }
    *output = '\0';
 8011366:	697b      	ldr	r3, [r7, #20]
 8011368:	2200      	movs	r2, #0
 801136a:	701a      	strb	r2, [r3, #0]
    /* restore the 'output' start address */
    output = outputBak;
 801136c:	6a3b      	ldr	r3, [r7, #32]
 801136e:	617b      	str	r3, [r7, #20]
    len = strlen(output);
 8011370:	6978      	ldr	r0, [r7, #20]
 8011372:	f7fd fb8a 	bl	800ea8a <strlen>
 8011376:	61b8      	str	r0, [r7, #24]
    /* clear the space which is located at the first character in buffer */
    if (*output == ' ') {
 8011378:	697b      	ldr	r3, [r7, #20]
 801137a:	781b      	ldrb	r3, [r3, #0]
 801137c:	2b20      	cmp	r3, #32
 801137e:	d105      	bne.n	801138c <OsCmdKeyShift+0xfc>
        output++;
 8011380:	697b      	ldr	r3, [r7, #20]
 8011382:	3301      	adds	r3, #1
 8011384:	617b      	str	r3, [r7, #20]
        len--;
 8011386:	69bb      	ldr	r3, [r7, #24]
 8011388:	3b01      	subs	r3, #1
 801138a:	61bb      	str	r3, [r7, #24]
    }
    /* copy out the buffer which is been operated already */
    ret = strncpy_s(cmdOut, size, output, len);
 801138c:	69bb      	ldr	r3, [r7, #24]
 801138e:	697a      	ldr	r2, [r7, #20]
 8011390:	6879      	ldr	r1, [r7, #4]
 8011392:	68b8      	ldr	r0, [r7, #8]
 8011394:	f004 ff68 	bl	8016268 <strncpy_s>
 8011398:	6278      	str	r0, [r7, #36]	; 0x24
    if (ret != EOK) {
 801139a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801139c:	2b00      	cmp	r3, #0
 801139e:	d012      	beq.n	80113c6 <OsCmdKeyShift+0x136>
        PRINT_ERR("%s,%d strncpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 80113a0:	4811      	ldr	r0, [pc, #68]	; (80113e8 <OsCmdKeyShift+0x158>)
 80113a2:	f7f3 f993 	bl	80046cc <dprintf>
 80113a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80113a8:	f240 12ef 	movw	r2, #495	; 0x1ef
 80113ac:	490c      	ldr	r1, [pc, #48]	; (80113e0 <OsCmdKeyShift+0x150>)
 80113ae:	480f      	ldr	r0, [pc, #60]	; (80113ec <OsCmdKeyShift+0x15c>)
 80113b0:	f7f3 f98c 	bl	80046cc <dprintf>
        (VOID)LOS_MemFree(m_aucSysMem0, outputBak);
 80113b4:	4b09      	ldr	r3, [pc, #36]	; (80113dc <OsCmdKeyShift+0x14c>)
 80113b6:	681b      	ldr	r3, [r3, #0]
 80113b8:	6a39      	ldr	r1, [r7, #32]
 80113ba:	4618      	mov	r0, r3
 80113bc:	f7f7 fbac 	bl	8008b18 <LOS_MemFree>
        return OS_ERROR;
 80113c0:	f04f 33ff 	mov.w	r3, #4294967295
 80113c4:	e006      	b.n	80113d4 <OsCmdKeyShift+0x144>
    }

    (VOID)LOS_MemFree(m_aucSysMem0, outputBak);
 80113c6:	4b05      	ldr	r3, [pc, #20]	; (80113dc <OsCmdKeyShift+0x14c>)
 80113c8:	681b      	ldr	r3, [r3, #0]
 80113ca:	6a39      	ldr	r1, [r7, #32]
 80113cc:	4618      	mov	r0, r3
 80113ce:	f7f7 fba3 	bl	8008b18 <LOS_MemFree>

    return LOS_OK;
 80113d2:	2300      	movs	r3, #0
}
 80113d4:	4618      	mov	r0, r3
 80113d6:	3728      	adds	r7, #40	; 0x28
 80113d8:	46bd      	mov	sp, r7
 80113da:	bd80      	pop	{r7, pc}
 80113dc:	200021b4 	.word	0x200021b4
 80113e0:	08023540 	.word	0x08023540
 80113e4:	080219c8 	.word	0x080219c8
 80113e8:	080219e4 	.word	0x080219e4
 80113ec:	080219ec 	.word	0x080219ec

080113f0 <OsTabCompletion>:

    return TRUE;
}

LITE_OS_SEC_TEXT_MINOR INT32 OsTabCompletion(CHAR *cmdKey, UINT32 *len)
{
 80113f0:	b580      	push	{r7, lr}
 80113f2:	b086      	sub	sp, #24
 80113f4:	af00      	add	r7, sp, #0
 80113f6:	6078      	str	r0, [r7, #4]
 80113f8:	6039      	str	r1, [r7, #0]
    INT32 count = 0;
 80113fa:	2300      	movs	r3, #0
 80113fc:	60fb      	str	r3, [r7, #12]
    CHAR *space = NULL;
 80113fe:	2300      	movs	r3, #0
 8011400:	617b      	str	r3, [r7, #20]
    CHAR *cmdMainStr = cmdKey;
 8011402:	687b      	ldr	r3, [r7, #4]
 8011404:	613b      	str	r3, [r7, #16]

    if ((cmdKey == NULL) || (len == NULL)) {
 8011406:	687b      	ldr	r3, [r7, #4]
 8011408:	2b00      	cmp	r3, #0
 801140a:	d002      	beq.n	8011412 <OsTabCompletion+0x22>
 801140c:	683b      	ldr	r3, [r7, #0]
 801140e:	2b00      	cmp	r3, #0
 8011410:	d105      	bne.n	801141e <OsTabCompletion+0x2e>
        return (INT32)OS_ERROR;
 8011412:	f04f 33ff 	mov.w	r3, #4294967295
 8011416:	e020      	b.n	801145a <OsTabCompletion+0x6a>
    }

    /* cut left space */
    while (*cmdMainStr == SPACE) {
        cmdMainStr++;
 8011418:	693b      	ldr	r3, [r7, #16]
 801141a:	3301      	adds	r3, #1
 801141c:	613b      	str	r3, [r7, #16]
    while (*cmdMainStr == SPACE) {
 801141e:	693b      	ldr	r3, [r7, #16]
 8011420:	781b      	ldrb	r3, [r3, #0]
 8011422:	2b20      	cmp	r3, #32
 8011424:	d0f8      	beq.n	8011418 <OsTabCompletion+0x28>
    }

    /* try to find space in remain */
    space = strrchr(cmdMainStr, SPACE);
 8011426:	2120      	movs	r1, #32
 8011428:	6938      	ldr	r0, [r7, #16]
 801142a:	f008 f834 	bl	8019496 <strrchr>
 801142e:	6178      	str	r0, [r7, #20]
    if ((space == NULL) && (*cmdMainStr != '\0')) {
 8011430:	697b      	ldr	r3, [r7, #20]
 8011432:	2b00      	cmp	r3, #0
 8011434:	d108      	bne.n	8011448 <OsTabCompletion+0x58>
 8011436:	693b      	ldr	r3, [r7, #16]
 8011438:	781b      	ldrb	r3, [r3, #0]
 801143a:	2b00      	cmp	r3, #0
 801143c:	d004      	beq.n	8011448 <OsTabCompletion+0x58>
        count = OsTabMatchCmd(cmdKey, len);
 801143e:	6839      	ldr	r1, [r7, #0]
 8011440:	6878      	ldr	r0, [r7, #4]
 8011442:	f7ff fea7 	bl	8011194 <OsTabMatchCmd>
 8011446:	60f8      	str	r0, [r7, #12]
    }

    if (count == 0) {
 8011448:	68fb      	ldr	r3, [r7, #12]
 801144a:	2b00      	cmp	r3, #0
 801144c:	d104      	bne.n	8011458 <OsTabCompletion+0x68>
        count = OsTabMatchFile(cmdKey, len);
 801144e:	6839      	ldr	r1, [r7, #0]
 8011450:	6878      	ldr	r0, [r7, #4]
 8011452:	f7ff fe93 	bl	801117c <OsTabMatchFile>
 8011456:	60f8      	str	r0, [r7, #12]
    }

    return count;
 8011458:	68fb      	ldr	r3, [r7, #12]
}
 801145a:	4618      	mov	r0, r3
 801145c:	3718      	adds	r7, #24
 801145e:	46bd      	mov	sp, r7
 8011460:	bd80      	pop	{r7, pc}
	...

08011464 <OsCmdAscendingInsert>:

LITE_OS_SEC_TEXT_MINOR VOID OsCmdAscendingInsert(CmdItemNode *cmd)
{
 8011464:	b5b0      	push	{r4, r5, r7, lr}
 8011466:	b084      	sub	sp, #16
 8011468:	af00      	add	r7, sp, #0
 801146a:	6078      	str	r0, [r7, #4]
    CmdItemNode *cmdItem = NULL;
 801146c:	2300      	movs	r3, #0
 801146e:	60bb      	str	r3, [r7, #8]
    CmdItemNode *cmdNext = NULL;
 8011470:	2300      	movs	r3, #0
 8011472:	60fb      	str	r3, [r7, #12]

    for (cmdItem = LOS_DL_LIST_ENTRY((&g_cmdInfo.cmdList.list)->pstPrev, CmdItemNode, list);
 8011474:	4b32      	ldr	r3, [pc, #200]	; (8011540 <OsCmdAscendingInsert+0xdc>)
 8011476:	681b      	ldr	r3, [r3, #0]
 8011478:	60bb      	str	r3, [r7, #8]
 801147a:	e052      	b.n	8011522 <OsCmdAscendingInsert+0xbe>
         &cmdItem->list != &g_cmdInfo.cmdList.list;) {
        cmdNext = LOS_DL_LIST_ENTRY(cmdItem->list.pstPrev, CmdItemNode, list);
 801147c:	68bb      	ldr	r3, [r7, #8]
 801147e:	681b      	ldr	r3, [r3, #0]
 8011480:	60fb      	str	r3, [r7, #12]
        if (&cmdNext->list != &g_cmdInfo.cmdList.list) {
 8011482:	68fb      	ldr	r3, [r7, #12]
 8011484:	4a2e      	ldr	r2, [pc, #184]	; (8011540 <OsCmdAscendingInsert+0xdc>)
 8011486:	4293      	cmp	r3, r2
 8011488:	d033      	beq.n	80114f2 <OsCmdAscendingInsert+0x8e>
            if ((strncmp(cmdItem->cmd->cmdKey, cmd->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) >= 0) &&
 801148a:	68bb      	ldr	r3, [r7, #8]
 801148c:	689b      	ldr	r3, [r3, #8]
 801148e:	685c      	ldr	r4, [r3, #4]
 8011490:	687b      	ldr	r3, [r7, #4]
 8011492:	689b      	ldr	r3, [r3, #8]
 8011494:	685d      	ldr	r5, [r3, #4]
 8011496:	687b      	ldr	r3, [r7, #4]
 8011498:	689b      	ldr	r3, [r3, #8]
 801149a:	685b      	ldr	r3, [r3, #4]
 801149c:	4618      	mov	r0, r3
 801149e:	f7fd faf4 	bl	800ea8a <strlen>
 80114a2:	4603      	mov	r3, r0
 80114a4:	461a      	mov	r2, r3
 80114a6:	4629      	mov	r1, r5
 80114a8:	4620      	mov	r0, r4
 80114aa:	f007 ffbd 	bl	8019428 <strncmp>
 80114ae:	4603      	mov	r3, r0
 80114b0:	2b00      	cmp	r3, #0
 80114b2:	db1b      	blt.n	80114ec <OsCmdAscendingInsert+0x88>
                (strncmp(cmdNext->cmd->cmdKey, cmd->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) < 0)) {
 80114b4:	68fb      	ldr	r3, [r7, #12]
 80114b6:	689b      	ldr	r3, [r3, #8]
 80114b8:	685c      	ldr	r4, [r3, #4]
 80114ba:	687b      	ldr	r3, [r7, #4]
 80114bc:	689b      	ldr	r3, [r3, #8]
 80114be:	685d      	ldr	r5, [r3, #4]
 80114c0:	687b      	ldr	r3, [r7, #4]
 80114c2:	689b      	ldr	r3, [r3, #8]
 80114c4:	685b      	ldr	r3, [r3, #4]
 80114c6:	4618      	mov	r0, r3
 80114c8:	f7fd fadf 	bl	800ea8a <strlen>
 80114cc:	4603      	mov	r3, r0
 80114ce:	461a      	mov	r2, r3
 80114d0:	4629      	mov	r1, r5
 80114d2:	4620      	mov	r0, r4
 80114d4:	f007 ffa8 	bl	8019428 <strncmp>
 80114d8:	4603      	mov	r3, r0
            if ((strncmp(cmdItem->cmd->cmdKey, cmd->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) >= 0) &&
 80114da:	2b00      	cmp	r3, #0
 80114dc:	da06      	bge.n	80114ec <OsCmdAscendingInsert+0x88>
                LOS_ListTailInsert(&cmdItem->list, &cmd->list);
 80114de:	68bb      	ldr	r3, [r7, #8]
 80114e0:	687a      	ldr	r2, [r7, #4]
 80114e2:	4611      	mov	r1, r2
 80114e4:	4618      	mov	r0, r3
 80114e6:	f7ff fd8e 	bl	8011006 <LOS_ListTailInsert>
                return;
 80114ea:	e026      	b.n	801153a <OsCmdAscendingInsert+0xd6>
            }
            cmdItem = cmdNext;
 80114ec:	68fb      	ldr	r3, [r7, #12]
 80114ee:	60bb      	str	r3, [r7, #8]
 80114f0:	e017      	b.n	8011522 <OsCmdAscendingInsert+0xbe>
        } else {
            if (strncmp(cmd->cmd->cmdKey, cmdItem->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) > 0) {
 80114f2:	687b      	ldr	r3, [r7, #4]
 80114f4:	689b      	ldr	r3, [r3, #8]
 80114f6:	685c      	ldr	r4, [r3, #4]
 80114f8:	68bb      	ldr	r3, [r7, #8]
 80114fa:	689b      	ldr	r3, [r3, #8]
 80114fc:	685d      	ldr	r5, [r3, #4]
 80114fe:	687b      	ldr	r3, [r7, #4]
 8011500:	689b      	ldr	r3, [r3, #8]
 8011502:	685b      	ldr	r3, [r3, #4]
 8011504:	4618      	mov	r0, r3
 8011506:	f7fd fac0 	bl	800ea8a <strlen>
 801150a:	4603      	mov	r3, r0
 801150c:	461a      	mov	r2, r3
 801150e:	4629      	mov	r1, r5
 8011510:	4620      	mov	r0, r4
 8011512:	f007 ff89 	bl	8019428 <strncmp>
 8011516:	4603      	mov	r3, r0
 8011518:	2b00      	cmp	r3, #0
 801151a:	dd07      	ble.n	801152c <OsCmdAscendingInsert+0xc8>
                cmdItem = cmdNext;
 801151c:	68fb      	ldr	r3, [r7, #12]
 801151e:	60bb      	str	r3, [r7, #8]
            }
            break;
 8011520:	e004      	b.n	801152c <OsCmdAscendingInsert+0xc8>
    for (cmdItem = LOS_DL_LIST_ENTRY((&g_cmdInfo.cmdList.list)->pstPrev, CmdItemNode, list);
 8011522:	68bb      	ldr	r3, [r7, #8]
 8011524:	4a06      	ldr	r2, [pc, #24]	; (8011540 <OsCmdAscendingInsert+0xdc>)
 8011526:	4293      	cmp	r3, r2
 8011528:	d1a8      	bne.n	801147c <OsCmdAscendingInsert+0x18>
 801152a:	e000      	b.n	801152e <OsCmdAscendingInsert+0xca>
            break;
 801152c:	bf00      	nop
        }
    }

    LOS_ListTailInsert(&cmdItem->list, &cmd->list);
 801152e:	68bb      	ldr	r3, [r7, #8]
 8011530:	687a      	ldr	r2, [r7, #4]
 8011532:	4611      	mov	r1, r2
 8011534:	4618      	mov	r0, r3
 8011536:	f7ff fd66 	bl	8011006 <LOS_ListTailInsert>
}
 801153a:	3710      	adds	r7, #16
 801153c:	46bd      	mov	sp, r7
 801153e:	bdb0      	pop	{r4, r5, r7, pc}
 8011540:	2000329c 	.word	0x2000329c

08011544 <OsShellKeyInit>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellKeyInit(ShellCB *shellCB)
{
 8011544:	b580      	push	{r7, lr}
 8011546:	b084      	sub	sp, #16
 8011548:	af00      	add	r7, sp, #0
 801154a:	6078      	str	r0, [r7, #4]
    CmdKeyLink *cmdKeyLink = NULL;
 801154c:	2300      	movs	r3, #0
 801154e:	60bb      	str	r3, [r7, #8]
    CmdKeyLink *cmdHistoryLink = NULL;
 8011550:	2300      	movs	r3, #0
 8011552:	60fb      	str	r3, [r7, #12]

    cmdKeyLink = (CmdKeyLink *)LOS_MemAlloc(m_aucSysMem0, sizeof(CmdKeyLink));
 8011554:	4b24      	ldr	r3, [pc, #144]	; (80115e8 <OsShellKeyInit+0xa4>)
 8011556:	681b      	ldr	r3, [r3, #0]
 8011558:	210c      	movs	r1, #12
 801155a:	4618      	mov	r0, r3
 801155c:	f7f7 fa24 	bl	80089a8 <LOS_MemAlloc>
 8011560:	60b8      	str	r0, [r7, #8]
    if (cmdKeyLink == NULL) {
 8011562:	68bb      	ldr	r3, [r7, #8]
 8011564:	2b00      	cmp	r3, #0
 8011566:	d108      	bne.n	801157a <OsShellKeyInit+0x36>
        PRINT_ERR("Shell CmdKeyLink memory alloc error!\n");
 8011568:	4820      	ldr	r0, [pc, #128]	; (80115ec <OsShellKeyInit+0xa8>)
 801156a:	f7f3 f8af 	bl	80046cc <dprintf>
 801156e:	4820      	ldr	r0, [pc, #128]	; (80115f0 <OsShellKeyInit+0xac>)
 8011570:	f7f3 f8ac 	bl	80046cc <dprintf>
        return OS_ERROR;
 8011574:	f04f 33ff 	mov.w	r3, #4294967295
 8011578:	e032      	b.n	80115e0 <OsShellKeyInit+0x9c>
    }
    cmdHistoryLink = (CmdKeyLink *)LOS_MemAlloc(m_aucSysMem0, sizeof(CmdKeyLink));
 801157a:	4b1b      	ldr	r3, [pc, #108]	; (80115e8 <OsShellKeyInit+0xa4>)
 801157c:	681b      	ldr	r3, [r3, #0]
 801157e:	210c      	movs	r1, #12
 8011580:	4618      	mov	r0, r3
 8011582:	f7f7 fa11 	bl	80089a8 <LOS_MemAlloc>
 8011586:	60f8      	str	r0, [r7, #12]
    if (cmdHistoryLink == NULL) {
 8011588:	68fb      	ldr	r3, [r7, #12]
 801158a:	2b00      	cmp	r3, #0
 801158c:	d10e      	bne.n	80115ac <OsShellKeyInit+0x68>
        (VOID)LOS_MemFree(m_aucSysMem0, cmdKeyLink);
 801158e:	4b16      	ldr	r3, [pc, #88]	; (80115e8 <OsShellKeyInit+0xa4>)
 8011590:	681b      	ldr	r3, [r3, #0]
 8011592:	68b9      	ldr	r1, [r7, #8]
 8011594:	4618      	mov	r0, r3
 8011596:	f7f7 fabf 	bl	8008b18 <LOS_MemFree>
        PRINT_ERR("Shell CmdHistoryLink memory alloc error!\n");
 801159a:	4814      	ldr	r0, [pc, #80]	; (80115ec <OsShellKeyInit+0xa8>)
 801159c:	f7f3 f896 	bl	80046cc <dprintf>
 80115a0:	4814      	ldr	r0, [pc, #80]	; (80115f4 <OsShellKeyInit+0xb0>)
 80115a2:	f7f3 f893 	bl	80046cc <dprintf>
        return OS_ERROR;
 80115a6:	f04f 33ff 	mov.w	r3, #4294967295
 80115aa:	e019      	b.n	80115e0 <OsShellKeyInit+0x9c>
    }

    cmdKeyLink->count = 0;
 80115ac:	68bb      	ldr	r3, [r7, #8]
 80115ae:	2200      	movs	r2, #0
 80115b0:	601a      	str	r2, [r3, #0]
    LOS_ListInit(&cmdKeyLink->list);
 80115b2:	68bb      	ldr	r3, [r7, #8]
 80115b4:	3304      	adds	r3, #4
 80115b6:	4618      	mov	r0, r3
 80115b8:	f7ff fcfc 	bl	8010fb4 <LOS_ListInit>
    shellCB->cmdKeyLink = (VOID *)cmdKeyLink;
 80115bc:	687b      	ldr	r3, [r7, #4]
 80115be:	68ba      	ldr	r2, [r7, #8]
 80115c0:	60da      	str	r2, [r3, #12]

    cmdHistoryLink->count = 0;
 80115c2:	68fb      	ldr	r3, [r7, #12]
 80115c4:	2200      	movs	r2, #0
 80115c6:	601a      	str	r2, [r3, #0]
    LOS_ListInit(&cmdHistoryLink->list);
 80115c8:	68fb      	ldr	r3, [r7, #12]
 80115ca:	3304      	adds	r3, #4
 80115cc:	4618      	mov	r0, r3
 80115ce:	f7ff fcf1 	bl	8010fb4 <LOS_ListInit>
    shellCB->cmdHistoryKeyLink = (VOID *)cmdHistoryLink;
 80115d2:	687b      	ldr	r3, [r7, #4]
 80115d4:	68fa      	ldr	r2, [r7, #12]
 80115d6:	611a      	str	r2, [r3, #16]
    shellCB->cmdMaskKeyLink = (VOID *)cmdHistoryLink;
 80115d8:	687b      	ldr	r3, [r7, #4]
 80115da:	68fa      	ldr	r2, [r7, #12]
 80115dc:	615a      	str	r2, [r3, #20]
    return LOS_OK;
 80115de:	2300      	movs	r3, #0
}
 80115e0:	4618      	mov	r0, r3
 80115e2:	3710      	adds	r7, #16
 80115e4:	46bd      	mov	sp, r7
 80115e6:	bd80      	pop	{r7, pc}
 80115e8:	200021b4 	.word	0x200021b4
 80115ec:	080219e4 	.word	0x080219e4
 80115f0:	08021a10 	.word	0x08021a10
 80115f4:	08021a38 	.word	0x08021a38

080115f8 <OsShellKeyLinkDeInit>:

LITE_OS_SEC_TEXT_MINOR VOID OsShellKeyLinkDeInit(CmdKeyLink *cmdKeyLink)
{
 80115f8:	b580      	push	{r7, lr}
 80115fa:	b084      	sub	sp, #16
 80115fc:	af00      	add	r7, sp, #0
 80115fe:	6078      	str	r0, [r7, #4]
    CmdKeyLink *cmd = NULL;
 8011600:	2300      	movs	r3, #0
 8011602:	60fb      	str	r3, [r7, #12]

    while (!LOS_ListEmpty(&cmdKeyLink->list)) {
 8011604:	e00e      	b.n	8011624 <OsShellKeyLinkDeInit+0x2c>
        cmd = LOS_DL_LIST_ENTRY(cmdKeyLink->list.pstNext, CmdKeyLink, list);
 8011606:	687b      	ldr	r3, [r7, #4]
 8011608:	689b      	ldr	r3, [r3, #8]
 801160a:	3b04      	subs	r3, #4
 801160c:	60fb      	str	r3, [r7, #12]
        LOS_ListDelete(&cmd->list);
 801160e:	68fb      	ldr	r3, [r7, #12]
 8011610:	3304      	adds	r3, #4
 8011612:	4618      	mov	r0, r3
 8011614:	f7ff fd06 	bl	8011024 <LOS_ListDelete>
        (VOID)LOS_MemFree(m_aucSysMem0, cmd);
 8011618:	4b0d      	ldr	r3, [pc, #52]	; (8011650 <OsShellKeyLinkDeInit+0x58>)
 801161a:	681b      	ldr	r3, [r3, #0]
 801161c:	68f9      	ldr	r1, [r7, #12]
 801161e:	4618      	mov	r0, r3
 8011620:	f7f7 fa7a 	bl	8008b18 <LOS_MemFree>
    while (!LOS_ListEmpty(&cmdKeyLink->list)) {
 8011624:	687b      	ldr	r3, [r7, #4]
 8011626:	3304      	adds	r3, #4
 8011628:	4618      	mov	r0, r3
 801162a:	f7ff fd15 	bl	8011058 <LOS_ListEmpty>
 801162e:	4603      	mov	r3, r0
 8011630:	2b00      	cmp	r3, #0
 8011632:	d0e8      	beq.n	8011606 <OsShellKeyLinkDeInit+0xe>
    }

    cmdKeyLink->count = 0;
 8011634:	687b      	ldr	r3, [r7, #4]
 8011636:	2200      	movs	r2, #0
 8011638:	601a      	str	r2, [r3, #0]
    (VOID)LOS_MemFree(m_aucSysMem0, cmdKeyLink);
 801163a:	4b05      	ldr	r3, [pc, #20]	; (8011650 <OsShellKeyLinkDeInit+0x58>)
 801163c:	681b      	ldr	r3, [r3, #0]
 801163e:	6879      	ldr	r1, [r7, #4]
 8011640:	4618      	mov	r0, r3
 8011642:	f7f7 fa69 	bl	8008b18 <LOS_MemFree>
}
 8011646:	bf00      	nop
 8011648:	3710      	adds	r7, #16
 801164a:	46bd      	mov	sp, r7
 801164c:	bd80      	pop	{r7, pc}
 801164e:	bf00      	nop
 8011650:	200021b4 	.word	0x200021b4

08011654 <OsShellKeyDeInit>:

LITE_OS_SEC_TEXT_MINOR VOID OsShellKeyDeInit(const ShellCB *shellCB)
{
 8011654:	b580      	push	{r7, lr}
 8011656:	b082      	sub	sp, #8
 8011658:	af00      	add	r7, sp, #0
 801165a:	6078      	str	r0, [r7, #4]
    OsShellKeyLinkDeInit(shellCB->cmdKeyLink);
 801165c:	687b      	ldr	r3, [r7, #4]
 801165e:	68db      	ldr	r3, [r3, #12]
 8011660:	4618      	mov	r0, r3
 8011662:	f7ff ffc9 	bl	80115f8 <OsShellKeyLinkDeInit>
    OsShellKeyLinkDeInit(shellCB->cmdHistoryKeyLink);
 8011666:	687b      	ldr	r3, [r7, #4]
 8011668:	691b      	ldr	r3, [r3, #16]
 801166a:	4618      	mov	r0, r3
 801166c:	f7ff ffc4 	bl	80115f8 <OsShellKeyLinkDeInit>
}
 8011670:	bf00      	nop
 8011672:	3708      	adds	r7, #8
 8011674:	46bd      	mov	sp, r7
 8011676:	bd80      	pop	{r7, pc}

08011678 <OsShellSysCmdRegister>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellSysCmdRegister(VOID)
{
 8011678:	b580      	push	{r7, lr}
 801167a:	b084      	sub	sp, #16
 801167c:	af00      	add	r7, sp, #0
    UINT32 i;
    UINT32 index = ((UINTPTR)(&g_shellcmdEnd) - (UINTPTR)(&g_shellcmd[0])) / sizeof(CmdItem);
 801167e:	4a24      	ldr	r2, [pc, #144]	; (8011710 <OsShellSysCmdRegister+0x98>)
 8011680:	4b24      	ldr	r3, [pc, #144]	; (8011714 <OsShellSysCmdRegister+0x9c>)
 8011682:	1ad3      	subs	r3, r2, r3
 8011684:	091b      	lsrs	r3, r3, #4
 8011686:	60bb      	str	r3, [r7, #8]
    CmdItemNode *cmdItem = NULL;
 8011688:	2300      	movs	r3, #0
 801168a:	60fb      	str	r3, [r7, #12]

    g_cmdItemGroup = (UINT8 *)LOS_MemAlloc(m_aucSysMem0, index * sizeof(CmdItemNode));
 801168c:	4b22      	ldr	r3, [pc, #136]	; (8011718 <OsShellSysCmdRegister+0xa0>)
 801168e:	6818      	ldr	r0, [r3, #0]
 8011690:	68ba      	ldr	r2, [r7, #8]
 8011692:	4613      	mov	r3, r2
 8011694:	005b      	lsls	r3, r3, #1
 8011696:	4413      	add	r3, r2
 8011698:	009b      	lsls	r3, r3, #2
 801169a:	4619      	mov	r1, r3
 801169c:	f7f7 f984 	bl	80089a8 <LOS_MemAlloc>
 80116a0:	4603      	mov	r3, r0
 80116a2:	4a1e      	ldr	r2, [pc, #120]	; (801171c <OsShellSysCmdRegister+0xa4>)
 80116a4:	6013      	str	r3, [r2, #0]
    if (g_cmdItemGroup == NULL) {
 80116a6:	4b1d      	ldr	r3, [pc, #116]	; (801171c <OsShellSysCmdRegister+0xa4>)
 80116a8:	681b      	ldr	r3, [r3, #0]
 80116aa:	2b00      	cmp	r3, #0
 80116ac:	d109      	bne.n	80116c2 <OsShellSysCmdRegister+0x4a>
        PRINT_ERR("[%s]System memory allocation failure!\n", __FUNCTION__);
 80116ae:	481c      	ldr	r0, [pc, #112]	; (8011720 <OsShellSysCmdRegister+0xa8>)
 80116b0:	f7f3 f80c 	bl	80046cc <dprintf>
 80116b4:	491b      	ldr	r1, [pc, #108]	; (8011724 <OsShellSysCmdRegister+0xac>)
 80116b6:	481c      	ldr	r0, [pc, #112]	; (8011728 <OsShellSysCmdRegister+0xb0>)
 80116b8:	f7f3 f808 	bl	80046cc <dprintf>
        return (UINT32)OS_ERROR;
 80116bc:	f04f 33ff 	mov.w	r3, #4294967295
 80116c0:	e022      	b.n	8011708 <OsShellSysCmdRegister+0x90>
    }

    for (i = 0; i < index; ++i) {
 80116c2:	2300      	movs	r3, #0
 80116c4:	607b      	str	r3, [r7, #4]
 80116c6:	e014      	b.n	80116f2 <OsShellSysCmdRegister+0x7a>
        cmdItem = (CmdItemNode *)(g_cmdItemGroup + i * sizeof(CmdItemNode));
 80116c8:	4b14      	ldr	r3, [pc, #80]	; (801171c <OsShellSysCmdRegister+0xa4>)
 80116ca:	6819      	ldr	r1, [r3, #0]
 80116cc:	687a      	ldr	r2, [r7, #4]
 80116ce:	4613      	mov	r3, r2
 80116d0:	005b      	lsls	r3, r3, #1
 80116d2:	4413      	add	r3, r2
 80116d4:	009b      	lsls	r3, r3, #2
 80116d6:	440b      	add	r3, r1
 80116d8:	60fb      	str	r3, [r7, #12]
        cmdItem->cmd = &g_shellcmd[i];
 80116da:	687b      	ldr	r3, [r7, #4]
 80116dc:	011b      	lsls	r3, r3, #4
 80116de:	4a0d      	ldr	r2, [pc, #52]	; (8011714 <OsShellSysCmdRegister+0x9c>)
 80116e0:	441a      	add	r2, r3
 80116e2:	68fb      	ldr	r3, [r7, #12]
 80116e4:	609a      	str	r2, [r3, #8]
        OsCmdAscendingInsert(cmdItem);
 80116e6:	68f8      	ldr	r0, [r7, #12]
 80116e8:	f7ff febc 	bl	8011464 <OsCmdAscendingInsert>
    for (i = 0; i < index; ++i) {
 80116ec:	687b      	ldr	r3, [r7, #4]
 80116ee:	3301      	adds	r3, #1
 80116f0:	607b      	str	r3, [r7, #4]
 80116f2:	687a      	ldr	r2, [r7, #4]
 80116f4:	68bb      	ldr	r3, [r7, #8]
 80116f6:	429a      	cmp	r2, r3
 80116f8:	d3e6      	bcc.n	80116c8 <OsShellSysCmdRegister+0x50>
    }
    g_cmdInfo.listNum += index;
 80116fa:	4b0c      	ldr	r3, [pc, #48]	; (801172c <OsShellSysCmdRegister+0xb4>)
 80116fc:	68da      	ldr	r2, [r3, #12]
 80116fe:	68bb      	ldr	r3, [r7, #8]
 8011700:	4413      	add	r3, r2
 8011702:	4a0a      	ldr	r2, [pc, #40]	; (801172c <OsShellSysCmdRegister+0xb4>)
 8011704:	60d3      	str	r3, [r2, #12]
    return LOS_OK;
 8011706:	2300      	movs	r3, #0
}
 8011708:	4618      	mov	r0, r3
 801170a:	3710      	adds	r7, #16
 801170c:	46bd      	mov	sp, r7
 801170e:	bd80      	pop	{r7, pc}
 8011710:	20000724 	.word	0x20000724
 8011714:	200005d4 	.word	0x200005d4
 8011718:	200021b4 	.word	0x200021b4
 801171c:	200032b8 	.word	0x200032b8
 8011720:	080219e4 	.word	0x080219e4
 8011724:	08023550 	.word	0x08023550
 8011728:	08021a64 	.word	0x08021a64
 801172c:	2000329c 	.word	0x2000329c

08011730 <OsShellSysCmdUnregister>:

LITE_OS_SEC_TEXT_MINOR VOID OsShellSysCmdUnregister(VOID)
{
 8011730:	b580      	push	{r7, lr}
 8011732:	b082      	sub	sp, #8
 8011734:	af00      	add	r7, sp, #0
    CmdItemNode *cmdItem = NULL;
 8011736:	2300      	movs	r3, #0
 8011738:	607b      	str	r3, [r7, #4]
    while (!LOS_ListEmpty(&(g_cmdInfo.cmdList.list))) {
 801173a:	e006      	b.n	801174a <OsShellSysCmdUnregister+0x1a>
        cmdItem = LOS_DL_LIST_ENTRY(g_cmdInfo.cmdList.list.pstNext, CmdItemNode, list);
 801173c:	4b0c      	ldr	r3, [pc, #48]	; (8011770 <OsShellSysCmdUnregister+0x40>)
 801173e:	685b      	ldr	r3, [r3, #4]
 8011740:	607b      	str	r3, [r7, #4]
        LOS_ListDelete(&cmdItem->list);
 8011742:	687b      	ldr	r3, [r7, #4]
 8011744:	4618      	mov	r0, r3
 8011746:	f7ff fc6d 	bl	8011024 <LOS_ListDelete>
    while (!LOS_ListEmpty(&(g_cmdInfo.cmdList.list))) {
 801174a:	4809      	ldr	r0, [pc, #36]	; (8011770 <OsShellSysCmdUnregister+0x40>)
 801174c:	f7ff fc84 	bl	8011058 <LOS_ListEmpty>
 8011750:	4603      	mov	r3, r0
 8011752:	2b00      	cmp	r3, #0
 8011754:	d0f2      	beq.n	801173c <OsShellSysCmdUnregister+0xc>
    }
    (VOID)LOS_MemFree(m_aucSysMem0, g_cmdItemGroup);
 8011756:	4b07      	ldr	r3, [pc, #28]	; (8011774 <OsShellSysCmdUnregister+0x44>)
 8011758:	681b      	ldr	r3, [r3, #0]
 801175a:	4a07      	ldr	r2, [pc, #28]	; (8011778 <OsShellSysCmdUnregister+0x48>)
 801175c:	6812      	ldr	r2, [r2, #0]
 801175e:	4611      	mov	r1, r2
 8011760:	4618      	mov	r0, r3
 8011762:	f7f7 f9d9 	bl	8008b18 <LOS_MemFree>
}
 8011766:	bf00      	nop
 8011768:	3708      	adds	r7, #8
 801176a:	46bd      	mov	sp, r7
 801176c:	bd80      	pop	{r7, pc}
 801176e:	bf00      	nop
 8011770:	2000329c 	.word	0x2000329c
 8011774:	200021b4 	.word	0x200021b4
 8011778:	200032b8 	.word	0x200032b8

0801177c <OsShellCmdPush>:

LITE_OS_SEC_TEXT_MINOR VOID OsShellCmdPush(const CHAR *string, CmdKeyLink *cmdKeyLink)
{
 801177c:	b580      	push	{r7, lr}
 801177e:	b084      	sub	sp, #16
 8011780:	af00      	add	r7, sp, #0
 8011782:	6078      	str	r0, [r7, #4]
 8011784:	6039      	str	r1, [r7, #0]
    CmdKeyLink *cmdNewNode = NULL;
 8011786:	2300      	movs	r3, #0
 8011788:	60bb      	str	r3, [r7, #8]
    UINT32 len;

    if ((string == NULL) || (strlen(string) == 0)) {
 801178a:	687b      	ldr	r3, [r7, #4]
 801178c:	2b00      	cmp	r3, #0
 801178e:	d03a      	beq.n	8011806 <OsShellCmdPush+0x8a>
 8011790:	6878      	ldr	r0, [r7, #4]
 8011792:	f7fd f97a 	bl	800ea8a <strlen>
 8011796:	4603      	mov	r3, r0
 8011798:	2b00      	cmp	r3, #0
 801179a:	d034      	beq.n	8011806 <OsShellCmdPush+0x8a>
        return;
    }

    len = strlen(string);
 801179c:	6878      	ldr	r0, [r7, #4]
 801179e:	f7fd f974 	bl	800ea8a <strlen>
 80117a2:	60f8      	str	r0, [r7, #12]
    cmdNewNode = (CmdKeyLink *)LOS_MemAlloc(m_aucSysMem0, sizeof(CmdKeyLink) + len + 1);
 80117a4:	4b1b      	ldr	r3, [pc, #108]	; (8011814 <OsShellCmdPush+0x98>)
 80117a6:	681a      	ldr	r2, [r3, #0]
 80117a8:	68fb      	ldr	r3, [r7, #12]
 80117aa:	330d      	adds	r3, #13
 80117ac:	4619      	mov	r1, r3
 80117ae:	4610      	mov	r0, r2
 80117b0:	f7f7 f8fa 	bl	80089a8 <LOS_MemAlloc>
 80117b4:	60b8      	str	r0, [r7, #8]
    if (cmdNewNode == NULL) {
 80117b6:	68bb      	ldr	r3, [r7, #8]
 80117b8:	2b00      	cmp	r3, #0
 80117ba:	d026      	beq.n	801180a <OsShellCmdPush+0x8e>
        return;
    }

    (VOID)memset_s(cmdNewNode, sizeof(CmdKeyLink) + len + 1, 0, sizeof(CmdKeyLink) + len + 1);
 80117bc:	68fb      	ldr	r3, [r7, #12]
 80117be:	f103 010d 	add.w	r1, r3, #13
 80117c2:	68fb      	ldr	r3, [r7, #12]
 80117c4:	330d      	adds	r3, #13
 80117c6:	2200      	movs	r2, #0
 80117c8:	68b8      	ldr	r0, [r7, #8]
 80117ca:	f004 fc5f 	bl	801608c <memset_s>
    if (strncpy_s(cmdNewNode->cmdString, len + 1, string, len) != EOK) {
 80117ce:	68bb      	ldr	r3, [r7, #8]
 80117d0:	f103 000c 	add.w	r0, r3, #12
 80117d4:	68fb      	ldr	r3, [r7, #12]
 80117d6:	1c59      	adds	r1, r3, #1
 80117d8:	68fb      	ldr	r3, [r7, #12]
 80117da:	687a      	ldr	r2, [r7, #4]
 80117dc:	f004 fd44 	bl	8016268 <strncpy_s>
 80117e0:	4603      	mov	r3, r0
 80117e2:	2b00      	cmp	r3, #0
 80117e4:	d006      	beq.n	80117f4 <OsShellCmdPush+0x78>
        (VOID)LOS_MemFree(m_aucSysMem0, cmdNewNode);
 80117e6:	4b0b      	ldr	r3, [pc, #44]	; (8011814 <OsShellCmdPush+0x98>)
 80117e8:	681b      	ldr	r3, [r3, #0]
 80117ea:	68b9      	ldr	r1, [r7, #8]
 80117ec:	4618      	mov	r0, r3
 80117ee:	f7f7 f993 	bl	8008b18 <LOS_MemFree>
        return;
 80117f2:	e00b      	b.n	801180c <OsShellCmdPush+0x90>
    }

    LOS_ListTailInsert(&cmdKeyLink->list, &cmdNewNode->list);
 80117f4:	683b      	ldr	r3, [r7, #0]
 80117f6:	1d1a      	adds	r2, r3, #4
 80117f8:	68bb      	ldr	r3, [r7, #8]
 80117fa:	3304      	adds	r3, #4
 80117fc:	4619      	mov	r1, r3
 80117fe:	4610      	mov	r0, r2
 8011800:	f7ff fc01 	bl	8011006 <LOS_ListTailInsert>

    return;
 8011804:	e002      	b.n	801180c <OsShellCmdPush+0x90>
        return;
 8011806:	bf00      	nop
 8011808:	e000      	b.n	801180c <OsShellCmdPush+0x90>
        return;
 801180a:	bf00      	nop
}
 801180c:	3710      	adds	r7, #16
 801180e:	46bd      	mov	sp, r7
 8011810:	bd80      	pop	{r7, pc}
 8011812:	bf00      	nop
 8011814:	200021b4 	.word	0x200021b4

08011818 <OsShellHistoryShow>:

LITE_OS_SEC_TEXT_MINOR VOID OsShellHistoryShow(UINT32 value, ShellCB *shellCB)
{
 8011818:	b580      	push	{r7, lr}
 801181a:	b088      	sub	sp, #32
 801181c:	af00      	add	r7, sp, #0
 801181e:	6078      	str	r0, [r7, #4]
 8011820:	6039      	str	r1, [r7, #0]
    CmdKeyLink *cmd = NULL;
 8011822:	2300      	movs	r3, #0
 8011824:	60fb      	str	r3, [r7, #12]
    CmdKeyLink *cmdNode = shellCB->cmdHistoryKeyLink;
 8011826:	683b      	ldr	r3, [r7, #0]
 8011828:	691b      	ldr	r3, [r3, #16]
 801182a:	613b      	str	r3, [r7, #16]
    CmdKeyLink *cmdMask = shellCB->cmdMaskKeyLink;
 801182c:	683b      	ldr	r3, [r7, #0]
 801182e:	695b      	ldr	r3, [r3, #20]
 8011830:	60bb      	str	r3, [r7, #8]
    errno_t ret;

    HISTORY_LOCK(shellCB);
 8011832:	683b      	ldr	r3, [r7, #0]
 8011834:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011836:	f04f 31ff 	mov.w	r1, #4294967295
 801183a:	4618      	mov	r0, r3
 801183c:	f7f9 fb40 	bl	800aec0 <LOS_MuxPend>
 8011840:	6178      	str	r0, [r7, #20]
 8011842:	697b      	ldr	r3, [r7, #20]
 8011844:	2b00      	cmp	r3, #0
 8011846:	d009      	beq.n	801185c <OsShellHistoryShow+0x44>
 8011848:	4843      	ldr	r0, [pc, #268]	; (8011958 <OsShellHistoryShow+0x140>)
 801184a:	f7f2 ff3f 	bl	80046cc <dprintf>
 801184e:	697b      	ldr	r3, [r7, #20]
 8011850:	f240 22c6 	movw	r2, #710	; 0x2c6
 8011854:	4941      	ldr	r1, [pc, #260]	; (801195c <OsShellHistoryShow+0x144>)
 8011856:	4842      	ldr	r0, [pc, #264]	; (8011960 <OsShellHistoryShow+0x148>)
 8011858:	f7f2 ff38 	bl	80046cc <dprintf>
    if (value == CMD_KEY_DOWN) {
 801185c:	687b      	ldr	r3, [r7, #4]
 801185e:	2b01      	cmp	r3, #1
 8011860:	d10e      	bne.n	8011880 <OsShellHistoryShow+0x68>
        if (cmdMask == cmdNode) {
 8011862:	68ba      	ldr	r2, [r7, #8]
 8011864:	693b      	ldr	r3, [r7, #16]
 8011866:	429a      	cmp	r2, r3
 8011868:	d058      	beq.n	801191c <OsShellHistoryShow+0x104>
            goto END;
        }

        cmd = LOS_DL_LIST_ENTRY(cmdMask->list.pstNext, CmdKeyLink, list);
 801186a:	68bb      	ldr	r3, [r7, #8]
 801186c:	689b      	ldr	r3, [r3, #8]
 801186e:	3b04      	subs	r3, #4
 8011870:	60fb      	str	r3, [r7, #12]
        if (cmd != cmdNode) {
 8011872:	68fa      	ldr	r2, [r7, #12]
 8011874:	693b      	ldr	r3, [r7, #16]
 8011876:	429a      	cmp	r2, r3
 8011878:	d052      	beq.n	8011920 <OsShellHistoryShow+0x108>
            cmdMask = cmd;
 801187a:	68fb      	ldr	r3, [r7, #12]
 801187c:	60bb      	str	r3, [r7, #8]
 801187e:	e010      	b.n	80118a2 <OsShellHistoryShow+0x8a>
        } else {
            goto END;
        }
    } else if (value == CMD_KEY_UP) {
 8011880:	687b      	ldr	r3, [r7, #4]
 8011882:	2b00      	cmp	r3, #0
 8011884:	d10d      	bne.n	80118a2 <OsShellHistoryShow+0x8a>
        cmd = LOS_DL_LIST_ENTRY(cmdMask->list.pstPrev, CmdKeyLink, list);
 8011886:	68bb      	ldr	r3, [r7, #8]
 8011888:	685b      	ldr	r3, [r3, #4]
 801188a:	3b04      	subs	r3, #4
 801188c:	60fb      	str	r3, [r7, #12]
        if (cmd != cmdNode) {
 801188e:	68fa      	ldr	r2, [r7, #12]
 8011890:	693b      	ldr	r3, [r7, #16]
 8011892:	429a      	cmp	r2, r3
 8011894:	d046      	beq.n	8011924 <OsShellHistoryShow+0x10c>
            cmdMask = cmd;
 8011896:	68fb      	ldr	r3, [r7, #12]
 8011898:	60bb      	str	r3, [r7, #8]
        } else {
            goto END;
        }
    }

    while (shellCB->shellBufOffset--) {
 801189a:	e002      	b.n	80118a2 <OsShellHistoryShow+0x8a>
        PRINTK("\b \b");
 801189c:	4831      	ldr	r0, [pc, #196]	; (8011964 <OsShellHistoryShow+0x14c>)
 801189e:	f7f2 ff15 	bl	80046cc <dprintf>
    while (shellCB->shellBufOffset--) {
 80118a2:	683b      	ldr	r3, [r7, #0]
 80118a4:	699b      	ldr	r3, [r3, #24]
 80118a6:	1e59      	subs	r1, r3, #1
 80118a8:	683a      	ldr	r2, [r7, #0]
 80118aa:	6191      	str	r1, [r2, #24]
 80118ac:	2b00      	cmp	r3, #0
 80118ae:	d1f5      	bne.n	801189c <OsShellHistoryShow+0x84>
    }
    PRINTK("%s", cmdMask->cmdString);
 80118b0:	68bb      	ldr	r3, [r7, #8]
 80118b2:	330c      	adds	r3, #12
 80118b4:	4619      	mov	r1, r3
 80118b6:	482c      	ldr	r0, [pc, #176]	; (8011968 <OsShellHistoryShow+0x150>)
 80118b8:	f7f2 ff08 	bl	80046cc <dprintf>
    shellCB->shellBufOffset = strlen(cmdMask->cmdString);
 80118bc:	68bb      	ldr	r3, [r7, #8]
 80118be:	330c      	adds	r3, #12
 80118c0:	4618      	mov	r0, r3
 80118c2:	f7fd f8e2 	bl	800ea8a <strlen>
 80118c6:	4602      	mov	r2, r0
 80118c8:	683b      	ldr	r3, [r7, #0]
 80118ca:	619a      	str	r2, [r3, #24]
    (VOID)memset_s(shellCB->shellBuf, SHOW_MAX_LEN, 0, SHOW_MAX_LEN);
 80118cc:	683b      	ldr	r3, [r7, #0]
 80118ce:	f103 0034 	add.w	r0, r3, #52	; 0x34
 80118d2:	f44f 7388 	mov.w	r3, #272	; 0x110
 80118d6:	2200      	movs	r2, #0
 80118d8:	f44f 7188 	mov.w	r1, #272	; 0x110
 80118dc:	f004 fbd6 	bl	801608c <memset_s>
    ret = memcpy_s(shellCB->shellBuf, SHOW_MAX_LEN, cmdMask->cmdString, shellCB->shellBufOffset);
 80118e0:	683b      	ldr	r3, [r7, #0]
 80118e2:	f103 0034 	add.w	r0, r3, #52	; 0x34
 80118e6:	68bb      	ldr	r3, [r7, #8]
 80118e8:	f103 020c 	add.w	r2, r3, #12
 80118ec:	683b      	ldr	r3, [r7, #0]
 80118ee:	699b      	ldr	r3, [r3, #24]
 80118f0:	f44f 7188 	mov.w	r1, #272	; 0x110
 80118f4:	f004 fe52 	bl	801659c <memcpy_s>
 80118f8:	61b8      	str	r0, [r7, #24]
    if (ret != EOK) {
 80118fa:	69bb      	ldr	r3, [r7, #24]
 80118fc:	2b00      	cmp	r3, #0
 80118fe:	d009      	beq.n	8011914 <OsShellHistoryShow+0xfc>
        PRINT_ERR("%s, %d memcpy failed!\n", __FUNCTION__, __LINE__);
 8011900:	4815      	ldr	r0, [pc, #84]	; (8011958 <OsShellHistoryShow+0x140>)
 8011902:	f7f2 fee3 	bl	80046cc <dprintf>
 8011906:	f240 22e3 	movw	r2, #739	; 0x2e3
 801190a:	4914      	ldr	r1, [pc, #80]	; (801195c <OsShellHistoryShow+0x144>)
 801190c:	4817      	ldr	r0, [pc, #92]	; (801196c <OsShellHistoryShow+0x154>)
 801190e:	f7f2 fedd 	bl	80046cc <dprintf>
        goto END;
 8011912:	e008      	b.n	8011926 <OsShellHistoryShow+0x10e>
    }
    shellCB->cmdMaskKeyLink = (VOID *)cmdMask;
 8011914:	683b      	ldr	r3, [r7, #0]
 8011916:	68ba      	ldr	r2, [r7, #8]
 8011918:	615a      	str	r2, [r3, #20]
 801191a:	e004      	b.n	8011926 <OsShellHistoryShow+0x10e>
            goto END;
 801191c:	bf00      	nop
 801191e:	e002      	b.n	8011926 <OsShellHistoryShow+0x10e>
            goto END;
 8011920:	bf00      	nop
 8011922:	e000      	b.n	8011926 <OsShellHistoryShow+0x10e>
            goto END;
 8011924:	bf00      	nop

END:
    HISTORY_UNLOCK(shellCB);
 8011926:	683b      	ldr	r3, [r7, #0]
 8011928:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801192a:	4618      	mov	r0, r3
 801192c:	f7f9 fc48 	bl	800b1c0 <LOS_MuxPost>
 8011930:	61f8      	str	r0, [r7, #28]
 8011932:	69fb      	ldr	r3, [r7, #28]
 8011934:	2b00      	cmp	r3, #0
 8011936:	d00a      	beq.n	801194e <OsShellHistoryShow+0x136>
 8011938:	4807      	ldr	r0, [pc, #28]	; (8011958 <OsShellHistoryShow+0x140>)
 801193a:	f7f2 fec7 	bl	80046cc <dprintf>
 801193e:	69fb      	ldr	r3, [r7, #28]
 8011940:	f240 22e9 	movw	r2, #745	; 0x2e9
 8011944:	4905      	ldr	r1, [pc, #20]	; (801195c <OsShellHistoryShow+0x144>)
 8011946:	480a      	ldr	r0, [pc, #40]	; (8011970 <OsShellHistoryShow+0x158>)
 8011948:	f7f2 fec0 	bl	80046cc <dprintf>
    return;
 801194c:	bf00      	nop
 801194e:	bf00      	nop
}
 8011950:	3720      	adds	r7, #32
 8011952:	46bd      	mov	sp, r7
 8011954:	bd80      	pop	{r7, pc}
 8011956:	bf00      	nop
 8011958:	080219e4 	.word	0x080219e4
 801195c:	08023568 	.word	0x08023568
 8011960:	08021a8c 	.word	0x08021a8c
 8011964:	08021ab0 	.word	0x08021ab0
 8011968:	08021ab4 	.word	0x08021ab4
 801196c:	08021ab8 	.word	0x08021ab8
 8011970:	08021ad0 	.word	0x08021ad0

08011974 <OsCmdExec>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdExec(CmdParsed *cmdParsed, CHAR *cmdStr)
{
 8011974:	b590      	push	{r4, r7, lr}
 8011976:	b087      	sub	sp, #28
 8011978:	af00      	add	r7, sp, #0
 801197a:	6078      	str	r0, [r7, #4]
 801197c:	6039      	str	r1, [r7, #0]
    UINT32 ret;
    CmdCallBackFunc cmdHook = NULL;
 801197e:	2300      	movs	r3, #0
 8011980:	60fb      	str	r3, [r7, #12]
    CmdItemNode *curCmdItem = NULL;
 8011982:	2300      	movs	r3, #0
 8011984:	613b      	str	r3, [r7, #16]
    CHAR *cmdKey = NULL;
 8011986:	2300      	movs	r3, #0
 8011988:	617b      	str	r3, [r7, #20]

    if ((cmdStr == NULL) || (strlen(cmdStr) == 0)) {
 801198a:	683b      	ldr	r3, [r7, #0]
 801198c:	2b00      	cmp	r3, #0
 801198e:	d005      	beq.n	801199c <OsCmdExec+0x28>
 8011990:	6838      	ldr	r0, [r7, #0]
 8011992:	f7fd f87a 	bl	800ea8a <strlen>
 8011996:	4603      	mov	r3, r0
 8011998:	2b00      	cmp	r3, #0
 801199a:	d102      	bne.n	80119a2 <OsCmdExec+0x2e>
        return (UINT32)OS_ERROR;
 801199c:	f04f 33ff 	mov.w	r3, #4294967295
 80119a0:	e052      	b.n	8011a48 <OsCmdExec+0xd4>
    }

    ret = OsCmdParse(cmdStr, cmdParsed);
 80119a2:	6879      	ldr	r1, [r7, #4]
 80119a4:	6838      	ldr	r0, [r7, #0]
 80119a6:	f001 fd01 	bl	80133ac <OsCmdParse>
 80119aa:	60b8      	str	r0, [r7, #8]
    if (ret != LOS_OK) {
 80119ac:	68bb      	ldr	r3, [r7, #8]
 80119ae:	2b00      	cmp	r3, #0
 80119b0:	d001      	beq.n	80119b6 <OsCmdExec+0x42>
        return ret;
 80119b2:	68bb      	ldr	r3, [r7, #8]
 80119b4:	e048      	b.n	8011a48 <OsCmdExec+0xd4>
    }

    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &g_cmdInfo.cmdList.list, CmdItemNode, list) {
 80119b6:	4b26      	ldr	r3, [pc, #152]	; (8011a50 <OsCmdExec+0xdc>)
 80119b8:	685b      	ldr	r3, [r3, #4]
 80119ba:	613b      	str	r3, [r7, #16]
 80119bc:	e02d      	b.n	8011a1a <OsCmdExec+0xa6>
        cmdKey = curCmdItem->cmd->cmdKey;
 80119be:	693b      	ldr	r3, [r7, #16]
 80119c0:	689b      	ldr	r3, [r3, #8]
 80119c2:	685b      	ldr	r3, [r3, #4]
 80119c4:	617b      	str	r3, [r7, #20]
        if ((cmdParsed->cmdType == curCmdItem->cmd->cmdType) &&
 80119c6:	687b      	ldr	r3, [r7, #4]
 80119c8:	685a      	ldr	r2, [r3, #4]
 80119ca:	693b      	ldr	r3, [r7, #16]
 80119cc:	689b      	ldr	r3, [r3, #8]
 80119ce:	681b      	ldr	r3, [r3, #0]
 80119d0:	429a      	cmp	r2, r3
 80119d2:	d11f      	bne.n	8011a14 <OsCmdExec+0xa0>
            (strlen(cmdKey) == strlen(cmdParsed->cmdKeyword)) &&
 80119d4:	6978      	ldr	r0, [r7, #20]
 80119d6:	f7fd f858 	bl	800ea8a <strlen>
 80119da:	4604      	mov	r4, r0
 80119dc:	687b      	ldr	r3, [r7, #4]
 80119de:	3308      	adds	r3, #8
 80119e0:	4618      	mov	r0, r3
 80119e2:	f7fd f852 	bl	800ea8a <strlen>
 80119e6:	4603      	mov	r3, r0
        if ((cmdParsed->cmdType == curCmdItem->cmd->cmdType) &&
 80119e8:	429c      	cmp	r4, r3
 80119ea:	d113      	bne.n	8011a14 <OsCmdExec+0xa0>
            (strncmp(cmdKey, (CHAR *)(cmdParsed->cmdKeyword), strlen(cmdKey)) == 0)) {
 80119ec:	687b      	ldr	r3, [r7, #4]
 80119ee:	f103 0408 	add.w	r4, r3, #8
 80119f2:	6978      	ldr	r0, [r7, #20]
 80119f4:	f7fd f849 	bl	800ea8a <strlen>
 80119f8:	4603      	mov	r3, r0
 80119fa:	461a      	mov	r2, r3
 80119fc:	4621      	mov	r1, r4
 80119fe:	6978      	ldr	r0, [r7, #20]
 8011a00:	f007 fd12 	bl	8019428 <strncmp>
 8011a04:	4603      	mov	r3, r0
            (strlen(cmdKey) == strlen(cmdParsed->cmdKeyword)) &&
 8011a06:	2b00      	cmp	r3, #0
 8011a08:	d104      	bne.n	8011a14 <OsCmdExec+0xa0>
            cmdHook = curCmdItem->cmd->cmdHook;
 8011a0a:	693b      	ldr	r3, [r7, #16]
 8011a0c:	689b      	ldr	r3, [r3, #8]
 8011a0e:	68db      	ldr	r3, [r3, #12]
 8011a10:	60fb      	str	r3, [r7, #12]
            break;
 8011a12:	e006      	b.n	8011a22 <OsCmdExec+0xae>
    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &g_cmdInfo.cmdList.list, CmdItemNode, list) {
 8011a14:	693b      	ldr	r3, [r7, #16]
 8011a16:	685b      	ldr	r3, [r3, #4]
 8011a18:	613b      	str	r3, [r7, #16]
 8011a1a:	693b      	ldr	r3, [r7, #16]
 8011a1c:	4a0c      	ldr	r2, [pc, #48]	; (8011a50 <OsCmdExec+0xdc>)
 8011a1e:	4293      	cmp	r3, r2
 8011a20:	d1cd      	bne.n	80119be <OsCmdExec+0x4a>
        }
    }

    ret = OS_ERROR;
 8011a22:	f04f 33ff 	mov.w	r3, #4294967295
 8011a26:	60bb      	str	r3, [r7, #8]
    if (cmdHook != NULL) {
 8011a28:	68fb      	ldr	r3, [r7, #12]
 8011a2a:	2b00      	cmp	r3, #0
 8011a2c:	d008      	beq.n	8011a40 <OsCmdExec+0xcc>
        ret = (cmdHook)(cmdParsed->paramCnt, (const CHAR **)cmdParsed->paramArray);
 8011a2e:	687b      	ldr	r3, [r7, #4]
 8011a30:	681a      	ldr	r2, [r3, #0]
 8011a32:	687b      	ldr	r3, [r7, #4]
 8011a34:	f103 0118 	add.w	r1, r3, #24
 8011a38:	68fb      	ldr	r3, [r7, #12]
 8011a3a:	4610      	mov	r0, r2
 8011a3c:	4798      	blx	r3
 8011a3e:	60b8      	str	r0, [r7, #8]
    }
    OsFreeCmdPara(cmdParsed);
 8011a40:	6878      	ldr	r0, [r7, #4]
 8011a42:	f7ff fb25 	bl	8011090 <OsFreeCmdPara>

    return (UINT32)ret;
 8011a46:	68bb      	ldr	r3, [r7, #8]
}
 8011a48:	4618      	mov	r0, r3
 8011a4a:	371c      	adds	r7, #28
 8011a4c:	46bd      	mov	sp, r7
 8011a4e:	bd90      	pop	{r4, r7, pc}
 8011a50:	2000329c 	.word	0x2000329c

08011a54 <OsCmdInit>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdInit(VOID)
{
 8011a54:	b580      	push	{r7, lr}
 8011a56:	b082      	sub	sp, #8
 8011a58:	af00      	add	r7, sp, #0
    UINT32 ret;
    LOS_ListInit(&(g_cmdInfo.cmdList.list));
 8011a5a:	4811      	ldr	r0, [pc, #68]	; (8011aa0 <OsCmdInit+0x4c>)
 8011a5c:	f7ff faaa 	bl	8010fb4 <LOS_ListInit>
    g_cmdInfo.listNum = 0;
 8011a60:	4b0f      	ldr	r3, [pc, #60]	; (8011aa0 <OsCmdInit+0x4c>)
 8011a62:	2200      	movs	r2, #0
 8011a64:	60da      	str	r2, [r3, #12]
    g_cmdInfo.muxLock = 0;
 8011a66:	4b0e      	ldr	r3, [pc, #56]	; (8011aa0 <OsCmdInit+0x4c>)
 8011a68:	2200      	movs	r2, #0
 8011a6a:	615a      	str	r2, [r3, #20]
    g_cmdInfo.initMagicFlag = SHELL_INIT_MAGIC_FLAG;
 8011a6c:	4b0c      	ldr	r3, [pc, #48]	; (8011aa0 <OsCmdInit+0x4c>)
 8011a6e:	f04f 32ab 	mov.w	r2, #2880154539	; 0xabababab
 8011a72:	611a      	str	r2, [r3, #16]
    ret = LOS_MuxCreate(&g_cmdInfo.muxLock);
 8011a74:	480b      	ldr	r0, [pc, #44]	; (8011aa4 <OsCmdInit+0x50>)
 8011a76:	f7f8 ff79 	bl	800a96c <LOS_MuxCreate>
 8011a7a:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 8011a7c:	687b      	ldr	r3, [r7, #4]
 8011a7e:	2b00      	cmp	r3, #0
 8011a80:	d008      	beq.n	8011a94 <OsCmdInit+0x40>
        PRINT_ERR("Create mutex for shell cmd info failed\n");
 8011a82:	4809      	ldr	r0, [pc, #36]	; (8011aa8 <OsCmdInit+0x54>)
 8011a84:	f7f2 fe22 	bl	80046cc <dprintf>
 8011a88:	4808      	ldr	r0, [pc, #32]	; (8011aac <OsCmdInit+0x58>)
 8011a8a:	f7f2 fe1f 	bl	80046cc <dprintf>
        return OS_ERROR;
 8011a8e:	f04f 33ff 	mov.w	r3, #4294967295
 8011a92:	e000      	b.n	8011a96 <OsCmdInit+0x42>
    }
    return LOS_OK;
 8011a94:	2300      	movs	r3, #0
}
 8011a96:	4618      	mov	r0, r3
 8011a98:	3708      	adds	r7, #8
 8011a9a:	46bd      	mov	sp, r7
 8011a9c:	bd80      	pop	{r7, pc}
 8011a9e:	bf00      	nop
 8011aa0:	2000329c 	.word	0x2000329c
 8011aa4:	200032b0 	.word	0x200032b0
 8011aa8:	080219e4 	.word	0x080219e4
 8011aac:	08021af4 	.word	0x08021af4

08011ab0 <OsCmdDeInit>:

LITE_OS_SEC_TEXT_MINOR VOID OsCmdDeInit(VOID)
{
 8011ab0:	b580      	push	{r7, lr}
 8011ab2:	af00      	add	r7, sp, #0
    g_cmdInfo.initMagicFlag = 0;
 8011ab4:	4b04      	ldr	r3, [pc, #16]	; (8011ac8 <OsCmdDeInit+0x18>)
 8011ab6:	2200      	movs	r2, #0
 8011ab8:	611a      	str	r2, [r3, #16]
    (VOID)LOS_MuxDelete(g_cmdInfo.muxLock);
 8011aba:	4b03      	ldr	r3, [pc, #12]	; (8011ac8 <OsCmdDeInit+0x18>)
 8011abc:	695b      	ldr	r3, [r3, #20]
 8011abe:	4618      	mov	r0, r3
 8011ac0:	f7f8 ffee 	bl	800aaa0 <LOS_MuxDelete>
}
 8011ac4:	bf00      	nop
 8011ac6:	bd80      	pop	{r7, pc}
 8011ac8:	2000329c 	.word	0x2000329c

08011acc <OsCopyTm>:
    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
    {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

STATIC VOID OsCopyTm(struct tm *destTm, const struct tm *srcTm)
{
 8011acc:	b580      	push	{r7, lr}
 8011ace:	b082      	sub	sp, #8
 8011ad0:	af00      	add	r7, sp, #0
 8011ad2:	6078      	str	r0, [r7, #4]
 8011ad4:	6039      	str	r1, [r7, #0]
    if (srcTm == NULL) {
 8011ad6:	683b      	ldr	r3, [r7, #0]
 8011ad8:	2b00      	cmp	r3, #0
 8011ada:	d106      	bne.n	8011aea <OsCopyTm+0x1e>
        (VOID)memset_s(destTm, sizeof(struct tm), 0, sizeof(struct tm));
 8011adc:	232c      	movs	r3, #44	; 0x2c
 8011ade:	2200      	movs	r2, #0
 8011ae0:	212c      	movs	r1, #44	; 0x2c
 8011ae2:	6878      	ldr	r0, [r7, #4]
 8011ae4:	f004 fad2 	bl	801608c <memset_s>
        destTm->tm_yday = srcTm->tm_yday;
        destTm->tm_isdst = srcTm->tm_isdst;
        destTm->tm_gmtoff = srcTm->tm_gmtoff;
        destTm->tm_zone = srcTm->tm_zone;
    }
}
 8011ae8:	e02b      	b.n	8011b42 <OsCopyTm+0x76>
        destTm->tm_sec = srcTm->tm_sec;
 8011aea:	683b      	ldr	r3, [r7, #0]
 8011aec:	681a      	ldr	r2, [r3, #0]
 8011aee:	687b      	ldr	r3, [r7, #4]
 8011af0:	601a      	str	r2, [r3, #0]
        destTm->tm_min = srcTm->tm_min;
 8011af2:	683b      	ldr	r3, [r7, #0]
 8011af4:	685a      	ldr	r2, [r3, #4]
 8011af6:	687b      	ldr	r3, [r7, #4]
 8011af8:	605a      	str	r2, [r3, #4]
        destTm->tm_hour = srcTm->tm_hour;
 8011afa:	683b      	ldr	r3, [r7, #0]
 8011afc:	689a      	ldr	r2, [r3, #8]
 8011afe:	687b      	ldr	r3, [r7, #4]
 8011b00:	609a      	str	r2, [r3, #8]
        destTm->tm_mday = srcTm->tm_mday;
 8011b02:	683b      	ldr	r3, [r7, #0]
 8011b04:	68da      	ldr	r2, [r3, #12]
 8011b06:	687b      	ldr	r3, [r7, #4]
 8011b08:	60da      	str	r2, [r3, #12]
        destTm->tm_mon = srcTm->tm_mon;
 8011b0a:	683b      	ldr	r3, [r7, #0]
 8011b0c:	691a      	ldr	r2, [r3, #16]
 8011b0e:	687b      	ldr	r3, [r7, #4]
 8011b10:	611a      	str	r2, [r3, #16]
        destTm->tm_year = srcTm->tm_year;
 8011b12:	683b      	ldr	r3, [r7, #0]
 8011b14:	695a      	ldr	r2, [r3, #20]
 8011b16:	687b      	ldr	r3, [r7, #4]
 8011b18:	615a      	str	r2, [r3, #20]
        destTm->tm_wday = srcTm->tm_wday;
 8011b1a:	683b      	ldr	r3, [r7, #0]
 8011b1c:	699a      	ldr	r2, [r3, #24]
 8011b1e:	687b      	ldr	r3, [r7, #4]
 8011b20:	619a      	str	r2, [r3, #24]
        destTm->tm_yday = srcTm->tm_yday;
 8011b22:	683b      	ldr	r3, [r7, #0]
 8011b24:	69da      	ldr	r2, [r3, #28]
 8011b26:	687b      	ldr	r3, [r7, #4]
 8011b28:	61da      	str	r2, [r3, #28]
        destTm->tm_isdst = srcTm->tm_isdst;
 8011b2a:	683b      	ldr	r3, [r7, #0]
 8011b2c:	6a1a      	ldr	r2, [r3, #32]
 8011b2e:	687b      	ldr	r3, [r7, #4]
 8011b30:	621a      	str	r2, [r3, #32]
        destTm->tm_gmtoff = srcTm->tm_gmtoff;
 8011b32:	683b      	ldr	r3, [r7, #0]
 8011b34:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8011b36:	687b      	ldr	r3, [r7, #4]
 8011b38:	625a      	str	r2, [r3, #36]	; 0x24
        destTm->tm_zone = srcTm->tm_zone;
 8011b3a:	683b      	ldr	r3, [r7, #0]
 8011b3c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8011b3e:	687b      	ldr	r3, [r7, #4]
 8011b40:	629a      	str	r2, [r3, #40]	; 0x28
}
 8011b42:	bf00      	nop
 8011b44:	3708      	adds	r7, #8
 8011b46:	46bd      	mov	sp, r7
 8011b48:	bd80      	pop	{r7, pc}
	...

08011b4c <OsCmdUsageDate>:

STATIC VOID OsCmdUsageDate(INT32 order)
{
 8011b4c:	b580      	push	{r7, lr}
 8011b4e:	b082      	sub	sp, #8
 8011b50:	af00      	add	r7, sp, #0
 8011b52:	6078      	str	r0, [r7, #4]
    if (order) {
 8011b54:	687b      	ldr	r3, [r7, #4]
 8011b56:	2b00      	cmp	r3, #0
 8011b58:	d006      	beq.n	8011b68 <OsCmdUsageDate+0x1c>
        PRINTK("date: invalid option or parameter.\n");
 8011b5a:	4842      	ldr	r0, [pc, #264]	; (8011c64 <OsCmdUsageDate+0x118>)
 8011b5c:	f7f2 fdb6 	bl	80046cc <dprintf>
        PRINTK("Try 'date --help' for more information.\n");
 8011b60:	4841      	ldr	r0, [pc, #260]	; (8011c68 <OsCmdUsageDate+0x11c>)
 8011b62:	f7f2 fdb3 	bl	80046cc <dprintf>
        return;
 8011b66:	e07a      	b.n	8011c5e <OsCmdUsageDate+0x112>
    }
    PRINTK("\nUsage: date [+FORMAT]\n");
 8011b68:	4840      	ldr	r0, [pc, #256]	; (8011c6c <OsCmdUsageDate+0x120>)
 8011b6a:	f7f2 fdaf 	bl	80046cc <dprintf>
    PRINTK("   or: date [-s] [YY/MM/DD] [hh:mm:ss]\n");
 8011b6e:	4840      	ldr	r0, [pc, #256]	; (8011c70 <OsCmdUsageDate+0x124>)
 8011b70:	f7f2 fdac 	bl	80046cc <dprintf>
    PRINTK("Display the current time in the given FORMAT, or set the system date.\n");
 8011b74:	483f      	ldr	r0, [pc, #252]	; (8011c74 <OsCmdUsageDate+0x128>)
 8011b76:	f7f2 fda9 	bl	80046cc <dprintf>
    PRINTK("FORMAT controls the output.  Interpreted sequences are:\n");
 8011b7a:	483f      	ldr	r0, [pc, #252]	; (8011c78 <OsCmdUsageDate+0x12c>)
 8011b7c:	f7f2 fda6 	bl	80046cc <dprintf>
    PRINTK("  %%b     The abbreviated month name according to the current locale.\n");
 8011b80:	483e      	ldr	r0, [pc, #248]	; (8011c7c <OsCmdUsageDate+0x130>)
 8011b82:	f7f2 fda3 	bl	80046cc <dprintf>
    PRINTK("  %%B     The full month name according to the current locale.\n");
 8011b86:	483e      	ldr	r0, [pc, #248]	; (8011c80 <OsCmdUsageDate+0x134>)
 8011b88:	f7f2 fda0 	bl	80046cc <dprintf>
    PRINTK("  %%C     The century number (year/100) as a 2-digit integer. (SU)\n");
 8011b8c:	483d      	ldr	r0, [pc, #244]	; (8011c84 <OsCmdUsageDate+0x138>)
 8011b8e:	f7f2 fd9d 	bl	80046cc <dprintf>
    PRINTK("  %%d     The day of the month as a decimal number (range 01 to 31).\n");
 8011b92:	483d      	ldr	r0, [pc, #244]	; (8011c88 <OsCmdUsageDate+0x13c>)
 8011b94:	f7f2 fd9a 	bl	80046cc <dprintf>
    PRINTK("  %%e     Like %%d, the day of the month as a decimal number, \n");
 8011b98:	483c      	ldr	r0, [pc, #240]	; (8011c8c <OsCmdUsageDate+0x140>)
 8011b9a:	f7f2 fd97 	bl	80046cc <dprintf>
    PRINTK("         but a leading zero is replaced by a space.\n");
 8011b9e:	483c      	ldr	r0, [pc, #240]	; (8011c90 <OsCmdUsageDate+0x144>)
 8011ba0:	f7f2 fd94 	bl	80046cc <dprintf>
    PRINTK("  %%h     Equivalent to %%b.  (SU)\n");
 8011ba4:	483b      	ldr	r0, [pc, #236]	; (8011c94 <OsCmdUsageDate+0x148>)
 8011ba6:	f7f2 fd91 	bl	80046cc <dprintf>
    PRINTK("  %%H     The hour as a decimal number using a 24-hour clock (range 00 to 23).\n");
 8011baa:	483b      	ldr	r0, [pc, #236]	; (8011c98 <OsCmdUsageDate+0x14c>)
 8011bac:	f7f2 fd8e 	bl	80046cc <dprintf>
    PRINTK("  %%I     The hour as a decimal number using a 12-hour clock (range 01 to 12).\n");
 8011bb0:	483a      	ldr	r0, [pc, #232]	; (8011c9c <OsCmdUsageDate+0x150>)
 8011bb2:	f7f2 fd8b 	bl	80046cc <dprintf>
    PRINTK("  %%j     The day of the year as a decimal number (range 001 to 366).\n");
 8011bb6:	483a      	ldr	r0, [pc, #232]	; (8011ca0 <OsCmdUsageDate+0x154>)
 8011bb8:	f7f2 fd88 	bl	80046cc <dprintf>
    PRINTK("  %%k     The hour (24-hour clock) as a decimal number (range  0  to  23); \n");
 8011bbc:	4839      	ldr	r0, [pc, #228]	; (8011ca4 <OsCmdUsageDate+0x158>)
 8011bbe:	f7f2 fd85 	bl	80046cc <dprintf>
    PRINTK("         single digits are preceded by a blank.  (See also %%H.)  (TZ)\n");
 8011bc2:	4839      	ldr	r0, [pc, #228]	; (8011ca8 <OsCmdUsageDate+0x15c>)
 8011bc4:	f7f2 fd82 	bl	80046cc <dprintf>
    PRINTK("  %%l     The hour (12-hour  clock) as a decimal number (range 1 to 12); \n");
 8011bc8:	4838      	ldr	r0, [pc, #224]	; (8011cac <OsCmdUsageDate+0x160>)
 8011bca:	f7f2 fd7f 	bl	80046cc <dprintf>
    PRINTK("         single digits are preceded by a blank.  (See also %%I.)  (TZ)\n");
 8011bce:	4838      	ldr	r0, [pc, #224]	; (8011cb0 <OsCmdUsageDate+0x164>)
 8011bd0:	f7f2 fd7c 	bl	80046cc <dprintf>
    PRINTK("  %%m     The month as a decimal number (range 01 to 12).\n");
 8011bd4:	4837      	ldr	r0, [pc, #220]	; (8011cb4 <OsCmdUsageDate+0x168>)
 8011bd6:	f7f2 fd79 	bl	80046cc <dprintf>
    PRINTK("  %%M     The minute as a decimal number (range 00 to 59).\n");
 8011bda:	4837      	ldr	r0, [pc, #220]	; (8011cb8 <OsCmdUsageDate+0x16c>)
 8011bdc:	f7f2 fd76 	bl	80046cc <dprintf>
    PRINTK("  %%n     A newline character. (SU)\n");
 8011be0:	4836      	ldr	r0, [pc, #216]	; (8011cbc <OsCmdUsageDate+0x170>)
 8011be2:	f7f2 fd73 	bl	80046cc <dprintf>
    PRINTK("  %%p     Either \"AM\" or \"PM\" according to the given time value, \n");
 8011be6:	4836      	ldr	r0, [pc, #216]	; (8011cc0 <OsCmdUsageDate+0x174>)
 8011be8:	f7f2 fd70 	bl	80046cc <dprintf>
    PRINTK("         or the corresponding strings for the current locale.\n");
 8011bec:	4835      	ldr	r0, [pc, #212]	; (8011cc4 <OsCmdUsageDate+0x178>)
 8011bee:	f7f2 fd6d 	bl	80046cc <dprintf>
    PRINTK("         Noon is treated as \"PM\" and midnight as \"AM\".\n");
 8011bf2:	4835      	ldr	r0, [pc, #212]	; (8011cc8 <OsCmdUsageDate+0x17c>)
 8011bf4:	f7f2 fd6a 	bl	80046cc <dprintf>
    PRINTK("  %%P     Like %%p but in lowercase: \"am\" or \"pm\" \n");
 8011bf8:	4834      	ldr	r0, [pc, #208]	; (8011ccc <OsCmdUsageDate+0x180>)
 8011bfa:	f7f2 fd67 	bl	80046cc <dprintf>
    PRINTK("         or a corresponding string for the current locale. (GNU)\n");
 8011bfe:	4834      	ldr	r0, [pc, #208]	; (8011cd0 <OsCmdUsageDate+0x184>)
 8011c00:	f7f2 fd64 	bl	80046cc <dprintf>
    PRINTK("  %%s     The number of seconds since the Epoch, that is,\n");
 8011c04:	4833      	ldr	r0, [pc, #204]	; (8011cd4 <OsCmdUsageDate+0x188>)
 8011c06:	f7f2 fd61 	bl	80046cc <dprintf>
    PRINTK("         since 1970-01-01 00:00:00 UTC. (TZ)\n");
 8011c0a:	4833      	ldr	r0, [pc, #204]	; (8011cd8 <OsCmdUsageDate+0x18c>)
 8011c0c:	f7f2 fd5e 	bl	80046cc <dprintf>
    PRINTK("  %%S     The second as a decimal number (range 00 to 60).\n");
 8011c10:	4832      	ldr	r0, [pc, #200]	; (8011cdc <OsCmdUsageDate+0x190>)
 8011c12:	f7f2 fd5b 	bl	80046cc <dprintf>
    PRINTK("         (The range is up to 60 to allow for occasional leap seconds.)\n");
 8011c16:	4832      	ldr	r0, [pc, #200]	; (8011ce0 <OsCmdUsageDate+0x194>)
 8011c18:	f7f2 fd58 	bl	80046cc <dprintf>
    PRINTK("  %%t     A tab character. (SU)\n");
 8011c1c:	4831      	ldr	r0, [pc, #196]	; (8011ce4 <OsCmdUsageDate+0x198>)
 8011c1e:	f7f2 fd55 	bl	80046cc <dprintf>
    PRINTK("  %%y     The year as a decimal number without a century (range 00 to 99).\n");
 8011c22:	4831      	ldr	r0, [pc, #196]	; (8011ce8 <OsCmdUsageDate+0x19c>)
 8011c24:	f7f2 fd52 	bl	80046cc <dprintf>
    PRINTK("  %%Y     The year as a decimal number including the century.\n");
 8011c28:	4830      	ldr	r0, [pc, #192]	; (8011cec <OsCmdUsageDate+0x1a0>)
 8011c2a:	f7f2 fd4f 	bl	80046cc <dprintf>
    PRINTK("  %%%%     A literal '%%' character.\n");
 8011c2e:	4830      	ldr	r0, [pc, #192]	; (8011cf0 <OsCmdUsageDate+0x1a4>)
 8011c30:	f7f2 fd4c 	bl	80046cc <dprintf>
    PRINTK("\nExamples:\n");
 8011c34:	482f      	ldr	r0, [pc, #188]	; (8011cf4 <OsCmdUsageDate+0x1a8>)
 8011c36:	f7f2 fd49 	bl	80046cc <dprintf>
    PRINTK("Set system date (2017-01-01)\n");
 8011c3a:	482f      	ldr	r0, [pc, #188]	; (8011cf8 <OsCmdUsageDate+0x1ac>)
 8011c3c:	f7f2 fd46 	bl	80046cc <dprintf>
    PRINTK("$ date -s 20170101\n");
 8011c40:	482e      	ldr	r0, [pc, #184]	; (8011cfc <OsCmdUsageDate+0x1b0>)
 8011c42:	f7f2 fd43 	bl	80046cc <dprintf>
    PRINTK("Set system time (12:00:00)\n");
 8011c46:	482e      	ldr	r0, [pc, #184]	; (8011d00 <OsCmdUsageDate+0x1b4>)
 8011c48:	f7f2 fd40 	bl	80046cc <dprintf>
    PRINTK("$ date -s 12:00:00\n");
 8011c4c:	482d      	ldr	r0, [pc, #180]	; (8011d04 <OsCmdUsageDate+0x1b8>)
 8011c4e:	f7f2 fd3d 	bl	80046cc <dprintf>
    PRINTK("Show the time with format Year-Month-Day\n");
 8011c52:	482d      	ldr	r0, [pc, #180]	; (8011d08 <OsCmdUsageDate+0x1bc>)
 8011c54:	f7f2 fd3a 	bl	80046cc <dprintf>
    PRINTK("$ date +%%Y-%%m-%%d\n");
 8011c58:	482c      	ldr	r0, [pc, #176]	; (8011d0c <OsCmdUsageDate+0x1c0>)
 8011c5a:	f7f2 fd37 	bl	80046cc <dprintf>
}
 8011c5e:	3708      	adds	r7, #8
 8011c60:	46bd      	mov	sp, r7
 8011c62:	bd80      	pop	{r7, pc}
 8011c64:	08021b40 	.word	0x08021b40
 8011c68:	08021b64 	.word	0x08021b64
 8011c6c:	08021b90 	.word	0x08021b90
 8011c70:	08021ba8 	.word	0x08021ba8
 8011c74:	08021bd0 	.word	0x08021bd0
 8011c78:	08021c18 	.word	0x08021c18
 8011c7c:	08021c54 	.word	0x08021c54
 8011c80:	08021c9c 	.word	0x08021c9c
 8011c84:	08021cdc 	.word	0x08021cdc
 8011c88:	08021d20 	.word	0x08021d20
 8011c8c:	08021d68 	.word	0x08021d68
 8011c90:	08021da8 	.word	0x08021da8
 8011c94:	08021de0 	.word	0x08021de0
 8011c98:	08021e04 	.word	0x08021e04
 8011c9c:	08021e54 	.word	0x08021e54
 8011ca0:	08021ea4 	.word	0x08021ea4
 8011ca4:	08021eec 	.word	0x08021eec
 8011ca8:	08021f3c 	.word	0x08021f3c
 8011cac:	08021f84 	.word	0x08021f84
 8011cb0:	08021fd0 	.word	0x08021fd0
 8011cb4:	08022018 	.word	0x08022018
 8011cb8:	08022054 	.word	0x08022054
 8011cbc:	08022090 	.word	0x08022090
 8011cc0:	080220b8 	.word	0x080220b8
 8011cc4:	080220fc 	.word	0x080220fc
 8011cc8:	0802213c 	.word	0x0802213c
 8011ccc:	08022174 	.word	0x08022174
 8011cd0:	080221a8 	.word	0x080221a8
 8011cd4:	080221ec 	.word	0x080221ec
 8011cd8:	08022228 	.word	0x08022228
 8011cdc:	08022258 	.word	0x08022258
 8011ce0:	08022294 	.word	0x08022294
 8011ce4:	080222dc 	.word	0x080222dc
 8011ce8:	08022300 	.word	0x08022300
 8011cec:	0802234c 	.word	0x0802234c
 8011cf0:	0802238c 	.word	0x0802238c
 8011cf4:	080223b4 	.word	0x080223b4
 8011cf8:	080223c0 	.word	0x080223c0
 8011cfc:	080223e0 	.word	0x080223e0
 8011d00:	080223f4 	.word	0x080223f4
 8011d04:	08022410 	.word	0x08022410
 8011d08:	08022424 	.word	0x08022424
 8011d0c:	08022450 	.word	0x08022450

08011d10 <OsStrToTm>:

STATIC INT32 OsStrToTm(const CHAR *str, struct tm *tm)
{
 8011d10:	b590      	push	{r4, r7, lr}
 8011d12:	b085      	sub	sp, #20
 8011d14:	af00      	add	r7, sp, #0
 8011d16:	6078      	str	r0, [r7, #4]
 8011d18:	6039      	str	r1, [r7, #0]
    CHAR *ret = NULL;
 8011d1a:	2300      	movs	r3, #0
 8011d1c:	60bb      	str	r3, [r7, #8]
    UINT32 strLen = strlen(str);
 8011d1e:	6878      	ldr	r0, [r7, #4]
 8011d20:	f7fc feb3 	bl	800ea8a <strlen>
 8011d24:	60f8      	str	r0, [r7, #12]
    if (strLen == 8) { /* 8:Time format string length, such as hh:mm:ss or yyyymmdd */
 8011d26:	68fb      	ldr	r3, [r7, #12]
 8011d28:	2b08      	cmp	r3, #8
 8011d2a:	d112      	bne.n	8011d52 <OsStrToTm+0x42>
        if (str[2] == ':') { /* 2:Index of Eigenvalues */
 8011d2c:	687b      	ldr	r3, [r7, #4]
 8011d2e:	3302      	adds	r3, #2
 8011d30:	781b      	ldrb	r3, [r3, #0]
 8011d32:	2b3a      	cmp	r3, #58	; 0x3a
 8011d34:	d106      	bne.n	8011d44 <OsStrToTm+0x34>
            ret = strptime(str, "%H:%M:%S", tm);
 8011d36:	683a      	ldr	r2, [r7, #0]
 8011d38:	494e      	ldr	r1, [pc, #312]	; (8011e74 <OsStrToTm+0x164>)
 8011d3a:	6878      	ldr	r0, [r7, #4]
 8011d3c:	f008 f96c 	bl	801a018 <strptime>
 8011d40:	60b8      	str	r0, [r7, #8]
 8011d42:	e039      	b.n	8011db8 <OsStrToTm+0xa8>
        } else {
            ret = strptime(str, "%Y%m%d", tm);
 8011d44:	683a      	ldr	r2, [r7, #0]
 8011d46:	494c      	ldr	r1, [pc, #304]	; (8011e78 <OsStrToTm+0x168>)
 8011d48:	6878      	ldr	r0, [r7, #4]
 8011d4a:	f008 f965 	bl	801a018 <strptime>
 8011d4e:	60b8      	str	r0, [r7, #8]
 8011d50:	e032      	b.n	8011db8 <OsStrToTm+0xa8>
        }
    } else if (strLen == 10) { /* 10:Time format string length,such as yyyy/mm/dd  */
 8011d52:	68fb      	ldr	r3, [r7, #12]
 8011d54:	2b0a      	cmp	r3, #10
 8011d56:	d106      	bne.n	8011d66 <OsStrToTm+0x56>
        ret = strptime(str, "%Y/%m/%d", tm);
 8011d58:	683a      	ldr	r2, [r7, #0]
 8011d5a:	4948      	ldr	r1, [pc, #288]	; (8011e7c <OsStrToTm+0x16c>)
 8011d5c:	6878      	ldr	r0, [r7, #4]
 8011d5e:	f008 f95b 	bl	801a018 <strptime>
 8011d62:	60b8      	str	r0, [r7, #8]
 8011d64:	e028      	b.n	8011db8 <OsStrToTm+0xa8>
    } else if (strLen == 5) { /* 5:Time format string length,such as hh:mm or mm/dd */
 8011d66:	68fb      	ldr	r3, [r7, #12]
 8011d68:	2b05      	cmp	r3, #5
 8011d6a:	d117      	bne.n	8011d9c <OsStrToTm+0x8c>
        if (str[2] == ':') { /* 2:Index of Eigenvalues */
 8011d6c:	687b      	ldr	r3, [r7, #4]
 8011d6e:	3302      	adds	r3, #2
 8011d70:	781b      	ldrb	r3, [r3, #0]
 8011d72:	2b3a      	cmp	r3, #58	; 0x3a
 8011d74:	d106      	bne.n	8011d84 <OsStrToTm+0x74>
            ret = strptime(str, "%H:%M", tm);
 8011d76:	683a      	ldr	r2, [r7, #0]
 8011d78:	4941      	ldr	r1, [pc, #260]	; (8011e80 <OsStrToTm+0x170>)
 8011d7a:	6878      	ldr	r0, [r7, #4]
 8011d7c:	f008 f94c 	bl	801a018 <strptime>
 8011d80:	60b8      	str	r0, [r7, #8]
 8011d82:	e019      	b.n	8011db8 <OsStrToTm+0xa8>
        } else if (str[2] == '/') { /* 2:Index of Eigenvalues */
 8011d84:	687b      	ldr	r3, [r7, #4]
 8011d86:	3302      	adds	r3, #2
 8011d88:	781b      	ldrb	r3, [r3, #0]
 8011d8a:	2b2f      	cmp	r3, #47	; 0x2f
 8011d8c:	d114      	bne.n	8011db8 <OsStrToTm+0xa8>
            ret = strptime(str, "%m/%d", tm);
 8011d8e:	683a      	ldr	r2, [r7, #0]
 8011d90:	493c      	ldr	r1, [pc, #240]	; (8011e84 <OsStrToTm+0x174>)
 8011d92:	6878      	ldr	r0, [r7, #4]
 8011d94:	f008 f940 	bl	801a018 <strptime>
 8011d98:	60b8      	str	r0, [r7, #8]
 8011d9a:	e00d      	b.n	8011db8 <OsStrToTm+0xa8>
        }
    } else if (strLen == 7) { /* 7:Time format string length,such as yyyy/mm */
 8011d9c:	68fb      	ldr	r3, [r7, #12]
 8011d9e:	2b07      	cmp	r3, #7
 8011da0:	d10a      	bne.n	8011db8 <OsStrToTm+0xa8>
        if (str[4] == '/') { /* 4:Index of Eigenvalues */
 8011da2:	687b      	ldr	r3, [r7, #4]
 8011da4:	3304      	adds	r3, #4
 8011da6:	781b      	ldrb	r3, [r3, #0]
 8011da8:	2b2f      	cmp	r3, #47	; 0x2f
 8011daa:	d105      	bne.n	8011db8 <OsStrToTm+0xa8>
            ret = strptime(str, "%Y/%m", tm);
 8011dac:	683a      	ldr	r2, [r7, #0]
 8011dae:	4936      	ldr	r1, [pc, #216]	; (8011e88 <OsStrToTm+0x178>)
 8011db0:	6878      	ldr	r0, [r7, #4]
 8011db2:	f008 f931 	bl	801a018 <strptime>
 8011db6:	60b8      	str	r0, [r7, #8]
        }
    }

    if (tm->tm_year < 70) { /* 70:the year is starting in 1970,tm_year must be greater than 70 */
 8011db8:	683b      	ldr	r3, [r7, #0]
 8011dba:	695b      	ldr	r3, [r3, #20]
 8011dbc:	2b45      	cmp	r3, #69	; 0x45
 8011dbe:	dc05      	bgt.n	8011dcc <OsStrToTm+0xbc>
        PRINTK("\nUsage: date -s set system time range from 1970.\n");
 8011dc0:	4832      	ldr	r0, [pc, #200]	; (8011e8c <OsStrToTm+0x17c>)
 8011dc2:	f7f2 fc83 	bl	80046cc <dprintf>
        return DATE_ERR;
 8011dc6:	f04f 33ff 	mov.w	r3, #4294967295
 8011dca:	e04e      	b.n	8011e6a <OsStrToTm+0x15a>
    }

    if (tm->tm_mday > g_monLengths[(INT32)LEAPYEAR(tm->tm_year + DATE_BASE_YEAR)][tm->tm_mon]) {
 8011dcc:	683b      	ldr	r3, [r7, #0]
 8011dce:	68d9      	ldr	r1, [r3, #12]
 8011dd0:	683b      	ldr	r3, [r7, #0]
 8011dd2:	695b      	ldr	r3, [r3, #20]
 8011dd4:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 8011dd8:	f003 0303 	and.w	r3, r3, #3
 8011ddc:	2b00      	cmp	r3, #0
 8011dde:	d122      	bne.n	8011e26 <OsStrToTm+0x116>
 8011de0:	683b      	ldr	r3, [r7, #0]
 8011de2:	695b      	ldr	r3, [r3, #20]
 8011de4:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 8011de8:	4b29      	ldr	r3, [pc, #164]	; (8011e90 <OsStrToTm+0x180>)
 8011dea:	fb83 0302 	smull	r0, r3, r3, r2
 8011dee:	1158      	asrs	r0, r3, #5
 8011df0:	17d3      	asrs	r3, r2, #31
 8011df2:	1ac3      	subs	r3, r0, r3
 8011df4:	2064      	movs	r0, #100	; 0x64
 8011df6:	fb00 f303 	mul.w	r3, r0, r3
 8011dfa:	1ad3      	subs	r3, r2, r3
 8011dfc:	2b00      	cmp	r3, #0
 8011dfe:	d110      	bne.n	8011e22 <OsStrToTm+0x112>
 8011e00:	683b      	ldr	r3, [r7, #0]
 8011e02:	695b      	ldr	r3, [r3, #20]
 8011e04:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 8011e08:	4b21      	ldr	r3, [pc, #132]	; (8011e90 <OsStrToTm+0x180>)
 8011e0a:	fb83 0302 	smull	r0, r3, r3, r2
 8011e0e:	11d8      	asrs	r0, r3, #7
 8011e10:	17d3      	asrs	r3, r2, #31
 8011e12:	1ac3      	subs	r3, r0, r3
 8011e14:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8011e18:	fb00 f303 	mul.w	r3, r0, r3
 8011e1c:	1ad3      	subs	r3, r2, r3
 8011e1e:	2b00      	cmp	r3, #0
 8011e20:	d101      	bne.n	8011e26 <OsStrToTm+0x116>
 8011e22:	2201      	movs	r2, #1
 8011e24:	e000      	b.n	8011e28 <OsStrToTm+0x118>
 8011e26:	2200      	movs	r2, #0
 8011e28:	683b      	ldr	r3, [r7, #0]
 8011e2a:	6918      	ldr	r0, [r3, #16]
 8011e2c:	4c19      	ldr	r4, [pc, #100]	; (8011e94 <OsStrToTm+0x184>)
 8011e2e:	4613      	mov	r3, r2
 8011e30:	005b      	lsls	r3, r3, #1
 8011e32:	4413      	add	r3, r2
 8011e34:	009b      	lsls	r3, r3, #2
 8011e36:	4403      	add	r3, r0
 8011e38:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8011e3c:	4299      	cmp	r1, r3
 8011e3e:	dd02      	ble.n	8011e46 <OsStrToTm+0x136>
        return DATE_ERR;
 8011e40:	f04f 33ff 	mov.w	r3, #4294967295
 8011e44:	e011      	b.n	8011e6a <OsStrToTm+0x15a>
    }

    if ((tm->tm_sec < 0) || (tm->tm_sec > 59)) { /* Seconds (0-59), leap seconds shall not be used when set time. */
 8011e46:	683b      	ldr	r3, [r7, #0]
 8011e48:	681b      	ldr	r3, [r3, #0]
 8011e4a:	2b00      	cmp	r3, #0
 8011e4c:	db03      	blt.n	8011e56 <OsStrToTm+0x146>
 8011e4e:	683b      	ldr	r3, [r7, #0]
 8011e50:	681b      	ldr	r3, [r3, #0]
 8011e52:	2b3b      	cmp	r3, #59	; 0x3b
 8011e54:	dd02      	ble.n	8011e5c <OsStrToTm+0x14c>
        return DATE_ERR;
 8011e56:	f04f 33ff 	mov.w	r3, #4294967295
 8011e5a:	e006      	b.n	8011e6a <OsStrToTm+0x15a>
    }
    return (ret == NULL) ? DATE_ERR : DATE_OK;
 8011e5c:	68bb      	ldr	r3, [r7, #8]
 8011e5e:	2b00      	cmp	r3, #0
 8011e60:	d102      	bne.n	8011e68 <OsStrToTm+0x158>
 8011e62:	f04f 33ff 	mov.w	r3, #4294967295
 8011e66:	e000      	b.n	8011e6a <OsStrToTm+0x15a>
 8011e68:	2300      	movs	r3, #0
}
 8011e6a:	4618      	mov	r0, r3
 8011e6c:	3714      	adds	r7, #20
 8011e6e:	46bd      	mov	sp, r7
 8011e70:	bd90      	pop	{r4, r7, pc}
 8011e72:	bf00      	nop
 8011e74:	08022468 	.word	0x08022468
 8011e78:	08022474 	.word	0x08022474
 8011e7c:	0802247c 	.word	0x0802247c
 8011e80:	08022488 	.word	0x08022488
 8011e84:	08022490 	.word	0x08022490
 8011e88:	08022498 	.word	0x08022498
 8011e8c:	080224a0 	.word	0x080224a0
 8011e90:	51eb851f 	.word	0x51eb851f
 8011e94:	0802357c 	.word	0x0802357c

08011e98 <OsFormatPrintTime>:

STATIC INT32 OsFormatPrintTime(const CHAR *formatStr)
{
 8011e98:	b590      	push	{r4, r7, lr}
 8011e9a:	b0cf      	sub	sp, #316	; 0x13c
 8011e9c:	af00      	add	r7, sp, #0
 8011e9e:	1d3b      	adds	r3, r7, #4
 8011ea0:	6018      	str	r0, [r3, #0]
 8011ea2:	4b37      	ldr	r3, [pc, #220]	; (8011f80 <OsFormatPrintTime+0xe8>)
 8011ea4:	681b      	ldr	r3, [r3, #0]
 8011ea6:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
 8011eaa:	f04f 0300 	mov.w	r3, #0
    CHAR timebuf[SHOW_MAX_LEN] = {0};
 8011eae:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8011eb2:	2200      	movs	r2, #0
 8011eb4:	601a      	str	r2, [r3, #0]
 8011eb6:	3304      	adds	r3, #4
 8011eb8:	f44f 7286 	mov.w	r2, #268	; 0x10c
 8011ebc:	2100      	movs	r1, #0
 8011ebe:	4618      	mov	r0, r3
 8011ec0:	f7fc fcc0 	bl	800e844 <memset>
    struct tm *tm = NULL;
 8011ec4:	f107 030c 	add.w	r3, r7, #12
 8011ec8:	2200      	movs	r2, #0
 8011eca:	601a      	str	r2, [r3, #0]
    struct timeval64 nowTime = {0};
 8011ecc:	f107 0310 	add.w	r3, r7, #16
 8011ed0:	461a      	mov	r2, r3
 8011ed2:	2300      	movs	r3, #0
 8011ed4:	6013      	str	r3, [r2, #0]
 8011ed6:	6053      	str	r3, [r2, #4]
 8011ed8:	6093      	str	r3, [r2, #8]
 8011eda:	60d3      	str	r3, [r2, #12]

    if (strlen(formatStr) < 2) { /* 2:check format string length */
 8011edc:	1d3b      	adds	r3, r7, #4
 8011ede:	6818      	ldr	r0, [r3, #0]
 8011ee0:	f7fc fdd3 	bl	800ea8a <strlen>
 8011ee4:	4603      	mov	r3, r0
 8011ee6:	2b01      	cmp	r3, #1
 8011ee8:	d805      	bhi.n	8011ef6 <OsFormatPrintTime+0x5e>
        OsCmdUsageDate(DATE_ERR_INFO);
 8011eea:	2001      	movs	r0, #1
 8011eec:	f7ff fe2e 	bl	8011b4c <OsCmdUsageDate>
        return DATE_ERR;
 8011ef0:	f04f 33ff 	mov.w	r3, #4294967295
 8011ef4:	e037      	b.n	8011f66 <OsFormatPrintTime+0xce>
    }

    if (gettimeofday64(&nowTime, NULL)) {
 8011ef6:	f107 0310 	add.w	r3, r7, #16
 8011efa:	2100      	movs	r1, #0
 8011efc:	4618      	mov	r0, r3
 8011efe:	f00b fcb9 	bl	801d874 <gettimeofday64>
 8011f02:	4603      	mov	r3, r0
 8011f04:	2b00      	cmp	r3, #0
 8011f06:	d002      	beq.n	8011f0e <OsFormatPrintTime+0x76>
        return DATE_ERR;
 8011f08:	f04f 33ff 	mov.w	r3, #4294967295
 8011f0c:	e02b      	b.n	8011f66 <OsFormatPrintTime+0xce>
    }
    tm = localtime64(&nowTime.tv_sec);
 8011f0e:	f107 040c 	add.w	r4, r7, #12
 8011f12:	f107 0310 	add.w	r3, r7, #16
 8011f16:	4618      	mov	r0, r3
 8011f18:	f00b fd60 	bl	801d9dc <localtime64>
 8011f1c:	6020      	str	r0, [r4, #0]
    if (tm == NULL) {
 8011f1e:	f107 030c 	add.w	r3, r7, #12
 8011f22:	681b      	ldr	r3, [r3, #0]
 8011f24:	2b00      	cmp	r3, #0
 8011f26:	d102      	bne.n	8011f2e <OsFormatPrintTime+0x96>
        return DATE_ERR;
 8011f28:	f04f 33ff 	mov.w	r3, #4294967295
 8011f2c:	e01b      	b.n	8011f66 <OsFormatPrintTime+0xce>
    }

    if (strftime(timebuf, SHOW_MAX_LEN - 1, formatStr + 1, tm)) {
 8011f2e:	1d3b      	adds	r3, r7, #4
 8011f30:	681b      	ldr	r3, [r3, #0]
 8011f32:	1c5a      	adds	r2, r3, #1
 8011f34:	f107 030c 	add.w	r3, r7, #12
 8011f38:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8011f3c:	681b      	ldr	r3, [r3, #0]
 8011f3e:	f240 110f 	movw	r1, #271	; 0x10f
 8011f42:	f008 f841 	bl	8019fc8 <strftime>
 8011f46:	4603      	mov	r3, r0
 8011f48:	2b00      	cmp	r3, #0
 8011f4a:	d007      	beq.n	8011f5c <OsFormatPrintTime+0xc4>
        PRINTK("%s\n", timebuf);
 8011f4c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8011f50:	4619      	mov	r1, r3
 8011f52:	480c      	ldr	r0, [pc, #48]	; (8011f84 <OsFormatPrintTime+0xec>)
 8011f54:	f7f2 fbba 	bl	80046cc <dprintf>
    } else {
        OsCmdUsageDate(DATE_ERR_INFO);
        return DATE_ERR;
    }
    return DATE_OK;
 8011f58:	2300      	movs	r3, #0
 8011f5a:	e004      	b.n	8011f66 <OsFormatPrintTime+0xce>
        OsCmdUsageDate(DATE_ERR_INFO);
 8011f5c:	2001      	movs	r0, #1
 8011f5e:	f7ff fdf5 	bl	8011b4c <OsCmdUsageDate>
        return DATE_ERR;
 8011f62:	f04f 33ff 	mov.w	r3, #4294967295
}
 8011f66:	4a06      	ldr	r2, [pc, #24]	; (8011f80 <OsFormatPrintTime+0xe8>)
 8011f68:	6811      	ldr	r1, [r2, #0]
 8011f6a:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8011f6e:	4051      	eors	r1, r2
 8011f70:	d001      	beq.n	8011f76 <OsFormatPrintTime+0xde>
 8011f72:	f7f2 fa39 	bl	80043e8 <__stack_chk_fail>
 8011f76:	4618      	mov	r0, r3
 8011f78:	f507 779e 	add.w	r7, r7, #316	; 0x13c
 8011f7c:	46bd      	mov	sp, r7
 8011f7e:	bd90      	pop	{r4, r7, pc}
 8011f80:	080224d8 	.word	0x080224d8
 8011f84:	080224d4 	.word	0x080224d4

08011f88 <OsDateSetTime>:

STATIC INT32 OsDateSetTime(const CHAR *timeStr)
{
 8011f88:	b580      	push	{r7, lr}
 8011f8a:	b096      	sub	sp, #88	; 0x58
 8011f8c:	af00      	add	r7, sp, #0
 8011f8e:	6078      	str	r0, [r7, #4]
 8011f90:	4b3c      	ldr	r3, [pc, #240]	; (8012084 <OsDateSetTime+0xfc>)
 8011f92:	681b      	ldr	r3, [r3, #0]
 8011f94:	657b      	str	r3, [r7, #84]	; 0x54
 8011f96:	f04f 0300 	mov.w	r3, #0
    struct tm tm = {0};
 8011f9a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8011f9e:	222c      	movs	r2, #44	; 0x2c
 8011fa0:	2100      	movs	r1, #0
 8011fa2:	4618      	mov	r0, r3
 8011fa4:	f7fc fc4e 	bl	800e844 <memset>
    struct timeval64 nowTime = {0};
 8011fa8:	f107 0308 	add.w	r3, r7, #8
 8011fac:	2200      	movs	r2, #0
 8011fae:	601a      	str	r2, [r3, #0]
 8011fb0:	605a      	str	r2, [r3, #4]
 8011fb2:	609a      	str	r2, [r3, #8]
 8011fb4:	60da      	str	r2, [r3, #12]
    struct timeval64 setTime = {0};
 8011fb6:	f107 0318 	add.w	r3, r7, #24
 8011fba:	2200      	movs	r2, #0
 8011fbc:	601a      	str	r2, [r3, #0]
 8011fbe:	605a      	str	r2, [r3, #4]
 8011fc0:	609a      	str	r2, [r3, #8]
 8011fc2:	60da      	str	r2, [r3, #12]

    if (gettimeofday64(&nowTime, NULL)) {
 8011fc4:	f107 0308 	add.w	r3, r7, #8
 8011fc8:	2100      	movs	r1, #0
 8011fca:	4618      	mov	r0, r3
 8011fcc:	f00b fc52 	bl	801d874 <gettimeofday64>
 8011fd0:	4603      	mov	r3, r0
 8011fd2:	2b00      	cmp	r3, #0
 8011fd4:	d005      	beq.n	8011fe2 <OsDateSetTime+0x5a>
        PRINTK("settime failed...\n");
 8011fd6:	482c      	ldr	r0, [pc, #176]	; (8012088 <OsDateSetTime+0x100>)
 8011fd8:	f7f2 fb78 	bl	80046cc <dprintf>
        return DATE_ERR;
 8011fdc:	f04f 33ff 	mov.w	r3, #4294967295
 8011fe0:	e045      	b.n	801206e <OsDateSetTime+0xe6>
    }

    setTime.tv_usec = nowTime.tv_usec;
 8011fe2:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8011fe6:	e9c7 2308 	strd	r2, r3, [r7, #32]
    OsCopyTm(&tm, localtime64(&nowTime.tv_sec));
 8011fea:	f107 0308 	add.w	r3, r7, #8
 8011fee:	4618      	mov	r0, r3
 8011ff0:	f00b fcf4 	bl	801d9dc <localtime64>
 8011ff4:	4602      	mov	r2, r0
 8011ff6:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8011ffa:	4611      	mov	r1, r2
 8011ffc:	4618      	mov	r0, r3
 8011ffe:	f7ff fd65 	bl	8011acc <OsCopyTm>

    if (OsStrToTm(timeStr, &tm)) {
 8012002:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8012006:	4619      	mov	r1, r3
 8012008:	6878      	ldr	r0, [r7, #4]
 801200a:	f7ff fe81 	bl	8011d10 <OsStrToTm>
 801200e:	4603      	mov	r3, r0
 8012010:	2b00      	cmp	r3, #0
 8012012:	d005      	beq.n	8012020 <OsDateSetTime+0x98>
        OsCmdUsageDate(DATE_ERR_INFO);
 8012014:	2001      	movs	r0, #1
 8012016:	f7ff fd99 	bl	8011b4c <OsCmdUsageDate>
        return DATE_ERR;
 801201a:	f04f 33ff 	mov.w	r3, #4294967295
 801201e:	e026      	b.n	801206e <OsDateSetTime+0xe6>
    }

    setTime.tv_sec = mktime64(&tm);
 8012020:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8012024:	4618      	mov	r0, r3
 8012026:	f00b fd33 	bl	801da90 <mktime64>
 801202a:	4602      	mov	r2, r0
 801202c:	460b      	mov	r3, r1
 801202e:	e9c7 2306 	strd	r2, r3, [r7, #24]
    if (setTime.tv_sec == -1) {
 8012032:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8012036:	f1b3 3fff 	cmp.w	r3, #4294967295
 801203a:	bf08      	it	eq
 801203c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 8012040:	d105      	bne.n	801204e <OsDateSetTime+0xc6>
        PRINTK("mktime failed...\n");
 8012042:	4812      	ldr	r0, [pc, #72]	; (801208c <OsDateSetTime+0x104>)
 8012044:	f7f2 fb42 	bl	80046cc <dprintf>
        return DATE_ERR;
 8012048:	f04f 33ff 	mov.w	r3, #4294967295
 801204c:	e00f      	b.n	801206e <OsDateSetTime+0xe6>
    }

    if (settimeofday64(&setTime, NULL)) {
 801204e:	f107 0318 	add.w	r3, r7, #24
 8012052:	2100      	movs	r1, #0
 8012054:	4618      	mov	r0, r3
 8012056:	f00b fb33 	bl	801d6c0 <settimeofday64>
 801205a:	4603      	mov	r3, r0
 801205c:	2b00      	cmp	r3, #0
 801205e:	d005      	beq.n	801206c <OsDateSetTime+0xe4>
        PRINTK("settime failed...\n");
 8012060:	4809      	ldr	r0, [pc, #36]	; (8012088 <OsDateSetTime+0x100>)
 8012062:	f7f2 fb33 	bl	80046cc <dprintf>
        return DATE_ERR;
 8012066:	f04f 33ff 	mov.w	r3, #4294967295
 801206a:	e000      	b.n	801206e <OsDateSetTime+0xe6>
    }

    return DATE_OK;
 801206c:	2300      	movs	r3, #0
}
 801206e:	4a05      	ldr	r2, [pc, #20]	; (8012084 <OsDateSetTime+0xfc>)
 8012070:	6811      	ldr	r1, [r2, #0]
 8012072:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8012074:	4051      	eors	r1, r2
 8012076:	d001      	beq.n	801207c <OsDateSetTime+0xf4>
 8012078:	f7f2 f9b6 	bl	80043e8 <__stack_chk_fail>
 801207c:	4618      	mov	r0, r3
 801207e:	3758      	adds	r7, #88	; 0x58
 8012080:	46bd      	mov	sp, r7
 8012082:	bd80      	pop	{r7, pc}
 8012084:	08022504 	.word	0x08022504
 8012088:	080224dc 	.word	0x080224dc
 801208c:	080224f0 	.word	0x080224f0

08012090 <OsShellCmdDate>:
    return DATE_OK;
}
#endif

INT32 OsShellCmdDate(INT32 argc, const CHAR **argv)
{
 8012090:	b580      	push	{r7, lr}
 8012092:	b088      	sub	sp, #32
 8012094:	af00      	add	r7, sp, #0
 8012096:	6078      	str	r0, [r7, #4]
 8012098:	6039      	str	r1, [r7, #0]
 801209a:	4b38      	ldr	r3, [pc, #224]	; (801217c <OsShellCmdDate+0xec>)
 801209c:	681b      	ldr	r3, [r3, #0]
 801209e:	61fb      	str	r3, [r7, #28]
 80120a0:	f04f 0300 	mov.w	r3, #0
    struct timeval64 nowTime = {0};
 80120a4:	f107 0308 	add.w	r3, r7, #8
 80120a8:	2200      	movs	r2, #0
 80120aa:	601a      	str	r2, [r3, #0]
 80120ac:	605a      	str	r2, [r3, #4]
 80120ae:	609a      	str	r2, [r3, #8]
 80120b0:	60da      	str	r2, [r3, #12]

    if (argc == 1) { /* 1:count of parameters */
 80120b2:	687b      	ldr	r3, [r7, #4]
 80120b4:	2b01      	cmp	r3, #1
 80120b6:	d117      	bne.n	80120e8 <OsShellCmdDate+0x58>
        if (gettimeofday64(&nowTime, NULL)) {
 80120b8:	f107 0308 	add.w	r3, r7, #8
 80120bc:	2100      	movs	r1, #0
 80120be:	4618      	mov	r0, r3
 80120c0:	f00b fbd8 	bl	801d874 <gettimeofday64>
 80120c4:	4603      	mov	r3, r0
 80120c6:	2b00      	cmp	r3, #0
 80120c8:	d002      	beq.n	80120d0 <OsShellCmdDate+0x40>
            return DATE_ERR;
 80120ca:	f04f 33ff 	mov.w	r3, #4294967295
 80120ce:	e049      	b.n	8012164 <OsShellCmdDate+0xd4>
        }
        PRINTK("%s\n", ctime64(&nowTime.tv_sec));
 80120d0:	f107 0308 	add.w	r3, r7, #8
 80120d4:	4618      	mov	r0, r3
 80120d6:	f00b fcc5 	bl	801da64 <ctime64>
 80120da:	4603      	mov	r3, r0
 80120dc:	4619      	mov	r1, r3
 80120de:	4828      	ldr	r0, [pc, #160]	; (8012180 <OsShellCmdDate+0xf0>)
 80120e0:	f7f2 faf4 	bl	80046cc <dprintf>
        return DATE_OK;
 80120e4:	2300      	movs	r3, #0
 80120e6:	e03d      	b.n	8012164 <OsShellCmdDate+0xd4>
    }

    if (argc == 2) { /* 2:count of parameters */
 80120e8:	687b      	ldr	r3, [r7, #4]
 80120ea:	2b02      	cmp	r3, #2
 80120ec:	d121      	bne.n	8012132 <OsShellCmdDate+0xa2>
        if (!(strcmp(argv[1], "--help"))) {
 80120ee:	683b      	ldr	r3, [r7, #0]
 80120f0:	3304      	adds	r3, #4
 80120f2:	681b      	ldr	r3, [r3, #0]
 80120f4:	4923      	ldr	r1, [pc, #140]	; (8012184 <OsShellCmdDate+0xf4>)
 80120f6:	4618      	mov	r0, r3
 80120f8:	f7fc fca5 	bl	800ea46 <strcmp>
 80120fc:	4603      	mov	r3, r0
 80120fe:	2b00      	cmp	r3, #0
 8012100:	d104      	bne.n	801210c <OsShellCmdDate+0x7c>
            OsCmdUsageDate(DATE_HELP_INFO);
 8012102:	2000      	movs	r0, #0
 8012104:	f7ff fd22 	bl	8011b4c <OsCmdUsageDate>
            return DATE_OK;
 8012108:	2300      	movs	r3, #0
 801210a:	e02b      	b.n	8012164 <OsShellCmdDate+0xd4>
        }
        if (!(strncmp(argv[1], "+", 1))) {
 801210c:	683b      	ldr	r3, [r7, #0]
 801210e:	3304      	adds	r3, #4
 8012110:	681b      	ldr	r3, [r3, #0]
 8012112:	2201      	movs	r2, #1
 8012114:	491c      	ldr	r1, [pc, #112]	; (8012188 <OsShellCmdDate+0xf8>)
 8012116:	4618      	mov	r0, r3
 8012118:	f007 f986 	bl	8019428 <strncmp>
 801211c:	4603      	mov	r3, r0
 801211e:	2b00      	cmp	r3, #0
 8012120:	d107      	bne.n	8012132 <OsShellCmdDate+0xa2>
            return OsFormatPrintTime(argv[1]);
 8012122:	683b      	ldr	r3, [r7, #0]
 8012124:	3304      	adds	r3, #4
 8012126:	681b      	ldr	r3, [r3, #0]
 8012128:	4618      	mov	r0, r3
 801212a:	f7ff feb5 	bl	8011e98 <OsFormatPrintTime>
 801212e:	4603      	mov	r3, r0
 8012130:	e018      	b.n	8012164 <OsShellCmdDate+0xd4>
        }
    }

    if (argc > 2) { /* 2:count of parameters */
 8012132:	687b      	ldr	r3, [r7, #4]
 8012134:	2b02      	cmp	r3, #2
 8012136:	dd11      	ble.n	801215c <OsShellCmdDate+0xcc>
        if (!(strcmp(argv[1], "-s"))) {
 8012138:	683b      	ldr	r3, [r7, #0]
 801213a:	3304      	adds	r3, #4
 801213c:	681b      	ldr	r3, [r3, #0]
 801213e:	4913      	ldr	r1, [pc, #76]	; (801218c <OsShellCmdDate+0xfc>)
 8012140:	4618      	mov	r0, r3
 8012142:	f7fc fc80 	bl	800ea46 <strcmp>
 8012146:	4603      	mov	r3, r0
 8012148:	2b00      	cmp	r3, #0
 801214a:	d107      	bne.n	801215c <OsShellCmdDate+0xcc>
            return OsDateSetTime(argv[2]); /* 2:index of parameters */
 801214c:	683b      	ldr	r3, [r7, #0]
 801214e:	3308      	adds	r3, #8
 8012150:	681b      	ldr	r3, [r3, #0]
 8012152:	4618      	mov	r0, r3
 8012154:	f7ff ff18 	bl	8011f88 <OsDateSetTime>
 8012158:	4603      	mov	r3, r0
 801215a:	e003      	b.n	8012164 <OsShellCmdDate+0xd4>
            return OsViewFileTime(argv[2]); /* 2:index of parameters */
        }
#endif
    }

    OsCmdUsageDate(DATE_ERR_INFO);
 801215c:	2001      	movs	r0, #1
 801215e:	f7ff fcf5 	bl	8011b4c <OsCmdUsageDate>
    return DATE_OK;
 8012162:	2300      	movs	r3, #0
}
 8012164:	4a05      	ldr	r2, [pc, #20]	; (801217c <OsShellCmdDate+0xec>)
 8012166:	6811      	ldr	r1, [r2, #0]
 8012168:	69fa      	ldr	r2, [r7, #28]
 801216a:	4051      	eors	r1, r2
 801216c:	d001      	beq.n	8012172 <OsShellCmdDate+0xe2>
 801216e:	f7f2 f93b 	bl	80043e8 <__stack_chk_fail>
 8012172:	4618      	mov	r0, r3
 8012174:	3720      	adds	r7, #32
 8012176:	46bd      	mov	sp, r7
 8012178:	bd80      	pop	{r7, pc}
 801217a:	bf00      	nop
 801217c:	08022518 	.word	0x08022518
 8012180:	080224d4 	.word	0x080224d4
 8012184:	08022508 	.word	0x08022508
 8012188:	08022510 	.word	0x08022510
 801218c:	08022514 	.word	0x08022514

08012190 <PrintTime>:
#define WATCH_COUNT_MAX 0xFFFFFF
#define WATCH_INTETVAL_MAX 0xFFFFFF
#define WATCH_EVENT_MASK 0x01U

STATIC VOID PrintTime(VOID)
{
 8012190:	b580      	push	{r7, lr}
 8012192:	b086      	sub	sp, #24
 8012194:	af00      	add	r7, sp, #0
 8012196:	4b13      	ldr	r3, [pc, #76]	; (80121e4 <PrintTime+0x54>)
 8012198:	681b      	ldr	r3, [r3, #0]
 801219a:	617b      	str	r3, [r7, #20]
 801219c:	f04f 0300 	mov.w	r3, #0
    struct timeval64 nowTime = {0};
 80121a0:	463b      	mov	r3, r7
 80121a2:	2200      	movs	r2, #0
 80121a4:	601a      	str	r2, [r3, #0]
 80121a6:	605a      	str	r2, [r3, #4]
 80121a8:	609a      	str	r2, [r3, #8]
 80121aa:	60da      	str	r2, [r3, #12]

    if (gettimeofday64(&nowTime, NULL) == 0) {
 80121ac:	463b      	mov	r3, r7
 80121ae:	2100      	movs	r1, #0
 80121b0:	4618      	mov	r0, r3
 80121b2:	f00b fb5f 	bl	801d874 <gettimeofday64>
 80121b6:	4603      	mov	r3, r0
 80121b8:	2b00      	cmp	r3, #0
 80121ba:	d108      	bne.n	80121ce <PrintTime+0x3e>
        PRINTK("%s", ctime64(&nowTime.tv_sec));
 80121bc:	463b      	mov	r3, r7
 80121be:	4618      	mov	r0, r3
 80121c0:	f00b fc50 	bl	801da64 <ctime64>
 80121c4:	4603      	mov	r3, r0
 80121c6:	4619      	mov	r1, r3
 80121c8:	4807      	ldr	r0, [pc, #28]	; (80121e8 <PrintTime+0x58>)
 80121ca:	f7f2 fa7f 	bl	80046cc <dprintf>
    }
}
 80121ce:	bf00      	nop
 80121d0:	4b04      	ldr	r3, [pc, #16]	; (80121e4 <PrintTime+0x54>)
 80121d2:	681a      	ldr	r2, [r3, #0]
 80121d4:	697b      	ldr	r3, [r7, #20]
 80121d6:	405a      	eors	r2, r3
 80121d8:	d001      	beq.n	80121de <PrintTime+0x4e>
 80121da:	f7f2 f905 	bl	80043e8 <__stack_chk_fail>
 80121de:	3718      	adds	r7, #24
 80121e0:	46bd      	mov	sp, r7
 80121e2:	bd80      	pop	{r7, pc}
 80121e4:	08022528 	.word	0x08022528
 80121e8:	08022524 	.word	0x08022524

080121ec <OsShellCmdDoWatch>:

STATIC VOID OsShellCmdDoWatch(VOID *arg1)
{
 80121ec:	b580      	push	{r7, lr}
 80121ee:	b084      	sub	sp, #16
 80121f0:	af00      	add	r7, sp, #0
 80121f2:	6078      	str	r0, [r7, #4]
    WatchCB *watchItem = (WatchCB *)arg1;
 80121f4:	687b      	ldr	r3, [r7, #4]
 80121f6:	60bb      	str	r3, [r7, #8]
    UINT32 ret;
    g_watchCmd = watchItem;
 80121f8:	4a1d      	ldr	r2, [pc, #116]	; (8012270 <OsShellCmdDoWatch+0x84>)
 80121fa:	68bb      	ldr	r3, [r7, #8]
 80121fc:	6013      	str	r3, [r2, #0]

    while (watchItem->count--) {
 80121fe:	e01a      	b.n	8012236 <OsShellCmdDoWatch+0x4a>
        PRINTK("\033[2J\n");
 8012200:	481c      	ldr	r0, [pc, #112]	; (8012274 <OsShellCmdDoWatch+0x88>)
 8012202:	f7f2 fa63 	bl	80046cc <dprintf>
        if (watchItem->title) {
 8012206:	68bb      	ldr	r3, [r7, #8]
 8012208:	681b      	ldr	r3, [r3, #0]
 801220a:	2b00      	cmp	r3, #0
 801220c:	d001      	beq.n	8012212 <OsShellCmdDoWatch+0x26>
            PrintTime();
 801220e:	f7ff ffbf 	bl	8012190 <PrintTime>
        }
        (VOID)ShellMsgParse(watchItem->cmdBuf);
 8012212:	68bb      	ldr	r3, [r7, #8]
 8012214:	3318      	adds	r3, #24
 8012216:	4618      	mov	r0, r3
 8012218:	f000 fe5a 	bl	8012ed0 <ShellMsgParse>
        ret = LOS_EventRead(&watchItem->watchEvent, WATCH_EVENT_MASK,
 801221c:	68bb      	ldr	r3, [r7, #8]
 801221e:	f103 000c 	add.w	r0, r3, #12
 8012222:	68bb      	ldr	r3, [r7, #8]
 8012224:	689b      	ldr	r3, [r3, #8]
 8012226:	2203      	movs	r2, #3
 8012228:	2101      	movs	r1, #1
 801222a:	f006 fd45 	bl	8018cb8 <LOS_EventRead>
 801222e:	60f8      	str	r0, [r7, #12]
                            LOS_WAITMODE_OR | LOS_WAITMODE_CLR, watchItem->interval);
        if (ret == WATCH_EVENT_MASK) {
 8012230:	68fb      	ldr	r3, [r7, #12]
 8012232:	2b01      	cmp	r3, #1
 8012234:	d007      	beq.n	8012246 <OsShellCmdDoWatch+0x5a>
    while (watchItem->count--) {
 8012236:	68bb      	ldr	r3, [r7, #8]
 8012238:	685b      	ldr	r3, [r3, #4]
 801223a:	1e59      	subs	r1, r3, #1
 801223c:	68ba      	ldr	r2, [r7, #8]
 801223e:	6051      	str	r1, [r2, #4]
 8012240:	2b00      	cmp	r3, #0
 8012242:	d1dd      	bne.n	8012200 <OsShellCmdDoWatch+0x14>
 8012244:	e000      	b.n	8012248 <OsShellCmdDoWatch+0x5c>
            break;
 8012246:	bf00      	nop
        }
    }

    (VOID)LOS_EventDestroy(&watchItem->watchEvent);
 8012248:	68bb      	ldr	r3, [r7, #8]
 801224a:	330c      	adds	r3, #12
 801224c:	4618      	mov	r0, r3
 801224e:	f006 fd57 	bl	8018d00 <LOS_EventDestroy>
    free(g_watchCmd);
 8012252:	4b07      	ldr	r3, [pc, #28]	; (8012270 <OsShellCmdDoWatch+0x84>)
 8012254:	681b      	ldr	r3, [r3, #0]
 8012256:	4618      	mov	r0, r3
 8012258:	f008 fabc 	bl	801a7d4 <free>
    g_watchCmd = NULL;
 801225c:	4b04      	ldr	r3, [pc, #16]	; (8012270 <OsShellCmdDoWatch+0x84>)
 801225e:	2200      	movs	r2, #0
 8012260:	601a      	str	r2, [r3, #0]
    PRINTK("\nHuawei LiteOS # ");
 8012262:	4805      	ldr	r0, [pc, #20]	; (8012278 <OsShellCmdDoWatch+0x8c>)
 8012264:	f7f2 fa32 	bl	80046cc <dprintf>
}
 8012268:	bf00      	nop
 801226a:	3710      	adds	r7, #16
 801226c:	46bd      	mov	sp, r7
 801226e:	bd80      	pop	{r7, pc}
 8012270:	200032bc 	.word	0x200032bc
 8012274:	0802252c 	.word	0x0802252c
 8012278:	08022534 	.word	0x08022534

0801227c <OsWatchCmdUsage>:

STATIC INLINE VOID OsWatchCmdUsage(VOID)
{
 801227c:	b580      	push	{r7, lr}
 801227e:	af00      	add	r7, sp, #0
    PRINTK("\nUsage: watch\n");
 8012280:	4803      	ldr	r0, [pc, #12]	; (8012290 <OsWatchCmdUsage+0x14>)
 8012282:	f7f2 fa23 	bl	80046cc <dprintf>
    PRINTK("watch [options] command\n");
 8012286:	4803      	ldr	r0, [pc, #12]	; (8012294 <OsWatchCmdUsage+0x18>)
 8012288:	f7f2 fa20 	bl	80046cc <dprintf>
}
 801228c:	bf00      	nop
 801228e:	bd80      	pop	{r7, pc}
 8012290:	08022548 	.word	0x08022548
 8012294:	08022558 	.word	0x08022558

08012298 <OsWatchOverFunc>:

STATIC UINT32 OsWatchOverFunc(VOID)
{
 8012298:	b580      	push	{r7, lr}
 801229a:	b082      	sub	sp, #8
 801229c:	af00      	add	r7, sp, #0
    UINT32 ret;
    if (g_watchCmd != NULL) {
 801229e:	4b12      	ldr	r3, [pc, #72]	; (80122e8 <OsWatchOverFunc+0x50>)
 80122a0:	681b      	ldr	r3, [r3, #0]
 80122a2:	2b00      	cmp	r3, #0
 80122a4:	d017      	beq.n	80122d6 <OsWatchOverFunc+0x3e>
        ret = LOS_EventWrite(&g_watchCmd->watchEvent, WATCH_EVENT_MASK);
 80122a6:	4b10      	ldr	r3, [pc, #64]	; (80122e8 <OsWatchOverFunc+0x50>)
 80122a8:	681b      	ldr	r3, [r3, #0]
 80122aa:	330c      	adds	r3, #12
 80122ac:	2101      	movs	r1, #1
 80122ae:	4618      	mov	r0, r3
 80122b0:	f006 fd16 	bl	8018ce0 <LOS_EventWrite>
 80122b4:	6078      	str	r0, [r7, #4]
        if (ret != LOS_OK) {
 80122b6:	687b      	ldr	r3, [r7, #4]
 80122b8:	2b00      	cmp	r3, #0
 80122ba:	d00a      	beq.n	80122d2 <OsWatchOverFunc+0x3a>
            PRINT_ERR("Write event failed in %s,%d\n", __FUNCTION__, __LINE__);
 80122bc:	480b      	ldr	r0, [pc, #44]	; (80122ec <OsWatchOverFunc+0x54>)
 80122be:	f7f2 fa05 	bl	80046cc <dprintf>
 80122c2:	2268      	movs	r2, #104	; 0x68
 80122c4:	490a      	ldr	r1, [pc, #40]	; (80122f0 <OsWatchOverFunc+0x58>)
 80122c6:	480b      	ldr	r0, [pc, #44]	; (80122f4 <OsWatchOverFunc+0x5c>)
 80122c8:	f7f2 fa00 	bl	80046cc <dprintf>
            return OS_ERROR;
 80122cc:	f04f 33ff 	mov.w	r3, #4294967295
 80122d0:	e006      	b.n	80122e0 <OsWatchOverFunc+0x48>
        }
        return LOS_OK;
 80122d2:	2300      	movs	r3, #0
 80122d4:	e004      	b.n	80122e0 <OsWatchOverFunc+0x48>
    } else {
        PRINTK("No watch task to turn off.\n");
 80122d6:	4808      	ldr	r0, [pc, #32]	; (80122f8 <OsWatchOverFunc+0x60>)
 80122d8:	f7f2 f9f8 	bl	80046cc <dprintf>
        return OS_ERROR;
 80122dc:	f04f 33ff 	mov.w	r3, #4294967295
    }
}
 80122e0:	4618      	mov	r0, r3
 80122e2:	3708      	adds	r7, #8
 80122e4:	46bd      	mov	sp, r7
 80122e6:	bd80      	pop	{r7, pc}
 80122e8:	200032bc 	.word	0x200032bc
 80122ec:	08022574 	.word	0x08022574
 80122f0:	080235dc 	.word	0x080235dc
 80122f4:	0802257c 	.word	0x0802257c
 80122f8:	0802259c 	.word	0x0802259c

080122fc <OsWatchOptionParsed>:

STATIC INT32 OsWatchOptionParsed(UINT32 argc, UINT32 *argoff, const CHAR **argv, WatchCB *watchItem)
{
 80122fc:	b5b0      	push	{r4, r5, r7, lr}
 80122fe:	b088      	sub	sp, #32
 8012300:	af00      	add	r7, sp, #0
 8012302:	60f8      	str	r0, [r7, #12]
 8012304:	60b9      	str	r1, [r7, #8]
 8012306:	607a      	str	r2, [r7, #4]
 8012308:	603b      	str	r3, [r7, #0]
 801230a:	4b86      	ldr	r3, [pc, #536]	; (8012524 <OsWatchOptionParsed+0x228>)
 801230c:	681b      	ldr	r3, [r3, #0]
 801230e:	61fb      	str	r3, [r7, #28]
 8012310:	f04f 0300 	mov.w	r3, #0
    size_t tmpVal;
    CHAR *strPtr = NULL;
 8012314:	2300      	movs	r3, #0
 8012316:	613b      	str	r3, [r7, #16]
    UINT32 argCount = argc;
 8012318:	68fb      	ldr	r3, [r7, #12]
 801231a:	617b      	str	r3, [r7, #20]

    while (argv[*argoff][0] == '-') {
 801231c:	e0eb      	b.n	80124f6 <OsWatchOptionParsed+0x1fa>
        if (argCount <= 1) {
 801231e:	697b      	ldr	r3, [r7, #20]
 8012320:	2b01      	cmp	r3, #1
 8012322:	d804      	bhi.n	801232e <OsWatchOptionParsed+0x32>
            OsWatchCmdUsage();
 8012324:	f7ff ffaa 	bl	801227c <OsWatchCmdUsage>
            return -1;
 8012328:	f04f 33ff 	mov.w	r3, #4294967295
 801232c:	e0ee      	b.n	801250c <OsWatchOptionParsed+0x210>
        }

        if ((strcmp(argv[*argoff], "-n") == 0) || (strcmp(argv[*argoff], "--interval") == 0)) {
 801232e:	68bb      	ldr	r3, [r7, #8]
 8012330:	681b      	ldr	r3, [r3, #0]
 8012332:	009b      	lsls	r3, r3, #2
 8012334:	687a      	ldr	r2, [r7, #4]
 8012336:	4413      	add	r3, r2
 8012338:	681b      	ldr	r3, [r3, #0]
 801233a:	497b      	ldr	r1, [pc, #492]	; (8012528 <OsWatchOptionParsed+0x22c>)
 801233c:	4618      	mov	r0, r3
 801233e:	f7fc fb82 	bl	800ea46 <strcmp>
 8012342:	4603      	mov	r3, r0
 8012344:	2b00      	cmp	r3, #0
 8012346:	d00c      	beq.n	8012362 <OsWatchOptionParsed+0x66>
 8012348:	68bb      	ldr	r3, [r7, #8]
 801234a:	681b      	ldr	r3, [r3, #0]
 801234c:	009b      	lsls	r3, r3, #2
 801234e:	687a      	ldr	r2, [r7, #4]
 8012350:	4413      	add	r3, r2
 8012352:	681b      	ldr	r3, [r3, #0]
 8012354:	4975      	ldr	r1, [pc, #468]	; (801252c <OsWatchOptionParsed+0x230>)
 8012356:	4618      	mov	r0, r3
 8012358:	f7fc fb75 	bl	800ea46 <strcmp>
 801235c:	4603      	mov	r3, r0
 801235e:	2b00      	cmp	r3, #0
 8012360:	d14e      	bne.n	8012400 <OsWatchOptionParsed+0x104>
            if (argCount <= 2) { /* 2:count of parameter */
 8012362:	697b      	ldr	r3, [r7, #20]
 8012364:	2b02      	cmp	r3, #2
 8012366:	d804      	bhi.n	8012372 <OsWatchOptionParsed+0x76>
                OsWatchCmdUsage();
 8012368:	f7ff ff88 	bl	801227c <OsWatchCmdUsage>
                return -1;
 801236c:	f04f 33ff 	mov.w	r3, #4294967295
 8012370:	e0cc      	b.n	801250c <OsWatchOptionParsed+0x210>
            }
            tmpVal = strtoul(argv[*argoff + 1], &strPtr, 0);
 8012372:	68bb      	ldr	r3, [r7, #8]
 8012374:	681b      	ldr	r3, [r3, #0]
 8012376:	3301      	adds	r3, #1
 8012378:	009b      	lsls	r3, r3, #2
 801237a:	687a      	ldr	r2, [r7, #4]
 801237c:	4413      	add	r3, r2
 801237e:	681b      	ldr	r3, [r3, #0]
 8012380:	f107 0110 	add.w	r1, r7, #16
 8012384:	2200      	movs	r2, #0
 8012386:	4618      	mov	r0, r3
 8012388:	f7fc fc02 	bl	800eb90 <strtoul>
 801238c:	61b8      	str	r0, [r7, #24]
            if ((*strPtr != 0) || (tmpVal == 0) || (tmpVal > WATCH_INTETVAL_MAX) ||
 801238e:	693b      	ldr	r3, [r7, #16]
 8012390:	781b      	ldrb	r3, [r3, #0]
 8012392:	2b00      	cmp	r3, #0
 8012394:	d11c      	bne.n	80123d0 <OsWatchOptionParsed+0xd4>
 8012396:	69bb      	ldr	r3, [r7, #24]
 8012398:	2b00      	cmp	r3, #0
 801239a:	d019      	beq.n	80123d0 <OsWatchOptionParsed+0xd4>
 801239c:	69bb      	ldr	r3, [r7, #24]
 801239e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80123a2:	d215      	bcs.n	80123d0 <OsWatchOptionParsed+0xd4>
                ((UINT64)g_tickPerSecond * tmpVal > UINT32_MAX)) {
 80123a4:	4b62      	ldr	r3, [pc, #392]	; (8012530 <OsWatchOptionParsed+0x234>)
 80123a6:	681b      	ldr	r3, [r3, #0]
 80123a8:	4618      	mov	r0, r3
 80123aa:	f04f 0100 	mov.w	r1, #0
 80123ae:	69bb      	ldr	r3, [r7, #24]
 80123b0:	461a      	mov	r2, r3
 80123b2:	f04f 0300 	mov.w	r3, #0
 80123b6:	fb02 f501 	mul.w	r5, r2, r1
 80123ba:	fb00 f403 	mul.w	r4, r0, r3
 80123be:	442c      	add	r4, r5
 80123c0:	fba0 2302 	umull	r2, r3, r0, r2
 80123c4:	18e1      	adds	r1, r4, r3
 80123c6:	460b      	mov	r3, r1
            if ((*strPtr != 0) || (tmpVal == 0) || (tmpVal > WATCH_INTETVAL_MAX) ||
 80123c8:	2b01      	cmp	r3, #1
 80123ca:	bf08      	it	eq
 80123cc:	2a00      	cmpeq	r2, #0
 80123ce:	d307      	bcc.n	80123e0 <OsWatchOptionParsed+0xe4>
                PRINTK("\ninterval time is invalid\n");
 80123d0:	4858      	ldr	r0, [pc, #352]	; (8012534 <OsWatchOptionParsed+0x238>)
 80123d2:	f7f2 f97b 	bl	80046cc <dprintf>
                OsWatchCmdUsage();
 80123d6:	f7ff ff51 	bl	801227c <OsWatchCmdUsage>
                return -1;
 80123da:	f04f 33ff 	mov.w	r3, #4294967295
 80123de:	e095      	b.n	801250c <OsWatchOptionParsed+0x210>
            }

            watchItem->interval = g_tickPerSecond * (UINT32)tmpVal;
 80123e0:	4b53      	ldr	r3, [pc, #332]	; (8012530 <OsWatchOptionParsed+0x234>)
 80123e2:	681b      	ldr	r3, [r3, #0]
 80123e4:	69ba      	ldr	r2, [r7, #24]
 80123e6:	fb02 f203 	mul.w	r2, r2, r3
 80123ea:	683b      	ldr	r3, [r7, #0]
 80123ec:	609a      	str	r2, [r3, #8]
            argCount -= 2; /* 2:offset of argv */
 80123ee:	697b      	ldr	r3, [r7, #20]
 80123f0:	3b02      	subs	r3, #2
 80123f2:	617b      	str	r3, [r7, #20]
            (*argoff) += 2; /* 2:offset of argv */
 80123f4:	68bb      	ldr	r3, [r7, #8]
 80123f6:	681b      	ldr	r3, [r3, #0]
 80123f8:	1c9a      	adds	r2, r3, #2
 80123fa:	68bb      	ldr	r3, [r7, #8]
 80123fc:	601a      	str	r2, [r3, #0]
 80123fe:	e07a      	b.n	80124f6 <OsWatchOptionParsed+0x1fa>
        } else if ((strcmp(argv[*argoff], "-t") == 0) || (strcmp(argv[*argoff], "-no-title") == 0)) {
 8012400:	68bb      	ldr	r3, [r7, #8]
 8012402:	681b      	ldr	r3, [r3, #0]
 8012404:	009b      	lsls	r3, r3, #2
 8012406:	687a      	ldr	r2, [r7, #4]
 8012408:	4413      	add	r3, r2
 801240a:	681b      	ldr	r3, [r3, #0]
 801240c:	494a      	ldr	r1, [pc, #296]	; (8012538 <OsWatchOptionParsed+0x23c>)
 801240e:	4618      	mov	r0, r3
 8012410:	f7fc fb19 	bl	800ea46 <strcmp>
 8012414:	4603      	mov	r3, r0
 8012416:	2b00      	cmp	r3, #0
 8012418:	d00c      	beq.n	8012434 <OsWatchOptionParsed+0x138>
 801241a:	68bb      	ldr	r3, [r7, #8]
 801241c:	681b      	ldr	r3, [r3, #0]
 801241e:	009b      	lsls	r3, r3, #2
 8012420:	687a      	ldr	r2, [r7, #4]
 8012422:	4413      	add	r3, r2
 8012424:	681b      	ldr	r3, [r3, #0]
 8012426:	4945      	ldr	r1, [pc, #276]	; (801253c <OsWatchOptionParsed+0x240>)
 8012428:	4618      	mov	r0, r3
 801242a:	f7fc fb0c 	bl	800ea46 <strcmp>
 801242e:	4603      	mov	r3, r0
 8012430:	2b00      	cmp	r3, #0
 8012432:	d10b      	bne.n	801244c <OsWatchOptionParsed+0x150>
            watchItem->title = FALSE;
 8012434:	683b      	ldr	r3, [r7, #0]
 8012436:	2200      	movs	r2, #0
 8012438:	601a      	str	r2, [r3, #0]
            argCount--;
 801243a:	697b      	ldr	r3, [r7, #20]
 801243c:	3b01      	subs	r3, #1
 801243e:	617b      	str	r3, [r7, #20]
            (*argoff)++;
 8012440:	68bb      	ldr	r3, [r7, #8]
 8012442:	681b      	ldr	r3, [r3, #0]
 8012444:	1c5a      	adds	r2, r3, #1
 8012446:	68bb      	ldr	r3, [r7, #8]
 8012448:	601a      	str	r2, [r3, #0]
 801244a:	e054      	b.n	80124f6 <OsWatchOptionParsed+0x1fa>
        } else if ((strcmp(argv[*argoff], "-c") == 0) || (strcmp(argv[*argoff], "--count") == 0)) {
 801244c:	68bb      	ldr	r3, [r7, #8]
 801244e:	681b      	ldr	r3, [r3, #0]
 8012450:	009b      	lsls	r3, r3, #2
 8012452:	687a      	ldr	r2, [r7, #4]
 8012454:	4413      	add	r3, r2
 8012456:	681b      	ldr	r3, [r3, #0]
 8012458:	4939      	ldr	r1, [pc, #228]	; (8012540 <OsWatchOptionParsed+0x244>)
 801245a:	4618      	mov	r0, r3
 801245c:	f7fc faf3 	bl	800ea46 <strcmp>
 8012460:	4603      	mov	r3, r0
 8012462:	2b00      	cmp	r3, #0
 8012464:	d00c      	beq.n	8012480 <OsWatchOptionParsed+0x184>
 8012466:	68bb      	ldr	r3, [r7, #8]
 8012468:	681b      	ldr	r3, [r3, #0]
 801246a:	009b      	lsls	r3, r3, #2
 801246c:	687a      	ldr	r2, [r7, #4]
 801246e:	4413      	add	r3, r2
 8012470:	681b      	ldr	r3, [r3, #0]
 8012472:	4934      	ldr	r1, [pc, #208]	; (8012544 <OsWatchOptionParsed+0x248>)
 8012474:	4618      	mov	r0, r3
 8012476:	f7fc fae6 	bl	800ea46 <strcmp>
 801247a:	4603      	mov	r3, r0
 801247c:	2b00      	cmp	r3, #0
 801247e:	d134      	bne.n	80124ea <OsWatchOptionParsed+0x1ee>
            if (argCount <= 2) { /* 2:count of parameter */
 8012480:	697b      	ldr	r3, [r7, #20]
 8012482:	2b02      	cmp	r3, #2
 8012484:	d804      	bhi.n	8012490 <OsWatchOptionParsed+0x194>
                OsWatchCmdUsage();
 8012486:	f7ff fef9 	bl	801227c <OsWatchCmdUsage>
                return -1;
 801248a:	f04f 33ff 	mov.w	r3, #4294967295
 801248e:	e03d      	b.n	801250c <OsWatchOptionParsed+0x210>
            }
            tmpVal = strtoul(argv[*argoff + 1], &strPtr, 0);
 8012490:	68bb      	ldr	r3, [r7, #8]
 8012492:	681b      	ldr	r3, [r3, #0]
 8012494:	3301      	adds	r3, #1
 8012496:	009b      	lsls	r3, r3, #2
 8012498:	687a      	ldr	r2, [r7, #4]
 801249a:	4413      	add	r3, r2
 801249c:	681b      	ldr	r3, [r3, #0]
 801249e:	f107 0110 	add.w	r1, r7, #16
 80124a2:	2200      	movs	r2, #0
 80124a4:	4618      	mov	r0, r3
 80124a6:	f7fc fb73 	bl	800eb90 <strtoul>
 80124aa:	61b8      	str	r0, [r7, #24]
            if ((*strPtr != 0) || (tmpVal == 0) || (tmpVal > WATCH_COUNT_MAX)) {
 80124ac:	693b      	ldr	r3, [r7, #16]
 80124ae:	781b      	ldrb	r3, [r3, #0]
 80124b0:	2b00      	cmp	r3, #0
 80124b2:	d106      	bne.n	80124c2 <OsWatchOptionParsed+0x1c6>
 80124b4:	69bb      	ldr	r3, [r7, #24]
 80124b6:	2b00      	cmp	r3, #0
 80124b8:	d003      	beq.n	80124c2 <OsWatchOptionParsed+0x1c6>
 80124ba:	69bb      	ldr	r3, [r7, #24]
 80124bc:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80124c0:	d307      	bcc.n	80124d2 <OsWatchOptionParsed+0x1d6>
                PRINTK("\ncount is invalid\n");
 80124c2:	4821      	ldr	r0, [pc, #132]	; (8012548 <OsWatchOptionParsed+0x24c>)
 80124c4:	f7f2 f902 	bl	80046cc <dprintf>
                OsWatchCmdUsage();
 80124c8:	f7ff fed8 	bl	801227c <OsWatchCmdUsage>
                return -1;
 80124cc:	f04f 33ff 	mov.w	r3, #4294967295
 80124d0:	e01c      	b.n	801250c <OsWatchOptionParsed+0x210>
            }
            watchItem->count = (UINT32)tmpVal;
 80124d2:	683b      	ldr	r3, [r7, #0]
 80124d4:	69ba      	ldr	r2, [r7, #24]
 80124d6:	605a      	str	r2, [r3, #4]
            argCount -= 2; /* 2:offset of argv */
 80124d8:	697b      	ldr	r3, [r7, #20]
 80124da:	3b02      	subs	r3, #2
 80124dc:	617b      	str	r3, [r7, #20]
            (*argoff) += 2; /* 2:offset of argv */
 80124de:	68bb      	ldr	r3, [r7, #8]
 80124e0:	681b      	ldr	r3, [r3, #0]
 80124e2:	1c9a      	adds	r2, r3, #2
 80124e4:	68bb      	ldr	r3, [r7, #8]
 80124e6:	601a      	str	r2, [r3, #0]
 80124e8:	e005      	b.n	80124f6 <OsWatchOptionParsed+0x1fa>
        } else {
            PRINTK("Unknown option.\n");
 80124ea:	4818      	ldr	r0, [pc, #96]	; (801254c <OsWatchOptionParsed+0x250>)
 80124ec:	f7f2 f8ee 	bl	80046cc <dprintf>
            return -1;
 80124f0:	f04f 33ff 	mov.w	r3, #4294967295
 80124f4:	e00a      	b.n	801250c <OsWatchOptionParsed+0x210>
    while (argv[*argoff][0] == '-') {
 80124f6:	68bb      	ldr	r3, [r7, #8]
 80124f8:	681b      	ldr	r3, [r3, #0]
 80124fa:	009b      	lsls	r3, r3, #2
 80124fc:	687a      	ldr	r2, [r7, #4]
 80124fe:	4413      	add	r3, r2
 8012500:	681b      	ldr	r3, [r3, #0]
 8012502:	781b      	ldrb	r3, [r3, #0]
 8012504:	2b2d      	cmp	r3, #45	; 0x2d
 8012506:	f43f af0a 	beq.w	801231e <OsWatchOptionParsed+0x22>
        }
    }
    return 0;
 801250a:	2300      	movs	r3, #0
}
 801250c:	4a05      	ldr	r2, [pc, #20]	; (8012524 <OsWatchOptionParsed+0x228>)
 801250e:	6811      	ldr	r1, [r2, #0]
 8012510:	69fa      	ldr	r2, [r7, #28]
 8012512:	4051      	eors	r1, r2
 8012514:	d001      	beq.n	801251a <OsWatchOptionParsed+0x21e>
 8012516:	f7f1 ff67 	bl	80043e8 <__stack_chk_fail>
 801251a:	4618      	mov	r0, r3
 801251c:	3720      	adds	r7, #32
 801251e:	46bd      	mov	sp, r7
 8012520:	bdb0      	pop	{r4, r5, r7, pc}
 8012522:	bf00      	nop
 8012524:	08022628 	.word	0x08022628
 8012528:	080225b8 	.word	0x080225b8
 801252c:	080225bc 	.word	0x080225bc
 8012530:	200036e4 	.word	0x200036e4
 8012534:	080225c8 	.word	0x080225c8
 8012538:	080225e4 	.word	0x080225e4
 801253c:	080225e8 	.word	0x080225e8
 8012540:	080225f4 	.word	0x080225f4
 8012544:	080225f8 	.word	0x080225f8
 8012548:	08022600 	.word	0x08022600
 801254c:	08022614 	.word	0x08022614

08012550 <OsWatchCmdSplice>:

STATIC INT32 OsWatchCmdSplice(UINT32 argc, UINT32 argoff, const CHAR **argv, WatchCB *watchItem)
{
 8012550:	b580      	push	{r7, lr}
 8012552:	b086      	sub	sp, #24
 8012554:	af00      	add	r7, sp, #0
 8012556:	60f8      	str	r0, [r7, #12]
 8012558:	60b9      	str	r1, [r7, #8]
 801255a:	607a      	str	r2, [r7, #4]
 801255c:	603b      	str	r3, [r7, #0]
    INT32 err = 0;
 801255e:	2300      	movs	r3, #0
 8012560:	617b      	str	r3, [r7, #20]
    if ((argc - argoff) == 0) {
 8012562:	68fa      	ldr	r2, [r7, #12]
 8012564:	68bb      	ldr	r3, [r7, #8]
 8012566:	429a      	cmp	r2, r3
 8012568:	d13e      	bne.n	80125e8 <OsWatchCmdSplice+0x98>
        PRINT_ERR("no watch command!\n");
 801256a:	4824      	ldr	r0, [pc, #144]	; (80125fc <OsWatchCmdSplice+0xac>)
 801256c:	f7f2 f8ae 	bl	80046cc <dprintf>
 8012570:	4823      	ldr	r0, [pc, #140]	; (8012600 <OsWatchCmdSplice+0xb0>)
 8012572:	f7f2 f8ab 	bl	80046cc <dprintf>
        return -1;
 8012576:	f04f 33ff 	mov.w	r3, #4294967295
 801257a:	e03a      	b.n	80125f2 <OsWatchCmdSplice+0xa2>
    }
    while (argc - argoff) {
        err = strcat_s(watchItem->cmdBuf, sizeof(watchItem->cmdBuf), argv[argoff]);
 801257c:	683b      	ldr	r3, [r7, #0]
 801257e:	f103 0018 	add.w	r0, r3, #24
 8012582:	68bb      	ldr	r3, [r7, #8]
 8012584:	009b      	lsls	r3, r3, #2
 8012586:	687a      	ldr	r2, [r7, #4]
 8012588:	4413      	add	r3, r2
 801258a:	681b      	ldr	r3, [r3, #0]
 801258c:	461a      	mov	r2, r3
 801258e:	f44f 7188 	mov.w	r1, #272	; 0x110
 8012592:	f003 ff8f 	bl	80164b4 <strcat_s>
 8012596:	6178      	str	r0, [r7, #20]
        if (err != EOK) {
 8012598:	697b      	ldr	r3, [r7, #20]
 801259a:	2b00      	cmp	r3, #0
 801259c:	d00a      	beq.n	80125b4 <OsWatchCmdSplice+0x64>
            PRINT_ERR("%s, %d strcat_s failed!\n", __FUNCTION__, __LINE__);
 801259e:	4817      	ldr	r0, [pc, #92]	; (80125fc <OsWatchCmdSplice+0xac>)
 80125a0:	f7f2 f894 	bl	80046cc <dprintf>
 80125a4:	22b2      	movs	r2, #178	; 0xb2
 80125a6:	4917      	ldr	r1, [pc, #92]	; (8012604 <OsWatchCmdSplice+0xb4>)
 80125a8:	4817      	ldr	r0, [pc, #92]	; (8012608 <OsWatchCmdSplice+0xb8>)
 80125aa:	f7f2 f88f 	bl	80046cc <dprintf>
            return -1;
 80125ae:	f04f 33ff 	mov.w	r3, #4294967295
 80125b2:	e01e      	b.n	80125f2 <OsWatchCmdSplice+0xa2>
        }
        err = strcat_s(watchItem->cmdBuf, sizeof(watchItem->cmdBuf), " ");
 80125b4:	683b      	ldr	r3, [r7, #0]
 80125b6:	3318      	adds	r3, #24
 80125b8:	4a14      	ldr	r2, [pc, #80]	; (801260c <OsWatchCmdSplice+0xbc>)
 80125ba:	f44f 7188 	mov.w	r1, #272	; 0x110
 80125be:	4618      	mov	r0, r3
 80125c0:	f003 ff78 	bl	80164b4 <strcat_s>
 80125c4:	6178      	str	r0, [r7, #20]
        if (err != EOK) {
 80125c6:	697b      	ldr	r3, [r7, #20]
 80125c8:	2b00      	cmp	r3, #0
 80125ca:	d00a      	beq.n	80125e2 <OsWatchCmdSplice+0x92>
            PRINT_ERR("%s, %d strcat_s failed!\n", __FUNCTION__, __LINE__);
 80125cc:	480b      	ldr	r0, [pc, #44]	; (80125fc <OsWatchCmdSplice+0xac>)
 80125ce:	f7f2 f87d 	bl	80046cc <dprintf>
 80125d2:	22b7      	movs	r2, #183	; 0xb7
 80125d4:	490b      	ldr	r1, [pc, #44]	; (8012604 <OsWatchCmdSplice+0xb4>)
 80125d6:	480c      	ldr	r0, [pc, #48]	; (8012608 <OsWatchCmdSplice+0xb8>)
 80125d8:	f7f2 f878 	bl	80046cc <dprintf>
            return -1;
 80125dc:	f04f 33ff 	mov.w	r3, #4294967295
 80125e0:	e007      	b.n	80125f2 <OsWatchCmdSplice+0xa2>
        }
        argoff++;
 80125e2:	68bb      	ldr	r3, [r7, #8]
 80125e4:	3301      	adds	r3, #1
 80125e6:	60bb      	str	r3, [r7, #8]
    while (argc - argoff) {
 80125e8:	68fa      	ldr	r2, [r7, #12]
 80125ea:	68bb      	ldr	r3, [r7, #8]
 80125ec:	429a      	cmp	r2, r3
 80125ee:	d1c5      	bne.n	801257c <OsWatchCmdSplice+0x2c>
    }
    return err;
 80125f0:	697b      	ldr	r3, [r7, #20]
}
 80125f2:	4618      	mov	r0, r3
 80125f4:	3718      	adds	r7, #24
 80125f6:	46bd      	mov	sp, r7
 80125f8:	bd80      	pop	{r7, pc}
 80125fa:	bf00      	nop
 80125fc:	08022574 	.word	0x08022574
 8012600:	0802262c 	.word	0x0802262c
 8012604:	080235ec 	.word	0x080235ec
 8012608:	08022640 	.word	0x08022640
 801260c:	0802265c 	.word	0x0802265c

08012610 <OsWatchTaskCreate>:

STATIC UINT32 OsWatchTaskCreate(WatchCB *watchItem)
{
 8012610:	b580      	push	{r7, lr}
 8012612:	b08e      	sub	sp, #56	; 0x38
 8012614:	af00      	add	r7, sp, #0
 8012616:	6078      	str	r0, [r7, #4]
 8012618:	4b28      	ldr	r3, [pc, #160]	; (80126bc <OsWatchTaskCreate+0xac>)
 801261a:	681b      	ldr	r3, [r3, #0]
 801261c:	637b      	str	r3, [r7, #52]	; 0x34
 801261e:	f04f 0300 	mov.w	r3, #0
    TSK_INIT_PARAM_S initParam = {0};
 8012622:	f107 0310 	add.w	r3, r7, #16
 8012626:	2224      	movs	r2, #36	; 0x24
 8012628:	2100      	movs	r1, #0
 801262a:	4618      	mov	r0, r3
 801262c:	f7fc f90a 	bl	800e844 <memset>
    UINT32 watchTaskId = 0;
 8012630:	2300      	movs	r3, #0
 8012632:	60bb      	str	r3, [r7, #8]
    UINT32 ret;

    ret = LOS_EventInit(&watchItem->watchEvent);
 8012634:	687b      	ldr	r3, [r7, #4]
 8012636:	330c      	adds	r3, #12
 8012638:	4618      	mov	r0, r3
 801263a:	f006 f8a9 	bl	8018790 <LOS_EventInit>
 801263e:	60f8      	str	r0, [r7, #12]
    if (ret != 0) {
 8012640:	68fb      	ldr	r3, [r7, #12]
 8012642:	2b00      	cmp	r3, #0
 8012644:	d009      	beq.n	801265a <OsWatchTaskCreate+0x4a>
        PRINT_ERR("Watch event init failed in %s, %d\n", __FUNCTION__, __LINE__);
 8012646:	481e      	ldr	r0, [pc, #120]	; (80126c0 <OsWatchTaskCreate+0xb0>)
 8012648:	f7f2 f840 	bl	80046cc <dprintf>
 801264c:	22c7      	movs	r2, #199	; 0xc7
 801264e:	491d      	ldr	r1, [pc, #116]	; (80126c4 <OsWatchTaskCreate+0xb4>)
 8012650:	481d      	ldr	r0, [pc, #116]	; (80126c8 <OsWatchTaskCreate+0xb8>)
 8012652:	f7f2 f83b 	bl	80046cc <dprintf>
        return ret;
 8012656:	68fb      	ldr	r3, [r7, #12]
 8012658:	e024      	b.n	80126a4 <OsWatchTaskCreate+0x94>
    }

    initParam.pfnTaskEntry = (TSK_ENTRY_FUNC)OsShellCmdDoWatch;
 801265a:	4b1c      	ldr	r3, [pc, #112]	; (80126cc <OsWatchTaskCreate+0xbc>)
 801265c:	613b      	str	r3, [r7, #16]
    initParam.usTaskPrio   = 10; /* 10:shellcmd_watch task priority */
 801265e:	230a      	movs	r3, #10
 8012660:	82bb      	strh	r3, [r7, #20]
    initParam.uwStackSize  = 0x3000; /* 0x3000:stack size of shellcmd_watch task */
 8012662:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8012666:	62bb      	str	r3, [r7, #40]	; 0x28
    initParam.pcName       = "shellcmd_watch";
 8012668:	4b19      	ldr	r3, [pc, #100]	; (80126d0 <OsWatchTaskCreate+0xc0>)
 801266a:	62fb      	str	r3, [r7, #44]	; 0x2c
    initParam.uwResved     = LOS_TASK_STATUS_DETACHED;
 801266c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8012670:	633b      	str	r3, [r7, #48]	; 0x30
    LOS_TASK_PARAM_INIT_ARG(initParam, watchItem);
 8012672:	687b      	ldr	r3, [r7, #4]
 8012674:	61bb      	str	r3, [r7, #24]

    ret = LOS_TaskCreate(&watchTaskId, &initParam);
 8012676:	f107 0210 	add.w	r2, r7, #16
 801267a:	f107 0308 	add.w	r3, r7, #8
 801267e:	4611      	mov	r1, r2
 8012680:	4618      	mov	r0, r3
 8012682:	f7f1 f959 	bl	8003938 <LOS_TaskCreate>
 8012686:	60f8      	str	r0, [r7, #12]
    if (ret != 0) {
 8012688:	68fb      	ldr	r3, [r7, #12]
 801268a:	2b00      	cmp	r3, #0
 801268c:	d009      	beq.n	80126a2 <OsWatchTaskCreate+0x92>
        PRINT_ERR("Watch task init failed in %s, %d\n", __FUNCTION__, __LINE__);
 801268e:	480c      	ldr	r0, [pc, #48]	; (80126c0 <OsWatchTaskCreate+0xb0>)
 8012690:	f7f2 f81c 	bl	80046cc <dprintf>
 8012694:	22d4      	movs	r2, #212	; 0xd4
 8012696:	490b      	ldr	r1, [pc, #44]	; (80126c4 <OsWatchTaskCreate+0xb4>)
 8012698:	480e      	ldr	r0, [pc, #56]	; (80126d4 <OsWatchTaskCreate+0xc4>)
 801269a:	f7f2 f817 	bl	80046cc <dprintf>
        return ret;
 801269e:	68fb      	ldr	r3, [r7, #12]
 80126a0:	e000      	b.n	80126a4 <OsWatchTaskCreate+0x94>
    }
    return ret;
 80126a2:	68fb      	ldr	r3, [r7, #12]
}
 80126a4:	4a05      	ldr	r2, [pc, #20]	; (80126bc <OsWatchTaskCreate+0xac>)
 80126a6:	6811      	ldr	r1, [r2, #0]
 80126a8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80126aa:	4051      	eors	r1, r2
 80126ac:	d001      	beq.n	80126b2 <OsWatchTaskCreate+0xa2>
 80126ae:	f7f1 fe9b 	bl	80043e8 <__stack_chk_fail>
 80126b2:	4618      	mov	r0, r3
 80126b4:	3738      	adds	r7, #56	; 0x38
 80126b6:	46bd      	mov	sp, r7
 80126b8:	bd80      	pop	{r7, pc}
 80126ba:	bf00      	nop
 80126bc:	080226b8 	.word	0x080226b8
 80126c0:	08022574 	.word	0x08022574
 80126c4:	08023600 	.word	0x08023600
 80126c8:	08022660 	.word	0x08022660
 80126cc:	080121ed 	.word	0x080121ed
 80126d0:	08022684 	.word	0x08022684
 80126d4:	08022694 	.word	0x08022694

080126d8 <OsShellCmdWatch>:

UINT32 OsShellCmdWatch(UINT32 argc, const CHAR **argv)
{
 80126d8:	b580      	push	{r7, lr}
 80126da:	b088      	sub	sp, #32
 80126dc:	af00      	add	r7, sp, #0
 80126de:	6078      	str	r0, [r7, #4]
 80126e0:	6039      	str	r1, [r7, #0]
 80126e2:	4b40      	ldr	r3, [pc, #256]	; (80127e4 <OsShellCmdWatch+0x10c>)
 80126e4:	681b      	ldr	r3, [r3, #0]
 80126e6:	61fb      	str	r3, [r7, #28]
 80126e8:	f04f 0300 	mov.w	r3, #0
    WatchCB *watchItem = NULL;
 80126ec:	2300      	movs	r3, #0
 80126ee:	613b      	str	r3, [r7, #16]
    UINT32 argoff = 0;
 80126f0:	2300      	movs	r3, #0
 80126f2:	60fb      	str	r3, [r7, #12]
    UINT32 ret;
    INT32 err;

    if (argc == 0) {
 80126f4:	687b      	ldr	r3, [r7, #4]
 80126f6:	2b00      	cmp	r3, #0
 80126f8:	d104      	bne.n	8012704 <OsShellCmdWatch+0x2c>
        OsWatchCmdUsage();
 80126fa:	f7ff fdbf 	bl	801227c <OsWatchCmdUsage>
        return OS_ERROR;
 80126fe:	f04f 33ff 	mov.w	r3, #4294967295
 8012702:	e063      	b.n	80127cc <OsShellCmdWatch+0xf4>
    }

    if ((argc == 1) && (strcmp(argv[0], "--over") == 0)) {
 8012704:	687b      	ldr	r3, [r7, #4]
 8012706:	2b01      	cmp	r3, #1
 8012708:	d10d      	bne.n	8012726 <OsShellCmdWatch+0x4e>
 801270a:	683b      	ldr	r3, [r7, #0]
 801270c:	681b      	ldr	r3, [r3, #0]
 801270e:	4936      	ldr	r1, [pc, #216]	; (80127e8 <OsShellCmdWatch+0x110>)
 8012710:	4618      	mov	r0, r3
 8012712:	f7fc f998 	bl	800ea46 <strcmp>
 8012716:	4603      	mov	r3, r0
 8012718:	2b00      	cmp	r3, #0
 801271a:	d104      	bne.n	8012726 <OsShellCmdWatch+0x4e>
        ret = OsWatchOverFunc();
 801271c:	f7ff fdbc 	bl	8012298 <OsWatchOverFunc>
 8012720:	6178      	str	r0, [r7, #20]
        return ret;
 8012722:	697b      	ldr	r3, [r7, #20]
 8012724:	e052      	b.n	80127cc <OsShellCmdWatch+0xf4>
    }

    if (g_watchCmd != NULL) {
 8012726:	4b31      	ldr	r3, [pc, #196]	; (80127ec <OsShellCmdWatch+0x114>)
 8012728:	681b      	ldr	r3, [r3, #0]
 801272a:	2b00      	cmp	r3, #0
 801272c:	d005      	beq.n	801273a <OsShellCmdWatch+0x62>
        PRINTK("Please turn off previous watch before to start a new watch.\n");
 801272e:	4830      	ldr	r0, [pc, #192]	; (80127f0 <OsShellCmdWatch+0x118>)
 8012730:	f7f1 ffcc 	bl	80046cc <dprintf>
        return OS_ERROR;
 8012734:	f04f 33ff 	mov.w	r3, #4294967295
 8012738:	e048      	b.n	80127cc <OsShellCmdWatch+0xf4>
    }

    watchItem = (WatchCB *)malloc(sizeof(WatchCB));
 801273a:	f44f 7094 	mov.w	r0, #296	; 0x128
 801273e:	f008 f85d 	bl	801a7fc <malloc>
 8012742:	6138      	str	r0, [r7, #16]
    if (watchItem == NULL) {
 8012744:	693b      	ldr	r3, [r7, #16]
 8012746:	2b00      	cmp	r3, #0
 8012748:	d105      	bne.n	8012756 <OsShellCmdWatch+0x7e>
        PRINTK("Malloc error!\n");
 801274a:	482a      	ldr	r0, [pc, #168]	; (80127f4 <OsShellCmdWatch+0x11c>)
 801274c:	f7f1 ffbe 	bl	80046cc <dprintf>
        return OS_ERROR;
 8012750:	f04f 33ff 	mov.w	r3, #4294967295
 8012754:	e03a      	b.n	80127cc <OsShellCmdWatch+0xf4>
    }
    (VOID)memset_s(watchItem, sizeof(WatchCB), 0, sizeof(WatchCB));
 8012756:	f44f 7394 	mov.w	r3, #296	; 0x128
 801275a:	2200      	movs	r2, #0
 801275c:	f44f 7194 	mov.w	r1, #296	; 0x128
 8012760:	6938      	ldr	r0, [r7, #16]
 8012762:	f003 fc93 	bl	801608c <memset_s>
    watchItem->title = TRUE;
 8012766:	693b      	ldr	r3, [r7, #16]
 8012768:	2201      	movs	r2, #1
 801276a:	601a      	str	r2, [r3, #0]
    watchItem->count = WATCH_COUNT_MAX;
 801276c:	693b      	ldr	r3, [r7, #16]
 801276e:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8012772:	605a      	str	r2, [r3, #4]
    watchItem->interval = g_tickPerSecond;
 8012774:	4b20      	ldr	r3, [pc, #128]	; (80127f8 <OsShellCmdWatch+0x120>)
 8012776:	681a      	ldr	r2, [r3, #0]
 8012778:	693b      	ldr	r3, [r7, #16]
 801277a:	609a      	str	r2, [r3, #8]

    err = OsWatchOptionParsed(argc, &argoff, argv, watchItem);
 801277c:	f107 010c 	add.w	r1, r7, #12
 8012780:	693b      	ldr	r3, [r7, #16]
 8012782:	683a      	ldr	r2, [r7, #0]
 8012784:	6878      	ldr	r0, [r7, #4]
 8012786:	f7ff fdb9 	bl	80122fc <OsWatchOptionParsed>
 801278a:	61b8      	str	r0, [r7, #24]
    if (err != 0) {
 801278c:	69bb      	ldr	r3, [r7, #24]
 801278e:	2b00      	cmp	r3, #0
 8012790:	d112      	bne.n	80127b8 <OsShellCmdWatch+0xe0>
        goto WATCH_ERROR;
    }

    err = OsWatchCmdSplice(argc, argoff, argv, watchItem);
 8012792:	68f9      	ldr	r1, [r7, #12]
 8012794:	693b      	ldr	r3, [r7, #16]
 8012796:	683a      	ldr	r2, [r7, #0]
 8012798:	6878      	ldr	r0, [r7, #4]
 801279a:	f7ff fed9 	bl	8012550 <OsWatchCmdSplice>
 801279e:	61b8      	str	r0, [r7, #24]
    if (err != 0) {
 80127a0:	69bb      	ldr	r3, [r7, #24]
 80127a2:	2b00      	cmp	r3, #0
 80127a4:	d10a      	bne.n	80127bc <OsShellCmdWatch+0xe4>
        goto WATCH_ERROR;
    }

    ret = OsWatchTaskCreate(watchItem);
 80127a6:	6938      	ldr	r0, [r7, #16]
 80127a8:	f7ff ff32 	bl	8012610 <OsWatchTaskCreate>
 80127ac:	6178      	str	r0, [r7, #20]
    if (ret != 0) {
 80127ae:	697b      	ldr	r3, [r7, #20]
 80127b0:	2b00      	cmp	r3, #0
 80127b2:	d105      	bne.n	80127c0 <OsShellCmdWatch+0xe8>
        goto WATCH_ERROR;
    }

    return LOS_OK;
 80127b4:	2300      	movs	r3, #0
 80127b6:	e009      	b.n	80127cc <OsShellCmdWatch+0xf4>
        goto WATCH_ERROR;
 80127b8:	bf00      	nop
 80127ba:	e002      	b.n	80127c2 <OsShellCmdWatch+0xea>
        goto WATCH_ERROR;
 80127bc:	bf00      	nop
 80127be:	e000      	b.n	80127c2 <OsShellCmdWatch+0xea>
        goto WATCH_ERROR;
 80127c0:	bf00      	nop

WATCH_ERROR:
    free(watchItem);
 80127c2:	6938      	ldr	r0, [r7, #16]
 80127c4:	f008 f806 	bl	801a7d4 <free>
    return OS_ERROR;
 80127c8:	f04f 33ff 	mov.w	r3, #4294967295
}
 80127cc:	4a05      	ldr	r2, [pc, #20]	; (80127e4 <OsShellCmdWatch+0x10c>)
 80127ce:	6811      	ldr	r1, [r2, #0]
 80127d0:	69fa      	ldr	r2, [r7, #28]
 80127d2:	4051      	eors	r1, r2
 80127d4:	d001      	beq.n	80127da <OsShellCmdWatch+0x102>
 80127d6:	f7f1 fe07 	bl	80043e8 <__stack_chk_fail>
 80127da:	4618      	mov	r0, r3
 80127dc:	3720      	adds	r7, #32
 80127de:	46bd      	mov	sp, r7
 80127e0:	bd80      	pop	{r7, pc}
 80127e2:	bf00      	nop
 80127e4:	08022714 	.word	0x08022714
 80127e8:	080226bc 	.word	0x080226bc
 80127ec:	200032bc 	.word	0x200032bc
 80127f0:	080226c4 	.word	0x080226c4
 80127f4:	08022704 	.word	0x08022704
 80127f8:	200036e4 	.word	0x200036e4

080127fc <LOS_ListAdd>:
{
 80127fc:	b480      	push	{r7}
 80127fe:	b083      	sub	sp, #12
 8012800:	af00      	add	r7, sp, #0
 8012802:	6078      	str	r0, [r7, #4]
 8012804:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 8012806:	687b      	ldr	r3, [r7, #4]
 8012808:	685a      	ldr	r2, [r3, #4]
 801280a:	683b      	ldr	r3, [r7, #0]
 801280c:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 801280e:	683b      	ldr	r3, [r7, #0]
 8012810:	687a      	ldr	r2, [r7, #4]
 8012812:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8012814:	687b      	ldr	r3, [r7, #4]
 8012816:	685b      	ldr	r3, [r3, #4]
 8012818:	683a      	ldr	r2, [r7, #0]
 801281a:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 801281c:	687b      	ldr	r3, [r7, #4]
 801281e:	683a      	ldr	r2, [r7, #0]
 8012820:	605a      	str	r2, [r3, #4]
}
 8012822:	bf00      	nop
 8012824:	370c      	adds	r7, #12
 8012826:	46bd      	mov	sp, r7
 8012828:	f85d 7b04 	ldr.w	r7, [sp], #4
 801282c:	4770      	bx	lr

0801282e <LOS_ListTailInsert>:
{
 801282e:	b580      	push	{r7, lr}
 8012830:	b082      	sub	sp, #8
 8012832:	af00      	add	r7, sp, #0
 8012834:	6078      	str	r0, [r7, #4]
 8012836:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 8012838:	687b      	ldr	r3, [r7, #4]
 801283a:	681b      	ldr	r3, [r3, #0]
 801283c:	6839      	ldr	r1, [r7, #0]
 801283e:	4618      	mov	r0, r3
 8012840:	f7ff ffdc 	bl	80127fc <LOS_ListAdd>
}
 8012844:	bf00      	nop
 8012846:	3708      	adds	r7, #8
 8012848:	46bd      	mov	sp, r7
 801284a:	bd80      	pop	{r7, pc}

0801284c <LOS_ListDelete>:
{
 801284c:	b480      	push	{r7}
 801284e:	b083      	sub	sp, #12
 8012850:	af00      	add	r7, sp, #0
 8012852:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8012854:	687b      	ldr	r3, [r7, #4]
 8012856:	685b      	ldr	r3, [r3, #4]
 8012858:	687a      	ldr	r2, [r7, #4]
 801285a:	6812      	ldr	r2, [r2, #0]
 801285c:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 801285e:	687b      	ldr	r3, [r7, #4]
 8012860:	681b      	ldr	r3, [r3, #0]
 8012862:	687a      	ldr	r2, [r7, #4]
 8012864:	6852      	ldr	r2, [r2, #4]
 8012866:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8012868:	687b      	ldr	r3, [r7, #4]
 801286a:	2200      	movs	r2, #0
 801286c:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 801286e:	687b      	ldr	r3, [r7, #4]
 8012870:	2200      	movs	r2, #0
 8012872:	601a      	str	r2, [r3, #0]
}
 8012874:	bf00      	nop
 8012876:	370c      	adds	r7, #12
 8012878:	46bd      	mov	sp, r7
 801287a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801287e:	4770      	bx	lr

08012880 <LOS_ListEmpty>:
{
 8012880:	b480      	push	{r7}
 8012882:	b083      	sub	sp, #12
 8012884:	af00      	add	r7, sp, #0
 8012886:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8012888:	687b      	ldr	r3, [r7, #4]
 801288a:	685b      	ldr	r3, [r3, #4]
 801288c:	687a      	ldr	r2, [r7, #4]
 801288e:	429a      	cmp	r2, r3
 8012890:	bf0c      	ite	eq
 8012892:	2301      	moveq	r3, #1
 8012894:	2300      	movne	r3, #0
 8012896:	b2db      	uxtb	r3, r3
}
 8012898:	4618      	mov	r0, r3
 801289a:	370c      	adds	r7, #12
 801289c:	46bd      	mov	sp, r7
 801289e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128a2:	4770      	bx	lr

080128a4 <ShellGetInputBuf>:

#define SHELL_TASK_PRIORITY     9
#define SHELL_ENTRY_PRIORITY    9

CHAR *ShellGetInputBuf(ShellCB *shellCB)
{
 80128a4:	b580      	push	{r7, lr}
 80128a6:	b088      	sub	sp, #32
 80128a8:	af00      	add	r7, sp, #0
 80128aa:	6078      	str	r0, [r7, #4]
    CmdKeyLink *cmdKey = shellCB->cmdKeyLink;
 80128ac:	687b      	ldr	r3, [r7, #4]
 80128ae:	68db      	ldr	r3, [r3, #12]
 80128b0:	60fb      	str	r3, [r7, #12]
    CmdKeyLink *cmdNode = NULL;
 80128b2:	2300      	movs	r3, #0
 80128b4:	613b      	str	r3, [r7, #16]

    KEY_LOCK(shellCB);
 80128b6:	687b      	ldr	r3, [r7, #4]
 80128b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80128ba:	f04f 31ff 	mov.w	r1, #4294967295
 80128be:	4618      	mov	r0, r3
 80128c0:	f7f8 fafe 	bl	800aec0 <LOS_MuxPend>
 80128c4:	6178      	str	r0, [r7, #20]
 80128c6:	697b      	ldr	r3, [r7, #20]
 80128c8:	2b00      	cmp	r3, #0
 80128ca:	d008      	beq.n	80128de <ShellGetInputBuf+0x3a>
 80128cc:	4824      	ldr	r0, [pc, #144]	; (8012960 <ShellGetInputBuf+0xbc>)
 80128ce:	f7f1 fefd 	bl	80046cc <dprintf>
 80128d2:	697b      	ldr	r3, [r7, #20]
 80128d4:	2248      	movs	r2, #72	; 0x48
 80128d6:	4923      	ldr	r1, [pc, #140]	; (8012964 <ShellGetInputBuf+0xc0>)
 80128d8:	4823      	ldr	r0, [pc, #140]	; (8012968 <ShellGetInputBuf+0xc4>)
 80128da:	f7f1 fef7 	bl	80046cc <dprintf>
    if ((cmdKey == NULL) || LOS_ListEmpty(&cmdKey->list)) {
 80128de:	68fb      	ldr	r3, [r7, #12]
 80128e0:	2b00      	cmp	r3, #0
 80128e2:	d007      	beq.n	80128f4 <ShellGetInputBuf+0x50>
 80128e4:	68fb      	ldr	r3, [r7, #12]
 80128e6:	3304      	adds	r3, #4
 80128e8:	4618      	mov	r0, r3
 80128ea:	f7ff ffc9 	bl	8012880 <LOS_ListEmpty>
 80128ee:	4603      	mov	r3, r0
 80128f0:	2b00      	cmp	r3, #0
 80128f2:	d013      	beq.n	801291c <ShellGetInputBuf+0x78>
        KEY_UNLOCK(shellCB);
 80128f4:	687b      	ldr	r3, [r7, #4]
 80128f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80128f8:	4618      	mov	r0, r3
 80128fa:	f7f8 fc61 	bl	800b1c0 <LOS_MuxPost>
 80128fe:	61f8      	str	r0, [r7, #28]
 8012900:	69fb      	ldr	r3, [r7, #28]
 8012902:	2b00      	cmp	r3, #0
 8012904:	d008      	beq.n	8012918 <ShellGetInputBuf+0x74>
 8012906:	4816      	ldr	r0, [pc, #88]	; (8012960 <ShellGetInputBuf+0xbc>)
 8012908:	f7f1 fee0 	bl	80046cc <dprintf>
 801290c:	69fb      	ldr	r3, [r7, #28]
 801290e:	224a      	movs	r2, #74	; 0x4a
 8012910:	4914      	ldr	r1, [pc, #80]	; (8012964 <ShellGetInputBuf+0xc0>)
 8012912:	4816      	ldr	r0, [pc, #88]	; (801296c <ShellGetInputBuf+0xc8>)
 8012914:	f7f1 feda 	bl	80046cc <dprintf>
        return NULL;
 8012918:	2300      	movs	r3, #0
 801291a:	e01c      	b.n	8012956 <ShellGetInputBuf+0xb2>
    }

    cmdNode = LOS_DL_LIST_ENTRY(cmdKey->list.pstNext, CmdKeyLink, list);
 801291c:	68fb      	ldr	r3, [r7, #12]
 801291e:	689b      	ldr	r3, [r3, #8]
 8012920:	3b04      	subs	r3, #4
 8012922:	613b      	str	r3, [r7, #16]
    LOS_ListDelete(&(cmdNode->list));
 8012924:	693b      	ldr	r3, [r7, #16]
 8012926:	3304      	adds	r3, #4
 8012928:	4618      	mov	r0, r3
 801292a:	f7ff ff8f 	bl	801284c <LOS_ListDelete>
    KEY_UNLOCK(shellCB);
 801292e:	687b      	ldr	r3, [r7, #4]
 8012930:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012932:	4618      	mov	r0, r3
 8012934:	f7f8 fc44 	bl	800b1c0 <LOS_MuxPost>
 8012938:	61b8      	str	r0, [r7, #24]
 801293a:	69bb      	ldr	r3, [r7, #24]
 801293c:	2b00      	cmp	r3, #0
 801293e:	d008      	beq.n	8012952 <ShellGetInputBuf+0xae>
 8012940:	4807      	ldr	r0, [pc, #28]	; (8012960 <ShellGetInputBuf+0xbc>)
 8012942:	f7f1 fec3 	bl	80046cc <dprintf>
 8012946:	69bb      	ldr	r3, [r7, #24]
 8012948:	2250      	movs	r2, #80	; 0x50
 801294a:	4906      	ldr	r1, [pc, #24]	; (8012964 <ShellGetInputBuf+0xc0>)
 801294c:	4807      	ldr	r0, [pc, #28]	; (801296c <ShellGetInputBuf+0xc8>)
 801294e:	f7f1 febd 	bl	80046cc <dprintf>

    return cmdNode->cmdString;
 8012952:	693b      	ldr	r3, [r7, #16]
 8012954:	330c      	adds	r3, #12
}
 8012956:	4618      	mov	r0, r3
 8012958:	3720      	adds	r7, #32
 801295a:	46bd      	mov	sp, r7
 801295c:	bd80      	pop	{r7, pc}
 801295e:	bf00      	nop
 8012960:	08022720 	.word	0x08022720
 8012964:	08023614 	.word	0x08023614
 8012968:	08022728 	.word	0x08022728
 801296c:	0802274c 	.word	0x0802274c

08012970 <ShellSaveHistoryCmd>:

STATIC VOID ShellSaveHistoryCmd(CHAR *string, ShellCB *shellCB)
{
 8012970:	b580      	push	{r7, lr}
 8012972:	b088      	sub	sp, #32
 8012974:	af00      	add	r7, sp, #0
 8012976:	6078      	str	r0, [r7, #4]
 8012978:	6039      	str	r1, [r7, #0]
    CmdKeyLink *cmdHistory = shellCB->cmdHistoryKeyLink;
 801297a:	683b      	ldr	r3, [r7, #0]
 801297c:	691b      	ldr	r3, [r3, #16]
 801297e:	60fb      	str	r3, [r7, #12]
    CmdKeyLink *cmdKey = LOS_DL_LIST_ENTRY(string, CmdKeyLink, cmdString);
 8012980:	687b      	ldr	r3, [r7, #4]
 8012982:	3b0c      	subs	r3, #12
 8012984:	613b      	str	r3, [r7, #16]
    CmdKeyLink *cmdNxt = NULL;
 8012986:	2300      	movs	r3, #0
 8012988:	617b      	str	r3, [r7, #20]

    if ((string == NULL) || (strlen(string) == 0)) {
 801298a:	687b      	ldr	r3, [r7, #4]
 801298c:	2b00      	cmp	r3, #0
 801298e:	d06d      	beq.n	8012a6c <ShellSaveHistoryCmd+0xfc>
 8012990:	6878      	ldr	r0, [r7, #4]
 8012992:	f7fc f87a 	bl	800ea8a <strlen>
 8012996:	4603      	mov	r3, r0
 8012998:	2b00      	cmp	r3, #0
 801299a:	d067      	beq.n	8012a6c <ShellSaveHistoryCmd+0xfc>
        return;
    }

    HISTORY_LOCK(shellCB);
 801299c:	683b      	ldr	r3, [r7, #0]
 801299e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80129a0:	f04f 31ff 	mov.w	r1, #4294967295
 80129a4:	4618      	mov	r0, r3
 80129a6:	f7f8 fa8b 	bl	800aec0 <LOS_MuxPend>
 80129aa:	61b8      	str	r0, [r7, #24]
 80129ac:	69bb      	ldr	r3, [r7, #24]
 80129ae:	2b00      	cmp	r3, #0
 80129b0:	d008      	beq.n	80129c4 <ShellSaveHistoryCmd+0x54>
 80129b2:	4831      	ldr	r0, [pc, #196]	; (8012a78 <ShellSaveHistoryCmd+0x108>)
 80129b4:	f7f1 fe8a 	bl	80046cc <dprintf>
 80129b8:	69bb      	ldr	r3, [r7, #24]
 80129ba:	225f      	movs	r2, #95	; 0x5f
 80129bc:	492f      	ldr	r1, [pc, #188]	; (8012a7c <ShellSaveHistoryCmd+0x10c>)
 80129be:	4830      	ldr	r0, [pc, #192]	; (8012a80 <ShellSaveHistoryCmd+0x110>)
 80129c0:	f7f1 fe84 	bl	80046cc <dprintf>

    if (cmdHistory->count != 0) {
 80129c4:	68fb      	ldr	r3, [r7, #12]
 80129c6:	681b      	ldr	r3, [r3, #0]
 80129c8:	2b00      	cmp	r3, #0
 80129ca:	d013      	beq.n	80129f4 <ShellSaveHistoryCmd+0x84>
        cmdNxt = LOS_DL_LIST_ENTRY(cmdHistory->list.pstPrev, CmdKeyLink, list);
 80129cc:	68fb      	ldr	r3, [r7, #12]
 80129ce:	685b      	ldr	r3, [r3, #4]
 80129d0:	3b04      	subs	r3, #4
 80129d2:	617b      	str	r3, [r7, #20]
        if (strcmp(string, cmdNxt->cmdString) == 0) {
 80129d4:	697b      	ldr	r3, [r7, #20]
 80129d6:	330c      	adds	r3, #12
 80129d8:	4619      	mov	r1, r3
 80129da:	6878      	ldr	r0, [r7, #4]
 80129dc:	f7fc f833 	bl	800ea46 <strcmp>
 80129e0:	4603      	mov	r3, r0
 80129e2:	2b00      	cmp	r3, #0
 80129e4:	d106      	bne.n	80129f4 <ShellSaveHistoryCmd+0x84>
            (VOID)LOS_MemFree(m_aucSysMem0, (VOID *)cmdKey);
 80129e6:	4b27      	ldr	r3, [pc, #156]	; (8012a84 <ShellSaveHistoryCmd+0x114>)
 80129e8:	681b      	ldr	r3, [r3, #0]
 80129ea:	6939      	ldr	r1, [r7, #16]
 80129ec:	4618      	mov	r0, r3
 80129ee:	f7f6 f893 	bl	8008b18 <LOS_MemFree>
            goto END;
 80129f2:	e028      	b.n	8012a46 <ShellSaveHistoryCmd+0xd6>
        }
    }

    if (cmdHistory->count == CMD_HISTORY_LEN) {
 80129f4:	68fb      	ldr	r3, [r7, #12]
 80129f6:	681b      	ldr	r3, [r3, #0]
 80129f8:	2b0a      	cmp	r3, #10
 80129fa:	d117      	bne.n	8012a2c <ShellSaveHistoryCmd+0xbc>
        cmdNxt = LOS_DL_LIST_ENTRY(cmdHistory->list.pstNext, CmdKeyLink, list);
 80129fc:	68fb      	ldr	r3, [r7, #12]
 80129fe:	689b      	ldr	r3, [r3, #8]
 8012a00:	3b04      	subs	r3, #4
 8012a02:	617b      	str	r3, [r7, #20]
        LOS_ListDelete(&cmdNxt->list);
 8012a04:	697b      	ldr	r3, [r7, #20]
 8012a06:	3304      	adds	r3, #4
 8012a08:	4618      	mov	r0, r3
 8012a0a:	f7ff ff1f 	bl	801284c <LOS_ListDelete>
        LOS_ListTailInsert(&cmdHistory->list, &cmdKey->list);
 8012a0e:	68fb      	ldr	r3, [r7, #12]
 8012a10:	1d1a      	adds	r2, r3, #4
 8012a12:	693b      	ldr	r3, [r7, #16]
 8012a14:	3304      	adds	r3, #4
 8012a16:	4619      	mov	r1, r3
 8012a18:	4610      	mov	r0, r2
 8012a1a:	f7ff ff08 	bl	801282e <LOS_ListTailInsert>
        (VOID)LOS_MemFree(m_aucSysMem0, (VOID *)cmdNxt);
 8012a1e:	4b19      	ldr	r3, [pc, #100]	; (8012a84 <ShellSaveHistoryCmd+0x114>)
 8012a20:	681b      	ldr	r3, [r3, #0]
 8012a22:	6979      	ldr	r1, [r7, #20]
 8012a24:	4618      	mov	r0, r3
 8012a26:	f7f6 f877 	bl	8008b18 <LOS_MemFree>
        goto END;
 8012a2a:	e00c      	b.n	8012a46 <ShellSaveHistoryCmd+0xd6>
    }

    LOS_ListTailInsert(&cmdHistory->list, &cmdKey->list);
 8012a2c:	68fb      	ldr	r3, [r7, #12]
 8012a2e:	1d1a      	adds	r2, r3, #4
 8012a30:	693b      	ldr	r3, [r7, #16]
 8012a32:	3304      	adds	r3, #4
 8012a34:	4619      	mov	r1, r3
 8012a36:	4610      	mov	r0, r2
 8012a38:	f7ff fef9 	bl	801282e <LOS_ListTailInsert>
    cmdHistory->count++;
 8012a3c:	68fb      	ldr	r3, [r7, #12]
 8012a3e:	681b      	ldr	r3, [r3, #0]
 8012a40:	1c5a      	adds	r2, r3, #1
 8012a42:	68fb      	ldr	r3, [r7, #12]
 8012a44:	601a      	str	r2, [r3, #0]

END:
    HISTORY_UNLOCK(shellCB);
 8012a46:	683b      	ldr	r3, [r7, #0]
 8012a48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012a4a:	4618      	mov	r0, r3
 8012a4c:	f7f8 fbb8 	bl	800b1c0 <LOS_MuxPost>
 8012a50:	61f8      	str	r0, [r7, #28]
 8012a52:	69fb      	ldr	r3, [r7, #28]
 8012a54:	2b00      	cmp	r3, #0
 8012a56:	d00b      	beq.n	8012a70 <ShellSaveHistoryCmd+0x100>
 8012a58:	4807      	ldr	r0, [pc, #28]	; (8012a78 <ShellSaveHistoryCmd+0x108>)
 8012a5a:	f7f1 fe37 	bl	80046cc <dprintf>
 8012a5e:	69fb      	ldr	r3, [r7, #28]
 8012a60:	2275      	movs	r2, #117	; 0x75
 8012a62:	4906      	ldr	r1, [pc, #24]	; (8012a7c <ShellSaveHistoryCmd+0x10c>)
 8012a64:	4808      	ldr	r0, [pc, #32]	; (8012a88 <ShellSaveHistoryCmd+0x118>)
 8012a66:	f7f1 fe31 	bl	80046cc <dprintf>
    return;
 8012a6a:	e001      	b.n	8012a70 <ShellSaveHistoryCmd+0x100>
        return;
 8012a6c:	bf00      	nop
 8012a6e:	e000      	b.n	8012a72 <ShellSaveHistoryCmd+0x102>
    return;
 8012a70:	bf00      	nop
}
 8012a72:	3720      	adds	r7, #32
 8012a74:	46bd      	mov	sp, r7
 8012a76:	bd80      	pop	{r7, pc}
 8012a78:	08022720 	.word	0x08022720
 8012a7c:	08023628 	.word	0x08023628
 8012a80:	08022728 	.word	0x08022728
 8012a84:	200021b4 	.word	0x200021b4
 8012a88:	0802274c 	.word	0x0802274c

08012a8c <ShellNotify>:

STATIC VOID ShellNotify(ShellCB *shellCB)
{
 8012a8c:	b580      	push	{r7, lr}
 8012a8e:	b082      	sub	sp, #8
 8012a90:	af00      	add	r7, sp, #0
 8012a92:	6078      	str	r0, [r7, #4]
    (VOID)LOS_EventWrite(&shellCB->shellEvent, SHELL_CMD_PARSE_EVENT);
 8012a94:	687b      	ldr	r3, [r7, #4]
 8012a96:	3320      	adds	r3, #32
 8012a98:	f240 1111 	movw	r1, #273	; 0x111
 8012a9c:	4618      	mov	r0, r3
 8012a9e:	f006 f91f 	bl	8018ce0 <LOS_EventWrite>
}
 8012aa2:	bf00      	nop
 8012aa4:	3708      	adds	r7, #8
 8012aa6:	46bd      	mov	sp, r7
 8012aa8:	bd80      	pop	{r7, pc}

08012aaa <ShellCmdLineCheckUDRL>:
    CMD_KEY_LEFT_VALUE  = 0x44,
    CMD_KEY_COMBINATION_VALUE = 0x5b
};

STATIC INT32 ShellCmdLineCheckUDRL(const CHAR ch, ShellCB *shellCB)
{
 8012aaa:	b580      	push	{r7, lr}
 8012aac:	b084      	sub	sp, #16
 8012aae:	af00      	add	r7, sp, #0
 8012ab0:	4603      	mov	r3, r0
 8012ab2:	6039      	str	r1, [r7, #0]
 8012ab4:	71fb      	strb	r3, [r7, #7]
    INT32 ret = LOS_OK;
 8012ab6:	2300      	movs	r3, #0
 8012ab8:	60fb      	str	r3, [r7, #12]
    if (ch == CMD_KEY_ESC_VALUE) {
 8012aba:	79fb      	ldrb	r3, [r7, #7]
 8012abc:	2b1b      	cmp	r3, #27
 8012abe:	d104      	bne.n	8012aca <ShellCmdLineCheckUDRL+0x20>
        shellCB->shellKeyType = STAT_ESC_KEY;
 8012ac0:	683b      	ldr	r3, [r7, #0]
 8012ac2:	2201      	movs	r2, #1
 8012ac4:	61da      	str	r2, [r3, #28]
        return ret;
 8012ac6:	68fb      	ldr	r3, [r7, #12]
 8012ac8:	e044      	b.n	8012b54 <ShellCmdLineCheckUDRL+0xaa>
    } else if (ch == CMD_KEY_COMBINATION_VALUE) {
 8012aca:	79fb      	ldrb	r3, [r7, #7]
 8012acc:	2b5b      	cmp	r3, #91	; 0x5b
 8012ace:	d108      	bne.n	8012ae2 <ShellCmdLineCheckUDRL+0x38>
        if (shellCB->shellKeyType == STAT_ESC_KEY) {
 8012ad0:	683b      	ldr	r3, [r7, #0]
 8012ad2:	69db      	ldr	r3, [r3, #28]
 8012ad4:	2b01      	cmp	r3, #1
 8012ad6:	d13c      	bne.n	8012b52 <ShellCmdLineCheckUDRL+0xa8>
            shellCB->shellKeyType = STAT_MULTI_KEY;
 8012ad8:	683b      	ldr	r3, [r7, #0]
 8012ada:	2202      	movs	r2, #2
 8012adc:	61da      	str	r2, [r3, #28]
            return ret;
 8012ade:	68fb      	ldr	r3, [r7, #12]
 8012ae0:	e038      	b.n	8012b54 <ShellCmdLineCheckUDRL+0xaa>
        }
    } else if (ch == CMD_KEY_UP_VALUE) {
 8012ae2:	79fb      	ldrb	r3, [r7, #7]
 8012ae4:	2b41      	cmp	r3, #65	; 0x41
 8012ae6:	d10c      	bne.n	8012b02 <ShellCmdLineCheckUDRL+0x58>
        if (shellCB->shellKeyType == STAT_MULTI_KEY) {
 8012ae8:	683b      	ldr	r3, [r7, #0]
 8012aea:	69db      	ldr	r3, [r3, #28]
 8012aec:	2b02      	cmp	r3, #2
 8012aee:	d130      	bne.n	8012b52 <ShellCmdLineCheckUDRL+0xa8>
            OsShellHistoryShow(CMD_KEY_UP, shellCB);
 8012af0:	6839      	ldr	r1, [r7, #0]
 8012af2:	2000      	movs	r0, #0
 8012af4:	f7fe fe90 	bl	8011818 <OsShellHistoryShow>
            shellCB->shellKeyType = STAT_NOMAL_KEY;
 8012af8:	683b      	ldr	r3, [r7, #0]
 8012afa:	2200      	movs	r2, #0
 8012afc:	61da      	str	r2, [r3, #28]
            return ret;
 8012afe:	68fb      	ldr	r3, [r7, #12]
 8012b00:	e028      	b.n	8012b54 <ShellCmdLineCheckUDRL+0xaa>
        }
    } else if (ch == CMD_KEY_DOWN_VALUE) {
 8012b02:	79fb      	ldrb	r3, [r7, #7]
 8012b04:	2b42      	cmp	r3, #66	; 0x42
 8012b06:	d10c      	bne.n	8012b22 <ShellCmdLineCheckUDRL+0x78>
        if (shellCB->shellKeyType == STAT_MULTI_KEY) {
 8012b08:	683b      	ldr	r3, [r7, #0]
 8012b0a:	69db      	ldr	r3, [r3, #28]
 8012b0c:	2b02      	cmp	r3, #2
 8012b0e:	d120      	bne.n	8012b52 <ShellCmdLineCheckUDRL+0xa8>
            shellCB->shellKeyType = STAT_NOMAL_KEY;
 8012b10:	683b      	ldr	r3, [r7, #0]
 8012b12:	2200      	movs	r2, #0
 8012b14:	61da      	str	r2, [r3, #28]
            OsShellHistoryShow(CMD_KEY_DOWN, shellCB);
 8012b16:	6839      	ldr	r1, [r7, #0]
 8012b18:	2001      	movs	r0, #1
 8012b1a:	f7fe fe7d 	bl	8011818 <OsShellHistoryShow>
            return ret;
 8012b1e:	68fb      	ldr	r3, [r7, #12]
 8012b20:	e018      	b.n	8012b54 <ShellCmdLineCheckUDRL+0xaa>
        }
    } else if (ch == CMD_KEY_RIGHT_VALUE) {
 8012b22:	79fb      	ldrb	r3, [r7, #7]
 8012b24:	2b43      	cmp	r3, #67	; 0x43
 8012b26:	d108      	bne.n	8012b3a <ShellCmdLineCheckUDRL+0x90>
        if (shellCB->shellKeyType == STAT_MULTI_KEY) {
 8012b28:	683b      	ldr	r3, [r7, #0]
 8012b2a:	69db      	ldr	r3, [r3, #28]
 8012b2c:	2b02      	cmp	r3, #2
 8012b2e:	d110      	bne.n	8012b52 <ShellCmdLineCheckUDRL+0xa8>
            shellCB->shellKeyType = STAT_NOMAL_KEY;
 8012b30:	683b      	ldr	r3, [r7, #0]
 8012b32:	2200      	movs	r2, #0
 8012b34:	61da      	str	r2, [r3, #28]
            return ret;
 8012b36:	68fb      	ldr	r3, [r7, #12]
 8012b38:	e00c      	b.n	8012b54 <ShellCmdLineCheckUDRL+0xaa>
        }
    } else if (ch == CMD_KEY_LEFT_VALUE) {
 8012b3a:	79fb      	ldrb	r3, [r7, #7]
 8012b3c:	2b44      	cmp	r3, #68	; 0x44
 8012b3e:	d108      	bne.n	8012b52 <ShellCmdLineCheckUDRL+0xa8>
        if (shellCB->shellKeyType == STAT_MULTI_KEY) {
 8012b40:	683b      	ldr	r3, [r7, #0]
 8012b42:	69db      	ldr	r3, [r3, #28]
 8012b44:	2b02      	cmp	r3, #2
 8012b46:	d104      	bne.n	8012b52 <ShellCmdLineCheckUDRL+0xa8>
            shellCB->shellKeyType = STAT_NOMAL_KEY;
 8012b48:	683b      	ldr	r3, [r7, #0]
 8012b4a:	2200      	movs	r2, #0
 8012b4c:	61da      	str	r2, [r3, #28]
            return ret;
 8012b4e:	68fb      	ldr	r3, [r7, #12]
 8012b50:	e000      	b.n	8012b54 <ShellCmdLineCheckUDRL+0xaa>
        }
    }
    return LOS_NOK;
 8012b52:	2301      	movs	r3, #1
}
 8012b54:	4618      	mov	r0, r3
 8012b56:	3710      	adds	r7, #16
 8012b58:	46bd      	mov	sp, r7
 8012b5a:	bd80      	pop	{r7, pc}

08012b5c <ShellCmdLineParse>:

LITE_OS_SEC_TEXT_MINOR VOID ShellCmdLineParse(CHAR c, pf_OUTPUT outputFunc, ShellCB *shellCB)
{
 8012b5c:	b580      	push	{r7, lr}
 8012b5e:	b088      	sub	sp, #32
 8012b60:	af00      	add	r7, sp, #0
 8012b62:	4603      	mov	r3, r0
 8012b64:	60b9      	str	r1, [r7, #8]
 8012b66:	607a      	str	r2, [r7, #4]
 8012b68:	73fb      	strb	r3, [r7, #15]
    const CHAR ch = c;
 8012b6a:	7bfb      	ldrb	r3, [r7, #15]
 8012b6c:	74fb      	strb	r3, [r7, #19]
    INT32 ret;

    if ((shellCB->shellBufOffset == 0) && (ch != '\n') && (ch != '\0')) {
 8012b6e:	687b      	ldr	r3, [r7, #4]
 8012b70:	699b      	ldr	r3, [r3, #24]
 8012b72:	2b00      	cmp	r3, #0
 8012b74:	d10f      	bne.n	8012b96 <ShellCmdLineParse+0x3a>
 8012b76:	7cfb      	ldrb	r3, [r7, #19]
 8012b78:	2b0a      	cmp	r3, #10
 8012b7a:	d00c      	beq.n	8012b96 <ShellCmdLineParse+0x3a>
 8012b7c:	7cfb      	ldrb	r3, [r7, #19]
 8012b7e:	2b00      	cmp	r3, #0
 8012b80:	d009      	beq.n	8012b96 <ShellCmdLineParse+0x3a>
        (VOID)memset_s(shellCB->shellBuf, SHOW_MAX_LEN, 0, SHOW_MAX_LEN);
 8012b82:	687b      	ldr	r3, [r7, #4]
 8012b84:	f103 0034 	add.w	r0, r3, #52	; 0x34
 8012b88:	f44f 7388 	mov.w	r3, #272	; 0x110
 8012b8c:	2200      	movs	r2, #0
 8012b8e:	f44f 7188 	mov.w	r1, #272	; 0x110
 8012b92:	f003 fa7b 	bl	801608c <memset_s>
    }

    if (ch == '\r') {
 8012b96:	7cfb      	ldrb	r3, [r7, #19]
 8012b98:	2b0d      	cmp	r3, #13
 8012b9a:	d141      	bne.n	8012c20 <ShellCmdLineParse+0xc4>
        if (shellCB->shellBufOffset < (SHOW_MAX_LEN - 1)) {
 8012b9c:	687b      	ldr	r3, [r7, #4]
 8012b9e:	699b      	ldr	r3, [r3, #24]
 8012ba0:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 8012ba4:	d806      	bhi.n	8012bb4 <ShellCmdLineParse+0x58>
            shellCB->shellBuf[shellCB->shellBufOffset] = '\0';
 8012ba6:	687b      	ldr	r3, [r7, #4]
 8012ba8:	699b      	ldr	r3, [r3, #24]
 8012baa:	687a      	ldr	r2, [r7, #4]
 8012bac:	4413      	add	r3, r2
 8012bae:	2200      	movs	r2, #0
 8012bb0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        }
        shellCB->shellBufOffset = 0;
 8012bb4:	687b      	ldr	r3, [r7, #4]
 8012bb6:	2200      	movs	r2, #0
 8012bb8:	619a      	str	r2, [r3, #24]
        KEY_LOCK(shellCB);
 8012bba:	687b      	ldr	r3, [r7, #4]
 8012bbc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012bbe:	f04f 31ff 	mov.w	r1, #4294967295
 8012bc2:	4618      	mov	r0, r3
 8012bc4:	f7f8 f97c 	bl	800aec0 <LOS_MuxPend>
 8012bc8:	61b8      	str	r0, [r7, #24]
 8012bca:	69bb      	ldr	r3, [r7, #24]
 8012bcc:	2b00      	cmp	r3, #0
 8012bce:	d008      	beq.n	8012be2 <ShellCmdLineParse+0x86>
 8012bd0:	484f      	ldr	r0, [pc, #316]	; (8012d10 <ShellCmdLineParse+0x1b4>)
 8012bd2:	f7f1 fd7b 	bl	80046cc <dprintf>
 8012bd6:	69bb      	ldr	r3, [r7, #24]
 8012bd8:	22c0      	movs	r2, #192	; 0xc0
 8012bda:	494e      	ldr	r1, [pc, #312]	; (8012d14 <ShellCmdLineParse+0x1b8>)
 8012bdc:	484e      	ldr	r0, [pc, #312]	; (8012d18 <ShellCmdLineParse+0x1bc>)
 8012bde:	f7f1 fd75 	bl	80046cc <dprintf>
        OsShellCmdPush(shellCB->shellBuf, shellCB->cmdKeyLink);
 8012be2:	687b      	ldr	r3, [r7, #4]
 8012be4:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8012be8:	687b      	ldr	r3, [r7, #4]
 8012bea:	68db      	ldr	r3, [r3, #12]
 8012bec:	4619      	mov	r1, r3
 8012bee:	4610      	mov	r0, r2
 8012bf0:	f7fe fdc4 	bl	801177c <OsShellCmdPush>
        KEY_UNLOCK(shellCB);
 8012bf4:	687b      	ldr	r3, [r7, #4]
 8012bf6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012bf8:	4618      	mov	r0, r3
 8012bfa:	f7f8 fae1 	bl	800b1c0 <LOS_MuxPost>
 8012bfe:	61f8      	str	r0, [r7, #28]
 8012c00:	69fb      	ldr	r3, [r7, #28]
 8012c02:	2b00      	cmp	r3, #0
 8012c04:	d008      	beq.n	8012c18 <ShellCmdLineParse+0xbc>
 8012c06:	4842      	ldr	r0, [pc, #264]	; (8012d10 <ShellCmdLineParse+0x1b4>)
 8012c08:	f7f1 fd60 	bl	80046cc <dprintf>
 8012c0c:	69fb      	ldr	r3, [r7, #28]
 8012c0e:	22c2      	movs	r2, #194	; 0xc2
 8012c10:	4940      	ldr	r1, [pc, #256]	; (8012d14 <ShellCmdLineParse+0x1b8>)
 8012c12:	4842      	ldr	r0, [pc, #264]	; (8012d1c <ShellCmdLineParse+0x1c0>)
 8012c14:	f7f1 fd5a 	bl	80046cc <dprintf>
        ShellNotify(shellCB);
 8012c18:	6878      	ldr	r0, [r7, #4]
 8012c1a:	f7ff ff37 	bl	8012a8c <ShellNotify>
        return;
 8012c1e:	e073      	b.n	8012d08 <ShellCmdLineParse+0x1ac>
    } else if ((ch == '\b') || (ch == 0x7F)) { /* backspace or delete(0x7F) */
 8012c20:	7cfb      	ldrb	r3, [r7, #19]
 8012c22:	2b08      	cmp	r3, #8
 8012c24:	d002      	beq.n	8012c2c <ShellCmdLineParse+0xd0>
 8012c26:	7cfb      	ldrb	r3, [r7, #19]
 8012c28:	2b7f      	cmp	r3, #127	; 0x7f
 8012c2a:	d119      	bne.n	8012c60 <ShellCmdLineParse+0x104>
        if ((shellCB->shellBufOffset > 0) && (shellCB->shellBufOffset < (SHOW_MAX_LEN - 1))) {
 8012c2c:	687b      	ldr	r3, [r7, #4]
 8012c2e:	699b      	ldr	r3, [r3, #24]
 8012c30:	2b00      	cmp	r3, #0
 8012c32:	d064      	beq.n	8012cfe <ShellCmdLineParse+0x1a2>
 8012c34:	687b      	ldr	r3, [r7, #4]
 8012c36:	699b      	ldr	r3, [r3, #24]
 8012c38:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 8012c3c:	d85f      	bhi.n	8012cfe <ShellCmdLineParse+0x1a2>
            shellCB->shellBuf[shellCB->shellBufOffset - 1] = '\0';
 8012c3e:	687b      	ldr	r3, [r7, #4]
 8012c40:	699b      	ldr	r3, [r3, #24]
 8012c42:	3b01      	subs	r3, #1
 8012c44:	687a      	ldr	r2, [r7, #4]
 8012c46:	4413      	add	r3, r2
 8012c48:	2200      	movs	r2, #0
 8012c4a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            shellCB->shellBufOffset--;
 8012c4e:	687b      	ldr	r3, [r7, #4]
 8012c50:	699b      	ldr	r3, [r3, #24]
 8012c52:	1e5a      	subs	r2, r3, #1
 8012c54:	687b      	ldr	r3, [r7, #4]
 8012c56:	619a      	str	r2, [r3, #24]
            outputFunc("\b \b");
 8012c58:	68bb      	ldr	r3, [r7, #8]
 8012c5a:	4831      	ldr	r0, [pc, #196]	; (8012d20 <ShellCmdLineParse+0x1c4>)
 8012c5c:	4798      	blx	r3
        }
        return;
 8012c5e:	e04e      	b.n	8012cfe <ShellCmdLineParse+0x1a2>
    } else if (ch == 0x09) { /* 0x09: tab */
 8012c60:	7cfb      	ldrb	r3, [r7, #19]
 8012c62:	2b09      	cmp	r3, #9
 8012c64:	d11d      	bne.n	8012ca2 <ShellCmdLineParse+0x146>
        if ((shellCB->shellBufOffset > 0) && (shellCB->shellBufOffset < (SHOW_MAX_LEN - 1))) {
 8012c66:	687b      	ldr	r3, [r7, #4]
 8012c68:	699b      	ldr	r3, [r3, #24]
 8012c6a:	2b00      	cmp	r3, #0
 8012c6c:	d049      	beq.n	8012d02 <ShellCmdLineParse+0x1a6>
 8012c6e:	687b      	ldr	r3, [r7, #4]
 8012c70:	699b      	ldr	r3, [r3, #24]
 8012c72:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 8012c76:	d844      	bhi.n	8012d02 <ShellCmdLineParse+0x1a6>
            ret = OsTabCompletion(shellCB->shellBuf, &shellCB->shellBufOffset);
 8012c78:	687b      	ldr	r3, [r7, #4]
 8012c7a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8012c7e:	687b      	ldr	r3, [r7, #4]
 8012c80:	3318      	adds	r3, #24
 8012c82:	4619      	mov	r1, r3
 8012c84:	4610      	mov	r0, r2
 8012c86:	f7fe fbb3 	bl	80113f0 <OsTabCompletion>
 8012c8a:	6178      	str	r0, [r7, #20]
            if (ret > 1) {
 8012c8c:	697b      	ldr	r3, [r7, #20]
 8012c8e:	2b01      	cmp	r3, #1
 8012c90:	dd37      	ble.n	8012d02 <ShellCmdLineParse+0x1a6>
                outputFunc("Huawei LiteOS # %s", shellCB->shellBuf);
 8012c92:	687b      	ldr	r3, [r7, #4]
 8012c94:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8012c98:	68bb      	ldr	r3, [r7, #8]
 8012c9a:	4611      	mov	r1, r2
 8012c9c:	4821      	ldr	r0, [pc, #132]	; (8012d24 <ShellCmdLineParse+0x1c8>)
 8012c9e:	4798      	blx	r3
            }
        }
        return;
 8012ca0:	e02f      	b.n	8012d02 <ShellCmdLineParse+0x1a6>
    }
    /* parse the up/down/right/left key */
    ret = ShellCmdLineCheckUDRL(ch, shellCB);
 8012ca2:	7cfb      	ldrb	r3, [r7, #19]
 8012ca4:	6879      	ldr	r1, [r7, #4]
 8012ca6:	4618      	mov	r0, r3
 8012ca8:	f7ff feff 	bl	8012aaa <ShellCmdLineCheckUDRL>
 8012cac:	6178      	str	r0, [r7, #20]
    if (ret == LOS_OK) {
 8012cae:	697b      	ldr	r3, [r7, #20]
 8012cb0:	2b00      	cmp	r3, #0
 8012cb2:	d028      	beq.n	8012d06 <ShellCmdLineParse+0x1aa>
        return;
    }

    if ((ch != '\n') && (ch != '\0')) {
 8012cb4:	7cfb      	ldrb	r3, [r7, #19]
 8012cb6:	2b0a      	cmp	r3, #10
 8012cb8:	d01d      	beq.n	8012cf6 <ShellCmdLineParse+0x19a>
 8012cba:	7cfb      	ldrb	r3, [r7, #19]
 8012cbc:	2b00      	cmp	r3, #0
 8012cbe:	d01a      	beq.n	8012cf6 <ShellCmdLineParse+0x19a>
        if (shellCB->shellBufOffset < (SHOW_MAX_LEN - 1)) {
 8012cc0:	687b      	ldr	r3, [r7, #4]
 8012cc2:	699b      	ldr	r3, [r3, #24]
 8012cc4:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 8012cc8:	d807      	bhi.n	8012cda <ShellCmdLineParse+0x17e>
            shellCB->shellBuf[shellCB->shellBufOffset] = ch;
 8012cca:	687b      	ldr	r3, [r7, #4]
 8012ccc:	699b      	ldr	r3, [r3, #24]
 8012cce:	687a      	ldr	r2, [r7, #4]
 8012cd0:	4413      	add	r3, r2
 8012cd2:	7cfa      	ldrb	r2, [r7, #19]
 8012cd4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 8012cd8:	e003      	b.n	8012ce2 <ShellCmdLineParse+0x186>
        } else {
            shellCB->shellBuf[SHOW_MAX_LEN - 1] = '\0';
 8012cda:	687b      	ldr	r3, [r7, #4]
 8012cdc:	2200      	movs	r2, #0
 8012cde:	f883 2143 	strb.w	r2, [r3, #323]	; 0x143
        }
        shellCB->shellBufOffset++;
 8012ce2:	687b      	ldr	r3, [r7, #4]
 8012ce4:	699b      	ldr	r3, [r3, #24]
 8012ce6:	1c5a      	adds	r2, r3, #1
 8012ce8:	687b      	ldr	r3, [r7, #4]
 8012cea:	619a      	str	r2, [r3, #24]
        outputFunc("%c", ch);
 8012cec:	7cfa      	ldrb	r2, [r7, #19]
 8012cee:	68bb      	ldr	r3, [r7, #8]
 8012cf0:	4611      	mov	r1, r2
 8012cf2:	480d      	ldr	r0, [pc, #52]	; (8012d28 <ShellCmdLineParse+0x1cc>)
 8012cf4:	4798      	blx	r3
    }

    shellCB->shellKeyType = STAT_NOMAL_KEY;
 8012cf6:	687b      	ldr	r3, [r7, #4]
 8012cf8:	2200      	movs	r2, #0
 8012cfa:	61da      	str	r2, [r3, #28]
 8012cfc:	e004      	b.n	8012d08 <ShellCmdLineParse+0x1ac>
        return;
 8012cfe:	bf00      	nop
 8012d00:	e002      	b.n	8012d08 <ShellCmdLineParse+0x1ac>
        return;
 8012d02:	bf00      	nop
 8012d04:	e000      	b.n	8012d08 <ShellCmdLineParse+0x1ac>
        return;
 8012d06:	bf00      	nop
}
 8012d08:	3720      	adds	r7, #32
 8012d0a:	46bd      	mov	sp, r7
 8012d0c:	bd80      	pop	{r7, pc}
 8012d0e:	bf00      	nop
 8012d10:	08022720 	.word	0x08022720
 8012d14:	0802363c 	.word	0x0802363c
 8012d18:	08022728 	.word	0x08022728
 8012d1c:	0802274c 	.word	0x0802274c
 8012d20:	08022770 	.word	0x08022770
 8012d24:	08022774 	.word	0x08022774
 8012d28:	08022788 	.word	0x08022788

08012d2c <ShellMsgTypeGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 ShellMsgTypeGet(CmdParsed *cmdParsed, const CHAR *cmdType)
{
 8012d2c:	b580      	push	{r7, lr}
 8012d2e:	b086      	sub	sp, #24
 8012d30:	af00      	add	r7, sp, #0
 8012d32:	6078      	str	r0, [r7, #4]
 8012d34:	6039      	str	r1, [r7, #0]
    UINT32 minLen;
    CmdItemNode *curCmdItem = (CmdItemNode *)NULL;
 8012d36:	2300      	movs	r3, #0
 8012d38:	60bb      	str	r3, [r7, #8]
    UINT32 len = strlen(cmdType);
 8012d3a:	6838      	ldr	r0, [r7, #0]
 8012d3c:	f7fb fea5 	bl	800ea8a <strlen>
 8012d40:	60f8      	str	r0, [r7, #12]
    CmdModInfo *cmdInfo = OsCmdInfoGet();
 8012d42:	f7fe f99b 	bl	801107c <OsCmdInfoGet>
 8012d46:	6138      	str	r0, [r7, #16]

    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &cmdInfo->cmdList.list, CmdItemNode, list) {
 8012d48:	693b      	ldr	r3, [r7, #16]
 8012d4a:	685b      	ldr	r3, [r3, #4]
 8012d4c:	60bb      	str	r3, [r7, #8]
 8012d4e:	e032      	b.n	8012db6 <ShellMsgTypeGet+0x8a>
        if ((len == strlen(curCmdItem->cmd->cmdKey)) &&
 8012d50:	68bb      	ldr	r3, [r7, #8]
 8012d52:	689b      	ldr	r3, [r3, #8]
 8012d54:	685b      	ldr	r3, [r3, #4]
 8012d56:	4618      	mov	r0, r3
 8012d58:	f7fb fe97 	bl	800ea8a <strlen>
 8012d5c:	4602      	mov	r2, r0
 8012d5e:	68fb      	ldr	r3, [r7, #12]
 8012d60:	4293      	cmp	r3, r2
 8012d62:	d125      	bne.n	8012db0 <ShellMsgTypeGet+0x84>
            (strncmp((CHAR *)(curCmdItem->cmd->cmdKey), cmdType, len) == 0)) {
 8012d64:	68bb      	ldr	r3, [r7, #8]
 8012d66:	689b      	ldr	r3, [r3, #8]
 8012d68:	685b      	ldr	r3, [r3, #4]
 8012d6a:	68fa      	ldr	r2, [r7, #12]
 8012d6c:	6839      	ldr	r1, [r7, #0]
 8012d6e:	4618      	mov	r0, r3
 8012d70:	f006 fb5a 	bl	8019428 <strncmp>
 8012d74:	4603      	mov	r3, r0
        if ((len == strlen(curCmdItem->cmd->cmdKey)) &&
 8012d76:	2b00      	cmp	r3, #0
 8012d78:	d11a      	bne.n	8012db0 <ShellMsgTypeGet+0x84>
            minLen = (len < CMD_KEY_LEN) ? len : (CMD_KEY_LEN - 1);
 8012d7a:	68fb      	ldr	r3, [r7, #12]
 8012d7c:	2b0f      	cmp	r3, #15
 8012d7e:	bf28      	it	cs
 8012d80:	230f      	movcs	r3, #15
 8012d82:	617b      	str	r3, [r7, #20]
            if (strncpy_s((CHAR *)(cmdParsed->cmdKeyword), CMD_KEY_LEN, cmdType, minLen) != EOK) {
 8012d84:	687b      	ldr	r3, [r7, #4]
 8012d86:	f103 0008 	add.w	r0, r3, #8
 8012d8a:	697b      	ldr	r3, [r7, #20]
 8012d8c:	683a      	ldr	r2, [r7, #0]
 8012d8e:	2110      	movs	r1, #16
 8012d90:	f003 fa6a 	bl	8016268 <strncpy_s>
 8012d94:	4603      	mov	r3, r0
 8012d96:	2b00      	cmp	r3, #0
 8012d98:	d003      	beq.n	8012da2 <ShellMsgTypeGet+0x76>
                PRINTK("strncpy_s failure in %s\n", __FUNCTION__);
 8012d9a:	490c      	ldr	r1, [pc, #48]	; (8012dcc <ShellMsgTypeGet+0xa0>)
 8012d9c:	480c      	ldr	r0, [pc, #48]	; (8012dd0 <ShellMsgTypeGet+0xa4>)
 8012d9e:	f7f1 fc95 	bl	80046cc <dprintf>
            }
            cmdParsed->cmdType = curCmdItem->cmd->cmdType;
 8012da2:	68bb      	ldr	r3, [r7, #8]
 8012da4:	689b      	ldr	r3, [r3, #8]
 8012da6:	681a      	ldr	r2, [r3, #0]
 8012da8:	687b      	ldr	r3, [r7, #4]
 8012daa:	605a      	str	r2, [r3, #4]
            return LOS_OK;
 8012dac:	2300      	movs	r3, #0
 8012dae:	e008      	b.n	8012dc2 <ShellMsgTypeGet+0x96>
    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &cmdInfo->cmdList.list, CmdItemNode, list) {
 8012db0:	68bb      	ldr	r3, [r7, #8]
 8012db2:	685b      	ldr	r3, [r3, #4]
 8012db4:	60bb      	str	r3, [r7, #8]
 8012db6:	68ba      	ldr	r2, [r7, #8]
 8012db8:	693b      	ldr	r3, [r7, #16]
 8012dba:	429a      	cmp	r2, r3
 8012dbc:	d1c8      	bne.n	8012d50 <ShellMsgTypeGet+0x24>
        }
    }

    return OS_INVALID;
 8012dbe:	f04f 33ff 	mov.w	r3, #4294967295
}
 8012dc2:	4618      	mov	r0, r3
 8012dc4:	3718      	adds	r7, #24
 8012dc6:	46bd      	mov	sp, r7
 8012dc8:	bd80      	pop	{r7, pc}
 8012dca:	bf00      	nop
 8012dcc:	08023650 	.word	0x08023650
 8012dd0:	0802278c 	.word	0x0802278c

08012dd4 <ShellMsgNameGetAndExec>:

STATIC UINT32 ShellMsgNameGetAndExec(CmdParsed *cmdParsed, const CHAR *output, UINT32 len)
{
 8012dd4:	b580      	push	{r7, lr}
 8012dd6:	b08a      	sub	sp, #40	; 0x28
 8012dd8:	af00      	add	r7, sp, #0
 8012dda:	60f8      	str	r0, [r7, #12]
 8012ddc:	60b9      	str	r1, [r7, #8]
 8012dde:	607a      	str	r2, [r7, #4]
    UINT32 loop;
    UINT32 ret;
    const CHAR *tmpStr = NULL;
 8012de0:	2300      	movs	r3, #0
 8012de2:	61bb      	str	r3, [r7, #24]
    BOOL quotes = FALSE;
 8012de4:	2300      	movs	r3, #0
 8012de6:	61fb      	str	r3, [r7, #28]
    CHAR *msgName = (CHAR *)LOS_MemAlloc(m_aucSysMem0, len + 1);
 8012de8:	4b34      	ldr	r3, [pc, #208]	; (8012ebc <ShellMsgNameGetAndExec+0xe8>)
 8012dea:	681a      	ldr	r2, [r3, #0]
 8012dec:	687b      	ldr	r3, [r7, #4]
 8012dee:	3301      	adds	r3, #1
 8012df0:	4619      	mov	r1, r3
 8012df2:	4610      	mov	r0, r2
 8012df4:	f7f5 fdd8 	bl	80089a8 <LOS_MemAlloc>
 8012df8:	6238      	str	r0, [r7, #32]
    if (msgName == NULL) {
 8012dfa:	6a3b      	ldr	r3, [r7, #32]
 8012dfc:	2b00      	cmp	r3, #0
 8012dfe:	d108      	bne.n	8012e12 <ShellMsgNameGetAndExec+0x3e>
        PRINTK("malloc failure in %s[%d]\n", __FUNCTION__, __LINE__);
 8012e00:	f44f 7283 	mov.w	r2, #262	; 0x106
 8012e04:	492e      	ldr	r1, [pc, #184]	; (8012ec0 <ShellMsgNameGetAndExec+0xec>)
 8012e06:	482f      	ldr	r0, [pc, #188]	; (8012ec4 <ShellMsgNameGetAndExec+0xf0>)
 8012e08:	f7f1 fc60 	bl	80046cc <dprintf>
        return OS_INVALID;
 8012e0c:	f04f 33ff 	mov.w	r3, #4294967295
 8012e10:	e050      	b.n	8012eb4 <ShellMsgNameGetAndExec+0xe0>
    }
    /* Scan the 'output' string for command */
    /* Notice: Command string must not have any special name */
    for (tmpStr = output, loop = 0; (*tmpStr != '\0') && (loop < len);) {
 8012e12:	68bb      	ldr	r3, [r7, #8]
 8012e14:	61bb      	str	r3, [r7, #24]
 8012e16:	2300      	movs	r3, #0
 8012e18:	617b      	str	r3, [r7, #20]
 8012e1a:	e021      	b.n	8012e60 <ShellMsgNameGetAndExec+0x8c>
        /* If reach a double quotes, switch the quotes matching status */
        if (*tmpStr == '\"') {
 8012e1c:	69bb      	ldr	r3, [r7, #24]
 8012e1e:	781b      	ldrb	r3, [r3, #0]
 8012e20:	2b22      	cmp	r3, #34	; 0x22
 8012e22:	d10b      	bne.n	8012e3c <ShellMsgNameGetAndExec+0x68>
            SWITCH_QUOTES_STATUS(quotes);
 8012e24:	69fb      	ldr	r3, [r7, #28]
 8012e26:	2b01      	cmp	r3, #1
 8012e28:	d102      	bne.n	8012e30 <ShellMsgNameGetAndExec+0x5c>
 8012e2a:	2300      	movs	r3, #0
 8012e2c:	61fb      	str	r3, [r7, #28]
 8012e2e:	e001      	b.n	8012e34 <ShellMsgNameGetAndExec+0x60>
 8012e30:	2301      	movs	r3, #1
 8012e32:	61fb      	str	r3, [r7, #28]
            /* Ignore the double quote CHARactor itself */
            tmpStr++;
 8012e34:	69bb      	ldr	r3, [r7, #24]
 8012e36:	3301      	adds	r3, #1
 8012e38:	61bb      	str	r3, [r7, #24]
            continue;
 8012e3a:	e011      	b.n	8012e60 <ShellMsgNameGetAndExec+0x8c>
        }
        /* If detected a space which the quotes matching status is false */
        /* which said has detected the first space for separator, finish this scan operation */
        if ((*tmpStr == ' ') && (QUOTES_STATUS_CLOSE(quotes))) {
 8012e3c:	69bb      	ldr	r3, [r7, #24]
 8012e3e:	781b      	ldrb	r3, [r3, #0]
 8012e40:	2b20      	cmp	r3, #32
 8012e42:	d102      	bne.n	8012e4a <ShellMsgNameGetAndExec+0x76>
 8012e44:	69fb      	ldr	r3, [r7, #28]
 8012e46:	2b00      	cmp	r3, #0
 8012e48:	d013      	beq.n	8012e72 <ShellMsgNameGetAndExec+0x9e>
            break;
        }
        msgName[loop] = *tmpStr++;
 8012e4a:	69bb      	ldr	r3, [r7, #24]
 8012e4c:	1c5a      	adds	r2, r3, #1
 8012e4e:	61ba      	str	r2, [r7, #24]
 8012e50:	6a39      	ldr	r1, [r7, #32]
 8012e52:	697a      	ldr	r2, [r7, #20]
 8012e54:	440a      	add	r2, r1
 8012e56:	781b      	ldrb	r3, [r3, #0]
 8012e58:	7013      	strb	r3, [r2, #0]
        loop++;
 8012e5a:	697b      	ldr	r3, [r7, #20]
 8012e5c:	3301      	adds	r3, #1
 8012e5e:	617b      	str	r3, [r7, #20]
    for (tmpStr = output, loop = 0; (*tmpStr != '\0') && (loop < len);) {
 8012e60:	69bb      	ldr	r3, [r7, #24]
 8012e62:	781b      	ldrb	r3, [r3, #0]
 8012e64:	2b00      	cmp	r3, #0
 8012e66:	d005      	beq.n	8012e74 <ShellMsgNameGetAndExec+0xa0>
 8012e68:	697a      	ldr	r2, [r7, #20]
 8012e6a:	687b      	ldr	r3, [r7, #4]
 8012e6c:	429a      	cmp	r2, r3
 8012e6e:	d3d5      	bcc.n	8012e1c <ShellMsgNameGetAndExec+0x48>
 8012e70:	e000      	b.n	8012e74 <ShellMsgNameGetAndExec+0xa0>
            break;
 8012e72:	bf00      	nop
    }
    msgName[loop] = '\0';
 8012e74:	6a3a      	ldr	r2, [r7, #32]
 8012e76:	697b      	ldr	r3, [r7, #20]
 8012e78:	4413      	add	r3, r2
 8012e7a:	2200      	movs	r2, #0
 8012e7c:	701a      	strb	r2, [r3, #0]
    /* Scan the command list to check whether the command can be found */
    ret = ShellMsgTypeGet(cmdParsed, msgName);
 8012e7e:	6a39      	ldr	r1, [r7, #32]
 8012e80:	68f8      	ldr	r0, [r7, #12]
 8012e82:	f7ff ff53 	bl	8012d2c <ShellMsgTypeGet>
 8012e86:	6278      	str	r0, [r7, #36]	; 0x24
    PRINTK("\n");
 8012e88:	480f      	ldr	r0, [pc, #60]	; (8012ec8 <ShellMsgNameGetAndExec+0xf4>)
 8012e8a:	f7f1 fc1f 	bl	80046cc <dprintf>
    if (ret != LOS_OK) {
 8012e8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e90:	2b00      	cmp	r3, #0
 8012e92:	d004      	beq.n	8012e9e <ShellMsgNameGetAndExec+0xca>
        PRINTK("%s:command not found", msgName);
 8012e94:	6a39      	ldr	r1, [r7, #32]
 8012e96:	480d      	ldr	r0, [pc, #52]	; (8012ecc <ShellMsgNameGetAndExec+0xf8>)
 8012e98:	f7f1 fc18 	bl	80046cc <dprintf>
 8012e9c:	e003      	b.n	8012ea6 <ShellMsgNameGetAndExec+0xd2>
    } else {
        (VOID)OsCmdExec(cmdParsed, (CHAR *)output);
 8012e9e:	68b9      	ldr	r1, [r7, #8]
 8012ea0:	68f8      	ldr	r0, [r7, #12]
 8012ea2:	f7fe fd67 	bl	8011974 <OsCmdExec>
    }
    (VOID)LOS_MemFree(m_aucSysMem0, msgName);
 8012ea6:	4b05      	ldr	r3, [pc, #20]	; (8012ebc <ShellMsgNameGetAndExec+0xe8>)
 8012ea8:	681b      	ldr	r3, [r3, #0]
 8012eaa:	6a39      	ldr	r1, [r7, #32]
 8012eac:	4618      	mov	r0, r3
 8012eae:	f7f5 fe33 	bl	8008b18 <LOS_MemFree>
    return ret;
 8012eb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8012eb4:	4618      	mov	r0, r3
 8012eb6:	3728      	adds	r7, #40	; 0x28
 8012eb8:	46bd      	mov	sp, r7
 8012eba:	bd80      	pop	{r7, pc}
 8012ebc:	200021b4 	.word	0x200021b4
 8012ec0:	08023660 	.word	0x08023660
 8012ec4:	080227a8 	.word	0x080227a8
 8012ec8:	080227c4 	.word	0x080227c4
 8012ecc:	080227c8 	.word	0x080227c8

08012ed0 <ShellMsgParse>:

LITE_OS_SEC_TEXT_MINOR UINT32 ShellMsgParse(const VOID *msg)
{
 8012ed0:	b580      	push	{r7, lr}
 8012ed2:	b0ac      	sub	sp, #176	; 0xb0
 8012ed4:	af00      	add	r7, sp, #0
 8012ed6:	6078      	str	r0, [r7, #4]
 8012ed8:	4b2e      	ldr	r3, [pc, #184]	; (8012f94 <ShellMsgParse+0xc4>)
 8012eda:	681b      	ldr	r3, [r3, #0]
 8012edc:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8012ee0:	f04f 0300 	mov.w	r3, #0
    CHAR *output = NULL;
 8012ee4:	2300      	movs	r3, #0
 8012ee6:	60fb      	str	r3, [r7, #12]
    UINT32 len;
    CmdParsed cmdParsed;
    UINT32 ret = OS_INVALID;
 8012ee8:	f04f 33ff 	mov.w	r3, #4294967295
 8012eec:	60bb      	str	r3, [r7, #8]

    if (msg == NULL) {
 8012eee:	687b      	ldr	r3, [r7, #4]
 8012ef0:	2b00      	cmp	r3, #0
 8012ef2:	d041      	beq.n	8012f78 <ShellMsgParse+0xa8>
        goto END;
    }

    len = strlen(msg);
 8012ef4:	6878      	ldr	r0, [r7, #4]
 8012ef6:	f7fb fdc8 	bl	800ea8a <strlen>
 8012efa:	6138      	str	r0, [r7, #16]
    output = (CHAR *)LOS_MemAlloc(m_aucSysMem0, len + 1);
 8012efc:	4b26      	ldr	r3, [pc, #152]	; (8012f98 <ShellMsgParse+0xc8>)
 8012efe:	681a      	ldr	r2, [r3, #0]
 8012f00:	693b      	ldr	r3, [r7, #16]
 8012f02:	3301      	adds	r3, #1
 8012f04:	4619      	mov	r1, r3
 8012f06:	4610      	mov	r0, r2
 8012f08:	f7f5 fd4e 	bl	80089a8 <LOS_MemAlloc>
 8012f0c:	60f8      	str	r0, [r7, #12]
    if (output == NULL) {
 8012f0e:	68fb      	ldr	r3, [r7, #12]
 8012f10:	2b00      	cmp	r3, #0
 8012f12:	d106      	bne.n	8012f22 <ShellMsgParse+0x52>
        PRINTK("malloc failure in %s[%d]\n", __FUNCTION__, __LINE__);
 8012f14:	f44f 729b 	mov.w	r2, #310	; 0x136
 8012f18:	4920      	ldr	r1, [pc, #128]	; (8012f9c <ShellMsgParse+0xcc>)
 8012f1a:	4821      	ldr	r0, [pc, #132]	; (8012fa0 <ShellMsgParse+0xd0>)
 8012f1c:	f7f1 fbd6 	bl	80046cc <dprintf>
        goto END;
 8012f20:	e02b      	b.n	8012f7a <ShellMsgParse+0xaa>
    }
    /* Call function 'OsCmdKeyShift' to squeeze and clear useless or overmuch space if string buffer */
    ret = OsCmdKeyShift((CHAR *)msg, output, len + 1);
 8012f22:	693b      	ldr	r3, [r7, #16]
 8012f24:	3301      	adds	r3, #1
 8012f26:	461a      	mov	r2, r3
 8012f28:	68f9      	ldr	r1, [r7, #12]
 8012f2a:	6878      	ldr	r0, [r7, #4]
 8012f2c:	f7fe f9b0 	bl	8011290 <OsCmdKeyShift>
 8012f30:	60b8      	str	r0, [r7, #8]
    if ((ret != LOS_OK) || (strlen(output) == 0)) {
 8012f32:	68bb      	ldr	r3, [r7, #8]
 8012f34:	2b00      	cmp	r3, #0
 8012f36:	d105      	bne.n	8012f44 <ShellMsgParse+0x74>
 8012f38:	68f8      	ldr	r0, [r7, #12]
 8012f3a:	f7fb fda6 	bl	800ea8a <strlen>
 8012f3e:	4603      	mov	r3, r0
 8012f40:	2b00      	cmp	r3, #0
 8012f42:	d103      	bne.n	8012f4c <ShellMsgParse+0x7c>
        ret = OS_INVALID;
 8012f44:	f04f 33ff 	mov.w	r3, #4294967295
 8012f48:	60bb      	str	r3, [r7, #8]
        goto END_FREE_OUTPUT;
 8012f4a:	e00e      	b.n	8012f6a <ShellMsgParse+0x9a>
    }

    (VOID)memset_s(&cmdParsed, sizeof(CmdParsed), 0, sizeof(CmdParsed));
 8012f4c:	f107 0014 	add.w	r0, r7, #20
 8012f50:	2398      	movs	r3, #152	; 0x98
 8012f52:	2200      	movs	r2, #0
 8012f54:	2198      	movs	r1, #152	; 0x98
 8012f56:	f003 f899 	bl	801608c <memset_s>

    ret = ShellMsgNameGetAndExec(&cmdParsed, output, len);
 8012f5a:	f107 0314 	add.w	r3, r7, #20
 8012f5e:	693a      	ldr	r2, [r7, #16]
 8012f60:	68f9      	ldr	r1, [r7, #12]
 8012f62:	4618      	mov	r0, r3
 8012f64:	f7ff ff36 	bl	8012dd4 <ShellMsgNameGetAndExec>
 8012f68:	60b8      	str	r0, [r7, #8]

END_FREE_OUTPUT:
    (VOID)LOS_MemFree(m_aucSysMem0, output);
 8012f6a:	4b0b      	ldr	r3, [pc, #44]	; (8012f98 <ShellMsgParse+0xc8>)
 8012f6c:	681b      	ldr	r3, [r3, #0]
 8012f6e:	68f9      	ldr	r1, [r7, #12]
 8012f70:	4618      	mov	r0, r3
 8012f72:	f7f5 fdd1 	bl	8008b18 <LOS_MemFree>
 8012f76:	e000      	b.n	8012f7a <ShellMsgParse+0xaa>
        goto END;
 8012f78:	bf00      	nop
END:
    return ret;
 8012f7a:	68bb      	ldr	r3, [r7, #8]
}
 8012f7c:	4a05      	ldr	r2, [pc, #20]	; (8012f94 <ShellMsgParse+0xc4>)
 8012f7e:	6811      	ldr	r1, [r2, #0]
 8012f80:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8012f84:	4051      	eors	r1, r2
 8012f86:	d001      	beq.n	8012f8c <ShellMsgParse+0xbc>
 8012f88:	f7f1 fa2e 	bl	80043e8 <__stack_chk_fail>
 8012f8c:	4618      	mov	r0, r3
 8012f8e:	37b0      	adds	r7, #176	; 0xb0
 8012f90:	46bd      	mov	sp, r7
 8012f92:	bd80      	pop	{r7, pc}
 8012f94:	080227e0 	.word	0x080227e0
 8012f98:	200021b4 	.word	0x200021b4
 8012f9c:	08023678 	.word	0x08023678
 8012fa0:	080227a8 	.word	0x080227a8

08012fa4 <ShellEntry>:

LITE_OS_SEC_TEXT_MINOR UINT32 ShellEntry(VOID *param)
{
 8012fa4:	b580      	push	{r7, lr}
 8012fa6:	b084      	sub	sp, #16
 8012fa8:	af00      	add	r7, sp, #0
 8012faa:	6078      	str	r0, [r7, #4]
    ShellCB *shellCB = (ShellCB *)param;
 8012fac:	687b      	ldr	r3, [r7, #4]
 8012fae:	60fb      	str	r3, [r7, #12]

    (VOID)memset_s(shellCB->shellBuf, SHOW_MAX_LEN, 0, SHOW_MAX_LEN);
 8012fb0:	68fb      	ldr	r3, [r7, #12]
 8012fb2:	f103 0034 	add.w	r0, r3, #52	; 0x34
 8012fb6:	f44f 7388 	mov.w	r3, #272	; 0x110
 8012fba:	2200      	movs	r2, #0
 8012fbc:	f44f 7188 	mov.w	r1, #272	; 0x110
 8012fc0:	f003 f864 	bl	801608c <memset_s>
    return ShellStdinLoop(shellCB);
 8012fc4:	68f8      	ldr	r0, [r7, #12]
 8012fc6:	f000 fa0f 	bl	80133e8 <ShellStdinLoop>
 8012fca:	4603      	mov	r3, r0
}
 8012fcc:	4618      	mov	r0, r3
 8012fce:	3710      	adds	r7, #16
 8012fd0:	46bd      	mov	sp, r7
 8012fd2:	bd80      	pop	{r7, pc}

08012fd4 <ShellCmdProcess>:

STATIC VOID ShellCmdProcess(ShellCB *shellCB)
{
 8012fd4:	b580      	push	{r7, lr}
 8012fd6:	b084      	sub	sp, #16
 8012fd8:	af00      	add	r7, sp, #0
 8012fda:	6078      	str	r0, [r7, #4]
    CHAR *buf = NULL;
 8012fdc:	2300      	movs	r3, #0
 8012fde:	60fb      	str	r3, [r7, #12]
    while (1) {
        buf = ShellGetInputBuf(shellCB);
 8012fe0:	6878      	ldr	r0, [r7, #4]
 8012fe2:	f7ff fc5f 	bl	80128a4 <ShellGetInputBuf>
 8012fe6:	60f8      	str	r0, [r7, #12]
        if (buf == NULL) {
 8012fe8:	68fb      	ldr	r3, [r7, #12]
 8012fea:	2b00      	cmp	r3, #0
 8012fec:	d00b      	beq.n	8013006 <ShellCmdProcess+0x32>
            break;
        }
        (VOID)ShellMsgParse(buf);
 8012fee:	68f8      	ldr	r0, [r7, #12]
 8012ff0:	f7ff ff6e 	bl	8012ed0 <ShellMsgParse>
        ShellSaveHistoryCmd(buf, shellCB);
 8012ff4:	6879      	ldr	r1, [r7, #4]
 8012ff6:	68f8      	ldr	r0, [r7, #12]
 8012ff8:	f7ff fcba 	bl	8012970 <ShellSaveHistoryCmd>
        shellCB->cmdMaskKeyLink = shellCB->cmdHistoryKeyLink;
 8012ffc:	687b      	ldr	r3, [r7, #4]
 8012ffe:	691a      	ldr	r2, [r3, #16]
 8013000:	687b      	ldr	r3, [r7, #4]
 8013002:	615a      	str	r2, [r3, #20]
        buf = ShellGetInputBuf(shellCB);
 8013004:	e7ec      	b.n	8012fe0 <ShellCmdProcess+0xc>
            break;
 8013006:	bf00      	nop
    }
}
 8013008:	bf00      	nop
 801300a:	3710      	adds	r7, #16
 801300c:	46bd      	mov	sp, r7
 801300e:	bd80      	pop	{r7, pc}

08013010 <ShellTask>:

LITE_OS_SEC_TEXT_MINOR UINT32 ShellTask(VOID *param)
{
 8013010:	b580      	push	{r7, lr}
 8013012:	b084      	sub	sp, #16
 8013014:	af00      	add	r7, sp, #0
 8013016:	6078      	str	r0, [r7, #4]
    UINT32 ret;
    ShellCB *shellCB = (ShellCB *)param;
 8013018:	687b      	ldr	r3, [r7, #4]
 801301a:	60bb      	str	r3, [r7, #8]

    while (1) {
        PRINTK("\nHuawei LiteOS # ");
 801301c:	481c      	ldr	r0, [pc, #112]	; (8013090 <ShellTask+0x80>)
 801301e:	f7f1 fb55 	bl	80046cc <dprintf>
        ret = LOS_EventRead(&shellCB->shellEvent, SHELL_CMD_EVENT_MASK,
 8013022:	68bb      	ldr	r3, [r7, #8]
 8013024:	f103 0020 	add.w	r0, r3, #32
 8013028:	f04f 33ff 	mov.w	r3, #4294967295
 801302c:	2203      	movs	r2, #3
 801302e:	f640 71ff 	movw	r1, #4095	; 0xfff
 8013032:	f005 fe41 	bl	8018cb8 <LOS_EventRead>
 8013036:	60f8      	str	r0, [r7, #12]
                            LOS_WAITMODE_OR | LOS_WAITMODE_CLR, LOS_WAIT_FOREVER);
        if (ret == SHELL_CMD_PARSE_EVENT) {
 8013038:	68fb      	ldr	r3, [r7, #12]
 801303a:	f240 1211 	movw	r2, #273	; 0x111
 801303e:	4293      	cmp	r3, r2
 8013040:	d103      	bne.n	801304a <ShellTask+0x3a>
            ShellCmdProcess(shellCB);
 8013042:	68b8      	ldr	r0, [r7, #8]
 8013044:	f7ff ffc6 	bl	8012fd4 <ShellCmdProcess>
 8013048:	e7e8      	b.n	801301c <ShellTask+0xc>
        } else if (ret == SHELL_CMD_EXIT_EVENT) {
 801304a:	68fb      	ldr	r3, [r7, #12]
 801304c:	f5b3 7f89 	cmp.w	r3, #274	; 0x112
 8013050:	d000      	beq.n	8013054 <ShellTask+0x44>
        PRINTK("\nHuawei LiteOS # ");
 8013052:	e7e3      	b.n	801301c <ShellTask+0xc>
            break;
 8013054:	bf00      	nop
        }
    }
    OsShellKeyDeInit(shellCB);
 8013056:	68b8      	ldr	r0, [r7, #8]
 8013058:	f7fe fafc 	bl	8011654 <OsShellKeyDeInit>
    (VOID)LOS_EventDestroy(&shellCB->shellEvent);
 801305c:	68bb      	ldr	r3, [r7, #8]
 801305e:	3320      	adds	r3, #32
 8013060:	4618      	mov	r0, r3
 8013062:	f005 fe4d 	bl	8018d00 <LOS_EventDestroy>
    (VOID)LOS_MuxDelete(shellCB->historyMutex);
 8013066:	68bb      	ldr	r3, [r7, #8]
 8013068:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801306a:	4618      	mov	r0, r3
 801306c:	f7f7 fd18 	bl	800aaa0 <LOS_MuxDelete>
    (VOID)LOS_MuxDelete(shellCB->keyMutex);
 8013070:	68bb      	ldr	r3, [r7, #8]
 8013072:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013074:	4618      	mov	r0, r3
 8013076:	f7f7 fd13 	bl	800aaa0 <LOS_MuxDelete>
    (VOID)LOS_MemFree((VOID *)m_aucSysMem0, shellCB);
 801307a:	4b06      	ldr	r3, [pc, #24]	; (8013094 <ShellTask+0x84>)
 801307c:	681b      	ldr	r3, [r3, #0]
 801307e:	68b9      	ldr	r1, [r7, #8]
 8013080:	4618      	mov	r0, r3
 8013082:	f7f5 fd49 	bl	8008b18 <LOS_MemFree>
    return 0;
 8013086:	2300      	movs	r3, #0
}
 8013088:	4618      	mov	r0, r3
 801308a:	3710      	adds	r7, #16
 801308c:	46bd      	mov	sp, r7
 801308e:	bd80      	pop	{r7, pc}
 8013090:	080227e4 	.word	0x080227e4
 8013094:	200021b4 	.word	0x200021b4

08013098 <ShellTaskInit>:
#define SERIAL_ENTRY_TASK_NAME "SerialEntryTask"
#define TELNET_SHELL_TASK_NAME "TelnetShellTask"
#define TELNET_ENTRY_TASK_NAME "TelnetEntryTask"

LITE_OS_SEC_TEXT_MINOR UINT32 ShellTaskInit(ShellCB *shellCB)
{
 8013098:	b580      	push	{r7, lr}
 801309a:	b08e      	sub	sp, #56	; 0x38
 801309c:	af00      	add	r7, sp, #0
 801309e:	6078      	str	r0, [r7, #4]
 80130a0:	4b1d      	ldr	r3, [pc, #116]	; (8013118 <ShellTaskInit+0x80>)
 80130a2:	681b      	ldr	r3, [r3, #0]
 80130a4:	637b      	str	r3, [r7, #52]	; 0x34
 80130a6:	f04f 0300 	mov.w	r3, #0
    CHAR *name = NULL;
 80130aa:	2300      	movs	r3, #0
 80130ac:	60fb      	str	r3, [r7, #12]
    TSK_INIT_PARAM_S initParam = {0};
 80130ae:	f107 0310 	add.w	r3, r7, #16
 80130b2:	2224      	movs	r2, #36	; 0x24
 80130b4:	2100      	movs	r1, #0
 80130b6:	4618      	mov	r0, r3
 80130b8:	f7fb fbc4 	bl	800e844 <memset>

    if (shellCB == NULL) {
 80130bc:	687b      	ldr	r3, [r7, #4]
 80130be:	2b00      	cmp	r3, #0
 80130c0:	d101      	bne.n	80130c6 <ShellTaskInit+0x2e>
        return LOS_NOK;
 80130c2:	2301      	movs	r3, #1
 80130c4:	e01d      	b.n	8013102 <ShellTaskInit+0x6a>
    } else {
        return LOS_NOK;
    }
#else
    /* in non-console mode, shell only support one input */
    name = SERIAL_SHELL_TASK_NAME;
 80130c6:	4b15      	ldr	r3, [pc, #84]	; (801311c <ShellTaskInit+0x84>)
 80130c8:	60fb      	str	r3, [r7, #12]
#endif

    initParam.pfnTaskEntry = (TSK_ENTRY_FUNC)ShellTask;
 80130ca:	4b15      	ldr	r3, [pc, #84]	; (8013120 <ShellTaskInit+0x88>)
 80130cc:	613b      	str	r3, [r7, #16]
    initParam.usTaskPrio   = SHELL_TASK_PRIORITY;
 80130ce:	2309      	movs	r3, #9
 80130d0:	82bb      	strh	r3, [r7, #20]
    initParam.uwStackSize  = SHELL_TASK_STACK_SIZE;
 80130d2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80130d6:	62bb      	str	r3, [r7, #40]	; 0x28
    initParam.pcName       = name;
 80130d8:	68fb      	ldr	r3, [r7, #12]
 80130da:	62fb      	str	r3, [r7, #44]	; 0x2c
    initParam.uwResved     = LOS_TASK_STATUS_DETACHED;
 80130dc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80130e0:	633b      	str	r3, [r7, #48]	; 0x30
    LOS_TASK_PARAM_INIT_ARG(initParam, shellCB);
 80130e2:	687b      	ldr	r3, [r7, #4]
 80130e4:	61bb      	str	r3, [r7, #24]

    (VOID)LOS_EventInit(&shellCB->shellEvent);
 80130e6:	687b      	ldr	r3, [r7, #4]
 80130e8:	3320      	adds	r3, #32
 80130ea:	4618      	mov	r0, r3
 80130ec:	f005 fb50 	bl	8018790 <LOS_EventInit>

    return LOS_TaskCreate(&shellCB->shellTaskHandle, &initParam);
 80130f0:	687b      	ldr	r3, [r7, #4]
 80130f2:	3304      	adds	r3, #4
 80130f4:	f107 0210 	add.w	r2, r7, #16
 80130f8:	4611      	mov	r1, r2
 80130fa:	4618      	mov	r0, r3
 80130fc:	f7f0 fc1c 	bl	8003938 <LOS_TaskCreate>
 8013100:	4603      	mov	r3, r0
}
 8013102:	4a05      	ldr	r2, [pc, #20]	; (8013118 <ShellTaskInit+0x80>)
 8013104:	6811      	ldr	r1, [r2, #0]
 8013106:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013108:	4051      	eors	r1, r2
 801310a:	d001      	beq.n	8013110 <ShellTaskInit+0x78>
 801310c:	f7f1 f96c 	bl	80043e8 <__stack_chk_fail>
 8013110:	4618      	mov	r0, r3
 8013112:	3738      	adds	r7, #56	; 0x38
 8013114:	46bd      	mov	sp, r7
 8013116:	bd80      	pop	{r7, pc}
 8013118:	08022808 	.word	0x08022808
 801311c:	080227f8 	.word	0x080227f8
 8013120:	08013011 	.word	0x08013011

08013124 <ShellEntryInit>:
    return FALSE;
}
#endif

LITE_OS_SEC_TEXT_MINOR UINT32 ShellEntryInit(ShellCB *shellCB)
{
 8013124:	b580      	push	{r7, lr}
 8013126:	b08e      	sub	sp, #56	; 0x38
 8013128:	af00      	add	r7, sp, #0
 801312a:	6078      	str	r0, [r7, #4]
 801312c:	4b1b      	ldr	r3, [pc, #108]	; (801319c <ShellEntryInit+0x78>)
 801312e:	681b      	ldr	r3, [r3, #0]
 8013130:	637b      	str	r3, [r7, #52]	; 0x34
 8013132:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    CHAR *name = NULL;
 8013136:	2300      	movs	r3, #0
 8013138:	60bb      	str	r3, [r7, #8]
    TSK_INIT_PARAM_S initParam = {0};
 801313a:	f107 0310 	add.w	r3, r7, #16
 801313e:	2224      	movs	r2, #36	; 0x24
 8013140:	2100      	movs	r1, #0
 8013142:	4618      	mov	r0, r3
 8013144:	f7fb fb7e 	bl	800e844 <memset>

    if (shellCB == NULL) {
 8013148:	687b      	ldr	r3, [r7, #4]
 801314a:	2b00      	cmp	r3, #0
 801314c:	d101      	bne.n	8013152 <ShellEntryInit+0x2e>
        return LOS_NOK;
 801314e:	2301      	movs	r3, #1
 8013150:	e019      	b.n	8013186 <ShellEntryInit+0x62>
    } else {
        return LOS_NOK;
    }
#else
    /* in non-console mode, shell only support one input */
    name = SERIAL_ENTRY_TASK_NAME;
 8013152:	4b13      	ldr	r3, [pc, #76]	; (80131a0 <ShellEntryInit+0x7c>)
 8013154:	60bb      	str	r3, [r7, #8]
#endif

    initParam.pfnTaskEntry = (TSK_ENTRY_FUNC)ShellEntry;
 8013156:	4b13      	ldr	r3, [pc, #76]	; (80131a4 <ShellEntryInit+0x80>)
 8013158:	613b      	str	r3, [r7, #16]
    initParam.usTaskPrio   = SHELL_ENTRY_PRIORITY;
 801315a:	2309      	movs	r3, #9
 801315c:	82bb      	strh	r3, [r7, #20]
    initParam.uwStackSize  = SHELL_ENTRY_STACK_SIZE;
 801315e:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8013162:	62bb      	str	r3, [r7, #40]	; 0x28
    initParam.pcName       = name;
 8013164:	68bb      	ldr	r3, [r7, #8]
 8013166:	62fb      	str	r3, [r7, #44]	; 0x2c
    initParam.uwResved     = LOS_TASK_STATUS_DETACHED;
 8013168:	f44f 7380 	mov.w	r3, #256	; 0x100
 801316c:	633b      	str	r3, [r7, #48]	; 0x30
    LOS_TASK_PARAM_INIT_ARG(initParam, shellCB);
 801316e:	687b      	ldr	r3, [r7, #4]
 8013170:	61bb      	str	r3, [r7, #24]

    ret = LOS_TaskCreate(&shellCB->shellEntryHandle, &initParam);
 8013172:	687b      	ldr	r3, [r7, #4]
 8013174:	3308      	adds	r3, #8
 8013176:	f107 0210 	add.w	r2, r7, #16
 801317a:	4611      	mov	r1, r2
 801317c:	4618      	mov	r0, r3
 801317e:	f7f0 fbdb 	bl	8003938 <LOS_TaskCreate>
 8013182:	60f8      	str	r0, [r7, #12]

#ifdef LOSCFG_SHELL_CONSOLE
    ret = ConsoleTaskReg((INT32)shellCB->consoleID, shellCB->shellEntryHandle);
#endif

    return ret;
 8013184:	68fb      	ldr	r3, [r7, #12]
}
 8013186:	4a05      	ldr	r2, [pc, #20]	; (801319c <ShellEntryInit+0x78>)
 8013188:	6811      	ldr	r1, [r2, #0]
 801318a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801318c:	4051      	eors	r1, r2
 801318e:	d001      	beq.n	8013194 <ShellEntryInit+0x70>
 8013190:	f7f1 f92a 	bl	80043e8 <__stack_chk_fail>
 8013194:	4618      	mov	r0, r3
 8013196:	3738      	adds	r7, #56	; 0x38
 8013198:	46bd      	mov	sp, r7
 801319a:	bd80      	pop	{r7, pc}
 801319c:	0802281c 	.word	0x0802281c
 80131a0:	0802280c 	.word	0x0802280c
 80131a4:	08012fa5 	.word	0x08012fa5

080131a8 <OsCmdParseStrdup>:

/*
 * Filter out double quote or single-quoted strings at both ends
 */
LITE_OS_SEC_TEXT_MINOR CHAR *OsCmdParseStrdup(const CHAR *str)
{
 80131a8:	b590      	push	{r4, r7, lr}
 80131aa:	b085      	sub	sp, #20
 80131ac:	af00      	add	r7, sp, #0
 80131ae:	6078      	str	r0, [r7, #4]
    CHAR *tempStr = NULL;
 80131b0:	2300      	movs	r3, #0
 80131b2:	60fb      	str	r3, [r7, #12]
    CHAR *newStr = NULL;
 80131b4:	2300      	movs	r3, #0
 80131b6:	60bb      	str	r3, [r7, #8]

    newStr = (CHAR *)LOS_MemAlloc(m_aucSysMem0, strlen(str) + 1);
 80131b8:	4b19      	ldr	r3, [pc, #100]	; (8013220 <OsCmdParseStrdup+0x78>)
 80131ba:	681c      	ldr	r4, [r3, #0]
 80131bc:	6878      	ldr	r0, [r7, #4]
 80131be:	f7fb fc64 	bl	800ea8a <strlen>
 80131c2:	4603      	mov	r3, r0
 80131c4:	3301      	adds	r3, #1
 80131c6:	4619      	mov	r1, r3
 80131c8:	4620      	mov	r0, r4
 80131ca:	f7f5 fbed 	bl	80089a8 <LOS_MemAlloc>
 80131ce:	60b8      	str	r0, [r7, #8]
    if (newStr == NULL) {
 80131d0:	68bb      	ldr	r3, [r7, #8]
 80131d2:	2b00      	cmp	r3, #0
 80131d4:	d101      	bne.n	80131da <OsCmdParseStrdup+0x32>
        return NULL;
 80131d6:	2300      	movs	r3, #0
 80131d8:	e01e      	b.n	8013218 <OsCmdParseStrdup+0x70>
    }

    tempStr = newStr;
 80131da:	68bb      	ldr	r3, [r7, #8]
 80131dc:	60fb      	str	r3, [r7, #12]
    for (; *str != '\0'; str++) {
 80131de:	e013      	b.n	8013208 <OsCmdParseStrdup+0x60>
        if ((*str == '\"') || (*str == '\'')) {
 80131e0:	687b      	ldr	r3, [r7, #4]
 80131e2:	781b      	ldrb	r3, [r3, #0]
 80131e4:	2b22      	cmp	r3, #34	; 0x22
 80131e6:	d00b      	beq.n	8013200 <OsCmdParseStrdup+0x58>
 80131e8:	687b      	ldr	r3, [r7, #4]
 80131ea:	781b      	ldrb	r3, [r3, #0]
 80131ec:	2b27      	cmp	r3, #39	; 0x27
 80131ee:	d007      	beq.n	8013200 <OsCmdParseStrdup+0x58>
            continue;
        }
        *newStr = *str;
 80131f0:	687b      	ldr	r3, [r7, #4]
 80131f2:	781a      	ldrb	r2, [r3, #0]
 80131f4:	68bb      	ldr	r3, [r7, #8]
 80131f6:	701a      	strb	r2, [r3, #0]
        newStr++;
 80131f8:	68bb      	ldr	r3, [r7, #8]
 80131fa:	3301      	adds	r3, #1
 80131fc:	60bb      	str	r3, [r7, #8]
 80131fe:	e000      	b.n	8013202 <OsCmdParseStrdup+0x5a>
            continue;
 8013200:	bf00      	nop
    for (; *str != '\0'; str++) {
 8013202:	687b      	ldr	r3, [r7, #4]
 8013204:	3301      	adds	r3, #1
 8013206:	607b      	str	r3, [r7, #4]
 8013208:	687b      	ldr	r3, [r7, #4]
 801320a:	781b      	ldrb	r3, [r3, #0]
 801320c:	2b00      	cmp	r3, #0
 801320e:	d1e7      	bne.n	80131e0 <OsCmdParseStrdup+0x38>
    }
    *newStr = '\0';
 8013210:	68bb      	ldr	r3, [r7, #8]
 8013212:	2200      	movs	r2, #0
 8013214:	701a      	strb	r2, [r3, #0]
    return tempStr;
 8013216:	68fb      	ldr	r3, [r7, #12]
}
 8013218:	4618      	mov	r0, r3
 801321a:	3714      	adds	r7, #20
 801321c:	46bd      	mov	sp, r7
 801321e:	bd90      	pop	{r4, r7, pc}
 8013220:	200021b4 	.word	0x200021b4

08013224 <OsCmdParseParaGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdParseParaGet(CHAR **value, const CHAR *paraTokenStr)
{
 8013224:	b580      	push	{r7, lr}
 8013226:	b082      	sub	sp, #8
 8013228:	af00      	add	r7, sp, #0
 801322a:	6078      	str	r0, [r7, #4]
 801322c:	6039      	str	r1, [r7, #0]
    if ((paraTokenStr == NULL) || (value == NULL)) {
 801322e:	683b      	ldr	r3, [r7, #0]
 8013230:	2b00      	cmp	r3, #0
 8013232:	d002      	beq.n	801323a <OsCmdParseParaGet+0x16>
 8013234:	687b      	ldr	r3, [r7, #4]
 8013236:	2b00      	cmp	r3, #0
 8013238:	d102      	bne.n	8013240 <OsCmdParseParaGet+0x1c>
        return (UINT32)OS_ERROR;
 801323a:	f04f 33ff 	mov.w	r3, #4294967295
 801323e:	e006      	b.n	801324e <OsCmdParseParaGet+0x2a>
    }
    *value = OsCmdParseStrdup(paraTokenStr);
 8013240:	6838      	ldr	r0, [r7, #0]
 8013242:	f7ff ffb1 	bl	80131a8 <OsCmdParseStrdup>
 8013246:	4602      	mov	r2, r0
 8013248:	687b      	ldr	r3, [r7, #4]
 801324a:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 801324c:	2300      	movs	r3, #0
}
 801324e:	4618      	mov	r0, r3
 8013250:	3708      	adds	r7, #8
 8013252:	46bd      	mov	sp, r7
 8013254:	bd80      	pop	{r7, pc}

08013256 <OsCmdParseOneToken>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdParseOneToken(CmdParsed *cmdParsed, UINT32 index, const CHAR *token)
{
 8013256:	b580      	push	{r7, lr}
 8013258:	b086      	sub	sp, #24
 801325a:	af00      	add	r7, sp, #0
 801325c:	60f8      	str	r0, [r7, #12]
 801325e:	60b9      	str	r1, [r7, #8]
 8013260:	607a      	str	r2, [r7, #4]
    UINT32 ret = LOS_OK;
 8013262:	2300      	movs	r3, #0
 8013264:	613b      	str	r3, [r7, #16]
    UINT32 tempLen;

    if (cmdParsed == NULL) {
 8013266:	68fb      	ldr	r3, [r7, #12]
 8013268:	2b00      	cmp	r3, #0
 801326a:	d102      	bne.n	8013272 <OsCmdParseOneToken+0x1c>
        return (UINT32)OS_ERROR;
 801326c:	f04f 33ff 	mov.w	r3, #4294967295
 8013270:	e027      	b.n	80132c2 <OsCmdParseOneToken+0x6c>
    }

    if (index == 0) {
 8013272:	68bb      	ldr	r3, [r7, #8]
 8013274:	2b00      	cmp	r3, #0
 8013276:	d105      	bne.n	8013284 <OsCmdParseOneToken+0x2e>
        if (cmdParsed->cmdType != CMD_TYPE_STD) {
 8013278:	68fb      	ldr	r3, [r7, #12]
 801327a:	685b      	ldr	r3, [r3, #4]
 801327c:	2b01      	cmp	r3, #1
 801327e:	d001      	beq.n	8013284 <OsCmdParseOneToken+0x2e>
            return ret;
 8013280:	693b      	ldr	r3, [r7, #16]
 8013282:	e01e      	b.n	80132c2 <OsCmdParseOneToken+0x6c>
        }
    }

    if ((token != NULL) && (cmdParsed->paramCnt < CMD_MAX_PARAS)) {
 8013284:	687b      	ldr	r3, [r7, #4]
 8013286:	2b00      	cmp	r3, #0
 8013288:	d01a      	beq.n	80132c0 <OsCmdParseOneToken+0x6a>
 801328a:	68fb      	ldr	r3, [r7, #12]
 801328c:	681b      	ldr	r3, [r3, #0]
 801328e:	2b1f      	cmp	r3, #31
 8013290:	d816      	bhi.n	80132c0 <OsCmdParseOneToken+0x6a>
        tempLen = cmdParsed->paramCnt;
 8013292:	68fb      	ldr	r3, [r7, #12]
 8013294:	681b      	ldr	r3, [r3, #0]
 8013296:	617b      	str	r3, [r7, #20]
        ret = OsCmdParseParaGet(&(cmdParsed->paramArray[tempLen]), token);
 8013298:	697b      	ldr	r3, [r7, #20]
 801329a:	3306      	adds	r3, #6
 801329c:	009b      	lsls	r3, r3, #2
 801329e:	68fa      	ldr	r2, [r7, #12]
 80132a0:	4413      	add	r3, r2
 80132a2:	6879      	ldr	r1, [r7, #4]
 80132a4:	4618      	mov	r0, r3
 80132a6:	f7ff ffbd 	bl	8013224 <OsCmdParseParaGet>
 80132aa:	6138      	str	r0, [r7, #16]
        if (ret != LOS_OK) {
 80132ac:	693b      	ldr	r3, [r7, #16]
 80132ae:	2b00      	cmp	r3, #0
 80132b0:	d001      	beq.n	80132b6 <OsCmdParseOneToken+0x60>
            return ret;
 80132b2:	693b      	ldr	r3, [r7, #16]
 80132b4:	e005      	b.n	80132c2 <OsCmdParseOneToken+0x6c>
        }
        cmdParsed->paramCnt++;
 80132b6:	68fb      	ldr	r3, [r7, #12]
 80132b8:	681b      	ldr	r3, [r3, #0]
 80132ba:	1c5a      	adds	r2, r3, #1
 80132bc:	68fb      	ldr	r3, [r7, #12]
 80132be:	601a      	str	r2, [r3, #0]
    }
    return ret;
 80132c0:	693b      	ldr	r3, [r7, #16]
}
 80132c2:	4618      	mov	r0, r3
 80132c4:	3718      	adds	r7, #24
 80132c6:	46bd      	mov	sp, r7
 80132c8:	bd80      	pop	{r7, pc}

080132ca <OsCmdTokenSplit>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdTokenSplit(CHAR *cmdStr, CHAR split, CmdParsed *cmdParsed)
{
 80132ca:	b580      	push	{r7, lr}
 80132cc:	b08a      	sub	sp, #40	; 0x28
 80132ce:	af00      	add	r7, sp, #0
 80132d0:	60f8      	str	r0, [r7, #12]
 80132d2:	460b      	mov	r3, r1
 80132d4:	607a      	str	r2, [r7, #4]
 80132d6:	72fb      	strb	r3, [r7, #11]
    enum {
        STAT_INIT,
        STAT_TOKEN_IN,
        STAT_TOKEN_OUT
    } state = STAT_INIT;
 80132d8:	2300      	movs	r3, #0
 80132da:	613b      	str	r3, [r7, #16]
    UINT32 count = 0;
 80132dc:	2300      	movs	r3, #0
 80132de:	617b      	str	r3, [r7, #20]
    CHAR *p = NULL;
 80132e0:	2300      	movs	r3, #0
 80132e2:	61bb      	str	r3, [r7, #24]
    CHAR *token = cmdStr;
 80132e4:	68fb      	ldr	r3, [r7, #12]
 80132e6:	61fb      	str	r3, [r7, #28]
    UINT32 ret = LOS_OK;
 80132e8:	2300      	movs	r3, #0
 80132ea:	623b      	str	r3, [r7, #32]
    BOOL quotes = FALSE;
 80132ec:	2300      	movs	r3, #0
 80132ee:	627b      	str	r3, [r7, #36]	; 0x24

    if (cmdStr == NULL) {
 80132f0:	68fb      	ldr	r3, [r7, #12]
 80132f2:	2b00      	cmp	r3, #0
 80132f4:	d102      	bne.n	80132fc <OsCmdTokenSplit+0x32>
        return (UINT32)OS_ERROR;
 80132f6:	f04f 33ff 	mov.w	r3, #4294967295
 80132fa:	e053      	b.n	80133a4 <OsCmdTokenSplit+0xda>
    }

    for (p = cmdStr; (*p != '\0') && (ret == LOS_OK); p++) {
 80132fc:	68fb      	ldr	r3, [r7, #12]
 80132fe:	61bb      	str	r3, [r7, #24]
 8013300:	e039      	b.n	8013376 <OsCmdTokenSplit+0xac>
        if (*p == '\"') {
 8013302:	69bb      	ldr	r3, [r7, #24]
 8013304:	781b      	ldrb	r3, [r3, #0]
 8013306:	2b22      	cmp	r3, #34	; 0x22
 8013308:	d107      	bne.n	801331a <OsCmdTokenSplit+0x50>
            SWITCH_QUOTES_STATUS(quotes);
 801330a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801330c:	2b01      	cmp	r3, #1
 801330e:	d102      	bne.n	8013316 <OsCmdTokenSplit+0x4c>
 8013310:	2300      	movs	r3, #0
 8013312:	627b      	str	r3, [r7, #36]	; 0x24
 8013314:	e001      	b.n	801331a <OsCmdTokenSplit+0x50>
 8013316:	2301      	movs	r3, #1
 8013318:	627b      	str	r3, [r7, #36]	; 0x24
        }
        switch (state) {
 801331a:	693b      	ldr	r3, [r7, #16]
 801331c:	2b01      	cmp	r3, #1
 801331e:	d903      	bls.n	8013328 <OsCmdTokenSplit+0x5e>
 8013320:	693b      	ldr	r3, [r7, #16]
 8013322:	2b02      	cmp	r3, #2
 8013324:	d017      	beq.n	8013356 <OsCmdTokenSplit+0x8c>
                    token = p;
                    state = STAT_TOKEN_IN;
                }
                break;
            default:
                break;
 8013326:	e023      	b.n	8013370 <OsCmdTokenSplit+0xa6>
                if ((*p == split) && QUOTES_STATUS_CLOSE(quotes)) {
 8013328:	69bb      	ldr	r3, [r7, #24]
 801332a:	781b      	ldrb	r3, [r3, #0]
 801332c:	7afa      	ldrb	r2, [r7, #11]
 801332e:	429a      	cmp	r2, r3
 8013330:	d11b      	bne.n	801336a <OsCmdTokenSplit+0xa0>
 8013332:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013334:	2b00      	cmp	r3, #0
 8013336:	d118      	bne.n	801336a <OsCmdTokenSplit+0xa0>
                    *p = '\0';
 8013338:	69bb      	ldr	r3, [r7, #24]
 801333a:	2200      	movs	r2, #0
 801333c:	701a      	strb	r2, [r3, #0]
                    ret = OsCmdParseOneToken(cmdParsed, count++, token);
 801333e:	697b      	ldr	r3, [r7, #20]
 8013340:	1c5a      	adds	r2, r3, #1
 8013342:	617a      	str	r2, [r7, #20]
 8013344:	69fa      	ldr	r2, [r7, #28]
 8013346:	4619      	mov	r1, r3
 8013348:	6878      	ldr	r0, [r7, #4]
 801334a:	f7ff ff84 	bl	8013256 <OsCmdParseOneToken>
 801334e:	6238      	str	r0, [r7, #32]
                    state = STAT_TOKEN_OUT;
 8013350:	2302      	movs	r3, #2
 8013352:	613b      	str	r3, [r7, #16]
                break;
 8013354:	e009      	b.n	801336a <OsCmdTokenSplit+0xa0>
                if (*p != split) {
 8013356:	69bb      	ldr	r3, [r7, #24]
 8013358:	781b      	ldrb	r3, [r3, #0]
 801335a:	7afa      	ldrb	r2, [r7, #11]
 801335c:	429a      	cmp	r2, r3
 801335e:	d006      	beq.n	801336e <OsCmdTokenSplit+0xa4>
                    token = p;
 8013360:	69bb      	ldr	r3, [r7, #24]
 8013362:	61fb      	str	r3, [r7, #28]
                    state = STAT_TOKEN_IN;
 8013364:	2301      	movs	r3, #1
 8013366:	613b      	str	r3, [r7, #16]
                break;
 8013368:	e001      	b.n	801336e <OsCmdTokenSplit+0xa4>
                break;
 801336a:	bf00      	nop
 801336c:	e000      	b.n	8013370 <OsCmdTokenSplit+0xa6>
                break;
 801336e:	bf00      	nop
    for (p = cmdStr; (*p != '\0') && (ret == LOS_OK); p++) {
 8013370:	69bb      	ldr	r3, [r7, #24]
 8013372:	3301      	adds	r3, #1
 8013374:	61bb      	str	r3, [r7, #24]
 8013376:	69bb      	ldr	r3, [r7, #24]
 8013378:	781b      	ldrb	r3, [r3, #0]
 801337a:	2b00      	cmp	r3, #0
 801337c:	d002      	beq.n	8013384 <OsCmdTokenSplit+0xba>
 801337e:	6a3b      	ldr	r3, [r7, #32]
 8013380:	2b00      	cmp	r3, #0
 8013382:	d0be      	beq.n	8013302 <OsCmdTokenSplit+0x38>
        }
    }

    if (((ret == LOS_OK) && (state == STAT_TOKEN_IN)) || (state == STAT_INIT)) {
 8013384:	6a3b      	ldr	r3, [r7, #32]
 8013386:	2b00      	cmp	r3, #0
 8013388:	d102      	bne.n	8013390 <OsCmdTokenSplit+0xc6>
 801338a:	693b      	ldr	r3, [r7, #16]
 801338c:	2b01      	cmp	r3, #1
 801338e:	d002      	beq.n	8013396 <OsCmdTokenSplit+0xcc>
 8013390:	693b      	ldr	r3, [r7, #16]
 8013392:	2b00      	cmp	r3, #0
 8013394:	d105      	bne.n	80133a2 <OsCmdTokenSplit+0xd8>
        ret = OsCmdParseOneToken(cmdParsed, count, token);
 8013396:	69fa      	ldr	r2, [r7, #28]
 8013398:	6979      	ldr	r1, [r7, #20]
 801339a:	6878      	ldr	r0, [r7, #4]
 801339c:	f7ff ff5b 	bl	8013256 <OsCmdParseOneToken>
 80133a0:	6238      	str	r0, [r7, #32]
    }

    return ret;
 80133a2:	6a3b      	ldr	r3, [r7, #32]
}
 80133a4:	4618      	mov	r0, r3
 80133a6:	3728      	adds	r7, #40	; 0x28
 80133a8:	46bd      	mov	sp, r7
 80133aa:	bd80      	pop	{r7, pc}

080133ac <OsCmdParse>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdParse(CHAR *cmdStr, CmdParsed *cmdParsed)
{
 80133ac:	b580      	push	{r7, lr}
 80133ae:	b082      	sub	sp, #8
 80133b0:	af00      	add	r7, sp, #0
 80133b2:	6078      	str	r0, [r7, #4]
 80133b4:	6039      	str	r1, [r7, #0]
    if ((cmdStr == NULL) || (cmdParsed == NULL) || (strlen(cmdStr) == 0)) {
 80133b6:	687b      	ldr	r3, [r7, #4]
 80133b8:	2b00      	cmp	r3, #0
 80133ba:	d008      	beq.n	80133ce <OsCmdParse+0x22>
 80133bc:	683b      	ldr	r3, [r7, #0]
 80133be:	2b00      	cmp	r3, #0
 80133c0:	d005      	beq.n	80133ce <OsCmdParse+0x22>
 80133c2:	6878      	ldr	r0, [r7, #4]
 80133c4:	f7fb fb61 	bl	800ea8a <strlen>
 80133c8:	4603      	mov	r3, r0
 80133ca:	2b00      	cmp	r3, #0
 80133cc:	d102      	bne.n	80133d4 <OsCmdParse+0x28>
        return (UINT32)OS_ERROR;
 80133ce:	f04f 33ff 	mov.w	r3, #4294967295
 80133d2:	e005      	b.n	80133e0 <OsCmdParse+0x34>
    }
    return OsCmdTokenSplit(cmdStr, ' ', cmdParsed);
 80133d4:	683a      	ldr	r2, [r7, #0]
 80133d6:	2120      	movs	r1, #32
 80133d8:	6878      	ldr	r0, [r7, #4]
 80133da:	f7ff ff76 	bl	80132ca <OsCmdTokenSplit>
 80133de:	4603      	mov	r3, r0
}
 80133e0:	4618      	mov	r0, r3
 80133e2:	3708      	adds	r7, #8
 80133e4:	46bd      	mov	sp, r7
 80133e6:	bd80      	pop	{r7, pc}

080133e8 <ShellStdinLoop>:
#include "shmsg.h"
#include "console.h"
#include "uart.h"

UINT32 ShellStdinLoop(ShellCB *shellCB)
{
 80133e8:	b580      	push	{r7, lr}
 80133ea:	b084      	sub	sp, #16
 80133ec:	af00      	add	r7, sp, #0
 80133ee:	6078      	str	r0, [r7, #4]
    UINT8 ch;
    while (1) {
        ch = uart_read();
 80133f0:	f7fc fd60 	bl	800feb4 <uart_read>
 80133f4:	4603      	mov	r3, r0
 80133f6:	73fb      	strb	r3, [r7, #15]
        ShellCmdLineParse(ch, (pf_OUTPUT)dprintf, shellCB);
 80133f8:	7bfb      	ldrb	r3, [r7, #15]
 80133fa:	687a      	ldr	r2, [r7, #4]
 80133fc:	4902      	ldr	r1, [pc, #8]	; (8013408 <ShellStdinLoop+0x20>)
 80133fe:	4618      	mov	r0, r3
 8013400:	f7ff fbac 	bl	8012b5c <ShellCmdLineParse>
        ch = uart_read();
 8013404:	e7f4      	b.n	80133f0 <ShellStdinLoop+0x8>
 8013406:	bf00      	nop
 8013408:	080046cd 	.word	0x080046cd

0801340c <ArchCurrCpuid>:
{
 801340c:	b480      	push	{r7}
 801340e:	af00      	add	r7, sp, #0
    return 0;
 8013410:	2300      	movs	r3, #0
}
 8013412:	4618      	mov	r0, r3
 8013414:	46bd      	mov	sp, r7
 8013416:	f85d 7b04 	ldr.w	r7, [sp], #4
 801341a:	4770      	bx	lr

0801341c <LOS_IntLock>:
{
 801341c:	b580      	push	{r7, lr}
 801341e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8013420:	f7ed fc52 	bl	8000cc8 <ArchIntLock>
 8013424:	4603      	mov	r3, r0
}
 8013426:	4618      	mov	r0, r3
 8013428:	bd80      	pop	{r7, pc}

0801342a <LOS_IntRestore>:
{
 801342a:	b580      	push	{r7, lr}
 801342c:	b082      	sub	sp, #8
 801342e:	af00      	add	r7, sp, #0
 8013430:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8013432:	6878      	ldr	r0, [r7, #4]
 8013434:	f7ed fc50 	bl	8000cd8 <ArchIntRestore>
}
 8013438:	bf00      	nop
 801343a:	3708      	adds	r7, #8
 801343c:	46bd      	mov	sp, r7
 801343e:	bd80      	pop	{r7, pc}

08013440 <LOS_SpinLock>:
{
 8013440:	b480      	push	{r7}
 8013442:	b083      	sub	sp, #12
 8013444:	af00      	add	r7, sp, #0
 8013446:	6078      	str	r0, [r7, #4]
}
 8013448:	bf00      	nop
 801344a:	370c      	adds	r7, #12
 801344c:	46bd      	mov	sp, r7
 801344e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013452:	4770      	bx	lr

08013454 <LOS_SpinUnlock>:
{
 8013454:	b480      	push	{r7}
 8013456:	b083      	sub	sp, #12
 8013458:	af00      	add	r7, sp, #0
 801345a:	6078      	str	r0, [r7, #4]
}
 801345c:	bf00      	nop
 801345e:	370c      	adds	r7, #12
 8013460:	46bd      	mov	sp, r7
 8013462:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013466:	4770      	bx	lr

08013468 <OsPercpuGet>:
{
 8013468:	b580      	push	{r7, lr}
 801346a:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 801346c:	f7ff ffce 	bl	801340c <ArchCurrCpuid>
 8013470:	4602      	mov	r2, r0
 8013472:	4613      	mov	r3, r2
 8013474:	00db      	lsls	r3, r3, #3
 8013476:	4413      	add	r3, r2
 8013478:	009b      	lsls	r3, r3, #2
 801347a:	4a02      	ldr	r2, [pc, #8]	; (8013484 <OsPercpuGet+0x1c>)
 801347c:	4413      	add	r3, r2
}
 801347e:	4618      	mov	r0, r3
 8013480:	bd80      	pop	{r7, pc}
 8013482:	bf00      	nop
 8013484:	200036fc 	.word	0x200036fc

08013488 <LOS_TicklessEnable>:
#define OS_GET_CYCLECOMPENSATE(cyclesPre, cyclesCur) (((cyclesPre) > (cyclesCur)) ? \
    (((GET_SYS_CLOCK()) / (g_tickPerSecond)) - (cyclesCur)) : \
    ((((GET_SYS_CLOCK()) / (g_tickPerSecond)) << 1) - (cyclesCur)))

LITE_OS_SEC_TEXT VOID LOS_TicklessEnable(VOID)
{
 8013488:	b480      	push	{r7}
 801348a:	af00      	add	r7, sp, #0
    g_ticklessFlag = TRUE;
 801348c:	4b03      	ldr	r3, [pc, #12]	; (801349c <LOS_TicklessEnable+0x14>)
 801348e:	2201      	movs	r2, #1
 8013490:	601a      	str	r2, [r3, #0]
}
 8013492:	bf00      	nop
 8013494:	46bd      	mov	sp, r7
 8013496:	f85d 7b04 	ldr.w	r7, [sp], #4
 801349a:	4770      	bx	lr
 801349c:	200032c0 	.word	0x200032c0

080134a0 <OsTickIrqFlagGet>:
{
    return g_ticklessFlag;
}

LITE_OS_SEC_TEXT BOOL OsTickIrqFlagGet(VOID)
{
 80134a0:	b580      	push	{r7, lr}
 80134a2:	af00      	add	r7, sp, #0
    return g_tickIrqFlag[ArchCurrCpuid()];
 80134a4:	f7ff ffb2 	bl	801340c <ArchCurrCpuid>
 80134a8:	4603      	mov	r3, r0
 80134aa:	4a02      	ldr	r2, [pc, #8]	; (80134b4 <OsTickIrqFlagGet+0x14>)
 80134ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 80134b0:	4618      	mov	r0, r3
 80134b2:	bd80      	pop	{r7, pc}
 80134b4:	200032c4 	.word	0x200032c4

080134b8 <OsTickIrqFlagSet>:

LITE_OS_SEC_TEXT VOID OsTickIrqFlagSet(BOOL tickIrqFlag)
{
 80134b8:	b580      	push	{r7, lr}
 80134ba:	b082      	sub	sp, #8
 80134bc:	af00      	add	r7, sp, #0
 80134be:	6078      	str	r0, [r7, #4]
    g_tickIrqFlag[ArchCurrCpuid()] = tickIrqFlag;
 80134c0:	f7ff ffa4 	bl	801340c <ArchCurrCpuid>
 80134c4:	4602      	mov	r2, r0
 80134c6:	4904      	ldr	r1, [pc, #16]	; (80134d8 <OsTickIrqFlagSet+0x20>)
 80134c8:	687b      	ldr	r3, [r7, #4]
 80134ca:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
 80134ce:	bf00      	nop
 80134d0:	3708      	adds	r7, #8
 80134d2:	46bd      	mov	sp, r7
 80134d4:	bd80      	pop	{r7, pc}
 80134d6:	bf00      	nop
 80134d8:	200032c4 	.word	0x200032c4

080134dc <OsTicklessSleepTickGet>:

LITE_OS_SEC_TEXT UINT32 OsTicklessSleepTickGet(VOID)
{
 80134dc:	b580      	push	{r7, lr}
 80134de:	af00      	add	r7, sp, #0
    return g_sleepTicks[ArchCurrCpuid()];
 80134e0:	f7ff ff94 	bl	801340c <ArchCurrCpuid>
 80134e4:	4603      	mov	r3, r0
 80134e6:	4a02      	ldr	r2, [pc, #8]	; (80134f0 <OsTicklessSleepTickGet+0x14>)
 80134e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 80134ec:	4618      	mov	r0, r3
 80134ee:	bd80      	pop	{r7, pc}
 80134f0:	200032c8 	.word	0x200032c8

080134f4 <OsTicklessSleepTickSet>:

LITE_OS_SEC_TEXT VOID OsTicklessSleepTickSet(UINT32 sleeptick)
{
 80134f4:	b580      	push	{r7, lr}
 80134f6:	b082      	sub	sp, #8
 80134f8:	af00      	add	r7, sp, #0
 80134fa:	6078      	str	r0, [r7, #4]
    g_sleepTicks[ArchCurrCpuid()] = sleeptick;
 80134fc:	f7ff ff86 	bl	801340c <ArchCurrCpuid>
 8013500:	4602      	mov	r2, r0
 8013502:	4904      	ldr	r1, [pc, #16]	; (8013514 <OsTicklessSleepTickSet+0x20>)
 8013504:	687b      	ldr	r3, [r7, #4]
 8013506:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
 801350a:	bf00      	nop
 801350c:	3708      	adds	r7, #8
 801350e:	46bd      	mov	sp, r7
 8013510:	bd80      	pop	{r7, pc}
 8013512:	bf00      	nop
 8013514:	200032c8 	.word	0x200032c8

08013518 <OsSleepTicksGet>:

LITE_OS_SEC_TEXT UINT32 OsSleepTicksGet(VOID)
{
 8013518:	b580      	push	{r7, lr}
 801351a:	b084      	sub	sp, #16
 801351c:	af00      	add	r7, sp, #0
    UINT32 tskSortLinkTicks, sleepTicks;

    UINT32 intSave = LOS_IntLock();
 801351e:	f7ff ff7d 	bl	801341c <LOS_IntLock>
 8013522:	6038      	str	r0, [r7, #0]
    LOS_SpinLock(&g_taskSpin);
 8013524:	4814      	ldr	r0, [pc, #80]	; (8013578 <OsSleepTicksGet+0x60>)
 8013526:	f7ff ff8b 	bl	8013440 <LOS_SpinLock>
    tskSortLinkTicks = OsSortLinkGetNextExpireTime(&OsPercpuGet()->taskSortLink);
 801352a:	f7ff ff9d 	bl	8013468 <OsPercpuGet>
 801352e:	4603      	mov	r3, r0
 8013530:	4618      	mov	r0, r3
 8013532:	f7f6 f9ef 	bl	8009914 <OsSortLinkGetNextExpireTime>
 8013536:	6078      	str	r0, [r7, #4]
    LOS_SpinUnlock(&g_taskSpin);
 8013538:	480f      	ldr	r0, [pc, #60]	; (8013578 <OsSleepTicksGet+0x60>)
 801353a:	f7ff ff8b 	bl	8013454 <LOS_SpinUnlock>

#ifdef LOSCFG_BASE_CORE_SWTMR
    UINT32 swtmrSortLinkTicks;
    LOS_SpinLock(&g_swtmrSpin);
 801353e:	480f      	ldr	r0, [pc, #60]	; (801357c <OsSleepTicksGet+0x64>)
 8013540:	f7ff ff7e 	bl	8013440 <LOS_SpinLock>
    swtmrSortLinkTicks = OsSortLinkGetNextExpireTime(&OsPercpuGet()->swtmrSortLink);
 8013544:	f7ff ff90 	bl	8013468 <OsPercpuGet>
 8013548:	4603      	mov	r3, r0
 801354a:	3308      	adds	r3, #8
 801354c:	4618      	mov	r0, r3
 801354e:	f7f6 f9e1 	bl	8009914 <OsSortLinkGetNextExpireTime>
 8013552:	60b8      	str	r0, [r7, #8]
    LOS_SpinUnlock(&g_swtmrSpin);
 8013554:	4809      	ldr	r0, [pc, #36]	; (801357c <OsSleepTicksGet+0x64>)
 8013556:	f7ff ff7d 	bl	8013454 <LOS_SpinUnlock>
    sleepTicks = (tskSortLinkTicks < swtmrSortLinkTicks) ? tskSortLinkTicks : swtmrSortLinkTicks;
 801355a:	68ba      	ldr	r2, [r7, #8]
 801355c:	687b      	ldr	r3, [r7, #4]
 801355e:	4293      	cmp	r3, r2
 8013560:	bf28      	it	cs
 8013562:	4613      	movcs	r3, r2
 8013564:	60fb      	str	r3, [r7, #12]
#else
    sleepTicks = tskSortLinkTicks;
#endif

    LOS_IntRestore(intSave);
 8013566:	6838      	ldr	r0, [r7, #0]
 8013568:	f7ff ff5f 	bl	801342a <LOS_IntRestore>
    return sleepTicks;
 801356c:	68fb      	ldr	r3, [r7, #12]
}
 801356e:	4618      	mov	r0, r3
 8013570:	3710      	adds	r7, #16
 8013572:	46bd      	mov	sp, r7
 8013574:	bd80      	pop	{r7, pc}
 8013576:	bf00      	nop
 8013578:	20000764 	.word	0x20000764
 801357c:	20000798 	.word	0x20000798

08013580 <OsSysTimeUpdate>:

LITE_OS_SEC_TEXT VOID OsSysTimeUpdate(UINT32 sleepTicks)
{
 8013580:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013582:	b085      	sub	sp, #20
 8013584:	af00      	add	r7, sp, #0
 8013586:	6078      	str	r0, [r7, #4]
    UINT32 intSave;

    if (sleepTicks == 0) {
 8013588:	687b      	ldr	r3, [r7, #4]
 801358a:	2b00      	cmp	r3, #0
 801358c:	d036      	beq.n	80135fc <OsSysTimeUpdate+0x7c>
        return;
    }

    intSave = LOS_IntLock();
 801358e:	f7ff ff45 	bl	801341c <LOS_IntLock>
 8013592:	60f8      	str	r0, [r7, #12]
    g_tickCount[ArchCurrCpuid()] += (sleepTicks - 1);
 8013594:	f7ff ff3a 	bl	801340c <ArchCurrCpuid>
 8013598:	4606      	mov	r6, r0
 801359a:	4a1a      	ldr	r2, [pc, #104]	; (8013604 <OsSysTimeUpdate+0x84>)
 801359c:	00f3      	lsls	r3, r6, #3
 801359e:	4413      	add	r3, r2
 80135a0:	e9d3 0100 	ldrd	r0, r1, [r3]
 80135a4:	687b      	ldr	r3, [r7, #4]
 80135a6:	3b01      	subs	r3, #1
 80135a8:	461a      	mov	r2, r3
 80135aa:	f04f 0300 	mov.w	r3, #0
 80135ae:	1884      	adds	r4, r0, r2
 80135b0:	eb41 0503 	adc.w	r5, r1, r3
 80135b4:	4a13      	ldr	r2, [pc, #76]	; (8013604 <OsSysTimeUpdate+0x84>)
 80135b6:	00f3      	lsls	r3, r6, #3
 80135b8:	4413      	add	r3, r2
 80135ba:	e9c3 4500 	strd	r4, r5, [r3]
    LOS_SpinLock(&g_taskSpin);
 80135be:	4812      	ldr	r0, [pc, #72]	; (8013608 <OsSysTimeUpdate+0x88>)
 80135c0:	f7ff ff3e 	bl	8013440 <LOS_SpinLock>
    OsSortLinkUpdateExpireTime(sleepTicks, &OsPercpuGet()->taskSortLink);
 80135c4:	f7ff ff50 	bl	8013468 <OsPercpuGet>
 80135c8:	4603      	mov	r3, r0
 80135ca:	4619      	mov	r1, r3
 80135cc:	6878      	ldr	r0, [r7, #4]
 80135ce:	f7f6 f9f9 	bl	80099c4 <OsSortLinkUpdateExpireTime>
    LOS_SpinUnlock(&g_taskSpin);
 80135d2:	480d      	ldr	r0, [pc, #52]	; (8013608 <OsSysTimeUpdate+0x88>)
 80135d4:	f7ff ff3e 	bl	8013454 <LOS_SpinUnlock>

#ifdef LOSCFG_BASE_CORE_SWTMR
    LOS_SpinLock(&g_swtmrSpin);
 80135d8:	480c      	ldr	r0, [pc, #48]	; (801360c <OsSysTimeUpdate+0x8c>)
 80135da:	f7ff ff31 	bl	8013440 <LOS_SpinLock>
    OsSortLinkUpdateExpireTime(sleepTicks, &OsPercpuGet()->swtmrSortLink);
 80135de:	f7ff ff43 	bl	8013468 <OsPercpuGet>
 80135e2:	4603      	mov	r3, r0
 80135e4:	3308      	adds	r3, #8
 80135e6:	4619      	mov	r1, r3
 80135e8:	6878      	ldr	r0, [r7, #4]
 80135ea:	f7f6 f9eb 	bl	80099c4 <OsSortLinkUpdateExpireTime>
    LOS_SpinUnlock(&g_swtmrSpin);
 80135ee:	4807      	ldr	r0, [pc, #28]	; (801360c <OsSysTimeUpdate+0x8c>)
 80135f0:	f7ff ff30 	bl	8013454 <LOS_SpinUnlock>
#endif

    LOS_IntRestore(intSave);
 80135f4:	68f8      	ldr	r0, [r7, #12]
 80135f6:	f7ff ff18 	bl	801342a <LOS_IntRestore>
 80135fa:	e000      	b.n	80135fe <OsSysTimeUpdate+0x7e>
        return;
 80135fc:	bf00      	nop
}
 80135fe:	3714      	adds	r7, #20
 8013600:	46bd      	mov	sp, r7
 8013602:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013604:	20000778 	.word	0x20000778
 8013608:	20000764 	.word	0x20000764
 801360c:	20000798 	.word	0x20000798

08013610 <OsTicklessUpdate>:

VOID OsTicklessUpdate(UINT32 irqnum)
{
 8013610:	b580      	push	{r7, lr}
 8013612:	b088      	sub	sp, #32
 8013614:	af00      	add	r7, sp, #0
 8013616:	6078      	str	r0, [r7, #4]
    UINT32 cycles, ticks;
    UINT32 cyclesPertick;
    UINT32 sleepTicks;
    UINT32 intSave = LOS_IntLock();
 8013618:	f7ff ff00 	bl	801341c <LOS_IntLock>
 801361c:	60f8      	str	r0, [r7, #12]

    sleepTicks = OsTicklessSleepTickGet();
 801361e:	f7ff ff5d 	bl	80134dc <OsTicklessSleepTickGet>
 8013622:	6138      	str	r0, [r7, #16]
    if (sleepTicks == 0) {
 8013624:	693b      	ldr	r3, [r7, #16]
 8013626:	2b00      	cmp	r3, #0
 8013628:	d103      	bne.n	8013632 <OsTicklessUpdate+0x22>
        LOS_IntRestore(intSave);
 801362a:	68f8      	ldr	r0, [r7, #12]
 801362c:	f7ff fefd 	bl	801342a <LOS_IntRestore>
        return;
 8013630:	e03e      	b.n	80136b0 <OsTicklessUpdate+0xa0>
    }

    cyclesPertick = GET_SYS_CLOCK() / LOSCFG_BASE_CORE_TICK_PER_SECOND;
 8013632:	4b21      	ldr	r3, [pc, #132]	; (80136b8 <OsTicklessUpdate+0xa8>)
 8013634:	681b      	ldr	r3, [r3, #0]
 8013636:	4a21      	ldr	r2, [pc, #132]	; (80136bc <OsTicklessUpdate+0xac>)
 8013638:	fba2 2303 	umull	r2, r3, r2, r3
 801363c:	099b      	lsrs	r3, r3, #6
 801363e:	617b      	str	r3, [r7, #20]
    if (irqnum == OS_TICK_INT_NUM) {
 8013640:	687b      	ldr	r3, [r7, #4]
 8013642:	2b0f      	cmp	r3, #15
 8013644:	d103      	bne.n	801364e <OsTicklessUpdate+0x3e>
        OsSysTimeUpdate(sleepTicks);
 8013646:	6938      	ldr	r0, [r7, #16]
 8013648:	f7ff ff9a 	bl	8013580 <OsSysTimeUpdate>
 801364c:	e02a      	b.n	80136a4 <OsTicklessUpdate+0x94>
    } else {
        cycles = HalClockGetTickTimerCycles();
 801364e:	f7fc fb3b 	bl	800fcc8 <HalClockGetTickTimerCycles>
 8013652:	61b8      	str	r0, [r7, #24]
        cycles = (sleepTicks * cyclesPertick) - cycles;
 8013654:	693b      	ldr	r3, [r7, #16]
 8013656:	697a      	ldr	r2, [r7, #20]
 8013658:	fb02 f203 	mul.w	r2, r2, r3
 801365c:	69bb      	ldr	r3, [r7, #24]
 801365e:	1ad3      	subs	r3, r2, r3
 8013660:	61bb      	str	r3, [r7, #24]
        ticks = cycles / cyclesPertick;
 8013662:	69ba      	ldr	r2, [r7, #24]
 8013664:	697b      	ldr	r3, [r7, #20]
 8013666:	fbb2 f3f3 	udiv	r3, r2, r3
 801366a:	61fb      	str	r3, [r7, #28]
        if (ticks < sleepTicks) {
 801366c:	69fa      	ldr	r2, [r7, #28]
 801366e:	693b      	ldr	r3, [r7, #16]
 8013670:	429a      	cmp	r2, r3
 8013672:	d214      	bcs.n	801369e <OsTicklessUpdate+0x8e>
            cycles = cycles % cyclesPertick;
 8013674:	69bb      	ldr	r3, [r7, #24]
 8013676:	697a      	ldr	r2, [r7, #20]
 8013678:	fbb3 f2f2 	udiv	r2, r3, r2
 801367c:	6979      	ldr	r1, [r7, #20]
 801367e:	fb01 f202 	mul.w	r2, r1, r2
 8013682:	1a9b      	subs	r3, r3, r2
 8013684:	61bb      	str	r3, [r7, #24]
            OsSysTimeUpdate(ticks + 1);
 8013686:	69fb      	ldr	r3, [r7, #28]
 8013688:	3301      	adds	r3, #1
 801368a:	4618      	mov	r0, r3
 801368c:	f7ff ff78 	bl	8013580 <OsSysTimeUpdate>
            HalClockTickTimerReload(cyclesPertick - cycles);
 8013690:	697a      	ldr	r2, [r7, #20]
 8013692:	69bb      	ldr	r3, [r7, #24]
 8013694:	1ad3      	subs	r3, r2, r3
 8013696:	4618      	mov	r0, r3
 8013698:	f7fc fb22 	bl	800fce0 <HalClockTickTimerReload>
 801369c:	e002      	b.n	80136a4 <OsTicklessUpdate+0x94>
            /*
             * If ticks is greater or equal to sleepTicks, it means the tick has already
             * arrived, it should compensate with the sleepTicks just as that will be done
             * in tick handler.
             */
            OsSysTimeUpdate(sleepTicks);
 801369e:	6938      	ldr	r0, [r7, #16]
 80136a0:	f7ff ff6e 	bl	8013580 <OsSysTimeUpdate>
        }
    }
    OsTicklessSleepTickSet(0);
 80136a4:	2000      	movs	r0, #0
 80136a6:	f7ff ff25 	bl	80134f4 <OsTicklessSleepTickSet>

    LOS_IntRestore(intSave);
 80136aa:	68f8      	ldr	r0, [r7, #12]
 80136ac:	f7ff febd 	bl	801342a <LOS_IntRestore>
}
 80136b0:	3720      	adds	r7, #32
 80136b2:	46bd      	mov	sp, r7
 80136b4:	bd80      	pop	{r7, pc}
 80136b6:	bf00      	nop
 80136b8:	200036e0 	.word	0x200036e0
 80136bc:	10624dd3 	.word	0x10624dd3

080136c0 <OsTicklessStart>:

VOID OsTicklessStart(VOID)
{
 80136c0:	b580      	push	{r7, lr}
 80136c2:	b088      	sub	sp, #32
 80136c4:	af00      	add	r7, sp, #0
    UINT32 intSave;
    /*
     * The system has already started, GET_SYS_CLOCK() muse get a non-zero value and greater or equal to
     * LOSCFG_BASE_CORE_TICK_PER_SECOND (see OsTickInit). So the cyclesPerTick won't be zero.
     */
    UINT32 cyclesPerTick = GET_SYS_CLOCK() / LOSCFG_BASE_CORE_TICK_PER_SECOND;
 80136c6:	4b29      	ldr	r3, [pc, #164]	; (801376c <OsTicklessStart+0xac>)
 80136c8:	681b      	ldr	r3, [r3, #0]
 80136ca:	4a29      	ldr	r2, [pc, #164]	; (8013770 <OsTicklessStart+0xb0>)
 80136cc:	fba2 2303 	umull	r2, r3, r2, r3
 80136d0:	099b      	lsrs	r3, r3, #6
 80136d2:	607b      	str	r3, [r7, #4]
    UINT32 maxTicks = OS_NULL_INT / cyclesPerTick;
 80136d4:	f04f 32ff 	mov.w	r2, #4294967295
 80136d8:	687b      	ldr	r3, [r7, #4]
 80136da:	fbb2 f3f3 	udiv	r3, r2, r3
 80136de:	60bb      	str	r3, [r7, #8]
    UINT32 sleepTicks;
    UINT32 cycles, cyclesPre, cyclesCur, cycleCompensate;

    intSave = LOS_IntLock();
 80136e0:	f7ff fe9c 	bl	801341c <LOS_IntLock>
 80136e4:	60f8      	str	r0, [r7, #12]
    /*
     * The sleep tick may be changed afterwards, cause interrupt has been disabled, the sleep tick
     * may increase but cannot decrease. Thus there's no need to spin here.
     */
    sleepTicks = OsSleepTicksGet();
 80136e6:	f7ff ff17 	bl	8013518 <OsSleepTicksGet>
 80136ea:	6038      	str	r0, [r7, #0]
    cyclesPre = HalClockGetTickTimerCycles();
 80136ec:	f7fc faec 	bl	800fcc8 <HalClockGetTickTimerCycles>
 80136f0:	6138      	str	r0, [r7, #16]

    if (sleepTicks > 1) {
 80136f2:	683b      	ldr	r3, [r7, #0]
 80136f4:	2b01      	cmp	r3, #1
 80136f6:	d931      	bls.n	801375c <OsTicklessStart+0x9c>
        if (sleepTicks >= maxTicks) {
 80136f8:	683a      	ldr	r2, [r7, #0]
 80136fa:	68bb      	ldr	r3, [r7, #8]
 80136fc:	429a      	cmp	r2, r3
 80136fe:	d301      	bcc.n	8013704 <OsTicklessStart+0x44>
            sleepTicks = maxTicks;
 8013700:	68bb      	ldr	r3, [r7, #8]
 8013702:	603b      	str	r3, [r7, #0]
        }
        cycles = sleepTicks * cyclesPerTick;
 8013704:	683b      	ldr	r3, [r7, #0]
 8013706:	687a      	ldr	r2, [r7, #4]
 8013708:	fb02 f303 	mul.w	r3, r2, r3
 801370c:	617b      	str	r3, [r7, #20]
        cyclesCur = HalClockGetTickTimerCycles();
 801370e:	f7fc fadb 	bl	800fcc8 <HalClockGetTickTimerCycles>
 8013712:	61b8      	str	r0, [r7, #24]
        cycleCompensate = OS_GET_CYCLECOMPENSATE(cyclesPre, cyclesCur);
 8013714:	693a      	ldr	r2, [r7, #16]
 8013716:	69bb      	ldr	r3, [r7, #24]
 8013718:	429a      	cmp	r2, r3
 801371a:	d908      	bls.n	801372e <OsTicklessStart+0x6e>
 801371c:	4b13      	ldr	r3, [pc, #76]	; (801376c <OsTicklessStart+0xac>)
 801371e:	681a      	ldr	r2, [r3, #0]
 8013720:	4b14      	ldr	r3, [pc, #80]	; (8013774 <OsTicklessStart+0xb4>)
 8013722:	681b      	ldr	r3, [r3, #0]
 8013724:	fbb2 f2f3 	udiv	r2, r2, r3
 8013728:	69bb      	ldr	r3, [r7, #24]
 801372a:	1ad3      	subs	r3, r2, r3
 801372c:	e008      	b.n	8013740 <OsTicklessStart+0x80>
 801372e:	4b0f      	ldr	r3, [pc, #60]	; (801376c <OsTicklessStart+0xac>)
 8013730:	681a      	ldr	r2, [r3, #0]
 8013732:	4b10      	ldr	r3, [pc, #64]	; (8013774 <OsTicklessStart+0xb4>)
 8013734:	681b      	ldr	r3, [r3, #0]
 8013736:	fbb2 f3f3 	udiv	r3, r2, r3
 801373a:	005a      	lsls	r2, r3, #1
 801373c:	69bb      	ldr	r3, [r7, #24]
 801373e:	1ad3      	subs	r3, r2, r3
 8013740:	61fb      	str	r3, [r7, #28]
        HalClockTickTimerReload(cycles - cycleCompensate);
 8013742:	697a      	ldr	r2, [r7, #20]
 8013744:	69fb      	ldr	r3, [r7, #28]
 8013746:	1ad3      	subs	r3, r2, r3
 8013748:	4618      	mov	r0, r3
 801374a:	f7fc fac9 	bl	800fce0 <HalClockTickTimerReload>
        OsTicklessSleepTickSet(sleepTicks);
 801374e:	6838      	ldr	r0, [r7, #0]
 8013750:	f7ff fed0 	bl	80134f4 <OsTicklessSleepTickSet>
        LOS_IntRestore(intSave);
 8013754:	68f8      	ldr	r0, [r7, #12]
 8013756:	f7ff fe68 	bl	801342a <LOS_IntRestore>

        return;
 801375a:	e003      	b.n	8013764 <OsTicklessStart+0xa4>
    }
    LOS_IntRestore(intSave);
 801375c:	68f8      	ldr	r0, [r7, #12]
 801375e:	f7ff fe64 	bl	801342a <LOS_IntRestore>
    return;
 8013762:	bf00      	nop
}
 8013764:	3720      	adds	r7, #32
 8013766:	46bd      	mov	sp, r7
 8013768:	bd80      	pop	{r7, pc}
 801376a:	bf00      	nop
 801376c:	200036e0 	.word	0x200036e0
 8013770:	10624dd3 	.word	0x10624dd3
 8013774:	200036e4 	.word	0x200036e4

08013778 <OsTicklessOpen>:

VOID OsTicklessOpen(VOID)
{
 8013778:	b580      	push	{r7, lr}
 801377a:	af00      	add	r7, sp, #0
    if (OsTickIrqFlagGet()) {
 801377c:	f7ff fe90 	bl	80134a0 <OsTickIrqFlagGet>
 8013780:	4603      	mov	r3, r0
 8013782:	2b00      	cmp	r3, #0
 8013784:	d004      	beq.n	8013790 <OsTicklessOpen+0x18>
        OsTickIrqFlagSet(0);
 8013786:	2000      	movs	r0, #0
 8013788:	f7ff fe96 	bl	80134b8 <OsTickIrqFlagSet>
        OsTicklessStart();
 801378c:	f7ff ff98 	bl	80136c0 <OsTicklessStart>
    }
}
 8013790:	bf00      	nop
 8013792:	bd80      	pop	{r7, pc}

08013794 <ArchCurrCpuid>:
{
 8013794:	b480      	push	{r7}
 8013796:	af00      	add	r7, sp, #0
    return 0;
 8013798:	2300      	movs	r3, #0
}
 801379a:	4618      	mov	r0, r3
 801379c:	46bd      	mov	sp, r7
 801379e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80137a2:	4770      	bx	lr

080137a4 <LOS_IntLock>:
{
 80137a4:	b580      	push	{r7, lr}
 80137a6:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80137a8:	f7ed fa8e 	bl	8000cc8 <ArchIntLock>
 80137ac:	4603      	mov	r3, r0
}
 80137ae:	4618      	mov	r0, r3
 80137b0:	bd80      	pop	{r7, pc}

080137b2 <LOS_IntRestore>:
{
 80137b2:	b580      	push	{r7, lr}
 80137b4:	b082      	sub	sp, #8
 80137b6:	af00      	add	r7, sp, #0
 80137b8:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80137ba:	6878      	ldr	r0, [r7, #4]
 80137bc:	f7ed fa8c 	bl	8000cd8 <ArchIntRestore>
}
 80137c0:	bf00      	nop
 80137c2:	3708      	adds	r7, #8
 80137c4:	46bd      	mov	sp, r7
 80137c6:	bd80      	pop	{r7, pc}

080137c8 <ArchCurrTaskGet>:
{
 80137c8:	b480      	push	{r7}
 80137ca:	af00      	add	r7, sp, #0
    return g_runTask;
 80137cc:	4b03      	ldr	r3, [pc, #12]	; (80137dc <ArchCurrTaskGet+0x14>)
 80137ce:	681b      	ldr	r3, [r3, #0]
}
 80137d0:	4618      	mov	r0, r3
 80137d2:	46bd      	mov	sp, r7
 80137d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80137d8:	4770      	bx	lr
 80137da:	bf00      	nop
 80137dc:	200033bc 	.word	0x200033bc

080137e0 <OsCurrTaskGet>:
{
 80137e0:	b580      	push	{r7, lr}
 80137e2:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 80137e4:	f7ff fff0 	bl	80137c8 <ArchCurrTaskGet>
 80137e8:	4603      	mov	r3, r0
}
 80137ea:	4618      	mov	r0, r3
 80137ec:	bd80      	pop	{r7, pc}
	...

080137f0 <OsCpupCBGet>:

#define CPUP_PRE_POS(pos) (((pos) == 0) ? (OS_CPUP_HISTORY_RECORD_NUM - 1) : ((pos) - 1))
#define CPUP_POST_POS(pos) (((pos) == (OS_CPUP_HISTORY_RECORD_NUM - 1)) ? 0 : ((pos) + 1))

LITE_OS_SEC_TEXT_INIT OsCpupCB *OsCpupCBGet(UINT32 index)
{
 80137f0:	b480      	push	{r7}
 80137f2:	b083      	sub	sp, #12
 80137f4:	af00      	add	r7, sp, #0
 80137f6:	6078      	str	r0, [r7, #4]
    return &g_cpup[index];
 80137f8:	4b06      	ldr	r3, [pc, #24]	; (8013814 <OsCpupCBGet+0x24>)
 80137fa:	6819      	ldr	r1, [r3, #0]
 80137fc:	687a      	ldr	r2, [r7, #4]
 80137fe:	4613      	mov	r3, r2
 8013800:	011b      	lsls	r3, r3, #4
 8013802:	1a9b      	subs	r3, r3, r2
 8013804:	00db      	lsls	r3, r3, #3
 8013806:	440b      	add	r3, r1
}
 8013808:	4618      	mov	r0, r3
 801380a:	370c      	adds	r7, #12
 801380c:	46bd      	mov	sp, r7
 801380e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013812:	4770      	bx	lr
 8013814:	200032d0 	.word	0x200032d0

08013818 <OsCpupGuard>:

LITE_OS_SEC_TEXT_INIT VOID OsCpupGuard(VOID)
{
 8013818:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801381c:	b089      	sub	sp, #36	; 0x24
 801381e:	af00      	add	r7, sp, #0
    UINT16 prevPos = g_hisPos;
 8013820:	4b5d      	ldr	r3, [pc, #372]	; (8013998 <OsCpupGuard+0x180>)
 8013822:	881b      	ldrh	r3, [r3, #0]
 8013824:	823b      	strh	r3, [r7, #16]
    UINT16 loop;
    UINT16 runTaskId;
    UINT64 curCycle;
    UINT32 intSave;

    if (g_cpupInitFlg == 0) {
 8013826:	4b5d      	ldr	r3, [pc, #372]	; (801399c <OsCpupGuard+0x184>)
 8013828:	881b      	ldrh	r3, [r3, #0]
 801382a:	2b00      	cmp	r3, #0
 801382c:	f000 80ae 	beq.w	801398c <OsCpupGuard+0x174>
        return;
    }
    intSave = LOS_IntLock();
 8013830:	f7ff ffb8 	bl	80137a4 <LOS_IntLock>
 8013834:	6178      	str	r0, [r7, #20]
    curCycle = OsCpupGetCycle();
 8013836:	f000 f957 	bl	8013ae8 <OsCpupGetCycle>
 801383a:	e9c7 0106 	strd	r0, r1, [r7, #24]

    g_hisPos = CPUP_POST_POS(g_hisPos);
 801383e:	4b56      	ldr	r3, [pc, #344]	; (8013998 <OsCpupGuard+0x180>)
 8013840:	881b      	ldrh	r3, [r3, #0]
 8013842:	2b0a      	cmp	r3, #10
 8013844:	d004      	beq.n	8013850 <OsCpupGuard+0x38>
 8013846:	4b54      	ldr	r3, [pc, #336]	; (8013998 <OsCpupGuard+0x180>)
 8013848:	881b      	ldrh	r3, [r3, #0]
 801384a:	3301      	adds	r3, #1
 801384c:	b29b      	uxth	r3, r3
 801384e:	e000      	b.n	8013852 <OsCpupGuard+0x3a>
 8013850:	2300      	movs	r3, #0
 8013852:	4a51      	ldr	r2, [pc, #324]	; (8013998 <OsCpupGuard+0x180>)
 8013854:	8013      	strh	r3, [r2, #0]
    cpuHistoryTime[prevPos] = curCycle;
 8013856:	8a3b      	ldrh	r3, [r7, #16]
 8013858:	4a51      	ldr	r2, [pc, #324]	; (80139a0 <OsCpupGuard+0x188>)
 801385a:	00db      	lsls	r3, r3, #3
 801385c:	18d1      	adds	r1, r2, r3
 801385e:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8013862:	e9c1 2300 	strd	r2, r3, [r1]

    for (loop = 0; loop < g_cpupMaxNum; loop++) {
 8013866:	2300      	movs	r3, #0
 8013868:	81fb      	strh	r3, [r7, #14]
 801386a:	e01a      	b.n	80138a2 <OsCpupGuard+0x8a>
        g_cpup[loop].historyTime[prevPos] = g_cpup[loop].allTime;
 801386c:	4b4d      	ldr	r3, [pc, #308]	; (80139a4 <OsCpupGuard+0x18c>)
 801386e:	6819      	ldr	r1, [r3, #0]
 8013870:	89fa      	ldrh	r2, [r7, #14]
 8013872:	4613      	mov	r3, r2
 8013874:	011b      	lsls	r3, r3, #4
 8013876:	1a9b      	subs	r3, r3, r2
 8013878:	00db      	lsls	r3, r3, #3
 801387a:	18ce      	adds	r6, r1, r3
 801387c:	4b49      	ldr	r3, [pc, #292]	; (80139a4 <OsCpupGuard+0x18c>)
 801387e:	6819      	ldr	r1, [r3, #0]
 8013880:	89fa      	ldrh	r2, [r7, #14]
 8013882:	4613      	mov	r3, r2
 8013884:	011b      	lsls	r3, r3, #4
 8013886:	1a9b      	subs	r3, r3, r2
 8013888:	00db      	lsls	r3, r3, #3
 801388a:	18c8      	adds	r0, r1, r3
 801388c:	8a39      	ldrh	r1, [r7, #16]
 801388e:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8013892:	3103      	adds	r1, #3
 8013894:	00c9      	lsls	r1, r1, #3
 8013896:	4401      	add	r1, r0
 8013898:	e9c1 2300 	strd	r2, r3, [r1]
    for (loop = 0; loop < g_cpupMaxNum; loop++) {
 801389c:	89fb      	ldrh	r3, [r7, #14]
 801389e:	3301      	adds	r3, #1
 80138a0:	81fb      	strh	r3, [r7, #14]
 80138a2:	4b41      	ldr	r3, [pc, #260]	; (80139a8 <OsCpupGuard+0x190>)
 80138a4:	881b      	ldrh	r3, [r3, #0]
 80138a6:	89fa      	ldrh	r2, [r7, #14]
 80138a8:	429a      	cmp	r2, r3
 80138aa:	d3df      	bcc.n	801386c <OsCpupGuard+0x54>
    }

    for (loop = 0; loop < LOSCFG_KERNEL_CORE_NUM; loop++) {
 80138ac:	2300      	movs	r3, #0
 80138ae:	81fb      	strh	r3, [r7, #14]
 80138b0:	e065      	b.n	801397e <OsCpupGuard+0x166>
        runTaskId = runningTasks[loop];
 80138b2:	89fb      	ldrh	r3, [r7, #14]
 80138b4:	4a3d      	ldr	r2, [pc, #244]	; (80139ac <OsCpupGuard+0x194>)
 80138b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80138ba:	827b      	strh	r3, [r7, #18]
        /* reacquire the cycle to prevent flip */
        curCycle = OsCpupGetCycle();
 80138bc:	f000 f914 	bl	8013ae8 <OsCpupGetCycle>
 80138c0:	e9c7 0106 	strd	r0, r1, [r7, #24]
        g_cpup[runTaskId].historyTime[prevPos] += curCycle - g_cpup[runTaskId].startTime;
 80138c4:	4b37      	ldr	r3, [pc, #220]	; (80139a4 <OsCpupGuard+0x18c>)
 80138c6:	6819      	ldr	r1, [r3, #0]
 80138c8:	8a7a      	ldrh	r2, [r7, #18]
 80138ca:	4613      	mov	r3, r2
 80138cc:	011b      	lsls	r3, r3, #4
 80138ce:	1a9b      	subs	r3, r3, r2
 80138d0:	00db      	lsls	r3, r3, #3
 80138d2:	18ca      	adds	r2, r1, r3
 80138d4:	8a3b      	ldrh	r3, [r7, #16]
 80138d6:	3303      	adds	r3, #3
 80138d8:	00db      	lsls	r3, r3, #3
 80138da:	4413      	add	r3, r2
 80138dc:	e9d3 0100 	ldrd	r0, r1, [r3]
 80138e0:	4b30      	ldr	r3, [pc, #192]	; (80139a4 <OsCpupGuard+0x18c>)
 80138e2:	681e      	ldr	r6, [r3, #0]
 80138e4:	8a7a      	ldrh	r2, [r7, #18]
 80138e6:	4613      	mov	r3, r2
 80138e8:	011b      	lsls	r3, r3, #4
 80138ea:	1a9b      	subs	r3, r3, r2
 80138ec:	00db      	lsls	r3, r3, #3
 80138ee:	4433      	add	r3, r6
 80138f0:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80138f4:	e9d7 8906 	ldrd	r8, r9, [r7, #24]
 80138f8:	ebb8 0402 	subs.w	r4, r8, r2
 80138fc:	eb69 0503 	sbc.w	r5, r9, r3
 8013900:	4b28      	ldr	r3, [pc, #160]	; (80139a4 <OsCpupGuard+0x18c>)
 8013902:	681e      	ldr	r6, [r3, #0]
 8013904:	8a7a      	ldrh	r2, [r7, #18]
 8013906:	4613      	mov	r3, r2
 8013908:	011b      	lsls	r3, r3, #4
 801390a:	1a9b      	subs	r3, r3, r2
 801390c:	00db      	lsls	r3, r3, #3
 801390e:	18f2      	adds	r2, r6, r3
 8013910:	8a3b      	ldrh	r3, [r7, #16]
 8013912:	eb10 0a04 	adds.w	sl, r0, r4
 8013916:	eb41 0b05 	adc.w	fp, r1, r5
 801391a:	3303      	adds	r3, #3
 801391c:	00db      	lsls	r3, r3, #3
 801391e:	4413      	add	r3, r2
 8013920:	e9c3 ab00 	strd	sl, fp, [r3]
#ifdef LOSCFG_CPUP_INCLUDE_IRQ
        g_cpup[runTaskId].historyTime[prevPos] -= g_timeInIrqPerTskSwitch[loop];
 8013924:	4b1f      	ldr	r3, [pc, #124]	; (80139a4 <OsCpupGuard+0x18c>)
 8013926:	6819      	ldr	r1, [r3, #0]
 8013928:	8a7a      	ldrh	r2, [r7, #18]
 801392a:	4613      	mov	r3, r2
 801392c:	011b      	lsls	r3, r3, #4
 801392e:	1a9b      	subs	r3, r3, r2
 8013930:	00db      	lsls	r3, r3, #3
 8013932:	18ca      	adds	r2, r1, r3
 8013934:	8a3b      	ldrh	r3, [r7, #16]
 8013936:	3303      	adds	r3, #3
 8013938:	00db      	lsls	r3, r3, #3
 801393a:	4413      	add	r3, r2
 801393c:	e9d3 8900 	ldrd	r8, r9, [r3]
 8013940:	89fb      	ldrh	r3, [r7, #14]
 8013942:	4a1b      	ldr	r2, [pc, #108]	; (80139b0 <OsCpupGuard+0x198>)
 8013944:	00db      	lsls	r3, r3, #3
 8013946:	4413      	add	r3, r2
 8013948:	e9d3 0100 	ldrd	r0, r1, [r3]
 801394c:	4b15      	ldr	r3, [pc, #84]	; (80139a4 <OsCpupGuard+0x18c>)
 801394e:	681e      	ldr	r6, [r3, #0]
 8013950:	8a7a      	ldrh	r2, [r7, #18]
 8013952:	4613      	mov	r3, r2
 8013954:	011b      	lsls	r3, r3, #4
 8013956:	1a9b      	subs	r3, r3, r2
 8013958:	00db      	lsls	r3, r3, #3
 801395a:	18f2      	adds	r2, r6, r3
 801395c:	8a3b      	ldrh	r3, [r7, #16]
 801395e:	ebb8 0600 	subs.w	r6, r8, r0
 8013962:	603e      	str	r6, [r7, #0]
 8013964:	eb69 0101 	sbc.w	r1, r9, r1
 8013968:	6079      	str	r1, [r7, #4]
 801396a:	3303      	adds	r3, #3
 801396c:	00db      	lsls	r3, r3, #3
 801396e:	4413      	add	r3, r2
 8013970:	e9d7 1200 	ldrd	r1, r2, [r7]
 8013974:	e9c3 1200 	strd	r1, r2, [r3]
    for (loop = 0; loop < LOSCFG_KERNEL_CORE_NUM; loop++) {
 8013978:	89fb      	ldrh	r3, [r7, #14]
 801397a:	3301      	adds	r3, #1
 801397c:	81fb      	strh	r3, [r7, #14]
 801397e:	89fb      	ldrh	r3, [r7, #14]
 8013980:	2b00      	cmp	r3, #0
 8013982:	d096      	beq.n	80138b2 <OsCpupGuard+0x9a>
#endif
    }

    LOS_IntRestore(intSave);
 8013984:	6978      	ldr	r0, [r7, #20]
 8013986:	f7ff ff14 	bl	80137b2 <LOS_IntRestore>
 801398a:	e000      	b.n	801398e <OsCpupGuard+0x176>
        return;
 801398c:	bf00      	nop
}
 801398e:	3724      	adds	r7, #36	; 0x24
 8013990:	46bd      	mov	sp, r7
 8013992:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013996:	bf00      	nop
 8013998:	200032d8 	.word	0x200032d8
 801399c:	200032ce 	.word	0x200032ce
 80139a0:	200032e0 	.word	0x200032e0
 80139a4:	200032d0 	.word	0x200032d0
 80139a8:	200032d4 	.word	0x200032d4
 80139ac:	200004a0 	.word	0x200004a0
 80139b0:	20003770 	.word	0x20003770

080139b4 <OsCpupGuardCreator>:

LITE_OS_SEC_TEXT_INIT VOID OsCpupGuardCreator(VOID)
{
 80139b4:	b580      	push	{r7, lr}
 80139b6:	b082      	sub	sp, #8
 80139b8:	af02      	add	r7, sp, #8
    (VOID)LOS_SwtmrCreate(LOSCFG_BASE_CORE_TICK_PER_SECOND, LOS_SWTMR_MODE_PERIOD,
 80139ba:	2300      	movs	r3, #0
 80139bc:	9300      	str	r3, [sp, #0]
 80139be:	4b07      	ldr	r3, [pc, #28]	; (80139dc <OsCpupGuardCreator+0x28>)
 80139c0:	4a07      	ldr	r2, [pc, #28]	; (80139e0 <OsCpupGuardCreator+0x2c>)
 80139c2:	2101      	movs	r1, #1
 80139c4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80139c8:	f7f1 fbc8 	bl	800515c <LOS_SwtmrCreate>
                          (SWTMR_PROC_FUNC)OsCpupGuard, &g_cpupSwtmrId, 0);

    (VOID)LOS_SwtmrStart(g_cpupSwtmrId);
 80139cc:	4b03      	ldr	r3, [pc, #12]	; (80139dc <OsCpupGuardCreator+0x28>)
 80139ce:	881b      	ldrh	r3, [r3, #0]
 80139d0:	4618      	mov	r0, r3
 80139d2:	f7f1 fc6b 	bl	80052ac <LOS_SwtmrStart>
}
 80139d6:	bf00      	nop
 80139d8:	46bd      	mov	sp, r7
 80139da:	bd80      	pop	{r7, pc}
 80139dc:	200032cc 	.word	0x200032cc
 80139e0:	08013819 	.word	0x08013819

080139e4 <OsCpupGuardInit>:

LITE_OS_SEC_TEXT_INIT VOID OsCpupGuardInit(VOID)
{
 80139e4:	b580      	push	{r7, lr}
 80139e6:	b08c      	sub	sp, #48	; 0x30
 80139e8:	af00      	add	r7, sp, #0
 80139ea:	4b17      	ldr	r3, [pc, #92]	; (8013a48 <OsCpupGuardInit+0x64>)
 80139ec:	681b      	ldr	r3, [r3, #0]
 80139ee:	62fb      	str	r3, [r7, #44]	; 0x2c
 80139f0:	f04f 0300 	mov.w	r3, #0
    TSK_INIT_PARAM_S taskInitParam;
    UINT32 tempId;

    (VOID)memset_s((void *)(&taskInitParam), sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
 80139f4:	f107 0008 	add.w	r0, r7, #8
 80139f8:	2324      	movs	r3, #36	; 0x24
 80139fa:	2200      	movs	r2, #0
 80139fc:	2124      	movs	r1, #36	; 0x24
 80139fe:	f002 fb45 	bl	801608c <memset_s>
    taskInitParam.pfnTaskEntry  = (TSK_ENTRY_FUNC)OsCpupGuardCreator;
 8013a02:	4b12      	ldr	r3, [pc, #72]	; (8013a4c <OsCpupGuardInit+0x68>)
 8013a04:	60bb      	str	r3, [r7, #8]
    taskInitParam.uwStackSize   = LOS_TASK_MIN_STACK_SIZE;
 8013a06:	2108      	movs	r1, #8
 8013a08:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8013a0c:	f7ee fe5a 	bl	80026c4 <LOS_Align>
 8013a10:	4603      	mov	r3, r0
 8013a12:	623b      	str	r3, [r7, #32]
    taskInitParam.pcName        = "CpupGuardCreator";
 8013a14:	4b0e      	ldr	r3, [pc, #56]	; (8013a50 <OsCpupGuardInit+0x6c>)
 8013a16:	627b      	str	r3, [r7, #36]	; 0x24
    taskInitParam.usTaskPrio    = OS_TASK_PRIORITY_HIGHEST;
 8013a18:	2300      	movs	r3, #0
 8013a1a:	81bb      	strh	r3, [r7, #12]
    taskInitParam.uwResved      = LOS_TASK_STATUS_DETACHED;
 8013a1c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8013a20:	62bb      	str	r3, [r7, #40]	; 0x28
#ifdef LOSCFG_KERNEL_SMP
    taskInitParam.usCpuAffiMask = CPUID_TO_AFFI_MASK(ArchCurrCpuid());
#endif
    (VOID)LOS_TaskCreate(&tempId, &taskInitParam);
 8013a22:	f107 0208 	add.w	r2, r7, #8
 8013a26:	1d3b      	adds	r3, r7, #4
 8013a28:	4611      	mov	r1, r2
 8013a2a:	4618      	mov	r0, r3
 8013a2c:	f7ef ff84 	bl	8003938 <LOS_TaskCreate>
}
 8013a30:	bf00      	nop
 8013a32:	4b05      	ldr	r3, [pc, #20]	; (8013a48 <OsCpupGuardInit+0x64>)
 8013a34:	681a      	ldr	r2, [r3, #0]
 8013a36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013a38:	405a      	eors	r2, r3
 8013a3a:	d001      	beq.n	8013a40 <OsCpupGuardInit+0x5c>
 8013a3c:	f7f0 fcd4 	bl	80043e8 <__stack_chk_fail>
 8013a40:	3730      	adds	r7, #48	; 0x30
 8013a42:	46bd      	mov	sp, r7
 8013a44:	bd80      	pop	{r7, pc}
 8013a46:	bf00      	nop
 8013a48:	08022834 	.word	0x08022834
 8013a4c:	080139b5 	.word	0x080139b5
 8013a50:	08022820 	.word	0x08022820

08013a54 <OsCpupInit>:
/*
 * Description: initialization of CPUP
 * Return     : LOS_OK or Error Information
 */
LITE_OS_SEC_TEXT_INIT UINT32 OsCpupInit(VOID)
{
 8013a54:	b580      	push	{r7, lr}
 8013a56:	b082      	sub	sp, #8
 8013a58:	af00      	add	r7, sp, #0
    UINT32 size;

    g_cpupTaskMaxNum = g_taskMaxNum;
 8013a5a:	4b1c      	ldr	r3, [pc, #112]	; (8013acc <OsCpupInit+0x78>)
 8013a5c:	681b      	ldr	r3, [r3, #0]
 8013a5e:	b29a      	uxth	r2, r3
 8013a60:	4b1b      	ldr	r3, [pc, #108]	; (8013ad0 <OsCpupInit+0x7c>)
 8013a62:	801a      	strh	r2, [r3, #0]
    g_cpupMaxNum = g_cpupTaskMaxNum;
 8013a64:	4b1a      	ldr	r3, [pc, #104]	; (8013ad0 <OsCpupInit+0x7c>)
 8013a66:	881a      	ldrh	r2, [r3, #0]
 8013a68:	4b1a      	ldr	r3, [pc, #104]	; (8013ad4 <OsCpupInit+0x80>)
 8013a6a:	801a      	strh	r2, [r3, #0]
#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    g_cpupMaxNum += LOSCFG_PLATFORM_HWI_LIMIT;
 8013a6c:	4b19      	ldr	r3, [pc, #100]	; (8013ad4 <OsCpupInit+0x80>)
 8013a6e:	881b      	ldrh	r3, [r3, #0]
 8013a70:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8013a74:	b29a      	uxth	r2, r3
 8013a76:	4b17      	ldr	r3, [pc, #92]	; (8013ad4 <OsCpupInit+0x80>)
 8013a78:	801a      	strh	r2, [r3, #0]
#endif

    /* every task has only one record, and it won't operated at the same time */
    size = g_cpupMaxNum * sizeof(OsCpupCB);
 8013a7a:	4b16      	ldr	r3, [pc, #88]	; (8013ad4 <OsCpupInit+0x80>)
 8013a7c:	881b      	ldrh	r3, [r3, #0]
 8013a7e:	461a      	mov	r2, r3
 8013a80:	4613      	mov	r3, r2
 8013a82:	011b      	lsls	r3, r3, #4
 8013a84:	1a9b      	subs	r3, r3, r2
 8013a86:	00db      	lsls	r3, r3, #3
 8013a88:	607b      	str	r3, [r7, #4]
    g_cpup = (OsCpupCB *)LOS_MemAlloc(m_aucSysMem0, size);
 8013a8a:	4b13      	ldr	r3, [pc, #76]	; (8013ad8 <OsCpupInit+0x84>)
 8013a8c:	681b      	ldr	r3, [r3, #0]
 8013a8e:	6879      	ldr	r1, [r7, #4]
 8013a90:	4618      	mov	r0, r3
 8013a92:	f7f4 ff89 	bl	80089a8 <LOS_MemAlloc>
 8013a96:	4603      	mov	r3, r0
 8013a98:	4a10      	ldr	r2, [pc, #64]	; (8013adc <OsCpupInit+0x88>)
 8013a9a:	6013      	str	r3, [r2, #0]
    if (g_cpup == NULL) {
 8013a9c:	4b0f      	ldr	r3, [pc, #60]	; (8013adc <OsCpupInit+0x88>)
 8013a9e:	681b      	ldr	r3, [r3, #0]
 8013aa0:	2b00      	cmp	r3, #0
 8013aa2:	d101      	bne.n	8013aa8 <OsCpupInit+0x54>
        return LOS_ERRNO_CPUP_NO_MEMORY;
 8013aa4:	4b0e      	ldr	r3, [pc, #56]	; (8013ae0 <OsCpupInit+0x8c>)
 8013aa6:	e00c      	b.n	8013ac2 <OsCpupInit+0x6e>
    }

    OsCpupGuardInit();
 8013aa8:	f7ff ff9c 	bl	80139e4 <OsCpupGuardInit>

    (VOID)memset_s(g_cpup, size, 0, size);
 8013aac:	4b0b      	ldr	r3, [pc, #44]	; (8013adc <OsCpupInit+0x88>)
 8013aae:	6818      	ldr	r0, [r3, #0]
 8013ab0:	687b      	ldr	r3, [r7, #4]
 8013ab2:	2200      	movs	r2, #0
 8013ab4:	6879      	ldr	r1, [r7, #4]
 8013ab6:	f002 fae9 	bl	801608c <memset_s>
    g_cpupInitFlg = 1;
 8013aba:	4b0a      	ldr	r3, [pc, #40]	; (8013ae4 <OsCpupInit+0x90>)
 8013abc:	2201      	movs	r2, #1
 8013abe:	801a      	strh	r2, [r3, #0]

    return LOS_OK;
 8013ac0:	2300      	movs	r3, #0
}
 8013ac2:	4618      	mov	r0, r3
 8013ac4:	3708      	adds	r7, #8
 8013ac6:	46bd      	mov	sp, r7
 8013ac8:	bd80      	pop	{r7, pc}
 8013aca:	bf00      	nop
 8013acc:	200036d8 	.word	0x200036d8
 8013ad0:	200032d6 	.word	0x200032d6
 8013ad4:	200032d4 	.word	0x200032d4
 8013ad8:	200021b4 	.word	0x200021b4
 8013adc:	200032d0 	.word	0x200032d0
 8013ae0:	02001e00 	.word	0x02001e00
 8013ae4:	200032ce 	.word	0x200032ce

08013ae8 <OsCpupGetCycle>:
/*
 * Description: get current cycles count
 * Return     : current cycles count
 */
LITE_OS_SEC_TEXT_MINOR UINT64 OsCpupGetCycle(VOID)
{
 8013ae8:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8013aec:	b086      	sub	sp, #24
 8013aee:	af00      	add	r7, sp, #0
 8013af0:	4b2a      	ldr	r3, [pc, #168]	; (8013b9c <OsCpupGetCycle+0xb4>)
 8013af2:	681b      	ldr	r3, [r3, #0]
 8013af4:	617b      	str	r3, [r7, #20]
 8013af6:	f04f 0300 	mov.w	r3, #0
    UINT32 high;
    UINT32 low;
    UINT64 cycles;

    LOS_GetCpuCycle(&high, &low);
 8013afa:	1d3a      	adds	r2, r7, #4
 8013afc:	463b      	mov	r3, r7
 8013afe:	4611      	mov	r1, r2
 8013b00:	4618      	mov	r0, r3
 8013b02:	f7f0 fb65 	bl	80041d0 <LOS_GetCpuCycle>
    cycles = ((UINT64)high << HIGH_BITS) + low;
 8013b06:	683b      	ldr	r3, [r7, #0]
 8013b08:	4618      	mov	r0, r3
 8013b0a:	f04f 0100 	mov.w	r1, #0
 8013b0e:	f04f 0200 	mov.w	r2, #0
 8013b12:	f04f 0300 	mov.w	r3, #0
 8013b16:	0003      	movs	r3, r0
 8013b18:	2200      	movs	r2, #0
 8013b1a:	6879      	ldr	r1, [r7, #4]
 8013b1c:	4608      	mov	r0, r1
 8013b1e:	f04f 0100 	mov.w	r1, #0
 8013b22:	1814      	adds	r4, r2, r0
 8013b24:	eb43 0501 	adc.w	r5, r3, r1
 8013b28:	e9c7 4502 	strd	r4, r5, [r7, #8]
    if (g_startCycles == 0) {
 8013b2c:	4b1c      	ldr	r3, [pc, #112]	; (8013ba0 <OsCpupGetCycle+0xb8>)
 8013b2e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013b32:	4313      	orrs	r3, r2
 8013b34:	d104      	bne.n	8013b40 <OsCpupGetCycle+0x58>
        g_startCycles = cycles;
 8013b36:	491a      	ldr	r1, [pc, #104]	; (8013ba0 <OsCpupGetCycle+0xb8>)
 8013b38:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8013b3c:	e9c1 2300 	strd	r2, r3, [r1]

    /*
     * The cycles should keep growing, if the checking failed,
     * it mean LOS_GetCpuCycle has the problem which should be fixed.
     */
    LOS_ASSERT(cycles >= g_startCycles);
 8013b40:	4b17      	ldr	r3, [pc, #92]	; (8013ba0 <OsCpupGetCycle+0xb8>)
 8013b42:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013b46:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8013b4a:	4299      	cmp	r1, r3
 8013b4c:	bf08      	it	eq
 8013b4e:	4290      	cmpeq	r0, r2
 8013b50:	d20b      	bcs.n	8013b6a <OsCpupGetCycle+0x82>
 8013b52:	f7ff fe27 	bl	80137a4 <LOS_IntLock>
 8013b56:	4813      	ldr	r0, [pc, #76]	; (8013ba4 <OsCpupGetCycle+0xbc>)
 8013b58:	f7f0 fdb8 	bl	80046cc <dprintf>
 8013b5c:	4b12      	ldr	r3, [pc, #72]	; (8013ba8 <OsCpupGetCycle+0xc0>)
 8013b5e:	22e1      	movs	r2, #225	; 0xe1
 8013b60:	4912      	ldr	r1, [pc, #72]	; (8013bac <OsCpupGetCycle+0xc4>)
 8013b62:	4813      	ldr	r0, [pc, #76]	; (8013bb0 <OsCpupGetCycle+0xc8>)
 8013b64:	f7f0 fdb2 	bl	80046cc <dprintf>
 8013b68:	e7fe      	b.n	8013b68 <OsCpupGetCycle+0x80>

    return (cycles - g_startCycles);
 8013b6a:	4b0d      	ldr	r3, [pc, #52]	; (8013ba0 <OsCpupGetCycle+0xb8>)
 8013b6c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013b70:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8013b74:	ebb0 0802 	subs.w	r8, r0, r2
 8013b78:	eb61 0903 	sbc.w	r9, r1, r3
 8013b7c:	4642      	mov	r2, r8
 8013b7e:	464b      	mov	r3, r9
}
 8013b80:	4906      	ldr	r1, [pc, #24]	; (8013b9c <OsCpupGetCycle+0xb4>)
 8013b82:	6808      	ldr	r0, [r1, #0]
 8013b84:	6979      	ldr	r1, [r7, #20]
 8013b86:	4048      	eors	r0, r1
 8013b88:	d001      	beq.n	8013b8e <OsCpupGetCycle+0xa6>
 8013b8a:	f7f0 fc2d 	bl	80043e8 <__stack_chk_fail>
 8013b8e:	4610      	mov	r0, r2
 8013b90:	4619      	mov	r1, r3
 8013b92:	3718      	adds	r7, #24
 8013b94:	46bd      	mov	sp, r7
 8013b96:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 8013b9a:	bf00      	nop
 8013b9c:	08022868 	.word	0x08022868
 8013ba0:	20003340 	.word	0x20003340
 8013ba4:	08022838 	.word	0x08022838
 8013ba8:	08023688 	.word	0x08023688
 8013bac:	08022840 	.word	0x08022840
 8013bb0:	0802284c 	.word	0x0802284c

08013bb4 <OsTaskCycleStart>:

/*
 * Description: start task to get cycles count in current task beginning
 */
LITE_OS_SEC_TEXT_MINOR VOID OsTaskCycleStart(VOID)
{
 8013bb4:	b590      	push	{r4, r7, lr}
 8013bb6:	b083      	sub	sp, #12
 8013bb8:	af00      	add	r7, sp, #0
    UINT32 taskId;
    LosTaskCB *runTask = NULL;
 8013bba:	2300      	movs	r3, #0
 8013bbc:	603b      	str	r3, [r7, #0]

    if (g_cpupInitFlg == 0) {
 8013bbe:	4b13      	ldr	r3, [pc, #76]	; (8013c0c <OsTaskCycleStart+0x58>)
 8013bc0:	881b      	ldrh	r3, [r3, #0]
 8013bc2:	2b00      	cmp	r3, #0
 8013bc4:	d01e      	beq.n	8013c04 <OsTaskCycleStart+0x50>
        return;
    }

    runTask = OsCurrTaskGet();
 8013bc6:	f7ff fe0b 	bl	80137e0 <OsCurrTaskGet>
 8013bca:	6038      	str	r0, [r7, #0]
    taskId = runTask->taskId;
 8013bcc:	683b      	ldr	r3, [r7, #0]
 8013bce:	695b      	ldr	r3, [r3, #20]
 8013bd0:	607b      	str	r3, [r7, #4]

    g_cpup[taskId].id = taskId;
 8013bd2:	4b0f      	ldr	r3, [pc, #60]	; (8013c10 <OsTaskCycleStart+0x5c>)
 8013bd4:	6819      	ldr	r1, [r3, #0]
 8013bd6:	687a      	ldr	r2, [r7, #4]
 8013bd8:	4613      	mov	r3, r2
 8013bda:	011b      	lsls	r3, r3, #4
 8013bdc:	1a9b      	subs	r3, r3, r2
 8013bde:	00db      	lsls	r3, r3, #3
 8013be0:	440b      	add	r3, r1
 8013be2:	687a      	ldr	r2, [r7, #4]
 8013be4:	601a      	str	r2, [r3, #0]
    g_cpup[taskId].startTime = OsCpupGetCycle();
 8013be6:	4b0a      	ldr	r3, [pc, #40]	; (8013c10 <OsTaskCycleStart+0x5c>)
 8013be8:	6819      	ldr	r1, [r3, #0]
 8013bea:	687a      	ldr	r2, [r7, #4]
 8013bec:	4613      	mov	r3, r2
 8013bee:	011b      	lsls	r3, r3, #4
 8013bf0:	1a9b      	subs	r3, r3, r2
 8013bf2:	00db      	lsls	r3, r3, #3
 8013bf4:	18cc      	adds	r4, r1, r3
 8013bf6:	f7ff ff77 	bl	8013ae8 <OsCpupGetCycle>
 8013bfa:	4602      	mov	r2, r0
 8013bfc:	460b      	mov	r3, r1
 8013bfe:	e9c4 2304 	strd	r2, r3, [r4, #16]

    return;
 8013c02:	e000      	b.n	8013c06 <OsTaskCycleStart+0x52>
        return;
 8013c04:	bf00      	nop
}
 8013c06:	370c      	adds	r7, #12
 8013c08:	46bd      	mov	sp, r7
 8013c0a:	bd90      	pop	{r4, r7, pc}
 8013c0c:	200032ce 	.word	0x200032ce
 8013c10:	200032d0 	.word	0x200032d0

08013c14 <OsTaskCycleEnd>:

/*
 * Description: quit task and get cycle count
 */
LITE_OS_SEC_TEXT_MINOR VOID OsTaskCycleEnd(VOID)
{
 8013c14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013c18:	b089      	sub	sp, #36	; 0x24
 8013c1a:	af00      	add	r7, sp, #0
    UINT32 taskId;
    UINT64 cpuCycle;
    LosTaskCB *runTask = NULL;
 8013c1c:	2300      	movs	r3, #0
 8013c1e:	60fb      	str	r3, [r7, #12]

    if (g_cpupInitFlg == 0) {
 8013c20:	4b42      	ldr	r3, [pc, #264]	; (8013d2c <OsTaskCycleEnd+0x118>)
 8013c22:	881b      	ldrh	r3, [r3, #0]
 8013c24:	2b00      	cmp	r3, #0
 8013c26:	d07a      	beq.n	8013d1e <OsTaskCycleEnd+0x10a>
        return;
    }

    runTask = OsCurrTaskGet();
 8013c28:	f7ff fdda 	bl	80137e0 <OsCurrTaskGet>
 8013c2c:	60f8      	str	r0, [r7, #12]
    taskId = runTask->taskId;
 8013c2e:	68fb      	ldr	r3, [r7, #12]
 8013c30:	695b      	ldr	r3, [r3, #20]
 8013c32:	613b      	str	r3, [r7, #16]

    if (g_cpup[taskId].startTime == 0) {
 8013c34:	4b3e      	ldr	r3, [pc, #248]	; (8013d30 <OsTaskCycleEnd+0x11c>)
 8013c36:	6819      	ldr	r1, [r3, #0]
 8013c38:	693a      	ldr	r2, [r7, #16]
 8013c3a:	4613      	mov	r3, r2
 8013c3c:	011b      	lsls	r3, r3, #4
 8013c3e:	1a9b      	subs	r3, r3, r2
 8013c40:	00db      	lsls	r3, r3, #3
 8013c42:	440b      	add	r3, r1
 8013c44:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8013c48:	4313      	orrs	r3, r2
 8013c4a:	d06a      	beq.n	8013d22 <OsTaskCycleEnd+0x10e>
        return;
    }

    cpuCycle = OsCpupGetCycle();
 8013c4c:	f7ff ff4c 	bl	8013ae8 <OsCpupGetCycle>
 8013c50:	e9c7 0106 	strd	r0, r1, [r7, #24]
    g_cpup[taskId].allTime += cpuCycle - g_cpup[taskId].startTime;
 8013c54:	4b36      	ldr	r3, [pc, #216]	; (8013d30 <OsTaskCycleEnd+0x11c>)
 8013c56:	6819      	ldr	r1, [r3, #0]
 8013c58:	693a      	ldr	r2, [r7, #16]
 8013c5a:	4613      	mov	r3, r2
 8013c5c:	011b      	lsls	r3, r3, #4
 8013c5e:	1a9b      	subs	r3, r3, r2
 8013c60:	00db      	lsls	r3, r3, #3
 8013c62:	440b      	add	r3, r1
 8013c64:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8013c68:	4b31      	ldr	r3, [pc, #196]	; (8013d30 <OsTaskCycleEnd+0x11c>)
 8013c6a:	681e      	ldr	r6, [r3, #0]
 8013c6c:	693a      	ldr	r2, [r7, #16]
 8013c6e:	4613      	mov	r3, r2
 8013c70:	011b      	lsls	r3, r3, #4
 8013c72:	1a9b      	subs	r3, r3, r2
 8013c74:	00db      	lsls	r3, r3, #3
 8013c76:	4433      	add	r3, r6
 8013c78:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8013c7c:	e9d7 8906 	ldrd	r8, r9, [r7, #24]
 8013c80:	ebb8 0402 	subs.w	r4, r8, r2
 8013c84:	eb69 0503 	sbc.w	r5, r9, r3
 8013c88:	4b29      	ldr	r3, [pc, #164]	; (8013d30 <OsTaskCycleEnd+0x11c>)
 8013c8a:	681e      	ldr	r6, [r3, #0]
 8013c8c:	693a      	ldr	r2, [r7, #16]
 8013c8e:	4613      	mov	r3, r2
 8013c90:	011b      	lsls	r3, r3, #4
 8013c92:	1a9b      	subs	r3, r3, r2
 8013c94:	00db      	lsls	r3, r3, #3
 8013c96:	4433      	add	r3, r6
 8013c98:	1902      	adds	r2, r0, r4
 8013c9a:	603a      	str	r2, [r7, #0]
 8013c9c:	eb41 0205 	adc.w	r2, r1, r5
 8013ca0:	607a      	str	r2, [r7, #4]
 8013ca2:	e9d7 1200 	ldrd	r1, r2, [r7]
 8013ca6:	e9c3 1202 	strd	r1, r2, [r3, #8]

#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    UINT32 cpuId = ArchCurrCpuid();
 8013caa:	f7ff fd73 	bl	8013794 <ArchCurrCpuid>
 8013cae:	6178      	str	r0, [r7, #20]
    g_cpup[taskId].allTime -= g_timeInIrqPerTskSwitch[cpuId];
 8013cb0:	4b1f      	ldr	r3, [pc, #124]	; (8013d30 <OsTaskCycleEnd+0x11c>)
 8013cb2:	6819      	ldr	r1, [r3, #0]
 8013cb4:	693a      	ldr	r2, [r7, #16]
 8013cb6:	4613      	mov	r3, r2
 8013cb8:	011b      	lsls	r3, r3, #4
 8013cba:	1a9b      	subs	r3, r3, r2
 8013cbc:	00db      	lsls	r3, r3, #3
 8013cbe:	440b      	add	r3, r1
 8013cc0:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 8013cc4:	4a1b      	ldr	r2, [pc, #108]	; (8013d34 <OsTaskCycleEnd+0x120>)
 8013cc6:	697b      	ldr	r3, [r7, #20]
 8013cc8:	00db      	lsls	r3, r3, #3
 8013cca:	4413      	add	r3, r2
 8013ccc:	e9d3 0100 	ldrd	r0, r1, [r3]
 8013cd0:	4b17      	ldr	r3, [pc, #92]	; (8013d30 <OsTaskCycleEnd+0x11c>)
 8013cd2:	681e      	ldr	r6, [r3, #0]
 8013cd4:	693a      	ldr	r2, [r7, #16]
 8013cd6:	4613      	mov	r3, r2
 8013cd8:	011b      	lsls	r3, r3, #4
 8013cda:	1a9b      	subs	r3, r3, r2
 8013cdc:	00db      	lsls	r3, r3, #3
 8013cde:	4433      	add	r3, r6
 8013ce0:	ebb4 0a00 	subs.w	sl, r4, r0
 8013ce4:	eb65 0b01 	sbc.w	fp, r5, r1
 8013ce8:	e9c3 ab02 	strd	sl, fp, [r3, #8]
    g_timeInIrqPerTskSwitch[cpuId] = 0;
 8013cec:	4a11      	ldr	r2, [pc, #68]	; (8013d34 <OsTaskCycleEnd+0x120>)
 8013cee:	697b      	ldr	r3, [r7, #20]
 8013cf0:	00db      	lsls	r3, r3, #3
 8013cf2:	18d1      	adds	r1, r2, r3
 8013cf4:	f04f 0200 	mov.w	r2, #0
 8013cf8:	f04f 0300 	mov.w	r3, #0
 8013cfc:	e9c1 2300 	strd	r2, r3, [r1]
#endif
    g_cpup[taskId].startTime = 0;
 8013d00:	4b0b      	ldr	r3, [pc, #44]	; (8013d30 <OsTaskCycleEnd+0x11c>)
 8013d02:	6819      	ldr	r1, [r3, #0]
 8013d04:	693a      	ldr	r2, [r7, #16]
 8013d06:	4613      	mov	r3, r2
 8013d08:	011b      	lsls	r3, r3, #4
 8013d0a:	1a9b      	subs	r3, r3, r2
 8013d0c:	00db      	lsls	r3, r3, #3
 8013d0e:	4419      	add	r1, r3
 8013d10:	f04f 0200 	mov.w	r2, #0
 8013d14:	f04f 0300 	mov.w	r3, #0
 8013d18:	e9c1 2304 	strd	r2, r3, [r1, #16]

    return;
 8013d1c:	e002      	b.n	8013d24 <OsTaskCycleEnd+0x110>
        return;
 8013d1e:	bf00      	nop
 8013d20:	e000      	b.n	8013d24 <OsTaskCycleEnd+0x110>
        return;
 8013d22:	bf00      	nop
}
 8013d24:	3724      	adds	r7, #36	; 0x24
 8013d26:	46bd      	mov	sp, r7
 8013d28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013d2c:	200032ce 	.word	0x200032ce
 8013d30:	200032d0 	.word	0x200032d0
 8013d34:	20003770 	.word	0x20003770

08013d38 <OsTaskCycleEndStart>:

/*
 * Description: start task to get cycles count in current task ending
 */
LITE_OS_SEC_TEXT_MINOR VOID OsTaskCycleEndStart(const LosTaskCB *newTask)
{
 8013d38:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8013d3c:	b08a      	sub	sp, #40	; 0x28
 8013d3e:	af00      	add	r7, sp, #0
 8013d40:	60f8      	str	r0, [r7, #12]
    UINT64 cpuCycle;
    LosTaskCB *runTask = NULL;
 8013d42:	2300      	movs	r3, #0
 8013d44:	617b      	str	r3, [r7, #20]
    OsCpupCB *cpup = NULL;
 8013d46:	2300      	movs	r3, #0
 8013d48:	61bb      	str	r3, [r7, #24]
    UINT32 cpuId = ArchCurrCpuid();
 8013d4a:	f7ff fd23 	bl	8013794 <ArchCurrCpuid>
 8013d4e:	61f8      	str	r0, [r7, #28]

    if ((g_cpupInitFlg == 0) || (newTask == NULL)) {
 8013d50:	4b35      	ldr	r3, [pc, #212]	; (8013e28 <OsTaskCycleEndStart+0xf0>)
 8013d52:	881b      	ldrh	r3, [r3, #0]
 8013d54:	2b00      	cmp	r3, #0
 8013d56:	d061      	beq.n	8013e1c <OsTaskCycleEndStart+0xe4>
 8013d58:	68fb      	ldr	r3, [r7, #12]
 8013d5a:	2b00      	cmp	r3, #0
 8013d5c:	d05e      	beq.n	8013e1c <OsTaskCycleEndStart+0xe4>
        return;
    }

    runTask = OsCurrTaskGet();
 8013d5e:	f7ff fd3f 	bl	80137e0 <OsCurrTaskGet>
 8013d62:	6178      	str	r0, [r7, #20]
    cpuCycle = OsCpupGetCycle();
 8013d64:	f7ff fec0 	bl	8013ae8 <OsCpupGetCycle>
 8013d68:	e9c7 0108 	strd	r0, r1, [r7, #32]

    cpup = &g_cpup[runTask->taskId];
 8013d6c:	4b2f      	ldr	r3, [pc, #188]	; (8013e2c <OsTaskCycleEndStart+0xf4>)
 8013d6e:	6819      	ldr	r1, [r3, #0]
 8013d70:	697b      	ldr	r3, [r7, #20]
 8013d72:	695a      	ldr	r2, [r3, #20]
 8013d74:	4613      	mov	r3, r2
 8013d76:	011b      	lsls	r3, r3, #4
 8013d78:	1a9b      	subs	r3, r3, r2
 8013d7a:	00db      	lsls	r3, r3, #3
 8013d7c:	440b      	add	r3, r1
 8013d7e:	61bb      	str	r3, [r7, #24]
    if (cpup->startTime != 0) {
 8013d80:	69bb      	ldr	r3, [r7, #24]
 8013d82:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8013d86:	4313      	orrs	r3, r2
 8013d88:	d02e      	beq.n	8013de8 <OsTaskCycleEndStart+0xb0>
        cpup->allTime += cpuCycle - cpup->startTime;
 8013d8a:	69bb      	ldr	r3, [r7, #24]
 8013d8c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8013d90:	69b9      	ldr	r1, [r7, #24]
 8013d92:	e9d1 0104 	ldrd	r0, r1, [r1, #16]
 8013d96:	e9d7 8908 	ldrd	r8, r9, [r7, #32]
 8013d9a:	ebb8 0400 	subs.w	r4, r8, r0
 8013d9e:	eb69 0501 	sbc.w	r5, r9, r1
 8013da2:	1911      	adds	r1, r2, r4
 8013da4:	6039      	str	r1, [r7, #0]
 8013da6:	416b      	adcs	r3, r5
 8013da8:	607b      	str	r3, [r7, #4]
 8013daa:	69bb      	ldr	r3, [r7, #24]
 8013dac:	e9d7 1200 	ldrd	r1, r2, [r7]
 8013db0:	e9c3 1202 	strd	r1, r2, [r3, #8]
#ifdef LOSCFG_CPUP_INCLUDE_IRQ
        cpup->allTime -= g_timeInIrqPerTskSwitch[cpuId];
 8013db4:	69bb      	ldr	r3, [r7, #24]
 8013db6:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8013dba:	4a1d      	ldr	r2, [pc, #116]	; (8013e30 <OsTaskCycleEndStart+0xf8>)
 8013dbc:	69fb      	ldr	r3, [r7, #28]
 8013dbe:	00db      	lsls	r3, r3, #3
 8013dc0:	4413      	add	r3, r2
 8013dc2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013dc6:	ebb0 0a02 	subs.w	sl, r0, r2
 8013dca:	eb61 0b03 	sbc.w	fp, r1, r3
 8013dce:	69bb      	ldr	r3, [r7, #24]
 8013dd0:	e9c3 ab02 	strd	sl, fp, [r3, #8]
        g_timeInIrqPerTskSwitch[cpuId] = 0;
 8013dd4:	4a16      	ldr	r2, [pc, #88]	; (8013e30 <OsTaskCycleEndStart+0xf8>)
 8013dd6:	69fb      	ldr	r3, [r7, #28]
 8013dd8:	00db      	lsls	r3, r3, #3
 8013dda:	18d1      	adds	r1, r2, r3
 8013ddc:	f04f 0200 	mov.w	r2, #0
 8013de0:	f04f 0300 	mov.w	r3, #0
 8013de4:	e9c1 2300 	strd	r2, r3, [r1]
#endif
    }

    cpup = &g_cpup[newTask->taskId];
 8013de8:	4b10      	ldr	r3, [pc, #64]	; (8013e2c <OsTaskCycleEndStart+0xf4>)
 8013dea:	6819      	ldr	r1, [r3, #0]
 8013dec:	68fb      	ldr	r3, [r7, #12]
 8013dee:	695a      	ldr	r2, [r3, #20]
 8013df0:	4613      	mov	r3, r2
 8013df2:	011b      	lsls	r3, r3, #4
 8013df4:	1a9b      	subs	r3, r3, r2
 8013df6:	00db      	lsls	r3, r3, #3
 8013df8:	440b      	add	r3, r1
 8013dfa:	61bb      	str	r3, [r7, #24]
    cpup->id = newTask->taskId;
 8013dfc:	68fb      	ldr	r3, [r7, #12]
 8013dfe:	695a      	ldr	r2, [r3, #20]
 8013e00:	69bb      	ldr	r3, [r7, #24]
 8013e02:	601a      	str	r2, [r3, #0]
    cpup->startTime = cpuCycle;
 8013e04:	69b9      	ldr	r1, [r7, #24]
 8013e06:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8013e0a:	e9c1 2304 	strd	r2, r3, [r1, #16]
    runningTasks[cpuId] = newTask->taskId;
 8013e0e:	68fb      	ldr	r3, [r7, #12]
 8013e10:	695a      	ldr	r2, [r3, #20]
 8013e12:	4908      	ldr	r1, [pc, #32]	; (8013e34 <OsTaskCycleEndStart+0xfc>)
 8013e14:	69fb      	ldr	r3, [r7, #28]
 8013e16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

    return;
 8013e1a:	e000      	b.n	8013e1e <OsTaskCycleEndStart+0xe6>
        return;
 8013e1c:	bf00      	nop
}
 8013e1e:	3728      	adds	r7, #40	; 0x28
 8013e20:	46bd      	mov	sp, r7
 8013e22:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8013e26:	bf00      	nop
 8013e28:	200032ce 	.word	0x200032ce
 8013e2c:	200032d0 	.word	0x200032d0
 8013e30:	20003770 	.word	0x20003770
 8013e34:	200004a0 	.word	0x200004a0

08013e38 <OsCpupGetPos>:

LITE_OS_SEC_TEXT_MINOR STATIC VOID OsCpupGetPos(UINT32 mode, UINT16 *curPosPointer, UINT16 *prePosPointer)
{
 8013e38:	b480      	push	{r7}
 8013e3a:	b087      	sub	sp, #28
 8013e3c:	af00      	add	r7, sp, #0
 8013e3e:	60f8      	str	r0, [r7, #12]
 8013e40:	60b9      	str	r1, [r7, #8]
 8013e42:	607a      	str	r2, [r7, #4]
    UINT16 curPos;
    UINT16 tmpPos;
    UINT16 prePos;

    tmpPos = g_hisPos;
 8013e44:	4b16      	ldr	r3, [pc, #88]	; (8013ea0 <OsCpupGetPos+0x68>)
 8013e46:	881b      	ldrh	r3, [r3, #0]
 8013e48:	82bb      	strh	r3, [r7, #20]
    curPos = CPUP_PRE_POS(tmpPos);
 8013e4a:	8abb      	ldrh	r3, [r7, #20]
 8013e4c:	2b00      	cmp	r3, #0
 8013e4e:	d003      	beq.n	8013e58 <OsCpupGetPos+0x20>
 8013e50:	8abb      	ldrh	r3, [r7, #20]
 8013e52:	3b01      	subs	r3, #1
 8013e54:	b29b      	uxth	r3, r3
 8013e56:	e000      	b.n	8013e5a <OsCpupGetPos+0x22>
 8013e58:	230a      	movs	r3, #10
 8013e5a:	82fb      	strh	r3, [r7, #22]

    /*
     * The current position has nothing to do with the CPUP modes,
     * however, the previous position differs.
     */
    switch (mode) {
 8013e5c:	68fb      	ldr	r3, [r7, #12]
 8013e5e:	2b00      	cmp	r3, #0
 8013e60:	d00c      	beq.n	8013e7c <OsCpupGetPos+0x44>
 8013e62:	68fb      	ldr	r3, [r7, #12]
 8013e64:	2b01      	cmp	r3, #1
 8013e66:	d10c      	bne.n	8013e82 <OsCpupGetPos+0x4a>
        case CPUP_LAST_ONE_SECONDS:
            prePos = CPUP_PRE_POS(curPos);
 8013e68:	8afb      	ldrh	r3, [r7, #22]
 8013e6a:	2b00      	cmp	r3, #0
 8013e6c:	d003      	beq.n	8013e76 <OsCpupGetPos+0x3e>
 8013e6e:	8afb      	ldrh	r3, [r7, #22]
 8013e70:	3b01      	subs	r3, #1
 8013e72:	b29b      	uxth	r3, r3
 8013e74:	e000      	b.n	8013e78 <OsCpupGetPos+0x40>
 8013e76:	230a      	movs	r3, #10
 8013e78:	827b      	strh	r3, [r7, #18]
            break;
 8013e7a:	e005      	b.n	8013e88 <OsCpupGetPos+0x50>
        case CPUP_LAST_TEN_SECONDS:
            prePos = tmpPos;
 8013e7c:	8abb      	ldrh	r3, [r7, #20]
 8013e7e:	827b      	strh	r3, [r7, #18]
            break;
 8013e80:	e002      	b.n	8013e88 <OsCpupGetPos+0x50>
        case CPUP_ALL_TIME:
            /* fall-through */
        default:
            prePos = OS_CPUP_HISTORY_RECORD_NUM;
 8013e82:	230b      	movs	r3, #11
 8013e84:	827b      	strh	r3, [r7, #18]
            break;
 8013e86:	bf00      	nop
    }

    *curPosPointer = curPos;
 8013e88:	68bb      	ldr	r3, [r7, #8]
 8013e8a:	8afa      	ldrh	r2, [r7, #22]
 8013e8c:	801a      	strh	r2, [r3, #0]
    *prePosPointer = prePos;
 8013e8e:	687b      	ldr	r3, [r7, #4]
 8013e90:	8a7a      	ldrh	r2, [r7, #18]
 8013e92:	801a      	strh	r2, [r3, #0]

    return;
 8013e94:	bf00      	nop
}
 8013e96:	371c      	adds	r7, #28
 8013e98:	46bd      	mov	sp, r7
 8013e9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013e9e:	4770      	bx	lr
 8013ea0:	200032d8 	.word	0x200032d8

08013ea4 <OsCpuUsageParaCheck>:

LITE_OS_SEC_TEXT_MINOR STATIC INLINE UINT32 OsCpuUsageParaCheck(UINT32 taskId)
{
 8013ea4:	b480      	push	{r7}
 8013ea6:	b083      	sub	sp, #12
 8013ea8:	af00      	add	r7, sp, #0
 8013eaa:	6078      	str	r0, [r7, #4]
    if (g_cpupInitFlg == 0) {
 8013eac:	4b1d      	ldr	r3, [pc, #116]	; (8013f24 <OsCpuUsageParaCheck+0x80>)
 8013eae:	881b      	ldrh	r3, [r3, #0]
 8013eb0:	2b00      	cmp	r3, #0
 8013eb2:	d101      	bne.n	8013eb8 <OsCpuUsageParaCheck+0x14>
        return LOS_ERRNO_CPUP_NO_INIT;
 8013eb4:	4b1c      	ldr	r3, [pc, #112]	; (8013f28 <OsCpuUsageParaCheck+0x84>)
 8013eb6:	e02f      	b.n	8013f18 <OsCpuUsageParaCheck+0x74>
    }

    if (OS_TSK_GET_INDEX(taskId) >= g_taskMaxNum) {
 8013eb8:	4b1c      	ldr	r3, [pc, #112]	; (8013f2c <OsCpuUsageParaCheck+0x88>)
 8013eba:	681b      	ldr	r3, [r3, #0]
 8013ebc:	687a      	ldr	r2, [r7, #4]
 8013ebe:	429a      	cmp	r2, r3
 8013ec0:	d301      	bcc.n	8013ec6 <OsCpuUsageParaCheck+0x22>
        return LOS_ERRNO_CPUP_TSK_ID_INVALID;
 8013ec2:	4b1b      	ldr	r3, [pc, #108]	; (8013f30 <OsCpuUsageParaCheck+0x8c>)
 8013ec4:	e028      	b.n	8013f18 <OsCpuUsageParaCheck+0x74>
    }

    /* weather the task is created */
    if (g_cpup[taskId].id != taskId) {
 8013ec6:	4b1b      	ldr	r3, [pc, #108]	; (8013f34 <OsCpuUsageParaCheck+0x90>)
 8013ec8:	6819      	ldr	r1, [r3, #0]
 8013eca:	687a      	ldr	r2, [r7, #4]
 8013ecc:	4613      	mov	r3, r2
 8013ece:	011b      	lsls	r3, r3, #4
 8013ed0:	1a9b      	subs	r3, r3, r2
 8013ed2:	00db      	lsls	r3, r3, #3
 8013ed4:	440b      	add	r3, r1
 8013ed6:	681b      	ldr	r3, [r3, #0]
 8013ed8:	687a      	ldr	r2, [r7, #4]
 8013eda:	429a      	cmp	r2, r3
 8013edc:	d001      	beq.n	8013ee2 <OsCpuUsageParaCheck+0x3e>
        return LOS_ERRNO_CPUP_THREAD_NO_CREATED;
 8013ede:	4b16      	ldr	r3, [pc, #88]	; (8013f38 <OsCpuUsageParaCheck+0x94>)
 8013ee0:	e01a      	b.n	8013f18 <OsCpuUsageParaCheck+0x74>
    }

    if ((g_cpup[taskId].status & OS_TASK_STATUS_UNUSED) || (g_cpup[taskId].status == 0)) {
 8013ee2:	4b14      	ldr	r3, [pc, #80]	; (8013f34 <OsCpuUsageParaCheck+0x90>)
 8013ee4:	6819      	ldr	r1, [r3, #0]
 8013ee6:	687a      	ldr	r2, [r7, #4]
 8013ee8:	4613      	mov	r3, r2
 8013eea:	011b      	lsls	r3, r3, #4
 8013eec:	1a9b      	subs	r3, r3, r2
 8013eee:	00db      	lsls	r3, r3, #3
 8013ef0:	440b      	add	r3, r1
 8013ef2:	889b      	ldrh	r3, [r3, #4]
 8013ef4:	f003 0301 	and.w	r3, r3, #1
 8013ef8:	2b00      	cmp	r3, #0
 8013efa:	d10a      	bne.n	8013f12 <OsCpuUsageParaCheck+0x6e>
 8013efc:	4b0d      	ldr	r3, [pc, #52]	; (8013f34 <OsCpuUsageParaCheck+0x90>)
 8013efe:	6819      	ldr	r1, [r3, #0]
 8013f00:	687a      	ldr	r2, [r7, #4]
 8013f02:	4613      	mov	r3, r2
 8013f04:	011b      	lsls	r3, r3, #4
 8013f06:	1a9b      	subs	r3, r3, r2
 8013f08:	00db      	lsls	r3, r3, #3
 8013f0a:	440b      	add	r3, r1
 8013f0c:	889b      	ldrh	r3, [r3, #4]
 8013f0e:	2b00      	cmp	r3, #0
 8013f10:	d101      	bne.n	8013f16 <OsCpuUsageParaCheck+0x72>
        return LOS_ERRNO_CPUP_THREAD_NO_CREATED;
 8013f12:	4b09      	ldr	r3, [pc, #36]	; (8013f38 <OsCpuUsageParaCheck+0x94>)
 8013f14:	e000      	b.n	8013f18 <OsCpuUsageParaCheck+0x74>
    }

    return LOS_OK;
 8013f16:	2300      	movs	r3, #0
}
 8013f18:	4618      	mov	r0, r3
 8013f1a:	370c      	adds	r7, #12
 8013f1c:	46bd      	mov	sp, r7
 8013f1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f22:	4770      	bx	lr
 8013f24:	200032ce 	.word	0x200032ce
 8013f28:	02001e02 	.word	0x02001e02
 8013f2c:	200036d8 	.word	0x200036d8
 8013f30:	02001e05 	.word	0x02001e05
 8013f34:	200032d0 	.word	0x200032d0
 8013f38:	02001e04 	.word	0x02001e04

08013f3c <LOS_HistorySysCpuUsage>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_HistorySysCpuUsage(UINT32 mode)
{
 8013f3c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8013f40:	b08d      	sub	sp, #52	; 0x34
 8013f42:	af00      	add	r7, sp, #0
 8013f44:	6078      	str	r0, [r7, #4]
 8013f46:	4b50      	ldr	r3, [pc, #320]	; (8014088 <LOS_HistorySysCpuUsage+0x14c>)
 8013f48:	681b      	ldr	r3, [r3, #0]
 8013f4a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013f4c:	f04f 0300 	mov.w	r3, #0
    UINT64 cpuCycleAll;
    UINT64 idleCycleAll = 0;
 8013f50:	f04f 0200 	mov.w	r2, #0
 8013f54:	f04f 0300 	mov.w	r3, #0
 8013f58:	e9c7 2306 	strd	r2, r3, [r7, #24]
    UINT32 cpup = 0;
 8013f5c:	2300      	movs	r3, #0
 8013f5e:	60fb      	str	r3, [r7, #12]
    UINT32 idleTaskId;
#ifdef LOSCFG_KERNEL_SMP
    UINT32 cpuId = 0;
#endif

    if (g_cpupInitFlg == 0) {
 8013f60:	4b4a      	ldr	r3, [pc, #296]	; (801408c <LOS_HistorySysCpuUsage+0x150>)
 8013f62:	881b      	ldrh	r3, [r3, #0]
 8013f64:	2b00      	cmp	r3, #0
 8013f66:	d101      	bne.n	8013f6c <LOS_HistorySysCpuUsage+0x30>
        return LOS_ERRNO_CPUP_NO_INIT;
 8013f68:	4b49      	ldr	r3, [pc, #292]	; (8014090 <LOS_HistorySysCpuUsage+0x154>)
 8013f6a:	e080      	b.n	801406e <LOS_HistorySysCpuUsage+0x132>
    }

    /* get end time of current task */
    intSave = LOS_IntLock();
 8013f6c:	f7ff fc1a 	bl	80137a4 <LOS_IntLock>
 8013f70:	6138      	str	r0, [r7, #16]
    OsTaskCycleEnd();
 8013f72:	f7ff fe4f 	bl	8013c14 <OsTaskCycleEnd>

    OsCpupGetPos(mode, &pos, &prePos);
 8013f76:	f107 020a 	add.w	r2, r7, #10
 8013f7a:	f107 0308 	add.w	r3, r7, #8
 8013f7e:	4619      	mov	r1, r3
 8013f80:	6878      	ldr	r0, [r7, #4]
 8013f82:	f7ff ff59 	bl	8013e38 <OsCpupGetPos>
    cpuCycleAll = cpuHistoryTime[pos] - cpuHistoryTime[prePos];
 8013f86:	893b      	ldrh	r3, [r7, #8]
 8013f88:	4a42      	ldr	r2, [pc, #264]	; (8014094 <LOS_HistorySysCpuUsage+0x158>)
 8013f8a:	00db      	lsls	r3, r3, #3
 8013f8c:	4413      	add	r3, r2
 8013f8e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8013f92:	897b      	ldrh	r3, [r7, #10]
 8013f94:	4a3f      	ldr	r2, [pc, #252]	; (8014094 <LOS_HistorySysCpuUsage+0x158>)
 8013f96:	00db      	lsls	r3, r3, #3
 8013f98:	4413      	add	r3, r2
 8013f9a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013f9e:	ebb0 0802 	subs.w	r8, r0, r2
 8013fa2:	eb61 0903 	sbc.w	r9, r1, r3
 8013fa6:	e9c7 8908 	strd	r8, r9, [r7, #32]
        idleCycleAll += g_cpup[idleTaskId].historyTime[pos] - g_cpup[idleTaskId].historyTime[prePos];
        cpuId++;
    }
    cpuCycleAll *= LOSCFG_KERNEL_CORE_NUM;
#else
    idleTaskId = OsGetIdleTaskId();
 8013faa:	f7ee ffc7 	bl	8002f3c <OsGetIdleTaskId>
 8013fae:	6178      	str	r0, [r7, #20]
    idleCycleAll = g_cpup[idleTaskId].historyTime[pos] - g_cpup[idleTaskId].historyTime[prePos];
 8013fb0:	4b39      	ldr	r3, [pc, #228]	; (8014098 <LOS_HistorySysCpuUsage+0x15c>)
 8013fb2:	6819      	ldr	r1, [r3, #0]
 8013fb4:	697a      	ldr	r2, [r7, #20]
 8013fb6:	4613      	mov	r3, r2
 8013fb8:	011b      	lsls	r3, r3, #4
 8013fba:	1a9b      	subs	r3, r3, r2
 8013fbc:	00db      	lsls	r3, r3, #3
 8013fbe:	18ca      	adds	r2, r1, r3
 8013fc0:	893b      	ldrh	r3, [r7, #8]
 8013fc2:	3303      	adds	r3, #3
 8013fc4:	00db      	lsls	r3, r3, #3
 8013fc6:	4413      	add	r3, r2
 8013fc8:	e9d3 0100 	ldrd	r0, r1, [r3]
 8013fcc:	4b32      	ldr	r3, [pc, #200]	; (8014098 <LOS_HistorySysCpuUsage+0x15c>)
 8013fce:	681e      	ldr	r6, [r3, #0]
 8013fd0:	697a      	ldr	r2, [r7, #20]
 8013fd2:	4613      	mov	r3, r2
 8013fd4:	011b      	lsls	r3, r3, #4
 8013fd6:	1a9b      	subs	r3, r3, r2
 8013fd8:	00db      	lsls	r3, r3, #3
 8013fda:	18f2      	adds	r2, r6, r3
 8013fdc:	897b      	ldrh	r3, [r7, #10]
 8013fde:	3303      	adds	r3, #3
 8013fe0:	00db      	lsls	r3, r3, #3
 8013fe2:	4413      	add	r3, r2
 8013fe4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013fe8:	1a84      	subs	r4, r0, r2
 8013fea:	eb61 0503 	sbc.w	r5, r1, r3
 8013fee:	e9c7 4506 	strd	r4, r5, [r7, #24]
#endif

    if (cpuCycleAll) {
 8013ff2:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8013ff6:	4313      	orrs	r3, r2
 8013ff8:	d033      	beq.n	8014062 <LOS_HistorySysCpuUsage+0x126>
        cpup = (LOS_CPUP_PRECISION - (UINT32)((LOS_CPUP_PRECISION * idleCycleAll) / cpuCycleAll));
 8013ffa:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8013ffe:	4602      	mov	r2, r0
 8014000:	460b      	mov	r3, r1
 8014002:	f04f 0400 	mov.w	r4, #0
 8014006:	f04f 0500 	mov.w	r5, #0
 801400a:	015d      	lsls	r5, r3, #5
 801400c:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 8014010:	0154      	lsls	r4, r2, #5
 8014012:	4622      	mov	r2, r4
 8014014:	462b      	mov	r3, r5
 8014016:	1a12      	subs	r2, r2, r0
 8014018:	eb63 0301 	sbc.w	r3, r3, r1
 801401c:	f04f 0400 	mov.w	r4, #0
 8014020:	f04f 0500 	mov.w	r5, #0
 8014024:	009d      	lsls	r5, r3, #2
 8014026:	ea45 7592 	orr.w	r5, r5, r2, lsr #30
 801402a:	0094      	lsls	r4, r2, #2
 801402c:	4622      	mov	r2, r4
 801402e:	462b      	mov	r3, r5
 8014030:	1812      	adds	r2, r2, r0
 8014032:	eb41 0303 	adc.w	r3, r1, r3
 8014036:	f04f 0000 	mov.w	r0, #0
 801403a:	f04f 0100 	mov.w	r1, #0
 801403e:	00d9      	lsls	r1, r3, #3
 8014040:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8014044:	00d0      	lsls	r0, r2, #3
 8014046:	4602      	mov	r2, r0
 8014048:	460b      	mov	r3, r1
 801404a:	4610      	mov	r0, r2
 801404c:	4619      	mov	r1, r3
 801404e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8014052:	f7ec fc9f 	bl	8000994 <__aeabi_uldivmod>
 8014056:	4602      	mov	r2, r0
 8014058:	460b      	mov	r3, r1
 801405a:	4613      	mov	r3, r2
 801405c:	f5c3 737a 	rsb	r3, r3, #1000	; 0x3e8
 8014060:	60fb      	str	r3, [r7, #12]
    }

    OsTaskCycleStart();
 8014062:	f7ff fda7 	bl	8013bb4 <OsTaskCycleStart>
    LOS_IntRestore(intSave);
 8014066:	6938      	ldr	r0, [r7, #16]
 8014068:	f7ff fba3 	bl	80137b2 <LOS_IntRestore>

    return cpup;
 801406c:	68fb      	ldr	r3, [r7, #12]
}
 801406e:	4a06      	ldr	r2, [pc, #24]	; (8014088 <LOS_HistorySysCpuUsage+0x14c>)
 8014070:	6811      	ldr	r1, [r2, #0]
 8014072:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014074:	4051      	eors	r1, r2
 8014076:	d001      	beq.n	801407c <LOS_HistorySysCpuUsage+0x140>
 8014078:	f7f0 f9b6 	bl	80043e8 <__stack_chk_fail>
 801407c:	4618      	mov	r0, r3
 801407e:	3734      	adds	r7, #52	; 0x34
 8014080:	46bd      	mov	sp, r7
 8014082:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8014086:	bf00      	nop
 8014088:	0802286c 	.word	0x0802286c
 801408c:	200032ce 	.word	0x200032ce
 8014090:	02001e02 	.word	0x02001e02
 8014094:	200032e0 	.word	0x200032e0
 8014098:	200032d0 	.word	0x200032d0

0801409c <LOS_HistoryTaskCpuUsage>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_HistoryTaskCpuUsage(UINT32 taskId, UINT32 mode)
{
 801409c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 80140a0:	b08e      	sub	sp, #56	; 0x38
 80140a2:	af00      	add	r7, sp, #0
 80140a4:	6078      	str	r0, [r7, #4]
 80140a6:	6039      	str	r1, [r7, #0]
 80140a8:	4b4c      	ldr	r3, [pc, #304]	; (80141dc <LOS_HistoryTaskCpuUsage+0x140>)
 80140aa:	681b      	ldr	r3, [r3, #0]
 80140ac:	637b      	str	r3, [r7, #52]	; 0x34
 80140ae:	f04f 0300 	mov.w	r3, #0
    UINT64 cpuCycleAll;
    UINT64 cpuCycleCurTask;
    UINT16 pos;
    UINT16 prePos;
    UINT32 intSave;
    UINT32 cpup = 0;
 80140b2:	2300      	movs	r3, #0
 80140b4:	613b      	str	r3, [r7, #16]
    UINT32 ret;

    if (g_cpupInitFlg == 0) {
 80140b6:	4b4a      	ldr	r3, [pc, #296]	; (80141e0 <LOS_HistoryTaskCpuUsage+0x144>)
 80140b8:	881b      	ldrh	r3, [r3, #0]
 80140ba:	2b00      	cmp	r3, #0
 80140bc:	d101      	bne.n	80140c2 <LOS_HistoryTaskCpuUsage+0x26>
        return LOS_ERRNO_CPUP_NO_INIT;
 80140be:	4b49      	ldr	r3, [pc, #292]	; (80141e4 <LOS_HistoryTaskCpuUsage+0x148>)
 80140c0:	e07f      	b.n	80141c2 <LOS_HistoryTaskCpuUsage+0x126>
    }

    ret = OsCpuUsageParaCheck(taskId);
 80140c2:	6878      	ldr	r0, [r7, #4]
 80140c4:	f7ff feee 	bl	8013ea4 <OsCpuUsageParaCheck>
 80140c8:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 80140ca:	697b      	ldr	r3, [r7, #20]
 80140cc:	2b00      	cmp	r3, #0
 80140ce:	d001      	beq.n	80140d4 <LOS_HistoryTaskCpuUsage+0x38>
        return ret;
 80140d0:	697b      	ldr	r3, [r7, #20]
 80140d2:	e076      	b.n	80141c2 <LOS_HistoryTaskCpuUsage+0x126>
    }
    OsCpupCB *taskCpup = &g_cpup[taskId];
 80140d4:	4b44      	ldr	r3, [pc, #272]	; (80141e8 <LOS_HistoryTaskCpuUsage+0x14c>)
 80140d6:	6819      	ldr	r1, [r3, #0]
 80140d8:	687a      	ldr	r2, [r7, #4]
 80140da:	4613      	mov	r3, r2
 80140dc:	011b      	lsls	r3, r3, #4
 80140de:	1a9b      	subs	r3, r3, r2
 80140e0:	00db      	lsls	r3, r3, #3
 80140e2:	440b      	add	r3, r1
 80140e4:	61bb      	str	r3, [r7, #24]

    intSave = LOS_IntLock();
 80140e6:	f7ff fb5d 	bl	80137a4 <LOS_IntLock>
 80140ea:	61f8      	str	r0, [r7, #28]
    OsTaskCycleEnd();
 80140ec:	f7ff fd92 	bl	8013c14 <OsTaskCycleEnd>

    OsCpupGetPos(mode, &pos, &prePos);
 80140f0:	f107 020e 	add.w	r2, r7, #14
 80140f4:	f107 030c 	add.w	r3, r7, #12
 80140f8:	4619      	mov	r1, r3
 80140fa:	6838      	ldr	r0, [r7, #0]
 80140fc:	f7ff fe9c 	bl	8013e38 <OsCpupGetPos>
    cpuCycleAll = cpuHistoryTime[pos] - cpuHistoryTime[prePos];
 8014100:	89bb      	ldrh	r3, [r7, #12]
 8014102:	4a3a      	ldr	r2, [pc, #232]	; (80141ec <LOS_HistoryTaskCpuUsage+0x150>)
 8014104:	00db      	lsls	r3, r3, #3
 8014106:	4413      	add	r3, r2
 8014108:	e9d3 0100 	ldrd	r0, r1, [r3]
 801410c:	89fb      	ldrh	r3, [r7, #14]
 801410e:	4a37      	ldr	r2, [pc, #220]	; (80141ec <LOS_HistoryTaskCpuUsage+0x150>)
 8014110:	00db      	lsls	r3, r3, #3
 8014112:	4413      	add	r3, r2
 8014114:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014118:	ebb0 0802 	subs.w	r8, r0, r2
 801411c:	eb61 0903 	sbc.w	r9, r1, r3
 8014120:	e9c7 8908 	strd	r8, r9, [r7, #32]
    cpuCycleCurTask = taskCpup->historyTime[pos] - taskCpup->historyTime[prePos];
 8014124:	89bb      	ldrh	r3, [r7, #12]
 8014126:	69ba      	ldr	r2, [r7, #24]
 8014128:	3303      	adds	r3, #3
 801412a:	00db      	lsls	r3, r3, #3
 801412c:	4413      	add	r3, r2
 801412e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014132:	89fb      	ldrh	r3, [r7, #14]
 8014134:	69ba      	ldr	r2, [r7, #24]
 8014136:	3303      	adds	r3, #3
 8014138:	00db      	lsls	r3, r3, #3
 801413a:	4413      	add	r3, r2
 801413c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014140:	1a84      	subs	r4, r0, r2
 8014142:	eb61 0503 	sbc.w	r5, r1, r3
 8014146:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
    if (cpuCycleAll) {
 801414a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801414e:	4313      	orrs	r3, r2
 8014150:	d031      	beq.n	80141b6 <LOS_HistoryTaskCpuUsage+0x11a>
        cpup = (UINT32)((LOS_CPUP_PRECISION * cpuCycleCurTask) / cpuCycleAll);
 8014152:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014156:	4602      	mov	r2, r0
 8014158:	460b      	mov	r3, r1
 801415a:	f04f 0400 	mov.w	r4, #0
 801415e:	f04f 0500 	mov.w	r5, #0
 8014162:	015d      	lsls	r5, r3, #5
 8014164:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 8014168:	0154      	lsls	r4, r2, #5
 801416a:	4622      	mov	r2, r4
 801416c:	462b      	mov	r3, r5
 801416e:	1a12      	subs	r2, r2, r0
 8014170:	eb63 0301 	sbc.w	r3, r3, r1
 8014174:	f04f 0400 	mov.w	r4, #0
 8014178:	f04f 0500 	mov.w	r5, #0
 801417c:	009d      	lsls	r5, r3, #2
 801417e:	ea45 7592 	orr.w	r5, r5, r2, lsr #30
 8014182:	0094      	lsls	r4, r2, #2
 8014184:	4622      	mov	r2, r4
 8014186:	462b      	mov	r3, r5
 8014188:	1812      	adds	r2, r2, r0
 801418a:	eb41 0303 	adc.w	r3, r1, r3
 801418e:	f04f 0000 	mov.w	r0, #0
 8014192:	f04f 0100 	mov.w	r1, #0
 8014196:	00d9      	lsls	r1, r3, #3
 8014198:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 801419c:	00d0      	lsls	r0, r2, #3
 801419e:	4602      	mov	r2, r0
 80141a0:	460b      	mov	r3, r1
 80141a2:	4610      	mov	r0, r2
 80141a4:	4619      	mov	r1, r3
 80141a6:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80141aa:	f7ec fbf3 	bl	8000994 <__aeabi_uldivmod>
 80141ae:	4602      	mov	r2, r0
 80141b0:	460b      	mov	r3, r1
 80141b2:	4613      	mov	r3, r2
 80141b4:	613b      	str	r3, [r7, #16]
    }

    OsTaskCycleStart();
 80141b6:	f7ff fcfd 	bl	8013bb4 <OsTaskCycleStart>
    LOS_IntRestore(intSave);
 80141ba:	69f8      	ldr	r0, [r7, #28]
 80141bc:	f7ff faf9 	bl	80137b2 <LOS_IntRestore>

    return cpup;
 80141c0:	693b      	ldr	r3, [r7, #16]
}
 80141c2:	4a06      	ldr	r2, [pc, #24]	; (80141dc <LOS_HistoryTaskCpuUsage+0x140>)
 80141c4:	6811      	ldr	r1, [r2, #0]
 80141c6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80141c8:	4051      	eors	r1, r2
 80141ca:	d001      	beq.n	80141d0 <LOS_HistoryTaskCpuUsage+0x134>
 80141cc:	f7f0 f90c 	bl	80043e8 <__stack_chk_fail>
 80141d0:	4618      	mov	r0, r3
 80141d2:	3738      	adds	r7, #56	; 0x38
 80141d4:	46bd      	mov	sp, r7
 80141d6:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 80141da:	bf00      	nop
 80141dc:	08022870 	.word	0x08022870
 80141e0:	200032ce 	.word	0x200032ce
 80141e4:	02001e02 	.word	0x02001e02
 80141e8:	200032d0 	.word	0x200032d0
 80141ec:	200032e0 	.word	0x200032e0

080141f0 <LOS_AllCpuUsage>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_AllCpuUsage(UINT16 maxNum, CPUP_INFO_S *cpupInfo, UINT32 mode, UINT16 flag)
{
 80141f0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 80141f4:	b08e      	sub	sp, #56	; 0x38
 80141f6:	af00      	add	r7, sp, #0
 80141f8:	60b9      	str	r1, [r7, #8]
 80141fa:	607a      	str	r2, [r7, #4]
 80141fc:	461a      	mov	r2, r3
 80141fe:	4603      	mov	r3, r0
 8014200:	81fb      	strh	r3, [r7, #14]
 8014202:	4613      	mov	r3, r2
 8014204:	81bb      	strh	r3, [r7, #12]
 8014206:	4b7b      	ldr	r3, [pc, #492]	; (80143f4 <LOS_AllCpuUsage+0x204>)
 8014208:	681b      	ldr	r3, [r3, #0]
 801420a:	637b      	str	r3, [r7, #52]	; 0x34
 801420c:	f04f 0300 	mov.w	r3, #0
    UINT16 pos;
    UINT16 prePos;
    UINT32 intSave;
    UINT64 cpuCycleAll;
    UINT64 cpuCycleCurTask;
    UINT16 numTmpMax = maxNum;
 8014210:	89fb      	ldrh	r3, [r7, #14]
 8014212:	82fb      	strh	r3, [r7, #22]
    UINT16 numTmpMin = 0;
 8014214:	2300      	movs	r3, #0
 8014216:	833b      	strh	r3, [r7, #24]
    UINT16 numMax = g_cpupTaskMaxNum;
 8014218:	4b77      	ldr	r3, [pc, #476]	; (80143f8 <LOS_AllCpuUsage+0x208>)
 801421a:	881b      	ldrh	r3, [r3, #0]
 801421c:	837b      	strh	r3, [r7, #26]

    if (g_cpupInitFlg == 0) {
 801421e:	4b77      	ldr	r3, [pc, #476]	; (80143fc <LOS_AllCpuUsage+0x20c>)
 8014220:	881b      	ldrh	r3, [r3, #0]
 8014222:	2b00      	cmp	r3, #0
 8014224:	d101      	bne.n	801422a <LOS_AllCpuUsage+0x3a>
        return  LOS_ERRNO_CPUP_NO_INIT;
 8014226:	4b76      	ldr	r3, [pc, #472]	; (8014400 <LOS_AllCpuUsage+0x210>)
 8014228:	e0d8      	b.n	80143dc <LOS_AllCpuUsage+0x1ec>
    }

    if (cpupInfo == NULL) {
 801422a:	68bb      	ldr	r3, [r7, #8]
 801422c:	2b00      	cmp	r3, #0
 801422e:	d101      	bne.n	8014234 <LOS_AllCpuUsage+0x44>
        return LOS_ERRNO_CPUP_TASK_PTR_NULL;
 8014230:	4b74      	ldr	r3, [pc, #464]	; (8014404 <LOS_AllCpuUsage+0x214>)
 8014232:	e0d3      	b.n	80143dc <LOS_AllCpuUsage+0x1ec>
    }

    if (maxNum == 0) {
 8014234:	89fb      	ldrh	r3, [r7, #14]
 8014236:	2b00      	cmp	r3, #0
 8014238:	d101      	bne.n	801423e <LOS_AllCpuUsage+0x4e>
        return  LOS_ERRNO_CPUP_MAXNUM_INVALID;
 801423a:	4b73      	ldr	r3, [pc, #460]	; (8014408 <LOS_AllCpuUsage+0x218>)
 801423c:	e0ce      	b.n	80143dc <LOS_AllCpuUsage+0x1ec>
    }

#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    if (flag == 0) {
 801423e:	89bb      	ldrh	r3, [r7, #12]
 8014240:	2b00      	cmp	r3, #0
 8014242:	d10c      	bne.n	801425e <LOS_AllCpuUsage+0x6e>
        numTmpMax += g_cpupTaskMaxNum;
 8014244:	4b6c      	ldr	r3, [pc, #432]	; (80143f8 <LOS_AllCpuUsage+0x208>)
 8014246:	881a      	ldrh	r2, [r3, #0]
 8014248:	8afb      	ldrh	r3, [r7, #22]
 801424a:	4413      	add	r3, r2
 801424c:	82fb      	strh	r3, [r7, #22]
        numTmpMin += g_cpupTaskMaxNum;
 801424e:	4b6a      	ldr	r3, [pc, #424]	; (80143f8 <LOS_AllCpuUsage+0x208>)
 8014250:	881a      	ldrh	r2, [r3, #0]
 8014252:	8b3b      	ldrh	r3, [r7, #24]
 8014254:	4413      	add	r3, r2
 8014256:	833b      	strh	r3, [r7, #24]
        numMax = g_cpupMaxNum;
 8014258:	4b6c      	ldr	r3, [pc, #432]	; (801440c <LOS_AllCpuUsage+0x21c>)
 801425a:	881b      	ldrh	r3, [r3, #0]
 801425c:	837b      	strh	r3, [r7, #26]
    }
#endif

    if (numTmpMax > numMax) {
 801425e:	8afa      	ldrh	r2, [r7, #22]
 8014260:	8b7b      	ldrh	r3, [r7, #26]
 8014262:	429a      	cmp	r2, r3
 8014264:	d901      	bls.n	801426a <LOS_AllCpuUsage+0x7a>
        numTmpMax = numMax;
 8014266:	8b7b      	ldrh	r3, [r7, #26]
 8014268:	82fb      	strh	r3, [r7, #22]
    }

    intSave = LOS_IntLock();
 801426a:	f7ff fa9b 	bl	80137a4 <LOS_IntLock>
 801426e:	61f8      	str	r0, [r7, #28]
    OsTaskCycleEnd();
 8014270:	f7ff fcd0 	bl	8013c14 <OsTaskCycleEnd>

    OsCpupGetPos(mode, &pos, &prePos);
 8014274:	f107 0212 	add.w	r2, r7, #18
 8014278:	f107 0310 	add.w	r3, r7, #16
 801427c:	4619      	mov	r1, r3
 801427e:	6878      	ldr	r0, [r7, #4]
 8014280:	f7ff fdda 	bl	8013e38 <OsCpupGetPos>
    cpuCycleAll = cpuHistoryTime[pos] - cpuHistoryTime[prePos];
 8014284:	8a3b      	ldrh	r3, [r7, #16]
 8014286:	4a62      	ldr	r2, [pc, #392]	; (8014410 <LOS_AllCpuUsage+0x220>)
 8014288:	00db      	lsls	r3, r3, #3
 801428a:	4413      	add	r3, r2
 801428c:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014290:	8a7b      	ldrh	r3, [r7, #18]
 8014292:	4a5f      	ldr	r2, [pc, #380]	; (8014410 <LOS_AllCpuUsage+0x220>)
 8014294:	00db      	lsls	r3, r3, #3
 8014296:	4413      	add	r3, r2
 8014298:	e9d3 2300 	ldrd	r2, r3, [r3]
 801429c:	1a84      	subs	r4, r0, r2
 801429e:	eb61 0503 	sbc.w	r5, r1, r3
 80142a2:	e9c7 4508 	strd	r4, r5, [r7, #32]

    for (loop = numTmpMin; loop < numTmpMax; loop++) {
 80142a6:	8b3b      	ldrh	r3, [r7, #24]
 80142a8:	82bb      	strh	r3, [r7, #20]
 80142aa:	e08c      	b.n	80143c6 <LOS_AllCpuUsage+0x1d6>
        if ((g_cpup[loop].status & OS_TASK_STATUS_UNUSED) || (g_cpup[loop].status == 0)) {
 80142ac:	4b59      	ldr	r3, [pc, #356]	; (8014414 <LOS_AllCpuUsage+0x224>)
 80142ae:	6819      	ldr	r1, [r3, #0]
 80142b0:	8aba      	ldrh	r2, [r7, #20]
 80142b2:	4613      	mov	r3, r2
 80142b4:	011b      	lsls	r3, r3, #4
 80142b6:	1a9b      	subs	r3, r3, r2
 80142b8:	00db      	lsls	r3, r3, #3
 80142ba:	440b      	add	r3, r1
 80142bc:	889b      	ldrh	r3, [r3, #4]
 80142be:	f003 0301 	and.w	r3, r3, #1
 80142c2:	2b00      	cmp	r3, #0
 80142c4:	d17b      	bne.n	80143be <LOS_AllCpuUsage+0x1ce>
 80142c6:	4b53      	ldr	r3, [pc, #332]	; (8014414 <LOS_AllCpuUsage+0x224>)
 80142c8:	6819      	ldr	r1, [r3, #0]
 80142ca:	8aba      	ldrh	r2, [r7, #20]
 80142cc:	4613      	mov	r3, r2
 80142ce:	011b      	lsls	r3, r3, #4
 80142d0:	1a9b      	subs	r3, r3, r2
 80142d2:	00db      	lsls	r3, r3, #3
 80142d4:	440b      	add	r3, r1
 80142d6:	889b      	ldrh	r3, [r3, #4]
 80142d8:	2b00      	cmp	r3, #0
 80142da:	d070      	beq.n	80143be <LOS_AllCpuUsage+0x1ce>
            continue;
        }

        cpuCycleCurTask = g_cpup[loop].historyTime[pos] - g_cpup[loop].historyTime[prePos];
 80142dc:	4b4d      	ldr	r3, [pc, #308]	; (8014414 <LOS_AllCpuUsage+0x224>)
 80142de:	6819      	ldr	r1, [r3, #0]
 80142e0:	8aba      	ldrh	r2, [r7, #20]
 80142e2:	4613      	mov	r3, r2
 80142e4:	011b      	lsls	r3, r3, #4
 80142e6:	1a9b      	subs	r3, r3, r2
 80142e8:	00db      	lsls	r3, r3, #3
 80142ea:	18ca      	adds	r2, r1, r3
 80142ec:	8a3b      	ldrh	r3, [r7, #16]
 80142ee:	3303      	adds	r3, #3
 80142f0:	00db      	lsls	r3, r3, #3
 80142f2:	4413      	add	r3, r2
 80142f4:	e9d3 0100 	ldrd	r0, r1, [r3]
 80142f8:	4b46      	ldr	r3, [pc, #280]	; (8014414 <LOS_AllCpuUsage+0x224>)
 80142fa:	681c      	ldr	r4, [r3, #0]
 80142fc:	8aba      	ldrh	r2, [r7, #20]
 80142fe:	4613      	mov	r3, r2
 8014300:	011b      	lsls	r3, r3, #4
 8014302:	1a9b      	subs	r3, r3, r2
 8014304:	00db      	lsls	r3, r3, #3
 8014306:	18e2      	adds	r2, r4, r3
 8014308:	8a7b      	ldrh	r3, [r7, #18]
 801430a:	3303      	adds	r3, #3
 801430c:	00db      	lsls	r3, r3, #3
 801430e:	4413      	add	r3, r2
 8014310:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014314:	ebb0 0802 	subs.w	r8, r0, r2
 8014318:	eb61 0903 	sbc.w	r9, r1, r3
 801431c:	e9c7 890a 	strd	r8, r9, [r7, #40]	; 0x28
        cpupInfo[loop - numTmpMin].usStatus = g_cpup[loop].status;
 8014320:	4b3c      	ldr	r3, [pc, #240]	; (8014414 <LOS_AllCpuUsage+0x224>)
 8014322:	6819      	ldr	r1, [r3, #0]
 8014324:	8aba      	ldrh	r2, [r7, #20]
 8014326:	4613      	mov	r3, r2
 8014328:	011b      	lsls	r3, r3, #4
 801432a:	1a9b      	subs	r3, r3, r2
 801432c:	00db      	lsls	r3, r3, #3
 801432e:	18ca      	adds	r2, r1, r3
 8014330:	8ab9      	ldrh	r1, [r7, #20]
 8014332:	8b3b      	ldrh	r3, [r7, #24]
 8014334:	1acb      	subs	r3, r1, r3
 8014336:	00db      	lsls	r3, r3, #3
 8014338:	68b9      	ldr	r1, [r7, #8]
 801433a:	440b      	add	r3, r1
 801433c:	8892      	ldrh	r2, [r2, #4]
 801433e:	801a      	strh	r2, [r3, #0]

        if (cpuCycleAll) {
 8014340:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8014344:	4313      	orrs	r3, r2
 8014346:	d03b      	beq.n	80143c0 <LOS_AllCpuUsage+0x1d0>
            cpupInfo[loop - numTmpMin].uwUsage = (UINT32)((LOS_CPUP_PRECISION * cpuCycleCurTask) / cpuCycleAll);
 8014348:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 801434c:	4602      	mov	r2, r0
 801434e:	460b      	mov	r3, r1
 8014350:	f04f 0400 	mov.w	r4, #0
 8014354:	f04f 0500 	mov.w	r5, #0
 8014358:	015d      	lsls	r5, r3, #5
 801435a:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 801435e:	0154      	lsls	r4, r2, #5
 8014360:	4622      	mov	r2, r4
 8014362:	462b      	mov	r3, r5
 8014364:	1a12      	subs	r2, r2, r0
 8014366:	eb63 0301 	sbc.w	r3, r3, r1
 801436a:	f04f 0400 	mov.w	r4, #0
 801436e:	f04f 0500 	mov.w	r5, #0
 8014372:	009d      	lsls	r5, r3, #2
 8014374:	ea45 7592 	orr.w	r5, r5, r2, lsr #30
 8014378:	0094      	lsls	r4, r2, #2
 801437a:	4622      	mov	r2, r4
 801437c:	462b      	mov	r3, r5
 801437e:	1812      	adds	r2, r2, r0
 8014380:	eb41 0303 	adc.w	r3, r1, r3
 8014384:	f04f 0000 	mov.w	r0, #0
 8014388:	f04f 0100 	mov.w	r1, #0
 801438c:	00d9      	lsls	r1, r3, #3
 801438e:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8014392:	00d0      	lsls	r0, r2, #3
 8014394:	4602      	mov	r2, r0
 8014396:	460b      	mov	r3, r1
 8014398:	4610      	mov	r0, r2
 801439a:	4619      	mov	r1, r3
 801439c:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80143a0:	f7ec faf8 	bl	8000994 <__aeabi_uldivmod>
 80143a4:	4602      	mov	r2, r0
 80143a6:	460b      	mov	r3, r1
 80143a8:	4610      	mov	r0, r2
 80143aa:	4619      	mov	r1, r3
 80143ac:	8aba      	ldrh	r2, [r7, #20]
 80143ae:	8b3b      	ldrh	r3, [r7, #24]
 80143b0:	1ad3      	subs	r3, r2, r3
 80143b2:	00db      	lsls	r3, r3, #3
 80143b4:	68ba      	ldr	r2, [r7, #8]
 80143b6:	4413      	add	r3, r2
 80143b8:	4602      	mov	r2, r0
 80143ba:	605a      	str	r2, [r3, #4]
 80143bc:	e000      	b.n	80143c0 <LOS_AllCpuUsage+0x1d0>
            continue;
 80143be:	bf00      	nop
    for (loop = numTmpMin; loop < numTmpMax; loop++) {
 80143c0:	8abb      	ldrh	r3, [r7, #20]
 80143c2:	3301      	adds	r3, #1
 80143c4:	82bb      	strh	r3, [r7, #20]
 80143c6:	8aba      	ldrh	r2, [r7, #20]
 80143c8:	8afb      	ldrh	r3, [r7, #22]
 80143ca:	429a      	cmp	r2, r3
 80143cc:	f4ff af6e 	bcc.w	80142ac <LOS_AllCpuUsage+0xbc>
        }
    }

    OsTaskCycleStart();
 80143d0:	f7ff fbf0 	bl	8013bb4 <OsTaskCycleStart>
    LOS_IntRestore(intSave);
 80143d4:	69f8      	ldr	r0, [r7, #28]
 80143d6:	f7ff f9ec 	bl	80137b2 <LOS_IntRestore>

    return LOS_OK;
 80143da:	2300      	movs	r3, #0
}
 80143dc:	4a05      	ldr	r2, [pc, #20]	; (80143f4 <LOS_AllCpuUsage+0x204>)
 80143de:	6811      	ldr	r1, [r2, #0]
 80143e0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80143e2:	4051      	eors	r1, r2
 80143e4:	d001      	beq.n	80143ea <LOS_AllCpuUsage+0x1fa>
 80143e6:	f7ef ffff 	bl	80043e8 <__stack_chk_fail>
 80143ea:	4618      	mov	r0, r3
 80143ec:	3738      	adds	r7, #56	; 0x38
 80143ee:	46bd      	mov	sp, r7
 80143f0:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 80143f4:	08022874 	.word	0x08022874
 80143f8:	200032d6 	.word	0x200032d6
 80143fc:	200032ce 	.word	0x200032ce
 8014400:	02001e02 	.word	0x02001e02
 8014404:	02001e01 	.word	0x02001e01
 8014408:	02001e03 	.word	0x02001e03
 801440c:	200032d4 	.word	0x200032d4
 8014410:	200032e0 	.word	0x200032e0
 8014414:	200032d0 	.word	0x200032d0

08014418 <OsCpupIrqStart>:

#ifdef LOSCFG_CPUP_INCLUDE_IRQ
LITE_OS_SEC_TEXT_MINOR VOID OsCpupIrqStart(VOID)
{
 8014418:	b598      	push	{r3, r4, r7, lr}
 801441a:	af00      	add	r7, sp, #0
    g_intTimeStart[ArchCurrCpuid()] = OsCpupGetCycle();
 801441c:	f7ff f9ba 	bl	8013794 <ArchCurrCpuid>
 8014420:	4604      	mov	r4, r0
 8014422:	f7ff fb61 	bl	8013ae8 <OsCpupGetCycle>
 8014426:	4602      	mov	r2, r0
 8014428:	460b      	mov	r3, r1
 801442a:	4803      	ldr	r0, [pc, #12]	; (8014438 <OsCpupIrqStart+0x20>)
 801442c:	00e1      	lsls	r1, r4, #3
 801442e:	4401      	add	r1, r0
 8014430:	e9c1 2300 	strd	r2, r3, [r1]
    return;
 8014434:	bf00      	nop
}
 8014436:	bd98      	pop	{r3, r4, r7, pc}
 8014438:	20003348 	.word	0x20003348

0801443c <OsCpupIrqEnd>:

LITE_OS_SEC_TEXT_MINOR VOID OsCpupIrqEnd(UINT32 intNum)
{
 801443c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8014440:	b08a      	sub	sp, #40	; 0x28
 8014442:	af00      	add	r7, sp, #0
 8014444:	6178      	str	r0, [r7, #20]
    UINT64 intTimeEnd = OsCpupGetCycle();
 8014446:	f7ff fb4f 	bl	8013ae8 <OsCpupGetCycle>
 801444a:	e9c7 0108 	strd	r0, r1, [r7, #32]
    UINT32 cpuId = ArchCurrCpuid();
 801444e:	f7ff f9a1 	bl	8013794 <ArchCurrCpuid>
 8014452:	61f8      	str	r0, [r7, #28]

    if (g_cpupInitFlg == 0) {
 8014454:	4b37      	ldr	r3, [pc, #220]	; (8014534 <OsCpupIrqEnd+0xf8>)
 8014456:	881b      	ldrh	r3, [r3, #0]
 8014458:	2b00      	cmp	r3, #0
 801445a:	d066      	beq.n	801452a <OsCpupIrqEnd+0xee>
        return;
    }

    g_cpup[g_taskMaxNum + intNum].id = intNum;
 801445c:	4b36      	ldr	r3, [pc, #216]	; (8014538 <OsCpupIrqEnd+0xfc>)
 801445e:	6819      	ldr	r1, [r3, #0]
 8014460:	4b36      	ldr	r3, [pc, #216]	; (801453c <OsCpupIrqEnd+0x100>)
 8014462:	681a      	ldr	r2, [r3, #0]
 8014464:	697b      	ldr	r3, [r7, #20]
 8014466:	441a      	add	r2, r3
 8014468:	4613      	mov	r3, r2
 801446a:	011b      	lsls	r3, r3, #4
 801446c:	1a9b      	subs	r3, r3, r2
 801446e:	00db      	lsls	r3, r3, #3
 8014470:	440b      	add	r3, r1
 8014472:	697a      	ldr	r2, [r7, #20]
 8014474:	601a      	str	r2, [r3, #0]
    g_cpup[g_taskMaxNum + intNum].status = OS_TASK_STATUS_RUNNING;
 8014476:	4b30      	ldr	r3, [pc, #192]	; (8014538 <OsCpupIrqEnd+0xfc>)
 8014478:	6819      	ldr	r1, [r3, #0]
 801447a:	4b30      	ldr	r3, [pc, #192]	; (801453c <OsCpupIrqEnd+0x100>)
 801447c:	681a      	ldr	r2, [r3, #0]
 801447e:	697b      	ldr	r3, [r7, #20]
 8014480:	441a      	add	r2, r3
 8014482:	4613      	mov	r3, r2
 8014484:	011b      	lsls	r3, r3, #4
 8014486:	1a9b      	subs	r3, r3, r2
 8014488:	00db      	lsls	r3, r3, #3
 801448a:	440b      	add	r3, r1
 801448c:	2210      	movs	r2, #16
 801448e:	809a      	strh	r2, [r3, #4]
    g_timeInIrqPerTskSwitch[cpuId] += (intTimeEnd - g_intTimeStart[cpuId]);
 8014490:	4a2b      	ldr	r2, [pc, #172]	; (8014540 <OsCpupIrqEnd+0x104>)
 8014492:	69fb      	ldr	r3, [r7, #28]
 8014494:	00db      	lsls	r3, r3, #3
 8014496:	4413      	add	r3, r2
 8014498:	e9d3 2300 	ldrd	r2, r3, [r3]
 801449c:	4829      	ldr	r0, [pc, #164]	; (8014544 <OsCpupIrqEnd+0x108>)
 801449e:	69f9      	ldr	r1, [r7, #28]
 80144a0:	00c9      	lsls	r1, r1, #3
 80144a2:	4401      	add	r1, r0
 80144a4:	e9d1 0100 	ldrd	r0, r1, [r1]
 80144a8:	e9d7 ab08 	ldrd	sl, fp, [r7, #32]
 80144ac:	ebba 0400 	subs.w	r4, sl, r0
 80144b0:	eb6b 0501 	sbc.w	r5, fp, r1
 80144b4:	1911      	adds	r1, r2, r4
 80144b6:	60b9      	str	r1, [r7, #8]
 80144b8:	416b      	adcs	r3, r5
 80144ba:	60fb      	str	r3, [r7, #12]
 80144bc:	4a20      	ldr	r2, [pc, #128]	; (8014540 <OsCpupIrqEnd+0x104>)
 80144be:	69fb      	ldr	r3, [r7, #28]
 80144c0:	00db      	lsls	r3, r3, #3
 80144c2:	4413      	add	r3, r2
 80144c4:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 80144c8:	e9c3 1200 	strd	r1, r2, [r3]
    g_cpup[g_taskMaxNum + intNum].allTime += (intTimeEnd - g_intTimeStart[cpuId]);
 80144cc:	4b1a      	ldr	r3, [pc, #104]	; (8014538 <OsCpupIrqEnd+0xfc>)
 80144ce:	6819      	ldr	r1, [r3, #0]
 80144d0:	4b1a      	ldr	r3, [pc, #104]	; (801453c <OsCpupIrqEnd+0x100>)
 80144d2:	681a      	ldr	r2, [r3, #0]
 80144d4:	697b      	ldr	r3, [r7, #20]
 80144d6:	441a      	add	r2, r3
 80144d8:	4613      	mov	r3, r2
 80144da:	011b      	lsls	r3, r3, #4
 80144dc:	1a9b      	subs	r3, r3, r2
 80144de:	00db      	lsls	r3, r3, #3
 80144e0:	440b      	add	r3, r1
 80144e2:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80144e6:	4a17      	ldr	r2, [pc, #92]	; (8014544 <OsCpupIrqEnd+0x108>)
 80144e8:	69fb      	ldr	r3, [r7, #28]
 80144ea:	00db      	lsls	r3, r3, #3
 80144ec:	4413      	add	r3, r2
 80144ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80144f2:	e9d7 4508 	ldrd	r4, r5, [r7, #32]
 80144f6:	ebb4 0802 	subs.w	r8, r4, r2
 80144fa:	eb65 0903 	sbc.w	r9, r5, r3
 80144fe:	4b0e      	ldr	r3, [pc, #56]	; (8014538 <OsCpupIrqEnd+0xfc>)
 8014500:	681c      	ldr	r4, [r3, #0]
 8014502:	4b0e      	ldr	r3, [pc, #56]	; (801453c <OsCpupIrqEnd+0x100>)
 8014504:	681a      	ldr	r2, [r3, #0]
 8014506:	697b      	ldr	r3, [r7, #20]
 8014508:	441a      	add	r2, r3
 801450a:	4613      	mov	r3, r2
 801450c:	011b      	lsls	r3, r3, #4
 801450e:	1a9b      	subs	r3, r3, r2
 8014510:	00db      	lsls	r3, r3, #3
 8014512:	4423      	add	r3, r4
 8014514:	eb10 0208 	adds.w	r2, r0, r8
 8014518:	603a      	str	r2, [r7, #0]
 801451a:	eb41 0209 	adc.w	r2, r1, r9
 801451e:	607a      	str	r2, [r7, #4]
 8014520:	e9d7 1200 	ldrd	r1, r2, [r7]
 8014524:	e9c3 1202 	strd	r1, r2, [r3, #8]

    return;
 8014528:	e000      	b.n	801452c <OsCpupIrqEnd+0xf0>
        return;
 801452a:	bf00      	nop
}
 801452c:	3728      	adds	r7, #40	; 0x28
 801452e:	46bd      	mov	sp, r7
 8014530:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8014534:	200032ce 	.word	0x200032ce
 8014538:	200032d0 	.word	0x200032d0
 801453c:	200036d8 	.word	0x200036d8
 8014540:	20003770 	.word	0x20003770
 8014544:	20003348 	.word	0x20003348

08014548 <OsCmdCpupOperateOneParam>:
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

VOID OsCmdCpupOperateOneParam(UINT32 mode)
{
 8014548:	b580      	push	{r7, lr}
 801454a:	b084      	sub	sp, #16
 801454c:	af00      	add	r7, sp, #0
 801454e:	6078      	str	r0, [r7, #4]
    UINT32 ret;

    if (mode == CPUP_LAST_TEN_SECONDS) {
 8014550:	687b      	ldr	r3, [r7, #4]
 8014552:	2b00      	cmp	r3, #0
 8014554:	d103      	bne.n	801455e <OsCmdCpupOperateOneParam+0x16>
        PRINTK("\nSysCpuUsage in 10s: ");
 8014556:	4814      	ldr	r0, [pc, #80]	; (80145a8 <OsCmdCpupOperateOneParam+0x60>)
 8014558:	f7f0 f8b8 	bl	80046cc <dprintf>
 801455c:	e009      	b.n	8014572 <OsCmdCpupOperateOneParam+0x2a>
    } else if (mode == CPUP_LAST_ONE_SECONDS) {
 801455e:	687b      	ldr	r3, [r7, #4]
 8014560:	2b01      	cmp	r3, #1
 8014562:	d103      	bne.n	801456c <OsCmdCpupOperateOneParam+0x24>
        PRINTK("\nSysCpuUsage in 1s: ");
 8014564:	4811      	ldr	r0, [pc, #68]	; (80145ac <OsCmdCpupOperateOneParam+0x64>)
 8014566:	f7f0 f8b1 	bl	80046cc <dprintf>
 801456a:	e002      	b.n	8014572 <OsCmdCpupOperateOneParam+0x2a>
    } else {
        PRINTK("\nSysCpuUsage in all time: ");
 801456c:	4810      	ldr	r0, [pc, #64]	; (80145b0 <OsCmdCpupOperateOneParam+0x68>)
 801456e:	f7f0 f8ad 	bl	80046cc <dprintf>
    }
    ret = LOS_HistorySysCpuUsage(mode);
 8014572:	6878      	ldr	r0, [r7, #4]
 8014574:	f7ff fce2 	bl	8013f3c <LOS_HistorySysCpuUsage>
 8014578:	60f8      	str	r0, [r7, #12]
    PRINTK("%u.%u", ret / LOS_CPUP_PRECISION_MULT, ret % LOS_CPUP_PRECISION_MULT);
 801457a:	68fb      	ldr	r3, [r7, #12]
 801457c:	4a0d      	ldr	r2, [pc, #52]	; (80145b4 <OsCmdCpupOperateOneParam+0x6c>)
 801457e:	fba2 2303 	umull	r2, r3, r2, r3
 8014582:	08d8      	lsrs	r0, r3, #3
 8014584:	68f9      	ldr	r1, [r7, #12]
 8014586:	4b0b      	ldr	r3, [pc, #44]	; (80145b4 <OsCmdCpupOperateOneParam+0x6c>)
 8014588:	fba3 2301 	umull	r2, r3, r3, r1
 801458c:	08da      	lsrs	r2, r3, #3
 801458e:	4613      	mov	r3, r2
 8014590:	009b      	lsls	r3, r3, #2
 8014592:	4413      	add	r3, r2
 8014594:	005b      	lsls	r3, r3, #1
 8014596:	1aca      	subs	r2, r1, r3
 8014598:	4601      	mov	r1, r0
 801459a:	4807      	ldr	r0, [pc, #28]	; (80145b8 <OsCmdCpupOperateOneParam+0x70>)
 801459c:	f7f0 f896 	bl	80046cc <dprintf>
}
 80145a0:	bf00      	nop
 80145a2:	3710      	adds	r7, #16
 80145a4:	46bd      	mov	sp, r7
 80145a6:	bd80      	pop	{r7, pc}
 80145a8:	08022878 	.word	0x08022878
 80145ac:	08022890 	.word	0x08022890
 80145b0:	080228a8 	.word	0x080228a8
 80145b4:	cccccccd 	.word	0xcccccccd
 80145b8:	080228c4 	.word	0x080228c4

080145bc <OsCmdCpupOperateTwoParam>:

VOID OsCmdCpupOperateTwoParam(UINT32 mode, UINT32 taskId)
{
 80145bc:	b580      	push	{r7, lr}
 80145be:	b084      	sub	sp, #16
 80145c0:	af00      	add	r7, sp, #0
 80145c2:	6078      	str	r0, [r7, #4]
 80145c4:	6039      	str	r1, [r7, #0]
    UINT32 ret;

    if (mode == CPUP_LAST_TEN_SECONDS) {
 80145c6:	687b      	ldr	r3, [r7, #4]
 80145c8:	2b00      	cmp	r3, #0
 80145ca:	d104      	bne.n	80145d6 <OsCmdCpupOperateTwoParam+0x1a>
        PRINTK("\nTaskId %u CpuUsage in 10s: ", taskId);
 80145cc:	6839      	ldr	r1, [r7, #0]
 80145ce:	4816      	ldr	r0, [pc, #88]	; (8014628 <OsCmdCpupOperateTwoParam+0x6c>)
 80145d0:	f7f0 f87c 	bl	80046cc <dprintf>
 80145d4:	e00b      	b.n	80145ee <OsCmdCpupOperateTwoParam+0x32>
    } else if (mode == CPUP_LAST_ONE_SECONDS) {
 80145d6:	687b      	ldr	r3, [r7, #4]
 80145d8:	2b01      	cmp	r3, #1
 80145da:	d104      	bne.n	80145e6 <OsCmdCpupOperateTwoParam+0x2a>
        PRINTK("\nTaskId %u CpuUsage in 1s: ", taskId);
 80145dc:	6839      	ldr	r1, [r7, #0]
 80145de:	4813      	ldr	r0, [pc, #76]	; (801462c <OsCmdCpupOperateTwoParam+0x70>)
 80145e0:	f7f0 f874 	bl	80046cc <dprintf>
 80145e4:	e003      	b.n	80145ee <OsCmdCpupOperateTwoParam+0x32>
    } else {
        PRINTK("\nTaskId %u CpuUsage in all time: ", taskId);
 80145e6:	6839      	ldr	r1, [r7, #0]
 80145e8:	4811      	ldr	r0, [pc, #68]	; (8014630 <OsCmdCpupOperateTwoParam+0x74>)
 80145ea:	f7f0 f86f 	bl	80046cc <dprintf>
    }
    ret = LOS_HistoryTaskCpuUsage(taskId, mode);
 80145ee:	6879      	ldr	r1, [r7, #4]
 80145f0:	6838      	ldr	r0, [r7, #0]
 80145f2:	f7ff fd53 	bl	801409c <LOS_HistoryTaskCpuUsage>
 80145f6:	60f8      	str	r0, [r7, #12]
    PRINTK("%u.%u", ret / LOS_CPUP_PRECISION_MULT, ret % LOS_CPUP_PRECISION_MULT);
 80145f8:	68fb      	ldr	r3, [r7, #12]
 80145fa:	4a0e      	ldr	r2, [pc, #56]	; (8014634 <OsCmdCpupOperateTwoParam+0x78>)
 80145fc:	fba2 2303 	umull	r2, r3, r2, r3
 8014600:	08d8      	lsrs	r0, r3, #3
 8014602:	68f9      	ldr	r1, [r7, #12]
 8014604:	4b0b      	ldr	r3, [pc, #44]	; (8014634 <OsCmdCpupOperateTwoParam+0x78>)
 8014606:	fba3 2301 	umull	r2, r3, r3, r1
 801460a:	08da      	lsrs	r2, r3, #3
 801460c:	4613      	mov	r3, r2
 801460e:	009b      	lsls	r3, r3, #2
 8014610:	4413      	add	r3, r2
 8014612:	005b      	lsls	r3, r3, #1
 8014614:	1aca      	subs	r2, r1, r3
 8014616:	4601      	mov	r1, r0
 8014618:	4807      	ldr	r0, [pc, #28]	; (8014638 <OsCmdCpupOperateTwoParam+0x7c>)
 801461a:	f7f0 f857 	bl	80046cc <dprintf>
}
 801461e:	bf00      	nop
 8014620:	3710      	adds	r7, #16
 8014622:	46bd      	mov	sp, r7
 8014624:	bd80      	pop	{r7, pc}
 8014626:	bf00      	nop
 8014628:	080228cc 	.word	0x080228cc
 801462c:	080228ec 	.word	0x080228ec
 8014630:	08022908 	.word	0x08022908
 8014634:	cccccccd 	.word	0xcccccccd
 8014638:	080228c4 	.word	0x080228c4

0801463c <OsShellCmdCpup>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdCpup(INT32 argc, const CHAR **argv)
{
 801463c:	b580      	push	{r7, lr}
 801463e:	b08a      	sub	sp, #40	; 0x28
 8014640:	af00      	add	r7, sp, #0
 8014642:	6078      	str	r0, [r7, #4]
 8014644:	6039      	str	r1, [r7, #0]
 8014646:	4b47      	ldr	r3, [pc, #284]	; (8014764 <OsShellCmdCpup+0x128>)
 8014648:	681b      	ldr	r3, [r3, #0]
 801464a:	627b      	str	r3, [r7, #36]	; 0x24
 801464c:	f04f 0300 	mov.w	r3, #0
    size_t mode, taskId;
    CHAR *bufMode = NULL;
 8014650:	2300      	movs	r3, #0
 8014652:	60fb      	str	r3, [r7, #12]
    CHAR *bufId = NULL;
 8014654:	2300      	movs	r3, #0
 8014656:	613b      	str	r3, [r7, #16]
    LosTaskCB *taskCB = NULL;
 8014658:	2300      	movs	r3, #0
 801465a:	61bb      	str	r3, [r7, #24]
    UINT32 ret;

    if (argc <= 0) {
 801465c:	687b      	ldr	r3, [r7, #4]
 801465e:	2b00      	cmp	r3, #0
 8014660:	dc18      	bgt.n	8014694 <OsShellCmdCpup+0x58>
        ret = LOS_HistorySysCpuUsage(CPUP_LAST_TEN_SECONDS);
 8014662:	2000      	movs	r0, #0
 8014664:	f7ff fc6a 	bl	8013f3c <LOS_HistorySysCpuUsage>
 8014668:	6238      	str	r0, [r7, #32]
        PRINTK("\nSysCpuUsage in 10s: %u.%u", ret / LOS_CPUP_PRECISION_MULT, ret % LOS_CPUP_PRECISION_MULT);
 801466a:	6a3b      	ldr	r3, [r7, #32]
 801466c:	4a3e      	ldr	r2, [pc, #248]	; (8014768 <OsShellCmdCpup+0x12c>)
 801466e:	fba2 2303 	umull	r2, r3, r2, r3
 8014672:	08d8      	lsrs	r0, r3, #3
 8014674:	6a39      	ldr	r1, [r7, #32]
 8014676:	4b3c      	ldr	r3, [pc, #240]	; (8014768 <OsShellCmdCpup+0x12c>)
 8014678:	fba3 2301 	umull	r2, r3, r3, r1
 801467c:	08da      	lsrs	r2, r3, #3
 801467e:	4613      	mov	r3, r2
 8014680:	009b      	lsls	r3, r3, #2
 8014682:	4413      	add	r3, r2
 8014684:	005b      	lsls	r3, r3, #1
 8014686:	1aca      	subs	r2, r1, r3
 8014688:	4601      	mov	r1, r0
 801468a:	4838      	ldr	r0, [pc, #224]	; (801476c <OsShellCmdCpup+0x130>)
 801468c:	f7f0 f81e 	bl	80046cc <dprintf>
        return 0;
 8014690:	2300      	movs	r3, #0
 8014692:	e05c      	b.n	801474e <OsShellCmdCpup+0x112>
    }

    mode = strtoul(argv[0], &bufMode, 0);
 8014694:	683b      	ldr	r3, [r7, #0]
 8014696:	681b      	ldr	r3, [r3, #0]
 8014698:	f107 010c 	add.w	r1, r7, #12
 801469c:	2200      	movs	r2, #0
 801469e:	4618      	mov	r0, r3
 80146a0:	f7fa fa76 	bl	800eb90 <strtoul>
 80146a4:	6178      	str	r0, [r7, #20]
    if ((bufMode == NULL) || (*bufMode != 0)) {
 80146a6:	68fb      	ldr	r3, [r7, #12]
 80146a8:	2b00      	cmp	r3, #0
 80146aa:	d003      	beq.n	80146b4 <OsShellCmdCpup+0x78>
 80146ac:	68fb      	ldr	r3, [r7, #12]
 80146ae:	781b      	ldrb	r3, [r3, #0]
 80146b0:	2b00      	cmp	r3, #0
 80146b2:	d004      	beq.n	80146be <OsShellCmdCpup+0x82>
        PRINTK("\nThe input mode is invalid. Please try again.\n");
 80146b4:	482e      	ldr	r0, [pc, #184]	; (8014770 <OsShellCmdCpup+0x134>)
 80146b6:	f7f0 f809 	bl	80046cc <dprintf>
        return 0;
 80146ba:	2300      	movs	r3, #0
 80146bc:	e047      	b.n	801474e <OsShellCmdCpup+0x112>
    }

    if (mode > CPUP_ALL_TIME) {
 80146be:	697b      	ldr	r3, [r7, #20]
 80146c0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80146c4:	d302      	bcc.n	80146cc <OsShellCmdCpup+0x90>
        mode = CPUP_ALL_TIME;
 80146c6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80146ca:	617b      	str	r3, [r7, #20]
    }

    if (argc == 1) {
 80146cc:	687b      	ldr	r3, [r7, #4]
 80146ce:	2b01      	cmp	r3, #1
 80146d0:	d104      	bne.n	80146dc <OsShellCmdCpup+0xa0>
        OsCmdCpupOperateOneParam((UINT32)mode);
 80146d2:	6978      	ldr	r0, [r7, #20]
 80146d4:	f7ff ff38 	bl	8014548 <OsCmdCpupOperateOneParam>
        return 0;
 80146d8:	2300      	movs	r3, #0
 80146da:	e038      	b.n	801474e <OsShellCmdCpup+0x112>
    }

    taskId = strtoul(argv[1], &bufId, 0);
 80146dc:	683b      	ldr	r3, [r7, #0]
 80146de:	3304      	adds	r3, #4
 80146e0:	681b      	ldr	r3, [r3, #0]
 80146e2:	f107 0110 	add.w	r1, r7, #16
 80146e6:	2200      	movs	r2, #0
 80146e8:	4618      	mov	r0, r3
 80146ea:	f7fa fa51 	bl	800eb90 <strtoul>
 80146ee:	61f8      	str	r0, [r7, #28]
    if ((taskId >= g_taskMaxNum) || (*bufId != 0)) {
 80146f0:	4b20      	ldr	r3, [pc, #128]	; (8014774 <OsShellCmdCpup+0x138>)
 80146f2:	681b      	ldr	r3, [r3, #0]
 80146f4:	69fa      	ldr	r2, [r7, #28]
 80146f6:	429a      	cmp	r2, r3
 80146f8:	d203      	bcs.n	8014702 <OsShellCmdCpup+0xc6>
 80146fa:	693b      	ldr	r3, [r7, #16]
 80146fc:	781b      	ldrb	r3, [r3, #0]
 80146fe:	2b00      	cmp	r3, #0
 8014700:	d004      	beq.n	801470c <OsShellCmdCpup+0xd0>
        PRINTK("\nThe input taskId is invalid. Please try again.\n");
 8014702:	481d      	ldr	r0, [pc, #116]	; (8014778 <OsShellCmdCpup+0x13c>)
 8014704:	f7ef ffe2 	bl	80046cc <dprintf>
        return 0;
 8014708:	2300      	movs	r3, #0
 801470a:	e020      	b.n	801474e <OsShellCmdCpup+0x112>
    }
    taskCB = OS_TCB_FROM_TID(taskId);
 801470c:	4b1b      	ldr	r3, [pc, #108]	; (801477c <OsShellCmdCpup+0x140>)
 801470e:	6819      	ldr	r1, [r3, #0]
 8014710:	69fa      	ldr	r2, [r7, #28]
 8014712:	4613      	mov	r3, r2
 8014714:	009b      	lsls	r3, r3, #2
 8014716:	4413      	add	r3, r2
 8014718:	015b      	lsls	r3, r3, #5
 801471a:	440b      	add	r3, r1
 801471c:	61bb      	str	r3, [r7, #24]
    if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 801471e:	69bb      	ldr	r3, [r7, #24]
 8014720:	889b      	ldrh	r3, [r3, #4]
 8014722:	f003 0301 	and.w	r3, r3, #1
 8014726:	2b00      	cmp	r3, #0
 8014728:	d004      	beq.n	8014734 <OsShellCmdCpup+0xf8>
        PRINTK("\nThe task is unused. Please try again.\n");
 801472a:	4815      	ldr	r0, [pc, #84]	; (8014780 <OsShellCmdCpup+0x144>)
 801472c:	f7ef ffce 	bl	80046cc <dprintf>
        return 0;
 8014730:	2300      	movs	r3, #0
 8014732:	e00c      	b.n	801474e <OsShellCmdCpup+0x112>
    }

    if (argc == 2) {
 8014734:	687b      	ldr	r3, [r7, #4]
 8014736:	2b02      	cmp	r3, #2
 8014738:	d105      	bne.n	8014746 <OsShellCmdCpup+0x10a>
        OsCmdCpupOperateTwoParam((UINT32)mode, (UINT32)taskId);
 801473a:	69f9      	ldr	r1, [r7, #28]
 801473c:	6978      	ldr	r0, [r7, #20]
 801473e:	f7ff ff3d 	bl	80145bc <OsCmdCpupOperateTwoParam>
        return 0;
 8014742:	2300      	movs	r3, #0
 8014744:	e003      	b.n	801474e <OsShellCmdCpup+0x112>
    }

    PRINTK("cpup [MODE] \ncpup [MODE] [TASKID] \n");
 8014746:	480f      	ldr	r0, [pc, #60]	; (8014784 <OsShellCmdCpup+0x148>)
 8014748:	f7ef ffc0 	bl	80046cc <dprintf>
    return 0;
 801474c:	2300      	movs	r3, #0
}
 801474e:	4a05      	ldr	r2, [pc, #20]	; (8014764 <OsShellCmdCpup+0x128>)
 8014750:	6811      	ldr	r1, [r2, #0]
 8014752:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014754:	4051      	eors	r1, r2
 8014756:	d001      	beq.n	801475c <OsShellCmdCpup+0x120>
 8014758:	f7ef fe46 	bl	80043e8 <__stack_chk_fail>
 801475c:	4618      	mov	r0, r3
 801475e:	3728      	adds	r7, #40	; 0x28
 8014760:	46bd      	mov	sp, r7
 8014762:	bd80      	pop	{r7, pc}
 8014764:	080229f8 	.word	0x080229f8
 8014768:	cccccccd 	.word	0xcccccccd
 801476c:	0802292c 	.word	0x0802292c
 8014770:	08022948 	.word	0x08022948
 8014774:	200036d8 	.word	0x200036d8
 8014778:	08022978 	.word	0x08022978
 801477c:	200036c4 	.word	0x200036c4
 8014780:	080229ac 	.word	0x080229ac
 8014784:	080229d4 	.word	0x080229d4

08014788 <ArchCurrCpuid>:
{
 8014788:	b480      	push	{r7}
 801478a:	af00      	add	r7, sp, #0
    return 0;
 801478c:	2300      	movs	r3, #0
}
 801478e:	4618      	mov	r0, r3
 8014790:	46bd      	mov	sp, r7
 8014792:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014796:	4770      	bx	lr

08014798 <LOS_IntLock>:
{
 8014798:	b580      	push	{r7, lr}
 801479a:	af00      	add	r7, sp, #0
    return ArchIntLock();
 801479c:	f7ec fa94 	bl	8000cc8 <ArchIntLock>
 80147a0:	4603      	mov	r3, r0
}
 80147a2:	4618      	mov	r0, r3
 80147a4:	bd80      	pop	{r7, pc}

080147a6 <LOS_IntRestore>:
{
 80147a6:	b580      	push	{r7, lr}
 80147a8:	b082      	sub	sp, #8
 80147aa:	af00      	add	r7, sp, #0
 80147ac:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80147ae:	6878      	ldr	r0, [r7, #4]
 80147b0:	f7ec fa92 	bl	8000cd8 <ArchIntRestore>
}
 80147b4:	bf00      	nop
 80147b6:	3708      	adds	r7, #8
 80147b8:	46bd      	mov	sp, r7
 80147ba:	bd80      	pop	{r7, pc}

080147bc <ArchCurrTaskGet>:
{
 80147bc:	b480      	push	{r7}
 80147be:	af00      	add	r7, sp, #0
    return g_runTask;
 80147c0:	4b03      	ldr	r3, [pc, #12]	; (80147d0 <ArchCurrTaskGet+0x14>)
 80147c2:	681b      	ldr	r3, [r3, #0]
}
 80147c4:	4618      	mov	r0, r3
 80147c6:	46bd      	mov	sp, r7
 80147c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80147cc:	4770      	bx	lr
 80147ce:	bf00      	nop
 80147d0:	200033bc 	.word	0x200033bc

080147d4 <OsPercpuGet>:
{
 80147d4:	b580      	push	{r7, lr}
 80147d6:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 80147d8:	f7ff ffd6 	bl	8014788 <ArchCurrCpuid>
 80147dc:	4602      	mov	r2, r0
 80147de:	4613      	mov	r3, r2
 80147e0:	00db      	lsls	r3, r3, #3
 80147e2:	4413      	add	r3, r2
 80147e4:	009b      	lsls	r3, r3, #2
 80147e6:	4a02      	ldr	r2, [pc, #8]	; (80147f0 <OsPercpuGet+0x1c>)
 80147e8:	4413      	add	r3, r2
}
 80147ea:	4618      	mov	r0, r3
 80147ec:	bd80      	pop	{r7, pc}
 80147ee:	bf00      	nop
 80147f0:	200036fc 	.word	0x200036fc

080147f4 <LOS_SpinLockSave>:
{
 80147f4:	b580      	push	{r7, lr}
 80147f6:	b082      	sub	sp, #8
 80147f8:	af00      	add	r7, sp, #0
 80147fa:	6078      	str	r0, [r7, #4]
 80147fc:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 80147fe:	f7ff ffcb 	bl	8014798 <LOS_IntLock>
 8014802:	4602      	mov	r2, r0
 8014804:	683b      	ldr	r3, [r7, #0]
 8014806:	601a      	str	r2, [r3, #0]
}
 8014808:	bf00      	nop
 801480a:	3708      	adds	r7, #8
 801480c:	46bd      	mov	sp, r7
 801480e:	bd80      	pop	{r7, pc}

08014810 <LOS_SpinUnlockRestore>:
{
 8014810:	b580      	push	{r7, lr}
 8014812:	b082      	sub	sp, #8
 8014814:	af00      	add	r7, sp, #0
 8014816:	6078      	str	r0, [r7, #4]
 8014818:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 801481a:	6838      	ldr	r0, [r7, #0]
 801481c:	f7ff ffc3 	bl	80147a6 <LOS_IntRestore>
}
 8014820:	bf00      	nop
 8014822:	3708      	adds	r7, #8
 8014824:	46bd      	mov	sp, r7
 8014826:	bd80      	pop	{r7, pc}

08014828 <OsCurrTaskGet>:
{
 8014828:	b580      	push	{r7, lr}
 801482a:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 801482c:	f7ff ffc6 	bl	80147bc <ArchCurrTaskGet>
 8014830:	4603      	mov	r3, r0
}
 8014832:	4618      	mov	r0, r3
 8014834:	bd80      	pop	{r7, pc}
	...

08014838 <OsTraceHwiFilter>:
LITE_OS_SEC_BSS STATIC TRACE_HWI_FILTER_HOOK g_traceHwiFliterHook = NULL;

LITE_OS_SEC_BSS SPIN_LOCK_INIT(g_traceSpin);

STATIC_INLINE BOOL OsTraceHwiFilter(UINT32 hwiNum)
{
 8014838:	b580      	push	{r7, lr}
 801483a:	b084      	sub	sp, #16
 801483c:	af00      	add	r7, sp, #0
 801483e:	6078      	str	r0, [r7, #4]
    BOOL ret = ((hwiNum == NUM_HAL_INTERRUPT_UART) || (hwiNum == OS_TICK_INT_NUM));
 8014840:	687b      	ldr	r3, [r7, #4]
 8014842:	2b35      	cmp	r3, #53	; 0x35
 8014844:	d002      	beq.n	801484c <OsTraceHwiFilter+0x14>
 8014846:	687b      	ldr	r3, [r7, #4]
 8014848:	2b0f      	cmp	r3, #15
 801484a:	d101      	bne.n	8014850 <OsTraceHwiFilter+0x18>
 801484c:	2301      	movs	r3, #1
 801484e:	e000      	b.n	8014852 <OsTraceHwiFilter+0x1a>
 8014850:	2300      	movs	r3, #0
 8014852:	60fb      	str	r3, [r7, #12]
#ifdef LOSCFG_KERNEL_SMP
    ret |= (hwiNum == LOS_MP_IPI_SCHEDULE);
#endif
    if (g_traceHwiFliterHook != NULL) {
 8014854:	4b08      	ldr	r3, [pc, #32]	; (8014878 <OsTraceHwiFilter+0x40>)
 8014856:	681b      	ldr	r3, [r3, #0]
 8014858:	2b00      	cmp	r3, #0
 801485a:	d007      	beq.n	801486c <OsTraceHwiFilter+0x34>
        ret |= g_traceHwiFliterHook(hwiNum);
 801485c:	4b06      	ldr	r3, [pc, #24]	; (8014878 <OsTraceHwiFilter+0x40>)
 801485e:	681b      	ldr	r3, [r3, #0]
 8014860:	6878      	ldr	r0, [r7, #4]
 8014862:	4798      	blx	r3
 8014864:	4602      	mov	r2, r0
 8014866:	68fb      	ldr	r3, [r7, #12]
 8014868:	4313      	orrs	r3, r2
 801486a:	60fb      	str	r3, [r7, #12]
    }
    return ret;
 801486c:	68fb      	ldr	r3, [r7, #12]
}
 801486e:	4618      	mov	r0, r3
 8014870:	3710      	adds	r7, #16
 8014872:	46bd      	mov	sp, r7
 8014874:	bd80      	pop	{r7, pc}
 8014876:	bf00      	nop
 8014878:	2000335c 	.word	0x2000335c

0801487c <OsTraceSetFrame>:

STATIC VOID OsTraceSetFrame(TraceEventFrame *frame, UINT32 eventType, UINTPTR identity, const UINTPTR *params,
    UINT16 paramCount)
{
 801487c:	b580      	push	{r7, lr}
 801487e:	b088      	sub	sp, #32
 8014880:	af00      	add	r7, sp, #0
 8014882:	60f8      	str	r0, [r7, #12]
 8014884:	60b9      	str	r1, [r7, #8]
 8014886:	607a      	str	r2, [r7, #4]
 8014888:	603b      	str	r3, [r7, #0]
 801488a:	4b45      	ldr	r3, [pc, #276]	; (80149a0 <OsTraceSetFrame+0x124>)
 801488c:	681b      	ldr	r3, [r3, #0]
 801488e:	61fb      	str	r3, [r7, #28]
 8014890:	f04f 0300 	mov.w	r3, #0
    INT32 i;
    UINT32 intSave;

    (VOID)memset_s(frame, sizeof(TraceEventFrame), 0, sizeof(TraceEventFrame));
 8014894:	2328      	movs	r3, #40	; 0x28
 8014896:	2200      	movs	r2, #0
 8014898:	2128      	movs	r1, #40	; 0x28
 801489a:	68f8      	ldr	r0, [r7, #12]
 801489c:	f001 fbf6 	bl	801608c <memset_s>

    if (paramCount > LOSCFG_TRACE_FRAME_MAX_PARAMS) {
 80148a0:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80148a2:	2b03      	cmp	r3, #3
 80148a4:	d901      	bls.n	80148aa <OsTraceSetFrame+0x2e>
        paramCount = LOSCFG_TRACE_FRAME_MAX_PARAMS;
 80148a6:	2303      	movs	r3, #3
 80148a8:	853b      	strh	r3, [r7, #40]	; 0x28
    }

    TRACE_LOCK(intSave);
 80148aa:	f107 0314 	add.w	r3, r7, #20
 80148ae:	4619      	mov	r1, r3
 80148b0:	483c      	ldr	r0, [pc, #240]	; (80149a4 <OsTraceSetFrame+0x128>)
 80148b2:	f7ff ff9f 	bl	80147f4 <LOS_SpinLockSave>
    frame->curTask   = OsTraceGetMaskTid(OsCurrTaskGet()->taskId);
 80148b6:	f7ff ffb7 	bl	8014828 <OsCurrTaskGet>
 80148ba:	4603      	mov	r3, r0
 80148bc:	695b      	ldr	r3, [r3, #20]
 80148be:	4618      	mov	r0, r3
 80148c0:	f000 fb02 	bl	8014ec8 <OsTraceGetMaskTid>
 80148c4:	4602      	mov	r2, r0
 80148c6:	68fb      	ldr	r3, [r7, #12]
 80148c8:	605a      	str	r2, [r3, #4]
    frame->identity  = identity;
 80148ca:	68fb      	ldr	r3, [r7, #12]
 80148cc:	687a      	ldr	r2, [r7, #4]
 80148ce:	611a      	str	r2, [r3, #16]
    frame->curTime   = HalClockGetCycles();
 80148d0:	f7fb f97e 	bl	800fbd0 <HalClockGetCycles>
 80148d4:	4602      	mov	r2, r0
 80148d6:	460b      	mov	r3, r1
 80148d8:	68f9      	ldr	r1, [r7, #12]
 80148da:	e9c1 2302 	strd	r2, r3, [r1, #8]
    frame->eventType = eventType;
 80148de:	68fb      	ldr	r3, [r7, #12]
 80148e0:	68ba      	ldr	r2, [r7, #8]
 80148e2:	601a      	str	r2, [r3, #0]

#ifdef LOSCFG_TRACE_FRAME_CORE_MSG
    frame->core.cpuId      = ArchCurrCpuid();
 80148e4:	f7ff ff50 	bl	8014788 <ArchCurrCpuid>
 80148e8:	4603      	mov	r3, r0
 80148ea:	b2da      	uxtb	r2, r3
 80148ec:	68fb      	ldr	r3, [r7, #12]
 80148ee:	751a      	strb	r2, [r3, #20]
    frame->core.hwiActive  = OS_INT_ACTIVE ? TRUE : FALSE;
 80148f0:	f7ed fdbc 	bl	800246c <IntActive>
 80148f4:	4603      	mov	r3, r0
 80148f6:	2b00      	cmp	r3, #0
 80148f8:	d001      	beq.n	80148fe <OsTraceSetFrame+0x82>
 80148fa:	2101      	movs	r1, #1
 80148fc:	e000      	b.n	8014900 <OsTraceSetFrame+0x84>
 80148fe:	2100      	movs	r1, #0
 8014900:	68fa      	ldr	r2, [r7, #12]
 8014902:	7d53      	ldrb	r3, [r2, #21]
 8014904:	f361 0303 	bfi	r3, r1, #0, #4
 8014908:	7553      	strb	r3, [r2, #21]
    frame->core.taskLockCnt = MIN(OsPercpuGet()->taskLockCnt, 0xF); /* taskLockCnt is 4 bits, max vaule = 0xF */
 801490a:	f7ff ff63 	bl	80147d4 <OsPercpuGet>
 801490e:	4603      	mov	r3, r0
 8014910:	695b      	ldr	r3, [r3, #20]
 8014912:	2b0e      	cmp	r3, #14
 8014914:	d807      	bhi.n	8014926 <OsTraceSetFrame+0xaa>
 8014916:	f7ff ff5d 	bl	80147d4 <OsPercpuGet>
 801491a:	4603      	mov	r3, r0
 801491c:	695b      	ldr	r3, [r3, #20]
 801491e:	f003 030f 	and.w	r3, r3, #15
 8014922:	b2d9      	uxtb	r1, r3
 8014924:	e000      	b.n	8014928 <OsTraceSetFrame+0xac>
 8014926:	210f      	movs	r1, #15
 8014928:	68fa      	ldr	r2, [r7, #12]
 801492a:	7d53      	ldrb	r3, [r2, #21]
 801492c:	f361 1307 	bfi	r3, r1, #4, #4
 8014930:	7553      	strb	r3, [r2, #21]
    frame->core.paramCount = paramCount;
 8014932:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8014934:	f003 030f 	and.w	r3, r3, #15
 8014938:	b2d9      	uxtb	r1, r3
 801493a:	68fa      	ldr	r2, [r7, #12]
 801493c:	7d93      	ldrb	r3, [r2, #22]
 801493e:	f361 0303 	bfi	r3, r1, #0, #4
 8014942:	7593      	strb	r3, [r2, #22]
#endif

#ifdef LOSCFG_TRACE_FRAME_EVENT_COUNT
    frame->eventCount = g_traceEventCount;
 8014944:	4b18      	ldr	r3, [pc, #96]	; (80149a8 <OsTraceSetFrame+0x12c>)
 8014946:	681a      	ldr	r2, [r3, #0]
 8014948:	68fb      	ldr	r3, [r7, #12]
 801494a:	619a      	str	r2, [r3, #24]
    g_traceEventCount++;
 801494c:	4b16      	ldr	r3, [pc, #88]	; (80149a8 <OsTraceSetFrame+0x12c>)
 801494e:	681b      	ldr	r3, [r3, #0]
 8014950:	3301      	adds	r3, #1
 8014952:	4a15      	ldr	r2, [pc, #84]	; (80149a8 <OsTraceSetFrame+0x12c>)
 8014954:	6013      	str	r3, [r2, #0]
#endif
    TRACE_UNLOCK(intSave);
 8014956:	697b      	ldr	r3, [r7, #20]
 8014958:	4619      	mov	r1, r3
 801495a:	4812      	ldr	r0, [pc, #72]	; (80149a4 <OsTraceSetFrame+0x128>)
 801495c:	f7ff ff58 	bl	8014810 <LOS_SpinUnlockRestore>

    for (i = 0; i < paramCount; i++) {
 8014960:	2300      	movs	r3, #0
 8014962:	61bb      	str	r3, [r7, #24]
 8014964:	e00d      	b.n	8014982 <OsTraceSetFrame+0x106>
        frame->params[i] = params[i];
 8014966:	69bb      	ldr	r3, [r7, #24]
 8014968:	009b      	lsls	r3, r3, #2
 801496a:	683a      	ldr	r2, [r7, #0]
 801496c:	4413      	add	r3, r2
 801496e:	681a      	ldr	r2, [r3, #0]
 8014970:	68f9      	ldr	r1, [r7, #12]
 8014972:	69bb      	ldr	r3, [r7, #24]
 8014974:	3306      	adds	r3, #6
 8014976:	009b      	lsls	r3, r3, #2
 8014978:	440b      	add	r3, r1
 801497a:	605a      	str	r2, [r3, #4]
    for (i = 0; i < paramCount; i++) {
 801497c:	69bb      	ldr	r3, [r7, #24]
 801497e:	3301      	adds	r3, #1
 8014980:	61bb      	str	r3, [r7, #24]
 8014982:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8014984:	69ba      	ldr	r2, [r7, #24]
 8014986:	429a      	cmp	r2, r3
 8014988:	dbed      	blt.n	8014966 <OsTraceSetFrame+0xea>
    }
}
 801498a:	bf00      	nop
 801498c:	4b04      	ldr	r3, [pc, #16]	; (80149a0 <OsTraceSetFrame+0x124>)
 801498e:	681a      	ldr	r2, [r3, #0]
 8014990:	69fb      	ldr	r3, [r7, #28]
 8014992:	405a      	eors	r2, r3
 8014994:	d001      	beq.n	801499a <OsTraceSetFrame+0x11e>
 8014996:	f7ef fd27 	bl	80043e8 <__stack_chk_fail>
 801499a:	3720      	adds	r7, #32
 801499c:	46bd      	mov	sp, r7
 801499e:	bd80      	pop	{r7, pc}
 80149a0:	08022a04 	.word	0x08022a04
 80149a4:	20003360 	.word	0x20003360
 80149a8:	20003350 	.word	0x20003350

080149ac <OsTraceHook>:
        TRACE_ERROR("Task name copy failed!\n");
    }
}

VOID OsTraceHook(UINT32 eventType, UINTPTR identity, const UINTPTR *params, UINT16 paramCount)
{
 80149ac:	b590      	push	{r4, r7, lr}
 80149ae:	b09b      	sub	sp, #108	; 0x6c
 80149b0:	af02      	add	r7, sp, #8
 80149b2:	60f8      	str	r0, [r7, #12]
 80149b4:	60b9      	str	r1, [r7, #8]
 80149b6:	607a      	str	r2, [r7, #4]
 80149b8:	807b      	strh	r3, [r7, #2]
 80149ba:	4b3c      	ldr	r3, [pc, #240]	; (8014aac <OsTraceHook+0x100>)
 80149bc:	681b      	ldr	r3, [r3, #0]
 80149be:	65fb      	str	r3, [r7, #92]	; 0x5c
 80149c0:	f04f 0300 	mov.w	r3, #0
    if ((eventType == TASK_CREATE) || (eventType == TASK_PRIOSET)) {
 80149c4:	68fb      	ldr	r3, [r7, #12]
 80149c6:	2b40      	cmp	r3, #64	; 0x40
 80149c8:	d002      	beq.n	80149d0 <OsTraceHook+0x24>
 80149ca:	68fb      	ldr	r3, [r7, #12]
 80149cc:	2b41      	cmp	r3, #65	; 0x41
 80149ce:	d103      	bne.n	80149d8 <OsTraceHook+0x2c>
        OsTraceObjAdd(eventType, identity); /* handle important obj info, these can not be filtered */
 80149d0:	68b9      	ldr	r1, [r7, #8]
 80149d2:	68f8      	ldr	r0, [r7, #12]
 80149d4:	f000 fb1c 	bl	8015010 <OsTraceObjAdd>
    }

    if ((g_enableTrace == TRUE) && (eventType & g_traceMask)) {
 80149d8:	4b35      	ldr	r3, [pc, #212]	; (8014ab0 <OsTraceHook+0x104>)
 80149da:	681b      	ldr	r3, [r3, #0]
 80149dc:	2b01      	cmp	r3, #1
 80149de:	d15b      	bne.n	8014a98 <OsTraceHook+0xec>
 80149e0:	4b34      	ldr	r3, [pc, #208]	; (8014ab4 <OsTraceHook+0x108>)
 80149e2:	681a      	ldr	r2, [r3, #0]
 80149e4:	68fb      	ldr	r3, [r7, #12]
 80149e6:	4013      	ands	r3, r2
 80149e8:	2b00      	cmp	r3, #0
 80149ea:	d055      	beq.n	8014a98 <OsTraceHook+0xec>
        UINTPTR id = identity;
 80149ec:	68bb      	ldr	r3, [r7, #8]
 80149ee:	613b      	str	r3, [r7, #16]
        if (TRACE_GET_MODE_FLAG(eventType) == TRACE_HWI_FLAG) {
 80149f0:	68fb      	ldr	r3, [r7, #12]
 80149f2:	f023 030f 	bic.w	r3, r3, #15
 80149f6:	2b20      	cmp	r3, #32
 80149f8:	d106      	bne.n	8014a08 <OsTraceHook+0x5c>
            if (OsTraceHwiFilter(identity)) {
 80149fa:	68b8      	ldr	r0, [r7, #8]
 80149fc:	f7ff ff1c 	bl	8014838 <OsTraceHwiFilter>
 8014a00:	4603      	mov	r3, r0
 8014a02:	2b00      	cmp	r3, #0
 8014a04:	d03a      	beq.n	8014a7c <OsTraceHook+0xd0>
                return;
 8014a06:	e047      	b.n	8014a98 <OsTraceHook+0xec>
            }
        } else if (TRACE_GET_MODE_FLAG(eventType) == TRACE_TASK_FLAG) {
 8014a08:	68fb      	ldr	r3, [r7, #12]
 8014a0a:	f023 030f 	bic.w	r3, r3, #15
 8014a0e:	2b40      	cmp	r3, #64	; 0x40
 8014a10:	d104      	bne.n	8014a1c <OsTraceHook+0x70>
            id = OsTraceGetMaskTid(identity);
 8014a12:	68b8      	ldr	r0, [r7, #8]
 8014a14:	f000 fa58 	bl	8014ec8 <OsTraceGetMaskTid>
 8014a18:	6138      	str	r0, [r7, #16]
 8014a1a:	e02f      	b.n	8014a7c <OsTraceHook+0xd0>
        } else if (eventType == MEM_INFO_REQ) {
 8014a1c:	68fb      	ldr	r3, [r7, #12]
 8014a1e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8014a22:	d12b      	bne.n	8014a7c <OsTraceHook+0xd0>
            LOS_MEM_POOL_STATUS status;
            LOS_MemInfoGet((VOID *)identity, &status);
 8014a24:	68bb      	ldr	r3, [r7, #8]
 8014a26:	f107 0218 	add.w	r2, r7, #24
 8014a2a:	4611      	mov	r1, r2
 8014a2c:	4618      	mov	r0, r3
 8014a2e:	f7f4 f8d9 	bl	8008be4 <LOS_MemInfoGet>
            LOS_TRACE(MEM_INFO, identity, status.uwTotalUsedSize, status.uwTotalFreeSize);
 8014a32:	2300      	movs	r3, #0
 8014a34:	633b      	str	r3, [r7, #48]	; 0x30
 8014a36:	68bb      	ldr	r3, [r7, #8]
 8014a38:	637b      	str	r3, [r7, #52]	; 0x34
 8014a3a:	69bb      	ldr	r3, [r7, #24]
 8014a3c:	63bb      	str	r3, [r7, #56]	; 0x38
 8014a3e:	69fb      	ldr	r3, [r7, #28]
 8014a40:	63fb      	str	r3, [r7, #60]	; 0x3c
 8014a42:	2304      	movs	r3, #4
 8014a44:	617b      	str	r3, [r7, #20]
 8014a46:	697b      	ldr	r3, [r7, #20]
 8014a48:	2b01      	cmp	r3, #1
 8014a4a:	d925      	bls.n	8014a98 <OsTraceHook+0xec>
 8014a4c:	4b1a      	ldr	r3, [pc, #104]	; (8014ab8 <OsTraceHook+0x10c>)
 8014a4e:	681b      	ldr	r3, [r3, #0]
 8014a50:	2b00      	cmp	r3, #0
 8014a52:	d021      	beq.n	8014a98 <OsTraceHook+0xec>
 8014a54:	4b18      	ldr	r3, [pc, #96]	; (8014ab8 <OsTraceHook+0x10c>)
 8014a56:	681c      	ldr	r4, [r3, #0]
 8014a58:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8014a5a:	697b      	ldr	r3, [r7, #20]
 8014a5c:	2b02      	cmp	r3, #2
 8014a5e:	d904      	bls.n	8014a6a <OsTraceHook+0xbe>
 8014a60:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8014a64:	f103 0208 	add.w	r2, r3, #8
 8014a68:	e000      	b.n	8014a6c <OsTraceHook+0xc0>
 8014a6a:	2200      	movs	r2, #0
 8014a6c:	697b      	ldr	r3, [r7, #20]
 8014a6e:	b29b      	uxth	r3, r3
 8014a70:	3b02      	subs	r3, #2
 8014a72:	b29b      	uxth	r3, r3
 8014a74:	f240 1005 	movw	r0, #261	; 0x105
 8014a78:	47a0      	blx	r4
 8014a7a:	e00d      	b.n	8014a98 <OsTraceHook+0xec>
            return;
        }

        TraceEventFrame frame;
        OsTraceSetFrame(&frame, eventType, id, params, paramCount);
 8014a7c:	f107 0030 	add.w	r0, r7, #48	; 0x30
 8014a80:	887b      	ldrh	r3, [r7, #2]
 8014a82:	9300      	str	r3, [sp, #0]
 8014a84:	687b      	ldr	r3, [r7, #4]
 8014a86:	693a      	ldr	r2, [r7, #16]
 8014a88:	68f9      	ldr	r1, [r7, #12]
 8014a8a:	f7ff fef7 	bl	801487c <OsTraceSetFrame>

        OsTraceWriteOrSendEvent(&frame);
 8014a8e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8014a92:	4618      	mov	r0, r3
 8014a94:	f000 fae6 	bl	8015064 <OsTraceWriteOrSendEvent>
    }
}
 8014a98:	4b04      	ldr	r3, [pc, #16]	; (8014aac <OsTraceHook+0x100>)
 8014a9a:	681a      	ldr	r2, [r3, #0]
 8014a9c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8014a9e:	405a      	eors	r2, r3
 8014aa0:	d001      	beq.n	8014aa6 <OsTraceHook+0xfa>
 8014aa2:	f7ef fca1 	bl	80043e8 <__stack_chk_fail>
 8014aa6:	3764      	adds	r7, #100	; 0x64
 8014aa8:	46bd      	mov	sp, r7
 8014aaa:	bd90      	pop	{r4, r7, pc}
 8014aac:	08022a28 	.word	0x08022a28
 8014ab0:	20003358 	.word	0x20003358
 8014ab4:	200004a4 	.word	0x200004a4
 8014ab8:	2000075c 	.word	0x2000075c

08014abc <OsTraceHookInstall>:
{
    return g_enableTrace == TRUE;
}

STATIC VOID OsTraceHookInstall(VOID)
{
 8014abc:	b480      	push	{r7}
 8014abe:	af00      	add	r7, sp, #0
    g_traceEventHook = OsTraceHook;
 8014ac0:	4b05      	ldr	r3, [pc, #20]	; (8014ad8 <OsTraceHookInstall+0x1c>)
 8014ac2:	4a06      	ldr	r2, [pc, #24]	; (8014adc <OsTraceHookInstall+0x20>)
 8014ac4:	601a      	str	r2, [r3, #0]
#ifdef LOSCFG_RECORDER_MODE_OFFLINE
    g_traceDumpHook = OsTraceRecordDump;
 8014ac6:	4b06      	ldr	r3, [pc, #24]	; (8014ae0 <OsTraceHookInstall+0x24>)
 8014ac8:	4a06      	ldr	r2, [pc, #24]	; (8014ae4 <OsTraceHookInstall+0x28>)
 8014aca:	601a      	str	r2, [r3, #0]
#endif
}
 8014acc:	bf00      	nop
 8014ace:	46bd      	mov	sp, r7
 8014ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014ad4:	4770      	bx	lr
 8014ad6:	bf00      	nop
 8014ad8:	2000075c 	.word	0x2000075c
 8014adc:	080149ad 	.word	0x080149ad
 8014ae0:	20000760 	.word	0x20000760
 8014ae4:	080153d9 	.word	0x080153d9

08014ae8 <LOS_TraceInit>:
    return ret;
}
#endif

UINT32 LOS_TraceInit(VOID *buf, UINT32 size)
{
 8014ae8:	b580      	push	{r7, lr}
 8014aea:	b086      	sub	sp, #24
 8014aec:	af00      	add	r7, sp, #0
 8014aee:	6078      	str	r0, [r7, #4]
 8014af0:	6039      	str	r1, [r7, #0]
 8014af2:	4b27      	ldr	r3, [pc, #156]	; (8014b90 <LOS_TraceInit+0xa8>)
 8014af4:	681b      	ldr	r3, [r3, #0]
 8014af6:	617b      	str	r3, [r7, #20]
 8014af8:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 ret;

    TRACE_LOCK(intSave);
 8014afc:	f107 030c 	add.w	r3, r7, #12
 8014b00:	4619      	mov	r1, r3
 8014b02:	4824      	ldr	r0, [pc, #144]	; (8014b94 <LOS_TraceInit+0xac>)
 8014b04:	f7ff fe76 	bl	80147f4 <LOS_SpinLockSave>
    if (g_traceState != TRACE_UNINIT) {
 8014b08:	4b23      	ldr	r3, [pc, #140]	; (8014b98 <LOS_TraceInit+0xb0>)
 8014b0a:	681b      	ldr	r3, [r3, #0]
 8014b0c:	2b00      	cmp	r3, #0
 8014b0e:	d00b      	beq.n	8014b28 <LOS_TraceInit+0x40>
        TRACE_ERROR("trace has been initialized already, the current state is :%d\n", g_traceState);
 8014b10:	4822      	ldr	r0, [pc, #136]	; (8014b9c <LOS_TraceInit+0xb4>)
 8014b12:	f7ef fddb 	bl	80046cc <dprintf>
 8014b16:	4b20      	ldr	r3, [pc, #128]	; (8014b98 <LOS_TraceInit+0xb0>)
 8014b18:	681b      	ldr	r3, [r3, #0]
 8014b1a:	4619      	mov	r1, r3
 8014b1c:	4820      	ldr	r0, [pc, #128]	; (8014ba0 <LOS_TraceInit+0xb8>)
 8014b1e:	f7ef fdd5 	bl	80046cc <dprintf>
        ret = LOS_ERRNO_TRACE_ERROR_STATUS;
 8014b22:	4b20      	ldr	r3, [pc, #128]	; (8014ba4 <LOS_TraceInit+0xbc>)
 8014b24:	613b      	str	r3, [r7, #16]
        goto LOS_ERREND;
 8014b26:	e022      	b.n	8014b6e <LOS_TraceInit+0x86>
    }

#ifdef LOSCFG_TRACE_CLIENT_INTERACT
    ret = OsTracePipelineInit();
 8014b28:	f000 fd56 	bl	80155d8 <OsTracePipelineInit>
 8014b2c:	6138      	str	r0, [r7, #16]
    if (ret != LOS_OK) {
 8014b2e:	693b      	ldr	r3, [r7, #16]
 8014b30:	2b00      	cmp	r3, #0
 8014b32:	d119      	bne.n	8014b68 <LOS_TraceInit+0x80>
        TRACE_ERROR("trace init create agentTask error :0x%x\n", ret);
        goto LOS_ERREND;
    }
#endif

    ret = OsTraceBufInit(buf, size);
 8014b34:	6839      	ldr	r1, [r7, #0]
 8014b36:	6878      	ldr	r0, [r7, #4]
 8014b38:	f000 f9de 	bl	8014ef8 <OsTraceBufInit>
 8014b3c:	6138      	str	r0, [r7, #16]
    if (ret != LOS_OK) {
 8014b3e:	693b      	ldr	r3, [r7, #16]
 8014b40:	2b00      	cmp	r3, #0
 8014b42:	d113      	bne.n	8014b6c <LOS_TraceInit+0x84>
        goto LOS_RELEASE;
    }

    OsTraceHookInstall();
 8014b44:	f7ff ffba 	bl	8014abc <OsTraceHookInstall>

    g_traceEventCount = 0;
 8014b48:	4b17      	ldr	r3, [pc, #92]	; (8014ba8 <LOS_TraceInit+0xc0>)
 8014b4a:	2200      	movs	r2, #0
 8014b4c:	601a      	str	r2, [r3, #0]

#ifdef LOSCFG_RECORDER_MODE_ONLINE  /* Wait trace client to start trace */
    g_enableTrace = FALSE;
    g_traceState = TRACE_INITED;
#else
    g_enableTrace = TRUE;
 8014b4e:	4b17      	ldr	r3, [pc, #92]	; (8014bac <LOS_TraceInit+0xc4>)
 8014b50:	2201      	movs	r2, #1
 8014b52:	601a      	str	r2, [r3, #0]
    g_traceState = TRACE_STARTED;
 8014b54:	4b10      	ldr	r3, [pc, #64]	; (8014b98 <LOS_TraceInit+0xb0>)
 8014b56:	2202      	movs	r2, #2
 8014b58:	601a      	str	r2, [r3, #0]
#endif
    TRACE_UNLOCK(intSave);
 8014b5a:	68fb      	ldr	r3, [r7, #12]
 8014b5c:	4619      	mov	r1, r3
 8014b5e:	480d      	ldr	r0, [pc, #52]	; (8014b94 <LOS_TraceInit+0xac>)
 8014b60:	f7ff fe56 	bl	8014810 <LOS_SpinUnlockRestore>
    return LOS_OK;
 8014b64:	2300      	movs	r3, #0
 8014b66:	e008      	b.n	8014b7a <LOS_TraceInit+0x92>
        goto LOS_ERREND;
 8014b68:	bf00      	nop
 8014b6a:	e000      	b.n	8014b6e <LOS_TraceInit+0x86>
        goto LOS_RELEASE;
 8014b6c:	bf00      	nop
LOS_RELEASE:
#ifdef LOSCFG_TRACE_CONTROL_AGENT
    LOS_TaskDelete(g_traceTaskId);
#endif
LOS_ERREND:
    TRACE_UNLOCK(intSave);
 8014b6e:	68fb      	ldr	r3, [r7, #12]
 8014b70:	4619      	mov	r1, r3
 8014b72:	4808      	ldr	r0, [pc, #32]	; (8014b94 <LOS_TraceInit+0xac>)
 8014b74:	f7ff fe4c 	bl	8014810 <LOS_SpinUnlockRestore>
    return ret;
 8014b78:	693b      	ldr	r3, [r7, #16]
}
 8014b7a:	4a05      	ldr	r2, [pc, #20]	; (8014b90 <LOS_TraceInit+0xa8>)
 8014b7c:	6811      	ldr	r1, [r2, #0]
 8014b7e:	697a      	ldr	r2, [r7, #20]
 8014b80:	4051      	eors	r1, r2
 8014b82:	d001      	beq.n	8014b88 <LOS_TraceInit+0xa0>
 8014b84:	f7ef fc30 	bl	80043e8 <__stack_chk_fail>
 8014b88:	4618      	mov	r0, r3
 8014b8a:	3718      	adds	r7, #24
 8014b8c:	46bd      	mov	sp, r7
 8014b8e:	bd80      	pop	{r7, pc}
 8014b90:	08022a6c 	.word	0x08022a6c
 8014b94:	20003360 	.word	0x20003360
 8014b98:	20003354 	.word	0x20003354
 8014b9c:	08022a08 	.word	0x08022a08
 8014ba0:	08022a2c 	.word	0x08022a2c
 8014ba4:	02001400 	.word	0x02001400
 8014ba8:	20003350 	.word	0x20003350
 8014bac:	20003358 	.word	0x20003358

08014bb0 <LOS_TraceStart>:

UINT32 LOS_TraceStart(VOID)
{
 8014bb0:	b590      	push	{r4, r7, lr}
 8014bb2:	b087      	sub	sp, #28
 8014bb4:	af00      	add	r7, sp, #0
 8014bb6:	4b2e      	ldr	r3, [pc, #184]	; (8014c70 <LOS_TraceStart+0xc0>)
 8014bb8:	681b      	ldr	r3, [r3, #0]
 8014bba:	617b      	str	r3, [r7, #20]
 8014bbc:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 ret = LOS_OK;
 8014bc0:	2300      	movs	r3, #0
 8014bc2:	607b      	str	r3, [r7, #4]

    TRACE_LOCK(intSave);
 8014bc4:	463b      	mov	r3, r7
 8014bc6:	4619      	mov	r1, r3
 8014bc8:	482a      	ldr	r0, [pc, #168]	; (8014c74 <LOS_TraceStart+0xc4>)
 8014bca:	f7ff fe13 	bl	80147f4 <LOS_SpinLockSave>
    if (g_traceState == TRACE_STARTED) {
 8014bce:	4b2a      	ldr	r3, [pc, #168]	; (8014c78 <LOS_TraceStart+0xc8>)
 8014bd0:	681b      	ldr	r3, [r3, #0]
 8014bd2:	2b02      	cmp	r3, #2
 8014bd4:	d03a      	beq.n	8014c4c <LOS_TraceStart+0x9c>
        goto START_END;
    }

    if (g_traceState == TRACE_UNINIT) {
 8014bd6:	4b28      	ldr	r3, [pc, #160]	; (8014c78 <LOS_TraceStart+0xc8>)
 8014bd8:	681b      	ldr	r3, [r3, #0]
 8014bda:	2b00      	cmp	r3, #0
 8014bdc:	d108      	bne.n	8014bf0 <LOS_TraceStart+0x40>
        TRACE_ERROR("trace not inited, be sure LOS_TraceInit excute success\n");
 8014bde:	4827      	ldr	r0, [pc, #156]	; (8014c7c <LOS_TraceStart+0xcc>)
 8014be0:	f7ef fd74 	bl	80046cc <dprintf>
 8014be4:	4826      	ldr	r0, [pc, #152]	; (8014c80 <LOS_TraceStart+0xd0>)
 8014be6:	f7ef fd71 	bl	80046cc <dprintf>
        ret = LOS_ERRNO_TRACE_ERROR_STATUS;
 8014bea:	4b26      	ldr	r3, [pc, #152]	; (8014c84 <LOS_TraceStart+0xd4>)
 8014bec:	607b      	str	r3, [r7, #4]
        goto START_END;
 8014bee:	e02e      	b.n	8014c4e <LOS_TraceStart+0x9e>
    }

    OsTraceNotifyStart();

    g_enableTrace = TRUE;
 8014bf0:	4b25      	ldr	r3, [pc, #148]	; (8014c88 <LOS_TraceStart+0xd8>)
 8014bf2:	2201      	movs	r2, #1
 8014bf4:	601a      	str	r2, [r3, #0]
    g_traceState = TRACE_STARTED;
 8014bf6:	4b20      	ldr	r3, [pc, #128]	; (8014c78 <LOS_TraceStart+0xc8>)
 8014bf8:	2202      	movs	r2, #2
 8014bfa:	601a      	str	r2, [r3, #0]

    TRACE_UNLOCK(intSave);
 8014bfc:	683b      	ldr	r3, [r7, #0]
 8014bfe:	4619      	mov	r1, r3
 8014c00:	481c      	ldr	r0, [pc, #112]	; (8014c74 <LOS_TraceStart+0xc4>)
 8014c02:	f7ff fe05 	bl	8014810 <LOS_SpinUnlockRestore>
    LOS_TRACE(MEM_INFO_REQ, m_aucSysMem0);
 8014c06:	2300      	movs	r3, #0
 8014c08:	60fb      	str	r3, [r7, #12]
 8014c0a:	4b20      	ldr	r3, [pc, #128]	; (8014c8c <LOS_TraceStart+0xdc>)
 8014c0c:	681b      	ldr	r3, [r3, #0]
 8014c0e:	613b      	str	r3, [r7, #16]
 8014c10:	2302      	movs	r3, #2
 8014c12:	60bb      	str	r3, [r7, #8]
 8014c14:	68bb      	ldr	r3, [r7, #8]
 8014c16:	2b01      	cmp	r3, #1
 8014c18:	d916      	bls.n	8014c48 <LOS_TraceStart+0x98>
 8014c1a:	4b1d      	ldr	r3, [pc, #116]	; (8014c90 <LOS_TraceStart+0xe0>)
 8014c1c:	681b      	ldr	r3, [r3, #0]
 8014c1e:	2b00      	cmp	r3, #0
 8014c20:	d012      	beq.n	8014c48 <LOS_TraceStart+0x98>
 8014c22:	4b1b      	ldr	r3, [pc, #108]	; (8014c90 <LOS_TraceStart+0xe0>)
 8014c24:	681c      	ldr	r4, [r3, #0]
 8014c26:	6939      	ldr	r1, [r7, #16]
 8014c28:	68bb      	ldr	r3, [r7, #8]
 8014c2a:	2b02      	cmp	r3, #2
 8014c2c:	d904      	bls.n	8014c38 <LOS_TraceStart+0x88>
 8014c2e:	f107 030c 	add.w	r3, r7, #12
 8014c32:	f103 0208 	add.w	r2, r3, #8
 8014c36:	e000      	b.n	8014c3a <LOS_TraceStart+0x8a>
 8014c38:	2200      	movs	r2, #0
 8014c3a:	68bb      	ldr	r3, [r7, #8]
 8014c3c:	b29b      	uxth	r3, r3
 8014c3e:	3b02      	subs	r3, #2
 8014c40:	b29b      	uxth	r3, r3
 8014c42:	f44f 7082 	mov.w	r0, #260	; 0x104
 8014c46:	47a0      	blx	r4
    return ret;
 8014c48:	687b      	ldr	r3, [r7, #4]
 8014c4a:	e006      	b.n	8014c5a <LOS_TraceStart+0xaa>
        goto START_END;
 8014c4c:	bf00      	nop
START_END:
    TRACE_UNLOCK(intSave);
 8014c4e:	683b      	ldr	r3, [r7, #0]
 8014c50:	4619      	mov	r1, r3
 8014c52:	4808      	ldr	r0, [pc, #32]	; (8014c74 <LOS_TraceStart+0xc4>)
 8014c54:	f7ff fddc 	bl	8014810 <LOS_SpinUnlockRestore>
    return ret;
 8014c58:	687b      	ldr	r3, [r7, #4]
}
 8014c5a:	4a05      	ldr	r2, [pc, #20]	; (8014c70 <LOS_TraceStart+0xc0>)
 8014c5c:	6811      	ldr	r1, [r2, #0]
 8014c5e:	697a      	ldr	r2, [r7, #20]
 8014c60:	4051      	eors	r1, r2
 8014c62:	d001      	beq.n	8014c68 <LOS_TraceStart+0xb8>
 8014c64:	f7ef fbc0 	bl	80043e8 <__stack_chk_fail>
 8014c68:	4618      	mov	r0, r3
 8014c6a:	371c      	adds	r7, #28
 8014c6c:	46bd      	mov	sp, r7
 8014c6e:	bd90      	pop	{r4, r7, pc}
 8014c70:	08022aa8 	.word	0x08022aa8
 8014c74:	20003360 	.word	0x20003360
 8014c78:	20003354 	.word	0x20003354
 8014c7c:	08022a08 	.word	0x08022a08
 8014c80:	08022a70 	.word	0x08022a70
 8014c84:	02001400 	.word	0x02001400
 8014c88:	20003358 	.word	0x20003358
 8014c8c:	200021b4 	.word	0x200021b4
 8014c90:	2000075c 	.word	0x2000075c

08014c94 <LOS_TraceStop>:

VOID LOS_TraceStop(VOID)
{
 8014c94:	b580      	push	{r7, lr}
 8014c96:	b082      	sub	sp, #8
 8014c98:	af00      	add	r7, sp, #0
 8014c9a:	4b13      	ldr	r3, [pc, #76]	; (8014ce8 <LOS_TraceStop+0x54>)
 8014c9c:	681b      	ldr	r3, [r3, #0]
 8014c9e:	607b      	str	r3, [r7, #4]
 8014ca0:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    TRACE_LOCK(intSave);
 8014ca4:	463b      	mov	r3, r7
 8014ca6:	4619      	mov	r1, r3
 8014ca8:	4810      	ldr	r0, [pc, #64]	; (8014cec <LOS_TraceStop+0x58>)
 8014caa:	f7ff fda3 	bl	80147f4 <LOS_SpinLockSave>
    if (g_traceState != TRACE_STARTED) {
 8014cae:	4b10      	ldr	r3, [pc, #64]	; (8014cf0 <LOS_TraceStop+0x5c>)
 8014cb0:	681b      	ldr	r3, [r3, #0]
 8014cb2:	2b02      	cmp	r3, #2
 8014cb4:	d106      	bne.n	8014cc4 <LOS_TraceStop+0x30>
        goto STOP_END;
    }

    g_enableTrace = FALSE;
 8014cb6:	4b0f      	ldr	r3, [pc, #60]	; (8014cf4 <LOS_TraceStop+0x60>)
 8014cb8:	2200      	movs	r2, #0
 8014cba:	601a      	str	r2, [r3, #0]
    g_traceState = TRACE_STOPED;
 8014cbc:	4b0c      	ldr	r3, [pc, #48]	; (8014cf0 <LOS_TraceStop+0x5c>)
 8014cbe:	2203      	movs	r2, #3
 8014cc0:	601a      	str	r2, [r3, #0]
 8014cc2:	e000      	b.n	8014cc6 <LOS_TraceStop+0x32>
        goto STOP_END;
 8014cc4:	bf00      	nop
    OsTraceNotifyStop();
STOP_END:
    TRACE_UNLOCK(intSave);
 8014cc6:	683b      	ldr	r3, [r7, #0]
 8014cc8:	4619      	mov	r1, r3
 8014cca:	4808      	ldr	r0, [pc, #32]	; (8014cec <LOS_TraceStop+0x58>)
 8014ccc:	f7ff fda0 	bl	8014810 <LOS_SpinUnlockRestore>
}
 8014cd0:	bf00      	nop
 8014cd2:	4b05      	ldr	r3, [pc, #20]	; (8014ce8 <LOS_TraceStop+0x54>)
 8014cd4:	681a      	ldr	r2, [r3, #0]
 8014cd6:	687b      	ldr	r3, [r7, #4]
 8014cd8:	405a      	eors	r2, r3
 8014cda:	d001      	beq.n	8014ce0 <LOS_TraceStop+0x4c>
 8014cdc:	f7ef fb84 	bl	80043e8 <__stack_chk_fail>
 8014ce0:	3708      	adds	r7, #8
 8014ce2:	46bd      	mov	sp, r7
 8014ce4:	bd80      	pop	{r7, pc}
 8014ce6:	bf00      	nop
 8014ce8:	08022aac 	.word	0x08022aac
 8014cec:	20003360 	.word	0x20003360
 8014cf0:	20003354 	.word	0x20003354
 8014cf4:	20003358 	.word	0x20003358

08014cf8 <LOS_TraceEventMaskSet>:

VOID LOS_TraceEventMaskSet(UINT32 mask)
{
 8014cf8:	b480      	push	{r7}
 8014cfa:	b083      	sub	sp, #12
 8014cfc:	af00      	add	r7, sp, #0
 8014cfe:	6078      	str	r0, [r7, #4]
    g_traceMask = mask & EVENT_MASK;
 8014d00:	687b      	ldr	r3, [r7, #4]
 8014d02:	f023 030f 	bic.w	r3, r3, #15
 8014d06:	4a04      	ldr	r2, [pc, #16]	; (8014d18 <LOS_TraceEventMaskSet+0x20>)
 8014d08:	6013      	str	r3, [r2, #0]
}
 8014d0a:	bf00      	nop
 8014d0c:	370c      	adds	r7, #12
 8014d0e:	46bd      	mov	sp, r7
 8014d10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d14:	4770      	bx	lr
 8014d16:	bf00      	nop
 8014d18:	200004a4 	.word	0x200004a4

08014d1c <LOS_TraceRecordDump>:

VOID LOS_TraceRecordDump(BOOL toClient)
{
 8014d1c:	b580      	push	{r7, lr}
 8014d1e:	b082      	sub	sp, #8
 8014d20:	af00      	add	r7, sp, #0
 8014d22:	6078      	str	r0, [r7, #4]
    if (g_traceState != TRACE_STOPED) {
 8014d24:	4b09      	ldr	r3, [pc, #36]	; (8014d4c <LOS_TraceRecordDump+0x30>)
 8014d26:	681b      	ldr	r3, [r3, #0]
 8014d28:	2b03      	cmp	r3, #3
 8014d2a:	d009      	beq.n	8014d40 <LOS_TraceRecordDump+0x24>
        TRACE_ERROR("trace dump must after trace stopped , the current state is : %d\n", g_traceState);
 8014d2c:	4808      	ldr	r0, [pc, #32]	; (8014d50 <LOS_TraceRecordDump+0x34>)
 8014d2e:	f7ef fccd 	bl	80046cc <dprintf>
 8014d32:	4b06      	ldr	r3, [pc, #24]	; (8014d4c <LOS_TraceRecordDump+0x30>)
 8014d34:	681b      	ldr	r3, [r3, #0]
 8014d36:	4619      	mov	r1, r3
 8014d38:	4806      	ldr	r0, [pc, #24]	; (8014d54 <LOS_TraceRecordDump+0x38>)
 8014d3a:	f7ef fcc7 	bl	80046cc <dprintf>
        return;
 8014d3e:	e002      	b.n	8014d46 <LOS_TraceRecordDump+0x2a>
    }
    OsTraceRecordDump(toClient);
 8014d40:	6878      	ldr	r0, [r7, #4]
 8014d42:	f000 fb49 	bl	80153d8 <OsTraceRecordDump>
}
 8014d46:	3708      	adds	r7, #8
 8014d48:	46bd      	mov	sp, r7
 8014d4a:	bd80      	pop	{r7, pc}
 8014d4c:	20003354 	.word	0x20003354
 8014d50:	08022a08 	.word	0x08022a08
 8014d54:	08022ab0 	.word	0x08022ab0

08014d58 <LOS_TraceReset>:
{
    return OsTraceRecordGet();
}

VOID LOS_TraceReset(VOID)
{
 8014d58:	b580      	push	{r7, lr}
 8014d5a:	af00      	add	r7, sp, #0
    if (g_traceState == TRACE_UNINIT) {
 8014d5c:	4b06      	ldr	r3, [pc, #24]	; (8014d78 <LOS_TraceReset+0x20>)
 8014d5e:	681b      	ldr	r3, [r3, #0]
 8014d60:	2b00      	cmp	r3, #0
 8014d62:	d106      	bne.n	8014d72 <LOS_TraceReset+0x1a>
        TRACE_ERROR("trace not inited, be sure LOS_TraceInit excute success\n");
 8014d64:	4805      	ldr	r0, [pc, #20]	; (8014d7c <LOS_TraceReset+0x24>)
 8014d66:	f7ef fcb1 	bl	80046cc <dprintf>
 8014d6a:	4805      	ldr	r0, [pc, #20]	; (8014d80 <LOS_TraceReset+0x28>)
 8014d6c:	f7ef fcae 	bl	80046cc <dprintf>
        return;
 8014d70:	e001      	b.n	8014d76 <LOS_TraceReset+0x1e>
    }

    OsTraceReset();
 8014d72:	f000 f9bb 	bl	80150ec <OsTraceReset>
}
 8014d76:	bd80      	pop	{r7, pc}
 8014d78:	20003354 	.word	0x20003354
 8014d7c:	08022a08 	.word	0x08022a08
 8014d80:	08022a70 	.word	0x08022a70

08014d84 <OsShellCmdTraceSetMask>:
    TRACE_UNLOCK(intSave);
}

#ifdef LOSCFG_SHELL
LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdTraceSetMask(INT32 argc, const CHAR **argv)
{
 8014d84:	b580      	push	{r7, lr}
 8014d86:	b086      	sub	sp, #24
 8014d88:	af00      	add	r7, sp, #0
 8014d8a:	6078      	str	r0, [r7, #4]
 8014d8c:	6039      	str	r1, [r7, #0]
 8014d8e:	4b17      	ldr	r3, [pc, #92]	; (8014dec <OsShellCmdTraceSetMask+0x68>)
 8014d90:	681b      	ldr	r3, [r3, #0]
 8014d92:	617b      	str	r3, [r7, #20]
 8014d94:	f04f 0300 	mov.w	r3, #0
    size_t mask;
    CHAR *endPtr = NULL;
 8014d98:	2300      	movs	r3, #0
 8014d9a:	60fb      	str	r3, [r7, #12]

    if (argc >= 2) { /* 2:Just as number of parameters */
 8014d9c:	687b      	ldr	r3, [r7, #4]
 8014d9e:	2b01      	cmp	r3, #1
 8014da0:	dd05      	ble.n	8014dae <OsShellCmdTraceSetMask+0x2a>
        PRINTK("\nUsage: trace_mask or trace_mask ID\n");
 8014da2:	4813      	ldr	r0, [pc, #76]	; (8014df0 <OsShellCmdTraceSetMask+0x6c>)
 8014da4:	f7ef fc92 	bl	80046cc <dprintf>
        return OS_ERROR;
 8014da8:	f04f 33ff 	mov.w	r3, #4294967295
 8014dac:	e012      	b.n	8014dd4 <OsShellCmdTraceSetMask+0x50>
    }

    if (argc == 0) {
 8014dae:	687b      	ldr	r3, [r7, #4]
 8014db0:	2b00      	cmp	r3, #0
 8014db2:	d102      	bne.n	8014dba <OsShellCmdTraceSetMask+0x36>
        mask = TRACE_DEFAULT_MASK;
 8014db4:	2360      	movs	r3, #96	; 0x60
 8014db6:	613b      	str	r3, [r7, #16]
 8014db8:	e008      	b.n	8014dcc <OsShellCmdTraceSetMask+0x48>
    } else {
        mask = strtoul(argv[0], &endPtr, 0);
 8014dba:	683b      	ldr	r3, [r7, #0]
 8014dbc:	681b      	ldr	r3, [r3, #0]
 8014dbe:	f107 010c 	add.w	r1, r7, #12
 8014dc2:	2200      	movs	r2, #0
 8014dc4:	4618      	mov	r0, r3
 8014dc6:	f7f9 fee3 	bl	800eb90 <strtoul>
 8014dca:	6138      	str	r0, [r7, #16]
    }
    LOS_TraceEventMaskSet((UINT32)mask);
 8014dcc:	6938      	ldr	r0, [r7, #16]
 8014dce:	f7ff ff93 	bl	8014cf8 <LOS_TraceEventMaskSet>
    return LOS_OK;
 8014dd2:	2300      	movs	r3, #0
}
 8014dd4:	4a05      	ldr	r2, [pc, #20]	; (8014dec <OsShellCmdTraceSetMask+0x68>)
 8014dd6:	6811      	ldr	r1, [r2, #0]
 8014dd8:	697a      	ldr	r2, [r7, #20]
 8014dda:	4051      	eors	r1, r2
 8014ddc:	d001      	beq.n	8014de2 <OsShellCmdTraceSetMask+0x5e>
 8014dde:	f7ef fb03 	bl	80043e8 <__stack_chk_fail>
 8014de2:	4618      	mov	r0, r3
 8014de4:	3718      	adds	r7, #24
 8014de6:	46bd      	mov	sp, r7
 8014de8:	bd80      	pop	{r7, pc}
 8014dea:	bf00      	nop
 8014dec:	08022b20 	.word	0x08022b20
 8014df0:	08022af8 	.word	0x08022af8

08014df4 <OsShellCmdTraceDump>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdTraceDump(INT32 argc, const CHAR **argv)
{
 8014df4:	b580      	push	{r7, lr}
 8014df6:	b086      	sub	sp, #24
 8014df8:	af00      	add	r7, sp, #0
 8014dfa:	6078      	str	r0, [r7, #4]
 8014dfc:	6039      	str	r1, [r7, #0]
 8014dfe:	4b1a      	ldr	r3, [pc, #104]	; (8014e68 <OsShellCmdTraceDump+0x74>)
 8014e00:	681b      	ldr	r3, [r3, #0]
 8014e02:	617b      	str	r3, [r7, #20]
 8014e04:	f04f 0300 	mov.w	r3, #0
    BOOL toClient;
    CHAR *endPtr = NULL;
 8014e08:	2300      	movs	r3, #0
 8014e0a:	60fb      	str	r3, [r7, #12]

    if (argc >= 2) { /* 2:Just as number of parameters */
 8014e0c:	687b      	ldr	r3, [r7, #4]
 8014e0e:	2b01      	cmp	r3, #1
 8014e10:	dd05      	ble.n	8014e1e <OsShellCmdTraceDump+0x2a>
        PRINTK("\nUsage: trace_dump or trace_dump [1/0]\n");
 8014e12:	4816      	ldr	r0, [pc, #88]	; (8014e6c <OsShellCmdTraceDump+0x78>)
 8014e14:	f7ef fc5a 	bl	80046cc <dprintf>
        return OS_ERROR;
 8014e18:	f04f 33ff 	mov.w	r3, #4294967295
 8014e1c:	e018      	b.n	8014e50 <OsShellCmdTraceDump+0x5c>
    }

    if (argc == 0) {
 8014e1e:	687b      	ldr	r3, [r7, #4]
 8014e20:	2b00      	cmp	r3, #0
 8014e22:	d102      	bne.n	8014e2a <OsShellCmdTraceDump+0x36>
        toClient = FALSE;
 8014e24:	2300      	movs	r3, #0
 8014e26:	613b      	str	r3, [r7, #16]
 8014e28:	e00e      	b.n	8014e48 <OsShellCmdTraceDump+0x54>
    } else {
        toClient = strtoul(argv[0], &endPtr, 0) != 0 ? TRUE : FALSE;
 8014e2a:	683b      	ldr	r3, [r7, #0]
 8014e2c:	681b      	ldr	r3, [r3, #0]
 8014e2e:	f107 010c 	add.w	r1, r7, #12
 8014e32:	2200      	movs	r2, #0
 8014e34:	4618      	mov	r0, r3
 8014e36:	f7f9 feab 	bl	800eb90 <strtoul>
 8014e3a:	4603      	mov	r3, r0
 8014e3c:	2b00      	cmp	r3, #0
 8014e3e:	d001      	beq.n	8014e44 <OsShellCmdTraceDump+0x50>
 8014e40:	2301      	movs	r3, #1
 8014e42:	e000      	b.n	8014e46 <OsShellCmdTraceDump+0x52>
 8014e44:	2300      	movs	r3, #0
 8014e46:	613b      	str	r3, [r7, #16]
    }
    LOS_TraceRecordDump(toClient);
 8014e48:	6938      	ldr	r0, [r7, #16]
 8014e4a:	f7ff ff67 	bl	8014d1c <LOS_TraceRecordDump>
    return LOS_OK;
 8014e4e:	2300      	movs	r3, #0
}
 8014e50:	4a05      	ldr	r2, [pc, #20]	; (8014e68 <OsShellCmdTraceDump+0x74>)
 8014e52:	6811      	ldr	r1, [r2, #0]
 8014e54:	697a      	ldr	r2, [r7, #20]
 8014e56:	4051      	eors	r1, r2
 8014e58:	d001      	beq.n	8014e5e <OsShellCmdTraceDump+0x6a>
 8014e5a:	f7ef fac5 	bl	80043e8 <__stack_chk_fail>
 8014e5e:	4618      	mov	r0, r3
 8014e60:	3718      	adds	r7, #24
 8014e62:	46bd      	mov	sp, r7
 8014e64:	bd80      	pop	{r7, pc}
 8014e66:	bf00      	nop
 8014e68:	08022b4c 	.word	0x08022b4c
 8014e6c:	08022b24 	.word	0x08022b24

08014e70 <LOS_IntLock>:
{
 8014e70:	b580      	push	{r7, lr}
 8014e72:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8014e74:	f7eb ff28 	bl	8000cc8 <ArchIntLock>
 8014e78:	4603      	mov	r3, r0
}
 8014e7a:	4618      	mov	r0, r3
 8014e7c:	bd80      	pop	{r7, pc}

08014e7e <LOS_IntRestore>:
{
 8014e7e:	b580      	push	{r7, lr}
 8014e80:	b082      	sub	sp, #8
 8014e82:	af00      	add	r7, sp, #0
 8014e84:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8014e86:	6878      	ldr	r0, [r7, #4]
 8014e88:	f7eb ff26 	bl	8000cd8 <ArchIntRestore>
}
 8014e8c:	bf00      	nop
 8014e8e:	3708      	adds	r7, #8
 8014e90:	46bd      	mov	sp, r7
 8014e92:	bd80      	pop	{r7, pc}

08014e94 <LOS_SpinLockSave>:
{
 8014e94:	b580      	push	{r7, lr}
 8014e96:	b082      	sub	sp, #8
 8014e98:	af00      	add	r7, sp, #0
 8014e9a:	6078      	str	r0, [r7, #4]
 8014e9c:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8014e9e:	f7ff ffe7 	bl	8014e70 <LOS_IntLock>
 8014ea2:	4602      	mov	r2, r0
 8014ea4:	683b      	ldr	r3, [r7, #0]
 8014ea6:	601a      	str	r2, [r3, #0]
}
 8014ea8:	bf00      	nop
 8014eaa:	3708      	adds	r7, #8
 8014eac:	46bd      	mov	sp, r7
 8014eae:	bd80      	pop	{r7, pc}

08014eb0 <LOS_SpinUnlockRestore>:
{
 8014eb0:	b580      	push	{r7, lr}
 8014eb2:	b082      	sub	sp, #8
 8014eb4:	af00      	add	r7, sp, #0
 8014eb6:	6078      	str	r0, [r7, #4]
 8014eb8:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8014eba:	6838      	ldr	r0, [r7, #0]
 8014ebc:	f7ff ffdf 	bl	8014e7e <LOS_IntRestore>
}
 8014ec0:	bf00      	nop
 8014ec2:	3708      	adds	r7, #8
 8014ec4:	46bd      	mov	sp, r7
 8014ec6:	bd80      	pop	{r7, pc}

08014ec8 <OsTraceGetMaskTid>:

LITE_OS_SEC_BSS STATIC TraceOfflineHeaderInfo g_traceRecoder;
LITE_OS_SEC_BSS STATIC UINT32 g_tidMask[LOSCFG_BASE_CORE_TSK_LIMIT] = {0};

UINT32 OsTraceGetMaskTid(UINT32 tid)
{
 8014ec8:	b480      	push	{r7}
 8014eca:	b083      	sub	sp, #12
 8014ecc:	af00      	add	r7, sp, #0
 8014ece:	6078      	str	r0, [r7, #4]
    return tid | ((tid < LOSCFG_BASE_CORE_TSK_LIMIT) ? g_tidMask[tid] << BITS_NUM_FOR_TASK_ID : 0); /* tid < 65535 */
 8014ed0:	687b      	ldr	r3, [r7, #4]
 8014ed2:	2b0f      	cmp	r3, #15
 8014ed4:	d805      	bhi.n	8014ee2 <OsTraceGetMaskTid+0x1a>
 8014ed6:	4a07      	ldr	r2, [pc, #28]	; (8014ef4 <OsTraceGetMaskTid+0x2c>)
 8014ed8:	687b      	ldr	r3, [r7, #4]
 8014eda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014ede:	041b      	lsls	r3, r3, #16
 8014ee0:	e000      	b.n	8014ee4 <OsTraceGetMaskTid+0x1c>
 8014ee2:	2300      	movs	r3, #0
 8014ee4:	687a      	ldr	r2, [r7, #4]
 8014ee6:	4313      	orrs	r3, r2
}
 8014ee8:	4618      	mov	r0, r3
 8014eea:	370c      	adds	r7, #12
 8014eec:	46bd      	mov	sp, r7
 8014eee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014ef2:	4770      	bx	lr
 8014ef4:	20003378 	.word	0x20003378

08014ef8 <OsTraceBufInit>:

UINT32 OsTraceBufInit(VOID *buf, UINT32 size)
{
 8014ef8:	b580      	push	{r7, lr}
 8014efa:	b084      	sub	sp, #16
 8014efc:	af00      	add	r7, sp, #0
 8014efe:	6078      	str	r0, [r7, #4]
 8014f00:	6039      	str	r1, [r7, #0]
    UINT32 headSize;

    headSize = sizeof(OfflineHead) + sizeof(ObjData) * LOSCFG_TRACE_OBJ_MAX_NUM;
 8014f02:	2318      	movs	r3, #24
 8014f04:	60fb      	str	r3, [r7, #12]
    if (size <= headSize) {
 8014f06:	683a      	ldr	r2, [r7, #0]
 8014f08:	68fb      	ldr	r3, [r7, #12]
 8014f0a:	429a      	cmp	r2, r3
 8014f0c:	d808      	bhi.n	8014f20 <OsTraceBufInit+0x28>
        TRACE_ERROR("trace buf size not enough than 0x%x\n", headSize);
 8014f0e:	4837      	ldr	r0, [pc, #220]	; (8014fec <OsTraceBufInit+0xf4>)
 8014f10:	f7ef fbdc 	bl	80046cc <dprintf>
 8014f14:	68f9      	ldr	r1, [r7, #12]
 8014f16:	4836      	ldr	r0, [pc, #216]	; (8014ff0 <OsTraceBufInit+0xf8>)
 8014f18:	f7ef fbd8 	bl	80046cc <dprintf>
        return LOS_ERRNO_TRACE_BUF_TOO_SMALL;
 8014f1c:	4b35      	ldr	r3, [pc, #212]	; (8014ff4 <OsTraceBufInit+0xfc>)
 8014f1e:	e060      	b.n	8014fe2 <OsTraceBufInit+0xea>
    }

    if (buf == NULL) {
 8014f20:	687b      	ldr	r3, [r7, #4]
 8014f22:	2b00      	cmp	r3, #0
 8014f24:	d10b      	bne.n	8014f3e <OsTraceBufInit+0x46>
        buf = LOS_MemAlloc(m_aucSysMem1, size);
 8014f26:	4b34      	ldr	r3, [pc, #208]	; (8014ff8 <OsTraceBufInit+0x100>)
 8014f28:	681b      	ldr	r3, [r3, #0]
 8014f2a:	6839      	ldr	r1, [r7, #0]
 8014f2c:	4618      	mov	r0, r3
 8014f2e:	f7f3 fd3b 	bl	80089a8 <LOS_MemAlloc>
 8014f32:	6078      	str	r0, [r7, #4]
        if (buf == NULL) {
 8014f34:	687b      	ldr	r3, [r7, #4]
 8014f36:	2b00      	cmp	r3, #0
 8014f38:	d101      	bne.n	8014f3e <OsTraceBufInit+0x46>
            return LOS_ERRNO_TRACE_NO_MEMORY;
 8014f3a:	4b30      	ldr	r3, [pc, #192]	; (8014ffc <OsTraceBufInit+0x104>)
 8014f3c:	e051      	b.n	8014fe2 <OsTraceBufInit+0xea>
        }
    }

    (VOID)memset_s(buf, size, 0, size);
 8014f3e:	683b      	ldr	r3, [r7, #0]
 8014f40:	2200      	movs	r2, #0
 8014f42:	6839      	ldr	r1, [r7, #0]
 8014f44:	6878      	ldr	r0, [r7, #4]
 8014f46:	f001 f8a1 	bl	801608c <memset_s>
    g_traceRecoder.head = (OfflineHead *)buf;
 8014f4a:	4a2d      	ldr	r2, [pc, #180]	; (8015000 <OsTraceBufInit+0x108>)
 8014f4c:	687b      	ldr	r3, [r7, #4]
 8014f4e:	6113      	str	r3, [r2, #16]
    g_traceRecoder.head->baseInfo.bigLittleEndian = TRACE_BIGLITTLE_WORD;
 8014f50:	4b2b      	ldr	r3, [pc, #172]	; (8015000 <OsTraceBufInit+0x108>)
 8014f52:	691b      	ldr	r3, [r3, #16]
 8014f54:	4a2b      	ldr	r2, [pc, #172]	; (8015004 <OsTraceBufInit+0x10c>)
 8014f56:	601a      	str	r2, [r3, #0]
    g_traceRecoder.head->baseInfo.version         = TRACE_VERSION(TRACE_MODE_OFFLINE);
 8014f58:	4b29      	ldr	r3, [pc, #164]	; (8015000 <OsTraceBufInit+0x108>)
 8014f5a:	691b      	ldr	r3, [r3, #16]
 8014f5c:	2200      	movs	r2, #0
 8014f5e:	609a      	str	r2, [r3, #8]
    g_traceRecoder.head->baseInfo.clockFreq       = GET_SYS_CLOCK();
 8014f60:	4b27      	ldr	r3, [pc, #156]	; (8015000 <OsTraceBufInit+0x108>)
 8014f62:	691b      	ldr	r3, [r3, #16]
 8014f64:	4a28      	ldr	r2, [pc, #160]	; (8015008 <OsTraceBufInit+0x110>)
 8014f66:	6812      	ldr	r2, [r2, #0]
 8014f68:	605a      	str	r2, [r3, #4]
    g_traceRecoder.head->objSize                  = sizeof(ObjData);
 8014f6a:	4b25      	ldr	r3, [pc, #148]	; (8015000 <OsTraceBufInit+0x108>)
 8014f6c:	691b      	ldr	r3, [r3, #16]
 8014f6e:	2228      	movs	r2, #40	; 0x28
 8014f70:	81da      	strh	r2, [r3, #14]
    g_traceRecoder.head->frameSize                = sizeof(TraceEventFrame);
 8014f72:	4b23      	ldr	r3, [pc, #140]	; (8015000 <OsTraceBufInit+0x108>)
 8014f74:	691b      	ldr	r3, [r3, #16]
 8014f76:	2228      	movs	r2, #40	; 0x28
 8014f78:	821a      	strh	r2, [r3, #16]
    g_traceRecoder.head->objOffset                = sizeof(OfflineHead);
 8014f7a:	4b21      	ldr	r3, [pc, #132]	; (8015000 <OsTraceBufInit+0x108>)
 8014f7c:	691b      	ldr	r3, [r3, #16]
 8014f7e:	2218      	movs	r2, #24
 8014f80:	825a      	strh	r2, [r3, #18]
    g_traceRecoder.head->frameOffset              = headSize;
 8014f82:	4b1f      	ldr	r3, [pc, #124]	; (8015000 <OsTraceBufInit+0x108>)
 8014f84:	691b      	ldr	r3, [r3, #16]
 8014f86:	68fa      	ldr	r2, [r7, #12]
 8014f88:	b292      	uxth	r2, r2
 8014f8a:	829a      	strh	r2, [r3, #20]
    g_traceRecoder.head->totalLen                 = size;
 8014f8c:	4b1c      	ldr	r3, [pc, #112]	; (8015000 <OsTraceBufInit+0x108>)
 8014f8e:	691b      	ldr	r3, [r3, #16]
 8014f90:	683a      	ldr	r2, [r7, #0]
 8014f92:	b292      	uxth	r2, r2
 8014f94:	819a      	strh	r2, [r3, #12]

    g_traceRecoder.ctrl.curIndex       = 0;
 8014f96:	4b1a      	ldr	r3, [pc, #104]	; (8015000 <OsTraceBufInit+0x108>)
 8014f98:	2200      	movs	r2, #0
 8014f9a:	801a      	strh	r2, [r3, #0]
    g_traceRecoder.ctrl.curObjIndex    = 0;
 8014f9c:	4b18      	ldr	r3, [pc, #96]	; (8015000 <OsTraceBufInit+0x108>)
 8014f9e:	2200      	movs	r2, #0
 8014fa0:	809a      	strh	r2, [r3, #4]
    g_traceRecoder.ctrl.maxObjCount    = LOSCFG_TRACE_OBJ_MAX_NUM;
 8014fa2:	4b17      	ldr	r3, [pc, #92]	; (8015000 <OsTraceBufInit+0x108>)
 8014fa4:	2200      	movs	r2, #0
 8014fa6:	80da      	strh	r2, [r3, #6]
    g_traceRecoder.ctrl.maxRecordCount = (size - headSize) / sizeof(TraceEventFrame);
 8014fa8:	683a      	ldr	r2, [r7, #0]
 8014faa:	68fb      	ldr	r3, [r7, #12]
 8014fac:	1ad3      	subs	r3, r2, r3
 8014fae:	4a17      	ldr	r2, [pc, #92]	; (801500c <OsTraceBufInit+0x114>)
 8014fb0:	fba2 2303 	umull	r2, r3, r2, r3
 8014fb4:	095b      	lsrs	r3, r3, #5
 8014fb6:	b29a      	uxth	r2, r3
 8014fb8:	4b11      	ldr	r3, [pc, #68]	; (8015000 <OsTraceBufInit+0x108>)
 8014fba:	805a      	strh	r2, [r3, #2]
    g_traceRecoder.ctrl.objBuf         = (ObjData *)((UINTPTR)buf + g_traceRecoder.head->objOffset);
 8014fbc:	4b10      	ldr	r3, [pc, #64]	; (8015000 <OsTraceBufInit+0x108>)
 8014fbe:	691b      	ldr	r3, [r3, #16]
 8014fc0:	8a5b      	ldrh	r3, [r3, #18]
 8014fc2:	461a      	mov	r2, r3
 8014fc4:	687b      	ldr	r3, [r7, #4]
 8014fc6:	4413      	add	r3, r2
 8014fc8:	461a      	mov	r2, r3
 8014fca:	4b0d      	ldr	r3, [pc, #52]	; (8015000 <OsTraceBufInit+0x108>)
 8014fcc:	609a      	str	r2, [r3, #8]
    g_traceRecoder.ctrl.frameBuf       = (TraceEventFrame *)((UINTPTR)buf + g_traceRecoder.head->frameOffset);
 8014fce:	4b0c      	ldr	r3, [pc, #48]	; (8015000 <OsTraceBufInit+0x108>)
 8014fd0:	691b      	ldr	r3, [r3, #16]
 8014fd2:	8a9b      	ldrh	r3, [r3, #20]
 8014fd4:	461a      	mov	r2, r3
 8014fd6:	687b      	ldr	r3, [r7, #4]
 8014fd8:	4413      	add	r3, r2
 8014fda:	461a      	mov	r2, r3
 8014fdc:	4b08      	ldr	r3, [pc, #32]	; (8015000 <OsTraceBufInit+0x108>)
 8014fde:	60da      	str	r2, [r3, #12]

    return LOS_OK;
 8014fe0:	2300      	movs	r3, #0
}
 8014fe2:	4618      	mov	r0, r3
 8014fe4:	3710      	adds	r7, #16
 8014fe6:	46bd      	mov	sp, r7
 8014fe8:	bd80      	pop	{r7, pc}
 8014fea:	bf00      	nop
 8014fec:	08022b8c 	.word	0x08022b8c
 8014ff0:	08022b94 	.word	0x08022b94
 8014ff4:	02001402 	.word	0x02001402
 8014ff8:	200021b8 	.word	0x200021b8
 8014ffc:	02001401 	.word	0x02001401
 8015000:	20003364 	.word	0x20003364
 8015004:	12345678 	.word	0x12345678
 8015008:	200036e0 	.word	0x200036e0
 801500c:	cccccccd 	.word	0xcccccccd

08015010 <OsTraceObjAdd>:

VOID OsTraceObjAdd(UINT32 eventType, UINT32 taskId)
{
 8015010:	b580      	push	{r7, lr}
 8015012:	b086      	sub	sp, #24
 8015014:	af00      	add	r7, sp, #0
 8015016:	6078      	str	r0, [r7, #4]
 8015018:	6039      	str	r1, [r7, #0]
 801501a:	4b0f      	ldr	r3, [pc, #60]	; (8015058 <OsTraceObjAdd+0x48>)
 801501c:	681b      	ldr	r3, [r3, #0]
 801501e:	617b      	str	r3, [r7, #20]
 8015020:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 index;
    ObjData *obj = NULL;
 8015024:	2300      	movs	r3, #0
 8015026:	613b      	str	r3, [r7, #16]

    TRACE_LOCK(intSave);
 8015028:	f107 0308 	add.w	r3, r7, #8
 801502c:	4619      	mov	r1, r3
 801502e:	480b      	ldr	r0, [pc, #44]	; (801505c <OsTraceObjAdd+0x4c>)
 8015030:	f7ff ff30 	bl	8014e94 <LOS_SpinLockSave>
    /* add obj begin */
    index = g_traceRecoder.ctrl.curObjIndex;
 8015034:	4b0a      	ldr	r3, [pc, #40]	; (8015060 <OsTraceObjAdd+0x50>)
 8015036:	889b      	ldrh	r3, [r3, #4]
 8015038:	60fb      	str	r3, [r7, #12]
    if (index >= LOSCFG_TRACE_OBJ_MAX_NUM) { /* do nothing when config LOSCFG_TRACE_OBJ_MAX_NUM = 0 */
        TRACE_UNLOCK(intSave);
 801503a:	68bb      	ldr	r3, [r7, #8]
 801503c:	4619      	mov	r1, r3
 801503e:	4807      	ldr	r0, [pc, #28]	; (801505c <OsTraceObjAdd+0x4c>)
 8015040:	f7ff ff36 	bl	8014eb0 <LOS_SpinUnlockRestore>
    if (g_traceRecoder.ctrl.curObjIndex >= g_traceRecoder.ctrl.maxObjCount) {
        g_traceRecoder.ctrl.curObjIndex = 0; /* turn around */
    }
    /* add obj end */
    TRACE_UNLOCK(intSave);
}
 8015044:	4b04      	ldr	r3, [pc, #16]	; (8015058 <OsTraceObjAdd+0x48>)
 8015046:	681a      	ldr	r2, [r3, #0]
 8015048:	697b      	ldr	r3, [r7, #20]
 801504a:	405a      	eors	r2, r3
 801504c:	d001      	beq.n	8015052 <OsTraceObjAdd+0x42>
 801504e:	f7ef f9cb 	bl	80043e8 <__stack_chk_fail>
 8015052:	3718      	adds	r7, #24
 8015054:	46bd      	mov	sp, r7
 8015056:	bd80      	pop	{r7, pc}
 8015058:	08022bbc 	.word	0x08022bbc
 801505c:	20003360 	.word	0x20003360
 8015060:	20003364 	.word	0x20003364

08015064 <OsTraceWriteOrSendEvent>:

VOID OsTraceWriteOrSendEvent(const TraceEventFrame *frame)
{
 8015064:	b580      	push	{r7, lr}
 8015066:	b086      	sub	sp, #24
 8015068:	af00      	add	r7, sp, #0
 801506a:	6078      	str	r0, [r7, #4]
 801506c:	4b1c      	ldr	r3, [pc, #112]	; (80150e0 <OsTraceWriteOrSendEvent+0x7c>)
 801506e:	681b      	ldr	r3, [r3, #0]
 8015070:	617b      	str	r3, [r7, #20]
 8015072:	f04f 0300 	mov.w	r3, #0
    UINT16 index;
    UINT32 intSave;

    TRACE_LOCK(intSave);
 8015076:	f107 0310 	add.w	r3, r7, #16
 801507a:	4619      	mov	r1, r3
 801507c:	4819      	ldr	r0, [pc, #100]	; (80150e4 <OsTraceWriteOrSendEvent+0x80>)
 801507e:	f7ff ff09 	bl	8014e94 <LOS_SpinLockSave>
    index = g_traceRecoder.ctrl.curIndex;
 8015082:	4b19      	ldr	r3, [pc, #100]	; (80150e8 <OsTraceWriteOrSendEvent+0x84>)
 8015084:	881b      	ldrh	r3, [r3, #0]
 8015086:	81fb      	strh	r3, [r7, #14]
    (VOID)memcpy_s(&g_traceRecoder.ctrl.frameBuf[index], sizeof(TraceEventFrame), frame, sizeof(TraceEventFrame));
 8015088:	4b17      	ldr	r3, [pc, #92]	; (80150e8 <OsTraceWriteOrSendEvent+0x84>)
 801508a:	68d9      	ldr	r1, [r3, #12]
 801508c:	89fa      	ldrh	r2, [r7, #14]
 801508e:	4613      	mov	r3, r2
 8015090:	009b      	lsls	r3, r3, #2
 8015092:	4413      	add	r3, r2
 8015094:	00db      	lsls	r3, r3, #3
 8015096:	18c8      	adds	r0, r1, r3
 8015098:	2328      	movs	r3, #40	; 0x28
 801509a:	687a      	ldr	r2, [r7, #4]
 801509c:	2128      	movs	r1, #40	; 0x28
 801509e:	f001 fa7d 	bl	801659c <memcpy_s>

    g_traceRecoder.ctrl.curIndex++;
 80150a2:	4b11      	ldr	r3, [pc, #68]	; (80150e8 <OsTraceWriteOrSendEvent+0x84>)
 80150a4:	881b      	ldrh	r3, [r3, #0]
 80150a6:	3301      	adds	r3, #1
 80150a8:	b29a      	uxth	r2, r3
 80150aa:	4b0f      	ldr	r3, [pc, #60]	; (80150e8 <OsTraceWriteOrSendEvent+0x84>)
 80150ac:	801a      	strh	r2, [r3, #0]
    if (g_traceRecoder.ctrl.curIndex >= g_traceRecoder.ctrl.maxRecordCount) {
 80150ae:	4b0e      	ldr	r3, [pc, #56]	; (80150e8 <OsTraceWriteOrSendEvent+0x84>)
 80150b0:	881a      	ldrh	r2, [r3, #0]
 80150b2:	4b0d      	ldr	r3, [pc, #52]	; (80150e8 <OsTraceWriteOrSendEvent+0x84>)
 80150b4:	885b      	ldrh	r3, [r3, #2]
 80150b6:	429a      	cmp	r2, r3
 80150b8:	d302      	bcc.n	80150c0 <OsTraceWriteOrSendEvent+0x5c>
        g_traceRecoder.ctrl.curIndex = 0;
 80150ba:	4b0b      	ldr	r3, [pc, #44]	; (80150e8 <OsTraceWriteOrSendEvent+0x84>)
 80150bc:	2200      	movs	r2, #0
 80150be:	801a      	strh	r2, [r3, #0]
    }
    TRACE_UNLOCK(intSave);
 80150c0:	693b      	ldr	r3, [r7, #16]
 80150c2:	4619      	mov	r1, r3
 80150c4:	4807      	ldr	r0, [pc, #28]	; (80150e4 <OsTraceWriteOrSendEvent+0x80>)
 80150c6:	f7ff fef3 	bl	8014eb0 <LOS_SpinUnlockRestore>
}
 80150ca:	bf00      	nop
 80150cc:	4b04      	ldr	r3, [pc, #16]	; (80150e0 <OsTraceWriteOrSendEvent+0x7c>)
 80150ce:	681a      	ldr	r2, [r3, #0]
 80150d0:	697b      	ldr	r3, [r7, #20]
 80150d2:	405a      	eors	r2, r3
 80150d4:	d001      	beq.n	80150da <OsTraceWriteOrSendEvent+0x76>
 80150d6:	f7ef f987 	bl	80043e8 <__stack_chk_fail>
 80150da:	3718      	adds	r7, #24
 80150dc:	46bd      	mov	sp, r7
 80150de:	bd80      	pop	{r7, pc}
 80150e0:	08022bc0 	.word	0x08022bc0
 80150e4:	20003360 	.word	0x20003360
 80150e8:	20003364 	.word	0x20003364

080150ec <OsTraceReset>:

VOID OsTraceReset(VOID)
{
 80150ec:	b580      	push	{r7, lr}
 80150ee:	b084      	sub	sp, #16
 80150f0:	af00      	add	r7, sp, #0
 80150f2:	4b16      	ldr	r3, [pc, #88]	; (801514c <OsTraceReset+0x60>)
 80150f4:	681b      	ldr	r3, [r3, #0]
 80150f6:	60fb      	str	r3, [r7, #12]
 80150f8:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 bufLen;

    TRACE_LOCK(intSave);
 80150fc:	1d3b      	adds	r3, r7, #4
 80150fe:	4619      	mov	r1, r3
 8015100:	4813      	ldr	r0, [pc, #76]	; (8015150 <OsTraceReset+0x64>)
 8015102:	f7ff fec7 	bl	8014e94 <LOS_SpinLockSave>
    bufLen = sizeof(TraceEventFrame) * g_traceRecoder.ctrl.maxRecordCount;
 8015106:	4b13      	ldr	r3, [pc, #76]	; (8015154 <OsTraceReset+0x68>)
 8015108:	885b      	ldrh	r3, [r3, #2]
 801510a:	461a      	mov	r2, r3
 801510c:	4613      	mov	r3, r2
 801510e:	009b      	lsls	r3, r3, #2
 8015110:	4413      	add	r3, r2
 8015112:	00db      	lsls	r3, r3, #3
 8015114:	60bb      	str	r3, [r7, #8]
    (VOID)memset_s(g_traceRecoder.ctrl.frameBuf, bufLen, 0, bufLen);
 8015116:	4b0f      	ldr	r3, [pc, #60]	; (8015154 <OsTraceReset+0x68>)
 8015118:	68d8      	ldr	r0, [r3, #12]
 801511a:	68bb      	ldr	r3, [r7, #8]
 801511c:	2200      	movs	r2, #0
 801511e:	68b9      	ldr	r1, [r7, #8]
 8015120:	f000 ffb4 	bl	801608c <memset_s>
    g_traceRecoder.ctrl.curIndex = 0;
 8015124:	4b0b      	ldr	r3, [pc, #44]	; (8015154 <OsTraceReset+0x68>)
 8015126:	2200      	movs	r2, #0
 8015128:	801a      	strh	r2, [r3, #0]
    TRACE_UNLOCK(intSave);
 801512a:	687b      	ldr	r3, [r7, #4]
 801512c:	4619      	mov	r1, r3
 801512e:	4808      	ldr	r0, [pc, #32]	; (8015150 <OsTraceReset+0x64>)
 8015130:	f7ff febe 	bl	8014eb0 <LOS_SpinUnlockRestore>
}
 8015134:	bf00      	nop
 8015136:	4b05      	ldr	r3, [pc, #20]	; (801514c <OsTraceReset+0x60>)
 8015138:	681a      	ldr	r2, [r3, #0]
 801513a:	68fb      	ldr	r3, [r7, #12]
 801513c:	405a      	eors	r2, r3
 801513e:	d001      	beq.n	8015144 <OsTraceReset+0x58>
 8015140:	f7ef f952 	bl	80043e8 <__stack_chk_fail>
 8015144:	3710      	adds	r7, #16
 8015146:	46bd      	mov	sp, r7
 8015148:	bd80      	pop	{r7, pc}
 801514a:	bf00      	nop
 801514c:	08022bc4 	.word	0x08022bc4
 8015150:	20003360 	.word	0x20003360
 8015154:	20003364 	.word	0x20003364

08015158 <OsTraceInfoObj>:

STATIC VOID OsTraceInfoObj(VOID)
{
 8015158:	b580      	push	{r7, lr}
 801515a:	b084      	sub	sp, #16
 801515c:	af02      	add	r7, sp, #8
    UINT32 i;
    ObjData *obj = &g_traceRecoder.ctrl.objBuf[0];
 801515e:	4b19      	ldr	r3, [pc, #100]	; (80151c4 <OsTraceInfoObj+0x6c>)
 8015160:	689b      	ldr	r3, [r3, #8]
 8015162:	607b      	str	r3, [r7, #4]

    if (g_traceRecoder.ctrl.maxObjCount > 0) {
 8015164:	4b17      	ldr	r3, [pc, #92]	; (80151c4 <OsTraceInfoObj+0x6c>)
 8015166:	88db      	ldrh	r3, [r3, #6]
 8015168:	2b00      	cmp	r3, #0
 801516a:	d026      	beq.n	80151ba <OsTraceInfoObj+0x62>
        PRINTK("CurObjIndex = %u\n", g_traceRecoder.ctrl.curObjIndex);
 801516c:	4b15      	ldr	r3, [pc, #84]	; (80151c4 <OsTraceInfoObj+0x6c>)
 801516e:	889b      	ldrh	r3, [r3, #4]
 8015170:	4619      	mov	r1, r3
 8015172:	4815      	ldr	r0, [pc, #84]	; (80151c8 <OsTraceInfoObj+0x70>)
 8015174:	f7ef faaa 	bl	80046cc <dprintf>
        PRINTK("Index   TaskID   TaskPrio   TaskName \n");
 8015178:	4814      	ldr	r0, [pc, #80]	; (80151cc <OsTraceInfoObj+0x74>)
 801517a:	f7ef faa7 	bl	80046cc <dprintf>
        for (i = 0; i < g_traceRecoder.ctrl.maxObjCount; i++, obj++) {
 801517e:	2300      	movs	r3, #0
 8015180:	603b      	str	r3, [r7, #0]
 8015182:	e011      	b.n	80151a8 <OsTraceInfoObj+0x50>
            PRINTK("%-7u 0x%-6x %-10u %s\n", i, obj->id, obj->prio, obj->name);
 8015184:	687b      	ldr	r3, [r7, #4]
 8015186:	681a      	ldr	r2, [r3, #0]
 8015188:	687b      	ldr	r3, [r7, #4]
 801518a:	6859      	ldr	r1, [r3, #4]
 801518c:	687b      	ldr	r3, [r7, #4]
 801518e:	3308      	adds	r3, #8
 8015190:	9300      	str	r3, [sp, #0]
 8015192:	460b      	mov	r3, r1
 8015194:	6839      	ldr	r1, [r7, #0]
 8015196:	480e      	ldr	r0, [pc, #56]	; (80151d0 <OsTraceInfoObj+0x78>)
 8015198:	f7ef fa98 	bl	80046cc <dprintf>
        for (i = 0; i < g_traceRecoder.ctrl.maxObjCount; i++, obj++) {
 801519c:	683b      	ldr	r3, [r7, #0]
 801519e:	3301      	adds	r3, #1
 80151a0:	603b      	str	r3, [r7, #0]
 80151a2:	687b      	ldr	r3, [r7, #4]
 80151a4:	3328      	adds	r3, #40	; 0x28
 80151a6:	607b      	str	r3, [r7, #4]
 80151a8:	4b06      	ldr	r3, [pc, #24]	; (80151c4 <OsTraceInfoObj+0x6c>)
 80151aa:	88db      	ldrh	r3, [r3, #6]
 80151ac:	461a      	mov	r2, r3
 80151ae:	683b      	ldr	r3, [r7, #0]
 80151b0:	4293      	cmp	r3, r2
 80151b2:	d3e7      	bcc.n	8015184 <OsTraceInfoObj+0x2c>
        }
        PRINTK("\n");
 80151b4:	4807      	ldr	r0, [pc, #28]	; (80151d4 <OsTraceInfoObj+0x7c>)
 80151b6:	f7ef fa89 	bl	80046cc <dprintf>
    }
}
 80151ba:	bf00      	nop
 80151bc:	3708      	adds	r7, #8
 80151be:	46bd      	mov	sp, r7
 80151c0:	bd80      	pop	{r7, pc}
 80151c2:	bf00      	nop
 80151c4:	20003364 	.word	0x20003364
 80151c8:	08022bc8 	.word	0x08022bc8
 80151cc:	08022bdc 	.word	0x08022bdc
 80151d0:	08022c04 	.word	0x08022c04
 80151d4:	08022c1c 	.word	0x08022c1c

080151d8 <OsTraceInfoEventTitle>:

STATIC VOID OsTraceInfoEventTitle(VOID)
{
 80151d8:	b580      	push	{r7, lr}
 80151da:	af00      	add	r7, sp, #0
    PRINTK("CurEvtIndex = %u\n", g_traceRecoder.ctrl.curIndex);
 80151dc:	4b0b      	ldr	r3, [pc, #44]	; (801520c <OsTraceInfoEventTitle+0x34>)
 80151de:	881b      	ldrh	r3, [r3, #0]
 80151e0:	4619      	mov	r1, r3
 80151e2:	480b      	ldr	r0, [pc, #44]	; (8015210 <OsTraceInfoEventTitle+0x38>)
 80151e4:	f7ef fa72 	bl	80046cc <dprintf>

    PRINTK("Index   Time(cycles)      EventType      CurTask   Identity      ");
 80151e8:	480a      	ldr	r0, [pc, #40]	; (8015214 <OsTraceInfoEventTitle+0x3c>)
 80151ea:	f7ef fa6f 	bl	80046cc <dprintf>
#ifdef LOSCFG_TRACE_FRAME_CORE_MSG
    PRINTK("cpuId    hwiActive    taskLockCnt    ");
 80151ee:	480a      	ldr	r0, [pc, #40]	; (8015218 <OsTraceInfoEventTitle+0x40>)
 80151f0:	f7ef fa6c 	bl	80046cc <dprintf>
#endif
#ifdef LOSCFG_TRACE_FRAME_EVENT_COUNT
    PRINTK("eventCount    ");
 80151f4:	4809      	ldr	r0, [pc, #36]	; (801521c <OsTraceInfoEventTitle+0x44>)
 80151f6:	f7ef fa69 	bl	80046cc <dprintf>
#endif
    if (LOSCFG_TRACE_FRAME_MAX_PARAMS > 0) {
        PRINTK("params    ");
 80151fa:	4809      	ldr	r0, [pc, #36]	; (8015220 <OsTraceInfoEventTitle+0x48>)
 80151fc:	f7ef fa66 	bl	80046cc <dprintf>
    }
    PRINTK("\n");
 8015200:	4808      	ldr	r0, [pc, #32]	; (8015224 <OsTraceInfoEventTitle+0x4c>)
 8015202:	f7ef fa63 	bl	80046cc <dprintf>
}
 8015206:	bf00      	nop
 8015208:	bd80      	pop	{r7, pc}
 801520a:	bf00      	nop
 801520c:	20003364 	.word	0x20003364
 8015210:	08022c20 	.word	0x08022c20
 8015214:	08022c34 	.word	0x08022c34
 8015218:	08022c78 	.word	0x08022c78
 801521c:	08022ca0 	.word	0x08022ca0
 8015220:	08022cb0 	.word	0x08022cb0
 8015224:	08022c1c 	.word	0x08022c1c

08015228 <OsTraceInfoEventData>:

STATIC VOID OsTraceInfoEventData(VOID)
{
 8015228:	b590      	push	{r4, r7, lr}
 801522a:	b089      	sub	sp, #36	; 0x24
 801522c:	af04      	add	r7, sp, #16
    UINT32 i, j;
    TraceEventFrame *frame = &g_traceRecoder.ctrl.frameBuf[0];
 801522e:	4b2b      	ldr	r3, [pc, #172]	; (80152dc <OsTraceInfoEventData+0xb4>)
 8015230:	68db      	ldr	r3, [r3, #12]
 8015232:	60bb      	str	r3, [r7, #8]

    for (i = 0; i < g_traceRecoder.ctrl.maxRecordCount; i++, frame++) {
 8015234:	2300      	movs	r3, #0
 8015236:	603b      	str	r3, [r7, #0]
 8015238:	e044      	b.n	80152c4 <OsTraceInfoEventData+0x9c>
        PRINTK("%-7u 0x%-15llx 0x%-12x 0x%-7x 0x%-11x ", i, frame->curTime, frame->eventType,
 801523a:	68bb      	ldr	r3, [r7, #8]
 801523c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8015240:	68b9      	ldr	r1, [r7, #8]
 8015242:	6809      	ldr	r1, [r1, #0]
 8015244:	68b8      	ldr	r0, [r7, #8]
 8015246:	6840      	ldr	r0, [r0, #4]
 8015248:	68bc      	ldr	r4, [r7, #8]
 801524a:	6924      	ldr	r4, [r4, #16]
 801524c:	9402      	str	r4, [sp, #8]
 801524e:	9001      	str	r0, [sp, #4]
 8015250:	9100      	str	r1, [sp, #0]
 8015252:	6839      	ldr	r1, [r7, #0]
 8015254:	4822      	ldr	r0, [pc, #136]	; (80152e0 <OsTraceInfoEventData+0xb8>)
 8015256:	f7ef fa39 	bl	80046cc <dprintf>
            frame->curTask, frame->identity);
#ifdef LOSCFG_TRACE_FRAME_CORE_MSG
        UINT32 taskLockCnt = frame->core.taskLockCnt;
 801525a:	68bb      	ldr	r3, [r7, #8]
 801525c:	7d5b      	ldrb	r3, [r3, #21]
 801525e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8015262:	b2db      	uxtb	r3, r3
 8015264:	60fb      	str	r3, [r7, #12]
         * For smp systems, TRACE_LOCK will requst taskLock, and this counter
         * will increase by 1 in that case.
         */
        taskLockCnt -= 1;
#endif
        PRINTK("%-11u %-11u %-11u", frame->core.cpuId, frame->core.hwiActive, taskLockCnt);
 8015266:	68bb      	ldr	r3, [r7, #8]
 8015268:	7d1b      	ldrb	r3, [r3, #20]
 801526a:	4619      	mov	r1, r3
 801526c:	68bb      	ldr	r3, [r7, #8]
 801526e:	7d5b      	ldrb	r3, [r3, #21]
 8015270:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8015274:	b2db      	uxtb	r3, r3
 8015276:	461a      	mov	r2, r3
 8015278:	68fb      	ldr	r3, [r7, #12]
 801527a:	481a      	ldr	r0, [pc, #104]	; (80152e4 <OsTraceInfoEventData+0xbc>)
 801527c:	f7ef fa26 	bl	80046cc <dprintf>
#endif
#ifdef LOSCFG_TRACE_FRAME_EVENT_COUNT
        PRINTK("%-11u", frame->eventCount);
 8015280:	68bb      	ldr	r3, [r7, #8]
 8015282:	699b      	ldr	r3, [r3, #24]
 8015284:	4619      	mov	r1, r3
 8015286:	4818      	ldr	r0, [pc, #96]	; (80152e8 <OsTraceInfoEventData+0xc0>)
 8015288:	f7ef fa20 	bl	80046cc <dprintf>
#endif
        for (j = 0; j < LOSCFG_TRACE_FRAME_MAX_PARAMS; j++) {
 801528c:	2300      	movs	r3, #0
 801528e:	607b      	str	r3, [r7, #4]
 8015290:	e00c      	b.n	80152ac <OsTraceInfoEventData+0x84>
            PRINTK("0x%-11x", frame->params[j]);
 8015292:	68ba      	ldr	r2, [r7, #8]
 8015294:	687b      	ldr	r3, [r7, #4]
 8015296:	3306      	adds	r3, #6
 8015298:	009b      	lsls	r3, r3, #2
 801529a:	4413      	add	r3, r2
 801529c:	685b      	ldr	r3, [r3, #4]
 801529e:	4619      	mov	r1, r3
 80152a0:	4812      	ldr	r0, [pc, #72]	; (80152ec <OsTraceInfoEventData+0xc4>)
 80152a2:	f7ef fa13 	bl	80046cc <dprintf>
        for (j = 0; j < LOSCFG_TRACE_FRAME_MAX_PARAMS; j++) {
 80152a6:	687b      	ldr	r3, [r7, #4]
 80152a8:	3301      	adds	r3, #1
 80152aa:	607b      	str	r3, [r7, #4]
 80152ac:	687b      	ldr	r3, [r7, #4]
 80152ae:	2b02      	cmp	r3, #2
 80152b0:	d9ef      	bls.n	8015292 <OsTraceInfoEventData+0x6a>
        }
        PRINTK("\n");
 80152b2:	480f      	ldr	r0, [pc, #60]	; (80152f0 <OsTraceInfoEventData+0xc8>)
 80152b4:	f7ef fa0a 	bl	80046cc <dprintf>
    for (i = 0; i < g_traceRecoder.ctrl.maxRecordCount; i++, frame++) {
 80152b8:	683b      	ldr	r3, [r7, #0]
 80152ba:	3301      	adds	r3, #1
 80152bc:	603b      	str	r3, [r7, #0]
 80152be:	68bb      	ldr	r3, [r7, #8]
 80152c0:	3328      	adds	r3, #40	; 0x28
 80152c2:	60bb      	str	r3, [r7, #8]
 80152c4:	4b05      	ldr	r3, [pc, #20]	; (80152dc <OsTraceInfoEventData+0xb4>)
 80152c6:	885b      	ldrh	r3, [r3, #2]
 80152c8:	461a      	mov	r2, r3
 80152ca:	683b      	ldr	r3, [r7, #0]
 80152cc:	4293      	cmp	r3, r2
 80152ce:	d3b4      	bcc.n	801523a <OsTraceInfoEventData+0x12>
    }
}
 80152d0:	bf00      	nop
 80152d2:	bf00      	nop
 80152d4:	3714      	adds	r7, #20
 80152d6:	46bd      	mov	sp, r7
 80152d8:	bd90      	pop	{r4, r7, pc}
 80152da:	bf00      	nop
 80152dc:	20003364 	.word	0x20003364
 80152e0:	08022cbc 	.word	0x08022cbc
 80152e4:	08022ce4 	.word	0x08022ce4
 80152e8:	08022cf8 	.word	0x08022cf8
 80152ec:	08022d00 	.word	0x08022d00
 80152f0:	08022c1c 	.word	0x08022c1c

080152f4 <OsTraceInfoDisplay>:

STATIC VOID OsTraceInfoDisplay(VOID)
{
 80152f4:	b580      	push	{r7, lr}
 80152f6:	b082      	sub	sp, #8
 80152f8:	af00      	add	r7, sp, #0
    OfflineHead *head = g_traceRecoder.head;
 80152fa:	4b0c      	ldr	r3, [pc, #48]	; (801532c <OsTraceInfoDisplay+0x38>)
 80152fc:	691b      	ldr	r3, [r3, #16]
 80152fe:	607b      	str	r3, [r7, #4]

    PRINTK("*******TraceInfo begin*******\n");
 8015300:	480b      	ldr	r0, [pc, #44]	; (8015330 <OsTraceInfoDisplay+0x3c>)
 8015302:	f7ef f9e3 	bl	80046cc <dprintf>
    PRINTK("clockFreq = %u\n", head->baseInfo.clockFreq);
 8015306:	687b      	ldr	r3, [r7, #4]
 8015308:	685b      	ldr	r3, [r3, #4]
 801530a:	4619      	mov	r1, r3
 801530c:	4809      	ldr	r0, [pc, #36]	; (8015334 <OsTraceInfoDisplay+0x40>)
 801530e:	f7ef f9dd 	bl	80046cc <dprintf>

    OsTraceInfoObj();
 8015312:	f7ff ff21 	bl	8015158 <OsTraceInfoObj>

    OsTraceInfoEventTitle();
 8015316:	f7ff ff5f 	bl	80151d8 <OsTraceInfoEventTitle>
    OsTraceInfoEventData();
 801531a:	f7ff ff85 	bl	8015228 <OsTraceInfoEventData>

    PRINTK("*******TraceInfo end*******\n");
 801531e:	4806      	ldr	r0, [pc, #24]	; (8015338 <OsTraceInfoDisplay+0x44>)
 8015320:	f7ef f9d4 	bl	80046cc <dprintf>
}
 8015324:	bf00      	nop
 8015326:	3708      	adds	r7, #8
 8015328:	46bd      	mov	sp, r7
 801532a:	bd80      	pop	{r7, pc}
 801532c:	20003364 	.word	0x20003364
 8015330:	08022d08 	.word	0x08022d08
 8015334:	08022d28 	.word	0x08022d28
 8015338:	08022d38 	.word	0x08022d38

0801533c <OsTraceSendInfo>:

#ifdef LOSCFG_TRACE_CLIENT_INTERACT
STATIC VOID OsTraceSendInfo(VOID)
{
 801533c:	b580      	push	{r7, lr}
 801533e:	b084      	sub	sp, #16
 8015340:	af00      	add	r7, sp, #0
    UINT32 i;
    ObjData *obj = NULL;
 8015342:	2300      	movs	r3, #0
 8015344:	60bb      	str	r3, [r7, #8]
    TraceEventFrame *frame = NULL;
 8015346:	2300      	movs	r3, #0
 8015348:	60fb      	str	r3, [r7, #12]

    OsTraceDataSend(HEAD, sizeof(OfflineHead), (UINT8 *)g_traceRecoder.head);
 801534a:	4b22      	ldr	r3, [pc, #136]	; (80153d4 <OsTraceSendInfo+0x98>)
 801534c:	691b      	ldr	r3, [r3, #16]
 801534e:	461a      	mov	r2, r3
 8015350:	2118      	movs	r1, #24
 8015352:	2001      	movs	r0, #1
 8015354:	f000 f8b4 	bl	80154c0 <OsTraceDataSend>

    obj = &g_traceRecoder.ctrl.objBuf[0];
 8015358:	4b1e      	ldr	r3, [pc, #120]	; (80153d4 <OsTraceSendInfo+0x98>)
 801535a:	689b      	ldr	r3, [r3, #8]
 801535c:	60bb      	str	r3, [r7, #8]
    for (i = 0; i < g_traceRecoder.ctrl.maxObjCount; i++) {
 801535e:	2300      	movs	r3, #0
 8015360:	607b      	str	r3, [r7, #4]
 8015362:	e00f      	b.n	8015384 <OsTraceSendInfo+0x48>
        OsTraceDataSend(OBJ, sizeof(ObjData), (UINT8 *)(obj + i));
 8015364:	687a      	ldr	r2, [r7, #4]
 8015366:	4613      	mov	r3, r2
 8015368:	009b      	lsls	r3, r3, #2
 801536a:	4413      	add	r3, r2
 801536c:	00db      	lsls	r3, r3, #3
 801536e:	461a      	mov	r2, r3
 8015370:	68bb      	ldr	r3, [r7, #8]
 8015372:	4413      	add	r3, r2
 8015374:	461a      	mov	r2, r3
 8015376:	2128      	movs	r1, #40	; 0x28
 8015378:	2002      	movs	r0, #2
 801537a:	f000 f8a1 	bl	80154c0 <OsTraceDataSend>
    for (i = 0; i < g_traceRecoder.ctrl.maxObjCount; i++) {
 801537e:	687b      	ldr	r3, [r7, #4]
 8015380:	3301      	adds	r3, #1
 8015382:	607b      	str	r3, [r7, #4]
 8015384:	4b13      	ldr	r3, [pc, #76]	; (80153d4 <OsTraceSendInfo+0x98>)
 8015386:	88db      	ldrh	r3, [r3, #6]
 8015388:	461a      	mov	r2, r3
 801538a:	687b      	ldr	r3, [r7, #4]
 801538c:	4293      	cmp	r3, r2
 801538e:	d3e9      	bcc.n	8015364 <OsTraceSendInfo+0x28>
    }

    frame = &g_traceRecoder.ctrl.frameBuf[0];
 8015390:	4b10      	ldr	r3, [pc, #64]	; (80153d4 <OsTraceSendInfo+0x98>)
 8015392:	68db      	ldr	r3, [r3, #12]
 8015394:	60fb      	str	r3, [r7, #12]
    for (i = 0; i < g_traceRecoder.ctrl.maxRecordCount; i++) {
 8015396:	2300      	movs	r3, #0
 8015398:	607b      	str	r3, [r7, #4]
 801539a:	e00f      	b.n	80153bc <OsTraceSendInfo+0x80>
        OsTraceDataSend(EVENT, sizeof(TraceEventFrame), (UINT8 *)(frame + i));
 801539c:	687a      	ldr	r2, [r7, #4]
 801539e:	4613      	mov	r3, r2
 80153a0:	009b      	lsls	r3, r3, #2
 80153a2:	4413      	add	r3, r2
 80153a4:	00db      	lsls	r3, r3, #3
 80153a6:	461a      	mov	r2, r3
 80153a8:	68fb      	ldr	r3, [r7, #12]
 80153aa:	4413      	add	r3, r2
 80153ac:	461a      	mov	r2, r3
 80153ae:	2128      	movs	r1, #40	; 0x28
 80153b0:	2003      	movs	r0, #3
 80153b2:	f000 f885 	bl	80154c0 <OsTraceDataSend>
    for (i = 0; i < g_traceRecoder.ctrl.maxRecordCount; i++) {
 80153b6:	687b      	ldr	r3, [r7, #4]
 80153b8:	3301      	adds	r3, #1
 80153ba:	607b      	str	r3, [r7, #4]
 80153bc:	4b05      	ldr	r3, [pc, #20]	; (80153d4 <OsTraceSendInfo+0x98>)
 80153be:	885b      	ldrh	r3, [r3, #2]
 80153c0:	461a      	mov	r2, r3
 80153c2:	687b      	ldr	r3, [r7, #4]
 80153c4:	4293      	cmp	r3, r2
 80153c6:	d3e9      	bcc.n	801539c <OsTraceSendInfo+0x60>
    }
}
 80153c8:	bf00      	nop
 80153ca:	bf00      	nop
 80153cc:	3710      	adds	r7, #16
 80153ce:	46bd      	mov	sp, r7
 80153d0:	bd80      	pop	{r7, pc}
 80153d2:	bf00      	nop
 80153d4:	20003364 	.word	0x20003364

080153d8 <OsTraceRecordDump>:
#endif

VOID OsTraceRecordDump(BOOL toClient)
{
 80153d8:	b580      	push	{r7, lr}
 80153da:	b082      	sub	sp, #8
 80153dc:	af00      	add	r7, sp, #0
 80153de:	6078      	str	r0, [r7, #4]
    if (!toClient) {
 80153e0:	687b      	ldr	r3, [r7, #4]
 80153e2:	2b00      	cmp	r3, #0
 80153e4:	d102      	bne.n	80153ec <OsTraceRecordDump+0x14>
        OsTraceInfoDisplay();
 80153e6:	f7ff ff85 	bl	80152f4 <OsTraceInfoDisplay>
        return;
 80153ea:	e001      	b.n	80153f0 <OsTraceRecordDump+0x18>
    }

#ifdef LOSCFG_TRACE_CLIENT_INTERACT
    OsTraceSendInfo();
 80153ec:	f7ff ffa6 	bl	801533c <OsTraceSendInfo>
#endif
}
 80153f0:	3708      	adds	r7, #8
 80153f2:	46bd      	mov	sp, r7
 80153f4:	bd80      	pop	{r7, pc}

080153f6 <LOS_IntLock>:
{
 80153f6:	b580      	push	{r7, lr}
 80153f8:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80153fa:	f7eb fc65 	bl	8000cc8 <ArchIntLock>
 80153fe:	4603      	mov	r3, r0
}
 8015400:	4618      	mov	r0, r3
 8015402:	bd80      	pop	{r7, pc}

08015404 <LOS_IntRestore>:
{
 8015404:	b580      	push	{r7, lr}
 8015406:	b082      	sub	sp, #8
 8015408:	af00      	add	r7, sp, #0
 801540a:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 801540c:	6878      	ldr	r0, [r7, #4]
 801540e:	f7eb fc63 	bl	8000cd8 <ArchIntRestore>
}
 8015412:	bf00      	nop
 8015414:	3708      	adds	r7, #8
 8015416:	46bd      	mov	sp, r7
 8015418:	bd80      	pop	{r7, pc}

0801541a <LOS_SpinLockSave>:
{
 801541a:	b580      	push	{r7, lr}
 801541c:	b082      	sub	sp, #8
 801541e:	af00      	add	r7, sp, #0
 8015420:	6078      	str	r0, [r7, #4]
 8015422:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8015424:	f7ff ffe7 	bl	80153f6 <LOS_IntLock>
 8015428:	4602      	mov	r2, r0
 801542a:	683b      	ldr	r3, [r7, #0]
 801542c:	601a      	str	r2, [r3, #0]
}
 801542e:	bf00      	nop
 8015430:	3708      	adds	r7, #8
 8015432:	46bd      	mov	sp, r7
 8015434:	bd80      	pop	{r7, pc}

08015436 <LOS_SpinUnlockRestore>:
{
 8015436:	b580      	push	{r7, lr}
 8015438:	b082      	sub	sp, #8
 801543a:	af00      	add	r7, sp, #0
 801543c:	6078      	str	r0, [r7, #4]
 801543e:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8015440:	6838      	ldr	r0, [r7, #0]
 8015442:	f7ff ffdf 	bl	8015404 <LOS_IntRestore>
}
 8015446:	bf00      	nop
 8015448:	3708      	adds	r7, #8
 801544a:	46bd      	mov	sp, r7
 801544c:	bd80      	pop	{r7, pc}

0801544e <DefaultPipelineInit>:
    g_traceTlvTblObj,
    g_traceTlvTblEvent
};

STATIC UINT32 DefaultPipelineInit(VOID)
{
 801544e:	b480      	push	{r7}
 8015450:	af00      	add	r7, sp, #0
    return LOS_OK;
 8015452:	2300      	movs	r3, #0
}
 8015454:	4618      	mov	r0, r3
 8015456:	46bd      	mov	sp, r7
 8015458:	f85d 7b04 	ldr.w	r7, [sp], #4
 801545c:	4770      	bx	lr

0801545e <DefaultDataSend>:

STATIC VOID DefaultDataSend(UINT16 len, UINT8 *data)
{
 801545e:	b480      	push	{r7}
 8015460:	b083      	sub	sp, #12
 8015462:	af00      	add	r7, sp, #0
 8015464:	4603      	mov	r3, r0
 8015466:	6039      	str	r1, [r7, #0]
 8015468:	80fb      	strh	r3, [r7, #6]
    (VOID)len;
    (VOID)data;
}
 801546a:	bf00      	nop
 801546c:	370c      	adds	r7, #12
 801546e:	46bd      	mov	sp, r7
 8015470:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015474:	4770      	bx	lr

08015476 <DefaultDataReceive>:

STATIC UINT32 DefaultDataReceive(UINT8 *data, UINT32 size, UINT32 timeout)
{
 8015476:	b480      	push	{r7}
 8015478:	b085      	sub	sp, #20
 801547a:	af00      	add	r7, sp, #0
 801547c:	60f8      	str	r0, [r7, #12]
 801547e:	60b9      	str	r1, [r7, #8]
 8015480:	607a      	str	r2, [r7, #4]
    (VOID)data;
    (VOID)size;
    (VOID)timeout;
    return LOS_OK;
 8015482:	2300      	movs	r3, #0
}
 8015484:	4618      	mov	r0, r3
 8015486:	3714      	adds	r7, #20
 8015488:	46bd      	mov	sp, r7
 801548a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801548e:	4770      	bx	lr

08015490 <DefaultWait>:

STATIC UINT32 DefaultWait(VOID)
{
 8015490:	b480      	push	{r7}
 8015492:	af00      	add	r7, sp, #0
    return LOS_OK;
 8015494:	2300      	movs	r3, #0
}
 8015496:	4618      	mov	r0, r3
 8015498:	46bd      	mov	sp, r7
 801549a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801549e:	4770      	bx	lr

080154a0 <OsTracePipelineReg>:
};

STATIC const TracePipelineOps *g_tracePipelineOps = &g_defaultOps;

VOID OsTracePipelineReg(const TracePipelineOps *ops)
{
 80154a0:	b480      	push	{r7}
 80154a2:	b083      	sub	sp, #12
 80154a4:	af00      	add	r7, sp, #0
 80154a6:	6078      	str	r0, [r7, #4]
    g_tracePipelineOps = ops;
 80154a8:	4a04      	ldr	r2, [pc, #16]	; (80154bc <OsTracePipelineReg+0x1c>)
 80154aa:	687b      	ldr	r3, [r7, #4]
 80154ac:	6013      	str	r3, [r2, #0]
}
 80154ae:	bf00      	nop
 80154b0:	370c      	adds	r7, #12
 80154b2:	46bd      	mov	sp, r7
 80154b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80154b8:	4770      	bx	lr
 80154ba:	bf00      	nop
 80154bc:	20000504 	.word	0x20000504

080154c0 <OsTraceDataSend>:

VOID OsTraceDataSend(UINT8 type, UINT16 len, UINT8 *data)
{
 80154c0:	b580      	push	{r7, lr}
 80154c2:	b0a0      	sub	sp, #128	; 0x80
 80154c4:	af02      	add	r7, sp, #8
 80154c6:	4603      	mov	r3, r0
 80154c8:	603a      	str	r2, [r7, #0]
 80154ca:	71fb      	strb	r3, [r7, #7]
 80154cc:	460b      	mov	r3, r1
 80154ce:	80bb      	strh	r3, [r7, #4]
 80154d0:	4b20      	ldr	r3, [pc, #128]	; (8015554 <OsTraceDataSend+0x94>)
 80154d2:	681b      	ldr	r3, [r3, #0]
 80154d4:	677b      	str	r3, [r7, #116]	; 0x74
 80154d6:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT8 outBuf[LOSCFG_TRACE_TLV_BUF_SIZE] = {0};
 80154da:	2300      	movs	r3, #0
 80154dc:	613b      	str	r3, [r7, #16]
 80154de:	f107 0314 	add.w	r3, r7, #20
 80154e2:	2260      	movs	r2, #96	; 0x60
 80154e4:	2100      	movs	r1, #0
 80154e6:	4618      	mov	r0, r3
 80154e8:	f7f9 f9ac 	bl	800e844 <memset>

    if ((type > TRACE_MSG_MAX) || (len > LOSCFG_TRACE_TLV_BUF_SIZE)) {
 80154ec:	79fb      	ldrb	r3, [r7, #7]
 80154ee:	2b04      	cmp	r3, #4
 80154f0:	d824      	bhi.n	801553c <OsTraceDataSend+0x7c>
 80154f2:	88bb      	ldrh	r3, [r7, #4]
 80154f4:	2b64      	cmp	r3, #100	; 0x64
 80154f6:	d821      	bhi.n	801553c <OsTraceDataSend+0x7c>
        return;
    }

    len = OsTraceDataEncode(type, g_traceTlvTbl[type], data, &outBuf[0], sizeof(outBuf));
 80154f8:	79fb      	ldrb	r3, [r7, #7]
 80154fa:	4a17      	ldr	r2, [pc, #92]	; (8015558 <OsTraceDataSend+0x98>)
 80154fc:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 8015500:	f107 0310 	add.w	r3, r7, #16
 8015504:	79f8      	ldrb	r0, [r7, #7]
 8015506:	2264      	movs	r2, #100	; 0x64
 8015508:	9200      	str	r2, [sp, #0]
 801550a:	683a      	ldr	r2, [r7, #0]
 801550c:	f000 f903 	bl	8015716 <OsTraceDataEncode>
 8015510:	4603      	mov	r3, r0
 8015512:	80bb      	strh	r3, [r7, #4]

    PIPE_LOCK(intSave);
 8015514:	f107 030c 	add.w	r3, r7, #12
 8015518:	4619      	mov	r1, r3
 801551a:	4810      	ldr	r0, [pc, #64]	; (801555c <OsTraceDataSend+0x9c>)
 801551c:	f7ff ff7d 	bl	801541a <LOS_SpinLockSave>
    g_tracePipelineOps->dataSend(len, &outBuf[0]);
 8015520:	4b0f      	ldr	r3, [pc, #60]	; (8015560 <OsTraceDataSend+0xa0>)
 8015522:	681b      	ldr	r3, [r3, #0]
 8015524:	685b      	ldr	r3, [r3, #4]
 8015526:	f107 0110 	add.w	r1, r7, #16
 801552a:	88ba      	ldrh	r2, [r7, #4]
 801552c:	4610      	mov	r0, r2
 801552e:	4798      	blx	r3
    PIPE_UNLOCK(intSave);
 8015530:	68fb      	ldr	r3, [r7, #12]
 8015532:	4619      	mov	r1, r3
 8015534:	4809      	ldr	r0, [pc, #36]	; (801555c <OsTraceDataSend+0x9c>)
 8015536:	f7ff ff7e 	bl	8015436 <LOS_SpinUnlockRestore>
 801553a:	e000      	b.n	801553e <OsTraceDataSend+0x7e>
        return;
 801553c:	bf00      	nop
}
 801553e:	4b05      	ldr	r3, [pc, #20]	; (8015554 <OsTraceDataSend+0x94>)
 8015540:	681a      	ldr	r2, [r3, #0]
 8015542:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015544:	405a      	eors	r2, r3
 8015546:	d001      	beq.n	801554c <OsTraceDataSend+0x8c>
 8015548:	f7ee ff4e 	bl	80043e8 <__stack_chk_fail>
 801554c:	3778      	adds	r7, #120	; 0x78
 801554e:	46bd      	mov	sp, r7
 8015550:	bd80      	pop	{r7, pc}
 8015552:	bf00      	nop
 8015554:	08022d58 	.word	0x08022d58
 8015558:	200004e4 	.word	0x200004e4
 801555c:	200033b8 	.word	0x200033b8
 8015560:	20000504 	.word	0x20000504

08015564 <SerialPipelineInit>:
}

#else

UINT32 SerialPipelineInit(VOID)
{
 8015564:	b480      	push	{r7}
 8015566:	af00      	add	r7, sp, #0
    return LOS_OK;
 8015568:	2300      	movs	r3, #0
}
 801556a:	4618      	mov	r0, r3
 801556c:	46bd      	mov	sp, r7
 801556e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015572:	4770      	bx	lr

08015574 <SerialDataReceive>:

UINT32 SerialDataReceive(UINT8 *data, UINT32 size, UINT32 timeout)
{
 8015574:	b480      	push	{r7}
 8015576:	b085      	sub	sp, #20
 8015578:	af00      	add	r7, sp, #0
 801557a:	60f8      	str	r0, [r7, #12]
 801557c:	60b9      	str	r1, [r7, #8]
 801557e:	607a      	str	r2, [r7, #4]
    return LOS_OK;
 8015580:	2300      	movs	r3, #0
}
 8015582:	4618      	mov	r0, r3
 8015584:	3714      	adds	r7, #20
 8015586:	46bd      	mov	sp, r7
 8015588:	f85d 7b04 	ldr.w	r7, [sp], #4
 801558c:	4770      	bx	lr

0801558e <SerialWait>:

UINT32 SerialWait(VOID)
{
 801558e:	b480      	push	{r7}
 8015590:	af00      	add	r7, sp, #0
    return LOS_OK;
 8015592:	2300      	movs	r3, #0
}
 8015594:	4618      	mov	r0, r3
 8015596:	46bd      	mov	sp, r7
 8015598:	f85d 7b04 	ldr.w	r7, [sp], #4
 801559c:	4770      	bx	lr

0801559e <SerialDataSend>:
#endif

VOID SerialDataSend(UINT16 len, UINT8 *data)
{
 801559e:	b580      	push	{r7, lr}
 80155a0:	b084      	sub	sp, #16
 80155a2:	af00      	add	r7, sp, #0
 80155a4:	4603      	mov	r3, r0
 80155a6:	6039      	str	r1, [r7, #0]
 80155a8:	80fb      	strh	r3, [r7, #6]
    UINT32 i;

    for (i = 0; i < len; i++) {
 80155aa:	2300      	movs	r3, #0
 80155ac:	60fb      	str	r3, [r7, #12]
 80155ae:	e009      	b.n	80155c4 <SerialDataSend+0x26>
        UART_PUTC(data[i]);
 80155b0:	683a      	ldr	r2, [r7, #0]
 80155b2:	68fb      	ldr	r3, [r7, #12]
 80155b4:	4413      	add	r3, r2
 80155b6:	781b      	ldrb	r3, [r3, #0]
 80155b8:	4618      	mov	r0, r3
 80155ba:	f7fa fc1d 	bl	800fdf8 <uart_putc>
    for (i = 0; i < len; i++) {
 80155be:	68fb      	ldr	r3, [r7, #12]
 80155c0:	3301      	adds	r3, #1
 80155c2:	60fb      	str	r3, [r7, #12]
 80155c4:	88fb      	ldrh	r3, [r7, #6]
 80155c6:	68fa      	ldr	r2, [r7, #12]
 80155c8:	429a      	cmp	r2, r3
 80155ca:	d3f1      	bcc.n	80155b0 <SerialDataSend+0x12>
    }
}
 80155cc:	bf00      	nop
 80155ce:	bf00      	nop
 80155d0:	3710      	adds	r7, #16
 80155d2:	46bd      	mov	sp, r7
 80155d4:	bd80      	pop	{r7, pc}
	...

080155d8 <OsTracePipelineInit>:
    .dataRecv = SerialDataReceive,
    .wait = SerialWait,
};

UINT32 OsTracePipelineInit(VOID)
{
 80155d8:	b580      	push	{r7, lr}
 80155da:	af00      	add	r7, sp, #0
    OsTracePipelineReg(&g_serialOps);
 80155dc:	4803      	ldr	r0, [pc, #12]	; (80155ec <OsTracePipelineInit+0x14>)
 80155de:	f7ff ff5f 	bl	80154a0 <OsTracePipelineReg>
    return g_serialOps.init();
 80155e2:	4b03      	ldr	r3, [pc, #12]	; (80155f0 <OsTracePipelineInit+0x18>)
 80155e4:	4798      	blx	r3
 80155e6:	4603      	mov	r3, r0
}
 80155e8:	4618      	mov	r0, r3
 80155ea:	bd80      	pop	{r7, pc}
 80155ec:	08023698 	.word	0x08023698
 80155f0:	08015565 	.word	0x08015565

080155f4 <CalcCrc16>:
#define CRC_WIDTH  8
#define CRC_POLY   0x1021
#define CRC_TOPBIT 0x8000

STATIC UINT16 CalcCrc16(const UINT8 *buf, UINT32 len)
{
 80155f4:	b480      	push	{r7}
 80155f6:	b085      	sub	sp, #20
 80155f8:	af00      	add	r7, sp, #0
 80155fa:	6078      	str	r0, [r7, #4]
 80155fc:	6039      	str	r1, [r7, #0]
    UINT32 i;
    UINT16 crc = 0;
 80155fe:	2300      	movs	r3, #0
 8015600:	817b      	strh	r3, [r7, #10]

    for (; len > 0; len--) {
 8015602:	e026      	b.n	8015652 <CalcCrc16+0x5e>
        crc = crc ^ (*buf++ << CRC_WIDTH);
 8015604:	687b      	ldr	r3, [r7, #4]
 8015606:	1c5a      	adds	r2, r3, #1
 8015608:	607a      	str	r2, [r7, #4]
 801560a:	781b      	ldrb	r3, [r3, #0]
 801560c:	021b      	lsls	r3, r3, #8
 801560e:	b21a      	sxth	r2, r3
 8015610:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8015614:	4053      	eors	r3, r2
 8015616:	b21b      	sxth	r3, r3
 8015618:	817b      	strh	r3, [r7, #10]
        for (i = 0; i < CRC_WIDTH; i++) {
 801561a:	2300      	movs	r3, #0
 801561c:	60fb      	str	r3, [r7, #12]
 801561e:	e012      	b.n	8015646 <CalcCrc16+0x52>
            if (crc & CRC_TOPBIT) {
 8015620:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8015624:	2b00      	cmp	r3, #0
 8015626:	da08      	bge.n	801563a <CalcCrc16+0x46>
                crc = (crc << 1) ^ CRC_POLY;
 8015628:	897b      	ldrh	r3, [r7, #10]
 801562a:	005b      	lsls	r3, r3, #1
 801562c:	b21a      	sxth	r2, r3
 801562e:	f241 0321 	movw	r3, #4129	; 0x1021
 8015632:	4053      	eors	r3, r2
 8015634:	b21b      	sxth	r3, r3
 8015636:	817b      	strh	r3, [r7, #10]
 8015638:	e002      	b.n	8015640 <CalcCrc16+0x4c>
            } else {
                crc <<= 1;
 801563a:	897b      	ldrh	r3, [r7, #10]
 801563c:	005b      	lsls	r3, r3, #1
 801563e:	817b      	strh	r3, [r7, #10]
        for (i = 0; i < CRC_WIDTH; i++) {
 8015640:	68fb      	ldr	r3, [r7, #12]
 8015642:	3301      	adds	r3, #1
 8015644:	60fb      	str	r3, [r7, #12]
 8015646:	68fb      	ldr	r3, [r7, #12]
 8015648:	2b07      	cmp	r3, #7
 801564a:	d9e9      	bls.n	8015620 <CalcCrc16+0x2c>
    for (; len > 0; len--) {
 801564c:	683b      	ldr	r3, [r7, #0]
 801564e:	3b01      	subs	r3, #1
 8015650:	603b      	str	r3, [r7, #0]
 8015652:	683b      	ldr	r3, [r7, #0]
 8015654:	2b00      	cmp	r3, #0
 8015656:	d1d5      	bne.n	8015604 <CalcCrc16+0x10>
            }
        }
    }
    return crc;
 8015658:	897b      	ldrh	r3, [r7, #10]
}
 801565a:	4618      	mov	r0, r3
 801565c:	3714      	adds	r7, #20
 801565e:	46bd      	mov	sp, r7
 8015660:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015664:	4770      	bx	lr

08015666 <OsWriteTlv>:

STATIC UINT32 OsWriteTlv(UINT8 *tlvBuf, UINT8 type, UINT8 len, UINT8 *value)
{
 8015666:	b580      	push	{r7, lr}
 8015668:	b086      	sub	sp, #24
 801566a:	af00      	add	r7, sp, #0
 801566c:	60f8      	str	r0, [r7, #12]
 801566e:	607b      	str	r3, [r7, #4]
 8015670:	460b      	mov	r3, r1
 8015672:	72fb      	strb	r3, [r7, #11]
 8015674:	4613      	mov	r3, r2
 8015676:	72bb      	strb	r3, [r7, #10]
    TraceMsgTlvBody *body = (TraceMsgTlvBody *)tlvBuf;
 8015678:	68fb      	ldr	r3, [r7, #12]
 801567a:	617b      	str	r3, [r7, #20]

    if (len == 0) {
 801567c:	7abb      	ldrb	r3, [r7, #10]
 801567e:	2b00      	cmp	r3, #0
 8015680:	d101      	bne.n	8015686 <OsWriteTlv+0x20>
        return 0;
 8015682:	2300      	movs	r3, #0
 8015684:	e00e      	b.n	80156a4 <OsWriteTlv+0x3e>
    }

    body->type = type;
 8015686:	697b      	ldr	r3, [r7, #20]
 8015688:	7afa      	ldrb	r2, [r7, #11]
 801568a:	701a      	strb	r2, [r3, #0]
    body->len = len;
 801568c:	697b      	ldr	r3, [r7, #20]
 801568e:	7aba      	ldrb	r2, [r7, #10]
 8015690:	705a      	strb	r2, [r3, #1]
    /* Do not check return value for performance, if copy failed, only this package will be discarded */
    (VOID)memcpy_s(body->value, len, value, len);
 8015692:	697b      	ldr	r3, [r7, #20]
 8015694:	1c98      	adds	r0, r3, #2
 8015696:	7ab9      	ldrb	r1, [r7, #10]
 8015698:	7abb      	ldrb	r3, [r7, #10]
 801569a:	687a      	ldr	r2, [r7, #4]
 801569c:	f000 ff7e 	bl	801659c <memcpy_s>
    return len + sizeof(body->type) + sizeof(body->len);
 80156a0:	7abb      	ldrb	r3, [r7, #10]
 80156a2:	3302      	adds	r3, #2
}
 80156a4:	4618      	mov	r0, r3
 80156a6:	3718      	adds	r7, #24
 80156a8:	46bd      	mov	sp, r7
 80156aa:	bd80      	pop	{r7, pc}

080156ac <OsTlvEncode>:

STATIC UINT32 OsTlvEncode(const TlvTable *table, UINT8 *srcBuf, UINT8 *tlvBuf, INT32 tlvBufLen)
{
 80156ac:	b590      	push	{r4, r7, lr}
 80156ae:	b087      	sub	sp, #28
 80156b0:	af00      	add	r7, sp, #0
 80156b2:	60f8      	str	r0, [r7, #12]
 80156b4:	60b9      	str	r1, [r7, #8]
 80156b6:	607a      	str	r2, [r7, #4]
 80156b8:	603b      	str	r3, [r7, #0]
    UINT32 len = 0;
 80156ba:	2300      	movs	r3, #0
 80156bc:	613b      	str	r3, [r7, #16]
    const TlvTable *tlvTableItem = table;
 80156be:	68fb      	ldr	r3, [r7, #12]
 80156c0:	617b      	str	r3, [r7, #20]

    while (tlvTableItem->tag != TRACE_TLV_TYPE_NULL) {
 80156c2:	e01d      	b.n	8015700 <OsTlvEncode+0x54>
        if ((len + tlvTableItem->elemSize + sizeof(UINT8) + sizeof(UINT8)) > tlvBufLen) {
 80156c4:	697b      	ldr	r3, [r7, #20]
 80156c6:	789b      	ldrb	r3, [r3, #2]
 80156c8:	461a      	mov	r2, r3
 80156ca:	693b      	ldr	r3, [r7, #16]
 80156cc:	4413      	add	r3, r2
 80156ce:	1c9a      	adds	r2, r3, #2
 80156d0:	683b      	ldr	r3, [r7, #0]
 80156d2:	429a      	cmp	r2, r3
 80156d4:	d819      	bhi.n	801570a <OsTlvEncode+0x5e>
            break;
        }
        len += OsWriteTlv(tlvBuf + len, tlvTableItem->tag, tlvTableItem->elemSize, srcBuf + tlvTableItem->elemOffset);
 80156d6:	687a      	ldr	r2, [r7, #4]
 80156d8:	693b      	ldr	r3, [r7, #16]
 80156da:	18d0      	adds	r0, r2, r3
 80156dc:	697b      	ldr	r3, [r7, #20]
 80156de:	7819      	ldrb	r1, [r3, #0]
 80156e0:	697b      	ldr	r3, [r7, #20]
 80156e2:	789a      	ldrb	r2, [r3, #2]
 80156e4:	697b      	ldr	r3, [r7, #20]
 80156e6:	785b      	ldrb	r3, [r3, #1]
 80156e8:	461c      	mov	r4, r3
 80156ea:	68bb      	ldr	r3, [r7, #8]
 80156ec:	4423      	add	r3, r4
 80156ee:	f7ff ffba 	bl	8015666 <OsWriteTlv>
 80156f2:	4602      	mov	r2, r0
 80156f4:	693b      	ldr	r3, [r7, #16]
 80156f6:	4413      	add	r3, r2
 80156f8:	613b      	str	r3, [r7, #16]
        tlvTableItem++;
 80156fa:	697b      	ldr	r3, [r7, #20]
 80156fc:	3303      	adds	r3, #3
 80156fe:	617b      	str	r3, [r7, #20]
    while (tlvTableItem->tag != TRACE_TLV_TYPE_NULL) {
 8015700:	697b      	ldr	r3, [r7, #20]
 8015702:	781b      	ldrb	r3, [r3, #0]
 8015704:	2bff      	cmp	r3, #255	; 0xff
 8015706:	d1dd      	bne.n	80156c4 <OsTlvEncode+0x18>
 8015708:	e000      	b.n	801570c <OsTlvEncode+0x60>
            break;
 801570a:	bf00      	nop
    }
    return len;
 801570c:	693b      	ldr	r3, [r7, #16]
}
 801570e:	4618      	mov	r0, r3
 8015710:	371c      	adds	r7, #28
 8015712:	46bd      	mov	sp, r7
 8015714:	bd90      	pop	{r4, r7, pc}

08015716 <OsTraceDataEncode>:

UINT32 OsTraceDataEncode(UINT8 type, const TlvTable *table, UINT8 *src, UINT8 *dest, INT32 destLen)
{
 8015716:	b580      	push	{r7, lr}
 8015718:	b08a      	sub	sp, #40	; 0x28
 801571a:	af00      	add	r7, sp, #0
 801571c:	60b9      	str	r1, [r7, #8]
 801571e:	607a      	str	r2, [r7, #4]
 8015720:	603b      	str	r3, [r7, #0]
 8015722:	4603      	mov	r3, r0
 8015724:	73fb      	strb	r3, [r7, #15]
    UINT16 crc;
    INT32 len;
    INT32 tlvBufLen;
    UINT8 *tlvBuf = NULL;
 8015726:	2300      	movs	r3, #0
 8015728:	61bb      	str	r3, [r7, #24]

    TraceMsgTlvHead *head = (TraceMsgTlvHead *)dest;
 801572a:	683b      	ldr	r3, [r7, #0]
 801572c:	61fb      	str	r3, [r7, #28]
    tlvBufLen = destLen - sizeof(TraceMsgTlvHead);
 801572e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015730:	3b06      	subs	r3, #6
 8015732:	623b      	str	r3, [r7, #32]

    if ((tlvBufLen <= 0) || (table == NULL)) {
 8015734:	6a3b      	ldr	r3, [r7, #32]
 8015736:	2b00      	cmp	r3, #0
 8015738:	dd02      	ble.n	8015740 <OsTraceDataEncode+0x2a>
 801573a:	68bb      	ldr	r3, [r7, #8]
 801573c:	2b00      	cmp	r3, #0
 801573e:	d101      	bne.n	8015744 <OsTraceDataEncode+0x2e>
        return 0;
 8015740:	2300      	movs	r3, #0
 8015742:	e020      	b.n	8015786 <OsTraceDataEncode+0x70>
    }

    tlvBuf = dest + sizeof(TraceMsgTlvHead);
 8015744:	683b      	ldr	r3, [r7, #0]
 8015746:	3306      	adds	r3, #6
 8015748:	61bb      	str	r3, [r7, #24]
    len = OsTlvEncode(table, src, tlvBuf, tlvBufLen);
 801574a:	6a3b      	ldr	r3, [r7, #32]
 801574c:	69ba      	ldr	r2, [r7, #24]
 801574e:	6879      	ldr	r1, [r7, #4]
 8015750:	68b8      	ldr	r0, [r7, #8]
 8015752:	f7ff ffab 	bl	80156ac <OsTlvEncode>
 8015756:	4603      	mov	r3, r0
 8015758:	627b      	str	r3, [r7, #36]	; 0x24
    crc = CalcCrc16(tlvBuf, len);
 801575a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801575c:	4619      	mov	r1, r3
 801575e:	69b8      	ldr	r0, [r7, #24]
 8015760:	f7ff ff48 	bl	80155f4 <CalcCrc16>
 8015764:	4603      	mov	r3, r0
 8015766:	82fb      	strh	r3, [r7, #22]

    head->magicNum = TRACE_TLV_MSG_HEAD;
 8015768:	69fb      	ldr	r3, [r7, #28]
 801576a:	22ff      	movs	r2, #255	; 0xff
 801576c:	701a      	strb	r2, [r3, #0]
    head->msgType  = type;
 801576e:	69fb      	ldr	r3, [r7, #28]
 8015770:	7bfa      	ldrb	r2, [r7, #15]
 8015772:	705a      	strb	r2, [r3, #1]
    head->len      = len;
 8015774:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015776:	b29a      	uxth	r2, r3
 8015778:	69fb      	ldr	r3, [r7, #28]
 801577a:	805a      	strh	r2, [r3, #2]
    head->crc      = crc;
 801577c:	69fb      	ldr	r3, [r7, #28]
 801577e:	8afa      	ldrh	r2, [r7, #22]
 8015780:	809a      	strh	r2, [r3, #4]
    return len + sizeof(TraceMsgTlvHead);
 8015782:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015784:	3306      	adds	r3, #6
}
 8015786:	4618      	mov	r0, r3
 8015788:	3728      	adds	r7, #40	; 0x28
 801578a:	46bd      	mov	sp, r7
 801578c:	bd80      	pop	{r7, pc}

0801578e <OsTaskExit>:
                 "\tpop {fp, pc}\n");
}
#endif

LITE_OS_SEC_TEXT_MINOR VOID OsTaskExit(VOID)
{
 801578e:	b480      	push	{r7}
 8015790:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 8015792:	b672      	cpsid	i
}
 8015794:	bf00      	nop
    __disable_irq();
    while (1) { }
 8015796:	e7fe      	b.n	8015796 <OsTaskExit+0x8>

08015798 <OsTaskStackInit>:
}

LITE_OS_SEC_TEXT_INIT VOID *OsTaskStackInit(UINT32 taskId, UINT32 stackSize, VOID *topStack)
{
 8015798:	b580      	push	{r7, lr}
 801579a:	b086      	sub	sp, #24
 801579c:	af00      	add	r7, sp, #0
 801579e:	60f8      	str	r0, [r7, #12]
 80157a0:	60b9      	str	r1, [r7, #8]
 80157a2:	607a      	str	r2, [r7, #4]
    TaskContext *taskContext = NULL;
 80157a4:	2300      	movs	r3, #0
 80157a6:	617b      	str	r3, [r7, #20]

    OsStackInit(topStack, stackSize);
 80157a8:	68b9      	ldr	r1, [r7, #8]
 80157aa:	6878      	ldr	r0, [r7, #4]
 80157ac:	f7f4 f9aa 	bl	8009b04 <OsStackInit>
    taskContext = (TaskContext *)(((UINTPTR)topStack + stackSize) - sizeof(TaskContext));
 80157b0:	687a      	ldr	r2, [r7, #4]
 80157b2:	68bb      	ldr	r3, [r7, #8]
 80157b4:	4413      	add	r3, r2
 80157b6:	3b48      	subs	r3, #72	; 0x48
 80157b8:	617b      	str	r3, [r7, #20]

#ifdef LOSCFG_ARCH_FPU_ENABLE
    taskContext->excReturn = 0xFFFFFFFD;
 80157ba:	697b      	ldr	r3, [r7, #20]
 80157bc:	f06f 0202 	mvn.w	r2, #2
 80157c0:	625a      	str	r2, [r3, #36]	; 0x24
#endif

    taskContext->R4  = 0x04040404L;
 80157c2:	697b      	ldr	r3, [r7, #20]
 80157c4:	f04f 3204 	mov.w	r2, #67372036	; 0x4040404
 80157c8:	601a      	str	r2, [r3, #0]
    taskContext->R5  = 0x05050505L;
 80157ca:	697b      	ldr	r3, [r7, #20]
 80157cc:	f04f 3205 	mov.w	r2, #84215045	; 0x5050505
 80157d0:	605a      	str	r2, [r3, #4]
    taskContext->R6  = 0x06060606L;
 80157d2:	697b      	ldr	r3, [r7, #20]
 80157d4:	f04f 3206 	mov.w	r2, #101058054	; 0x6060606
 80157d8:	609a      	str	r2, [r3, #8]
    taskContext->R7  = 0x07070707L;
 80157da:	697b      	ldr	r3, [r7, #20]
 80157dc:	f04f 3207 	mov.w	r2, #117901063	; 0x7070707
 80157e0:	60da      	str	r2, [r3, #12]
    taskContext->R8  = 0x08080808L;
 80157e2:	697b      	ldr	r3, [r7, #20]
 80157e4:	f04f 3208 	mov.w	r2, #134744072	; 0x8080808
 80157e8:	611a      	str	r2, [r3, #16]
    taskContext->R9  = 0x09090909L;
 80157ea:	697b      	ldr	r3, [r7, #20]
 80157ec:	f04f 3209 	mov.w	r2, #151587081	; 0x9090909
 80157f0:	615a      	str	r2, [r3, #20]
    taskContext->R10 = 0x10101010L;
 80157f2:	697b      	ldr	r3, [r7, #20]
 80157f4:	f04f 3210 	mov.w	r2, #269488144	; 0x10101010
 80157f8:	619a      	str	r2, [r3, #24]
    taskContext->R11 = 0x11111111L;
 80157fa:	697b      	ldr	r3, [r7, #20]
 80157fc:	f04f 3211 	mov.w	r2, #286331153	; 0x11111111
 8015800:	61da      	str	r2, [r3, #28]
    taskContext->PriMask = 0;
 8015802:	697b      	ldr	r3, [r7, #20]
 8015804:	2200      	movs	r2, #0
 8015806:	621a      	str	r2, [r3, #32]
    taskContext->R0  = taskId;
 8015808:	697b      	ldr	r3, [r7, #20]
 801580a:	68fa      	ldr	r2, [r7, #12]
 801580c:	629a      	str	r2, [r3, #40]	; 0x28
    taskContext->R1  = 0x01010101L;
 801580e:	697b      	ldr	r3, [r7, #20]
 8015810:	f04f 3201 	mov.w	r2, #16843009	; 0x1010101
 8015814:	62da      	str	r2, [r3, #44]	; 0x2c
    taskContext->R2  = 0x02020202L;
 8015816:	697b      	ldr	r3, [r7, #20]
 8015818:	f04f 3202 	mov.w	r2, #33686018	; 0x2020202
 801581c:	631a      	str	r2, [r3, #48]	; 0x30
    taskContext->R3  = 0x03030303L;
 801581e:	697b      	ldr	r3, [r7, #20]
 8015820:	f04f 3203 	mov.w	r2, #50529027	; 0x3030303
 8015824:	635a      	str	r2, [r3, #52]	; 0x34
    taskContext->R12 = 0x12121212L;
 8015826:	697b      	ldr	r3, [r7, #20]
 8015828:	f04f 3212 	mov.w	r2, #303174162	; 0x12121212
 801582c:	639a      	str	r2, [r3, #56]	; 0x38
    taskContext->LR  = (UINT32)OsTaskExit;
 801582e:	4a07      	ldr	r2, [pc, #28]	; (801584c <OsTaskStackInit+0xb4>)
 8015830:	697b      	ldr	r3, [r7, #20]
 8015832:	63da      	str	r2, [r3, #60]	; 0x3c
    taskContext->PC  = (UINT32)OsTaskEntry;
 8015834:	4a06      	ldr	r2, [pc, #24]	; (8015850 <OsTaskStackInit+0xb8>)
 8015836:	697b      	ldr	r3, [r7, #20]
 8015838:	641a      	str	r2, [r3, #64]	; 0x40
    taskContext->xPSR = 0x01000000L;
 801583a:	697b      	ldr	r3, [r7, #20]
 801583c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8015840:	645a      	str	r2, [r3, #68]	; 0x44

    return (VOID *)taskContext;
 8015842:	697b      	ldr	r3, [r7, #20]
}
 8015844:	4618      	mov	r0, r3
 8015846:	3718      	adds	r7, #24
 8015848:	46bd      	mov	sp, r7
 801584a:	bd80      	pop	{r7, pc}
 801584c:	0801578f 	.word	0x0801578f
 8015850:	080031ed 	.word	0x080031ed

08015854 <ArchStackGuardInit>:
 * value to replace the function implementation template shown as below.
 */
#pragma GCC push_options
#pragma GCC optimize ("-fno-stack-protector")
LITE_OS_SEC_TEXT_INIT WEAK VOID ArchStackGuardInit(VOID)
{
 8015854:	b480      	push	{r7}
 8015856:	af00      	add	r7, sp, #0
}
 8015858:	bf00      	nop
 801585a:	46bd      	mov	sp, r7
 801585c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015860:	4770      	bx	lr

08015862 <ArchGetSp>:
{
 8015862:	b480      	push	{r7}
 8015864:	b083      	sub	sp, #12
 8015866:	af00      	add	r7, sp, #0
    __asm__ __volatile__("mov %0, sp\n" : "=r"(regSp));
 8015868:	466b      	mov	r3, sp
 801586a:	607b      	str	r3, [r7, #4]
    return regSp;
 801586c:	687b      	ldr	r3, [r7, #4]
}
 801586e:	4618      	mov	r0, r3
 8015870:	370c      	adds	r7, #12
 8015872:	46bd      	mov	sp, r7
 8015874:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015878:	4770      	bx	lr

0801587a <ArchGetPsp>:
{
 801587a:	b480      	push	{r7}
 801587c:	b083      	sub	sp, #12
 801587e:	af00      	add	r7, sp, #0
    __asm__ __volatile__("MRS %0, psp\n" : "=r"(regPsp));
 8015880:	f3ef 8309 	mrs	r3, PSP
 8015884:	607b      	str	r3, [r7, #4]
    return regPsp;
 8015886:	687b      	ldr	r3, [r7, #4]
}
 8015888:	4618      	mov	r0, r3
 801588a:	370c      	adds	r7, #12
 801588c:	46bd      	mov	sp, r7
 801588e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015892:	4770      	bx	lr

08015894 <ArchCurrTaskGet>:
{
 8015894:	b480      	push	{r7}
 8015896:	af00      	add	r7, sp, #0
    return g_runTask;
 8015898:	4b03      	ldr	r3, [pc, #12]	; (80158a8 <ArchCurrTaskGet+0x14>)
 801589a:	681b      	ldr	r3, [r3, #0]
}
 801589c:	4618      	mov	r0, r3
 801589e:	46bd      	mov	sp, r7
 80158a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80158a4:	4770      	bx	lr
 80158a6:	bf00      	nop
 80158a8:	200033bc 	.word	0x200033bc

080158ac <OsCurrTaskGet>:
{
 80158ac:	b580      	push	{r7, lr}
 80158ae:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 80158b0:	f7ff fff0 	bl	8015894 <ArchCurrTaskGet>
 80158b4:	4603      	mov	r3, r0
}
 80158b6:	4618      	mov	r0, r3
 80158b8:	bd80      	pop	{r7, pc}
	...

080158bc <OsExcSysInfo>:
    "fault in task",
    "fault in interrupt",
};

STATIC VOID OsExcSysInfo(VOID)
{
 80158bc:	b580      	push	{r7, lr}
 80158be:	b084      	sub	sp, #16
 80158c0:	af02      	add	r7, sp, #8
    LosTaskCB *runTask = OsCurrTaskGet();
 80158c2:	f7ff fff3 	bl	80158ac <OsCurrTaskGet>
 80158c6:	6078      	str	r0, [r7, #4]

    if (runTask != NULL) {
 80158c8:	687b      	ldr	r3, [r7, #4]
 80158ca:	2b00      	cmp	r3, #0
 80158cc:	d00c      	beq.n	80158e8 <OsExcSysInfo+0x2c>
        PrintExcInfo("TaskName = %s\n"
 80158ce:	687b      	ldr	r3, [r7, #4]
 80158d0:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80158d2:	687b      	ldr	r3, [r7, #4]
 80158d4:	695a      	ldr	r2, [r3, #20]
 80158d6:	687b      	ldr	r3, [r7, #4]
 80158d8:	68d8      	ldr	r0, [r3, #12]
 80158da:	4b05      	ldr	r3, [pc, #20]	; (80158f0 <OsExcSysInfo+0x34>)
 80158dc:	681b      	ldr	r3, [r3, #0]
 80158de:	9300      	str	r3, [sp, #0]
 80158e0:	4603      	mov	r3, r0
 80158e2:	4804      	ldr	r0, [pc, #16]	; (80158f4 <OsExcSysInfo+0x38>)
 80158e4:	f7ee ff16 	bl	8004714 <PrintExcInfo>
                     runTask->taskName,
                     runTask->taskId,
                     runTask->stackSize,
                     m_aucSysMem0);
    }
}
 80158e8:	bf00      	nop
 80158ea:	3708      	adds	r7, #8
 80158ec:	46bd      	mov	sp, r7
 80158ee:	bd80      	pop	{r7, pc}
 80158f0:	200021b4 	.word	0x200021b4
 80158f4:	08022d90 	.word	0x08022d90

080158f8 <OsExcInfoDisplay>:

LITE_OS_SEC_TEXT_INIT VOID OsExcInfoDisplay(const ExcInfo *exc, const ExcContext *excBufAddr)
{
 80158f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80158fa:	b0a5      	sub	sp, #148	; 0x94
 80158fc:	af14      	add	r7, sp, #80	; 0x50
 80158fe:	63f8      	str	r0, [r7, #60]	; 0x3c
 8015900:	63b9      	str	r1, [r7, #56]	; 0x38
                 "PriMask    = 0x%x\n"
                 "SP         = 0x%x\n"
                 "LR         = 0x%x\n"
                 "PC         = 0x%x\n"
                 "xPSR       = 0x%x\n",
                 g_phaseName[exc->phase], exc->type, exc->faultAddr, exc->intNumOrTaskId, excBufAddr->R0,
 8015902:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015904:	881b      	ldrh	r3, [r3, #0]
 8015906:	461a      	mov	r2, r3
    PrintExcInfo("Phase      = %s\n"
 8015908:	4b33      	ldr	r3, [pc, #204]	; (80159d8 <OsExcInfoDisplay+0xe0>)
 801590a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801590e:	637b      	str	r3, [r7, #52]	; 0x34
                 g_phaseName[exc->phase], exc->type, exc->faultAddr, exc->intNumOrTaskId, excBufAddr->R0,
 8015910:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015912:	885b      	ldrh	r3, [r3, #2]
    PrintExcInfo("Phase      = %s\n"
 8015914:	469c      	mov	ip, r3
 8015916:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015918:	685a      	ldr	r2, [r3, #4]
 801591a:	633a      	str	r2, [r7, #48]	; 0x30
 801591c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801591e:	6898      	ldr	r0, [r3, #8]
 8015920:	62f8      	str	r0, [r7, #44]	; 0x2c
 8015922:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015924:	6e9c      	ldr	r4, [r3, #104]	; 0x68
 8015926:	62bc      	str	r4, [r7, #40]	; 0x28
 8015928:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801592a:	6edd      	ldr	r5, [r3, #108]	; 0x6c
 801592c:	627d      	str	r5, [r7, #36]	; 0x24
 801592e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015930:	6f1e      	ldr	r6, [r3, #112]	; 0x70
 8015932:	623e      	str	r6, [r7, #32]
 8015934:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015936:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8015938:	61fa      	str	r2, [r7, #28]
 801593a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801593c:	6c19      	ldr	r1, [r3, #64]	; 0x40
 801593e:	61b9      	str	r1, [r7, #24]
 8015940:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015942:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015944:	617b      	str	r3, [r7, #20]
 8015946:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015948:	6c98      	ldr	r0, [r3, #72]	; 0x48
 801594a:	6138      	str	r0, [r7, #16]
 801594c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801594e:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
 8015950:	60fc      	str	r4, [r7, #12]
 8015952:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015954:	6d1d      	ldr	r5, [r3, #80]	; 0x50
 8015956:	60bd      	str	r5, [r7, #8]
 8015958:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801595a:	6d5e      	ldr	r6, [r3, #84]	; 0x54
 801595c:	607e      	str	r6, [r7, #4]
 801595e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015960:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8015962:	603a      	str	r2, [r7, #0]
 8015964:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015966:	6dde      	ldr	r6, [r3, #92]	; 0x5c
 8015968:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801596a:	6f9d      	ldr	r5, [r3, #120]	; 0x78
 801596c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801596e:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 8015970:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015972:	6e58      	ldr	r0, [r3, #100]	; 0x64
 8015974:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015976:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 8015978:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801597a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 801597e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015980:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8015984:	9312      	str	r3, [sp, #72]	; 0x48
 8015986:	9211      	str	r2, [sp, #68]	; 0x44
 8015988:	9110      	str	r1, [sp, #64]	; 0x40
 801598a:	900f      	str	r0, [sp, #60]	; 0x3c
 801598c:	940e      	str	r4, [sp, #56]	; 0x38
 801598e:	950d      	str	r5, [sp, #52]	; 0x34
 8015990:	960c      	str	r6, [sp, #48]	; 0x30
 8015992:	683a      	ldr	r2, [r7, #0]
 8015994:	920b      	str	r2, [sp, #44]	; 0x2c
 8015996:	687e      	ldr	r6, [r7, #4]
 8015998:	960a      	str	r6, [sp, #40]	; 0x28
 801599a:	68bd      	ldr	r5, [r7, #8]
 801599c:	9509      	str	r5, [sp, #36]	; 0x24
 801599e:	68fc      	ldr	r4, [r7, #12]
 80159a0:	9408      	str	r4, [sp, #32]
 80159a2:	6938      	ldr	r0, [r7, #16]
 80159a4:	9007      	str	r0, [sp, #28]
 80159a6:	697b      	ldr	r3, [r7, #20]
 80159a8:	9306      	str	r3, [sp, #24]
 80159aa:	69b9      	ldr	r1, [r7, #24]
 80159ac:	9105      	str	r1, [sp, #20]
 80159ae:	69fa      	ldr	r2, [r7, #28]
 80159b0:	9204      	str	r2, [sp, #16]
 80159b2:	6a3e      	ldr	r6, [r7, #32]
 80159b4:	9603      	str	r6, [sp, #12]
 80159b6:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 80159b8:	9502      	str	r5, [sp, #8]
 80159ba:	6abc      	ldr	r4, [r7, #40]	; 0x28
 80159bc:	9401      	str	r4, [sp, #4]
 80159be:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80159c0:	9000      	str	r0, [sp, #0]
 80159c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80159c4:	4662      	mov	r2, ip
 80159c6:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80159c8:	4804      	ldr	r0, [pc, #16]	; (80159dc <OsExcInfoDisplay+0xe4>)
 80159ca:	f7ee fea3 	bl	8004714 <PrintExcInfo>
                 excBufAddr->R1, excBufAddr->R2, excBufAddr->R3, excBufAddr->R4, excBufAddr->R5,
                 excBufAddr->R6, excBufAddr->R7, excBufAddr->R8, excBufAddr->R9,
                 excBufAddr->R10, excBufAddr->R11, excBufAddr->R12, excBufAddr->PriMask,
                 excBufAddr->SP, excBufAddr->LR, excBufAddr->PC, excBufAddr->xPSR);
}
 80159ce:	bf00      	nop
 80159d0:	3744      	adds	r7, #68	; 0x44
 80159d2:	46bd      	mov	sp, r7
 80159d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80159d6:	bf00      	nop
 80159d8:	2000052c 	.word	0x2000052c
 80159dc:	08022dd8 	.word	0x08022dd8

080159e0 <OsExcHandleEntry>:

LITE_OS_SEC_TEXT_INIT VOID OsExcHandleEntry(UINT32 excType, UINT32 faultAddr, UINT32 pid,
                                            const ExcContext *excBufAddr)
{
 80159e0:	b580      	push	{r7, lr}
 80159e2:	b086      	sub	sp, #24
 80159e4:	af00      	add	r7, sp, #0
 80159e6:	60f8      	str	r0, [r7, #12]
 80159e8:	60b9      	str	r1, [r7, #8]
 80159ea:	607a      	str	r2, [r7, #4]
 80159ec:	603b      	str	r3, [r7, #0]
    ExcContext *BufAddr = NULL;
 80159ee:	2300      	movs	r3, #0
 80159f0:	617b      	str	r3, [r7, #20]
    UINT16 tmpFlag = (excType >> MASK_16_BIT) & OS_NULL_SHORT; /* 2:in intrrupt,1:faul addr valid */
 80159f2:	68fb      	ldr	r3, [r7, #12]
 80159f4:	0c1b      	lsrs	r3, r3, #16
 80159f6:	827b      	strh	r3, [r7, #18]
    g_curNestCount++;
 80159f8:	4b31      	ldr	r3, [pc, #196]	; (8015ac0 <OsExcHandleEntry+0xe0>)
 80159fa:	681b      	ldr	r3, [r3, #0]
 80159fc:	3301      	adds	r3, #1
 80159fe:	4a30      	ldr	r2, [pc, #192]	; (8015ac0 <OsExcHandleEntry+0xe0>)
 8015a00:	6013      	str	r3, [r2, #0]
    g_excInfo.nestCnt = (UINT16)g_curNestCount;
 8015a02:	4b2f      	ldr	r3, [pc, #188]	; (8015ac0 <OsExcHandleEntry+0xe0>)
 8015a04:	681b      	ldr	r3, [r3, #0]
 8015a06:	b29a      	uxth	r2, r3
 8015a08:	4b2e      	ldr	r3, [pc, #184]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a0a:	819a      	strh	r2, [r3, #12]

    g_excInfo.type = excType & OS_NULL_SHORT;
 8015a0c:	68fb      	ldr	r3, [r7, #12]
 8015a0e:	b29a      	uxth	r2, r3
 8015a10:	4b2c      	ldr	r3, [pc, #176]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a12:	805a      	strh	r2, [r3, #2]

    if (tmpFlag & OS_EXC_FLAG_FAULTADDR_VALID) {
 8015a14:	8a7b      	ldrh	r3, [r7, #18]
 8015a16:	f003 0301 	and.w	r3, r3, #1
 8015a1a:	2b00      	cmp	r3, #0
 8015a1c:	d003      	beq.n	8015a26 <OsExcHandleEntry+0x46>
        g_excInfo.faultAddr = faultAddr;
 8015a1e:	4a29      	ldr	r2, [pc, #164]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a20:	68bb      	ldr	r3, [r7, #8]
 8015a22:	6053      	str	r3, [r2, #4]
 8015a24:	e003      	b.n	8015a2e <OsExcHandleEntry+0x4e>
    } else {
        g_excInfo.faultAddr = OS_EXC_IMPRECISE_ACCESS_ADDR;
 8015a26:	4b27      	ldr	r3, [pc, #156]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a28:	f04f 32ab 	mov.w	r2, #2880154539	; 0xabababab
 8015a2c:	605a      	str	r2, [r3, #4]
    }

    if (ArchCurrTaskGet() != NULL) {
 8015a2e:	f7ff ff31 	bl	8015894 <ArchCurrTaskGet>
 8015a32:	4603      	mov	r3, r0
 8015a34:	2b00      	cmp	r3, #0
 8015a36:	d017      	beq.n	8015a68 <OsExcHandleEntry+0x88>
        if (tmpFlag & OS_EXC_FLAG_IN_HWI) {
 8015a38:	8a7b      	ldrh	r3, [r7, #18]
 8015a3a:	f003 0302 	and.w	r3, r3, #2
 8015a3e:	2b00      	cmp	r3, #0
 8015a40:	d006      	beq.n	8015a50 <OsExcHandleEntry+0x70>
            g_excInfo.phase = OS_EXC_IN_HWI;
 8015a42:	4b20      	ldr	r3, [pc, #128]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a44:	2202      	movs	r2, #2
 8015a46:	801a      	strh	r2, [r3, #0]
            g_excInfo.intNumOrTaskId = pid;
 8015a48:	4a1e      	ldr	r2, [pc, #120]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a4a:	687b      	ldr	r3, [r7, #4]
 8015a4c:	6093      	str	r3, [r2, #8]
 8015a4e:	e012      	b.n	8015a76 <OsExcHandleEntry+0x96>
        } else {
            g_excInfo.phase = OS_EXC_IN_TASK;
 8015a50:	4b1c      	ldr	r3, [pc, #112]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a52:	2201      	movs	r2, #1
 8015a54:	801a      	strh	r2, [r3, #0]
            g_excInfo.intNumOrTaskId = ((LosTaskCB *)ArchCurrTaskGet())->taskId;
 8015a56:	f7ff ff1d 	bl	8015894 <ArchCurrTaskGet>
 8015a5a:	4603      	mov	r3, r0
 8015a5c:	695b      	ldr	r3, [r3, #20]
 8015a5e:	4a19      	ldr	r2, [pc, #100]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a60:	6093      	str	r3, [r2, #8]
            OsExcSysInfo();
 8015a62:	f7ff ff2b 	bl	80158bc <OsExcSysInfo>
 8015a66:	e006      	b.n	8015a76 <OsExcHandleEntry+0x96>
        }
    } else {
        g_excInfo.phase = OS_EXC_IN_INIT;
 8015a68:	4b16      	ldr	r3, [pc, #88]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a6a:	2200      	movs	r2, #0
 8015a6c:	801a      	strh	r2, [r3, #0]
        g_excInfo.intNumOrTaskId = OS_NULL_INT;
 8015a6e:	4b15      	ldr	r3, [pc, #84]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a70:	f04f 32ff 	mov.w	r2, #4294967295
 8015a74:	609a      	str	r2, [r3, #8]
    }

    if (excType & OS_EXC_FLAG_NO_FLOAT) {
 8015a76:	68fb      	ldr	r3, [r7, #12]
 8015a78:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8015a7c:	2b00      	cmp	r3, #0
 8015a7e:	d004      	beq.n	8015a8a <OsExcHandleEntry+0xaa>
        g_excInfo.context = (ExcContext *)((CHAR *)excBufAddr - LOS_OFF_SET_OF(ExcContext, R4));
 8015a80:	683b      	ldr	r3, [r7, #0]
 8015a82:	3b40      	subs	r3, #64	; 0x40
 8015a84:	4a0f      	ldr	r2, [pc, #60]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a86:	6113      	str	r3, [r2, #16]
 8015a88:	e002      	b.n	8015a90 <OsExcHandleEntry+0xb0>
    } else {
        g_excInfo.context = (ExcContext *)excBufAddr;
 8015a8a:	4a0e      	ldr	r2, [pc, #56]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a8c:	683b      	ldr	r3, [r7, #0]
 8015a8e:	6113      	str	r3, [r2, #16]
    }

    if (g_excInfo.phase == OS_EXC_IN_TASK) {
 8015a90:	4b0c      	ldr	r3, [pc, #48]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015a92:	881b      	ldrh	r3, [r3, #0]
 8015a94:	2b01      	cmp	r3, #1
 8015a96:	d105      	bne.n	8015aa4 <OsExcHandleEntry+0xc4>
        BufAddr =  (ExcContext *)(ArchGetPsp() - OFFSET_OF_PSP);
 8015a98:	f7ff feef 	bl	801587a <ArchGetPsp>
 8015a9c:	4603      	mov	r3, r0
 8015a9e:	3b28      	subs	r3, #40	; 0x28
 8015aa0:	617b      	str	r3, [r7, #20]
 8015aa2:	e002      	b.n	8015aaa <OsExcHandleEntry+0xca>
    } else {
        BufAddr = g_excInfo.context;
 8015aa4:	4b07      	ldr	r3, [pc, #28]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015aa6:	691b      	ldr	r3, [r3, #16]
 8015aa8:	617b      	str	r3, [r7, #20]
    }

    OsExcInfoDisplay((const ExcInfo *)&g_excInfo, BufAddr);
 8015aaa:	6979      	ldr	r1, [r7, #20]
 8015aac:	4805      	ldr	r0, [pc, #20]	; (8015ac4 <OsExcHandleEntry+0xe4>)
 8015aae:	f7ff ff23 	bl	80158f8 <OsExcInfoDisplay>

#ifdef LOSCFG_BACKTRACE
    ArchBackTraceWithSp(BufAddr);
 8015ab2:	6978      	ldr	r0, [r7, #20]
 8015ab4:	f000 f9c8 	bl	8015e48 <ArchBackTraceWithSp>
#endif

#ifdef LOSCFG_KERNEL_TRACE
    OsTraceRecordDump(FALSE);
 8015ab8:	2000      	movs	r0, #0
 8015aba:	f7ff fc8d 	bl	80153d8 <OsTraceRecordDump>
#endif
    while (1) { }
 8015abe:	e7fe      	b.n	8015abe <OsExcHandleEntry+0xde>
 8015ac0:	200033c4 	.word	0x200033c4
 8015ac4:	20003778 	.word	0x20003778

08015ac8 <IsValidSP>:
}

#ifdef LOSCFG_BACKTRACE
/* this function is used to validate sp or validate the checking range start and end. */
STATIC INLINE BOOL IsValidSP(UINTPTR regSP, UINTPTR start, UINTPTR end)
{
 8015ac8:	b480      	push	{r7}
 8015aca:	b085      	sub	sp, #20
 8015acc:	af00      	add	r7, sp, #0
 8015ace:	60f8      	str	r0, [r7, #12]
 8015ad0:	60b9      	str	r1, [r7, #8]
 8015ad2:	607a      	str	r2, [r7, #4]
    return (regSP >= start) && (regSP < end);
 8015ad4:	68fa      	ldr	r2, [r7, #12]
 8015ad6:	68bb      	ldr	r3, [r7, #8]
 8015ad8:	429a      	cmp	r2, r3
 8015ada:	d305      	bcc.n	8015ae8 <IsValidSP+0x20>
 8015adc:	68fa      	ldr	r2, [r7, #12]
 8015ade:	687b      	ldr	r3, [r7, #4]
 8015ae0:	429a      	cmp	r2, r3
 8015ae2:	d201      	bcs.n	8015ae8 <IsValidSP+0x20>
 8015ae4:	2301      	movs	r3, #1
 8015ae6:	e000      	b.n	8015aea <IsValidSP+0x22>
 8015ae8:	2300      	movs	r3, #0
}
 8015aea:	4618      	mov	r0, r3
 8015aec:	3714      	adds	r7, #20
 8015aee:	46bd      	mov	sp, r7
 8015af0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015af4:	4770      	bx	lr
	...

08015af8 <FindSuitableStack>:

STATIC INLINE BOOL FindSuitableStack(UINTPTR *regSP, UINTPTR *start, UINTPTR *end)
{
 8015af8:	b580      	push	{r7, lr}
 8015afa:	b08a      	sub	sp, #40	; 0x28
 8015afc:	af00      	add	r7, sp, #0
 8015afe:	60f8      	str	r0, [r7, #12]
 8015b00:	60b9      	str	r1, [r7, #8]
 8015b02:	607a      	str	r2, [r7, #4]
    UINT32 index, topOfStack, stackBottom;
    BOOL found = FALSE;
 8015b04:	2300      	movs	r3, #0
 8015b06:	623b      	str	r3, [r7, #32]
    LosTaskCB *taskCB = NULL;
 8015b08:	2300      	movs	r3, #0
 8015b0a:	627b      	str	r3, [r7, #36]	; 0x24

    /* Search in the task stacks */
    for (index = 0; index < g_taskMaxNum; index++) {
 8015b0c:	2300      	movs	r3, #0
 8015b0e:	617b      	str	r3, [r7, #20]
 8015b10:	e028      	b.n	8015b64 <FindSuitableStack+0x6c>
        taskCB = OS_TCB_FROM_TID(index);
 8015b12:	4b27      	ldr	r3, [pc, #156]	; (8015bb0 <FindSuitableStack+0xb8>)
 8015b14:	6819      	ldr	r1, [r3, #0]
 8015b16:	697a      	ldr	r2, [r7, #20]
 8015b18:	4613      	mov	r3, r2
 8015b1a:	009b      	lsls	r3, r3, #2
 8015b1c:	4413      	add	r3, r2
 8015b1e:	015b      	lsls	r3, r3, #5
 8015b20:	440b      	add	r3, r1
 8015b22:	627b      	str	r3, [r7, #36]	; 0x24
        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 8015b24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015b26:	889b      	ldrh	r3, [r3, #4]
 8015b28:	f003 0301 	and.w	r3, r3, #1
 8015b2c:	2b00      	cmp	r3, #0
 8015b2e:	d115      	bne.n	8015b5c <FindSuitableStack+0x64>
            continue;
        }
        topOfStack = taskCB->topOfStack;
 8015b30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015b32:	691b      	ldr	r3, [r3, #16]
 8015b34:	61bb      	str	r3, [r7, #24]
        stackBottom = taskCB->topOfStack + taskCB->stackSize;
 8015b36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015b38:	691a      	ldr	r2, [r3, #16]
 8015b3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015b3c:	68db      	ldr	r3, [r3, #12]
 8015b3e:	4413      	add	r3, r2
 8015b40:	61fb      	str	r3, [r7, #28]

        if (IsValidSP(*regSP, topOfStack, stackBottom)) {
 8015b42:	68fb      	ldr	r3, [r7, #12]
 8015b44:	681b      	ldr	r3, [r3, #0]
 8015b46:	69fa      	ldr	r2, [r7, #28]
 8015b48:	69b9      	ldr	r1, [r7, #24]
 8015b4a:	4618      	mov	r0, r3
 8015b4c:	f7ff ffbc 	bl	8015ac8 <IsValidSP>
 8015b50:	4603      	mov	r3, r0
 8015b52:	2b00      	cmp	r3, #0
 8015b54:	d003      	beq.n	8015b5e <FindSuitableStack+0x66>
            found = TRUE;
 8015b56:	2301      	movs	r3, #1
 8015b58:	623b      	str	r3, [r7, #32]
            goto FOUND;
 8015b5a:	e009      	b.n	8015b70 <FindSuitableStack+0x78>
            continue;
 8015b5c:	bf00      	nop
    for (index = 0; index < g_taskMaxNum; index++) {
 8015b5e:	697b      	ldr	r3, [r7, #20]
 8015b60:	3301      	adds	r3, #1
 8015b62:	617b      	str	r3, [r7, #20]
 8015b64:	4b13      	ldr	r3, [pc, #76]	; (8015bb4 <FindSuitableStack+0xbc>)
 8015b66:	681b      	ldr	r3, [r3, #0]
 8015b68:	697a      	ldr	r2, [r7, #20]
 8015b6a:	429a      	cmp	r2, r3
 8015b6c:	d3d1      	bcc.n	8015b12 <FindSuitableStack+0x1a>
        }
    }

FOUND:
 8015b6e:	bf00      	nop
    if (found == TRUE) {
 8015b70:	6a3b      	ldr	r3, [r7, #32]
 8015b72:	2b01      	cmp	r3, #1
 8015b74:	d106      	bne.n	8015b84 <FindSuitableStack+0x8c>
        *start = topOfStack;
 8015b76:	68bb      	ldr	r3, [r7, #8]
 8015b78:	69ba      	ldr	r2, [r7, #24]
 8015b7a:	601a      	str	r2, [r3, #0]
        *end = stackBottom;
 8015b7c:	687b      	ldr	r3, [r7, #4]
 8015b7e:	69fa      	ldr	r2, [r7, #28]
 8015b80:	601a      	str	r2, [r3, #0]
 8015b82:	e010      	b.n	8015ba6 <FindSuitableStack+0xae>
    } else if (*regSP < g_estack) {
 8015b84:	68fb      	ldr	r3, [r7, #12]
 8015b86:	681b      	ldr	r3, [r3, #0]
 8015b88:	4a0b      	ldr	r2, [pc, #44]	; (8015bb8 <FindSuitableStack+0xc0>)
 8015b8a:	6812      	ldr	r2, [r2, #0]
 8015b8c:	4293      	cmp	r3, r2
 8015b8e:	d20a      	bcs.n	8015ba6 <FindSuitableStack+0xae>
        *start = *regSP;
 8015b90:	68fb      	ldr	r3, [r7, #12]
 8015b92:	681a      	ldr	r2, [r3, #0]
 8015b94:	68bb      	ldr	r3, [r7, #8]
 8015b96:	601a      	str	r2, [r3, #0]
        *end = g_estack;
 8015b98:	4b07      	ldr	r3, [pc, #28]	; (8015bb8 <FindSuitableStack+0xc0>)
 8015b9a:	681b      	ldr	r3, [r3, #0]
 8015b9c:	461a      	mov	r2, r3
 8015b9e:	687b      	ldr	r3, [r7, #4]
 8015ba0:	601a      	str	r2, [r3, #0]
        found = TRUE;
 8015ba2:	2301      	movs	r3, #1
 8015ba4:	623b      	str	r3, [r7, #32]
    }

    return found;
 8015ba6:	6a3b      	ldr	r3, [r7, #32]
}
 8015ba8:	4618      	mov	r0, r3
 8015baa:	3728      	adds	r7, #40	; 0x28
 8015bac:	46bd      	mov	sp, r7
 8015bae:	bd80      	pop	{r7, pc}
 8015bb0:	200036c4 	.word	0x200036c4
 8015bb4:	200036d8 	.word	0x200036d8
 8015bb8:	080236b0 	.word	0x080236b0

08015bbc <LoopUntilEntry>:

UINTPTR LoopUntilEntry(UINTPTR addr)
{
 8015bbc:	b480      	push	{r7}
 8015bbe:	b083      	sub	sp, #12
 8015bc0:	af00      	add	r7, sp, #0
 8015bc2:	6078      	str	r0, [r7, #4]
    while (addr > (UINTPTR)g_textStart) {
 8015bc4:	e00e      	b.n	8015be4 <LoopUntilEntry+0x28>
        if (((*((UINT16 *)addr) >> HIGH_8_OFFSET) == PUSH_MASK_WITH_LR) ||
 8015bc6:	687b      	ldr	r3, [r7, #4]
 8015bc8:	881b      	ldrh	r3, [r3, #0]
 8015bca:	0a1b      	lsrs	r3, r3, #8
 8015bcc:	b29b      	uxth	r3, r3
 8015bce:	2bb5      	cmp	r3, #181	; 0xb5
 8015bd0:	d00e      	beq.n	8015bf0 <LoopUntilEntry+0x34>
            ((*((UINT16 *)addr) >> HIGH_8_OFFSET) == PUSH_MASK)) {
 8015bd2:	687b      	ldr	r3, [r7, #4]
 8015bd4:	881b      	ldrh	r3, [r3, #0]
 8015bd6:	0a1b      	lsrs	r3, r3, #8
 8015bd8:	b29b      	uxth	r3, r3
        if (((*((UINT16 *)addr) >> HIGH_8_OFFSET) == PUSH_MASK_WITH_LR) ||
 8015bda:	2bb4      	cmp	r3, #180	; 0xb4
 8015bdc:	d008      	beq.n	8015bf0 <LoopUntilEntry+0x34>
            break;
        }
        addr -= THUM_OFFSET;
 8015bde:	687b      	ldr	r3, [r7, #4]
 8015be0:	3b02      	subs	r3, #2
 8015be2:	607b      	str	r3, [r7, #4]
    while (addr > (UINTPTR)g_textStart) {
 8015be4:	4b06      	ldr	r3, [pc, #24]	; (8015c00 <LoopUntilEntry+0x44>)
 8015be6:	681b      	ldr	r3, [r3, #0]
 8015be8:	461a      	mov	r2, r3
 8015bea:	687b      	ldr	r3, [r7, #4]
 8015bec:	4293      	cmp	r3, r2
 8015bee:	d8ea      	bhi.n	8015bc6 <LoopUntilEntry+0xa>
    }

    return addr;
 8015bf0:	687b      	ldr	r3, [r7, #4]
}
 8015bf2:	4618      	mov	r0, r3
 8015bf4:	370c      	adds	r7, #12
 8015bf6:	46bd      	mov	sp, r7
 8015bf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015bfc:	4770      	bx	lr
 8015bfe:	bf00      	nop
 8015c00:	080236a8 	.word	0x080236a8

08015c04 <CalculateBLTargetAddress>:

UINTPTR CalculateBLTargetAddress(UINTPTR bl)
{
 8015c04:	b480      	push	{r7}
 8015c06:	b087      	sub	sp, #28
 8015c08:	af00      	add	r7, sp, #0
 8015c0a:	6078      	str	r0, [r7, #4]
    UINTPTR target;
    UINT32 off0, off1, off;

    if (*(UINT16 *)bl & SIGN_BIT_MASK) {
 8015c0c:	687b      	ldr	r3, [r7, #4]
 8015c0e:	881b      	ldrh	r3, [r3, #0]
 8015c10:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8015c14:	2b00      	cmp	r3, #0
 8015c16:	d00b      	beq.n	8015c30 <CalculateBLTargetAddress+0x2c>
        off1 = *(UINT16 *)bl & LOW_11_BITS_MASK;
 8015c18:	687b      	ldr	r3, [r7, #4]
 8015c1a:	881b      	ldrh	r3, [r3, #0]
 8015c1c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8015c20:	613b      	str	r3, [r7, #16]
        off0 = *(UINT16 *)(bl + MASK_OFFSET) & LOW_11_BITS_MASK;
 8015c22:	687b      	ldr	r3, [r7, #4]
 8015c24:	3302      	adds	r3, #2
 8015c26:	881b      	ldrh	r3, [r3, #0]
 8015c28:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8015c2c:	60fb      	str	r3, [r7, #12]
 8015c2e:	e00a      	b.n	8015c46 <CalculateBLTargetAddress+0x42>
    } else {
        off0 = *(UINT16 *)bl & LOW_11_BITS_MASK;
 8015c30:	687b      	ldr	r3, [r7, #4]
 8015c32:	881b      	ldrh	r3, [r3, #0]
 8015c34:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8015c38:	60fb      	str	r3, [r7, #12]
        off1 = *(UINT16 *)(bl + MASK_OFFSET) & LOW_11_BITS_MASK;
 8015c3a:	687b      	ldr	r3, [r7, #4]
 8015c3c:	3302      	adds	r3, #2
 8015c3e:	881b      	ldrh	r3, [r3, #0]
 8015c40:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8015c44:	613b      	str	r3, [r7, #16]
    }
    off = (off0 << HIGH_OFFSET_NUMBER) + (off1 << LOW_OFFSET_NUMBER);
 8015c46:	68fb      	ldr	r3, [r7, #12]
 8015c48:	031a      	lsls	r2, r3, #12
 8015c4a:	693b      	ldr	r3, [r7, #16]
 8015c4c:	005b      	lsls	r3, r3, #1
 8015c4e:	4413      	add	r3, r2
 8015c50:	617b      	str	r3, [r7, #20]
    if (off & SIGN_BIT_MASK) {
 8015c52:	697b      	ldr	r3, [r7, #20]
 8015c54:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8015c58:	2b00      	cmp	r3, #0
 8015c5a:	d008      	beq.n	8015c6e <CalculateBLTargetAddress+0x6a>
        target = bl + BL_CMD_OFFSET - ((~(off - 1)) & 0x7FFFFF); // 0x7FFFFF : offset mask
 8015c5c:	697b      	ldr	r3, [r7, #20]
 8015c5e:	425b      	negs	r3, r3
 8015c60:	f3c3 0316 	ubfx	r3, r3, #0, #23
 8015c64:	687a      	ldr	r2, [r7, #4]
 8015c66:	1ad3      	subs	r3, r2, r3
 8015c68:	3304      	adds	r3, #4
 8015c6a:	60bb      	str	r3, [r7, #8]
 8015c6c:	e004      	b.n	8015c78 <CalculateBLTargetAddress+0x74>
    } else {
        target = bl + BL_CMD_OFFSET + off;
 8015c6e:	687a      	ldr	r2, [r7, #4]
 8015c70:	697b      	ldr	r3, [r7, #20]
 8015c72:	4413      	add	r3, r2
 8015c74:	3304      	adds	r3, #4
 8015c76:	60bb      	str	r3, [r7, #8]
    }

    return target;
 8015c78:	68bb      	ldr	r3, [r7, #8]
}
 8015c7a:	4618      	mov	r0, r3
 8015c7c:	371c      	adds	r7, #28
 8015c7e:	46bd      	mov	sp, r7
 8015c80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015c84:	4770      	bx	lr
	...

08015c88 <CalculateTargetAddress>:

UINTPTR CalculateTargetAddress(UINTPTR bl)
{
 8015c88:	b580      	push	{r7, lr}
 8015c8a:	b084      	sub	sp, #16
 8015c8c:	af00      	add	r7, sp, #0
 8015c8e:	6078      	str	r0, [r7, #4]
    UINTPTR target;
    STATIC UINTPTR tmpBL = 0;

    if ((((*(UINT16 *)(bl - BLX_CMD_OFFSET)) & HIGH_8_BITS_MASK) == BLX_INX)) {
 8015c90:	687b      	ldr	r3, [r7, #4]
 8015c92:	3b02      	subs	r3, #2
 8015c94:	881b      	ldrh	r3, [r3, #0]
 8015c96:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8015c9a:	f5b3 4f8e 	cmp.w	r3, #18176	; 0x4700
 8015c9e:	d11a      	bne.n	8015cd6 <CalculateTargetAddress+0x4e>
        if (tmpBL != 0) {
 8015ca0:	4b19      	ldr	r3, [pc, #100]	; (8015d08 <CalculateTargetAddress+0x80>)
 8015ca2:	681b      	ldr	r3, [r3, #0]
 8015ca4:	2b00      	cmp	r3, #0
 8015ca6:	d00b      	beq.n	8015cc0 <CalculateTargetAddress+0x38>
            target = LoopUntilEntry(tmpBL);
 8015ca8:	4b17      	ldr	r3, [pc, #92]	; (8015d08 <CalculateTargetAddress+0x80>)
 8015caa:	681b      	ldr	r3, [r3, #0]
 8015cac:	4618      	mov	r0, r3
 8015cae:	f7ff ff85 	bl	8015bbc <LoopUntilEntry>
 8015cb2:	60f8      	str	r0, [r7, #12]
            tmpBL = bl - BLX_CMD_OFFSET;
 8015cb4:	687b      	ldr	r3, [r7, #4]
 8015cb6:	3b02      	subs	r3, #2
 8015cb8:	4a13      	ldr	r2, [pc, #76]	; (8015d08 <CalculateTargetAddress+0x80>)
 8015cba:	6013      	str	r3, [r2, #0]
            return target;
 8015cbc:	68fb      	ldr	r3, [r7, #12]
 8015cbe:	e01e      	b.n	8015cfe <CalculateTargetAddress+0x76>
        }
        tmpBL = bl - BLX_CMD_OFFSET;
 8015cc0:	687b      	ldr	r3, [r7, #4]
 8015cc2:	3b02      	subs	r3, #2
 8015cc4:	4a10      	ldr	r2, [pc, #64]	; (8015d08 <CalculateTargetAddress+0x80>)
 8015cc6:	6013      	str	r3, [r2, #0]
        return LoopUntilEntry(tmpBL);
 8015cc8:	4b0f      	ldr	r3, [pc, #60]	; (8015d08 <CalculateTargetAddress+0x80>)
 8015cca:	681b      	ldr	r3, [r3, #0]
 8015ccc:	4618      	mov	r0, r3
 8015cce:	f7ff ff75 	bl	8015bbc <LoopUntilEntry>
 8015cd2:	4603      	mov	r3, r0
 8015cd4:	e013      	b.n	8015cfe <CalculateTargetAddress+0x76>
    } else if ((*(UINT32 *)(bl - BL_CMD_OFFSET) & BL_INS) == BL_INS) {
 8015cd6:	687b      	ldr	r3, [r7, #4]
 8015cd8:	3b04      	subs	r3, #4
 8015cda:	681b      	ldr	r3, [r3, #0]
 8015cdc:	f003 23f0 	and.w	r3, r3, #4026593280	; 0xf000f000
 8015ce0:	f1b3 2ff0 	cmp.w	r3, #4026593280	; 0xf000f000
 8015ce4:	d10a      	bne.n	8015cfc <CalculateTargetAddress+0x74>
        tmpBL = bl - BL_CMD_OFFSET;
 8015ce6:	687b      	ldr	r3, [r7, #4]
 8015ce8:	3b04      	subs	r3, #4
 8015cea:	4a07      	ldr	r2, [pc, #28]	; (8015d08 <CalculateTargetAddress+0x80>)
 8015cec:	6013      	str	r3, [r2, #0]
        return CalculateBLTargetAddress(tmpBL);
 8015cee:	4b06      	ldr	r3, [pc, #24]	; (8015d08 <CalculateTargetAddress+0x80>)
 8015cf0:	681b      	ldr	r3, [r3, #0]
 8015cf2:	4618      	mov	r0, r3
 8015cf4:	f7ff ff86 	bl	8015c04 <CalculateBLTargetAddress>
 8015cf8:	4603      	mov	r3, r0
 8015cfa:	e000      	b.n	8015cfe <CalculateTargetAddress+0x76>
    }

    return 0;
 8015cfc:	2300      	movs	r3, #0
}
 8015cfe:	4618      	mov	r0, r3
 8015d00:	3710      	adds	r7, #16
 8015d02:	46bd      	mov	sp, r7
 8015d04:	bd80      	pop	{r7, pc}
 8015d06:	bf00      	nop
 8015d08:	200033c8 	.word	0x200033c8

08015d0c <BackTraceSub>:

VOID BackTraceSub(UINTPTR sp)
{
 8015d0c:	b580      	push	{r7, lr}
 8015d0e:	b088      	sub	sp, #32
 8015d10:	af00      	add	r7, sp, #0
 8015d12:	6078      	str	r0, [r7, #4]
 8015d14:	4b32      	ldr	r3, [pc, #200]	; (8015de0 <BackTraceSub+0xd4>)
 8015d16:	681b      	ldr	r3, [r3, #0]
 8015d18:	61fb      	str	r3, [r7, #28]
 8015d1a:	f04f 0300 	mov.w	r3, #0
    UINTPTR stackPointer = sp;
 8015d1e:	687b      	ldr	r3, [r7, #4]
 8015d20:	60bb      	str	r3, [r7, #8]
    UINT32 count = 0;
 8015d22:	2300      	movs	r3, #0
 8015d24:	617b      	str	r3, [r7, #20]
    UINTPTR topOfStack = 0;
 8015d26:	2300      	movs	r3, #0
 8015d28:	60fb      	str	r3, [r7, #12]
    UINTPTR stackBottom = 0;
 8015d2a:	2300      	movs	r3, #0
 8015d2c:	613b      	str	r3, [r7, #16]
    STATIC UINTPTR tmpJump = 0;

    if (FindSuitableStack(&stackPointer, &topOfStack, &stackBottom) == FALSE) {
 8015d2e:	f107 0210 	add.w	r2, r7, #16
 8015d32:	f107 010c 	add.w	r1, r7, #12
 8015d36:	f107 0308 	add.w	r3, r7, #8
 8015d3a:	4618      	mov	r0, r3
 8015d3c:	f7ff fedc 	bl	8015af8 <FindSuitableStack>
 8015d40:	4603      	mov	r3, r0
 8015d42:	2b00      	cmp	r3, #0
 8015d44:	d040      	beq.n	8015dc8 <BackTraceSub+0xbc>
        return;
    }

    while ((stackPointer < stackBottom) && (count < OS_MAX_BACKTRACE)) {
 8015d46:	e037      	b.n	8015db8 <BackTraceSub+0xac>
        if ((*(UINT32 *)stackPointer >= (UINT32)g_textStart) &&
 8015d48:	68bb      	ldr	r3, [r7, #8]
 8015d4a:	681b      	ldr	r3, [r3, #0]
 8015d4c:	4a25      	ldr	r2, [pc, #148]	; (8015de4 <BackTraceSub+0xd8>)
 8015d4e:	6812      	ldr	r2, [r2, #0]
 8015d50:	4293      	cmp	r3, r2
 8015d52:	d32e      	bcc.n	8015db2 <BackTraceSub+0xa6>
            (*(UINT32 *)stackPointer <= (UINT32)g_textEnd) &&
 8015d54:	68bb      	ldr	r3, [r7, #8]
 8015d56:	681b      	ldr	r3, [r3, #0]
 8015d58:	4a23      	ldr	r2, [pc, #140]	; (8015de8 <BackTraceSub+0xdc>)
 8015d5a:	6812      	ldr	r2, [r2, #0]
        if ((*(UINT32 *)stackPointer >= (UINT32)g_textStart) &&
 8015d5c:	4293      	cmp	r3, r2
 8015d5e:	d828      	bhi.n	8015db2 <BackTraceSub+0xa6>
            /**
             * 2022-04-11 tanzhongqiang LR thumb 16bit 
             * LR  LR  BL,BX 
             * */
            IS_ALIGNED(*(UINT32 *)stackPointer - 1, THUM_OFFSET)) {
 8015d60:	68bb      	ldr	r3, [r7, #8]
 8015d62:	681b      	ldr	r3, [r3, #0]
 8015d64:	3b01      	subs	r3, #1
 8015d66:	f003 0301 	and.w	r3, r3, #1
            (*(UINT32 *)stackPointer <= (UINT32)g_textEnd) &&
 8015d6a:	2b00      	cmp	r3, #0
 8015d6c:	d121      	bne.n	8015db2 <BackTraceSub+0xa6>
            /* Get the entry address of current function. */
            UINTPTR checkBL = CalculateTargetAddress(*(UINT32 *)stackPointer - 1);
 8015d6e:	68bb      	ldr	r3, [r7, #8]
 8015d70:	681b      	ldr	r3, [r3, #0]
 8015d72:	3b01      	subs	r3, #1
 8015d74:	4618      	mov	r0, r3
 8015d76:	f7ff ff87 	bl	8015c88 <CalculateTargetAddress>
 8015d7a:	61b8      	str	r0, [r7, #24]
            if ((checkBL == 0) || (checkBL == tmpJump)) {
 8015d7c:	69bb      	ldr	r3, [r7, #24]
 8015d7e:	2b00      	cmp	r3, #0
 8015d80:	d004      	beq.n	8015d8c <BackTraceSub+0x80>
 8015d82:	4b1a      	ldr	r3, [pc, #104]	; (8015dec <BackTraceSub+0xe0>)
 8015d84:	681b      	ldr	r3, [r3, #0]
 8015d86:	69ba      	ldr	r2, [r7, #24]
 8015d88:	429a      	cmp	r2, r3
 8015d8a:	d103      	bne.n	8015d94 <BackTraceSub+0x88>
                stackPointer += STACK_OFFSET;
 8015d8c:	68bb      	ldr	r3, [r7, #8]
 8015d8e:	3304      	adds	r3, #4
 8015d90:	60bb      	str	r3, [r7, #8]
                continue;
 8015d92:	e011      	b.n	8015db8 <BackTraceSub+0xac>
            }
            tmpJump = checkBL;
 8015d94:	4a15      	ldr	r2, [pc, #84]	; (8015dec <BackTraceSub+0xe0>)
 8015d96:	69bb      	ldr	r3, [r7, #24]
 8015d98:	6013      	str	r3, [r2, #0]
            count++;
 8015d9a:	697b      	ldr	r3, [r7, #20]
 8015d9c:	3301      	adds	r3, #1
 8015d9e:	617b      	str	r3, [r7, #20]
            PrintExcInfo("traceback %u -- lr = 0x%08x -- fp = 0x%08x\n", count, *(UINT32 *)stackPointer - 1, tmpJump);
 8015da0:	68bb      	ldr	r3, [r7, #8]
 8015da2:	681b      	ldr	r3, [r3, #0]
 8015da4:	1e5a      	subs	r2, r3, #1
 8015da6:	4b11      	ldr	r3, [pc, #68]	; (8015dec <BackTraceSub+0xe0>)
 8015da8:	681b      	ldr	r3, [r3, #0]
 8015daa:	6979      	ldr	r1, [r7, #20]
 8015dac:	4810      	ldr	r0, [pc, #64]	; (8015df0 <BackTraceSub+0xe4>)
 8015dae:	f7ee fcb1 	bl	8004714 <PrintExcInfo>
        }
        stackPointer += STACK_OFFSET;
 8015db2:	68bb      	ldr	r3, [r7, #8]
 8015db4:	3304      	adds	r3, #4
 8015db6:	60bb      	str	r3, [r7, #8]
    while ((stackPointer < stackBottom) && (count < OS_MAX_BACKTRACE)) {
 8015db8:	68ba      	ldr	r2, [r7, #8]
 8015dba:	693b      	ldr	r3, [r7, #16]
 8015dbc:	429a      	cmp	r2, r3
 8015dbe:	d204      	bcs.n	8015dca <BackTraceSub+0xbe>
 8015dc0:	697b      	ldr	r3, [r7, #20]
 8015dc2:	2b0e      	cmp	r3, #14
 8015dc4:	d9c0      	bls.n	8015d48 <BackTraceSub+0x3c>
 8015dc6:	e000      	b.n	8015dca <BackTraceSub+0xbe>
        return;
 8015dc8:	bf00      	nop
    }
}
 8015dca:	4b05      	ldr	r3, [pc, #20]	; (8015de0 <BackTraceSub+0xd4>)
 8015dcc:	681a      	ldr	r2, [r3, #0]
 8015dce:	69fb      	ldr	r3, [r7, #28]
 8015dd0:	405a      	eors	r2, r3
 8015dd2:	d001      	beq.n	8015dd8 <BackTraceSub+0xcc>
 8015dd4:	f7ee fb08 	bl	80043e8 <__stack_chk_fail>
 8015dd8:	3720      	adds	r7, #32
 8015dda:	46bd      	mov	sp, r7
 8015ddc:	bd80      	pop	{r7, pc}
 8015dde:	bf00      	nop
 8015de0:	08022f98 	.word	0x08022f98
 8015de4:	080236a8 	.word	0x080236a8
 8015de8:	080236ac 	.word	0x080236ac
 8015dec:	200033cc 	.word	0x200033cc
 8015df0:	08022f6c 	.word	0x08022f6c

08015df4 <BackTraceWithSp>:

STATIC VOID BackTraceWithSp(UINTPTR sp)
{
 8015df4:	b580      	push	{r7, lr}
 8015df6:	b082      	sub	sp, #8
 8015df8:	af00      	add	r7, sp, #0
 8015dfa:	6078      	str	r0, [r7, #4]
    PrintExcInfo("*******backtrace begin*******\n");
 8015dfc:	4806      	ldr	r0, [pc, #24]	; (8015e18 <BackTraceWithSp+0x24>)
 8015dfe:	f7ee fc89 	bl	8004714 <PrintExcInfo>
    BackTraceSub(sp);
 8015e02:	6878      	ldr	r0, [r7, #4]
 8015e04:	f7ff ff82 	bl	8015d0c <BackTraceSub>
    PrintExcInfo("*******backtrace end*******\n");
 8015e08:	4804      	ldr	r0, [pc, #16]	; (8015e1c <BackTraceWithSp+0x28>)
 8015e0a:	f7ee fc83 	bl	8004714 <PrintExcInfo>
}
 8015e0e:	bf00      	nop
 8015e10:	3708      	adds	r7, #8
 8015e12:	46bd      	mov	sp, r7
 8015e14:	bd80      	pop	{r7, pc}
 8015e16:	bf00      	nop
 8015e18:	08022f9c 	.word	0x08022f9c
 8015e1c:	08022fbc 	.word	0x08022fbc

08015e20 <ArchBackTrace>:
#endif

VOID ArchBackTrace(VOID)
{
 8015e20:	b580      	push	{r7, lr}
 8015e22:	b082      	sub	sp, #8
 8015e24:	af00      	add	r7, sp, #0
#ifdef LOSCFG_BACKTRACE
    UINTPTR sp = ArchGetSp();
 8015e26:	f7ff fd1c 	bl	8015862 <ArchGetSp>
 8015e2a:	6078      	str	r0, [r7, #4]
    PrintExcInfo("sp:0x%08x\n", sp);
 8015e2c:	6879      	ldr	r1, [r7, #4]
 8015e2e:	4805      	ldr	r0, [pc, #20]	; (8015e44 <ArchBackTrace+0x24>)
 8015e30:	f7ee fc70 	bl	8004714 <PrintExcInfo>
    BackTraceWithSp(sp);
 8015e34:	6878      	ldr	r0, [r7, #4]
 8015e36:	f7ff ffdd 	bl	8015df4 <BackTraceWithSp>
#endif
}
 8015e3a:	bf00      	nop
 8015e3c:	3708      	adds	r7, #8
 8015e3e:	46bd      	mov	sp, r7
 8015e40:	bd80      	pop	{r7, pc}
 8015e42:	bf00      	nop
 8015e44:	08022fdc 	.word	0x08022fdc

08015e48 <ArchBackTraceWithSp>:

VOID ArchBackTraceWithSp(const VOID *stackPointer)
{
 8015e48:	b580      	push	{r7, lr}
 8015e4a:	b082      	sub	sp, #8
 8015e4c:	af00      	add	r7, sp, #0
 8015e4e:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_BACKTRACE
    BackTraceWithSp((UINTPTR)stackPointer);
 8015e50:	687b      	ldr	r3, [r7, #4]
 8015e52:	4618      	mov	r0, r3
 8015e54:	f7ff ffce 	bl	8015df4 <BackTraceWithSp>
#else
    (VOID)stackPointer;
#endif
}
 8015e58:	bf00      	nop
 8015e5a:	3708      	adds	r7, #8
 8015e5c:	46bd      	mov	sp, r7
 8015e5e:	bd80      	pop	{r7, pc}

08015e60 <ArchExcInit>:

LITE_OS_SEC_TEXT_INIT VOID ArchExcInit(VOID)
{
 8015e60:	b480      	push	{r7}
 8015e62:	af00      	add	r7, sp, #0
#ifndef LOSCFG_ARCH_CORTEX_M0
#ifndef LOSCFG_ARCH_CORTEX_M0_PLUS
    g_hwiVec[HARD_FAULT_IRQN + OS_SYS_VECTOR_CNT] = OsExcHardFault;
 8015e64:	4b11      	ldr	r3, [pc, #68]	; (8015eac <ArchExcInit+0x4c>)
 8015e66:	4a12      	ldr	r2, [pc, #72]	; (8015eb0 <ArchExcInit+0x50>)
 8015e68:	60da      	str	r2, [r3, #12]
    g_hwiVec[NonMaskableInt_IRQn + OS_SYS_VECTOR_CNT] = OsExcNMI;
 8015e6a:	4b10      	ldr	r3, [pc, #64]	; (8015eac <ArchExcInit+0x4c>)
 8015e6c:	4a11      	ldr	r2, [pc, #68]	; (8015eb4 <ArchExcInit+0x54>)
 8015e6e:	609a      	str	r2, [r3, #8]
    g_hwiVec[MemoryManagement_IRQn + OS_SYS_VECTOR_CNT] = OsExcMemFault;
 8015e70:	4b0e      	ldr	r3, [pc, #56]	; (8015eac <ArchExcInit+0x4c>)
 8015e72:	4a11      	ldr	r2, [pc, #68]	; (8015eb8 <ArchExcInit+0x58>)
 8015e74:	611a      	str	r2, [r3, #16]
    g_hwiVec[BusFault_IRQn + OS_SYS_VECTOR_CNT] = OsExcBusFault;
 8015e76:	4b0d      	ldr	r3, [pc, #52]	; (8015eac <ArchExcInit+0x4c>)
 8015e78:	4a10      	ldr	r2, [pc, #64]	; (8015ebc <ArchExcInit+0x5c>)
 8015e7a:	615a      	str	r2, [r3, #20]
    g_hwiVec[UsageFault_IRQn + OS_SYS_VECTOR_CNT] = OsExcUsageFault;
 8015e7c:	4b0b      	ldr	r3, [pc, #44]	; (8015eac <ArchExcInit+0x4c>)
 8015e7e:	4a10      	ldr	r2, [pc, #64]	; (8015ec0 <ArchExcInit+0x60>)
 8015e80:	619a      	str	r2, [r3, #24]
    g_hwiVec[SVCall_IRQn + OS_SYS_VECTOR_CNT] = OsExcSvcCall;
 8015e82:	4b0a      	ldr	r3, [pc, #40]	; (8015eac <ArchExcInit+0x4c>)
 8015e84:	4a0f      	ldr	r2, [pc, #60]	; (8015ec4 <ArchExcInit+0x64>)
 8015e86:	62da      	str	r2, [r3, #44]	; 0x2c
    g_hwiVec[SVC_IRQn + OS_SYS_VECTOR_CNT] = OsExcSvcCall;
    g_hwiVec[NonMaskableInt_IRQn + OS_SYS_VECTOR_CNT] = OsExcNMI;
#endif
#endif
    /* Enable USGFAULT, BUSFAULT, MEMFAULT */
    *(volatile UINT32 *)OS_NVIC_SHCSR |= (USGFAULT | BUSFAULT | MEMFAULT);
 8015e88:	4b0f      	ldr	r3, [pc, #60]	; (8015ec8 <ArchExcInit+0x68>)
 8015e8a:	681b      	ldr	r3, [r3, #0]
 8015e8c:	4a0e      	ldr	r2, [pc, #56]	; (8015ec8 <ArchExcInit+0x68>)
 8015e8e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
 8015e92:	6013      	str	r3, [r2, #0]
    /* Enable DIV 0 and unaligned exception */
    *(volatile UINT32 *)OS_NVIC_CCR |= DIV0FAULT;
 8015e94:	4b0d      	ldr	r3, [pc, #52]	; (8015ecc <ArchExcInit+0x6c>)
 8015e96:	681b      	ldr	r3, [r3, #0]
 8015e98:	4a0c      	ldr	r2, [pc, #48]	; (8015ecc <ArchExcInit+0x6c>)
 8015e9a:	f043 0310 	orr.w	r3, r3, #16
 8015e9e:	6013      	str	r3, [r2, #0]
}
 8015ea0:	bf00      	nop
 8015ea2:	46bd      	mov	sp, r7
 8015ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015ea8:	4770      	bx	lr
 8015eaa:	bf00      	nop
 8015eac:	20000000 	.word	0x20000000
 8015eb0:	08000d4f 	.word	0x08000d4f
 8015eb4:	08000d45 	.word	0x08000d45
 8015eb8:	08000df9 	.word	0x08000df9
 8015ebc:	08000ddb 	.word	0x08000ddb
 8015ec0:	08000e17 	.word	0x08000e17
 8015ec4:	08000dc1 	.word	0x08000dc1
 8015ec8:	e000ed24 	.word	0xe000ed24
 8015ecc:	e000ed14 	.word	0xe000ed14

08015ed0 <LedTask1>:
static EVENT_CB_S g_pevent;
/*  */
#define EVENT_WAIT 0x00000001
UINT64 g_lastTick;
STATIC UINT32 LedTask1(VOID)
{// 2022-3-31 tanzhongqiang event CPUevent 
 8015ed0:	b580      	push	{r7, lr}
 8015ed2:	b082      	sub	sp, #8
 8015ed4:	af00      	add	r7, sp, #0

    UINT32 event;

    while (1) {          
        event = LOS_EventRead(&g_pevent, EVENT_WAIT, LOS_WAITMODE_AND, LOS_WAIT_FOREVER);
 8015ed6:	f04f 33ff 	mov.w	r3, #4294967295
 8015eda:	2204      	movs	r2, #4
 8015edc:	2101      	movs	r1, #1
 8015ede:	480b      	ldr	r0, [pc, #44]	; (8015f0c <LedTask1+0x3c>)
 8015ee0:	f002 feea 	bl	8018cb8 <LOS_EventRead>
 8015ee4:	6078      	str	r0, [r7, #4]
        if (event == EVENT_WAIT) {
 8015ee6:	687b      	ldr	r3, [r7, #4]
 8015ee8:	2b01      	cmp	r3, #1
 8015eea:	d109      	bne.n	8015f00 <LedTask1+0x30>
            LOS_EventClear(&g_pevent, ~g_pevent.uwEventID);
 8015eec:	4b07      	ldr	r3, [pc, #28]	; (8015f0c <LedTask1+0x3c>)
 8015eee:	681b      	ldr	r3, [r3, #0]
 8015ef0:	43db      	mvns	r3, r3
 8015ef2:	4619      	mov	r1, r3
 8015ef4:	4805      	ldr	r0, [pc, #20]	; (8015f0c <LedTask1+0x3c>)
 8015ef6:	f002 ff65 	bl	8018dc4 <LOS_EventClear>
            // printf("last_pc : 0x%x\n",g_interrupt_pc);  
            Fire_DEBUG_GPIOB6_TRIGGER();                 
 8015efa:	f7eb fefd 	bl	8001cf8 <Fire_DEBUG_GPIOB6_TRIGGER>
 8015efe:	e7ea      	b.n	8015ed6 <LedTask1+0x6>
        }else{
            printf("event 0x%x\n",event);
 8015f00:	6879      	ldr	r1, [r7, #4]
 8015f02:	4803      	ldr	r0, [pc, #12]	; (8015f10 <LedTask1+0x40>)
 8015f04:	f7f9 fb7a 	bl	800f5fc <printf>
        event = LOS_EventRead(&g_pevent, EVENT_WAIT, LOS_WAITMODE_AND, LOS_WAIT_FOREVER);
 8015f08:	e7e5      	b.n	8015ed6 <LedTask1+0x6>
 8015f0a:	bf00      	nop
 8015f0c:	200033d0 	.word	0x200033d0
 8015f10:	08022fe8 	.word	0x08022fe8

08015f14 <LedTask2>:
    }
    return 0;
}

STATIC UINT32 LedTask2(VOID)
{
 8015f14:	b580      	push	{r7, lr}
 8015f16:	af00      	add	r7, sp, #0
    while (1) {       
        LOS_TaskDelay(100); 
 8015f18:	2064      	movs	r0, #100	; 0x64
 8015f1a:	f7ed fec9 	bl	8003cb0 <LOS_TaskDelay>
        // LOS_TaskYield();   
        Fire_DEBUG_GPIOB7_TRIGGER();
 8015f1e:	f7eb fef5 	bl	8001d0c <Fire_DEBUG_GPIOB7_TRIGGER>
        LOS_TaskDelay(100); 
 8015f22:	e7f9      	b.n	8015f18 <LedTask2+0x4>

08015f24 <Timer1_CallBack>:
        // LedTaskTrigger();
    }
    return 0;
}
VOID Timer1_CallBack(UINT32 arg)
{
 8015f24:	b580      	push	{r7, lr}
 8015f26:	b082      	sub	sp, #8
 8015f28:	af00      	add	r7, sp, #0
 8015f2a:	6078      	str	r0, [r7, #4]
    g_lastTick=LOS_TickCountGet();
 8015f2c:	f7ee f924 	bl	8004178 <LOS_TickCountGet>
 8015f30:	4602      	mov	r2, r0
 8015f32:	460b      	mov	r3, r1
 8015f34:	4903      	ldr	r1, [pc, #12]	; (8015f44 <Timer1_CallBack+0x20>)
 8015f36:	e9c1 2300 	strd	r2, r3, [r1]
}
 8015f3a:	bf00      	nop
 8015f3c:	3708      	adds	r7, #8
 8015f3e:	46bd      	mov	sp, r7
 8015f40:	bd80      	pop	{r7, pc}
 8015f42:	bf00      	nop
 8015f44:	200037e0 	.word	0x200037e0

08015f48 <LedTaskCreate>:

STATIC UINT32 LedTaskCreate(VOID)
{
 8015f48:	b580      	push	{r7, lr}
 8015f4a:	b090      	sub	sp, #64	; 0x40
 8015f4c:	af02      	add	r7, sp, #8
 8015f4e:	4b31      	ldr	r3, [pc, #196]	; (8016014 <LedTaskCreate+0xcc>)
 8015f50:	681b      	ldr	r3, [r3, #0]
 8015f52:	637b      	str	r3, [r7, #52]	; 0x34
 8015f54:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    UINT32 taskId = 0;
 8015f58:	2300      	movs	r3, #0
 8015f5a:	60bb      	str	r3, [r7, #8]
    UINT16 id1;     // Timer1 id

    TSK_INIT_PARAM_S ledTaskParam;

       /*  */
    ret = LOS_EventInit(&g_pevent);
 8015f5c:	482e      	ldr	r0, [pc, #184]	; (8016018 <LedTaskCreate+0xd0>)
 8015f5e:	f002 fc17 	bl	8018790 <LOS_EventInit>
 8015f62:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 8015f64:	68fb      	ldr	r3, [r7, #12]
 8015f66:	2b00      	cmp	r3, #0
 8015f68:	d005      	beq.n	8015f76 <LedTaskCreate+0x2e>
        printf("init event failed .\n");
 8015f6a:	482c      	ldr	r0, [pc, #176]	; (801601c <LedTaskCreate+0xd4>)
 8015f6c:	f7f9 fb46 	bl	800f5fc <printf>
        return -1;
 8015f70:	f04f 33ff 	mov.w	r3, #4294967295
 8015f74:	e043      	b.n	8015ffe <LedTaskCreate+0xb6>
    }

    ret = (UINT32)memset_s(&ledTaskParam, sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
 8015f76:	f107 0010 	add.w	r0, r7, #16
 8015f7a:	2324      	movs	r3, #36	; 0x24
 8015f7c:	2200      	movs	r2, #0
 8015f7e:	2124      	movs	r1, #36	; 0x24
 8015f80:	f000 f884 	bl	801608c <memset_s>
 8015f84:	4603      	mov	r3, r0
 8015f86:	60fb      	str	r3, [r7, #12]
    if (ret != EOK) {
 8015f88:	68fb      	ldr	r3, [r7, #12]
 8015f8a:	2b00      	cmp	r3, #0
 8015f8c:	d001      	beq.n	8015f92 <LedTaskCreate+0x4a>
        return ret;
 8015f8e:	68fb      	ldr	r3, [r7, #12]
 8015f90:	e035      	b.n	8015ffe <LedTaskCreate+0xb6>
    }

    // LOS_TaskLock();
    ledTaskParam.pfnTaskEntry = (TSK_ENTRY_FUNC)LedTask1;
 8015f92:	4b23      	ldr	r3, [pc, #140]	; (8016020 <LedTaskCreate+0xd8>)
 8015f94:	613b      	str	r3, [r7, #16]
    ledTaskParam.uwStackSize = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
 8015f96:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8015f9a:	62bb      	str	r3, [r7, #40]	; 0x28
    ledTaskParam.pcName = "ledTask1";
 8015f9c:	4b21      	ldr	r3, [pc, #132]	; (8016024 <LedTaskCreate+0xdc>)
 8015f9e:	62fb      	str	r3, [r7, #44]	; 0x2c
    ledTaskParam.usTaskPrio = LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
 8015fa0:	230a      	movs	r3, #10
 8015fa2:	82bb      	strh	r3, [r7, #20]
    ledTaskParam.uwResved = LOS_TASK_STATUS_DETACHED;
 8015fa4:	f44f 7380 	mov.w	r3, #256	; 0x100
 8015fa8:	633b      	str	r3, [r7, #48]	; 0x30
    LOS_TaskCreate(&taskId, &ledTaskParam);
 8015faa:	f107 0210 	add.w	r2, r7, #16
 8015fae:	f107 0308 	add.w	r3, r7, #8
 8015fb2:	4611      	mov	r1, r2
 8015fb4:	4618      	mov	r0, r3
 8015fb6:	f7ed fcbf 	bl	8003938 <LOS_TaskCreate>

    ledTaskParam.pfnTaskEntry = (TSK_ENTRY_FUNC)LedTask2;
 8015fba:	4b1b      	ldr	r3, [pc, #108]	; (8016028 <LedTaskCreate+0xe0>)
 8015fbc:	613b      	str	r3, [r7, #16]
    ledTaskParam.uwStackSize = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
 8015fbe:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8015fc2:	62bb      	str	r3, [r7, #40]	; 0x28
    ledTaskParam.pcName = "ledTask2";
 8015fc4:	4b19      	ldr	r3, [pc, #100]	; (801602c <LedTaskCreate+0xe4>)
 8015fc6:	62fb      	str	r3, [r7, #44]	; 0x2c
    ledTaskParam.usTaskPrio = LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
 8015fc8:	230a      	movs	r3, #10
 8015fca:	82bb      	strh	r3, [r7, #20]
    ledTaskParam.uwResved = LOS_TASK_STATUS_DETACHED;
 8015fcc:	f44f 7380 	mov.w	r3, #256	; 0x100
 8015fd0:	633b      	str	r3, [r7, #48]	; 0x30
    LOS_TaskCreate(&taskId, &ledTaskParam);
 8015fd2:	f107 0210 	add.w	r2, r7, #16
 8015fd6:	f107 0308 	add.w	r3, r7, #8
 8015fda:	4611      	mov	r1, r2
 8015fdc:	4618      	mov	r0, r3
 8015fde:	f7ed fcab 	bl	8003938 <LOS_TaskCreate>

    LOS_SwtmrCreate(1000*30, LOS_SWTMR_MODE_PERIOD, Timer1_CallBack, &id1, 1);
 8015fe2:	1dbb      	adds	r3, r7, #6
 8015fe4:	2201      	movs	r2, #1
 8015fe6:	9200      	str	r2, [sp, #0]
 8015fe8:	4a11      	ldr	r2, [pc, #68]	; (8016030 <LedTaskCreate+0xe8>)
 8015fea:	2101      	movs	r1, #1
 8015fec:	f247 5030 	movw	r0, #30000	; 0x7530
 8015ff0:	f7ef f8b4 	bl	800515c <LOS_SwtmrCreate>
    LOS_SwtmrStart(id1);
 8015ff4:	88fb      	ldrh	r3, [r7, #6]
 8015ff6:	4618      	mov	r0, r3
 8015ff8:	f7ef f958 	bl	80052ac <LOS_SwtmrStart>
    // LOS_TaskUnlock();
    return 0; 
 8015ffc:	2300      	movs	r3, #0
}
 8015ffe:	4a05      	ldr	r2, [pc, #20]	; (8016014 <LedTaskCreate+0xcc>)
 8016000:	6811      	ldr	r1, [r2, #0]
 8016002:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8016004:	4051      	eors	r1, r2
 8016006:	d001      	beq.n	801600c <LedTaskCreate+0xc4>
 8016008:	f7ee f9ee 	bl	80043e8 <__stack_chk_fail>
 801600c:	4618      	mov	r0, r3
 801600e:	3738      	adds	r7, #56	; 0x38
 8016010:	46bd      	mov	sp, r7
 8016012:	bd80      	pop	{r7, pc}
 8016014:	08023024 	.word	0x08023024
 8016018:	200033d0 	.word	0x200033d0
 801601c:	08022ff4 	.word	0x08022ff4
 8016020:	08015ed1 	.word	0x08015ed1
 8016024:	0802300c 	.word	0x0802300c
 8016028:	08015f15 	.word	0x08015f15
 801602c:	08023018 	.word	0x08023018
 8016030:	08015f25 	.word	0x08015f25

08016034 <app_init>:

VOID app_init(VOID)
{
 8016034:	b580      	push	{r7, lr}
 8016036:	af00      	add	r7, sp, #0
    printf("app init!\n");
 8016038:	4804      	ldr	r0, [pc, #16]	; (801604c <app_init+0x18>)
 801603a:	f7f9 fadf 	bl	800f5fc <printf>
    (VOID)LedTaskCreate();
 801603e:	f7ff ff83 	bl	8015f48 <LedTaskCreate>
    DemoEntry();
 8016042:	f002 ff19 	bl	8018e78 <DemoEntry>
}
 8016046:	bf00      	nop
 8016048:	bd80      	pop	{r7, pc}
 801604a:	bf00      	nop
 801604c:	08023028 	.word	0x08023028

08016050 <SecMemsetError>:

/*
 * Handling errors
 */
SECUREC_INLINE errno_t SecMemsetError(void *dest, size_t destMax, int c)
{
 8016050:	b580      	push	{r7, lr}
 8016052:	b084      	sub	sp, #16
 8016054:	af00      	add	r7, sp, #0
 8016056:	60f8      	str	r0, [r7, #12]
 8016058:	60b9      	str	r1, [r7, #8]
 801605a:	607a      	str	r2, [r7, #4]
    /* Check destMax is 0 compatible with _sp macro */
    if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN) {
 801605c:	68bb      	ldr	r3, [r7, #8]
 801605e:	2b00      	cmp	r3, #0
 8016060:	d002      	beq.n	8016068 <SecMemsetError+0x18>
 8016062:	68bb      	ldr	r3, [r7, #8]
 8016064:	2b00      	cmp	r3, #0
 8016066:	da01      	bge.n	801606c <SecMemsetError+0x1c>
        SECUREC_ERROR_INVALID_RANGE("memset_s");
        return ERANGE;
 8016068:	2322      	movs	r3, #34	; 0x22
 801606a:	e00b      	b.n	8016084 <SecMemsetError+0x34>
    }
    if (dest == NULL) {
 801606c:	68fb      	ldr	r3, [r7, #12]
 801606e:	2b00      	cmp	r3, #0
 8016070:	d101      	bne.n	8016076 <SecMemsetError+0x26>
        SECUREC_ERROR_INVALID_PARAMTER("memset_s");
        return EINVAL;
 8016072:	2316      	movs	r3, #22
 8016074:	e006      	b.n	8016084 <SecMemsetError+0x34>
    }
    SECUREC_MEMSET_PREVENT_DSE(dest, c, destMax); /* Set entire buffer to value c */
 8016076:	68ba      	ldr	r2, [r7, #8]
 8016078:	6879      	ldr	r1, [r7, #4]
 801607a:	68f8      	ldr	r0, [r7, #12]
 801607c:	f7f8 fbe2 	bl	800e844 <memset>
 8016080:	68fb      	ldr	r3, [r7, #12]
    SECUREC_ERROR_INVALID_RANGE("memset_s");
    return ERANGE_AND_RESET;
 8016082:	23a2      	movs	r3, #162	; 0xa2
}
 8016084:	4618      	mov	r0, r3
 8016086:	3710      	adds	r7, #16
 8016088:	46bd      	mov	sp, r7
 801608a:	bd80      	pop	{r7, pc}

0801608c <memset_s>:
 *    ERANGE_AND_RESET    count > destMax and destMax != 0 and destMax <= SECUREC_MEM_MAX_LEN and dest != NULL
 *
 *    if return ERANGE_AND_RESET then fill dest to c ,fill length is destMax
 */
errno_t memset_s(void *dest, size_t destMax, int c, size_t count)
{
 801608c:	b580      	push	{r7, lr}
 801608e:	b084      	sub	sp, #16
 8016090:	af00      	add	r7, sp, #0
 8016092:	60f8      	str	r0, [r7, #12]
 8016094:	60b9      	str	r1, [r7, #8]
 8016096:	607a      	str	r2, [r7, #4]
 8016098:	603b      	str	r3, [r7, #0]
    if (SECUREC_MEMSET_PARAM_OK(dest, destMax, count)) {
 801609a:	68bb      	ldr	r3, [r7, #8]
 801609c:	43db      	mvns	r3, r3
 801609e:	0fdb      	lsrs	r3, r3, #31
 80160a0:	b2db      	uxtb	r3, r3
 80160a2:	2b00      	cmp	r3, #0
 80160a4:	d009      	beq.n	80160ba <memset_s+0x2e>
 80160a6:	68fb      	ldr	r3, [r7, #12]
 80160a8:	2b00      	cmp	r3, #0
 80160aa:	bf14      	ite	ne
 80160ac:	2301      	movne	r3, #1
 80160ae:	2300      	moveq	r3, #0
 80160b0:	b2db      	uxtb	r3, r3
 80160b2:	2b00      	cmp	r3, #0
 80160b4:	d001      	beq.n	80160ba <memset_s+0x2e>
 80160b6:	2301      	movs	r3, #1
 80160b8:	e000      	b.n	80160bc <memset_s+0x30>
 80160ba:	2300      	movs	r3, #0
 80160bc:	2b00      	cmp	r3, #0
 80160be:	d010      	beq.n	80160e2 <memset_s+0x56>
 80160c0:	683a      	ldr	r2, [r7, #0]
 80160c2:	68bb      	ldr	r3, [r7, #8]
 80160c4:	429a      	cmp	r2, r3
 80160c6:	bf94      	ite	ls
 80160c8:	2301      	movls	r3, #1
 80160ca:	2300      	movhi	r3, #0
 80160cc:	b2db      	uxtb	r3, r3
 80160ce:	2b00      	cmp	r3, #0
 80160d0:	d007      	beq.n	80160e2 <memset_s+0x56>
        SECUREC_MEMSET_PREVENT_DSE(dest, c, count);
 80160d2:	683a      	ldr	r2, [r7, #0]
 80160d4:	6879      	ldr	r1, [r7, #4]
 80160d6:	68f8      	ldr	r0, [r7, #12]
 80160d8:	f7f8 fbb4 	bl	800e844 <memset>
 80160dc:	68fb      	ldr	r3, [r7, #12]
        return EOK;
 80160de:	2300      	movs	r3, #0
 80160e0:	e005      	b.n	80160ee <memset_s+0x62>
    }
    /* Meet some runtime violation, return error code */
    return SecMemsetError(dest, destMax, c);
 80160e2:	687a      	ldr	r2, [r7, #4]
 80160e4:	68b9      	ldr	r1, [r7, #8]
 80160e6:	68f8      	ldr	r0, [r7, #12]
 80160e8:	f7ff ffb2 	bl	8016050 <SecMemsetError>
 80160ec:	4603      	mov	r3, r0
}
 80160ee:	4618      	mov	r0, r3
 80160f0:	3710      	adds	r7, #16
 80160f2:	46bd      	mov	sp, r7
 80160f4:	bd80      	pop	{r7, pc}

080160f6 <vsnprintf_s>:
 *    return -1 if count < destMax and the output string  has been truncated
 *
 * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
 */
int vsnprintf_s(char *strDest, size_t destMax, size_t count, const char *format, va_list argList)
{
 80160f6:	b580      	push	{r7, lr}
 80160f8:	b086      	sub	sp, #24
 80160fa:	af00      	add	r7, sp, #0
 80160fc:	60f8      	str	r0, [r7, #12]
 80160fe:	60b9      	str	r1, [r7, #8]
 8016100:	607a      	str	r2, [r7, #4]
 8016102:	603b      	str	r3, [r7, #0]
    int retVal;

    if (SECUREC_VSNPRINTF_PARAM_ERROR(format, strDest, destMax, count, SECUREC_STRING_MAX_LEN)) {
 8016104:	683b      	ldr	r3, [r7, #0]
 8016106:	2b00      	cmp	r3, #0
 8016108:	d00d      	beq.n	8016126 <vsnprintf_s+0x30>
 801610a:	68fb      	ldr	r3, [r7, #12]
 801610c:	2b00      	cmp	r3, #0
 801610e:	d00a      	beq.n	8016126 <vsnprintf_s+0x30>
 8016110:	68bb      	ldr	r3, [r7, #8]
 8016112:	2b00      	cmp	r3, #0
 8016114:	d007      	beq.n	8016126 <vsnprintf_s+0x30>
 8016116:	68bb      	ldr	r3, [r7, #8]
 8016118:	2b00      	cmp	r3, #0
 801611a:	db04      	blt.n	8016126 <vsnprintf_s+0x30>
 801611c:	687b      	ldr	r3, [r7, #4]
 801611e:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 8016122:	4293      	cmp	r3, r2
 8016124:	d30e      	bcc.n	8016144 <vsnprintf_s+0x4e>
        SECUREC_VSPRINTF_CLEAR_DEST(strDest, destMax, SECUREC_STRING_MAX_LEN);
 8016126:	68fb      	ldr	r3, [r7, #12]
 8016128:	2b00      	cmp	r3, #0
 801612a:	d008      	beq.n	801613e <vsnprintf_s+0x48>
 801612c:	68bb      	ldr	r3, [r7, #8]
 801612e:	2b00      	cmp	r3, #0
 8016130:	d005      	beq.n	801613e <vsnprintf_s+0x48>
 8016132:	68bb      	ldr	r3, [r7, #8]
 8016134:	2b00      	cmp	r3, #0
 8016136:	db02      	blt.n	801613e <vsnprintf_s+0x48>
 8016138:	68fb      	ldr	r3, [r7, #12]
 801613a:	2200      	movs	r2, #0
 801613c:	701a      	strb	r2, [r3, #0]
        SECUREC_ERROR_INVALID_PARAMTER("vsnprintf_s");
        return -1;
 801613e:	f04f 33ff 	mov.w	r3, #4294967295
 8016142:	e023      	b.n	801618c <vsnprintf_s+0x96>
    }

    if (destMax > count) {
 8016144:	68ba      	ldr	r2, [r7, #8]
 8016146:	687b      	ldr	r3, [r7, #4]
 8016148:	429a      	cmp	r2, r3
 801614a:	d90e      	bls.n	801616a <vsnprintf_s+0x74>
        retVal = SecVsnprintfImpl(strDest, count + 1, format, argList);
 801614c:	687b      	ldr	r3, [r7, #4]
 801614e:	1c59      	adds	r1, r3, #1
 8016150:	6a3b      	ldr	r3, [r7, #32]
 8016152:	683a      	ldr	r2, [r7, #0]
 8016154:	68f8      	ldr	r0, [r7, #12]
 8016156:	f002 fa0f 	bl	8018578 <SecVsnprintfImpl>
 801615a:	6178      	str	r0, [r7, #20]
        if (retVal == SECUREC_PRINTF_TRUNCATE) {  /* To keep dest buffer not destroyed 2014.2.18 */
 801615c:	697b      	ldr	r3, [r7, #20]
 801615e:	f113 0f02 	cmn.w	r3, #2
 8016162:	d109      	bne.n	8016178 <vsnprintf_s+0x82>
            /* The string has been truncated, return  -1 */
            return -1;          /* To skip error handler,  return strlen(strDest) or -1 */
 8016164:	f04f 33ff 	mov.w	r3, #4294967295
 8016168:	e010      	b.n	801618c <vsnprintf_s+0x96>
        }
    } else {
        retVal = SecVsnprintfImpl(strDest, destMax, format, argList);
 801616a:	6a3b      	ldr	r3, [r7, #32]
 801616c:	683a      	ldr	r2, [r7, #0]
 801616e:	68b9      	ldr	r1, [r7, #8]
 8016170:	68f8      	ldr	r0, [r7, #12]
 8016172:	f002 fa01 	bl	8018578 <SecVsnprintfImpl>
 8016176:	6178      	str	r0, [r7, #20]
            return -1;
        }
#endif
    }

    if (retVal < 0) {
 8016178:	697b      	ldr	r3, [r7, #20]
 801617a:	2b00      	cmp	r3, #0
 801617c:	da05      	bge.n	801618a <vsnprintf_s+0x94>
        strDest[0] = '\0';      /* Empty the dest strDest */
 801617e:	68fb      	ldr	r3, [r7, #12]
 8016180:	2200      	movs	r2, #0
 8016182:	701a      	strb	r2, [r3, #0]
        if (retVal == SECUREC_PRINTF_TRUNCATE) {
            /* Buffer too small */
            SECUREC_ERROR_INVALID_RANGE("vsnprintf_s");
        }
        SECUREC_ERROR_INVALID_PARAMTER("vsnprintf_s");
        return -1;
 8016184:	f04f 33ff 	mov.w	r3, #4294967295
 8016188:	e000      	b.n	801618c <vsnprintf_s+0x96>
    }

    return retVal;
 801618a:	697b      	ldr	r3, [r7, #20]
}
 801618c:	4618      	mov	r0, r3
 801618e:	3718      	adds	r7, #24
 8016190:	46bd      	mov	sp, r7
 8016192:	bd80      	pop	{r7, pc}

08016194 <CheckSrcCountRange>:

/*
 * Check Src Count Range
 */
SECUREC_INLINE errno_t CheckSrcCountRange(char *strDest, size_t destMax, const char *strSrc, size_t count)
{
 8016194:	b480      	push	{r7}
 8016196:	b089      	sub	sp, #36	; 0x24
 8016198:	af00      	add	r7, sp, #0
 801619a:	60f8      	str	r0, [r7, #12]
 801619c:	60b9      	str	r1, [r7, #8]
 801619e:	607a      	str	r2, [r7, #4]
 80161a0:	603b      	str	r3, [r7, #0]
    size_t tmpDestMax = destMax;
 80161a2:	68bb      	ldr	r3, [r7, #8]
 80161a4:	617b      	str	r3, [r7, #20]
    size_t tmpCount = count;
 80161a6:	683b      	ldr	r3, [r7, #0]
 80161a8:	61bb      	str	r3, [r7, #24]
    const char *endPos = strSrc;
 80161aa:	687b      	ldr	r3, [r7, #4]
 80161ac:	61fb      	str	r3, [r7, #28]

    /* Use destMax and  count as boundary checker and destMax must be greater than zero */
    while (*(endPos) != '\0' && tmpDestMax > 0 && tmpCount > 0) {
 80161ae:	e008      	b.n	80161c2 <CheckSrcCountRange+0x2e>
        ++endPos;
 80161b0:	69fb      	ldr	r3, [r7, #28]
 80161b2:	3301      	adds	r3, #1
 80161b4:	61fb      	str	r3, [r7, #28]
        --tmpCount;
 80161b6:	69bb      	ldr	r3, [r7, #24]
 80161b8:	3b01      	subs	r3, #1
 80161ba:	61bb      	str	r3, [r7, #24]
        --tmpDestMax;
 80161bc:	697b      	ldr	r3, [r7, #20]
 80161be:	3b01      	subs	r3, #1
 80161c0:	617b      	str	r3, [r7, #20]
    while (*(endPos) != '\0' && tmpDestMax > 0 && tmpCount > 0) {
 80161c2:	69fb      	ldr	r3, [r7, #28]
 80161c4:	781b      	ldrb	r3, [r3, #0]
 80161c6:	2b00      	cmp	r3, #0
 80161c8:	d005      	beq.n	80161d6 <CheckSrcCountRange+0x42>
 80161ca:	697b      	ldr	r3, [r7, #20]
 80161cc:	2b00      	cmp	r3, #0
 80161ce:	d002      	beq.n	80161d6 <CheckSrcCountRange+0x42>
 80161d0:	69bb      	ldr	r3, [r7, #24]
 80161d2:	2b00      	cmp	r3, #0
 80161d4:	d1ec      	bne.n	80161b0 <CheckSrcCountRange+0x1c>
    }
    if (tmpDestMax == 0) {
 80161d6:	697b      	ldr	r3, [r7, #20]
 80161d8:	2b00      	cmp	r3, #0
 80161da:	d104      	bne.n	80161e6 <CheckSrcCountRange+0x52>
        strDest[0] = '\0';
 80161dc:	68fb      	ldr	r3, [r7, #12]
 80161de:	2200      	movs	r2, #0
 80161e0:	701a      	strb	r2, [r3, #0]
        SECUREC_ERROR_INVALID_RANGE("strncpy_s");
        return ERANGE_AND_RESET;
 80161e2:	23a2      	movs	r3, #162	; 0xa2
 80161e4:	e000      	b.n	80161e8 <CheckSrcCountRange+0x54>
    }
    return EOK;
 80161e6:	2300      	movs	r3, #0
}
 80161e8:	4618      	mov	r0, r3
 80161ea:	3724      	adds	r7, #36	; 0x24
 80161ec:	46bd      	mov	sp, r7
 80161ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80161f2:	4770      	bx	lr

080161f4 <strncpy_error>:

/*
 * Handling errors, when dest equal src return EOK
 */
errno_t strncpy_error(char *strDest, size_t destMax, const char *strSrc, size_t count)
{
 80161f4:	b580      	push	{r7, lr}
 80161f6:	b084      	sub	sp, #16
 80161f8:	af00      	add	r7, sp, #0
 80161fa:	60f8      	str	r0, [r7, #12]
 80161fc:	60b9      	str	r1, [r7, #8]
 80161fe:	607a      	str	r2, [r7, #4]
 8016200:	603b      	str	r3, [r7, #0]
    if (destMax == 0 || destMax > SECUREC_STRING_MAX_LEN) {
 8016202:	68bb      	ldr	r3, [r7, #8]
 8016204:	2b00      	cmp	r3, #0
 8016206:	d002      	beq.n	801620e <strncpy_error+0x1a>
 8016208:	68bb      	ldr	r3, [r7, #8]
 801620a:	2b00      	cmp	r3, #0
 801620c:	da01      	bge.n	8016212 <strncpy_error+0x1e>
        SECUREC_ERROR_INVALID_RANGE("strncpy_s");
        return ERANGE;
 801620e:	2322      	movs	r3, #34	; 0x22
 8016210:	e026      	b.n	8016260 <strncpy_error+0x6c>
    }
    if (strDest == NULL || strSrc == NULL) {
 8016212:	68fb      	ldr	r3, [r7, #12]
 8016214:	2b00      	cmp	r3, #0
 8016216:	d002      	beq.n	801621e <strncpy_error+0x2a>
 8016218:	687b      	ldr	r3, [r7, #4]
 801621a:	2b00      	cmp	r3, #0
 801621c:	d109      	bne.n	8016232 <strncpy_error+0x3e>
        SECUREC_ERROR_INVALID_PARAMTER("strncpy_s");
        if (strDest != NULL) {
 801621e:	68fb      	ldr	r3, [r7, #12]
 8016220:	2b00      	cmp	r3, #0
 8016222:	d004      	beq.n	801622e <strncpy_error+0x3a>
            strDest[0] = '\0';
 8016224:	68fb      	ldr	r3, [r7, #12]
 8016226:	2200      	movs	r2, #0
 8016228:	701a      	strb	r2, [r3, #0]
            return EINVAL_AND_RESET;
 801622a:	2396      	movs	r3, #150	; 0x96
 801622c:	e018      	b.n	8016260 <strncpy_error+0x6c>
        }
        return EINVAL;
 801622e:	2316      	movs	r3, #22
 8016230:	e016      	b.n	8016260 <strncpy_error+0x6c>
    }
    if (count > SECUREC_STRING_MAX_LEN) {
 8016232:	683b      	ldr	r3, [r7, #0]
 8016234:	2b00      	cmp	r3, #0
 8016236:	da04      	bge.n	8016242 <strncpy_error+0x4e>
        strDest[0] = '\0';      /* Clear dest string */
 8016238:	68fb      	ldr	r3, [r7, #12]
 801623a:	2200      	movs	r2, #0
 801623c:	701a      	strb	r2, [r3, #0]
        SECUREC_ERROR_INVALID_RANGE("strncpy_s");
        return ERANGE_AND_RESET;
 801623e:	23a2      	movs	r3, #162	; 0xa2
 8016240:	e00e      	b.n	8016260 <strncpy_error+0x6c>
    }
    if (count == 0) {
 8016242:	683b      	ldr	r3, [r7, #0]
 8016244:	2b00      	cmp	r3, #0
 8016246:	d104      	bne.n	8016252 <strncpy_error+0x5e>
        strDest[0] = '\0';
 8016248:	68fb      	ldr	r3, [r7, #12]
 801624a:	2200      	movs	r2, #0
 801624c:	701a      	strb	r2, [r3, #0]
        return EOK;
 801624e:	2300      	movs	r3, #0
 8016250:	e006      	b.n	8016260 <strncpy_error+0x6c>
    }
    return CheckSrcCountRange(strDest, destMax, strSrc, count);
 8016252:	683b      	ldr	r3, [r7, #0]
 8016254:	687a      	ldr	r2, [r7, #4]
 8016256:	68b9      	ldr	r1, [r7, #8]
 8016258:	68f8      	ldr	r0, [r7, #12]
 801625a:	f7ff ff9b 	bl	8016194 <CheckSrcCountRange>
 801625e:	4603      	mov	r3, r0
}
 8016260:	4618      	mov	r0, r3
 8016262:	3710      	adds	r7, #16
 8016264:	46bd      	mov	sp, r7
 8016266:	bd80      	pop	{r7, pc}

08016268 <strncpy_s>:
 *    EOVERLAP_AND_RESET   dest buffer and source buffer are overlapped and all  parameters are valid
 *
 *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
 */
errno_t strncpy_s(char *strDest, size_t destMax, const char *strSrc, size_t count)
{
 8016268:	b580      	push	{r7, lr}
 801626a:	b08c      	sub	sp, #48	; 0x30
 801626c:	af00      	add	r7, sp, #0
 801626e:	60f8      	str	r0, [r7, #12]
 8016270:	60b9      	str	r1, [r7, #8]
 8016272:	607a      	str	r2, [r7, #4]
 8016274:	603b      	str	r3, [r7, #0]
 8016276:	4b47      	ldr	r3, [pc, #284]	; (8016394 <strncpy_s+0x12c>)
 8016278:	681b      	ldr	r3, [r3, #0]
 801627a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801627c:	f04f 0300 	mov.w	r3, #0
    if (SECUREC_STRNCPY_PARAM_OK(strDest, destMax, strSrc, count)) {
 8016280:	68bb      	ldr	r3, [r7, #8]
 8016282:	2b00      	cmp	r3, #0
 8016284:	d074      	beq.n	8016370 <strncpy_s+0x108>
 8016286:	68bb      	ldr	r3, [r7, #8]
 8016288:	2b00      	cmp	r3, #0
 801628a:	db71      	blt.n	8016370 <strncpy_s+0x108>
 801628c:	68fb      	ldr	r3, [r7, #12]
 801628e:	2b00      	cmp	r3, #0
 8016290:	d06e      	beq.n	8016370 <strncpy_s+0x108>
 8016292:	687b      	ldr	r3, [r7, #4]
 8016294:	2b00      	cmp	r3, #0
 8016296:	d06b      	beq.n	8016370 <strncpy_s+0x108>
 8016298:	683b      	ldr	r3, [r7, #0]
 801629a:	2b00      	cmp	r3, #0
 801629c:	db68      	blt.n	8016370 <strncpy_s+0x108>
 801629e:	683b      	ldr	r3, [r7, #0]
 80162a0:	2b00      	cmp	r3, #0
 80162a2:	d065      	beq.n	8016370 <strncpy_s+0x108>
        size_t minCpLen;        /* Use it to store the maxi length limit */
        if (count < destMax) {
 80162a4:	683a      	ldr	r2, [r7, #0]
 80162a6:	68bb      	ldr	r3, [r7, #8]
 80162a8:	429a      	cmp	r2, r3
 80162aa:	d216      	bcs.n	80162da <strncpy_s+0x72>
            SECUREC_CALC_STR_LEN(strSrc, count, &minCpLen); /* No ending terminator */
 80162ac:	687b      	ldr	r3, [r7, #4]
 80162ae:	61bb      	str	r3, [r7, #24]
 80162b0:	683b      	ldr	r3, [r7, #0]
 80162b2:	61fb      	str	r3, [r7, #28]
 80162b4:	e005      	b.n	80162c2 <strncpy_s+0x5a>
 80162b6:	69fb      	ldr	r3, [r7, #28]
 80162b8:	3b01      	subs	r3, #1
 80162ba:	61fb      	str	r3, [r7, #28]
 80162bc:	69bb      	ldr	r3, [r7, #24]
 80162be:	3301      	adds	r3, #1
 80162c0:	61bb      	str	r3, [r7, #24]
 80162c2:	69fb      	ldr	r3, [r7, #28]
 80162c4:	2b00      	cmp	r3, #0
 80162c6:	d003      	beq.n	80162d0 <strncpy_s+0x68>
 80162c8:	69bb      	ldr	r3, [r7, #24]
 80162ca:	781b      	ldrb	r3, [r3, #0]
 80162cc:	2b00      	cmp	r3, #0
 80162ce:	d1f2      	bne.n	80162b6 <strncpy_s+0x4e>
 80162d0:	69ba      	ldr	r2, [r7, #24]
 80162d2:	687b      	ldr	r3, [r7, #4]
 80162d4:	1ad3      	subs	r3, r2, r3
 80162d6:	617b      	str	r3, [r7, #20]
 80162d8:	e020      	b.n	801631c <strncpy_s+0xb4>
        } else {
            size_t tmpCount = destMax;
 80162da:	68bb      	ldr	r3, [r7, #8]
 80162dc:	62bb      	str	r3, [r7, #40]	; 0x28
#ifdef  SECUREC_COMPATIBLE_WIN_FORMAT
            if (count == ((size_t)(-1))) {
                tmpCount = destMax - 1;
            }
#endif
            SECUREC_CALC_STR_LEN(strSrc, tmpCount, &minCpLen); /* No ending terminator */
 80162de:	687b      	ldr	r3, [r7, #4]
 80162e0:	623b      	str	r3, [r7, #32]
 80162e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80162e4:	627b      	str	r3, [r7, #36]	; 0x24
 80162e6:	e005      	b.n	80162f4 <strncpy_s+0x8c>
 80162e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80162ea:	3b01      	subs	r3, #1
 80162ec:	627b      	str	r3, [r7, #36]	; 0x24
 80162ee:	6a3b      	ldr	r3, [r7, #32]
 80162f0:	3301      	adds	r3, #1
 80162f2:	623b      	str	r3, [r7, #32]
 80162f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80162f6:	2b00      	cmp	r3, #0
 80162f8:	d003      	beq.n	8016302 <strncpy_s+0x9a>
 80162fa:	6a3b      	ldr	r3, [r7, #32]
 80162fc:	781b      	ldrb	r3, [r3, #0]
 80162fe:	2b00      	cmp	r3, #0
 8016300:	d1f2      	bne.n	80162e8 <strncpy_s+0x80>
 8016302:	6a3a      	ldr	r2, [r7, #32]
 8016304:	687b      	ldr	r3, [r7, #4]
 8016306:	1ad3      	subs	r3, r2, r3
 8016308:	617b      	str	r3, [r7, #20]
            if (minCpLen == destMax) {
 801630a:	697b      	ldr	r3, [r7, #20]
 801630c:	68ba      	ldr	r2, [r7, #8]
 801630e:	429a      	cmp	r2, r3
 8016310:	d104      	bne.n	801631c <strncpy_s+0xb4>
                strDest[0] = '\0';
 8016312:	68fb      	ldr	r3, [r7, #12]
 8016314:	2200      	movs	r2, #0
 8016316:	701a      	strb	r2, [r3, #0]
                SECUREC_ERROR_INVALID_RANGE("strncpy_s");
                return ERANGE_AND_RESET;
 8016318:	23a2      	movs	r3, #162	; 0xa2
 801631a:	e030      	b.n	801637e <strncpy_s+0x116>
            }
        }
        if (SECUREC_STRING_NO_OVERLAP(strDest, strSrc, minCpLen) || strDest == strSrc) {
 801631c:	687a      	ldr	r2, [r7, #4]
 801631e:	68fb      	ldr	r3, [r7, #12]
 8016320:	429a      	cmp	r2, r3
 8016322:	d205      	bcs.n	8016330 <strncpy_s+0xc8>
 8016324:	697b      	ldr	r3, [r7, #20]
 8016326:	687a      	ldr	r2, [r7, #4]
 8016328:	4413      	add	r3, r2
 801632a:	68fa      	ldr	r2, [r7, #12]
 801632c:	429a      	cmp	r2, r3
 801632e:	d80d      	bhi.n	801634c <strncpy_s+0xe4>
 8016330:	68fa      	ldr	r2, [r7, #12]
 8016332:	687b      	ldr	r3, [r7, #4]
 8016334:	429a      	cmp	r2, r3
 8016336:	d205      	bcs.n	8016344 <strncpy_s+0xdc>
 8016338:	697b      	ldr	r3, [r7, #20]
 801633a:	68fa      	ldr	r2, [r7, #12]
 801633c:	4413      	add	r3, r2
 801633e:	687a      	ldr	r2, [r7, #4]
 8016340:	429a      	cmp	r2, r3
 8016342:	d803      	bhi.n	801634c <strncpy_s+0xe4>
 8016344:	68fa      	ldr	r2, [r7, #12]
 8016346:	687b      	ldr	r3, [r7, #4]
 8016348:	429a      	cmp	r2, r3
 801634a:	d10c      	bne.n	8016366 <strncpy_s+0xfe>
            /* Not overlap */
            SECUREC_MEMCPY_WARP_OPT(strDest, strSrc, minCpLen);    /* Copy string without terminator */
 801634c:	697b      	ldr	r3, [r7, #20]
 801634e:	461a      	mov	r2, r3
 8016350:	6879      	ldr	r1, [r7, #4]
 8016352:	68f8      	ldr	r0, [r7, #12]
 8016354:	f002 fdbc 	bl	8018ed0 <memcpy>
            strDest[minCpLen] = '\0';
 8016358:	697b      	ldr	r3, [r7, #20]
 801635a:	68fa      	ldr	r2, [r7, #12]
 801635c:	4413      	add	r3, r2
 801635e:	2200      	movs	r2, #0
 8016360:	701a      	strb	r2, [r3, #0]
            return EOK;
 8016362:	2300      	movs	r3, #0
 8016364:	e00b      	b.n	801637e <strncpy_s+0x116>
        } else {
            strDest[0] = '\0';
 8016366:	68fb      	ldr	r3, [r7, #12]
 8016368:	2200      	movs	r2, #0
 801636a:	701a      	strb	r2, [r3, #0]
            SECUREC_ERROR_BUFFER_OVERLAP("strncpy_s");
            return EOVERLAP_AND_RESET;
 801636c:	23b6      	movs	r3, #182	; 0xb6
 801636e:	e006      	b.n	801637e <strncpy_s+0x116>
        }
    }
    return strncpy_error(strDest, destMax, strSrc, count);
 8016370:	683b      	ldr	r3, [r7, #0]
 8016372:	687a      	ldr	r2, [r7, #4]
 8016374:	68b9      	ldr	r1, [r7, #8]
 8016376:	68f8      	ldr	r0, [r7, #12]
 8016378:	f7ff ff3c 	bl	80161f4 <strncpy_error>
 801637c:	4603      	mov	r3, r0
}
 801637e:	4a05      	ldr	r2, [pc, #20]	; (8016394 <strncpy_s+0x12c>)
 8016380:	6811      	ldr	r1, [r2, #0]
 8016382:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016384:	4051      	eors	r1, r2
 8016386:	d001      	beq.n	801638c <strncpy_s+0x124>
 8016388:	f7ee f82e 	bl	80043e8 <__stack_chk_fail>
 801638c:	4618      	mov	r0, r3
 801638e:	3730      	adds	r7, #48	; 0x30
 8016390:	46bd      	mov	sp, r7
 8016392:	bd80      	pop	{r7, pc}
 8016394:	08023034 	.word	0x08023034

08016398 <SecDoCat>:

/*
 * Befor this function, the basic parameter checking has been done
 */
SECUREC_INLINE errno_t SecDoCat(char *strDest, size_t destMax, const char *strSrc)
{
 8016398:	b580      	push	{r7, lr}
 801639a:	b08c      	sub	sp, #48	; 0x30
 801639c:	af00      	add	r7, sp, #0
 801639e:	60f8      	str	r0, [r7, #12]
 80163a0:	60b9      	str	r1, [r7, #8]
 80163a2:	607a      	str	r2, [r7, #4]
 80163a4:	4b42      	ldr	r3, [pc, #264]	; (80164b0 <SecDoCat+0x118>)
 80163a6:	681b      	ldr	r3, [r3, #0]
 80163a8:	62fb      	str	r3, [r7, #44]	; 0x2c
 80163aa:	f04f 0300 	mov.w	r3, #0
    size_t destLen;
    size_t srcLen;
    size_t maxSrcLen;
    SECUREC_CALC_STR_LEN(strDest, destMax, &destLen);
 80163ae:	68fb      	ldr	r3, [r7, #12]
 80163b0:	61bb      	str	r3, [r7, #24]
 80163b2:	68bb      	ldr	r3, [r7, #8]
 80163b4:	61fb      	str	r3, [r7, #28]
 80163b6:	e005      	b.n	80163c4 <SecDoCat+0x2c>
 80163b8:	69fb      	ldr	r3, [r7, #28]
 80163ba:	3b01      	subs	r3, #1
 80163bc:	61fb      	str	r3, [r7, #28]
 80163be:	69bb      	ldr	r3, [r7, #24]
 80163c0:	3301      	adds	r3, #1
 80163c2:	61bb      	str	r3, [r7, #24]
 80163c4:	69fb      	ldr	r3, [r7, #28]
 80163c6:	2b00      	cmp	r3, #0
 80163c8:	d003      	beq.n	80163d2 <SecDoCat+0x3a>
 80163ca:	69bb      	ldr	r3, [r7, #24]
 80163cc:	781b      	ldrb	r3, [r3, #0]
 80163ce:	2b00      	cmp	r3, #0
 80163d0:	d1f2      	bne.n	80163b8 <SecDoCat+0x20>
 80163d2:	69ba      	ldr	r2, [r7, #24]
 80163d4:	68fb      	ldr	r3, [r7, #12]
 80163d6:	1ad3      	subs	r3, r2, r3
 80163d8:	613b      	str	r3, [r7, #16]
    /* Only optimize strSrc, do not apply this function to strDest */
    maxSrcLen = destMax - destLen;
 80163da:	693b      	ldr	r3, [r7, #16]
 80163dc:	68ba      	ldr	r2, [r7, #8]
 80163de:	1ad3      	subs	r3, r2, r3
 80163e0:	62bb      	str	r3, [r7, #40]	; 0x28
    SECUREC_CALC_STR_LEN_OPT(strSrc, maxSrcLen, &srcLen);
 80163e2:	687b      	ldr	r3, [r7, #4]
 80163e4:	623b      	str	r3, [r7, #32]
 80163e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80163e8:	627b      	str	r3, [r7, #36]	; 0x24
 80163ea:	e005      	b.n	80163f8 <SecDoCat+0x60>
 80163ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80163ee:	3b01      	subs	r3, #1
 80163f0:	627b      	str	r3, [r7, #36]	; 0x24
 80163f2:	6a3b      	ldr	r3, [r7, #32]
 80163f4:	3301      	adds	r3, #1
 80163f6:	623b      	str	r3, [r7, #32]
 80163f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80163fa:	2b00      	cmp	r3, #0
 80163fc:	d003      	beq.n	8016406 <SecDoCat+0x6e>
 80163fe:	6a3b      	ldr	r3, [r7, #32]
 8016400:	781b      	ldrb	r3, [r3, #0]
 8016402:	2b00      	cmp	r3, #0
 8016404:	d1f2      	bne.n	80163ec <SecDoCat+0x54>
 8016406:	6a3a      	ldr	r2, [r7, #32]
 8016408:	687b      	ldr	r3, [r7, #4]
 801640a:	1ad3      	subs	r3, r2, r3
 801640c:	617b      	str	r3, [r7, #20]

    if (SECUREC_CAT_STRING_IS_OVERLAP(strDest, destLen, strSrc, srcLen)) {
 801640e:	68fa      	ldr	r2, [r7, #12]
 8016410:	687b      	ldr	r3, [r7, #4]
 8016412:	429a      	cmp	r2, r3
 8016414:	d207      	bcs.n	8016426 <SecDoCat+0x8e>
 8016416:	693a      	ldr	r2, [r7, #16]
 8016418:	697b      	ldr	r3, [r7, #20]
 801641a:	4413      	add	r3, r2
 801641c:	68fa      	ldr	r2, [r7, #12]
 801641e:	4413      	add	r3, r2
 8016420:	687a      	ldr	r2, [r7, #4]
 8016422:	429a      	cmp	r2, r3
 8016424:	d909      	bls.n	801643a <SecDoCat+0xa2>
 8016426:	687a      	ldr	r2, [r7, #4]
 8016428:	68fb      	ldr	r3, [r7, #12]
 801642a:	429a      	cmp	r2, r3
 801642c:	d216      	bcs.n	801645c <SecDoCat+0xc4>
 801642e:	697b      	ldr	r3, [r7, #20]
 8016430:	687a      	ldr	r2, [r7, #4]
 8016432:	4413      	add	r3, r2
 8016434:	68fa      	ldr	r2, [r7, #12]
 8016436:	429a      	cmp	r2, r3
 8016438:	d810      	bhi.n	801645c <SecDoCat+0xc4>
        strDest[0] = '\0';
 801643a:	68fb      	ldr	r3, [r7, #12]
 801643c:	2200      	movs	r2, #0
 801643e:	701a      	strb	r2, [r3, #0]
        if (strDest + destLen <= strSrc && destLen == destMax) {
 8016440:	693b      	ldr	r3, [r7, #16]
 8016442:	68fa      	ldr	r2, [r7, #12]
 8016444:	4413      	add	r3, r2
 8016446:	687a      	ldr	r2, [r7, #4]
 8016448:	429a      	cmp	r2, r3
 801644a:	d305      	bcc.n	8016458 <SecDoCat+0xc0>
 801644c:	693b      	ldr	r3, [r7, #16]
 801644e:	68ba      	ldr	r2, [r7, #8]
 8016450:	429a      	cmp	r2, r3
 8016452:	d101      	bne.n	8016458 <SecDoCat+0xc0>
            SECUREC_ERROR_INVALID_PARAMTER("strcat_s");
            return EINVAL_AND_RESET;
 8016454:	2396      	movs	r3, #150	; 0x96
 8016456:	e020      	b.n	801649a <SecDoCat+0x102>
        }
        SECUREC_ERROR_BUFFER_OVERLAP("strcat_s");
        return EOVERLAP_AND_RESET;
 8016458:	23b6      	movs	r3, #182	; 0xb6
 801645a:	e01e      	b.n	801649a <SecDoCat+0x102>
    }
    if (srcLen + destLen >= destMax || strDest == strSrc) {
 801645c:	697a      	ldr	r2, [r7, #20]
 801645e:	693b      	ldr	r3, [r7, #16]
 8016460:	4413      	add	r3, r2
 8016462:	68ba      	ldr	r2, [r7, #8]
 8016464:	429a      	cmp	r2, r3
 8016466:	d903      	bls.n	8016470 <SecDoCat+0xd8>
 8016468:	68fa      	ldr	r2, [r7, #12]
 801646a:	687b      	ldr	r3, [r7, #4]
 801646c:	429a      	cmp	r2, r3
 801646e:	d10a      	bne.n	8016486 <SecDoCat+0xee>
        strDest[0] = '\0';
 8016470:	68fb      	ldr	r3, [r7, #12]
 8016472:	2200      	movs	r2, #0
 8016474:	701a      	strb	r2, [r3, #0]
        if (destLen == destMax) {
 8016476:	693b      	ldr	r3, [r7, #16]
 8016478:	68ba      	ldr	r2, [r7, #8]
 801647a:	429a      	cmp	r2, r3
 801647c:	d101      	bne.n	8016482 <SecDoCat+0xea>
            SECUREC_ERROR_INVALID_PARAMTER("strcat_s");
            return EINVAL_AND_RESET;
 801647e:	2396      	movs	r3, #150	; 0x96
 8016480:	e00b      	b.n	801649a <SecDoCat+0x102>
        }
        SECUREC_ERROR_INVALID_RANGE("strcat_s");
        return ERANGE_AND_RESET;
 8016482:	23a2      	movs	r3, #162	; 0xa2
 8016484:	e009      	b.n	801649a <SecDoCat+0x102>
    }
    SECUREC_MEMCPY_WARP_OPT(strDest + destLen, strSrc, srcLen + 1); /* Single character length  include \0 */
 8016486:	693b      	ldr	r3, [r7, #16]
 8016488:	68fa      	ldr	r2, [r7, #12]
 801648a:	18d0      	adds	r0, r2, r3
 801648c:	697b      	ldr	r3, [r7, #20]
 801648e:	3301      	adds	r3, #1
 8016490:	461a      	mov	r2, r3
 8016492:	6879      	ldr	r1, [r7, #4]
 8016494:	f002 fd1c 	bl	8018ed0 <memcpy>
    return EOK;
 8016498:	2300      	movs	r3, #0
}
 801649a:	4a05      	ldr	r2, [pc, #20]	; (80164b0 <SecDoCat+0x118>)
 801649c:	6811      	ldr	r1, [r2, #0]
 801649e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80164a0:	4051      	eors	r1, r2
 80164a2:	d001      	beq.n	80164a8 <SecDoCat+0x110>
 80164a4:	f7ed ffa0 	bl	80043e8 <__stack_chk_fail>
 80164a8:	4618      	mov	r0, r3
 80164aa:	3730      	adds	r7, #48	; 0x30
 80164ac:	46bd      	mov	sp, r7
 80164ae:	bd80      	pop	{r7, pc}
 80164b0:	08023038 	.word	0x08023038

080164b4 <strcat_s>:
 *    EOVERLAP_AND_RESET   dest buffer and source buffer are overlapped and all  parameters are valid
 *
 *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
 */
errno_t strcat_s(char *strDest, size_t destMax, const char *strSrc)
{
 80164b4:	b580      	push	{r7, lr}
 80164b6:	b084      	sub	sp, #16
 80164b8:	af00      	add	r7, sp, #0
 80164ba:	60f8      	str	r0, [r7, #12]
 80164bc:	60b9      	str	r1, [r7, #8]
 80164be:	607a      	str	r2, [r7, #4]
    if (destMax == 0 || destMax > SECUREC_STRING_MAX_LEN) {
 80164c0:	68bb      	ldr	r3, [r7, #8]
 80164c2:	2b00      	cmp	r3, #0
 80164c4:	d002      	beq.n	80164cc <strcat_s+0x18>
 80164c6:	68bb      	ldr	r3, [r7, #8]
 80164c8:	2b00      	cmp	r3, #0
 80164ca:	da01      	bge.n	80164d0 <strcat_s+0x1c>
        SECUREC_ERROR_INVALID_RANGE("strcat_s");
        return ERANGE;
 80164cc:	2322      	movs	r3, #34	; 0x22
 80164ce:	e015      	b.n	80164fc <strcat_s+0x48>
    }
    if (strDest == NULL || strSrc == NULL) {
 80164d0:	68fb      	ldr	r3, [r7, #12]
 80164d2:	2b00      	cmp	r3, #0
 80164d4:	d002      	beq.n	80164dc <strcat_s+0x28>
 80164d6:	687b      	ldr	r3, [r7, #4]
 80164d8:	2b00      	cmp	r3, #0
 80164da:	d109      	bne.n	80164f0 <strcat_s+0x3c>
        SECUREC_ERROR_INVALID_PARAMTER("strcat_s");
        if (strDest != NULL) {
 80164dc:	68fb      	ldr	r3, [r7, #12]
 80164de:	2b00      	cmp	r3, #0
 80164e0:	d004      	beq.n	80164ec <strcat_s+0x38>
            strDest[0] = '\0';
 80164e2:	68fb      	ldr	r3, [r7, #12]
 80164e4:	2200      	movs	r2, #0
 80164e6:	701a      	strb	r2, [r3, #0]
            return EINVAL_AND_RESET;
 80164e8:	2396      	movs	r3, #150	; 0x96
 80164ea:	e007      	b.n	80164fc <strcat_s+0x48>
        }
        return EINVAL;
 80164ec:	2316      	movs	r3, #22
 80164ee:	e005      	b.n	80164fc <strcat_s+0x48>
    }
    return SecDoCat(strDest, destMax, strSrc);
 80164f0:	687a      	ldr	r2, [r7, #4]
 80164f2:	68b9      	ldr	r1, [r7, #8]
 80164f4:	68f8      	ldr	r0, [r7, #12]
 80164f6:	f7ff ff4f 	bl	8016398 <SecDoCat>
 80164fa:	4603      	mov	r3, r0
}
 80164fc:	4618      	mov	r0, r3
 80164fe:	3710      	adds	r7, #16
 8016500:	46bd      	mov	sp, r7
 8016502:	bd80      	pop	{r7, pc}

08016504 <SecMemcpyError>:

/*
 * Handling errors
 */
SECUREC_INLINE errno_t SecMemcpyError(void *dest, size_t destMax, const void *src, size_t count)
{
 8016504:	b580      	push	{r7, lr}
 8016506:	b084      	sub	sp, #16
 8016508:	af00      	add	r7, sp, #0
 801650a:	60f8      	str	r0, [r7, #12]
 801650c:	60b9      	str	r1, [r7, #8]
 801650e:	607a      	str	r2, [r7, #4]
 8016510:	603b      	str	r3, [r7, #0]
    if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN) {
 8016512:	68bb      	ldr	r3, [r7, #8]
 8016514:	2b00      	cmp	r3, #0
 8016516:	d002      	beq.n	801651e <SecMemcpyError+0x1a>
 8016518:	68bb      	ldr	r3, [r7, #8]
 801651a:	2b00      	cmp	r3, #0
 801651c:	da01      	bge.n	8016522 <SecMemcpyError+0x1e>
        SECUREC_ERROR_INVALID_RANGE("memcpy_s");
        return ERANGE;
 801651e:	2322      	movs	r3, #34	; 0x22
 8016520:	e038      	b.n	8016594 <SecMemcpyError+0x90>
    }
    if (dest == NULL || src == NULL) {
 8016522:	68fb      	ldr	r3, [r7, #12]
 8016524:	2b00      	cmp	r3, #0
 8016526:	d002      	beq.n	801652e <SecMemcpyError+0x2a>
 8016528:	687b      	ldr	r3, [r7, #4]
 801652a:	2b00      	cmp	r3, #0
 801652c:	d10b      	bne.n	8016546 <SecMemcpyError+0x42>
        SECUREC_ERROR_INVALID_PARAMTER("memcpy_s");
        if (dest != NULL) {
 801652e:	68fb      	ldr	r3, [r7, #12]
 8016530:	2b00      	cmp	r3, #0
 8016532:	d006      	beq.n	8016542 <SecMemcpyError+0x3e>
            (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
 8016534:	68ba      	ldr	r2, [r7, #8]
 8016536:	2100      	movs	r1, #0
 8016538:	68f8      	ldr	r0, [r7, #12]
 801653a:	f7f8 f983 	bl	800e844 <memset>
            return EINVAL_AND_RESET;
 801653e:	2396      	movs	r3, #150	; 0x96
 8016540:	e028      	b.n	8016594 <SecMemcpyError+0x90>
        }
        return EINVAL;
 8016542:	2316      	movs	r3, #22
 8016544:	e026      	b.n	8016594 <SecMemcpyError+0x90>
    }
    if (count > destMax) {
 8016546:	683a      	ldr	r2, [r7, #0]
 8016548:	68bb      	ldr	r3, [r7, #8]
 801654a:	429a      	cmp	r2, r3
 801654c:	d906      	bls.n	801655c <SecMemcpyError+0x58>
        (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
 801654e:	68ba      	ldr	r2, [r7, #8]
 8016550:	2100      	movs	r1, #0
 8016552:	68f8      	ldr	r0, [r7, #12]
 8016554:	f7f8 f976 	bl	800e844 <memset>
        SECUREC_ERROR_INVALID_RANGE("memcpy_s");
        return ERANGE_AND_RESET;
 8016558:	23a2      	movs	r3, #162	; 0xa2
 801655a:	e01b      	b.n	8016594 <SecMemcpyError+0x90>
    }
    if (SECUREC_MEMORY_IS_OVERLAP(dest, src, count)) {
 801655c:	687a      	ldr	r2, [r7, #4]
 801655e:	68fb      	ldr	r3, [r7, #12]
 8016560:	429a      	cmp	r2, r3
 8016562:	d205      	bcs.n	8016570 <SecMemcpyError+0x6c>
 8016564:	687a      	ldr	r2, [r7, #4]
 8016566:	683b      	ldr	r3, [r7, #0]
 8016568:	4413      	add	r3, r2
 801656a:	68fa      	ldr	r2, [r7, #12]
 801656c:	429a      	cmp	r2, r3
 801656e:	d309      	bcc.n	8016584 <SecMemcpyError+0x80>
 8016570:	68fa      	ldr	r2, [r7, #12]
 8016572:	687b      	ldr	r3, [r7, #4]
 8016574:	429a      	cmp	r2, r3
 8016576:	d20c      	bcs.n	8016592 <SecMemcpyError+0x8e>
 8016578:	68fa      	ldr	r2, [r7, #12]
 801657a:	683b      	ldr	r3, [r7, #0]
 801657c:	4413      	add	r3, r2
 801657e:	687a      	ldr	r2, [r7, #4]
 8016580:	429a      	cmp	r2, r3
 8016582:	d206      	bcs.n	8016592 <SecMemcpyError+0x8e>
        (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
 8016584:	68ba      	ldr	r2, [r7, #8]
 8016586:	2100      	movs	r1, #0
 8016588:	68f8      	ldr	r0, [r7, #12]
 801658a:	f7f8 f95b 	bl	800e844 <memset>
        SECUREC_ERROR_BUFFER_OVERLAP("memcpy_s");
        return EOVERLAP_AND_RESET;
 801658e:	23b6      	movs	r3, #182	; 0xb6
 8016590:	e000      	b.n	8016594 <SecMemcpyError+0x90>
    }
    /* Count is 0 or dest equal src also ret EOK */
    return EOK;
 8016592:	2300      	movs	r3, #0
}
 8016594:	4618      	mov	r0, r3
 8016596:	3710      	adds	r7, #16
 8016598:	46bd      	mov	sp, r7
 801659a:	bd80      	pop	{r7, pc}

0801659c <memcpy_s>:
 *    if an error occurred, dest will be filled with 0.
 *    If the source and destination overlap, the behavior of memcpy_s is undefined.
 *    Use memmove_s to handle overlapping regions.
 */
errno_t memcpy_s(void *dest, size_t destMax, const void *src, size_t count)
{
 801659c:	b580      	push	{r7, lr}
 801659e:	b084      	sub	sp, #16
 80165a0:	af00      	add	r7, sp, #0
 80165a2:	60f8      	str	r0, [r7, #12]
 80165a4:	60b9      	str	r1, [r7, #8]
 80165a6:	607a      	str	r2, [r7, #4]
 80165a8:	603b      	str	r3, [r7, #0]
    if (SECUREC_MEMCPY_PARAM_OK(dest, destMax, src, count)) {
 80165aa:	683a      	ldr	r2, [r7, #0]
 80165ac:	68bb      	ldr	r3, [r7, #8]
 80165ae:	429a      	cmp	r2, r3
 80165b0:	bf94      	ite	ls
 80165b2:	2301      	movls	r3, #1
 80165b4:	2300      	movhi	r3, #0
 80165b6:	b2db      	uxtb	r3, r3
 80165b8:	2b00      	cmp	r3, #0
 80165ba:	d009      	beq.n	80165d0 <memcpy_s+0x34>
 80165bc:	68fb      	ldr	r3, [r7, #12]
 80165be:	2b00      	cmp	r3, #0
 80165c0:	bf14      	ite	ne
 80165c2:	2301      	movne	r3, #1
 80165c4:	2300      	moveq	r3, #0
 80165c6:	b2db      	uxtb	r3, r3
 80165c8:	2b00      	cmp	r3, #0
 80165ca:	d001      	beq.n	80165d0 <memcpy_s+0x34>
 80165cc:	2301      	movs	r3, #1
 80165ce:	e000      	b.n	80165d2 <memcpy_s+0x36>
 80165d0:	2300      	movs	r3, #0
 80165d2:	2b00      	cmp	r3, #0
 80165d4:	d009      	beq.n	80165ea <memcpy_s+0x4e>
 80165d6:	687b      	ldr	r3, [r7, #4]
 80165d8:	2b00      	cmp	r3, #0
 80165da:	bf14      	ite	ne
 80165dc:	2301      	movne	r3, #1
 80165de:	2300      	moveq	r3, #0
 80165e0:	b2db      	uxtb	r3, r3
 80165e2:	2b00      	cmp	r3, #0
 80165e4:	d001      	beq.n	80165ea <memcpy_s+0x4e>
 80165e6:	2301      	movs	r3, #1
 80165e8:	e000      	b.n	80165ec <memcpy_s+0x50>
 80165ea:	2300      	movs	r3, #0
 80165ec:	2b00      	cmp	r3, #0
 80165ee:	d007      	beq.n	8016600 <memcpy_s+0x64>
 80165f0:	68bb      	ldr	r3, [r7, #8]
 80165f2:	43db      	mvns	r3, r3
 80165f4:	0fdb      	lsrs	r3, r3, #31
 80165f6:	b2db      	uxtb	r3, r3
 80165f8:	2b00      	cmp	r3, #0
 80165fa:	d001      	beq.n	8016600 <memcpy_s+0x64>
 80165fc:	2301      	movs	r3, #1
 80165fe:	e000      	b.n	8016602 <memcpy_s+0x66>
 8016600:	2300      	movs	r3, #0
 8016602:	2b00      	cmp	r3, #0
 8016604:	d009      	beq.n	801661a <memcpy_s+0x7e>
 8016606:	683b      	ldr	r3, [r7, #0]
 8016608:	2b00      	cmp	r3, #0
 801660a:	bf14      	ite	ne
 801660c:	2301      	movne	r3, #1
 801660e:	2300      	moveq	r3, #0
 8016610:	b2db      	uxtb	r3, r3
 8016612:	2b00      	cmp	r3, #0
 8016614:	d001      	beq.n	801661a <memcpy_s+0x7e>
 8016616:	2301      	movs	r3, #1
 8016618:	e000      	b.n	801661c <memcpy_s+0x80>
 801661a:	2300      	movs	r3, #0
 801661c:	2b00      	cmp	r3, #0
 801661e:	d03d      	beq.n	801669c <memcpy_s+0x100>
 8016620:	687a      	ldr	r2, [r7, #4]
 8016622:	68fb      	ldr	r3, [r7, #12]
 8016624:	429a      	cmp	r2, r3
 8016626:	bf34      	ite	cc
 8016628:	2301      	movcc	r3, #1
 801662a:	2300      	movcs	r3, #0
 801662c:	b2db      	uxtb	r3, r3
 801662e:	2b00      	cmp	r3, #0
 8016630:	d00c      	beq.n	801664c <memcpy_s+0xb0>
 8016632:	687a      	ldr	r2, [r7, #4]
 8016634:	683b      	ldr	r3, [r7, #0]
 8016636:	4413      	add	r3, r2
 8016638:	68fa      	ldr	r2, [r7, #12]
 801663a:	429a      	cmp	r2, r3
 801663c:	bf2c      	ite	cs
 801663e:	2301      	movcs	r3, #1
 8016640:	2300      	movcc	r3, #0
 8016642:	b2db      	uxtb	r3, r3
 8016644:	2b00      	cmp	r3, #0
 8016646:	d001      	beq.n	801664c <memcpy_s+0xb0>
 8016648:	2301      	movs	r3, #1
 801664a:	e000      	b.n	801664e <memcpy_s+0xb2>
 801664c:	2300      	movs	r3, #0
 801664e:	2b00      	cmp	r3, #0
 8016650:	d118      	bne.n	8016684 <memcpy_s+0xe8>
 8016652:	68fa      	ldr	r2, [r7, #12]
 8016654:	687b      	ldr	r3, [r7, #4]
 8016656:	429a      	cmp	r2, r3
 8016658:	bf34      	ite	cc
 801665a:	2301      	movcc	r3, #1
 801665c:	2300      	movcs	r3, #0
 801665e:	b2db      	uxtb	r3, r3
 8016660:	2b00      	cmp	r3, #0
 8016662:	d00c      	beq.n	801667e <memcpy_s+0xe2>
 8016664:	68fa      	ldr	r2, [r7, #12]
 8016666:	683b      	ldr	r3, [r7, #0]
 8016668:	4413      	add	r3, r2
 801666a:	687a      	ldr	r2, [r7, #4]
 801666c:	429a      	cmp	r2, r3
 801666e:	bf2c      	ite	cs
 8016670:	2301      	movcs	r3, #1
 8016672:	2300      	movcc	r3, #0
 8016674:	b2db      	uxtb	r3, r3
 8016676:	2b00      	cmp	r3, #0
 8016678:	d001      	beq.n	801667e <memcpy_s+0xe2>
 801667a:	2301      	movs	r3, #1
 801667c:	e000      	b.n	8016680 <memcpy_s+0xe4>
 801667e:	2300      	movs	r3, #0
 8016680:	2b00      	cmp	r3, #0
 8016682:	d001      	beq.n	8016688 <memcpy_s+0xec>
 8016684:	2301      	movs	r3, #1
 8016686:	e000      	b.n	801668a <memcpy_s+0xee>
 8016688:	2300      	movs	r3, #0
 801668a:	2b00      	cmp	r3, #0
 801668c:	d006      	beq.n	801669c <memcpy_s+0x100>
        SECUREC_MEMCPY_WARP_OPT(dest, src, count);
 801668e:	683a      	ldr	r2, [r7, #0]
 8016690:	6879      	ldr	r1, [r7, #4]
 8016692:	68f8      	ldr	r0, [r7, #12]
 8016694:	f002 fc1c 	bl	8018ed0 <memcpy>
        return EOK;
 8016698:	2300      	movs	r3, #0
 801669a:	e006      	b.n	80166aa <memcpy_s+0x10e>
    }
    /* Meet some runtime violation, return error code */
    return SecMemcpyError(dest, destMax, src, count);
 801669c:	683b      	ldr	r3, [r7, #0]
 801669e:	687a      	ldr	r2, [r7, #4]
 80166a0:	68b9      	ldr	r1, [r7, #8]
 80166a2:	68f8      	ldr	r0, [r7, #12]
 80166a4:	f7ff ff2e 	bl	8016504 <SecMemcpyError>
 80166a8:	4603      	mov	r3, r0
}
 80166aa:	4618      	mov	r0, r3
 80166ac:	3710      	adds	r7, #16
 80166ae:	46bd      	mov	sp, r7
 80166b0:	bd80      	pop	{r7, pc}
	...

080166b4 <SecFormatFloat>:
static const char g_itoaLowerDigits[SECUREC_DIGITS_BUF_SIZE] = "0123456789abcdefx";

#if SECUREC_ENABLE_SPRINTF_FLOAT
/* Call system sprintf to format float value */
SECUREC_INLINE int SecFormatFloat(char *strDest, const char *format, ...)
{
 80166b4:	b40e      	push	{r1, r2, r3}
 80166b6:	b580      	push	{r7, lr}
 80166b8:	b087      	sub	sp, #28
 80166ba:	af00      	add	r7, sp, #0
 80166bc:	6078      	str	r0, [r7, #4]
 80166be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80166c0:	603b      	str	r3, [r7, #0]
 80166c2:	4b0e      	ldr	r3, [pc, #56]	; (80166fc <SecFormatFloat+0x48>)
 80166c4:	681b      	ldr	r3, [r3, #0]
 80166c6:	617b      	str	r3, [r7, #20]
 80166c8:	f04f 0300 	mov.w	r3, #0
    int ret;                    /* If initialization causes  e838 */
    va_list argList;

    va_start(argList, format);
 80166cc:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80166d0:	60fb      	str	r3, [r7, #12]
    SECUREC_MASK_VSPRINTF_WARNING
    ret = vsprintf(strDest, format, argList);
 80166d2:	68fa      	ldr	r2, [r7, #12]
 80166d4:	6839      	ldr	r1, [r7, #0]
 80166d6:	6878      	ldr	r0, [r7, #4]
 80166d8:	f004 f8ce 	bl	801a878 <vsprintf>
 80166dc:	6138      	str	r0, [r7, #16]
    SECUREC_END_MASK_VSPRINTF_WARNING
    va_end(argList);
    (void)argList; /* To clear e438 last value assigned not used , the compiler will optimize this code */

    return ret;
 80166de:	693b      	ldr	r3, [r7, #16]
}
 80166e0:	4a06      	ldr	r2, [pc, #24]	; (80166fc <SecFormatFloat+0x48>)
 80166e2:	6811      	ldr	r1, [r2, #0]
 80166e4:	697a      	ldr	r2, [r7, #20]
 80166e6:	4051      	eors	r1, r2
 80166e8:	d001      	beq.n	80166ee <SecFormatFloat+0x3a>
 80166ea:	f7ed fe7d 	bl	80043e8 <__stack_chk_fail>
 80166ee:	4618      	mov	r0, r3
 80166f0:	371c      	adds	r7, #28
 80166f2:	46bd      	mov	sp, r7
 80166f4:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 80166f8:	b003      	add	sp, #12
 80166fa:	4770      	bx	lr
 80166fc:	0802303c 	.word	0x0802303c

08016700 <SecFormatLongDouble>:

#if defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && SECUREC_ENABLE_SPRINTF_LONG_DOUBLE
/* Out put long double value to dest */
SECUREC_INLINE void SecFormatLongDouble(SecFormatAttr *attr, const SecFloatAdapt *floatAdapt, long double ldValue)
{
 8016700:	b590      	push	{r4, r7, lr}
 8016702:	b089      	sub	sp, #36	; 0x24
 8016704:	af02      	add	r7, sp, #8
 8016706:	60f8      	str	r0, [r7, #12]
 8016708:	60b9      	str	r1, [r7, #8]
 801670a:	e9c7 2300 	strd	r2, r3, [r7]
    int fldWidth = (((attr->flags & SECUREC_FLAG_LEFT) != 0) ? (-attr->fldWidth) : attr->fldWidth);
 801670e:	68fb      	ldr	r3, [r7, #12]
 8016710:	695b      	ldr	r3, [r3, #20]
 8016712:	f003 0304 	and.w	r3, r3, #4
 8016716:	2b00      	cmp	r3, #0
 8016718:	d003      	beq.n	8016722 <SecFormatLongDouble+0x22>
 801671a:	68fb      	ldr	r3, [r7, #12]
 801671c:	699b      	ldr	r3, [r3, #24]
 801671e:	425b      	negs	r3, r3
 8016720:	e001      	b.n	8016726 <SecFormatLongDouble+0x26>
 8016722:	68fb      	ldr	r3, [r7, #12]
 8016724:	699b      	ldr	r3, [r3, #24]
 8016726:	617b      	str	r3, [r7, #20]
    if (attr->dynWidth != 0 && attr->dynPrecision != 0) {
 8016728:	68fb      	ldr	r3, [r7, #12]
 801672a:	6a1b      	ldr	r3, [r3, #32]
 801672c:	2b00      	cmp	r3, #0
 801672e:	d015      	beq.n	801675c <SecFormatLongDouble+0x5c>
 8016730:	68fb      	ldr	r3, [r7, #12]
 8016732:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016734:	2b00      	cmp	r3, #0
 8016736:	d011      	beq.n	801675c <SecFormatLongDouble+0x5c>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, attr->precision, ldValue);
 8016738:	68fb      	ldr	r3, [r7, #12]
 801673a:	6858      	ldr	r0, [r3, #4]
 801673c:	68bb      	ldr	r3, [r7, #8]
 801673e:	6919      	ldr	r1, [r3, #16]
 8016740:	68fb      	ldr	r3, [r7, #12]
 8016742:	69dc      	ldr	r4, [r3, #28]
 8016744:	e9d7 2300 	ldrd	r2, r3, [r7]
 8016748:	e9cd 2300 	strd	r2, r3, [sp]
 801674c:	4623      	mov	r3, r4
 801674e:	697a      	ldr	r2, [r7, #20]
 8016750:	f7ff ffb0 	bl	80166b4 <SecFormatFloat>
 8016754:	4602      	mov	r2, r0
 8016756:	68fb      	ldr	r3, [r7, #12]
 8016758:	609a      	str	r2, [r3, #8]
 801675a:	e032      	b.n	80167c2 <SecFormatLongDouble+0xc2>
    } else if (attr->dynWidth != 0) {
 801675c:	68fb      	ldr	r3, [r7, #12]
 801675e:	6a1b      	ldr	r3, [r3, #32]
 8016760:	2b00      	cmp	r3, #0
 8016762:	d00e      	beq.n	8016782 <SecFormatLongDouble+0x82>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, ldValue);
 8016764:	68fb      	ldr	r3, [r7, #12]
 8016766:	6858      	ldr	r0, [r3, #4]
 8016768:	68bb      	ldr	r3, [r7, #8]
 801676a:	6919      	ldr	r1, [r3, #16]
 801676c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8016770:	e9cd 2300 	strd	r2, r3, [sp]
 8016774:	697a      	ldr	r2, [r7, #20]
 8016776:	f7ff ff9d 	bl	80166b4 <SecFormatFloat>
 801677a:	4602      	mov	r2, r0
 801677c:	68fb      	ldr	r3, [r7, #12]
 801677e:	609a      	str	r2, [r3, #8]
 8016780:	e01f      	b.n	80167c2 <SecFormatLongDouble+0xc2>
    } else if (attr->dynPrecision != 0) {
 8016782:	68fb      	ldr	r3, [r7, #12]
 8016784:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016786:	2b00      	cmp	r3, #0
 8016788:	d010      	beq.n	80167ac <SecFormatLongDouble+0xac>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, attr->precision, ldValue);
 801678a:	68fb      	ldr	r3, [r7, #12]
 801678c:	6858      	ldr	r0, [r3, #4]
 801678e:	68bb      	ldr	r3, [r7, #8]
 8016790:	6919      	ldr	r1, [r3, #16]
 8016792:	68fb      	ldr	r3, [r7, #12]
 8016794:	69dc      	ldr	r4, [r3, #28]
 8016796:	e9d7 2300 	ldrd	r2, r3, [r7]
 801679a:	e9cd 2300 	strd	r2, r3, [sp]
 801679e:	4622      	mov	r2, r4
 80167a0:	f7ff ff88 	bl	80166b4 <SecFormatFloat>
 80167a4:	4602      	mov	r2, r0
 80167a6:	68fb      	ldr	r3, [r7, #12]
 80167a8:	609a      	str	r2, [r3, #8]
 80167aa:	e00a      	b.n	80167c2 <SecFormatLongDouble+0xc2>
    } else {
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, ldValue);
 80167ac:	68fb      	ldr	r3, [r7, #12]
 80167ae:	6858      	ldr	r0, [r3, #4]
 80167b0:	68bb      	ldr	r3, [r7, #8]
 80167b2:	6919      	ldr	r1, [r3, #16]
 80167b4:	e9d7 2300 	ldrd	r2, r3, [r7]
 80167b8:	f7ff ff7c 	bl	80166b4 <SecFormatFloat>
 80167bc:	4602      	mov	r2, r0
 80167be:	68fb      	ldr	r3, [r7, #12]
 80167c0:	609a      	str	r2, [r3, #8]
    }
    if (attr->textLen < 0 || attr->textLen >= floatAdapt->bufferSize) {
 80167c2:	68fb      	ldr	r3, [r7, #12]
 80167c4:	689b      	ldr	r3, [r3, #8]
 80167c6:	2b00      	cmp	r3, #0
 80167c8:	db05      	blt.n	80167d6 <SecFormatLongDouble+0xd6>
 80167ca:	68fb      	ldr	r3, [r7, #12]
 80167cc:	689a      	ldr	r2, [r3, #8]
 80167ce:	68bb      	ldr	r3, [r7, #8]
 80167d0:	69db      	ldr	r3, [r3, #28]
 80167d2:	429a      	cmp	r2, r3
 80167d4:	db02      	blt.n	80167dc <SecFormatLongDouble+0xdc>
        attr->textLen = 0;
 80167d6:	68fb      	ldr	r3, [r7, #12]
 80167d8:	2200      	movs	r2, #0
 80167da:	609a      	str	r2, [r3, #8]
    }
}
 80167dc:	bf00      	nop
 80167de:	371c      	adds	r7, #28
 80167e0:	46bd      	mov	sp, r7
 80167e2:	bd90      	pop	{r4, r7, pc}

080167e4 <SecFormatDouble>:
#endif

/* Out put double value to dest */
SECUREC_INLINE void SecFormatDouble(SecFormatAttr *attr, const SecFloatAdapt *floatAdapt, double dValue)
{
 80167e4:	b590      	push	{r4, r7, lr}
 80167e6:	b089      	sub	sp, #36	; 0x24
 80167e8:	af02      	add	r7, sp, #8
 80167ea:	60f8      	str	r0, [r7, #12]
 80167ec:	60b9      	str	r1, [r7, #8]
 80167ee:	e9c7 2300 	strd	r2, r3, [r7]
    int fldWidth = (((attr->flags & SECUREC_FLAG_LEFT) != 0) ? (-attr->fldWidth) : attr->fldWidth);
 80167f2:	68fb      	ldr	r3, [r7, #12]
 80167f4:	695b      	ldr	r3, [r3, #20]
 80167f6:	f003 0304 	and.w	r3, r3, #4
 80167fa:	2b00      	cmp	r3, #0
 80167fc:	d003      	beq.n	8016806 <SecFormatDouble+0x22>
 80167fe:	68fb      	ldr	r3, [r7, #12]
 8016800:	699b      	ldr	r3, [r3, #24]
 8016802:	425b      	negs	r3, r3
 8016804:	e001      	b.n	801680a <SecFormatDouble+0x26>
 8016806:	68fb      	ldr	r3, [r7, #12]
 8016808:	699b      	ldr	r3, [r3, #24]
 801680a:	617b      	str	r3, [r7, #20]
    if (attr->dynWidth != 0 && attr->dynPrecision != 0) {
 801680c:	68fb      	ldr	r3, [r7, #12]
 801680e:	6a1b      	ldr	r3, [r3, #32]
 8016810:	2b00      	cmp	r3, #0
 8016812:	d015      	beq.n	8016840 <SecFormatDouble+0x5c>
 8016814:	68fb      	ldr	r3, [r7, #12]
 8016816:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016818:	2b00      	cmp	r3, #0
 801681a:	d011      	beq.n	8016840 <SecFormatDouble+0x5c>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, attr->precision, dValue);
 801681c:	68fb      	ldr	r3, [r7, #12]
 801681e:	6858      	ldr	r0, [r3, #4]
 8016820:	68bb      	ldr	r3, [r7, #8]
 8016822:	6919      	ldr	r1, [r3, #16]
 8016824:	68fb      	ldr	r3, [r7, #12]
 8016826:	69dc      	ldr	r4, [r3, #28]
 8016828:	e9d7 2300 	ldrd	r2, r3, [r7]
 801682c:	e9cd 2300 	strd	r2, r3, [sp]
 8016830:	4623      	mov	r3, r4
 8016832:	697a      	ldr	r2, [r7, #20]
 8016834:	f7ff ff3e 	bl	80166b4 <SecFormatFloat>
 8016838:	4602      	mov	r2, r0
 801683a:	68fb      	ldr	r3, [r7, #12]
 801683c:	609a      	str	r2, [r3, #8]
 801683e:	e032      	b.n	80168a6 <SecFormatDouble+0xc2>
    } else if (attr->dynWidth != 0) {
 8016840:	68fb      	ldr	r3, [r7, #12]
 8016842:	6a1b      	ldr	r3, [r3, #32]
 8016844:	2b00      	cmp	r3, #0
 8016846:	d00e      	beq.n	8016866 <SecFormatDouble+0x82>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, dValue);
 8016848:	68fb      	ldr	r3, [r7, #12]
 801684a:	6858      	ldr	r0, [r3, #4]
 801684c:	68bb      	ldr	r3, [r7, #8]
 801684e:	6919      	ldr	r1, [r3, #16]
 8016850:	e9d7 2300 	ldrd	r2, r3, [r7]
 8016854:	e9cd 2300 	strd	r2, r3, [sp]
 8016858:	697a      	ldr	r2, [r7, #20]
 801685a:	f7ff ff2b 	bl	80166b4 <SecFormatFloat>
 801685e:	4602      	mov	r2, r0
 8016860:	68fb      	ldr	r3, [r7, #12]
 8016862:	609a      	str	r2, [r3, #8]
 8016864:	e01f      	b.n	80168a6 <SecFormatDouble+0xc2>
    } else if (attr->dynPrecision != 0) {
 8016866:	68fb      	ldr	r3, [r7, #12]
 8016868:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801686a:	2b00      	cmp	r3, #0
 801686c:	d010      	beq.n	8016890 <SecFormatDouble+0xac>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, attr->precision, dValue);
 801686e:	68fb      	ldr	r3, [r7, #12]
 8016870:	6858      	ldr	r0, [r3, #4]
 8016872:	68bb      	ldr	r3, [r7, #8]
 8016874:	6919      	ldr	r1, [r3, #16]
 8016876:	68fb      	ldr	r3, [r7, #12]
 8016878:	69dc      	ldr	r4, [r3, #28]
 801687a:	e9d7 2300 	ldrd	r2, r3, [r7]
 801687e:	e9cd 2300 	strd	r2, r3, [sp]
 8016882:	4622      	mov	r2, r4
 8016884:	f7ff ff16 	bl	80166b4 <SecFormatFloat>
 8016888:	4602      	mov	r2, r0
 801688a:	68fb      	ldr	r3, [r7, #12]
 801688c:	609a      	str	r2, [r3, #8]
 801688e:	e00a      	b.n	80168a6 <SecFormatDouble+0xc2>
    } else {
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, dValue);
 8016890:	68fb      	ldr	r3, [r7, #12]
 8016892:	6858      	ldr	r0, [r3, #4]
 8016894:	68bb      	ldr	r3, [r7, #8]
 8016896:	6919      	ldr	r1, [r3, #16]
 8016898:	e9d7 2300 	ldrd	r2, r3, [r7]
 801689c:	f7ff ff0a 	bl	80166b4 <SecFormatFloat>
 80168a0:	4602      	mov	r2, r0
 80168a2:	68fb      	ldr	r3, [r7, #12]
 80168a4:	609a      	str	r2, [r3, #8]
    }
    if (attr->textLen < 0 || attr->textLen >= floatAdapt->bufferSize) {
 80168a6:	68fb      	ldr	r3, [r7, #12]
 80168a8:	689b      	ldr	r3, [r3, #8]
 80168aa:	2b00      	cmp	r3, #0
 80168ac:	db05      	blt.n	80168ba <SecFormatDouble+0xd6>
 80168ae:	68fb      	ldr	r3, [r7, #12]
 80168b0:	689a      	ldr	r2, [r3, #8]
 80168b2:	68bb      	ldr	r3, [r7, #8]
 80168b4:	69db      	ldr	r3, [r3, #28]
 80168b6:	429a      	cmp	r2, r3
 80168b8:	db02      	blt.n	80168c0 <SecFormatDouble+0xdc>
        attr->textLen = 0;
 80168ba:	68fb      	ldr	r3, [r7, #12]
 80168bc:	2200      	movs	r2, #0
 80168be:	609a      	str	r2, [r3, #8]
    }
}
 80168c0:	bf00      	nop
 80168c2:	371c      	adds	r7, #28
 80168c4:	46bd      	mov	sp, r7
 80168c6:	bd90      	pop	{r4, r7, pc}

080168c8 <SecIsSameSize>:
#endif

#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
/* To clear e506 warning */
SECUREC_INLINE int SecIsSameSize(size_t sizeA, size_t sizeB)
{
 80168c8:	b480      	push	{r7}
 80168ca:	b083      	sub	sp, #12
 80168cc:	af00      	add	r7, sp, #0
 80168ce:	6078      	str	r0, [r7, #4]
 80168d0:	6039      	str	r1, [r7, #0]
    return (int)(sizeA == sizeB);
 80168d2:	687a      	ldr	r2, [r7, #4]
 80168d4:	683b      	ldr	r3, [r7, #0]
 80168d6:	429a      	cmp	r2, r3
 80168d8:	bf0c      	ite	eq
 80168da:	2301      	moveq	r3, #1
 80168dc:	2300      	movne	r3, #0
 80168de:	b2db      	uxtb	r3, r3
}
 80168e0:	4618      	mov	r0, r3
 80168e2:	370c      	adds	r7, #12
 80168e4:	46bd      	mov	sp, r7
 80168e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80168ea:	4770      	bx	lr

080168ec <SecNumber32ToOctalString>:
/*
 * Compiler Optimized Division 8.
 * The text.str point to buffer end, must be Large enough
 */
SECUREC_INLINE void SecNumber32ToOctalString(SecUnsignedInt32 number, SecFormatAttr *attr)
{
 80168ec:	b480      	push	{r7}
 80168ee:	b085      	sub	sp, #20
 80168f0:	af00      	add	r7, sp, #0
 80168f2:	6078      	str	r0, [r7, #4]
 80168f4:	6039      	str	r1, [r7, #0]
    SecUnsignedInt32 val32 = number;
 80168f6:	687b      	ldr	r3, [r7, #4]
 80168f8:	60fb      	str	r3, [r7, #12]
    do {
        --attr->text.str;
 80168fa:	683b      	ldr	r3, [r7, #0]
 80168fc:	685b      	ldr	r3, [r3, #4]
 80168fe:	1e5a      	subs	r2, r3, #1
 8016900:	683b      	ldr	r3, [r7, #0]
 8016902:	605a      	str	r2, [r3, #4]
        /* Just use lowerDigits for 0 - 9 */
        *(attr->text.str) = g_itoaLowerDigits[val32 % SECUREC_RADIX_OCTAL];
 8016904:	68fb      	ldr	r3, [r7, #12]
 8016906:	f003 0207 	and.w	r2, r3, #7
 801690a:	683b      	ldr	r3, [r7, #0]
 801690c:	685b      	ldr	r3, [r3, #4]
 801690e:	4908      	ldr	r1, [pc, #32]	; (8016930 <SecNumber32ToOctalString+0x44>)
 8016910:	5c8a      	ldrb	r2, [r1, r2]
 8016912:	701a      	strb	r2, [r3, #0]
        val32 /= SECUREC_RADIX_OCTAL;
 8016914:	68fb      	ldr	r3, [r7, #12]
 8016916:	08db      	lsrs	r3, r3, #3
 8016918:	60fb      	str	r3, [r7, #12]
    } while (val32 != 0);
 801691a:	68fb      	ldr	r3, [r7, #12]
 801691c:	2b00      	cmp	r3, #0
 801691e:	d1ec      	bne.n	80168fa <SecNumber32ToOctalString+0xe>
}
 8016920:	bf00      	nop
 8016922:	bf00      	nop
 8016924:	3714      	adds	r7, #20
 8016926:	46bd      	mov	sp, r7
 8016928:	f85d 7b04 	ldr.w	r7, [sp], #4
 801692c:	4770      	bx	lr
 801692e:	bf00      	nop
 8016930:	080236c8 	.word	0x080236c8

08016934 <SecNumber32ToHexString>:
/*
 * Compiler Optimized Division 16.
 * The text.str point to buffer end, must be Large enough
 */
SECUREC_INLINE void SecNumber32ToHexString(SecUnsignedInt32 number, SecFormatAttr *attr)
{
 8016934:	b480      	push	{r7}
 8016936:	b085      	sub	sp, #20
 8016938:	af00      	add	r7, sp, #0
 801693a:	6078      	str	r0, [r7, #4]
 801693c:	6039      	str	r1, [r7, #0]
    SecUnsignedInt32 val32 = number;
 801693e:	687b      	ldr	r3, [r7, #4]
 8016940:	60fb      	str	r3, [r7, #12]
    do {
        --attr->text.str;
 8016942:	683b      	ldr	r3, [r7, #0]
 8016944:	685b      	ldr	r3, [r3, #4]
 8016946:	1e5a      	subs	r2, r3, #1
 8016948:	683b      	ldr	r3, [r7, #0]
 801694a:	605a      	str	r2, [r3, #4]
        *(attr->text.str) = attr->digits[val32 % SECUREC_RADIX_HEX];
 801694c:	683b      	ldr	r3, [r7, #0]
 801694e:	681a      	ldr	r2, [r3, #0]
 8016950:	68fb      	ldr	r3, [r7, #12]
 8016952:	f003 030f 	and.w	r3, r3, #15
 8016956:	441a      	add	r2, r3
 8016958:	683b      	ldr	r3, [r7, #0]
 801695a:	685b      	ldr	r3, [r3, #4]
 801695c:	7812      	ldrb	r2, [r2, #0]
 801695e:	701a      	strb	r2, [r3, #0]
        val32 /= SECUREC_RADIX_HEX;
 8016960:	68fb      	ldr	r3, [r7, #12]
 8016962:	091b      	lsrs	r3, r3, #4
 8016964:	60fb      	str	r3, [r7, #12]
    } while (val32 != 0);
 8016966:	68fb      	ldr	r3, [r7, #12]
 8016968:	2b00      	cmp	r3, #0
 801696a:	d1ea      	bne.n	8016942 <SecNumber32ToHexString+0xe>
}
 801696c:	bf00      	nop
 801696e:	bf00      	nop
 8016970:	3714      	adds	r7, #20
 8016972:	46bd      	mov	sp, r7
 8016974:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016978:	4770      	bx	lr
	...

0801697c <SecNumber32ToDecStringFast>:

#ifndef _AIX
/* Use fast div 10 */
SECUREC_INLINE void SecNumber32ToDecStringFast(SecUnsignedInt32 number, SecFormatAttr *attr)
{
 801697c:	b480      	push	{r7}
 801697e:	b087      	sub	sp, #28
 8016980:	af00      	add	r7, sp, #0
 8016982:	6078      	str	r0, [r7, #4]
 8016984:	6039      	str	r1, [r7, #0]
    SecUnsignedInt32 val32 = number;
 8016986:	687b      	ldr	r3, [r7, #4]
 8016988:	60fb      	str	r3, [r7, #12]
    do {
        SecUnsignedInt32 quotient;
        SecUnsignedInt32 remain;
        --attr->text.str;
 801698a:	683b      	ldr	r3, [r7, #0]
 801698c:	685b      	ldr	r3, [r3, #4]
 801698e:	1e5a      	subs	r2, r3, #1
 8016990:	683b      	ldr	r3, [r7, #0]
 8016992:	605a      	str	r2, [r3, #4]
        *(attr->text.str) = g_itoaLowerDigits[val32 % SECUREC_RADIX_DECIMAL];
 8016994:	68f9      	ldr	r1, [r7, #12]
 8016996:	4b20      	ldr	r3, [pc, #128]	; (8016a18 <SecNumber32ToDecStringFast+0x9c>)
 8016998:	fba3 2301 	umull	r2, r3, r3, r1
 801699c:	08da      	lsrs	r2, r3, #3
 801699e:	4613      	mov	r3, r2
 80169a0:	009b      	lsls	r3, r3, #2
 80169a2:	4413      	add	r3, r2
 80169a4:	005b      	lsls	r3, r3, #1
 80169a6:	1aca      	subs	r2, r1, r3
 80169a8:	683b      	ldr	r3, [r7, #0]
 80169aa:	685b      	ldr	r3, [r3, #4]
 80169ac:	491b      	ldr	r1, [pc, #108]	; (8016a1c <SecNumber32ToDecStringFast+0xa0>)
 80169ae:	5c8a      	ldrb	r2, [r1, r2]
 80169b0:	701a      	strb	r2, [r3, #0]
        quotient = (val32 >> 1U) + (val32 >> 2U); /* Fast div  magic 2 */
 80169b2:	68fb      	ldr	r3, [r7, #12]
 80169b4:	085a      	lsrs	r2, r3, #1
 80169b6:	68fb      	ldr	r3, [r7, #12]
 80169b8:	089b      	lsrs	r3, r3, #2
 80169ba:	4413      	add	r3, r2
 80169bc:	613b      	str	r3, [r7, #16]
        quotient = quotient + (quotient >> 4U); /* Fast div  magic 4 */
 80169be:	693b      	ldr	r3, [r7, #16]
 80169c0:	091b      	lsrs	r3, r3, #4
 80169c2:	693a      	ldr	r2, [r7, #16]
 80169c4:	4413      	add	r3, r2
 80169c6:	613b      	str	r3, [r7, #16]
        quotient = quotient + (quotient >> 8U); /* Fast div  magic 8 */
 80169c8:	693b      	ldr	r3, [r7, #16]
 80169ca:	0a1b      	lsrs	r3, r3, #8
 80169cc:	693a      	ldr	r2, [r7, #16]
 80169ce:	4413      	add	r3, r2
 80169d0:	613b      	str	r3, [r7, #16]
        quotient = quotient + (quotient >> 16U); /* Fast div  magic 16 */
 80169d2:	693b      	ldr	r3, [r7, #16]
 80169d4:	0c1b      	lsrs	r3, r3, #16
 80169d6:	693a      	ldr	r2, [r7, #16]
 80169d8:	4413      	add	r3, r2
 80169da:	613b      	str	r3, [r7, #16]
        quotient = quotient >> 3U; /* Fast div  magic 3 */
 80169dc:	693b      	ldr	r3, [r7, #16]
 80169de:	08db      	lsrs	r3, r3, #3
 80169e0:	613b      	str	r3, [r7, #16]
        remain = val32 - SECUREC_MUL_TEN(quotient);
 80169e2:	693b      	ldr	r3, [r7, #16]
 80169e4:	009a      	lsls	r2, r3, #2
 80169e6:	693b      	ldr	r3, [r7, #16]
 80169e8:	4413      	add	r3, r2
 80169ea:	005b      	lsls	r3, r3, #1
 80169ec:	68fa      	ldr	r2, [r7, #12]
 80169ee:	1ad3      	subs	r3, r2, r3
 80169f0:	617b      	str	r3, [r7, #20]
        val32 = (remain > 9U) ? (quotient + 1U) : quotient; /* Fast div  magic 9 */
 80169f2:	697b      	ldr	r3, [r7, #20]
 80169f4:	2b09      	cmp	r3, #9
 80169f6:	d902      	bls.n	80169fe <SecNumber32ToDecStringFast+0x82>
 80169f8:	693b      	ldr	r3, [r7, #16]
 80169fa:	3301      	adds	r3, #1
 80169fc:	e000      	b.n	8016a00 <SecNumber32ToDecStringFast+0x84>
 80169fe:	693b      	ldr	r3, [r7, #16]
 8016a00:	60fb      	str	r3, [r7, #12]
    } while (val32 != 0);
 8016a02:	68fb      	ldr	r3, [r7, #12]
 8016a04:	2b00      	cmp	r3, #0
 8016a06:	d1c0      	bne.n	801698a <SecNumber32ToDecStringFast+0xe>
}
 8016a08:	bf00      	nop
 8016a0a:	bf00      	nop
 8016a0c:	371c      	adds	r7, #28
 8016a0e:	46bd      	mov	sp, r7
 8016a10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016a14:	4770      	bx	lr
 8016a16:	bf00      	nop
 8016a18:	cccccccd 	.word	0xcccccccd
 8016a1c:	080236c8 	.word	0x080236c8

08016a20 <SecNumber32ToString>:
#endif

SECUREC_INLINE void SecNumber32ToString(SecUnsignedInt32 number, SecFormatAttr *attr)
{
 8016a20:	b580      	push	{r7, lr}
 8016a22:	b082      	sub	sp, #8
 8016a24:	af00      	add	r7, sp, #0
 8016a26:	6078      	str	r0, [r7, #4]
 8016a28:	6039      	str	r1, [r7, #0]
    switch (attr->radix) {
 8016a2a:	683b      	ldr	r3, [r7, #0]
 8016a2c:	691b      	ldr	r3, [r3, #16]
 8016a2e:	2b10      	cmp	r3, #16
 8016a30:	d006      	beq.n	8016a40 <SecNumber32ToString+0x20>
 8016a32:	2b10      	cmp	r3, #16
 8016a34:	d813      	bhi.n	8016a5e <SecNumber32ToString+0x3e>
 8016a36:	2b08      	cmp	r3, #8
 8016a38:	d007      	beq.n	8016a4a <SecNumber32ToString+0x2a>
 8016a3a:	2b0a      	cmp	r3, #10
 8016a3c:	d00a      	beq.n	8016a54 <SecNumber32ToString+0x34>
            SecNumber32ToDecStringFast(number, attr);
#endif
            break;
        default:
            /* Do nothing */
            break;
 8016a3e:	e00e      	b.n	8016a5e <SecNumber32ToString+0x3e>
            SecNumber32ToHexString(number, attr);
 8016a40:	6839      	ldr	r1, [r7, #0]
 8016a42:	6878      	ldr	r0, [r7, #4]
 8016a44:	f7ff ff76 	bl	8016934 <SecNumber32ToHexString>
            break;
 8016a48:	e00a      	b.n	8016a60 <SecNumber32ToString+0x40>
            SecNumber32ToOctalString(number, attr);
 8016a4a:	6839      	ldr	r1, [r7, #0]
 8016a4c:	6878      	ldr	r0, [r7, #4]
 8016a4e:	f7ff ff4d 	bl	80168ec <SecNumber32ToOctalString>
            break;
 8016a52:	e005      	b.n	8016a60 <SecNumber32ToString+0x40>
            SecNumber32ToDecStringFast(number, attr);
 8016a54:	6839      	ldr	r1, [r7, #0]
 8016a56:	6878      	ldr	r0, [r7, #4]
 8016a58:	f7ff ff90 	bl	801697c <SecNumber32ToDecStringFast>
            break;
 8016a5c:	e000      	b.n	8016a60 <SecNumber32ToString+0x40>
            break;
 8016a5e:	bf00      	nop
    }
}
 8016a60:	bf00      	nop
 8016a62:	3708      	adds	r7, #8
 8016a64:	46bd      	mov	sp, r7
 8016a66:	bd80      	pop	{r7, pc}

08016a68 <SecNumber64ToDecString>:
/*
 * Compiler Optimized Division 10.
 * The text.str point to buffer end, must be Large enough
 */
SECUREC_INLINE void SecNumber64ToDecString(SecUnsignedInt64 number, SecFormatAttr *attr)
{
 8016a68:	b580      	push	{r7, lr}
 8016a6a:	b086      	sub	sp, #24
 8016a6c:	af00      	add	r7, sp, #0
 8016a6e:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8016a72:	607a      	str	r2, [r7, #4]
    SecUnsignedInt64 val64 = number;
 8016a74:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8016a78:	e9c7 2304 	strd	r2, r3, [r7, #16]
    do {
        --attr->text.str;
 8016a7c:	687b      	ldr	r3, [r7, #4]
 8016a7e:	685b      	ldr	r3, [r3, #4]
 8016a80:	1e5a      	subs	r2, r3, #1
 8016a82:	687b      	ldr	r3, [r7, #4]
 8016a84:	605a      	str	r2, [r3, #4]
        /* Just use lowerDigits for 0 - 9 */
        *(attr->text.str) = g_itoaLowerDigits[val64 % SECUREC_RADIX_DECIMAL];
 8016a86:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8016a8a:	f04f 020a 	mov.w	r2, #10
 8016a8e:	f04f 0300 	mov.w	r3, #0
 8016a92:	f7e9 ff7f 	bl	8000994 <__aeabi_uldivmod>
 8016a96:	6879      	ldr	r1, [r7, #4]
 8016a98:	6849      	ldr	r1, [r1, #4]
 8016a9a:	480c      	ldr	r0, [pc, #48]	; (8016acc <SecNumber64ToDecString+0x64>)
 8016a9c:	1883      	adds	r3, r0, r2
 8016a9e:	781b      	ldrb	r3, [r3, #0]
 8016aa0:	700b      	strb	r3, [r1, #0]
        val64 /= SECUREC_RADIX_DECIMAL;
 8016aa2:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8016aa6:	f04f 020a 	mov.w	r2, #10
 8016aaa:	f04f 0300 	mov.w	r3, #0
 8016aae:	f7e9 ff71 	bl	8000994 <__aeabi_uldivmod>
 8016ab2:	4602      	mov	r2, r0
 8016ab4:	460b      	mov	r3, r1
 8016ab6:	e9c7 2304 	strd	r2, r3, [r7, #16]
    } while (val64 != 0);
 8016aba:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8016abe:	4313      	orrs	r3, r2
 8016ac0:	d1dc      	bne.n	8016a7c <SecNumber64ToDecString+0x14>
}
 8016ac2:	bf00      	nop
 8016ac4:	bf00      	nop
 8016ac6:	3718      	adds	r7, #24
 8016ac8:	46bd      	mov	sp, r7
 8016aca:	bd80      	pop	{r7, pc}
 8016acc:	080236c8 	.word	0x080236c8

08016ad0 <SecNumber64ToOctalString>:
/*
 * Compiler Optimized Division 8.
 * The text.str point to buffer end, must be Large enough
 */
SECUREC_INLINE void SecNumber64ToOctalString(SecUnsignedInt64 number, SecFormatAttr *attr)
{
 8016ad0:	b4b0      	push	{r4, r5, r7}
 8016ad2:	b087      	sub	sp, #28
 8016ad4:	af00      	add	r7, sp, #0
 8016ad6:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8016ada:	607a      	str	r2, [r7, #4]
    SecUnsignedInt64 val64 = number;
 8016adc:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8016ae0:	e9c7 2304 	strd	r2, r3, [r7, #16]
    do {
        --attr->text.str;
 8016ae4:	687b      	ldr	r3, [r7, #4]
 8016ae6:	685b      	ldr	r3, [r3, #4]
 8016ae8:	1e5a      	subs	r2, r3, #1
 8016aea:	687b      	ldr	r3, [r7, #4]
 8016aec:	605a      	str	r2, [r3, #4]
        /* Just use lowerDigits for 0 - 9 */
        *(attr->text.str) = g_itoaLowerDigits[val64 % SECUREC_RADIX_OCTAL];
 8016aee:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8016af2:	f04f 0007 	mov.w	r0, #7
 8016af6:	f04f 0100 	mov.w	r1, #0
 8016afa:	ea02 0400 	and.w	r4, r2, r0
 8016afe:	ea03 0501 	and.w	r5, r3, r1
 8016b02:	687b      	ldr	r3, [r7, #4]
 8016b04:	685b      	ldr	r3, [r3, #4]
 8016b06:	4a0d      	ldr	r2, [pc, #52]	; (8016b3c <SecNumber64ToOctalString+0x6c>)
 8016b08:	4422      	add	r2, r4
 8016b0a:	7812      	ldrb	r2, [r2, #0]
 8016b0c:	701a      	strb	r2, [r3, #0]
        val64 /= SECUREC_RADIX_OCTAL;
 8016b0e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8016b12:	f04f 0200 	mov.w	r2, #0
 8016b16:	f04f 0300 	mov.w	r3, #0
 8016b1a:	08c2      	lsrs	r2, r0, #3
 8016b1c:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
 8016b20:	08cb      	lsrs	r3, r1, #3
 8016b22:	e9c7 2304 	strd	r2, r3, [r7, #16]
    } while (val64 != 0);
 8016b26:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8016b2a:	4313      	orrs	r3, r2
 8016b2c:	d1da      	bne.n	8016ae4 <SecNumber64ToOctalString+0x14>
}
 8016b2e:	bf00      	nop
 8016b30:	bf00      	nop
 8016b32:	371c      	adds	r7, #28
 8016b34:	46bd      	mov	sp, r7
 8016b36:	bcb0      	pop	{r4, r5, r7}
 8016b38:	4770      	bx	lr
 8016b3a:	bf00      	nop
 8016b3c:	080236c8 	.word	0x080236c8

08016b40 <SecNumber64ToHexString>:
/*
 * Compiler Optimized Division 16.
 * The text.str point to buffer end, must be Large enough
 */
SECUREC_INLINE void SecNumber64ToHexString(SecUnsignedInt64 number, SecFormatAttr *attr)
{
 8016b40:	b480      	push	{r7}
 8016b42:	b087      	sub	sp, #28
 8016b44:	af00      	add	r7, sp, #0
 8016b46:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8016b4a:	607a      	str	r2, [r7, #4]
    SecUnsignedInt64 val64 = number;
 8016b4c:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8016b50:	e9c7 2304 	strd	r2, r3, [r7, #16]
    do {
        --attr->text.str;
 8016b54:	687b      	ldr	r3, [r7, #4]
 8016b56:	685b      	ldr	r3, [r3, #4]
 8016b58:	1e5a      	subs	r2, r3, #1
 8016b5a:	687b      	ldr	r3, [r7, #4]
 8016b5c:	605a      	str	r2, [r3, #4]
        *(attr->text.str) = attr->digits[val64 % SECUREC_RADIX_HEX];
 8016b5e:	687b      	ldr	r3, [r7, #4]
 8016b60:	681a      	ldr	r2, [r3, #0]
 8016b62:	693b      	ldr	r3, [r7, #16]
 8016b64:	f003 030f 	and.w	r3, r3, #15
 8016b68:	441a      	add	r2, r3
 8016b6a:	687b      	ldr	r3, [r7, #4]
 8016b6c:	685b      	ldr	r3, [r3, #4]
 8016b6e:	7812      	ldrb	r2, [r2, #0]
 8016b70:	701a      	strb	r2, [r3, #0]
        val64 /= SECUREC_RADIX_HEX;
 8016b72:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8016b76:	f04f 0200 	mov.w	r2, #0
 8016b7a:	f04f 0300 	mov.w	r3, #0
 8016b7e:	0902      	lsrs	r2, r0, #4
 8016b80:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 8016b84:	090b      	lsrs	r3, r1, #4
 8016b86:	e9c7 2304 	strd	r2, r3, [r7, #16]
    } while (val64 != 0);
 8016b8a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8016b8e:	4313      	orrs	r3, r2
 8016b90:	d1e0      	bne.n	8016b54 <SecNumber64ToHexString+0x14>
}
 8016b92:	bf00      	nop
 8016b94:	bf00      	nop
 8016b96:	371c      	adds	r7, #28
 8016b98:	46bd      	mov	sp, r7
 8016b9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016b9e:	4770      	bx	lr

08016ba0 <SecNumber64ToString>:

SECUREC_INLINE void SecNumber64ToString(SecUnsignedInt64 number, SecFormatAttr *attr)
{
 8016ba0:	b580      	push	{r7, lr}
 8016ba2:	b084      	sub	sp, #16
 8016ba4:	af00      	add	r7, sp, #0
 8016ba6:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8016baa:	607a      	str	r2, [r7, #4]
    switch (attr->radix) {
 8016bac:	687b      	ldr	r3, [r7, #4]
 8016bae:	691b      	ldr	r3, [r3, #16]
 8016bb0:	2b10      	cmp	r3, #16
 8016bb2:	d011      	beq.n	8016bd8 <SecNumber64ToString+0x38>
 8016bb4:	2b10      	cmp	r3, #16
 8016bb6:	d815      	bhi.n	8016be4 <SecNumber64ToString+0x44>
 8016bb8:	2b08      	cmp	r3, #8
 8016bba:	d007      	beq.n	8016bcc <SecNumber64ToString+0x2c>
 8016bbc:	2b0a      	cmp	r3, #10
 8016bbe:	d111      	bne.n	8016be4 <SecNumber64ToString+0x44>
        /* The compiler will optimize div 10 */
        case SECUREC_RADIX_DECIMAL:
            SecNumber64ToDecString(number, attr);
 8016bc0:	687a      	ldr	r2, [r7, #4]
 8016bc2:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8016bc6:	f7ff ff4f 	bl	8016a68 <SecNumber64ToDecString>
            break;
 8016bca:	e00c      	b.n	8016be6 <SecNumber64ToString+0x46>
        case SECUREC_RADIX_OCTAL:
            SecNumber64ToOctalString(number, attr);
 8016bcc:	687a      	ldr	r2, [r7, #4]
 8016bce:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8016bd2:	f7ff ff7d 	bl	8016ad0 <SecNumber64ToOctalString>
            break;
 8016bd6:	e006      	b.n	8016be6 <SecNumber64ToString+0x46>
        case SECUREC_RADIX_HEX:
            SecNumber64ToHexString(number, attr);
 8016bd8:	687a      	ldr	r2, [r7, #4]
 8016bda:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8016bde:	f7ff ffaf 	bl	8016b40 <SecNumber64ToHexString>
            break;
 8016be2:	e000      	b.n	8016be6 <SecNumber64ToString+0x46>
        default:
            /* Do nothing */
            break;
 8016be4:	bf00      	nop
    }
}
 8016be6:	bf00      	nop
 8016be8:	3710      	adds	r7, #16
 8016bea:	46bd      	mov	sp, r7
 8016bec:	bd80      	pop	{r7, pc}

08016bee <SecNumberToString>:

/*
 * Converting integers to string
 */
SECUREC_INLINE void SecNumberToString(SecUnsignedInt64 number, SecFormatAttr *attr)
{
 8016bee:	b580      	push	{r7, lr}
 8016bf0:	b086      	sub	sp, #24
 8016bf2:	af00      	add	r7, sp, #0
 8016bf4:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8016bf8:	607a      	str	r2, [r7, #4]
#ifdef SECUREC_ON_64BITS
    SecNumber64ToString(number, attr);
#else /* For 32 bits system */
    if (number <= 0xffffffffUL) { /* Use 0xffffffffUL to check if the value is in the 32-bit range */
 8016bfa:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8016bfe:	2b01      	cmp	r3, #1
 8016c00:	bf08      	it	eq
 8016c02:	2a00      	cmpeq	r2, #0
 8016c04:	d206      	bcs.n	8016c14 <SecNumberToString+0x26>
        /* In most case, the value to be converted is small value */
        SecUnsignedInt32 n32Tmp = (SecUnsignedInt32)number;
 8016c06:	68bb      	ldr	r3, [r7, #8]
 8016c08:	617b      	str	r3, [r7, #20]
        SecNumber32ToString(n32Tmp, attr);
 8016c0a:	6879      	ldr	r1, [r7, #4]
 8016c0c:	6978      	ldr	r0, [r7, #20]
 8016c0e:	f7ff ff07 	bl	8016a20 <SecNumber32ToString>
#else
        SecNumber64ToString(number, attr);
#endif
    }
#endif
}
 8016c12:	e004      	b.n	8016c1e <SecNumberToString+0x30>
        SecNumber64ToString(number, attr);
 8016c14:	687a      	ldr	r2, [r7, #4]
 8016c16:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8016c1a:	f7ff ffc1 	bl	8016ba0 <SecNumber64ToString>
}
 8016c1e:	bf00      	nop
 8016c20:	3718      	adds	r7, #24
 8016c22:	46bd      	mov	sp, r7
 8016c24:	bd80      	pop	{r7, pc}

08016c26 <SecIsNumberNeedTo32Bit>:

SECUREC_INLINE int SecIsNumberNeedTo32Bit(const SecFormatAttr *attr)
{
 8016c26:	b480      	push	{r7}
 8016c28:	b083      	sub	sp, #12
 8016c2a:	af00      	add	r7, sp, #0
 8016c2c:	6078      	str	r0, [r7, #4]
    return (int)(((attr->flags & SECUREC_FLAG_I64) == 0) &&
 8016c2e:	687b      	ldr	r3, [r7, #4]
 8016c30:	695b      	ldr	r3, [r3, #20]
 8016c32:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8016c36:	2b00      	cmp	r3, #0
 8016c38:	d10d      	bne.n	8016c56 <SecIsNumberNeedTo32Bit+0x30>
#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
            ((attr->flags & SECUREC_FLAG_INTMAX) == 0) &&
 8016c3a:	687b      	ldr	r3, [r7, #4]
 8016c3c:	695b      	ldr	r3, [r3, #20]
 8016c3e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
    return (int)(((attr->flags & SECUREC_FLAG_I64) == 0) &&
 8016c42:	2b00      	cmp	r3, #0
 8016c44:	d107      	bne.n	8016c56 <SecIsNumberNeedTo32Bit+0x30>
            ((attr->flags & SECUREC_FLAG_SIZE) == 0) &&
#if !defined(SECUREC_COMPATIBLE_WIN_FORMAT)  /* on window 64 system sizeof long is 32bit */
            ((attr->flags & SECUREC_FLAG_LONG) == 0) &&
#endif
#endif
            ((attr->flags & SECUREC_FLAG_LONGLONG) == 0));
 8016c46:	687b      	ldr	r3, [r7, #4]
 8016c48:	695b      	ldr	r3, [r3, #20]
 8016c4a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    return (int)(((attr->flags & SECUREC_FLAG_I64) == 0) &&
 8016c4e:	2b00      	cmp	r3, #0
 8016c50:	d101      	bne.n	8016c56 <SecIsNumberNeedTo32Bit+0x30>
 8016c52:	2301      	movs	r3, #1
 8016c54:	e000      	b.n	8016c58 <SecIsNumberNeedTo32Bit+0x32>
 8016c56:	2300      	movs	r3, #0
}
 8016c58:	4618      	mov	r0, r3
 8016c5a:	370c      	adds	r7, #12
 8016c5c:	46bd      	mov	sp, r7
 8016c5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016c62:	4770      	bx	lr

08016c64 <SecNumberToBuffer>:

SECUREC_INLINE void SecNumberToBuffer(SecFormatAttr *attr, SecInt64 num64)
{
 8016c64:	b5b0      	push	{r4, r5, r7, lr}
 8016c66:	b086      	sub	sp, #24
 8016c68:	af00      	add	r7, sp, #0
 8016c6a:	60f8      	str	r0, [r7, #12]
 8016c6c:	e9c7 2300 	strd	r2, r3, [r7]
    SecUnsignedInt64 number;
    /* Check for negative; copy into number */
    if ((attr->flags & SECUREC_FLAG_SIGNED) != 0 && num64 < 0) {
 8016c70:	68fb      	ldr	r3, [r7, #12]
 8016c72:	695b      	ldr	r3, [r3, #20]
 8016c74:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016c78:	2b00      	cmp	r3, #0
 8016c7a:	d013      	beq.n	8016ca4 <SecNumberToBuffer+0x40>
 8016c7c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8016c80:	2a00      	cmp	r2, #0
 8016c82:	f173 0300 	sbcs.w	r3, r3, #0
 8016c86:	da0d      	bge.n	8016ca4 <SecNumberToBuffer+0x40>
        number = (SecUnsignedInt64)(0 - (SecUnsignedInt64)num64); /* Wrap with unsigned int64 numbers */
 8016c88:	e9d7 2300 	ldrd	r2, r3, [r7]
 8016c8c:	4252      	negs	r2, r2
 8016c8e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8016c92:	e9c7 2304 	strd	r2, r3, [r7, #16]
        attr->flags |= SECUREC_FLAG_NEGATIVE;
 8016c96:	68fb      	ldr	r3, [r7, #12]
 8016c98:	695b      	ldr	r3, [r3, #20]
 8016c9a:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8016c9e:	68fb      	ldr	r3, [r7, #12]
 8016ca0:	615a      	str	r2, [r3, #20]
 8016ca2:	e003      	b.n	8016cac <SecNumberToBuffer+0x48>
    } else {
        number = (SecUnsignedInt64)num64;
 8016ca4:	e9d7 2300 	ldrd	r2, r3, [r7]
 8016ca8:	e9c7 2304 	strd	r2, r3, [r7, #16]
    }
    if (SecIsNumberNeedTo32Bit(attr) != 0) {
 8016cac:	68f8      	ldr	r0, [r7, #12]
 8016cae:	f7ff ffba 	bl	8016c26 <SecIsNumberNeedTo32Bit>
 8016cb2:	4603      	mov	r3, r0
 8016cb4:	2b00      	cmp	r3, #0
 8016cb6:	d00b      	beq.n	8016cd0 <SecNumberToBuffer+0x6c>
        number = (number & (SecUnsignedInt64)0xffffffffUL);  /* Use 0xffffffff as 32 bit mask */
 8016cb8:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8016cbc:	f04f 30ff 	mov.w	r0, #4294967295
 8016cc0:	f04f 0100 	mov.w	r1, #0
 8016cc4:	ea02 0400 	and.w	r4, r2, r0
 8016cc8:	ea03 0501 	and.w	r5, r3, r1
 8016ccc:	e9c7 4504 	strd	r4, r5, [r7, #16]
    }

    /* The text.str must be point to buffer.str, this pointer is used outside the function */
    attr->text.str = &attr->buffer.str[SECUREC_BUFFER_SIZE];
 8016cd0:	68fb      	ldr	r3, [r7, #12]
 8016cd2:	f503 720d 	add.w	r2, r3, #564	; 0x234
 8016cd6:	68fb      	ldr	r3, [r7, #12]
 8016cd8:	605a      	str	r2, [r3, #4]

    if (number == 0) {
 8016cda:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8016cde:	4313      	orrs	r3, r2
 8016ce0:	d106      	bne.n	8016cf0 <SecNumberToBuffer+0x8c>
        /* Turn off hex prefix default, and textLen is zero */
        attr->prefixLen = 0;
 8016ce2:	68fb      	ldr	r3, [r7, #12]
 8016ce4:	2200      	movs	r2, #0
 8016ce6:	62da      	str	r2, [r3, #44]	; 0x2c
        attr->textLen = 0;
 8016ce8:	68fb      	ldr	r3, [r7, #12]
 8016cea:	2200      	movs	r2, #0
 8016cec:	609a      	str	r2, [r3, #8]
        return;
 8016cee:	e00c      	b.n	8016d0a <SecNumberToBuffer+0xa6>
    }

    /* Convert integer to string. It must be invoked when number > 0, otherwise the following logic is incorrect */
    SecNumberToString(number, attr);
 8016cf0:	68fa      	ldr	r2, [r7, #12]
 8016cf2:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8016cf6:	f7ff ff7a 	bl	8016bee <SecNumberToString>
    /* Compute length of number,  text.str must be in buffer.str */
    attr->textLen = (int)(size_t)((char *)&attr->buffer.str[SECUREC_BUFFER_SIZE] - attr->text.str);
 8016cfa:	68fb      	ldr	r3, [r7, #12]
 8016cfc:	f503 720d 	add.w	r2, r3, #564	; 0x234
 8016d00:	68fb      	ldr	r3, [r7, #12]
 8016d02:	685b      	ldr	r3, [r3, #4]
 8016d04:	1ad2      	subs	r2, r2, r3
 8016d06:	68fb      	ldr	r3, [r7, #12]
 8016d08:	609a      	str	r2, [r3, #8]
}
 8016d0a:	3718      	adds	r7, #24
 8016d0c:	46bd      	mov	sp, r7
 8016d0e:	bdb0      	pop	{r4, r5, r7, pc}

08016d10 <SecWriteChar>:

/*
 * Write one character to dest buffer
 */
SECUREC_INLINE void SecWriteChar(SecPrintfStream *stream, SecChar ch, int *charsOut)
{
 8016d10:	b480      	push	{r7}
 8016d12:	b085      	sub	sp, #20
 8016d14:	af00      	add	r7, sp, #0
 8016d16:	60f8      	str	r0, [r7, #12]
 8016d18:	460b      	mov	r3, r1
 8016d1a:	607a      	str	r2, [r7, #4]
 8016d1c:	72fb      	strb	r3, [r7, #11]
    /* Count must be reduced first, In order to identify insufficient length */
    --stream->count;
 8016d1e:	68fb      	ldr	r3, [r7, #12]
 8016d20:	681b      	ldr	r3, [r3, #0]
 8016d22:	1e5a      	subs	r2, r3, #1
 8016d24:	68fb      	ldr	r3, [r7, #12]
 8016d26:	601a      	str	r2, [r3, #0]
    if (stream->count >= 0) {
 8016d28:	68fb      	ldr	r3, [r7, #12]
 8016d2a:	681b      	ldr	r3, [r3, #0]
 8016d2c:	2b00      	cmp	r3, #0
 8016d2e:	db0e      	blt.n	8016d4e <SecWriteChar+0x3e>
        *(stream->cur) = ch;
 8016d30:	68fb      	ldr	r3, [r7, #12]
 8016d32:	685b      	ldr	r3, [r3, #4]
 8016d34:	7afa      	ldrb	r2, [r7, #11]
 8016d36:	701a      	strb	r2, [r3, #0]
        ++stream->cur;
 8016d38:	68fb      	ldr	r3, [r7, #12]
 8016d3a:	685b      	ldr	r3, [r3, #4]
 8016d3c:	1c5a      	adds	r2, r3, #1
 8016d3e:	68fb      	ldr	r3, [r7, #12]
 8016d40:	605a      	str	r2, [r3, #4]
        *charsOut = *charsOut + 1;
 8016d42:	687b      	ldr	r3, [r7, #4]
 8016d44:	681b      	ldr	r3, [r3, #0]
 8016d46:	1c5a      	adds	r2, r3, #1
 8016d48:	687b      	ldr	r3, [r7, #4]
 8016d4a:	601a      	str	r2, [r3, #0]
        return;
 8016d4c:	e003      	b.n	8016d56 <SecWriteChar+0x46>
    }
    /* No enough length */
    *charsOut = -1;
 8016d4e:	687b      	ldr	r3, [r7, #4]
 8016d50:	f04f 32ff 	mov.w	r2, #4294967295
 8016d54:	601a      	str	r2, [r3, #0]
}
 8016d56:	3714      	adds	r7, #20
 8016d58:	46bd      	mov	sp, r7
 8016d5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016d5e:	4770      	bx	lr

08016d60 <SecWriteMultiChar>:

/*
* Write multiple identical characters.
*/
SECUREC_INLINE void SecWriteMultiChar(SecPrintfStream *stream, SecChar ch, int num, int *charsOut)
{
 8016d60:	b480      	push	{r7}
 8016d62:	b087      	sub	sp, #28
 8016d64:	af00      	add	r7, sp, #0
 8016d66:	60f8      	str	r0, [r7, #12]
 8016d68:	607a      	str	r2, [r7, #4]
 8016d6a:	603b      	str	r3, [r7, #0]
 8016d6c:	460b      	mov	r3, r1
 8016d6e:	72fb      	strb	r3, [r7, #11]
    int count;
    for (count = num; count > 0; --count) {
 8016d70:	687b      	ldr	r3, [r7, #4]
 8016d72:	617b      	str	r3, [r7, #20]
 8016d74:	e019      	b.n	8016daa <SecWriteMultiChar+0x4a>
        --stream->count; /* count may be negative,indicating insufficient space */
 8016d76:	68fb      	ldr	r3, [r7, #12]
 8016d78:	681b      	ldr	r3, [r3, #0]
 8016d7a:	1e5a      	subs	r2, r3, #1
 8016d7c:	68fb      	ldr	r3, [r7, #12]
 8016d7e:	601a      	str	r2, [r3, #0]
        if (stream->count < 0) {
 8016d80:	68fb      	ldr	r3, [r7, #12]
 8016d82:	681b      	ldr	r3, [r3, #0]
 8016d84:	2b00      	cmp	r3, #0
 8016d86:	da04      	bge.n	8016d92 <SecWriteMultiChar+0x32>
            *charsOut = -1;
 8016d88:	683b      	ldr	r3, [r7, #0]
 8016d8a:	f04f 32ff 	mov.w	r2, #4294967295
 8016d8e:	601a      	str	r2, [r3, #0]
            return;
 8016d90:	e014      	b.n	8016dbc <SecWriteMultiChar+0x5c>
        }
        *(stream->cur) = ch;
 8016d92:	68fb      	ldr	r3, [r7, #12]
 8016d94:	685b      	ldr	r3, [r3, #4]
 8016d96:	7afa      	ldrb	r2, [r7, #11]
 8016d98:	701a      	strb	r2, [r3, #0]
        ++stream->cur;
 8016d9a:	68fb      	ldr	r3, [r7, #12]
 8016d9c:	685b      	ldr	r3, [r3, #4]
 8016d9e:	1c5a      	adds	r2, r3, #1
 8016da0:	68fb      	ldr	r3, [r7, #12]
 8016da2:	605a      	str	r2, [r3, #4]
    for (count = num; count > 0; --count) {
 8016da4:	697b      	ldr	r3, [r7, #20]
 8016da6:	3b01      	subs	r3, #1
 8016da8:	617b      	str	r3, [r7, #20]
 8016daa:	697b      	ldr	r3, [r7, #20]
 8016dac:	2b00      	cmp	r3, #0
 8016dae:	dce2      	bgt.n	8016d76 <SecWriteMultiChar+0x16>
    }
    *charsOut = *charsOut + num;
 8016db0:	683b      	ldr	r3, [r7, #0]
 8016db2:	681a      	ldr	r2, [r3, #0]
 8016db4:	687b      	ldr	r3, [r7, #4]
 8016db6:	441a      	add	r2, r3
 8016db8:	683b      	ldr	r3, [r7, #0]
 8016dba:	601a      	str	r2, [r3, #0]
}
 8016dbc:	371c      	adds	r7, #28
 8016dbe:	46bd      	mov	sp, r7
 8016dc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016dc4:	4770      	bx	lr

08016dc6 <SecWriteString>:

/*
* Write string function, where this function is called, make sure that len is greater than 0
*/
SECUREC_INLINE void SecWriteString(SecPrintfStream *stream, const SecChar *str, int len, int *charsOut)
{
 8016dc6:	b480      	push	{r7}
 8016dc8:	b087      	sub	sp, #28
 8016dca:	af00      	add	r7, sp, #0
 8016dcc:	60f8      	str	r0, [r7, #12]
 8016dce:	60b9      	str	r1, [r7, #8]
 8016dd0:	607a      	str	r2, [r7, #4]
 8016dd2:	603b      	str	r3, [r7, #0]
    const SecChar *tmp = str;
 8016dd4:	68bb      	ldr	r3, [r7, #8]
 8016dd6:	613b      	str	r3, [r7, #16]
    int count;
    for (count = len; count > 0; --count) {
 8016dd8:	687b      	ldr	r3, [r7, #4]
 8016dda:	617b      	str	r3, [r7, #20]
 8016ddc:	e01d      	b.n	8016e1a <SecWriteString+0x54>
        --stream->count; /* count may be negative,indicating insufficient space */
 8016dde:	68fb      	ldr	r3, [r7, #12]
 8016de0:	681b      	ldr	r3, [r3, #0]
 8016de2:	1e5a      	subs	r2, r3, #1
 8016de4:	68fb      	ldr	r3, [r7, #12]
 8016de6:	601a      	str	r2, [r3, #0]
        if (stream->count < 0) {
 8016de8:	68fb      	ldr	r3, [r7, #12]
 8016dea:	681b      	ldr	r3, [r3, #0]
 8016dec:	2b00      	cmp	r3, #0
 8016dee:	da04      	bge.n	8016dfa <SecWriteString+0x34>
            *charsOut = -1;
 8016df0:	683b      	ldr	r3, [r7, #0]
 8016df2:	f04f 32ff 	mov.w	r2, #4294967295
 8016df6:	601a      	str	r2, [r3, #0]
            return;
 8016df8:	e018      	b.n	8016e2c <SecWriteString+0x66>
        }
        *(stream->cur) = *tmp;
 8016dfa:	68fb      	ldr	r3, [r7, #12]
 8016dfc:	685b      	ldr	r3, [r3, #4]
 8016dfe:	693a      	ldr	r2, [r7, #16]
 8016e00:	7812      	ldrb	r2, [r2, #0]
 8016e02:	701a      	strb	r2, [r3, #0]
        ++stream->cur;
 8016e04:	68fb      	ldr	r3, [r7, #12]
 8016e06:	685b      	ldr	r3, [r3, #4]
 8016e08:	1c5a      	adds	r2, r3, #1
 8016e0a:	68fb      	ldr	r3, [r7, #12]
 8016e0c:	605a      	str	r2, [r3, #4]
        ++tmp;
 8016e0e:	693b      	ldr	r3, [r7, #16]
 8016e10:	3301      	adds	r3, #1
 8016e12:	613b      	str	r3, [r7, #16]
    for (count = len; count > 0; --count) {
 8016e14:	697b      	ldr	r3, [r7, #20]
 8016e16:	3b01      	subs	r3, #1
 8016e18:	617b      	str	r3, [r7, #20]
 8016e1a:	697b      	ldr	r3, [r7, #20]
 8016e1c:	2b00      	cmp	r3, #0
 8016e1e:	dcde      	bgt.n	8016dde <SecWriteString+0x18>
    }
    *charsOut = *charsOut + len;
 8016e20:	683b      	ldr	r3, [r7, #0]
 8016e22:	681a      	ldr	r2, [r3, #0]
 8016e24:	687b      	ldr	r3, [r7, #4]
 8016e26:	441a      	add	r2, r3
 8016e28:	683b      	ldr	r3, [r7, #0]
 8016e2a:	601a      	str	r2, [r3, #0]
}
 8016e2c:	371c      	adds	r7, #28
 8016e2e:	46bd      	mov	sp, r7
 8016e30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016e34:	4770      	bx	lr

08016e36 <SecWriteStringByLoop>:

/* Use loop copy char or wchar_t string */
SECUREC_INLINE void SecWriteStringByLoop(SecPrintfStream *stream, const SecChar *str, int len)
{
 8016e36:	b480      	push	{r7}
 8016e38:	b087      	sub	sp, #28
 8016e3a:	af00      	add	r7, sp, #0
 8016e3c:	60f8      	str	r0, [r7, #12]
 8016e3e:	60b9      	str	r1, [r7, #8]
 8016e40:	607a      	str	r2, [r7, #4]
    int i;
    const SecChar *tmp = str;
 8016e42:	68bb      	ldr	r3, [r7, #8]
 8016e44:	617b      	str	r3, [r7, #20]
    for (i = 0; i < len; ++i) {
 8016e46:	2300      	movs	r3, #0
 8016e48:	613b      	str	r3, [r7, #16]
 8016e4a:	e00f      	b.n	8016e6c <SecWriteStringByLoop+0x36>
        *stream->cur = *tmp;
 8016e4c:	68fb      	ldr	r3, [r7, #12]
 8016e4e:	685b      	ldr	r3, [r3, #4]
 8016e50:	697a      	ldr	r2, [r7, #20]
 8016e52:	7812      	ldrb	r2, [r2, #0]
 8016e54:	701a      	strb	r2, [r3, #0]
        ++stream->cur;
 8016e56:	68fb      	ldr	r3, [r7, #12]
 8016e58:	685b      	ldr	r3, [r3, #4]
 8016e5a:	1c5a      	adds	r2, r3, #1
 8016e5c:	68fb      	ldr	r3, [r7, #12]
 8016e5e:	605a      	str	r2, [r3, #4]
        ++tmp;
 8016e60:	697b      	ldr	r3, [r7, #20]
 8016e62:	3301      	adds	r3, #1
 8016e64:	617b      	str	r3, [r7, #20]
    for (i = 0; i < len; ++i) {
 8016e66:	693b      	ldr	r3, [r7, #16]
 8016e68:	3301      	adds	r3, #1
 8016e6a:	613b      	str	r3, [r7, #16]
 8016e6c:	693a      	ldr	r2, [r7, #16]
 8016e6e:	687b      	ldr	r3, [r7, #4]
 8016e70:	429a      	cmp	r2, r3
 8016e72:	dbeb      	blt.n	8016e4c <SecWriteStringByLoop+0x16>
    }
    stream->count -= len;
 8016e74:	68fb      	ldr	r3, [r7, #12]
 8016e76:	681a      	ldr	r2, [r3, #0]
 8016e78:	687b      	ldr	r3, [r7, #4]
 8016e7a:	1ad2      	subs	r2, r2, r3
 8016e7c:	68fb      	ldr	r3, [r7, #12]
 8016e7e:	601a      	str	r2, [r3, #0]
}
 8016e80:	bf00      	nop
 8016e82:	371c      	adds	r7, #28
 8016e84:	46bd      	mov	sp, r7
 8016e86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016e8a:	4770      	bx	lr

08016e8c <SecWriteStringOpt>:

SECUREC_INLINE void SecWriteStringOpt(SecPrintfStream *stream, const SecChar *str, int len)
{
 8016e8c:	b580      	push	{r7, lr}
 8016e8e:	b086      	sub	sp, #24
 8016e90:	af00      	add	r7, sp, #0
 8016e92:	60f8      	str	r0, [r7, #12]
 8016e94:	60b9      	str	r1, [r7, #8]
 8016e96:	607a      	str	r2, [r7, #4]
    if (len < 12) { /* Performance optimization for mobile number length 12 */
 8016e98:	687b      	ldr	r3, [r7, #4]
 8016e9a:	2b0b      	cmp	r3, #11
 8016e9c:	dc05      	bgt.n	8016eaa <SecWriteStringOpt+0x1e>
        SecWriteStringByLoop(stream, str, len);
 8016e9e:	687a      	ldr	r2, [r7, #4]
 8016ea0:	68b9      	ldr	r1, [r7, #8]
 8016ea2:	68f8      	ldr	r0, [r7, #12]
 8016ea4:	f7ff ffc7 	bl	8016e36 <SecWriteStringByLoop>
        size_t count = (size_t)(unsigned int)len * sizeof(SecChar);
        SECUREC_MEMCPY_WARP_OPT(stream->cur, str, count);
        stream->cur += len;
        stream->count -= len;
    }
}
 8016ea8:	e014      	b.n	8016ed4 <SecWriteStringOpt+0x48>
        size_t count = (size_t)(unsigned int)len * sizeof(SecChar);
 8016eaa:	687b      	ldr	r3, [r7, #4]
 8016eac:	617b      	str	r3, [r7, #20]
        SECUREC_MEMCPY_WARP_OPT(stream->cur, str, count);
 8016eae:	68fb      	ldr	r3, [r7, #12]
 8016eb0:	685b      	ldr	r3, [r3, #4]
 8016eb2:	697a      	ldr	r2, [r7, #20]
 8016eb4:	68b9      	ldr	r1, [r7, #8]
 8016eb6:	4618      	mov	r0, r3
 8016eb8:	f002 f80a 	bl	8018ed0 <memcpy>
        stream->cur += len;
 8016ebc:	68fb      	ldr	r3, [r7, #12]
 8016ebe:	685a      	ldr	r2, [r3, #4]
 8016ec0:	687b      	ldr	r3, [r7, #4]
 8016ec2:	441a      	add	r2, r3
 8016ec4:	68fb      	ldr	r3, [r7, #12]
 8016ec6:	605a      	str	r2, [r3, #4]
        stream->count -= len;
 8016ec8:	68fb      	ldr	r3, [r7, #12]
 8016eca:	681a      	ldr	r2, [r3, #0]
 8016ecc:	687b      	ldr	r3, [r7, #4]
 8016ece:	1ad2      	subs	r2, r2, r3
 8016ed0:	68fb      	ldr	r3, [r7, #12]
 8016ed2:	601a      	str	r2, [r3, #0]
}
 8016ed4:	bf00      	nop
 8016ed6:	3718      	adds	r7, #24
 8016ed8:	46bd      	mov	sp, r7
 8016eda:	bd80      	pop	{r7, pc}

08016edc <SecIsStreamBufEnough>:
/*
 * Return if buffer length is enough
 * The count variable can be reduced to 0, and the external function complements the \0 terminator.
 */
SECUREC_INLINE int SecIsStreamBufEnough(const SecPrintfStream *stream, int needLen)
{
 8016edc:	b480      	push	{r7}
 8016ede:	b083      	sub	sp, #12
 8016ee0:	af00      	add	r7, sp, #0
 8016ee2:	6078      	str	r0, [r7, #4]
 8016ee4:	6039      	str	r1, [r7, #0]
    return (int)(stream->count >= needLen);
 8016ee6:	687b      	ldr	r3, [r7, #4]
 8016ee8:	681b      	ldr	r3, [r3, #0]
 8016eea:	683a      	ldr	r2, [r7, #0]
 8016eec:	429a      	cmp	r2, r3
 8016eee:	bfd4      	ite	le
 8016ef0:	2301      	movle	r3, #1
 8016ef2:	2300      	movgt	r3, #0
 8016ef4:	b2db      	uxtb	r3, r3
}
 8016ef6:	4618      	mov	r0, r3
 8016ef8:	370c      	adds	r7, #12
 8016efa:	46bd      	mov	sp, r7
 8016efc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016f00:	4770      	bx	lr

08016f02 <SecWriteTextOpt>:

/* Write text string */
SECUREC_INLINE void SecWriteTextOpt(SecPrintfStream *stream, const SecChar *str, int len, int *charsOut)
{
 8016f02:	b580      	push	{r7, lr}
 8016f04:	b084      	sub	sp, #16
 8016f06:	af00      	add	r7, sp, #0
 8016f08:	60f8      	str	r0, [r7, #12]
 8016f0a:	60b9      	str	r1, [r7, #8]
 8016f0c:	607a      	str	r2, [r7, #4]
 8016f0e:	603b      	str	r3, [r7, #0]
    if (SecIsStreamBufEnough(stream, len) != 0) {
 8016f10:	6879      	ldr	r1, [r7, #4]
 8016f12:	68f8      	ldr	r0, [r7, #12]
 8016f14:	f7ff ffe2 	bl	8016edc <SecIsStreamBufEnough>
 8016f18:	4603      	mov	r3, r0
 8016f1a:	2b00      	cmp	r3, #0
 8016f1c:	d00b      	beq.n	8016f36 <SecWriteTextOpt+0x34>
        SecWriteStringOpt(stream, str, len);
 8016f1e:	687a      	ldr	r2, [r7, #4]
 8016f20:	68b9      	ldr	r1, [r7, #8]
 8016f22:	68f8      	ldr	r0, [r7, #12]
 8016f24:	f7ff ffb2 	bl	8016e8c <SecWriteStringOpt>
        *charsOut += len;
 8016f28:	683b      	ldr	r3, [r7, #0]
 8016f2a:	681a      	ldr	r2, [r3, #0]
 8016f2c:	687b      	ldr	r3, [r7, #4]
 8016f2e:	441a      	add	r2, r3
 8016f30:	683b      	ldr	r3, [r7, #0]
 8016f32:	601a      	str	r2, [r3, #0]
    } else {
        SecWriteString(stream, str, len, charsOut);
    }
}
 8016f34:	e005      	b.n	8016f42 <SecWriteTextOpt+0x40>
        SecWriteString(stream, str, len, charsOut);
 8016f36:	683b      	ldr	r3, [r7, #0]
 8016f38:	687a      	ldr	r2, [r7, #4]
 8016f3a:	68b9      	ldr	r1, [r7, #8]
 8016f3c:	68f8      	ldr	r0, [r7, #12]
 8016f3e:	f7ff ff42 	bl	8016dc6 <SecWriteString>
}
 8016f42:	bf00      	nop
 8016f44:	3710      	adds	r7, #16
 8016f46:	46bd      	mov	sp, r7
 8016f48:	bd80      	pop	{r7, pc}

08016f4a <SecWriteLeftPadding>:

/* Write left padding */
SECUREC_INLINE void SecWriteLeftPadding(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8016f4a:	b580      	push	{r7, lr}
 8016f4c:	b084      	sub	sp, #16
 8016f4e:	af00      	add	r7, sp, #0
 8016f50:	60f8      	str	r0, [r7, #12]
 8016f52:	60b9      	str	r1, [r7, #8]
 8016f54:	607a      	str	r2, [r7, #4]
    if ((attr->flags & (SECUREC_FLAG_LEFT | SECUREC_FLAG_LEADZERO)) == 0 && attr->padding > 0) {
 8016f56:	68bb      	ldr	r3, [r7, #8]
 8016f58:	695b      	ldr	r3, [r3, #20]
 8016f5a:	f003 030c 	and.w	r3, r3, #12
 8016f5e:	2b00      	cmp	r3, #0
 8016f60:	d10a      	bne.n	8016f78 <SecWriteLeftPadding+0x2e>
 8016f62:	68bb      	ldr	r3, [r7, #8]
 8016f64:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8016f66:	2b00      	cmp	r3, #0
 8016f68:	dd06      	ble.n	8016f78 <SecWriteLeftPadding+0x2e>
        /* Pad on left with blanks */
        SecWriteMultiChar(stream, SECUREC_CHAR(' '), attr->padding, charsOut);
 8016f6a:	68bb      	ldr	r3, [r7, #8]
 8016f6c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8016f6e:	687b      	ldr	r3, [r7, #4]
 8016f70:	2120      	movs	r1, #32
 8016f72:	68f8      	ldr	r0, [r7, #12]
 8016f74:	f7ff fef4 	bl	8016d60 <SecWriteMultiChar>
    }
}
 8016f78:	bf00      	nop
 8016f7a:	3710      	adds	r7, #16
 8016f7c:	46bd      	mov	sp, r7
 8016f7e:	bd80      	pop	{r7, pc}

08016f80 <SecWritePrefix>:

/* Write prefix */
SECUREC_INLINE void SecWritePrefix(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8016f80:	b580      	push	{r7, lr}
 8016f82:	b084      	sub	sp, #16
 8016f84:	af00      	add	r7, sp, #0
 8016f86:	60f8      	str	r0, [r7, #12]
 8016f88:	60b9      	str	r1, [r7, #8]
 8016f8a:	607a      	str	r2, [r7, #4]
    if (attr->prefixLen > 0) {
 8016f8c:	68bb      	ldr	r3, [r7, #8]
 8016f8e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8016f90:	2b00      	cmp	r3, #0
 8016f92:	dd08      	ble.n	8016fa6 <SecWritePrefix+0x26>
        SecWriteString(stream, attr->prefix, attr->prefixLen, charsOut);
 8016f94:	68bb      	ldr	r3, [r7, #8]
 8016f96:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8016f9a:	68bb      	ldr	r3, [r7, #8]
 8016f9c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8016f9e:	687b      	ldr	r3, [r7, #4]
 8016fa0:	68f8      	ldr	r0, [r7, #12]
 8016fa2:	f7ff ff10 	bl	8016dc6 <SecWriteString>
    }
}
 8016fa6:	bf00      	nop
 8016fa8:	3710      	adds	r7, #16
 8016faa:	46bd      	mov	sp, r7
 8016fac:	bd80      	pop	{r7, pc}

08016fae <SecWriteLeadingZero>:

/* Write leading zeros */
SECUREC_INLINE void SecWriteLeadingZero(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8016fae:	b580      	push	{r7, lr}
 8016fb0:	b084      	sub	sp, #16
 8016fb2:	af00      	add	r7, sp, #0
 8016fb4:	60f8      	str	r0, [r7, #12]
 8016fb6:	60b9      	str	r1, [r7, #8]
 8016fb8:	607a      	str	r2, [r7, #4]
    if ((attr->flags & SECUREC_FLAG_LEADZERO) != 0 && (attr->flags & SECUREC_FLAG_LEFT) == 0 &&
 8016fba:	68bb      	ldr	r3, [r7, #8]
 8016fbc:	695b      	ldr	r3, [r3, #20]
 8016fbe:	f003 0308 	and.w	r3, r3, #8
 8016fc2:	2b00      	cmp	r3, #0
 8016fc4:	d010      	beq.n	8016fe8 <SecWriteLeadingZero+0x3a>
 8016fc6:	68bb      	ldr	r3, [r7, #8]
 8016fc8:	695b      	ldr	r3, [r3, #20]
 8016fca:	f003 0304 	and.w	r3, r3, #4
 8016fce:	2b00      	cmp	r3, #0
 8016fd0:	d10a      	bne.n	8016fe8 <SecWriteLeadingZero+0x3a>
        attr->padding > 0) {
 8016fd2:	68bb      	ldr	r3, [r7, #8]
 8016fd4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    if ((attr->flags & SECUREC_FLAG_LEADZERO) != 0 && (attr->flags & SECUREC_FLAG_LEFT) == 0 &&
 8016fd6:	2b00      	cmp	r3, #0
 8016fd8:	dd06      	ble.n	8016fe8 <SecWriteLeadingZero+0x3a>
        SecWriteMultiChar(stream, SECUREC_CHAR('0'), attr->padding, charsOut);
 8016fda:	68bb      	ldr	r3, [r7, #8]
 8016fdc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8016fde:	687b      	ldr	r3, [r7, #4]
 8016fe0:	2130      	movs	r1, #48	; 0x30
 8016fe2:	68f8      	ldr	r0, [r7, #12]
 8016fe4:	f7ff febc 	bl	8016d60 <SecWriteMultiChar>
    }
}
 8016fe8:	bf00      	nop
 8016fea:	3710      	adds	r7, #16
 8016fec:	46bd      	mov	sp, r7
 8016fee:	bd80      	pop	{r7, pc}

08016ff0 <SecWriteRightPadding>:

/* Write right padding */
SECUREC_INLINE void SecWriteRightPadding(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8016ff0:	b580      	push	{r7, lr}
 8016ff2:	b084      	sub	sp, #16
 8016ff4:	af00      	add	r7, sp, #0
 8016ff6:	60f8      	str	r0, [r7, #12]
 8016ff8:	60b9      	str	r1, [r7, #8]
 8016ffa:	607a      	str	r2, [r7, #4]
    if (*charsOut >= 0 && (attr->flags & SECUREC_FLAG_LEFT) != 0 && attr->padding > 0) {
 8016ffc:	687b      	ldr	r3, [r7, #4]
 8016ffe:	681b      	ldr	r3, [r3, #0]
 8017000:	2b00      	cmp	r3, #0
 8017002:	db10      	blt.n	8017026 <SecWriteRightPadding+0x36>
 8017004:	68bb      	ldr	r3, [r7, #8]
 8017006:	695b      	ldr	r3, [r3, #20]
 8017008:	f003 0304 	and.w	r3, r3, #4
 801700c:	2b00      	cmp	r3, #0
 801700e:	d00a      	beq.n	8017026 <SecWriteRightPadding+0x36>
 8017010:	68bb      	ldr	r3, [r7, #8]
 8017012:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017014:	2b00      	cmp	r3, #0
 8017016:	dd06      	ble.n	8017026 <SecWriteRightPadding+0x36>
        /* Pad on right with blanks */
        SecWriteMultiChar(stream, SECUREC_CHAR(' '), attr->padding, charsOut);
 8017018:	68bb      	ldr	r3, [r7, #8]
 801701a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801701c:	687b      	ldr	r3, [r7, #4]
 801701e:	2120      	movs	r1, #32
 8017020:	68f8      	ldr	r0, [r7, #12]
 8017022:	f7ff fe9d 	bl	8016d60 <SecWriteMultiChar>
    }
}
 8017026:	bf00      	nop
 8017028:	3710      	adds	r7, #16
 801702a:	46bd      	mov	sp, r7
 801702c:	bd80      	pop	{r7, pc}
	...

08017030 <SecWriteTextAfterWctomb>:
}
#endif
#else  /* Not SECUREC_FOR_WCHAR */
#if SECUREC_HAVE_WCTOMB
SECUREC_INLINE void SecWriteTextAfterWctomb(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8017030:	b580      	push	{r7, lr}
 8017032:	b08e      	sub	sp, #56	; 0x38
 8017034:	af00      	add	r7, sp, #0
 8017036:	60f8      	str	r0, [r7, #12]
 8017038:	60b9      	str	r1, [r7, #8]
 801703a:	607a      	str	r2, [r7, #4]
 801703c:	4b20      	ldr	r3, [pc, #128]	; (80170c0 <SecWriteTextAfterWctomb+0x90>)
 801703e:	681b      	ldr	r3, [r3, #0]
 8017040:	637b      	str	r3, [r7, #52]	; 0x34
 8017042:	f04f 0300 	mov.w	r3, #0
    const wchar_t *p = attr->text.wStr;
 8017046:	68bb      	ldr	r3, [r7, #8]
 8017048:	685b      	ldr	r3, [r3, #4]
 801704a:	617b      	str	r3, [r7, #20]
    int count = attr->textLen;
 801704c:	68bb      	ldr	r3, [r7, #8]
 801704e:	689b      	ldr	r3, [r3, #8]
 8017050:	61bb      	str	r3, [r7, #24]
    while (count > 0) {
 8017052:	e026      	b.n	80170a2 <SecWriteTextAfterWctomb+0x72>
        char tmpBuf[SECUREC_MB_LEN + 1];
        SECUREC_MASK_MSVC_CRT_WARNING
        int retVal = wctomb(tmpBuf, *p);
 8017054:	697b      	ldr	r3, [r7, #20]
 8017056:	681a      	ldr	r2, [r3, #0]
 8017058:	f107 0320 	add.w	r3, r7, #32
 801705c:	4611      	mov	r1, r2
 801705e:	4618      	mov	r0, r3
 8017060:	f008 f950 	bl	801f304 <wctomb>
 8017064:	61f8      	str	r0, [r7, #28]
        SECUREC_END_MASK_MSVC_CRT_WARNING
        if (retVal <= 0) {
 8017066:	69fb      	ldr	r3, [r7, #28]
 8017068:	2b00      	cmp	r3, #0
 801706a:	dc05      	bgt.n	8017078 <SecWriteTextAfterWctomb+0x48>
            *charsOut = -1;
 801706c:	687b      	ldr	r3, [r7, #4]
 801706e:	f04f 32ff 	mov.w	r2, #4294967295
 8017072:	601a      	str	r2, [r3, #0]
            break;
 8017074:	bf00      	nop
            break;
        }
        --count;
        ++p;
    }
}
 8017076:	e017      	b.n	80170a8 <SecWriteTextAfterWctomb+0x78>
        SecWriteString(stream, tmpBuf, retVal, charsOut);
 8017078:	f107 0120 	add.w	r1, r7, #32
 801707c:	687b      	ldr	r3, [r7, #4]
 801707e:	69fa      	ldr	r2, [r7, #28]
 8017080:	68f8      	ldr	r0, [r7, #12]
 8017082:	f7ff fea0 	bl	8016dc6 <SecWriteString>
        if (*charsOut == -1) {
 8017086:	687b      	ldr	r3, [r7, #4]
 8017088:	681b      	ldr	r3, [r3, #0]
 801708a:	f1b3 3fff 	cmp.w	r3, #4294967295
 801708e:	d006      	beq.n	801709e <SecWriteTextAfterWctomb+0x6e>
        --count;
 8017090:	69bb      	ldr	r3, [r7, #24]
 8017092:	3b01      	subs	r3, #1
 8017094:	61bb      	str	r3, [r7, #24]
        ++p;
 8017096:	697b      	ldr	r3, [r7, #20]
 8017098:	3304      	adds	r3, #4
 801709a:	617b      	str	r3, [r7, #20]
 801709c:	e001      	b.n	80170a2 <SecWriteTextAfterWctomb+0x72>
            break;
 801709e:	bf00      	nop
}
 80170a0:	e002      	b.n	80170a8 <SecWriteTextAfterWctomb+0x78>
    while (count > 0) {
 80170a2:	69bb      	ldr	r3, [r7, #24]
 80170a4:	2b00      	cmp	r3, #0
 80170a6:	dcd5      	bgt.n	8017054 <SecWriteTextAfterWctomb+0x24>
}
 80170a8:	bf00      	nop
 80170aa:	4b05      	ldr	r3, [pc, #20]	; (80170c0 <SecWriteTextAfterWctomb+0x90>)
 80170ac:	681a      	ldr	r2, [r3, #0]
 80170ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80170b0:	405a      	eors	r2, r3
 80170b2:	d001      	beq.n	80170b8 <SecWriteTextAfterWctomb+0x88>
 80170b4:	f7ed f998 	bl	80043e8 <__stack_chk_fail>
 80170b8:	3738      	adds	r7, #56	; 0x38
 80170ba:	46bd      	mov	sp, r7
 80170bc:	bd80      	pop	{r7, pc}
 80170be:	bf00      	nop
 80170c0:	08023040 	.word	0x08023040

080170c4 <SecWriteFloatText>:
/*
 * Write text of float
 * Using independent functions to optimize the expansion of inline functions by the compiler
 */
SECUREC_INLINE void SecWriteFloatText(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 80170c4:	b580      	push	{r7, lr}
 80170c6:	b084      	sub	sp, #16
 80170c8:	af00      	add	r7, sp, #0
 80170ca:	60f8      	str	r0, [r7, #12]
 80170cc:	60b9      	str	r1, [r7, #8]
 80170ce:	607a      	str	r2, [r7, #4]
    *charsOut = -1;
    (void)stream; /* To clear e438 last value assigned not used , the compiler will optimize this code */
    (void)attr;   /* To clear e438 last value assigned not used , the compiler will optimize this code */
#endif
#else /* Not SECUREC_FOR_WCHAR */
    SecWriteString(stream, attr->text.str, attr->textLen, charsOut);
 80170d0:	68bb      	ldr	r3, [r7, #8]
 80170d2:	6859      	ldr	r1, [r3, #4]
 80170d4:	68bb      	ldr	r3, [r7, #8]
 80170d6:	689a      	ldr	r2, [r3, #8]
 80170d8:	687b      	ldr	r3, [r7, #4]
 80170da:	68f8      	ldr	r0, [r7, #12]
 80170dc:	f7ff fe73 	bl	8016dc6 <SecWriteString>
#endif
}
 80170e0:	bf00      	nop
 80170e2:	3710      	adds	r7, #16
 80170e4:	46bd      	mov	sp, r7
 80170e6:	bd80      	pop	{r7, pc}

080170e8 <SecWriteText>:
#endif

/* Write text of integer or string ... */
SECUREC_INLINE void SecWriteText(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 80170e8:	b580      	push	{r7, lr}
 80170ea:	b084      	sub	sp, #16
 80170ec:	af00      	add	r7, sp, #0
 80170ee:	60f8      	str	r0, [r7, #12]
 80170f0:	60b9      	str	r1, [r7, #8]
 80170f2:	607a      	str	r2, [r7, #4]
    if (SECUREC_NEED_CONVERT_TEXT(attr)) {
 80170f4:	68bb      	ldr	r3, [r7, #8]
 80170f6:	68db      	ldr	r3, [r3, #12]
 80170f8:	2b00      	cmp	r3, #0
 80170fa:	d005      	beq.n	8017108 <SecWriteText+0x20>
        SECUREC_WRITE_TEXT_AFTER_CONVERT(stream, attr, charsOut);
 80170fc:	687a      	ldr	r2, [r7, #4]
 80170fe:	68b9      	ldr	r1, [r7, #8]
 8017100:	68f8      	ldr	r0, [r7, #12]
 8017102:	f7ff ff95 	bl	8017030 <SecWriteTextAfterWctomb>
    } else {
        SecWriteTextOpt(stream, SECUREC_TEXT_CHAR_PTR(attr->text), attr->textLen, charsOut);
    }
}
 8017106:	e007      	b.n	8017118 <SecWriteText+0x30>
        SecWriteTextOpt(stream, SECUREC_TEXT_CHAR_PTR(attr->text), attr->textLen, charsOut);
 8017108:	68bb      	ldr	r3, [r7, #8]
 801710a:	6859      	ldr	r1, [r3, #4]
 801710c:	68bb      	ldr	r3, [r7, #8]
 801710e:	689a      	ldr	r2, [r3, #8]
 8017110:	687b      	ldr	r3, [r7, #4]
 8017112:	68f8      	ldr	r0, [r7, #12]
 8017114:	f7ff fef5 	bl	8016f02 <SecWriteTextOpt>
}
 8017118:	bf00      	nop
 801711a:	3710      	adds	r7, #16
 801711c:	46bd      	mov	sp, r7
 801711e:	bd80      	pop	{r7, pc}

08017120 <SecDecodeState>:

#define SECUREC_FMT_STATE_OFFSET  256

SECUREC_INLINE SecFmtState SecDecodeState(SecChar ch, SecFmtState lastState)
{
 8017120:	b480      	push	{r7}
 8017122:	b085      	sub	sp, #20
 8017124:	af00      	add	r7, sp, #0
 8017126:	4603      	mov	r3, r0
 8017128:	6039      	str	r1, [r7, #0]
 801712a:	71fb      	strb	r3, [r7, #7]
    unsigned char fmtType = (unsigned char)((((unsigned int)(int)(ch)) <= (unsigned int)(int)(L'~')) ? \
        (stateTable[(unsigned char)(ch)]) : 0);
    return (SecFmtState)(stateTable[fmtType * ((unsigned char)STAT_INVALID + 1) +
        (unsigned char)(lastState) + SECUREC_FMT_STATE_OFFSET]);
#else
    unsigned char fmtType = stateTable[(unsigned char)(ch)];
 801712c:	79fb      	ldrb	r3, [r7, #7]
 801712e:	4a0a      	ldr	r2, [pc, #40]	; (8017158 <SecDecodeState+0x38>)
 8017130:	5cd3      	ldrb	r3, [r2, r3]
 8017132:	73fb      	strb	r3, [r7, #15]
    return (SecFmtState)(stateTable[fmtType * ((unsigned char)STAT_INVALID + 1) +
 8017134:	7bfa      	ldrb	r2, [r7, #15]
 8017136:	4613      	mov	r3, r2
 8017138:	00db      	lsls	r3, r3, #3
 801713a:	4413      	add	r3, r2
        (unsigned char)(lastState) + SECUREC_FMT_STATE_OFFSET]);
 801713c:	683a      	ldr	r2, [r7, #0]
 801713e:	b2d2      	uxtb	r2, r2
    return (SecFmtState)(stateTable[fmtType * ((unsigned char)STAT_INVALID + 1) +
 8017140:	4413      	add	r3, r2
        (unsigned char)(lastState) + SECUREC_FMT_STATE_OFFSET]);
 8017142:	f503 7380 	add.w	r3, r3, #256	; 0x100
    return (SecFmtState)(stateTable[fmtType * ((unsigned char)STAT_INVALID + 1) +
 8017146:	4a04      	ldr	r2, [pc, #16]	; (8017158 <SecDecodeState+0x38>)
 8017148:	5cd3      	ldrb	r3, [r2, r3]
#endif
}
 801714a:	4618      	mov	r0, r3
 801714c:	3714      	adds	r7, #20
 801714e:	46bd      	mov	sp, r7
 8017150:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017154:	4770      	bx	lr
 8017156:	bf00      	nop
 8017158:	080236dc 	.word	0x080236dc

0801715c <SecDecodeFlags>:

SECUREC_INLINE void SecDecodeFlags(SecChar ch, SecFormatAttr *attr)
{
 801715c:	b480      	push	{r7}
 801715e:	b083      	sub	sp, #12
 8017160:	af00      	add	r7, sp, #0
 8017162:	4603      	mov	r3, r0
 8017164:	6039      	str	r1, [r7, #0]
 8017166:	71fb      	strb	r3, [r7, #7]
    switch (ch) {
 8017168:	79fb      	ldrb	r3, [r7, #7]
 801716a:	3b20      	subs	r3, #32
 801716c:	2b10      	cmp	r3, #16
 801716e:	d848      	bhi.n	8017202 <SecDecodeFlags+0xa6>
 8017170:	a201      	add	r2, pc, #4	; (adr r2, 8017178 <SecDecodeFlags+0x1c>)
 8017172:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017176:	bf00      	nop
 8017178:	080171bd 	.word	0x080171bd
 801717c:	08017203 	.word	0x08017203
 8017180:	08017203 	.word	0x08017203
 8017184:	080171f5 	.word	0x080171f5
 8017188:	08017203 	.word	0x08017203
 801718c:	08017203 	.word	0x08017203
 8017190:	08017203 	.word	0x08017203
 8017194:	08017203 	.word	0x08017203
 8017198:	08017203 	.word	0x08017203
 801719c:	08017203 	.word	0x08017203
 80171a0:	08017203 	.word	0x08017203
 80171a4:	080171cb 	.word	0x080171cb
 80171a8:	08017203 	.word	0x08017203
 80171ac:	080171d9 	.word	0x080171d9
 80171b0:	08017203 	.word	0x08017203
 80171b4:	08017203 	.word	0x08017203
 80171b8:	080171e7 	.word	0x080171e7
        case SECUREC_CHAR(' '):
            attr->flags |= SECUREC_FLAG_SIGN_SPACE;
 80171bc:	683b      	ldr	r3, [r7, #0]
 80171be:	695b      	ldr	r3, [r3, #20]
 80171c0:	f043 0202 	orr.w	r2, r3, #2
 80171c4:	683b      	ldr	r3, [r7, #0]
 80171c6:	615a      	str	r2, [r3, #20]
            break;
 80171c8:	e01c      	b.n	8017204 <SecDecodeFlags+0xa8>
        case SECUREC_CHAR('+'):
            attr->flags |= SECUREC_FLAG_SIGN;
 80171ca:	683b      	ldr	r3, [r7, #0]
 80171cc:	695b      	ldr	r3, [r3, #20]
 80171ce:	f043 0201 	orr.w	r2, r3, #1
 80171d2:	683b      	ldr	r3, [r7, #0]
 80171d4:	615a      	str	r2, [r3, #20]
            break;
 80171d6:	e015      	b.n	8017204 <SecDecodeFlags+0xa8>
        case SECUREC_CHAR('-'):
            attr->flags |= SECUREC_FLAG_LEFT;
 80171d8:	683b      	ldr	r3, [r7, #0]
 80171da:	695b      	ldr	r3, [r3, #20]
 80171dc:	f043 0204 	orr.w	r2, r3, #4
 80171e0:	683b      	ldr	r3, [r7, #0]
 80171e2:	615a      	str	r2, [r3, #20]
            break;
 80171e4:	e00e      	b.n	8017204 <SecDecodeFlags+0xa8>
        case SECUREC_CHAR('0'):
            attr->flags |= SECUREC_FLAG_LEADZERO;   /* Add zero th the front */
 80171e6:	683b      	ldr	r3, [r7, #0]
 80171e8:	695b      	ldr	r3, [r3, #20]
 80171ea:	f043 0208 	orr.w	r2, r3, #8
 80171ee:	683b      	ldr	r3, [r7, #0]
 80171f0:	615a      	str	r2, [r3, #20]
            break;
 80171f2:	e007      	b.n	8017204 <SecDecodeFlags+0xa8>
        case SECUREC_CHAR('#'):
            attr->flags |= SECUREC_FLAG_ALTERNATE;  /* Output %x with 0x */
 80171f4:	683b      	ldr	r3, [r7, #0]
 80171f6:	695b      	ldr	r3, [r3, #20]
 80171f8:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80171fc:	683b      	ldr	r3, [r7, #0]
 80171fe:	615a      	str	r2, [r3, #20]
            break;
 8017200:	e000      	b.n	8017204 <SecDecodeFlags+0xa8>
        default:
            /* Do nothing */
            break;
 8017202:	bf00      	nop
    }
    return;
 8017204:	bf00      	nop
}
 8017206:	370c      	adds	r7, #12
 8017208:	46bd      	mov	sp, r7
 801720a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801720e:	4770      	bx	lr

08017210 <SecDecodeSizeI>:

/*
 * Decoded size identifier in format string to Reduce the number of lines of function code
 */
SECUREC_INLINE int SecDecodeSizeI(SecFormatAttr *attr, const SecChar **format)
{
 8017210:	b480      	push	{r7}
 8017212:	b083      	sub	sp, #12
 8017214:	af00      	add	r7, sp, #0
 8017216:	6078      	str	r0, [r7, #4]
 8017218:	6039      	str	r1, [r7, #0]
#ifdef SECUREC_ON_64BITS
    attr->flags |= SECUREC_FLAG_I64;    /* %I  to  INT64 */
#endif
    if ((**format == SECUREC_CHAR('6')) && (*((*format) + 1) == SECUREC_CHAR('4'))) {
 801721a:	683b      	ldr	r3, [r7, #0]
 801721c:	681b      	ldr	r3, [r3, #0]
 801721e:	781b      	ldrb	r3, [r3, #0]
 8017220:	2b36      	cmp	r3, #54	; 0x36
 8017222:	d111      	bne.n	8017248 <SecDecodeSizeI+0x38>
 8017224:	683b      	ldr	r3, [r7, #0]
 8017226:	681b      	ldr	r3, [r3, #0]
 8017228:	3301      	adds	r3, #1
 801722a:	781b      	ldrb	r3, [r3, #0]
 801722c:	2b34      	cmp	r3, #52	; 0x34
 801722e:	d10b      	bne.n	8017248 <SecDecodeSizeI+0x38>
        (*format) += 2; /* Add 2 to skip I64 */
 8017230:	683b      	ldr	r3, [r7, #0]
 8017232:	681b      	ldr	r3, [r3, #0]
 8017234:	1c9a      	adds	r2, r3, #2
 8017236:	683b      	ldr	r3, [r7, #0]
 8017238:	601a      	str	r2, [r3, #0]
        attr->flags |= SECUREC_FLAG_I64;    /* %I64  to  INT64 */
 801723a:	687b      	ldr	r3, [r7, #4]
 801723c:	695b      	ldr	r3, [r3, #20]
 801723e:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8017242:	687b      	ldr	r3, [r7, #4]
 8017244:	615a      	str	r2, [r3, #20]
 8017246:	e037      	b.n	80172b8 <SecDecodeSizeI+0xa8>
    } else if ((**format == SECUREC_CHAR('3')) && (*((*format) + 1) == SECUREC_CHAR('2'))) {
 8017248:	683b      	ldr	r3, [r7, #0]
 801724a:	681b      	ldr	r3, [r3, #0]
 801724c:	781b      	ldrb	r3, [r3, #0]
 801724e:	2b33      	cmp	r3, #51	; 0x33
 8017250:	d111      	bne.n	8017276 <SecDecodeSizeI+0x66>
 8017252:	683b      	ldr	r3, [r7, #0]
 8017254:	681b      	ldr	r3, [r3, #0]
 8017256:	3301      	adds	r3, #1
 8017258:	781b      	ldrb	r3, [r3, #0]
 801725a:	2b32      	cmp	r3, #50	; 0x32
 801725c:	d10b      	bne.n	8017276 <SecDecodeSizeI+0x66>
        (*format) += 2; /* Add 2 to skip I32 */
 801725e:	683b      	ldr	r3, [r7, #0]
 8017260:	681b      	ldr	r3, [r3, #0]
 8017262:	1c9a      	adds	r2, r3, #2
 8017264:	683b      	ldr	r3, [r7, #0]
 8017266:	601a      	str	r2, [r3, #0]
        attr->flags &= ~SECUREC_FLAG_I64;   /* %I64  to  INT32 */
 8017268:	687b      	ldr	r3, [r7, #4]
 801726a:	695b      	ldr	r3, [r3, #20]
 801726c:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 8017270:	687b      	ldr	r3, [r7, #4]
 8017272:	615a      	str	r2, [r3, #20]
 8017274:	e020      	b.n	80172b8 <SecDecodeSizeI+0xa8>
    } else if ((**format == SECUREC_CHAR('d')) || (**format == SECUREC_CHAR('i')) ||
 8017276:	683b      	ldr	r3, [r7, #0]
 8017278:	681b      	ldr	r3, [r3, #0]
 801727a:	781b      	ldrb	r3, [r3, #0]
 801727c:	2b64      	cmp	r3, #100	; 0x64
 801727e:	d01b      	beq.n	80172b8 <SecDecodeSizeI+0xa8>
 8017280:	683b      	ldr	r3, [r7, #0]
 8017282:	681b      	ldr	r3, [r3, #0]
 8017284:	781b      	ldrb	r3, [r3, #0]
 8017286:	2b69      	cmp	r3, #105	; 0x69
 8017288:	d016      	beq.n	80172b8 <SecDecodeSizeI+0xa8>
        (**format == SECUREC_CHAR('o')) || (**format == SECUREC_CHAR('u')) ||
 801728a:	683b      	ldr	r3, [r7, #0]
 801728c:	681b      	ldr	r3, [r3, #0]
 801728e:	781b      	ldrb	r3, [r3, #0]
    } else if ((**format == SECUREC_CHAR('d')) || (**format == SECUREC_CHAR('i')) ||
 8017290:	2b6f      	cmp	r3, #111	; 0x6f
 8017292:	d011      	beq.n	80172b8 <SecDecodeSizeI+0xa8>
        (**format == SECUREC_CHAR('o')) || (**format == SECUREC_CHAR('u')) ||
 8017294:	683b      	ldr	r3, [r7, #0]
 8017296:	681b      	ldr	r3, [r3, #0]
 8017298:	781b      	ldrb	r3, [r3, #0]
 801729a:	2b75      	cmp	r3, #117	; 0x75
 801729c:	d00c      	beq.n	80172b8 <SecDecodeSizeI+0xa8>
        (**format == SECUREC_CHAR('x')) || (**format == SECUREC_CHAR('X'))) {
 801729e:	683b      	ldr	r3, [r7, #0]
 80172a0:	681b      	ldr	r3, [r3, #0]
 80172a2:	781b      	ldrb	r3, [r3, #0]
        (**format == SECUREC_CHAR('o')) || (**format == SECUREC_CHAR('u')) ||
 80172a4:	2b78      	cmp	r3, #120	; 0x78
 80172a6:	d007      	beq.n	80172b8 <SecDecodeSizeI+0xa8>
        (**format == SECUREC_CHAR('x')) || (**format == SECUREC_CHAR('X'))) {
 80172a8:	683b      	ldr	r3, [r7, #0]
 80172aa:	681b      	ldr	r3, [r3, #0]
 80172ac:	781b      	ldrb	r3, [r3, #0]
 80172ae:	2b58      	cmp	r3, #88	; 0x58
 80172b0:	d002      	beq.n	80172b8 <SecDecodeSizeI+0xa8>
        /* Do nothing */
    } else {
        /* Compatibility  code for "%I" just print I */
        return -1;
 80172b2:	f04f 33ff 	mov.w	r3, #4294967295
 80172b6:	e000      	b.n	80172ba <SecDecodeSizeI+0xaa>
    }
    return 0;
 80172b8:	2300      	movs	r3, #0
}
 80172ba:	4618      	mov	r0, r3
 80172bc:	370c      	adds	r7, #12
 80172be:	46bd      	mov	sp, r7
 80172c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80172c4:	4770      	bx	lr
	...

080172c8 <SecDecodeSize>:

/*
 * Decoded size identifier in format string, and skip format to next charater
 */
SECUREC_INLINE int SecDecodeSize(SecChar ch, SecFormatAttr *attr, const SecChar **format)
{
 80172c8:	b580      	push	{r7, lr}
 80172ca:	b084      	sub	sp, #16
 80172cc:	af00      	add	r7, sp, #0
 80172ce:	4603      	mov	r3, r0
 80172d0:	60b9      	str	r1, [r7, #8]
 80172d2:	607a      	str	r2, [r7, #4]
 80172d4:	73fb      	strb	r3, [r7, #15]
    switch (ch) {
 80172d6:	7bfb      	ldrb	r3, [r7, #15]
 80172d8:	3b49      	subs	r3, #73	; 0x49
 80172da:	2b31      	cmp	r3, #49	; 0x31
 80172dc:	f200 80c5 	bhi.w	801746a <SecDecodeSize+0x1a2>
 80172e0:	a201      	add	r2, pc, #4	; (adr r2, 80172e8 <SecDecodeSize+0x20>)
 80172e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80172e6:	bf00      	nop
 80172e8:	08017419 	.word	0x08017419
 80172ec:	0801746b 	.word	0x0801746b
 80172f0:	0801746b 	.word	0x0801746b
 80172f4:	0801740b 	.word	0x0801740b
 80172f8:	0801746b 	.word	0x0801746b
 80172fc:	0801746b 	.word	0x0801746b
 8017300:	0801746b 	.word	0x0801746b
 8017304:	0801746b 	.word	0x0801746b
 8017308:	0801746b 	.word	0x0801746b
 801730c:	0801746b 	.word	0x0801746b
 8017310:	0801746b 	.word	0x0801746b
 8017314:	0801746b 	.word	0x0801746b
 8017318:	0801746b 	.word	0x0801746b
 801731c:	0801746b 	.word	0x0801746b
 8017320:	0801746b 	.word	0x0801746b
 8017324:	0801746b 	.word	0x0801746b
 8017328:	0801746b 	.word	0x0801746b
 801732c:	080173e1 	.word	0x080173e1
 8017330:	0801746b 	.word	0x0801746b
 8017334:	0801746b 	.word	0x0801746b
 8017338:	0801746b 	.word	0x0801746b
 801733c:	0801746b 	.word	0x0801746b
 8017340:	0801746b 	.word	0x0801746b
 8017344:	0801746b 	.word	0x0801746b
 8017348:	0801746b 	.word	0x0801746b
 801734c:	0801746b 	.word	0x0801746b
 8017350:	0801746b 	.word	0x0801746b
 8017354:	0801746b 	.word	0x0801746b
 8017358:	0801746b 	.word	0x0801746b
 801735c:	0801746b 	.word	0x0801746b
 8017360:	0801746b 	.word	0x0801746b
 8017364:	0801742d 	.word	0x0801742d
 8017368:	0801746b 	.word	0x0801746b
 801736c:	080173ef 	.word	0x080173ef
 8017370:	0801746b 	.word	0x0801746b
 8017374:	080173b1 	.word	0x080173b1
 8017378:	0801746b 	.word	0x0801746b
 801737c:	0801746b 	.word	0x0801746b
 8017380:	0801746b 	.word	0x0801746b
 8017384:	0801746b 	.word	0x0801746b
 8017388:	0801740b 	.word	0x0801740b
 801738c:	0801746b 	.word	0x0801746b
 8017390:	0801746b 	.word	0x0801746b
 8017394:	080173fd 	.word	0x080173fd
 8017398:	0801746b 	.word	0x0801746b
 801739c:	0801746b 	.word	0x0801746b
 80173a0:	0801745d 	.word	0x0801745d
 80173a4:	0801746b 	.word	0x0801746b
 80173a8:	0801746b 	.word	0x0801746b
 80173ac:	080173e1 	.word	0x080173e1
        case SECUREC_CHAR('l'):
            if (**format == SECUREC_CHAR('l')) {
 80173b0:	687b      	ldr	r3, [r7, #4]
 80173b2:	681b      	ldr	r3, [r3, #0]
 80173b4:	781b      	ldrb	r3, [r3, #0]
 80173b6:	2b6c      	cmp	r3, #108	; 0x6c
 80173b8:	d10b      	bne.n	80173d2 <SecDecodeSize+0x10a>
                *format = *format + 1;
 80173ba:	687b      	ldr	r3, [r7, #4]
 80173bc:	681b      	ldr	r3, [r3, #0]
 80173be:	1c5a      	adds	r2, r3, #1
 80173c0:	687b      	ldr	r3, [r7, #4]
 80173c2:	601a      	str	r2, [r3, #0]
                attr->flags |= SECUREC_FLAG_LONGLONG; /* For long long */
 80173c4:	68bb      	ldr	r3, [r7, #8]
 80173c6:	695b      	ldr	r3, [r3, #20]
 80173c8:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 80173cc:	68bb      	ldr	r3, [r7, #8]
 80173ce:	615a      	str	r2, [r3, #20]
            } else {
                attr->flags |= SECUREC_FLAG_LONG;     /* For long int or wchar_t */
            }
            break;
 80173d0:	e04e      	b.n	8017470 <SecDecodeSize+0x1a8>
                attr->flags |= SECUREC_FLAG_LONG;     /* For long int or wchar_t */
 80173d2:	68bb      	ldr	r3, [r7, #8]
 80173d4:	695b      	ldr	r3, [r3, #20]
 80173d6:	f043 0210 	orr.w	r2, r3, #16
 80173da:	68bb      	ldr	r3, [r7, #8]
 80173dc:	615a      	str	r2, [r3, #20]
            break;
 80173de:	e047      	b.n	8017470 <SecDecodeSize+0x1a8>
#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
        case SECUREC_CHAR('z'): /* fall-through */ /* FALLTHRU */
        case SECUREC_CHAR('Z'):
            attr->flags |= SECUREC_FLAG_SIZE;
 80173e0:	68bb      	ldr	r3, [r7, #8]
 80173e2:	695b      	ldr	r3, [r3, #20]
 80173e4:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 80173e8:	68bb      	ldr	r3, [r7, #8]
 80173ea:	615a      	str	r2, [r3, #20]
            break;
 80173ec:	e040      	b.n	8017470 <SecDecodeSize+0x1a8>
        case SECUREC_CHAR('j'):
            attr->flags |= SECUREC_FLAG_INTMAX;
 80173ee:	68bb      	ldr	r3, [r7, #8]
 80173f0:	695b      	ldr	r3, [r3, #20]
 80173f2:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 80173f6:	68bb      	ldr	r3, [r7, #8]
 80173f8:	615a      	str	r2, [r3, #20]
            break;
 80173fa:	e039      	b.n	8017470 <SecDecodeSize+0x1a8>
#endif
        case SECUREC_CHAR('t'):
            attr->flags |= SECUREC_FLAG_PTRDIFF;
 80173fc:	68bb      	ldr	r3, [r7, #8]
 80173fe:	695b      	ldr	r3, [r3, #20]
 8017400:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8017404:	68bb      	ldr	r3, [r7, #8]
 8017406:	615a      	str	r2, [r3, #20]
            break;
 8017408:	e032      	b.n	8017470 <SecDecodeSize+0x1a8>
        case SECUREC_CHAR('q'): /* fall-through */ /* FALLTHRU */
        case SECUREC_CHAR('L'):
            attr->flags |= (SECUREC_FLAG_LONGLONG | SECUREC_FLAG_LONG_DOUBLE);
 801740a:	68bb      	ldr	r3, [r7, #8]
 801740c:	695b      	ldr	r3, [r3, #20]
 801740e:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 8017412:	68bb      	ldr	r3, [r7, #8]
 8017414:	615a      	str	r2, [r3, #20]
            break;
 8017416:	e02b      	b.n	8017470 <SecDecodeSize+0x1a8>
        case SECUREC_CHAR('I'):
            if (SecDecodeSizeI(attr, format) != 0) {
 8017418:	6879      	ldr	r1, [r7, #4]
 801741a:	68b8      	ldr	r0, [r7, #8]
 801741c:	f7ff fef8 	bl	8017210 <SecDecodeSizeI>
 8017420:	4603      	mov	r3, r0
 8017422:	2b00      	cmp	r3, #0
 8017424:	d023      	beq.n	801746e <SecDecodeSize+0x1a6>
                /* Compatibility  code for "%I" just print I */
                return -1;
 8017426:	f04f 33ff 	mov.w	r3, #4294967295
 801742a:	e022      	b.n	8017472 <SecDecodeSize+0x1aa>
            }
            break;
        case SECUREC_CHAR('h'):
            if (**format == SECUREC_CHAR('h')) {
 801742c:	687b      	ldr	r3, [r7, #4]
 801742e:	681b      	ldr	r3, [r3, #0]
 8017430:	781b      	ldrb	r3, [r3, #0]
 8017432:	2b68      	cmp	r3, #104	; 0x68
 8017434:	d10b      	bne.n	801744e <SecDecodeSize+0x186>
                *format = *format + 1;
 8017436:	687b      	ldr	r3, [r7, #4]
 8017438:	681b      	ldr	r3, [r3, #0]
 801743a:	1c5a      	adds	r2, r3, #1
 801743c:	687b      	ldr	r3, [r7, #4]
 801743e:	601a      	str	r2, [r3, #0]
                attr->flags |= SECUREC_FLAG_CHAR;   /* For char */
 8017440:	68bb      	ldr	r3, [r7, #8]
 8017442:	695b      	ldr	r3, [r3, #20]
 8017444:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 8017448:	68bb      	ldr	r3, [r7, #8]
 801744a:	615a      	str	r2, [r3, #20]
            } else {
                attr->flags |= SECUREC_FLAG_SHORT;  /* For short int */
            }
            break;
 801744c:	e010      	b.n	8017470 <SecDecodeSize+0x1a8>
                attr->flags |= SECUREC_FLAG_SHORT;  /* For short int */
 801744e:	68bb      	ldr	r3, [r7, #8]
 8017450:	695b      	ldr	r3, [r3, #20]
 8017452:	f043 0220 	orr.w	r2, r3, #32
 8017456:	68bb      	ldr	r3, [r7, #8]
 8017458:	615a      	str	r2, [r3, #20]
            break;
 801745a:	e009      	b.n	8017470 <SecDecodeSize+0x1a8>
        case SECUREC_CHAR('w'):
            attr->flags |= SECUREC_FLAG_WIDECHAR;   /* For wide char */
 801745c:	68bb      	ldr	r3, [r7, #8]
 801745e:	695b      	ldr	r3, [r3, #20]
 8017460:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 8017464:	68bb      	ldr	r3, [r7, #8]
 8017466:	615a      	str	r2, [r3, #20]
            break;
 8017468:	e002      	b.n	8017470 <SecDecodeSize+0x1a8>
        default:
            /* Do nothing */
            break;
 801746a:	bf00      	nop
 801746c:	e000      	b.n	8017470 <SecDecodeSize+0x1a8>
            break;
 801746e:	bf00      	nop
    }
    return 0;
 8017470:	2300      	movs	r3, #0
}
 8017472:	4618      	mov	r0, r3
 8017474:	3710      	adds	r7, #16
 8017476:	46bd      	mov	sp, r7
 8017478:	bd80      	pop	{r7, pc}
 801747a:	bf00      	nop

0801747c <SecDecodeTypeC>:

/*
 * Decoded char type identifier
 */
SECUREC_INLINE void SecDecodeTypeC(SecFormatAttr *attr, unsigned int c)
{
 801747c:	b480      	push	{r7}
 801747e:	b083      	sub	sp, #12
 8017480:	af00      	add	r7, sp, #0
 8017482:	6078      	str	r0, [r7, #4]
 8017484:	6039      	str	r1, [r7, #0]
    attr->textLen = 1; /* Only 1 wide character */
 8017486:	687b      	ldr	r3, [r7, #4]
 8017488:	2201      	movs	r2, #1
 801748a:	609a      	str	r2, [r3, #8]

#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT)) && !(defined(__hpux)) && !(defined(SECUREC_ON_SOLARIS))
    attr->flags &= ~SECUREC_FLAG_LEADZERO;
 801748c:	687b      	ldr	r3, [r7, #4]
 801748e:	695b      	ldr	r3, [r3, #20]
 8017490:	f023 0208 	bic.w	r2, r3, #8
 8017494:	687b      	ldr	r3, [r7, #4]
 8017496:	615a      	str	r2, [r3, #20]
        attr->buffer.wStr[0] = (wchar_t)c;
        attr->text.wStr = attr->buffer.wStr;
        attr->textIsWide = 1;
    }
#else /* Not SECUREC_FOR_WCHAR */
    if ((attr->flags & (SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) != 0) {
 8017498:	687b      	ldr	r3, [r7, #4]
 801749a:	695b      	ldr	r3, [r3, #20]
 801749c:	f403 6301 	and.w	r3, r3, #2064	; 0x810
 80174a0:	2b00      	cmp	r3, #0
 80174a2:	d00b      	beq.n	80174bc <SecDecodeTypeC+0x40>
#if SECUREC_HAVE_WCHART
        attr->buffer.wStr[0] = (wchar_t)c;
 80174a4:	687b      	ldr	r3, [r7, #4]
 80174a6:	683a      	ldr	r2, [r7, #0]
 80174a8:	635a      	str	r2, [r3, #52]	; 0x34
        attr->text.wStr = attr->buffer.wStr;
 80174aa:	687b      	ldr	r3, [r7, #4]
 80174ac:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80174b0:	687b      	ldr	r3, [r7, #4]
 80174b2:	605a      	str	r2, [r3, #4]
        attr->textIsWide = 1;
 80174b4:	687b      	ldr	r3, [r7, #4]
 80174b6:	2201      	movs	r2, #1
 80174b8:	60da      	str	r2, [r3, #12]
        attr->buffer.str[0] = (char)c;
        attr->text.str = attr->buffer.str;
        attr->textIsWide = 0;
    }
#endif
}
 80174ba:	e00c      	b.n	80174d6 <SecDecodeTypeC+0x5a>
        attr->buffer.str[0] = (char)c;
 80174bc:	683b      	ldr	r3, [r7, #0]
 80174be:	b2da      	uxtb	r2, r3
 80174c0:	687b      	ldr	r3, [r7, #4]
 80174c2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        attr->text.str = attr->buffer.str;
 80174c6:	687b      	ldr	r3, [r7, #4]
 80174c8:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80174cc:	687b      	ldr	r3, [r7, #4]
 80174ce:	605a      	str	r2, [r3, #4]
        attr->textIsWide = 0;
 80174d0:	687b      	ldr	r3, [r7, #4]
 80174d2:	2200      	movs	r2, #0
 80174d4:	60da      	str	r2, [r3, #12]
}
 80174d6:	bf00      	nop
 80174d8:	370c      	adds	r7, #12
 80174da:	46bd      	mov	sp, r7
 80174dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80174e0:	4770      	bx	lr
	...

080174e4 <SecDecodeTypeSchar>:
#else
#define SECUREC_IS_NARROW_STRING(attr) (((attr)->flags & (SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) == 0)
#endif

SECUREC_INLINE void SecDecodeTypeSchar(SecFormatAttr *attr)
{
 80174e4:	b580      	push	{r7, lr}
 80174e6:	b086      	sub	sp, #24
 80174e8:	af00      	add	r7, sp, #0
 80174ea:	6078      	str	r0, [r7, #4]
 80174ec:	4b22      	ldr	r3, [pc, #136]	; (8017578 <SecDecodeTypeSchar+0x94>)
 80174ee:	681b      	ldr	r3, [r3, #0]
 80174f0:	617b      	str	r3, [r7, #20]
 80174f2:	f04f 0300 	mov.w	r3, #0
    size_t textLen;
    if (attr->text.str == NULL) {
 80174f6:	687b      	ldr	r3, [r7, #4]
 80174f8:	685b      	ldr	r3, [r3, #4]
 80174fa:	2b00      	cmp	r3, #0
 80174fc:	d102      	bne.n	8017504 <SecDecodeTypeSchar+0x20>
        /*
         * Literal string to print null ptr, define it as array rather than const text area
         * To avoid gcc warning with pointing const text with variable
         */
        static char strNullString[SECUREC_NULL_STRING_SIZE] = "(null)";
        attr->text.str = strNullString;
 80174fe:	687b      	ldr	r3, [r7, #4]
 8017500:	4a1e      	ldr	r2, [pc, #120]	; (801757c <SecDecodeTypeSchar+0x98>)
 8017502:	605a      	str	r2, [r3, #4]
    }
    if (attr->precision == -1) {
 8017504:	687b      	ldr	r3, [r7, #4]
 8017506:	69db      	ldr	r3, [r3, #28]
 8017508:	f1b3 3fff 	cmp.w	r3, #4294967295
 801750c:	d10c      	bne.n	8017528 <SecDecodeTypeSchar+0x44>
        /* Precision NOT assigned */
        /* The strlen performance is high when the string length is greater than 32 */
        textLen = strlen(attr->text.str);
 801750e:	687b      	ldr	r3, [r7, #4]
 8017510:	685b      	ldr	r3, [r3, #4]
 8017512:	4618      	mov	r0, r3
 8017514:	f7f7 fab9 	bl	800ea8a <strlen>
 8017518:	4603      	mov	r3, r0
 801751a:	60bb      	str	r3, [r7, #8]
        if (textLen > SECUREC_STRING_MAX_LEN) {
 801751c:	68bb      	ldr	r3, [r7, #8]
 801751e:	2b00      	cmp	r3, #0
 8017520:	da1b      	bge.n	801755a <SecDecodeTypeSchar+0x76>
            textLen = 0;
 8017522:	2300      	movs	r3, #0
 8017524:	60bb      	str	r3, [r7, #8]
 8017526:	e018      	b.n	801755a <SecDecodeTypeSchar+0x76>
        }
    } else {
        /* Precision assigned */
        SECUREC_CALC_STR_LEN(attr->text.str, (size_t)(unsigned int)attr->precision, &textLen);
 8017528:	687b      	ldr	r3, [r7, #4]
 801752a:	685b      	ldr	r3, [r3, #4]
 801752c:	60fb      	str	r3, [r7, #12]
 801752e:	687b      	ldr	r3, [r7, #4]
 8017530:	69db      	ldr	r3, [r3, #28]
 8017532:	613b      	str	r3, [r7, #16]
 8017534:	e005      	b.n	8017542 <SecDecodeTypeSchar+0x5e>
 8017536:	693b      	ldr	r3, [r7, #16]
 8017538:	3b01      	subs	r3, #1
 801753a:	613b      	str	r3, [r7, #16]
 801753c:	68fb      	ldr	r3, [r7, #12]
 801753e:	3301      	adds	r3, #1
 8017540:	60fb      	str	r3, [r7, #12]
 8017542:	693b      	ldr	r3, [r7, #16]
 8017544:	2b00      	cmp	r3, #0
 8017546:	d003      	beq.n	8017550 <SecDecodeTypeSchar+0x6c>
 8017548:	68fb      	ldr	r3, [r7, #12]
 801754a:	781b      	ldrb	r3, [r3, #0]
 801754c:	2b00      	cmp	r3, #0
 801754e:	d1f2      	bne.n	8017536 <SecDecodeTypeSchar+0x52>
 8017550:	687b      	ldr	r3, [r7, #4]
 8017552:	685b      	ldr	r3, [r3, #4]
 8017554:	68fa      	ldr	r2, [r7, #12]
 8017556:	1ad3      	subs	r3, r2, r3
 8017558:	60bb      	str	r3, [r7, #8]
    }
    attr->textLen = (int)textLen;
 801755a:	68bb      	ldr	r3, [r7, #8]
 801755c:	461a      	mov	r2, r3
 801755e:	687b      	ldr	r3, [r7, #4]
 8017560:	609a      	str	r2, [r3, #8]
}
 8017562:	bf00      	nop
 8017564:	4b04      	ldr	r3, [pc, #16]	; (8017578 <SecDecodeTypeSchar+0x94>)
 8017566:	681a      	ldr	r2, [r3, #0]
 8017568:	697b      	ldr	r3, [r7, #20]
 801756a:	405a      	eors	r2, r3
 801756c:	d001      	beq.n	8017572 <SecDecodeTypeSchar+0x8e>
 801756e:	f7ec ff3b 	bl	80043e8 <__stack_chk_fail>
 8017572:	3718      	adds	r7, #24
 8017574:	46bd      	mov	sp, r7
 8017576:	bd80      	pop	{r7, pc}
 8017578:	08023044 	.word	0x08023044
 801757c:	20000538 	.word	0x20000538

08017580 <SecDecodeTypeSwchar>:

SECUREC_INLINE void SecDecodeTypeSwchar(SecFormatAttr *attr)
{
 8017580:	b580      	push	{r7, lr}
 8017582:	b086      	sub	sp, #24
 8017584:	af00      	add	r7, sp, #0
 8017586:	6078      	str	r0, [r7, #4]
 8017588:	4b1d      	ldr	r3, [pc, #116]	; (8017600 <SecDecodeTypeSwchar+0x80>)
 801758a:	681b      	ldr	r3, [r3, #0]
 801758c:	617b      	str	r3, [r7, #20]
 801758e:	f04f 0300 	mov.w	r3, #0
#if SECUREC_HAVE_WCHART
    size_t textLen;
    attr->textIsWide = 1;
 8017592:	687b      	ldr	r3, [r7, #4]
 8017594:	2201      	movs	r2, #1
 8017596:	60da      	str	r2, [r3, #12]
    if (attr->text.wStr == NULL) {
 8017598:	687b      	ldr	r3, [r7, #4]
 801759a:	685b      	ldr	r3, [r3, #4]
 801759c:	2b00      	cmp	r3, #0
 801759e:	d102      	bne.n	80175a6 <SecDecodeTypeSwchar+0x26>
        /*
         * Literal string to print null ptr, define it as array rather than const text area
         * To avoid gcc warning with pointing const text with variable
         */
        static wchar_t wStrNullString[SECUREC_NULL_STRING_SIZE] = { L'(', L'n', L'u', L'l', L'l', L')', L'\0', L'\0' };
        attr->text.wStr = wStrNullString;
 80175a0:	687b      	ldr	r3, [r7, #4]
 80175a2:	4a18      	ldr	r2, [pc, #96]	; (8017604 <SecDecodeTypeSwchar+0x84>)
 80175a4:	605a      	str	r2, [r3, #4]
    }
    /* The textLen in wchar_t,when precision is -1, it is unlimited  */
    SECUREC_CALC_WSTR_LEN(attr->text.wStr, (size_t)(unsigned int)attr->precision, &textLen);
 80175a6:	687b      	ldr	r3, [r7, #4]
 80175a8:	685b      	ldr	r3, [r3, #4]
 80175aa:	60fb      	str	r3, [r7, #12]
 80175ac:	2300      	movs	r3, #0
 80175ae:	613b      	str	r3, [r7, #16]
 80175b0:	e005      	b.n	80175be <SecDecodeTypeSwchar+0x3e>
 80175b2:	693b      	ldr	r3, [r7, #16]
 80175b4:	3301      	adds	r3, #1
 80175b6:	613b      	str	r3, [r7, #16]
 80175b8:	68fb      	ldr	r3, [r7, #12]
 80175ba:	3304      	adds	r3, #4
 80175bc:	60fb      	str	r3, [r7, #12]
 80175be:	687b      	ldr	r3, [r7, #4]
 80175c0:	69db      	ldr	r3, [r3, #28]
 80175c2:	461a      	mov	r2, r3
 80175c4:	693b      	ldr	r3, [r7, #16]
 80175c6:	4293      	cmp	r3, r2
 80175c8:	d203      	bcs.n	80175d2 <SecDecodeTypeSwchar+0x52>
 80175ca:	68fb      	ldr	r3, [r7, #12]
 80175cc:	681b      	ldr	r3, [r3, #0]
 80175ce:	2b00      	cmp	r3, #0
 80175d0:	d1ef      	bne.n	80175b2 <SecDecodeTypeSwchar+0x32>
 80175d2:	693b      	ldr	r3, [r7, #16]
 80175d4:	60bb      	str	r3, [r7, #8]
    if (textLen > SECUREC_WCHAR_STRING_MAX_LEN) {
 80175d6:	68bb      	ldr	r3, [r7, #8]
 80175d8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80175dc:	d301      	bcc.n	80175e2 <SecDecodeTypeSwchar+0x62>
        textLen = 0;
 80175de:	2300      	movs	r3, #0
 80175e0:	60bb      	str	r3, [r7, #8]
    }
    attr->textLen = (int)textLen;
 80175e2:	68bb      	ldr	r3, [r7, #8]
 80175e4:	461a      	mov	r2, r3
 80175e6:	687b      	ldr	r3, [r7, #4]
 80175e8:	609a      	str	r2, [r3, #8]
#else
    attr->textLen = 0;
#endif
}
 80175ea:	bf00      	nop
 80175ec:	4b04      	ldr	r3, [pc, #16]	; (8017600 <SecDecodeTypeSwchar+0x80>)
 80175ee:	681a      	ldr	r2, [r3, #0]
 80175f0:	697b      	ldr	r3, [r7, #20]
 80175f2:	405a      	eors	r2, r3
 80175f4:	d001      	beq.n	80175fa <SecDecodeTypeSwchar+0x7a>
 80175f6:	f7ec fef7 	bl	80043e8 <__stack_chk_fail>
 80175fa:	3718      	adds	r7, #24
 80175fc:	46bd      	mov	sp, r7
 80175fe:	bd80      	pop	{r7, pc}
 8017600:	08023048 	.word	0x08023048
 8017604:	20000540 	.word	0x20000540

08017608 <SecDecodeTypeS>:

/*
 * Decoded string identifier
 */
SECUREC_INLINE void SecDecodeTypeS(SecFormatAttr *attr, char *argPtr)
{
 8017608:	b580      	push	{r7, lr}
 801760a:	b082      	sub	sp, #8
 801760c:	af00      	add	r7, sp, #0
 801760e:	6078      	str	r0, [r7, #4]
 8017610:	6039      	str	r1, [r7, #0]
#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT))
#if (!defined(SECUREC_ON_UNIX))
    attr->flags &= ~SECUREC_FLAG_LEADZERO;
 8017612:	687b      	ldr	r3, [r7, #4]
 8017614:	695b      	ldr	r3, [r3, #20]
 8017616:	f023 0208 	bic.w	r2, r3, #8
 801761a:	687b      	ldr	r3, [r7, #4]
 801761c:	615a      	str	r2, [r3, #20]
    if ((attr->flags & SECUREC_FLAG_LONG) == 0) {
        attr->flags |= SECUREC_FLAG_SHORT;
    }
#endif
#endif
    attr->text.str = argPtr;
 801761e:	687b      	ldr	r3, [r7, #4]
 8017620:	683a      	ldr	r2, [r7, #0]
 8017622:	605a      	str	r2, [r3, #4]
    if (SECUREC_IS_NARROW_STRING(attr)) {
 8017624:	687b      	ldr	r3, [r7, #4]
 8017626:	695b      	ldr	r3, [r3, #20]
 8017628:	f403 6301 	and.w	r3, r3, #2064	; 0x810
 801762c:	2b00      	cmp	r3, #0
 801762e:	d103      	bne.n	8017638 <SecDecodeTypeS+0x30>
        /* The textLen now contains length in multibyte chars */
        SecDecodeTypeSchar(attr);
 8017630:	6878      	ldr	r0, [r7, #4]
 8017632:	f7ff ff57 	bl	80174e4 <SecDecodeTypeSchar>
    } else {
        /* The textLen now contains length in wide chars */
        SecDecodeTypeSwchar(attr);
    }
}
 8017636:	e002      	b.n	801763e <SecDecodeTypeS+0x36>
        SecDecodeTypeSwchar(attr);
 8017638:	6878      	ldr	r0, [r7, #4]
 801763a:	f7ff ffa1 	bl	8017580 <SecDecodeTypeSwchar>
}
 801763e:	bf00      	nop
 8017640:	3708      	adds	r7, #8
 8017642:	46bd      	mov	sp, r7
 8017644:	bd80      	pop	{r7, pc}
	...

08017648 <SecDecodePrecision>:

/*
 * Check precision in format
 */
SECUREC_INLINE int SecDecodePrecision(SecChar ch, SecFormatAttr *attr)
{
 8017648:	b480      	push	{r7}
 801764a:	b083      	sub	sp, #12
 801764c:	af00      	add	r7, sp, #0
 801764e:	4603      	mov	r3, r0
 8017650:	6039      	str	r1, [r7, #0]
 8017652:	71fb      	strb	r3, [r7, #7]
    if (attr->dynPrecision == 0) {
 8017654:	683b      	ldr	r3, [r7, #0]
 8017656:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017658:	2b00      	cmp	r3, #0
 801765a:	d116      	bne.n	801768a <SecDecodePrecision+0x42>
        /* Add digit to current precision */
        if (SECUREC_MUL_TEN_ADD_BEYOND_MAX(attr->precision)) {
 801765c:	683b      	ldr	r3, [r7, #0]
 801765e:	69db      	ldr	r3, [r3, #28]
 8017660:	4a15      	ldr	r2, [pc, #84]	; (80176b8 <SecDecodePrecision+0x70>)
 8017662:	4293      	cmp	r3, r2
 8017664:	dd02      	ble.n	801766c <SecDecodePrecision+0x24>
            return -1;
 8017666:	f04f 33ff 	mov.w	r3, #4294967295
 801766a:	e01f      	b.n	80176ac <SecDecodePrecision+0x64>
        }
        attr->precision = (int)SECUREC_MUL_TEN((unsigned int)attr->precision) +
 801766c:	683b      	ldr	r3, [r7, #0]
 801766e:	69db      	ldr	r3, [r3, #28]
 8017670:	009b      	lsls	r3, r3, #2
 8017672:	683a      	ldr	r2, [r7, #0]
 8017674:	69d2      	ldr	r2, [r2, #28]
 8017676:	4413      	add	r3, r2
 8017678:	005b      	lsls	r3, r3, #1
 801767a:	461a      	mov	r2, r3
            (unsigned char)(ch - SECUREC_CHAR('0'));
 801767c:	79fb      	ldrb	r3, [r7, #7]
 801767e:	3b30      	subs	r3, #48	; 0x30
 8017680:	b2db      	uxtb	r3, r3
        attr->precision = (int)SECUREC_MUL_TEN((unsigned int)attr->precision) +
 8017682:	441a      	add	r2, r3
 8017684:	683b      	ldr	r3, [r7, #0]
 8017686:	61da      	str	r2, [r3, #28]
 8017688:	e00f      	b.n	80176aa <SecDecodePrecision+0x62>
    } else {
        if (attr->precision < 0) {
 801768a:	683b      	ldr	r3, [r7, #0]
 801768c:	69db      	ldr	r3, [r3, #28]
 801768e:	2b00      	cmp	r3, #0
 8017690:	da03      	bge.n	801769a <SecDecodePrecision+0x52>
            attr->precision = -1;
 8017692:	683b      	ldr	r3, [r7, #0]
 8017694:	f04f 32ff 	mov.w	r2, #4294967295
 8017698:	61da      	str	r2, [r3, #28]
        }
        if (attr->precision > SECUREC_MAX_WIDTH_LEN) {
 801769a:	683b      	ldr	r3, [r7, #0]
 801769c:	69db      	ldr	r3, [r3, #28]
 801769e:	4a07      	ldr	r2, [pc, #28]	; (80176bc <SecDecodePrecision+0x74>)
 80176a0:	4293      	cmp	r3, r2
 80176a2:	dd02      	ble.n	80176aa <SecDecodePrecision+0x62>
            return -1;
 80176a4:	f04f 33ff 	mov.w	r3, #4294967295
 80176a8:	e000      	b.n	80176ac <SecDecodePrecision+0x64>
        }
    }
    return 0;
 80176aa:	2300      	movs	r3, #0
}
 80176ac:	4618      	mov	r0, r3
 80176ae:	370c      	adds	r7, #12
 80176b0:	46bd      	mov	sp, r7
 80176b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80176b6:	4770      	bx	lr
 80176b8:	0147ae14 	.word	0x0147ae14
 80176bc:	0cccccc8 	.word	0x0cccccc8

080176c0 <SecDecodeWidth>:

/*
 * Check width in format
 */
SECUREC_INLINE int SecDecodeWidth(SecChar ch, SecFormatAttr *attr, SecFmtState lastState)
{
 80176c0:	b480      	push	{r7}
 80176c2:	b085      	sub	sp, #20
 80176c4:	af00      	add	r7, sp, #0
 80176c6:	4603      	mov	r3, r0
 80176c8:	60b9      	str	r1, [r7, #8]
 80176ca:	607a      	str	r2, [r7, #4]
 80176cc:	73fb      	strb	r3, [r7, #15]
    if (attr->dynWidth == 0) {
 80176ce:	68bb      	ldr	r3, [r7, #8]
 80176d0:	6a1b      	ldr	r3, [r3, #32]
 80176d2:	2b00      	cmp	r3, #0
 80176d4:	d11c      	bne.n	8017710 <SecDecodeWidth+0x50>
        if (lastState != STAT_WIDTH) {
 80176d6:	687b      	ldr	r3, [r7, #4]
 80176d8:	2b03      	cmp	r3, #3
 80176da:	d002      	beq.n	80176e2 <SecDecodeWidth+0x22>
            attr->fldWidth = 0;
 80176dc:	68bb      	ldr	r3, [r7, #8]
 80176de:	2200      	movs	r2, #0
 80176e0:	619a      	str	r2, [r3, #24]
        }
        if (SECUREC_MUL_TEN_ADD_BEYOND_MAX(attr->fldWidth)) {
 80176e2:	68bb      	ldr	r3, [r7, #8]
 80176e4:	699b      	ldr	r3, [r3, #24]
 80176e6:	4a19      	ldr	r2, [pc, #100]	; (801774c <SecDecodeWidth+0x8c>)
 80176e8:	4293      	cmp	r3, r2
 80176ea:	dd02      	ble.n	80176f2 <SecDecodeWidth+0x32>
            return -1;
 80176ec:	f04f 33ff 	mov.w	r3, #4294967295
 80176f0:	e026      	b.n	8017740 <SecDecodeWidth+0x80>
        }
        attr->fldWidth = (int)SECUREC_MUL_TEN((unsigned int)attr->fldWidth) +
 80176f2:	68bb      	ldr	r3, [r7, #8]
 80176f4:	699b      	ldr	r3, [r3, #24]
 80176f6:	009b      	lsls	r3, r3, #2
 80176f8:	68ba      	ldr	r2, [r7, #8]
 80176fa:	6992      	ldr	r2, [r2, #24]
 80176fc:	4413      	add	r3, r2
 80176fe:	005b      	lsls	r3, r3, #1
 8017700:	461a      	mov	r2, r3
            (unsigned char)(ch - SECUREC_CHAR('0'));
 8017702:	7bfb      	ldrb	r3, [r7, #15]
 8017704:	3b30      	subs	r3, #48	; 0x30
 8017706:	b2db      	uxtb	r3, r3
        attr->fldWidth = (int)SECUREC_MUL_TEN((unsigned int)attr->fldWidth) +
 8017708:	441a      	add	r2, r3
 801770a:	68bb      	ldr	r3, [r7, #8]
 801770c:	619a      	str	r2, [r3, #24]
 801770e:	e016      	b.n	801773e <SecDecodeWidth+0x7e>
    } else {
        if (attr->fldWidth < 0) {
 8017710:	68bb      	ldr	r3, [r7, #8]
 8017712:	699b      	ldr	r3, [r3, #24]
 8017714:	2b00      	cmp	r3, #0
 8017716:	da0a      	bge.n	801772e <SecDecodeWidth+0x6e>
            attr->flags |= SECUREC_FLAG_LEFT;
 8017718:	68bb      	ldr	r3, [r7, #8]
 801771a:	695b      	ldr	r3, [r3, #20]
 801771c:	f043 0204 	orr.w	r2, r3, #4
 8017720:	68bb      	ldr	r3, [r7, #8]
 8017722:	615a      	str	r2, [r3, #20]
            attr->fldWidth = (-attr->fldWidth);
 8017724:	68bb      	ldr	r3, [r7, #8]
 8017726:	699b      	ldr	r3, [r3, #24]
 8017728:	425a      	negs	r2, r3
 801772a:	68bb      	ldr	r3, [r7, #8]
 801772c:	619a      	str	r2, [r3, #24]
        }
        if (attr->fldWidth > SECUREC_MAX_WIDTH_LEN) {
 801772e:	68bb      	ldr	r3, [r7, #8]
 8017730:	699b      	ldr	r3, [r3, #24]
 8017732:	4a07      	ldr	r2, [pc, #28]	; (8017750 <SecDecodeWidth+0x90>)
 8017734:	4293      	cmp	r3, r2
 8017736:	dd02      	ble.n	801773e <SecDecodeWidth+0x7e>
            return -1;
 8017738:	f04f 33ff 	mov.w	r3, #4294967295
 801773c:	e000      	b.n	8017740 <SecDecodeWidth+0x80>
        }
    }
    return 0;
 801773e:	2300      	movs	r3, #0
}
 8017740:	4618      	mov	r0, r3
 8017742:	3714      	adds	r7, #20
 8017744:	46bd      	mov	sp, r7
 8017746:	f85d 7b04 	ldr.w	r7, [sp], #4
 801774a:	4770      	bx	lr
 801774c:	0147ae14 	.word	0x0147ae14
 8017750:	0cccccc8 	.word	0x0cccccc8

08017754 <SecUpdateWcharFlags>:
/*
 * The sprintf_s function processes the wide character as a parameter for %C
 * The swprintf_s function processes the multiple character as a parameter for %C
 */
SECUREC_INLINE void SecUpdateWcharFlags(SecFormatAttr *attr)
{
 8017754:	b480      	push	{r7}
 8017756:	b083      	sub	sp, #12
 8017758:	af00      	add	r7, sp, #0
 801775a:	6078      	str	r0, [r7, #4]
    if ((attr->flags & (SECUREC_FLAG_SHORT | SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) == 0) {
 801775c:	687b      	ldr	r3, [r7, #4]
 801775e:	695b      	ldr	r3, [r3, #20]
 8017760:	f403 6303 	and.w	r3, r3, #2096	; 0x830
 8017764:	2b00      	cmp	r3, #0
 8017766:	d105      	bne.n	8017774 <SecUpdateWcharFlags+0x20>
#ifdef SECUREC_FOR_WCHAR
        attr->flags |= SECUREC_FLAG_SHORT;
#else
        attr->flags |= SECUREC_FLAG_WIDECHAR;
 8017768:	687b      	ldr	r3, [r7, #4]
 801776a:	695b      	ldr	r3, [r3, #20]
 801776c:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 8017770:	687b      	ldr	r3, [r7, #4]
 8017772:	615a      	str	r2, [r3, #20]
#endif
    }
}
 8017774:	bf00      	nop
 8017776:	370c      	adds	r7, #12
 8017778:	46bd      	mov	sp, r7
 801777a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801777e:	4770      	bx	lr

08017780 <SecUpdateWstringFlags>:
/*
 * When encountering %S, current just same as %C
 */
SECUREC_INLINE void SecUpdateWstringFlags(SecFormatAttr *attr)
{
 8017780:	b580      	push	{r7, lr}
 8017782:	b082      	sub	sp, #8
 8017784:	af00      	add	r7, sp, #0
 8017786:	6078      	str	r0, [r7, #4]
    SecUpdateWcharFlags(attr);
 8017788:	6878      	ldr	r0, [r7, #4]
 801778a:	f7ff ffe3 	bl	8017754 <SecUpdateWcharFlags>
}
 801778e:	bf00      	nop
 8017790:	3708      	adds	r7, #8
 8017792:	46bd      	mov	sp, r7
 8017794:	bd80      	pop	{r7, pc}
	...

08017798 <SecUpdatePointFlags>:
    attr->flags |= SECUREC_FLAG_LONG;  /* Converting a long */
}
#endif

SECUREC_INLINE void SecUpdatePointFlags(SecFormatAttr *attr)
{
 8017798:	b480      	push	{r7}
 801779a:	b083      	sub	sp, #12
 801779c:	af00      	add	r7, sp, #0
 801779e:	6078      	str	r0, [r7, #4]
    attr->flags |= SECUREC_FLAG_POINTER;
 80177a0:	687b      	ldr	r3, [r7, #4]
 80177a2:	695b      	ldr	r3, [r3, #20]
 80177a4:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
 80177a8:	687b      	ldr	r3, [r7, #4]
 80177aa:	615a      	str	r2, [r3, #20]
#else
#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) || defined(SECUREC_VXWORKS_PLATFORM)) && (!defined(SECUREC_ON_UNIX))
#if defined(SECUREC_VXWORKS_PLATFORM)
    attr->precision = 1;
#else
    attr->precision = 0;
 80177ac:	687b      	ldr	r3, [r7, #4]
 80177ae:	2200      	movs	r2, #0
 80177b0:	61da      	str	r2, [r3, #28]
#endif
    attr->flags |= SECUREC_FLAG_ALTERNATE; /* "0x" is not default prefix in UNIX */
 80177b2:	687b      	ldr	r3, [r7, #4]
 80177b4:	695b      	ldr	r3, [r3, #20]
 80177b6:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80177ba:	687b      	ldr	r3, [r7, #4]
 80177bc:	615a      	str	r2, [r3, #20]
    attr->digits = g_itoaLowerDigits;
 80177be:	687b      	ldr	r3, [r7, #4]
 80177c0:	4a0f      	ldr	r2, [pc, #60]	; (8017800 <SecUpdatePointFlags+0x68>)
 80177c2:	601a      	str	r2, [r3, #0]
#endif

#ifdef SECUREC_ON_64BITS
    attr->flags |= SECUREC_FLAG_I64;   /* Converting an int64 */
#else
    attr->flags |= SECUREC_FLAG_LONG;  /* Converting a long */
 80177c4:	687b      	ldr	r3, [r7, #4]
 80177c6:	695b      	ldr	r3, [r3, #20]
 80177c8:	f043 0210 	orr.w	r2, r3, #16
 80177cc:	687b      	ldr	r3, [r7, #4]
 80177ce:	615a      	str	r2, [r3, #20]
#endif
    /* Set up for %#p on different system */
    if ((attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
 80177d0:	687b      	ldr	r3, [r7, #4]
 80177d2:	695b      	ldr	r3, [r3, #20]
 80177d4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80177d8:	2b00      	cmp	r3, #0
 80177da:	d00a      	beq.n	80177f2 <SecUpdatePointFlags+0x5a>
        /* Alternate form means '0x' prefix */
        attr->prefix[0] = SECUREC_CHAR('0');
 80177dc:	687b      	ldr	r3, [r7, #4]
 80177de:	2230      	movs	r2, #48	; 0x30
 80177e0:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) || defined(SECUREC_VXWORKS_PLATFORM))
        attr->prefix[1] = SECUREC_CHAR('x');
 80177e4:	687b      	ldr	r3, [r7, #4]
 80177e6:	2278      	movs	r2, #120	; 0x78
 80177e8:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
        attr->prefix[1] = (SecChar)(attr->digits[SECUREC_NUMBER_OF_X]);
#endif
#if defined(_AIX) || defined(SECUREC_ON_SOLARIS)
        attr->prefixLen = 0;
#else
        attr->prefixLen = SECUREC_PREFIX_LEN;
 80177ec:	687b      	ldr	r3, [r7, #4]
 80177ee:	2202      	movs	r2, #2
 80177f0:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
    }
#endif
}
 80177f2:	bf00      	nop
 80177f4:	370c      	adds	r7, #12
 80177f6:	46bd      	mov	sp, r7
 80177f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80177fc:	4770      	bx	lr
 80177fe:	bf00      	nop
 8017800:	080236c8 	.word	0x080236c8

08017804 <SecUpdateXpxFlags>:

SECUREC_INLINE void SecUpdateXpxFlags(SecFormatAttr *attr, SecChar ch)
{
 8017804:	b580      	push	{r7, lr}
 8017806:	b082      	sub	sp, #8
 8017808:	af00      	add	r7, sp, #0
 801780a:	6078      	str	r0, [r7, #4]
 801780c:	460b      	mov	r3, r1
 801780e:	70fb      	strb	r3, [r7, #3]
    /* Use unsigned lower hex output for 'x' */
    attr->digits = g_itoaLowerDigits;
 8017810:	687b      	ldr	r3, [r7, #4]
 8017812:	4a15      	ldr	r2, [pc, #84]	; (8017868 <SecUpdateXpxFlags+0x64>)
 8017814:	601a      	str	r2, [r3, #0]
    attr->radix = SECUREC_RADIX_HEX;
 8017816:	687b      	ldr	r3, [r7, #4]
 8017818:	2210      	movs	r2, #16
 801781a:	611a      	str	r2, [r3, #16]
    switch (ch) {
 801781c:	78fb      	ldrb	r3, [r7, #3]
 801781e:	2b58      	cmp	r3, #88	; 0x58
 8017820:	d005      	beq.n	801782e <SecUpdateXpxFlags+0x2a>
 8017822:	2b70      	cmp	r3, #112	; 0x70
 8017824:	d106      	bne.n	8017834 <SecUpdateXpxFlags+0x30>
        case SECUREC_CHAR('p'):
            /* Print a pointer */
            SecUpdatePointFlags(attr);
 8017826:	6878      	ldr	r0, [r7, #4]
 8017828:	f7ff ffb6 	bl	8017798 <SecUpdatePointFlags>
            break;
 801782c:	e017      	b.n	801785e <SecUpdateXpxFlags+0x5a>
        case SECUREC_CHAR('X'): /* fall-through */ /* FALLTHRU */
            /* Unsigned upper hex output */
            attr->digits = g_itoaUpperDigits;
 801782e:	687b      	ldr	r3, [r7, #4]
 8017830:	4a0e      	ldr	r2, [pc, #56]	; (801786c <SecUpdateXpxFlags+0x68>)
 8017832:	601a      	str	r2, [r3, #0]
            /* fall-through */ /* FALLTHRU */
        default:
            /* For %#x or %#X */
            if ((attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
 8017834:	687b      	ldr	r3, [r7, #4]
 8017836:	695b      	ldr	r3, [r3, #20]
 8017838:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801783c:	2b00      	cmp	r3, #0
 801783e:	d00d      	beq.n	801785c <SecUpdateXpxFlags+0x58>
                /* Alternate form means '0x' prefix */
                attr->prefix[0] = SECUREC_CHAR('0');
 8017840:	687b      	ldr	r3, [r7, #4]
 8017842:	2230      	movs	r2, #48	; 0x30
 8017844:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                attr->prefix[1] = (SecChar)(attr->digits[SECUREC_NUMBER_OF_X]);
 8017848:	687b      	ldr	r3, [r7, #4]
 801784a:	681b      	ldr	r3, [r3, #0]
 801784c:	3310      	adds	r3, #16
 801784e:	781a      	ldrb	r2, [r3, #0]
 8017850:	687b      	ldr	r3, [r7, #4]
 8017852:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
                attr->prefixLen = SECUREC_PREFIX_LEN;
 8017856:	687b      	ldr	r3, [r7, #4]
 8017858:	2202      	movs	r2, #2
 801785a:	62da      	str	r2, [r3, #44]	; 0x2c
            }
            break;
 801785c:	bf00      	nop
    }
}
 801785e:	bf00      	nop
 8017860:	3708      	adds	r7, #8
 8017862:	46bd      	mov	sp, r7
 8017864:	bd80      	pop	{r7, pc}
 8017866:	bf00      	nop
 8017868:	080236c8 	.word	0x080236c8
 801786c:	080236b4 	.word	0x080236b4

08017870 <SecUpdateOudiFlags>:

SECUREC_INLINE void SecUpdateOudiFlags(SecFormatAttr *attr, SecChar ch)
{
 8017870:	b480      	push	{r7}
 8017872:	b083      	sub	sp, #12
 8017874:	af00      	add	r7, sp, #0
 8017876:	6078      	str	r0, [r7, #4]
 8017878:	460b      	mov	r3, r1
 801787a:	70fb      	strb	r3, [r7, #3]
    /* Do not set digits here */
    switch (ch) {
 801787c:	78fb      	ldrb	r3, [r7, #3]
 801787e:	3b64      	subs	r3, #100	; 0x64
 8017880:	2b11      	cmp	r3, #17
 8017882:	d847      	bhi.n	8017914 <SecUpdateOudiFlags+0xa4>
 8017884:	a201      	add	r2, pc, #4	; (adr r2, 801788c <SecUpdateOudiFlags+0x1c>)
 8017886:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801788a:	bf00      	nop
 801788c:	080178d5 	.word	0x080178d5
 8017890:	08017915 	.word	0x08017915
 8017894:	08017915 	.word	0x08017915
 8017898:	08017915 	.word	0x08017915
 801789c:	08017915 	.word	0x08017915
 80178a0:	080178d5 	.word	0x080178d5
 80178a4:	08017915 	.word	0x08017915
 80178a8:	08017915 	.word	0x08017915
 80178ac:	08017915 	.word	0x08017915
 80178b0:	08017915 	.word	0x08017915
 80178b4:	08017915 	.word	0x08017915
 80178b8:	080178ef 	.word	0x080178ef
 80178bc:	08017915 	.word	0x08017915
 80178c0:	08017915 	.word	0x08017915
 80178c4:	08017915 	.word	0x08017915
 80178c8:	08017915 	.word	0x08017915
 80178cc:	08017915 	.word	0x08017915
 80178d0:	080178e1 	.word	0x080178e1
        case SECUREC_CHAR('i'): /* fall-through */ /* FALLTHRU */
        case SECUREC_CHAR('d'): /* fall-through */ /* FALLTHRU */
            /* For signed decimal output */
            attr->flags |= SECUREC_FLAG_SIGNED;
 80178d4:	687b      	ldr	r3, [r7, #4]
 80178d6:	695b      	ldr	r3, [r3, #20]
 80178d8:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 80178dc:	687b      	ldr	r3, [r7, #4]
 80178de:	615a      	str	r2, [r3, #20]
            /* fall-through */ /* FALLTHRU */
        case SECUREC_CHAR('u'):
            attr->radix = SECUREC_RADIX_DECIMAL;
 80178e0:	687b      	ldr	r3, [r7, #4]
 80178e2:	220a      	movs	r2, #10
 80178e4:	611a      	str	r2, [r3, #16]
            attr->digits = g_itoaLowerDigits;
 80178e6:	687b      	ldr	r3, [r7, #4]
 80178e8:	4a0f      	ldr	r2, [pc, #60]	; (8017928 <SecUpdateOudiFlags+0xb8>)
 80178ea:	601a      	str	r2, [r3, #0]
            break;
 80178ec:	e015      	b.n	801791a <SecUpdateOudiFlags+0xaa>
        case SECUREC_CHAR('o'):
            /* For unsigned octal output */
            attr->radix = SECUREC_RADIX_OCTAL;
 80178ee:	687b      	ldr	r3, [r7, #4]
 80178f0:	2208      	movs	r2, #8
 80178f2:	611a      	str	r2, [r3, #16]
            attr->digits = g_itoaLowerDigits;
 80178f4:	687b      	ldr	r3, [r7, #4]
 80178f6:	4a0c      	ldr	r2, [pc, #48]	; (8017928 <SecUpdateOudiFlags+0xb8>)
 80178f8:	601a      	str	r2, [r3, #0]
            if ((attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
 80178fa:	687b      	ldr	r3, [r7, #4]
 80178fc:	695b      	ldr	r3, [r3, #20]
 80178fe:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8017902:	2b00      	cmp	r3, #0
 8017904:	d008      	beq.n	8017918 <SecUpdateOudiFlags+0xa8>
                /* Alternate form means force a leading 0 */
                attr->flags |= SECUREC_FLAG_FORCE_OCTAL;
 8017906:	687b      	ldr	r3, [r7, #4]
 8017908:	695b      	ldr	r3, [r3, #20]
 801790a:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 801790e:	687b      	ldr	r3, [r7, #4]
 8017910:	615a      	str	r2, [r3, #20]
            }
            break;
 8017912:	e001      	b.n	8017918 <SecUpdateOudiFlags+0xa8>
        default:
            /* Do nothing */
            break;
 8017914:	bf00      	nop
 8017916:	e000      	b.n	801791a <SecUpdateOudiFlags+0xaa>
            break;
 8017918:	bf00      	nop
    }
}
 801791a:	bf00      	nop
 801791c:	370c      	adds	r7, #12
 801791e:	46bd      	mov	sp, r7
 8017920:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017924:	4770      	bx	lr
 8017926:	bf00      	nop
 8017928:	080236c8 	.word	0x080236c8

0801792c <SecFreeFloatBuffer>:

#if SECUREC_ENABLE_SPRINTF_FLOAT
SECUREC_INLINE void SecFreeFloatBuffer(SecFloatAdapt *floatAdapt)
{
 801792c:	b580      	push	{r7, lr}
 801792e:	b082      	sub	sp, #8
 8017930:	af00      	add	r7, sp, #0
 8017932:	6078      	str	r0, [r7, #4]
    if (floatAdapt->floatBuffer != NULL) {
 8017934:	687b      	ldr	r3, [r7, #4]
 8017936:	699b      	ldr	r3, [r3, #24]
 8017938:	2b00      	cmp	r3, #0
 801793a:	d004      	beq.n	8017946 <SecFreeFloatBuffer+0x1a>
        SECUREC_FREE(floatAdapt->floatBuffer);
 801793c:	687b      	ldr	r3, [r7, #4]
 801793e:	699b      	ldr	r3, [r3, #24]
 8017940:	4618      	mov	r0, r3
 8017942:	f002 ff47 	bl	801a7d4 <free>
    }
    if (floatAdapt->allocatedFmtStr != NULL) {
 8017946:	687b      	ldr	r3, [r7, #4]
 8017948:	695b      	ldr	r3, [r3, #20]
 801794a:	2b00      	cmp	r3, #0
 801794c:	d004      	beq.n	8017958 <SecFreeFloatBuffer+0x2c>
        SECUREC_FREE(floatAdapt->allocatedFmtStr);
 801794e:	687b      	ldr	r3, [r7, #4]
 8017950:	695b      	ldr	r3, [r3, #20]
 8017952:	4618      	mov	r0, r3
 8017954:	f002 ff3e 	bl	801a7d4 <free>
    }
    floatAdapt->floatBuffer = NULL;
 8017958:	687b      	ldr	r3, [r7, #4]
 801795a:	2200      	movs	r2, #0
 801795c:	619a      	str	r2, [r3, #24]
    floatAdapt->allocatedFmtStr = NULL;
 801795e:	687b      	ldr	r3, [r7, #4]
 8017960:	2200      	movs	r2, #0
 8017962:	615a      	str	r2, [r3, #20]
    floatAdapt->fmtStr = NULL;
 8017964:	687b      	ldr	r3, [r7, #4]
 8017966:	2200      	movs	r2, #0
 8017968:	611a      	str	r2, [r3, #16]
    floatAdapt->bufferSize = 0;
 801796a:	687b      	ldr	r3, [r7, #4]
 801796c:	2200      	movs	r2, #0
 801796e:	61da      	str	r2, [r3, #28]
}
 8017970:	bf00      	nop
 8017972:	3708      	adds	r7, #8
 8017974:	46bd      	mov	sp, r7
 8017976:	bd80      	pop	{r7, pc}

08017978 <SecSeekToFrontPercent>:

SECUREC_INLINE void SecSeekToFrontPercent(const SecChar **format)
{
 8017978:	b480      	push	{r7}
 801797a:	b085      	sub	sp, #20
 801797c:	af00      	add	r7, sp, #0
 801797e:	6078      	str	r0, [r7, #4]
    const SecChar *fmt = *format;
 8017980:	687b      	ldr	r3, [r7, #4]
 8017982:	681b      	ldr	r3, [r3, #0]
 8017984:	60fb      	str	r3, [r7, #12]
    while (*fmt != SECUREC_CHAR('%')) { /* Must meet '%' */
 8017986:	e002      	b.n	801798e <SecSeekToFrontPercent+0x16>
        --fmt;
 8017988:	68fb      	ldr	r3, [r7, #12]
 801798a:	3b01      	subs	r3, #1
 801798c:	60fb      	str	r3, [r7, #12]
    while (*fmt != SECUREC_CHAR('%')) { /* Must meet '%' */
 801798e:	68fb      	ldr	r3, [r7, #12]
 8017990:	781b      	ldrb	r3, [r3, #0]
 8017992:	2b25      	cmp	r3, #37	; 0x25
 8017994:	d1f8      	bne.n	8017988 <SecSeekToFrontPercent+0x10>
    }
    *format = fmt;
 8017996:	687b      	ldr	r3, [r7, #4]
 8017998:	68fa      	ldr	r2, [r7, #12]
 801799a:	601a      	str	r2, [r3, #0]
}
 801799c:	bf00      	nop
 801799e:	3714      	adds	r7, #20
 80179a0:	46bd      	mov	sp, r7
 80179a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80179a6:	4770      	bx	lr

080179a8 <SecInitFloatFmt>:

/* Init float format, return 0 is OK */
SECUREC_INLINE int SecInitFloatFmt(SecFloatAdapt *floatFmt, const SecChar *format)
{
 80179a8:	b580      	push	{r7, lr}
 80179aa:	b086      	sub	sp, #24
 80179ac:	af00      	add	r7, sp, #0
 80179ae:	6078      	str	r0, [r7, #4]
 80179b0:	6039      	str	r1, [r7, #0]
 80179b2:	4b2a      	ldr	r3, [pc, #168]	; (8017a5c <SecInitFloatFmt+0xb4>)
 80179b4:	681b      	ldr	r3, [r3, #0]
 80179b6:	617b      	str	r3, [r7, #20]
 80179b8:	f04f 0300 	mov.w	r3, #0
    const SecChar *fmt = format - 2;  /* Sub 2 to the position before 'f' or 'g' */
 80179bc:	683b      	ldr	r3, [r7, #0]
 80179be:	3b02      	subs	r3, #2
 80179c0:	60bb      	str	r3, [r7, #8]
    int fmtStrLen;
    int i;

    SecSeekToFrontPercent(&fmt);
 80179c2:	f107 0308 	add.w	r3, r7, #8
 80179c6:	4618      	mov	r0, r3
 80179c8:	f7ff ffd6 	bl	8017978 <SecSeekToFrontPercent>
    /* Now fmt point to '%' */
    fmtStrLen = (int)(size_t)(format - fmt) + 1;   /* With ending terminator */
 80179cc:	68bb      	ldr	r3, [r7, #8]
 80179ce:	683a      	ldr	r2, [r7, #0]
 80179d0:	1ad3      	subs	r3, r2, r3
 80179d2:	3301      	adds	r3, #1
 80179d4:	613b      	str	r3, [r7, #16]
    if (fmtStrLen > (int)sizeof(floatFmt->buffer)) {
 80179d6:	693b      	ldr	r3, [r7, #16]
 80179d8:	2b10      	cmp	r3, #16
 80179da:	dd12      	ble.n	8017a02 <SecInitFloatFmt+0x5a>
        /* When buffer is NOT enough, alloc a new buffer */
        floatFmt->allocatedFmtStr = (char *)SECUREC_MALLOC((size_t)((unsigned int)fmtStrLen));
 80179dc:	693b      	ldr	r3, [r7, #16]
 80179de:	4618      	mov	r0, r3
 80179e0:	f002 ff0c 	bl	801a7fc <malloc>
 80179e4:	4602      	mov	r2, r0
 80179e6:	687b      	ldr	r3, [r7, #4]
 80179e8:	615a      	str	r2, [r3, #20]
        if (floatFmt->allocatedFmtStr == NULL) {
 80179ea:	687b      	ldr	r3, [r7, #4]
 80179ec:	695b      	ldr	r3, [r3, #20]
 80179ee:	2b00      	cmp	r3, #0
 80179f0:	d102      	bne.n	80179f8 <SecInitFloatFmt+0x50>
            return -1;
 80179f2:	f04f 33ff 	mov.w	r3, #4294967295
 80179f6:	e026      	b.n	8017a46 <SecInitFloatFmt+0x9e>
        }
        floatFmt->fmtStr = floatFmt->allocatedFmtStr;
 80179f8:	687b      	ldr	r3, [r7, #4]
 80179fa:	695a      	ldr	r2, [r3, #20]
 80179fc:	687b      	ldr	r3, [r7, #4]
 80179fe:	611a      	str	r2, [r3, #16]
 8017a00:	e005      	b.n	8017a0e <SecInitFloatFmt+0x66>
    } else {
        floatFmt->fmtStr = floatFmt->buffer;
 8017a02:	687a      	ldr	r2, [r7, #4]
 8017a04:	687b      	ldr	r3, [r7, #4]
 8017a06:	611a      	str	r2, [r3, #16]
        floatFmt->allocatedFmtStr = NULL; /* Must set to NULL, later code free memory based on this identity */
 8017a08:	687b      	ldr	r3, [r7, #4]
 8017a0a:	2200      	movs	r2, #0
 8017a0c:	615a      	str	r2, [r3, #20]
    }

    for (i = 0; i < fmtStrLen - 1; ++i) {
 8017a0e:	2300      	movs	r3, #0
 8017a10:	60fb      	str	r3, [r7, #12]
 8017a12:	e00b      	b.n	8017a2c <SecInitFloatFmt+0x84>
        /* Convert wchar to char */
        floatFmt->fmtStr[i] = (char)(fmt[i]);  /* Copy the format string */
 8017a14:	68ba      	ldr	r2, [r7, #8]
 8017a16:	68fb      	ldr	r3, [r7, #12]
 8017a18:	441a      	add	r2, r3
 8017a1a:	687b      	ldr	r3, [r7, #4]
 8017a1c:	6919      	ldr	r1, [r3, #16]
 8017a1e:	68fb      	ldr	r3, [r7, #12]
 8017a20:	440b      	add	r3, r1
 8017a22:	7812      	ldrb	r2, [r2, #0]
 8017a24:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < fmtStrLen - 1; ++i) {
 8017a26:	68fb      	ldr	r3, [r7, #12]
 8017a28:	3301      	adds	r3, #1
 8017a2a:	60fb      	str	r3, [r7, #12]
 8017a2c:	693b      	ldr	r3, [r7, #16]
 8017a2e:	3b01      	subs	r3, #1
 8017a30:	68fa      	ldr	r2, [r7, #12]
 8017a32:	429a      	cmp	r2, r3
 8017a34:	dbee      	blt.n	8017a14 <SecInitFloatFmt+0x6c>
    }
    floatFmt->fmtStr[fmtStrLen - 1] = '\0';
 8017a36:	687b      	ldr	r3, [r7, #4]
 8017a38:	691a      	ldr	r2, [r3, #16]
 8017a3a:	693b      	ldr	r3, [r7, #16]
 8017a3c:	3b01      	subs	r3, #1
 8017a3e:	4413      	add	r3, r2
 8017a40:	2200      	movs	r2, #0
 8017a42:	701a      	strb	r2, [r3, #0]

    return 0;
 8017a44:	2300      	movs	r3, #0
}
 8017a46:	4a05      	ldr	r2, [pc, #20]	; (8017a5c <SecInitFloatFmt+0xb4>)
 8017a48:	6811      	ldr	r1, [r2, #0]
 8017a4a:	697a      	ldr	r2, [r7, #20]
 8017a4c:	4051      	eors	r1, r2
 8017a4e:	d001      	beq.n	8017a54 <SecInitFloatFmt+0xac>
 8017a50:	f7ec fcca 	bl	80043e8 <__stack_chk_fail>
 8017a54:	4618      	mov	r0, r3
 8017a56:	3718      	adds	r7, #24
 8017a58:	46bd      	mov	sp, r7
 8017a5a:	bd80      	pop	{r7, pc}
 8017a5c:	0802304c 	.word	0x0802304c

08017a60 <SecInitFloatBuffer>:

/* Init float buffer and format, return 0 is OK */
SECUREC_INLINE int SecInitFloatBuffer(SecFloatAdapt *floatAdapt, const SecChar *format, SecFormatAttr *attr)
{
 8017a60:	b580      	push	{r7, lr}
 8017a62:	b084      	sub	sp, #16
 8017a64:	af00      	add	r7, sp, #0
 8017a66:	60f8      	str	r0, [r7, #12]
 8017a68:	60b9      	str	r1, [r7, #8]
 8017a6a:	607a      	str	r2, [r7, #4]
    floatAdapt->allocatedFmtStr = NULL;
 8017a6c:	68fb      	ldr	r3, [r7, #12]
 8017a6e:	2200      	movs	r2, #0
 8017a70:	615a      	str	r2, [r3, #20]
    floatAdapt->fmtStr = NULL;
 8017a72:	68fb      	ldr	r3, [r7, #12]
 8017a74:	2200      	movs	r2, #0
 8017a76:	611a      	str	r2, [r3, #16]
    floatAdapt->floatBuffer = NULL;
 8017a78:	68fb      	ldr	r3, [r7, #12]
 8017a7a:	2200      	movs	r2, #0
 8017a7c:	619a      	str	r2, [r3, #24]
    /* Compute the precision value */
    if (attr->precision < 0) {
 8017a7e:	687b      	ldr	r3, [r7, #4]
 8017a80:	69db      	ldr	r3, [r3, #28]
 8017a82:	2b00      	cmp	r3, #0
 8017a84:	da02      	bge.n	8017a8c <SecInitFloatBuffer+0x2c>
        attr->precision = SECUREC_FLOAT_DEFAULT_PRECISION;
 8017a86:	687b      	ldr	r3, [r7, #4]
 8017a88:	2206      	movs	r2, #6
 8017a8a:	61da      	str	r2, [r3, #28]
    }
    /*
     * Calc buffer size to store double value
     * The maximum length of SECUREC_MAX_WIDTH_LEN is enough
     */
    if ((attr->flags & SECUREC_FLAG_LONG_DOUBLE) != 0) {
 8017a8c:	687b      	ldr	r3, [r7, #4]
 8017a8e:	695b      	ldr	r3, [r3, #20]
 8017a90:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8017a94:	2b00      	cmp	r3, #0
 8017a96:	d00f      	beq.n	8017ab8 <SecInitFloatBuffer+0x58>
        if (attr->precision > (SECUREC_MAX_WIDTH_LEN - SECUREC_FLOAT_BUFSIZE_LB)) {
 8017a98:	687b      	ldr	r3, [r7, #4]
 8017a9a:	69db      	ldr	r3, [r3, #28]
 8017a9c:	4a2f      	ldr	r2, [pc, #188]	; (8017b5c <SecInitFloatBuffer+0xfc>)
 8017a9e:	4293      	cmp	r3, r2
 8017aa0:	dd02      	ble.n	8017aa8 <SecInitFloatBuffer+0x48>
            return -1;
 8017aa2:	f04f 33ff 	mov.w	r3, #4294967295
 8017aa6:	e055      	b.n	8017b54 <SecInitFloatBuffer+0xf4>
        }
        /* Long double needs to meet the basic print length */
        floatAdapt->bufferSize = SECUREC_FLOAT_BUFSIZE_LB + attr->precision + SECUREC_FLOAT_BUF_EXT;
 8017aa8:	687b      	ldr	r3, [r7, #4]
 8017aaa:	69da      	ldr	r2, [r3, #28]
 8017aac:	f241 336e 	movw	r3, #4974	; 0x136e
 8017ab0:	4413      	add	r3, r2
 8017ab2:	68fa      	ldr	r2, [r7, #12]
 8017ab4:	61d3      	str	r3, [r2, #28]
 8017ab6:	e00d      	b.n	8017ad4 <SecInitFloatBuffer+0x74>
    } else {
        if (attr->precision > (SECUREC_MAX_WIDTH_LEN - SECUREC_FLOAT_BUFSIZE)) {
 8017ab8:	687b      	ldr	r3, [r7, #4]
 8017aba:	69db      	ldr	r3, [r3, #28]
 8017abc:	4a28      	ldr	r2, [pc, #160]	; (8017b60 <SecInitFloatBuffer+0x100>)
 8017abe:	4293      	cmp	r3, r2
 8017ac0:	dd02      	ble.n	8017ac8 <SecInitFloatBuffer+0x68>
            return -1;
 8017ac2:	f04f 33ff 	mov.w	r3, #4294967295
 8017ac6:	e045      	b.n	8017b54 <SecInitFloatBuffer+0xf4>
        }
        /* Double needs to meet the basic print length */
        floatAdapt->bufferSize = SECUREC_FLOAT_BUFSIZE + attr->precision + SECUREC_FLOAT_BUF_EXT;
 8017ac8:	687b      	ldr	r3, [r7, #4]
 8017aca:	69db      	ldr	r3, [r3, #28]
 8017acc:	f203 125f 	addw	r2, r3, #351	; 0x15f
 8017ad0:	68fb      	ldr	r3, [r7, #12]
 8017ad2:	61da      	str	r2, [r3, #28]
    }
    if (attr->fldWidth > floatAdapt->bufferSize) {
 8017ad4:	687b      	ldr	r3, [r7, #4]
 8017ad6:	699a      	ldr	r2, [r3, #24]
 8017ad8:	68fb      	ldr	r3, [r7, #12]
 8017ada:	69db      	ldr	r3, [r3, #28]
 8017adc:	429a      	cmp	r2, r3
 8017ade:	dd04      	ble.n	8017aea <SecInitFloatBuffer+0x8a>
        floatAdapt->bufferSize = attr->fldWidth + SECUREC_FLOAT_BUF_EXT;
 8017ae0:	687b      	ldr	r3, [r7, #4]
 8017ae2:	699b      	ldr	r3, [r3, #24]
 8017ae4:	1c9a      	adds	r2, r3, #2
 8017ae6:	68fb      	ldr	r3, [r7, #12]
 8017ae8:	61da      	str	r2, [r3, #28]
    }

    if (floatAdapt->bufferSize > SECUREC_BUFFER_SIZE) {
 8017aea:	68fb      	ldr	r3, [r7, #12]
 8017aec:	69db      	ldr	r3, [r3, #28]
 8017aee:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8017af2:	dd13      	ble.n	8017b1c <SecInitFloatBuffer+0xbc>
        /* The current value of SECUREC_BUFFER_SIZE could not store the formatted float string */
        floatAdapt->floatBuffer = (char *)SECUREC_MALLOC(((size_t)(unsigned int)floatAdapt->bufferSize));
 8017af4:	68fb      	ldr	r3, [r7, #12]
 8017af6:	69db      	ldr	r3, [r3, #28]
 8017af8:	4618      	mov	r0, r3
 8017afa:	f002 fe7f 	bl	801a7fc <malloc>
 8017afe:	4602      	mov	r2, r0
 8017b00:	68fb      	ldr	r3, [r7, #12]
 8017b02:	619a      	str	r2, [r3, #24]
        if (floatAdapt->floatBuffer == NULL) {
 8017b04:	68fb      	ldr	r3, [r7, #12]
 8017b06:	699b      	ldr	r3, [r3, #24]
 8017b08:	2b00      	cmp	r3, #0
 8017b0a:	d102      	bne.n	8017b12 <SecInitFloatBuffer+0xb2>
            return -1;
 8017b0c:	f04f 33ff 	mov.w	r3, #4294967295
 8017b10:	e020      	b.n	8017b54 <SecInitFloatBuffer+0xf4>
        }
        attr->text.str = floatAdapt->floatBuffer;
 8017b12:	68fb      	ldr	r3, [r7, #12]
 8017b14:	699a      	ldr	r2, [r3, #24]
 8017b16:	687b      	ldr	r3, [r7, #4]
 8017b18:	605a      	str	r2, [r3, #4]
 8017b1a:	e004      	b.n	8017b26 <SecInitFloatBuffer+0xc6>
    } else {
        attr->text.str = attr->buffer.str; /* Output buffer for float string with default size */
 8017b1c:	687b      	ldr	r3, [r7, #4]
 8017b1e:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8017b22:	687b      	ldr	r3, [r7, #4]
 8017b24:	605a      	str	r2, [r3, #4]
    }

    if (SecInitFloatFmt(floatAdapt, format) != 0) {
 8017b26:	68b9      	ldr	r1, [r7, #8]
 8017b28:	68f8      	ldr	r0, [r7, #12]
 8017b2a:	f7ff ff3d 	bl	80179a8 <SecInitFloatFmt>
 8017b2e:	4603      	mov	r3, r0
 8017b30:	2b00      	cmp	r3, #0
 8017b32:	d00e      	beq.n	8017b52 <SecInitFloatBuffer+0xf2>
        if (floatAdapt->floatBuffer != NULL) {
 8017b34:	68fb      	ldr	r3, [r7, #12]
 8017b36:	699b      	ldr	r3, [r3, #24]
 8017b38:	2b00      	cmp	r3, #0
 8017b3a:	d007      	beq.n	8017b4c <SecInitFloatBuffer+0xec>
            SECUREC_FREE(floatAdapt->floatBuffer);
 8017b3c:	68fb      	ldr	r3, [r7, #12]
 8017b3e:	699b      	ldr	r3, [r3, #24]
 8017b40:	4618      	mov	r0, r3
 8017b42:	f002 fe47 	bl	801a7d4 <free>
            floatAdapt->floatBuffer = NULL;
 8017b46:	68fb      	ldr	r3, [r7, #12]
 8017b48:	2200      	movs	r2, #0
 8017b4a:	619a      	str	r2, [r3, #24]
        }
        return -1;
 8017b4c:	f04f 33ff 	mov.w	r3, #4294967295
 8017b50:	e000      	b.n	8017b54 <SecInitFloatBuffer+0xf4>
    }
    return 0;
 8017b52:	2300      	movs	r3, #0
}
 8017b54:	4618      	mov	r0, r3
 8017b56:	3710      	adds	r7, #16
 8017b58:	46bd      	mov	sp, r7
 8017b5a:	bd80      	pop	{r7, pc}
 8017b5c:	0cccb95c 	.word	0x0cccb95c
 8017b60:	0ccccb6b 	.word	0x0ccccb6b

08017b64 <SecUpdateNegativeChar>:
#endif

SECUREC_INLINE SecInt64 SecUpdateNegativeChar(SecFormatAttr *attr, char ch)
{
 8017b64:	b480      	push	{r7}
 8017b66:	b087      	sub	sp, #28
 8017b68:	af00      	add	r7, sp, #0
 8017b6a:	6078      	str	r0, [r7, #4]
 8017b6c:	460b      	mov	r3, r1
 8017b6e:	70fb      	strb	r3, [r7, #3]
    SecInt64 num64 = ch; /* Sign extend */
 8017b70:	78fa      	ldrb	r2, [r7, #3]
 8017b72:	f04f 0300 	mov.w	r3, #0
 8017b76:	e9c7 2304 	strd	r2, r3, [r7, #16]
    if (num64 >= 128) { /* 128 on some platform, char is always unsigned */
 8017b7a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8017b7e:	2a80      	cmp	r2, #128	; 0x80
 8017b80:	f173 0300 	sbcs.w	r3, r3, #0
 8017b84:	db0f      	blt.n	8017ba6 <SecUpdateNegativeChar+0x42>
        unsigned char tmp = (unsigned char)(~((unsigned char)ch));
 8017b86:	78fb      	ldrb	r3, [r7, #3]
 8017b88:	43db      	mvns	r3, r3
 8017b8a:	73fb      	strb	r3, [r7, #15]
        num64 = tmp + 1;
 8017b8c:	7bfb      	ldrb	r3, [r7, #15]
 8017b8e:	3301      	adds	r3, #1
 8017b90:	461a      	mov	r2, r3
 8017b92:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8017b96:	e9c7 2304 	strd	r2, r3, [r7, #16]
        attr->flags |= SECUREC_FLAG_NEGATIVE;
 8017b9a:	687b      	ldr	r3, [r7, #4]
 8017b9c:	695b      	ldr	r3, [r3, #20]
 8017b9e:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8017ba2:	687b      	ldr	r3, [r7, #4]
 8017ba4:	615a      	str	r2, [r3, #20]
    }
    return num64;
 8017ba6:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
}
 8017baa:	4610      	mov	r0, r2
 8017bac:	4619      	mov	r1, r3
 8017bae:	371c      	adds	r7, #28
 8017bb0:	46bd      	mov	sp, r7
 8017bb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017bb6:	4770      	bx	lr

08017bb8 <SecNumberSatisfyPrecision>:

/*
 * If the precision is not satisfied, zero is added before the string
 */
SECUREC_INLINE void SecNumberSatisfyPrecision(SecFormatAttr *attr)
{
 8017bb8:	b480      	push	{r7}
 8017bba:	b085      	sub	sp, #20
 8017bbc:	af00      	add	r7, sp, #0
 8017bbe:	6078      	str	r0, [r7, #4]
    int precision;
    if (attr->precision < 0) {
 8017bc0:	687b      	ldr	r3, [r7, #4]
 8017bc2:	69db      	ldr	r3, [r3, #28]
 8017bc4:	2b00      	cmp	r3, #0
 8017bc6:	da02      	bge.n	8017bce <SecNumberSatisfyPrecision+0x16>
        precision = 1; /* Default precision 1 */
 8017bc8:	2301      	movs	r3, #1
 8017bca:	60fb      	str	r3, [r7, #12]
 8017bcc:	e026      	b.n	8017c1c <SecNumberSatisfyPrecision+0x64>
    } else {
#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
        attr->flags &= ~SECUREC_FLAG_LEADZERO;
#else
        if ((attr->flags & SECUREC_FLAG_POINTER) == 0) {
 8017bce:	687b      	ldr	r3, [r7, #4]
 8017bd0:	695b      	ldr	r3, [r3, #20]
 8017bd2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8017bd6:	2b00      	cmp	r3, #0
 8017bd8:	d105      	bne.n	8017be6 <SecNumberSatisfyPrecision+0x2e>
            attr->flags &= ~SECUREC_FLAG_LEADZERO;
 8017bda:	687b      	ldr	r3, [r7, #4]
 8017bdc:	695b      	ldr	r3, [r3, #20]
 8017bde:	f023 0208 	bic.w	r2, r3, #8
 8017be2:	687b      	ldr	r3, [r7, #4]
 8017be4:	615a      	str	r2, [r3, #20]
        }
#endif
        if (attr->precision > SECUREC_MAX_PRECISION) {
 8017be6:	687b      	ldr	r3, [r7, #4]
 8017be8:	69db      	ldr	r3, [r3, #28]
 8017bea:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8017bee:	dd03      	ble.n	8017bf8 <SecNumberSatisfyPrecision+0x40>
            attr->precision = SECUREC_MAX_PRECISION;
 8017bf0:	687b      	ldr	r3, [r7, #4]
 8017bf2:	f44f 7200 	mov.w	r2, #512	; 0x200
 8017bf6:	61da      	str	r2, [r3, #28]
        }
        precision = attr->precision;
 8017bf8:	687b      	ldr	r3, [r7, #4]
 8017bfa:	69db      	ldr	r3, [r3, #28]
 8017bfc:	60fb      	str	r3, [r7, #12]
    }
    while (attr->textLen < precision) {
 8017bfe:	e00d      	b.n	8017c1c <SecNumberSatisfyPrecision+0x64>
        --attr->text.str;
 8017c00:	687b      	ldr	r3, [r7, #4]
 8017c02:	685b      	ldr	r3, [r3, #4]
 8017c04:	1e5a      	subs	r2, r3, #1
 8017c06:	687b      	ldr	r3, [r7, #4]
 8017c08:	605a      	str	r2, [r3, #4]
        *(attr->text.str) = '0';
 8017c0a:	687b      	ldr	r3, [r7, #4]
 8017c0c:	685b      	ldr	r3, [r3, #4]
 8017c0e:	2230      	movs	r2, #48	; 0x30
 8017c10:	701a      	strb	r2, [r3, #0]
        ++attr->textLen;
 8017c12:	687b      	ldr	r3, [r7, #4]
 8017c14:	689b      	ldr	r3, [r3, #8]
 8017c16:	1c5a      	adds	r2, r3, #1
 8017c18:	687b      	ldr	r3, [r7, #4]
 8017c1a:	609a      	str	r2, [r3, #8]
    while (attr->textLen < precision) {
 8017c1c:	687b      	ldr	r3, [r7, #4]
 8017c1e:	689b      	ldr	r3, [r3, #8]
 8017c20:	68fa      	ldr	r2, [r7, #12]
 8017c22:	429a      	cmp	r2, r3
 8017c24:	dcec      	bgt.n	8017c00 <SecNumberSatisfyPrecision+0x48>
    }
}
 8017c26:	bf00      	nop
 8017c28:	bf00      	nop
 8017c2a:	3714      	adds	r7, #20
 8017c2c:	46bd      	mov	sp, r7
 8017c2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017c32:	4770      	bx	lr

08017c34 <SecNumberForceOctal>:

/*
 * Add leading zero for %#o
 */
SECUREC_INLINE void SecNumberForceOctal(SecFormatAttr *attr)
{
 8017c34:	b480      	push	{r7}
 8017c36:	b083      	sub	sp, #12
 8017c38:	af00      	add	r7, sp, #0
 8017c3a:	6078      	str	r0, [r7, #4]
    /* Force a leading zero if FORCEOCTAL flag set */
    if ((attr->flags & SECUREC_FLAG_FORCE_OCTAL) != 0 &&
 8017c3c:	687b      	ldr	r3, [r7, #4]
 8017c3e:	695b      	ldr	r3, [r3, #20]
 8017c40:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8017c44:	2b00      	cmp	r3, #0
 8017c46:	d016      	beq.n	8017c76 <SecNumberForceOctal+0x42>
        (attr->textLen == 0 || attr->text.str[0] != '0')) {
 8017c48:	687b      	ldr	r3, [r7, #4]
 8017c4a:	689b      	ldr	r3, [r3, #8]
    if ((attr->flags & SECUREC_FLAG_FORCE_OCTAL) != 0 &&
 8017c4c:	2b00      	cmp	r3, #0
 8017c4e:	d004      	beq.n	8017c5a <SecNumberForceOctal+0x26>
        (attr->textLen == 0 || attr->text.str[0] != '0')) {
 8017c50:	687b      	ldr	r3, [r7, #4]
 8017c52:	685b      	ldr	r3, [r3, #4]
 8017c54:	781b      	ldrb	r3, [r3, #0]
 8017c56:	2b30      	cmp	r3, #48	; 0x30
 8017c58:	d00d      	beq.n	8017c76 <SecNumberForceOctal+0x42>
        --attr->text.str;
 8017c5a:	687b      	ldr	r3, [r7, #4]
 8017c5c:	685b      	ldr	r3, [r3, #4]
 8017c5e:	1e5a      	subs	r2, r3, #1
 8017c60:	687b      	ldr	r3, [r7, #4]
 8017c62:	605a      	str	r2, [r3, #4]
        *(attr->text.str) = '0';
 8017c64:	687b      	ldr	r3, [r7, #4]
 8017c66:	685b      	ldr	r3, [r3, #4]
 8017c68:	2230      	movs	r2, #48	; 0x30
 8017c6a:	701a      	strb	r2, [r3, #0]
        ++attr->textLen;
 8017c6c:	687b      	ldr	r3, [r7, #4]
 8017c6e:	689b      	ldr	r3, [r3, #8]
 8017c70:	1c5a      	adds	r2, r3, #1
 8017c72:	687b      	ldr	r3, [r7, #4]
 8017c74:	609a      	str	r2, [r3, #8]
    }
}
 8017c76:	bf00      	nop
 8017c78:	370c      	adds	r7, #12
 8017c7a:	46bd      	mov	sp, r7
 8017c7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017c80:	4770      	bx	lr

08017c82 <SecUpdateSignedNumberPrefix>:

SECUREC_INLINE void SecUpdateSignedNumberPrefix(SecFormatAttr *attr)
{
 8017c82:	b480      	push	{r7}
 8017c84:	b083      	sub	sp, #12
 8017c86:	af00      	add	r7, sp, #0
 8017c88:	6078      	str	r0, [r7, #4]
    if ((attr->flags & SECUREC_FLAG_SIGNED) == 0) {
 8017c8a:	687b      	ldr	r3, [r7, #4]
 8017c8c:	695b      	ldr	r3, [r3, #20]
 8017c8e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8017c92:	2b00      	cmp	r3, #0
 8017c94:	d029      	beq.n	8017cea <SecUpdateSignedNumberPrefix+0x68>
        return;
    }
    if ((attr->flags & SECUREC_FLAG_NEGATIVE) != 0) {
 8017c96:	687b      	ldr	r3, [r7, #4]
 8017c98:	695b      	ldr	r3, [r3, #20]
 8017c9a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8017c9e:	2b00      	cmp	r3, #0
 8017ca0:	d007      	beq.n	8017cb2 <SecUpdateSignedNumberPrefix+0x30>
        /* Prefix is '-' */
        attr->prefix[0] = SECUREC_CHAR('-');
 8017ca2:	687b      	ldr	r3, [r7, #4]
 8017ca4:	222d      	movs	r2, #45	; 0x2d
 8017ca6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        attr->prefixLen = 1;
 8017caa:	687b      	ldr	r3, [r7, #4]
 8017cac:	2201      	movs	r2, #1
 8017cae:	62da      	str	r2, [r3, #44]	; 0x2c
        return;
 8017cb0:	e01e      	b.n	8017cf0 <SecUpdateSignedNumberPrefix+0x6e>
    }
    if ((attr->flags & SECUREC_FLAG_SIGN) != 0) {
 8017cb2:	687b      	ldr	r3, [r7, #4]
 8017cb4:	695b      	ldr	r3, [r3, #20]
 8017cb6:	f003 0301 	and.w	r3, r3, #1
 8017cba:	2b00      	cmp	r3, #0
 8017cbc:	d007      	beq.n	8017cce <SecUpdateSignedNumberPrefix+0x4c>
        /* Prefix is '+' */
        attr->prefix[0] = SECUREC_CHAR('+');
 8017cbe:	687b      	ldr	r3, [r7, #4]
 8017cc0:	222b      	movs	r2, #43	; 0x2b
 8017cc2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        attr->prefixLen = 1;
 8017cc6:	687b      	ldr	r3, [r7, #4]
 8017cc8:	2201      	movs	r2, #1
 8017cca:	62da      	str	r2, [r3, #44]	; 0x2c
        return;
 8017ccc:	e010      	b.n	8017cf0 <SecUpdateSignedNumberPrefix+0x6e>
    }
    if ((attr->flags & SECUREC_FLAG_SIGN_SPACE) != 0) {
 8017cce:	687b      	ldr	r3, [r7, #4]
 8017cd0:	695b      	ldr	r3, [r3, #20]
 8017cd2:	f003 0302 	and.w	r3, r3, #2
 8017cd6:	2b00      	cmp	r3, #0
 8017cd8:	d009      	beq.n	8017cee <SecUpdateSignedNumberPrefix+0x6c>
        /* Prefix is ' ' */
        attr->prefix[0] = SECUREC_CHAR(' ');
 8017cda:	687b      	ldr	r3, [r7, #4]
 8017cdc:	2220      	movs	r2, #32
 8017cde:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        attr->prefixLen = 1;
 8017ce2:	687b      	ldr	r3, [r7, #4]
 8017ce4:	2201      	movs	r2, #1
 8017ce6:	62da      	str	r2, [r3, #44]	; 0x2c
        return;
 8017ce8:	e002      	b.n	8017cf0 <SecUpdateSignedNumberPrefix+0x6e>
        return;
 8017cea:	bf00      	nop
 8017cec:	e000      	b.n	8017cf0 <SecUpdateSignedNumberPrefix+0x6e>
    }
    return;
 8017cee:	bf00      	nop
}
 8017cf0:	370c      	adds	r7, #12
 8017cf2:	46bd      	mov	sp, r7
 8017cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017cf8:	4770      	bx	lr
	...

08017cfc <SecNumberCompatZero>:

SECUREC_INLINE void SecNumberCompatZero(SecFormatAttr *attr)
{
 8017cfc:	b480      	push	{r7}
 8017cfe:	b083      	sub	sp, #12
 8017d00:	af00      	add	r7, sp, #0
 8017d02:	6078      	str	r0, [r7, #4]
        (attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
        /* Add 0x prefix for %x or %X, the prefix string has been set before */
        attr->prefixLen = SECUREC_PREFIX_LEN;
    }
#elif defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && (!defined(SECUREC_ON_UNIX))
    if ((attr->flags & SECUREC_FLAG_POINTER) != 0) {
 8017d04:	687b      	ldr	r3, [r7, #4]
 8017d06:	695b      	ldr	r3, [r3, #20]
 8017d08:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8017d0c:	2b00      	cmp	r3, #0
 8017d0e:	d00b      	beq.n	8017d28 <SecNumberCompatZero+0x2c>
        static char strNullPointer[SECUREC_NULL_STRING_SIZE] = "(nil)";
        attr->text.str = strNullPointer;
 8017d10:	687b      	ldr	r3, [r7, #4]
 8017d12:	4a08      	ldr	r2, [pc, #32]	; (8017d34 <SecNumberCompatZero+0x38>)
 8017d14:	605a      	str	r2, [r3, #4]
        attr->textLen = 5; /* Length of (nil) is 5 */
 8017d16:	687b      	ldr	r3, [r7, #4]
 8017d18:	2205      	movs	r2, #5
 8017d1a:	609a      	str	r2, [r3, #8]
        attr->flags &= ~SECUREC_FLAG_LEADZERO;
 8017d1c:	687b      	ldr	r3, [r7, #4]
 8017d1e:	695b      	ldr	r3, [r3, #20]
 8017d20:	f023 0208 	bic.w	r2, r3, #8
 8017d24:	687b      	ldr	r3, [r7, #4]
 8017d26:	615a      	str	r2, [r3, #20]
        /* Add 0x prefix for %p, the prefix string has been set before */
        attr->prefixLen = SECUREC_PREFIX_LEN;
    }
#endif
    (void)attr; /* To clear e438 last value assigned not used , the compiler will optimize this code */
}
 8017d28:	bf00      	nop
 8017d2a:	370c      	adds	r7, #12
 8017d2c:	46bd      	mov	sp, r7
 8017d2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017d32:	4770      	bx	lr
 8017d34:	20000560 	.word	0x20000560

08017d38 <SecOutput>:

/*
 * Formatting output core function
 */
SECUREC_INLINE int SecOutput(SecPrintfStream *stream, const SecChar *cFormat, va_list argList)
{
 8017d38:	b590      	push	{r4, r7, lr}
 8017d3a:	f5ad 7d2b 	sub.w	sp, sp, #684	; 0x2ac
 8017d3e:	af00      	add	r7, sp, #0
 8017d40:	f107 030c 	add.w	r3, r7, #12
 8017d44:	6018      	str	r0, [r3, #0]
 8017d46:	f107 0308 	add.w	r3, r7, #8
 8017d4a:	6019      	str	r1, [r3, #0]
 8017d4c:	1d3b      	adds	r3, r7, #4
 8017d4e:	601a      	str	r2, [r3, #0]
 8017d50:	4bd1      	ldr	r3, [pc, #836]	; (8018098 <SecOutput+0x360>)
 8017d52:	681b      	ldr	r3, [r3, #0]
 8017d54:	f8c7 32a4 	str.w	r3, [r7, #676]	; 0x2a4
 8017d58:	f04f 0300 	mov.w	r3, #0
    const SecChar *format = cFormat;
 8017d5c:	f107 0314 	add.w	r3, r7, #20
 8017d60:	f107 0208 	add.w	r2, r7, #8
 8017d64:	6812      	ldr	r2, [r2, #0]
 8017d66:	601a      	str	r2, [r3, #0]
    int charsOut;               /* Characters written */
    int noOutput = 0; /* Must be initialized or compiler alerts */
 8017d68:	f107 031c 	add.w	r3, r7, #28
 8017d6c:	2200      	movs	r2, #0
 8017d6e:	601a      	str	r2, [r3, #0]
    SecFmtState state;
    SecFormatAttr formatAttr;

    formatAttr.flags = 0;
 8017d70:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017d74:	2200      	movs	r2, #0
 8017d76:	615a      	str	r2, [r3, #20]
    formatAttr.textIsWide = 0;    /* Flag for buffer contains wide chars */
 8017d78:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017d7c:	2200      	movs	r2, #0
 8017d7e:	60da      	str	r2, [r3, #12]
    formatAttr.fldWidth = 0;
 8017d80:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017d84:	2200      	movs	r2, #0
 8017d86:	619a      	str	r2, [r3, #24]
    formatAttr.precision = 0;
 8017d88:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017d8c:	2200      	movs	r2, #0
 8017d8e:	61da      	str	r2, [r3, #28]
    formatAttr.dynWidth = 0;
 8017d90:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017d94:	2200      	movs	r2, #0
 8017d96:	621a      	str	r2, [r3, #32]
    formatAttr.dynPrecision = 0;
 8017d98:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017d9c:	2200      	movs	r2, #0
 8017d9e:	625a      	str	r2, [r3, #36]	; 0x24
    formatAttr.digits = g_itoaUpperDigits;
 8017da0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017da4:	4abd      	ldr	r2, [pc, #756]	; (801809c <SecOutput+0x364>)
 8017da6:	601a      	str	r2, [r3, #0]
    formatAttr.radix = SECUREC_RADIX_DECIMAL;
 8017da8:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017dac:	220a      	movs	r2, #10
 8017dae:	611a      	str	r2, [r3, #16]
    formatAttr.padding = 0;
 8017db0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017db4:	2200      	movs	r2, #0
 8017db6:	629a      	str	r2, [r3, #40]	; 0x28
    formatAttr.textLen = 0;
 8017db8:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017dbc:	2200      	movs	r2, #0
 8017dbe:	609a      	str	r2, [r3, #8]
    formatAttr.text.str = NULL;
 8017dc0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017dc4:	2200      	movs	r2, #0
 8017dc6:	605a      	str	r2, [r3, #4]
    formatAttr.prefixLen = 0;
 8017dc8:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017dcc:	2200      	movs	r2, #0
 8017dce:	62da      	str	r2, [r3, #44]	; 0x2c
    formatAttr.prefix[0] = SECUREC_CHAR('\0');
 8017dd0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017dd4:	2200      	movs	r2, #0
 8017dd6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    formatAttr.prefix[1] = SECUREC_CHAR('\0');
 8017dda:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017dde:	2200      	movs	r2, #0
 8017de0:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
    charsOut = 0;
 8017de4:	f107 0318 	add.w	r3, r7, #24
 8017de8:	2200      	movs	r2, #0
 8017dea:	601a      	str	r2, [r3, #0]
    state = STAT_NORMAL;        /* Starting state */
 8017dec:	f107 0320 	add.w	r3, r7, #32
 8017df0:	2200      	movs	r2, #0
 8017df2:	601a      	str	r2, [r3, #0]

    /* Loop each format character */
    while (*format != SECUREC_CHAR('\0') && charsOut >= 0) {
 8017df4:	e375      	b.n	80184e2 <SecOutput+0x7aa>
        SecFmtState lastState = state;
 8017df6:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8017dfa:	f107 0220 	add.w	r2, r7, #32
 8017dfe:	6812      	ldr	r2, [r2, #0]
 8017e00:	601a      	str	r2, [r3, #0]
        SecChar ch = *format; /* Currently read character */
 8017e02:	f107 0314 	add.w	r3, r7, #20
 8017e06:	681a      	ldr	r2, [r3, #0]
 8017e08:	f107 0313 	add.w	r3, r7, #19
 8017e0c:	7812      	ldrb	r2, [r2, #0]
 8017e0e:	701a      	strb	r2, [r3, #0]
        ++format;
 8017e10:	f107 0314 	add.w	r3, r7, #20
 8017e14:	681b      	ldr	r3, [r3, #0]
 8017e16:	1c5a      	adds	r2, r3, #1
 8017e18:	f107 0314 	add.w	r3, r7, #20
 8017e1c:	601a      	str	r2, [r3, #0]
        state = SecDecodeState(ch, lastState);
 8017e1e:	f107 0420 	add.w	r4, r7, #32
 8017e22:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8017e26:	f107 0213 	add.w	r2, r7, #19
 8017e2a:	7812      	ldrb	r2, [r2, #0]
 8017e2c:	6819      	ldr	r1, [r3, #0]
 8017e2e:	4610      	mov	r0, r2
 8017e30:	f7ff f976 	bl	8017120 <SecDecodeState>
 8017e34:	6020      	str	r0, [r4, #0]
 8017e36:	f107 0320 	add.w	r3, r7, #32
 8017e3a:	681b      	ldr	r3, [r3, #0]
 8017e3c:	2b07      	cmp	r3, #7
 8017e3e:	f200 834d 	bhi.w	80184dc <SecOutput+0x7a4>
 8017e42:	a201      	add	r2, pc, #4	; (adr r2, 8017e48 <SecOutput+0x110>)
 8017e44:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017e48:	08017e69 	.word	0x08017e69
 8017e4c:	08017e7f 	.word	0x08017e7f
 8017e50:	08017ecb 	.word	0x08017ecb
 8017e54:	08017edf 	.word	0x08017edf
 8017e58:	08017f25 	.word	0x08017f25
 8017e5c:	08017f2f 	.word	0x08017f2f
 8017e60:	08017f73 	.word	0x08017f73
 8017e64:	08017fad 	.word	0x08017fad
        switch (state) {
            case STAT_NORMAL:
                SecWriteChar(stream, ch, &charsOut);
 8017e68:	f107 0218 	add.w	r2, r7, #24
 8017e6c:	f107 0313 	add.w	r3, r7, #19
 8017e70:	7819      	ldrb	r1, [r3, #0]
 8017e72:	f107 030c 	add.w	r3, r7, #12
 8017e76:	6818      	ldr	r0, [r3, #0]
 8017e78:	f7fe ff4a 	bl	8016d10 <SecWriteChar>
                continue;
 8017e7c:	e331      	b.n	80184e2 <SecOutput+0x7aa>
            case STAT_PERCENT:
                /* Set default values */
                noOutput = 0;
 8017e7e:	f107 031c 	add.w	r3, r7, #28
 8017e82:	2200      	movs	r2, #0
 8017e84:	601a      	str	r2, [r3, #0]
                formatAttr.prefixLen = 0;
 8017e86:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017e8a:	2200      	movs	r2, #0
 8017e8c:	62da      	str	r2, [r3, #44]	; 0x2c
                formatAttr.textLen = 0;
 8017e8e:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017e92:	2200      	movs	r2, #0
 8017e94:	609a      	str	r2, [r3, #8]
                formatAttr.flags = 0;
 8017e96:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017e9a:	2200      	movs	r2, #0
 8017e9c:	615a      	str	r2, [r3, #20]
                formatAttr.fldWidth = 0;
 8017e9e:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017ea2:	2200      	movs	r2, #0
 8017ea4:	619a      	str	r2, [r3, #24]
                formatAttr.precision = -1;
 8017ea6:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017eaa:	f04f 32ff 	mov.w	r2, #4294967295
 8017eae:	61da      	str	r2, [r3, #28]
                formatAttr.textIsWide = 0;
 8017eb0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017eb4:	2200      	movs	r2, #0
 8017eb6:	60da      	str	r2, [r3, #12]
                formatAttr.dynWidth = 0;
 8017eb8:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017ebc:	2200      	movs	r2, #0
 8017ebe:	621a      	str	r2, [r3, #32]
                formatAttr.dynPrecision = 0;
 8017ec0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017ec4:	2200      	movs	r2, #0
 8017ec6:	625a      	str	r2, [r3, #36]	; 0x24
                break;
 8017ec8:	e30b      	b.n	80184e2 <SecOutput+0x7aa>
            case STAT_FLAG:
                /* Set flag based on which flag character */
                SecDecodeFlags(ch, &formatAttr);
 8017eca:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8017ece:	f107 0313 	add.w	r3, r7, #19
 8017ed2:	781b      	ldrb	r3, [r3, #0]
 8017ed4:	4611      	mov	r1, r2
 8017ed6:	4618      	mov	r0, r3
 8017ed8:	f7ff f940 	bl	801715c <SecDecodeFlags>
                break;
 8017edc:	e301      	b.n	80184e2 <SecOutput+0x7aa>
            case STAT_WIDTH:
                /* Update width value */
                if (ch == SECUREC_CHAR('*')) {
 8017ede:	f107 0313 	add.w	r3, r7, #19
 8017ee2:	781b      	ldrb	r3, [r3, #0]
 8017ee4:	2b2a      	cmp	r3, #42	; 0x2a
 8017ee6:	d10c      	bne.n	8017f02 <SecOutput+0x1ca>
                    /* get width from arg list */
                    formatAttr.fldWidth = (int)va_arg(argList, int);
 8017ee8:	1d3b      	adds	r3, r7, #4
 8017eea:	681b      	ldr	r3, [r3, #0]
 8017eec:	1d19      	adds	r1, r3, #4
 8017eee:	1d3a      	adds	r2, r7, #4
 8017ef0:	6011      	str	r1, [r2, #0]
 8017ef2:	681a      	ldr	r2, [r3, #0]
 8017ef4:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017ef8:	619a      	str	r2, [r3, #24]
                    formatAttr.dynWidth = 1;
 8017efa:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017efe:	2201      	movs	r2, #1
 8017f00:	621a      	str	r2, [r3, #32]
                }
                if (SecDecodeWidth(ch, &formatAttr, lastState) != 0) {
 8017f02:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8017f06:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8017f0a:	f107 0213 	add.w	r2, r7, #19
 8017f0e:	7810      	ldrb	r0, [r2, #0]
 8017f10:	681a      	ldr	r2, [r3, #0]
 8017f12:	f7ff fbd5 	bl	80176c0 <SecDecodeWidth>
 8017f16:	4603      	mov	r3, r0
 8017f18:	2b00      	cmp	r3, #0
 8017f1a:	f000 82e2 	beq.w	80184e2 <SecOutput+0x7aa>
                    return -1;
 8017f1e:	f04f 33ff 	mov.w	r3, #4294967295
 8017f22:	e2fa      	b.n	801851a <SecOutput+0x7e2>
                }
                break;
            case STAT_DOT:
                formatAttr.precision = 0;
 8017f24:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017f28:	2200      	movs	r2, #0
 8017f2a:	61da      	str	r2, [r3, #28]
                break;
 8017f2c:	e2d9      	b.n	80184e2 <SecOutput+0x7aa>
            case STAT_PRECIS:
                /* Update precision value */
                if (ch == SECUREC_CHAR('*')) {
 8017f2e:	f107 0313 	add.w	r3, r7, #19
 8017f32:	781b      	ldrb	r3, [r3, #0]
 8017f34:	2b2a      	cmp	r3, #42	; 0x2a
 8017f36:	d10c      	bne.n	8017f52 <SecOutput+0x21a>
                    /* Get precision from arg list */
                    formatAttr.precision = (int)va_arg(argList, int);
 8017f38:	1d3b      	adds	r3, r7, #4
 8017f3a:	681b      	ldr	r3, [r3, #0]
 8017f3c:	1d19      	adds	r1, r3, #4
 8017f3e:	1d3a      	adds	r2, r7, #4
 8017f40:	6011      	str	r1, [r2, #0]
 8017f42:	681a      	ldr	r2, [r3, #0]
 8017f44:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017f48:	61da      	str	r2, [r3, #28]
                    formatAttr.dynPrecision = 1;
 8017f4a:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8017f4e:	2201      	movs	r2, #1
 8017f50:	625a      	str	r2, [r3, #36]	; 0x24
                }
                if (SecDecodePrecision(ch, &formatAttr) != 0) {
 8017f52:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8017f56:	f107 0313 	add.w	r3, r7, #19
 8017f5a:	781b      	ldrb	r3, [r3, #0]
 8017f5c:	4611      	mov	r1, r2
 8017f5e:	4618      	mov	r0, r3
 8017f60:	f7ff fb72 	bl	8017648 <SecDecodePrecision>
 8017f64:	4603      	mov	r3, r0
 8017f66:	2b00      	cmp	r3, #0
 8017f68:	f000 82bb 	beq.w	80184e2 <SecOutput+0x7aa>
                    return -1;
 8017f6c:	f04f 33ff 	mov.w	r3, #4294967295
 8017f70:	e2d3      	b.n	801851a <SecOutput+0x7e2>
                }
                break;
            case STAT_SIZE:
                /* Read a size specifier, set the formatAttr.flags based on it, and skip format to next character */
                if (SecDecodeSize(ch, &formatAttr, &format) != 0) {
 8017f72:	f107 0214 	add.w	r2, r7, #20
 8017f76:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8017f7a:	f107 0313 	add.w	r3, r7, #19
 8017f7e:	781b      	ldrb	r3, [r3, #0]
 8017f80:	4618      	mov	r0, r3
 8017f82:	f7ff f9a1 	bl	80172c8 <SecDecodeSize>
 8017f86:	4603      	mov	r3, r0
 8017f88:	2b00      	cmp	r3, #0
 8017f8a:	f000 82aa 	beq.w	80184e2 <SecOutput+0x7aa>
                    /* Compatibility  code for "%I" just print I */
                    SecWriteChar(stream, ch, &charsOut);
 8017f8e:	f107 0218 	add.w	r2, r7, #24
 8017f92:	f107 0313 	add.w	r3, r7, #19
 8017f96:	7819      	ldrb	r1, [r3, #0]
 8017f98:	f107 030c 	add.w	r3, r7, #12
 8017f9c:	6818      	ldr	r0, [r3, #0]
 8017f9e:	f7fe feb7 	bl	8016d10 <SecWriteChar>
                    state = STAT_NORMAL;
 8017fa2:	f107 0320 	add.w	r3, r7, #32
 8017fa6:	2200      	movs	r2, #0
 8017fa8:	601a      	str	r2, [r3, #0]
                    continue;
 8017faa:	e29a      	b.n	80184e2 <SecOutput+0x7aa>
                }
                break;
            case STAT_TYPE:
                switch (ch) {
 8017fac:	f107 0313 	add.w	r3, r7, #19
 8017fb0:	781b      	ldrb	r3, [r3, #0]
 8017fb2:	3b43      	subs	r3, #67	; 0x43
 8017fb4:	2b35      	cmp	r3, #53	; 0x35
 8017fb6:	f200 824b 	bhi.w	8018450 <SecOutput+0x718>
 8017fba:	a201      	add	r2, pc, #4	; (adr r2, 8017fc0 <SecOutput+0x288>)
 8017fbc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017fc0:	080180a1 	.word	0x080180a1
 8017fc4:	08018451 	.word	0x08018451
 8017fc8:	080180fd 	.word	0x080180fd
 8017fcc:	080180fd 	.word	0x080180fd
 8017fd0:	080180fd 	.word	0x080180fd
 8017fd4:	08018451 	.word	0x08018451
 8017fd8:	08018451 	.word	0x08018451
 8017fdc:	08018451 	.word	0x08018451
 8017fe0:	08018451 	.word	0x08018451
 8017fe4:	08018451 	.word	0x08018451
 8017fe8:	08018451 	.word	0x08018451
 8017fec:	08018451 	.word	0x08018451
 8017ff0:	08018451 	.word	0x08018451
 8017ff4:	08018451 	.word	0x08018451
 8017ff8:	08018451 	.word	0x08018451
 8017ffc:	08018451 	.word	0x08018451
 8018000:	080180cf 	.word	0x080180cf
 8018004:	08018451 	.word	0x08018451
 8018008:	08018451 	.word	0x08018451
 801800c:	08018451 	.word	0x08018451
 8018010:	08018451 	.word	0x08018451
 8018014:	080181b3 	.word	0x080181b3
 8018018:	08018451 	.word	0x08018451
 801801c:	08018451 	.word	0x08018451
 8018020:	08018451 	.word	0x08018451
 8018024:	08018451 	.word	0x08018451
 8018028:	08018451 	.word	0x08018451
 801802c:	08018451 	.word	0x08018451
 8018030:	08018451 	.word	0x08018451
 8018034:	08018451 	.word	0x08018451
 8018038:	08018451 	.word	0x08018451
 801803c:	08018451 	.word	0x08018451
 8018040:	080180ab 	.word	0x080180ab
 8018044:	080181c5 	.word	0x080181c5
 8018048:	080180fd 	.word	0x080180fd
 801804c:	080180fd 	.word	0x080180fd
 8018050:	080180fd 	.word	0x080180fd
 8018054:	08018451 	.word	0x08018451
 8018058:	080181c5 	.word	0x080181c5
 801805c:	08018451 	.word	0x08018451
 8018060:	08018451 	.word	0x08018451
 8018064:	08018451 	.word	0x08018451
 8018068:	08018451 	.word	0x08018451
 801806c:	08018451 	.word	0x08018451
 8018070:	080181c5 	.word	0x080181c5
 8018074:	080181b3 	.word	0x080181b3
 8018078:	08018451 	.word	0x08018451
 801807c:	08018451 	.word	0x08018451
 8018080:	080180d9 	.word	0x080180d9
 8018084:	08018451 	.word	0x08018451
 8018088:	080181c5 	.word	0x080181c5
 801808c:	08018451 	.word	0x08018451
 8018090:	08018451 	.word	0x08018451
 8018094:	080181b3 	.word	0x080181b3
 8018098:	08023050 	.word	0x08023050
 801809c:	080236b4 	.word	0x080236b4
                    case SECUREC_CHAR('C'): /* Wide char */
                        SecUpdateWcharFlags(&formatAttr);
 80180a0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80180a4:	4618      	mov	r0, r3
 80180a6:	f7ff fb55 	bl	8017754 <SecUpdateWcharFlags>
                        /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('c'): {
                        unsigned int cValue = (unsigned int)va_arg(argList, int);
 80180aa:	1d3b      	adds	r3, r7, #4
 80180ac:	681b      	ldr	r3, [r3, #0]
 80180ae:	1d19      	adds	r1, r3, #4
 80180b0:	1d3a      	adds	r2, r7, #4
 80180b2:	6011      	str	r1, [r2, #0]
 80180b4:	681a      	ldr	r2, [r3, #0]
 80180b6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80180ba:	601a      	str	r2, [r3, #0]
                        SecDecodeTypeC(&formatAttr, cValue);
 80180bc:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80180c0:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 80180c4:	6819      	ldr	r1, [r3, #0]
 80180c6:	4610      	mov	r0, r2
 80180c8:	f7ff f9d8 	bl	801747c <SecDecodeTypeC>
                        break;
 80180cc:	e1c5      	b.n	801845a <SecOutput+0x722>
                    }
                    case SECUREC_CHAR('S'):    /* Wide char string */
                        SecUpdateWstringFlags(&formatAttr);
 80180ce:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80180d2:	4618      	mov	r0, r3
 80180d4:	f7ff fb54 	bl	8017780 <SecUpdateWstringFlags>
                        /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('s'): {
                        char *argPtr = (char *)va_arg(argList, char *);
 80180d8:	1d3b      	adds	r3, r7, #4
 80180da:	681b      	ldr	r3, [r3, #0]
 80180dc:	1d19      	adds	r1, r3, #4
 80180de:	1d3a      	adds	r2, r7, #4
 80180e0:	6011      	str	r1, [r2, #0]
 80180e2:	f107 0228 	add.w	r2, r7, #40	; 0x28
 80180e6:	681b      	ldr	r3, [r3, #0]
 80180e8:	6013      	str	r3, [r2, #0]
                        SecDecodeTypeS(&formatAttr, argPtr);
 80180ea:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80180ee:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 80180f2:	6819      	ldr	r1, [r3, #0]
 80180f4:	4610      	mov	r0, r2
 80180f6:	f7ff fa87 	bl	8017608 <SecDecodeTypeS>
                        break;
 80180fa:	e1ae      	b.n	801845a <SecOutput+0x722>
                    case SECUREC_CHAR('e'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('f'): {
#if SECUREC_ENABLE_SPRINTF_FLOAT
                        /* Add following code to call system sprintf API for float number */
                        SecFloatAdapt floatAdapt;
                        noOutput = 1; /* It's no more data needs to be written */
 80180fc:	f107 031c 	add.w	r3, r7, #28
 8018100:	2201      	movs	r2, #1
 8018102:	601a      	str	r2, [r3, #0]

                        /* Now format is pointer to the next character of 'f' */
                        if (SecInitFloatBuffer(&floatAdapt, format, &formatAttr) != 0) {
 8018104:	f107 0314 	add.w	r3, r7, #20
 8018108:	6819      	ldr	r1, [r3, #0]
 801810a:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 801810e:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8018112:	4618      	mov	r0, r3
 8018114:	f7ff fca4 	bl	8017a60 <SecInitFloatBuffer>
 8018118:	4603      	mov	r3, r0
 801811a:	2b00      	cmp	r3, #0
 801811c:	f040 819a 	bne.w	8018454 <SecOutput+0x71c>
                            break;
                        }

                        if ((formatAttr.flags & SECUREC_FLAG_LONG_DOUBLE) != 0) {
 8018120:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018124:	695b      	ldr	r3, [r3, #20]
 8018126:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801812a:	2b00      	cmp	r3, #0
 801812c:	d019      	beq.n	8018162 <SecOutput+0x42a>
#if defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && SECUREC_ENABLE_SPRINTF_LONG_DOUBLE
                            long double tmp = (long double)va_arg(argList, long double);
 801812e:	1d3b      	adds	r3, r7, #4
 8018130:	681b      	ldr	r3, [r3, #0]
 8018132:	3307      	adds	r3, #7
 8018134:	f023 0307 	bic.w	r3, r3, #7
 8018138:	f103 0108 	add.w	r1, r3, #8
 801813c:	1d3a      	adds	r2, r7, #4
 801813e:	6011      	str	r1, [r2, #0]
 8018140:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8018144:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018148:	e9c1 2300 	strd	r2, r3, [r1]
                            SecFormatLongDouble(&formatAttr, &floatAdapt, tmp);
 801814c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8018150:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8018154:	f107 006c 	add.w	r0, r7, #108	; 0x6c
 8018158:	e9d3 2300 	ldrd	r2, r3, [r3]
 801815c:	f7fe fad0 	bl	8016700 <SecFormatLongDouble>
 8018160:	e018      	b.n	8018194 <SecOutput+0x45c>
#else
                            double tmp = (double)va_arg(argList, double);
                            SecFormatDouble(&formatAttr, &floatAdapt, tmp);
#endif
                        } else {
                            double tmp = (double)va_arg(argList, double);
 8018162:	1d3b      	adds	r3, r7, #4
 8018164:	681b      	ldr	r3, [r3, #0]
 8018166:	3307      	adds	r3, #7
 8018168:	f023 0307 	bic.w	r3, r3, #7
 801816c:	f103 0108 	add.w	r1, r3, #8
 8018170:	1d3a      	adds	r2, r7, #4
 8018172:	6011      	str	r1, [r2, #0]
 8018174:	f107 0138 	add.w	r1, r7, #56	; 0x38
 8018178:	e9d3 2300 	ldrd	r2, r3, [r3]
 801817c:	e9c1 2300 	strd	r2, r3, [r1]
                            SecFormatDouble(&formatAttr, &floatAdapt, tmp);
 8018180:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8018184:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8018188:	f107 006c 	add.w	r0, r7, #108	; 0x6c
 801818c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018190:	f7fe fb28 	bl	80167e4 <SecFormatDouble>
                        }

                        /* Only need write formatted float string */
                        SecWriteFloatText(stream, &formatAttr, &charsOut);
 8018194:	f107 0218 	add.w	r2, r7, #24
 8018198:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 801819c:	f107 030c 	add.w	r3, r7, #12
 80181a0:	6818      	ldr	r0, [r3, #0]
 80181a2:	f7fe ff8f 	bl	80170c4 <SecWriteFloatText>
                        SecFreeFloatBuffer(&floatAdapt);
 80181a6:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80181aa:	4618      	mov	r0, r3
 80181ac:	f7ff fbbe 	bl	801792c <SecFreeFloatBuffer>
                        break;
 80181b0:	e153      	b.n	801845a <SecOutput+0x722>
#endif
                    }
                    case SECUREC_CHAR('X'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('p'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('x'): /* fall-through */ /* FALLTHRU */
                        SecUpdateXpxFlags(&formatAttr, ch);
 80181b2:	f107 0313 	add.w	r3, r7, #19
 80181b6:	781a      	ldrb	r2, [r3, #0]
 80181b8:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80181bc:	4611      	mov	r1, r2
 80181be:	4618      	mov	r0, r3
 80181c0:	f7ff fb20 	bl	8017804 <SecUpdateXpxFlags>
                    case SECUREC_CHAR('i'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('d'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('u'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('o'): {
                        SecInt64 num64;
                        SecUpdateOudiFlags(&formatAttr, ch);
 80181c4:	f107 0313 	add.w	r3, r7, #19
 80181c8:	781a      	ldrb	r2, [r3, #0]
 80181ca:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80181ce:	4611      	mov	r1, r2
 80181d0:	4618      	mov	r0, r3
 80181d2:	f7ff fb4d 	bl	8017870 <SecUpdateOudiFlags>
                        /* Read argument into variable num64. Be careful, depend on the order of judgment */
                        if ((formatAttr.flags & SECUREC_FLAG_I64) != 0 ||
 80181d6:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80181da:	695b      	ldr	r3, [r3, #20]
 80181dc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80181e0:	2b00      	cmp	r3, #0
 80181e2:	d106      	bne.n	80181f2 <SecOutput+0x4ba>
                            (formatAttr.flags & SECUREC_FLAG_LONGLONG) != 0) {
 80181e4:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80181e8:	695b      	ldr	r3, [r3, #20]
 80181ea:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
                        if ((formatAttr.flags & SECUREC_FLAG_I64) != 0 ||
 80181ee:	2b00      	cmp	r3, #0
 80181f0:	d00d      	beq.n	801820e <SecOutput+0x4d6>
                            num64 = (SecInt64)va_arg(argList, SecInt64); /* Maximum Bit Width sign bit unchanged */
 80181f2:	1d3b      	adds	r3, r7, #4
 80181f4:	681b      	ldr	r3, [r3, #0]
 80181f6:	3307      	adds	r3, #7
 80181f8:	f023 0307 	bic.w	r3, r3, #7
 80181fc:	f103 0108 	add.w	r1, r3, #8
 8018200:	1d3a      	adds	r2, r7, #4
 8018202:	6011      	str	r1, [r2, #0]
 8018204:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018208:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 801820c:	e100      	b.n	8018410 <SecOutput+0x6d8>
                        } else if ((formatAttr.flags & SECUREC_FLAG_LONG) != 0) {
 801820e:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018212:	695b      	ldr	r3, [r3, #20]
 8018214:	f003 0310 	and.w	r3, r3, #16
 8018218:	2b00      	cmp	r3, #0
 801821a:	d01c      	beq.n	8018256 <SecOutput+0x51e>
                            num64 = SECUREC_GET_LONG_FROM_ARG(formatAttr);
 801821c:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018220:	695b      	ldr	r3, [r3, #20]
 8018222:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8018226:	2b00      	cmp	r3, #0
 8018228:	d009      	beq.n	801823e <SecOutput+0x506>
 801822a:	1d3b      	adds	r3, r7, #4
 801822c:	681b      	ldr	r3, [r3, #0]
 801822e:	1d19      	adds	r1, r3, #4
 8018230:	1d3a      	adds	r2, r7, #4
 8018232:	6011      	str	r1, [r2, #0]
 8018234:	681b      	ldr	r3, [r3, #0]
 8018236:	461a      	mov	r2, r3
 8018238:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801823c:	e008      	b.n	8018250 <SecOutput+0x518>
 801823e:	1d3b      	adds	r3, r7, #4
 8018240:	681b      	ldr	r3, [r3, #0]
 8018242:	1d19      	adds	r1, r3, #4
 8018244:	1d3a      	adds	r2, r7, #4
 8018246:	6011      	str	r1, [r2, #0]
 8018248:	681b      	ldr	r3, [r3, #0]
 801824a:	461a      	mov	r2, r3
 801824c:	f04f 0300 	mov.w	r3, #0
 8018250:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8018254:	e0dc      	b.n	8018410 <SecOutput+0x6d8>
                        } else if ((formatAttr.flags & SECUREC_FLAG_CHAR) != 0) {
 8018256:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801825a:	695b      	ldr	r3, [r3, #20]
 801825c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8018260:	2b00      	cmp	r3, #0
 8018262:	d023      	beq.n	80182ac <SecOutput+0x574>
                            num64 = SECUREC_GET_CHAR_FROM_ARG(formatAttr);
 8018264:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018268:	695b      	ldr	r3, [r3, #20]
 801826a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801826e:	2b00      	cmp	r3, #0
 8018270:	d00f      	beq.n	8018292 <SecOutput+0x55a>
 8018272:	1d3b      	adds	r3, r7, #4
 8018274:	681b      	ldr	r3, [r3, #0]
 8018276:	1d19      	adds	r1, r3, #4
 8018278:	1d3a      	adds	r2, r7, #4
 801827a:	6011      	str	r1, [r2, #0]
 801827c:	681b      	ldr	r3, [r3, #0]
 801827e:	b2da      	uxtb	r2, r3
 8018280:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018284:	4611      	mov	r1, r2
 8018286:	4618      	mov	r0, r3
 8018288:	f7ff fc6c 	bl	8017b64 <SecUpdateNegativeChar>
 801828c:	4602      	mov	r2, r0
 801828e:	460b      	mov	r3, r1
 8018290:	e009      	b.n	80182a6 <SecOutput+0x56e>
 8018292:	1d3b      	adds	r3, r7, #4
 8018294:	681b      	ldr	r3, [r3, #0]
 8018296:	1d19      	adds	r1, r3, #4
 8018298:	1d3a      	adds	r2, r7, #4
 801829a:	6011      	str	r1, [r2, #0]
 801829c:	681b      	ldr	r3, [r3, #0]
 801829e:	b2db      	uxtb	r3, r3
 80182a0:	b2da      	uxtb	r2, r3
 80182a2:	f04f 0300 	mov.w	r3, #0
 80182a6:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80182aa:	e0b1      	b.n	8018410 <SecOutput+0x6d8>
                        } else if ((formatAttr.flags & SECUREC_FLAG_SHORT) != 0) {
 80182ac:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80182b0:	695b      	ldr	r3, [r3, #20]
 80182b2:	f003 0320 	and.w	r3, r3, #32
 80182b6:	2b00      	cmp	r3, #0
 80182b8:	d01e      	beq.n	80182f8 <SecOutput+0x5c0>
                            num64 = SECUREC_GET_SHORT_FROM_ARG(formatAttr);
 80182ba:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80182be:	695b      	ldr	r3, [r3, #20]
 80182c0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80182c4:	2b00      	cmp	r3, #0
 80182c6:	d00a      	beq.n	80182de <SecOutput+0x5a6>
 80182c8:	1d3b      	adds	r3, r7, #4
 80182ca:	681b      	ldr	r3, [r3, #0]
 80182cc:	1d19      	adds	r1, r3, #4
 80182ce:	1d3a      	adds	r2, r7, #4
 80182d0:	6011      	str	r1, [r2, #0]
 80182d2:	681b      	ldr	r3, [r3, #0]
 80182d4:	b21b      	sxth	r3, r3
 80182d6:	b21a      	sxth	r2, r3
 80182d8:	ea4f 73e2 	mov.w	r3, r2, asr #31
 80182dc:	e009      	b.n	80182f2 <SecOutput+0x5ba>
 80182de:	1d3b      	adds	r3, r7, #4
 80182e0:	681b      	ldr	r3, [r3, #0]
 80182e2:	1d19      	adds	r1, r3, #4
 80182e4:	1d3a      	adds	r2, r7, #4
 80182e6:	6011      	str	r1, [r2, #0]
 80182e8:	681b      	ldr	r3, [r3, #0]
 80182ea:	b29b      	uxth	r3, r3
 80182ec:	b29a      	uxth	r2, r3
 80182ee:	f04f 0300 	mov.w	r3, #0
 80182f2:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80182f6:	e08b      	b.n	8018410 <SecOutput+0x6d8>
#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
                        } else if ((formatAttr.flags & SECUREC_FLAG_PTRDIFF) != 0) {
 80182f8:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80182fc:	695b      	ldr	r3, [r3, #20]
 80182fe:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8018302:	2b00      	cmp	r3, #0
 8018304:	d00b      	beq.n	801831e <SecOutput+0x5e6>
                            num64 = (ptrdiff_t)va_arg(argList, ptrdiff_t);  /* Sign extend */
 8018306:	1d3b      	adds	r3, r7, #4
 8018308:	681b      	ldr	r3, [r3, #0]
 801830a:	1d19      	adds	r1, r3, #4
 801830c:	1d3a      	adds	r2, r7, #4
 801830e:	6011      	str	r1, [r2, #0]
 8018310:	681b      	ldr	r3, [r3, #0]
 8018312:	461a      	mov	r2, r3
 8018314:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8018318:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 801831c:	e078      	b.n	8018410 <SecOutput+0x6d8>
                        } else if ((formatAttr.flags & SECUREC_FLAG_SIZE) != 0) {
 801831e:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018322:	695b      	ldr	r3, [r3, #20]
 8018324:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8018328:	2b00      	cmp	r3, #0
 801832a:	d040      	beq.n	80183ae <SecOutput+0x676>
                            num64 = SECUREC_GET_SIZE_FROM_ARG(formatAttr);
 801832c:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018330:	695b      	ldr	r3, [r3, #20]
 8018332:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8018336:	2b00      	cmp	r3, #0
 8018338:	d02d      	beq.n	8018396 <SecOutput+0x65e>
 801833a:	2104      	movs	r1, #4
 801833c:	2004      	movs	r0, #4
 801833e:	f7fe fac3 	bl	80168c8 <SecIsSameSize>
 8018342:	4603      	mov	r3, r0
 8018344:	2b00      	cmp	r3, #0
 8018346:	d009      	beq.n	801835c <SecOutput+0x624>
 8018348:	1d3b      	adds	r3, r7, #4
 801834a:	681b      	ldr	r3, [r3, #0]
 801834c:	1d19      	adds	r1, r3, #4
 801834e:	1d3a      	adds	r2, r7, #4
 8018350:	6011      	str	r1, [r2, #0]
 8018352:	681b      	ldr	r3, [r3, #0]
 8018354:	461a      	mov	r2, r3
 8018356:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801835a:	e025      	b.n	80183a8 <SecOutput+0x670>
 801835c:	2108      	movs	r1, #8
 801835e:	2004      	movs	r0, #4
 8018360:	f7fe fab2 	bl	80168c8 <SecIsSameSize>
 8018364:	4603      	mov	r3, r0
 8018366:	2b00      	cmp	r3, #0
 8018368:	d00b      	beq.n	8018382 <SecOutput+0x64a>
 801836a:	1d3b      	adds	r3, r7, #4
 801836c:	681b      	ldr	r3, [r3, #0]
 801836e:	3307      	adds	r3, #7
 8018370:	f023 0307 	bic.w	r3, r3, #7
 8018374:	f103 0108 	add.w	r1, r3, #8
 8018378:	1d3a      	adds	r2, r7, #4
 801837a:	6011      	str	r1, [r2, #0]
 801837c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018380:	e012      	b.n	80183a8 <SecOutput+0x670>
 8018382:	1d3b      	adds	r3, r7, #4
 8018384:	681b      	ldr	r3, [r3, #0]
 8018386:	1d19      	adds	r1, r3, #4
 8018388:	1d3a      	adds	r2, r7, #4
 801838a:	6011      	str	r1, [r2, #0]
 801838c:	681b      	ldr	r3, [r3, #0]
 801838e:	461a      	mov	r2, r3
 8018390:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8018394:	e008      	b.n	80183a8 <SecOutput+0x670>
 8018396:	1d3b      	adds	r3, r7, #4
 8018398:	681b      	ldr	r3, [r3, #0]
 801839a:	1d19      	adds	r1, r3, #4
 801839c:	1d3a      	adds	r2, r7, #4
 801839e:	6011      	str	r1, [r2, #0]
 80183a0:	681b      	ldr	r3, [r3, #0]
 80183a2:	461a      	mov	r2, r3
 80183a4:	f04f 0300 	mov.w	r3, #0
 80183a8:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80183ac:	e030      	b.n	8018410 <SecOutput+0x6d8>
                        } else if ((formatAttr.flags & SECUREC_FLAG_INTMAX) != 0) {
 80183ae:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80183b2:	695b      	ldr	r3, [r3, #20]
 80183b4:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80183b8:	2b00      	cmp	r3, #0
 80183ba:	d00d      	beq.n	80183d8 <SecOutput+0x6a0>
                            num64 = (SecInt64)va_arg(argList, SecInt64);
 80183bc:	1d3b      	adds	r3, r7, #4
 80183be:	681b      	ldr	r3, [r3, #0]
 80183c0:	3307      	adds	r3, #7
 80183c2:	f023 0307 	bic.w	r3, r3, #7
 80183c6:	f103 0108 	add.w	r1, r3, #8
 80183ca:	1d3a      	adds	r2, r7, #4
 80183cc:	6011      	str	r1, [r2, #0]
 80183ce:	e9d3 2300 	ldrd	r2, r3, [r3]
 80183d2:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 80183d6:	e01b      	b.n	8018410 <SecOutput+0x6d8>
#endif
                        } else {
                            num64 = SECUREC_GET_INT_FROM_ARG(formatAttr);
 80183d8:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80183dc:	695b      	ldr	r3, [r3, #20]
 80183de:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80183e2:	2b00      	cmp	r3, #0
 80183e4:	d009      	beq.n	80183fa <SecOutput+0x6c2>
 80183e6:	1d3b      	adds	r3, r7, #4
 80183e8:	681b      	ldr	r3, [r3, #0]
 80183ea:	1d19      	adds	r1, r3, #4
 80183ec:	1d3a      	adds	r2, r7, #4
 80183ee:	6011      	str	r1, [r2, #0]
 80183f0:	681b      	ldr	r3, [r3, #0]
 80183f2:	461a      	mov	r2, r3
 80183f4:	ea4f 73e2 	mov.w	r3, r2, asr #31
 80183f8:	e008      	b.n	801840c <SecOutput+0x6d4>
 80183fa:	1d3b      	adds	r3, r7, #4
 80183fc:	681b      	ldr	r3, [r3, #0]
 80183fe:	1d19      	adds	r1, r3, #4
 8018400:	1d3a      	adds	r2, r7, #4
 8018402:	6011      	str	r1, [r2, #0]
 8018404:	681b      	ldr	r3, [r3, #0]
 8018406:	461a      	mov	r2, r3
 8018408:	f04f 0300 	mov.w	r3, #0
 801840c:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
                        }

                        /* The order of the following calls must be correct */
                        SecNumberToBuffer(&formatAttr, num64);
 8018410:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018414:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 8018418:	4608      	mov	r0, r1
 801841a:	f7fe fc23 	bl	8016c64 <SecNumberToBuffer>
                        SecNumberSatisfyPrecision(&formatAttr);
 801841e:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018422:	4618      	mov	r0, r3
 8018424:	f7ff fbc8 	bl	8017bb8 <SecNumberSatisfyPrecision>
                        SecNumberForceOctal(&formatAttr);
 8018428:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801842c:	4618      	mov	r0, r3
 801842e:	f7ff fc01 	bl	8017c34 <SecNumberForceOctal>
                        SecUpdateSignedNumberPrefix(&formatAttr);
 8018432:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018436:	4618      	mov	r0, r3
 8018438:	f7ff fc23 	bl	8017c82 <SecUpdateSignedNumberPrefix>
                        if (num64 == 0) {
 801843c:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 8018440:	4313      	orrs	r3, r2
 8018442:	d109      	bne.n	8018458 <SecOutput+0x720>
                            SecNumberCompatZero(&formatAttr);
 8018444:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018448:	4618      	mov	r0, r3
 801844a:	f7ff fc57 	bl	8017cfc <SecNumberCompatZero>
                        }
                        break;
 801844e:	e003      	b.n	8018458 <SecOutput+0x720>
                    }
                    default:
                        /* Do nothing */
                        break;
 8018450:	bf00      	nop
 8018452:	e002      	b.n	801845a <SecOutput+0x722>
                            break;
 8018454:	bf00      	nop
 8018456:	e000      	b.n	801845a <SecOutput+0x722>
                        break;
 8018458:	bf00      	nop
                }

                if (noOutput == 0) {
 801845a:	f107 031c 	add.w	r3, r7, #28
 801845e:	681b      	ldr	r3, [r3, #0]
 8018460:	2b00      	cmp	r3, #0
 8018462:	d13e      	bne.n	80184e2 <SecOutput+0x7aa>
                    /* Calculate amount of padding */
                    formatAttr.padding = (formatAttr.fldWidth - formatAttr.textLen) - formatAttr.prefixLen;
 8018464:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018468:	699a      	ldr	r2, [r3, #24]
 801846a:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801846e:	689b      	ldr	r3, [r3, #8]
 8018470:	1ad2      	subs	r2, r2, r3
 8018472:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018476:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8018478:	1ad2      	subs	r2, r2, r3
 801847a:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801847e:	629a      	str	r2, [r3, #40]	; 0x28

                    /* Put out the padding, prefix, and text, in the correct order */
                    SecWriteLeftPadding(stream, &formatAttr, &charsOut);
 8018480:	f107 0218 	add.w	r2, r7, #24
 8018484:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018488:	f107 030c 	add.w	r3, r7, #12
 801848c:	6818      	ldr	r0, [r3, #0]
 801848e:	f7fe fd5c 	bl	8016f4a <SecWriteLeftPadding>
                    SecWritePrefix(stream, &formatAttr, &charsOut);
 8018492:	f107 0218 	add.w	r2, r7, #24
 8018496:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 801849a:	f107 030c 	add.w	r3, r7, #12
 801849e:	6818      	ldr	r0, [r3, #0]
 80184a0:	f7fe fd6e 	bl	8016f80 <SecWritePrefix>
                    SecWriteLeadingZero(stream, &formatAttr, &charsOut);
 80184a4:	f107 0218 	add.w	r2, r7, #24
 80184a8:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 80184ac:	f107 030c 	add.w	r3, r7, #12
 80184b0:	6818      	ldr	r0, [r3, #0]
 80184b2:	f7fe fd7c 	bl	8016fae <SecWriteLeadingZero>
                    SecWriteText(stream, &formatAttr, &charsOut);
 80184b6:	f107 0218 	add.w	r2, r7, #24
 80184ba:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 80184be:	f107 030c 	add.w	r3, r7, #12
 80184c2:	6818      	ldr	r0, [r3, #0]
 80184c4:	f7fe fe10 	bl	80170e8 <SecWriteText>
                    SecWriteRightPadding(stream, &formatAttr, &charsOut);
 80184c8:	f107 0218 	add.w	r2, r7, #24
 80184cc:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 80184d0:	f107 030c 	add.w	r3, r7, #12
 80184d4:	6818      	ldr	r0, [r3, #0]
 80184d6:	f7fe fd8b 	bl	8016ff0 <SecWriteRightPadding>
                }
                break;
 80184da:	e002      	b.n	80184e2 <SecOutput+0x7aa>
            case STAT_INVALID: /* fall-through */ /* FALLTHRU */
            default:
                return -1;  /* Input format is wrong(STAT_INVALID), directly return */
 80184dc:	f04f 33ff 	mov.w	r3, #4294967295
 80184e0:	e01b      	b.n	801851a <SecOutput+0x7e2>
    while (*format != SECUREC_CHAR('\0') && charsOut >= 0) {
 80184e2:	f107 0314 	add.w	r3, r7, #20
 80184e6:	681b      	ldr	r3, [r3, #0]
 80184e8:	781b      	ldrb	r3, [r3, #0]
 80184ea:	2b00      	cmp	r3, #0
 80184ec:	d005      	beq.n	80184fa <SecOutput+0x7c2>
 80184ee:	f107 0318 	add.w	r3, r7, #24
 80184f2:	681b      	ldr	r3, [r3, #0]
 80184f4:	2b00      	cmp	r3, #0
 80184f6:	f6bf ac7e 	bge.w	8017df6 <SecOutput+0xbe>
        }
    }

    if (state != STAT_NORMAL && state != STAT_TYPE) {
 80184fa:	f107 0320 	add.w	r3, r7, #32
 80184fe:	681b      	ldr	r3, [r3, #0]
 8018500:	2b00      	cmp	r3, #0
 8018502:	d007      	beq.n	8018514 <SecOutput+0x7dc>
 8018504:	f107 0320 	add.w	r3, r7, #32
 8018508:	681b      	ldr	r3, [r3, #0]
 801850a:	2b07      	cmp	r3, #7
 801850c:	d002      	beq.n	8018514 <SecOutput+0x7dc>
        return -1;
 801850e:	f04f 33ff 	mov.w	r3, #4294967295
 8018512:	e002      	b.n	801851a <SecOutput+0x7e2>
    }

    return charsOut;            /* The number of characters written */
 8018514:	f107 0318 	add.w	r3, r7, #24
 8018518:	681b      	ldr	r3, [r3, #0]
}
 801851a:	4a06      	ldr	r2, [pc, #24]	; (8018534 <SecOutput+0x7fc>)
 801851c:	6811      	ldr	r1, [r2, #0]
 801851e:	f8d7 22a4 	ldr.w	r2, [r7, #676]	; 0x2a4
 8018522:	4051      	eors	r1, r2
 8018524:	d001      	beq.n	801852a <SecOutput+0x7f2>
 8018526:	f7eb ff5f 	bl	80043e8 <__stack_chk_fail>
 801852a:	4618      	mov	r0, r3
 801852c:	f507 772b 	add.w	r7, r7, #684	; 0x2ac
 8018530:	46bd      	mov	sp, r7
 8018532:	bd90      	pop	{r4, r7, pc}
 8018534:	08023050 	.word	0x08023050

08018538 <SecPutZeroChar>:
/*
 * Output one zero character zero into the SecPrintfStream structure
 * If there is not enough space, make sure f->count is less than 0
 */
SECUREC_INLINE int SecPutZeroChar(SecPrintfStream *stream)
{
 8018538:	b480      	push	{r7}
 801853a:	b083      	sub	sp, #12
 801853c:	af00      	add	r7, sp, #0
 801853e:	6078      	str	r0, [r7, #4]
    --stream->count;
 8018540:	687b      	ldr	r3, [r7, #4]
 8018542:	681b      	ldr	r3, [r3, #0]
 8018544:	1e5a      	subs	r2, r3, #1
 8018546:	687b      	ldr	r3, [r7, #4]
 8018548:	601a      	str	r2, [r3, #0]
    if (stream->count >= 0) {
 801854a:	687b      	ldr	r3, [r7, #4]
 801854c:	681b      	ldr	r3, [r3, #0]
 801854e:	2b00      	cmp	r3, #0
 8018550:	db0a      	blt.n	8018568 <SecPutZeroChar+0x30>
        *(stream->cur) = SECUREC_CHAR('\0');
 8018552:	687b      	ldr	r3, [r7, #4]
 8018554:	685b      	ldr	r3, [r3, #4]
 8018556:	2200      	movs	r2, #0
 8018558:	701a      	strb	r2, [r3, #0]
        ++stream->cur;
 801855a:	687b      	ldr	r3, [r7, #4]
 801855c:	685b      	ldr	r3, [r3, #4]
 801855e:	1c5a      	adds	r2, r3, #1
 8018560:	687b      	ldr	r3, [r7, #4]
 8018562:	605a      	str	r2, [r3, #4]
        return 0;
 8018564:	2300      	movs	r3, #0
 8018566:	e001      	b.n	801856c <SecPutZeroChar+0x34>
    }
    return -1;
 8018568:	f04f 33ff 	mov.w	r3, #4294967295
}
 801856c:	4618      	mov	r0, r3
 801856e:	370c      	adds	r7, #12
 8018570:	46bd      	mov	sp, r7
 8018572:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018576:	4770      	bx	lr

08018578 <SecVsnprintfImpl>:
#ifdef SECUREC_FOR_WCHAR
int SecVswprintfImpl(wchar_t *string, size_t count, const wchar_t *format, va_list argList)
#else
int SecVsnprintfImpl(char *string, size_t count, const char *format, va_list argList)
#endif
{
 8018578:	b580      	push	{r7, lr}
 801857a:	b088      	sub	sp, #32
 801857c:	af00      	add	r7, sp, #0
 801857e:	60f8      	str	r0, [r7, #12]
 8018580:	60b9      	str	r1, [r7, #8]
 8018582:	607a      	str	r2, [r7, #4]
 8018584:	603b      	str	r3, [r7, #0]
 8018586:	4b1d      	ldr	r3, [pc, #116]	; (80185fc <SecVsnprintfImpl+0x84>)
 8018588:	681b      	ldr	r3, [r3, #0]
 801858a:	61fb      	str	r3, [r7, #28]
 801858c:	f04f 0300 	mov.w	r3, #0
    SecPrintfStream stream;
    int retVal;

    stream.count = (int)count; /* The count include \0 character, must be greater than zero */
 8018590:	68bb      	ldr	r3, [r7, #8]
 8018592:	617b      	str	r3, [r7, #20]
    stream.cur = string;
 8018594:	68fb      	ldr	r3, [r7, #12]
 8018596:	61bb      	str	r3, [r7, #24]

    retVal = SecOutput(&stream, format, argList);
 8018598:	f107 0314 	add.w	r3, r7, #20
 801859c:	683a      	ldr	r2, [r7, #0]
 801859e:	6879      	ldr	r1, [r7, #4]
 80185a0:	4618      	mov	r0, r3
 80185a2:	f7ff fbc9 	bl	8017d38 <SecOutput>
 80185a6:	6138      	str	r0, [r7, #16]
    if (retVal >= 0) {
 80185a8:	693b      	ldr	r3, [r7, #16]
 80185aa:	2b00      	cmp	r3, #0
 80185ac:	db09      	blt.n	80185c2 <SecVsnprintfImpl+0x4a>
        if (SecPutZeroChar(&stream) == 0) {
 80185ae:	f107 0314 	add.w	r3, r7, #20
 80185b2:	4618      	mov	r0, r3
 80185b4:	f7ff ffc0 	bl	8018538 <SecPutZeroChar>
 80185b8:	4603      	mov	r3, r0
 80185ba:	2b00      	cmp	r3, #0
 80185bc:	d101      	bne.n	80185c2 <SecVsnprintfImpl+0x4a>
            return retVal;
 80185be:	693b      	ldr	r3, [r7, #16]
 80185c0:	e010      	b.n	80185e4 <SecVsnprintfImpl+0x6c>
        }
    }
    if (stream.count < 0) {
 80185c2:	697b      	ldr	r3, [r7, #20]
 80185c4:	2b00      	cmp	r3, #0
 80185c6:	da08      	bge.n	80185da <SecVsnprintfImpl+0x62>
        /* The buffer was too small, then truncate */
        string[count - 1] = SECUREC_CHAR('\0');
 80185c8:	68bb      	ldr	r3, [r7, #8]
 80185ca:	3b01      	subs	r3, #1
 80185cc:	68fa      	ldr	r2, [r7, #12]
 80185ce:	4413      	add	r3, r2
 80185d0:	2200      	movs	r2, #0
 80185d2:	701a      	strb	r2, [r3, #0]
        return SECUREC_PRINTF_TRUNCATE;
 80185d4:	f06f 0301 	mvn.w	r3, #1
 80185d8:	e004      	b.n	80185e4 <SecVsnprintfImpl+0x6c>
    }
    string[0] = SECUREC_CHAR('\0'); /* Empty the dest string */
 80185da:	68fb      	ldr	r3, [r7, #12]
 80185dc:	2200      	movs	r2, #0
 80185de:	701a      	strb	r2, [r3, #0]
    return -1;
 80185e0:	f04f 33ff 	mov.w	r3, #4294967295
}
 80185e4:	4a05      	ldr	r2, [pc, #20]	; (80185fc <SecVsnprintfImpl+0x84>)
 80185e6:	6811      	ldr	r1, [r2, #0]
 80185e8:	69fa      	ldr	r2, [r7, #28]
 80185ea:	4051      	eors	r1, r2
 80185ec:	d001      	beq.n	80185f2 <SecVsnprintfImpl+0x7a>
 80185ee:	f7eb fefb 	bl	80043e8 <__stack_chk_fail>
 80185f2:	4618      	mov	r0, r3
 80185f4:	3720      	adds	r7, #32
 80185f6:	46bd      	mov	sp, r7
 80185f8:	bd80      	pop	{r7, pc}
 80185fa:	bf00      	nop
 80185fc:	08023054 	.word	0x08023054

08018600 <LOS_ListInit>:
{
 8018600:	b480      	push	{r7}
 8018602:	b083      	sub	sp, #12
 8018604:	af00      	add	r7, sp, #0
 8018606:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 8018608:	687b      	ldr	r3, [r7, #4]
 801860a:	687a      	ldr	r2, [r7, #4]
 801860c:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 801860e:	687b      	ldr	r3, [r7, #4]
 8018610:	687a      	ldr	r2, [r7, #4]
 8018612:	601a      	str	r2, [r3, #0]
}
 8018614:	bf00      	nop
 8018616:	370c      	adds	r7, #12
 8018618:	46bd      	mov	sp, r7
 801861a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801861e:	4770      	bx	lr

08018620 <LOS_ListEmpty>:
{
 8018620:	b480      	push	{r7}
 8018622:	b083      	sub	sp, #12
 8018624:	af00      	add	r7, sp, #0
 8018626:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8018628:	687b      	ldr	r3, [r7, #4]
 801862a:	685b      	ldr	r3, [r3, #4]
 801862c:	687a      	ldr	r2, [r7, #4]
 801862e:	429a      	cmp	r2, r3
 8018630:	bf0c      	ite	eq
 8018632:	2301      	moveq	r3, #1
 8018634:	2300      	movne	r3, #0
 8018636:	b2db      	uxtb	r3, r3
}
 8018638:	4618      	mov	r0, r3
 801863a:	370c      	adds	r7, #12
 801863c:	46bd      	mov	sp, r7
 801863e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018642:	4770      	bx	lr

08018644 <ArchCurrCpuid>:
{
 8018644:	b480      	push	{r7}
 8018646:	af00      	add	r7, sp, #0
    return 0;
 8018648:	2300      	movs	r3, #0
}
 801864a:	4618      	mov	r0, r3
 801864c:	46bd      	mov	sp, r7
 801864e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018652:	4770      	bx	lr

08018654 <ArchIntLocked>:
{
 8018654:	b480      	push	{r7}
 8018656:	b083      	sub	sp, #12
 8018658:	af00      	add	r7, sp, #0
    __asm__ volatile("mrs %0, primask" : "=r" (intSave) : : "memory");
 801865a:	f3ef 8310 	mrs	r3, PRIMASK
 801865e:	607b      	str	r3, [r7, #4]
    return intSave;
 8018660:	687b      	ldr	r3, [r7, #4]
}
 8018662:	4618      	mov	r0, r3
 8018664:	370c      	adds	r7, #12
 8018666:	46bd      	mov	sp, r7
 8018668:	f85d 7b04 	ldr.w	r7, [sp], #4
 801866c:	4770      	bx	lr

0801866e <LOS_IntLock>:
{
 801866e:	b580      	push	{r7, lr}
 8018670:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8018672:	f7e8 fb29 	bl	8000cc8 <ArchIntLock>
 8018676:	4603      	mov	r3, r0
}
 8018678:	4618      	mov	r0, r3
 801867a:	bd80      	pop	{r7, pc}

0801867c <LOS_IntRestore>:
{
 801867c:	b580      	push	{r7, lr}
 801867e:	b082      	sub	sp, #8
 8018680:	af00      	add	r7, sp, #0
 8018682:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8018684:	6878      	ldr	r0, [r7, #4]
 8018686:	f7e8 fb27 	bl	8000cd8 <ArchIntRestore>
}
 801868a:	bf00      	nop
 801868c:	3708      	adds	r7, #8
 801868e:	46bd      	mov	sp, r7
 8018690:	bd80      	pop	{r7, pc}
	...

08018694 <ArchCurrTaskGet>:
{
 8018694:	b480      	push	{r7}
 8018696:	af00      	add	r7, sp, #0
    return g_runTask;
 8018698:	4b03      	ldr	r3, [pc, #12]	; (80186a8 <ArchCurrTaskGet+0x14>)
 801869a:	681b      	ldr	r3, [r3, #0]
}
 801869c:	4618      	mov	r0, r3
 801869e:	46bd      	mov	sp, r7
 80186a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80186a4:	4770      	bx	lr
 80186a6:	bf00      	nop
 80186a8:	200033bc 	.word	0x200033bc

080186ac <OsPercpuGet>:
{
 80186ac:	b580      	push	{r7, lr}
 80186ae:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 80186b0:	f7ff ffc8 	bl	8018644 <ArchCurrCpuid>
 80186b4:	4602      	mov	r2, r0
 80186b6:	4613      	mov	r3, r2
 80186b8:	00db      	lsls	r3, r3, #3
 80186ba:	4413      	add	r3, r2
 80186bc:	009b      	lsls	r3, r3, #2
 80186be:	4a02      	ldr	r2, [pc, #8]	; (80186c8 <OsPercpuGet+0x1c>)
 80186c0:	4413      	add	r3, r2
}
 80186c2:	4618      	mov	r0, r3
 80186c4:	bd80      	pop	{r7, pc}
 80186c6:	bf00      	nop
 80186c8:	200036fc 	.word	0x200036fc

080186cc <OsPreemptableInSched>:
{
 80186cc:	b580      	push	{r7, lr}
 80186ce:	b082      	sub	sp, #8
 80186d0:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 80186d2:	2300      	movs	r3, #0
 80186d4:	607b      	str	r3, [r7, #4]
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 80186d6:	f7ff ffe9 	bl	80186ac <OsPercpuGet>
 80186da:	4603      	mov	r3, r0
 80186dc:	695b      	ldr	r3, [r3, #20]
 80186de:	2b00      	cmp	r3, #0
 80186e0:	bf0c      	ite	eq
 80186e2:	2301      	moveq	r3, #1
 80186e4:	2300      	movne	r3, #0
 80186e6:	b2db      	uxtb	r3, r3
 80186e8:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 80186ea:	687b      	ldr	r3, [r7, #4]
 80186ec:	2b00      	cmp	r3, #0
 80186ee:	d104      	bne.n	80186fa <OsPreemptableInSched+0x2e>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 80186f0:	f7ff ffdc 	bl	80186ac <OsPercpuGet>
 80186f4:	4603      	mov	r3, r0
 80186f6:	2201      	movs	r2, #1
 80186f8:	621a      	str	r2, [r3, #32]
    return preemptable;
 80186fa:	687b      	ldr	r3, [r7, #4]
}
 80186fc:	4618      	mov	r0, r3
 80186fe:	3708      	adds	r7, #8
 8018700:	46bd      	mov	sp, r7
 8018702:	bd80      	pop	{r7, pc}

08018704 <LOS_Schedule>:
{
 8018704:	b580      	push	{r7, lr}
 8018706:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 8018708:	f7e9 feb0 	bl	800246c <IntActive>
 801870c:	4603      	mov	r3, r0
 801870e:	2b00      	cmp	r3, #0
 8018710:	d005      	beq.n	801871e <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8018712:	f7ff ffcb 	bl	80186ac <OsPercpuGet>
 8018716:	4603      	mov	r3, r0
 8018718:	2201      	movs	r2, #1
 801871a:	621a      	str	r2, [r3, #32]
        return;
 801871c:	e001      	b.n	8018722 <LOS_Schedule+0x1e>
    OsSchedPreempt();
 801871e:	f7ef fdd3 	bl	80082c8 <OsSchedPreempt>
}
 8018722:	bd80      	pop	{r7, pc}

08018724 <LOS_SpinLockSave>:
{
 8018724:	b580      	push	{r7, lr}
 8018726:	b082      	sub	sp, #8
 8018728:	af00      	add	r7, sp, #0
 801872a:	6078      	str	r0, [r7, #4]
 801872c:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 801872e:	f7ff ff9e 	bl	801866e <LOS_IntLock>
 8018732:	4602      	mov	r2, r0
 8018734:	683b      	ldr	r3, [r7, #0]
 8018736:	601a      	str	r2, [r3, #0]
}
 8018738:	bf00      	nop
 801873a:	3708      	adds	r7, #8
 801873c:	46bd      	mov	sp, r7
 801873e:	bd80      	pop	{r7, pc}

08018740 <LOS_SpinUnlockRestore>:
{
 8018740:	b580      	push	{r7, lr}
 8018742:	b082      	sub	sp, #8
 8018744:	af00      	add	r7, sp, #0
 8018746:	6078      	str	r0, [r7, #4]
 8018748:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 801874a:	6838      	ldr	r0, [r7, #0]
 801874c:	f7ff ff96 	bl	801867c <LOS_IntRestore>
}
 8018750:	bf00      	nop
 8018752:	3708      	adds	r7, #8
 8018754:	46bd      	mov	sp, r7
 8018756:	bd80      	pop	{r7, pc}

08018758 <LOS_SpinHeld>:
{
 8018758:	b480      	push	{r7}
 801875a:	b083      	sub	sp, #12
 801875c:	af00      	add	r7, sp, #0
 801875e:	6078      	str	r0, [r7, #4]
    return TRUE;
 8018760:	2301      	movs	r3, #1
}
 8018762:	4618      	mov	r0, r3
 8018764:	370c      	adds	r7, #12
 8018766:	46bd      	mov	sp, r7
 8018768:	f85d 7b04 	ldr.w	r7, [sp], #4
 801876c:	4770      	bx	lr

0801876e <OsCurrTaskGet>:
{
 801876e:	b580      	push	{r7, lr}
 8018770:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 8018772:	f7ff ff8f 	bl	8018694 <ArchCurrTaskGet>
 8018776:	4603      	mov	r3, r0
}
 8018778:	4618      	mov	r0, r3
 801877a:	bd80      	pop	{r7, pc}

0801877c <LOS_MpSchedule>:
{
 801877c:	b480      	push	{r7}
 801877e:	b083      	sub	sp, #12
 8018780:	af00      	add	r7, sp, #0
 8018782:	6078      	str	r0, [r7, #4]
}
 8018784:	bf00      	nop
 8018786:	370c      	adds	r7, #12
 8018788:	46bd      	mov	sp, r7
 801878a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801878e:	4770      	bx	lr

08018790 <LOS_EventInit>:
extern "C" {
#endif
#endif /* __cplusplus */

LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventInit(PEVENT_CB_S eventCB)
{
 8018790:	b590      	push	{r4, r7, lr}
 8018792:	b089      	sub	sp, #36	; 0x24
 8018794:	af00      	add	r7, sp, #0
 8018796:	6078      	str	r0, [r7, #4]
 8018798:	4b21      	ldr	r3, [pc, #132]	; (8018820 <LOS_EventInit+0x90>)
 801879a:	681b      	ldr	r3, [r3, #0]
 801879c:	61fb      	str	r3, [r7, #28]
 801879e:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    LOS_TRACE(EVENT_CREATE, (UINTPTR)eventCB);
 80187a2:	2300      	movs	r3, #0
 80187a4:	617b      	str	r3, [r7, #20]
 80187a6:	687b      	ldr	r3, [r7, #4]
 80187a8:	61bb      	str	r3, [r7, #24]
 80187aa:	2302      	movs	r3, #2
 80187ac:	60fb      	str	r3, [r7, #12]
 80187ae:	68fb      	ldr	r3, [r7, #12]
 80187b0:	2b01      	cmp	r3, #1
 80187b2:	d916      	bls.n	80187e2 <LOS_EventInit+0x52>
 80187b4:	4b1b      	ldr	r3, [pc, #108]	; (8018824 <LOS_EventInit+0x94>)
 80187b6:	681b      	ldr	r3, [r3, #0]
 80187b8:	2b00      	cmp	r3, #0
 80187ba:	d012      	beq.n	80187e2 <LOS_EventInit+0x52>
 80187bc:	4b19      	ldr	r3, [pc, #100]	; (8018824 <LOS_EventInit+0x94>)
 80187be:	681c      	ldr	r4, [r3, #0]
 80187c0:	69b9      	ldr	r1, [r7, #24]
 80187c2:	68fb      	ldr	r3, [r7, #12]
 80187c4:	2b02      	cmp	r3, #2
 80187c6:	d904      	bls.n	80187d2 <LOS_EventInit+0x42>
 80187c8:	f107 0314 	add.w	r3, r7, #20
 80187cc:	f103 0208 	add.w	r2, r3, #8
 80187d0:	e000      	b.n	80187d4 <LOS_EventInit+0x44>
 80187d2:	2200      	movs	r2, #0
 80187d4:	68fb      	ldr	r3, [r7, #12]
 80187d6:	b29b      	uxth	r3, r3
 80187d8:	3b02      	subs	r3, #2
 80187da:	b29b      	uxth	r3, r3
 80187dc:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80187e0:	47a0      	blx	r4

    if (eventCB == NULL) {
 80187e2:	687b      	ldr	r3, [r7, #4]
 80187e4:	2b00      	cmp	r3, #0
 80187e6:	d101      	bne.n	80187ec <LOS_EventInit+0x5c>
        return LOS_ERRNO_EVENT_PTR_NULL;
 80187e8:	4b0f      	ldr	r3, [pc, #60]	; (8018828 <LOS_EventInit+0x98>)
 80187ea:	e00e      	b.n	801880a <LOS_EventInit+0x7a>
    }

    intSave = LOS_IntLock();
 80187ec:	f7ff ff3f 	bl	801866e <LOS_IntLock>
 80187f0:	6138      	str	r0, [r7, #16]
    eventCB->uwEventID = 0;
 80187f2:	687b      	ldr	r3, [r7, #4]
 80187f4:	2200      	movs	r2, #0
 80187f6:	601a      	str	r2, [r3, #0]
    LOS_ListInit(&eventCB->stEventList);
 80187f8:	687b      	ldr	r3, [r7, #4]
 80187fa:	3304      	adds	r3, #4
 80187fc:	4618      	mov	r0, r3
 80187fe:	f7ff feff 	bl	8018600 <LOS_ListInit>
    LOS_IntRestore(intSave);
 8018802:	6938      	ldr	r0, [r7, #16]
 8018804:	f7ff ff3a 	bl	801867c <LOS_IntRestore>
    return LOS_OK;
 8018808:	2300      	movs	r3, #0
}
 801880a:	4a05      	ldr	r2, [pc, #20]	; (8018820 <LOS_EventInit+0x90>)
 801880c:	6811      	ldr	r1, [r2, #0]
 801880e:	69fa      	ldr	r2, [r7, #28]
 8018810:	4051      	eors	r1, r2
 8018812:	d001      	beq.n	8018818 <LOS_EventInit+0x88>
 8018814:	f7eb fde8 	bl	80043e8 <__stack_chk_fail>
 8018818:	4618      	mov	r0, r3
 801881a:	3724      	adds	r7, #36	; 0x24
 801881c:	46bd      	mov	sp, r7
 801881e:	bd90      	pop	{r4, r7, pc}
 8018820:	08023058 	.word	0x08023058
 8018824:	2000075c 	.word	0x2000075c
 8018828:	02001c06 	.word	0x02001c06

0801882c <OsEventParamCheck>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventParamCheck(const VOID *ptr, UINT32 eventMask, UINT32 mode)
{
 801882c:	b480      	push	{r7}
 801882e:	b085      	sub	sp, #20
 8018830:	af00      	add	r7, sp, #0
 8018832:	60f8      	str	r0, [r7, #12]
 8018834:	60b9      	str	r1, [r7, #8]
 8018836:	607a      	str	r2, [r7, #4]
    if (ptr == NULL) {
 8018838:	68fb      	ldr	r3, [r7, #12]
 801883a:	2b00      	cmp	r3, #0
 801883c:	d101      	bne.n	8018842 <OsEventParamCheck+0x16>
        return LOS_ERRNO_EVENT_PTR_NULL;
 801883e:	4b15      	ldr	r3, [pc, #84]	; (8018894 <OsEventParamCheck+0x68>)
 8018840:	e022      	b.n	8018888 <OsEventParamCheck+0x5c>
    }

    if (eventMask == 0) {
 8018842:	68bb      	ldr	r3, [r7, #8]
 8018844:	2b00      	cmp	r3, #0
 8018846:	d101      	bne.n	801884c <OsEventParamCheck+0x20>
        return LOS_ERRNO_EVENT_EVENTMASK_INVALID;
 8018848:	4b13      	ldr	r3, [pc, #76]	; (8018898 <OsEventParamCheck+0x6c>)
 801884a:	e01d      	b.n	8018888 <OsEventParamCheck+0x5c>
    }

    if (eventMask & LOS_ERRTYPE_ERROR) {
 801884c:	68bb      	ldr	r3, [r7, #8]
 801884e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8018852:	2b00      	cmp	r3, #0
 8018854:	d001      	beq.n	801885a <OsEventParamCheck+0x2e>
        return LOS_ERRNO_EVENT_SETBIT_INVALID;
 8018856:	4b11      	ldr	r3, [pc, #68]	; (801889c <OsEventParamCheck+0x70>)
 8018858:	e016      	b.n	8018888 <OsEventParamCheck+0x5c>
    }

    if (((mode & LOS_WAITMODE_OR) && (mode & LOS_WAITMODE_AND)) ||
 801885a:	687b      	ldr	r3, [r7, #4]
 801885c:	f003 0302 	and.w	r3, r3, #2
 8018860:	2b00      	cmp	r3, #0
 8018862:	d004      	beq.n	801886e <OsEventParamCheck+0x42>
 8018864:	687b      	ldr	r3, [r7, #4]
 8018866:	f003 0304 	and.w	r3, r3, #4
 801886a:	2b00      	cmp	r3, #0
 801886c:	d109      	bne.n	8018882 <OsEventParamCheck+0x56>
        (mode & ~(LOS_WAITMODE_OR | LOS_WAITMODE_AND | LOS_WAITMODE_CLR)) ||
 801886e:	687b      	ldr	r3, [r7, #4]
 8018870:	f023 0307 	bic.w	r3, r3, #7
    if (((mode & LOS_WAITMODE_OR) && (mode & LOS_WAITMODE_AND)) ||
 8018874:	2b00      	cmp	r3, #0
 8018876:	d104      	bne.n	8018882 <OsEventParamCheck+0x56>
        !(mode & (LOS_WAITMODE_OR | LOS_WAITMODE_AND))) {
 8018878:	687b      	ldr	r3, [r7, #4]
 801887a:	f003 0306 	and.w	r3, r3, #6
        (mode & ~(LOS_WAITMODE_OR | LOS_WAITMODE_AND | LOS_WAITMODE_CLR)) ||
 801887e:	2b00      	cmp	r3, #0
 8018880:	d101      	bne.n	8018886 <OsEventParamCheck+0x5a>
        return LOS_ERRNO_EVENT_FLAGS_INVALID;
 8018882:	4b07      	ldr	r3, [pc, #28]	; (80188a0 <OsEventParamCheck+0x74>)
 8018884:	e000      	b.n	8018888 <OsEventParamCheck+0x5c>
    }
    return LOS_OK;
 8018886:	2300      	movs	r3, #0
}
 8018888:	4618      	mov	r0, r3
 801888a:	3714      	adds	r7, #20
 801888c:	46bd      	mov	sp, r7
 801888e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018892:	4770      	bx	lr
 8018894:	02001c06 	.word	0x02001c06
 8018898:	02001c02 	.word	0x02001c02
 801889c:	02001c00 	.word	0x02001c00
 80188a0:	02001c04 	.word	0x02001c04

080188a4 <OsEventPoll>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventPoll(UINT32 *eventId, UINT32 eventMask, UINT32 mode)
{
 80188a4:	b580      	push	{r7, lr}
 80188a6:	b086      	sub	sp, #24
 80188a8:	af00      	add	r7, sp, #0
 80188aa:	60f8      	str	r0, [r7, #12]
 80188ac:	60b9      	str	r1, [r7, #8]
 80188ae:	607a      	str	r2, [r7, #4]
    UINT32 ret = 0;
 80188b0:	2300      	movs	r3, #0
 80188b2:	617b      	str	r3, [r7, #20]

    LOS_ASSERT(ArchIntLocked());
 80188b4:	f7ff fece 	bl	8018654 <ArchIntLocked>
 80188b8:	4603      	mov	r3, r0
 80188ba:	2b00      	cmp	r3, #0
 80188bc:	d10b      	bne.n	80188d6 <OsEventPoll+0x32>
 80188be:	f7ff fed6 	bl	801866e <LOS_IntLock>
 80188c2:	4828      	ldr	r0, [pc, #160]	; (8018964 <OsEventPoll+0xc0>)
 80188c4:	f7eb ff02 	bl	80046cc <dprintf>
 80188c8:	4b27      	ldr	r3, [pc, #156]	; (8018968 <OsEventPoll+0xc4>)
 80188ca:	2255      	movs	r2, #85	; 0x55
 80188cc:	4927      	ldr	r1, [pc, #156]	; (801896c <OsEventPoll+0xc8>)
 80188ce:	4828      	ldr	r0, [pc, #160]	; (8018970 <OsEventPoll+0xcc>)
 80188d0:	f7eb fefc 	bl	80046cc <dprintf>
 80188d4:	e7fe      	b.n	80188d4 <OsEventPoll+0x30>
    LOS_ASSERT(LOS_SpinHeld(&g_taskSpin));
 80188d6:	4827      	ldr	r0, [pc, #156]	; (8018974 <OsEventPoll+0xd0>)
 80188d8:	f7ff ff3e 	bl	8018758 <LOS_SpinHeld>
 80188dc:	4603      	mov	r3, r0
 80188de:	2b00      	cmp	r3, #0
 80188e0:	d10b      	bne.n	80188fa <OsEventPoll+0x56>
 80188e2:	f7ff fec4 	bl	801866e <LOS_IntLock>
 80188e6:	481f      	ldr	r0, [pc, #124]	; (8018964 <OsEventPoll+0xc0>)
 80188e8:	f7eb fef0 	bl	80046cc <dprintf>
 80188ec:	4b1e      	ldr	r3, [pc, #120]	; (8018968 <OsEventPoll+0xc4>)
 80188ee:	2256      	movs	r2, #86	; 0x56
 80188f0:	491e      	ldr	r1, [pc, #120]	; (801896c <OsEventPoll+0xc8>)
 80188f2:	481f      	ldr	r0, [pc, #124]	; (8018970 <OsEventPoll+0xcc>)
 80188f4:	f7eb feea 	bl	80046cc <dprintf>
 80188f8:	e7fe      	b.n	80188f8 <OsEventPoll+0x54>

    if (mode & LOS_WAITMODE_OR) {
 80188fa:	687b      	ldr	r3, [r7, #4]
 80188fc:	f003 0302 	and.w	r3, r3, #2
 8018900:	2b00      	cmp	r3, #0
 8018902:	d00b      	beq.n	801891c <OsEventPoll+0x78>
        if ((*eventId & eventMask) != 0) {
 8018904:	68fb      	ldr	r3, [r7, #12]
 8018906:	681a      	ldr	r2, [r3, #0]
 8018908:	68bb      	ldr	r3, [r7, #8]
 801890a:	4013      	ands	r3, r2
 801890c:	2b00      	cmp	r3, #0
 801890e:	d014      	beq.n	801893a <OsEventPoll+0x96>
            ret = *eventId & eventMask;
 8018910:	68fb      	ldr	r3, [r7, #12]
 8018912:	681b      	ldr	r3, [r3, #0]
 8018914:	68ba      	ldr	r2, [r7, #8]
 8018916:	4013      	ands	r3, r2
 8018918:	617b      	str	r3, [r7, #20]
 801891a:	e00e      	b.n	801893a <OsEventPoll+0x96>
        }
    } else {
        if ((eventMask != 0) && (eventMask == (*eventId & eventMask))) {
 801891c:	68bb      	ldr	r3, [r7, #8]
 801891e:	2b00      	cmp	r3, #0
 8018920:	d00b      	beq.n	801893a <OsEventPoll+0x96>
 8018922:	68fb      	ldr	r3, [r7, #12]
 8018924:	681a      	ldr	r2, [r3, #0]
 8018926:	68bb      	ldr	r3, [r7, #8]
 8018928:	4013      	ands	r3, r2
 801892a:	68ba      	ldr	r2, [r7, #8]
 801892c:	429a      	cmp	r2, r3
 801892e:	d104      	bne.n	801893a <OsEventPoll+0x96>
            ret = *eventId & eventMask;
 8018930:	68fb      	ldr	r3, [r7, #12]
 8018932:	681b      	ldr	r3, [r3, #0]
 8018934:	68ba      	ldr	r2, [r7, #8]
 8018936:	4013      	ands	r3, r2
 8018938:	617b      	str	r3, [r7, #20]
        }
    }

    if (ret && (mode & LOS_WAITMODE_CLR)) {
 801893a:	697b      	ldr	r3, [r7, #20]
 801893c:	2b00      	cmp	r3, #0
 801893e:	d00b      	beq.n	8018958 <OsEventPoll+0xb4>
 8018940:	687b      	ldr	r3, [r7, #4]
 8018942:	f003 0301 	and.w	r3, r3, #1
 8018946:	2b00      	cmp	r3, #0
 8018948:	d006      	beq.n	8018958 <OsEventPoll+0xb4>
        *eventId = *eventId & ~ret;
 801894a:	68fb      	ldr	r3, [r7, #12]
 801894c:	681a      	ldr	r2, [r3, #0]
 801894e:	697b      	ldr	r3, [r7, #20]
 8018950:	43db      	mvns	r3, r3
 8018952:	401a      	ands	r2, r3
 8018954:	68fb      	ldr	r3, [r7, #12]
 8018956:	601a      	str	r2, [r3, #0]
    }

    return ret;
 8018958:	697b      	ldr	r3, [r7, #20]
}
 801895a:	4618      	mov	r0, r3
 801895c:	3718      	adds	r7, #24
 801895e:	46bd      	mov	sp, r7
 8018960:	bd80      	pop	{r7, pc}
 8018962:	bf00      	nop
 8018964:	0802305c 	.word	0x0802305c
 8018968:	08023830 	.word	0x08023830
 801896c:	08023064 	.word	0x08023064
 8018970:	08023070 	.word	0x08023070
 8018974:	20000764 	.word	0x20000764

08018978 <OsEventReadCheck>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventReadCheck(const PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode)
{
 8018978:	b580      	push	{r7, lr}
 801897a:	b086      	sub	sp, #24
 801897c:	af00      	add	r7, sp, #0
 801897e:	60f8      	str	r0, [r7, #12]
 8018980:	60b9      	str	r1, [r7, #8]
 8018982:	607a      	str	r2, [r7, #4]
    UINT32 ret;
    LosTaskCB *runTask = NULL;
 8018984:	2300      	movs	r3, #0
 8018986:	613b      	str	r3, [r7, #16]

    ret = OsEventParamCheck(eventCB, eventMask, mode);
 8018988:	687a      	ldr	r2, [r7, #4]
 801898a:	68b9      	ldr	r1, [r7, #8]
 801898c:	68f8      	ldr	r0, [r7, #12]
 801898e:	f7ff ff4d 	bl	801882c <OsEventParamCheck>
 8018992:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 8018994:	697b      	ldr	r3, [r7, #20]
 8018996:	2b00      	cmp	r3, #0
 8018998:	d001      	beq.n	801899e <OsEventReadCheck+0x26>
        return ret;
 801899a:	697b      	ldr	r3, [r7, #20]
 801899c:	e00a      	b.n	80189b4 <OsEventReadCheck+0x3c>
    }

    if (OS_INT_ACTIVE) {
 801899e:	f7e9 fd65 	bl	800246c <IntActive>
 80189a2:	4603      	mov	r3, r0
 80189a4:	2b00      	cmp	r3, #0
 80189a6:	d001      	beq.n	80189ac <OsEventReadCheck+0x34>
        return LOS_ERRNO_EVENT_READ_IN_INTERRUPT;
 80189a8:	4b04      	ldr	r3, [pc, #16]	; (80189bc <OsEventReadCheck+0x44>)
 80189aa:	e003      	b.n	80189b4 <OsEventReadCheck+0x3c>
    }

    runTask = OsCurrTaskGet();
 80189ac:	f7ff fedf 	bl	801876e <OsCurrTaskGet>
 80189b0:	6138      	str	r0, [r7, #16]
    if (runTask->taskFlags & OS_TASK_FLAG_SYSTEM) {
        PRINT_DEBUG("Warning: DO NOT recommend to use LOS_EventRead or OsEventReadOnce in system tasks.\n");
    }
    return LOS_OK;
 80189b2:	2300      	movs	r3, #0
}
 80189b4:	4618      	mov	r0, r3
 80189b6:	3718      	adds	r7, #24
 80189b8:	46bd      	mov	sp, r7
 80189ba:	bd80      	pop	{r7, pc}
 80189bc:	02001c03 	.word	0x02001c03

080189c0 <OsEventReadImp>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventReadImp(PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode,
                                              UINT32 timeout, BOOL once, UINT32 *intSave)
{
 80189c0:	b580      	push	{r7, lr}
 80189c2:	b086      	sub	sp, #24
 80189c4:	af00      	add	r7, sp, #0
 80189c6:	60f8      	str	r0, [r7, #12]
 80189c8:	60b9      	str	r1, [r7, #8]
 80189ca:	607a      	str	r2, [r7, #4]
 80189cc:	603b      	str	r3, [r7, #0]
    UINT32 ret = 0;
 80189ce:	2300      	movs	r3, #0
 80189d0:	613b      	str	r3, [r7, #16]
    LosTaskCB *runTask = OsCurrTaskGet();
 80189d2:	f7ff fecc 	bl	801876e <OsCurrTaskGet>
 80189d6:	6178      	str	r0, [r7, #20]

    if (once == FALSE) {
 80189d8:	6a3b      	ldr	r3, [r7, #32]
 80189da:	2b00      	cmp	r3, #0
 80189dc:	d106      	bne.n	80189ec <OsEventReadImp+0x2c>
        ret = OsEventPoll(&eventCB->uwEventID, eventMask, mode);
 80189de:	68fb      	ldr	r3, [r7, #12]
 80189e0:	687a      	ldr	r2, [r7, #4]
 80189e2:	68b9      	ldr	r1, [r7, #8]
 80189e4:	4618      	mov	r0, r3
 80189e6:	f7ff ff5d 	bl	80188a4 <OsEventPoll>
 80189ea:	6138      	str	r0, [r7, #16]
    }

    if (ret == 0) {
 80189ec:	693b      	ldr	r3, [r7, #16]
 80189ee:	2b00      	cmp	r3, #0
 80189f0:	d13a      	bne.n	8018a68 <OsEventReadImp+0xa8>
        if (timeout == 0) {
 80189f2:	683b      	ldr	r3, [r7, #0]
 80189f4:	2b00      	cmp	r3, #0
 80189f6:	d101      	bne.n	80189fc <OsEventReadImp+0x3c>
            return ret;
 80189f8:	693b      	ldr	r3, [r7, #16]
 80189fa:	e036      	b.n	8018a6a <OsEventReadImp+0xaa>
        }

        if (!OsPreemptableInSched()) {
 80189fc:	f7ff fe66 	bl	80186cc <OsPreemptableInSched>
 8018a00:	4603      	mov	r3, r0
 8018a02:	2b00      	cmp	r3, #0
 8018a04:	d101      	bne.n	8018a0a <OsEventReadImp+0x4a>
            return LOS_ERRNO_EVENT_READ_IN_LOCK;
 8018a06:	4b1b      	ldr	r3, [pc, #108]	; (8018a74 <OsEventReadImp+0xb4>)
 8018a08:	e02f      	b.n	8018a6a <OsEventReadImp+0xaa>
        }

        runTask->eventMask = eventMask;
 8018a0a:	697b      	ldr	r3, [r7, #20]
 8018a0c:	68ba      	ldr	r2, [r7, #8]
 8018a0e:	661a      	str	r2, [r3, #96]	; 0x60
        runTask->eventMode = mode;
 8018a10:	697b      	ldr	r3, [r7, #20]
 8018a12:	687a      	ldr	r2, [r7, #4]
 8018a14:	665a      	str	r2, [r3, #100]	; 0x64

        OsTaskWait(&eventCB->stEventList, OS_TASK_STATUS_PEND, timeout);
 8018a16:	68fb      	ldr	r3, [r7, #12]
 8018a18:	3304      	adds	r3, #4
 8018a1a:	683a      	ldr	r2, [r7, #0]
 8018a1c:	2108      	movs	r1, #8
 8018a1e:	4618      	mov	r0, r3
 8018a20:	f7eb f9a4 	bl	8003d6c <OsTaskWait>

        /*
         * it will immediately do the scheduling, so there's no need to release the
         * task spinlock. when this task's been rescheduled, it will be holding the spinlock.
         */
        OsSchedResched();
 8018a24:	f7ef fb92 	bl	800814c <OsSchedResched>

        SCHEDULER_UNLOCK(*intSave);
 8018a28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018a2a:	681b      	ldr	r3, [r3, #0]
 8018a2c:	4619      	mov	r1, r3
 8018a2e:	4812      	ldr	r0, [pc, #72]	; (8018a78 <OsEventReadImp+0xb8>)
 8018a30:	f7ff fe86 	bl	8018740 <LOS_SpinUnlockRestore>
        SCHEDULER_LOCK(*intSave);
 8018a34:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8018a36:	4810      	ldr	r0, [pc, #64]	; (8018a78 <OsEventReadImp+0xb8>)
 8018a38:	f7ff fe74 	bl	8018724 <LOS_SpinLockSave>

        if (runTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
 8018a3c:	697b      	ldr	r3, [r7, #20]
 8018a3e:	889b      	ldrh	r3, [r3, #4]
 8018a40:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8018a44:	2b00      	cmp	r3, #0
 8018a46:	d008      	beq.n	8018a5a <OsEventReadImp+0x9a>
            runTask->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
 8018a48:	697b      	ldr	r3, [r7, #20]
 8018a4a:	889b      	ldrh	r3, [r3, #4]
 8018a4c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8018a50:	b29a      	uxth	r2, r3
 8018a52:	697b      	ldr	r3, [r7, #20]
 8018a54:	809a      	strh	r2, [r3, #4]
            return LOS_ERRNO_EVENT_READ_TIMEOUT;
 8018a56:	4b09      	ldr	r3, [pc, #36]	; (8018a7c <OsEventReadImp+0xbc>)
 8018a58:	e007      	b.n	8018a6a <OsEventReadImp+0xaa>
        }

        ret = OsEventPoll(&eventCB->uwEventID, eventMask, mode);
 8018a5a:	68fb      	ldr	r3, [r7, #12]
 8018a5c:	687a      	ldr	r2, [r7, #4]
 8018a5e:	68b9      	ldr	r1, [r7, #8]
 8018a60:	4618      	mov	r0, r3
 8018a62:	f7ff ff1f 	bl	80188a4 <OsEventPoll>
 8018a66:	6138      	str	r0, [r7, #16]
    }
    return ret;
 8018a68:	693b      	ldr	r3, [r7, #16]
}
 8018a6a:	4618      	mov	r0, r3
 8018a6c:	3718      	adds	r7, #24
 8018a6e:	46bd      	mov	sp, r7
 8018a70:	bd80      	pop	{r7, pc}
 8018a72:	bf00      	nop
 8018a74:	02001c05 	.word	0x02001c05
 8018a78:	20000764 	.word	0x20000764
 8018a7c:	02001c01 	.word	0x02001c01

08018a80 <OsEventRead>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventRead(PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode,
                                           UINT32 timeout, BOOL once)
{
 8018a80:	b590      	push	{r4, r7, lr}
 8018a82:	b091      	sub	sp, #68	; 0x44
 8018a84:	af02      	add	r7, sp, #8
 8018a86:	60f8      	str	r0, [r7, #12]
 8018a88:	60b9      	str	r1, [r7, #8]
 8018a8a:	607a      	str	r2, [r7, #4]
 8018a8c:	603b      	str	r3, [r7, #0]
 8018a8e:	4b2e      	ldr	r3, [pc, #184]	; (8018b48 <OsEventRead+0xc8>)
 8018a90:	681b      	ldr	r3, [r3, #0]
 8018a92:	637b      	str	r3, [r7, #52]	; 0x34
 8018a94:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    UINT32 intSave;

    ret = OsEventReadCheck(eventCB, eventMask, mode);
 8018a98:	687a      	ldr	r2, [r7, #4]
 8018a9a:	68b9      	ldr	r1, [r7, #8]
 8018a9c:	68f8      	ldr	r0, [r7, #12]
 8018a9e:	f7ff ff6b 	bl	8018978 <OsEventReadCheck>
 8018aa2:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 8018aa4:	697b      	ldr	r3, [r7, #20]
 8018aa6:	2b00      	cmp	r3, #0
 8018aa8:	d001      	beq.n	8018aae <OsEventRead+0x2e>
        return ret;
 8018aaa:	697b      	ldr	r3, [r7, #20]
 8018aac:	e040      	b.n	8018b30 <OsEventRead+0xb0>
    }

    LOS_TRACE(EVENT_READ, (UINTPTR)eventCB, eventCB->uwEventID, eventMask, mode, timeout);
 8018aae:	2300      	movs	r3, #0
 8018ab0:	61fb      	str	r3, [r7, #28]
 8018ab2:	68fb      	ldr	r3, [r7, #12]
 8018ab4:	623b      	str	r3, [r7, #32]
 8018ab6:	68fb      	ldr	r3, [r7, #12]
 8018ab8:	681b      	ldr	r3, [r3, #0]
 8018aba:	627b      	str	r3, [r7, #36]	; 0x24
 8018abc:	68bb      	ldr	r3, [r7, #8]
 8018abe:	62bb      	str	r3, [r7, #40]	; 0x28
 8018ac0:	687b      	ldr	r3, [r7, #4]
 8018ac2:	62fb      	str	r3, [r7, #44]	; 0x2c
 8018ac4:	683b      	ldr	r3, [r7, #0]
 8018ac6:	633b      	str	r3, [r7, #48]	; 0x30
 8018ac8:	2306      	movs	r3, #6
 8018aca:	61bb      	str	r3, [r7, #24]
 8018acc:	69bb      	ldr	r3, [r7, #24]
 8018ace:	2b01      	cmp	r3, #1
 8018ad0:	d916      	bls.n	8018b00 <OsEventRead+0x80>
 8018ad2:	4b1e      	ldr	r3, [pc, #120]	; (8018b4c <OsEventRead+0xcc>)
 8018ad4:	681b      	ldr	r3, [r3, #0]
 8018ad6:	2b00      	cmp	r3, #0
 8018ad8:	d012      	beq.n	8018b00 <OsEventRead+0x80>
 8018ada:	4b1c      	ldr	r3, [pc, #112]	; (8018b4c <OsEventRead+0xcc>)
 8018adc:	681c      	ldr	r4, [r3, #0]
 8018ade:	6a39      	ldr	r1, [r7, #32]
 8018ae0:	69bb      	ldr	r3, [r7, #24]
 8018ae2:	2b02      	cmp	r3, #2
 8018ae4:	d904      	bls.n	8018af0 <OsEventRead+0x70>
 8018ae6:	f107 031c 	add.w	r3, r7, #28
 8018aea:	f103 0208 	add.w	r2, r3, #8
 8018aee:	e000      	b.n	8018af2 <OsEventRead+0x72>
 8018af0:	2200      	movs	r2, #0
 8018af2:	69bb      	ldr	r3, [r7, #24]
 8018af4:	b29b      	uxth	r3, r3
 8018af6:	3b02      	subs	r3, #2
 8018af8:	b29b      	uxth	r3, r3
 8018afa:	f240 4002 	movw	r0, #1026	; 0x402
 8018afe:	47a0      	blx	r4

    SCHEDULER_LOCK(intSave);
 8018b00:	f107 0310 	add.w	r3, r7, #16
 8018b04:	4619      	mov	r1, r3
 8018b06:	4812      	ldr	r0, [pc, #72]	; (8018b50 <OsEventRead+0xd0>)
 8018b08:	f7ff fe0c 	bl	8018724 <LOS_SpinLockSave>
    ret = OsEventReadImp(eventCB, eventMask, mode, timeout, once, &intSave);
 8018b0c:	f107 0310 	add.w	r3, r7, #16
 8018b10:	9301      	str	r3, [sp, #4]
 8018b12:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018b14:	9300      	str	r3, [sp, #0]
 8018b16:	683b      	ldr	r3, [r7, #0]
 8018b18:	687a      	ldr	r2, [r7, #4]
 8018b1a:	68b9      	ldr	r1, [r7, #8]
 8018b1c:	68f8      	ldr	r0, [r7, #12]
 8018b1e:	f7ff ff4f 	bl	80189c0 <OsEventReadImp>
 8018b22:	6178      	str	r0, [r7, #20]
    SCHEDULER_UNLOCK(intSave);
 8018b24:	693b      	ldr	r3, [r7, #16]
 8018b26:	4619      	mov	r1, r3
 8018b28:	4809      	ldr	r0, [pc, #36]	; (8018b50 <OsEventRead+0xd0>)
 8018b2a:	f7ff fe09 	bl	8018740 <LOS_SpinUnlockRestore>
    return ret;
 8018b2e:	697b      	ldr	r3, [r7, #20]
}
 8018b30:	4a05      	ldr	r2, [pc, #20]	; (8018b48 <OsEventRead+0xc8>)
 8018b32:	6811      	ldr	r1, [r2, #0]
 8018b34:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8018b36:	4051      	eors	r1, r2
 8018b38:	d001      	beq.n	8018b3e <OsEventRead+0xbe>
 8018b3a:	f7eb fc55 	bl	80043e8 <__stack_chk_fail>
 8018b3e:	4618      	mov	r0, r3
 8018b40:	373c      	adds	r7, #60	; 0x3c
 8018b42:	46bd      	mov	sp, r7
 8018b44:	bd90      	pop	{r4, r7, pc}
 8018b46:	bf00      	nop
 8018b48:	0802308c 	.word	0x0802308c
 8018b4c:	2000075c 	.word	0x2000075c
 8018b50:	20000764 	.word	0x20000764

08018b54 <OsEventWrite>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventWrite(PEVENT_CB_S eventCB, UINT32 events, BOOL once)
{
 8018b54:	b590      	push	{r4, r7, lr}
 8018b56:	b08f      	sub	sp, #60	; 0x3c
 8018b58:	af00      	add	r7, sp, #0
 8018b5a:	60f8      	str	r0, [r7, #12]
 8018b5c:	60b9      	str	r1, [r7, #8]
 8018b5e:	607a      	str	r2, [r7, #4]
 8018b60:	4b50      	ldr	r3, [pc, #320]	; (8018ca4 <OsEventWrite+0x150>)
 8018b62:	681b      	ldr	r3, [r3, #0]
 8018b64:	637b      	str	r3, [r7, #52]	; 0x34
 8018b66:	f04f 0300 	mov.w	r3, #0
    LosTaskCB *resumedTask = NULL;
 8018b6a:	2300      	movs	r3, #0
 8018b6c:	61bb      	str	r3, [r7, #24]
    LosTaskCB *nextTask = NULL;
 8018b6e:	2300      	movs	r3, #0
 8018b70:	61fb      	str	r3, [r7, #28]
    UINT32 intSave;
    UINT8 exitFlag = 0;
 8018b72:	2300      	movs	r3, #0
 8018b74:	74fb      	strb	r3, [r7, #19]

    if (eventCB == NULL) {
 8018b76:	68fb      	ldr	r3, [r7, #12]
 8018b78:	2b00      	cmp	r3, #0
 8018b7a:	d101      	bne.n	8018b80 <OsEventWrite+0x2c>
        return LOS_ERRNO_EVENT_PTR_NULL;
 8018b7c:	4b4a      	ldr	r3, [pc, #296]	; (8018ca8 <OsEventWrite+0x154>)
 8018b7e:	e085      	b.n	8018c8c <OsEventWrite+0x138>
    }

    if (events & LOS_ERRTYPE_ERROR) {
 8018b80:	68bb      	ldr	r3, [r7, #8]
 8018b82:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8018b86:	2b00      	cmp	r3, #0
 8018b88:	d001      	beq.n	8018b8e <OsEventWrite+0x3a>
        return LOS_ERRNO_EVENT_SETBIT_INVALID;
 8018b8a:	4b48      	ldr	r3, [pc, #288]	; (8018cac <OsEventWrite+0x158>)
 8018b8c:	e07e      	b.n	8018c8c <OsEventWrite+0x138>
    }

    LOS_TRACE(EVENT_WRITE, (UINTPTR)eventCB, eventCB->uwEventID, events);
 8018b8e:	2300      	movs	r3, #0
 8018b90:	627b      	str	r3, [r7, #36]	; 0x24
 8018b92:	68fb      	ldr	r3, [r7, #12]
 8018b94:	62bb      	str	r3, [r7, #40]	; 0x28
 8018b96:	68fb      	ldr	r3, [r7, #12]
 8018b98:	681b      	ldr	r3, [r3, #0]
 8018b9a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8018b9c:	68bb      	ldr	r3, [r7, #8]
 8018b9e:	633b      	str	r3, [r7, #48]	; 0x30
 8018ba0:	2304      	movs	r3, #4
 8018ba2:	623b      	str	r3, [r7, #32]
 8018ba4:	6a3b      	ldr	r3, [r7, #32]
 8018ba6:	2b01      	cmp	r3, #1
 8018ba8:	d916      	bls.n	8018bd8 <OsEventWrite+0x84>
 8018baa:	4b41      	ldr	r3, [pc, #260]	; (8018cb0 <OsEventWrite+0x15c>)
 8018bac:	681b      	ldr	r3, [r3, #0]
 8018bae:	2b00      	cmp	r3, #0
 8018bb0:	d012      	beq.n	8018bd8 <OsEventWrite+0x84>
 8018bb2:	4b3f      	ldr	r3, [pc, #252]	; (8018cb0 <OsEventWrite+0x15c>)
 8018bb4:	681c      	ldr	r4, [r3, #0]
 8018bb6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8018bb8:	6a3b      	ldr	r3, [r7, #32]
 8018bba:	2b02      	cmp	r3, #2
 8018bbc:	d904      	bls.n	8018bc8 <OsEventWrite+0x74>
 8018bbe:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8018bc2:	f103 0208 	add.w	r2, r3, #8
 8018bc6:	e000      	b.n	8018bca <OsEventWrite+0x76>
 8018bc8:	2200      	movs	r2, #0
 8018bca:	6a3b      	ldr	r3, [r7, #32]
 8018bcc:	b29b      	uxth	r3, r3
 8018bce:	3b02      	subs	r3, #2
 8018bd0:	b29b      	uxth	r3, r3
 8018bd2:	f240 4003 	movw	r0, #1027	; 0x403
 8018bd6:	47a0      	blx	r4

    SCHEDULER_LOCK(intSave);
 8018bd8:	f107 0314 	add.w	r3, r7, #20
 8018bdc:	4619      	mov	r1, r3
 8018bde:	4835      	ldr	r0, [pc, #212]	; (8018cb4 <OsEventWrite+0x160>)
 8018be0:	f7ff fda0 	bl	8018724 <LOS_SpinLockSave>

    eventCB->uwEventID |= events;
 8018be4:	68fb      	ldr	r3, [r7, #12]
 8018be6:	681a      	ldr	r2, [r3, #0]
 8018be8:	68bb      	ldr	r3, [r7, #8]
 8018bea:	431a      	orrs	r2, r3
 8018bec:	68fb      	ldr	r3, [r7, #12]
 8018bee:	601a      	str	r2, [r3, #0]
    if (!LOS_ListEmpty(&eventCB->stEventList)) {
 8018bf0:	68fb      	ldr	r3, [r7, #12]
 8018bf2:	3304      	adds	r3, #4
 8018bf4:	4618      	mov	r0, r3
 8018bf6:	f7ff fd13 	bl	8018620 <LOS_ListEmpty>
 8018bfa:	4603      	mov	r3, r0
 8018bfc:	2b00      	cmp	r3, #0
 8018bfe:	d137      	bne.n	8018c70 <OsEventWrite+0x11c>
        for (resumedTask = LOS_DL_LIST_ENTRY((&eventCB->stEventList)->pstNext, LosTaskCB, pendList);
 8018c00:	68fb      	ldr	r3, [r7, #12]
 8018c02:	689b      	ldr	r3, [r3, #8]
 8018c04:	3b40      	subs	r3, #64	; 0x40
 8018c06:	61bb      	str	r3, [r7, #24]
 8018c08:	e029      	b.n	8018c5e <OsEventWrite+0x10a>
             &resumedTask->pendList != &eventCB->stEventList;) {
            nextTask = LOS_DL_LIST_ENTRY(resumedTask->pendList.pstNext, LosTaskCB, pendList);
 8018c0a:	69bb      	ldr	r3, [r7, #24]
 8018c0c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8018c0e:	3b40      	subs	r3, #64	; 0x40
 8018c10:	61fb      	str	r3, [r7, #28]
            if (((resumedTask->eventMode & LOS_WAITMODE_OR) && ((resumedTask->eventMask & events) != 0)) ||
 8018c12:	69bb      	ldr	r3, [r7, #24]
 8018c14:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8018c16:	f003 0302 	and.w	r3, r3, #2
 8018c1a:	2b00      	cmp	r3, #0
 8018c1c:	d005      	beq.n	8018c2a <OsEventWrite+0xd6>
 8018c1e:	69bb      	ldr	r3, [r7, #24]
 8018c20:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8018c22:	68bb      	ldr	r3, [r7, #8]
 8018c24:	4013      	ands	r3, r2
 8018c26:	2b00      	cmp	r3, #0
 8018c28:	d10e      	bne.n	8018c48 <OsEventWrite+0xf4>
                ((resumedTask->eventMode & LOS_WAITMODE_AND) &&
 8018c2a:	69bb      	ldr	r3, [r7, #24]
 8018c2c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8018c2e:	f003 0304 	and.w	r3, r3, #4
            if (((resumedTask->eventMode & LOS_WAITMODE_OR) && ((resumedTask->eventMask & events) != 0)) ||
 8018c32:	2b00      	cmp	r3, #0
 8018c34:	d00e      	beq.n	8018c54 <OsEventWrite+0x100>
                 ((resumedTask->eventMask & eventCB->uwEventID) == resumedTask->eventMask))) {
 8018c36:	69bb      	ldr	r3, [r7, #24]
 8018c38:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8018c3a:	68fb      	ldr	r3, [r7, #12]
 8018c3c:	681b      	ldr	r3, [r3, #0]
 8018c3e:	401a      	ands	r2, r3
 8018c40:	69bb      	ldr	r3, [r7, #24]
 8018c42:	6e1b      	ldr	r3, [r3, #96]	; 0x60
                ((resumedTask->eventMode & LOS_WAITMODE_AND) &&
 8018c44:	429a      	cmp	r2, r3
 8018c46:	d105      	bne.n	8018c54 <OsEventWrite+0x100>
                exitFlag = 1;
 8018c48:	2301      	movs	r3, #1
 8018c4a:	74fb      	strb	r3, [r7, #19]
                OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
 8018c4c:	2108      	movs	r1, #8
 8018c4e:	69b8      	ldr	r0, [r7, #24]
 8018c50:	f7eb f8c2 	bl	8003dd8 <OsTaskWake>
            }
            if (once == TRUE) {
 8018c54:	687b      	ldr	r3, [r7, #4]
 8018c56:	2b01      	cmp	r3, #1
 8018c58:	d009      	beq.n	8018c6e <OsEventWrite+0x11a>
                break;
            }
            resumedTask = nextTask;
 8018c5a:	69fb      	ldr	r3, [r7, #28]
 8018c5c:	61bb      	str	r3, [r7, #24]
             &resumedTask->pendList != &eventCB->stEventList;) {
 8018c5e:	69bb      	ldr	r3, [r7, #24]
 8018c60:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8018c64:	68fb      	ldr	r3, [r7, #12]
 8018c66:	3304      	adds	r3, #4
        for (resumedTask = LOS_DL_LIST_ENTRY((&eventCB->stEventList)->pstNext, LosTaskCB, pendList);
 8018c68:	429a      	cmp	r2, r3
 8018c6a:	d1ce      	bne.n	8018c0a <OsEventWrite+0xb6>
 8018c6c:	e000      	b.n	8018c70 <OsEventWrite+0x11c>
                break;
 8018c6e:	bf00      	nop
        }
    }

    SCHEDULER_UNLOCK(intSave);
 8018c70:	697b      	ldr	r3, [r7, #20]
 8018c72:	4619      	mov	r1, r3
 8018c74:	480f      	ldr	r0, [pc, #60]	; (8018cb4 <OsEventWrite+0x160>)
 8018c76:	f7ff fd63 	bl	8018740 <LOS_SpinUnlockRestore>

    if (exitFlag == 1) {
 8018c7a:	7cfb      	ldrb	r3, [r7, #19]
 8018c7c:	2b01      	cmp	r3, #1
 8018c7e:	d104      	bne.n	8018c8a <OsEventWrite+0x136>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 8018c80:	2001      	movs	r0, #1
 8018c82:	f7ff fd7b 	bl	801877c <LOS_MpSchedule>
        LOS_Schedule();
 8018c86:	f7ff fd3d 	bl	8018704 <LOS_Schedule>
    }
    return LOS_OK;
 8018c8a:	2300      	movs	r3, #0
}
 8018c8c:	4a05      	ldr	r2, [pc, #20]	; (8018ca4 <OsEventWrite+0x150>)
 8018c8e:	6811      	ldr	r1, [r2, #0]
 8018c90:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8018c92:	4051      	eors	r1, r2
 8018c94:	d001      	beq.n	8018c9a <OsEventWrite+0x146>
 8018c96:	f7eb fba7 	bl	80043e8 <__stack_chk_fail>
 8018c9a:	4618      	mov	r0, r3
 8018c9c:	373c      	adds	r7, #60	; 0x3c
 8018c9e:	46bd      	mov	sp, r7
 8018ca0:	bd90      	pop	{r4, r7, pc}
 8018ca2:	bf00      	nop
 8018ca4:	08023090 	.word	0x08023090
 8018ca8:	02001c06 	.word	0x02001c06
 8018cac:	02001c00 	.word	0x02001c00
 8018cb0:	2000075c 	.word	0x2000075c
 8018cb4:	20000764 	.word	0x20000764

08018cb8 <LOS_EventRead>:
    SCHEDULER_UNLOCK(intSave);
    return ret;
}

LITE_OS_SEC_TEXT UINT32 LOS_EventRead(PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode, UINT32 timeout)
{
 8018cb8:	b580      	push	{r7, lr}
 8018cba:	b086      	sub	sp, #24
 8018cbc:	af02      	add	r7, sp, #8
 8018cbe:	60f8      	str	r0, [r7, #12]
 8018cc0:	60b9      	str	r1, [r7, #8]
 8018cc2:	607a      	str	r2, [r7, #4]
 8018cc4:	603b      	str	r3, [r7, #0]
    return OsEventRead(eventCB, eventMask, mode, timeout, FALSE);
 8018cc6:	2300      	movs	r3, #0
 8018cc8:	9300      	str	r3, [sp, #0]
 8018cca:	683b      	ldr	r3, [r7, #0]
 8018ccc:	687a      	ldr	r2, [r7, #4]
 8018cce:	68b9      	ldr	r1, [r7, #8]
 8018cd0:	68f8      	ldr	r0, [r7, #12]
 8018cd2:	f7ff fed5 	bl	8018a80 <OsEventRead>
 8018cd6:	4603      	mov	r3, r0
}
 8018cd8:	4618      	mov	r0, r3
 8018cda:	3710      	adds	r7, #16
 8018cdc:	46bd      	mov	sp, r7
 8018cde:	bd80      	pop	{r7, pc}

08018ce0 <LOS_EventWrite>:

LITE_OS_SEC_TEXT UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events)
{
 8018ce0:	b580      	push	{r7, lr}
 8018ce2:	b082      	sub	sp, #8
 8018ce4:	af00      	add	r7, sp, #0
 8018ce6:	6078      	str	r0, [r7, #4]
 8018ce8:	6039      	str	r1, [r7, #0]
    return OsEventWrite(eventCB, events, FALSE);
 8018cea:	2200      	movs	r2, #0
 8018cec:	6839      	ldr	r1, [r7, #0]
 8018cee:	6878      	ldr	r0, [r7, #4]
 8018cf0:	f7ff ff30 	bl	8018b54 <OsEventWrite>
 8018cf4:	4603      	mov	r3, r0
}
 8018cf6:	4618      	mov	r0, r3
 8018cf8:	3708      	adds	r7, #8
 8018cfa:	46bd      	mov	sp, r7
 8018cfc:	bd80      	pop	{r7, pc}
	...

08018d00 <LOS_EventDestroy>:

LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventDestroy(PEVENT_CB_S eventCB)
{
 8018d00:	b590      	push	{r4, r7, lr}
 8018d02:	b08b      	sub	sp, #44	; 0x2c
 8018d04:	af00      	add	r7, sp, #0
 8018d06:	6078      	str	r0, [r7, #4]
 8018d08:	4b29      	ldr	r3, [pc, #164]	; (8018db0 <LOS_EventDestroy+0xb0>)
 8018d0a:	681b      	ldr	r3, [r3, #0]
 8018d0c:	627b      	str	r3, [r7, #36]	; 0x24
 8018d0e:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 ret = LOS_OK;
 8018d12:	2300      	movs	r3, #0
 8018d14:	613b      	str	r3, [r7, #16]

    if (eventCB == NULL) {
 8018d16:	687b      	ldr	r3, [r7, #4]
 8018d18:	2b00      	cmp	r3, #0
 8018d1a:	d101      	bne.n	8018d20 <LOS_EventDestroy+0x20>
        return LOS_ERRNO_EVENT_PTR_NULL;
 8018d1c:	4b25      	ldr	r3, [pc, #148]	; (8018db4 <LOS_EventDestroy+0xb4>)
 8018d1e:	e03b      	b.n	8018d98 <LOS_EventDestroy+0x98>
    }

    SCHEDULER_LOCK(intSave);
 8018d20:	f107 030c 	add.w	r3, r7, #12
 8018d24:	4619      	mov	r1, r3
 8018d26:	4824      	ldr	r0, [pc, #144]	; (8018db8 <LOS_EventDestroy+0xb8>)
 8018d28:	f7ff fcfc 	bl	8018724 <LOS_SpinLockSave>
    if (!LOS_ListEmpty(&eventCB->stEventList)) {
 8018d2c:	687b      	ldr	r3, [r7, #4]
 8018d2e:	3304      	adds	r3, #4
 8018d30:	4618      	mov	r0, r3
 8018d32:	f7ff fc75 	bl	8018620 <LOS_ListEmpty>
 8018d36:	4603      	mov	r3, r0
 8018d38:	2b00      	cmp	r3, #0
 8018d3a:	d102      	bne.n	8018d42 <LOS_EventDestroy+0x42>
        ret = LOS_ERRNO_EVENT_SHOULD_NOT_DESTORY;
 8018d3c:	4b1f      	ldr	r3, [pc, #124]	; (8018dbc <LOS_EventDestroy+0xbc>)
 8018d3e:	613b      	str	r3, [r7, #16]
        goto OUT;
 8018d40:	e002      	b.n	8018d48 <LOS_EventDestroy+0x48>
    }

    eventCB->uwEventID = 0;
 8018d42:	687b      	ldr	r3, [r7, #4]
 8018d44:	2200      	movs	r2, #0
 8018d46:	601a      	str	r2, [r3, #0]
OUT:
    SCHEDULER_UNLOCK(intSave);
 8018d48:	68fb      	ldr	r3, [r7, #12]
 8018d4a:	4619      	mov	r1, r3
 8018d4c:	481a      	ldr	r0, [pc, #104]	; (8018db8 <LOS_EventDestroy+0xb8>)
 8018d4e:	f7ff fcf7 	bl	8018740 <LOS_SpinUnlockRestore>

    LOS_TRACE(EVENT_DELETE, (UINTPTR)eventCB, ret);
 8018d52:	2300      	movs	r3, #0
 8018d54:	61bb      	str	r3, [r7, #24]
 8018d56:	687b      	ldr	r3, [r7, #4]
 8018d58:	61fb      	str	r3, [r7, #28]
 8018d5a:	693b      	ldr	r3, [r7, #16]
 8018d5c:	623b      	str	r3, [r7, #32]
 8018d5e:	2303      	movs	r3, #3
 8018d60:	617b      	str	r3, [r7, #20]
 8018d62:	697b      	ldr	r3, [r7, #20]
 8018d64:	2b01      	cmp	r3, #1
 8018d66:	d916      	bls.n	8018d96 <LOS_EventDestroy+0x96>
 8018d68:	4b15      	ldr	r3, [pc, #84]	; (8018dc0 <LOS_EventDestroy+0xc0>)
 8018d6a:	681b      	ldr	r3, [r3, #0]
 8018d6c:	2b00      	cmp	r3, #0
 8018d6e:	d012      	beq.n	8018d96 <LOS_EventDestroy+0x96>
 8018d70:	4b13      	ldr	r3, [pc, #76]	; (8018dc0 <LOS_EventDestroy+0xc0>)
 8018d72:	681c      	ldr	r4, [r3, #0]
 8018d74:	69f9      	ldr	r1, [r7, #28]
 8018d76:	697b      	ldr	r3, [r7, #20]
 8018d78:	2b02      	cmp	r3, #2
 8018d7a:	d904      	bls.n	8018d86 <LOS_EventDestroy+0x86>
 8018d7c:	f107 0318 	add.w	r3, r7, #24
 8018d80:	f103 0208 	add.w	r2, r3, #8
 8018d84:	e000      	b.n	8018d88 <LOS_EventDestroy+0x88>
 8018d86:	2200      	movs	r2, #0
 8018d88:	697b      	ldr	r3, [r7, #20]
 8018d8a:	b29b      	uxth	r3, r3
 8018d8c:	3b02      	subs	r3, #2
 8018d8e:	b29b      	uxth	r3, r3
 8018d90:	f240 4001 	movw	r0, #1025	; 0x401
 8018d94:	47a0      	blx	r4
    return ret;
 8018d96:	693b      	ldr	r3, [r7, #16]
}
 8018d98:	4a05      	ldr	r2, [pc, #20]	; (8018db0 <LOS_EventDestroy+0xb0>)
 8018d9a:	6811      	ldr	r1, [r2, #0]
 8018d9c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018d9e:	4051      	eors	r1, r2
 8018da0:	d001      	beq.n	8018da6 <LOS_EventDestroy+0xa6>
 8018da2:	f7eb fb21 	bl	80043e8 <__stack_chk_fail>
 8018da6:	4618      	mov	r0, r3
 8018da8:	372c      	adds	r7, #44	; 0x2c
 8018daa:	46bd      	mov	sp, r7
 8018dac:	bd90      	pop	{r4, r7, pc}
 8018dae:	bf00      	nop
 8018db0:	08023098 	.word	0x08023098
 8018db4:	02001c06 	.word	0x02001c06
 8018db8:	20000764 	.word	0x20000764
 8018dbc:	02001c08 	.word	0x02001c08
 8018dc0:	2000075c 	.word	0x2000075c

08018dc4 <LOS_EventClear>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_EventClear(PEVENT_CB_S eventCB, UINT32 events)
{
 8018dc4:	b590      	push	{r4, r7, lr}
 8018dc6:	b08b      	sub	sp, #44	; 0x2c
 8018dc8:	af00      	add	r7, sp, #0
 8018dca:	6078      	str	r0, [r7, #4]
 8018dcc:	6039      	str	r1, [r7, #0]
 8018dce:	4b26      	ldr	r3, [pc, #152]	; (8018e68 <LOS_EventClear+0xa4>)
 8018dd0:	681b      	ldr	r3, [r3, #0]
 8018dd2:	627b      	str	r3, [r7, #36]	; 0x24
 8018dd4:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    if (eventCB == NULL) {
 8018dd8:	687b      	ldr	r3, [r7, #4]
 8018dda:	2b00      	cmp	r3, #0
 8018ddc:	d101      	bne.n	8018de2 <LOS_EventClear+0x1e>
        return LOS_ERRNO_EVENT_PTR_NULL;
 8018dde:	4b23      	ldr	r3, [pc, #140]	; (8018e6c <LOS_EventClear+0xa8>)
 8018de0:	e036      	b.n	8018e50 <LOS_EventClear+0x8c>
    }

    LOS_TRACE(EVENT_CLEAR, (UINTPTR)eventCB, eventCB->uwEventID, events);
 8018de2:	2300      	movs	r3, #0
 8018de4:	617b      	str	r3, [r7, #20]
 8018de6:	687b      	ldr	r3, [r7, #4]
 8018de8:	61bb      	str	r3, [r7, #24]
 8018dea:	687b      	ldr	r3, [r7, #4]
 8018dec:	681b      	ldr	r3, [r3, #0]
 8018dee:	61fb      	str	r3, [r7, #28]
 8018df0:	683b      	ldr	r3, [r7, #0]
 8018df2:	623b      	str	r3, [r7, #32]
 8018df4:	2304      	movs	r3, #4
 8018df6:	613b      	str	r3, [r7, #16]
 8018df8:	693b      	ldr	r3, [r7, #16]
 8018dfa:	2b01      	cmp	r3, #1
 8018dfc:	d916      	bls.n	8018e2c <LOS_EventClear+0x68>
 8018dfe:	4b1c      	ldr	r3, [pc, #112]	; (8018e70 <LOS_EventClear+0xac>)
 8018e00:	681b      	ldr	r3, [r3, #0]
 8018e02:	2b00      	cmp	r3, #0
 8018e04:	d012      	beq.n	8018e2c <LOS_EventClear+0x68>
 8018e06:	4b1a      	ldr	r3, [pc, #104]	; (8018e70 <LOS_EventClear+0xac>)
 8018e08:	681c      	ldr	r4, [r3, #0]
 8018e0a:	69b9      	ldr	r1, [r7, #24]
 8018e0c:	693b      	ldr	r3, [r7, #16]
 8018e0e:	2b02      	cmp	r3, #2
 8018e10:	d904      	bls.n	8018e1c <LOS_EventClear+0x58>
 8018e12:	f107 0314 	add.w	r3, r7, #20
 8018e16:	f103 0208 	add.w	r2, r3, #8
 8018e1a:	e000      	b.n	8018e1e <LOS_EventClear+0x5a>
 8018e1c:	2200      	movs	r2, #0
 8018e1e:	693b      	ldr	r3, [r7, #16]
 8018e20:	b29b      	uxth	r3, r3
 8018e22:	3b02      	subs	r3, #2
 8018e24:	b29b      	uxth	r3, r3
 8018e26:	f240 4004 	movw	r0, #1028	; 0x404
 8018e2a:	47a0      	blx	r4

    SCHEDULER_LOCK(intSave);
 8018e2c:	f107 030c 	add.w	r3, r7, #12
 8018e30:	4619      	mov	r1, r3
 8018e32:	4810      	ldr	r0, [pc, #64]	; (8018e74 <LOS_EventClear+0xb0>)
 8018e34:	f7ff fc76 	bl	8018724 <LOS_SpinLockSave>
    eventCB->uwEventID &= events;
 8018e38:	687b      	ldr	r3, [r7, #4]
 8018e3a:	681a      	ldr	r2, [r3, #0]
 8018e3c:	683b      	ldr	r3, [r7, #0]
 8018e3e:	401a      	ands	r2, r3
 8018e40:	687b      	ldr	r3, [r7, #4]
 8018e42:	601a      	str	r2, [r3, #0]
    SCHEDULER_UNLOCK(intSave);
 8018e44:	68fb      	ldr	r3, [r7, #12]
 8018e46:	4619      	mov	r1, r3
 8018e48:	480a      	ldr	r0, [pc, #40]	; (8018e74 <LOS_EventClear+0xb0>)
 8018e4a:	f7ff fc79 	bl	8018740 <LOS_SpinUnlockRestore>

    return LOS_OK;
 8018e4e:	2300      	movs	r3, #0
}
 8018e50:	4a05      	ldr	r2, [pc, #20]	; (8018e68 <LOS_EventClear+0xa4>)
 8018e52:	6811      	ldr	r1, [r2, #0]
 8018e54:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018e56:	4051      	eors	r1, r2
 8018e58:	d001      	beq.n	8018e5e <LOS_EventClear+0x9a>
 8018e5a:	f7eb fac5 	bl	80043e8 <__stack_chk_fail>
 8018e5e:	4618      	mov	r0, r3
 8018e60:	372c      	adds	r7, #44	; 0x2c
 8018e62:	46bd      	mov	sp, r7
 8018e64:	bd90      	pop	{r4, r7, pc}
 8018e66:	bf00      	nop
 8018e68:	0802309c 	.word	0x0802309c
 8018e6c:	02001c06 	.word	0x02001c06
 8018e70:	2000075c 	.word	0x2000075c
 8018e74:	20000764 	.word	0x20000764

08018e78 <DemoEntry>:
    }
}
#endif /* LOSCFG_COMPONENTS_NETWORK */

VOID DemoEntry(VOID)
{
 8018e78:	b580      	push	{r7, lr}
 8018e7a:	b082      	sub	sp, #8
 8018e7c:	af00      	add	r7, sp, #0
#ifndef LOSCFG_KERNEL_SMP
    printf("Hello, welcome to liteos demo!\n");
 8018e7e:	480f      	ldr	r0, [pc, #60]	; (8018ebc <DemoEntry+0x44>)
 8018e80:	f7f6 fbbc 	bl	800f5fc <printf>
#endif

#ifdef LOSCFG_SHELL
    (VOID)ShellQueueCreat();
 8018e84:	f7f6 fff4 	bl	800fe70 <ShellQueueCreat>
    if (OsShellInit(0) != LOS_OK) {
 8018e88:	2000      	movs	r0, #0
 8018e8a:	f006 f9b7 	bl	801f1fc <OsShellInit>
 8018e8e:	4603      	mov	r3, r0
 8018e90:	2b00      	cmp	r3, #0
 8018e92:	d002      	beq.n	8018e9a <DemoEntry+0x22>
        printf("Shell init failed.\n");
 8018e94:	480a      	ldr	r0, [pc, #40]	; (8018ec0 <DemoEntry+0x48>)
 8018e96:	f7f6 fbb1 	bl	800f5fc <printf>
    FileSystemInit();
#endif

#ifdef LOSCFG_KERNEL_CPPSUPPORT
    extern UINT32 __init_array_start, __init_array_end;
    INT32 ret = LOS_CppSystemInit((UINT32)&__init_array_start, (UINT32)&__init_array_end, NO_SCATTER);
 8018e9a:	4b0a      	ldr	r3, [pc, #40]	; (8018ec4 <DemoEntry+0x4c>)
 8018e9c:	490a      	ldr	r1, [pc, #40]	; (8018ec8 <DemoEntry+0x50>)
 8018e9e:	2202      	movs	r2, #2
 8018ea0:	4618      	mov	r0, r3
 8018ea2:	f006 fd7d 	bl	801f9a0 <LOS_CppSystemInit>
 8018ea6:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 8018ea8:	687b      	ldr	r3, [r7, #4]
 8018eaa:	2b00      	cmp	r3, #0
 8018eac:	d002      	beq.n	8018eb4 <DemoEntry+0x3c>
        printf("LiteOS Cpp Init fail.\n");
 8018eae:	4807      	ldr	r0, [pc, #28]	; (8018ecc <DemoEntry+0x54>)
 8018eb0:	f7f6 fba4 	bl	800f5fc <printf>
#endif

#ifdef LOSCFG_DEMOS_APRILTAG
    ApriltagDemoTask();
#endif
}
 8018eb4:	bf00      	nop
 8018eb6:	3708      	adds	r7, #8
 8018eb8:	46bd      	mov	sp, r7
 8018eba:	bd80      	pop	{r7, pc}
 8018ebc:	080230a4 	.word	0x080230a4
 8018ec0:	080230c4 	.word	0x080230c4
 8018ec4:	080243ac 	.word	0x080243ac
 8018ec8:	080243ac 	.word	0x080243ac
 8018ecc:	080230d8 	.word	0x080230d8

08018ed0 <memcpy>:
#include <string.h>
#include <stdint.h>
#include <endian.h>

void *memcpy(void *restrict dest, const void *restrict src, size_t n)
{
 8018ed0:	b480      	push	{r7}
 8018ed2:	b089      	sub	sp, #36	; 0x24
 8018ed4:	af00      	add	r7, sp, #0
 8018ed6:	60f8      	str	r0, [r7, #12]
 8018ed8:	60b9      	str	r1, [r7, #8]
 8018eda:	607a      	str	r2, [r7, #4]
	unsigned char *d = dest;
 8018edc:	68fb      	ldr	r3, [r7, #12]
 8018ede:	613b      	str	r3, [r7, #16]
	const unsigned char *s = src;
 8018ee0:	68bb      	ldr	r3, [r7, #8]
 8018ee2:	617b      	str	r3, [r7, #20]
#endif

	typedef uint32_t __attribute__((__may_alias__)) u32;
	uint32_t w, x;

	for (; (uintptr_t)s % 4 && n; n--) *d++ = *s++;
 8018ee4:	e00a      	b.n	8018efc <memcpy+0x2c>
 8018ee6:	697a      	ldr	r2, [r7, #20]
 8018ee8:	1c53      	adds	r3, r2, #1
 8018eea:	617b      	str	r3, [r7, #20]
 8018eec:	693b      	ldr	r3, [r7, #16]
 8018eee:	1c59      	adds	r1, r3, #1
 8018ef0:	6139      	str	r1, [r7, #16]
 8018ef2:	7812      	ldrb	r2, [r2, #0]
 8018ef4:	701a      	strb	r2, [r3, #0]
 8018ef6:	687b      	ldr	r3, [r7, #4]
 8018ef8:	3b01      	subs	r3, #1
 8018efa:	607b      	str	r3, [r7, #4]
 8018efc:	697b      	ldr	r3, [r7, #20]
 8018efe:	f003 0303 	and.w	r3, r3, #3
 8018f02:	2b00      	cmp	r3, #0
 8018f04:	d002      	beq.n	8018f0c <memcpy+0x3c>
 8018f06:	687b      	ldr	r3, [r7, #4]
 8018f08:	2b00      	cmp	r3, #0
 8018f0a:	d1ec      	bne.n	8018ee6 <memcpy+0x16>

	if ((uintptr_t)d % 4 == 0) {
 8018f0c:	693b      	ldr	r3, [r7, #16]
 8018f0e:	f003 0303 	and.w	r3, r3, #3
 8018f12:	2b00      	cmp	r3, #0
 8018f14:	d168      	bne.n	8018fe8 <memcpy+0x118>
		for (; n>=16; s+=16, d+=16, n-=16) {
 8018f16:	e020      	b.n	8018f5a <memcpy+0x8a>
			*(u32 *)(d+0) = *(u32 *)(s+0);
 8018f18:	697b      	ldr	r3, [r7, #20]
 8018f1a:	681a      	ldr	r2, [r3, #0]
 8018f1c:	693b      	ldr	r3, [r7, #16]
 8018f1e:	601a      	str	r2, [r3, #0]
			*(u32 *)(d+4) = *(u32 *)(s+4);
 8018f20:	697b      	ldr	r3, [r7, #20]
 8018f22:	1d1a      	adds	r2, r3, #4
 8018f24:	693b      	ldr	r3, [r7, #16]
 8018f26:	3304      	adds	r3, #4
 8018f28:	6812      	ldr	r2, [r2, #0]
 8018f2a:	601a      	str	r2, [r3, #0]
			*(u32 *)(d+8) = *(u32 *)(s+8);
 8018f2c:	697b      	ldr	r3, [r7, #20]
 8018f2e:	f103 0208 	add.w	r2, r3, #8
 8018f32:	693b      	ldr	r3, [r7, #16]
 8018f34:	3308      	adds	r3, #8
 8018f36:	6812      	ldr	r2, [r2, #0]
 8018f38:	601a      	str	r2, [r3, #0]
			*(u32 *)(d+12) = *(u32 *)(s+12);
 8018f3a:	697b      	ldr	r3, [r7, #20]
 8018f3c:	f103 020c 	add.w	r2, r3, #12
 8018f40:	693b      	ldr	r3, [r7, #16]
 8018f42:	330c      	adds	r3, #12
 8018f44:	6812      	ldr	r2, [r2, #0]
 8018f46:	601a      	str	r2, [r3, #0]
		for (; n>=16; s+=16, d+=16, n-=16) {
 8018f48:	697b      	ldr	r3, [r7, #20]
 8018f4a:	3310      	adds	r3, #16
 8018f4c:	617b      	str	r3, [r7, #20]
 8018f4e:	693b      	ldr	r3, [r7, #16]
 8018f50:	3310      	adds	r3, #16
 8018f52:	613b      	str	r3, [r7, #16]
 8018f54:	687b      	ldr	r3, [r7, #4]
 8018f56:	3b10      	subs	r3, #16
 8018f58:	607b      	str	r3, [r7, #4]
 8018f5a:	687b      	ldr	r3, [r7, #4]
 8018f5c:	2b0f      	cmp	r3, #15
 8018f5e:	d8db      	bhi.n	8018f18 <memcpy+0x48>
		}
		if (n&8) {
 8018f60:	687b      	ldr	r3, [r7, #4]
 8018f62:	f003 0308 	and.w	r3, r3, #8
 8018f66:	2b00      	cmp	r3, #0
 8018f68:	d00f      	beq.n	8018f8a <memcpy+0xba>
			*(u32 *)(d+0) = *(u32 *)(s+0);
 8018f6a:	697b      	ldr	r3, [r7, #20]
 8018f6c:	681a      	ldr	r2, [r3, #0]
 8018f6e:	693b      	ldr	r3, [r7, #16]
 8018f70:	601a      	str	r2, [r3, #0]
			*(u32 *)(d+4) = *(u32 *)(s+4);
 8018f72:	697b      	ldr	r3, [r7, #20]
 8018f74:	1d1a      	adds	r2, r3, #4
 8018f76:	693b      	ldr	r3, [r7, #16]
 8018f78:	3304      	adds	r3, #4
 8018f7a:	6812      	ldr	r2, [r2, #0]
 8018f7c:	601a      	str	r2, [r3, #0]
			d += 8; s += 8;
 8018f7e:	693b      	ldr	r3, [r7, #16]
 8018f80:	3308      	adds	r3, #8
 8018f82:	613b      	str	r3, [r7, #16]
 8018f84:	697b      	ldr	r3, [r7, #20]
 8018f86:	3308      	adds	r3, #8
 8018f88:	617b      	str	r3, [r7, #20]
		}
		if (n&4) {
 8018f8a:	687b      	ldr	r3, [r7, #4]
 8018f8c:	f003 0304 	and.w	r3, r3, #4
 8018f90:	2b00      	cmp	r3, #0
 8018f92:	d009      	beq.n	8018fa8 <memcpy+0xd8>
			*(u32 *)(d+0) = *(u32 *)(s+0);
 8018f94:	697b      	ldr	r3, [r7, #20]
 8018f96:	681a      	ldr	r2, [r3, #0]
 8018f98:	693b      	ldr	r3, [r7, #16]
 8018f9a:	601a      	str	r2, [r3, #0]
			d += 4; s += 4;
 8018f9c:	693b      	ldr	r3, [r7, #16]
 8018f9e:	3304      	adds	r3, #4
 8018fa0:	613b      	str	r3, [r7, #16]
 8018fa2:	697b      	ldr	r3, [r7, #20]
 8018fa4:	3304      	adds	r3, #4
 8018fa6:	617b      	str	r3, [r7, #20]
		}
		if (n&2) {
 8018fa8:	687b      	ldr	r3, [r7, #4]
 8018faa:	f003 0302 	and.w	r3, r3, #2
 8018fae:	2b00      	cmp	r3, #0
 8018fb0:	d00f      	beq.n	8018fd2 <memcpy+0x102>
			*d++ = *s++; *d++ = *s++;
 8018fb2:	697a      	ldr	r2, [r7, #20]
 8018fb4:	1c53      	adds	r3, r2, #1
 8018fb6:	617b      	str	r3, [r7, #20]
 8018fb8:	693b      	ldr	r3, [r7, #16]
 8018fba:	1c59      	adds	r1, r3, #1
 8018fbc:	6139      	str	r1, [r7, #16]
 8018fbe:	7812      	ldrb	r2, [r2, #0]
 8018fc0:	701a      	strb	r2, [r3, #0]
 8018fc2:	697a      	ldr	r2, [r7, #20]
 8018fc4:	1c53      	adds	r3, r2, #1
 8018fc6:	617b      	str	r3, [r7, #20]
 8018fc8:	693b      	ldr	r3, [r7, #16]
 8018fca:	1c59      	adds	r1, r3, #1
 8018fcc:	6139      	str	r1, [r7, #16]
 8018fce:	7812      	ldrb	r2, [r2, #0]
 8018fd0:	701a      	strb	r2, [r3, #0]
		}
		if (n&1) {
 8018fd2:	687b      	ldr	r3, [r7, #4]
 8018fd4:	f003 0301 	and.w	r3, r3, #1
 8018fd8:	2b00      	cmp	r3, #0
 8018fda:	d003      	beq.n	8018fe4 <memcpy+0x114>
			*d = *s;
 8018fdc:	697b      	ldr	r3, [r7, #20]
 8018fde:	781a      	ldrb	r2, [r3, #0]
 8018fe0:	693b      	ldr	r3, [r7, #16]
 8018fe2:	701a      	strb	r2, [r3, #0]
		}
		return dest;
 8018fe4:	68fb      	ldr	r3, [r7, #12]
 8018fe6:	e219      	b.n	801941c <memcpy+0x54c>
	}

	if (n >= 32) switch ((uintptr_t)d % 4) {
 8018fe8:	687b      	ldr	r3, [r7, #4]
 8018fea:	2b1f      	cmp	r3, #31
 8018fec:	f240 8107 	bls.w	80191fe <memcpy+0x32e>
 8018ff0:	693b      	ldr	r3, [r7, #16]
 8018ff2:	f003 0303 	and.w	r3, r3, #3
 8018ff6:	2b03      	cmp	r3, #3
 8018ff8:	f000 80b6 	beq.w	8019168 <memcpy+0x298>
 8018ffc:	2b03      	cmp	r3, #3
 8018ffe:	f200 80ff 	bhi.w	8019200 <memcpy+0x330>
 8019002:	2b01      	cmp	r3, #1
 8019004:	d002      	beq.n	801900c <memcpy+0x13c>
 8019006:	2b02      	cmp	r3, #2
 8019008:	d05b      	beq.n	80190c2 <memcpy+0x1f2>
 801900a:	e0f9      	b.n	8019200 <memcpy+0x330>
	case 1:
		w = *(u32 *)s;
 801900c:	697b      	ldr	r3, [r7, #20]
 801900e:	681b      	ldr	r3, [r3, #0]
 8019010:	61bb      	str	r3, [r7, #24]
		*d++ = *s++;
 8019012:	697a      	ldr	r2, [r7, #20]
 8019014:	1c53      	adds	r3, r2, #1
 8019016:	617b      	str	r3, [r7, #20]
 8019018:	693b      	ldr	r3, [r7, #16]
 801901a:	1c59      	adds	r1, r3, #1
 801901c:	6139      	str	r1, [r7, #16]
 801901e:	7812      	ldrb	r2, [r2, #0]
 8019020:	701a      	strb	r2, [r3, #0]
		*d++ = *s++;
 8019022:	697a      	ldr	r2, [r7, #20]
 8019024:	1c53      	adds	r3, r2, #1
 8019026:	617b      	str	r3, [r7, #20]
 8019028:	693b      	ldr	r3, [r7, #16]
 801902a:	1c59      	adds	r1, r3, #1
 801902c:	6139      	str	r1, [r7, #16]
 801902e:	7812      	ldrb	r2, [r2, #0]
 8019030:	701a      	strb	r2, [r3, #0]
		*d++ = *s++;
 8019032:	697a      	ldr	r2, [r7, #20]
 8019034:	1c53      	adds	r3, r2, #1
 8019036:	617b      	str	r3, [r7, #20]
 8019038:	693b      	ldr	r3, [r7, #16]
 801903a:	1c59      	adds	r1, r3, #1
 801903c:	6139      	str	r1, [r7, #16]
 801903e:	7812      	ldrb	r2, [r2, #0]
 8019040:	701a      	strb	r2, [r3, #0]
		n -= 3;
 8019042:	687b      	ldr	r3, [r7, #4]
 8019044:	3b03      	subs	r3, #3
 8019046:	607b      	str	r3, [r7, #4]
		for (; n>=17; s+=16, d+=16, n-=16) {
 8019048:	e037      	b.n	80190ba <memcpy+0x1ea>
			x = *(u32 *)(s+1);
 801904a:	697b      	ldr	r3, [r7, #20]
 801904c:	3301      	adds	r3, #1
 801904e:	681b      	ldr	r3, [r3, #0]
 8019050:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+0) = (w LS 24) | (x RS 8);
 8019052:	69bb      	ldr	r3, [r7, #24]
 8019054:	0e1a      	lsrs	r2, r3, #24
 8019056:	69fb      	ldr	r3, [r7, #28]
 8019058:	021b      	lsls	r3, r3, #8
 801905a:	431a      	orrs	r2, r3
 801905c:	693b      	ldr	r3, [r7, #16]
 801905e:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+5);
 8019060:	697b      	ldr	r3, [r7, #20]
 8019062:	3305      	adds	r3, #5
 8019064:	681b      	ldr	r3, [r3, #0]
 8019066:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+4) = (x LS 24) | (w RS 8);
 8019068:	69fb      	ldr	r3, [r7, #28]
 801906a:	0e19      	lsrs	r1, r3, #24
 801906c:	69bb      	ldr	r3, [r7, #24]
 801906e:	021a      	lsls	r2, r3, #8
 8019070:	693b      	ldr	r3, [r7, #16]
 8019072:	3304      	adds	r3, #4
 8019074:	430a      	orrs	r2, r1
 8019076:	601a      	str	r2, [r3, #0]
			x = *(u32 *)(s+9);
 8019078:	697b      	ldr	r3, [r7, #20]
 801907a:	3309      	adds	r3, #9
 801907c:	681b      	ldr	r3, [r3, #0]
 801907e:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+8) = (w LS 24) | (x RS 8);
 8019080:	69bb      	ldr	r3, [r7, #24]
 8019082:	0e19      	lsrs	r1, r3, #24
 8019084:	69fb      	ldr	r3, [r7, #28]
 8019086:	021a      	lsls	r2, r3, #8
 8019088:	693b      	ldr	r3, [r7, #16]
 801908a:	3308      	adds	r3, #8
 801908c:	430a      	orrs	r2, r1
 801908e:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+13);
 8019090:	697b      	ldr	r3, [r7, #20]
 8019092:	330d      	adds	r3, #13
 8019094:	681b      	ldr	r3, [r3, #0]
 8019096:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+12) = (x LS 24) | (w RS 8);
 8019098:	69fb      	ldr	r3, [r7, #28]
 801909a:	0e19      	lsrs	r1, r3, #24
 801909c:	69bb      	ldr	r3, [r7, #24]
 801909e:	021a      	lsls	r2, r3, #8
 80190a0:	693b      	ldr	r3, [r7, #16]
 80190a2:	330c      	adds	r3, #12
 80190a4:	430a      	orrs	r2, r1
 80190a6:	601a      	str	r2, [r3, #0]
		for (; n>=17; s+=16, d+=16, n-=16) {
 80190a8:	697b      	ldr	r3, [r7, #20]
 80190aa:	3310      	adds	r3, #16
 80190ac:	617b      	str	r3, [r7, #20]
 80190ae:	693b      	ldr	r3, [r7, #16]
 80190b0:	3310      	adds	r3, #16
 80190b2:	613b      	str	r3, [r7, #16]
 80190b4:	687b      	ldr	r3, [r7, #4]
 80190b6:	3b10      	subs	r3, #16
 80190b8:	607b      	str	r3, [r7, #4]
 80190ba:	687b      	ldr	r3, [r7, #4]
 80190bc:	2b10      	cmp	r3, #16
 80190be:	d8c4      	bhi.n	801904a <memcpy+0x17a>
		}
		break;
 80190c0:	e09e      	b.n	8019200 <memcpy+0x330>
	case 2:
		w = *(u32 *)s;
 80190c2:	697b      	ldr	r3, [r7, #20]
 80190c4:	681b      	ldr	r3, [r3, #0]
 80190c6:	61bb      	str	r3, [r7, #24]
		*d++ = *s++;
 80190c8:	697a      	ldr	r2, [r7, #20]
 80190ca:	1c53      	adds	r3, r2, #1
 80190cc:	617b      	str	r3, [r7, #20]
 80190ce:	693b      	ldr	r3, [r7, #16]
 80190d0:	1c59      	adds	r1, r3, #1
 80190d2:	6139      	str	r1, [r7, #16]
 80190d4:	7812      	ldrb	r2, [r2, #0]
 80190d6:	701a      	strb	r2, [r3, #0]
		*d++ = *s++;
 80190d8:	697a      	ldr	r2, [r7, #20]
 80190da:	1c53      	adds	r3, r2, #1
 80190dc:	617b      	str	r3, [r7, #20]
 80190de:	693b      	ldr	r3, [r7, #16]
 80190e0:	1c59      	adds	r1, r3, #1
 80190e2:	6139      	str	r1, [r7, #16]
 80190e4:	7812      	ldrb	r2, [r2, #0]
 80190e6:	701a      	strb	r2, [r3, #0]
		n -= 2;
 80190e8:	687b      	ldr	r3, [r7, #4]
 80190ea:	3b02      	subs	r3, #2
 80190ec:	607b      	str	r3, [r7, #4]
		for (; n>=18; s+=16, d+=16, n-=16) {
 80190ee:	e037      	b.n	8019160 <memcpy+0x290>
			x = *(u32 *)(s+2);
 80190f0:	697b      	ldr	r3, [r7, #20]
 80190f2:	3302      	adds	r3, #2
 80190f4:	681b      	ldr	r3, [r3, #0]
 80190f6:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+0) = (w LS 16) | (x RS 16);
 80190f8:	69bb      	ldr	r3, [r7, #24]
 80190fa:	0c1a      	lsrs	r2, r3, #16
 80190fc:	69fb      	ldr	r3, [r7, #28]
 80190fe:	041b      	lsls	r3, r3, #16
 8019100:	431a      	orrs	r2, r3
 8019102:	693b      	ldr	r3, [r7, #16]
 8019104:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+6);
 8019106:	697b      	ldr	r3, [r7, #20]
 8019108:	3306      	adds	r3, #6
 801910a:	681b      	ldr	r3, [r3, #0]
 801910c:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+4) = (x LS 16) | (w RS 16);
 801910e:	69fb      	ldr	r3, [r7, #28]
 8019110:	0c19      	lsrs	r1, r3, #16
 8019112:	69bb      	ldr	r3, [r7, #24]
 8019114:	041a      	lsls	r2, r3, #16
 8019116:	693b      	ldr	r3, [r7, #16]
 8019118:	3304      	adds	r3, #4
 801911a:	430a      	orrs	r2, r1
 801911c:	601a      	str	r2, [r3, #0]
			x = *(u32 *)(s+10);
 801911e:	697b      	ldr	r3, [r7, #20]
 8019120:	330a      	adds	r3, #10
 8019122:	681b      	ldr	r3, [r3, #0]
 8019124:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+8) = (w LS 16) | (x RS 16);
 8019126:	69bb      	ldr	r3, [r7, #24]
 8019128:	0c19      	lsrs	r1, r3, #16
 801912a:	69fb      	ldr	r3, [r7, #28]
 801912c:	041a      	lsls	r2, r3, #16
 801912e:	693b      	ldr	r3, [r7, #16]
 8019130:	3308      	adds	r3, #8
 8019132:	430a      	orrs	r2, r1
 8019134:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+14);
 8019136:	697b      	ldr	r3, [r7, #20]
 8019138:	330e      	adds	r3, #14
 801913a:	681b      	ldr	r3, [r3, #0]
 801913c:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+12) = (x LS 16) | (w RS 16);
 801913e:	69fb      	ldr	r3, [r7, #28]
 8019140:	0c19      	lsrs	r1, r3, #16
 8019142:	69bb      	ldr	r3, [r7, #24]
 8019144:	041a      	lsls	r2, r3, #16
 8019146:	693b      	ldr	r3, [r7, #16]
 8019148:	330c      	adds	r3, #12
 801914a:	430a      	orrs	r2, r1
 801914c:	601a      	str	r2, [r3, #0]
		for (; n>=18; s+=16, d+=16, n-=16) {
 801914e:	697b      	ldr	r3, [r7, #20]
 8019150:	3310      	adds	r3, #16
 8019152:	617b      	str	r3, [r7, #20]
 8019154:	693b      	ldr	r3, [r7, #16]
 8019156:	3310      	adds	r3, #16
 8019158:	613b      	str	r3, [r7, #16]
 801915a:	687b      	ldr	r3, [r7, #4]
 801915c:	3b10      	subs	r3, #16
 801915e:	607b      	str	r3, [r7, #4]
 8019160:	687b      	ldr	r3, [r7, #4]
 8019162:	2b11      	cmp	r3, #17
 8019164:	d8c4      	bhi.n	80190f0 <memcpy+0x220>
		}
		break;
 8019166:	e04b      	b.n	8019200 <memcpy+0x330>
	case 3:
		w = *(u32 *)s;
 8019168:	697b      	ldr	r3, [r7, #20]
 801916a:	681b      	ldr	r3, [r3, #0]
 801916c:	61bb      	str	r3, [r7, #24]
		*d++ = *s++;
 801916e:	697a      	ldr	r2, [r7, #20]
 8019170:	1c53      	adds	r3, r2, #1
 8019172:	617b      	str	r3, [r7, #20]
 8019174:	693b      	ldr	r3, [r7, #16]
 8019176:	1c59      	adds	r1, r3, #1
 8019178:	6139      	str	r1, [r7, #16]
 801917a:	7812      	ldrb	r2, [r2, #0]
 801917c:	701a      	strb	r2, [r3, #0]
		n -= 1;
 801917e:	687b      	ldr	r3, [r7, #4]
 8019180:	3b01      	subs	r3, #1
 8019182:	607b      	str	r3, [r7, #4]
		for (; n>=19; s+=16, d+=16, n-=16) {
 8019184:	e037      	b.n	80191f6 <memcpy+0x326>
			x = *(u32 *)(s+3);
 8019186:	697b      	ldr	r3, [r7, #20]
 8019188:	3303      	adds	r3, #3
 801918a:	681b      	ldr	r3, [r3, #0]
 801918c:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+0) = (w LS 8) | (x RS 24);
 801918e:	69bb      	ldr	r3, [r7, #24]
 8019190:	0a1a      	lsrs	r2, r3, #8
 8019192:	69fb      	ldr	r3, [r7, #28]
 8019194:	061b      	lsls	r3, r3, #24
 8019196:	431a      	orrs	r2, r3
 8019198:	693b      	ldr	r3, [r7, #16]
 801919a:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+7);
 801919c:	697b      	ldr	r3, [r7, #20]
 801919e:	3307      	adds	r3, #7
 80191a0:	681b      	ldr	r3, [r3, #0]
 80191a2:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+4) = (x LS 8) | (w RS 24);
 80191a4:	69fb      	ldr	r3, [r7, #28]
 80191a6:	0a19      	lsrs	r1, r3, #8
 80191a8:	69bb      	ldr	r3, [r7, #24]
 80191aa:	061a      	lsls	r2, r3, #24
 80191ac:	693b      	ldr	r3, [r7, #16]
 80191ae:	3304      	adds	r3, #4
 80191b0:	430a      	orrs	r2, r1
 80191b2:	601a      	str	r2, [r3, #0]
			x = *(u32 *)(s+11);
 80191b4:	697b      	ldr	r3, [r7, #20]
 80191b6:	330b      	adds	r3, #11
 80191b8:	681b      	ldr	r3, [r3, #0]
 80191ba:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+8) = (w LS 8) | (x RS 24);
 80191bc:	69bb      	ldr	r3, [r7, #24]
 80191be:	0a19      	lsrs	r1, r3, #8
 80191c0:	69fb      	ldr	r3, [r7, #28]
 80191c2:	061a      	lsls	r2, r3, #24
 80191c4:	693b      	ldr	r3, [r7, #16]
 80191c6:	3308      	adds	r3, #8
 80191c8:	430a      	orrs	r2, r1
 80191ca:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+15);
 80191cc:	697b      	ldr	r3, [r7, #20]
 80191ce:	330f      	adds	r3, #15
 80191d0:	681b      	ldr	r3, [r3, #0]
 80191d2:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+12) = (x LS 8) | (w RS 24);
 80191d4:	69fb      	ldr	r3, [r7, #28]
 80191d6:	0a19      	lsrs	r1, r3, #8
 80191d8:	69bb      	ldr	r3, [r7, #24]
 80191da:	061a      	lsls	r2, r3, #24
 80191dc:	693b      	ldr	r3, [r7, #16]
 80191de:	330c      	adds	r3, #12
 80191e0:	430a      	orrs	r2, r1
 80191e2:	601a      	str	r2, [r3, #0]
		for (; n>=19; s+=16, d+=16, n-=16) {
 80191e4:	697b      	ldr	r3, [r7, #20]
 80191e6:	3310      	adds	r3, #16
 80191e8:	617b      	str	r3, [r7, #20]
 80191ea:	693b      	ldr	r3, [r7, #16]
 80191ec:	3310      	adds	r3, #16
 80191ee:	613b      	str	r3, [r7, #16]
 80191f0:	687b      	ldr	r3, [r7, #4]
 80191f2:	3b10      	subs	r3, #16
 80191f4:	607b      	str	r3, [r7, #4]
 80191f6:	687b      	ldr	r3, [r7, #4]
 80191f8:	2b12      	cmp	r3, #18
 80191fa:	d8c4      	bhi.n	8019186 <memcpy+0x2b6>
		}
		break;
 80191fc:	e000      	b.n	8019200 <memcpy+0x330>
	}
	if (n&16) {
 80191fe:	bf00      	nop
 8019200:	687b      	ldr	r3, [r7, #4]
 8019202:	f003 0310 	and.w	r3, r3, #16
 8019206:	2b00      	cmp	r3, #0
 8019208:	d07f      	beq.n	801930a <memcpy+0x43a>
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 801920a:	697a      	ldr	r2, [r7, #20]
 801920c:	1c53      	adds	r3, r2, #1
 801920e:	617b      	str	r3, [r7, #20]
 8019210:	693b      	ldr	r3, [r7, #16]
 8019212:	1c59      	adds	r1, r3, #1
 8019214:	6139      	str	r1, [r7, #16]
 8019216:	7812      	ldrb	r2, [r2, #0]
 8019218:	701a      	strb	r2, [r3, #0]
 801921a:	697a      	ldr	r2, [r7, #20]
 801921c:	1c53      	adds	r3, r2, #1
 801921e:	617b      	str	r3, [r7, #20]
 8019220:	693b      	ldr	r3, [r7, #16]
 8019222:	1c59      	adds	r1, r3, #1
 8019224:	6139      	str	r1, [r7, #16]
 8019226:	7812      	ldrb	r2, [r2, #0]
 8019228:	701a      	strb	r2, [r3, #0]
 801922a:	697a      	ldr	r2, [r7, #20]
 801922c:	1c53      	adds	r3, r2, #1
 801922e:	617b      	str	r3, [r7, #20]
 8019230:	693b      	ldr	r3, [r7, #16]
 8019232:	1c59      	adds	r1, r3, #1
 8019234:	6139      	str	r1, [r7, #16]
 8019236:	7812      	ldrb	r2, [r2, #0]
 8019238:	701a      	strb	r2, [r3, #0]
 801923a:	697a      	ldr	r2, [r7, #20]
 801923c:	1c53      	adds	r3, r2, #1
 801923e:	617b      	str	r3, [r7, #20]
 8019240:	693b      	ldr	r3, [r7, #16]
 8019242:	1c59      	adds	r1, r3, #1
 8019244:	6139      	str	r1, [r7, #16]
 8019246:	7812      	ldrb	r2, [r2, #0]
 8019248:	701a      	strb	r2, [r3, #0]
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 801924a:	697a      	ldr	r2, [r7, #20]
 801924c:	1c53      	adds	r3, r2, #1
 801924e:	617b      	str	r3, [r7, #20]
 8019250:	693b      	ldr	r3, [r7, #16]
 8019252:	1c59      	adds	r1, r3, #1
 8019254:	6139      	str	r1, [r7, #16]
 8019256:	7812      	ldrb	r2, [r2, #0]
 8019258:	701a      	strb	r2, [r3, #0]
 801925a:	697a      	ldr	r2, [r7, #20]
 801925c:	1c53      	adds	r3, r2, #1
 801925e:	617b      	str	r3, [r7, #20]
 8019260:	693b      	ldr	r3, [r7, #16]
 8019262:	1c59      	adds	r1, r3, #1
 8019264:	6139      	str	r1, [r7, #16]
 8019266:	7812      	ldrb	r2, [r2, #0]
 8019268:	701a      	strb	r2, [r3, #0]
 801926a:	697a      	ldr	r2, [r7, #20]
 801926c:	1c53      	adds	r3, r2, #1
 801926e:	617b      	str	r3, [r7, #20]
 8019270:	693b      	ldr	r3, [r7, #16]
 8019272:	1c59      	adds	r1, r3, #1
 8019274:	6139      	str	r1, [r7, #16]
 8019276:	7812      	ldrb	r2, [r2, #0]
 8019278:	701a      	strb	r2, [r3, #0]
 801927a:	697a      	ldr	r2, [r7, #20]
 801927c:	1c53      	adds	r3, r2, #1
 801927e:	617b      	str	r3, [r7, #20]
 8019280:	693b      	ldr	r3, [r7, #16]
 8019282:	1c59      	adds	r1, r3, #1
 8019284:	6139      	str	r1, [r7, #16]
 8019286:	7812      	ldrb	r2, [r2, #0]
 8019288:	701a      	strb	r2, [r3, #0]
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 801928a:	697a      	ldr	r2, [r7, #20]
 801928c:	1c53      	adds	r3, r2, #1
 801928e:	617b      	str	r3, [r7, #20]
 8019290:	693b      	ldr	r3, [r7, #16]
 8019292:	1c59      	adds	r1, r3, #1
 8019294:	6139      	str	r1, [r7, #16]
 8019296:	7812      	ldrb	r2, [r2, #0]
 8019298:	701a      	strb	r2, [r3, #0]
 801929a:	697a      	ldr	r2, [r7, #20]
 801929c:	1c53      	adds	r3, r2, #1
 801929e:	617b      	str	r3, [r7, #20]
 80192a0:	693b      	ldr	r3, [r7, #16]
 80192a2:	1c59      	adds	r1, r3, #1
 80192a4:	6139      	str	r1, [r7, #16]
 80192a6:	7812      	ldrb	r2, [r2, #0]
 80192a8:	701a      	strb	r2, [r3, #0]
 80192aa:	697a      	ldr	r2, [r7, #20]
 80192ac:	1c53      	adds	r3, r2, #1
 80192ae:	617b      	str	r3, [r7, #20]
 80192b0:	693b      	ldr	r3, [r7, #16]
 80192b2:	1c59      	adds	r1, r3, #1
 80192b4:	6139      	str	r1, [r7, #16]
 80192b6:	7812      	ldrb	r2, [r2, #0]
 80192b8:	701a      	strb	r2, [r3, #0]
 80192ba:	697a      	ldr	r2, [r7, #20]
 80192bc:	1c53      	adds	r3, r2, #1
 80192be:	617b      	str	r3, [r7, #20]
 80192c0:	693b      	ldr	r3, [r7, #16]
 80192c2:	1c59      	adds	r1, r3, #1
 80192c4:	6139      	str	r1, [r7, #16]
 80192c6:	7812      	ldrb	r2, [r2, #0]
 80192c8:	701a      	strb	r2, [r3, #0]
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 80192ca:	697a      	ldr	r2, [r7, #20]
 80192cc:	1c53      	adds	r3, r2, #1
 80192ce:	617b      	str	r3, [r7, #20]
 80192d0:	693b      	ldr	r3, [r7, #16]
 80192d2:	1c59      	adds	r1, r3, #1
 80192d4:	6139      	str	r1, [r7, #16]
 80192d6:	7812      	ldrb	r2, [r2, #0]
 80192d8:	701a      	strb	r2, [r3, #0]
 80192da:	697a      	ldr	r2, [r7, #20]
 80192dc:	1c53      	adds	r3, r2, #1
 80192de:	617b      	str	r3, [r7, #20]
 80192e0:	693b      	ldr	r3, [r7, #16]
 80192e2:	1c59      	adds	r1, r3, #1
 80192e4:	6139      	str	r1, [r7, #16]
 80192e6:	7812      	ldrb	r2, [r2, #0]
 80192e8:	701a      	strb	r2, [r3, #0]
 80192ea:	697a      	ldr	r2, [r7, #20]
 80192ec:	1c53      	adds	r3, r2, #1
 80192ee:	617b      	str	r3, [r7, #20]
 80192f0:	693b      	ldr	r3, [r7, #16]
 80192f2:	1c59      	adds	r1, r3, #1
 80192f4:	6139      	str	r1, [r7, #16]
 80192f6:	7812      	ldrb	r2, [r2, #0]
 80192f8:	701a      	strb	r2, [r3, #0]
 80192fa:	697a      	ldr	r2, [r7, #20]
 80192fc:	1c53      	adds	r3, r2, #1
 80192fe:	617b      	str	r3, [r7, #20]
 8019300:	693b      	ldr	r3, [r7, #16]
 8019302:	1c59      	adds	r1, r3, #1
 8019304:	6139      	str	r1, [r7, #16]
 8019306:	7812      	ldrb	r2, [r2, #0]
 8019308:	701a      	strb	r2, [r3, #0]
	}
	if (n&8) {
 801930a:	687b      	ldr	r3, [r7, #4]
 801930c:	f003 0308 	and.w	r3, r3, #8
 8019310:	2b00      	cmp	r3, #0
 8019312:	d03f      	beq.n	8019394 <memcpy+0x4c4>
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 8019314:	697a      	ldr	r2, [r7, #20]
 8019316:	1c53      	adds	r3, r2, #1
 8019318:	617b      	str	r3, [r7, #20]
 801931a:	693b      	ldr	r3, [r7, #16]
 801931c:	1c59      	adds	r1, r3, #1
 801931e:	6139      	str	r1, [r7, #16]
 8019320:	7812      	ldrb	r2, [r2, #0]
 8019322:	701a      	strb	r2, [r3, #0]
 8019324:	697a      	ldr	r2, [r7, #20]
 8019326:	1c53      	adds	r3, r2, #1
 8019328:	617b      	str	r3, [r7, #20]
 801932a:	693b      	ldr	r3, [r7, #16]
 801932c:	1c59      	adds	r1, r3, #1
 801932e:	6139      	str	r1, [r7, #16]
 8019330:	7812      	ldrb	r2, [r2, #0]
 8019332:	701a      	strb	r2, [r3, #0]
 8019334:	697a      	ldr	r2, [r7, #20]
 8019336:	1c53      	adds	r3, r2, #1
 8019338:	617b      	str	r3, [r7, #20]
 801933a:	693b      	ldr	r3, [r7, #16]
 801933c:	1c59      	adds	r1, r3, #1
 801933e:	6139      	str	r1, [r7, #16]
 8019340:	7812      	ldrb	r2, [r2, #0]
 8019342:	701a      	strb	r2, [r3, #0]
 8019344:	697a      	ldr	r2, [r7, #20]
 8019346:	1c53      	adds	r3, r2, #1
 8019348:	617b      	str	r3, [r7, #20]
 801934a:	693b      	ldr	r3, [r7, #16]
 801934c:	1c59      	adds	r1, r3, #1
 801934e:	6139      	str	r1, [r7, #16]
 8019350:	7812      	ldrb	r2, [r2, #0]
 8019352:	701a      	strb	r2, [r3, #0]
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 8019354:	697a      	ldr	r2, [r7, #20]
 8019356:	1c53      	adds	r3, r2, #1
 8019358:	617b      	str	r3, [r7, #20]
 801935a:	693b      	ldr	r3, [r7, #16]
 801935c:	1c59      	adds	r1, r3, #1
 801935e:	6139      	str	r1, [r7, #16]
 8019360:	7812      	ldrb	r2, [r2, #0]
 8019362:	701a      	strb	r2, [r3, #0]
 8019364:	697a      	ldr	r2, [r7, #20]
 8019366:	1c53      	adds	r3, r2, #1
 8019368:	617b      	str	r3, [r7, #20]
 801936a:	693b      	ldr	r3, [r7, #16]
 801936c:	1c59      	adds	r1, r3, #1
 801936e:	6139      	str	r1, [r7, #16]
 8019370:	7812      	ldrb	r2, [r2, #0]
 8019372:	701a      	strb	r2, [r3, #0]
 8019374:	697a      	ldr	r2, [r7, #20]
 8019376:	1c53      	adds	r3, r2, #1
 8019378:	617b      	str	r3, [r7, #20]
 801937a:	693b      	ldr	r3, [r7, #16]
 801937c:	1c59      	adds	r1, r3, #1
 801937e:	6139      	str	r1, [r7, #16]
 8019380:	7812      	ldrb	r2, [r2, #0]
 8019382:	701a      	strb	r2, [r3, #0]
 8019384:	697a      	ldr	r2, [r7, #20]
 8019386:	1c53      	adds	r3, r2, #1
 8019388:	617b      	str	r3, [r7, #20]
 801938a:	693b      	ldr	r3, [r7, #16]
 801938c:	1c59      	adds	r1, r3, #1
 801938e:	6139      	str	r1, [r7, #16]
 8019390:	7812      	ldrb	r2, [r2, #0]
 8019392:	701a      	strb	r2, [r3, #0]
	}
	if (n&4) {
 8019394:	687b      	ldr	r3, [r7, #4]
 8019396:	f003 0304 	and.w	r3, r3, #4
 801939a:	2b00      	cmp	r3, #0
 801939c:	d01f      	beq.n	80193de <memcpy+0x50e>
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 801939e:	697a      	ldr	r2, [r7, #20]
 80193a0:	1c53      	adds	r3, r2, #1
 80193a2:	617b      	str	r3, [r7, #20]
 80193a4:	693b      	ldr	r3, [r7, #16]
 80193a6:	1c59      	adds	r1, r3, #1
 80193a8:	6139      	str	r1, [r7, #16]
 80193aa:	7812      	ldrb	r2, [r2, #0]
 80193ac:	701a      	strb	r2, [r3, #0]
 80193ae:	697a      	ldr	r2, [r7, #20]
 80193b0:	1c53      	adds	r3, r2, #1
 80193b2:	617b      	str	r3, [r7, #20]
 80193b4:	693b      	ldr	r3, [r7, #16]
 80193b6:	1c59      	adds	r1, r3, #1
 80193b8:	6139      	str	r1, [r7, #16]
 80193ba:	7812      	ldrb	r2, [r2, #0]
 80193bc:	701a      	strb	r2, [r3, #0]
 80193be:	697a      	ldr	r2, [r7, #20]
 80193c0:	1c53      	adds	r3, r2, #1
 80193c2:	617b      	str	r3, [r7, #20]
 80193c4:	693b      	ldr	r3, [r7, #16]
 80193c6:	1c59      	adds	r1, r3, #1
 80193c8:	6139      	str	r1, [r7, #16]
 80193ca:	7812      	ldrb	r2, [r2, #0]
 80193cc:	701a      	strb	r2, [r3, #0]
 80193ce:	697a      	ldr	r2, [r7, #20]
 80193d0:	1c53      	adds	r3, r2, #1
 80193d2:	617b      	str	r3, [r7, #20]
 80193d4:	693b      	ldr	r3, [r7, #16]
 80193d6:	1c59      	adds	r1, r3, #1
 80193d8:	6139      	str	r1, [r7, #16]
 80193da:	7812      	ldrb	r2, [r2, #0]
 80193dc:	701a      	strb	r2, [r3, #0]
	}
	if (n&2) {
 80193de:	687b      	ldr	r3, [r7, #4]
 80193e0:	f003 0302 	and.w	r3, r3, #2
 80193e4:	2b00      	cmp	r3, #0
 80193e6:	d00f      	beq.n	8019408 <memcpy+0x538>
		*d++ = *s++; *d++ = *s++;
 80193e8:	697a      	ldr	r2, [r7, #20]
 80193ea:	1c53      	adds	r3, r2, #1
 80193ec:	617b      	str	r3, [r7, #20]
 80193ee:	693b      	ldr	r3, [r7, #16]
 80193f0:	1c59      	adds	r1, r3, #1
 80193f2:	6139      	str	r1, [r7, #16]
 80193f4:	7812      	ldrb	r2, [r2, #0]
 80193f6:	701a      	strb	r2, [r3, #0]
 80193f8:	697a      	ldr	r2, [r7, #20]
 80193fa:	1c53      	adds	r3, r2, #1
 80193fc:	617b      	str	r3, [r7, #20]
 80193fe:	693b      	ldr	r3, [r7, #16]
 8019400:	1c59      	adds	r1, r3, #1
 8019402:	6139      	str	r1, [r7, #16]
 8019404:	7812      	ldrb	r2, [r2, #0]
 8019406:	701a      	strb	r2, [r3, #0]
	}
	if (n&1) {
 8019408:	687b      	ldr	r3, [r7, #4]
 801940a:	f003 0301 	and.w	r3, r3, #1
 801940e:	2b00      	cmp	r3, #0
 8019410:	d003      	beq.n	801941a <memcpy+0x54a>
		*d = *s;
 8019412:	697b      	ldr	r3, [r7, #20]
 8019414:	781a      	ldrb	r2, [r3, #0]
 8019416:	693b      	ldr	r3, [r7, #16]
 8019418:	701a      	strb	r2, [r3, #0]
	}
	return dest;
 801941a:	68fb      	ldr	r3, [r7, #12]
#endif

	for (; n; n--) *d++ = *s++;
	return dest;
}
 801941c:	4618      	mov	r0, r3
 801941e:	3724      	adds	r7, #36	; 0x24
 8019420:	46bd      	mov	sp, r7
 8019422:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019426:	4770      	bx	lr

08019428 <strncmp>:
#include <string.h>

int strncmp(const char *_l, const char *_r, size_t n)
{
 8019428:	b480      	push	{r7}
 801942a:	b087      	sub	sp, #28
 801942c:	af00      	add	r7, sp, #0
 801942e:	60f8      	str	r0, [r7, #12]
 8019430:	60b9      	str	r1, [r7, #8]
 8019432:	607a      	str	r2, [r7, #4]
	const unsigned char *l=(void *)_l, *r=(void *)_r;
 8019434:	68fb      	ldr	r3, [r7, #12]
 8019436:	613b      	str	r3, [r7, #16]
 8019438:	68bb      	ldr	r3, [r7, #8]
 801943a:	617b      	str	r3, [r7, #20]
	if (!n--) return 0;
 801943c:	687b      	ldr	r3, [r7, #4]
 801943e:	1e5a      	subs	r2, r3, #1
 8019440:	607a      	str	r2, [r7, #4]
 8019442:	2b00      	cmp	r3, #0
 8019444:	d10a      	bne.n	801945c <strncmp+0x34>
 8019446:	2300      	movs	r3, #0
 8019448:	e01f      	b.n	801948a <strncmp+0x62>
	for (; *l && *r && n && *l == *r ; l++, r++, n--);
 801944a:	693b      	ldr	r3, [r7, #16]
 801944c:	3301      	adds	r3, #1
 801944e:	613b      	str	r3, [r7, #16]
 8019450:	697b      	ldr	r3, [r7, #20]
 8019452:	3301      	adds	r3, #1
 8019454:	617b      	str	r3, [r7, #20]
 8019456:	687b      	ldr	r3, [r7, #4]
 8019458:	3b01      	subs	r3, #1
 801945a:	607b      	str	r3, [r7, #4]
 801945c:	693b      	ldr	r3, [r7, #16]
 801945e:	781b      	ldrb	r3, [r3, #0]
 8019460:	2b00      	cmp	r3, #0
 8019462:	d00c      	beq.n	801947e <strncmp+0x56>
 8019464:	697b      	ldr	r3, [r7, #20]
 8019466:	781b      	ldrb	r3, [r3, #0]
 8019468:	2b00      	cmp	r3, #0
 801946a:	d008      	beq.n	801947e <strncmp+0x56>
 801946c:	687b      	ldr	r3, [r7, #4]
 801946e:	2b00      	cmp	r3, #0
 8019470:	d005      	beq.n	801947e <strncmp+0x56>
 8019472:	693b      	ldr	r3, [r7, #16]
 8019474:	781a      	ldrb	r2, [r3, #0]
 8019476:	697b      	ldr	r3, [r7, #20]
 8019478:	781b      	ldrb	r3, [r3, #0]
 801947a:	429a      	cmp	r2, r3
 801947c:	d0e5      	beq.n	801944a <strncmp+0x22>
	return *l - *r;
 801947e:	693b      	ldr	r3, [r7, #16]
 8019480:	781b      	ldrb	r3, [r3, #0]
 8019482:	461a      	mov	r2, r3
 8019484:	697b      	ldr	r3, [r7, #20]
 8019486:	781b      	ldrb	r3, [r3, #0]
 8019488:	1ad3      	subs	r3, r2, r3
}
 801948a:	4618      	mov	r0, r3
 801948c:	371c      	adds	r7, #28
 801948e:	46bd      	mov	sp, r7
 8019490:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019494:	4770      	bx	lr

08019496 <strrchr>:
#include <string.h>

char *strrchr(const char *s, int c)
{
 8019496:	b580      	push	{r7, lr}
 8019498:	b082      	sub	sp, #8
 801949a:	af00      	add	r7, sp, #0
 801949c:	6078      	str	r0, [r7, #4]
 801949e:	6039      	str	r1, [r7, #0]
	return __memrchr(s, c, strlen(s) + 1);
 80194a0:	6878      	ldr	r0, [r7, #4]
 80194a2:	f7f5 faf2 	bl	800ea8a <strlen>
 80194a6:	4603      	mov	r3, r0
 80194a8:	3301      	adds	r3, #1
 80194aa:	461a      	mov	r2, r3
 80194ac:	6839      	ldr	r1, [r7, #0]
 80194ae:	6878      	ldr	r0, [r7, #4]
 80194b0:	f004 fb9f 	bl	801dbf2 <__memrchr>
 80194b4:	4603      	mov	r3, r0
}
 80194b6:	4618      	mov	r0, r3
 80194b8:	3708      	adds	r7, #8
 80194ba:	46bd      	mov	sp, r7
 80194bc:	bd80      	pop	{r7, pc}
	...

080194c0 <is_leap>:
#ifdef __LITEOS__
#include <ctype.h>
#endif

static int is_leap(int y)
{
 80194c0:	b480      	push	{r7}
 80194c2:	b083      	sub	sp, #12
 80194c4:	af00      	add	r7, sp, #0
 80194c6:	6078      	str	r0, [r7, #4]
	/* Avoid overflow */
	if (y>INT_MAX-1900) y -= 2000;
 80194c8:	687b      	ldr	r3, [r7, #4]
 80194ca:	4a1a      	ldr	r2, [pc, #104]	; (8019534 <is_leap+0x74>)
 80194cc:	4293      	cmp	r3, r2
 80194ce:	dd03      	ble.n	80194d8 <is_leap+0x18>
 80194d0:	687b      	ldr	r3, [r7, #4]
 80194d2:	f5a3 63fa 	sub.w	r3, r3, #2000	; 0x7d0
 80194d6:	607b      	str	r3, [r7, #4]
	y += 1900;
 80194d8:	687b      	ldr	r3, [r7, #4]
 80194da:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 80194de:	607b      	str	r3, [r7, #4]
	return !(y%4) && ((y%100) || !(y%400));
 80194e0:	687b      	ldr	r3, [r7, #4]
 80194e2:	f003 0303 	and.w	r3, r3, #3
 80194e6:	2b00      	cmp	r3, #0
 80194e8:	d11c      	bne.n	8019524 <is_leap+0x64>
 80194ea:	687a      	ldr	r2, [r7, #4]
 80194ec:	4b12      	ldr	r3, [pc, #72]	; (8019538 <is_leap+0x78>)
 80194ee:	fb83 1302 	smull	r1, r3, r3, r2
 80194f2:	1159      	asrs	r1, r3, #5
 80194f4:	17d3      	asrs	r3, r2, #31
 80194f6:	1acb      	subs	r3, r1, r3
 80194f8:	2164      	movs	r1, #100	; 0x64
 80194fa:	fb01 f303 	mul.w	r3, r1, r3
 80194fe:	1ad3      	subs	r3, r2, r3
 8019500:	2b00      	cmp	r3, #0
 8019502:	d10d      	bne.n	8019520 <is_leap+0x60>
 8019504:	687a      	ldr	r2, [r7, #4]
 8019506:	4b0c      	ldr	r3, [pc, #48]	; (8019538 <is_leap+0x78>)
 8019508:	fb83 1302 	smull	r1, r3, r3, r2
 801950c:	11d9      	asrs	r1, r3, #7
 801950e:	17d3      	asrs	r3, r2, #31
 8019510:	1acb      	subs	r3, r1, r3
 8019512:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8019516:	fb01 f303 	mul.w	r3, r1, r3
 801951a:	1ad3      	subs	r3, r2, r3
 801951c:	2b00      	cmp	r3, #0
 801951e:	d101      	bne.n	8019524 <is_leap+0x64>
 8019520:	2301      	movs	r3, #1
 8019522:	e000      	b.n	8019526 <is_leap+0x66>
 8019524:	2300      	movs	r3, #0
}
 8019526:	4618      	mov	r0, r3
 8019528:	370c      	adds	r7, #12
 801952a:	46bd      	mov	sp, r7
 801952c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019530:	4770      	bx	lr
 8019532:	bf00      	nop
 8019534:	7ffff893 	.word	0x7ffff893
 8019538:	51eb851f 	.word	0x51eb851f

0801953c <week_num>:

static int week_num(const struct tm *tm)
{
 801953c:	b580      	push	{r7, lr}
 801953e:	b086      	sub	sp, #24
 8019540:	af00      	add	r7, sp, #0
 8019542:	6078      	str	r0, [r7, #4]
	int val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
 8019544:	687b      	ldr	r3, [r7, #4]
 8019546:	69db      	ldr	r3, [r3, #28]
 8019548:	4618      	mov	r0, r3
 801954a:	687b      	ldr	r3, [r7, #4]
 801954c:	699b      	ldr	r3, [r3, #24]
 801954e:	1d99      	adds	r1, r3, #6
 8019550:	4b47      	ldr	r3, [pc, #284]	; (8019670 <week_num+0x134>)
 8019552:	fba3 2301 	umull	r2, r3, r3, r1
 8019556:	1aca      	subs	r2, r1, r3
 8019558:	0852      	lsrs	r2, r2, #1
 801955a:	4413      	add	r3, r2
 801955c:	089a      	lsrs	r2, r3, #2
 801955e:	4613      	mov	r3, r2
 8019560:	00db      	lsls	r3, r3, #3
 8019562:	1a9b      	subs	r3, r3, r2
 8019564:	1aca      	subs	r2, r1, r3
 8019566:	1a83      	subs	r3, r0, r2
 8019568:	1dda      	adds	r2, r3, #7
 801956a:	4b41      	ldr	r3, [pc, #260]	; (8019670 <week_num+0x134>)
 801956c:	fba3 1302 	umull	r1, r3, r3, r2
 8019570:	1ad2      	subs	r2, r2, r3
 8019572:	0852      	lsrs	r2, r2, #1
 8019574:	4413      	add	r3, r2
 8019576:	089b      	lsrs	r3, r3, #2
 8019578:	60fb      	str	r3, [r7, #12]
	/* If 1 Jan is just 1-3 days past Monday,
	 * the previous week is also in this year. */
	if ((tm->tm_wday + 371U - tm->tm_yday - 2) % 7 <= 2)
 801957a:	687b      	ldr	r3, [r7, #4]
 801957c:	699b      	ldr	r3, [r3, #24]
 801957e:	461a      	mov	r2, r3
 8019580:	687b      	ldr	r3, [r7, #4]
 8019582:	69db      	ldr	r3, [r3, #28]
 8019584:	1ad3      	subs	r3, r2, r3
 8019586:	f203 1171 	addw	r1, r3, #369	; 0x171
 801958a:	4b39      	ldr	r3, [pc, #228]	; (8019670 <week_num+0x134>)
 801958c:	fba3 2301 	umull	r2, r3, r3, r1
 8019590:	1aca      	subs	r2, r1, r3
 8019592:	0852      	lsrs	r2, r2, #1
 8019594:	4413      	add	r3, r2
 8019596:	089a      	lsrs	r2, r3, #2
 8019598:	4613      	mov	r3, r2
 801959a:	00db      	lsls	r3, r3, #3
 801959c:	1a9b      	subs	r3, r3, r2
 801959e:	1aca      	subs	r2, r1, r3
 80195a0:	2a02      	cmp	r2, #2
 80195a2:	d802      	bhi.n	80195aa <week_num+0x6e>
		val++;
 80195a4:	68fb      	ldr	r3, [r7, #12]
 80195a6:	3301      	adds	r3, #1
 80195a8:	60fb      	str	r3, [r7, #12]
	if (!val) {
 80195aa:	68fb      	ldr	r3, [r7, #12]
 80195ac:	2b00      	cmp	r3, #0
 80195ae:	d132      	bne.n	8019616 <week_num+0xda>
		val = 52;
 80195b0:	2334      	movs	r3, #52	; 0x34
 80195b2:	60fb      	str	r3, [r7, #12]
		/* If 31 December of prev year a Thursday,
		 * or Friday of a leap year, then the
		 * prev year has 53 weeks. */
		int dec31 = (tm->tm_wday + 7U - tm->tm_yday - 1) % 7;
 80195b4:	687b      	ldr	r3, [r7, #4]
 80195b6:	699b      	ldr	r3, [r3, #24]
 80195b8:	461a      	mov	r2, r3
 80195ba:	687b      	ldr	r3, [r7, #4]
 80195bc:	69db      	ldr	r3, [r3, #28]
 80195be:	1ad3      	subs	r3, r2, r3
 80195c0:	1d99      	adds	r1, r3, #6
 80195c2:	4b2b      	ldr	r3, [pc, #172]	; (8019670 <week_num+0x134>)
 80195c4:	fba3 2301 	umull	r2, r3, r3, r1
 80195c8:	1aca      	subs	r2, r1, r3
 80195ca:	0852      	lsrs	r2, r2, #1
 80195cc:	4413      	add	r3, r2
 80195ce:	089a      	lsrs	r2, r3, #2
 80195d0:	4613      	mov	r3, r2
 80195d2:	00db      	lsls	r3, r3, #3
 80195d4:	1a9b      	subs	r3, r3, r2
 80195d6:	1aca      	subs	r2, r1, r3
 80195d8:	617a      	str	r2, [r7, #20]
		if (dec31 == 4 || (dec31 == 5 && is_leap(tm->tm_year%400-1)))
 80195da:	697b      	ldr	r3, [r7, #20]
 80195dc:	2b04      	cmp	r3, #4
 80195de:	d016      	beq.n	801960e <week_num+0xd2>
 80195e0:	697b      	ldr	r3, [r7, #20]
 80195e2:	2b05      	cmp	r3, #5
 80195e4:	d13e      	bne.n	8019664 <week_num+0x128>
 80195e6:	687b      	ldr	r3, [r7, #4]
 80195e8:	695a      	ldr	r2, [r3, #20]
 80195ea:	4b22      	ldr	r3, [pc, #136]	; (8019674 <week_num+0x138>)
 80195ec:	fb83 1302 	smull	r1, r3, r3, r2
 80195f0:	11d9      	asrs	r1, r3, #7
 80195f2:	17d3      	asrs	r3, r2, #31
 80195f4:	1acb      	subs	r3, r1, r3
 80195f6:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80195fa:	fb01 f303 	mul.w	r3, r1, r3
 80195fe:	1ad3      	subs	r3, r2, r3
 8019600:	3b01      	subs	r3, #1
 8019602:	4618      	mov	r0, r3
 8019604:	f7ff ff5c 	bl	80194c0 <is_leap>
 8019608:	4603      	mov	r3, r0
 801960a:	2b00      	cmp	r3, #0
 801960c:	d02a      	beq.n	8019664 <week_num+0x128>
			val++;
 801960e:	68fb      	ldr	r3, [r7, #12]
 8019610:	3301      	adds	r3, #1
 8019612:	60fb      	str	r3, [r7, #12]
 8019614:	e026      	b.n	8019664 <week_num+0x128>
	} else if (val == 53) {
 8019616:	68fb      	ldr	r3, [r7, #12]
 8019618:	2b35      	cmp	r3, #53	; 0x35
 801961a:	d123      	bne.n	8019664 <week_num+0x128>
		/* If 1 January is not a Thursday, and not
		 * a Wednesday of a leap year, then this
		 * year has only 52 weeks. */
		int jan1 = (tm->tm_wday + 371U - tm->tm_yday) % 7;
 801961c:	687b      	ldr	r3, [r7, #4]
 801961e:	699b      	ldr	r3, [r3, #24]
 8019620:	461a      	mov	r2, r3
 8019622:	687b      	ldr	r3, [r7, #4]
 8019624:	69db      	ldr	r3, [r3, #28]
 8019626:	1ad3      	subs	r3, r2, r3
 8019628:	f203 1173 	addw	r1, r3, #371	; 0x173
 801962c:	4b10      	ldr	r3, [pc, #64]	; (8019670 <week_num+0x134>)
 801962e:	fba3 2301 	umull	r2, r3, r3, r1
 8019632:	1aca      	subs	r2, r1, r3
 8019634:	0852      	lsrs	r2, r2, #1
 8019636:	4413      	add	r3, r2
 8019638:	089a      	lsrs	r2, r3, #2
 801963a:	4613      	mov	r3, r2
 801963c:	00db      	lsls	r3, r3, #3
 801963e:	1a9b      	subs	r3, r3, r2
 8019640:	1aca      	subs	r2, r1, r3
 8019642:	613a      	str	r2, [r7, #16]
		if (jan1 != 4 && (jan1 != 3 || !is_leap(tm->tm_year)))
 8019644:	693b      	ldr	r3, [r7, #16]
 8019646:	2b04      	cmp	r3, #4
 8019648:	d00c      	beq.n	8019664 <week_num+0x128>
 801964a:	693b      	ldr	r3, [r7, #16]
 801964c:	2b03      	cmp	r3, #3
 801964e:	d107      	bne.n	8019660 <week_num+0x124>
 8019650:	687b      	ldr	r3, [r7, #4]
 8019652:	695b      	ldr	r3, [r3, #20]
 8019654:	4618      	mov	r0, r3
 8019656:	f7ff ff33 	bl	80194c0 <is_leap>
 801965a:	4603      	mov	r3, r0
 801965c:	2b00      	cmp	r3, #0
 801965e:	d101      	bne.n	8019664 <week_num+0x128>
			val = 1;
 8019660:	2301      	movs	r3, #1
 8019662:	60fb      	str	r3, [r7, #12]
	}
	return val;
 8019664:	68fb      	ldr	r3, [r7, #12]
}
 8019666:	4618      	mov	r0, r3
 8019668:	3718      	adds	r7, #24
 801966a:	46bd      	mov	sp, r7
 801966c:	bd80      	pop	{r7, pc}
 801966e:	bf00      	nop
 8019670:	24924925 	.word	0x24924925
 8019674:	51eb851f 	.word	0x51eb851f

08019678 <__strftime_fmt_1>:

const char *__strftime_fmt_1(char (*s)[100], size_t *l, int f, const struct tm *tm, locale_t loc, int pad)
{
 8019678:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 801967c:	b096      	sub	sp, #88	; 0x58
 801967e:	af02      	add	r7, sp, #8
 8019680:	6378      	str	r0, [r7, #52]	; 0x34
 8019682:	6339      	str	r1, [r7, #48]	; 0x30
 8019684:	62fa      	str	r2, [r7, #44]	; 0x2c
 8019686:	62bb      	str	r3, [r7, #40]	; 0x28
	nl_item item;
	long long val;
	const char *fmt = "-";
 8019688:	4bca      	ldr	r3, [pc, #808]	; (80199b4 <__strftime_fmt_1+0x33c>)
 801968a:	63fb      	str	r3, [r7, #60]	; 0x3c
	int width = 2, def_pad = '0';
 801968c:	2302      	movs	r3, #2
 801968e:	643b      	str	r3, [r7, #64]	; 0x40
 8019690:	2330      	movs	r3, #48	; 0x30
 8019692:	647b      	str	r3, [r7, #68]	; 0x44
 8019694:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019696:	3b25      	subs	r3, #37	; 0x25
 8019698:	2b54      	cmp	r3, #84	; 0x54
 801969a:	f200 829f 	bhi.w	8019bdc <__strftime_fmt_1+0x564>
 801969e:	a201      	add	r2, pc, #4	; (adr r2, 80196a4 <__strftime_fmt_1+0x2c>)
 80196a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80196a4:	08019bd3 	.word	0x08019bd3
 80196a8:	08019bdd 	.word	0x08019bdd
 80196ac:	08019bdd 	.word	0x08019bdd
 80196b0:	08019bdd 	.word	0x08019bdd
 80196b4:	08019bdd 	.word	0x08019bdd
 80196b8:	08019bdd 	.word	0x08019bdd
 80196bc:	08019bdd 	.word	0x08019bdd
 80196c0:	08019bdd 	.word	0x08019bdd
 80196c4:	08019bdd 	.word	0x08019bdd
 80196c8:	08019bdd 	.word	0x08019bdd
 80196cc:	08019bdd 	.word	0x08019bdd
 80196d0:	08019bdd 	.word	0x08019bdd
 80196d4:	08019bdd 	.word	0x08019bdd
 80196d8:	08019bdd 	.word	0x08019bdd
 80196dc:	08019bdd 	.word	0x08019bdd
 80196e0:	08019bdd 	.word	0x08019bdd
 80196e4:	08019bdd 	.word	0x08019bdd
 80196e8:	08019bdd 	.word	0x08019bdd
 80196ec:	08019bdd 	.word	0x08019bdd
 80196f0:	08019bdd 	.word	0x08019bdd
 80196f4:	08019bdd 	.word	0x08019bdd
 80196f8:	08019bdd 	.word	0x08019bdd
 80196fc:	08019bdd 	.word	0x08019bdd
 8019700:	08019bdd 	.word	0x08019bdd
 8019704:	08019bdd 	.word	0x08019bdd
 8019708:	08019bdd 	.word	0x08019bdd
 801970c:	08019bdd 	.word	0x08019bdd
 8019710:	08019bdd 	.word	0x08019bdd
 8019714:	0801980f 	.word	0x0801980f
 8019718:	0801983b 	.word	0x0801983b
 801971c:	08019857 	.word	0x08019857
 8019720:	0801989f 	.word	0x0801989f
 8019724:	08019bdd 	.word	0x08019bdd
 8019728:	080198a5 	.word	0x080198a5
 801972c:	080198ab 	.word	0x080198ab
 8019730:	08019949 	.word	0x08019949
 8019734:	08019965 	.word	0x08019965
 8019738:	08019bdd 	.word	0x08019bdd
 801973c:	08019bdd 	.word	0x08019bdd
 8019740:	08019bdd 	.word	0x08019bdd
 8019744:	080199f9 	.word	0x080199f9
 8019748:	08019bdd 	.word	0x08019bdd
 801974c:	08019bdd 	.word	0x08019bdd
 8019750:	08019a13 	.word	0x08019a13
 8019754:	08019bdd 	.word	0x08019bdd
 8019758:	08019a2b 	.word	0x08019a2b
 801975c:	08019a53 	.word	0x08019a53
 8019760:	08019a6d 	.word	0x08019a6d
 8019764:	08019a99 	.word	0x08019a99
 8019768:	08019b01 	.word	0x08019b01
 801976c:	08019ac1 	.word	0x08019ac1
 8019770:	08019b2f 	.word	0x08019b2f
 8019774:	08019b7f 	.word	0x08019b7f
 8019778:	08019bdd 	.word	0x08019bdd
 801977c:	08019bdd 	.word	0x08019bdd
 8019780:	08019bdd 	.word	0x08019bdd
 8019784:	08019bdd 	.word	0x08019bdd
 8019788:	08019bdd 	.word	0x08019bdd
 801978c:	08019bdd 	.word	0x08019bdd
 8019790:	08019bdd 	.word	0x08019bdd
 8019794:	080197f9 	.word	0x080197f9
 8019798:	08019825 	.word	0x08019825
 801979c:	08019851 	.word	0x08019851
 80197a0:	0801988f 	.word	0x0801988f
 80197a4:	0801988b 	.word	0x0801988b
 80197a8:	08019bdd 	.word	0x08019bdd
 80197ac:	080198ab 	.word	0x080198ab
 80197b0:	08019825 	.word	0x08019825
 80197b4:	08019bdd 	.word	0x08019bdd
 80197b8:	080199d1 	.word	0x080199d1
 80197bc:	08019949 	.word	0x08019949
 80197c0:	08019965 	.word	0x08019965
 80197c4:	080199e7 	.word	0x080199e7
 80197c8:	08019a09 	.word	0x08019a09
 80197cc:	08019bdd 	.word	0x08019bdd
 80197d0:	08019a13 	.word	0x08019a13
 80197d4:	08019bdd 	.word	0x08019bdd
 80197d8:	08019a25 	.word	0x08019a25
 80197dc:	08019a31 	.word	0x08019a31
 80197e0:	08019a63 	.word	0x08019a63
 80197e4:	08019a73 	.word	0x08019a73
 80197e8:	08019bdd 	.word	0x08019bdd
 80197ec:	08019b15 	.word	0x08019b15
 80197f0:	08019b29 	.word	0x08019b29
 80197f4:	08019b35 	.word	0x08019b35

	switch (f) {
	case 'a':
		if (tm->tm_wday > 6U) goto string;
 80197f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80197fa:	699b      	ldr	r3, [r3, #24]
 80197fc:	2b06      	cmp	r3, #6
 80197fe:	f200 8233 	bhi.w	8019c68 <__strftime_fmt_1+0x5f0>
		item = ABDAY_1 + tm->tm_wday;
 8019802:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019804:	699b      	ldr	r3, [r3, #24]
 8019806:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 801980a:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strcat;
 801980c:	e226      	b.n	8019c5c <__strftime_fmt_1+0x5e4>
	case 'A':
		if (tm->tm_wday > 6U) goto string;
 801980e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019810:	699b      	ldr	r3, [r3, #24]
 8019812:	2b06      	cmp	r3, #6
 8019814:	f200 822a 	bhi.w	8019c6c <__strftime_fmt_1+0x5f4>
		item = DAY_1 + tm->tm_wday;
 8019818:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801981a:	699a      	ldr	r2, [r3, #24]
 801981c:	4b66      	ldr	r3, [pc, #408]	; (80199b8 <__strftime_fmt_1+0x340>)
 801981e:	4413      	add	r3, r2
 8019820:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strcat;
 8019822:	e21b      	b.n	8019c5c <__strftime_fmt_1+0x5e4>
	case 'h':
	case 'b':
		if (tm->tm_mon > 11U) goto string;
 8019824:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019826:	691b      	ldr	r3, [r3, #16]
 8019828:	2b0b      	cmp	r3, #11
 801982a:	f200 8221 	bhi.w	8019c70 <__strftime_fmt_1+0x5f8>
		item = ABMON_1 + tm->tm_mon;
 801982e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019830:	691a      	ldr	r2, [r3, #16]
 8019832:	4b62      	ldr	r3, [pc, #392]	; (80199bc <__strftime_fmt_1+0x344>)
 8019834:	4413      	add	r3, r2
 8019836:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strcat;
 8019838:	e210      	b.n	8019c5c <__strftime_fmt_1+0x5e4>
	case 'B':
		if (tm->tm_mon > 11U) goto string;
 801983a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801983c:	691b      	ldr	r3, [r3, #16]
 801983e:	2b0b      	cmp	r3, #11
 8019840:	f200 8218 	bhi.w	8019c74 <__strftime_fmt_1+0x5fc>
		item = MON_1 + tm->tm_mon;
 8019844:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019846:	691a      	ldr	r2, [r3, #16]
 8019848:	4b5d      	ldr	r3, [pc, #372]	; (80199c0 <__strftime_fmt_1+0x348>)
 801984a:	4413      	add	r3, r2
 801984c:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strcat;
 801984e:	e205      	b.n	8019c5c <__strftime_fmt_1+0x5e4>
	case 'c':
		item = D_T_FMT;
 8019850:	4b5c      	ldr	r3, [pc, #368]	; (80199c4 <__strftime_fmt_1+0x34c>)
 8019852:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strftime;
 8019854:	e254      	b.n	8019d00 <__strftime_fmt_1+0x688>
	case 'C':
		val = (1900LL+tm->tm_year) / 100;
 8019856:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019858:	695b      	ldr	r3, [r3, #20]
 801985a:	461a      	mov	r2, r3
 801985c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019860:	f240 706c 	movw	r0, #1900	; 0x76c
 8019864:	f04f 0100 	mov.w	r1, #0
 8019868:	1814      	adds	r4, r2, r0
 801986a:	623c      	str	r4, [r7, #32]
 801986c:	414b      	adcs	r3, r1
 801986e:	627b      	str	r3, [r7, #36]	; 0x24
 8019870:	f04f 0264 	mov.w	r2, #100	; 0x64
 8019874:	f04f 0300 	mov.w	r3, #0
 8019878:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801987c:	f7e7 fc26 	bl	80010cc <__aeabi_ldivmod>
 8019880:	4602      	mov	r2, r0
 8019882:	460b      	mov	r3, r1
 8019884:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019888:	e1af      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'e':
		def_pad = '_';
 801988a:	235f      	movs	r3, #95	; 0x5f
 801988c:	647b      	str	r3, [r7, #68]	; 0x44
	case 'd':
		val = tm->tm_mday;
 801988e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019890:	68db      	ldr	r3, [r3, #12]
 8019892:	461a      	mov	r2, r3
 8019894:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019898:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 801989c:	e1a5      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'D':
		fmt = "%m/%d/%y";
 801989e:	4b4a      	ldr	r3, [pc, #296]	; (80199c8 <__strftime_fmt_1+0x350>)
 80198a0:	63fb      	str	r3, [r7, #60]	; 0x3c
		goto recu_strftime;
 80198a2:	e232      	b.n	8019d0a <__strftime_fmt_1+0x692>
	case 'F':
		fmt = "%Y-%m-%d";
 80198a4:	4b49      	ldr	r3, [pc, #292]	; (80199cc <__strftime_fmt_1+0x354>)
 80198a6:	63fb      	str	r3, [r7, #60]	; 0x3c
		goto recu_strftime;
 80198a8:	e22f      	b.n	8019d0a <__strftime_fmt_1+0x692>
	case 'g':
	case 'G':
		val = tm->tm_year + 1900LL;
 80198aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80198ac:	695b      	ldr	r3, [r3, #20]
 80198ae:	461a      	mov	r2, r3
 80198b0:	ea4f 73e2 	mov.w	r3, r2, asr #31
 80198b4:	f240 706c 	movw	r0, #1900	; 0x76c
 80198b8:	f04f 0100 	mov.w	r1, #0
 80198bc:	1814      	adds	r4, r2, r0
 80198be:	613c      	str	r4, [r7, #16]
 80198c0:	414b      	adcs	r3, r1
 80198c2:	617b      	str	r3, [r7, #20]
 80198c4:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 80198c8:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
		if (tm->tm_yday < 3 && week_num(tm) != 1) val--;
 80198cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80198ce:	69db      	ldr	r3, [r3, #28]
 80198d0:	2b02      	cmp	r3, #2
 80198d2:	dc12      	bgt.n	80198fa <__strftime_fmt_1+0x282>
 80198d4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80198d6:	f7ff fe31 	bl	801953c <week_num>
 80198da:	4603      	mov	r3, r0
 80198dc:	2b01      	cmp	r3, #1
 80198de:	d00c      	beq.n	80198fa <__strftime_fmt_1+0x282>
 80198e0:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 80198e4:	f112 31ff 	adds.w	r1, r2, #4294967295
 80198e8:	60b9      	str	r1, [r7, #8]
 80198ea:	f143 33ff 	adc.w	r3, r3, #4294967295
 80198ee:	60fb      	str	r3, [r7, #12]
 80198f0:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 80198f4:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
 80198f8:	e015      	b.n	8019926 <__strftime_fmt_1+0x2ae>
		else if (tm->tm_yday > 360 && week_num(tm) == 1) val++;
 80198fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80198fc:	69db      	ldr	r3, [r3, #28]
 80198fe:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
 8019902:	dd10      	ble.n	8019926 <__strftime_fmt_1+0x2ae>
 8019904:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8019906:	f7ff fe19 	bl	801953c <week_num>
 801990a:	4603      	mov	r3, r0
 801990c:	2b01      	cmp	r3, #1
 801990e:	d10a      	bne.n	8019926 <__strftime_fmt_1+0x2ae>
 8019910:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019914:	1c51      	adds	r1, r2, #1
 8019916:	6039      	str	r1, [r7, #0]
 8019918:	f143 0300 	adc.w	r3, r3, #0
 801991c:	607b      	str	r3, [r7, #4]
 801991e:	e9d7 3400 	ldrd	r3, r4, [r7]
 8019922:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
		if (f=='g') val %= 100;
 8019926:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019928:	2b67      	cmp	r3, #103	; 0x67
 801992a:	d10a      	bne.n	8019942 <__strftime_fmt_1+0x2ca>
 801992c:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
 8019930:	f04f 0264 	mov.w	r2, #100	; 0x64
 8019934:	f04f 0300 	mov.w	r3, #0
 8019938:	f7e7 fbc8 	bl	80010cc <__aeabi_ldivmod>
 801993c:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		else width = 4;
		goto number;
 8019940:	e153      	b.n	8019bea <__strftime_fmt_1+0x572>
		else width = 4;
 8019942:	2304      	movs	r3, #4
 8019944:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019946:	e150      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'k':
	case 'H':
		val = tm->tm_hour;
 8019948:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801994a:	689b      	ldr	r3, [r3, #8]
 801994c:	461a      	mov	r2, r3
 801994e:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019952:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		if (f=='k') pad = '_';
 8019956:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019958:	2b6b      	cmp	r3, #107	; 0x6b
 801995a:	f040 8141 	bne.w	8019be0 <__strftime_fmt_1+0x568>
 801995e:	235f      	movs	r3, #95	; 0x5f
 8019960:	677b      	str	r3, [r7, #116]	; 0x74
		goto number;
 8019962:	e13d      	b.n	8019be0 <__strftime_fmt_1+0x568>
	case 'l':
	case 'I':
		val = tm->tm_hour;
 8019964:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019966:	689b      	ldr	r3, [r3, #8]
 8019968:	461a      	mov	r2, r3
 801996a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801996e:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		if (!val) val = 12;
 8019972:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019976:	4313      	orrs	r3, r2
 8019978:	d106      	bne.n	8019988 <__strftime_fmt_1+0x310>
 801997a:	f04f 020c 	mov.w	r2, #12
 801997e:	f04f 0300 	mov.w	r3, #0
 8019982:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
 8019986:	e00d      	b.n	80199a4 <__strftime_fmt_1+0x32c>
		else if (val > 12) val -= 12;
 8019988:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 801998c:	2a0d      	cmp	r2, #13
 801998e:	f173 0300 	sbcs.w	r3, r3, #0
 8019992:	db07      	blt.n	80199a4 <__strftime_fmt_1+0x32c>
 8019994:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019998:	f1b2 0a0c 	subs.w	sl, r2, #12
 801999c:	f143 3bff 	adc.w	fp, r3, #4294967295
 80199a0:	e9c7 ab12 	strd	sl, fp, [r7, #72]	; 0x48
		if (f=='l') pad = '_';
 80199a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80199a6:	2b6c      	cmp	r3, #108	; 0x6c
 80199a8:	f040 811c 	bne.w	8019be4 <__strftime_fmt_1+0x56c>
 80199ac:	235f      	movs	r3, #95	; 0x5f
 80199ae:	677b      	str	r3, [r7, #116]	; 0x74
		goto number;
 80199b0:	e118      	b.n	8019be4 <__strftime_fmt_1+0x56c>
 80199b2:	bf00      	nop
 80199b4:	080230f0 	.word	0x080230f0
 80199b8:	00020007 	.word	0x00020007
 80199bc:	0002000e 	.word	0x0002000e
 80199c0:	0002001a 	.word	0x0002001a
 80199c4:	00020028 	.word	0x00020028
 80199c8:	080230f4 	.word	0x080230f4
 80199cc:	08023100 	.word	0x08023100
	case 'j':
		val = tm->tm_yday+1;
 80199d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80199d2:	69db      	ldr	r3, [r3, #28]
 80199d4:	3301      	adds	r3, #1
 80199d6:	461a      	mov	r2, r3
 80199d8:	ea4f 73e2 	mov.w	r3, r2, asr #31
 80199dc:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		width = 3;
 80199e0:	2303      	movs	r3, #3
 80199e2:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 80199e4:	e101      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'm':
		val = tm->tm_mon+1;
 80199e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80199e8:	691b      	ldr	r3, [r3, #16]
 80199ea:	3301      	adds	r3, #1
 80199ec:	461a      	mov	r2, r3
 80199ee:	ea4f 73e2 	mov.w	r3, r2, asr #31
 80199f2:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 80199f6:	e0f8      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'M':
		val = tm->tm_min;
 80199f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80199fa:	685b      	ldr	r3, [r3, #4]
 80199fc:	461a      	mov	r2, r3
 80199fe:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019a02:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019a06:	e0f0      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'n':
		*l = 1;
 8019a08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019a0a:	2201      	movs	r2, #1
 8019a0c:	601a      	str	r2, [r3, #0]
		return "\n";
 8019a0e:	4ba9      	ldr	r3, [pc, #676]	; (8019cb4 <__strftime_fmt_1+0x63c>)
 8019a10:	e18d      	b.n	8019d2e <__strftime_fmt_1+0x6b6>
	case 'P':
	case 'p':
		item = tm->tm_hour >= 12 ? PM_STR : AM_STR;
 8019a12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a14:	689b      	ldr	r3, [r3, #8]
 8019a16:	2b0b      	cmp	r3, #11
 8019a18:	dd01      	ble.n	8019a1e <__strftime_fmt_1+0x3a6>
 8019a1a:	4ba7      	ldr	r3, [pc, #668]	; (8019cb8 <__strftime_fmt_1+0x640>)
 8019a1c:	e000      	b.n	8019a20 <__strftime_fmt_1+0x3a8>
 8019a1e:	4ba7      	ldr	r3, [pc, #668]	; (8019cbc <__strftime_fmt_1+0x644>)
 8019a20:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strcat;
 8019a22:	e11b      	b.n	8019c5c <__strftime_fmt_1+0x5e4>
	case 'r':
		item = T_FMT_AMPM;
 8019a24:	4ba6      	ldr	r3, [pc, #664]	; (8019cc0 <__strftime_fmt_1+0x648>)
 8019a26:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strftime;
 8019a28:	e16a      	b.n	8019d00 <__strftime_fmt_1+0x688>
	case 'R':
		fmt = "%H:%M";
 8019a2a:	4ba6      	ldr	r3, [pc, #664]	; (8019cc4 <__strftime_fmt_1+0x64c>)
 8019a2c:	63fb      	str	r3, [r7, #60]	; 0x3c
		goto recu_strftime;
 8019a2e:	e16c      	b.n	8019d0a <__strftime_fmt_1+0x692>
	case 's':
		val = __tm_to_secs(tm) - tm->__tm_gmtoff;
 8019a30:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8019a32:	f004 fb1f 	bl	801e074 <__tm_to_secs>
 8019a36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a38:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8019a3a:	461a      	mov	r2, r3
 8019a3c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019a40:	ebb0 0802 	subs.w	r8, r0, r2
 8019a44:	eb61 0903 	sbc.w	r9, r1, r3
 8019a48:	e9c7 8912 	strd	r8, r9, [r7, #72]	; 0x48
		width = 1;
 8019a4c:	2301      	movs	r3, #1
 8019a4e:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019a50:	e0cb      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'S':
		val = tm->tm_sec;
 8019a52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a54:	681b      	ldr	r3, [r3, #0]
 8019a56:	461a      	mov	r2, r3
 8019a58:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019a5c:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019a60:	e0c3      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 't':
		*l = 1;
 8019a62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019a64:	2201      	movs	r2, #1
 8019a66:	601a      	str	r2, [r3, #0]
		return "\t";
 8019a68:	4b97      	ldr	r3, [pc, #604]	; (8019cc8 <__strftime_fmt_1+0x650>)
 8019a6a:	e160      	b.n	8019d2e <__strftime_fmt_1+0x6b6>
	case 'T':
		fmt = "%H:%M:%S";
 8019a6c:	4b97      	ldr	r3, [pc, #604]	; (8019ccc <__strftime_fmt_1+0x654>)
 8019a6e:	63fb      	str	r3, [r7, #60]	; 0x3c
		goto recu_strftime;
 8019a70:	e14b      	b.n	8019d0a <__strftime_fmt_1+0x692>
	case 'u':
		val = tm->tm_wday ? tm->tm_wday : 7;
 8019a72:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a74:	699b      	ldr	r3, [r3, #24]
 8019a76:	2b00      	cmp	r3, #0
 8019a78:	d005      	beq.n	8019a86 <__strftime_fmt_1+0x40e>
 8019a7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a7c:	699b      	ldr	r3, [r3, #24]
 8019a7e:	461a      	mov	r2, r3
 8019a80:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019a84:	e003      	b.n	8019a8e <__strftime_fmt_1+0x416>
 8019a86:	f04f 0207 	mov.w	r2, #7
 8019a8a:	f04f 0300 	mov.w	r3, #0
 8019a8e:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		width = 1;
 8019a92:	2301      	movs	r3, #1
 8019a94:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019a96:	e0a8      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'U':
		val = (tm->tm_yday + 7U - tm->tm_wday) / 7;
 8019a98:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a9a:	69db      	ldr	r3, [r3, #28]
 8019a9c:	461a      	mov	r2, r3
 8019a9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019aa0:	699b      	ldr	r3, [r3, #24]
 8019aa2:	1ad3      	subs	r3, r2, r3
 8019aa4:	1dda      	adds	r2, r3, #7
 8019aa6:	4b8a      	ldr	r3, [pc, #552]	; (8019cd0 <__strftime_fmt_1+0x658>)
 8019aa8:	fba3 1302 	umull	r1, r3, r3, r2
 8019aac:	1ad2      	subs	r2, r2, r3
 8019aae:	0852      	lsrs	r2, r2, #1
 8019ab0:	4413      	add	r3, r2
 8019ab2:	089b      	lsrs	r3, r3, #2
 8019ab4:	461a      	mov	r2, r3
 8019ab6:	f04f 0300 	mov.w	r3, #0
 8019aba:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019abe:	e094      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'W':
		val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
 8019ac0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019ac2:	69db      	ldr	r3, [r3, #28]
 8019ac4:	4618      	mov	r0, r3
 8019ac6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019ac8:	699b      	ldr	r3, [r3, #24]
 8019aca:	1d99      	adds	r1, r3, #6
 8019acc:	4b80      	ldr	r3, [pc, #512]	; (8019cd0 <__strftime_fmt_1+0x658>)
 8019ace:	fba3 2301 	umull	r2, r3, r3, r1
 8019ad2:	1aca      	subs	r2, r1, r3
 8019ad4:	0852      	lsrs	r2, r2, #1
 8019ad6:	4413      	add	r3, r2
 8019ad8:	089a      	lsrs	r2, r3, #2
 8019ada:	4613      	mov	r3, r2
 8019adc:	00db      	lsls	r3, r3, #3
 8019ade:	1a9b      	subs	r3, r3, r2
 8019ae0:	1aca      	subs	r2, r1, r3
 8019ae2:	1a83      	subs	r3, r0, r2
 8019ae4:	1dda      	adds	r2, r3, #7
 8019ae6:	4b7a      	ldr	r3, [pc, #488]	; (8019cd0 <__strftime_fmt_1+0x658>)
 8019ae8:	fba3 1302 	umull	r1, r3, r3, r2
 8019aec:	1ad2      	subs	r2, r2, r3
 8019aee:	0852      	lsrs	r2, r2, #1
 8019af0:	4413      	add	r3, r2
 8019af2:	089b      	lsrs	r3, r3, #2
 8019af4:	461a      	mov	r2, r3
 8019af6:	f04f 0300 	mov.w	r3, #0
 8019afa:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019afe:	e074      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'V':
		val = week_num(tm);
 8019b00:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8019b02:	f7ff fd1b 	bl	801953c <week_num>
 8019b06:	4603      	mov	r3, r0
 8019b08:	461a      	mov	r2, r3
 8019b0a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019b0e:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019b12:	e06a      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'w':
		val = tm->tm_wday;
 8019b14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019b16:	699b      	ldr	r3, [r3, #24]
 8019b18:	461a      	mov	r2, r3
 8019b1a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019b1e:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		width = 1;
 8019b22:	2301      	movs	r3, #1
 8019b24:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019b26:	e060      	b.n	8019bea <__strftime_fmt_1+0x572>
	case 'x':
		item = D_FMT;
 8019b28:	4b6a      	ldr	r3, [pc, #424]	; (8019cd4 <__strftime_fmt_1+0x65c>)
 8019b2a:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strftime;
 8019b2c:	e0e8      	b.n	8019d00 <__strftime_fmt_1+0x688>
	case 'X':
		item = T_FMT;
 8019b2e:	4b6a      	ldr	r3, [pc, #424]	; (8019cd8 <__strftime_fmt_1+0x660>)
 8019b30:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strftime;
 8019b32:	e0e5      	b.n	8019d00 <__strftime_fmt_1+0x688>
	case 'y':
		val = (tm->tm_year + 1900LL) % 100;
 8019b34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019b36:	695b      	ldr	r3, [r3, #20]
 8019b38:	461a      	mov	r2, r3
 8019b3a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019b3e:	f240 706c 	movw	r0, #1900	; 0x76c
 8019b42:	f04f 0100 	mov.w	r1, #0
 8019b46:	1814      	adds	r4, r2, r0
 8019b48:	61bc      	str	r4, [r7, #24]
 8019b4a:	414b      	adcs	r3, r1
 8019b4c:	61fb      	str	r3, [r7, #28]
 8019b4e:	f04f 0264 	mov.w	r2, #100	; 0x64
 8019b52:	f04f 0300 	mov.w	r3, #0
 8019b56:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8019b5a:	f7e7 fab7 	bl	80010cc <__aeabi_ldivmod>
 8019b5e:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		if (val < 0) val = -val;
 8019b62:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019b66:	2a00      	cmp	r2, #0
 8019b68:	f173 0300 	sbcs.w	r3, r3, #0
 8019b6c:	da3c      	bge.n	8019be8 <__strftime_fmt_1+0x570>
 8019b6e:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019b72:	4252      	negs	r2, r2
 8019b74:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8019b78:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019b7c:	e034      	b.n	8019be8 <__strftime_fmt_1+0x570>
	case 'Y':
		val = tm->tm_year + 1900LL;
 8019b7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019b80:	695b      	ldr	r3, [r3, #20]
 8019b82:	461a      	mov	r2, r3
 8019b84:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019b88:	f240 706c 	movw	r0, #1900	; 0x76c
 8019b8c:	f04f 0100 	mov.w	r1, #0
 8019b90:	1814      	adds	r4, r2, r0
 8019b92:	eb43 0501 	adc.w	r5, r3, r1
 8019b96:	e9c7 4512 	strd	r4, r5, [r7, #72]	; 0x48
		if (val >= 10000) {
 8019b9a:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019b9e:	f242 700f 	movw	r0, #9999	; 0x270f
 8019ba2:	f04f 0100 	mov.w	r1, #0
 8019ba6:	4290      	cmp	r0, r2
 8019ba8:	eb71 0303 	sbcs.w	r3, r1, r3
 8019bac:	da0e      	bge.n	8019bcc <__strftime_fmt_1+0x554>
			*l = snprintf(*s, sizeof *s, "+%lld", val);
 8019bae:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019bb2:	e9cd 2300 	strd	r2, r3, [sp]
 8019bb6:	4a49      	ldr	r2, [pc, #292]	; (8019cdc <__strftime_fmt_1+0x664>)
 8019bb8:	2164      	movs	r1, #100	; 0x64
 8019bba:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8019bbc:	f000 fe34 	bl	801a828 <snprintf>
 8019bc0:	4603      	mov	r3, r0
 8019bc2:	461a      	mov	r2, r3
 8019bc4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019bc6:	601a      	str	r2, [r3, #0]
			return *s;
 8019bc8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8019bca:	e0b0      	b.n	8019d2e <__strftime_fmt_1+0x6b6>
		}
		width = 4;
 8019bcc:	2304      	movs	r3, #4
 8019bce:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019bd0:	e00b      	b.n	8019bea <__strftime_fmt_1+0x572>
		}
		fmt = __tm_to_tzname(tm);
		goto string;
#endif
	case '%':
		*l = 1;
 8019bd2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019bd4:	2201      	movs	r2, #1
 8019bd6:	601a      	str	r2, [r3, #0]
		return "%";
 8019bd8:	4b41      	ldr	r3, [pc, #260]	; (8019ce0 <__strftime_fmt_1+0x668>)
 8019bda:	e0a8      	b.n	8019d2e <__strftime_fmt_1+0x6b6>
	default:
		return 0;
 8019bdc:	2300      	movs	r3, #0
 8019bde:	e0a6      	b.n	8019d2e <__strftime_fmt_1+0x6b6>
		goto number;
 8019be0:	bf00      	nop
 8019be2:	e002      	b.n	8019bea <__strftime_fmt_1+0x572>
		goto number;
 8019be4:	bf00      	nop
 8019be6:	e000      	b.n	8019bea <__strftime_fmt_1+0x572>
		goto number;
 8019be8:	bf00      	nop
	}
number:
	switch (pad ? pad : def_pad) {
 8019bea:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019bec:	2b00      	cmp	r3, #0
 8019bee:	d001      	beq.n	8019bf4 <__strftime_fmt_1+0x57c>
 8019bf0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019bf2:	e000      	b.n	8019bf6 <__strftime_fmt_1+0x57e>
 8019bf4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019bf6:	2b2d      	cmp	r3, #45	; 0x2d
 8019bf8:	d002      	beq.n	8019c00 <__strftime_fmt_1+0x588>
 8019bfa:	2b5f      	cmp	r3, #95	; 0x5f
 8019bfc:	d00e      	beq.n	8019c1c <__strftime_fmt_1+0x5a4>
 8019bfe:	e01c      	b.n	8019c3a <__strftime_fmt_1+0x5c2>
	case '-': *l = snprintf(*s, sizeof *s, "%lld", val); break;
 8019c00:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019c04:	e9cd 2300 	strd	r2, r3, [sp]
 8019c08:	4a36      	ldr	r2, [pc, #216]	; (8019ce4 <__strftime_fmt_1+0x66c>)
 8019c0a:	2164      	movs	r1, #100	; 0x64
 8019c0c:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8019c0e:	f000 fe0b 	bl	801a828 <snprintf>
 8019c12:	4603      	mov	r3, r0
 8019c14:	461a      	mov	r2, r3
 8019c16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019c18:	601a      	str	r2, [r3, #0]
 8019c1a:	e01d      	b.n	8019c58 <__strftime_fmt_1+0x5e0>
	case '_': *l = snprintf(*s, sizeof *s, "%*lld", width, val); break;
 8019c1c:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019c20:	e9cd 2300 	strd	r2, r3, [sp]
 8019c24:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8019c26:	4a30      	ldr	r2, [pc, #192]	; (8019ce8 <__strftime_fmt_1+0x670>)
 8019c28:	2164      	movs	r1, #100	; 0x64
 8019c2a:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8019c2c:	f000 fdfc 	bl	801a828 <snprintf>
 8019c30:	4603      	mov	r3, r0
 8019c32:	461a      	mov	r2, r3
 8019c34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019c36:	601a      	str	r2, [r3, #0]
 8019c38:	e00e      	b.n	8019c58 <__strftime_fmt_1+0x5e0>
	case '0':
	default:  *l = snprintf(*s, sizeof *s, "%0*lld", width, val); break;
 8019c3a:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019c3e:	e9cd 2300 	strd	r2, r3, [sp]
 8019c42:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8019c44:	4a29      	ldr	r2, [pc, #164]	; (8019cec <__strftime_fmt_1+0x674>)
 8019c46:	2164      	movs	r1, #100	; 0x64
 8019c48:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8019c4a:	f000 fded 	bl	801a828 <snprintf>
 8019c4e:	4603      	mov	r3, r0
 8019c50:	461a      	mov	r2, r3
 8019c52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019c54:	601a      	str	r2, [r3, #0]
 8019c56:	bf00      	nop
	}
	return *s;
 8019c58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8019c5a:	e068      	b.n	8019d2e <__strftime_fmt_1+0x6b6>
nl_strcat:
	fmt = __nl_langinfo_l(item, loc);
 8019c5c:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8019c5e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8019c60:	f000 fd4c 	bl	801a6fc <__nl_langinfo_l>
 8019c64:	63f8      	str	r0, [r7, #60]	; 0x3c
 8019c66:	e006      	b.n	8019c76 <__strftime_fmt_1+0x5fe>
		if (tm->tm_wday > 6U) goto string;
 8019c68:	bf00      	nop
 8019c6a:	e004      	b.n	8019c76 <__strftime_fmt_1+0x5fe>
		if (tm->tm_wday > 6U) goto string;
 8019c6c:	bf00      	nop
 8019c6e:	e002      	b.n	8019c76 <__strftime_fmt_1+0x5fe>
		if (tm->tm_mon > 11U) goto string;
 8019c70:	bf00      	nop
 8019c72:	e000      	b.n	8019c76 <__strftime_fmt_1+0x5fe>
		if (tm->tm_mon > 11U) goto string;
 8019c74:	bf00      	nop
string:
	*l = strlen(fmt);
 8019c76:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8019c78:	f7f4 ff07 	bl	800ea8a <strlen>
 8019c7c:	4602      	mov	r2, r0
 8019c7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019c80:	601a      	str	r2, [r3, #0]
	if (f=='P') {
 8019c82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019c84:	2b50      	cmp	r3, #80	; 0x50
 8019c86:	d113      	bne.n	8019cb0 <__strftime_fmt_1+0x638>
		static char ampm[2][3] = {"am", "pm"};
		if (!strncmp(fmt, "AM", 2)) return ampm[0];
 8019c88:	2202      	movs	r2, #2
 8019c8a:	4919      	ldr	r1, [pc, #100]	; (8019cf0 <__strftime_fmt_1+0x678>)
 8019c8c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8019c8e:	f7ff fbcb 	bl	8019428 <strncmp>
 8019c92:	4603      	mov	r3, r0
 8019c94:	2b00      	cmp	r3, #0
 8019c96:	d101      	bne.n	8019c9c <__strftime_fmt_1+0x624>
 8019c98:	4b16      	ldr	r3, [pc, #88]	; (8019cf4 <__strftime_fmt_1+0x67c>)
 8019c9a:	e048      	b.n	8019d2e <__strftime_fmt_1+0x6b6>
		else if (!strncmp(fmt, "PM", 2)) return ampm[1];
 8019c9c:	2202      	movs	r2, #2
 8019c9e:	4916      	ldr	r1, [pc, #88]	; (8019cf8 <__strftime_fmt_1+0x680>)
 8019ca0:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8019ca2:	f7ff fbc1 	bl	8019428 <strncmp>
 8019ca6:	4603      	mov	r3, r0
 8019ca8:	2b00      	cmp	r3, #0
 8019caa:	d101      	bne.n	8019cb0 <__strftime_fmt_1+0x638>
 8019cac:	4b13      	ldr	r3, [pc, #76]	; (8019cfc <__strftime_fmt_1+0x684>)
 8019cae:	e03e      	b.n	8019d2e <__strftime_fmt_1+0x6b6>
	}
	return fmt;
 8019cb0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019cb2:	e03c      	b.n	8019d2e <__strftime_fmt_1+0x6b6>
 8019cb4:	0802310c 	.word	0x0802310c
 8019cb8:	00020027 	.word	0x00020027
 8019cbc:	00020026 	.word	0x00020026
 8019cc0:	0002002b 	.word	0x0002002b
 8019cc4:	08023110 	.word	0x08023110
 8019cc8:	08023118 	.word	0x08023118
 8019ccc:	0802311c 	.word	0x0802311c
 8019cd0:	24924925 	.word	0x24924925
 8019cd4:	00020029 	.word	0x00020029
 8019cd8:	0002002a 	.word	0x0002002a
 8019cdc:	08023128 	.word	0x08023128
 8019ce0:	08023130 	.word	0x08023130
 8019ce4:	08023134 	.word	0x08023134
 8019ce8:	0802313c 	.word	0x0802313c
 8019cec:	08023144 	.word	0x08023144
 8019cf0:	0802314c 	.word	0x0802314c
 8019cf4:	20000568 	.word	0x20000568
 8019cf8:	08023150 	.word	0x08023150
 8019cfc:	2000056b 	.word	0x2000056b
nl_strftime:
	fmt = __nl_langinfo_l(item, loc);
 8019d00:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8019d02:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8019d04:	f000 fcfa 	bl	801a6fc <__nl_langinfo_l>
 8019d08:	63f8      	str	r0, [r7, #60]	; 0x3c
recu_strftime:
	*l = __strftime_l(*s, sizeof *s, fmt, tm, loc);
 8019d0a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8019d0c:	9300      	str	r3, [sp, #0]
 8019d0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019d10:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8019d12:	2164      	movs	r1, #100	; 0x64
 8019d14:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8019d16:	f000 f80f 	bl	8019d38 <__strftime_l>
 8019d1a:	4602      	mov	r2, r0
 8019d1c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019d1e:	601a      	str	r2, [r3, #0]
	if (!*l) return 0;
 8019d20:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019d22:	681b      	ldr	r3, [r3, #0]
 8019d24:	2b00      	cmp	r3, #0
 8019d26:	d101      	bne.n	8019d2c <__strftime_fmt_1+0x6b4>
 8019d28:	2300      	movs	r3, #0
 8019d2a:	e000      	b.n	8019d2e <__strftime_fmt_1+0x6b6>
	return *s;
 8019d2c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 8019d2e:	4618      	mov	r0, r3
 8019d30:	3750      	adds	r7, #80	; 0x50
 8019d32:	46bd      	mov	sp, r7
 8019d34:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08019d38 <__strftime_l>:

size_t __strftime_l(char *restrict s, size_t n, const char *restrict f, const struct tm *restrict tm, locale_t loc)
{
 8019d38:	b580      	push	{r7, lr}
 8019d3a:	b0aa      	sub	sp, #168	; 0xa8
 8019d3c:	af02      	add	r7, sp, #8
 8019d3e:	6178      	str	r0, [r7, #20]
 8019d40:	6139      	str	r1, [r7, #16]
 8019d42:	60fa      	str	r2, [r7, #12]
 8019d44:	60bb      	str	r3, [r7, #8]
 8019d46:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019d4a:	607b      	str	r3, [r7, #4]
 8019d4c:	4b9c      	ldr	r3, [pc, #624]	; (8019fc0 <__strftime_l+0x288>)
 8019d4e:	681b      	ldr	r3, [r3, #0]
 8019d50:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8019d54:	f04f 0300 	mov.w	r3, #0
	char buf[100];
	char *p;
	const char *t;
	int pad, plus;
	unsigned long width;
	for (l=0; l<n; f++) {
 8019d58:	2300      	movs	r3, #0
 8019d5a:	623b      	str	r3, [r7, #32]
 8019d5c:	e10d      	b.n	8019f7a <__strftime_l+0x242>
		if (!*f) {
 8019d5e:	68fb      	ldr	r3, [r7, #12]
 8019d60:	781b      	ldrb	r3, [r3, #0]
 8019d62:	2b00      	cmp	r3, #0
 8019d64:	d106      	bne.n	8019d74 <__strftime_l+0x3c>
			s[l] = 0;
 8019d66:	697a      	ldr	r2, [r7, #20]
 8019d68:	6a3b      	ldr	r3, [r7, #32]
 8019d6a:	4413      	add	r3, r2
 8019d6c:	2200      	movs	r2, #0
 8019d6e:	701a      	strb	r2, [r3, #0]
			return l;
 8019d70:	6a3b      	ldr	r3, [r7, #32]
 8019d72:	e119      	b.n	8019fa8 <__strftime_l+0x270>
		}
		if (*f != '%') {
 8019d74:	68fb      	ldr	r3, [r7, #12]
 8019d76:	781b      	ldrb	r3, [r3, #0]
 8019d78:	2b25      	cmp	r3, #37	; 0x25
 8019d7a:	d008      	beq.n	8019d8e <__strftime_l+0x56>
			s[l++] = *f;
 8019d7c:	6a3b      	ldr	r3, [r7, #32]
 8019d7e:	1c5a      	adds	r2, r3, #1
 8019d80:	623a      	str	r2, [r7, #32]
 8019d82:	697a      	ldr	r2, [r7, #20]
 8019d84:	4413      	add	r3, r2
 8019d86:	68fa      	ldr	r2, [r7, #12]
 8019d88:	7812      	ldrb	r2, [r2, #0]
 8019d8a:	701a      	strb	r2, [r3, #0]
			continue;
 8019d8c:	e0f2      	b.n	8019f74 <__strftime_l+0x23c>
		}
		f++;
 8019d8e:	68fb      	ldr	r3, [r7, #12]
 8019d90:	3301      	adds	r3, #1
 8019d92:	60fb      	str	r3, [r7, #12]
		pad = 0;
 8019d94:	2300      	movs	r3, #0
 8019d96:	62bb      	str	r3, [r7, #40]	; 0x28
		if (*f == '-' || *f == '_' || *f == '0') pad = *f++;
 8019d98:	68fb      	ldr	r3, [r7, #12]
 8019d9a:	781b      	ldrb	r3, [r3, #0]
 8019d9c:	2b2d      	cmp	r3, #45	; 0x2d
 8019d9e:	d007      	beq.n	8019db0 <__strftime_l+0x78>
 8019da0:	68fb      	ldr	r3, [r7, #12]
 8019da2:	781b      	ldrb	r3, [r3, #0]
 8019da4:	2b5f      	cmp	r3, #95	; 0x5f
 8019da6:	d003      	beq.n	8019db0 <__strftime_l+0x78>
 8019da8:	68fb      	ldr	r3, [r7, #12]
 8019daa:	781b      	ldrb	r3, [r3, #0]
 8019dac:	2b30      	cmp	r3, #48	; 0x30
 8019dae:	d104      	bne.n	8019dba <__strftime_l+0x82>
 8019db0:	68fb      	ldr	r3, [r7, #12]
 8019db2:	1c5a      	adds	r2, r3, #1
 8019db4:	60fa      	str	r2, [r7, #12]
 8019db6:	781b      	ldrb	r3, [r3, #0]
 8019db8:	62bb      	str	r3, [r7, #40]	; 0x28
		if ((plus = (*f == '+'))) f++;
 8019dba:	68fb      	ldr	r3, [r7, #12]
 8019dbc:	781b      	ldrb	r3, [r3, #0]
 8019dbe:	2b2b      	cmp	r3, #43	; 0x2b
 8019dc0:	bf0c      	ite	eq
 8019dc2:	2301      	moveq	r3, #1
 8019dc4:	2300      	movne	r3, #0
 8019dc6:	b2db      	uxtb	r3, r3
 8019dc8:	637b      	str	r3, [r7, #52]	; 0x34
 8019dca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8019dcc:	2b00      	cmp	r3, #0
 8019dce:	d002      	beq.n	8019dd6 <__strftime_l+0x9e>
 8019dd0:	68fb      	ldr	r3, [r7, #12]
 8019dd2:	3301      	adds	r3, #1
 8019dd4:	60fb      	str	r3, [r7, #12]
		width = strtoul(f, &p, 10);
 8019dd6:	f107 031c 	add.w	r3, r7, #28
 8019dda:	220a      	movs	r2, #10
 8019ddc:	4619      	mov	r1, r3
 8019dde:	68f8      	ldr	r0, [r7, #12]
 8019de0:	f7f4 fed6 	bl	800eb90 <strtoul>
 8019de4:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (*p == 'C' || *p == 'F' || *p == 'G' || *p == 'Y') {
 8019de6:	69fb      	ldr	r3, [r7, #28]
 8019de8:	781b      	ldrb	r3, [r3, #0]
 8019dea:	2b43      	cmp	r3, #67	; 0x43
 8019dec:	d00b      	beq.n	8019e06 <__strftime_l+0xce>
 8019dee:	69fb      	ldr	r3, [r7, #28]
 8019df0:	781b      	ldrb	r3, [r3, #0]
 8019df2:	2b46      	cmp	r3, #70	; 0x46
 8019df4:	d007      	beq.n	8019e06 <__strftime_l+0xce>
 8019df6:	69fb      	ldr	r3, [r7, #28]
 8019df8:	781b      	ldrb	r3, [r3, #0]
 8019dfa:	2b47      	cmp	r3, #71	; 0x47
 8019dfc:	d003      	beq.n	8019e06 <__strftime_l+0xce>
 8019dfe:	69fb      	ldr	r3, [r7, #28]
 8019e00:	781b      	ldrb	r3, [r3, #0]
 8019e02:	2b59      	cmp	r3, #89	; 0x59
 8019e04:	d109      	bne.n	8019e1a <__strftime_l+0xe2>
			if (!width && p!=f) width = 1;
 8019e06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019e08:	2b00      	cmp	r3, #0
 8019e0a:	d109      	bne.n	8019e20 <__strftime_l+0xe8>
 8019e0c:	69fb      	ldr	r3, [r7, #28]
 8019e0e:	68fa      	ldr	r2, [r7, #12]
 8019e10:	429a      	cmp	r2, r3
 8019e12:	d005      	beq.n	8019e20 <__strftime_l+0xe8>
 8019e14:	2301      	movs	r3, #1
 8019e16:	62fb      	str	r3, [r7, #44]	; 0x2c
 8019e18:	e002      	b.n	8019e20 <__strftime_l+0xe8>
		} else {
			width = 0;
 8019e1a:	2300      	movs	r3, #0
 8019e1c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8019e1e:	e000      	b.n	8019e22 <__strftime_l+0xea>
			if (!width && p!=f) width = 1;
 8019e20:	bf00      	nop
		}
		f = p;
 8019e22:	69fb      	ldr	r3, [r7, #28]
 8019e24:	60fb      	str	r3, [r7, #12]
		if (*f == 'E' || *f == 'O') f++;
 8019e26:	68fb      	ldr	r3, [r7, #12]
 8019e28:	781b      	ldrb	r3, [r3, #0]
 8019e2a:	2b45      	cmp	r3, #69	; 0x45
 8019e2c:	d003      	beq.n	8019e36 <__strftime_l+0xfe>
 8019e2e:	68fb      	ldr	r3, [r7, #12]
 8019e30:	781b      	ldrb	r3, [r3, #0]
 8019e32:	2b4f      	cmp	r3, #79	; 0x4f
 8019e34:	d102      	bne.n	8019e3c <__strftime_l+0x104>
 8019e36:	68fb      	ldr	r3, [r7, #12]
 8019e38:	3301      	adds	r3, #1
 8019e3a:	60fb      	str	r3, [r7, #12]
		t = __strftime_fmt_1(&buf, &k, *f, tm, loc, pad);
 8019e3c:	68fb      	ldr	r3, [r7, #12]
 8019e3e:	781b      	ldrb	r3, [r3, #0]
 8019e40:	461a      	mov	r2, r3
 8019e42:	f107 0118 	add.w	r1, r7, #24
 8019e46:	f107 0038 	add.w	r0, r7, #56	; 0x38
 8019e4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019e4c:	9301      	str	r3, [sp, #4]
 8019e4e:	687b      	ldr	r3, [r7, #4]
 8019e50:	9300      	str	r3, [sp, #0]
 8019e52:	68bb      	ldr	r3, [r7, #8]
 8019e54:	f7ff fc10 	bl	8019678 <__strftime_fmt_1>
 8019e58:	6278      	str	r0, [r7, #36]	; 0x24
		if (!t) break;
 8019e5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019e5c:	2b00      	cmp	r3, #0
 8019e5e:	f000 8092 	beq.w	8019f86 <__strftime_l+0x24e>
		if (width) {
 8019e62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019e64:	2b00      	cmp	r3, #0
 8019e66:	d06f      	beq.n	8019f48 <__strftime_l+0x210>
			/* Trim off any sign and leading zeros, then
			 * count remaining digits to determine behavior
			 * for the + flag. */
			if (*t=='+' || *t=='-') t++, k--;
 8019e68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019e6a:	781b      	ldrb	r3, [r3, #0]
 8019e6c:	2b2b      	cmp	r3, #43	; 0x2b
 8019e6e:	d003      	beq.n	8019e78 <__strftime_l+0x140>
 8019e70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019e72:	781b      	ldrb	r3, [r3, #0]
 8019e74:	2b2d      	cmp	r3, #45	; 0x2d
 8019e76:	d10c      	bne.n	8019e92 <__strftime_l+0x15a>
 8019e78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019e7a:	3301      	adds	r3, #1
 8019e7c:	627b      	str	r3, [r7, #36]	; 0x24
 8019e7e:	69bb      	ldr	r3, [r7, #24]
 8019e80:	3b01      	subs	r3, #1
 8019e82:	61bb      	str	r3, [r7, #24]
			for (; *t=='0' && t[1]-'0'<10U; t++, k--);
 8019e84:	e005      	b.n	8019e92 <__strftime_l+0x15a>
 8019e86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019e88:	3301      	adds	r3, #1
 8019e8a:	627b      	str	r3, [r7, #36]	; 0x24
 8019e8c:	69bb      	ldr	r3, [r7, #24]
 8019e8e:	3b01      	subs	r3, #1
 8019e90:	61bb      	str	r3, [r7, #24]
 8019e92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019e94:	781b      	ldrb	r3, [r3, #0]
 8019e96:	2b30      	cmp	r3, #48	; 0x30
 8019e98:	d105      	bne.n	8019ea6 <__strftime_l+0x16e>
 8019e9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019e9c:	3301      	adds	r3, #1
 8019e9e:	781b      	ldrb	r3, [r3, #0]
 8019ea0:	3b30      	subs	r3, #48	; 0x30
 8019ea2:	2b09      	cmp	r3, #9
 8019ea4:	d9ef      	bls.n	8019e86 <__strftime_l+0x14e>
			if (width < k) width = k;
 8019ea6:	69bb      	ldr	r3, [r7, #24]
 8019ea8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8019eaa:	429a      	cmp	r2, r3
 8019eac:	d201      	bcs.n	8019eb2 <__strftime_l+0x17a>
 8019eae:	69bb      	ldr	r3, [r7, #24]
 8019eb0:	62fb      	str	r3, [r7, #44]	; 0x2c
			size_t d;
			for (d=0; t[d]-'0'<10U; d++);
 8019eb2:	2300      	movs	r3, #0
 8019eb4:	633b      	str	r3, [r7, #48]	; 0x30
 8019eb6:	e002      	b.n	8019ebe <__strftime_l+0x186>
 8019eb8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019eba:	3301      	adds	r3, #1
 8019ebc:	633b      	str	r3, [r7, #48]	; 0x30
 8019ebe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8019ec0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019ec2:	4413      	add	r3, r2
 8019ec4:	781b      	ldrb	r3, [r3, #0]
 8019ec6:	3b30      	subs	r3, #48	; 0x30
 8019ec8:	2b09      	cmp	r3, #9
 8019eca:	d9f5      	bls.n	8019eb8 <__strftime_l+0x180>
			if (tm->tm_year < -1900) {
 8019ecc:	68bb      	ldr	r3, [r7, #8]
 8019ece:	695b      	ldr	r3, [r3, #20]
 8019ed0:	4a3c      	ldr	r2, [pc, #240]	; (8019fc4 <__strftime_l+0x28c>)
 8019ed2:	4293      	cmp	r3, r2
 8019ed4:	da0a      	bge.n	8019eec <__strftime_l+0x1b4>
				s[l++] = '-';
 8019ed6:	6a3b      	ldr	r3, [r7, #32]
 8019ed8:	1c5a      	adds	r2, r3, #1
 8019eda:	623a      	str	r2, [r7, #32]
 8019edc:	697a      	ldr	r2, [r7, #20]
 8019ede:	4413      	add	r3, r2
 8019ee0:	222d      	movs	r2, #45	; 0x2d
 8019ee2:	701a      	strb	r2, [r3, #0]
				width--;
 8019ee4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019ee6:	3b01      	subs	r3, #1
 8019ee8:	62fb      	str	r3, [r7, #44]	; 0x2c
 8019eea:	e025      	b.n	8019f38 <__strftime_l+0x200>
			} else if (plus && d+(width-k) >= (*p=='C'?3:5)) {
 8019eec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8019eee:	2b00      	cmp	r3, #0
 8019ef0:	d022      	beq.n	8019f38 <__strftime_l+0x200>
 8019ef2:	69bb      	ldr	r3, [r7, #24]
 8019ef4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8019ef6:	1ad2      	subs	r2, r2, r3
 8019ef8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019efa:	4413      	add	r3, r2
 8019efc:	69fa      	ldr	r2, [r7, #28]
 8019efe:	7812      	ldrb	r2, [r2, #0]
 8019f00:	2a43      	cmp	r2, #67	; 0x43
 8019f02:	d101      	bne.n	8019f08 <__strftime_l+0x1d0>
 8019f04:	2203      	movs	r2, #3
 8019f06:	e000      	b.n	8019f0a <__strftime_l+0x1d2>
 8019f08:	2205      	movs	r2, #5
 8019f0a:	429a      	cmp	r2, r3
 8019f0c:	d814      	bhi.n	8019f38 <__strftime_l+0x200>
				s[l++] = '+';
 8019f0e:	6a3b      	ldr	r3, [r7, #32]
 8019f10:	1c5a      	adds	r2, r3, #1
 8019f12:	623a      	str	r2, [r7, #32]
 8019f14:	697a      	ldr	r2, [r7, #20]
 8019f16:	4413      	add	r3, r2
 8019f18:	222b      	movs	r2, #43	; 0x2b
 8019f1a:	701a      	strb	r2, [r3, #0]
				width--;
 8019f1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019f1e:	3b01      	subs	r3, #1
 8019f20:	62fb      	str	r3, [r7, #44]	; 0x2c
			}
			for (; width > k && l < n; width--)
 8019f22:	e009      	b.n	8019f38 <__strftime_l+0x200>
				s[l++] = '0';
 8019f24:	6a3b      	ldr	r3, [r7, #32]
 8019f26:	1c5a      	adds	r2, r3, #1
 8019f28:	623a      	str	r2, [r7, #32]
 8019f2a:	697a      	ldr	r2, [r7, #20]
 8019f2c:	4413      	add	r3, r2
 8019f2e:	2230      	movs	r2, #48	; 0x30
 8019f30:	701a      	strb	r2, [r3, #0]
			for (; width > k && l < n; width--)
 8019f32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019f34:	3b01      	subs	r3, #1
 8019f36:	62fb      	str	r3, [r7, #44]	; 0x2c
 8019f38:	69bb      	ldr	r3, [r7, #24]
 8019f3a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8019f3c:	429a      	cmp	r2, r3
 8019f3e:	d903      	bls.n	8019f48 <__strftime_l+0x210>
 8019f40:	6a3a      	ldr	r2, [r7, #32]
 8019f42:	693b      	ldr	r3, [r7, #16]
 8019f44:	429a      	cmp	r2, r3
 8019f46:	d3ed      	bcc.n	8019f24 <__strftime_l+0x1ec>
		}
		if (k > n-l) k = n-l;
 8019f48:	693a      	ldr	r2, [r7, #16]
 8019f4a:	6a3b      	ldr	r3, [r7, #32]
 8019f4c:	1ad2      	subs	r2, r2, r3
 8019f4e:	69bb      	ldr	r3, [r7, #24]
 8019f50:	429a      	cmp	r2, r3
 8019f52:	d203      	bcs.n	8019f5c <__strftime_l+0x224>
 8019f54:	693a      	ldr	r2, [r7, #16]
 8019f56:	6a3b      	ldr	r3, [r7, #32]
 8019f58:	1ad3      	subs	r3, r2, r3
 8019f5a:	61bb      	str	r3, [r7, #24]
		memcpy(s+l, t, k);
 8019f5c:	697a      	ldr	r2, [r7, #20]
 8019f5e:	6a3b      	ldr	r3, [r7, #32]
 8019f60:	4413      	add	r3, r2
 8019f62:	69ba      	ldr	r2, [r7, #24]
 8019f64:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8019f66:	4618      	mov	r0, r3
 8019f68:	f7fe ffb2 	bl	8018ed0 <memcpy>
		l += k;
 8019f6c:	69bb      	ldr	r3, [r7, #24]
 8019f6e:	6a3a      	ldr	r2, [r7, #32]
 8019f70:	4413      	add	r3, r2
 8019f72:	623b      	str	r3, [r7, #32]
	for (l=0; l<n; f++) {
 8019f74:	68fb      	ldr	r3, [r7, #12]
 8019f76:	3301      	adds	r3, #1
 8019f78:	60fb      	str	r3, [r7, #12]
 8019f7a:	6a3a      	ldr	r2, [r7, #32]
 8019f7c:	693b      	ldr	r3, [r7, #16]
 8019f7e:	429a      	cmp	r2, r3
 8019f80:	f4ff aeed 	bcc.w	8019d5e <__strftime_l+0x26>
 8019f84:	e000      	b.n	8019f88 <__strftime_l+0x250>
		if (!t) break;
 8019f86:	bf00      	nop
	}
	if (n) {
 8019f88:	693b      	ldr	r3, [r7, #16]
 8019f8a:	2b00      	cmp	r3, #0
 8019f8c:	d00b      	beq.n	8019fa6 <__strftime_l+0x26e>
		if (l==n) l=n-1;
 8019f8e:	6a3a      	ldr	r2, [r7, #32]
 8019f90:	693b      	ldr	r3, [r7, #16]
 8019f92:	429a      	cmp	r2, r3
 8019f94:	d102      	bne.n	8019f9c <__strftime_l+0x264>
 8019f96:	693b      	ldr	r3, [r7, #16]
 8019f98:	3b01      	subs	r3, #1
 8019f9a:	623b      	str	r3, [r7, #32]
		s[l] = 0;
 8019f9c:	697a      	ldr	r2, [r7, #20]
 8019f9e:	6a3b      	ldr	r3, [r7, #32]
 8019fa0:	4413      	add	r3, r2
 8019fa2:	2200      	movs	r2, #0
 8019fa4:	701a      	strb	r2, [r3, #0]
	}
	return 0;
 8019fa6:	2300      	movs	r3, #0
}
 8019fa8:	4a05      	ldr	r2, [pc, #20]	; (8019fc0 <__strftime_l+0x288>)
 8019faa:	6811      	ldr	r1, [r2, #0]
 8019fac:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8019fb0:	4051      	eors	r1, r2
 8019fb2:	d001      	beq.n	8019fb8 <__strftime_l+0x280>
 8019fb4:	f7ea fa18 	bl	80043e8 <__stack_chk_fail>
 8019fb8:	4618      	mov	r0, r3
 8019fba:	37a0      	adds	r7, #160	; 0xa0
 8019fbc:	46bd      	mov	sp, r7
 8019fbe:	bd80      	pop	{r7, pc}
 8019fc0:	08023154 	.word	0x08023154
 8019fc4:	fffff894 	.word	0xfffff894

08019fc8 <strftime>:

size_t strftime(char *restrict s, size_t n, const char *restrict f, const struct tm *restrict tm)
{
 8019fc8:	b580      	push	{r7, lr}
 8019fca:	b086      	sub	sp, #24
 8019fcc:	af02      	add	r7, sp, #8
 8019fce:	60f8      	str	r0, [r7, #12]
 8019fd0:	60b9      	str	r1, [r7, #8]
 8019fd2:	607a      	str	r2, [r7, #4]
 8019fd4:	603b      	str	r3, [r7, #0]
	return __strftime_l(s, n, f, tm, CURRENT_LOCALE);
 8019fd6:	2301      	movs	r3, #1
 8019fd8:	9300      	str	r3, [sp, #0]
 8019fda:	683b      	ldr	r3, [r7, #0]
 8019fdc:	687a      	ldr	r2, [r7, #4]
 8019fde:	68b9      	ldr	r1, [r7, #8]
 8019fe0:	68f8      	ldr	r0, [r7, #12]
 8019fe2:	f7ff fea9 	bl	8019d38 <__strftime_l>
 8019fe6:	4603      	mov	r3, r0
}
 8019fe8:	4618      	mov	r0, r3
 8019fea:	3710      	adds	r7, #16
 8019fec:	46bd      	mov	sp, r7
 8019fee:	bd80      	pop	{r7, pc}

08019ff0 <__isspace>:
{
 8019ff0:	b480      	push	{r7}
 8019ff2:	b083      	sub	sp, #12
 8019ff4:	af00      	add	r7, sp, #0
 8019ff6:	6078      	str	r0, [r7, #4]
	return _c == ' ' || (unsigned)_c-'\t' < 5;
 8019ff8:	687b      	ldr	r3, [r7, #4]
 8019ffa:	2b20      	cmp	r3, #32
 8019ffc:	d003      	beq.n	801a006 <__isspace+0x16>
 8019ffe:	687b      	ldr	r3, [r7, #4]
 801a000:	3b09      	subs	r3, #9
 801a002:	2b04      	cmp	r3, #4
 801a004:	d801      	bhi.n	801a00a <__isspace+0x1a>
 801a006:	2301      	movs	r3, #1
 801a008:	e000      	b.n	801a00c <__isspace+0x1c>
 801a00a:	2300      	movs	r3, #0
}
 801a00c:	4618      	mov	r0, r3
 801a00e:	370c      	adds	r7, #12
 801a010:	46bd      	mov	sp, r7
 801a012:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a016:	4770      	bx	lr

0801a018 <strptime>:
#include <stddef.h>
#include <string.h>
#include <strings.h>

char *strptime(const char *restrict s, const char *restrict f, struct tm *restrict tm)
{
 801a018:	b580      	push	{r7, lr}
 801a01a:	b094      	sub	sp, #80	; 0x50
 801a01c:	af00      	add	r7, sp, #0
 801a01e:	60f8      	str	r0, [r7, #12]
 801a020:	60b9      	str	r1, [r7, #8]
 801a022:	607a      	str	r2, [r7, #4]
 801a024:	4bbe      	ldr	r3, [pc, #760]	; (801a320 <strptime+0x308>)
 801a026:	681b      	ldr	r3, [r3, #0]
 801a028:	64fb      	str	r3, [r7, #76]	; 0x4c
 801a02a:	f04f 0300 	mov.w	r3, #0
	int i, w, neg, adj, min, range, *dest, dummy;
	const char *ex;
	size_t len;
	int want_century = 0, century = 0, relyear = 0;
 801a02e:	2300      	movs	r3, #0
 801a030:	643b      	str	r3, [r7, #64]	; 0x40
 801a032:	2300      	movs	r3, #0
 801a034:	61bb      	str	r3, [r7, #24]
 801a036:	2300      	movs	r3, #0
 801a038:	61fb      	str	r3, [r7, #28]
	while (*f) {
 801a03a:	e32a      	b.n	801a692 <strptime+0x67a>
		if (*f != '%') {
 801a03c:	68bb      	ldr	r3, [r7, #8]
 801a03e:	781b      	ldrb	r3, [r3, #0]
 801a040:	2b25      	cmp	r3, #37	; 0x25
 801a042:	d027      	beq.n	801a094 <strptime+0x7c>
			if (isspace(*f)) for (; *s && isspace(*s); s++);
 801a044:	68bb      	ldr	r3, [r7, #8]
 801a046:	781b      	ldrb	r3, [r3, #0]
 801a048:	4618      	mov	r0, r3
 801a04a:	f7ff ffd1 	bl	8019ff0 <__isspace>
 801a04e:	4603      	mov	r3, r0
 801a050:	2b00      	cmp	r3, #0
 801a052:	d010      	beq.n	801a076 <strptime+0x5e>
 801a054:	e002      	b.n	801a05c <strptime+0x44>
 801a056:	68fb      	ldr	r3, [r7, #12]
 801a058:	3301      	adds	r3, #1
 801a05a:	60fb      	str	r3, [r7, #12]
 801a05c:	68fb      	ldr	r3, [r7, #12]
 801a05e:	781b      	ldrb	r3, [r3, #0]
 801a060:	2b00      	cmp	r3, #0
 801a062:	d013      	beq.n	801a08c <strptime+0x74>
 801a064:	68fb      	ldr	r3, [r7, #12]
 801a066:	781b      	ldrb	r3, [r3, #0]
 801a068:	4618      	mov	r0, r3
 801a06a:	f7ff ffc1 	bl	8019ff0 <__isspace>
 801a06e:	4603      	mov	r3, r0
 801a070:	2b00      	cmp	r3, #0
 801a072:	d1f0      	bne.n	801a056 <strptime+0x3e>
 801a074:	e00a      	b.n	801a08c <strptime+0x74>
			else if (*s != *f) return 0;
 801a076:	68fb      	ldr	r3, [r7, #12]
 801a078:	781a      	ldrb	r2, [r3, #0]
 801a07a:	68bb      	ldr	r3, [r7, #8]
 801a07c:	781b      	ldrb	r3, [r3, #0]
 801a07e:	429a      	cmp	r2, r3
 801a080:	d001      	beq.n	801a086 <strptime+0x6e>
 801a082:	2300      	movs	r3, #0
 801a084:	e32c      	b.n	801a6e0 <strptime+0x6c8>
			else s++;
 801a086:	68fb      	ldr	r3, [r7, #12]
 801a088:	3301      	adds	r3, #1
 801a08a:	60fb      	str	r3, [r7, #12]
			f++;
 801a08c:	68bb      	ldr	r3, [r7, #8]
 801a08e:	3301      	adds	r3, #1
 801a090:	60bb      	str	r3, [r7, #8]
			continue;
 801a092:	e2fe      	b.n	801a692 <strptime+0x67a>
		}
		f++;
 801a094:	68bb      	ldr	r3, [r7, #8]
 801a096:	3301      	adds	r3, #1
 801a098:	60bb      	str	r3, [r7, #8]
		if (*f == '+') f++;
 801a09a:	68bb      	ldr	r3, [r7, #8]
 801a09c:	781b      	ldrb	r3, [r3, #0]
 801a09e:	2b2b      	cmp	r3, #43	; 0x2b
 801a0a0:	d102      	bne.n	801a0a8 <strptime+0x90>
 801a0a2:	68bb      	ldr	r3, [r7, #8]
 801a0a4:	3301      	adds	r3, #1
 801a0a6:	60bb      	str	r3, [r7, #8]
		if (isdigit(*f)) {
 801a0a8:	68bb      	ldr	r3, [r7, #8]
 801a0aa:	781b      	ldrb	r3, [r3, #0]
 801a0ac:	3b30      	subs	r3, #48	; 0x30
 801a0ae:	2b09      	cmp	r3, #9
 801a0b0:	d80b      	bhi.n	801a0ca <strptime+0xb2>
			char *new_f;
			w=strtoul(f, &new_f, 10);
 801a0b2:	f107 0320 	add.w	r3, r7, #32
 801a0b6:	220a      	movs	r2, #10
 801a0b8:	4619      	mov	r1, r3
 801a0ba:	68b8      	ldr	r0, [r7, #8]
 801a0bc:	f7f4 fd68 	bl	800eb90 <strtoul>
 801a0c0:	4603      	mov	r3, r0
 801a0c2:	62bb      	str	r3, [r7, #40]	; 0x28
			f = new_f;
 801a0c4:	6a3b      	ldr	r3, [r7, #32]
 801a0c6:	60bb      	str	r3, [r7, #8]
 801a0c8:	e002      	b.n	801a0d0 <strptime+0xb8>
		} else {
			w=-1;
 801a0ca:	f04f 33ff 	mov.w	r3, #4294967295
 801a0ce:	62bb      	str	r3, [r7, #40]	; 0x28
		}
		adj=0;
 801a0d0:	2300      	movs	r3, #0
 801a0d2:	633b      	str	r3, [r7, #48]	; 0x30
		switch (*f++) {
 801a0d4:	68bb      	ldr	r3, [r7, #8]
 801a0d6:	1c5a      	adds	r2, r3, #1
 801a0d8:	60ba      	str	r2, [r7, #8]
 801a0da:	781b      	ldrb	r3, [r3, #0]
 801a0dc:	3b25      	subs	r3, #37	; 0x25
 801a0de:	2b54      	cmp	r3, #84	; 0x54
 801a0e0:	f200 8207 	bhi.w	801a4f2 <strptime+0x4da>
 801a0e4:	a201      	add	r2, pc, #4	; (adr r2, 801a0ec <strptime+0xd4>)
 801a0e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a0ea:	bf00      	nop
 801a0ec:	0801a4e1 	.word	0x0801a4e1
 801a0f0:	0801a4f3 	.word	0x0801a4f3
 801a0f4:	0801a4f3 	.word	0x0801a4f3
 801a0f8:	0801a4f3 	.word	0x0801a4f3
 801a0fc:	0801a4f3 	.word	0x0801a4f3
 801a100:	0801a4f3 	.word	0x0801a4f3
 801a104:	0801a4f3 	.word	0x0801a4f3
 801a108:	0801a4f3 	.word	0x0801a4f3
 801a10c:	0801a4f3 	.word	0x0801a4f3
 801a110:	0801a4f3 	.word	0x0801a4f3
 801a114:	0801a4f3 	.word	0x0801a4f3
 801a118:	0801a4f3 	.word	0x0801a4f3
 801a11c:	0801a4f3 	.word	0x0801a4f3
 801a120:	0801a4f3 	.word	0x0801a4f3
 801a124:	0801a4f3 	.word	0x0801a4f3
 801a128:	0801a4f3 	.word	0x0801a4f3
 801a12c:	0801a4f3 	.word	0x0801a4f3
 801a130:	0801a4f3 	.word	0x0801a4f3
 801a134:	0801a4f3 	.word	0x0801a4f3
 801a138:	0801a4f3 	.word	0x0801a4f3
 801a13c:	0801a4f3 	.word	0x0801a4f3
 801a140:	0801a4f3 	.word	0x0801a4f3
 801a144:	0801a4f3 	.word	0x0801a4f3
 801a148:	0801a4f3 	.word	0x0801a4f3
 801a14c:	0801a4f3 	.word	0x0801a4f3
 801a150:	0801a4f3 	.word	0x0801a4f3
 801a154:	0801a4f3 	.word	0x0801a4f3
 801a158:	0801a4f3 	.word	0x0801a4f3
 801a15c:	0801a241 	.word	0x0801a241
 801a160:	0801a253 	.word	0x0801a253
 801a164:	0801a283 	.word	0x0801a283
 801a168:	0801a2ad 	.word	0x0801a2ad
 801a16c:	0801a4f3 	.word	0x0801a4f3
 801a170:	0801a4f3 	.word	0x0801a4f3
 801a174:	0801a4f3 	.word	0x0801a4f3
 801a178:	0801a2c5 	.word	0x0801a2c5
 801a17c:	0801a2d5 	.word	0x0801a2d5
 801a180:	0801a4f3 	.word	0x0801a4f3
 801a184:	0801a4f3 	.word	0x0801a4f3
 801a188:	0801a4f3 	.word	0x0801a4f3
 801a18c:	0801a30f 	.word	0x0801a30f
 801a190:	0801a4f3 	.word	0x0801a4f3
 801a194:	0801a4f3 	.word	0x0801a4f3
 801a198:	0801a4f3 	.word	0x0801a4f3
 801a19c:	0801a4f3 	.word	0x0801a4f3
 801a1a0:	0801a413 	.word	0x0801a413
 801a1a4:	0801a42b 	.word	0x0801a42b
 801a1a8:	0801a439 	.word	0x0801a439
 801a1ac:	0801a451 	.word	0x0801a451
 801a1b0:	0801a4f3 	.word	0x0801a4f3
 801a1b4:	0801a451 	.word	0x0801a451
 801a1b8:	0801a491 	.word	0x0801a491
 801a1bc:	0801a4c5 	.word	0x0801a4c5
 801a1c0:	0801a4f3 	.word	0x0801a4f3
 801a1c4:	0801a4f3 	.word	0x0801a4f3
 801a1c8:	0801a4f3 	.word	0x0801a4f3
 801a1cc:	0801a4f3 	.word	0x0801a4f3
 801a1d0:	0801a4f3 	.word	0x0801a4f3
 801a1d4:	0801a4f3 	.word	0x0801a4f3
 801a1d8:	0801a4f3 	.word	0x0801a4f3
 801a1dc:	0801a241 	.word	0x0801a241
 801a1e0:	0801a253 	.word	0x0801a253
 801a1e4:	0801a263 	.word	0x0801a263
 801a1e8:	0801a29d 	.word	0x0801a29d
 801a1ec:	0801a29d 	.word	0x0801a29d
 801a1f0:	0801a4f3 	.word	0x0801a4f3
 801a1f4:	0801a4f3 	.word	0x0801a4f3
 801a1f8:	0801a253 	.word	0x0801a253
 801a1fc:	0801a4f3 	.word	0x0801a4f3
 801a200:	0801a2e5 	.word	0x0801a2e5
 801a204:	0801a4f3 	.word	0x0801a4f3
 801a208:	0801a4f3 	.word	0x0801a4f3
 801a20c:	0801a2fb 	.word	0x0801a2fb
 801a210:	0801a337 	.word	0x0801a337
 801a214:	0801a4f3 	.word	0x0801a4f3
 801a218:	0801a353 	.word	0x0801a353
 801a21c:	0801a4f3 	.word	0x0801a4f3
 801a220:	0801a3f3 	.word	0x0801a3f3
 801a224:	0801a4f3 	.word	0x0801a4f3
 801a228:	0801a337 	.word	0x0801a337
 801a22c:	0801a4f3 	.word	0x0801a4f3
 801a230:	0801a4f3 	.word	0x0801a4f3
 801a234:	0801a461 	.word	0x0801a461
 801a238:	0801a471 	.word	0x0801a471
 801a23c:	0801a4b1 	.word	0x0801a4b1
		case 'a': case 'A':
			dest = &tm->tm_wday;
 801a240:	687b      	ldr	r3, [r7, #4]
 801a242:	3318      	adds	r3, #24
 801a244:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = ABDAY_1;
 801a246:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 801a24a:	637b      	str	r3, [r7, #52]	; 0x34
			range = 7;
 801a24c:	2307      	movs	r3, #7
 801a24e:	63bb      	str	r3, [r7, #56]	; 0x38
			goto symbolic_range;
 801a250:	e1eb      	b.n	801a62a <strptime+0x612>
		case 'b': case 'B': case 'h':
			dest = &tm->tm_mon;
 801a252:	687b      	ldr	r3, [r7, #4]
 801a254:	3310      	adds	r3, #16
 801a256:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = ABMON_1;
 801a258:	4b32      	ldr	r3, [pc, #200]	; (801a324 <strptime+0x30c>)
 801a25a:	637b      	str	r3, [r7, #52]	; 0x34
			range = 12;
 801a25c:	230c      	movs	r3, #12
 801a25e:	63bb      	str	r3, [r7, #56]	; 0x38
			goto symbolic_range;
 801a260:	e1e3      	b.n	801a62a <strptime+0x612>
		case 'c':
			s = strptime(s, nl_langinfo(D_T_FMT), tm);
 801a262:	4831      	ldr	r0, [pc, #196]	; (801a328 <strptime+0x310>)
 801a264:	f000 faa8 	bl	801a7b8 <__nl_langinfo>
 801a268:	4603      	mov	r3, r0
 801a26a:	687a      	ldr	r2, [r7, #4]
 801a26c:	4619      	mov	r1, r3
 801a26e:	68f8      	ldr	r0, [r7, #12]
 801a270:	f7ff fed2 	bl	801a018 <strptime>
 801a274:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a276:	68fb      	ldr	r3, [r7, #12]
 801a278:	2b00      	cmp	r3, #0
 801a27a:	f040 820a 	bne.w	801a692 <strptime+0x67a>
 801a27e:	2300      	movs	r3, #0
 801a280:	e22e      	b.n	801a6e0 <strptime+0x6c8>
			break;
		case 'C':
			dest = &century;
 801a282:	f107 0318 	add.w	r3, r7, #24
 801a286:	63fb      	str	r3, [r7, #60]	; 0x3c
			if (w<0) w=2;
 801a288:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a28a:	2b00      	cmp	r3, #0
 801a28c:	da01      	bge.n	801a292 <strptime+0x27a>
 801a28e:	2302      	movs	r3, #2
 801a290:	62bb      	str	r3, [r7, #40]	; 0x28
			want_century |= 2;
 801a292:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a294:	f043 0302 	orr.w	r3, r3, #2
 801a298:	643b      	str	r3, [r7, #64]	; 0x40
			goto numeric_digits;
 801a29a:	e16b      	b.n	801a574 <strptime+0x55c>
		case 'd': case 'e':
			dest = &tm->tm_mday;
 801a29c:	687b      	ldr	r3, [r7, #4]
 801a29e:	330c      	adds	r3, #12
 801a2a0:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 1;
 801a2a2:	2301      	movs	r3, #1
 801a2a4:	637b      	str	r3, [r7, #52]	; 0x34
			range = 31;
 801a2a6:	231f      	movs	r3, #31
 801a2a8:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a2aa:	e124      	b.n	801a4f6 <strptime+0x4de>
		case 'D':
			s = strptime(s, "%m/%d/%y", tm);
 801a2ac:	687a      	ldr	r2, [r7, #4]
 801a2ae:	491f      	ldr	r1, [pc, #124]	; (801a32c <strptime+0x314>)
 801a2b0:	68f8      	ldr	r0, [r7, #12]
 801a2b2:	f7ff feb1 	bl	801a018 <strptime>
 801a2b6:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a2b8:	68fb      	ldr	r3, [r7, #12]
 801a2ba:	2b00      	cmp	r3, #0
 801a2bc:	f040 81e9 	bne.w	801a692 <strptime+0x67a>
 801a2c0:	2300      	movs	r3, #0
 801a2c2:	e20d      	b.n	801a6e0 <strptime+0x6c8>
			break;
		case 'H':
			dest = &tm->tm_hour;
 801a2c4:	687b      	ldr	r3, [r7, #4]
 801a2c6:	3308      	adds	r3, #8
 801a2c8:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 0;
 801a2ca:	2300      	movs	r3, #0
 801a2cc:	637b      	str	r3, [r7, #52]	; 0x34
			range = 24;
 801a2ce:	2318      	movs	r3, #24
 801a2d0:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a2d2:	e110      	b.n	801a4f6 <strptime+0x4de>
		case 'I':
			dest = &tm->tm_hour;
 801a2d4:	687b      	ldr	r3, [r7, #4]
 801a2d6:	3308      	adds	r3, #8
 801a2d8:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 1;
 801a2da:	2301      	movs	r3, #1
 801a2dc:	637b      	str	r3, [r7, #52]	; 0x34
			range = 12;
 801a2de:	230c      	movs	r3, #12
 801a2e0:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a2e2:	e108      	b.n	801a4f6 <strptime+0x4de>
		case 'j':
			dest = &tm->tm_yday;
 801a2e4:	687b      	ldr	r3, [r7, #4]
 801a2e6:	331c      	adds	r3, #28
 801a2e8:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 1;
 801a2ea:	2301      	movs	r3, #1
 801a2ec:	637b      	str	r3, [r7, #52]	; 0x34
			range = 366;
 801a2ee:	f44f 73b7 	mov.w	r3, #366	; 0x16e
 801a2f2:	63bb      	str	r3, [r7, #56]	; 0x38
			adj = 1;
 801a2f4:	2301      	movs	r3, #1
 801a2f6:	633b      	str	r3, [r7, #48]	; 0x30
			goto numeric_range;
 801a2f8:	e0fd      	b.n	801a4f6 <strptime+0x4de>
		case 'm':
			dest = &tm->tm_mon;
 801a2fa:	687b      	ldr	r3, [r7, #4]
 801a2fc:	3310      	adds	r3, #16
 801a2fe:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 1;
 801a300:	2301      	movs	r3, #1
 801a302:	637b      	str	r3, [r7, #52]	; 0x34
			range = 12;
 801a304:	230c      	movs	r3, #12
 801a306:	63bb      	str	r3, [r7, #56]	; 0x38
			adj = 1;
 801a308:	2301      	movs	r3, #1
 801a30a:	633b      	str	r3, [r7, #48]	; 0x30
			goto numeric_range;
 801a30c:	e0f3      	b.n	801a4f6 <strptime+0x4de>
		case 'M':
			dest = &tm->tm_min;
 801a30e:	687b      	ldr	r3, [r7, #4]
 801a310:	3304      	adds	r3, #4
 801a312:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 0;
 801a314:	2300      	movs	r3, #0
 801a316:	637b      	str	r3, [r7, #52]	; 0x34
			range = 60;
 801a318:	233c      	movs	r3, #60	; 0x3c
 801a31a:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a31c:	e0eb      	b.n	801a4f6 <strptime+0x4de>
 801a31e:	bf00      	nop
 801a320:	08023178 	.word	0x08023178
 801a324:	0002000e 	.word	0x0002000e
 801a328:	00020028 	.word	0x00020028
 801a32c:	08023158 	.word	0x08023158
		case 'n': case 't':
			for (; *s && isspace(*s); s++);
 801a330:	68fb      	ldr	r3, [r7, #12]
 801a332:	3301      	adds	r3, #1
 801a334:	60fb      	str	r3, [r7, #12]
 801a336:	68fb      	ldr	r3, [r7, #12]
 801a338:	781b      	ldrb	r3, [r3, #0]
 801a33a:	2b00      	cmp	r3, #0
 801a33c:	f000 81a9 	beq.w	801a692 <strptime+0x67a>
 801a340:	68fb      	ldr	r3, [r7, #12]
 801a342:	781b      	ldrb	r3, [r3, #0]
 801a344:	4618      	mov	r0, r3
 801a346:	f7ff fe53 	bl	8019ff0 <__isspace>
 801a34a:	4603      	mov	r3, r0
 801a34c:	2b00      	cmp	r3, #0
 801a34e:	d1ef      	bne.n	801a330 <strptime+0x318>
			break;
 801a350:	e19f      	b.n	801a692 <strptime+0x67a>
		case 'p':
			ex = nl_langinfo(AM_STR);
 801a352:	4898      	ldr	r0, [pc, #608]	; (801a5b4 <strptime+0x59c>)
 801a354:	f000 fa30 	bl	801a7b8 <__nl_langinfo>
 801a358:	6478      	str	r0, [r7, #68]	; 0x44
			len = strlen(ex);
 801a35a:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801a35c:	f7f4 fb95 	bl	800ea8a <strlen>
 801a360:	64b8      	str	r0, [r7, #72]	; 0x48
			if (!strncasecmp(s, ex, len)) {
 801a362:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801a364:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a366:	68f8      	ldr	r0, [r7, #12]
 801a368:	f003 fc67 	bl	801dc3a <strncasecmp>
 801a36c:	4603      	mov	r3, r0
 801a36e:	2b00      	cmp	r3, #0
 801a370:	d113      	bne.n	801a39a <strptime+0x382>
				tm->tm_hour %= 12;
 801a372:	687b      	ldr	r3, [r7, #4]
 801a374:	6899      	ldr	r1, [r3, #8]
 801a376:	4b90      	ldr	r3, [pc, #576]	; (801a5b8 <strptime+0x5a0>)
 801a378:	fb83 2301 	smull	r2, r3, r3, r1
 801a37c:	105a      	asrs	r2, r3, #1
 801a37e:	17cb      	asrs	r3, r1, #31
 801a380:	1ad2      	subs	r2, r2, r3
 801a382:	4613      	mov	r3, r2
 801a384:	005b      	lsls	r3, r3, #1
 801a386:	4413      	add	r3, r2
 801a388:	009b      	lsls	r3, r3, #2
 801a38a:	1aca      	subs	r2, r1, r3
 801a38c:	687b      	ldr	r3, [r7, #4]
 801a38e:	609a      	str	r2, [r3, #8]
				s += len;
 801a390:	68fa      	ldr	r2, [r7, #12]
 801a392:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a394:	4413      	add	r3, r2
 801a396:	60fb      	str	r3, [r7, #12]
				break;
 801a398:	e17b      	b.n	801a692 <strptime+0x67a>
			}
			ex = nl_langinfo(PM_STR);
 801a39a:	4888      	ldr	r0, [pc, #544]	; (801a5bc <strptime+0x5a4>)
 801a39c:	f000 fa0c 	bl	801a7b8 <__nl_langinfo>
 801a3a0:	6478      	str	r0, [r7, #68]	; 0x44
			len = strlen(ex);
 801a3a2:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801a3a4:	f7f4 fb71 	bl	800ea8a <strlen>
 801a3a8:	64b8      	str	r0, [r7, #72]	; 0x48
			if (!strncasecmp(s, ex, len)) {
 801a3aa:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801a3ac:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a3ae:	68f8      	ldr	r0, [r7, #12]
 801a3b0:	f003 fc43 	bl	801dc3a <strncasecmp>
 801a3b4:	4603      	mov	r3, r0
 801a3b6:	2b00      	cmp	r3, #0
 801a3b8:	d119      	bne.n	801a3ee <strptime+0x3d6>
				tm->tm_hour %= 12;
 801a3ba:	687b      	ldr	r3, [r7, #4]
 801a3bc:	6899      	ldr	r1, [r3, #8]
 801a3be:	4b7e      	ldr	r3, [pc, #504]	; (801a5b8 <strptime+0x5a0>)
 801a3c0:	fb83 2301 	smull	r2, r3, r3, r1
 801a3c4:	105a      	asrs	r2, r3, #1
 801a3c6:	17cb      	asrs	r3, r1, #31
 801a3c8:	1ad2      	subs	r2, r2, r3
 801a3ca:	4613      	mov	r3, r2
 801a3cc:	005b      	lsls	r3, r3, #1
 801a3ce:	4413      	add	r3, r2
 801a3d0:	009b      	lsls	r3, r3, #2
 801a3d2:	1aca      	subs	r2, r1, r3
 801a3d4:	687b      	ldr	r3, [r7, #4]
 801a3d6:	609a      	str	r2, [r3, #8]
				tm->tm_hour += 12;
 801a3d8:	687b      	ldr	r3, [r7, #4]
 801a3da:	689b      	ldr	r3, [r3, #8]
 801a3dc:	f103 020c 	add.w	r2, r3, #12
 801a3e0:	687b      	ldr	r3, [r7, #4]
 801a3e2:	609a      	str	r2, [r3, #8]
				s += len;
 801a3e4:	68fa      	ldr	r2, [r7, #12]
 801a3e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a3e8:	4413      	add	r3, r2
 801a3ea:	60fb      	str	r3, [r7, #12]
				break;
 801a3ec:	e151      	b.n	801a692 <strptime+0x67a>
			}
			return 0;
 801a3ee:	2300      	movs	r3, #0
 801a3f0:	e176      	b.n	801a6e0 <strptime+0x6c8>
		case 'r':
			s = strptime(s, nl_langinfo(T_FMT_AMPM), tm);
 801a3f2:	4873      	ldr	r0, [pc, #460]	; (801a5c0 <strptime+0x5a8>)
 801a3f4:	f000 f9e0 	bl	801a7b8 <__nl_langinfo>
 801a3f8:	4603      	mov	r3, r0
 801a3fa:	687a      	ldr	r2, [r7, #4]
 801a3fc:	4619      	mov	r1, r3
 801a3fe:	68f8      	ldr	r0, [r7, #12]
 801a400:	f7ff fe0a 	bl	801a018 <strptime>
 801a404:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a406:	68fb      	ldr	r3, [r7, #12]
 801a408:	2b00      	cmp	r3, #0
 801a40a:	f040 8142 	bne.w	801a692 <strptime+0x67a>
 801a40e:	2300      	movs	r3, #0
 801a410:	e166      	b.n	801a6e0 <strptime+0x6c8>
			break;
		case 'R':
			s = strptime(s, "%H:%M", tm);
 801a412:	687a      	ldr	r2, [r7, #4]
 801a414:	496b      	ldr	r1, [pc, #428]	; (801a5c4 <strptime+0x5ac>)
 801a416:	68f8      	ldr	r0, [r7, #12]
 801a418:	f7ff fdfe 	bl	801a018 <strptime>
 801a41c:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a41e:	68fb      	ldr	r3, [r7, #12]
 801a420:	2b00      	cmp	r3, #0
 801a422:	f040 8136 	bne.w	801a692 <strptime+0x67a>
 801a426:	2300      	movs	r3, #0
 801a428:	e15a      	b.n	801a6e0 <strptime+0x6c8>
			break;
		case 'S':
			dest = &tm->tm_sec;
 801a42a:	687b      	ldr	r3, [r7, #4]
 801a42c:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 0;
 801a42e:	2300      	movs	r3, #0
 801a430:	637b      	str	r3, [r7, #52]	; 0x34
			range = 61;
 801a432:	233d      	movs	r3, #61	; 0x3d
 801a434:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a436:	e05e      	b.n	801a4f6 <strptime+0x4de>
		case 'T':
			s = strptime(s, "%H:%M:%S", tm);
 801a438:	687a      	ldr	r2, [r7, #4]
 801a43a:	4963      	ldr	r1, [pc, #396]	; (801a5c8 <strptime+0x5b0>)
 801a43c:	68f8      	ldr	r0, [r7, #12]
 801a43e:	f7ff fdeb 	bl	801a018 <strptime>
 801a442:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a444:	68fb      	ldr	r3, [r7, #12]
 801a446:	2b00      	cmp	r3, #0
 801a448:	f040 8123 	bne.w	801a692 <strptime+0x67a>
 801a44c:	2300      	movs	r3, #0
 801a44e:	e147      	b.n	801a6e0 <strptime+0x6c8>
			break;
		case 'U':
		case 'W':
			/* Throw away result, for now. (FIXME?) */
			dest = &dummy;
 801a450:	f107 0314 	add.w	r3, r7, #20
 801a454:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 0;
 801a456:	2300      	movs	r3, #0
 801a458:	637b      	str	r3, [r7, #52]	; 0x34
			range = 54;
 801a45a:	2336      	movs	r3, #54	; 0x36
 801a45c:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a45e:	e04a      	b.n	801a4f6 <strptime+0x4de>
		case 'w':
			dest = &tm->tm_wday;
 801a460:	687b      	ldr	r3, [r7, #4]
 801a462:	3318      	adds	r3, #24
 801a464:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 0;
 801a466:	2300      	movs	r3, #0
 801a468:	637b      	str	r3, [r7, #52]	; 0x34
			range = 7;
 801a46a:	2307      	movs	r3, #7
 801a46c:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a46e:	e042      	b.n	801a4f6 <strptime+0x4de>
		case 'x':
			s = strptime(s, nl_langinfo(D_FMT), tm);
 801a470:	4856      	ldr	r0, [pc, #344]	; (801a5cc <strptime+0x5b4>)
 801a472:	f000 f9a1 	bl	801a7b8 <__nl_langinfo>
 801a476:	4603      	mov	r3, r0
 801a478:	687a      	ldr	r2, [r7, #4]
 801a47a:	4619      	mov	r1, r3
 801a47c:	68f8      	ldr	r0, [r7, #12]
 801a47e:	f7ff fdcb 	bl	801a018 <strptime>
 801a482:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a484:	68fb      	ldr	r3, [r7, #12]
 801a486:	2b00      	cmp	r3, #0
 801a488:	f040 8103 	bne.w	801a692 <strptime+0x67a>
 801a48c:	2300      	movs	r3, #0
 801a48e:	e127      	b.n	801a6e0 <strptime+0x6c8>
			break;
		case 'X':
			s = strptime(s, nl_langinfo(T_FMT), tm);
 801a490:	484f      	ldr	r0, [pc, #316]	; (801a5d0 <strptime+0x5b8>)
 801a492:	f000 f991 	bl	801a7b8 <__nl_langinfo>
 801a496:	4603      	mov	r3, r0
 801a498:	687a      	ldr	r2, [r7, #4]
 801a49a:	4619      	mov	r1, r3
 801a49c:	68f8      	ldr	r0, [r7, #12]
 801a49e:	f7ff fdbb 	bl	801a018 <strptime>
 801a4a2:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a4a4:	68fb      	ldr	r3, [r7, #12]
 801a4a6:	2b00      	cmp	r3, #0
 801a4a8:	f040 80f3 	bne.w	801a692 <strptime+0x67a>
 801a4ac:	2300      	movs	r3, #0
 801a4ae:	e117      	b.n	801a6e0 <strptime+0x6c8>
			break;
		case 'y':
			dest = &relyear;
 801a4b0:	f107 031c 	add.w	r3, r7, #28
 801a4b4:	63fb      	str	r3, [r7, #60]	; 0x3c
			w = 2;
 801a4b6:	2302      	movs	r3, #2
 801a4b8:	62bb      	str	r3, [r7, #40]	; 0x28
			want_century |= 1;
 801a4ba:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a4bc:	f043 0301 	orr.w	r3, r3, #1
 801a4c0:	643b      	str	r3, [r7, #64]	; 0x40
			goto numeric_digits;
 801a4c2:	e057      	b.n	801a574 <strptime+0x55c>
		case 'Y':
			dest = &tm->tm_year;
 801a4c4:	687b      	ldr	r3, [r7, #4]
 801a4c6:	3314      	adds	r3, #20
 801a4c8:	63fb      	str	r3, [r7, #60]	; 0x3c
			if (w<0) w=4;
 801a4ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a4cc:	2b00      	cmp	r3, #0
 801a4ce:	da01      	bge.n	801a4d4 <strptime+0x4bc>
 801a4d0:	2304      	movs	r3, #4
 801a4d2:	62bb      	str	r3, [r7, #40]	; 0x28
			adj = 1900;
 801a4d4:	f240 736c 	movw	r3, #1900	; 0x76c
 801a4d8:	633b      	str	r3, [r7, #48]	; 0x30
			want_century = 0;
 801a4da:	2300      	movs	r3, #0
 801a4dc:	643b      	str	r3, [r7, #64]	; 0x40
			goto numeric_digits;
 801a4de:	e049      	b.n	801a574 <strptime+0x55c>
		case '%':
			if (*s++ != '%') return 0;
 801a4e0:	68fb      	ldr	r3, [r7, #12]
 801a4e2:	1c5a      	adds	r2, r3, #1
 801a4e4:	60fa      	str	r2, [r7, #12]
 801a4e6:	781b      	ldrb	r3, [r3, #0]
 801a4e8:	2b25      	cmp	r3, #37	; 0x25
 801a4ea:	f000 80d2 	beq.w	801a692 <strptime+0x67a>
 801a4ee:	2300      	movs	r3, #0
 801a4f0:	e0f6      	b.n	801a6e0 <strptime+0x6c8>
			break;
		default:
			return 0;
 801a4f2:	2300      	movs	r3, #0
 801a4f4:	e0f4      	b.n	801a6e0 <strptime+0x6c8>
		numeric_range:
			if (!isdigit(*s)) return 0;
 801a4f6:	68fb      	ldr	r3, [r7, #12]
 801a4f8:	781b      	ldrb	r3, [r3, #0]
 801a4fa:	3b30      	subs	r3, #48	; 0x30
 801a4fc:	2b09      	cmp	r3, #9
 801a4fe:	d901      	bls.n	801a504 <strptime+0x4ec>
 801a500:	2300      	movs	r3, #0
 801a502:	e0ed      	b.n	801a6e0 <strptime+0x6c8>
			*dest = 0;
 801a504:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a506:	2200      	movs	r2, #0
 801a508:	601a      	str	r2, [r3, #0]
			for (i=1; i<=min+range && isdigit(*s); i*=10)
 801a50a:	2301      	movs	r3, #1
 801a50c:	627b      	str	r3, [r7, #36]	; 0x24
 801a50e:	e015      	b.n	801a53c <strptime+0x524>
				*dest = *dest * 10 + *s++ - '0';
 801a510:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a512:	681a      	ldr	r2, [r3, #0]
 801a514:	4613      	mov	r3, r2
 801a516:	009b      	lsls	r3, r3, #2
 801a518:	4413      	add	r3, r2
 801a51a:	005b      	lsls	r3, r3, #1
 801a51c:	4619      	mov	r1, r3
 801a51e:	68fb      	ldr	r3, [r7, #12]
 801a520:	1c5a      	adds	r2, r3, #1
 801a522:	60fa      	str	r2, [r7, #12]
 801a524:	781b      	ldrb	r3, [r3, #0]
 801a526:	440b      	add	r3, r1
 801a528:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 801a52c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a52e:	601a      	str	r2, [r3, #0]
			for (i=1; i<=min+range && isdigit(*s); i*=10)
 801a530:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a532:	4613      	mov	r3, r2
 801a534:	009b      	lsls	r3, r3, #2
 801a536:	4413      	add	r3, r2
 801a538:	005b      	lsls	r3, r3, #1
 801a53a:	627b      	str	r3, [r7, #36]	; 0x24
 801a53c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a53e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a540:	4413      	add	r3, r2
 801a542:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a544:	429a      	cmp	r2, r3
 801a546:	dc04      	bgt.n	801a552 <strptime+0x53a>
 801a548:	68fb      	ldr	r3, [r7, #12]
 801a54a:	781b      	ldrb	r3, [r3, #0]
 801a54c:	3b30      	subs	r3, #48	; 0x30
 801a54e:	2b09      	cmp	r3, #9
 801a550:	d9de      	bls.n	801a510 <strptime+0x4f8>
			if (*dest - min >= (unsigned)range) return 0;
 801a552:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a554:	681a      	ldr	r2, [r3, #0]
 801a556:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a558:	1ad3      	subs	r3, r2, r3
 801a55a:	461a      	mov	r2, r3
 801a55c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a55e:	429a      	cmp	r2, r3
 801a560:	d301      	bcc.n	801a566 <strptime+0x54e>
 801a562:	2300      	movs	r3, #0
 801a564:	e0bc      	b.n	801a6e0 <strptime+0x6c8>
			*dest -= adj;
 801a566:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a568:	681a      	ldr	r2, [r3, #0]
 801a56a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a56c:	1ad2      	subs	r2, r2, r3
 801a56e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a570:	601a      	str	r2, [r3, #0]
			switch((char *)dest - (char *)tm) {
			case offsetof(struct tm, tm_yday):
				;
			}
			goto update;
 801a572:	e08e      	b.n	801a692 <strptime+0x67a>
		numeric_digits:
			neg = 0;
 801a574:	2300      	movs	r3, #0
 801a576:	62fb      	str	r3, [r7, #44]	; 0x2c
			if (*s == '+') s++;
 801a578:	68fb      	ldr	r3, [r7, #12]
 801a57a:	781b      	ldrb	r3, [r3, #0]
 801a57c:	2b2b      	cmp	r3, #43	; 0x2b
 801a57e:	d103      	bne.n	801a588 <strptime+0x570>
 801a580:	68fb      	ldr	r3, [r7, #12]
 801a582:	3301      	adds	r3, #1
 801a584:	60fb      	str	r3, [r7, #12]
 801a586:	e008      	b.n	801a59a <strptime+0x582>
			else if (*s == '-') neg=1, s++;
 801a588:	68fb      	ldr	r3, [r7, #12]
 801a58a:	781b      	ldrb	r3, [r3, #0]
 801a58c:	2b2d      	cmp	r3, #45	; 0x2d
 801a58e:	d104      	bne.n	801a59a <strptime+0x582>
 801a590:	2301      	movs	r3, #1
 801a592:	62fb      	str	r3, [r7, #44]	; 0x2c
 801a594:	68fb      	ldr	r3, [r7, #12]
 801a596:	3301      	adds	r3, #1
 801a598:	60fb      	str	r3, [r7, #12]
			if (!isdigit(*s)) return 0;
 801a59a:	68fb      	ldr	r3, [r7, #12]
 801a59c:	781b      	ldrb	r3, [r3, #0]
 801a59e:	3b30      	subs	r3, #48	; 0x30
 801a5a0:	2b09      	cmp	r3, #9
 801a5a2:	d901      	bls.n	801a5a8 <strptime+0x590>
 801a5a4:	2300      	movs	r3, #0
 801a5a6:	e09b      	b.n	801a6e0 <strptime+0x6c8>
			for (*dest=i=0; i<w && isdigit(*s); i++)
 801a5a8:	2300      	movs	r3, #0
 801a5aa:	627b      	str	r3, [r7, #36]	; 0x24
 801a5ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a5ae:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a5b0:	601a      	str	r2, [r3, #0]
 801a5b2:	e022      	b.n	801a5fa <strptime+0x5e2>
 801a5b4:	00020026 	.word	0x00020026
 801a5b8:	2aaaaaab 	.word	0x2aaaaaab
 801a5bc:	00020027 	.word	0x00020027
 801a5c0:	0002002b 	.word	0x0002002b
 801a5c4:	08023164 	.word	0x08023164
 801a5c8:	0802316c 	.word	0x0802316c
 801a5cc:	00020029 	.word	0x00020029
 801a5d0:	0002002a 	.word	0x0002002a
				*dest = *dest * 10 + *s++ - '0';
 801a5d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a5d6:	681a      	ldr	r2, [r3, #0]
 801a5d8:	4613      	mov	r3, r2
 801a5da:	009b      	lsls	r3, r3, #2
 801a5dc:	4413      	add	r3, r2
 801a5de:	005b      	lsls	r3, r3, #1
 801a5e0:	4619      	mov	r1, r3
 801a5e2:	68fb      	ldr	r3, [r7, #12]
 801a5e4:	1c5a      	adds	r2, r3, #1
 801a5e6:	60fa      	str	r2, [r7, #12]
 801a5e8:	781b      	ldrb	r3, [r3, #0]
 801a5ea:	440b      	add	r3, r1
 801a5ec:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 801a5f0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a5f2:	601a      	str	r2, [r3, #0]
			for (*dest=i=0; i<w && isdigit(*s); i++)
 801a5f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a5f6:	3301      	adds	r3, #1
 801a5f8:	627b      	str	r3, [r7, #36]	; 0x24
 801a5fa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a5fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a5fe:	429a      	cmp	r2, r3
 801a600:	da04      	bge.n	801a60c <strptime+0x5f4>
 801a602:	68fb      	ldr	r3, [r7, #12]
 801a604:	781b      	ldrb	r3, [r3, #0]
 801a606:	3b30      	subs	r3, #48	; 0x30
 801a608:	2b09      	cmp	r3, #9
 801a60a:	d9e3      	bls.n	801a5d4 <strptime+0x5bc>
			if (neg) *dest = -*dest;
 801a60c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a60e:	2b00      	cmp	r3, #0
 801a610:	d004      	beq.n	801a61c <strptime+0x604>
 801a612:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a614:	681b      	ldr	r3, [r3, #0]
 801a616:	425a      	negs	r2, r3
 801a618:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a61a:	601a      	str	r2, [r3, #0]
			*dest -= adj;
 801a61c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a61e:	681a      	ldr	r2, [r3, #0]
 801a620:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a622:	1ad2      	subs	r2, r2, r3
 801a624:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a626:	601a      	str	r2, [r3, #0]
			goto update;
 801a628:	e033      	b.n	801a692 <strptime+0x67a>
		symbolic_range:
			for (i=2*range-1; i>=0; i--) {
 801a62a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a62c:	005b      	lsls	r3, r3, #1
 801a62e:	3b01      	subs	r3, #1
 801a630:	627b      	str	r3, [r7, #36]	; 0x24
 801a632:	e025      	b.n	801a680 <strptime+0x668>
				ex = nl_langinfo(min+i);
 801a634:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a636:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a638:	4413      	add	r3, r2
 801a63a:	4618      	mov	r0, r3
 801a63c:	f000 f8bc 	bl	801a7b8 <__nl_langinfo>
 801a640:	6478      	str	r0, [r7, #68]	; 0x44
				len = strlen(ex);
 801a642:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801a644:	f7f4 fa21 	bl	800ea8a <strlen>
 801a648:	64b8      	str	r0, [r7, #72]	; 0x48
				if (strncasecmp(s, ex, len)) continue;
 801a64a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801a64c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a64e:	68f8      	ldr	r0, [r7, #12]
 801a650:	f003 faf3 	bl	801dc3a <strncasecmp>
 801a654:	4603      	mov	r3, r0
 801a656:	2b00      	cmp	r3, #0
 801a658:	d003      	beq.n	801a662 <strptime+0x64a>
			for (i=2*range-1; i>=0; i--) {
 801a65a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a65c:	3b01      	subs	r3, #1
 801a65e:	627b      	str	r3, [r7, #36]	; 0x24
 801a660:	e00e      	b.n	801a680 <strptime+0x668>
				s += len;
 801a662:	68fa      	ldr	r2, [r7, #12]
 801a664:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a666:	4413      	add	r3, r2
 801a668:	60fb      	str	r3, [r7, #12]
				*dest = i % range;
 801a66a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a66c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a66e:	fb93 f2f2 	sdiv	r2, r3, r2
 801a672:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801a674:	fb01 f202 	mul.w	r2, r1, r2
 801a678:	1a9a      	subs	r2, r3, r2
 801a67a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a67c:	601a      	str	r2, [r3, #0]
				break;
 801a67e:	e002      	b.n	801a686 <strptime+0x66e>
			for (i=2*range-1; i>=0; i--) {
 801a680:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a682:	2b00      	cmp	r3, #0
 801a684:	dad6      	bge.n	801a634 <strptime+0x61c>
			}
			if (i<0) return 0;
 801a686:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a688:	2b00      	cmp	r3, #0
 801a68a:	da01      	bge.n	801a690 <strptime+0x678>
 801a68c:	2300      	movs	r3, #0
 801a68e:	e027      	b.n	801a6e0 <strptime+0x6c8>
			goto update;
 801a690:	bf00      	nop
	while (*f) {
 801a692:	68bb      	ldr	r3, [r7, #8]
 801a694:	781b      	ldrb	r3, [r3, #0]
 801a696:	2b00      	cmp	r3, #0
 801a698:	f47f acd0 	bne.w	801a03c <strptime+0x24>
		update:
			//FIXME
			;
		}
	}
	if (want_century) {
 801a69c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a69e:	2b00      	cmp	r3, #0
 801a6a0:	d01d      	beq.n	801a6de <strptime+0x6c6>
		tm->tm_year = relyear;
 801a6a2:	69fa      	ldr	r2, [r7, #28]
 801a6a4:	687b      	ldr	r3, [r7, #4]
 801a6a6:	615a      	str	r2, [r3, #20]
		if (want_century & 2) tm->tm_year += century * 100 - 1900;
 801a6a8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a6aa:	f003 0302 	and.w	r3, r3, #2
 801a6ae:	2b00      	cmp	r3, #0
 801a6b0:	d00b      	beq.n	801a6ca <strptime+0x6b2>
 801a6b2:	687b      	ldr	r3, [r7, #4]
 801a6b4:	695a      	ldr	r2, [r3, #20]
 801a6b6:	69bb      	ldr	r3, [r7, #24]
 801a6b8:	2164      	movs	r1, #100	; 0x64
 801a6ba:	fb01 f303 	mul.w	r3, r1, r3
 801a6be:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
 801a6c2:	441a      	add	r2, r3
 801a6c4:	687b      	ldr	r3, [r7, #4]
 801a6c6:	615a      	str	r2, [r3, #20]
 801a6c8:	e009      	b.n	801a6de <strptime+0x6c6>
		else if (tm->tm_year <= 68) tm->tm_year += 100;
 801a6ca:	687b      	ldr	r3, [r7, #4]
 801a6cc:	695b      	ldr	r3, [r3, #20]
 801a6ce:	2b44      	cmp	r3, #68	; 0x44
 801a6d0:	dc05      	bgt.n	801a6de <strptime+0x6c6>
 801a6d2:	687b      	ldr	r3, [r7, #4]
 801a6d4:	695b      	ldr	r3, [r3, #20]
 801a6d6:	f103 0264 	add.w	r2, r3, #100	; 0x64
 801a6da:	687b      	ldr	r3, [r7, #4]
 801a6dc:	615a      	str	r2, [r3, #20]
	}
	return (char *)s;
 801a6de:	68fb      	ldr	r3, [r7, #12]
}
 801a6e0:	4a05      	ldr	r2, [pc, #20]	; (801a6f8 <strptime+0x6e0>)
 801a6e2:	6811      	ldr	r1, [r2, #0]
 801a6e4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801a6e6:	4051      	eors	r1, r2
 801a6e8:	d001      	beq.n	801a6ee <strptime+0x6d6>
 801a6ea:	f7e9 fe7d 	bl	80043e8 <__stack_chk_fail>
 801a6ee:	4618      	mov	r0, r3
 801a6f0:	3750      	adds	r7, #80	; 0x50
 801a6f2:	46bd      	mov	sp, r7
 801a6f4:	bd80      	pop	{r7, pc}
 801a6f6:	bf00      	nop
 801a6f8:	08023178 	.word	0x08023178

0801a6fc <__nl_langinfo_l>:

static const char c_messages[] = "^[yY]\0" "^[nN]\0" "yes\0" "no";
static const char c_numeric[] = ".\0" "";

char *__nl_langinfo_l(nl_item item, locale_t loc)
{
 801a6fc:	b480      	push	{r7}
 801a6fe:	b087      	sub	sp, #28
 801a700:	af00      	add	r7, sp, #0
 801a702:	6078      	str	r0, [r7, #4]
 801a704:	6039      	str	r1, [r7, #0]
	int cat = item >> 16;
 801a706:	687b      	ldr	r3, [r7, #4]
 801a708:	141b      	asrs	r3, r3, #16
 801a70a:	617b      	str	r3, [r7, #20]
	int idx = item & 65535;
 801a70c:	687b      	ldr	r3, [r7, #4]
 801a70e:	b29b      	uxth	r3, r3
 801a710:	60fb      	str	r3, [r7, #12]
 801a712:	697b      	ldr	r3, [r7, #20]
 801a714:	3b01      	subs	r3, #1
 801a716:	2b04      	cmp	r3, #4
 801a718:	d82c      	bhi.n	801a774 <__nl_langinfo_l+0x78>
 801a71a:	a201      	add	r2, pc, #4	; (adr r2, 801a720 <__nl_langinfo_l+0x24>)
 801a71c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a720:	0801a735 	.word	0x0801a735
 801a724:	0801a745 	.word	0x0801a745
 801a728:	0801a775 	.word	0x0801a775
 801a72c:	0801a755 	.word	0x0801a755
 801a730:	0801a765 	.word	0x0801a765
		return loc->cat[cat] ? (char *)loc->cat[cat]->name : "C";
#endif
	
	switch (cat) {
	case LC_NUMERIC:
		if (idx > 1) return "";
 801a734:	68fb      	ldr	r3, [r7, #12]
 801a736:	2b01      	cmp	r3, #1
 801a738:	dd01      	ble.n	801a73e <__nl_langinfo_l+0x42>
 801a73a:	4b1b      	ldr	r3, [pc, #108]	; (801a7a8 <__nl_langinfo_l+0xac>)
 801a73c:	e02e      	b.n	801a79c <__nl_langinfo_l+0xa0>
		str = c_numeric;
 801a73e:	4b1b      	ldr	r3, [pc, #108]	; (801a7ac <__nl_langinfo_l+0xb0>)
 801a740:	613b      	str	r3, [r7, #16]
		break;
 801a742:	e019      	b.n	801a778 <__nl_langinfo_l+0x7c>
	case LC_TIME:
		if (idx > 0x31) return "";
 801a744:	68fb      	ldr	r3, [r7, #12]
 801a746:	2b31      	cmp	r3, #49	; 0x31
 801a748:	dd01      	ble.n	801a74e <__nl_langinfo_l+0x52>
 801a74a:	4b17      	ldr	r3, [pc, #92]	; (801a7a8 <__nl_langinfo_l+0xac>)
 801a74c:	e026      	b.n	801a79c <__nl_langinfo_l+0xa0>
		str = c_time;
 801a74e:	4b18      	ldr	r3, [pc, #96]	; (801a7b0 <__nl_langinfo_l+0xb4>)
 801a750:	613b      	str	r3, [r7, #16]
		break;
 801a752:	e011      	b.n	801a778 <__nl_langinfo_l+0x7c>
	case LC_MONETARY:
		if (idx > 0) return "";
 801a754:	68fb      	ldr	r3, [r7, #12]
 801a756:	2b00      	cmp	r3, #0
 801a758:	dd01      	ble.n	801a75e <__nl_langinfo_l+0x62>
 801a75a:	4b13      	ldr	r3, [pc, #76]	; (801a7a8 <__nl_langinfo_l+0xac>)
 801a75c:	e01e      	b.n	801a79c <__nl_langinfo_l+0xa0>
		str = "";
 801a75e:	4b12      	ldr	r3, [pc, #72]	; (801a7a8 <__nl_langinfo_l+0xac>)
 801a760:	613b      	str	r3, [r7, #16]
		break;
 801a762:	e009      	b.n	801a778 <__nl_langinfo_l+0x7c>
	case LC_MESSAGES:
		if (idx > 3) return "";
 801a764:	68fb      	ldr	r3, [r7, #12]
 801a766:	2b03      	cmp	r3, #3
 801a768:	dd01      	ble.n	801a76e <__nl_langinfo_l+0x72>
 801a76a:	4b0f      	ldr	r3, [pc, #60]	; (801a7a8 <__nl_langinfo_l+0xac>)
 801a76c:	e016      	b.n	801a79c <__nl_langinfo_l+0xa0>
		str = c_messages;
 801a76e:	4b11      	ldr	r3, [pc, #68]	; (801a7b4 <__nl_langinfo_l+0xb8>)
 801a770:	613b      	str	r3, [r7, #16]
		break;
 801a772:	e001      	b.n	801a778 <__nl_langinfo_l+0x7c>
	default:
		return "";
 801a774:	4b0c      	ldr	r3, [pc, #48]	; (801a7a8 <__nl_langinfo_l+0xac>)
 801a776:	e011      	b.n	801a79c <__nl_langinfo_l+0xa0>
	}

	for (; idx; idx--, str++) for (; *str; str++);
 801a778:	e00c      	b.n	801a794 <__nl_langinfo_l+0x98>
 801a77a:	693b      	ldr	r3, [r7, #16]
 801a77c:	3301      	adds	r3, #1
 801a77e:	613b      	str	r3, [r7, #16]
 801a780:	693b      	ldr	r3, [r7, #16]
 801a782:	781b      	ldrb	r3, [r3, #0]
 801a784:	2b00      	cmp	r3, #0
 801a786:	d1f8      	bne.n	801a77a <__nl_langinfo_l+0x7e>
 801a788:	68fb      	ldr	r3, [r7, #12]
 801a78a:	3b01      	subs	r3, #1
 801a78c:	60fb      	str	r3, [r7, #12]
 801a78e:	693b      	ldr	r3, [r7, #16]
 801a790:	3301      	adds	r3, #1
 801a792:	613b      	str	r3, [r7, #16]
 801a794:	68fb      	ldr	r3, [r7, #12]
 801a796:	2b00      	cmp	r3, #0
 801a798:	d1f2      	bne.n	801a780 <__nl_langinfo_l+0x84>
#ifndef __LITEOS__
	if (cat != LC_NUMERIC && *str) str = LCTRANS(str, cat, loc);
#endif
	return (char *)str;
 801a79a:	693b      	ldr	r3, [r7, #16]
}
 801a79c:	4618      	mov	r0, r3
 801a79e:	371c      	adds	r7, #28
 801a7a0:	46bd      	mov	sp, r7
 801a7a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a7a6:	4770      	bx	lr
 801a7a8:	0802317c 	.word	0x0802317c
 801a7ac:	0802398c 	.word	0x0802398c
 801a7b0:	0802383c 	.word	0x0802383c
 801a7b4:	08023978 	.word	0x08023978

0801a7b8 <__nl_langinfo>:

char *__nl_langinfo(nl_item item)
{
 801a7b8:	b580      	push	{r7, lr}
 801a7ba:	b082      	sub	sp, #8
 801a7bc:	af00      	add	r7, sp, #0
 801a7be:	6078      	str	r0, [r7, #4]
	return __nl_langinfo_l(item, CURRENT_LOCALE);
 801a7c0:	2101      	movs	r1, #1
 801a7c2:	6878      	ldr	r0, [r7, #4]
 801a7c4:	f7ff ff9a 	bl	801a6fc <__nl_langinfo_l>
 801a7c8:	4603      	mov	r3, r0
}
 801a7ca:	4618      	mov	r0, r3
 801a7cc:	3708      	adds	r7, #8
 801a7ce:	46bd      	mov	sp, r7
 801a7d0:	bd80      	pop	{r7, pc}
	...

0801a7d4 <free>:
 * realloc. The argument ptr points to the space that was previously allocated.
 * If ptr points to a memory block that was not allocated with calloc, malloc,
 * or realloc, or is a space that has been deallocated, then the result is undefined.
 */
void free(void *ptr)
{
 801a7d4:	b580      	push	{r7, lr}
 801a7d6:	b082      	sub	sp, #8
 801a7d8:	af00      	add	r7, sp, #0
 801a7da:	6078      	str	r0, [r7, #4]
    if (ptr == NULL) {
 801a7dc:	687b      	ldr	r3, [r7, #4]
 801a7de:	2b00      	cmp	r3, #0
 801a7e0:	d006      	beq.n	801a7f0 <free+0x1c>
        return;
    }

    (void)LOS_MemFree((void *)OS_SYS_MEM_ADDR, ptr);
 801a7e2:	4b05      	ldr	r3, [pc, #20]	; (801a7f8 <free+0x24>)
 801a7e4:	681b      	ldr	r3, [r3, #0]
 801a7e6:	6879      	ldr	r1, [r7, #4]
 801a7e8:	4618      	mov	r0, r3
 801a7ea:	f7ee f995 	bl	8008b18 <LOS_MemFree>
 801a7ee:	e000      	b.n	801a7f2 <free+0x1e>
        return;
 801a7f0:	bf00      	nop
}
 801a7f2:	3708      	adds	r7, #8
 801a7f4:	46bd      	mov	sp, r7
 801a7f6:	bd80      	pop	{r7, pc}
 801a7f8:	080001f0 	.word	0x080001f0

0801a7fc <malloc>:
/*
 * Allocates the requested memory and returns a pointer to it. The requested
 * size is size bytes. The value of the space is indeterminate.
 */
void *malloc(size_t size)
{
 801a7fc:	b580      	push	{r7, lr}
 801a7fe:	b082      	sub	sp, #8
 801a800:	af00      	add	r7, sp, #0
 801a802:	6078      	str	r0, [r7, #4]
    if (size == 0) {
 801a804:	687b      	ldr	r3, [r7, #4]
 801a806:	2b00      	cmp	r3, #0
 801a808:	d101      	bne.n	801a80e <malloc+0x12>
        return NULL;
 801a80a:	2300      	movs	r3, #0
 801a80c:	e006      	b.n	801a81c <malloc+0x20>
    }

    return (void *)LOS_MemAlloc((void *)OS_SYS_MEM_ADDR, (UINT32)size);
 801a80e:	4b05      	ldr	r3, [pc, #20]	; (801a824 <malloc+0x28>)
 801a810:	681b      	ldr	r3, [r3, #0]
 801a812:	6879      	ldr	r1, [r7, #4]
 801a814:	4618      	mov	r0, r3
 801a816:	f7ee f8c7 	bl	80089a8 <LOS_MemAlloc>
 801a81a:	4603      	mov	r3, r0
}
 801a81c:	4618      	mov	r0, r3
 801a81e:	3708      	adds	r7, #8
 801a820:	46bd      	mov	sp, r7
 801a822:	bd80      	pop	{r7, pc}
 801a824:	080001f0 	.word	0x080001f0

0801a828 <snprintf>:
#include <stdio.h>
#include <stdarg.h>

int snprintf(char *restrict s, size_t n, const char *restrict fmt, ...)
{
 801a828:	b40c      	push	{r2, r3}
 801a82a:	b580      	push	{r7, lr}
 801a82c:	b088      	sub	sp, #32
 801a82e:	af00      	add	r7, sp, #0
 801a830:	60f8      	str	r0, [r7, #12]
 801a832:	60b9      	str	r1, [r7, #8]
 801a834:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a836:	607b      	str	r3, [r7, #4]
 801a838:	4b0e      	ldr	r3, [pc, #56]	; (801a874 <snprintf+0x4c>)
 801a83a:	681b      	ldr	r3, [r3, #0]
 801a83c:	61fb      	str	r3, [r7, #28]
 801a83e:	f04f 0300 	mov.w	r3, #0
	int ret;
	va_list ap;
	va_start(ap, fmt);
 801a842:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801a846:	617b      	str	r3, [r7, #20]
	ret = vsnprintf(s, n, fmt, ap);
 801a848:	697b      	ldr	r3, [r7, #20]
 801a84a:	687a      	ldr	r2, [r7, #4]
 801a84c:	68b9      	ldr	r1, [r7, #8]
 801a84e:	68f8      	ldr	r0, [r7, #12]
 801a850:	f000 f87e 	bl	801a950 <vsnprintf>
 801a854:	61b8      	str	r0, [r7, #24]
	va_end(ap);
	return ret;
 801a856:	69bb      	ldr	r3, [r7, #24]
}
 801a858:	4a06      	ldr	r2, [pc, #24]	; (801a874 <snprintf+0x4c>)
 801a85a:	6811      	ldr	r1, [r2, #0]
 801a85c:	69fa      	ldr	r2, [r7, #28]
 801a85e:	4051      	eors	r1, r2
 801a860:	d001      	beq.n	801a866 <snprintf+0x3e>
 801a862:	f7e9 fdc1 	bl	80043e8 <__stack_chk_fail>
 801a866:	4618      	mov	r0, r3
 801a868:	3720      	adds	r7, #32
 801a86a:	46bd      	mov	sp, r7
 801a86c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 801a870:	b002      	add	sp, #8
 801a872:	4770      	bx	lr
 801a874:	08023180 	.word	0x08023180

0801a878 <vsprintf>:
#include <stdio.h>
#include <limits.h>

int vsprintf(char *restrict s, const char *restrict fmt, va_list ap)
{
 801a878:	b580      	push	{r7, lr}
 801a87a:	b084      	sub	sp, #16
 801a87c:	af00      	add	r7, sp, #0
 801a87e:	60f8      	str	r0, [r7, #12]
 801a880:	60b9      	str	r1, [r7, #8]
 801a882:	607a      	str	r2, [r7, #4]
	return vsnprintf(s, INT_MAX, fmt, ap);
 801a884:	687b      	ldr	r3, [r7, #4]
 801a886:	68ba      	ldr	r2, [r7, #8]
 801a888:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 801a88c:	68f8      	ldr	r0, [r7, #12]
 801a88e:	f000 f85f 	bl	801a950 <vsnprintf>
 801a892:	4603      	mov	r3, r0
}
 801a894:	4618      	mov	r0, r3
 801a896:	3710      	adds	r7, #16
 801a898:	46bd      	mov	sp, r7
 801a89a:	bd80      	pop	{r7, pc}

0801a89c <sn_write>:
};

#define MIN(a, b) ((a) < (b) ? (a) : (b))

static size_t sn_write(FILE *f, const unsigned char *s, size_t l)
{
 801a89c:	b580      	push	{r7, lr}
 801a89e:	b086      	sub	sp, #24
 801a8a0:	af00      	add	r7, sp, #0
 801a8a2:	60f8      	str	r0, [r7, #12]
 801a8a4:	60b9      	str	r1, [r7, #8]
 801a8a6:	607a      	str	r2, [r7, #4]
	struct cookie *c = f->cookie;
 801a8a8:	68fb      	ldr	r3, [r7, #12]
 801a8aa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801a8ac:	613b      	str	r3, [r7, #16]
	size_t k = MIN(c->n, (size_t)(f->wpos - f->wbase));
 801a8ae:	68fb      	ldr	r3, [r7, #12]
 801a8b0:	695a      	ldr	r2, [r3, #20]
 801a8b2:	68fb      	ldr	r3, [r7, #12]
 801a8b4:	69db      	ldr	r3, [r3, #28]
 801a8b6:	1ad3      	subs	r3, r2, r3
 801a8b8:	461a      	mov	r2, r3
 801a8ba:	693b      	ldr	r3, [r7, #16]
 801a8bc:	685b      	ldr	r3, [r3, #4]
 801a8be:	4293      	cmp	r3, r2
 801a8c0:	bf28      	it	cs
 801a8c2:	4613      	movcs	r3, r2
 801a8c4:	617b      	str	r3, [r7, #20]
	if (k) {
 801a8c6:	697b      	ldr	r3, [r7, #20]
 801a8c8:	2b00      	cmp	r3, #0
 801a8ca:	d013      	beq.n	801a8f4 <sn_write+0x58>
		memcpy(c->s, f->wbase, k);
 801a8cc:	693b      	ldr	r3, [r7, #16]
 801a8ce:	6818      	ldr	r0, [r3, #0]
 801a8d0:	68fb      	ldr	r3, [r7, #12]
 801a8d2:	69db      	ldr	r3, [r3, #28]
 801a8d4:	697a      	ldr	r2, [r7, #20]
 801a8d6:	4619      	mov	r1, r3
 801a8d8:	f7fe fafa 	bl	8018ed0 <memcpy>
		c->s += k;
 801a8dc:	693b      	ldr	r3, [r7, #16]
 801a8de:	681a      	ldr	r2, [r3, #0]
 801a8e0:	697b      	ldr	r3, [r7, #20]
 801a8e2:	441a      	add	r2, r3
 801a8e4:	693b      	ldr	r3, [r7, #16]
 801a8e6:	601a      	str	r2, [r3, #0]
		c->n -= k;
 801a8e8:	693b      	ldr	r3, [r7, #16]
 801a8ea:	685a      	ldr	r2, [r3, #4]
 801a8ec:	697b      	ldr	r3, [r7, #20]
 801a8ee:	1ad2      	subs	r2, r2, r3
 801a8f0:	693b      	ldr	r3, [r7, #16]
 801a8f2:	605a      	str	r2, [r3, #4]
	}
	k = MIN(c->n, l);
 801a8f4:	693b      	ldr	r3, [r7, #16]
 801a8f6:	685b      	ldr	r3, [r3, #4]
 801a8f8:	687a      	ldr	r2, [r7, #4]
 801a8fa:	4293      	cmp	r3, r2
 801a8fc:	bf28      	it	cs
 801a8fe:	4613      	movcs	r3, r2
 801a900:	617b      	str	r3, [r7, #20]
	if (k) {
 801a902:	697b      	ldr	r3, [r7, #20]
 801a904:	2b00      	cmp	r3, #0
 801a906:	d012      	beq.n	801a92e <sn_write+0x92>
		memcpy(c->s, s, k);
 801a908:	693b      	ldr	r3, [r7, #16]
 801a90a:	681b      	ldr	r3, [r3, #0]
 801a90c:	697a      	ldr	r2, [r7, #20]
 801a90e:	68b9      	ldr	r1, [r7, #8]
 801a910:	4618      	mov	r0, r3
 801a912:	f7fe fadd 	bl	8018ed0 <memcpy>
		c->s += k;
 801a916:	693b      	ldr	r3, [r7, #16]
 801a918:	681a      	ldr	r2, [r3, #0]
 801a91a:	697b      	ldr	r3, [r7, #20]
 801a91c:	441a      	add	r2, r3
 801a91e:	693b      	ldr	r3, [r7, #16]
 801a920:	601a      	str	r2, [r3, #0]
		c->n -= k;
 801a922:	693b      	ldr	r3, [r7, #16]
 801a924:	685a      	ldr	r2, [r3, #4]
 801a926:	697b      	ldr	r3, [r7, #20]
 801a928:	1ad2      	subs	r2, r2, r3
 801a92a:	693b      	ldr	r3, [r7, #16]
 801a92c:	605a      	str	r2, [r3, #4]
	}
	*c->s = 0;
 801a92e:	693b      	ldr	r3, [r7, #16]
 801a930:	681b      	ldr	r3, [r3, #0]
 801a932:	2200      	movs	r2, #0
 801a934:	701a      	strb	r2, [r3, #0]
	f->wpos = f->wbase = f->buf;
 801a936:	68fb      	ldr	r3, [r7, #12]
 801a938:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801a93a:	68fb      	ldr	r3, [r7, #12]
 801a93c:	61da      	str	r2, [r3, #28]
 801a93e:	68fb      	ldr	r3, [r7, #12]
 801a940:	69da      	ldr	r2, [r3, #28]
 801a942:	68fb      	ldr	r3, [r7, #12]
 801a944:	615a      	str	r2, [r3, #20]
	/* pretend to succeed, even if we discarded extra data */
	return l;
 801a946:	687b      	ldr	r3, [r7, #4]
}
 801a948:	4618      	mov	r0, r3
 801a94a:	3718      	adds	r7, #24
 801a94c:	46bd      	mov	sp, r7
 801a94e:	bd80      	pop	{r7, pc}

0801a950 <vsnprintf>:

int vsnprintf(char *restrict s, size_t n, const char *restrict fmt, va_list ap)
{
 801a950:	b580      	push	{r7, lr}
 801a952:	b0ae      	sub	sp, #184	; 0xb8
 801a954:	af00      	add	r7, sp, #0
 801a956:	60f8      	str	r0, [r7, #12]
 801a958:	60b9      	str	r1, [r7, #8]
 801a95a:	607a      	str	r2, [r7, #4]
 801a95c:	603b      	str	r3, [r7, #0]
 801a95e:	4b26      	ldr	r3, [pc, #152]	; (801a9f8 <vsnprintf+0xa8>)
 801a960:	681b      	ldr	r3, [r3, #0]
 801a962:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 801a966:	f04f 0300 	mov.w	r3, #0
	unsigned char buf[1];
	char dummy[1];
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
 801a96a:	68bb      	ldr	r3, [r7, #8]
 801a96c:	2b00      	cmp	r3, #0
 801a96e:	d102      	bne.n	801a976 <vsnprintf+0x26>
 801a970:	f107 03b0 	add.w	r3, r7, #176	; 0xb0
 801a974:	e000      	b.n	801a978 <vsnprintf+0x28>
 801a976:	68fb      	ldr	r3, [r7, #12]
 801a978:	613b      	str	r3, [r7, #16]
 801a97a:	68bb      	ldr	r3, [r7, #8]
 801a97c:	2b00      	cmp	r3, #0
 801a97e:	d002      	beq.n	801a986 <vsnprintf+0x36>
 801a980:	68bb      	ldr	r3, [r7, #8]
 801a982:	3b01      	subs	r3, #1
 801a984:	e000      	b.n	801a988 <vsnprintf+0x38>
 801a986:	2300      	movs	r3, #0
 801a988:	617b      	str	r3, [r7, #20]
	FILE f = {
 801a98a:	f107 0318 	add.w	r3, r7, #24
 801a98e:	2294      	movs	r2, #148	; 0x94
 801a990:	2100      	movs	r1, #0
 801a992:	4618      	mov	r0, r3
 801a994:	f7f3 ff56 	bl	800e844 <memset>
 801a998:	4b18      	ldr	r3, [pc, #96]	; (801a9fc <vsnprintf+0xac>)
 801a99a:	63fb      	str	r3, [r7, #60]	; 0x3c
 801a99c:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 801a9a0:	64bb      	str	r3, [r7, #72]	; 0x48
 801a9a2:	f04f 33ff 	mov.w	r3, #4294967295
 801a9a6:	66bb      	str	r3, [r7, #104]	; 0x68
 801a9a8:	f04f 33ff 	mov.w	r3, #4294967295
 801a9ac:	66fb      	str	r3, [r7, #108]	; 0x6c
 801a9ae:	f107 0310 	add.w	r3, r7, #16
 801a9b2:	673b      	str	r3, [r7, #112]	; 0x70
		.lock = -1,
		.buf = buf,
		.cookie = &c,
	};

	if (n > INT_MAX) {
 801a9b4:	68bb      	ldr	r3, [r7, #8]
 801a9b6:	2b00      	cmp	r3, #0
 801a9b8:	da07      	bge.n	801a9ca <vsnprintf+0x7a>
		errno = EOVERFLOW;
 801a9ba:	f7f4 fd8b 	bl	800f4d4 <__errno_location>
 801a9be:	4603      	mov	r3, r0
 801a9c0:	224b      	movs	r2, #75	; 0x4b
 801a9c2:	601a      	str	r2, [r3, #0]
		return -1;
 801a9c4:	f04f 33ff 	mov.w	r3, #4294967295
 801a9c8:	e00a      	b.n	801a9e0 <vsnprintf+0x90>
	}

	*c.s = 0;
 801a9ca:	693b      	ldr	r3, [r7, #16]
 801a9cc:	2200      	movs	r2, #0
 801a9ce:	701a      	strb	r2, [r3, #0]
	return vfprintf(&f, fmt, ap);
 801a9d0:	f107 0318 	add.w	r3, r7, #24
 801a9d4:	683a      	ldr	r2, [r7, #0]
 801a9d6:	6879      	ldr	r1, [r7, #4]
 801a9d8:	4618      	mov	r0, r3
 801a9da:	f002 faad 	bl	801cf38 <vfprintf>
 801a9de:	4603      	mov	r3, r0
}
 801a9e0:	4a05      	ldr	r2, [pc, #20]	; (801a9f8 <vsnprintf+0xa8>)
 801a9e2:	6811      	ldr	r1, [r2, #0]
 801a9e4:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 801a9e8:	4051      	eors	r1, r2
 801a9ea:	d001      	beq.n	801a9f0 <vsnprintf+0xa0>
 801a9ec:	f7e9 fcfc 	bl	80043e8 <__stack_chk_fail>
 801a9f0:	4618      	mov	r0, r3
 801a9f2:	37b8      	adds	r7, #184	; 0xb8
 801a9f4:	46bd      	mov	sp, r7
 801a9f6:	bd80      	pop	{r7, pc}
 801a9f8:	08023184 	.word	0x08023184
 801a9fc:	0801a89d 	.word	0x0801a89d

0801aa00 <__DOUBLE_BITS>:
	union {float __f; unsigned __i;} __u;
	__u.__f = __f;
	return __u.__i;
}
static __inline unsigned long long __DOUBLE_BITS(double __f)
{
 801aa00:	b480      	push	{r7}
 801aa02:	b085      	sub	sp, #20
 801aa04:	af00      	add	r7, sp, #0
 801aa06:	e9c7 0100 	strd	r0, r1, [r7]
	union {double __f; unsigned long long __i;} __u;
	__u.__f = __f;
 801aa0a:	e9d7 2300 	ldrd	r2, r3, [r7]
 801aa0e:	e9c7 2302 	strd	r2, r3, [r7, #8]
	return __u.__i;
 801aa12:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
}
 801aa16:	4610      	mov	r0, r2
 801aa18:	4619      	mov	r1, r3
 801aa1a:	3714      	adds	r7, #20
 801aa1c:	46bd      	mov	sp, r7
 801aa1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801aa22:	4770      	bx	lr

0801aa24 <pop_arg>:
	ldouble_t f;
	void *p;
};

static void pop_arg(union arg *arg, int type, va_list *ap)
{
 801aa24:	b480      	push	{r7}
 801aa26:	b085      	sub	sp, #20
 801aa28:	af00      	add	r7, sp, #0
 801aa2a:	60f8      	str	r0, [r7, #12]
 801aa2c:	60b9      	str	r1, [r7, #8]
 801aa2e:	607a      	str	r2, [r7, #4]
 801aa30:	68bb      	ldr	r3, [r7, #8]
 801aa32:	3b09      	subs	r3, #9
 801aa34:	2b11      	cmp	r3, #17
 801aa36:	f200 811d 	bhi.w	801ac74 <pop_arg+0x250>
 801aa3a:	a201      	add	r2, pc, #4	; (adr r2, 801aa40 <pop_arg+0x1c>)
 801aa3c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801aa40:	0801aa89 	.word	0x0801aa89
 801aa44:	0801aa9b 	.word	0x0801aa9b
 801aa48:	0801aab5 	.word	0x0801aab5
 801aa4c:	0801ab03 	.word	0x0801ab03
 801aa50:	0801aacf 	.word	0x0801aacf
 801aa54:	0801aae9 	.word	0x0801aae9
 801aa58:	0801ab21 	.word	0x0801ab21
 801aa5c:	0801ab3d 	.word	0x0801ab3d
 801aa60:	0801ab59 	.word	0x0801ab59
 801aa64:	0801ab75 	.word	0x0801ab75
 801aa68:	0801ab91 	.word	0x0801ab91
 801aa6c:	0801abaf 	.word	0x0801abaf
 801aa70:	0801abc9 	.word	0x0801abc9
 801aa74:	0801abe7 	.word	0x0801abe7
 801aa78:	0801ac05 	.word	0x0801ac05
 801aa7c:	0801ac1f 	.word	0x0801ac1f
 801aa80:	0801ac39 	.word	0x0801ac39
 801aa84:	0801ac57 	.word	0x0801ac57
	switch (type) {
	       case PTR:	arg->p = va_arg(*ap, void *);
 801aa88:	687b      	ldr	r3, [r7, #4]
 801aa8a:	681b      	ldr	r3, [r3, #0]
 801aa8c:	1d19      	adds	r1, r3, #4
 801aa8e:	687a      	ldr	r2, [r7, #4]
 801aa90:	6011      	str	r1, [r2, #0]
 801aa92:	681a      	ldr	r2, [r3, #0]
 801aa94:	68fb      	ldr	r3, [r7, #12]
 801aa96:	601a      	str	r2, [r3, #0]
	break; case INT:	arg->i = va_arg(*ap, int);
 801aa98:	e0ec      	b.n	801ac74 <pop_arg+0x250>
 801aa9a:	687b      	ldr	r3, [r7, #4]
 801aa9c:	681b      	ldr	r3, [r3, #0]
 801aa9e:	1d19      	adds	r1, r3, #4
 801aaa0:	687a      	ldr	r2, [r7, #4]
 801aaa2:	6011      	str	r1, [r2, #0]
 801aaa4:	681b      	ldr	r3, [r3, #0]
 801aaa6:	461a      	mov	r2, r3
 801aaa8:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801aaac:	68f9      	ldr	r1, [r7, #12]
 801aaae:	e9c1 2300 	strd	r2, r3, [r1]
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
 801aab2:	e0df      	b.n	801ac74 <pop_arg+0x250>
 801aab4:	687b      	ldr	r3, [r7, #4]
 801aab6:	681b      	ldr	r3, [r3, #0]
 801aab8:	1d19      	adds	r1, r3, #4
 801aaba:	687a      	ldr	r2, [r7, #4]
 801aabc:	6011      	str	r1, [r2, #0]
 801aabe:	681b      	ldr	r3, [r3, #0]
 801aac0:	461a      	mov	r2, r3
 801aac2:	f04f 0300 	mov.w	r3, #0
 801aac6:	68f9      	ldr	r1, [r7, #12]
 801aac8:	e9c1 2300 	strd	r2, r3, [r1]
	break; case LONG:	arg->i = va_arg(*ap, long);
 801aacc:	e0d2      	b.n	801ac74 <pop_arg+0x250>
 801aace:	687b      	ldr	r3, [r7, #4]
 801aad0:	681b      	ldr	r3, [r3, #0]
 801aad2:	1d19      	adds	r1, r3, #4
 801aad4:	687a      	ldr	r2, [r7, #4]
 801aad6:	6011      	str	r1, [r2, #0]
 801aad8:	681b      	ldr	r3, [r3, #0]
 801aada:	461a      	mov	r2, r3
 801aadc:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801aae0:	68f9      	ldr	r1, [r7, #12]
 801aae2:	e9c1 2300 	strd	r2, r3, [r1]
	break; case ULONG:	arg->i = va_arg(*ap, unsigned long);
 801aae6:	e0c5      	b.n	801ac74 <pop_arg+0x250>
 801aae8:	687b      	ldr	r3, [r7, #4]
 801aaea:	681b      	ldr	r3, [r3, #0]
 801aaec:	1d19      	adds	r1, r3, #4
 801aaee:	687a      	ldr	r2, [r7, #4]
 801aaf0:	6011      	str	r1, [r2, #0]
 801aaf2:	681b      	ldr	r3, [r3, #0]
 801aaf4:	461a      	mov	r2, r3
 801aaf6:	f04f 0300 	mov.w	r3, #0
 801aafa:	68f9      	ldr	r1, [r7, #12]
 801aafc:	e9c1 2300 	strd	r2, r3, [r1]
	break; case ULLONG:	arg->i = va_arg(*ap, unsigned long long);
 801ab00:	e0b8      	b.n	801ac74 <pop_arg+0x250>
 801ab02:	687b      	ldr	r3, [r7, #4]
 801ab04:	681b      	ldr	r3, [r3, #0]
 801ab06:	3307      	adds	r3, #7
 801ab08:	f023 0307 	bic.w	r3, r3, #7
 801ab0c:	f103 0108 	add.w	r1, r3, #8
 801ab10:	687a      	ldr	r2, [r7, #4]
 801ab12:	6011      	str	r1, [r2, #0]
 801ab14:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ab18:	68f9      	ldr	r1, [r7, #12]
 801ab1a:	e9c1 2300 	strd	r2, r3, [r1]
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
 801ab1e:	e0a9      	b.n	801ac74 <pop_arg+0x250>
 801ab20:	687b      	ldr	r3, [r7, #4]
 801ab22:	681b      	ldr	r3, [r3, #0]
 801ab24:	1d19      	adds	r1, r3, #4
 801ab26:	687a      	ldr	r2, [r7, #4]
 801ab28:	6011      	str	r1, [r2, #0]
 801ab2a:	681b      	ldr	r3, [r3, #0]
 801ab2c:	b21b      	sxth	r3, r3
 801ab2e:	b21a      	sxth	r2, r3
 801ab30:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801ab34:	68f9      	ldr	r1, [r7, #12]
 801ab36:	e9c1 2300 	strd	r2, r3, [r1]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
 801ab3a:	e09b      	b.n	801ac74 <pop_arg+0x250>
 801ab3c:	687b      	ldr	r3, [r7, #4]
 801ab3e:	681b      	ldr	r3, [r3, #0]
 801ab40:	1d19      	adds	r1, r3, #4
 801ab42:	687a      	ldr	r2, [r7, #4]
 801ab44:	6011      	str	r1, [r2, #0]
 801ab46:	681b      	ldr	r3, [r3, #0]
 801ab48:	b29b      	uxth	r3, r3
 801ab4a:	b29a      	uxth	r2, r3
 801ab4c:	f04f 0300 	mov.w	r3, #0
 801ab50:	68f9      	ldr	r1, [r7, #12]
 801ab52:	e9c1 2300 	strd	r2, r3, [r1]
	break; case CHAR1:	arg->i = (signed char)va_arg(*ap, int);
 801ab56:	e08d      	b.n	801ac74 <pop_arg+0x250>
 801ab58:	687b      	ldr	r3, [r7, #4]
 801ab5a:	681b      	ldr	r3, [r3, #0]
 801ab5c:	1d19      	adds	r1, r3, #4
 801ab5e:	687a      	ldr	r2, [r7, #4]
 801ab60:	6011      	str	r1, [r2, #0]
 801ab62:	681b      	ldr	r3, [r3, #0]
 801ab64:	b25b      	sxtb	r3, r3
 801ab66:	b25a      	sxtb	r2, r3
 801ab68:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801ab6c:	68f9      	ldr	r1, [r7, #12]
 801ab6e:	e9c1 2300 	strd	r2, r3, [r1]
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
 801ab72:	e07f      	b.n	801ac74 <pop_arg+0x250>
 801ab74:	687b      	ldr	r3, [r7, #4]
 801ab76:	681b      	ldr	r3, [r3, #0]
 801ab78:	1d19      	adds	r1, r3, #4
 801ab7a:	687a      	ldr	r2, [r7, #4]
 801ab7c:	6011      	str	r1, [r2, #0]
 801ab7e:	681b      	ldr	r3, [r3, #0]
 801ab80:	b2db      	uxtb	r3, r3
 801ab82:	b2da      	uxtb	r2, r3
 801ab84:	f04f 0300 	mov.w	r3, #0
 801ab88:	68f9      	ldr	r1, [r7, #12]
 801ab8a:	e9c1 2300 	strd	r2, r3, [r1]
	break; case LLONG:	arg->i = va_arg(*ap, long long);
 801ab8e:	e071      	b.n	801ac74 <pop_arg+0x250>
 801ab90:	687b      	ldr	r3, [r7, #4]
 801ab92:	681b      	ldr	r3, [r3, #0]
 801ab94:	3307      	adds	r3, #7
 801ab96:	f023 0307 	bic.w	r3, r3, #7
 801ab9a:	f103 0108 	add.w	r1, r3, #8
 801ab9e:	687a      	ldr	r2, [r7, #4]
 801aba0:	6011      	str	r1, [r2, #0]
 801aba2:	e9d3 2300 	ldrd	r2, r3, [r3]
 801aba6:	68f9      	ldr	r1, [r7, #12]
 801aba8:	e9c1 2300 	strd	r2, r3, [r1]
	break; case SIZET:	arg->i = va_arg(*ap, size_t);
 801abac:	e062      	b.n	801ac74 <pop_arg+0x250>
 801abae:	687b      	ldr	r3, [r7, #4]
 801abb0:	681b      	ldr	r3, [r3, #0]
 801abb2:	1d19      	adds	r1, r3, #4
 801abb4:	687a      	ldr	r2, [r7, #4]
 801abb6:	6011      	str	r1, [r2, #0]
 801abb8:	681b      	ldr	r3, [r3, #0]
 801abba:	461a      	mov	r2, r3
 801abbc:	f04f 0300 	mov.w	r3, #0
 801abc0:	68f9      	ldr	r1, [r7, #12]
 801abc2:	e9c1 2300 	strd	r2, r3, [r1]
	break; case IMAX:	arg->i = va_arg(*ap, intmax_t);
 801abc6:	e055      	b.n	801ac74 <pop_arg+0x250>
 801abc8:	687b      	ldr	r3, [r7, #4]
 801abca:	681b      	ldr	r3, [r3, #0]
 801abcc:	3307      	adds	r3, #7
 801abce:	f023 0307 	bic.w	r3, r3, #7
 801abd2:	f103 0108 	add.w	r1, r3, #8
 801abd6:	687a      	ldr	r2, [r7, #4]
 801abd8:	6011      	str	r1, [r2, #0]
 801abda:	e9d3 2300 	ldrd	r2, r3, [r3]
 801abde:	68f9      	ldr	r1, [r7, #12]
 801abe0:	e9c1 2300 	strd	r2, r3, [r1]
	break; case UMAX:	arg->i = va_arg(*ap, uintmax_t);
 801abe4:	e046      	b.n	801ac74 <pop_arg+0x250>
 801abe6:	687b      	ldr	r3, [r7, #4]
 801abe8:	681b      	ldr	r3, [r3, #0]
 801abea:	3307      	adds	r3, #7
 801abec:	f023 0307 	bic.w	r3, r3, #7
 801abf0:	f103 0108 	add.w	r1, r3, #8
 801abf4:	687a      	ldr	r2, [r7, #4]
 801abf6:	6011      	str	r1, [r2, #0]
 801abf8:	e9d3 2300 	ldrd	r2, r3, [r3]
 801abfc:	68f9      	ldr	r1, [r7, #12]
 801abfe:	e9c1 2300 	strd	r2, r3, [r1]
	break; case PDIFF:	arg->i = va_arg(*ap, ptrdiff_t);
 801ac02:	e037      	b.n	801ac74 <pop_arg+0x250>
 801ac04:	687b      	ldr	r3, [r7, #4]
 801ac06:	681b      	ldr	r3, [r3, #0]
 801ac08:	1d19      	adds	r1, r3, #4
 801ac0a:	687a      	ldr	r2, [r7, #4]
 801ac0c:	6011      	str	r1, [r2, #0]
 801ac0e:	681b      	ldr	r3, [r3, #0]
 801ac10:	461a      	mov	r2, r3
 801ac12:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801ac16:	68f9      	ldr	r1, [r7, #12]
 801ac18:	e9c1 2300 	strd	r2, r3, [r1]
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
 801ac1c:	e02a      	b.n	801ac74 <pop_arg+0x250>
 801ac1e:	687b      	ldr	r3, [r7, #4]
 801ac20:	681b      	ldr	r3, [r3, #0]
 801ac22:	1d19      	adds	r1, r3, #4
 801ac24:	687a      	ldr	r2, [r7, #4]
 801ac26:	6011      	str	r1, [r2, #0]
 801ac28:	681b      	ldr	r3, [r3, #0]
 801ac2a:	461a      	mov	r2, r3
 801ac2c:	f04f 0300 	mov.w	r3, #0
 801ac30:	68f9      	ldr	r1, [r7, #12]
 801ac32:	e9c1 2300 	strd	r2, r3, [r1]
	break; case DBL:	arg->f = va_arg(*ap, double);
 801ac36:	e01d      	b.n	801ac74 <pop_arg+0x250>
 801ac38:	687b      	ldr	r3, [r7, #4]
 801ac3a:	681b      	ldr	r3, [r3, #0]
 801ac3c:	3307      	adds	r3, #7
 801ac3e:	f023 0307 	bic.w	r3, r3, #7
 801ac42:	f103 0108 	add.w	r1, r3, #8
 801ac46:	687a      	ldr	r2, [r7, #4]
 801ac48:	6011      	str	r1, [r2, #0]
 801ac4a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ac4e:	68f9      	ldr	r1, [r7, #12]
 801ac50:	e9c1 2300 	strd	r2, r3, [r1]
	break; case LDBL:	arg->f = va_arg(*ap, ldouble_t);
 801ac54:	e00e      	b.n	801ac74 <pop_arg+0x250>
 801ac56:	687b      	ldr	r3, [r7, #4]
 801ac58:	681b      	ldr	r3, [r3, #0]
 801ac5a:	3307      	adds	r3, #7
 801ac5c:	f023 0307 	bic.w	r3, r3, #7
 801ac60:	f103 0108 	add.w	r1, r3, #8
 801ac64:	687a      	ldr	r2, [r7, #4]
 801ac66:	6011      	str	r1, [r2, #0]
 801ac68:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ac6c:	68f9      	ldr	r1, [r7, #12]
 801ac6e:	e9c1 2300 	strd	r2, r3, [r1]
	}
}
 801ac72:	e7ff      	b.n	801ac74 <pop_arg+0x250>
 801ac74:	bf00      	nop
 801ac76:	3714      	adds	r7, #20
 801ac78:	46bd      	mov	sp, r7
 801ac7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ac7e:	4770      	bx	lr

0801ac80 <out>:

static void out(FILE *f, const char *s, size_t l)
{
 801ac80:	b580      	push	{r7, lr}
 801ac82:	b084      	sub	sp, #16
 801ac84:	af00      	add	r7, sp, #0
 801ac86:	60f8      	str	r0, [r7, #12]
 801ac88:	60b9      	str	r1, [r7, #8]
 801ac8a:	607a      	str	r2, [r7, #4]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
 801ac8c:	68fb      	ldr	r3, [r7, #12]
 801ac8e:	681b      	ldr	r3, [r3, #0]
 801ac90:	f003 0320 	and.w	r3, r3, #32
 801ac94:	2b00      	cmp	r3, #0
 801ac96:	d104      	bne.n	801aca2 <out+0x22>
 801ac98:	68fa      	ldr	r2, [r7, #12]
 801ac9a:	6879      	ldr	r1, [r7, #4]
 801ac9c:	68b8      	ldr	r0, [r7, #8]
 801ac9e:	f002 fa69 	bl	801d174 <__fwritex>
}
 801aca2:	bf00      	nop
 801aca4:	3710      	adds	r7, #16
 801aca6:	46bd      	mov	sp, r7
 801aca8:	bd80      	pop	{r7, pc}
	...

0801acac <pad>:

static void pad(FILE *f, char c, int w, int l, int fl)
{
 801acac:	b590      	push	{r4, r7, lr}
 801acae:	b0c7      	sub	sp, #284	; 0x11c
 801acb0:	af00      	add	r7, sp, #0
 801acb2:	f107 040c 	add.w	r4, r7, #12
 801acb6:	6020      	str	r0, [r4, #0]
 801acb8:	4608      	mov	r0, r1
 801acba:	1d39      	adds	r1, r7, #4
 801acbc:	600a      	str	r2, [r1, #0]
 801acbe:	463a      	mov	r2, r7
 801acc0:	6013      	str	r3, [r2, #0]
 801acc2:	f107 030b 	add.w	r3, r7, #11
 801acc6:	4602      	mov	r2, r0
 801acc8:	701a      	strb	r2, [r3, #0]
 801acca:	4b2a      	ldr	r3, [pc, #168]	; (801ad74 <pad+0xc8>)
 801accc:	681b      	ldr	r3, [r3, #0]
 801acce:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 801acd2:	f04f 0300 	mov.w	r3, #0
	char pad[256];
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
 801acd6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801acda:	f403 3390 	and.w	r3, r3, #73728	; 0x12000
 801acde:	2b00      	cmp	r3, #0
 801ace0:	d13a      	bne.n	801ad58 <pad+0xac>
 801ace2:	463a      	mov	r2, r7
 801ace4:	1d3b      	adds	r3, r7, #4
 801ace6:	6812      	ldr	r2, [r2, #0]
 801ace8:	681b      	ldr	r3, [r3, #0]
 801acea:	429a      	cmp	r2, r3
 801acec:	da34      	bge.n	801ad58 <pad+0xac>
	l = w - l;
 801acee:	463b      	mov	r3, r7
 801acf0:	1d39      	adds	r1, r7, #4
 801acf2:	463a      	mov	r2, r7
 801acf4:	6809      	ldr	r1, [r1, #0]
 801acf6:	6812      	ldr	r2, [r2, #0]
 801acf8:	1a8a      	subs	r2, r1, r2
 801acfa:	601a      	str	r2, [r3, #0]
	memset(pad, c, (unsigned)l>sizeof pad ? sizeof pad : (unsigned)l);
 801acfc:	f107 030b 	add.w	r3, r7, #11
 801ad00:	7819      	ldrb	r1, [r3, #0]
 801ad02:	463b      	mov	r3, r7
 801ad04:	681b      	ldr	r3, [r3, #0]
 801ad06:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801ad0a:	bf28      	it	cs
 801ad0c:	f44f 7380 	movcs.w	r3, #256	; 0x100
 801ad10:	461a      	mov	r2, r3
 801ad12:	f107 0314 	add.w	r3, r7, #20
 801ad16:	4618      	mov	r0, r3
 801ad18:	f7f3 fd94 	bl	800e844 <memset>
	for (; l >= (int)(sizeof pad); l -= (int)(sizeof pad))
 801ad1c:	e00e      	b.n	801ad3c <pad+0x90>
		out(f, pad, sizeof pad);
 801ad1e:	f107 0114 	add.w	r1, r7, #20
 801ad22:	f107 030c 	add.w	r3, r7, #12
 801ad26:	f44f 7280 	mov.w	r2, #256	; 0x100
 801ad2a:	6818      	ldr	r0, [r3, #0]
 801ad2c:	f7ff ffa8 	bl	801ac80 <out>
	for (; l >= (int)(sizeof pad); l -= (int)(sizeof pad))
 801ad30:	463b      	mov	r3, r7
 801ad32:	463a      	mov	r2, r7
 801ad34:	6812      	ldr	r2, [r2, #0]
 801ad36:	f5a2 7280 	sub.w	r2, r2, #256	; 0x100
 801ad3a:	601a      	str	r2, [r3, #0]
 801ad3c:	463b      	mov	r3, r7
 801ad3e:	681b      	ldr	r3, [r3, #0]
 801ad40:	2bff      	cmp	r3, #255	; 0xff
 801ad42:	dcec      	bgt.n	801ad1e <pad+0x72>
	out(f, pad, l);
 801ad44:	463b      	mov	r3, r7
 801ad46:	681a      	ldr	r2, [r3, #0]
 801ad48:	f107 0114 	add.w	r1, r7, #20
 801ad4c:	f107 030c 	add.w	r3, r7, #12
 801ad50:	6818      	ldr	r0, [r3, #0]
 801ad52:	f7ff ff95 	bl	801ac80 <out>
 801ad56:	e000      	b.n	801ad5a <pad+0xae>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
 801ad58:	bf00      	nop
}
 801ad5a:	4b06      	ldr	r3, [pc, #24]	; (801ad74 <pad+0xc8>)
 801ad5c:	681a      	ldr	r2, [r3, #0]
 801ad5e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 801ad62:	405a      	eors	r2, r3
 801ad64:	d001      	beq.n	801ad6a <pad+0xbe>
 801ad66:	f7e9 fb3f 	bl	80043e8 <__stack_chk_fail>
 801ad6a:	f507 778e 	add.w	r7, r7, #284	; 0x11c
 801ad6e:	46bd      	mov	sp, r7
 801ad70:	bd90      	pop	{r4, r7, pc}
 801ad72:	bf00      	nop
 801ad74:	08023188 	.word	0x08023188

0801ad78 <fmt_x>:
static const char xdigits[16] = {
	"0123456789ABCDEF"
};

static char *fmt_x(uintmax_t x, char *s, int lower)
{
 801ad78:	b4b0      	push	{r4, r5, r7}
 801ad7a:	b085      	sub	sp, #20
 801ad7c:	af00      	add	r7, sp, #0
 801ad7e:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801ad82:	607a      	str	r2, [r7, #4]
 801ad84:	603b      	str	r3, [r7, #0]
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
 801ad86:	e023      	b.n	801add0 <fmt_x+0x58>
 801ad88:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801ad8c:	f04f 000f 	mov.w	r0, #15
 801ad90:	f04f 0100 	mov.w	r1, #0
 801ad94:	ea02 0400 	and.w	r4, r2, r0
 801ad98:	ea03 0501 	and.w	r5, r3, r1
 801ad9c:	4b11      	ldr	r3, [pc, #68]	; (801ade4 <fmt_x+0x6c>)
 801ad9e:	4423      	add	r3, r4
 801ada0:	781b      	ldrb	r3, [r3, #0]
 801ada2:	b25a      	sxtb	r2, r3
 801ada4:	683b      	ldr	r3, [r7, #0]
 801ada6:	b25b      	sxtb	r3, r3
 801ada8:	4313      	orrs	r3, r2
 801adaa:	b25a      	sxtb	r2, r3
 801adac:	687b      	ldr	r3, [r7, #4]
 801adae:	3b01      	subs	r3, #1
 801adb0:	607b      	str	r3, [r7, #4]
 801adb2:	b2d2      	uxtb	r2, r2
 801adb4:	687b      	ldr	r3, [r7, #4]
 801adb6:	701a      	strb	r2, [r3, #0]
 801adb8:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801adbc:	f04f 0200 	mov.w	r2, #0
 801adc0:	f04f 0300 	mov.w	r3, #0
 801adc4:	0902      	lsrs	r2, r0, #4
 801adc6:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 801adca:	090b      	lsrs	r3, r1, #4
 801adcc:	e9c7 2302 	strd	r2, r3, [r7, #8]
 801add0:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801add4:	4313      	orrs	r3, r2
 801add6:	d1d7      	bne.n	801ad88 <fmt_x+0x10>
	return s;
 801add8:	687b      	ldr	r3, [r7, #4]
}
 801adda:	4618      	mov	r0, r3
 801addc:	3714      	adds	r7, #20
 801adde:	46bd      	mov	sp, r7
 801ade0:	bcb0      	pop	{r4, r5, r7}
 801ade2:	4770      	bx	lr
 801ade4:	08023b60 	.word	0x08023b60

0801ade8 <fmt_o>:

static char *fmt_o(uintmax_t x, char *s)
{
 801ade8:	b480      	push	{r7}
 801adea:	b085      	sub	sp, #20
 801adec:	af00      	add	r7, sp, #0
 801adee:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801adf2:	607a      	str	r2, [r7, #4]
	for (; x; x>>=3) *--s = '0' + (x&7);
 801adf4:	e016      	b.n	801ae24 <fmt_o+0x3c>
 801adf6:	7a3b      	ldrb	r3, [r7, #8]
 801adf8:	f003 0307 	and.w	r3, r3, #7
 801adfc:	b2db      	uxtb	r3, r3
 801adfe:	687a      	ldr	r2, [r7, #4]
 801ae00:	3a01      	subs	r2, #1
 801ae02:	607a      	str	r2, [r7, #4]
 801ae04:	3330      	adds	r3, #48	; 0x30
 801ae06:	b2da      	uxtb	r2, r3
 801ae08:	687b      	ldr	r3, [r7, #4]
 801ae0a:	701a      	strb	r2, [r3, #0]
 801ae0c:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801ae10:	f04f 0200 	mov.w	r2, #0
 801ae14:	f04f 0300 	mov.w	r3, #0
 801ae18:	08c2      	lsrs	r2, r0, #3
 801ae1a:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
 801ae1e:	08cb      	lsrs	r3, r1, #3
 801ae20:	e9c7 2302 	strd	r2, r3, [r7, #8]
 801ae24:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801ae28:	4313      	orrs	r3, r2
 801ae2a:	d1e4      	bne.n	801adf6 <fmt_o+0xe>
	return s;
 801ae2c:	687b      	ldr	r3, [r7, #4]
}
 801ae2e:	4618      	mov	r0, r3
 801ae30:	3714      	adds	r7, #20
 801ae32:	46bd      	mov	sp, r7
 801ae34:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ae38:	4770      	bx	lr
	...

0801ae3c <fmt_u>:

static char *fmt_u(uintmax_t x, char *s)
{
 801ae3c:	b580      	push	{r7, lr}
 801ae3e:	b086      	sub	sp, #24
 801ae40:	af00      	add	r7, sp, #0
 801ae42:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801ae46:	607a      	str	r2, [r7, #4]
	unsigned long y;
	for (   ; x>ULONG_MAX; x/=10) *--s = '0' + x%10;
 801ae48:	e01b      	b.n	801ae82 <fmt_u+0x46>
 801ae4a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801ae4e:	f04f 020a 	mov.w	r2, #10
 801ae52:	f04f 0300 	mov.w	r3, #0
 801ae56:	f7e5 fd9d 	bl	8000994 <__aeabi_uldivmod>
 801ae5a:	b2d3      	uxtb	r3, r2
 801ae5c:	687a      	ldr	r2, [r7, #4]
 801ae5e:	3a01      	subs	r2, #1
 801ae60:	607a      	str	r2, [r7, #4]
 801ae62:	3330      	adds	r3, #48	; 0x30
 801ae64:	b2da      	uxtb	r2, r3
 801ae66:	687b      	ldr	r3, [r7, #4]
 801ae68:	701a      	strb	r2, [r3, #0]
 801ae6a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801ae6e:	f04f 020a 	mov.w	r2, #10
 801ae72:	f04f 0300 	mov.w	r3, #0
 801ae76:	f7e5 fd8d 	bl	8000994 <__aeabi_uldivmod>
 801ae7a:	4602      	mov	r2, r0
 801ae7c:	460b      	mov	r3, r1
 801ae7e:	e9c7 2302 	strd	r2, r3, [r7, #8]
 801ae82:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801ae86:	2b01      	cmp	r3, #1
 801ae88:	bf08      	it	eq
 801ae8a:	2a00      	cmpeq	r2, #0
 801ae8c:	d2dd      	bcs.n	801ae4a <fmt_u+0xe>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
 801ae8e:	68bb      	ldr	r3, [r7, #8]
 801ae90:	617b      	str	r3, [r7, #20]
 801ae92:	e017      	b.n	801aec4 <fmt_u+0x88>
 801ae94:	6979      	ldr	r1, [r7, #20]
 801ae96:	4b0f      	ldr	r3, [pc, #60]	; (801aed4 <fmt_u+0x98>)
 801ae98:	fba3 2301 	umull	r2, r3, r3, r1
 801ae9c:	08da      	lsrs	r2, r3, #3
 801ae9e:	4613      	mov	r3, r2
 801aea0:	009b      	lsls	r3, r3, #2
 801aea2:	4413      	add	r3, r2
 801aea4:	005b      	lsls	r3, r3, #1
 801aea6:	1aca      	subs	r2, r1, r3
 801aea8:	b2d3      	uxtb	r3, r2
 801aeaa:	687a      	ldr	r2, [r7, #4]
 801aeac:	3a01      	subs	r2, #1
 801aeae:	607a      	str	r2, [r7, #4]
 801aeb0:	3330      	adds	r3, #48	; 0x30
 801aeb2:	b2da      	uxtb	r2, r3
 801aeb4:	687b      	ldr	r3, [r7, #4]
 801aeb6:	701a      	strb	r2, [r3, #0]
 801aeb8:	697b      	ldr	r3, [r7, #20]
 801aeba:	4a06      	ldr	r2, [pc, #24]	; (801aed4 <fmt_u+0x98>)
 801aebc:	fba2 2303 	umull	r2, r3, r2, r3
 801aec0:	08db      	lsrs	r3, r3, #3
 801aec2:	617b      	str	r3, [r7, #20]
 801aec4:	697b      	ldr	r3, [r7, #20]
 801aec6:	2b00      	cmp	r3, #0
 801aec8:	d1e4      	bne.n	801ae94 <fmt_u+0x58>
	return s;
 801aeca:	687b      	ldr	r3, [r7, #4]
}
 801aecc:	4618      	mov	r0, r3
 801aece:	3718      	adds	r7, #24
 801aed0:	46bd      	mov	sp, r7
 801aed2:	bd80      	pop	{r7, pc}
 801aed4:	cccccccd 	.word	0xcccccccd

0801aed8 <fmt_fp>:
typedef char compiler_defines_long_double_incorrectly[9-(int)sizeof(ldouble_t)];
#endif
#endif

static int fmt_fp(FILE *f, ldouble_t y, int w, int p, int fl, int t)
{
 801aed8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801aedc:	f5ad 7d33 	sub.w	sp, sp, #716	; 0x2cc
 801aee0:	af02      	add	r7, sp, #8
 801aee2:	f107 010c 	add.w	r1, r7, #12
 801aee6:	6008      	str	r0, [r1, #0]
 801aee8:	4639      	mov	r1, r7
 801aeea:	e9c1 2300 	strd	r2, r3, [r1]
 801aeee:	4ba5      	ldr	r3, [pc, #660]	; (801b184 <fmt_fp+0x2ac>)
 801aef0:	681b      	ldr	r3, [r3, #0]
 801aef2:	f8c7 32bc 	str.w	r3, [r7, #700]	; 0x2bc
 801aef6:	f04f 0300 	mov.w	r3, #0
	uint32_t big[(LDBL_MANT_DIG+28)/29 + 1          // mantissa expansion
		+ (LDBL_MAX_EXP+LDBL_MANT_DIG+28+8)/9]; // exponent expansion
	uint32_t *a, *d, *r, *z;
	int e2=0, e, i, j, l;
 801aefa:	f107 0310 	add.w	r3, r7, #16
 801aefe:	2200      	movs	r2, #0
 801af00:	601a      	str	r2, [r3, #0]
	char buf[9+LDBL_MANT_DIG/4], *s;
	const char *prefix="-0X+0X 0X-0x+0x 0x";
 801af02:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801af06:	4aa0      	ldr	r2, [pc, #640]	; (801b188 <fmt_fp+0x2b0>)
 801af08:	601a      	str	r2, [r3, #0]
	int pl;
	char ebuf0[3*sizeof(int)], *ebuf=&ebuf0[3*sizeof(int)], *estr=NULL;
 801af0a:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801af0e:	f507 7226 	add.w	r2, r7, #664	; 0x298
 801af12:	320c      	adds	r2, #12
 801af14:	601a      	str	r2, [r3, #0]
 801af16:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801af1a:	2200      	movs	r2, #0
 801af1c:	601a      	str	r2, [r3, #0]

	pl=1;
 801af1e:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801af22:	2201      	movs	r2, #1
 801af24:	601a      	str	r2, [r3, #0]
	if (signbit(y)) {
 801af26:	463b      	mov	r3, r7
 801af28:	e9d3 0100 	ldrd	r0, r1, [r3]
 801af2c:	f7ff fd68 	bl	801aa00 <__DOUBLE_BITS>
 801af30:	f04f 0200 	mov.w	r2, #0
 801af34:	f04f 0300 	mov.w	r3, #0
 801af38:	0fca      	lsrs	r2, r1, #31
 801af3a:	2300      	movs	r3, #0
 801af3c:	4613      	mov	r3, r2
 801af3e:	2b00      	cmp	r3, #0
 801af40:	d008      	beq.n	801af54 <fmt_fp+0x7c>
		y=-y;
 801af42:	463b      	mov	r3, r7
 801af44:	463a      	mov	r2, r7
 801af46:	6811      	ldr	r1, [r2, #0]
 801af48:	6019      	str	r1, [r3, #0]
 801af4a:	6852      	ldr	r2, [r2, #4]
 801af4c:	f082 4200 	eor.w	r2, r2, #2147483648	; 0x80000000
 801af50:	605a      	str	r2, [r3, #4]
 801af52:	e026      	b.n	801afa2 <fmt_fp+0xca>
	} else if (fl & MARK_POS) {
 801af54:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801af58:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801af5c:	2b00      	cmp	r3, #0
 801af5e:	d007      	beq.n	801af70 <fmt_fp+0x98>
		prefix+=3;
 801af60:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801af64:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801af68:	6812      	ldr	r2, [r2, #0]
 801af6a:	3203      	adds	r2, #3
 801af6c:	601a      	str	r2, [r3, #0]
 801af6e:	e018      	b.n	801afa2 <fmt_fp+0xca>
	} else if (fl & PAD_POS) {
 801af70:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801af74:	f003 0301 	and.w	r3, r3, #1
 801af78:	2b00      	cmp	r3, #0
 801af7a:	d007      	beq.n	801af8c <fmt_fp+0xb4>
		prefix+=6;
 801af7c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801af80:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801af84:	6812      	ldr	r2, [r2, #0]
 801af86:	3206      	adds	r2, #6
 801af88:	601a      	str	r2, [r3, #0]
 801af8a:	e00a      	b.n	801afa2 <fmt_fp+0xca>
	} else prefix++, pl=0;
 801af8c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801af90:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801af94:	6812      	ldr	r2, [r2, #0]
 801af96:	3201      	adds	r2, #1
 801af98:	601a      	str	r2, [r3, #0]
 801af9a:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801af9e:	2200      	movs	r2, #0
 801afa0:	601a      	str	r2, [r3, #0]

	if (!isfinite(y)) {
 801afa2:	463b      	mov	r3, r7
 801afa4:	e9d3 0100 	ldrd	r0, r1, [r3]
 801afa8:	f7ff fd2a 	bl	801aa00 <__DOUBLE_BITS>
 801afac:	4602      	mov	r2, r0
 801afae:	460b      	mov	r3, r1
 801afb0:	f04f 30ff 	mov.w	r0, #4294967295
 801afb4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 801afb8:	ea02 0a00 	and.w	sl, r2, r0
 801afbc:	ea03 0b01 	and.w	fp, r3, r1
 801afc0:	f04f 32ff 	mov.w	r2, #4294967295
 801afc4:	4b71      	ldr	r3, [pc, #452]	; (801b18c <fmt_fp+0x2b4>)
 801afc6:	455b      	cmp	r3, fp
 801afc8:	bf08      	it	eq
 801afca:	4552      	cmpeq	r2, sl
 801afcc:	d265      	bcs.n	801b09a <fmt_fp+0x1c2>
		char *s = (t&32)?"inf":"INF";
 801afce:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801afd2:	f003 0320 	and.w	r3, r3, #32
 801afd6:	2b00      	cmp	r3, #0
 801afd8:	d001      	beq.n	801afde <fmt_fp+0x106>
 801afda:	4a6d      	ldr	r2, [pc, #436]	; (801b190 <fmt_fp+0x2b8>)
 801afdc:	e000      	b.n	801afe0 <fmt_fp+0x108>
 801afde:	4a6d      	ldr	r2, [pc, #436]	; (801b194 <fmt_fp+0x2bc>)
 801afe0:	f107 0344 	add.w	r3, r7, #68	; 0x44
 801afe4:	601a      	str	r2, [r3, #0]
		if (y!=y) s=(t&32)?"nan":"NAN";
 801afe6:	4639      	mov	r1, r7
 801afe8:	463b      	mov	r3, r7
 801afea:	e9d3 2300 	ldrd	r2, r3, [r3]
 801afee:	e9d1 0100 	ldrd	r0, r1, [r1]
 801aff2:	f7e5 fff1 	bl	8000fd8 <__aeabi_dcmpeq>
 801aff6:	4603      	mov	r3, r0
 801aff8:	2b00      	cmp	r3, #0
 801affa:	d10b      	bne.n	801b014 <fmt_fp+0x13c>
 801affc:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b000:	f003 0320 	and.w	r3, r3, #32
 801b004:	2b00      	cmp	r3, #0
 801b006:	d001      	beq.n	801b00c <fmt_fp+0x134>
 801b008:	4a63      	ldr	r2, [pc, #396]	; (801b198 <fmt_fp+0x2c0>)
 801b00a:	e000      	b.n	801b00e <fmt_fp+0x136>
 801b00c:	4a63      	ldr	r2, [pc, #396]	; (801b19c <fmt_fp+0x2c4>)
 801b00e:	f107 0344 	add.w	r3, r7, #68	; 0x44
 801b012:	601a      	str	r2, [r3, #0]
		pad(f, ' ', w, 3+pl, fl&~ZERO_PAD);
 801b014:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b018:	681b      	ldr	r3, [r3, #0]
 801b01a:	1cda      	adds	r2, r3, #3
 801b01c:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b020:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801b024:	f107 000c 	add.w	r0, r7, #12
 801b028:	9300      	str	r3, [sp, #0]
 801b02a:	4613      	mov	r3, r2
 801b02c:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801b030:	2120      	movs	r1, #32
 801b032:	6800      	ldr	r0, [r0, #0]
 801b034:	f7ff fe3a 	bl	801acac <pad>
		out(f, prefix, pl);
 801b038:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b03c:	681a      	ldr	r2, [r3, #0]
 801b03e:	f107 0138 	add.w	r1, r7, #56	; 0x38
 801b042:	f107 030c 	add.w	r3, r7, #12
 801b046:	6809      	ldr	r1, [r1, #0]
 801b048:	6818      	ldr	r0, [r3, #0]
 801b04a:	f7ff fe19 	bl	801ac80 <out>
		out(f, s, 3);
 801b04e:	f107 0144 	add.w	r1, r7, #68	; 0x44
 801b052:	f107 030c 	add.w	r3, r7, #12
 801b056:	2203      	movs	r2, #3
 801b058:	6809      	ldr	r1, [r1, #0]
 801b05a:	6818      	ldr	r0, [r3, #0]
 801b05c:	f7ff fe10 	bl	801ac80 <out>
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
 801b060:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b064:	681b      	ldr	r3, [r3, #0]
 801b066:	1cda      	adds	r2, r3, #3
 801b068:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b06c:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 801b070:	f107 000c 	add.w	r0, r7, #12
 801b074:	9300      	str	r3, [sp, #0]
 801b076:	4613      	mov	r3, r2
 801b078:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801b07c:	2120      	movs	r1, #32
 801b07e:	6800      	ldr	r0, [r0, #0]
 801b080:	f7ff fe14 	bl	801acac <pad>
		return MAX(w, 3+pl);
 801b084:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b088:	681b      	ldr	r3, [r3, #0]
 801b08a:	1cda      	adds	r2, r3, #3
 801b08c:	f8d7 32e8 	ldr.w	r3, [r7, #744]	; 0x2e8
 801b090:	4293      	cmp	r3, r2
 801b092:	bfb8      	it	lt
 801b094:	4613      	movlt	r3, r2
 801b096:	f001 ba31 	b.w	801c4fc <fmt_fp+0x1624>
	}

	y = frexpl(y, &e2);
 801b09a:	463e      	mov	r6, r7
 801b09c:	f107 0210 	add.w	r2, r7, #16
 801b0a0:	463b      	mov	r3, r7
 801b0a2:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b0a6:	f003 ffaf 	bl	801f008 <frexpl>
 801b0aa:	e9c6 0100 	strd	r0, r1, [r6]
	y *= 2;
 801b0ae:	463e      	mov	r6, r7
 801b0b0:	463b      	mov	r3, r7
 801b0b2:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b0b6:	4602      	mov	r2, r0
 801b0b8:	460b      	mov	r3, r1
 801b0ba:	f7e5 f8a3 	bl	8000204 <__adddf3>
 801b0be:	4602      	mov	r2, r0
 801b0c0:	460b      	mov	r3, r1
 801b0c2:	e9c6 2300 	strd	r2, r3, [r6]
	if (y) e2--;
 801b0c6:	4639      	mov	r1, r7
 801b0c8:	f04f 0200 	mov.w	r2, #0
 801b0cc:	f04f 0300 	mov.w	r3, #0
 801b0d0:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b0d4:	f7e5 ff80 	bl	8000fd8 <__aeabi_dcmpeq>
 801b0d8:	4603      	mov	r3, r0
 801b0da:	2b00      	cmp	r3, #0
 801b0dc:	d106      	bne.n	801b0ec <fmt_fp+0x214>
 801b0de:	f107 0310 	add.w	r3, r7, #16
 801b0e2:	681b      	ldr	r3, [r3, #0]
 801b0e4:	1e5a      	subs	r2, r3, #1
 801b0e6:	f107 0310 	add.w	r3, r7, #16
 801b0ea:	601a      	str	r2, [r3, #0]

	if ((t|32)=='a') {
 801b0ec:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b0f0:	f043 0320 	orr.w	r3, r3, #32
 801b0f4:	2b61      	cmp	r3, #97	; 0x61
 801b0f6:	f040 8251 	bne.w	801b59c <fmt_fp+0x6c4>
		ldouble_t round = 8.0;
 801b0fa:	f107 0180 	add.w	r1, r7, #128	; 0x80
 801b0fe:	f04f 0200 	mov.w	r2, #0
 801b102:	4b27      	ldr	r3, [pc, #156]	; (801b1a0 <fmt_fp+0x2c8>)
 801b104:	e9c1 2300 	strd	r2, r3, [r1]
		int re;

		if (t&32) prefix += 9;
 801b108:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b10c:	f003 0320 	and.w	r3, r3, #32
 801b110:	2b00      	cmp	r3, #0
 801b112:	d006      	beq.n	801b122 <fmt_fp+0x24a>
 801b114:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801b118:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801b11c:	6812      	ldr	r2, [r2, #0]
 801b11e:	3209      	adds	r2, #9
 801b120:	601a      	str	r2, [r3, #0]
		pl += 2;
 801b122:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b126:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b12a:	6812      	ldr	r2, [r2, #0]
 801b12c:	3202      	adds	r2, #2
 801b12e:	601a      	str	r2, [r3, #0]

		if (p<0 || p>=LDBL_MANT_DIG/4-1) re=0;
 801b130:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b134:	2b00      	cmp	r3, #0
 801b136:	db03      	blt.n	801b140 <fmt_fp+0x268>
 801b138:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b13c:	2b0b      	cmp	r3, #11
 801b13e:	dd04      	ble.n	801b14a <fmt_fp+0x272>
 801b140:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801b144:	2200      	movs	r2, #0
 801b146:	601a      	str	r2, [r3, #0]
 801b148:	e006      	b.n	801b158 <fmt_fp+0x280>
		else re=LDBL_MANT_DIG/4-1-p;
 801b14a:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801b14e:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801b152:	f1c2 020c 	rsb	r2, r2, #12
 801b156:	601a      	str	r2, [r3, #0]

		if (re) {
 801b158:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801b15c:	681b      	ldr	r3, [r3, #0]
 801b15e:	2b00      	cmp	r3, #0
 801b160:	f000 8087 	beq.w	801b272 <fmt_fp+0x39a>
			round *= 1<<(LDBL_MANT_DIG%4);
 801b164:	f107 0480 	add.w	r4, r7, #128	; 0x80
 801b168:	f107 0380 	add.w	r3, r7, #128	; 0x80
 801b16c:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b170:	4602      	mov	r2, r0
 801b172:	460b      	mov	r3, r1
 801b174:	f7e5 f846 	bl	8000204 <__adddf3>
 801b178:	4602      	mov	r2, r0
 801b17a:	460b      	mov	r3, r1
 801b17c:	e9c4 2300 	strd	r2, r3, [r4]
			while (re--) round*=16;
 801b180:	e01f      	b.n	801b1c2 <fmt_fp+0x2ea>
 801b182:	bf00      	nop
 801b184:	080231b4 	.word	0x080231b4
 801b188:	0802318c 	.word	0x0802318c
 801b18c:	7fefffff 	.word	0x7fefffff
 801b190:	080231a0 	.word	0x080231a0
 801b194:	080231a4 	.word	0x080231a4
 801b198:	080231a8 	.word	0x080231a8
 801b19c:	080231ac 	.word	0x080231ac
 801b1a0:	40200000 	.word	0x40200000
 801b1a4:	f107 0480 	add.w	r4, r7, #128	; 0x80
 801b1a8:	f107 0180 	add.w	r1, r7, #128	; 0x80
 801b1ac:	f04f 0200 	mov.w	r2, #0
 801b1b0:	4ba7      	ldr	r3, [pc, #668]	; (801b450 <fmt_fp+0x578>)
 801b1b2:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b1b6:	f7e5 f9db 	bl	8000570 <__aeabi_dmul>
 801b1ba:	4602      	mov	r2, r0
 801b1bc:	460b      	mov	r3, r1
 801b1be:	e9c4 2300 	strd	r2, r3, [r4]
 801b1c2:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801b1c6:	681b      	ldr	r3, [r3, #0]
 801b1c8:	f107 0248 	add.w	r2, r7, #72	; 0x48
 801b1cc:	1e59      	subs	r1, r3, #1
 801b1ce:	6011      	str	r1, [r2, #0]
 801b1d0:	2b00      	cmp	r3, #0
 801b1d2:	d1e7      	bne.n	801b1a4 <fmt_fp+0x2cc>
			if (*prefix=='-') {
 801b1d4:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801b1d8:	681b      	ldr	r3, [r3, #0]
 801b1da:	781b      	ldrb	r3, [r3, #0]
 801b1dc:	2b2d      	cmp	r3, #45	; 0x2d
 801b1de:	d12c      	bne.n	801b23a <fmt_fp+0x362>
				y=-y;
 801b1e0:	463b      	mov	r3, r7
 801b1e2:	463a      	mov	r2, r7
 801b1e4:	6811      	ldr	r1, [r2, #0]
 801b1e6:	6019      	str	r1, [r3, #0]
 801b1e8:	6852      	ldr	r2, [r2, #4]
 801b1ea:	f082 4200 	eor.w	r2, r2, #2147483648	; 0x80000000
 801b1ee:	605a      	str	r2, [r3, #4]
				y-=round;
 801b1f0:	463c      	mov	r4, r7
 801b1f2:	4639      	mov	r1, r7
 801b1f4:	f107 0380 	add.w	r3, r7, #128	; 0x80
 801b1f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b1fc:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b200:	f7e4 fffe 	bl	8000200 <__aeabi_dsub>
 801b204:	4602      	mov	r2, r0
 801b206:	460b      	mov	r3, r1
 801b208:	e9c4 2300 	strd	r2, r3, [r4]
				y+=round;
 801b20c:	463c      	mov	r4, r7
 801b20e:	4639      	mov	r1, r7
 801b210:	f107 0380 	add.w	r3, r7, #128	; 0x80
 801b214:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b218:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b21c:	f7e4 fff2 	bl	8000204 <__adddf3>
 801b220:	4602      	mov	r2, r0
 801b222:	460b      	mov	r3, r1
 801b224:	e9c4 2300 	strd	r2, r3, [r4]
				y=-y;
 801b228:	463b      	mov	r3, r7
 801b22a:	463a      	mov	r2, r7
 801b22c:	6811      	ldr	r1, [r2, #0]
 801b22e:	6019      	str	r1, [r3, #0]
 801b230:	6852      	ldr	r2, [r2, #4]
 801b232:	f082 4200 	eor.w	r2, r2, #2147483648	; 0x80000000
 801b236:	605a      	str	r2, [r3, #4]
 801b238:	e01b      	b.n	801b272 <fmt_fp+0x39a>
			} else {
				y+=round;
 801b23a:	463c      	mov	r4, r7
 801b23c:	4639      	mov	r1, r7
 801b23e:	f107 0380 	add.w	r3, r7, #128	; 0x80
 801b242:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b246:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b24a:	f7e4 ffdb 	bl	8000204 <__adddf3>
 801b24e:	4602      	mov	r2, r0
 801b250:	460b      	mov	r3, r1
 801b252:	e9c4 2300 	strd	r2, r3, [r4]
				y-=round;
 801b256:	463c      	mov	r4, r7
 801b258:	4639      	mov	r1, r7
 801b25a:	f107 0380 	add.w	r3, r7, #128	; 0x80
 801b25e:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b262:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b266:	f7e4 ffcb 	bl	8000200 <__aeabi_dsub>
 801b26a:	4602      	mov	r2, r0
 801b26c:	460b      	mov	r3, r1
 801b26e:	e9c4 2300 	strd	r2, r3, [r4]
			}
		}

		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
 801b272:	f107 0310 	add.w	r3, r7, #16
 801b276:	681b      	ldr	r3, [r3, #0]
 801b278:	2b00      	cmp	r3, #0
 801b27a:	bfb8      	it	lt
 801b27c:	425b      	neglt	r3, r3
 801b27e:	4618      	mov	r0, r3
 801b280:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801b284:	f107 0440 	add.w	r4, r7, #64	; 0x40
 801b288:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801b28c:	681a      	ldr	r2, [r3, #0]
 801b28e:	f7ff fdd5 	bl	801ae3c <fmt_u>
 801b292:	6020      	str	r0, [r4, #0]
		if (estr==ebuf) *--estr='0';
 801b294:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801b298:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801b29c:	6812      	ldr	r2, [r2, #0]
 801b29e:	681b      	ldr	r3, [r3, #0]
 801b2a0:	429a      	cmp	r2, r3
 801b2a2:	d10b      	bne.n	801b2bc <fmt_fp+0x3e4>
 801b2a4:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b2a8:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801b2ac:	6812      	ldr	r2, [r2, #0]
 801b2ae:	3a01      	subs	r2, #1
 801b2b0:	601a      	str	r2, [r3, #0]
 801b2b2:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b2b6:	681b      	ldr	r3, [r3, #0]
 801b2b8:	2230      	movs	r2, #48	; 0x30
 801b2ba:	701a      	strb	r2, [r3, #0]
		*--estr = (e2<0 ? '-' : '+');
 801b2bc:	f107 0310 	add.w	r3, r7, #16
 801b2c0:	681b      	ldr	r3, [r3, #0]
 801b2c2:	2b00      	cmp	r3, #0
 801b2c4:	da01      	bge.n	801b2ca <fmt_fp+0x3f2>
 801b2c6:	212d      	movs	r1, #45	; 0x2d
 801b2c8:	e000      	b.n	801b2cc <fmt_fp+0x3f4>
 801b2ca:	212b      	movs	r1, #43	; 0x2b
 801b2cc:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b2d0:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801b2d4:	6812      	ldr	r2, [r2, #0]
 801b2d6:	3a01      	subs	r2, #1
 801b2d8:	601a      	str	r2, [r3, #0]
 801b2da:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b2de:	681b      	ldr	r3, [r3, #0]
 801b2e0:	460a      	mov	r2, r1
 801b2e2:	701a      	strb	r2, [r3, #0]
		*--estr = t+('p'-'a');
 801b2e4:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b2e8:	b2db      	uxtb	r3, r3
 801b2ea:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801b2ee:	f107 0140 	add.w	r1, r7, #64	; 0x40
 801b2f2:	6809      	ldr	r1, [r1, #0]
 801b2f4:	3901      	subs	r1, #1
 801b2f6:	6011      	str	r1, [r2, #0]
 801b2f8:	330f      	adds	r3, #15
 801b2fa:	b2da      	uxtb	r2, r3
 801b2fc:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b300:	681b      	ldr	r3, [r3, #0]
 801b302:	701a      	strb	r2, [r3, #0]

		s=buf;
 801b304:	f107 0334 	add.w	r3, r7, #52	; 0x34
 801b308:	f507 7229 	add.w	r2, r7, #676	; 0x2a4
 801b30c:	601a      	str	r2, [r3, #0]
		do {
			int x=y;
 801b30e:	f107 047c 	add.w	r4, r7, #124	; 0x7c
 801b312:	463b      	mov	r3, r7
 801b314:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b318:	f7e5 fe90 	bl	800103c <__aeabi_d2iz>
 801b31c:	4603      	mov	r3, r0
 801b31e:	6023      	str	r3, [r4, #0]
			*s++=xdigits[x]|(t&32);
 801b320:	4a4c      	ldr	r2, [pc, #304]	; (801b454 <fmt_fp+0x57c>)
 801b322:	f107 037c 	add.w	r3, r7, #124	; 0x7c
 801b326:	681b      	ldr	r3, [r3, #0]
 801b328:	4413      	add	r3, r2
 801b32a:	781b      	ldrb	r3, [r3, #0]
 801b32c:	b25a      	sxtb	r2, r3
 801b32e:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b332:	b25b      	sxtb	r3, r3
 801b334:	f003 0320 	and.w	r3, r3, #32
 801b338:	b25b      	sxtb	r3, r3
 801b33a:	4313      	orrs	r3, r2
 801b33c:	b258      	sxtb	r0, r3
 801b33e:	f107 0334 	add.w	r3, r7, #52	; 0x34
 801b342:	681b      	ldr	r3, [r3, #0]
 801b344:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b348:	1c59      	adds	r1, r3, #1
 801b34a:	6011      	str	r1, [r2, #0]
 801b34c:	b2c2      	uxtb	r2, r0
 801b34e:	701a      	strb	r2, [r3, #0]
			y=16*(y-x);
 801b350:	f107 037c 	add.w	r3, r7, #124	; 0x7c
 801b354:	6818      	ldr	r0, [r3, #0]
 801b356:	f7e5 f8a1 	bl	800049c <__aeabi_i2d>
 801b35a:	4602      	mov	r2, r0
 801b35c:	460b      	mov	r3, r1
 801b35e:	4639      	mov	r1, r7
 801b360:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b364:	f7e4 ff4c 	bl	8000200 <__aeabi_dsub>
 801b368:	4602      	mov	r2, r0
 801b36a:	460b      	mov	r3, r1
 801b36c:	4610      	mov	r0, r2
 801b36e:	4619      	mov	r1, r3
 801b370:	463c      	mov	r4, r7
 801b372:	f04f 0200 	mov.w	r2, #0
 801b376:	4b36      	ldr	r3, [pc, #216]	; (801b450 <fmt_fp+0x578>)
 801b378:	f7e5 f8fa 	bl	8000570 <__aeabi_dmul>
 801b37c:	4602      	mov	r2, r0
 801b37e:	460b      	mov	r3, r1
 801b380:	e9c4 2300 	strd	r2, r3, [r4]
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
 801b384:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b388:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801b38c:	6812      	ldr	r2, [r2, #0]
 801b38e:	1ad3      	subs	r3, r2, r3
 801b390:	2b01      	cmp	r3, #1
 801b392:	d11e      	bne.n	801b3d2 <fmt_fp+0x4fa>
 801b394:	4639      	mov	r1, r7
 801b396:	f04f 0200 	mov.w	r2, #0
 801b39a:	f04f 0300 	mov.w	r3, #0
 801b39e:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b3a2:	f7e5 fe19 	bl	8000fd8 <__aeabi_dcmpeq>
 801b3a6:	4603      	mov	r3, r0
 801b3a8:	2b00      	cmp	r3, #0
 801b3aa:	d009      	beq.n	801b3c0 <fmt_fp+0x4e8>
 801b3ac:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b3b0:	2b00      	cmp	r3, #0
 801b3b2:	dc05      	bgt.n	801b3c0 <fmt_fp+0x4e8>
 801b3b4:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b3b8:	f003 0308 	and.w	r3, r3, #8
 801b3bc:	2b00      	cmp	r3, #0
 801b3be:	d008      	beq.n	801b3d2 <fmt_fp+0x4fa>
 801b3c0:	f107 0334 	add.w	r3, r7, #52	; 0x34
 801b3c4:	681b      	ldr	r3, [r3, #0]
 801b3c6:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b3ca:	1c59      	adds	r1, r3, #1
 801b3cc:	6011      	str	r1, [r2, #0]
 801b3ce:	222e      	movs	r2, #46	; 0x2e
 801b3d0:	701a      	strb	r2, [r3, #0]
		} while (y);
 801b3d2:	4639      	mov	r1, r7
 801b3d4:	f04f 0200 	mov.w	r2, #0
 801b3d8:	f04f 0300 	mov.w	r3, #0
 801b3dc:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b3e0:	f7e5 fdfa 	bl	8000fd8 <__aeabi_dcmpeq>
 801b3e4:	4603      	mov	r3, r0
 801b3e6:	2b00      	cmp	r3, #0
 801b3e8:	d091      	beq.n	801b30e <fmt_fp+0x436>

		if (p > INT_MAX-2-(ebuf-estr)-pl)
 801b3ea:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b3ee:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b3f2:	6812      	ldr	r2, [r2, #0]
 801b3f4:	681b      	ldr	r3, [r3, #0]
 801b3f6:	1ad2      	subs	r2, r2, r3
 801b3f8:	4b17      	ldr	r3, [pc, #92]	; (801b458 <fmt_fp+0x580>)
 801b3fa:	1a9b      	subs	r3, r3, r2
 801b3fc:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b400:	6812      	ldr	r2, [r2, #0]
 801b402:	1a9b      	subs	r3, r3, r2
 801b404:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801b408:	429a      	cmp	r2, r3
 801b40a:	dd03      	ble.n	801b414 <fmt_fp+0x53c>
			return -1;
 801b40c:	f04f 33ff 	mov.w	r3, #4294967295
 801b410:	f001 b874 	b.w	801c4fc <fmt_fp+0x1624>
		if (p && s-buf-2 < p)
 801b414:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b418:	2b00      	cmp	r3, #0
 801b41a:	d01f      	beq.n	801b45c <fmt_fp+0x584>
 801b41c:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b420:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801b424:	6812      	ldr	r2, [r2, #0]
 801b426:	1ad3      	subs	r3, r2, r3
 801b428:	3b01      	subs	r3, #1
 801b42a:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801b42e:	429a      	cmp	r2, r3
 801b430:	db14      	blt.n	801b45c <fmt_fp+0x584>
			l = (p+2) + (ebuf-estr);
 801b432:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b436:	1c99      	adds	r1, r3, #2
 801b438:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b43c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b440:	6812      	ldr	r2, [r2, #0]
 801b442:	681b      	ldr	r3, [r3, #0]
 801b444:	1ad2      	subs	r2, r2, r3
 801b446:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b44a:	440a      	add	r2, r1
 801b44c:	601a      	str	r2, [r3, #0]
 801b44e:	e016      	b.n	801b47e <fmt_fp+0x5a6>
 801b450:	40300000 	.word	0x40300000
 801b454:	08023b60 	.word	0x08023b60
 801b458:	7ffffffd 	.word	0x7ffffffd
		else
			l = (s-buf) + (ebuf-estr);
 801b45c:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b460:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801b464:	6812      	ldr	r2, [r2, #0]
 801b466:	1ad1      	subs	r1, r2, r3
 801b468:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b46c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b470:	6812      	ldr	r2, [r2, #0]
 801b472:	681b      	ldr	r3, [r3, #0]
 801b474:	1ad2      	subs	r2, r2, r3
 801b476:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b47a:	440a      	add	r2, r1
 801b47c:	601a      	str	r2, [r3, #0]

		pad(f, ' ', w, pl+l, fl);
 801b47e:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b482:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b486:	6812      	ldr	r2, [r2, #0]
 801b488:	681b      	ldr	r3, [r3, #0]
 801b48a:	441a      	add	r2, r3
 801b48c:	f107 000c 	add.w	r0, r7, #12
 801b490:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b494:	9300      	str	r3, [sp, #0]
 801b496:	4613      	mov	r3, r2
 801b498:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801b49c:	2120      	movs	r1, #32
 801b49e:	6800      	ldr	r0, [r0, #0]
 801b4a0:	f7ff fc04 	bl	801acac <pad>
		out(f, prefix, pl);
 801b4a4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b4a8:	681a      	ldr	r2, [r3, #0]
 801b4aa:	f107 0138 	add.w	r1, r7, #56	; 0x38
 801b4ae:	f107 030c 	add.w	r3, r7, #12
 801b4b2:	6809      	ldr	r1, [r1, #0]
 801b4b4:	6818      	ldr	r0, [r3, #0]
 801b4b6:	f7ff fbe3 	bl	801ac80 <out>
		pad(f, '0', w, pl+l, fl^ZERO_PAD);
 801b4ba:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b4be:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b4c2:	6812      	ldr	r2, [r2, #0]
 801b4c4:	681b      	ldr	r3, [r3, #0]
 801b4c6:	441a      	add	r2, r3
 801b4c8:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b4cc:	f483 3380 	eor.w	r3, r3, #65536	; 0x10000
 801b4d0:	f107 000c 	add.w	r0, r7, #12
 801b4d4:	9300      	str	r3, [sp, #0]
 801b4d6:	4613      	mov	r3, r2
 801b4d8:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801b4dc:	2130      	movs	r1, #48	; 0x30
 801b4de:	6800      	ldr	r0, [r0, #0]
 801b4e0:	f7ff fbe4 	bl	801acac <pad>
		out(f, buf, s-buf);
 801b4e4:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b4e8:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801b4ec:	6812      	ldr	r2, [r2, #0]
 801b4ee:	1ad3      	subs	r3, r2, r3
 801b4f0:	461a      	mov	r2, r3
 801b4f2:	f507 7129 	add.w	r1, r7, #676	; 0x2a4
 801b4f6:	f107 030c 	add.w	r3, r7, #12
 801b4fa:	6818      	ldr	r0, [r3, #0]
 801b4fc:	f7ff fbc0 	bl	801ac80 <out>
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
 801b500:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b504:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b508:	6812      	ldr	r2, [r2, #0]
 801b50a:	681b      	ldr	r3, [r3, #0]
 801b50c:	1ad3      	subs	r3, r2, r3
 801b50e:	f107 0230 	add.w	r2, r7, #48	; 0x30
 801b512:	6812      	ldr	r2, [r2, #0]
 801b514:	1ad2      	subs	r2, r2, r3
 801b516:	f107 0134 	add.w	r1, r7, #52	; 0x34
 801b51a:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801b51e:	6809      	ldr	r1, [r1, #0]
 801b520:	1acb      	subs	r3, r1, r3
 801b522:	1ad2      	subs	r2, r2, r3
 801b524:	f107 000c 	add.w	r0, r7, #12
 801b528:	2300      	movs	r3, #0
 801b52a:	9300      	str	r3, [sp, #0]
 801b52c:	2300      	movs	r3, #0
 801b52e:	2130      	movs	r1, #48	; 0x30
 801b530:	6800      	ldr	r0, [r0, #0]
 801b532:	f7ff fbbb 	bl	801acac <pad>
		out(f, estr, ebuf-estr);
 801b536:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b53a:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b53e:	6812      	ldr	r2, [r2, #0]
 801b540:	681b      	ldr	r3, [r3, #0]
 801b542:	1ad3      	subs	r3, r2, r3
 801b544:	461a      	mov	r2, r3
 801b546:	f107 0140 	add.w	r1, r7, #64	; 0x40
 801b54a:	f107 030c 	add.w	r3, r7, #12
 801b54e:	6809      	ldr	r1, [r1, #0]
 801b550:	6818      	ldr	r0, [r3, #0]
 801b552:	f7ff fb95 	bl	801ac80 <out>
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
 801b556:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b55a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b55e:	6812      	ldr	r2, [r2, #0]
 801b560:	681b      	ldr	r3, [r3, #0]
 801b562:	441a      	add	r2, r3
 801b564:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b568:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 801b56c:	f107 000c 	add.w	r0, r7, #12
 801b570:	9300      	str	r3, [sp, #0]
 801b572:	4613      	mov	r3, r2
 801b574:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801b578:	2120      	movs	r1, #32
 801b57a:	6800      	ldr	r0, [r0, #0]
 801b57c:	f7ff fb96 	bl	801acac <pad>
		return MAX(w, pl+l);
 801b580:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b584:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b588:	6812      	ldr	r2, [r2, #0]
 801b58a:	681b      	ldr	r3, [r3, #0]
 801b58c:	441a      	add	r2, r3
 801b58e:	f8d7 32e8 	ldr.w	r3, [r7, #744]	; 0x2e8
 801b592:	4293      	cmp	r3, r2
 801b594:	bfb8      	it	lt
 801b596:	4613      	movlt	r3, r2
 801b598:	f000 bfb0 	b.w	801c4fc <fmt_fp+0x1624>
	}
	if (p<0) p=6;
 801b59c:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b5a0:	2b00      	cmp	r3, #0
 801b5a2:	da02      	bge.n	801b5aa <fmt_fp+0x6d2>
 801b5a4:	2306      	movs	r3, #6
 801b5a6:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec

	if (y) y *= 0x1p28, e2-=28;
 801b5aa:	4639      	mov	r1, r7
 801b5ac:	f04f 0200 	mov.w	r2, #0
 801b5b0:	f04f 0300 	mov.w	r3, #0
 801b5b4:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b5b8:	f7e5 fd0e 	bl	8000fd8 <__aeabi_dcmpeq>
 801b5bc:	4603      	mov	r3, r0
 801b5be:	2b00      	cmp	r3, #0
 801b5c0:	d114      	bne.n	801b5ec <fmt_fp+0x714>
 801b5c2:	463e      	mov	r6, r7
 801b5c4:	4639      	mov	r1, r7
 801b5c6:	f04f 0200 	mov.w	r2, #0
 801b5ca:	4ba5      	ldr	r3, [pc, #660]	; (801b860 <fmt_fp+0x988>)
 801b5cc:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b5d0:	f7e4 ffce 	bl	8000570 <__aeabi_dmul>
 801b5d4:	4602      	mov	r2, r0
 801b5d6:	460b      	mov	r3, r1
 801b5d8:	e9c6 2300 	strd	r2, r3, [r6]
 801b5dc:	f107 0310 	add.w	r3, r7, #16
 801b5e0:	681b      	ldr	r3, [r3, #0]
 801b5e2:	f1a3 021c 	sub.w	r2, r3, #28
 801b5e6:	f107 0310 	add.w	r3, r7, #16
 801b5ea:	601a      	str	r2, [r3, #0]

	if (e2<0) a=r=z=big;
 801b5ec:	f107 0310 	add.w	r3, r7, #16
 801b5f0:	681b      	ldr	r3, [r3, #0]
 801b5f2:	2b00      	cmp	r3, #0
 801b5f4:	da11      	bge.n	801b61a <fmt_fp+0x742>
 801b5f6:	f107 0320 	add.w	r3, r7, #32
 801b5fa:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 801b5fe:	601a      	str	r2, [r3, #0]
 801b600:	f107 031c 	add.w	r3, r7, #28
 801b604:	f107 0220 	add.w	r2, r7, #32
 801b608:	6812      	ldr	r2, [r2, #0]
 801b60a:	601a      	str	r2, [r3, #0]
 801b60c:	f107 0314 	add.w	r3, r7, #20
 801b610:	f107 021c 	add.w	r2, r7, #28
 801b614:	6812      	ldr	r2, [r2, #0]
 801b616:	601a      	str	r2, [r3, #0]
 801b618:	e012      	b.n	801b640 <fmt_fp+0x768>
	else a=r=z=big+sizeof(big)/sizeof(*big) - LDBL_MANT_DIG - 1;
 801b61a:	f107 0320 	add.w	r3, r7, #32
 801b61e:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 801b622:	f502 7290 	add.w	r2, r2, #288	; 0x120
 801b626:	601a      	str	r2, [r3, #0]
 801b628:	f107 031c 	add.w	r3, r7, #28
 801b62c:	f107 0220 	add.w	r2, r7, #32
 801b630:	6812      	ldr	r2, [r2, #0]
 801b632:	601a      	str	r2, [r3, #0]
 801b634:	f107 0314 	add.w	r3, r7, #20
 801b638:	f107 021c 	add.w	r2, r7, #28
 801b63c:	6812      	ldr	r2, [r2, #0]
 801b63e:	601a      	str	r2, [r3, #0]

	do {
		*z = y;
 801b640:	463b      	mov	r3, r7
 801b642:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b646:	f7e5 fd21 	bl	800108c <__aeabi_d2uiz>
 801b64a:	4602      	mov	r2, r0
 801b64c:	f107 0320 	add.w	r3, r7, #32
 801b650:	681b      	ldr	r3, [r3, #0]
 801b652:	601a      	str	r2, [r3, #0]
		y = 1000000000*(y-*z++);
 801b654:	f107 0320 	add.w	r3, r7, #32
 801b658:	681b      	ldr	r3, [r3, #0]
 801b65a:	f107 0220 	add.w	r2, r7, #32
 801b65e:	1d19      	adds	r1, r3, #4
 801b660:	6011      	str	r1, [r2, #0]
 801b662:	681b      	ldr	r3, [r3, #0]
 801b664:	4618      	mov	r0, r3
 801b666:	f7e4 ff09 	bl	800047c <__aeabi_ui2d>
 801b66a:	4602      	mov	r2, r0
 801b66c:	460b      	mov	r3, r1
 801b66e:	4639      	mov	r1, r7
 801b670:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b674:	f7e4 fdc4 	bl	8000200 <__aeabi_dsub>
 801b678:	4602      	mov	r2, r0
 801b67a:	460b      	mov	r3, r1
 801b67c:	4610      	mov	r0, r2
 801b67e:	4619      	mov	r1, r3
 801b680:	463e      	mov	r6, r7
 801b682:	a373      	add	r3, pc, #460	; (adr r3, 801b850 <fmt_fp+0x978>)
 801b684:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b688:	f7e4 ff72 	bl	8000570 <__aeabi_dmul>
 801b68c:	4602      	mov	r2, r0
 801b68e:	460b      	mov	r3, r1
 801b690:	e9c6 2300 	strd	r2, r3, [r6]
 801b694:	f107 0314 	add.w	r3, r7, #20
 801b698:	f107 0214 	add.w	r2, r7, #20
 801b69c:	6812      	ldr	r2, [r2, #0]
 801b69e:	601a      	str	r2, [r3, #0]
 801b6a0:	f107 031c 	add.w	r3, r7, #28
 801b6a4:	f107 021c 	add.w	r2, r7, #28
 801b6a8:	6812      	ldr	r2, [r2, #0]
 801b6aa:	601a      	str	r2, [r3, #0]
	} while (y);
 801b6ac:	4639      	mov	r1, r7
 801b6ae:	f04f 0200 	mov.w	r2, #0
 801b6b2:	f04f 0300 	mov.w	r3, #0
 801b6b6:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b6ba:	f7e5 fc8d 	bl	8000fd8 <__aeabi_dcmpeq>
 801b6be:	4603      	mov	r3, r0
 801b6c0:	2b00      	cmp	r3, #0
 801b6c2:	d0bd      	beq.n	801b640 <fmt_fp+0x768>

	while (e2>0) {
 801b6c4:	e095      	b.n	801b7f2 <fmt_fp+0x91a>
		uint32_t carry=0;
 801b6c6:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 801b6ca:	2200      	movs	r2, #0
 801b6cc:	601a      	str	r2, [r3, #0]
		int sh=MIN(29,e2);
 801b6ce:	f107 0310 	add.w	r3, r7, #16
 801b6d2:	681a      	ldr	r2, [r3, #0]
 801b6d4:	f107 0378 	add.w	r3, r7, #120	; 0x78
 801b6d8:	2a1d      	cmp	r2, #29
 801b6da:	bfa8      	it	ge
 801b6dc:	221d      	movge	r2, #29
 801b6de:	601a      	str	r2, [r3, #0]
		for (d=z-1; d>=a; d--) {
 801b6e0:	f107 0318 	add.w	r3, r7, #24
 801b6e4:	f107 0220 	add.w	r2, r7, #32
 801b6e8:	6812      	ldr	r2, [r2, #0]
 801b6ea:	3a04      	subs	r2, #4
 801b6ec:	601a      	str	r2, [r3, #0]
 801b6ee:	e044      	b.n	801b77a <fmt_fp+0x8a2>
			uint64_t x = ((uint64_t)*d<<sh)+carry;
 801b6f0:	f107 0318 	add.w	r3, r7, #24
 801b6f4:	681b      	ldr	r3, [r3, #0]
 801b6f6:	681b      	ldr	r3, [r3, #0]
 801b6f8:	461a      	mov	r2, r3
 801b6fa:	f04f 0300 	mov.w	r3, #0
 801b6fe:	f107 0178 	add.w	r1, r7, #120	; 0x78
 801b702:	6809      	ldr	r1, [r1, #0]
 801b704:	f1a1 0620 	sub.w	r6, r1, #32
 801b708:	f1c1 0020 	rsb	r0, r1, #32
 801b70c:	fa03 f501 	lsl.w	r5, r3, r1
 801b710:	fa02 f606 	lsl.w	r6, r2, r6
 801b714:	4335      	orrs	r5, r6
 801b716:	fa22 f000 	lsr.w	r0, r2, r0
 801b71a:	4305      	orrs	r5, r0
 801b71c:	fa02 f401 	lsl.w	r4, r2, r1
 801b720:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 801b724:	681b      	ldr	r3, [r3, #0]
 801b726:	461a      	mov	r2, r3
 801b728:	f04f 0300 	mov.w	r3, #0
 801b72c:	eb14 0802 	adds.w	r8, r4, r2
 801b730:	eb45 0903 	adc.w	r9, r5, r3
 801b734:	e9c7 8926 	strd	r8, r9, [r7, #152]	; 0x98
			*d = x % 1000000000;
 801b738:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	; 0x98
 801b73c:	a346      	add	r3, pc, #280	; (adr r3, 801b858 <fmt_fp+0x980>)
 801b73e:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b742:	f7e5 f927 	bl	8000994 <__aeabi_uldivmod>
 801b746:	f107 0318 	add.w	r3, r7, #24
 801b74a:	681b      	ldr	r3, [r3, #0]
 801b74c:	601a      	str	r2, [r3, #0]
			carry = x / 1000000000;
 801b74e:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	; 0x98
 801b752:	a341      	add	r3, pc, #260	; (adr r3, 801b858 <fmt_fp+0x980>)
 801b754:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b758:	f7e5 f91c 	bl	8000994 <__aeabi_uldivmod>
 801b75c:	4602      	mov	r2, r0
 801b75e:	460b      	mov	r3, r1
 801b760:	4610      	mov	r0, r2
 801b762:	4619      	mov	r1, r3
 801b764:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 801b768:	4602      	mov	r2, r0
 801b76a:	601a      	str	r2, [r3, #0]
		for (d=z-1; d>=a; d--) {
 801b76c:	f107 0318 	add.w	r3, r7, #24
 801b770:	f107 0218 	add.w	r2, r7, #24
 801b774:	6812      	ldr	r2, [r2, #0]
 801b776:	3a04      	subs	r2, #4
 801b778:	601a      	str	r2, [r3, #0]
 801b77a:	f107 0218 	add.w	r2, r7, #24
 801b77e:	f107 0314 	add.w	r3, r7, #20
 801b782:	6812      	ldr	r2, [r2, #0]
 801b784:	681b      	ldr	r3, [r3, #0]
 801b786:	429a      	cmp	r2, r3
 801b788:	d2b2      	bcs.n	801b6f0 <fmt_fp+0x818>
		}
		if (carry) *--a = carry;
 801b78a:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 801b78e:	681b      	ldr	r3, [r3, #0]
 801b790:	2b00      	cmp	r3, #0
 801b792:	d015      	beq.n	801b7c0 <fmt_fp+0x8e8>
 801b794:	f107 0314 	add.w	r3, r7, #20
 801b798:	f107 0214 	add.w	r2, r7, #20
 801b79c:	6812      	ldr	r2, [r2, #0]
 801b79e:	3a04      	subs	r2, #4
 801b7a0:	601a      	str	r2, [r3, #0]
 801b7a2:	f107 0314 	add.w	r3, r7, #20
 801b7a6:	681b      	ldr	r3, [r3, #0]
 801b7a8:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 801b7ac:	6812      	ldr	r2, [r2, #0]
 801b7ae:	601a      	str	r2, [r3, #0]
		while (z>a && !z[-1]) z--;
 801b7b0:	e006      	b.n	801b7c0 <fmt_fp+0x8e8>
 801b7b2:	f107 0320 	add.w	r3, r7, #32
 801b7b6:	f107 0220 	add.w	r2, r7, #32
 801b7ba:	6812      	ldr	r2, [r2, #0]
 801b7bc:	3a04      	subs	r2, #4
 801b7be:	601a      	str	r2, [r3, #0]
 801b7c0:	f107 0220 	add.w	r2, r7, #32
 801b7c4:	f107 0314 	add.w	r3, r7, #20
 801b7c8:	6812      	ldr	r2, [r2, #0]
 801b7ca:	681b      	ldr	r3, [r3, #0]
 801b7cc:	429a      	cmp	r2, r3
 801b7ce:	d906      	bls.n	801b7de <fmt_fp+0x906>
 801b7d0:	f107 0320 	add.w	r3, r7, #32
 801b7d4:	681b      	ldr	r3, [r3, #0]
 801b7d6:	3b04      	subs	r3, #4
 801b7d8:	681b      	ldr	r3, [r3, #0]
 801b7da:	2b00      	cmp	r3, #0
 801b7dc:	d0e9      	beq.n	801b7b2 <fmt_fp+0x8da>
		e2-=sh;
 801b7de:	f107 0310 	add.w	r3, r7, #16
 801b7e2:	681a      	ldr	r2, [r3, #0]
 801b7e4:	f107 0378 	add.w	r3, r7, #120	; 0x78
 801b7e8:	681b      	ldr	r3, [r3, #0]
 801b7ea:	1ad2      	subs	r2, r2, r3
 801b7ec:	f107 0310 	add.w	r3, r7, #16
 801b7f0:	601a      	str	r2, [r3, #0]
	while (e2>0) {
 801b7f2:	f107 0310 	add.w	r3, r7, #16
 801b7f6:	681b      	ldr	r3, [r3, #0]
 801b7f8:	2b00      	cmp	r3, #0
 801b7fa:	f73f af64 	bgt.w	801b6c6 <fmt_fp+0x7ee>
	}
	while (e2<0) {
 801b7fe:	e0c1      	b.n	801b984 <fmt_fp+0xaac>
		uint32_t carry=0, *b;
 801b800:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801b804:	2200      	movs	r2, #0
 801b806:	601a      	str	r2, [r3, #0]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
 801b808:	f107 0310 	add.w	r3, r7, #16
 801b80c:	681b      	ldr	r3, [r3, #0]
 801b80e:	f113 0f09 	cmn.w	r3, #9
 801b812:	db04      	blt.n	801b81e <fmt_fp+0x946>
 801b814:	f107 0310 	add.w	r3, r7, #16
 801b818:	681b      	ldr	r3, [r3, #0]
 801b81a:	425b      	negs	r3, r3
 801b81c:	e000      	b.n	801b820 <fmt_fp+0x948>
 801b81e:	2309      	movs	r3, #9
 801b820:	f107 0268 	add.w	r2, r7, #104	; 0x68
 801b824:	6013      	str	r3, [r2, #0]
 801b826:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b82a:	3319      	adds	r3, #25
 801b82c:	4a0d      	ldr	r2, [pc, #52]	; (801b864 <fmt_fp+0x98c>)
 801b82e:	fba2 2303 	umull	r2, r3, r2, r3
 801b832:	085b      	lsrs	r3, r3, #1
 801b834:	1c5a      	adds	r2, r3, #1
 801b836:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801b83a:	601a      	str	r2, [r3, #0]
		for (d=a; d<z; d++) {
 801b83c:	f107 0318 	add.w	r3, r7, #24
 801b840:	f107 0214 	add.w	r2, r7, #20
 801b844:	6812      	ldr	r2, [r2, #0]
 801b846:	601a      	str	r2, [r3, #0]
 801b848:	e044      	b.n	801b8d4 <fmt_fp+0x9fc>
 801b84a:	bf00      	nop
 801b84c:	f3af 8000 	nop.w
 801b850:	00000000 	.word	0x00000000
 801b854:	41cdcd65 	.word	0x41cdcd65
 801b858:	3b9aca00 	.word	0x3b9aca00
 801b85c:	00000000 	.word	0x00000000
 801b860:	41b00000 	.word	0x41b00000
 801b864:	38e38e39 	.word	0x38e38e39
			uint32_t rm = *d & ((1<<sh)-1);
 801b868:	f107 0318 	add.w	r3, r7, #24
 801b86c:	681b      	ldr	r3, [r3, #0]
 801b86e:	681a      	ldr	r2, [r3, #0]
 801b870:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801b874:	2101      	movs	r1, #1
 801b876:	681b      	ldr	r3, [r3, #0]
 801b878:	fa01 f303 	lsl.w	r3, r1, r3
 801b87c:	3b01      	subs	r3, #1
 801b87e:	4619      	mov	r1, r3
 801b880:	f107 0374 	add.w	r3, r7, #116	; 0x74
 801b884:	400a      	ands	r2, r1
 801b886:	601a      	str	r2, [r3, #0]
			*d = (*d>>sh) + carry;
 801b888:	f107 0318 	add.w	r3, r7, #24
 801b88c:	681b      	ldr	r3, [r3, #0]
 801b88e:	681a      	ldr	r2, [r3, #0]
 801b890:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801b894:	681b      	ldr	r3, [r3, #0]
 801b896:	40da      	lsrs	r2, r3
 801b898:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801b89c:	681b      	ldr	r3, [r3, #0]
 801b89e:	441a      	add	r2, r3
 801b8a0:	f107 0318 	add.w	r3, r7, #24
 801b8a4:	681b      	ldr	r3, [r3, #0]
 801b8a6:	601a      	str	r2, [r3, #0]
			carry = (1000000000>>sh) * rm;
 801b8a8:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801b8ac:	4a8d      	ldr	r2, [pc, #564]	; (801bae4 <fmt_fp+0xc0c>)
 801b8ae:	681b      	ldr	r3, [r3, #0]
 801b8b0:	fa42 f303 	asr.w	r3, r2, r3
 801b8b4:	4619      	mov	r1, r3
 801b8b6:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801b8ba:	f107 0274 	add.w	r2, r7, #116	; 0x74
 801b8be:	6812      	ldr	r2, [r2, #0]
 801b8c0:	fb01 f202 	mul.w	r2, r1, r2
 801b8c4:	601a      	str	r2, [r3, #0]
		for (d=a; d<z; d++) {
 801b8c6:	f107 0318 	add.w	r3, r7, #24
 801b8ca:	f107 0218 	add.w	r2, r7, #24
 801b8ce:	6812      	ldr	r2, [r2, #0]
 801b8d0:	3204      	adds	r2, #4
 801b8d2:	601a      	str	r2, [r3, #0]
 801b8d4:	f107 0218 	add.w	r2, r7, #24
 801b8d8:	f107 0320 	add.w	r3, r7, #32
 801b8dc:	6812      	ldr	r2, [r2, #0]
 801b8de:	681b      	ldr	r3, [r3, #0]
 801b8e0:	429a      	cmp	r2, r3
 801b8e2:	d3c1      	bcc.n	801b868 <fmt_fp+0x990>
		}
		if (!*a) a++;
 801b8e4:	f107 0314 	add.w	r3, r7, #20
 801b8e8:	681b      	ldr	r3, [r3, #0]
 801b8ea:	681b      	ldr	r3, [r3, #0]
 801b8ec:	2b00      	cmp	r3, #0
 801b8ee:	d106      	bne.n	801b8fe <fmt_fp+0xa26>
 801b8f0:	f107 0314 	add.w	r3, r7, #20
 801b8f4:	f107 0214 	add.w	r2, r7, #20
 801b8f8:	6812      	ldr	r2, [r2, #0]
 801b8fa:	3204      	adds	r2, #4
 801b8fc:	601a      	str	r2, [r3, #0]
		if (carry) *z++ = carry;
 801b8fe:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801b902:	681b      	ldr	r3, [r3, #0]
 801b904:	2b00      	cmp	r3, #0
 801b906:	d00a      	beq.n	801b91e <fmt_fp+0xa46>
 801b908:	f107 0320 	add.w	r3, r7, #32
 801b90c:	681b      	ldr	r3, [r3, #0]
 801b90e:	f107 0220 	add.w	r2, r7, #32
 801b912:	1d19      	adds	r1, r3, #4
 801b914:	6011      	str	r1, [r2, #0]
 801b916:	f107 0250 	add.w	r2, r7, #80	; 0x50
 801b91a:	6812      	ldr	r2, [r2, #0]
 801b91c:	601a      	str	r2, [r3, #0]
		/* Avoid (slow!) computation past requested precision */
		b = (t|32)=='f' ? r : a;
 801b91e:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b922:	f043 0320 	orr.w	r3, r3, #32
 801b926:	2b66      	cmp	r3, #102	; 0x66
 801b928:	d103      	bne.n	801b932 <fmt_fp+0xa5a>
 801b92a:	f107 031c 	add.w	r3, r7, #28
 801b92e:	681b      	ldr	r3, [r3, #0]
 801b930:	e002      	b.n	801b938 <fmt_fp+0xa60>
 801b932:	f107 0314 	add.w	r3, r7, #20
 801b936:	681b      	ldr	r3, [r3, #0]
 801b938:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801b93c:	6013      	str	r3, [r2, #0]
		if (z-b > need) z = b+need;
 801b93e:	f107 0220 	add.w	r2, r7, #32
 801b942:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801b946:	6812      	ldr	r2, [r2, #0]
 801b948:	681b      	ldr	r3, [r3, #0]
 801b94a:	1ad3      	subs	r3, r2, r3
 801b94c:	109b      	asrs	r3, r3, #2
 801b94e:	461a      	mov	r2, r3
 801b950:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801b954:	681b      	ldr	r3, [r3, #0]
 801b956:	4293      	cmp	r3, r2
 801b958:	da0a      	bge.n	801b970 <fmt_fp+0xa98>
 801b95a:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801b95e:	681b      	ldr	r3, [r3, #0]
 801b960:	009a      	lsls	r2, r3, #2
 801b962:	f107 0320 	add.w	r3, r7, #32
 801b966:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801b96a:	6809      	ldr	r1, [r1, #0]
 801b96c:	440a      	add	r2, r1
 801b96e:	601a      	str	r2, [r3, #0]
		e2+=sh;
 801b970:	f107 0310 	add.w	r3, r7, #16
 801b974:	681a      	ldr	r2, [r3, #0]
 801b976:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801b97a:	681b      	ldr	r3, [r3, #0]
 801b97c:	441a      	add	r2, r3
 801b97e:	f107 0310 	add.w	r3, r7, #16
 801b982:	601a      	str	r2, [r3, #0]
	while (e2<0) {
 801b984:	f107 0310 	add.w	r3, r7, #16
 801b988:	681b      	ldr	r3, [r3, #0]
 801b98a:	2b00      	cmp	r3, #0
 801b98c:	f6ff af38 	blt.w	801b800 <fmt_fp+0x928>
	}

	if (a<z) for (i=10, e=9*(r-a); *a>=(uint32_t)i; i*=10, e++);
 801b990:	f107 0214 	add.w	r2, r7, #20
 801b994:	f107 0320 	add.w	r3, r7, #32
 801b998:	6812      	ldr	r2, [r2, #0]
 801b99a:	681b      	ldr	r3, [r3, #0]
 801b99c:	429a      	cmp	r2, r3
 801b99e:	d22e      	bcs.n	801b9fe <fmt_fp+0xb26>
 801b9a0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801b9a4:	220a      	movs	r2, #10
 801b9a6:	601a      	str	r2, [r3, #0]
 801b9a8:	f107 021c 	add.w	r2, r7, #28
 801b9ac:	f107 0314 	add.w	r3, r7, #20
 801b9b0:	6812      	ldr	r2, [r2, #0]
 801b9b2:	681b      	ldr	r3, [r3, #0]
 801b9b4:	1ad3      	subs	r3, r2, r3
 801b9b6:	109b      	asrs	r3, r3, #2
 801b9b8:	4619      	mov	r1, r3
 801b9ba:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801b9be:	460b      	mov	r3, r1
 801b9c0:	00db      	lsls	r3, r3, #3
 801b9c2:	440b      	add	r3, r1
 801b9c4:	6013      	str	r3, [r2, #0]
 801b9c6:	e010      	b.n	801b9ea <fmt_fp+0xb12>
 801b9c8:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801b9cc:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801b9d0:	681a      	ldr	r2, [r3, #0]
 801b9d2:	4613      	mov	r3, r2
 801b9d4:	009b      	lsls	r3, r3, #2
 801b9d6:	4413      	add	r3, r2
 801b9d8:	005b      	lsls	r3, r3, #1
 801b9da:	600b      	str	r3, [r1, #0]
 801b9dc:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801b9e0:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801b9e4:	6812      	ldr	r2, [r2, #0]
 801b9e6:	3201      	adds	r2, #1
 801b9e8:	601a      	str	r2, [r3, #0]
 801b9ea:	f107 0314 	add.w	r3, r7, #20
 801b9ee:	681b      	ldr	r3, [r3, #0]
 801b9f0:	681a      	ldr	r2, [r3, #0]
 801b9f2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801b9f6:	681b      	ldr	r3, [r3, #0]
 801b9f8:	429a      	cmp	r2, r3
 801b9fa:	d2e5      	bcs.n	801b9c8 <fmt_fp+0xaf0>
 801b9fc:	e003      	b.n	801ba06 <fmt_fp+0xb2e>
	else e=0;
 801b9fe:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801ba02:	2200      	movs	r2, #0
 801ba04:	601a      	str	r2, [r3, #0]

	/* Perform rounding: j is precision after the radix (possibly neg) */
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
 801ba06:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801ba0a:	f043 0320 	orr.w	r3, r3, #32
 801ba0e:	2b66      	cmp	r3, #102	; 0x66
 801ba10:	bf14      	ite	ne
 801ba12:	2301      	movne	r3, #1
 801ba14:	2300      	moveq	r3, #0
 801ba16:	b2db      	uxtb	r3, r3
 801ba18:	461a      	mov	r2, r3
 801ba1a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801ba1e:	681b      	ldr	r3, [r3, #0]
 801ba20:	fb03 f302 	mul.w	r3, r3, r2
 801ba24:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801ba28:	1ad1      	subs	r1, r2, r3
 801ba2a:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801ba2e:	f043 0320 	orr.w	r3, r3, #32
 801ba32:	2b67      	cmp	r3, #103	; 0x67
 801ba34:	d105      	bne.n	801ba42 <fmt_fp+0xb6a>
 801ba36:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801ba3a:	2b00      	cmp	r3, #0
 801ba3c:	d001      	beq.n	801ba42 <fmt_fp+0xb6a>
 801ba3e:	2201      	movs	r2, #1
 801ba40:	e000      	b.n	801ba44 <fmt_fp+0xb6c>
 801ba42:	2200      	movs	r2, #0
 801ba44:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801ba48:	1a8a      	subs	r2, r1, r2
 801ba4a:	601a      	str	r2, [r3, #0]
	if (j < 9*(z-r-1)) {
 801ba4c:	f107 0220 	add.w	r2, r7, #32
 801ba50:	f107 031c 	add.w	r3, r7, #28
 801ba54:	6812      	ldr	r2, [r2, #0]
 801ba56:	681b      	ldr	r3, [r3, #0]
 801ba58:	1ad3      	subs	r3, r2, r3
 801ba5a:	109b      	asrs	r3, r3, #2
 801ba5c:	1e5a      	subs	r2, r3, #1
 801ba5e:	4613      	mov	r3, r2
 801ba60:	00db      	lsls	r3, r3, #3
 801ba62:	4413      	add	r3, r2
 801ba64:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 801ba68:	6812      	ldr	r2, [r2, #0]
 801ba6a:	429a      	cmp	r2, r3
 801ba6c:	f280 81a9 	bge.w	801bdc2 <fmt_fp+0xeea>
		uint32_t x;
		/* We avoid C's broken division of negative numbers */
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
 801ba70:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801ba74:	681b      	ldr	r3, [r3, #0]
 801ba76:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
 801ba7a:	4a1b      	ldr	r2, [pc, #108]	; (801bae8 <fmt_fp+0xc10>)
 801ba7c:	fb82 1203 	smull	r1, r2, r2, r3
 801ba80:	1052      	asrs	r2, r2, #1
 801ba82:	17db      	asrs	r3, r3, #31
 801ba84:	1ad3      	subs	r3, r2, r3
 801ba86:	461a      	mov	r2, r3
 801ba88:	4b18      	ldr	r3, [pc, #96]	; (801baec <fmt_fp+0xc14>)
 801ba8a:	4413      	add	r3, r2
 801ba8c:	009a      	lsls	r2, r3, #2
 801ba8e:	f107 0318 	add.w	r3, r7, #24
 801ba92:	f107 011c 	add.w	r1, r7, #28
 801ba96:	6809      	ldr	r1, [r1, #0]
 801ba98:	440a      	add	r2, r1
 801ba9a:	601a      	str	r2, [r3, #0]
		j += 9*LDBL_MAX_EXP;
 801ba9c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801baa0:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 801baa4:	6812      	ldr	r2, [r2, #0]
 801baa6:	f502 5210 	add.w	r2, r2, #9216	; 0x2400
 801baaa:	601a      	str	r2, [r3, #0]
		j %= 9;
 801baac:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 801bab0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bab4:	681a      	ldr	r2, [r3, #0]
 801bab6:	4b0c      	ldr	r3, [pc, #48]	; (801bae8 <fmt_fp+0xc10>)
 801bab8:	fb83 1302 	smull	r1, r3, r3, r2
 801babc:	1059      	asrs	r1, r3, #1
 801babe:	17d3      	asrs	r3, r2, #31
 801bac0:	1ac9      	subs	r1, r1, r3
 801bac2:	460b      	mov	r3, r1
 801bac4:	00db      	lsls	r3, r3, #3
 801bac6:	440b      	add	r3, r1
 801bac8:	1ad3      	subs	r3, r2, r3
 801baca:	6003      	str	r3, [r0, #0]
		for (i=10, j++; j<9; i*=10, j++);
 801bacc:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bad0:	220a      	movs	r2, #10
 801bad2:	601a      	str	r2, [r3, #0]
 801bad4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bad8:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 801badc:	6812      	ldr	r2, [r2, #0]
 801bade:	3201      	adds	r2, #1
 801bae0:	601a      	str	r2, [r3, #0]
 801bae2:	e016      	b.n	801bb12 <fmt_fp+0xc3a>
 801bae4:	3b9aca00 	.word	0x3b9aca00
 801bae8:	38e38e39 	.word	0x38e38e39
 801baec:	3ffffc01 	.word	0x3ffffc01
 801baf0:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801baf4:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801baf8:	681a      	ldr	r2, [r3, #0]
 801bafa:	4613      	mov	r3, r2
 801bafc:	009b      	lsls	r3, r3, #2
 801bafe:	4413      	add	r3, r2
 801bb00:	005b      	lsls	r3, r3, #1
 801bb02:	600b      	str	r3, [r1, #0]
 801bb04:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bb08:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 801bb0c:	6812      	ldr	r2, [r2, #0]
 801bb0e:	3201      	adds	r2, #1
 801bb10:	601a      	str	r2, [r3, #0]
 801bb12:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bb16:	681b      	ldr	r3, [r3, #0]
 801bb18:	2b08      	cmp	r3, #8
 801bb1a:	dde9      	ble.n	801baf0 <fmt_fp+0xc18>
		x = *d % i;
 801bb1c:	f107 0318 	add.w	r3, r7, #24
 801bb20:	681b      	ldr	r3, [r3, #0]
 801bb22:	681b      	ldr	r3, [r3, #0]
 801bb24:	f107 0228 	add.w	r2, r7, #40	; 0x28
 801bb28:	6812      	ldr	r2, [r2, #0]
 801bb2a:	f107 0164 	add.w	r1, r7, #100	; 0x64
 801bb2e:	fbb3 f0f2 	udiv	r0, r3, r2
 801bb32:	fb02 f200 	mul.w	r2, r2, r0
 801bb36:	1a9b      	subs	r3, r3, r2
 801bb38:	600b      	str	r3, [r1, #0]
		/* Are there any significant digits past j? */
		if (x || d+1!=z) {
 801bb3a:	f107 0364 	add.w	r3, r7, #100	; 0x64
 801bb3e:	681b      	ldr	r3, [r3, #0]
 801bb40:	2b00      	cmp	r3, #0
 801bb42:	d109      	bne.n	801bb58 <fmt_fp+0xc80>
 801bb44:	f107 0318 	add.w	r3, r7, #24
 801bb48:	681b      	ldr	r3, [r3, #0]
 801bb4a:	3304      	adds	r3, #4
 801bb4c:	f107 0220 	add.w	r2, r7, #32
 801bb50:	6812      	ldr	r2, [r2, #0]
 801bb52:	429a      	cmp	r2, r3
 801bb54:	f000 811d 	beq.w	801bd92 <fmt_fp+0xeba>
			ldouble_t round = 2/LDBL_EPSILON;
 801bb58:	f107 0188 	add.w	r1, r7, #136	; 0x88
 801bb5c:	f04f 0200 	mov.w	r2, #0
 801bb60:	4bb5      	ldr	r3, [pc, #724]	; (801be38 <fmt_fp+0xf60>)
 801bb62:	e9c1 2300 	strd	r2, r3, [r1]
			ldouble_t small;
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
 801bb66:	f107 0318 	add.w	r3, r7, #24
 801bb6a:	681b      	ldr	r3, [r3, #0]
 801bb6c:	681a      	ldr	r2, [r3, #0]
 801bb6e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bb72:	681b      	ldr	r3, [r3, #0]
 801bb74:	fbb2 f3f3 	udiv	r3, r2, r3
 801bb78:	f003 0301 	and.w	r3, r3, #1
 801bb7c:	2b00      	cmp	r3, #0
 801bb7e:	d116      	bne.n	801bbae <fmt_fp+0xcd6>
 801bb80:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bb84:	681b      	ldr	r3, [r3, #0]
 801bb86:	4aad      	ldr	r2, [pc, #692]	; (801be3c <fmt_fp+0xf64>)
 801bb88:	4293      	cmp	r3, r2
 801bb8a:	d120      	bne.n	801bbce <fmt_fp+0xcf6>
 801bb8c:	f107 0218 	add.w	r2, r7, #24
 801bb90:	f107 0314 	add.w	r3, r7, #20
 801bb94:	6812      	ldr	r2, [r2, #0]
 801bb96:	681b      	ldr	r3, [r3, #0]
 801bb98:	429a      	cmp	r2, r3
 801bb9a:	d918      	bls.n	801bbce <fmt_fp+0xcf6>
 801bb9c:	f107 0318 	add.w	r3, r7, #24
 801bba0:	681b      	ldr	r3, [r3, #0]
 801bba2:	3b04      	subs	r3, #4
 801bba4:	681b      	ldr	r3, [r3, #0]
 801bba6:	f003 0301 	and.w	r3, r3, #1
 801bbaa:	2b00      	cmp	r3, #0
 801bbac:	d00f      	beq.n	801bbce <fmt_fp+0xcf6>
				round += 2;
 801bbae:	f107 0488 	add.w	r4, r7, #136	; 0x88
 801bbb2:	f107 0188 	add.w	r1, r7, #136	; 0x88
 801bbb6:	f04f 0200 	mov.w	r2, #0
 801bbba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 801bbbe:	e9d1 0100 	ldrd	r0, r1, [r1]
 801bbc2:	f7e4 fb1f 	bl	8000204 <__adddf3>
 801bbc6:	4602      	mov	r2, r0
 801bbc8:	460b      	mov	r3, r1
 801bbca:	e9c4 2300 	strd	r2, r3, [r4]
			if (x<(uint32_t)(i/2)) small=0x0.8p0;
 801bbce:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bbd2:	681b      	ldr	r3, [r3, #0]
 801bbd4:	2b00      	cmp	r3, #0
 801bbd6:	da00      	bge.n	801bbda <fmt_fp+0xd02>
 801bbd8:	3301      	adds	r3, #1
 801bbda:	105b      	asrs	r3, r3, #1
 801bbdc:	461a      	mov	r2, r3
 801bbde:	f107 0364 	add.w	r3, r7, #100	; 0x64
 801bbe2:	681b      	ldr	r3, [r3, #0]
 801bbe4:	4293      	cmp	r3, r2
 801bbe6:	d207      	bcs.n	801bbf8 <fmt_fp+0xd20>
 801bbe8:	f107 0190 	add.w	r1, r7, #144	; 0x90
 801bbec:	f04f 0200 	mov.w	r2, #0
 801bbf0:	4b93      	ldr	r3, [pc, #588]	; (801be40 <fmt_fp+0xf68>)
 801bbf2:	e9c1 2300 	strd	r2, r3, [r1]
 801bbf6:	e024      	b.n	801bc42 <fmt_fp+0xd6a>
			else if ((int)x==i/2 && d+1==z) small=0x1.0p0;
 801bbf8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bbfc:	681b      	ldr	r3, [r3, #0]
 801bbfe:	2b00      	cmp	r3, #0
 801bc00:	da00      	bge.n	801bc04 <fmt_fp+0xd2c>
 801bc02:	3301      	adds	r3, #1
 801bc04:	105b      	asrs	r3, r3, #1
 801bc06:	461a      	mov	r2, r3
 801bc08:	f107 0364 	add.w	r3, r7, #100	; 0x64
 801bc0c:	681b      	ldr	r3, [r3, #0]
 801bc0e:	429a      	cmp	r2, r3
 801bc10:	d110      	bne.n	801bc34 <fmt_fp+0xd5c>
 801bc12:	f107 0318 	add.w	r3, r7, #24
 801bc16:	681b      	ldr	r3, [r3, #0]
 801bc18:	3304      	adds	r3, #4
 801bc1a:	f107 0220 	add.w	r2, r7, #32
 801bc1e:	6812      	ldr	r2, [r2, #0]
 801bc20:	429a      	cmp	r2, r3
 801bc22:	d107      	bne.n	801bc34 <fmt_fp+0xd5c>
 801bc24:	f107 0190 	add.w	r1, r7, #144	; 0x90
 801bc28:	f04f 0200 	mov.w	r2, #0
 801bc2c:	4b85      	ldr	r3, [pc, #532]	; (801be44 <fmt_fp+0xf6c>)
 801bc2e:	e9c1 2300 	strd	r2, r3, [r1]
 801bc32:	e006      	b.n	801bc42 <fmt_fp+0xd6a>
			else small=0x1.8p0;
 801bc34:	f107 0190 	add.w	r1, r7, #144	; 0x90
 801bc38:	f04f 0200 	mov.w	r2, #0
 801bc3c:	4b82      	ldr	r3, [pc, #520]	; (801be48 <fmt_fp+0xf70>)
 801bc3e:	e9c1 2300 	strd	r2, r3, [r1]
			if (pl && *prefix=='-') round*=-1, small*=-1;
 801bc42:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801bc46:	681b      	ldr	r3, [r3, #0]
 801bc48:	2b00      	cmp	r3, #0
 801bc4a:	d019      	beq.n	801bc80 <fmt_fp+0xda8>
 801bc4c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801bc50:	681b      	ldr	r3, [r3, #0]
 801bc52:	781b      	ldrb	r3, [r3, #0]
 801bc54:	2b2d      	cmp	r3, #45	; 0x2d
 801bc56:	d113      	bne.n	801bc80 <fmt_fp+0xda8>
 801bc58:	f107 0388 	add.w	r3, r7, #136	; 0x88
 801bc5c:	f107 0288 	add.w	r2, r7, #136	; 0x88
 801bc60:	6811      	ldr	r1, [r2, #0]
 801bc62:	6019      	str	r1, [r3, #0]
 801bc64:	6852      	ldr	r2, [r2, #4]
 801bc66:	f082 4200 	eor.w	r2, r2, #2147483648	; 0x80000000
 801bc6a:	605a      	str	r2, [r3, #4]
 801bc6c:	f107 0390 	add.w	r3, r7, #144	; 0x90
 801bc70:	f107 0290 	add.w	r2, r7, #144	; 0x90
 801bc74:	6811      	ldr	r1, [r2, #0]
 801bc76:	6019      	str	r1, [r3, #0]
 801bc78:	6852      	ldr	r2, [r2, #4]
 801bc7a:	f082 4200 	eor.w	r2, r2, #2147483648	; 0x80000000
 801bc7e:	605a      	str	r2, [r3, #4]
			*d -= x;
 801bc80:	f107 0318 	add.w	r3, r7, #24
 801bc84:	681b      	ldr	r3, [r3, #0]
 801bc86:	681a      	ldr	r2, [r3, #0]
 801bc88:	f107 0364 	add.w	r3, r7, #100	; 0x64
 801bc8c:	681b      	ldr	r3, [r3, #0]
 801bc8e:	1ad2      	subs	r2, r2, r3
 801bc90:	f107 0318 	add.w	r3, r7, #24
 801bc94:	681b      	ldr	r3, [r3, #0]
 801bc96:	601a      	str	r2, [r3, #0]
			/* Decide whether to round by probing round+small */
			if (round+small != round) {
 801bc98:	f107 0188 	add.w	r1, r7, #136	; 0x88
 801bc9c:	f107 0390 	add.w	r3, r7, #144	; 0x90
 801bca0:	e9d3 2300 	ldrd	r2, r3, [r3]
 801bca4:	e9d1 0100 	ldrd	r0, r1, [r1]
 801bca8:	f7e4 faac 	bl	8000204 <__adddf3>
 801bcac:	4602      	mov	r2, r0
 801bcae:	460b      	mov	r3, r1
 801bcb0:	f107 0188 	add.w	r1, r7, #136	; 0x88
 801bcb4:	e9d1 0100 	ldrd	r0, r1, [r1]
 801bcb8:	f7e5 f98e 	bl	8000fd8 <__aeabi_dcmpeq>
 801bcbc:	4603      	mov	r3, r0
 801bcbe:	2b00      	cmp	r3, #0
 801bcc0:	d167      	bne.n	801bd92 <fmt_fp+0xeba>
				*d = *d + i;
 801bcc2:	f107 0318 	add.w	r3, r7, #24
 801bcc6:	681b      	ldr	r3, [r3, #0]
 801bcc8:	681a      	ldr	r2, [r3, #0]
 801bcca:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bcce:	681b      	ldr	r3, [r3, #0]
 801bcd0:	441a      	add	r2, r3
 801bcd2:	f107 0318 	add.w	r3, r7, #24
 801bcd6:	681b      	ldr	r3, [r3, #0]
 801bcd8:	601a      	str	r2, [r3, #0]
				while (*d > 999999999) {
 801bcda:	e025      	b.n	801bd28 <fmt_fp+0xe50>
					*d--=0;
 801bcdc:	f107 0318 	add.w	r3, r7, #24
 801bce0:	681b      	ldr	r3, [r3, #0]
 801bce2:	f107 0218 	add.w	r2, r7, #24
 801bce6:	1f19      	subs	r1, r3, #4
 801bce8:	6011      	str	r1, [r2, #0]
 801bcea:	2200      	movs	r2, #0
 801bcec:	601a      	str	r2, [r3, #0]
					if (d<a) *--a=0;
 801bcee:	f107 0218 	add.w	r2, r7, #24
 801bcf2:	f107 0314 	add.w	r3, r7, #20
 801bcf6:	6812      	ldr	r2, [r2, #0]
 801bcf8:	681b      	ldr	r3, [r3, #0]
 801bcfa:	429a      	cmp	r2, r3
 801bcfc:	d20b      	bcs.n	801bd16 <fmt_fp+0xe3e>
 801bcfe:	f107 0314 	add.w	r3, r7, #20
 801bd02:	f107 0214 	add.w	r2, r7, #20
 801bd06:	6812      	ldr	r2, [r2, #0]
 801bd08:	3a04      	subs	r2, #4
 801bd0a:	601a      	str	r2, [r3, #0]
 801bd0c:	f107 0314 	add.w	r3, r7, #20
 801bd10:	681b      	ldr	r3, [r3, #0]
 801bd12:	2200      	movs	r2, #0
 801bd14:	601a      	str	r2, [r3, #0]
					(*d)++;
 801bd16:	f107 0318 	add.w	r3, r7, #24
 801bd1a:	681b      	ldr	r3, [r3, #0]
 801bd1c:	681b      	ldr	r3, [r3, #0]
 801bd1e:	1c5a      	adds	r2, r3, #1
 801bd20:	f107 0318 	add.w	r3, r7, #24
 801bd24:	681b      	ldr	r3, [r3, #0]
 801bd26:	601a      	str	r2, [r3, #0]
				while (*d > 999999999) {
 801bd28:	f107 0318 	add.w	r3, r7, #24
 801bd2c:	681b      	ldr	r3, [r3, #0]
 801bd2e:	681b      	ldr	r3, [r3, #0]
 801bd30:	4a46      	ldr	r2, [pc, #280]	; (801be4c <fmt_fp+0xf74>)
 801bd32:	4293      	cmp	r3, r2
 801bd34:	d8d2      	bhi.n	801bcdc <fmt_fp+0xe04>
				}
				for (i=10, e=9*(r-a); *a>=(uint32_t)i; i*=10, e++);
 801bd36:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bd3a:	220a      	movs	r2, #10
 801bd3c:	601a      	str	r2, [r3, #0]
 801bd3e:	f107 021c 	add.w	r2, r7, #28
 801bd42:	f107 0314 	add.w	r3, r7, #20
 801bd46:	6812      	ldr	r2, [r2, #0]
 801bd48:	681b      	ldr	r3, [r3, #0]
 801bd4a:	1ad3      	subs	r3, r2, r3
 801bd4c:	109b      	asrs	r3, r3, #2
 801bd4e:	4619      	mov	r1, r3
 801bd50:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801bd54:	460b      	mov	r3, r1
 801bd56:	00db      	lsls	r3, r3, #3
 801bd58:	440b      	add	r3, r1
 801bd5a:	6013      	str	r3, [r2, #0]
 801bd5c:	e010      	b.n	801bd80 <fmt_fp+0xea8>
 801bd5e:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801bd62:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bd66:	681a      	ldr	r2, [r3, #0]
 801bd68:	4613      	mov	r3, r2
 801bd6a:	009b      	lsls	r3, r3, #2
 801bd6c:	4413      	add	r3, r2
 801bd6e:	005b      	lsls	r3, r3, #1
 801bd70:	600b      	str	r3, [r1, #0]
 801bd72:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801bd76:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801bd7a:	6812      	ldr	r2, [r2, #0]
 801bd7c:	3201      	adds	r2, #1
 801bd7e:	601a      	str	r2, [r3, #0]
 801bd80:	f107 0314 	add.w	r3, r7, #20
 801bd84:	681b      	ldr	r3, [r3, #0]
 801bd86:	681a      	ldr	r2, [r3, #0]
 801bd88:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bd8c:	681b      	ldr	r3, [r3, #0]
 801bd8e:	429a      	cmp	r2, r3
 801bd90:	d2e5      	bcs.n	801bd5e <fmt_fp+0xe86>
			}
		}
		if (z>d+1) z=d+1;
 801bd92:	f107 0318 	add.w	r3, r7, #24
 801bd96:	681b      	ldr	r3, [r3, #0]
 801bd98:	3304      	adds	r3, #4
 801bd9a:	f107 0220 	add.w	r2, r7, #32
 801bd9e:	6812      	ldr	r2, [r2, #0]
 801bda0:	429a      	cmp	r2, r3
 801bda2:	d90e      	bls.n	801bdc2 <fmt_fp+0xeea>
 801bda4:	f107 0320 	add.w	r3, r7, #32
 801bda8:	f107 0218 	add.w	r2, r7, #24
 801bdac:	6812      	ldr	r2, [r2, #0]
 801bdae:	3204      	adds	r2, #4
 801bdb0:	601a      	str	r2, [r3, #0]
	}
	for (; z>a && !z[-1]; z--);
 801bdb2:	e006      	b.n	801bdc2 <fmt_fp+0xeea>
 801bdb4:	f107 0320 	add.w	r3, r7, #32
 801bdb8:	f107 0220 	add.w	r2, r7, #32
 801bdbc:	6812      	ldr	r2, [r2, #0]
 801bdbe:	3a04      	subs	r2, #4
 801bdc0:	601a      	str	r2, [r3, #0]
 801bdc2:	f107 0220 	add.w	r2, r7, #32
 801bdc6:	f107 0314 	add.w	r3, r7, #20
 801bdca:	6812      	ldr	r2, [r2, #0]
 801bdcc:	681b      	ldr	r3, [r3, #0]
 801bdce:	429a      	cmp	r2, r3
 801bdd0:	d906      	bls.n	801bde0 <fmt_fp+0xf08>
 801bdd2:	f107 0320 	add.w	r3, r7, #32
 801bdd6:	681b      	ldr	r3, [r3, #0]
 801bdd8:	3b04      	subs	r3, #4
 801bdda:	681b      	ldr	r3, [r3, #0]
 801bddc:	2b00      	cmp	r3, #0
 801bdde:	d0e9      	beq.n	801bdb4 <fmt_fp+0xedc>
	
	if ((t|32)=='g') {
 801bde0:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801bde4:	f043 0320 	orr.w	r3, r3, #32
 801bde8:	2b67      	cmp	r3, #103	; 0x67
 801bdea:	f040 80bb 	bne.w	801bf64 <fmt_fp+0x108c>
		if (!p) p++;
 801bdee:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801bdf2:	2b00      	cmp	r3, #0
 801bdf4:	d104      	bne.n	801be00 <fmt_fp+0xf28>
 801bdf6:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801bdfa:	3301      	adds	r3, #1
 801bdfc:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
		if (p>e && e>=-4) {
 801be00:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801be04:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801be08:	681b      	ldr	r3, [r3, #0]
 801be0a:	429a      	cmp	r2, r3
 801be0c:	dd20      	ble.n	801be50 <fmt_fp+0xf78>
 801be0e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801be12:	681b      	ldr	r3, [r3, #0]
 801be14:	f113 0f04 	cmn.w	r3, #4
 801be18:	db1a      	blt.n	801be50 <fmt_fp+0xf78>
			t--;
 801be1a:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801be1e:	3b01      	subs	r3, #1
 801be20:	f8c7 32f4 	str.w	r3, [r7, #756]	; 0x2f4
			p-=e+1;
 801be24:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801be28:	681b      	ldr	r3, [r3, #0]
 801be2a:	3301      	adds	r3, #1
 801be2c:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801be30:	1ad3      	subs	r3, r2, r3
 801be32:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
 801be36:	e015      	b.n	801be64 <fmt_fp+0xf8c>
 801be38:	43400000 	.word	0x43400000
 801be3c:	3b9aca00 	.word	0x3b9aca00
 801be40:	3fe00000 	.word	0x3fe00000
 801be44:	3ff00000 	.word	0x3ff00000
 801be48:	3ff80000 	.word	0x3ff80000
 801be4c:	3b9ac9ff 	.word	0x3b9ac9ff
		} else {
			t-=2;
 801be50:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801be54:	3b02      	subs	r3, #2
 801be56:	f8c7 32f4 	str.w	r3, [r7, #756]	; 0x2f4
			p--;
 801be5a:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801be5e:	3b01      	subs	r3, #1
 801be60:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
		}
		if (!(fl&ALT_FORM)) {
 801be64:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801be68:	f003 0308 	and.w	r3, r3, #8
 801be6c:	2b00      	cmp	r3, #0
 801be6e:	d179      	bne.n	801bf64 <fmt_fp+0x108c>
			/* Count trailing zeros in last place */
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
 801be70:	f107 0220 	add.w	r2, r7, #32
 801be74:	f107 0314 	add.w	r3, r7, #20
 801be78:	6812      	ldr	r2, [r2, #0]
 801be7a:	681b      	ldr	r3, [r3, #0]
 801be7c:	429a      	cmp	r2, r3
 801be7e:	d930      	bls.n	801bee2 <fmt_fp+0x100a>
 801be80:	f107 0320 	add.w	r3, r7, #32
 801be84:	681b      	ldr	r3, [r3, #0]
 801be86:	3b04      	subs	r3, #4
 801be88:	681b      	ldr	r3, [r3, #0]
 801be8a:	2b00      	cmp	r3, #0
 801be8c:	d029      	beq.n	801bee2 <fmt_fp+0x100a>
 801be8e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801be92:	220a      	movs	r2, #10
 801be94:	601a      	str	r2, [r3, #0]
 801be96:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801be9a:	2200      	movs	r2, #0
 801be9c:	601a      	str	r2, [r3, #0]
 801be9e:	e010      	b.n	801bec2 <fmt_fp+0xfea>
 801bea0:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801bea4:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bea8:	681a      	ldr	r2, [r3, #0]
 801beaa:	4613      	mov	r3, r2
 801beac:	009b      	lsls	r3, r3, #2
 801beae:	4413      	add	r3, r2
 801beb0:	005b      	lsls	r3, r3, #1
 801beb2:	600b      	str	r3, [r1, #0]
 801beb4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801beb8:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 801bebc:	6812      	ldr	r2, [r2, #0]
 801bebe:	3201      	adds	r2, #1
 801bec0:	601a      	str	r2, [r3, #0]
 801bec2:	f107 0320 	add.w	r3, r7, #32
 801bec6:	681b      	ldr	r3, [r3, #0]
 801bec8:	3b04      	subs	r3, #4
 801beca:	681b      	ldr	r3, [r3, #0]
 801becc:	f107 0228 	add.w	r2, r7, #40	; 0x28
 801bed0:	6812      	ldr	r2, [r2, #0]
 801bed2:	fbb3 f1f2 	udiv	r1, r3, r2
 801bed6:	fb02 f201 	mul.w	r2, r2, r1
 801beda:	1a9b      	subs	r3, r3, r2
 801bedc:	2b00      	cmp	r3, #0
 801bede:	d0df      	beq.n	801bea0 <fmt_fp+0xfc8>
 801bee0:	e003      	b.n	801beea <fmt_fp+0x1012>
			else j=9;
 801bee2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bee6:	2209      	movs	r2, #9
 801bee8:	601a      	str	r2, [r3, #0]
			if ((t|32)=='f')
 801beea:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801beee:	f043 0320 	orr.w	r3, r3, #32
 801bef2:	2b66      	cmp	r3, #102	; 0x66
 801bef4:	d119      	bne.n	801bf2a <fmt_fp+0x1052>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
 801bef6:	f107 0220 	add.w	r2, r7, #32
 801befa:	f107 031c 	add.w	r3, r7, #28
 801befe:	6812      	ldr	r2, [r2, #0]
 801bf00:	681b      	ldr	r3, [r3, #0]
 801bf02:	1ad3      	subs	r3, r2, r3
 801bf04:	109b      	asrs	r3, r3, #2
 801bf06:	1e5a      	subs	r2, r3, #1
 801bf08:	4613      	mov	r3, r2
 801bf0a:	00db      	lsls	r3, r3, #3
 801bf0c:	441a      	add	r2, r3
 801bf0e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bf12:	681b      	ldr	r3, [r3, #0]
 801bf14:	1ad3      	subs	r3, r2, r3
 801bf16:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 801bf1a:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801bf1e:	4293      	cmp	r3, r2
 801bf20:	bfa8      	it	ge
 801bf22:	4613      	movge	r3, r2
 801bf24:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
 801bf28:	e01c      	b.n	801bf64 <fmt_fp+0x108c>
			else
				p = MIN(p,MAX(0,9*(z-r-1)+e-j));
 801bf2a:	f107 0220 	add.w	r2, r7, #32
 801bf2e:	f107 031c 	add.w	r3, r7, #28
 801bf32:	6812      	ldr	r2, [r2, #0]
 801bf34:	681b      	ldr	r3, [r3, #0]
 801bf36:	1ad3      	subs	r3, r2, r3
 801bf38:	109b      	asrs	r3, r3, #2
 801bf3a:	1e5a      	subs	r2, r3, #1
 801bf3c:	4613      	mov	r3, r2
 801bf3e:	00db      	lsls	r3, r3, #3
 801bf40:	441a      	add	r2, r3
 801bf42:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801bf46:	681b      	ldr	r3, [r3, #0]
 801bf48:	441a      	add	r2, r3
 801bf4a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bf4e:	681b      	ldr	r3, [r3, #0]
 801bf50:	1ad3      	subs	r3, r2, r3
 801bf52:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 801bf56:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801bf5a:	4293      	cmp	r3, r2
 801bf5c:	bfa8      	it	ge
 801bf5e:	4613      	movge	r3, r2
 801bf60:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
		}
	}
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
 801bf64:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801bf68:	2b00      	cmp	r3, #0
 801bf6a:	d105      	bne.n	801bf78 <fmt_fp+0x10a0>
 801bf6c:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801bf70:	f003 0308 	and.w	r3, r3, #8
 801bf74:	2b00      	cmp	r3, #0
 801bf76:	d001      	beq.n	801bf7c <fmt_fp+0x10a4>
 801bf78:	2201      	movs	r2, #1
 801bf7a:	e000      	b.n	801bf7e <fmt_fp+0x10a6>
 801bf7c:	2200      	movs	r2, #0
 801bf7e:	4bc5      	ldr	r3, [pc, #788]	; (801c294 <fmt_fp+0x13bc>)
 801bf80:	1a9b      	subs	r3, r3, r2
 801bf82:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801bf86:	429a      	cmp	r2, r3
 801bf88:	dd02      	ble.n	801bf90 <fmt_fp+0x10b8>
		return -1;
 801bf8a:	f04f 33ff 	mov.w	r3, #4294967295
 801bf8e:	e2b5      	b.n	801c4fc <fmt_fp+0x1624>
	l = 1 + p + (p || (fl&ALT_FORM));
 801bf90:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801bf94:	1c5a      	adds	r2, r3, #1
 801bf96:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801bf9a:	2b00      	cmp	r3, #0
 801bf9c:	d105      	bne.n	801bfaa <fmt_fp+0x10d2>
 801bf9e:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801bfa2:	f003 0308 	and.w	r3, r3, #8
 801bfa6:	2b00      	cmp	r3, #0
 801bfa8:	d001      	beq.n	801bfae <fmt_fp+0x10d6>
 801bfaa:	2101      	movs	r1, #1
 801bfac:	e000      	b.n	801bfb0 <fmt_fp+0x10d8>
 801bfae:	2100      	movs	r1, #0
 801bfb0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801bfb4:	440a      	add	r2, r1
 801bfb6:	601a      	str	r2, [r3, #0]
	if ((t|32)=='f') {
 801bfb8:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801bfbc:	f043 0320 	orr.w	r3, r3, #32
 801bfc0:	2b66      	cmp	r3, #102	; 0x66
 801bfc2:	d11d      	bne.n	801c000 <fmt_fp+0x1128>
		if (e > INT_MAX-l) return -1;
 801bfc4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801bfc8:	681a      	ldr	r2, [r3, #0]
 801bfca:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801bfce:	1a9b      	subs	r3, r3, r2
 801bfd0:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801bfd4:	6812      	ldr	r2, [r2, #0]
 801bfd6:	429a      	cmp	r2, r3
 801bfd8:	dd02      	ble.n	801bfe0 <fmt_fp+0x1108>
 801bfda:	f04f 33ff 	mov.w	r3, #4294967295
 801bfde:	e28d      	b.n	801c4fc <fmt_fp+0x1624>
		if (e>0) l+=e;
 801bfe0:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801bfe4:	681b      	ldr	r3, [r3, #0]
 801bfe6:	2b00      	cmp	r3, #0
 801bfe8:	dd73      	ble.n	801c0d2 <fmt_fp+0x11fa>
 801bfea:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801bfee:	f107 0130 	add.w	r1, r7, #48	; 0x30
 801bff2:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801bff6:	6809      	ldr	r1, [r1, #0]
 801bff8:	6812      	ldr	r2, [r2, #0]
 801bffa:	440a      	add	r2, r1
 801bffc:	601a      	str	r2, [r3, #0]
 801bffe:	e068      	b.n	801c0d2 <fmt_fp+0x11fa>
	} else {
		estr=fmt_u(e<0 ? -e : e, ebuf);
 801c000:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801c004:	681b      	ldr	r3, [r3, #0]
 801c006:	2b00      	cmp	r3, #0
 801c008:	bfb8      	it	lt
 801c00a:	425b      	neglt	r3, r3
 801c00c:	4618      	mov	r0, r3
 801c00e:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801c012:	f107 0440 	add.w	r4, r7, #64	; 0x40
 801c016:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801c01a:	681a      	ldr	r2, [r3, #0]
 801c01c:	f7fe ff0e 	bl	801ae3c <fmt_u>
 801c020:	6020      	str	r0, [r4, #0]
		while(ebuf-estr<2) *--estr='0';
 801c022:	e00b      	b.n	801c03c <fmt_fp+0x1164>
 801c024:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c028:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801c02c:	6812      	ldr	r2, [r2, #0]
 801c02e:	3a01      	subs	r2, #1
 801c030:	601a      	str	r2, [r3, #0]
 801c032:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c036:	681b      	ldr	r3, [r3, #0]
 801c038:	2230      	movs	r2, #48	; 0x30
 801c03a:	701a      	strb	r2, [r3, #0]
 801c03c:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801c040:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c044:	6812      	ldr	r2, [r2, #0]
 801c046:	681b      	ldr	r3, [r3, #0]
 801c048:	1ad3      	subs	r3, r2, r3
 801c04a:	2b01      	cmp	r3, #1
 801c04c:	ddea      	ble.n	801c024 <fmt_fp+0x114c>
		*--estr = (e<0 ? '-' : '+');
 801c04e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801c052:	681b      	ldr	r3, [r3, #0]
 801c054:	2b00      	cmp	r3, #0
 801c056:	da01      	bge.n	801c05c <fmt_fp+0x1184>
 801c058:	212d      	movs	r1, #45	; 0x2d
 801c05a:	e000      	b.n	801c05e <fmt_fp+0x1186>
 801c05c:	212b      	movs	r1, #43	; 0x2b
 801c05e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c062:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801c066:	6812      	ldr	r2, [r2, #0]
 801c068:	3a01      	subs	r2, #1
 801c06a:	601a      	str	r2, [r3, #0]
 801c06c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c070:	681b      	ldr	r3, [r3, #0]
 801c072:	460a      	mov	r2, r1
 801c074:	701a      	strb	r2, [r3, #0]
		*--estr = t;
 801c076:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c07a:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801c07e:	6812      	ldr	r2, [r2, #0]
 801c080:	3a01      	subs	r2, #1
 801c082:	601a      	str	r2, [r3, #0]
 801c084:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801c088:	b2da      	uxtb	r2, r3
 801c08a:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c08e:	681b      	ldr	r3, [r3, #0]
 801c090:	701a      	strb	r2, [r3, #0]
		if (ebuf-estr > INT_MAX-l) return -1;
 801c092:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801c096:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c09a:	6812      	ldr	r2, [r2, #0]
 801c09c:	681b      	ldr	r3, [r3, #0]
 801c09e:	1ad2      	subs	r2, r2, r3
 801c0a0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c0a4:	6819      	ldr	r1, [r3, #0]
 801c0a6:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c0aa:	1a5b      	subs	r3, r3, r1
 801c0ac:	429a      	cmp	r2, r3
 801c0ae:	dd02      	ble.n	801c0b6 <fmt_fp+0x11de>
 801c0b0:	f04f 33ff 	mov.w	r3, #4294967295
 801c0b4:	e222      	b.n	801c4fc <fmt_fp+0x1624>
		l += ebuf-estr;
 801c0b6:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801c0ba:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c0be:	6812      	ldr	r2, [r2, #0]
 801c0c0:	681b      	ldr	r3, [r3, #0]
 801c0c2:	1ad2      	subs	r2, r2, r3
 801c0c4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c0c8:	f107 0130 	add.w	r1, r7, #48	; 0x30
 801c0cc:	6809      	ldr	r1, [r1, #0]
 801c0ce:	440a      	add	r2, r1
 801c0d0:	601a      	str	r2, [r3, #0]
	}

	if (l > INT_MAX-pl) return -1;
 801c0d2:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801c0d6:	681a      	ldr	r2, [r3, #0]
 801c0d8:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c0dc:	1a9b      	subs	r3, r3, r2
 801c0de:	f107 0230 	add.w	r2, r7, #48	; 0x30
 801c0e2:	6812      	ldr	r2, [r2, #0]
 801c0e4:	429a      	cmp	r2, r3
 801c0e6:	dd02      	ble.n	801c0ee <fmt_fp+0x1216>
 801c0e8:	f04f 33ff 	mov.w	r3, #4294967295
 801c0ec:	e206      	b.n	801c4fc <fmt_fp+0x1624>
	pad(f, ' ', w, pl+l, fl);
 801c0ee:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801c0f2:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c0f6:	6812      	ldr	r2, [r2, #0]
 801c0f8:	681b      	ldr	r3, [r3, #0]
 801c0fa:	441a      	add	r2, r3
 801c0fc:	f107 000c 	add.w	r0, r7, #12
 801c100:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c104:	9300      	str	r3, [sp, #0]
 801c106:	4613      	mov	r3, r2
 801c108:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801c10c:	2120      	movs	r1, #32
 801c10e:	6800      	ldr	r0, [r0, #0]
 801c110:	f7fe fdcc 	bl	801acac <pad>
	out(f, prefix, pl);
 801c114:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801c118:	681a      	ldr	r2, [r3, #0]
 801c11a:	f107 0138 	add.w	r1, r7, #56	; 0x38
 801c11e:	f107 030c 	add.w	r3, r7, #12
 801c122:	6809      	ldr	r1, [r1, #0]
 801c124:	6818      	ldr	r0, [r3, #0]
 801c126:	f7fe fdab 	bl	801ac80 <out>
	pad(f, '0', w, pl+l, fl^ZERO_PAD);
 801c12a:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801c12e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c132:	6812      	ldr	r2, [r2, #0]
 801c134:	681b      	ldr	r3, [r3, #0]
 801c136:	441a      	add	r2, r3
 801c138:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c13c:	f483 3380 	eor.w	r3, r3, #65536	; 0x10000
 801c140:	f107 000c 	add.w	r0, r7, #12
 801c144:	9300      	str	r3, [sp, #0]
 801c146:	4613      	mov	r3, r2
 801c148:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801c14c:	2130      	movs	r1, #48	; 0x30
 801c14e:	6800      	ldr	r0, [r0, #0]
 801c150:	f7fe fdac 	bl	801acac <pad>

	if ((t|32)=='f') {
 801c154:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801c158:	f043 0320 	orr.w	r3, r3, #32
 801c15c:	2b66      	cmp	r3, #102	; 0x66
 801c15e:	f040 80e4 	bne.w	801c32a <fmt_fp+0x1452>
		if (a>r) a=r;
 801c162:	f107 0214 	add.w	r2, r7, #20
 801c166:	f107 031c 	add.w	r3, r7, #28
 801c16a:	6812      	ldr	r2, [r2, #0]
 801c16c:	681b      	ldr	r3, [r3, #0]
 801c16e:	429a      	cmp	r2, r3
 801c170:	d905      	bls.n	801c17e <fmt_fp+0x12a6>
 801c172:	f107 0314 	add.w	r3, r7, #20
 801c176:	f107 021c 	add.w	r2, r7, #28
 801c17a:	6812      	ldr	r2, [r2, #0]
 801c17c:	601a      	str	r2, [r3, #0]
		for (d=a; d<=r; d++) {
 801c17e:	f107 0318 	add.w	r3, r7, #24
 801c182:	f107 0214 	add.w	r2, r7, #20
 801c186:	6812      	ldr	r2, [r2, #0]
 801c188:	601a      	str	r2, [r3, #0]
 801c18a:	e057      	b.n	801c23c <fmt_fp+0x1364>
			char *s = fmt_u(*d, buf+9);
 801c18c:	f107 0318 	add.w	r3, r7, #24
 801c190:	681b      	ldr	r3, [r3, #0]
 801c192:	681b      	ldr	r3, [r3, #0]
 801c194:	4618      	mov	r0, r3
 801c196:	f04f 0100 	mov.w	r1, #0
 801c19a:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c19e:	3309      	adds	r3, #9
 801c1a0:	f107 0454 	add.w	r4, r7, #84	; 0x54
 801c1a4:	461a      	mov	r2, r3
 801c1a6:	f7fe fe49 	bl	801ae3c <fmt_u>
 801c1aa:	6020      	str	r0, [r4, #0]
			if (d!=a) while (s>buf) *--s='0';
 801c1ac:	f107 0218 	add.w	r2, r7, #24
 801c1b0:	f107 0314 	add.w	r3, r7, #20
 801c1b4:	6812      	ldr	r2, [r2, #0]
 801c1b6:	681b      	ldr	r3, [r3, #0]
 801c1b8:	429a      	cmp	r2, r3
 801c1ba:	d014      	beq.n	801c1e6 <fmt_fp+0x130e>
 801c1bc:	e00b      	b.n	801c1d6 <fmt_fp+0x12fe>
 801c1be:	f107 0354 	add.w	r3, r7, #84	; 0x54
 801c1c2:	f107 0254 	add.w	r2, r7, #84	; 0x54
 801c1c6:	6812      	ldr	r2, [r2, #0]
 801c1c8:	3a01      	subs	r2, #1
 801c1ca:	601a      	str	r2, [r3, #0]
 801c1cc:	f107 0354 	add.w	r3, r7, #84	; 0x54
 801c1d0:	681b      	ldr	r3, [r3, #0]
 801c1d2:	2230      	movs	r2, #48	; 0x30
 801c1d4:	701a      	strb	r2, [r3, #0]
 801c1d6:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c1da:	f107 0254 	add.w	r2, r7, #84	; 0x54
 801c1de:	6812      	ldr	r2, [r2, #0]
 801c1e0:	429a      	cmp	r2, r3
 801c1e2:	d8ec      	bhi.n	801c1be <fmt_fp+0x12e6>
 801c1e4:	e013      	b.n	801c20e <fmt_fp+0x1336>
			else if (s==buf+9) *--s='0';
 801c1e6:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c1ea:	3309      	adds	r3, #9
 801c1ec:	f107 0254 	add.w	r2, r7, #84	; 0x54
 801c1f0:	6812      	ldr	r2, [r2, #0]
 801c1f2:	429a      	cmp	r2, r3
 801c1f4:	d10b      	bne.n	801c20e <fmt_fp+0x1336>
 801c1f6:	f107 0354 	add.w	r3, r7, #84	; 0x54
 801c1fa:	f107 0254 	add.w	r2, r7, #84	; 0x54
 801c1fe:	6812      	ldr	r2, [r2, #0]
 801c200:	3a01      	subs	r2, #1
 801c202:	601a      	str	r2, [r3, #0]
 801c204:	f107 0354 	add.w	r3, r7, #84	; 0x54
 801c208:	681b      	ldr	r3, [r3, #0]
 801c20a:	2230      	movs	r2, #48	; 0x30
 801c20c:	701a      	strb	r2, [r3, #0]
			out(f, s, buf+9-s);
 801c20e:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c212:	3309      	adds	r3, #9
 801c214:	f107 0254 	add.w	r2, r7, #84	; 0x54
 801c218:	6812      	ldr	r2, [r2, #0]
 801c21a:	1a9b      	subs	r3, r3, r2
 801c21c:	461a      	mov	r2, r3
 801c21e:	f107 0154 	add.w	r1, r7, #84	; 0x54
 801c222:	f107 030c 	add.w	r3, r7, #12
 801c226:	6809      	ldr	r1, [r1, #0]
 801c228:	6818      	ldr	r0, [r3, #0]
 801c22a:	f7fe fd29 	bl	801ac80 <out>
		for (d=a; d<=r; d++) {
 801c22e:	f107 0318 	add.w	r3, r7, #24
 801c232:	f107 0218 	add.w	r2, r7, #24
 801c236:	6812      	ldr	r2, [r2, #0]
 801c238:	3204      	adds	r2, #4
 801c23a:	601a      	str	r2, [r3, #0]
 801c23c:	f107 0218 	add.w	r2, r7, #24
 801c240:	f107 031c 	add.w	r3, r7, #28
 801c244:	6812      	ldr	r2, [r2, #0]
 801c246:	681b      	ldr	r3, [r3, #0]
 801c248:	429a      	cmp	r2, r3
 801c24a:	d99f      	bls.n	801c18c <fmt_fp+0x12b4>
		}
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
 801c24c:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c250:	2b00      	cmp	r3, #0
 801c252:	d105      	bne.n	801c260 <fmt_fp+0x1388>
 801c254:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c258:	f003 0308 	and.w	r3, r3, #8
 801c25c:	2b00      	cmp	r3, #0
 801c25e:	d04a      	beq.n	801c2f6 <fmt_fp+0x141e>
 801c260:	f107 030c 	add.w	r3, r7, #12
 801c264:	2201      	movs	r2, #1
 801c266:	490c      	ldr	r1, [pc, #48]	; (801c298 <fmt_fp+0x13c0>)
 801c268:	6818      	ldr	r0, [r3, #0]
 801c26a:	f7fe fd09 	bl	801ac80 <out>
		for (; d<z && p>0; d++, p-=9) {
 801c26e:	e042      	b.n	801c2f6 <fmt_fp+0x141e>
			char *s = fmt_u(*d, buf+9);
 801c270:	f107 0318 	add.w	r3, r7, #24
 801c274:	681b      	ldr	r3, [r3, #0]
 801c276:	681b      	ldr	r3, [r3, #0]
 801c278:	4618      	mov	r0, r3
 801c27a:	f04f 0100 	mov.w	r1, #0
 801c27e:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c282:	3309      	adds	r3, #9
 801c284:	f107 0458 	add.w	r4, r7, #88	; 0x58
 801c288:	461a      	mov	r2, r3
 801c28a:	f7fe fdd7 	bl	801ae3c <fmt_u>
 801c28e:	6020      	str	r0, [r4, #0]
			while (s>buf) *--s='0';
 801c290:	e010      	b.n	801c2b4 <fmt_fp+0x13dc>
 801c292:	bf00      	nop
 801c294:	7ffffffe 	.word	0x7ffffffe
 801c298:	080231b0 	.word	0x080231b0
 801c29c:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801c2a0:	f107 0258 	add.w	r2, r7, #88	; 0x58
 801c2a4:	6812      	ldr	r2, [r2, #0]
 801c2a6:	3a01      	subs	r2, #1
 801c2a8:	601a      	str	r2, [r3, #0]
 801c2aa:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801c2ae:	681b      	ldr	r3, [r3, #0]
 801c2b0:	2230      	movs	r2, #48	; 0x30
 801c2b2:	701a      	strb	r2, [r3, #0]
 801c2b4:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c2b8:	f107 0258 	add.w	r2, r7, #88	; 0x58
 801c2bc:	6812      	ldr	r2, [r2, #0]
 801c2be:	429a      	cmp	r2, r3
 801c2c0:	d8ec      	bhi.n	801c29c <fmt_fp+0x13c4>
			out(f, s, MIN(9,p));
 801c2c2:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c2c6:	2b09      	cmp	r3, #9
 801c2c8:	bfa8      	it	ge
 801c2ca:	2309      	movge	r3, #9
 801c2cc:	461a      	mov	r2, r3
 801c2ce:	f107 0158 	add.w	r1, r7, #88	; 0x58
 801c2d2:	f107 030c 	add.w	r3, r7, #12
 801c2d6:	6809      	ldr	r1, [r1, #0]
 801c2d8:	6818      	ldr	r0, [r3, #0]
 801c2da:	f7fe fcd1 	bl	801ac80 <out>
		for (; d<z && p>0; d++, p-=9) {
 801c2de:	f107 0318 	add.w	r3, r7, #24
 801c2e2:	f107 0218 	add.w	r2, r7, #24
 801c2e6:	6812      	ldr	r2, [r2, #0]
 801c2e8:	3204      	adds	r2, #4
 801c2ea:	601a      	str	r2, [r3, #0]
 801c2ec:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c2f0:	3b09      	subs	r3, #9
 801c2f2:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
 801c2f6:	f107 0218 	add.w	r2, r7, #24
 801c2fa:	f107 0320 	add.w	r3, r7, #32
 801c2fe:	6812      	ldr	r2, [r2, #0]
 801c300:	681b      	ldr	r3, [r3, #0]
 801c302:	429a      	cmp	r2, r3
 801c304:	d203      	bcs.n	801c30e <fmt_fp+0x1436>
 801c306:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c30a:	2b00      	cmp	r3, #0
 801c30c:	dcb0      	bgt.n	801c270 <fmt_fp+0x1398>
		}
		pad(f, '0', p+9, 9, 0);
 801c30e:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c312:	f103 0209 	add.w	r2, r3, #9
 801c316:	f107 000c 	add.w	r0, r7, #12
 801c31a:	2300      	movs	r3, #0
 801c31c:	9300      	str	r3, [sp, #0]
 801c31e:	2309      	movs	r3, #9
 801c320:	2130      	movs	r1, #48	; 0x30
 801c322:	6800      	ldr	r0, [r0, #0]
 801c324:	f7fe fcc2 	bl	801acac <pad>
 801c328:	e0c7      	b.n	801c4ba <fmt_fp+0x15e2>
	} else {
		if (z<=a) z=a+1;
 801c32a:	f107 0220 	add.w	r2, r7, #32
 801c32e:	f107 0314 	add.w	r3, r7, #20
 801c332:	6812      	ldr	r2, [r2, #0]
 801c334:	681b      	ldr	r3, [r3, #0]
 801c336:	429a      	cmp	r2, r3
 801c338:	d806      	bhi.n	801c348 <fmt_fp+0x1470>
 801c33a:	f107 0320 	add.w	r3, r7, #32
 801c33e:	f107 0214 	add.w	r2, r7, #20
 801c342:	6812      	ldr	r2, [r2, #0]
 801c344:	3204      	adds	r2, #4
 801c346:	601a      	str	r2, [r3, #0]
		for (d=a; d<z && p>=0; d++) {
 801c348:	f107 0318 	add.w	r3, r7, #24
 801c34c:	f107 0214 	add.w	r2, r7, #20
 801c350:	6812      	ldr	r2, [r2, #0]
 801c352:	601a      	str	r2, [r3, #0]
 801c354:	e087      	b.n	801c466 <fmt_fp+0x158e>
			char *s = fmt_u(*d, buf+9);
 801c356:	f107 0318 	add.w	r3, r7, #24
 801c35a:	681b      	ldr	r3, [r3, #0]
 801c35c:	681b      	ldr	r3, [r3, #0]
 801c35e:	4618      	mov	r0, r3
 801c360:	f04f 0100 	mov.w	r1, #0
 801c364:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c368:	3309      	adds	r3, #9
 801c36a:	f107 045c 	add.w	r4, r7, #92	; 0x5c
 801c36e:	461a      	mov	r2, r3
 801c370:	f7fe fd64 	bl	801ae3c <fmt_u>
 801c374:	6020      	str	r0, [r4, #0]
			if (s==buf+9) *--s='0';
 801c376:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c37a:	3309      	adds	r3, #9
 801c37c:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c380:	6812      	ldr	r2, [r2, #0]
 801c382:	429a      	cmp	r2, r3
 801c384:	d10b      	bne.n	801c39e <fmt_fp+0x14c6>
 801c386:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801c38a:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c38e:	6812      	ldr	r2, [r2, #0]
 801c390:	3a01      	subs	r2, #1
 801c392:	601a      	str	r2, [r3, #0]
 801c394:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801c398:	681b      	ldr	r3, [r3, #0]
 801c39a:	2230      	movs	r2, #48	; 0x30
 801c39c:	701a      	strb	r2, [r3, #0]
			if (d!=a) while (s>buf) *--s='0';
 801c39e:	f107 0218 	add.w	r2, r7, #24
 801c3a2:	f107 0314 	add.w	r3, r7, #20
 801c3a6:	6812      	ldr	r2, [r2, #0]
 801c3a8:	681b      	ldr	r3, [r3, #0]
 801c3aa:	429a      	cmp	r2, r3
 801c3ac:	d014      	beq.n	801c3d8 <fmt_fp+0x1500>
 801c3ae:	e00b      	b.n	801c3c8 <fmt_fp+0x14f0>
 801c3b0:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801c3b4:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c3b8:	6812      	ldr	r2, [r2, #0]
 801c3ba:	3a01      	subs	r2, #1
 801c3bc:	601a      	str	r2, [r3, #0]
 801c3be:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801c3c2:	681b      	ldr	r3, [r3, #0]
 801c3c4:	2230      	movs	r2, #48	; 0x30
 801c3c6:	701a      	strb	r2, [r3, #0]
 801c3c8:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c3cc:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c3d0:	6812      	ldr	r2, [r2, #0]
 801c3d2:	429a      	cmp	r2, r3
 801c3d4:	d8ec      	bhi.n	801c3b0 <fmt_fp+0x14d8>
 801c3d6:	e01e      	b.n	801c416 <fmt_fp+0x153e>
			else {
				out(f, s++, 1);
 801c3d8:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801c3dc:	681b      	ldr	r3, [r3, #0]
 801c3de:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c3e2:	1c59      	adds	r1, r3, #1
 801c3e4:	6011      	str	r1, [r2, #0]
 801c3e6:	f107 000c 	add.w	r0, r7, #12
 801c3ea:	2201      	movs	r2, #1
 801c3ec:	4619      	mov	r1, r3
 801c3ee:	6800      	ldr	r0, [r0, #0]
 801c3f0:	f7fe fc46 	bl	801ac80 <out>
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
 801c3f4:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c3f8:	2b00      	cmp	r3, #0
 801c3fa:	dc05      	bgt.n	801c408 <fmt_fp+0x1530>
 801c3fc:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c400:	f003 0308 	and.w	r3, r3, #8
 801c404:	2b00      	cmp	r3, #0
 801c406:	d006      	beq.n	801c416 <fmt_fp+0x153e>
 801c408:	f107 030c 	add.w	r3, r7, #12
 801c40c:	2201      	movs	r2, #1
 801c40e:	4942      	ldr	r1, [pc, #264]	; (801c518 <fmt_fp+0x1640>)
 801c410:	6818      	ldr	r0, [r3, #0]
 801c412:	f7fe fc35 	bl	801ac80 <out>
			}
			out(f, s, MIN(buf+9-s, p));
 801c416:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c41a:	3309      	adds	r3, #9
 801c41c:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c420:	6812      	ldr	r2, [r2, #0]
 801c422:	1a9a      	subs	r2, r3, r2
 801c424:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c428:	4293      	cmp	r3, r2
 801c42a:	bfa8      	it	ge
 801c42c:	4613      	movge	r3, r2
 801c42e:	461a      	mov	r2, r3
 801c430:	f107 015c 	add.w	r1, r7, #92	; 0x5c
 801c434:	f107 030c 	add.w	r3, r7, #12
 801c438:	6809      	ldr	r1, [r1, #0]
 801c43a:	6818      	ldr	r0, [r3, #0]
 801c43c:	f7fe fc20 	bl	801ac80 <out>
			p -= buf+9-s;
 801c440:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c444:	3309      	adds	r3, #9
 801c446:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c44a:	6812      	ldr	r2, [r2, #0]
 801c44c:	1a9b      	subs	r3, r3, r2
 801c44e:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801c452:	1ad3      	subs	r3, r2, r3
 801c454:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
		for (d=a; d<z && p>=0; d++) {
 801c458:	f107 0318 	add.w	r3, r7, #24
 801c45c:	f107 0218 	add.w	r2, r7, #24
 801c460:	6812      	ldr	r2, [r2, #0]
 801c462:	3204      	adds	r2, #4
 801c464:	601a      	str	r2, [r3, #0]
 801c466:	f107 0218 	add.w	r2, r7, #24
 801c46a:	f107 0320 	add.w	r3, r7, #32
 801c46e:	6812      	ldr	r2, [r2, #0]
 801c470:	681b      	ldr	r3, [r3, #0]
 801c472:	429a      	cmp	r2, r3
 801c474:	d204      	bcs.n	801c480 <fmt_fp+0x15a8>
 801c476:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c47a:	2b00      	cmp	r3, #0
 801c47c:	f6bf af6b 	bge.w	801c356 <fmt_fp+0x147e>
		}
		pad(f, '0', p+18, 18, 0);
 801c480:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c484:	f103 0212 	add.w	r2, r3, #18
 801c488:	f107 000c 	add.w	r0, r7, #12
 801c48c:	2300      	movs	r3, #0
 801c48e:	9300      	str	r3, [sp, #0]
 801c490:	2312      	movs	r3, #18
 801c492:	2130      	movs	r1, #48	; 0x30
 801c494:	6800      	ldr	r0, [r0, #0]
 801c496:	f7fe fc09 	bl	801acac <pad>
		out(f, estr, ebuf-estr);
 801c49a:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801c49e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c4a2:	6812      	ldr	r2, [r2, #0]
 801c4a4:	681b      	ldr	r3, [r3, #0]
 801c4a6:	1ad3      	subs	r3, r2, r3
 801c4a8:	461a      	mov	r2, r3
 801c4aa:	f107 0140 	add.w	r1, r7, #64	; 0x40
 801c4ae:	f107 030c 	add.w	r3, r7, #12
 801c4b2:	6809      	ldr	r1, [r1, #0]
 801c4b4:	6818      	ldr	r0, [r3, #0]
 801c4b6:	f7fe fbe3 	bl	801ac80 <out>
	}

	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
 801c4ba:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801c4be:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c4c2:	6812      	ldr	r2, [r2, #0]
 801c4c4:	681b      	ldr	r3, [r3, #0]
 801c4c6:	441a      	add	r2, r3
 801c4c8:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c4cc:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 801c4d0:	f107 000c 	add.w	r0, r7, #12
 801c4d4:	9300      	str	r3, [sp, #0]
 801c4d6:	4613      	mov	r3, r2
 801c4d8:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801c4dc:	2120      	movs	r1, #32
 801c4de:	6800      	ldr	r0, [r0, #0]
 801c4e0:	f7fe fbe4 	bl	801acac <pad>

	return MAX(w, pl+l);
 801c4e4:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801c4e8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c4ec:	6812      	ldr	r2, [r2, #0]
 801c4ee:	681b      	ldr	r3, [r3, #0]
 801c4f0:	441a      	add	r2, r3
 801c4f2:	f8d7 32e8 	ldr.w	r3, [r7, #744]	; 0x2e8
 801c4f6:	4293      	cmp	r3, r2
 801c4f8:	bfb8      	it	lt
 801c4fa:	4613      	movlt	r3, r2
}
 801c4fc:	4a07      	ldr	r2, [pc, #28]	; (801c51c <fmt_fp+0x1644>)
 801c4fe:	6811      	ldr	r1, [r2, #0]
 801c500:	f8d7 22bc 	ldr.w	r2, [r7, #700]	; 0x2bc
 801c504:	4051      	eors	r1, r2
 801c506:	d001      	beq.n	801c50c <fmt_fp+0x1634>
 801c508:	f7e7 ff6e 	bl	80043e8 <__stack_chk_fail>
 801c50c:	4618      	mov	r0, r3
 801c50e:	f507 7731 	add.w	r7, r7, #708	; 0x2c4
 801c512:	46bd      	mov	sp, r7
 801c514:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801c518:	080231b0 	.word	0x080231b0
 801c51c:	080231b4 	.word	0x080231b4

0801c520 <getint>:

static int getint(char **s) {
 801c520:	b480      	push	{r7}
 801c522:	b085      	sub	sp, #20
 801c524:	af00      	add	r7, sp, #0
 801c526:	6078      	str	r0, [r7, #4]
	int i;
	for (i=0; isdigit(**s); (*s)++) {
 801c528:	2300      	movs	r3, #0
 801c52a:	60fb      	str	r3, [r7, #12]
 801c52c:	e027      	b.n	801c57e <getint+0x5e>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
 801c52e:	68fb      	ldr	r3, [r7, #12]
 801c530:	4a19      	ldr	r2, [pc, #100]	; (801c598 <getint+0x78>)
 801c532:	4293      	cmp	r3, r2
 801c534:	d80e      	bhi.n	801c554 <getint+0x34>
 801c536:	687b      	ldr	r3, [r7, #4]
 801c538:	681b      	ldr	r3, [r3, #0]
 801c53a:	781b      	ldrb	r3, [r3, #0]
 801c53c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 801c540:	68fb      	ldr	r3, [r7, #12]
 801c542:	f06f 0109 	mvn.w	r1, #9
 801c546:	fb01 f103 	mul.w	r1, r1, r3
 801c54a:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c54e:	440b      	add	r3, r1
 801c550:	429a      	cmp	r2, r3
 801c552:	dd03      	ble.n	801c55c <getint+0x3c>
 801c554:	f04f 33ff 	mov.w	r3, #4294967295
 801c558:	60fb      	str	r3, [r7, #12]
 801c55a:	e00b      	b.n	801c574 <getint+0x54>
		else i = 10*i + (**s-'0');
 801c55c:	68fa      	ldr	r2, [r7, #12]
 801c55e:	4613      	mov	r3, r2
 801c560:	009b      	lsls	r3, r3, #2
 801c562:	4413      	add	r3, r2
 801c564:	005b      	lsls	r3, r3, #1
 801c566:	461a      	mov	r2, r3
 801c568:	687b      	ldr	r3, [r7, #4]
 801c56a:	681b      	ldr	r3, [r3, #0]
 801c56c:	781b      	ldrb	r3, [r3, #0]
 801c56e:	3b30      	subs	r3, #48	; 0x30
 801c570:	4413      	add	r3, r2
 801c572:	60fb      	str	r3, [r7, #12]
	for (i=0; isdigit(**s); (*s)++) {
 801c574:	687b      	ldr	r3, [r7, #4]
 801c576:	681b      	ldr	r3, [r3, #0]
 801c578:	1c5a      	adds	r2, r3, #1
 801c57a:	687b      	ldr	r3, [r7, #4]
 801c57c:	601a      	str	r2, [r3, #0]
 801c57e:	687b      	ldr	r3, [r7, #4]
 801c580:	681b      	ldr	r3, [r3, #0]
 801c582:	781b      	ldrb	r3, [r3, #0]
 801c584:	3b30      	subs	r3, #48	; 0x30
 801c586:	2b09      	cmp	r3, #9
 801c588:	d9d1      	bls.n	801c52e <getint+0xe>
	}
	return i;
 801c58a:	68fb      	ldr	r3, [r7, #12]
}
 801c58c:	4618      	mov	r0, r3
 801c58e:	3714      	adds	r7, #20
 801c590:	46bd      	mov	sp, r7
 801c592:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c596:	4770      	bx	lr
 801c598:	0ccccccc 	.word	0x0ccccccc

0801c59c <printf_core>:

static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg, int *nl_type)
{
 801c59c:	b580      	push	{r7, lr}
 801c59e:	b0ac      	sub	sp, #176	; 0xb0
 801c5a0:	af04      	add	r7, sp, #16
 801c5a2:	6178      	str	r0, [r7, #20]
 801c5a4:	6139      	str	r1, [r7, #16]
 801c5a6:	60fa      	str	r2, [r7, #12]
 801c5a8:	60bb      	str	r3, [r7, #8]
 801c5aa:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801c5ae:	607b      	str	r3, [r7, #4]
 801c5b0:	4ba0      	ldr	r3, [pc, #640]	; (801c834 <printf_core+0x298>)
 801c5b2:	681b      	ldr	r3, [r3, #0]
 801c5b4:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 801c5b8:	f04f 0300 	mov.w	r3, #0
	char *a, *z, *s=(char *)fmt;
 801c5bc:	693b      	ldr	r3, [r7, #16]
 801c5be:	61bb      	str	r3, [r7, #24]
	unsigned l10n=0, fl;
 801c5c0:	2300      	movs	r3, #0
 801c5c2:	627b      	str	r3, [r7, #36]	; 0x24
	int w, p, xp;
	union arg arg;
	int argpos;
	unsigned st, ps;
	int cnt=0, l=0;
 801c5c4:	2300      	movs	r3, #0
 801c5c6:	643b      	str	r3, [r7, #64]	; 0x40
 801c5c8:	2300      	movs	r3, #0
 801c5ca:	647b      	str	r3, [r7, #68]	; 0x44

	for (;;) {
		/* This error is only specified for snprintf, but since it's
		 * unspecified for other forms, do the same. Stop immediately
		 * on overflow; otherwise %n could produce wrong results. */
		if (l > INT_MAX - cnt) goto overflow;
 801c5cc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801c5ce:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c5d2:	1a9b      	subs	r3, r3, r2
 801c5d4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801c5d6:	429a      	cmp	r2, r3
 801c5d8:	f300 8488 	bgt.w	801ceec <printf_core+0x950>

		/* Update output count, end loop when fmt is exhausted */
		cnt += l;
 801c5dc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801c5de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c5e0:	4413      	add	r3, r2
 801c5e2:	643b      	str	r3, [r7, #64]	; 0x40
		if (!*s) break;
 801c5e4:	69bb      	ldr	r3, [r7, #24]
 801c5e6:	781b      	ldrb	r3, [r3, #0]
 801c5e8:	2b00      	cmp	r3, #0
 801c5ea:	f000 8431 	beq.w	801ce50 <printf_core+0x8b4>

		/* Handle literal text and %% format specifiers */
		for (a=s; *s && *s!='%'; s++);
 801c5ee:	69bb      	ldr	r3, [r7, #24]
 801c5f0:	61fb      	str	r3, [r7, #28]
 801c5f2:	e002      	b.n	801c5fa <printf_core+0x5e>
 801c5f4:	69bb      	ldr	r3, [r7, #24]
 801c5f6:	3301      	adds	r3, #1
 801c5f8:	61bb      	str	r3, [r7, #24]
 801c5fa:	69bb      	ldr	r3, [r7, #24]
 801c5fc:	781b      	ldrb	r3, [r3, #0]
 801c5fe:	2b00      	cmp	r3, #0
 801c600:	d003      	beq.n	801c60a <printf_core+0x6e>
 801c602:	69bb      	ldr	r3, [r7, #24]
 801c604:	781b      	ldrb	r3, [r3, #0]
 801c606:	2b25      	cmp	r3, #37	; 0x25
 801c608:	d1f4      	bne.n	801c5f4 <printf_core+0x58>
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
 801c60a:	69bb      	ldr	r3, [r7, #24]
 801c60c:	623b      	str	r3, [r7, #32]
 801c60e:	e005      	b.n	801c61c <printf_core+0x80>
 801c610:	6a3b      	ldr	r3, [r7, #32]
 801c612:	3301      	adds	r3, #1
 801c614:	623b      	str	r3, [r7, #32]
 801c616:	69bb      	ldr	r3, [r7, #24]
 801c618:	3302      	adds	r3, #2
 801c61a:	61bb      	str	r3, [r7, #24]
 801c61c:	69bb      	ldr	r3, [r7, #24]
 801c61e:	781b      	ldrb	r3, [r3, #0]
 801c620:	2b25      	cmp	r3, #37	; 0x25
 801c622:	d104      	bne.n	801c62e <printf_core+0x92>
 801c624:	69bb      	ldr	r3, [r7, #24]
 801c626:	3301      	adds	r3, #1
 801c628:	781b      	ldrb	r3, [r3, #0]
 801c62a:	2b25      	cmp	r3, #37	; 0x25
 801c62c:	d0f0      	beq.n	801c610 <printf_core+0x74>
		if (z-a > INT_MAX-cnt) goto overflow;
 801c62e:	6a3a      	ldr	r2, [r7, #32]
 801c630:	69fb      	ldr	r3, [r7, #28]
 801c632:	1ad2      	subs	r2, r2, r3
 801c634:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801c636:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c63a:	1a5b      	subs	r3, r3, r1
 801c63c:	429a      	cmp	r2, r3
 801c63e:	f300 8457 	bgt.w	801cef0 <printf_core+0x954>
		l = z-a;
 801c642:	6a3a      	ldr	r2, [r7, #32]
 801c644:	69fb      	ldr	r3, [r7, #28]
 801c646:	1ad3      	subs	r3, r2, r3
 801c648:	647b      	str	r3, [r7, #68]	; 0x44
		if (f) out(f, a, l);
 801c64a:	697b      	ldr	r3, [r7, #20]
 801c64c:	2b00      	cmp	r3, #0
 801c64e:	d005      	beq.n	801c65c <printf_core+0xc0>
 801c650:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c652:	461a      	mov	r2, r3
 801c654:	69f9      	ldr	r1, [r7, #28]
 801c656:	6978      	ldr	r0, [r7, #20]
 801c658:	f7fe fb12 	bl	801ac80 <out>
		if (l) continue;
 801c65c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c65e:	2b00      	cmp	r3, #0
 801c660:	f040 83ea 	bne.w	801ce38 <printf_core+0x89c>

		if (isdigit(s[1]) && s[2]=='$') {
 801c664:	69bb      	ldr	r3, [r7, #24]
 801c666:	3301      	adds	r3, #1
 801c668:	781b      	ldrb	r3, [r3, #0]
 801c66a:	3b30      	subs	r3, #48	; 0x30
 801c66c:	2b09      	cmp	r3, #9
 801c66e:	d80f      	bhi.n	801c690 <printf_core+0xf4>
 801c670:	69bb      	ldr	r3, [r7, #24]
 801c672:	3302      	adds	r3, #2
 801c674:	781b      	ldrb	r3, [r3, #0]
 801c676:	2b24      	cmp	r3, #36	; 0x24
 801c678:	d10a      	bne.n	801c690 <printf_core+0xf4>
			l10n=1;
 801c67a:	2301      	movs	r3, #1
 801c67c:	627b      	str	r3, [r7, #36]	; 0x24
			argpos = s[1]-'0';
 801c67e:	69bb      	ldr	r3, [r7, #24]
 801c680:	3301      	adds	r3, #1
 801c682:	781b      	ldrb	r3, [r3, #0]
 801c684:	3b30      	subs	r3, #48	; 0x30
 801c686:	63bb      	str	r3, [r7, #56]	; 0x38
			s+=3;
 801c688:	69bb      	ldr	r3, [r7, #24]
 801c68a:	3303      	adds	r3, #3
 801c68c:	61bb      	str	r3, [r7, #24]
 801c68e:	e005      	b.n	801c69c <printf_core+0x100>
		} else {
			argpos = -1;
 801c690:	f04f 33ff 	mov.w	r3, #4294967295
 801c694:	63bb      	str	r3, [r7, #56]	; 0x38
			s++;
 801c696:	69bb      	ldr	r3, [r7, #24]
 801c698:	3301      	adds	r3, #1
 801c69a:	61bb      	str	r3, [r7, #24]
		}

		/* Read modifier flags */
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<(*s-' '))); s++)
 801c69c:	2300      	movs	r3, #0
 801c69e:	62bb      	str	r3, [r7, #40]	; 0x28
 801c6a0:	e00b      	b.n	801c6ba <printf_core+0x11e>
			fl |= 1U<<(*s-' ');
 801c6a2:	69bb      	ldr	r3, [r7, #24]
 801c6a4:	781b      	ldrb	r3, [r3, #0]
 801c6a6:	3b20      	subs	r3, #32
 801c6a8:	2201      	movs	r2, #1
 801c6aa:	fa02 f303 	lsl.w	r3, r2, r3
 801c6ae:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801c6b0:	4313      	orrs	r3, r2
 801c6b2:	62bb      	str	r3, [r7, #40]	; 0x28
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<(*s-' '))); s++)
 801c6b4:	69bb      	ldr	r3, [r7, #24]
 801c6b6:	3301      	adds	r3, #1
 801c6b8:	61bb      	str	r3, [r7, #24]
 801c6ba:	69bb      	ldr	r3, [r7, #24]
 801c6bc:	781b      	ldrb	r3, [r3, #0]
 801c6be:	3b20      	subs	r3, #32
 801c6c0:	2b1f      	cmp	r3, #31
 801c6c2:	d809      	bhi.n	801c6d8 <printf_core+0x13c>
 801c6c4:	69bb      	ldr	r3, [r7, #24]
 801c6c6:	781b      	ldrb	r3, [r3, #0]
 801c6c8:	3b20      	subs	r3, #32
 801c6ca:	4a5b      	ldr	r2, [pc, #364]	; (801c838 <printf_core+0x29c>)
 801c6cc:	fa22 f303 	lsr.w	r3, r2, r3
 801c6d0:	f003 0301 	and.w	r3, r3, #1
 801c6d4:	2b00      	cmp	r3, #0
 801c6d6:	d1e4      	bne.n	801c6a2 <printf_core+0x106>
		/* Read field width */
		if (*s=='*') {
 801c6d8:	69bb      	ldr	r3, [r7, #24]
 801c6da:	781b      	ldrb	r3, [r3, #0]
 801c6dc:	2b2a      	cmp	r3, #42	; 0x2a
 801c6de:	d146      	bne.n	801c76e <printf_core+0x1d2>
			if (isdigit(s[1]) && s[2]=='$') {
 801c6e0:	69bb      	ldr	r3, [r7, #24]
 801c6e2:	3301      	adds	r3, #1
 801c6e4:	781b      	ldrb	r3, [r3, #0]
 801c6e6:	3b30      	subs	r3, #48	; 0x30
 801c6e8:	2b09      	cmp	r3, #9
 801c6ea:	d822      	bhi.n	801c732 <printf_core+0x196>
 801c6ec:	69bb      	ldr	r3, [r7, #24]
 801c6ee:	3302      	adds	r3, #2
 801c6f0:	781b      	ldrb	r3, [r3, #0]
 801c6f2:	2b24      	cmp	r3, #36	; 0x24
 801c6f4:	d11d      	bne.n	801c732 <printf_core+0x196>
				l10n=1;
 801c6f6:	2301      	movs	r3, #1
 801c6f8:	627b      	str	r3, [r7, #36]	; 0x24
				nl_type[s[1]-'0'] = INT;
 801c6fa:	69bb      	ldr	r3, [r7, #24]
 801c6fc:	3301      	adds	r3, #1
 801c6fe:	781b      	ldrb	r3, [r3, #0]
 801c700:	461a      	mov	r2, r3
 801c702:	4b4e      	ldr	r3, [pc, #312]	; (801c83c <printf_core+0x2a0>)
 801c704:	4413      	add	r3, r2
 801c706:	009b      	lsls	r3, r3, #2
 801c708:	687a      	ldr	r2, [r7, #4]
 801c70a:	4413      	add	r3, r2
 801c70c:	220a      	movs	r2, #10
 801c70e:	601a      	str	r2, [r3, #0]
				w = nl_arg[s[1]-'0'].i;
 801c710:	69bb      	ldr	r3, [r7, #24]
 801c712:	3301      	adds	r3, #1
 801c714:	781b      	ldrb	r3, [r3, #0]
 801c716:	461a      	mov	r2, r3
 801c718:	4b49      	ldr	r3, [pc, #292]	; (801c840 <printf_core+0x2a4>)
 801c71a:	4413      	add	r3, r2
 801c71c:	00db      	lsls	r3, r3, #3
 801c71e:	68ba      	ldr	r2, [r7, #8]
 801c720:	4413      	add	r3, r2
 801c722:	e9d3 2300 	ldrd	r2, r3, [r3]
 801c726:	4613      	mov	r3, r2
 801c728:	62fb      	str	r3, [r7, #44]	; 0x2c
				s+=3;
 801c72a:	69bb      	ldr	r3, [r7, #24]
 801c72c:	3303      	adds	r3, #3
 801c72e:	61bb      	str	r3, [r7, #24]
 801c730:	e012      	b.n	801c758 <printf_core+0x1bc>
			} else if (!l10n) {
 801c732:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c734:	2b00      	cmp	r3, #0
 801c736:	f040 83c8 	bne.w	801ceca <printf_core+0x92e>
				w = f ? va_arg(*ap, int) : 0;
 801c73a:	697b      	ldr	r3, [r7, #20]
 801c73c:	2b00      	cmp	r3, #0
 801c73e:	d006      	beq.n	801c74e <printf_core+0x1b2>
 801c740:	68fb      	ldr	r3, [r7, #12]
 801c742:	681b      	ldr	r3, [r3, #0]
 801c744:	1d19      	adds	r1, r3, #4
 801c746:	68fa      	ldr	r2, [r7, #12]
 801c748:	6011      	str	r1, [r2, #0]
 801c74a:	681b      	ldr	r3, [r3, #0]
 801c74c:	e000      	b.n	801c750 <printf_core+0x1b4>
 801c74e:	2300      	movs	r3, #0
 801c750:	62fb      	str	r3, [r7, #44]	; 0x2c
				s++;
 801c752:	69bb      	ldr	r3, [r7, #24]
 801c754:	3301      	adds	r3, #1
 801c756:	61bb      	str	r3, [r7, #24]
			} else goto inval;
			if (w<0) fl|=LEFT_ADJ, w=-w;
 801c758:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c75a:	2b00      	cmp	r3, #0
 801c75c:	da11      	bge.n	801c782 <printf_core+0x1e6>
 801c75e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c760:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 801c764:	62bb      	str	r3, [r7, #40]	; 0x28
 801c766:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c768:	425b      	negs	r3, r3
 801c76a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801c76c:	e009      	b.n	801c782 <printf_core+0x1e6>
		} else if ((w=getint(&s))<0) goto overflow;
 801c76e:	f107 0318 	add.w	r3, r7, #24
 801c772:	4618      	mov	r0, r3
 801c774:	f7ff fed4 	bl	801c520 <getint>
 801c778:	62f8      	str	r0, [r7, #44]	; 0x2c
 801c77a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c77c:	2b00      	cmp	r3, #0
 801c77e:	f2c0 83b9 	blt.w	801cef4 <printf_core+0x958>

		/* Read precision */
		if (*s=='.' && s[1]=='*') {
 801c782:	69bb      	ldr	r3, [r7, #24]
 801c784:	781b      	ldrb	r3, [r3, #0]
 801c786:	2b2e      	cmp	r3, #46	; 0x2e
 801c788:	d144      	bne.n	801c814 <printf_core+0x278>
 801c78a:	69bb      	ldr	r3, [r7, #24]
 801c78c:	3301      	adds	r3, #1
 801c78e:	781b      	ldrb	r3, [r3, #0]
 801c790:	2b2a      	cmp	r3, #42	; 0x2a
 801c792:	d13f      	bne.n	801c814 <printf_core+0x278>
			if (isdigit(s[2]) && s[3]=='$') {
 801c794:	69bb      	ldr	r3, [r7, #24]
 801c796:	3302      	adds	r3, #2
 801c798:	781b      	ldrb	r3, [r3, #0]
 801c79a:	3b30      	subs	r3, #48	; 0x30
 801c79c:	2b09      	cmp	r3, #9
 801c79e:	d820      	bhi.n	801c7e2 <printf_core+0x246>
 801c7a0:	69bb      	ldr	r3, [r7, #24]
 801c7a2:	3303      	adds	r3, #3
 801c7a4:	781b      	ldrb	r3, [r3, #0]
 801c7a6:	2b24      	cmp	r3, #36	; 0x24
 801c7a8:	d11b      	bne.n	801c7e2 <printf_core+0x246>
				nl_type[s[2]-'0'] = INT;
 801c7aa:	69bb      	ldr	r3, [r7, #24]
 801c7ac:	3302      	adds	r3, #2
 801c7ae:	781b      	ldrb	r3, [r3, #0]
 801c7b0:	461a      	mov	r2, r3
 801c7b2:	4b22      	ldr	r3, [pc, #136]	; (801c83c <printf_core+0x2a0>)
 801c7b4:	4413      	add	r3, r2
 801c7b6:	009b      	lsls	r3, r3, #2
 801c7b8:	687a      	ldr	r2, [r7, #4]
 801c7ba:	4413      	add	r3, r2
 801c7bc:	220a      	movs	r2, #10
 801c7be:	601a      	str	r2, [r3, #0]
				p = nl_arg[s[2]-'0'].i;
 801c7c0:	69bb      	ldr	r3, [r7, #24]
 801c7c2:	3302      	adds	r3, #2
 801c7c4:	781b      	ldrb	r3, [r3, #0]
 801c7c6:	461a      	mov	r2, r3
 801c7c8:	4b1d      	ldr	r3, [pc, #116]	; (801c840 <printf_core+0x2a4>)
 801c7ca:	4413      	add	r3, r2
 801c7cc:	00db      	lsls	r3, r3, #3
 801c7ce:	68ba      	ldr	r2, [r7, #8]
 801c7d0:	4413      	add	r3, r2
 801c7d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 801c7d6:	4613      	mov	r3, r2
 801c7d8:	633b      	str	r3, [r7, #48]	; 0x30
				s+=4;
 801c7da:	69bb      	ldr	r3, [r7, #24]
 801c7dc:	3304      	adds	r3, #4
 801c7de:	61bb      	str	r3, [r7, #24]
 801c7e0:	e012      	b.n	801c808 <printf_core+0x26c>
			} else if (!l10n) {
 801c7e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c7e4:	2b00      	cmp	r3, #0
 801c7e6:	f040 8372 	bne.w	801cece <printf_core+0x932>
				p = f ? va_arg(*ap, int) : 0;
 801c7ea:	697b      	ldr	r3, [r7, #20]
 801c7ec:	2b00      	cmp	r3, #0
 801c7ee:	d006      	beq.n	801c7fe <printf_core+0x262>
 801c7f0:	68fb      	ldr	r3, [r7, #12]
 801c7f2:	681b      	ldr	r3, [r3, #0]
 801c7f4:	1d19      	adds	r1, r3, #4
 801c7f6:	68fa      	ldr	r2, [r7, #12]
 801c7f8:	6011      	str	r1, [r2, #0]
 801c7fa:	681b      	ldr	r3, [r3, #0]
 801c7fc:	e000      	b.n	801c800 <printf_core+0x264>
 801c7fe:	2300      	movs	r3, #0
 801c800:	633b      	str	r3, [r7, #48]	; 0x30
				s+=2;
 801c802:	69bb      	ldr	r3, [r7, #24]
 801c804:	3302      	adds	r3, #2
 801c806:	61bb      	str	r3, [r7, #24]
			} else goto inval;
			xp = (p>=0);
 801c808:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c80a:	43db      	mvns	r3, r3
 801c80c:	0fdb      	lsrs	r3, r3, #31
 801c80e:	b2db      	uxtb	r3, r3
 801c810:	637b      	str	r3, [r7, #52]	; 0x34
 801c812:	e01c      	b.n	801c84e <printf_core+0x2b2>
		} else if (*s=='.') {
 801c814:	69bb      	ldr	r3, [r7, #24]
 801c816:	781b      	ldrb	r3, [r3, #0]
 801c818:	2b2e      	cmp	r3, #46	; 0x2e
 801c81a:	d113      	bne.n	801c844 <printf_core+0x2a8>
			s++;
 801c81c:	69bb      	ldr	r3, [r7, #24]
 801c81e:	3301      	adds	r3, #1
 801c820:	61bb      	str	r3, [r7, #24]
			p = getint(&s);
 801c822:	f107 0318 	add.w	r3, r7, #24
 801c826:	4618      	mov	r0, r3
 801c828:	f7ff fe7a 	bl	801c520 <getint>
 801c82c:	6338      	str	r0, [r7, #48]	; 0x30
			xp = 1;
 801c82e:	2301      	movs	r3, #1
 801c830:	637b      	str	r3, [r7, #52]	; 0x34
 801c832:	e00c      	b.n	801c84e <printf_core+0x2b2>
 801c834:	080231cc 	.word	0x080231cc
 801c838:	00012889 	.word	0x00012889
 801c83c:	3fffffd0 	.word	0x3fffffd0
 801c840:	1fffffd0 	.word	0x1fffffd0
		} else {
			p = -1;
 801c844:	f04f 33ff 	mov.w	r3, #4294967295
 801c848:	633b      	str	r3, [r7, #48]	; 0x30
			xp = 0;
 801c84a:	2300      	movs	r3, #0
 801c84c:	637b      	str	r3, [r7, #52]	; 0x34
		}

		/* Format specifier state machine */
		st=0;
 801c84e:	2300      	movs	r3, #0
 801c850:	63fb      	str	r3, [r7, #60]	; 0x3c
		do {
			if (OOB(*s)) goto inval;
 801c852:	69bb      	ldr	r3, [r7, #24]
 801c854:	781b      	ldrb	r3, [r3, #0]
 801c856:	3b41      	subs	r3, #65	; 0x41
 801c858:	2b39      	cmp	r3, #57	; 0x39
 801c85a:	f200 833a 	bhi.w	801ced2 <printf_core+0x936>
			ps=st;
 801c85e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c860:	65fb      	str	r3, [r7, #92]	; 0x5c
			st=states[st]S(*s++);
 801c862:	69bb      	ldr	r3, [r7, #24]
 801c864:	1c5a      	adds	r2, r3, #1
 801c866:	61ba      	str	r2, [r7, #24]
 801c868:	781b      	ldrb	r3, [r3, #0]
 801c86a:	3b41      	subs	r3, #65	; 0x41
 801c86c:	49b8      	ldr	r1, [pc, #736]	; (801cb50 <printf_core+0x5b4>)
 801c86e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c870:	203a      	movs	r0, #58	; 0x3a
 801c872:	fb00 f202 	mul.w	r2, r0, r2
 801c876:	440a      	add	r2, r1
 801c878:	4413      	add	r3, r2
 801c87a:	781b      	ldrb	r3, [r3, #0]
 801c87c:	63fb      	str	r3, [r7, #60]	; 0x3c
		} while (st-1<STOP);
 801c87e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c880:	3b01      	subs	r3, #1
 801c882:	2b07      	cmp	r3, #7
 801c884:	d9e5      	bls.n	801c852 <printf_core+0x2b6>
		if (!st) goto inval;
 801c886:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c888:	2b00      	cmp	r3, #0
 801c88a:	f000 8324 	beq.w	801ced6 <printf_core+0x93a>

		/* Check validity of argument type (nl/normal) */
		if (st==NOARG) {
 801c88e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c890:	2b1b      	cmp	r3, #27
 801c892:	d103      	bne.n	801c89c <printf_core+0x300>
			if (argpos>=0) goto inval;
 801c894:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c896:	2b00      	cmp	r3, #0
 801c898:	db1f      	blt.n	801c8da <printf_core+0x33e>
 801c89a:	e31f      	b.n	801cedc <printf_core+0x940>
		} else {
			if (argpos>=0) nl_type[argpos]=st, arg=nl_arg[argpos];
 801c89c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c89e:	2b00      	cmp	r3, #0
 801c8a0:	db0e      	blt.n	801c8c0 <printf_core+0x324>
 801c8a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c8a4:	009b      	lsls	r3, r3, #2
 801c8a6:	687a      	ldr	r2, [r7, #4]
 801c8a8:	4413      	add	r3, r2
 801c8aa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c8ac:	601a      	str	r2, [r3, #0]
 801c8ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c8b0:	00db      	lsls	r3, r3, #3
 801c8b2:	68ba      	ldr	r2, [r7, #8]
 801c8b4:	4413      	add	r3, r2
 801c8b6:	e9d3 2300 	ldrd	r2, r3, [r3]
 801c8ba:	e9c7 2318 	strd	r2, r3, [r7, #96]	; 0x60
 801c8be:	e00c      	b.n	801c8da <printf_core+0x33e>
			else if (f) pop_arg(&arg, st, ap);
 801c8c0:	697b      	ldr	r3, [r7, #20]
 801c8c2:	2b00      	cmp	r3, #0
 801c8c4:	d007      	beq.n	801c8d6 <printf_core+0x33a>
 801c8c6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801c8c8:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801c8cc:	68fa      	ldr	r2, [r7, #12]
 801c8ce:	4618      	mov	r0, r3
 801c8d0:	f7fe f8a8 	bl	801aa24 <pop_arg>
 801c8d4:	e001      	b.n	801c8da <printf_core+0x33e>
			else return 0;
 801c8d6:	2300      	movs	r3, #0
 801c8d8:	e320      	b.n	801cf1c <printf_core+0x980>
		}

		if (!f) continue;
 801c8da:	697b      	ldr	r3, [r7, #20]
 801c8dc:	2b00      	cmp	r3, #0
 801c8de:	f000 82ae 	beq.w	801ce3e <printf_core+0x8a2>

		z = buf + sizeof(buf);
 801c8e2:	f107 0374 	add.w	r3, r7, #116	; 0x74
 801c8e6:	3328      	adds	r3, #40	; 0x28
 801c8e8:	623b      	str	r3, [r7, #32]
		prefix = "-+   0X0x";
 801c8ea:	4b9a      	ldr	r3, [pc, #616]	; (801cb54 <printf_core+0x5b8>)
 801c8ec:	64fb      	str	r3, [r7, #76]	; 0x4c
		pl = 0;
 801c8ee:	2300      	movs	r3, #0
 801c8f0:	657b      	str	r3, [r7, #84]	; 0x54
		t = s[-1];
 801c8f2:	69bb      	ldr	r3, [r7, #24]
 801c8f4:	3b01      	subs	r3, #1
 801c8f6:	781b      	ldrb	r3, [r3, #0]
 801c8f8:	653b      	str	r3, [r7, #80]	; 0x50

		/* Transform ls,lc -> S,C */
		if (ps && (t&15)==3) t&=~32;
 801c8fa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801c8fc:	2b00      	cmp	r3, #0
 801c8fe:	d008      	beq.n	801c912 <printf_core+0x376>
 801c900:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801c902:	f003 030f 	and.w	r3, r3, #15
 801c906:	2b03      	cmp	r3, #3
 801c908:	d103      	bne.n	801c912 <printf_core+0x376>
 801c90a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801c90c:	f023 0320 	bic.w	r3, r3, #32
 801c910:	653b      	str	r3, [r7, #80]	; 0x50

		/* - and 0 flags are mutually exclusive */
		if (fl & LEFT_ADJ) fl &= ~ZERO_PAD;
 801c912:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c914:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801c918:	2b00      	cmp	r3, #0
 801c91a:	d003      	beq.n	801c924 <printf_core+0x388>
 801c91c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c91e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801c922:	62bb      	str	r3, [r7, #40]	; 0x28
 801c924:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801c926:	3b41      	subs	r3, #65	; 0x41
 801c928:	2b37      	cmp	r3, #55	; 0x37
 801c92a:	f200 8220 	bhi.w	801cd6e <printf_core+0x7d2>
 801c92e:	a201      	add	r2, pc, #4	; (adr r2, 801c934 <printf_core+0x398>)
 801c930:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c934:	0801cd3d 	.word	0x0801cd3d
 801c938:	0801cd6f 	.word	0x0801cd6f
 801c93c:	0801cc3b 	.word	0x0801cc3b
 801c940:	0801cd6f 	.word	0x0801cd6f
 801c944:	0801cd3d 	.word	0x0801cd3d
 801c948:	0801cd3d 	.word	0x0801cd3d
 801c94c:	0801cd3d 	.word	0x0801cd3d
 801c950:	0801cd6f 	.word	0x0801cd6f
 801c954:	0801cd6f 	.word	0x0801cd6f
 801c958:	0801cd6f 	.word	0x0801cd6f
 801c95c:	0801cd6f 	.word	0x0801cd6f
 801c960:	0801cd6f 	.word	0x0801cd6f
 801c964:	0801cd6f 	.word	0x0801cd6f
 801c968:	0801cd6f 	.word	0x0801cd6f
 801c96c:	0801cd6f 	.word	0x0801cd6f
 801c970:	0801cd6f 	.word	0x0801cd6f
 801c974:	0801cd6f 	.word	0x0801cd6f
 801c978:	0801cd6f 	.word	0x0801cd6f
 801c97c:	0801cc53 	.word	0x0801cc53
 801c980:	0801cd6f 	.word	0x0801cd6f
 801c984:	0801cd6f 	.word	0x0801cd6f
 801c988:	0801cd6f 	.word	0x0801cd6f
 801c98c:	0801cd6f 	.word	0x0801cd6f
 801c990:	0801caa9 	.word	0x0801caa9
 801c994:	0801cd6f 	.word	0x0801cd6f
 801c998:	0801cd6f 	.word	0x0801cd6f
 801c99c:	0801cd6f 	.word	0x0801cd6f
 801c9a0:	0801cd6f 	.word	0x0801cd6f
 801c9a4:	0801cd6f 	.word	0x0801cd6f
 801c9a8:	0801cd6f 	.word	0x0801cd6f
 801c9ac:	0801cd6f 	.word	0x0801cd6f
 801c9b0:	0801cd6f 	.word	0x0801cd6f
 801c9b4:	0801cd3d 	.word	0x0801cd3d
 801c9b8:	0801cd6f 	.word	0x0801cd6f
 801c9bc:	0801cbbd 	.word	0x0801cbbd
 801c9c0:	0801cb0d 	.word	0x0801cb0d
 801c9c4:	0801cd3d 	.word	0x0801cd3d
 801c9c8:	0801cd3d 	.word	0x0801cd3d
 801c9cc:	0801cd3d 	.word	0x0801cd3d
 801c9d0:	0801cd6f 	.word	0x0801cd6f
 801c9d4:	0801cb0d 	.word	0x0801cb0d
 801c9d8:	0801cd6f 	.word	0x0801cd6f
 801c9dc:	0801cd6f 	.word	0x0801cd6f
 801c9e0:	0801cd6f 	.word	0x0801cd6f
 801c9e4:	0801cbdb 	.word	0x0801cbdb
 801c9e8:	0801ca15 	.word	0x0801ca15
 801c9ec:	0801cadf 	.word	0x0801cadf
 801c9f0:	0801ca93 	.word	0x0801ca93
 801c9f4:	0801cd6f 	.word	0x0801cd6f
 801c9f8:	0801cd6f 	.word	0x0801cd6f
 801c9fc:	0801cbed 	.word	0x0801cbed
 801ca00:	0801cd6f 	.word	0x0801cd6f
 801ca04:	0801cb5d 	.word	0x0801cb5d
 801ca08:	0801cd6f 	.word	0x0801cd6f
 801ca0c:	0801cd6f 	.word	0x0801cd6f
 801ca10:	0801caa9 	.word	0x0801caa9
 801ca14:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801ca16:	2b07      	cmp	r3, #7
 801ca18:	f200 8214 	bhi.w	801ce44 <printf_core+0x8a8>
 801ca1c:	a201      	add	r2, pc, #4	; (adr r2, 801ca24 <printf_core+0x488>)
 801ca1e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801ca22:	bf00      	nop
 801ca24:	0801ca45 	.word	0x0801ca45
 801ca28:	0801ca4d 	.word	0x0801ca4d
 801ca2c:	0801ca55 	.word	0x0801ca55
 801ca30:	0801ca65 	.word	0x0801ca65
 801ca34:	0801ca6f 	.word	0x0801ca6f
 801ca38:	0801ce45 	.word	0x0801ce45
 801ca3c:	0801ca79 	.word	0x0801ca79
 801ca40:	0801ca81 	.word	0x0801ca81

		switch(t) {
		case 'n':
			switch(ps) {
			case BARE: *(int *)arg.p = cnt; break;
 801ca44:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ca46:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801ca48:	601a      	str	r2, [r3, #0]
 801ca4a:	e021      	b.n	801ca90 <printf_core+0x4f4>
			case LPRE: *(long *)arg.p = cnt; break;
 801ca4c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ca4e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801ca50:	601a      	str	r2, [r3, #0]
 801ca52:	e01d      	b.n	801ca90 <printf_core+0x4f4>
			case LLPRE: *(long long *)arg.p = cnt; break;
 801ca54:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801ca56:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ca58:	461a      	mov	r2, r3
 801ca5a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801ca5e:	e9c1 2300 	strd	r2, r3, [r1]
 801ca62:	e015      	b.n	801ca90 <printf_core+0x4f4>
			case HPRE: *(unsigned short *)arg.p = cnt; break;
 801ca64:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ca66:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801ca68:	b292      	uxth	r2, r2
 801ca6a:	801a      	strh	r2, [r3, #0]
 801ca6c:	e010      	b.n	801ca90 <printf_core+0x4f4>
			case HHPRE: *(unsigned char *)arg.p = cnt; break;
 801ca6e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ca70:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801ca72:	b2d2      	uxtb	r2, r2
 801ca74:	701a      	strb	r2, [r3, #0]
 801ca76:	e00b      	b.n	801ca90 <printf_core+0x4f4>
			case ZTPRE: *(size_t *)arg.p = cnt; break;
 801ca78:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ca7a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801ca7c:	601a      	str	r2, [r3, #0]
 801ca7e:	e007      	b.n	801ca90 <printf_core+0x4f4>
			case JPRE: *(uintmax_t *)arg.p = cnt; break;
 801ca80:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801ca82:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ca84:	461a      	mov	r2, r3
 801ca86:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801ca8a:	e9c1 2300 	strd	r2, r3, [r1]
 801ca8e:	bf00      	nop
			}
			continue;
 801ca90:	e1d8      	b.n	801ce44 <printf_core+0x8a8>
		case 'p':
			p = MAX((unsigned)p, 2*sizeof(void*));
 801ca92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ca94:	2b08      	cmp	r3, #8
 801ca96:	bf38      	it	cc
 801ca98:	2308      	movcc	r3, #8
 801ca9a:	633b      	str	r3, [r7, #48]	; 0x30
			t = 'x';
 801ca9c:	2378      	movs	r3, #120	; 0x78
 801ca9e:	653b      	str	r3, [r7, #80]	; 0x50
			fl |= ALT_FORM;  /* fallthrough */
 801caa0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801caa2:	f043 0308 	orr.w	r3, r3, #8
 801caa6:	62bb      	str	r3, [r7, #40]	; 0x28
		case 'x': case 'X':
			a = fmt_x(arg.i, z, t&32);
 801caa8:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 801caac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801caae:	f003 0320 	and.w	r3, r3, #32
 801cab2:	6a3a      	ldr	r2, [r7, #32]
 801cab4:	f7fe f960 	bl	801ad78 <fmt_x>
 801cab8:	61f8      	str	r0, [r7, #28]
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
 801caba:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cabe:	4313      	orrs	r3, r2
 801cac0:	d052      	beq.n	801cb68 <printf_core+0x5cc>
 801cac2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cac4:	f003 0308 	and.w	r3, r3, #8
 801cac8:	2b00      	cmp	r3, #0
 801caca:	d04d      	beq.n	801cb68 <printf_core+0x5cc>
 801cacc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801cace:	111b      	asrs	r3, r3, #4
 801cad0:	461a      	mov	r2, r3
 801cad2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cad4:	4413      	add	r3, r2
 801cad6:	64fb      	str	r3, [r7, #76]	; 0x4c
 801cad8:	2302      	movs	r3, #2
 801cada:	657b      	str	r3, [r7, #84]	; 0x54
 801cadc:	e044      	b.n	801cb68 <printf_core+0x5cc>
			if (0) {
		case 'o':
			a = fmt_o(arg.i, z);
 801cade:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 801cae2:	6a3a      	ldr	r2, [r7, #32]
 801cae4:	f7fe f980 	bl	801ade8 <fmt_o>
 801cae8:	61f8      	str	r0, [r7, #28]
			if ((fl&ALT_FORM) && p<z-a+1) p=z-a+1;
 801caea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801caec:	f003 0308 	and.w	r3, r3, #8
 801caf0:	2b00      	cmp	r3, #0
 801caf2:	d039      	beq.n	801cb68 <printf_core+0x5cc>
 801caf4:	6a3a      	ldr	r2, [r7, #32]
 801caf6:	69fb      	ldr	r3, [r7, #28]
 801caf8:	1ad3      	subs	r3, r2, r3
 801cafa:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cafc:	429a      	cmp	r2, r3
 801cafe:	dc33      	bgt.n	801cb68 <printf_core+0x5cc>
 801cb00:	6a3a      	ldr	r2, [r7, #32]
 801cb02:	69fb      	ldr	r3, [r7, #28]
 801cb04:	1ad3      	subs	r3, r2, r3
 801cb06:	3301      	adds	r3, #1
 801cb08:	633b      	str	r3, [r7, #48]	; 0x30
 801cb0a:	e02d      	b.n	801cb68 <printf_core+0x5cc>
			} if (0) {
		case 'd': case 'i':
			pl=1;
 801cb0c:	2301      	movs	r3, #1
 801cb0e:	657b      	str	r3, [r7, #84]	; 0x54
			if (arg.i>INTMAX_MAX) {
 801cb10:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cb14:	2a00      	cmp	r2, #0
 801cb16:	f173 0300 	sbcs.w	r3, r3, #0
 801cb1a:	da07      	bge.n	801cb2c <printf_core+0x590>
				arg.i=-arg.i;
 801cb1c:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cb20:	4252      	negs	r2, r2
 801cb22:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 801cb26:	e9c7 2318 	strd	r2, r3, [r7, #96]	; 0x60
 801cb2a:	e017      	b.n	801cb5c <printf_core+0x5c0>
			} else if (fl & MARK_POS) {
 801cb2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cb2e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801cb32:	2b00      	cmp	r3, #0
 801cb34:	d003      	beq.n	801cb3e <printf_core+0x5a2>
				prefix++;
 801cb36:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cb38:	3301      	adds	r3, #1
 801cb3a:	64fb      	str	r3, [r7, #76]	; 0x4c
 801cb3c:	e00e      	b.n	801cb5c <printf_core+0x5c0>
			} else if (fl & PAD_POS) {
 801cb3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cb40:	f003 0301 	and.w	r3, r3, #1
 801cb44:	2b00      	cmp	r3, #0
 801cb46:	d007      	beq.n	801cb58 <printf_core+0x5bc>
				prefix+=2;
 801cb48:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cb4a:	3302      	adds	r3, #2
 801cb4c:	64fb      	str	r3, [r7, #76]	; 0x4c
 801cb4e:	e005      	b.n	801cb5c <printf_core+0x5c0>
 801cb50:	08023990 	.word	0x08023990
 801cb54:	080231b8 	.word	0x080231b8
			} else pl=0;
 801cb58:	2300      	movs	r3, #0
 801cb5a:	657b      	str	r3, [r7, #84]	; 0x54
		case 'u':
			a = fmt_u(arg.i, z);
 801cb5c:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 801cb60:	6a3a      	ldr	r2, [r7, #32]
 801cb62:	f7fe f96b 	bl	801ae3c <fmt_u>
 801cb66:	61f8      	str	r0, [r7, #28]
			}
			if (xp && p<0) goto overflow;
 801cb68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cb6a:	2b00      	cmp	r3, #0
 801cb6c:	d003      	beq.n	801cb76 <printf_core+0x5da>
 801cb6e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cb70:	2b00      	cmp	r3, #0
 801cb72:	f2c0 81c1 	blt.w	801cef8 <printf_core+0x95c>
			if (xp) fl &= ~ZERO_PAD;
 801cb76:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cb78:	2b00      	cmp	r3, #0
 801cb7a:	d003      	beq.n	801cb84 <printf_core+0x5e8>
 801cb7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cb7e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801cb82:	62bb      	str	r3, [r7, #40]	; 0x28
			if (!arg.i && !p) {
 801cb84:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cb88:	4313      	orrs	r3, r2
 801cb8a:	d105      	bne.n	801cb98 <printf_core+0x5fc>
 801cb8c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cb8e:	2b00      	cmp	r3, #0
 801cb90:	d102      	bne.n	801cb98 <printf_core+0x5fc>
				a=z;
 801cb92:	6a3b      	ldr	r3, [r7, #32]
 801cb94:	61fb      	str	r3, [r7, #28]
				break;
 801cb96:	e0ea      	b.n	801cd6e <printf_core+0x7d2>
			}
			p = MAX(p, z-a + !arg.i);
 801cb98:	6a3a      	ldr	r2, [r7, #32]
 801cb9a:	69fb      	ldr	r3, [r7, #28]
 801cb9c:	1ad1      	subs	r1, r2, r3
 801cb9e:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cba2:	4313      	orrs	r3, r2
 801cba4:	2b00      	cmp	r3, #0
 801cba6:	bf0c      	ite	eq
 801cba8:	2301      	moveq	r3, #1
 801cbaa:	2300      	movne	r3, #0
 801cbac:	b2db      	uxtb	r3, r3
 801cbae:	440b      	add	r3, r1
 801cbb0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cbb2:	4293      	cmp	r3, r2
 801cbb4:	bfb8      	it	lt
 801cbb6:	4613      	movlt	r3, r2
 801cbb8:	633b      	str	r3, [r7, #48]	; 0x30
			break;
 801cbba:	e0d8      	b.n	801cd6e <printf_core+0x7d2>
		case 'c':
			*(a=z-(p=1))=arg.i;
 801cbbc:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cbc0:	2101      	movs	r1, #1
 801cbc2:	6339      	str	r1, [r7, #48]	; 0x30
 801cbc4:	6a39      	ldr	r1, [r7, #32]
 801cbc6:	3901      	subs	r1, #1
 801cbc8:	61f9      	str	r1, [r7, #28]
 801cbca:	b2d2      	uxtb	r2, r2
 801cbcc:	69fb      	ldr	r3, [r7, #28]
 801cbce:	701a      	strb	r2, [r3, #0]
			fl &= ~ZERO_PAD;
 801cbd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cbd2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801cbd6:	62bb      	str	r3, [r7, #40]	; 0x28
			break;
 801cbd8:	e0c9      	b.n	801cd6e <printf_core+0x7d2>
		case 'm':
			if (1) a = strerror(errno); else /* fallthrough */
 801cbda:	f7f2 fc7b 	bl	800f4d4 <__errno_location>
 801cbde:	4603      	mov	r3, r0
 801cbe0:	681b      	ldr	r3, [r3, #0]
 801cbe2:	4618      	mov	r0, r3
 801cbe4:	f000 fff8 	bl	801dbd8 <strerror>
 801cbe8:	61f8      	str	r0, [r7, #28]
 801cbea:	e006      	b.n	801cbfa <printf_core+0x65e>
		case 's':
			a = arg.p ? arg.p : "(null)";
 801cbec:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801cbee:	2b00      	cmp	r3, #0
 801cbf0:	d001      	beq.n	801cbf6 <printf_core+0x65a>
 801cbf2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801cbf4:	e000      	b.n	801cbf8 <printf_core+0x65c>
 801cbf6:	4b9d      	ldr	r3, [pc, #628]	; (801ce6c <printf_core+0x8d0>)
 801cbf8:	61fb      	str	r3, [r7, #28]
			z = a + strnlen(a, p<0 ? INT_MAX : p);
 801cbfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cbfc:	2b00      	cmp	r3, #0
 801cbfe:	db01      	blt.n	801cc04 <printf_core+0x668>
 801cc00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cc02:	e001      	b.n	801cc08 <printf_core+0x66c>
 801cc04:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801cc08:	4619      	mov	r1, r3
 801cc0a:	69f8      	ldr	r0, [r7, #28]
 801cc0c:	f001 f85f 	bl	801dcce <strnlen>
 801cc10:	4602      	mov	r2, r0
 801cc12:	69fb      	ldr	r3, [r7, #28]
 801cc14:	4413      	add	r3, r2
 801cc16:	623b      	str	r3, [r7, #32]
			if (p<0 && *z) goto overflow;
 801cc18:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cc1a:	2b00      	cmp	r3, #0
 801cc1c:	da04      	bge.n	801cc28 <printf_core+0x68c>
 801cc1e:	6a3b      	ldr	r3, [r7, #32]
 801cc20:	781b      	ldrb	r3, [r3, #0]
 801cc22:	2b00      	cmp	r3, #0
 801cc24:	f040 816a 	bne.w	801cefc <printf_core+0x960>
			p = z-a;
 801cc28:	6a3a      	ldr	r2, [r7, #32]
 801cc2a:	69fb      	ldr	r3, [r7, #28]
 801cc2c:	1ad3      	subs	r3, r2, r3
 801cc2e:	633b      	str	r3, [r7, #48]	; 0x30
			fl &= ~ZERO_PAD;
 801cc30:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cc32:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801cc36:	62bb      	str	r3, [r7, #40]	; 0x28
			break;
 801cc38:	e099      	b.n	801cd6e <printf_core+0x7d2>
		case 'C':
			wc[0] = arg.i;
 801cc3a:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cc3e:	4613      	mov	r3, r2
 801cc40:	66bb      	str	r3, [r7, #104]	; 0x68
			wc[1] = 0;
 801cc42:	2300      	movs	r3, #0
 801cc44:	66fb      	str	r3, [r7, #108]	; 0x6c
			arg.p = wc;
 801cc46:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801cc4a:	663b      	str	r3, [r7, #96]	; 0x60
			p = -1; /* fallthrough */
 801cc4c:	f04f 33ff 	mov.w	r3, #4294967295
 801cc50:	633b      	str	r3, [r7, #48]	; 0x30
		case 'S':
			ws = arg.p;
 801cc52:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801cc54:	65bb      	str	r3, [r7, #88]	; 0x58
			for (i=l=0; (int)i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-(int)i; i+=l);
 801cc56:	2300      	movs	r3, #0
 801cc58:	647b      	str	r3, [r7, #68]	; 0x44
 801cc5a:	2300      	movs	r3, #0
 801cc5c:	64bb      	str	r3, [r7, #72]	; 0x48
 801cc5e:	e003      	b.n	801cc68 <printf_core+0x6cc>
 801cc60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cc62:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801cc64:	4413      	add	r3, r2
 801cc66:	64bb      	str	r3, [r7, #72]	; 0x48
 801cc68:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801cc6a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cc6c:	429a      	cmp	r2, r3
 801cc6e:	dd17      	ble.n	801cca0 <printf_core+0x704>
 801cc70:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801cc72:	681b      	ldr	r3, [r3, #0]
 801cc74:	2b00      	cmp	r3, #0
 801cc76:	d013      	beq.n	801cca0 <printf_core+0x704>
 801cc78:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801cc7a:	1d1a      	adds	r2, r3, #4
 801cc7c:	65ba      	str	r2, [r7, #88]	; 0x58
 801cc7e:	681a      	ldr	r2, [r3, #0]
 801cc80:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801cc84:	4611      	mov	r1, r2
 801cc86:	4618      	mov	r0, r3
 801cc88:	f002 fb3c 	bl	801f304 <wctomb>
 801cc8c:	6478      	str	r0, [r7, #68]	; 0x44
 801cc8e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cc90:	2b00      	cmp	r3, #0
 801cc92:	db05      	blt.n	801cca0 <printf_core+0x704>
 801cc94:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801cc96:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cc98:	1ad3      	subs	r3, r2, r3
 801cc9a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801cc9c:	429a      	cmp	r2, r3
 801cc9e:	dddf      	ble.n	801cc60 <printf_core+0x6c4>
			if (l<0) return -1;
 801cca0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cca2:	2b00      	cmp	r3, #0
 801cca4:	da02      	bge.n	801ccac <printf_core+0x710>
 801cca6:	f04f 33ff 	mov.w	r3, #4294967295
 801ccaa:	e137      	b.n	801cf1c <printf_core+0x980>
			if (i > INT_MAX) goto overflow;
 801ccac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ccae:	2b00      	cmp	r3, #0
 801ccb0:	f2c0 8126 	blt.w	801cf00 <printf_core+0x964>
			p = i;
 801ccb4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ccb6:	633b      	str	r3, [r7, #48]	; 0x30
			pad(f, ' ', w, p, fl);
 801ccb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ccba:	9300      	str	r3, [sp, #0]
 801ccbc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ccbe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801ccc0:	2120      	movs	r1, #32
 801ccc2:	6978      	ldr	r0, [r7, #20]
 801ccc4:	f7fd fff2 	bl	801acac <pad>
			ws = arg.p;
 801ccc8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ccca:	65bb      	str	r3, [r7, #88]	; 0x58
			for (i=0; (int)i<0+p && *ws && (int)i+(l=wctomb(mb, *ws++))<=p; i+=l)
 801cccc:	2300      	movs	r3, #0
 801ccce:	64bb      	str	r3, [r7, #72]	; 0x48
 801ccd0:	e00a      	b.n	801cce8 <printf_core+0x74c>
				out(f, mb, l);
 801ccd2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801ccd4:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801ccd8:	4619      	mov	r1, r3
 801ccda:	6978      	ldr	r0, [r7, #20]
 801ccdc:	f7fd ffd0 	bl	801ac80 <out>
			for (i=0; (int)i<0+p && *ws && (int)i+(l=wctomb(mb, *ws++))<=p; i+=l)
 801cce0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cce2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801cce4:	4413      	add	r3, r2
 801cce6:	64bb      	str	r3, [r7, #72]	; 0x48
 801cce8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ccea:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801ccec:	429a      	cmp	r2, r3
 801ccee:	dd14      	ble.n	801cd1a <printf_core+0x77e>
 801ccf0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801ccf2:	681b      	ldr	r3, [r3, #0]
 801ccf4:	2b00      	cmp	r3, #0
 801ccf6:	d010      	beq.n	801cd1a <printf_core+0x77e>
 801ccf8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801ccfa:	1d1a      	adds	r2, r3, #4
 801ccfc:	65ba      	str	r2, [r7, #88]	; 0x58
 801ccfe:	681a      	ldr	r2, [r3, #0]
 801cd00:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801cd04:	4611      	mov	r1, r2
 801cd06:	4618      	mov	r0, r3
 801cd08:	f002 fafc 	bl	801f304 <wctomb>
 801cd0c:	6478      	str	r0, [r7, #68]	; 0x44
 801cd0e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801cd10:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cd12:	4413      	add	r3, r2
 801cd14:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cd16:	429a      	cmp	r2, r3
 801cd18:	dadb      	bge.n	801ccd2 <printf_core+0x736>
			pad(f, ' ', w, p, fl^LEFT_ADJ);
 801cd1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cd1c:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 801cd20:	9300      	str	r3, [sp, #0]
 801cd22:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cd24:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801cd26:	2120      	movs	r1, #32
 801cd28:	6978      	ldr	r0, [r7, #20]
 801cd2a:	f7fd ffbf 	bl	801acac <pad>
			l = w>p ? w : p;
 801cd2e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cd30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801cd32:	4293      	cmp	r3, r2
 801cd34:	bfb8      	it	lt
 801cd36:	4613      	movlt	r3, r2
 801cd38:	647b      	str	r3, [r7, #68]	; 0x44
			continue;
 801cd3a:	e087      	b.n	801ce4c <printf_core+0x8b0>
		case 'e': case 'f': case 'g': case 'a':
		case 'E': case 'F': case 'G': case 'A':
			if (xp && p<0) goto overflow;
 801cd3c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cd3e:	2b00      	cmp	r3, #0
 801cd40:	d003      	beq.n	801cd4a <printf_core+0x7ae>
 801cd42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cd44:	2b00      	cmp	r3, #0
 801cd46:	f2c0 80dd 	blt.w	801cf04 <printf_core+0x968>
			l = fmt_fp(f, arg.f, w, p, fl, t);
 801cd4a:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cd4e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801cd50:	6d38      	ldr	r0, [r7, #80]	; 0x50
 801cd52:	9003      	str	r0, [sp, #12]
 801cd54:	9102      	str	r1, [sp, #8]
 801cd56:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801cd58:	9101      	str	r1, [sp, #4]
 801cd5a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801cd5c:	9100      	str	r1, [sp, #0]
 801cd5e:	6978      	ldr	r0, [r7, #20]
 801cd60:	f7fe f8ba 	bl	801aed8 <fmt_fp>
 801cd64:	6478      	str	r0, [r7, #68]	; 0x44
			if (l<0) goto overflow;
 801cd66:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cd68:	2b00      	cmp	r3, #0
 801cd6a:	da6e      	bge.n	801ce4a <printf_core+0x8ae>
 801cd6c:	e0cf      	b.n	801cf0e <printf_core+0x972>
			continue;
		}

		if (p < z-a) p = z-a;
 801cd6e:	6a3a      	ldr	r2, [r7, #32]
 801cd70:	69fb      	ldr	r3, [r7, #28]
 801cd72:	1ad3      	subs	r3, r2, r3
 801cd74:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cd76:	429a      	cmp	r2, r3
 801cd78:	da03      	bge.n	801cd82 <printf_core+0x7e6>
 801cd7a:	6a3a      	ldr	r2, [r7, #32]
 801cd7c:	69fb      	ldr	r3, [r7, #28]
 801cd7e:	1ad3      	subs	r3, r2, r3
 801cd80:	633b      	str	r3, [r7, #48]	; 0x30
		if (p > INT_MAX-pl) goto overflow;
 801cd82:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801cd84:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801cd88:	1a9b      	subs	r3, r3, r2
 801cd8a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cd8c:	429a      	cmp	r2, r3
 801cd8e:	f300 80bb 	bgt.w	801cf08 <printf_core+0x96c>
		if (w < pl+p) w = pl+p;
 801cd92:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801cd94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cd96:	4413      	add	r3, r2
 801cd98:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801cd9a:	429a      	cmp	r2, r3
 801cd9c:	da03      	bge.n	801cda6 <printf_core+0x80a>
 801cd9e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801cda0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cda2:	4413      	add	r3, r2
 801cda4:	62fb      	str	r3, [r7, #44]	; 0x2c
		if (w > INT_MAX-cnt) goto overflow;
 801cda6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801cda8:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801cdac:	1a9b      	subs	r3, r3, r2
 801cdae:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801cdb0:	429a      	cmp	r2, r3
 801cdb2:	f300 80ab 	bgt.w	801cf0c <printf_core+0x970>

		pad(f, ' ', w, pl+p, fl);
 801cdb6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801cdb8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cdba:	441a      	add	r2, r3
 801cdbc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cdbe:	9300      	str	r3, [sp, #0]
 801cdc0:	4613      	mov	r3, r2
 801cdc2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801cdc4:	2120      	movs	r1, #32
 801cdc6:	6978      	ldr	r0, [r7, #20]
 801cdc8:	f7fd ff70 	bl	801acac <pad>
		out(f, prefix, pl);
 801cdcc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801cdce:	461a      	mov	r2, r3
 801cdd0:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801cdd2:	6978      	ldr	r0, [r7, #20]
 801cdd4:	f7fd ff54 	bl	801ac80 <out>
		pad(f, '0', w, pl+p, fl^ZERO_PAD);
 801cdd8:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801cdda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cddc:	441a      	add	r2, r3
 801cdde:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cde0:	f483 3380 	eor.w	r3, r3, #65536	; 0x10000
 801cde4:	9300      	str	r3, [sp, #0]
 801cde6:	4613      	mov	r3, r2
 801cde8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801cdea:	2130      	movs	r1, #48	; 0x30
 801cdec:	6978      	ldr	r0, [r7, #20]
 801cdee:	f7fd ff5d 	bl	801acac <pad>
		pad(f, '0', p, z-a, 0);
 801cdf2:	6a3a      	ldr	r2, [r7, #32]
 801cdf4:	69fb      	ldr	r3, [r7, #28]
 801cdf6:	1ad3      	subs	r3, r2, r3
 801cdf8:	2200      	movs	r2, #0
 801cdfa:	9200      	str	r2, [sp, #0]
 801cdfc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cdfe:	2130      	movs	r1, #48	; 0x30
 801ce00:	6978      	ldr	r0, [r7, #20]
 801ce02:	f7fd ff53 	bl	801acac <pad>
		out(f, a, z-a);
 801ce06:	6a3a      	ldr	r2, [r7, #32]
 801ce08:	69fb      	ldr	r3, [r7, #28]
 801ce0a:	1ad3      	subs	r3, r2, r3
 801ce0c:	461a      	mov	r2, r3
 801ce0e:	69f9      	ldr	r1, [r7, #28]
 801ce10:	6978      	ldr	r0, [r7, #20]
 801ce12:	f7fd ff35 	bl	801ac80 <out>
		pad(f, ' ', w, pl+p, fl^LEFT_ADJ);
 801ce16:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801ce18:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ce1a:	441a      	add	r2, r3
 801ce1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ce1e:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 801ce22:	9300      	str	r3, [sp, #0]
 801ce24:	4613      	mov	r3, r2
 801ce26:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801ce28:	2120      	movs	r1, #32
 801ce2a:	6978      	ldr	r0, [r7, #20]
 801ce2c:	f7fd ff3e 	bl	801acac <pad>

		l = w;
 801ce30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ce32:	647b      	str	r3, [r7, #68]	; 0x44
 801ce34:	f7ff bbca 	b.w	801c5cc <printf_core+0x30>
		if (l) continue;
 801ce38:	bf00      	nop
 801ce3a:	f7ff bbc7 	b.w	801c5cc <printf_core+0x30>
		if (!f) continue;
 801ce3e:	bf00      	nop
 801ce40:	f7ff bbc4 	b.w	801c5cc <printf_core+0x30>
			continue;
 801ce44:	bf00      	nop
 801ce46:	f7ff bbc1 	b.w	801c5cc <printf_core+0x30>
			continue;
 801ce4a:	bf00      	nop
		if (l > INT_MAX - cnt) goto overflow;
 801ce4c:	f7ff bbbe 	b.w	801c5cc <printf_core+0x30>
		if (!*s) break;
 801ce50:	bf00      	nop
	}

	if (f) return cnt;
 801ce52:	697b      	ldr	r3, [r7, #20]
 801ce54:	2b00      	cmp	r3, #0
 801ce56:	d001      	beq.n	801ce5c <printf_core+0x8c0>
 801ce58:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ce5a:	e05f      	b.n	801cf1c <printf_core+0x980>
	if (!l10n) return 0;
 801ce5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ce5e:	2b00      	cmp	r3, #0
 801ce60:	d101      	bne.n	801ce66 <printf_core+0x8ca>
 801ce62:	2300      	movs	r3, #0
 801ce64:	e05a      	b.n	801cf1c <printf_core+0x980>

	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
 801ce66:	2301      	movs	r3, #1
 801ce68:	64bb      	str	r3, [r7, #72]	; 0x48
 801ce6a:	e011      	b.n	801ce90 <printf_core+0x8f4>
 801ce6c:	080231c4 	.word	0x080231c4
		pop_arg(nl_arg+i, nl_type[i], ap);
 801ce70:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ce72:	00db      	lsls	r3, r3, #3
 801ce74:	68ba      	ldr	r2, [r7, #8]
 801ce76:	18d0      	adds	r0, r2, r3
 801ce78:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ce7a:	009b      	lsls	r3, r3, #2
 801ce7c:	687a      	ldr	r2, [r7, #4]
 801ce7e:	4413      	add	r3, r2
 801ce80:	681b      	ldr	r3, [r3, #0]
 801ce82:	68fa      	ldr	r2, [r7, #12]
 801ce84:	4619      	mov	r1, r3
 801ce86:	f7fd fdcd 	bl	801aa24 <pop_arg>
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
 801ce8a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ce8c:	3301      	adds	r3, #1
 801ce8e:	64bb      	str	r3, [r7, #72]	; 0x48
 801ce90:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ce92:	2b09      	cmp	r3, #9
 801ce94:	d80a      	bhi.n	801ceac <printf_core+0x910>
 801ce96:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ce98:	009b      	lsls	r3, r3, #2
 801ce9a:	687a      	ldr	r2, [r7, #4]
 801ce9c:	4413      	add	r3, r2
 801ce9e:	681b      	ldr	r3, [r3, #0]
 801cea0:	2b00      	cmp	r3, #0
 801cea2:	d1e5      	bne.n	801ce70 <printf_core+0x8d4>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
 801cea4:	e002      	b.n	801ceac <printf_core+0x910>
 801cea6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801cea8:	3301      	adds	r3, #1
 801ceaa:	64bb      	str	r3, [r7, #72]	; 0x48
 801ceac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ceae:	2b09      	cmp	r3, #9
 801ceb0:	d806      	bhi.n	801cec0 <printf_core+0x924>
 801ceb2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ceb4:	009b      	lsls	r3, r3, #2
 801ceb6:	687a      	ldr	r2, [r7, #4]
 801ceb8:	4413      	add	r3, r2
 801ceba:	681b      	ldr	r3, [r3, #0]
 801cebc:	2b00      	cmp	r3, #0
 801cebe:	d0f2      	beq.n	801cea6 <printf_core+0x90a>
	if (i<=NL_ARGMAX) goto inval;
 801cec0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801cec2:	2b09      	cmp	r3, #9
 801cec4:	d909      	bls.n	801ceda <printf_core+0x93e>
	return 1;
 801cec6:	2301      	movs	r3, #1
 801cec8:	e028      	b.n	801cf1c <printf_core+0x980>
			} else goto inval;
 801ceca:	bf00      	nop
 801cecc:	e006      	b.n	801cedc <printf_core+0x940>
			} else goto inval;
 801cece:	bf00      	nop
 801ced0:	e004      	b.n	801cedc <printf_core+0x940>
			if (OOB(*s)) goto inval;
 801ced2:	bf00      	nop
 801ced4:	e002      	b.n	801cedc <printf_core+0x940>
		if (!st) goto inval;
 801ced6:	bf00      	nop
 801ced8:	e000      	b.n	801cedc <printf_core+0x940>
	if (i<=NL_ARGMAX) goto inval;
 801ceda:	bf00      	nop

inval:
	errno = EINVAL;
 801cedc:	f7f2 fafa 	bl	800f4d4 <__errno_location>
 801cee0:	4603      	mov	r3, r0
 801cee2:	2216      	movs	r2, #22
 801cee4:	601a      	str	r2, [r3, #0]
	return -1;
 801cee6:	f04f 33ff 	mov.w	r3, #4294967295
 801ceea:	e017      	b.n	801cf1c <printf_core+0x980>
		if (l > INT_MAX - cnt) goto overflow;
 801ceec:	bf00      	nop
 801ceee:	e00e      	b.n	801cf0e <printf_core+0x972>
		if (z-a > INT_MAX-cnt) goto overflow;
 801cef0:	bf00      	nop
 801cef2:	e00c      	b.n	801cf0e <printf_core+0x972>
		} else if ((w=getint(&s))<0) goto overflow;
 801cef4:	bf00      	nop
 801cef6:	e00a      	b.n	801cf0e <printf_core+0x972>
			if (xp && p<0) goto overflow;
 801cef8:	bf00      	nop
 801cefa:	e008      	b.n	801cf0e <printf_core+0x972>
			if (p<0 && *z) goto overflow;
 801cefc:	bf00      	nop
 801cefe:	e006      	b.n	801cf0e <printf_core+0x972>
			if (i > INT_MAX) goto overflow;
 801cf00:	bf00      	nop
 801cf02:	e004      	b.n	801cf0e <printf_core+0x972>
			if (xp && p<0) goto overflow;
 801cf04:	bf00      	nop
 801cf06:	e002      	b.n	801cf0e <printf_core+0x972>
		if (p > INT_MAX-pl) goto overflow;
 801cf08:	bf00      	nop
 801cf0a:	e000      	b.n	801cf0e <printf_core+0x972>
		if (w > INT_MAX-cnt) goto overflow;
 801cf0c:	bf00      	nop
overflow:
	errno = EOVERFLOW;
 801cf0e:	f7f2 fae1 	bl	800f4d4 <__errno_location>
 801cf12:	4603      	mov	r3, r0
 801cf14:	224b      	movs	r2, #75	; 0x4b
 801cf16:	601a      	str	r2, [r3, #0]
	return -1;
 801cf18:	f04f 33ff 	mov.w	r3, #4294967295
}
 801cf1c:	4a05      	ldr	r2, [pc, #20]	; (801cf34 <printf_core+0x998>)
 801cf1e:	6811      	ldr	r1, [r2, #0]
 801cf20:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 801cf24:	4051      	eors	r1, r2
 801cf26:	d001      	beq.n	801cf2c <printf_core+0x990>
 801cf28:	f7e7 fa5e 	bl	80043e8 <__stack_chk_fail>
 801cf2c:	4618      	mov	r0, r3
 801cf2e:	37a0      	adds	r7, #160	; 0xa0
 801cf30:	46bd      	mov	sp, r7
 801cf32:	bd80      	pop	{r7, pc}
 801cf34:	080231cc 	.word	0x080231cc

0801cf38 <vfprintf>:

int vfprintf(FILE *restrict f, const char *restrict fmt, va_list ap)
{
 801cf38:	b580      	push	{r7, lr}
 801cf3a:	b0c0      	sub	sp, #256	; 0x100
 801cf3c:	af02      	add	r7, sp, #8
 801cf3e:	60f8      	str	r0, [r7, #12]
 801cf40:	60b9      	str	r1, [r7, #8]
 801cf42:	607a      	str	r2, [r7, #4]
 801cf44:	4b59      	ldr	r3, [pc, #356]	; (801d0ac <vfprintf+0x174>)
 801cf46:	681b      	ldr	r3, [r3, #0]
 801cf48:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 801cf4c:	f04f 0300 	mov.w	r3, #0
	va_list ap2;
	int nl_type[NL_ARGMAX+1] = {0};
 801cf50:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801cf54:	2228      	movs	r2, #40	; 0x28
 801cf56:	2100      	movs	r1, #0
 801cf58:	4618      	mov	r0, r3
 801cf5a:	f7f1 fc73 	bl	800e844 <memset>
	union arg nl_arg[NL_ARGMAX+1];
	unsigned char internal_buf[80], *saved_buf = 0;
 801cf5e:	2300      	movs	r3, #0
 801cf60:	61bb      	str	r3, [r7, #24]
	int olderr;
	int ret;

	/* the copy allows passing va_list* even if va_list is an array */
	va_copy(ap2, ap);
 801cf62:	687b      	ldr	r3, [r7, #4]
 801cf64:	617b      	str	r3, [r7, #20]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
 801cf66:	f107 0150 	add.w	r1, r7, #80	; 0x50
 801cf6a:	f107 0214 	add.w	r2, r7, #20
 801cf6e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801cf72:	9300      	str	r3, [sp, #0]
 801cf74:	460b      	mov	r3, r1
 801cf76:	68b9      	ldr	r1, [r7, #8]
 801cf78:	2000      	movs	r0, #0
 801cf7a:	f7ff fb0f 	bl	801c59c <printf_core>
 801cf7e:	4603      	mov	r3, r0
 801cf80:	2b00      	cmp	r3, #0
 801cf82:	da02      	bge.n	801cf8a <vfprintf+0x52>
		va_end(ap2);
		return -1;
 801cf84:	f04f 33ff 	mov.w	r3, #4294967295
 801cf88:	e084      	b.n	801d094 <vfprintf+0x15c>
	}

	FLOCK(f);
 801cf8a:	68fb      	ldr	r3, [r7, #12]
 801cf8c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801cf8e:	2b00      	cmp	r3, #0
 801cf90:	db04      	blt.n	801cf9c <vfprintf+0x64>
 801cf92:	68f8      	ldr	r0, [r7, #12]
 801cf94:	f000 f88c 	bl	801d0b0 <__lockfile>
 801cf98:	4603      	mov	r3, r0
 801cf9a:	e000      	b.n	801cf9e <vfprintf+0x66>
 801cf9c:	2300      	movs	r3, #0
 801cf9e:	623b      	str	r3, [r7, #32]
	olderr = f->flags & F_ERR;
 801cfa0:	68fb      	ldr	r3, [r7, #12]
 801cfa2:	681b      	ldr	r3, [r3, #0]
 801cfa4:	f003 0320 	and.w	r3, r3, #32
 801cfa8:	627b      	str	r3, [r7, #36]	; 0x24
	if (f->mode < 1) f->flags &= ~F_ERR;
 801cfaa:	68fb      	ldr	r3, [r7, #12]
 801cfac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801cfae:	2b00      	cmp	r3, #0
 801cfb0:	dc05      	bgt.n	801cfbe <vfprintf+0x86>
 801cfb2:	68fb      	ldr	r3, [r7, #12]
 801cfb4:	681b      	ldr	r3, [r3, #0]
 801cfb6:	f023 0220 	bic.w	r2, r3, #32
 801cfba:	68fb      	ldr	r3, [r7, #12]
 801cfbc:	601a      	str	r2, [r3, #0]
	if (!f->buf_size) {
 801cfbe:	68fb      	ldr	r3, [r7, #12]
 801cfc0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801cfc2:	2b00      	cmp	r3, #0
 801cfc4:	d114      	bne.n	801cff0 <vfprintf+0xb8>
		saved_buf = f->buf;
 801cfc6:	68fb      	ldr	r3, [r7, #12]
 801cfc8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801cfca:	61bb      	str	r3, [r7, #24]
		f->buf = internal_buf;
 801cfcc:	68fb      	ldr	r3, [r7, #12]
 801cfce:	f107 02a4 	add.w	r2, r7, #164	; 0xa4
 801cfd2:	631a      	str	r2, [r3, #48]	; 0x30
		f->buf_size = sizeof internal_buf;
 801cfd4:	68fb      	ldr	r3, [r7, #12]
 801cfd6:	2250      	movs	r2, #80	; 0x50
 801cfd8:	635a      	str	r2, [r3, #52]	; 0x34
		f->wpos = f->wbase = f->wend = 0;
 801cfda:	68fb      	ldr	r3, [r7, #12]
 801cfdc:	2200      	movs	r2, #0
 801cfde:	611a      	str	r2, [r3, #16]
 801cfe0:	68fb      	ldr	r3, [r7, #12]
 801cfe2:	691a      	ldr	r2, [r3, #16]
 801cfe4:	68fb      	ldr	r3, [r7, #12]
 801cfe6:	61da      	str	r2, [r3, #28]
 801cfe8:	68fb      	ldr	r3, [r7, #12]
 801cfea:	69da      	ldr	r2, [r3, #28]
 801cfec:	68fb      	ldr	r3, [r7, #12]
 801cfee:	615a      	str	r2, [r3, #20]
	}
	if (!f->wend && __towrite(f)) ret = -1;
 801cff0:	68fb      	ldr	r3, [r7, #12]
 801cff2:	691b      	ldr	r3, [r3, #16]
 801cff4:	2b00      	cmp	r3, #0
 801cff6:	d109      	bne.n	801d00c <vfprintf+0xd4>
 801cff8:	68f8      	ldr	r0, [r7, #12]
 801cffa:	f000 f87a 	bl	801d0f2 <__towrite>
 801cffe:	4603      	mov	r3, r0
 801d000:	2b00      	cmp	r3, #0
 801d002:	d003      	beq.n	801d00c <vfprintf+0xd4>
 801d004:	f04f 33ff 	mov.w	r3, #4294967295
 801d008:	61fb      	str	r3, [r7, #28]
 801d00a:	e00c      	b.n	801d026 <vfprintf+0xee>
	else ret = printf_core(f, fmt, &ap2, nl_arg, nl_type);
 801d00c:	f107 0150 	add.w	r1, r7, #80	; 0x50
 801d010:	f107 0214 	add.w	r2, r7, #20
 801d014:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801d018:	9300      	str	r3, [sp, #0]
 801d01a:	460b      	mov	r3, r1
 801d01c:	68b9      	ldr	r1, [r7, #8]
 801d01e:	68f8      	ldr	r0, [r7, #12]
 801d020:	f7ff fabc 	bl	801c59c <printf_core>
 801d024:	61f8      	str	r0, [r7, #28]
	if (saved_buf) {
 801d026:	69bb      	ldr	r3, [r7, #24]
 801d028:	2b00      	cmp	r3, #0
 801d02a:	d01d      	beq.n	801d068 <vfprintf+0x130>
		f->write(f, 0, 0);
 801d02c:	68fb      	ldr	r3, [r7, #12]
 801d02e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801d030:	2200      	movs	r2, #0
 801d032:	2100      	movs	r1, #0
 801d034:	68f8      	ldr	r0, [r7, #12]
 801d036:	4798      	blx	r3
		if (!f->wpos) ret = -1;
 801d038:	68fb      	ldr	r3, [r7, #12]
 801d03a:	695b      	ldr	r3, [r3, #20]
 801d03c:	2b00      	cmp	r3, #0
 801d03e:	d102      	bne.n	801d046 <vfprintf+0x10e>
 801d040:	f04f 33ff 	mov.w	r3, #4294967295
 801d044:	61fb      	str	r3, [r7, #28]
		f->buf = saved_buf;
 801d046:	68fb      	ldr	r3, [r7, #12]
 801d048:	69ba      	ldr	r2, [r7, #24]
 801d04a:	631a      	str	r2, [r3, #48]	; 0x30
		f->buf_size = 0;
 801d04c:	68fb      	ldr	r3, [r7, #12]
 801d04e:	2200      	movs	r2, #0
 801d050:	635a      	str	r2, [r3, #52]	; 0x34
		f->wpos = f->wbase = f->wend = 0;
 801d052:	68fb      	ldr	r3, [r7, #12]
 801d054:	2200      	movs	r2, #0
 801d056:	611a      	str	r2, [r3, #16]
 801d058:	68fb      	ldr	r3, [r7, #12]
 801d05a:	691a      	ldr	r2, [r3, #16]
 801d05c:	68fb      	ldr	r3, [r7, #12]
 801d05e:	61da      	str	r2, [r3, #28]
 801d060:	68fb      	ldr	r3, [r7, #12]
 801d062:	69da      	ldr	r2, [r3, #28]
 801d064:	68fb      	ldr	r3, [r7, #12]
 801d066:	615a      	str	r2, [r3, #20]
	}
	if (f->flags & F_ERR) ret = -1;
 801d068:	68fb      	ldr	r3, [r7, #12]
 801d06a:	681b      	ldr	r3, [r3, #0]
 801d06c:	f003 0320 	and.w	r3, r3, #32
 801d070:	2b00      	cmp	r3, #0
 801d072:	d002      	beq.n	801d07a <vfprintf+0x142>
 801d074:	f04f 33ff 	mov.w	r3, #4294967295
 801d078:	61fb      	str	r3, [r7, #28]
	f->flags |= olderr;
 801d07a:	68fb      	ldr	r3, [r7, #12]
 801d07c:	681a      	ldr	r2, [r3, #0]
 801d07e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d080:	431a      	orrs	r2, r3
 801d082:	68fb      	ldr	r3, [r7, #12]
 801d084:	601a      	str	r2, [r3, #0]
	FUNLOCK(f);
 801d086:	6a3b      	ldr	r3, [r7, #32]
 801d088:	2b00      	cmp	r3, #0
 801d08a:	d002      	beq.n	801d092 <vfprintf+0x15a>
 801d08c:	68f8      	ldr	r0, [r7, #12]
 801d08e:	f000 f820 	bl	801d0d2 <__unlockfile>
	va_end(ap2);
	return ret;
 801d092:	69fb      	ldr	r3, [r7, #28]
}
 801d094:	4a05      	ldr	r2, [pc, #20]	; (801d0ac <vfprintf+0x174>)
 801d096:	6811      	ldr	r1, [r2, #0]
 801d098:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 801d09c:	4051      	eors	r1, r2
 801d09e:	d001      	beq.n	801d0a4 <vfprintf+0x16c>
 801d0a0:	f7e7 f9a2 	bl	80043e8 <__stack_chk_fail>
 801d0a4:	4618      	mov	r0, r3
 801d0a6:	37f8      	adds	r7, #248	; 0xf8
 801d0a8:	46bd      	mov	sp, r7
 801d0aa:	bd80      	pop	{r7, pc}
 801d0ac:	080231d0 	.word	0x080231d0

0801d0b0 <__lockfile>:
#include "stdio_impl.h"
#include "pthread_impl.h"

int __lockfile(FILE *f)
{
 801d0b0:	b580      	push	{r7, lr}
 801d0b2:	b082      	sub	sp, #8
 801d0b4:	af00      	add	r7, sp, #0
 801d0b6:	6078      	str	r0, [r7, #4]
		    a_cas(&f->lock, owner, owner|MAYBE_WAITERS)==owner)
			__futexwait(&f->lock, owner|MAYBE_WAITERS, 1);
	}
	return 1;
#else
	if (f != NULL) {
 801d0b8:	687b      	ldr	r3, [r7, #4]
 801d0ba:	2b00      	cmp	r3, #0
 801d0bc:	d004      	beq.n	801d0c8 <__lockfile+0x18>
		pthread_mutex_lock(&(f->_lock));
 801d0be:	687b      	ldr	r3, [r7, #4]
 801d0c0:	3380      	adds	r3, #128	; 0x80
 801d0c2:	4618      	mov	r0, r3
 801d0c4:	f002 fa27 	bl	801f516 <pthread_mutex_lock>
	}
	return 1;
 801d0c8:	2301      	movs	r3, #1
#endif
}
 801d0ca:	4618      	mov	r0, r3
 801d0cc:	3708      	adds	r7, #8
 801d0ce:	46bd      	mov	sp, r7
 801d0d0:	bd80      	pop	{r7, pc}

0801d0d2 <__unlockfile>:

void __unlockfile(FILE *f)
{
 801d0d2:	b580      	push	{r7, lr}
 801d0d4:	b082      	sub	sp, #8
 801d0d6:	af00      	add	r7, sp, #0
 801d0d8:	6078      	str	r0, [r7, #4]
#ifndef __LITEOS__
	if (a_swap(&f->lock, 0) & MAYBE_WAITERS)
		__wake(&f->lock, 1, 1);
#else
	if (f != NULL) {
 801d0da:	687b      	ldr	r3, [r7, #4]
 801d0dc:	2b00      	cmp	r3, #0
 801d0de:	d004      	beq.n	801d0ea <__unlockfile+0x18>
		pthread_mutex_unlock(&(f->_lock));
 801d0e0:	687b      	ldr	r3, [r7, #4]
 801d0e2:	3380      	adds	r3, #128	; 0x80
 801d0e4:	4618      	mov	r0, r3
 801d0e6:	f002 fa4b 	bl	801f580 <pthread_mutex_unlock>
	}
#endif
}
 801d0ea:	bf00      	nop
 801d0ec:	3708      	adds	r7, #8
 801d0ee:	46bd      	mov	sp, r7
 801d0f0:	bd80      	pop	{r7, pc}

0801d0f2 <__towrite>:
#include "stdio_impl.h"

int __towrite(FILE *f)
{
 801d0f2:	b480      	push	{r7}
 801d0f4:	b083      	sub	sp, #12
 801d0f6:	af00      	add	r7, sp, #0
 801d0f8:	6078      	str	r0, [r7, #4]
	f->mode |= f->mode-1;
 801d0fa:	687b      	ldr	r3, [r7, #4]
 801d0fc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801d0fe:	687b      	ldr	r3, [r7, #4]
 801d100:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801d102:	3b01      	subs	r3, #1
 801d104:	431a      	orrs	r2, r3
 801d106:	687b      	ldr	r3, [r7, #4]
 801d108:	64da      	str	r2, [r3, #76]	; 0x4c
	if (f->flags & F_NOWR) {
 801d10a:	687b      	ldr	r3, [r7, #4]
 801d10c:	681b      	ldr	r3, [r3, #0]
 801d10e:	f003 0308 	and.w	r3, r3, #8
 801d112:	2b00      	cmp	r3, #0
 801d114:	d008      	beq.n	801d128 <__towrite+0x36>
		f->flags |= F_ERR;
 801d116:	687b      	ldr	r3, [r7, #4]
 801d118:	681b      	ldr	r3, [r3, #0]
 801d11a:	f043 0220 	orr.w	r2, r3, #32
 801d11e:	687b      	ldr	r3, [r7, #4]
 801d120:	601a      	str	r2, [r3, #0]
		return EOF;
 801d122:	f04f 33ff 	mov.w	r3, #4294967295
 801d126:	e01f      	b.n	801d168 <__towrite+0x76>
	}
#ifdef __LITEOS__
	if (f->flags & F_CLS) {
 801d128:	687b      	ldr	r3, [r7, #4]
 801d12a:	681b      	ldr	r3, [r3, #0]
 801d12c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801d130:	2b00      	cmp	r3, #0
 801d132:	d002      	beq.n	801d13a <__towrite+0x48>
		return EOF;
 801d134:	f04f 33ff 	mov.w	r3, #4294967295
 801d138:	e016      	b.n	801d168 <__towrite+0x76>
	}
#endif
	/* Clear read buffer (easier than summoning nasal demons) */
	f->rpos = f->rend = 0;
 801d13a:	687b      	ldr	r3, [r7, #4]
 801d13c:	2200      	movs	r2, #0
 801d13e:	609a      	str	r2, [r3, #8]
 801d140:	687b      	ldr	r3, [r7, #4]
 801d142:	689a      	ldr	r2, [r3, #8]
 801d144:	687b      	ldr	r3, [r7, #4]
 801d146:	605a      	str	r2, [r3, #4]

	/* Activate write through the buffer. */
	f->wpos = f->wbase = f->buf;
 801d148:	687b      	ldr	r3, [r7, #4]
 801d14a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801d14c:	687b      	ldr	r3, [r7, #4]
 801d14e:	61da      	str	r2, [r3, #28]
 801d150:	687b      	ldr	r3, [r7, #4]
 801d152:	69da      	ldr	r2, [r3, #28]
 801d154:	687b      	ldr	r3, [r7, #4]
 801d156:	615a      	str	r2, [r3, #20]
	f->wend = f->buf + f->buf_size;
 801d158:	687b      	ldr	r3, [r7, #4]
 801d15a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801d15c:	687b      	ldr	r3, [r7, #4]
 801d15e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801d160:	441a      	add	r2, r3
 801d162:	687b      	ldr	r3, [r7, #4]
 801d164:	611a      	str	r2, [r3, #16]

	return 0;
 801d166:	2300      	movs	r3, #0
}
 801d168:	4618      	mov	r0, r3
 801d16a:	370c      	adds	r7, #12
 801d16c:	46bd      	mov	sp, r7
 801d16e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d172:	4770      	bx	lr

0801d174 <__fwritex>:
#if defined(__LITEOS__) && defined(LOSCFG_LLTSER)
#include "gcov_ser.h"
#endif

size_t __fwritex(const unsigned char * restrict s, size_t l, FILE * restrict f)
{
 801d174:	b580      	push	{r7, lr}
 801d176:	b086      	sub	sp, #24
 801d178:	af00      	add	r7, sp, #0
 801d17a:	60f8      	str	r0, [r7, #12]
 801d17c:	60b9      	str	r1, [r7, #8]
 801d17e:	607a      	str	r2, [r7, #4]
	size_t i = 0;
 801d180:	2300      	movs	r3, #0
 801d182:	613b      	str	r3, [r7, #16]

	if (!f->wend && __towrite(f)) {
 801d184:	687b      	ldr	r3, [r7, #4]
 801d186:	691b      	ldr	r3, [r3, #16]
 801d188:	2b00      	cmp	r3, #0
 801d18a:	d107      	bne.n	801d19c <__fwritex+0x28>
 801d18c:	6878      	ldr	r0, [r7, #4]
 801d18e:	f7ff ffb0 	bl	801d0f2 <__towrite>
 801d192:	4603      	mov	r3, r0
 801d194:	2b00      	cmp	r3, #0
 801d196:	d001      	beq.n	801d19c <__fwritex+0x28>
		return 0;
 801d198:	2300      	movs	r3, #0
 801d19a:	e04c      	b.n	801d236 <__fwritex+0xc2>
	}

	if (l > f->wend - f->wpos) {
 801d19c:	687b      	ldr	r3, [r7, #4]
 801d19e:	691a      	ldr	r2, [r3, #16]
 801d1a0:	687b      	ldr	r3, [r7, #4]
 801d1a2:	695b      	ldr	r3, [r3, #20]
 801d1a4:	1ad3      	subs	r3, r2, r3
 801d1a6:	461a      	mov	r2, r3
 801d1a8:	68bb      	ldr	r3, [r7, #8]
 801d1aa:	4293      	cmp	r3, r2
 801d1ac:	d907      	bls.n	801d1be <__fwritex+0x4a>
		return f->write(f, s, l);
 801d1ae:	687b      	ldr	r3, [r7, #4]
 801d1b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801d1b2:	68ba      	ldr	r2, [r7, #8]
 801d1b4:	68f9      	ldr	r1, [r7, #12]
 801d1b6:	6878      	ldr	r0, [r7, #4]
 801d1b8:	4798      	blx	r3
 801d1ba:	4603      	mov	r3, r0
 801d1bc:	e03b      	b.n	801d236 <__fwritex+0xc2>
	}

	if (f->lbf >= 0) {
 801d1be:	687b      	ldr	r3, [r7, #4]
 801d1c0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801d1c2:	2b00      	cmp	r3, #0
 801d1c4:	db27      	blt.n	801d216 <__fwritex+0xa2>
		/* Match /^(.*\n|)/ */
		for (i = l; i && s[i - 1] != '\n'; i--);
 801d1c6:	68bb      	ldr	r3, [r7, #8]
 801d1c8:	613b      	str	r3, [r7, #16]
 801d1ca:	e002      	b.n	801d1d2 <__fwritex+0x5e>
 801d1cc:	693b      	ldr	r3, [r7, #16]
 801d1ce:	3b01      	subs	r3, #1
 801d1d0:	613b      	str	r3, [r7, #16]
 801d1d2:	693b      	ldr	r3, [r7, #16]
 801d1d4:	2b00      	cmp	r3, #0
 801d1d6:	d006      	beq.n	801d1e6 <__fwritex+0x72>
 801d1d8:	693b      	ldr	r3, [r7, #16]
 801d1da:	3b01      	subs	r3, #1
 801d1dc:	68fa      	ldr	r2, [r7, #12]
 801d1de:	4413      	add	r3, r2
 801d1e0:	781b      	ldrb	r3, [r3, #0]
 801d1e2:	2b0a      	cmp	r3, #10
 801d1e4:	d1f2      	bne.n	801d1cc <__fwritex+0x58>
		if (i) {
 801d1e6:	693b      	ldr	r3, [r7, #16]
 801d1e8:	2b00      	cmp	r3, #0
 801d1ea:	d014      	beq.n	801d216 <__fwritex+0xa2>
			size_t n = f->write(f, s, i);
 801d1ec:	687b      	ldr	r3, [r7, #4]
 801d1ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801d1f0:	693a      	ldr	r2, [r7, #16]
 801d1f2:	68f9      	ldr	r1, [r7, #12]
 801d1f4:	6878      	ldr	r0, [r7, #4]
 801d1f6:	4798      	blx	r3
 801d1f8:	6178      	str	r0, [r7, #20]
			if (n < i) {
 801d1fa:	697a      	ldr	r2, [r7, #20]
 801d1fc:	693b      	ldr	r3, [r7, #16]
 801d1fe:	429a      	cmp	r2, r3
 801d200:	d201      	bcs.n	801d206 <__fwritex+0x92>
				return n;
 801d202:	697b      	ldr	r3, [r7, #20]
 801d204:	e017      	b.n	801d236 <__fwritex+0xc2>
			}
			s += i;
 801d206:	68fa      	ldr	r2, [r7, #12]
 801d208:	693b      	ldr	r3, [r7, #16]
 801d20a:	4413      	add	r3, r2
 801d20c:	60fb      	str	r3, [r7, #12]
			l -= i;
 801d20e:	68ba      	ldr	r2, [r7, #8]
 801d210:	693b      	ldr	r3, [r7, #16]
 801d212:	1ad3      	subs	r3, r2, r3
 801d214:	60bb      	str	r3, [r7, #8]
		}
	}

	memcpy(f->wpos, s, l);
 801d216:	687b      	ldr	r3, [r7, #4]
 801d218:	695b      	ldr	r3, [r3, #20]
 801d21a:	68ba      	ldr	r2, [r7, #8]
 801d21c:	68f9      	ldr	r1, [r7, #12]
 801d21e:	4618      	mov	r0, r3
 801d220:	f7fb fe56 	bl	8018ed0 <memcpy>
	f->wpos += l;
 801d224:	687b      	ldr	r3, [r7, #4]
 801d226:	695a      	ldr	r2, [r3, #20]
 801d228:	68bb      	ldr	r3, [r7, #8]
 801d22a:	441a      	add	r2, r3
 801d22c:	687b      	ldr	r3, [r7, #4]
 801d22e:	615a      	str	r2, [r3, #20]
	return l + i;
 801d230:	68ba      	ldr	r2, [r7, #8]
 801d232:	693b      	ldr	r3, [r7, #16]
 801d234:	4413      	add	r3, r2
}
 801d236:	4618      	mov	r0, r3
 801d238:	3718      	adds	r7, #24
 801d23a:	46bd      	mov	sp, r7
 801d23c:	bd80      	pop	{r7, pc}

0801d23e <LOS_IntLock>:
{
 801d23e:	b580      	push	{r7, lr}
 801d240:	af00      	add	r7, sp, #0
    return ArchIntLock();
 801d242:	f7e3 fd41 	bl	8000cc8 <ArchIntLock>
 801d246:	4603      	mov	r3, r0
}
 801d248:	4618      	mov	r0, r3
 801d24a:	bd80      	pop	{r7, pc}

0801d24c <LOS_IntRestore>:
{
 801d24c:	b580      	push	{r7, lr}
 801d24e:	b082      	sub	sp, #8
 801d250:	af00      	add	r7, sp, #0
 801d252:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 801d254:	6878      	ldr	r0, [r7, #4]
 801d256:	f7e3 fd3f 	bl	8000cd8 <ArchIntRestore>
}
 801d25a:	bf00      	nop
 801d25c:	3708      	adds	r7, #8
 801d25e:	46bd      	mov	sp, r7
 801d260:	bd80      	pop	{r7, pc}

0801d262 <LOS_SpinLockSave>:
{
 801d262:	b580      	push	{r7, lr}
 801d264:	b082      	sub	sp, #8
 801d266:	af00      	add	r7, sp, #0
 801d268:	6078      	str	r0, [r7, #4]
 801d26a:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 801d26c:	f7ff ffe7 	bl	801d23e <LOS_IntLock>
 801d270:	4602      	mov	r2, r0
 801d272:	683b      	ldr	r3, [r7, #0]
 801d274:	601a      	str	r2, [r3, #0]
}
 801d276:	bf00      	nop
 801d278:	3708      	adds	r7, #8
 801d27a:	46bd      	mov	sp, r7
 801d27c:	bd80      	pop	{r7, pc}

0801d27e <LOS_SpinUnlockRestore>:
{
 801d27e:	b580      	push	{r7, lr}
 801d280:	b082      	sub	sp, #8
 801d282:	af00      	add	r7, sp, #0
 801d284:	6078      	str	r0, [r7, #4]
 801d286:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 801d288:	6838      	ldr	r0, [r7, #0]
 801d28a:	f7ff ffdf 	bl	801d24c <LOS_IntRestore>
}
 801d28e:	bf00      	nop
 801d290:	3708      	adds	r7, #8
 801d292:	46bd      	mov	sp, r7
 801d294:	bd80      	pop	{r7, pc}
	...

0801d298 <ValidTimeval64>:
    return TRUE;
}

#ifndef LOSCFG_AARCH64
STATIC INLINE BOOL ValidTimeval64(const struct timeval64 *tv)
{
 801d298:	b480      	push	{r7}
 801d29a:	b083      	sub	sp, #12
 801d29c:	af00      	add	r7, sp, #0
 801d29e:	6078      	str	r0, [r7, #4]
    /* Fail a NULL pointer */
    if (tv == NULL) {
 801d2a0:	687b      	ldr	r3, [r7, #4]
 801d2a2:	2b00      	cmp	r3, #0
 801d2a4:	d101      	bne.n	801d2aa <ValidTimeval64+0x12>
        return FALSE;
 801d2a6:	2300      	movs	r3, #0
 801d2a8:	e01a      	b.n	801d2e0 <ValidTimeval64+0x48>
    }

    /* Fail illegal microseconds values */
    if ((tv->tv_usec < 0) || (tv->tv_usec >= OS_SYS_US_PER_SECOND) || (tv->tv_sec < 0)) {
 801d2aa:	687b      	ldr	r3, [r7, #4]
 801d2ac:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 801d2b0:	2a00      	cmp	r2, #0
 801d2b2:	f173 0300 	sbcs.w	r3, r3, #0
 801d2b6:	db10      	blt.n	801d2da <ValidTimeval64+0x42>
 801d2b8:	687b      	ldr	r3, [r7, #4]
 801d2ba:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 801d2be:	480b      	ldr	r0, [pc, #44]	; (801d2ec <ValidTimeval64+0x54>)
 801d2c0:	f04f 0100 	mov.w	r1, #0
 801d2c4:	4290      	cmp	r0, r2
 801d2c6:	eb71 0303 	sbcs.w	r3, r1, r3
 801d2ca:	db06      	blt.n	801d2da <ValidTimeval64+0x42>
 801d2cc:	687b      	ldr	r3, [r7, #4]
 801d2ce:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d2d2:	2a00      	cmp	r2, #0
 801d2d4:	f173 0300 	sbcs.w	r3, r3, #0
 801d2d8:	da01      	bge.n	801d2de <ValidTimeval64+0x46>
        return FALSE;
 801d2da:	2300      	movs	r3, #0
 801d2dc:	e000      	b.n	801d2e0 <ValidTimeval64+0x48>
    }

    return TRUE;
 801d2de:	2301      	movs	r3, #1
}
 801d2e0:	4618      	mov	r0, r3
 801d2e2:	370c      	adds	r7, #12
 801d2e4:	46bd      	mov	sp, r7
 801d2e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d2ea:	4770      	bx	lr
 801d2ec:	000f423f 	.word	0x000f423f

0801d2f0 <OsTimeSpecAdd>:
    LOS_SpinUnlockRestore(&g_timeSpin, intSave);
    return 0;
}

STATIC INLINE struct timespec64 OsTimeSpecAdd(const struct timespec64 t1, const struct timespec64 t2)
{
 801d2f0:	b082      	sub	sp, #8
 801d2f2:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 801d2f6:	b08d      	sub	sp, #52	; 0x34
 801d2f8:	af00      	add	r7, sp, #0
 801d2fa:	61f8      	str	r0, [r7, #28]
 801d2fc:	f107 0150 	add.w	r1, r7, #80	; 0x50
 801d300:	e881 000c 	stmia.w	r1, {r2, r3}
    struct timespec64 ret = {0};
 801d304:	f107 0320 	add.w	r3, r7, #32
 801d308:	2200      	movs	r2, #0
 801d30a:	601a      	str	r2, [r3, #0]
 801d30c:	605a      	str	r2, [r3, #4]
 801d30e:	609a      	str	r2, [r3, #8]
 801d310:	60da      	str	r2, [r3, #12]

    ret.tv_sec = t1.tv_sec + t2.tv_sec;
 801d312:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 801d316:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801d31a:	1884      	adds	r4, r0, r2
 801d31c:	eb41 0503 	adc.w	r5, r1, r3
 801d320:	e9c7 4508 	strd	r4, r5, [r7, #32]
    ret.tv_nsec = t1.tv_nsec + t2.tv_nsec;
 801d324:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	; 0x58
 801d328:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	; 0x68
 801d32c:	1884      	adds	r4, r0, r2
 801d32e:	613c      	str	r4, [r7, #16]
 801d330:	eb41 0303 	adc.w	r3, r1, r3
 801d334:	617b      	str	r3, [r7, #20]
 801d336:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 801d33a:	e9c7 340a 	strd	r3, r4, [r7, #40]	; 0x28
    if (ret.tv_nsec >= OS_SYS_NS_PER_SECOND) {
 801d33e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d342:	a123      	add	r1, pc, #140	; (adr r1, 801d3d0 <OsTimeSpecAdd+0xe0>)
 801d344:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d348:	4290      	cmp	r0, r2
 801d34a:	eb71 0303 	sbcs.w	r3, r1, r3
 801d34e:	da18      	bge.n	801d382 <OsTimeSpecAdd+0x92>
        ret.tv_sec += 1;
 801d350:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801d354:	1c51      	adds	r1, r2, #1
 801d356:	60b9      	str	r1, [r7, #8]
 801d358:	f143 0300 	adc.w	r3, r3, #0
 801d35c:	60fb      	str	r3, [r7, #12]
 801d35e:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 801d362:	e9c7 3408 	strd	r3, r4, [r7, #32]
        ret.tv_nsec -= OS_SYS_NS_PER_SECOND;
 801d366:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d36a:	a11b      	add	r1, pc, #108	; (adr r1, 801d3d8 <OsTimeSpecAdd+0xe8>)
 801d36c:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d370:	1814      	adds	r4, r2, r0
 801d372:	603c      	str	r4, [r7, #0]
 801d374:	414b      	adcs	r3, r1
 801d376:	607b      	str	r3, [r7, #4]
 801d378:	e9d7 3400 	ldrd	r3, r4, [r7]
 801d37c:	e9c7 340a 	strd	r3, r4, [r7, #40]	; 0x28
 801d380:	e018      	b.n	801d3b4 <OsTimeSpecAdd+0xc4>
    } else if (ret.tv_nsec < 0L) {
 801d382:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d386:	2a00      	cmp	r2, #0
 801d388:	f173 0300 	sbcs.w	r3, r3, #0
 801d38c:	da12      	bge.n	801d3b4 <OsTimeSpecAdd+0xc4>
        ret.tv_sec -= 1;
 801d38e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801d392:	f112 3aff 	adds.w	sl, r2, #4294967295
 801d396:	f143 3bff 	adc.w	fp, r3, #4294967295
 801d39a:	e9c7 ab08 	strd	sl, fp, [r7, #32]
        ret.tv_nsec += OS_SYS_NS_PER_SECOND;
 801d39e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d3a2:	a10f      	add	r1, pc, #60	; (adr r1, 801d3e0 <OsTimeSpecAdd+0xf0>)
 801d3a4:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d3a8:	eb12 0800 	adds.w	r8, r2, r0
 801d3ac:	eb43 0901 	adc.w	r9, r3, r1
 801d3b0:	e9c7 890a 	strd	r8, r9, [r7, #40]	; 0x28
    }

    return ret;
 801d3b4:	69fb      	ldr	r3, [r7, #28]
 801d3b6:	461c      	mov	r4, r3
 801d3b8:	f107 0320 	add.w	r3, r7, #32
 801d3bc:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d3be:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 801d3c2:	69f8      	ldr	r0, [r7, #28]
 801d3c4:	3734      	adds	r7, #52	; 0x34
 801d3c6:	46bd      	mov	sp, r7
 801d3c8:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 801d3cc:	b002      	add	sp, #8
 801d3ce:	4770      	bx	lr
 801d3d0:	3b9ac9ff 	.word	0x3b9ac9ff
 801d3d4:	00000000 	.word	0x00000000
 801d3d8:	c4653600 	.word	0xc4653600
 801d3dc:	ffffffff 	.word	0xffffffff
 801d3e0:	3b9aca00 	.word	0x3b9aca00
 801d3e4:	00000000 	.word	0x00000000

0801d3e8 <OsTimeSpecSub>:

STATIC INLINE struct timespec64 OsTimeSpecSub(const struct timespec64 t1, const struct timespec64 t2)
{
 801d3e8:	b082      	sub	sp, #8
 801d3ea:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801d3ee:	b088      	sub	sp, #32
 801d3f0:	af00      	add	r7, sp, #0
 801d3f2:	60f8      	str	r0, [r7, #12]
 801d3f4:	f107 0140 	add.w	r1, r7, #64	; 0x40
 801d3f8:	e881 000c 	stmia.w	r1, {r2, r3}
    struct timespec64 ret = {0};
 801d3fc:	f107 0310 	add.w	r3, r7, #16
 801d400:	2200      	movs	r2, #0
 801d402:	601a      	str	r2, [r3, #0]
 801d404:	605a      	str	r2, [r3, #4]
 801d406:	609a      	str	r2, [r3, #8]
 801d408:	60da      	str	r2, [r3, #12]

    ret.tv_sec = t1.tv_sec - t2.tv_sec;
 801d40a:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
 801d40e:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 801d412:	1a86      	subs	r6, r0, r2
 801d414:	603e      	str	r6, [r7, #0]
 801d416:	eb61 0303 	sbc.w	r3, r1, r3
 801d41a:	607b      	str	r3, [r7, #4]
 801d41c:	e9d7 2300 	ldrd	r2, r3, [r7]
 801d420:	e9c7 2304 	strd	r2, r3, [r7, #16]
    ret.tv_nsec = t1.tv_nsec - t2.tv_nsec;
 801d424:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
 801d428:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 801d42c:	ebb0 0a02 	subs.w	sl, r0, r2
 801d430:	eb61 0b03 	sbc.w	fp, r1, r3
 801d434:	e9c7 ab06 	strd	sl, fp, [r7, #24]
    if (ret.tv_nsec < 0) {
 801d438:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801d43c:	2a00      	cmp	r2, #0
 801d43e:	f173 0300 	sbcs.w	r3, r3, #0
 801d442:	da11      	bge.n	801d468 <OsTimeSpecSub+0x80>
        ret.tv_sec -= 1;
 801d444:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801d448:	f112 38ff 	adds.w	r8, r2, #4294967295
 801d44c:	f143 39ff 	adc.w	r9, r3, #4294967295
 801d450:	e9c7 8904 	strd	r8, r9, [r7, #16]
        ret.tv_nsec += OS_SYS_NS_PER_SECOND;
 801d454:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801d458:	a10b      	add	r1, pc, #44	; (adr r1, 801d488 <OsTimeSpecSub+0xa0>)
 801d45a:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d45e:	1814      	adds	r4, r2, r0
 801d460:	eb43 0501 	adc.w	r5, r3, r1
 801d464:	e9c7 4506 	strd	r4, r5, [r7, #24]
    }

    return ret;
 801d468:	68fb      	ldr	r3, [r7, #12]
 801d46a:	461c      	mov	r4, r3
 801d46c:	f107 0310 	add.w	r3, r7, #16
 801d470:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d472:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 801d476:	68f8      	ldr	r0, [r7, #12]
 801d478:	3720      	adds	r7, #32
 801d47a:	46bd      	mov	sp, r7
 801d47c:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801d480:	b002      	add	sp, #8
 801d482:	4770      	bx	lr
 801d484:	f3af 8000 	nop.w
 801d488:	3b9aca00 	.word	0x3b9aca00
 801d48c:	00000000 	.word	0x00000000

0801d490 <OsSetTimeOfDay>:

STATIC INT32 OsSetTimeOfDay(const struct timeval64 *tv, const struct timezone *tz)
{
 801d490:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801d494:	b0a5      	sub	sp, #148	; 0x94
 801d496:	af06      	add	r7, sp, #24
 801d498:	61f8      	str	r0, [r7, #28]
 801d49a:	61b9      	str	r1, [r7, #24]
 801d49c:	4b82      	ldr	r3, [pc, #520]	; (801d6a8 <OsSetTimeOfDay+0x218>)
 801d49e:	681b      	ldr	r3, [r3, #0]
 801d4a0:	677b      	str	r3, [r7, #116]	; 0x74
 801d4a2:	f04f 0300 	mov.w	r3, #0
    UINT64 nowNsec;
    UINT32 intSave;
    struct timespec64 setTime = {0};
 801d4a6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801d4aa:	2200      	movs	r2, #0
 801d4ac:	601a      	str	r2, [r3, #0]
 801d4ae:	605a      	str	r2, [r3, #4]
 801d4b0:	609a      	str	r2, [r3, #8]
 801d4b2:	60da      	str	r2, [r3, #12]
    struct timespec64 hwTime = {0};
 801d4b4:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801d4b8:	2200      	movs	r2, #0
 801d4ba:	601a      	str	r2, [r3, #0]
 801d4bc:	605a      	str	r2, [r3, #4]
 801d4be:	609a      	str	r2, [r3, #8]
 801d4c0:	60da      	str	r2, [r3, #12]
    struct timespec64 realTime = {0};
 801d4c2:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801d4c6:	2200      	movs	r2, #0
 801d4c8:	601a      	str	r2, [r3, #0]
 801d4ca:	605a      	str	r2, [r3, #4]
 801d4cc:	609a      	str	r2, [r3, #8]
 801d4ce:	60da      	str	r2, [r3, #12]
    struct timespec64 tmp = {0};
 801d4d0:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801d4d4:	2200      	movs	r2, #0
 801d4d6:	601a      	str	r2, [r3, #0]
 801d4d8:	605a      	str	r2, [r3, #4]
 801d4da:	609a      	str	r2, [r3, #8]
 801d4dc:	60da      	str	r2, [r3, #12]

    (VOID)tz;
    nowNsec = LOS_CurrNanosec();
 801d4de:	f7e6 fe99 	bl	8004214 <LOS_CurrNanosec>
 801d4e2:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
    setTime.tv_sec = tv->tv_sec;
 801d4e6:	69fb      	ldr	r3, [r7, #28]
 801d4e8:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d4ec:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
    setTime.tv_nsec = tv->tv_usec * OS_SYS_NS_PER_US;
 801d4f0:	69fb      	ldr	r3, [r7, #28]
 801d4f2:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 801d4f6:	4602      	mov	r2, r0
 801d4f8:	460b      	mov	r3, r1
 801d4fa:	f04f 0400 	mov.w	r4, #0
 801d4fe:	f04f 0500 	mov.w	r5, #0
 801d502:	015d      	lsls	r5, r3, #5
 801d504:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 801d508:	0154      	lsls	r4, r2, #5
 801d50a:	4622      	mov	r2, r4
 801d50c:	462b      	mov	r3, r5
 801d50e:	1a12      	subs	r2, r2, r0
 801d510:	eb63 0301 	sbc.w	r3, r3, r1
 801d514:	f04f 0400 	mov.w	r4, #0
 801d518:	f04f 0500 	mov.w	r5, #0
 801d51c:	009d      	lsls	r5, r3, #2
 801d51e:	ea45 7592 	orr.w	r5, r5, r2, lsr #30
 801d522:	0094      	lsls	r4, r2, #2
 801d524:	4622      	mov	r2, r4
 801d526:	462b      	mov	r3, r5
 801d528:	1812      	adds	r2, r2, r0
 801d52a:	eb41 0303 	adc.w	r3, r1, r3
 801d52e:	f04f 0000 	mov.w	r0, #0
 801d532:	f04f 0100 	mov.w	r1, #0
 801d536:	00d9      	lsls	r1, r3, #3
 801d538:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 801d53c:	00d0      	lsls	r0, r2, #3
 801d53e:	4602      	mov	r2, r0
 801d540:	460b      	mov	r3, r1
 801d542:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
    hwTime.tv_sec = nowNsec / OS_SYS_NS_PER_SECOND;
 801d546:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 801d54a:	a355      	add	r3, pc, #340	; (adr r3, 801d6a0 <OsSetTimeOfDay+0x210>)
 801d54c:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d550:	f7e3 fa20 	bl	8000994 <__aeabi_uldivmod>
 801d554:	4602      	mov	r2, r0
 801d556:	460b      	mov	r3, r1
 801d558:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40
    hwTime.tv_nsec = (INT64)(nowNsec -  hwTime.tv_sec * OS_SYS_NS_PER_SECOND);
 801d55c:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 801d560:	4952      	ldr	r1, [pc, #328]	; (801d6ac <OsSetTimeOfDay+0x21c>)
 801d562:	fb01 f003 	mul.w	r0, r1, r3
 801d566:	2100      	movs	r1, #0
 801d568:	fb01 f102 	mul.w	r1, r1, r2
 801d56c:	4401      	add	r1, r0
 801d56e:	484f      	ldr	r0, [pc, #316]	; (801d6ac <OsSetTimeOfDay+0x21c>)
 801d570:	fba2 2300 	umull	r2, r3, r2, r0
 801d574:	4419      	add	r1, r3
 801d576:	460b      	mov	r3, r1
 801d578:	4610      	mov	r0, r2
 801d57a:	4619      	mov	r1, r3
 801d57c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d580:	ebb2 0800 	subs.w	r8, r2, r0
 801d584:	eb63 0901 	sbc.w	r9, r3, r1
 801d588:	4642      	mov	r2, r8
 801d58a:	464b      	mov	r3, r9
 801d58c:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48

    LOS_SpinLockSave(&g_timeSpin, &intSave);
 801d590:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801d594:	4619      	mov	r1, r3
 801d596:	4846      	ldr	r0, [pc, #280]	; (801d6b0 <OsSetTimeOfDay+0x220>)
 801d598:	f7ff fe63 	bl	801d262 <LOS_SpinLockSave>
    /* stop on-going continuous adjusement */
    if (g_adjTimeLeft) {
 801d59c:	4b45      	ldr	r3, [pc, #276]	; (801d6b4 <OsSetTimeOfDay+0x224>)
 801d59e:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d5a2:	4313      	orrs	r3, r2
 801d5a4:	d006      	beq.n	801d5b4 <OsSetTimeOfDay+0x124>
        g_adjTimeLeft = 0;
 801d5a6:	4943      	ldr	r1, [pc, #268]	; (801d6b4 <OsSetTimeOfDay+0x224>)
 801d5a8:	f04f 0200 	mov.w	r2, #0
 801d5ac:	f04f 0300 	mov.w	r3, #0
 801d5b0:	e9c1 2300 	strd	r2, r3, [r1]
    }
    realTime = OsTimeSpecAdd(hwTime, g_accDeltaFromAdj);
 801d5b4:	f107 0550 	add.w	r5, r7, #80	; 0x50
 801d5b8:	4b3f      	ldr	r3, [pc, #252]	; (801d6b8 <OsSetTimeOfDay+0x228>)
 801d5ba:	ac02      	add	r4, sp, #8
 801d5bc:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d5be:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d5c2:	466a      	mov	r2, sp
 801d5c4:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801d5c8:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d5cc:	e882 0003 	stmia.w	r2, {r0, r1}
 801d5d0:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801d5d4:	cb0c      	ldmia	r3, {r2, r3}
 801d5d6:	4628      	mov	r0, r5
 801d5d8:	f7ff fe8a 	bl	801d2f0 <OsTimeSpecAdd>
    realTime = OsTimeSpecAdd(realTime, g_accDeltaFromSet);
 801d5dc:	f107 0508 	add.w	r5, r7, #8
 801d5e0:	4b36      	ldr	r3, [pc, #216]	; (801d6bc <OsSetTimeOfDay+0x22c>)
 801d5e2:	ac02      	add	r4, sp, #8
 801d5e4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d5e6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d5ea:	466a      	mov	r2, sp
 801d5ec:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801d5f0:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d5f4:	e882 0003 	stmia.w	r2, {r0, r1}
 801d5f8:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801d5fc:	cb0c      	ldmia	r3, {r2, r3}
 801d5fe:	4628      	mov	r0, r5
 801d600:	f7ff fe76 	bl	801d2f0 <OsTimeSpecAdd>
 801d604:	f107 0450 	add.w	r4, r7, #80	; 0x50
 801d608:	f107 0308 	add.w	r3, r7, #8
 801d60c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d60e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    tmp = OsTimeSpecSub(setTime, realTime);
 801d612:	f107 0560 	add.w	r5, r7, #96	; 0x60
 801d616:	ac02      	add	r4, sp, #8
 801d618:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801d61c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d61e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d622:	466a      	mov	r2, sp
 801d624:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801d628:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d62c:	e882 0003 	stmia.w	r2, {r0, r1}
 801d630:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801d634:	cb0c      	ldmia	r3, {r2, r3}
 801d636:	4628      	mov	r0, r5
 801d638:	f7ff fed6 	bl	801d3e8 <OsTimeSpecSub>
    g_accDeltaFromSet = OsTimeSpecAdd(g_accDeltaFromSet, tmp);
 801d63c:	4b1f      	ldr	r3, [pc, #124]	; (801d6bc <OsSetTimeOfDay+0x22c>)
 801d63e:	607b      	str	r3, [r7, #4]
 801d640:	f107 0608 	add.w	r6, r7, #8
 801d644:	4c1d      	ldr	r4, [pc, #116]	; (801d6bc <OsSetTimeOfDay+0x22c>)
 801d646:	ad02      	add	r5, sp, #8
 801d648:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801d64c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d64e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 801d652:	466a      	mov	r2, sp
 801d654:	f104 0308 	add.w	r3, r4, #8
 801d658:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d65c:	e882 0003 	stmia.w	r2, {r0, r1}
 801d660:	e894 000c 	ldmia.w	r4, {r2, r3}
 801d664:	4630      	mov	r0, r6
 801d666:	f7ff fe43 	bl	801d2f0 <OsTimeSpecAdd>
 801d66a:	687c      	ldr	r4, [r7, #4]
 801d66c:	f107 0308 	add.w	r3, r7, #8
 801d670:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d672:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    LOS_SpinUnlockRestore(&g_timeSpin, intSave);
 801d676:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d678:	4619      	mov	r1, r3
 801d67a:	480d      	ldr	r0, [pc, #52]	; (801d6b0 <OsSetTimeOfDay+0x220>)
 801d67c:	f7ff fdff 	bl	801d27e <LOS_SpinUnlockRestore>

    return 0;
 801d680:	2300      	movs	r3, #0
}
 801d682:	4a09      	ldr	r2, [pc, #36]	; (801d6a8 <OsSetTimeOfDay+0x218>)
 801d684:	6811      	ldr	r1, [r2, #0]
 801d686:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801d688:	4051      	eors	r1, r2
 801d68a:	d001      	beq.n	801d690 <OsSetTimeOfDay+0x200>
 801d68c:	f7e6 feac 	bl	80043e8 <__stack_chk_fail>
 801d690:	4618      	mov	r0, r3
 801d692:	377c      	adds	r7, #124	; 0x7c
 801d694:	46bd      	mov	sp, r7
 801d696:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801d69a:	bf00      	nop
 801d69c:	f3af 8000 	nop.w
 801d6a0:	3b9aca00 	.word	0x3b9aca00
 801d6a4:	00000000 	.word	0x00000000
 801d6a8:	080231dc 	.word	0x080231dc
 801d6ac:	3b9aca00 	.word	0x3b9aca00
 801d6b0:	200033dc 	.word	0x200033dc
 801d6b4:	200033e0 	.word	0x200033e0
 801d6b8:	200033e8 	.word	0x200033e8
 801d6bc:	200033f8 	.word	0x200033f8

0801d6c0 <settimeofday64>:
    return OsSetTimeOfDay(&stTimeVal64, tz);
}

#ifndef LOSCFG_AARCH64
int settimeofday64(const struct timeval64 *tv, const struct timezone *tz)
{
 801d6c0:	b580      	push	{r7, lr}
 801d6c2:	b084      	sub	sp, #16
 801d6c4:	af00      	add	r7, sp, #0
 801d6c6:	6078      	str	r0, [r7, #4]
 801d6c8:	6039      	str	r1, [r7, #0]
    if (!ValidTimeval64(tv)) {
 801d6ca:	6878      	ldr	r0, [r7, #4]
 801d6cc:	f7ff fde4 	bl	801d298 <ValidTimeval64>
 801d6d0:	4603      	mov	r3, r0
 801d6d2:	2b00      	cmp	r3, #0
 801d6d4:	d10b      	bne.n	801d6ee <settimeofday64+0x2e>
        TIME_RETURN(EINVAL);
 801d6d6:	2300      	movs	r3, #0
 801d6d8:	60fb      	str	r3, [r7, #12]
 801d6da:	f04f 33ff 	mov.w	r3, #4294967295
 801d6de:	60fb      	str	r3, [r7, #12]
 801d6e0:	f7f1 fef8 	bl	800f4d4 <__errno_location>
 801d6e4:	4603      	mov	r3, r0
 801d6e6:	2216      	movs	r2, #22
 801d6e8:	601a      	str	r2, [r3, #0]
 801d6ea:	68fb      	ldr	r3, [r7, #12]
 801d6ec:	e004      	b.n	801d6f8 <settimeofday64+0x38>
    }

    return OsSetTimeOfDay(tv, tz);
 801d6ee:	6839      	ldr	r1, [r7, #0]
 801d6f0:	6878      	ldr	r0, [r7, #4]
 801d6f2:	f7ff fecd 	bl	801d490 <OsSetTimeOfDay>
 801d6f6:	4603      	mov	r3, r0
}
 801d6f8:	4618      	mov	r0, r3
 801d6fa:	3710      	adds	r7, #16
 801d6fc:	46bd      	mov	sp, r7
 801d6fe:	bd80      	pop	{r7, pc}

0801d700 <OsGettimeOfDay>:

    return settimeofday(&tv, NULL);
}

STATIC INT32 OsGettimeOfDay(struct timeval64 *tv, const struct timezone *tz)
{
 801d700:	b5b0      	push	{r4, r5, r7, lr}
 801d702:	b09a      	sub	sp, #104	; 0x68
 801d704:	af06      	add	r7, sp, #24
 801d706:	6178      	str	r0, [r7, #20]
 801d708:	6139      	str	r1, [r7, #16]
 801d70a:	4b55      	ldr	r3, [pc, #340]	; (801d860 <OsGettimeOfDay+0x160>)
 801d70c:	681b      	ldr	r3, [r3, #0]
 801d70e:	64fb      	str	r3, [r7, #76]	; 0x4c
 801d710:	f04f 0300 	mov.w	r3, #0
    UINT64 nowNsec;
    UINT32 intSave;

    (VOID)tz;
    struct timespec64 hwTime = {0};
 801d714:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801d718:	2200      	movs	r2, #0
 801d71a:	601a      	str	r2, [r3, #0]
 801d71c:	605a      	str	r2, [r3, #4]
 801d71e:	609a      	str	r2, [r3, #8]
 801d720:	60da      	str	r2, [r3, #12]
    struct timespec64 realTime = {0};
 801d722:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801d726:	2200      	movs	r2, #0
 801d728:	601a      	str	r2, [r3, #0]
 801d72a:	605a      	str	r2, [r3, #4]
 801d72c:	609a      	str	r2, [r3, #8]
 801d72e:	60da      	str	r2, [r3, #12]

    nowNsec = LOS_CurrNanosec();
 801d730:	f7e6 fd70 	bl	8004214 <LOS_CurrNanosec>
 801d734:	e9c7 0108 	strd	r0, r1, [r7, #32]
    hwTime.tv_sec = nowNsec / OS_SYS_NS_PER_SECOND;
 801d738:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801d73c:	a346      	add	r3, pc, #280	; (adr r3, 801d858 <OsGettimeOfDay+0x158>)
 801d73e:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d742:	f7e3 f927 	bl	8000994 <__aeabi_uldivmod>
 801d746:	4602      	mov	r2, r0
 801d748:	460b      	mov	r3, r1
 801d74a:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
    hwTime.tv_nsec = (INT64)(nowNsec - (hwTime.tv_sec * OS_SYS_NS_PER_SECOND));
 801d74e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d752:	4944      	ldr	r1, [pc, #272]	; (801d864 <OsGettimeOfDay+0x164>)
 801d754:	fb01 f003 	mul.w	r0, r1, r3
 801d758:	2100      	movs	r1, #0
 801d75a:	fb01 f102 	mul.w	r1, r1, r2
 801d75e:	4401      	add	r1, r0
 801d760:	4840      	ldr	r0, [pc, #256]	; (801d864 <OsGettimeOfDay+0x164>)
 801d762:	fba2 2300 	umull	r2, r3, r2, r0
 801d766:	4419      	add	r1, r3
 801d768:	460b      	mov	r3, r1
 801d76a:	4610      	mov	r0, r2
 801d76c:	4619      	mov	r1, r3
 801d76e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801d772:	1a14      	subs	r4, r2, r0
 801d774:	eb63 0501 	sbc.w	r5, r3, r1
 801d778:	4622      	mov	r2, r4
 801d77a:	462b      	mov	r3, r5
 801d77c:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

    LOS_SpinLockSave(&g_timeSpin, &intSave);
 801d780:	f107 0318 	add.w	r3, r7, #24
 801d784:	4619      	mov	r1, r3
 801d786:	4838      	ldr	r0, [pc, #224]	; (801d868 <OsGettimeOfDay+0x168>)
 801d788:	f7ff fd6b 	bl	801d262 <LOS_SpinLockSave>
    realTime = OsTimeSpecAdd(hwTime, g_accDeltaFromAdj);
 801d78c:	f107 0538 	add.w	r5, r7, #56	; 0x38
 801d790:	4b36      	ldr	r3, [pc, #216]	; (801d86c <OsGettimeOfDay+0x16c>)
 801d792:	ac02      	add	r4, sp, #8
 801d794:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d796:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d79a:	466a      	mov	r2, sp
 801d79c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801d7a0:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d7a4:	e882 0003 	stmia.w	r2, {r0, r1}
 801d7a8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801d7ac:	cb0c      	ldmia	r3, {r2, r3}
 801d7ae:	4628      	mov	r0, r5
 801d7b0:	f7ff fd9e 	bl	801d2f0 <OsTimeSpecAdd>
    realTime = OsTimeSpecAdd(realTime, g_accDeltaFromSet);
 801d7b4:	463d      	mov	r5, r7
 801d7b6:	4b2e      	ldr	r3, [pc, #184]	; (801d870 <OsGettimeOfDay+0x170>)
 801d7b8:	ac02      	add	r4, sp, #8
 801d7ba:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d7bc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d7c0:	466a      	mov	r2, sp
 801d7c2:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801d7c6:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d7ca:	e882 0003 	stmia.w	r2, {r0, r1}
 801d7ce:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801d7d2:	cb0c      	ldmia	r3, {r2, r3}
 801d7d4:	4628      	mov	r0, r5
 801d7d6:	f7ff fd8b 	bl	801d2f0 <OsTimeSpecAdd>
 801d7da:	f107 0438 	add.w	r4, r7, #56	; 0x38
 801d7de:	463b      	mov	r3, r7
 801d7e0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d7e2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    LOS_SpinUnlockRestore(&g_timeSpin, intSave);
 801d7e6:	69bb      	ldr	r3, [r7, #24]
 801d7e8:	4619      	mov	r1, r3
 801d7ea:	481f      	ldr	r0, [pc, #124]	; (801d868 <OsGettimeOfDay+0x168>)
 801d7ec:	f7ff fd47 	bl	801d27e <LOS_SpinUnlockRestore>

    tv->tv_sec = realTime.tv_sec;
 801d7f0:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801d7f4:	6979      	ldr	r1, [r7, #20]
 801d7f6:	e9c1 2300 	strd	r2, r3, [r1]
    tv->tv_usec = realTime.tv_nsec / OS_SYS_NS_PER_US;
 801d7fa:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
 801d7fe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801d802:	f04f 0300 	mov.w	r3, #0
 801d806:	f7e3 fc61 	bl	80010cc <__aeabi_ldivmod>
 801d80a:	4602      	mov	r2, r0
 801d80c:	460b      	mov	r3, r1
 801d80e:	6979      	ldr	r1, [r7, #20]
 801d810:	e9c1 2302 	strd	r2, r3, [r1, #8]

    if (tv->tv_sec < 0) {
 801d814:	697b      	ldr	r3, [r7, #20]
 801d816:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d81a:	2a00      	cmp	r2, #0
 801d81c:	f173 0300 	sbcs.w	r3, r3, #0
 801d820:	da0b      	bge.n	801d83a <OsGettimeOfDay+0x13a>
        TIME_RETURN(EINVAL);
 801d822:	2300      	movs	r3, #0
 801d824:	61fb      	str	r3, [r7, #28]
 801d826:	f04f 33ff 	mov.w	r3, #4294967295
 801d82a:	61fb      	str	r3, [r7, #28]
 801d82c:	f7f1 fe52 	bl	800f4d4 <__errno_location>
 801d830:	4603      	mov	r3, r0
 801d832:	2216      	movs	r2, #22
 801d834:	601a      	str	r2, [r3, #0]
 801d836:	69fb      	ldr	r3, [r7, #28]
 801d838:	e000      	b.n	801d83c <OsGettimeOfDay+0x13c>
    }
    return 0;
 801d83a:	2300      	movs	r3, #0
}
 801d83c:	4a08      	ldr	r2, [pc, #32]	; (801d860 <OsGettimeOfDay+0x160>)
 801d83e:	6811      	ldr	r1, [r2, #0]
 801d840:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801d842:	4051      	eors	r1, r2
 801d844:	d001      	beq.n	801d84a <OsGettimeOfDay+0x14a>
 801d846:	f7e6 fdcf 	bl	80043e8 <__stack_chk_fail>
 801d84a:	4618      	mov	r0, r3
 801d84c:	3750      	adds	r7, #80	; 0x50
 801d84e:	46bd      	mov	sp, r7
 801d850:	bdb0      	pop	{r4, r5, r7, pc}
 801d852:	bf00      	nop
 801d854:	f3af 8000 	nop.w
 801d858:	3b9aca00 	.word	0x3b9aca00
 801d85c:	00000000 	.word	0x00000000
 801d860:	080231e8 	.word	0x080231e8
 801d864:	3b9aca00 	.word	0x3b9aca00
 801d868:	200033dc 	.word	0x200033dc
 801d86c:	200033e8 	.word	0x200033e8
 801d870:	200033f8 	.word	0x200033f8

0801d874 <gettimeofday64>:

#ifndef LOSCFG_AARCH64
int gettimeofday64(struct timeval64 *tv, struct timezone *tz)
{
 801d874:	b580      	push	{r7, lr}
 801d876:	b084      	sub	sp, #16
 801d878:	af00      	add	r7, sp, #0
 801d87a:	6078      	str	r0, [r7, #4]
 801d87c:	6039      	str	r1, [r7, #0]
    if (tv == NULL) {
 801d87e:	687b      	ldr	r3, [r7, #4]
 801d880:	2b00      	cmp	r3, #0
 801d882:	d10b      	bne.n	801d89c <gettimeofday64+0x28>
        TIME_RETURN(EINVAL);
 801d884:	2300      	movs	r3, #0
 801d886:	60fb      	str	r3, [r7, #12]
 801d888:	f04f 33ff 	mov.w	r3, #4294967295
 801d88c:	60fb      	str	r3, [r7, #12]
 801d88e:	f7f1 fe21 	bl	800f4d4 <__errno_location>
 801d892:	4603      	mov	r3, r0
 801d894:	2216      	movs	r2, #22
 801d896:	601a      	str	r2, [r3, #0]
 801d898:	68fb      	ldr	r3, [r7, #12]
 801d89a:	e004      	b.n	801d8a6 <gettimeofday64+0x32>
    }

    return OsGettimeOfDay(tv, tz);
 801d89c:	6839      	ldr	r1, [r7, #0]
 801d89e:	6878      	ldr	r0, [r7, #4]
 801d8a0:	f7ff ff2e 	bl	801d700 <OsGettimeOfDay>
 801d8a4:	4603      	mov	r3, r0
}
 801d8a6:	4618      	mov	r0, r3
 801d8a8:	3710      	adds	r7, #16
 801d8aa:	46bd      	mov	sp, r7
 801d8ac:	bd80      	pop	{r7, pc}

0801d8ae <valid_tm_wday>:
typedef time64_t Time64_T;
static struct TM g_returnDate;
static char g_returnString[RETURN_STRING_LEN];

static int valid_tm_wday(const struct TM *date)
{
 801d8ae:	b480      	push	{r7}
 801d8b0:	b083      	sub	sp, #12
 801d8b2:	af00      	add	r7, sp, #0
 801d8b4:	6078      	str	r0, [r7, #4]
    if ((date->tm_wday >= 0) && (date->tm_wday <= 6)) {
 801d8b6:	687b      	ldr	r3, [r7, #4]
 801d8b8:	699b      	ldr	r3, [r3, #24]
 801d8ba:	2b00      	cmp	r3, #0
 801d8bc:	db05      	blt.n	801d8ca <valid_tm_wday+0x1c>
 801d8be:	687b      	ldr	r3, [r7, #4]
 801d8c0:	699b      	ldr	r3, [r3, #24]
 801d8c2:	2b06      	cmp	r3, #6
 801d8c4:	dc01      	bgt.n	801d8ca <valid_tm_wday+0x1c>
        return 1;
 801d8c6:	2301      	movs	r3, #1
 801d8c8:	e000      	b.n	801d8cc <valid_tm_wday+0x1e>
    } else {
        return 0;
 801d8ca:	2300      	movs	r3, #0
    }
}
 801d8cc:	4618      	mov	r0, r3
 801d8ce:	370c      	adds	r7, #12
 801d8d0:	46bd      	mov	sp, r7
 801d8d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d8d6:	4770      	bx	lr

0801d8d8 <valid_tm_mon>:

static int valid_tm_mon(const struct TM *date)
{
 801d8d8:	b480      	push	{r7}
 801d8da:	b083      	sub	sp, #12
 801d8dc:	af00      	add	r7, sp, #0
 801d8de:	6078      	str	r0, [r7, #4]
    if ((date->tm_mon >= 0) && (date->tm_mon <= 11)) {
 801d8e0:	687b      	ldr	r3, [r7, #4]
 801d8e2:	691b      	ldr	r3, [r3, #16]
 801d8e4:	2b00      	cmp	r3, #0
 801d8e6:	db05      	blt.n	801d8f4 <valid_tm_mon+0x1c>
 801d8e8:	687b      	ldr	r3, [r7, #4]
 801d8ea:	691b      	ldr	r3, [r3, #16]
 801d8ec:	2b0b      	cmp	r3, #11
 801d8ee:	dc01      	bgt.n	801d8f4 <valid_tm_mon+0x1c>
        return 1;
 801d8f0:	2301      	movs	r3, #1
 801d8f2:	e000      	b.n	801d8f6 <valid_tm_mon+0x1e>
    } else {
        return 0;
 801d8f4:	2300      	movs	r3, #0
    }
}
 801d8f6:	4618      	mov	r0, r3
 801d8f8:	370c      	adds	r7, #12
 801d8fa:	46bd      	mov	sp, r7
 801d8fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d900:	4770      	bx	lr
 801d902:	0000      	movs	r0, r0
 801d904:	0000      	movs	r0, r0
	...

0801d908 <localtime64_r>:

struct TM *localtime64_r(const Time64_T *time, struct TM *local_tm)
{
 801d908:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801d90c:	b086      	sub	sp, #24
 801d90e:	af00      	add	r7, sp, #0
 801d910:	6078      	str	r0, [r7, #4]
 801d912:	6039      	str	r1, [r7, #0]
    Time64_T timeoff;
    int dstsec = 0;
 801d914:	2300      	movs	r3, #0
 801d916:	60fb      	str	r3, [r7, #12]

    (void)LIBC_LOCK(g_tzdstLock);
 801d918:	482d      	ldr	r0, [pc, #180]	; (801d9d0 <localtime64_r+0xc8>)
 801d91a:	f001 faa1 	bl	801ee60 <LibcLock>
    if (CheckWithinDstPeriod(NULL, *time) == TRUE) {
 801d91e:	687b      	ldr	r3, [r7, #4]
 801d920:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d924:	2000      	movs	r0, #0
 801d926:	f001 fa05 	bl	801ed34 <CheckWithinDstPeriod>
 801d92a:	4603      	mov	r3, r0
 801d92c:	2b01      	cmp	r3, #1
 801d92e:	d102      	bne.n	801d936 <localtime64_r+0x2e>
        dstsec = DstForwardSecondGet();
 801d930:	f000 fe60 	bl	801e5f4 <DstForwardSecondGet>
 801d934:	60f8      	str	r0, [r7, #12]
    }
    timeoff = *time + timezone + dstsec;
 801d936:	687b      	ldr	r3, [r7, #4]
 801d938:	e9d3 0100 	ldrd	r0, r1, [r3]
 801d93c:	4b25      	ldr	r3, [pc, #148]	; (801d9d4 <localtime64_r+0xcc>)
 801d93e:	681b      	ldr	r3, [r3, #0]
 801d940:	461a      	mov	r2, r3
 801d942:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801d946:	1884      	adds	r4, r0, r2
 801d948:	eb41 0503 	adc.w	r5, r1, r3
 801d94c:	68fb      	ldr	r3, [r7, #12]
 801d94e:	461a      	mov	r2, r3
 801d950:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801d954:	eb14 0802 	adds.w	r8, r4, r2
 801d958:	eb45 0903 	adc.w	r9, r5, r3
 801d95c:	e9c7 8904 	strd	r8, r9, [r7, #16]
    (void)LIBC_UNLOCK(g_tzdstLock);
 801d960:	481b      	ldr	r0, [pc, #108]	; (801d9d0 <localtime64_r+0xc8>)
 801d962:	f001 faa7 	bl	801eeb4 <LibcUnlock>

    /* Reject time_t values whose year would overflow int because
     * __secs_to_zone cannot safely handle them. */
    if ((timeoff < (INT_MIN * MAX_SEC_PER_YEAR)) || (timeoff > (INT_MAX * MAX_SEC_PER_YEAR))) {
 801d966:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801d96a:	f04f 30ff 	mov.w	r0, #4294967295
 801d96e:	491a      	ldr	r1, [pc, #104]	; (801d9d8 <localtime64_r+0xd0>)
 801d970:	4290      	cmp	r0, r2
 801d972:	eb71 0303 	sbcs.w	r3, r1, r3
 801d976:	da08      	bge.n	801d98a <localtime64_r+0x82>
 801d978:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801d97c:	a112      	add	r1, pc, #72	; (adr r1, 801d9c8 <localtime64_r+0xc0>)
 801d97e:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d982:	4290      	cmp	r0, r2
 801d984:	eb71 0303 	sbcs.w	r3, r1, r3
 801d988:	da06      	bge.n	801d998 <localtime64_r+0x90>
        errno = EOVERFLOW;
 801d98a:	f7f1 fda3 	bl	800f4d4 <__errno_location>
 801d98e:	4603      	mov	r3, r0
 801d990:	224b      	movs	r2, #75	; 0x4b
 801d992:	601a      	str	r2, [r3, #0]
        return 0;
 801d994:	2300      	movs	r3, #0
 801d996:	e00f      	b.n	801d9b8 <localtime64_r+0xb0>
    }

    if (__secs_to_tm(timeoff, local_tm) < 0) {
 801d998:	683a      	ldr	r2, [r7, #0]
 801d99a:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801d99e:	f000 f9af 	bl	801dd00 <__secs_to_tm>
 801d9a2:	4603      	mov	r3, r0
 801d9a4:	2b00      	cmp	r3, #0
 801d9a6:	da06      	bge.n	801d9b6 <localtime64_r+0xae>
        errno = EOVERFLOW;
 801d9a8:	f7f1 fd94 	bl	800f4d4 <__errno_location>
 801d9ac:	4603      	mov	r3, r0
 801d9ae:	224b      	movs	r2, #75	; 0x4b
 801d9b0:	601a      	str	r2, [r3, #0]
        return 0;
 801d9b2:	2300      	movs	r3, #0
 801d9b4:	e000      	b.n	801d9b8 <localtime64_r+0xb0>
    }
    return local_tm;
 801d9b6:	683b      	ldr	r3, [r7, #0]
}
 801d9b8:	4618      	mov	r0, r3
 801d9ba:	3718      	adds	r7, #24
 801d9bc:	46bd      	mov	sp, r7
 801d9be:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 801d9c2:	bf00      	nop
 801d9c4:	f3af 8000 	nop.w
 801d9c8:	fe1d7b00 	.word	0xfe1d7b00
 801d9cc:	00f1427f 	.word	0x00f1427f
 801d9d0:	20000570 	.word	0x20000570
 801d9d4:	200037e8 	.word	0x200037e8
 801d9d8:	ff0ebd7f 	.word	0xff0ebd7f

0801d9dc <localtime64>:

struct TM *localtime64(const Time64_T *time)
{
 801d9dc:	b580      	push	{r7, lr}
 801d9de:	b082      	sub	sp, #8
 801d9e0:	af00      	add	r7, sp, #0
 801d9e2:	6078      	str	r0, [r7, #4]
    return localtime64_r(time, &g_returnDate);
 801d9e4:	4904      	ldr	r1, [pc, #16]	; (801d9f8 <localtime64+0x1c>)
 801d9e6:	6878      	ldr	r0, [r7, #4]
 801d9e8:	f7ff ff8e 	bl	801d908 <localtime64_r>
 801d9ec:	4603      	mov	r3, r0
}
 801d9ee:	4618      	mov	r0, r3
 801d9f0:	3708      	adds	r7, #8
 801d9f2:	46bd      	mov	sp, r7
 801d9f4:	bd80      	pop	{r7, pc}
 801d9f6:	bf00      	nop
 801d9f8:	20003408 	.word	0x20003408

0801d9fc <asctime64_r>:

char *asctime64_r(const struct TM *date, char *result)
{
 801d9fc:	b580      	push	{r7, lr}
 801d9fe:	b082      	sub	sp, #8
 801da00:	af00      	add	r7, sp, #0
 801da02:	6078      	str	r0, [r7, #4]
 801da04:	6039      	str	r1, [r7, #0]
    if (!valid_tm_wday(date) || !valid_tm_mon(date)) {
 801da06:	6878      	ldr	r0, [r7, #4]
 801da08:	f7ff ff51 	bl	801d8ae <valid_tm_wday>
 801da0c:	4603      	mov	r3, r0
 801da0e:	2b00      	cmp	r3, #0
 801da10:	d005      	beq.n	801da1e <asctime64_r+0x22>
 801da12:	6878      	ldr	r0, [r7, #4]
 801da14:	f7ff ff60 	bl	801d8d8 <valid_tm_mon>
 801da18:	4603      	mov	r3, r0
 801da1a:	2b00      	cmp	r3, #0
 801da1c:	d101      	bne.n	801da22 <asctime64_r+0x26>
        return NULL;
 801da1e:	2300      	movs	r3, #0
 801da20:	e00c      	b.n	801da3c <asctime64_r+0x40>
    }

    if ((TM_YEAR_BASE + date->tm_year) > TM_YEAR_MAX) {
 801da22:	687b      	ldr	r3, [r7, #4]
 801da24:	695b      	ldr	r3, [r3, #20]
 801da26:	f641 72a3 	movw	r2, #8099	; 0x1fa3
 801da2a:	4293      	cmp	r3, r2
 801da2c:	dd01      	ble.n	801da32 <asctime64_r+0x36>
        return NULL;
 801da2e:	2300      	movs	r3, #0
 801da30:	e004      	b.n	801da3c <asctime64_r+0x40>
    }

    return asctime_r(date, result);
 801da32:	6839      	ldr	r1, [r7, #0]
 801da34:	6878      	ldr	r0, [r7, #4]
 801da36:	f000 fd6d 	bl	801e514 <__asctime_r>
 801da3a:	4603      	mov	r3, r0
}
 801da3c:	4618      	mov	r0, r3
 801da3e:	3708      	adds	r7, #8
 801da40:	46bd      	mov	sp, r7
 801da42:	bd80      	pop	{r7, pc}

0801da44 <asctime64>:

char *asctime64(const struct TM *date)
{
 801da44:	b580      	push	{r7, lr}
 801da46:	b082      	sub	sp, #8
 801da48:	af00      	add	r7, sp, #0
 801da4a:	6078      	str	r0, [r7, #4]
    return asctime64_r(date, g_returnString);
 801da4c:	4904      	ldr	r1, [pc, #16]	; (801da60 <asctime64+0x1c>)
 801da4e:	6878      	ldr	r0, [r7, #4]
 801da50:	f7ff ffd4 	bl	801d9fc <asctime64_r>
 801da54:	4603      	mov	r3, r0
}
 801da56:	4618      	mov	r0, r3
 801da58:	3708      	adds	r7, #8
 801da5a:	46bd      	mov	sp, r7
 801da5c:	bd80      	pop	{r7, pc}
 801da5e:	bf00      	nop
 801da60:	20003434 	.word	0x20003434

0801da64 <ctime64>:

char *ctime64(const Time64_T *time)
{
 801da64:	b580      	push	{r7, lr}
 801da66:	b084      	sub	sp, #16
 801da68:	af00      	add	r7, sp, #0
 801da6a:	6078      	str	r0, [r7, #4]
    struct TM *ptm = localtime64(time);
 801da6c:	6878      	ldr	r0, [r7, #4]
 801da6e:	f7ff ffb5 	bl	801d9dc <localtime64>
 801da72:	60f8      	str	r0, [r7, #12]
    if (ptm != NULL) {
 801da74:	68fb      	ldr	r3, [r7, #12]
 801da76:	2b00      	cmp	r3, #0
 801da78:	d004      	beq.n	801da84 <ctime64+0x20>
        return asctime64(ptm);
 801da7a:	68f8      	ldr	r0, [r7, #12]
 801da7c:	f7ff ffe2 	bl	801da44 <asctime64>
 801da80:	4603      	mov	r3, r0
 801da82:	e000      	b.n	801da86 <ctime64+0x22>
    }
    return NULL;
 801da84:	2300      	movs	r3, #0
}
 801da86:	4618      	mov	r0, r3
 801da88:	3710      	adds	r7, #16
 801da8a:	46bd      	mov	sp, r7
 801da8c:	bd80      	pop	{r7, pc}
	...

0801da90 <mktime64>:

Time64_T mktime64(struct TM *tm)
{
 801da90:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801da94:	b086      	sub	sp, #24
 801da96:	af00      	add	r7, sp, #0
 801da98:	6078      	str	r0, [r7, #4]
    long long t = __tm_to_secs(tm);
 801da9a:	6878      	ldr	r0, [r7, #4]
 801da9c:	f000 faea 	bl	801e074 <__tm_to_secs>
 801daa0:	e9c7 0104 	strd	r0, r1, [r7, #16]
    int dstsec = 0;
 801daa4:	2300      	movs	r3, #0
 801daa6:	60fb      	str	r3, [r7, #12]

    (void)LIBC_LOCK(g_tzdstLock);
 801daa8:	481a      	ldr	r0, [pc, #104]	; (801db14 <mktime64+0x84>)
 801daaa:	f001 f9d9 	bl	801ee60 <LibcLock>
    if (tm->tm_isdst != 0) {
 801daae:	687b      	ldr	r3, [r7, #4]
 801dab0:	6a1b      	ldr	r3, [r3, #32]
 801dab2:	2b00      	cmp	r3, #0
 801dab4:	d00f      	beq.n	801dad6 <mktime64+0x46>
        if (CheckWithinDstPeriod(tm, 0) == TRUE) {
 801dab6:	f04f 0200 	mov.w	r2, #0
 801daba:	f04f 0300 	mov.w	r3, #0
 801dabe:	6878      	ldr	r0, [r7, #4]
 801dac0:	f001 f938 	bl	801ed34 <CheckWithinDstPeriod>
 801dac4:	4603      	mov	r3, r0
 801dac6:	2b01      	cmp	r3, #1
 801dac8:	d102      	bne.n	801dad0 <mktime64+0x40>
            dstsec = DstForwardSecondGet();
 801daca:	f000 fd93 	bl	801e5f4 <DstForwardSecondGet>
 801dace:	60f8      	str	r0, [r7, #12]
        }
        tm->tm_isdst = 0;
 801dad0:	687b      	ldr	r3, [r7, #4]
 801dad2:	2200      	movs	r2, #0
 801dad4:	621a      	str	r2, [r3, #32]
    }
    t = t - timezone - dstsec;
 801dad6:	4b10      	ldr	r3, [pc, #64]	; (801db18 <mktime64+0x88>)
 801dad8:	681b      	ldr	r3, [r3, #0]
 801dada:	461a      	mov	r2, r3
 801dadc:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801dae0:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801dae4:	1a84      	subs	r4, r0, r2
 801dae6:	eb61 0503 	sbc.w	r5, r1, r3
 801daea:	68fb      	ldr	r3, [r7, #12]
 801daec:	461a      	mov	r2, r3
 801daee:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801daf2:	ebb4 0802 	subs.w	r8, r4, r2
 801daf6:	eb65 0903 	sbc.w	r9, r5, r3
 801dafa:	e9c7 8904 	strd	r8, r9, [r7, #16]
    (void)LIBC_UNLOCK(g_tzdstLock);
 801dafe:	4805      	ldr	r0, [pc, #20]	; (801db14 <mktime64+0x84>)
 801db00:	f001 f9d8 	bl	801eeb4 <LibcUnlock>

    if ((Time64_T)t != t) {
        goto error;
    }

    return t;
 801db04:	e9d7 2304 	ldrd	r2, r3, [r7, #16]

error:
    (void)LIBC_UNLOCK(g_tzdstLock);
    errno = EOVERFLOW;
    return -1;
}
 801db08:	4610      	mov	r0, r2
 801db0a:	4619      	mov	r1, r3
 801db0c:	3718      	adds	r7, #24
 801db0e:	46bd      	mov	sp, r7
 801db10:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 801db14:	20000570 	.word	0x20000570
 801db18:	200037e8 	.word	0x200037e8

0801db1c <gmtime64_r>:

struct TM *gmtime64_r(const Time64_T *in_time, struct TM *tm)
{
 801db1c:	b580      	push	{r7, lr}
 801db1e:	b082      	sub	sp, #8
 801db20:	af00      	add	r7, sp, #0
 801db22:	6078      	str	r0, [r7, #4]
 801db24:	6039      	str	r1, [r7, #0]
    if (__secs_to_tm(*in_time, tm) < 0) {
 801db26:	687b      	ldr	r3, [r7, #4]
 801db28:	e9d3 0100 	ldrd	r0, r1, [r3]
 801db2c:	683a      	ldr	r2, [r7, #0]
 801db2e:	f000 f8e7 	bl	801dd00 <__secs_to_tm>
 801db32:	4603      	mov	r3, r0
 801db34:	2b00      	cmp	r3, #0
 801db36:	da06      	bge.n	801db46 <gmtime64_r+0x2a>
        errno = EOVERFLOW;
 801db38:	f7f1 fccc 	bl	800f4d4 <__errno_location>
 801db3c:	4603      	mov	r3, r0
 801db3e:	224b      	movs	r2, #75	; 0x4b
 801db40:	601a      	str	r2, [r3, #0]
        return 0;
 801db42:	2300      	movs	r3, #0
 801db44:	e009      	b.n	801db5a <gmtime64_r+0x3e>
    }
    tm->tm_isdst = 0;
 801db46:	683b      	ldr	r3, [r7, #0]
 801db48:	2200      	movs	r2, #0
 801db4a:	621a      	str	r2, [r3, #32]
    tm->__tm_gmtoff = 0;
 801db4c:	683b      	ldr	r3, [r7, #0]
 801db4e:	2200      	movs	r2, #0
 801db50:	625a      	str	r2, [r3, #36]	; 0x24
    tm->__tm_zone = __utc;
 801db52:	683b      	ldr	r3, [r7, #0]
 801db54:	4a03      	ldr	r2, [pc, #12]	; (801db64 <gmtime64_r+0x48>)
 801db56:	629a      	str	r2, [r3, #40]	; 0x28
    return tm;
 801db58:	683b      	ldr	r3, [r7, #0]
}
 801db5a:	4618      	mov	r0, r3
 801db5c:	3708      	adds	r7, #8
 801db5e:	46bd      	mov	sp, r7
 801db60:	bd80      	pop	{r7, pc}
 801db62:	bf00      	nop
 801db64:	080242f8 	.word	0x080242f8

0801db68 <__strerror_l>:
static const char errmsg[] =
#include "__strerror.h"
;

char *__strerror_l(int e, locale_t loc)
{
 801db68:	b480      	push	{r7}
 801db6a:	b085      	sub	sp, #20
 801db6c:	af00      	add	r7, sp, #0
 801db6e:	6078      	str	r0, [r7, #4]
 801db70:	6039      	str	r1, [r7, #0]
	 * historical typo, so we just remap it. */
	if (EDQUOT==1133) {
		if (e==109) e=-1;
		else if (e==EDQUOT) e=109;
	}
	for (i=0; errid[i] && errid[i] != e; i++);
 801db72:	2300      	movs	r3, #0
 801db74:	60fb      	str	r3, [r7, #12]
 801db76:	e002      	b.n	801db7e <__strerror_l+0x16>
 801db78:	68fb      	ldr	r3, [r7, #12]
 801db7a:	3301      	adds	r3, #1
 801db7c:	60fb      	str	r3, [r7, #12]
 801db7e:	4a14      	ldr	r2, [pc, #80]	; (801dbd0 <__strerror_l+0x68>)
 801db80:	68fb      	ldr	r3, [r7, #12]
 801db82:	4413      	add	r3, r2
 801db84:	781b      	ldrb	r3, [r3, #0]
 801db86:	2b00      	cmp	r3, #0
 801db88:	d007      	beq.n	801db9a <__strerror_l+0x32>
 801db8a:	4a11      	ldr	r2, [pc, #68]	; (801dbd0 <__strerror_l+0x68>)
 801db8c:	68fb      	ldr	r3, [r7, #12]
 801db8e:	4413      	add	r3, r2
 801db90:	781b      	ldrb	r3, [r3, #0]
 801db92:	461a      	mov	r2, r3
 801db94:	687b      	ldr	r3, [r7, #4]
 801db96:	4293      	cmp	r3, r2
 801db98:	d1ee      	bne.n	801db78 <__strerror_l+0x10>
	for (s=errmsg; i; s++, i--) for (; *s; s++);
 801db9a:	4b0e      	ldr	r3, [pc, #56]	; (801dbd4 <__strerror_l+0x6c>)
 801db9c:	60bb      	str	r3, [r7, #8]
 801db9e:	e00c      	b.n	801dbba <__strerror_l+0x52>
 801dba0:	68bb      	ldr	r3, [r7, #8]
 801dba2:	3301      	adds	r3, #1
 801dba4:	60bb      	str	r3, [r7, #8]
 801dba6:	68bb      	ldr	r3, [r7, #8]
 801dba8:	781b      	ldrb	r3, [r3, #0]
 801dbaa:	2b00      	cmp	r3, #0
 801dbac:	d1f8      	bne.n	801dba0 <__strerror_l+0x38>
 801dbae:	68bb      	ldr	r3, [r7, #8]
 801dbb0:	3301      	adds	r3, #1
 801dbb2:	60bb      	str	r3, [r7, #8]
 801dbb4:	68fb      	ldr	r3, [r7, #12]
 801dbb6:	3b01      	subs	r3, #1
 801dbb8:	60fb      	str	r3, [r7, #12]
 801dbba:	68fb      	ldr	r3, [r7, #12]
 801dbbc:	2b00      	cmp	r3, #0
 801dbbe:	d1f2      	bne.n	801dba6 <__strerror_l+0x3e>
	return (char *)s;
 801dbc0:	68bb      	ldr	r3, [r7, #8]
}
 801dbc2:	4618      	mov	r0, r3
 801dbc4:	3714      	adds	r7, #20
 801dbc6:	46bd      	mov	sp, r7
 801dbc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dbcc:	4770      	bx	lr
 801dbce:	bf00      	nop
 801dbd0:	08023b70 	.word	0x08023b70
 801dbd4:	08023bcc 	.word	0x08023bcc

0801dbd8 <strerror>:

char *strerror(int e)
{
 801dbd8:	b580      	push	{r7, lr}
 801dbda:	b082      	sub	sp, #8
 801dbdc:	af00      	add	r7, sp, #0
 801dbde:	6078      	str	r0, [r7, #4]
	return __strerror_l(e, CURRENT_LOCALE);
 801dbe0:	2101      	movs	r1, #1
 801dbe2:	6878      	ldr	r0, [r7, #4]
 801dbe4:	f7ff ffc0 	bl	801db68 <__strerror_l>
 801dbe8:	4603      	mov	r3, r0
}
 801dbea:	4618      	mov	r0, r3
 801dbec:	3708      	adds	r7, #8
 801dbee:	46bd      	mov	sp, r7
 801dbf0:	bd80      	pop	{r7, pc}

0801dbf2 <__memrchr>:
#include <string.h>

void *__memrchr(const void *m, int c, size_t n)
{
 801dbf2:	b480      	push	{r7}
 801dbf4:	b087      	sub	sp, #28
 801dbf6:	af00      	add	r7, sp, #0
 801dbf8:	60f8      	str	r0, [r7, #12]
 801dbfa:	60b9      	str	r1, [r7, #8]
 801dbfc:	607a      	str	r2, [r7, #4]
	const unsigned char *s = m;
 801dbfe:	68fb      	ldr	r3, [r7, #12]
 801dc00:	617b      	str	r3, [r7, #20]
	c = (unsigned char)c;
 801dc02:	68bb      	ldr	r3, [r7, #8]
 801dc04:	b2db      	uxtb	r3, r3
 801dc06:	60bb      	str	r3, [r7, #8]
	while (n--) if (s[n]==c) return (void *)(s+n);
 801dc08:	e00b      	b.n	801dc22 <__memrchr+0x30>
 801dc0a:	697a      	ldr	r2, [r7, #20]
 801dc0c:	687b      	ldr	r3, [r7, #4]
 801dc0e:	4413      	add	r3, r2
 801dc10:	781b      	ldrb	r3, [r3, #0]
 801dc12:	461a      	mov	r2, r3
 801dc14:	68bb      	ldr	r3, [r7, #8]
 801dc16:	4293      	cmp	r3, r2
 801dc18:	d103      	bne.n	801dc22 <__memrchr+0x30>
 801dc1a:	697a      	ldr	r2, [r7, #20]
 801dc1c:	687b      	ldr	r3, [r7, #4]
 801dc1e:	4413      	add	r3, r2
 801dc20:	e005      	b.n	801dc2e <__memrchr+0x3c>
 801dc22:	687b      	ldr	r3, [r7, #4]
 801dc24:	1e5a      	subs	r2, r3, #1
 801dc26:	607a      	str	r2, [r7, #4]
 801dc28:	2b00      	cmp	r3, #0
 801dc2a:	d1ee      	bne.n	801dc0a <__memrchr+0x18>
	return 0;
 801dc2c:	2300      	movs	r3, #0
}
 801dc2e:	4618      	mov	r0, r3
 801dc30:	371c      	adds	r7, #28
 801dc32:	46bd      	mov	sp, r7
 801dc34:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dc38:	4770      	bx	lr

0801dc3a <strncasecmp>:
#include <strings.h>
#include <ctype.h>

int strncasecmp(const char *_l, const char *_r, size_t n)
{
 801dc3a:	b590      	push	{r4, r7, lr}
 801dc3c:	b087      	sub	sp, #28
 801dc3e:	af00      	add	r7, sp, #0
 801dc40:	60f8      	str	r0, [r7, #12]
 801dc42:	60b9      	str	r1, [r7, #8]
 801dc44:	607a      	str	r2, [r7, #4]
	const unsigned char *l=(void *)_l, *r=(void *)_r;
 801dc46:	68fb      	ldr	r3, [r7, #12]
 801dc48:	613b      	str	r3, [r7, #16]
 801dc4a:	68bb      	ldr	r3, [r7, #8]
 801dc4c:	617b      	str	r3, [r7, #20]
	if (!n--) return 0;
 801dc4e:	687b      	ldr	r3, [r7, #4]
 801dc50:	1e5a      	subs	r2, r3, #1
 801dc52:	607a      	str	r2, [r7, #4]
 801dc54:	2b00      	cmp	r3, #0
 801dc56:	d10a      	bne.n	801dc6e <strncasecmp+0x34>
 801dc58:	2300      	movs	r3, #0
 801dc5a:	e034      	b.n	801dcc6 <strncasecmp+0x8c>
	for (; *l && *r && n && (*l == *r || tolower(*l) == tolower(*r)); l++, r++, n--);
 801dc5c:	693b      	ldr	r3, [r7, #16]
 801dc5e:	3301      	adds	r3, #1
 801dc60:	613b      	str	r3, [r7, #16]
 801dc62:	697b      	ldr	r3, [r7, #20]
 801dc64:	3301      	adds	r3, #1
 801dc66:	617b      	str	r3, [r7, #20]
 801dc68:	687b      	ldr	r3, [r7, #4]
 801dc6a:	3b01      	subs	r3, #1
 801dc6c:	607b      	str	r3, [r7, #4]
 801dc6e:	693b      	ldr	r3, [r7, #16]
 801dc70:	781b      	ldrb	r3, [r3, #0]
 801dc72:	2b00      	cmp	r3, #0
 801dc74:	d01a      	beq.n	801dcac <strncasecmp+0x72>
 801dc76:	697b      	ldr	r3, [r7, #20]
 801dc78:	781b      	ldrb	r3, [r3, #0]
 801dc7a:	2b00      	cmp	r3, #0
 801dc7c:	d016      	beq.n	801dcac <strncasecmp+0x72>
 801dc7e:	687b      	ldr	r3, [r7, #4]
 801dc80:	2b00      	cmp	r3, #0
 801dc82:	d013      	beq.n	801dcac <strncasecmp+0x72>
 801dc84:	693b      	ldr	r3, [r7, #16]
 801dc86:	781a      	ldrb	r2, [r3, #0]
 801dc88:	697b      	ldr	r3, [r7, #20]
 801dc8a:	781b      	ldrb	r3, [r3, #0]
 801dc8c:	429a      	cmp	r2, r3
 801dc8e:	d0e5      	beq.n	801dc5c <strncasecmp+0x22>
 801dc90:	693b      	ldr	r3, [r7, #16]
 801dc92:	781b      	ldrb	r3, [r3, #0]
 801dc94:	4618      	mov	r0, r3
 801dc96:	f000 fc81 	bl	801e59c <tolower>
 801dc9a:	4604      	mov	r4, r0
 801dc9c:	697b      	ldr	r3, [r7, #20]
 801dc9e:	781b      	ldrb	r3, [r3, #0]
 801dca0:	4618      	mov	r0, r3
 801dca2:	f000 fc7b 	bl	801e59c <tolower>
 801dca6:	4603      	mov	r3, r0
 801dca8:	429c      	cmp	r4, r3
 801dcaa:	d0d7      	beq.n	801dc5c <strncasecmp+0x22>
	return tolower(*l) - tolower(*r);
 801dcac:	693b      	ldr	r3, [r7, #16]
 801dcae:	781b      	ldrb	r3, [r3, #0]
 801dcb0:	4618      	mov	r0, r3
 801dcb2:	f000 fc73 	bl	801e59c <tolower>
 801dcb6:	4604      	mov	r4, r0
 801dcb8:	697b      	ldr	r3, [r7, #20]
 801dcba:	781b      	ldrb	r3, [r3, #0]
 801dcbc:	4618      	mov	r0, r3
 801dcbe:	f000 fc6d 	bl	801e59c <tolower>
 801dcc2:	4603      	mov	r3, r0
 801dcc4:	1ae3      	subs	r3, r4, r3
}
 801dcc6:	4618      	mov	r0, r3
 801dcc8:	371c      	adds	r7, #28
 801dcca:	46bd      	mov	sp, r7
 801dccc:	bd90      	pop	{r4, r7, pc}

0801dcce <strnlen>:
#include <string.h>

size_t strnlen(const char *s, size_t n)
{
 801dcce:	b580      	push	{r7, lr}
 801dcd0:	b084      	sub	sp, #16
 801dcd2:	af00      	add	r7, sp, #0
 801dcd4:	6078      	str	r0, [r7, #4]
 801dcd6:	6039      	str	r1, [r7, #0]
	const char *p = memchr(s, 0, n);
 801dcd8:	683a      	ldr	r2, [r7, #0]
 801dcda:	2100      	movs	r1, #0
 801dcdc:	6878      	ldr	r0, [r7, #4]
 801dcde:	f001 f908 	bl	801eef2 <memchr>
 801dce2:	60f8      	str	r0, [r7, #12]
	return p ? p-s : n;
 801dce4:	68fb      	ldr	r3, [r7, #12]
 801dce6:	2b00      	cmp	r3, #0
 801dce8:	d003      	beq.n	801dcf2 <strnlen+0x24>
 801dcea:	68fa      	ldr	r2, [r7, #12]
 801dcec:	687b      	ldr	r3, [r7, #4]
 801dcee:	1ad3      	subs	r3, r2, r3
 801dcf0:	e000      	b.n	801dcf4 <strnlen+0x26>
 801dcf2:	683b      	ldr	r3, [r7, #0]
}
 801dcf4:	4618      	mov	r0, r3
 801dcf6:	3710      	adds	r7, #16
 801dcf8:	46bd      	mov	sp, r7
 801dcfa:	bd80      	pop	{r7, pc}
 801dcfc:	0000      	movs	r0, r0
	...

0801dd00 <__secs_to_tm>:
#define DAYS_PER_400Y (365*400 + 97)
#define DAYS_PER_100Y (365*100 + 24)
#define DAYS_PER_4Y   (365*4   + 1)

int __secs_to_tm(long long t, struct tm *tm)
{
 801dd00:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 801dd04:	b09a      	sub	sp, #104	; 0x68
 801dd06:	af00      	add	r7, sp, #0
 801dd08:	e9c7 0108 	strd	r0, r1, [r7, #32]
 801dd0c:	61fa      	str	r2, [r7, #28]
	int months;
	int wday, yday, leap;
	static const char days_in_month[] = {31,30,31,30,31,31,30,31,30,31,31,29};

	/* Reject time_t values whose year would overflow int */
	if (t < INT_MIN * 31622400LL || t > INT_MAX * 31622400LL)
 801dd0e:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801dd12:	f04f 32ff 	mov.w	r2, #4294967295
 801dd16:	4ba6      	ldr	r3, [pc, #664]	; (801dfb0 <__secs_to_tm+0x2b0>)
 801dd18:	4282      	cmp	r2, r0
 801dd1a:	418b      	sbcs	r3, r1
 801dd1c:	da07      	bge.n	801dd2e <__secs_to_tm+0x2e>
 801dd1e:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801dd22:	a39f      	add	r3, pc, #636	; (adr r3, 801dfa0 <__secs_to_tm+0x2a0>)
 801dd24:	e9d3 2300 	ldrd	r2, r3, [r3]
 801dd28:	4282      	cmp	r2, r0
 801dd2a:	418b      	sbcs	r3, r1
 801dd2c:	da02      	bge.n	801dd34 <__secs_to_tm+0x34>
		return -1;
 801dd2e:	f04f 33ff 	mov.w	r3, #4294967295
 801dd32:	e196      	b.n	801e062 <__secs_to_tm+0x362>

	secs = t - LEAPOCH;
 801dd34:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801dd38:	a39b      	add	r3, pc, #620	; (adr r3, 801dfa8 <__secs_to_tm+0x2a8>)
 801dd3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801dd3e:	1884      	adds	r4, r0, r2
 801dd40:	eb41 0503 	adc.w	r5, r1, r3
 801dd44:	e9c7 4518 	strd	r4, r5, [r7, #96]	; 0x60
	days = secs / 86400;
 801dd48:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 801dd4c:	4a99      	ldr	r2, [pc, #612]	; (801dfb4 <__secs_to_tm+0x2b4>)
 801dd4e:	f04f 0300 	mov.w	r3, #0
 801dd52:	f7e3 f9bb 	bl	80010cc <__aeabi_ldivmod>
 801dd56:	4602      	mov	r2, r0
 801dd58:	460b      	mov	r3, r1
 801dd5a:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50
	remsecs = secs % 86400;
 801dd5e:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 801dd62:	4a94      	ldr	r2, [pc, #592]	; (801dfb4 <__secs_to_tm+0x2b4>)
 801dd64:	f04f 0300 	mov.w	r3, #0
 801dd68:	f7e3 f9b0 	bl	80010cc <__aeabi_ldivmod>
 801dd6c:	4613      	mov	r3, r2
 801dd6e:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (remsecs < 0) {
 801dd70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801dd72:	2b00      	cmp	r3, #0
 801dd74:	da0b      	bge.n	801dd8e <__secs_to_tm+0x8e>
		remsecs += 86400;
 801dd76:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801dd78:	4b8e      	ldr	r3, [pc, #568]	; (801dfb4 <__secs_to_tm+0x2b4>)
 801dd7a:	4413      	add	r3, r2
 801dd7c:	62fb      	str	r3, [r7, #44]	; 0x2c
		days--;
 801dd7e:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 801dd82:	f112 38ff 	adds.w	r8, r2, #4294967295
 801dd86:	f143 39ff 	adc.w	r9, r3, #4294967295
 801dd8a:	e9c7 8914 	strd	r8, r9, [r7, #80]	; 0x50
	}

	wday = (3+days)%7;
 801dd8e:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 801dd92:	1cd1      	adds	r1, r2, #3
 801dd94:	6139      	str	r1, [r7, #16]
 801dd96:	f143 0300 	adc.w	r3, r3, #0
 801dd9a:	617b      	str	r3, [r7, #20]
 801dd9c:	f04f 0207 	mov.w	r2, #7
 801dda0:	f04f 0300 	mov.w	r3, #0
 801dda4:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801dda8:	f7e3 f990 	bl	80010cc <__aeabi_ldivmod>
 801ddac:	4613      	mov	r3, r2
 801ddae:	647b      	str	r3, [r7, #68]	; 0x44
	if (wday < 0) wday += 7;
 801ddb0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ddb2:	2b00      	cmp	r3, #0
 801ddb4:	da02      	bge.n	801ddbc <__secs_to_tm+0xbc>
 801ddb6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ddb8:	3307      	adds	r3, #7
 801ddba:	647b      	str	r3, [r7, #68]	; 0x44

	qc_cycles = days / DAYS_PER_400Y;
 801ddbc:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 801ddc0:	4a7d      	ldr	r2, [pc, #500]	; (801dfb8 <__secs_to_tm+0x2b8>)
 801ddc2:	f04f 0300 	mov.w	r3, #0
 801ddc6:	f7e3 f981 	bl	80010cc <__aeabi_ldivmod>
 801ddca:	4602      	mov	r2, r0
 801ddcc:	460b      	mov	r3, r1
 801ddce:	4613      	mov	r3, r2
 801ddd0:	637b      	str	r3, [r7, #52]	; 0x34
	remdays = days % DAYS_PER_400Y;
 801ddd2:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 801ddd6:	4a78      	ldr	r2, [pc, #480]	; (801dfb8 <__secs_to_tm+0x2b8>)
 801ddd8:	f04f 0300 	mov.w	r3, #0
 801dddc:	f7e3 f976 	bl	80010cc <__aeabi_ldivmod>
 801dde0:	4613      	mov	r3, r2
 801dde2:	62bb      	str	r3, [r7, #40]	; 0x28
	if (remdays < 0) {
 801dde4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801dde6:	2b00      	cmp	r3, #0
 801dde8:	da06      	bge.n	801ddf8 <__secs_to_tm+0xf8>
		remdays += DAYS_PER_400Y;
 801ddea:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801ddec:	4b72      	ldr	r3, [pc, #456]	; (801dfb8 <__secs_to_tm+0x2b8>)
 801ddee:	4413      	add	r3, r2
 801ddf0:	62bb      	str	r3, [r7, #40]	; 0x28
		qc_cycles--;
 801ddf2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ddf4:	3b01      	subs	r3, #1
 801ddf6:	637b      	str	r3, [r7, #52]	; 0x34
	}

	c_cycles = remdays / DAYS_PER_100Y;
 801ddf8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ddfa:	4a70      	ldr	r2, [pc, #448]	; (801dfbc <__secs_to_tm+0x2bc>)
 801ddfc:	fb82 1203 	smull	r1, r2, r2, r3
 801de00:	441a      	add	r2, r3
 801de02:	13d2      	asrs	r2, r2, #15
 801de04:	17db      	asrs	r3, r3, #31
 801de06:	1ad3      	subs	r3, r2, r3
 801de08:	63bb      	str	r3, [r7, #56]	; 0x38
	if (c_cycles == 4) c_cycles--;
 801de0a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801de0c:	2b04      	cmp	r3, #4
 801de0e:	d102      	bne.n	801de16 <__secs_to_tm+0x116>
 801de10:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801de12:	3b01      	subs	r3, #1
 801de14:	63bb      	str	r3, [r7, #56]	; 0x38
	remdays -= c_cycles * DAYS_PER_100Y;
 801de16:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801de18:	4a69      	ldr	r2, [pc, #420]	; (801dfc0 <__secs_to_tm+0x2c0>)
 801de1a:	fb02 f303 	mul.w	r3, r2, r3
 801de1e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801de20:	4413      	add	r3, r2
 801de22:	62bb      	str	r3, [r7, #40]	; 0x28

	q_cycles = remdays / DAYS_PER_4Y;
 801de24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801de26:	4a67      	ldr	r2, [pc, #412]	; (801dfc4 <__secs_to_tm+0x2c4>)
 801de28:	fb82 1203 	smull	r1, r2, r2, r3
 801de2c:	11d2      	asrs	r2, r2, #7
 801de2e:	17db      	asrs	r3, r3, #31
 801de30:	1ad3      	subs	r3, r2, r3
 801de32:	63fb      	str	r3, [r7, #60]	; 0x3c
	if (q_cycles == 25) q_cycles--;
 801de34:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801de36:	2b19      	cmp	r3, #25
 801de38:	d102      	bne.n	801de40 <__secs_to_tm+0x140>
 801de3a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801de3c:	3b01      	subs	r3, #1
 801de3e:	63fb      	str	r3, [r7, #60]	; 0x3c
	remdays -= q_cycles * DAYS_PER_4Y;
 801de40:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801de42:	4a61      	ldr	r2, [pc, #388]	; (801dfc8 <__secs_to_tm+0x2c8>)
 801de44:	fb02 f303 	mul.w	r3, r2, r3
 801de48:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801de4a:	4413      	add	r3, r2
 801de4c:	62bb      	str	r3, [r7, #40]	; 0x28

	remyears = remdays / 365;
 801de4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801de50:	4a5e      	ldr	r2, [pc, #376]	; (801dfcc <__secs_to_tm+0x2cc>)
 801de52:	fb82 1203 	smull	r1, r2, r2, r3
 801de56:	441a      	add	r2, r3
 801de58:	1212      	asrs	r2, r2, #8
 801de5a:	17db      	asrs	r3, r3, #31
 801de5c:	1ad3      	subs	r3, r2, r3
 801de5e:	633b      	str	r3, [r7, #48]	; 0x30
	if (remyears == 4) remyears--;
 801de60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801de62:	2b04      	cmp	r3, #4
 801de64:	d102      	bne.n	801de6c <__secs_to_tm+0x16c>
 801de66:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801de68:	3b01      	subs	r3, #1
 801de6a:	633b      	str	r3, [r7, #48]	; 0x30
	remdays -= remyears * 365;
 801de6c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801de6e:	f46f 72b6 	mvn.w	r2, #364	; 0x16c
 801de72:	fb02 f303 	mul.w	r3, r2, r3
 801de76:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801de78:	4413      	add	r3, r2
 801de7a:	62bb      	str	r3, [r7, #40]	; 0x28

	leap = !remyears && (q_cycles || !c_cycles);
 801de7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801de7e:	2b00      	cmp	r3, #0
 801de80:	d107      	bne.n	801de92 <__secs_to_tm+0x192>
 801de82:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801de84:	2b00      	cmp	r3, #0
 801de86:	d102      	bne.n	801de8e <__secs_to_tm+0x18e>
 801de88:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801de8a:	2b00      	cmp	r3, #0
 801de8c:	d101      	bne.n	801de92 <__secs_to_tm+0x192>
 801de8e:	2301      	movs	r3, #1
 801de90:	e000      	b.n	801de94 <__secs_to_tm+0x194>
 801de92:	2300      	movs	r3, #0
 801de94:	64fb      	str	r3, [r7, #76]	; 0x4c
	yday = remdays + 31 + 28 + leap;
 801de96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801de98:	333b      	adds	r3, #59	; 0x3b
 801de9a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801de9c:	4413      	add	r3, r2
 801de9e:	64bb      	str	r3, [r7, #72]	; 0x48
	if (yday >= 365+leap) yday -= 365+leap;
 801dea0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801dea2:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 801dea6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801dea8:	429a      	cmp	r2, r3
 801deaa:	dd05      	ble.n	801deb8 <__secs_to_tm+0x1b8>
 801deac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801deae:	f203 136d 	addw	r3, r3, #365	; 0x16d
 801deb2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801deb4:	1ad3      	subs	r3, r2, r3
 801deb6:	64bb      	str	r3, [r7, #72]	; 0x48

	years = remyears + 4*q_cycles + 100*c_cycles + 400LL*qc_cycles;
 801deb8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801deba:	009a      	lsls	r2, r3, #2
 801debc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801debe:	441a      	add	r2, r3
 801dec0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801dec2:	2164      	movs	r1, #100	; 0x64
 801dec4:	fb01 f303 	mul.w	r3, r1, r3
 801dec8:	4413      	add	r3, r2
 801deca:	4698      	mov	r8, r3
 801decc:	ea4f 79e8 	mov.w	r9, r8, asr #31
 801ded0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ded2:	4618      	mov	r0, r3
 801ded4:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801ded8:	4602      	mov	r2, r0
 801deda:	460b      	mov	r3, r1
 801dedc:	1894      	adds	r4, r2, r2
 801dede:	60bc      	str	r4, [r7, #8]
 801dee0:	415b      	adcs	r3, r3
 801dee2:	60fb      	str	r3, [r7, #12]
 801dee4:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801dee8:	1812      	adds	r2, r2, r0
 801deea:	eb41 0303 	adc.w	r3, r1, r3
 801deee:	f04f 0400 	mov.w	r4, #0
 801def2:	f04f 0500 	mov.w	r5, #0
 801def6:	00dd      	lsls	r5, r3, #3
 801def8:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
 801defc:	00d4      	lsls	r4, r2, #3
 801defe:	4622      	mov	r2, r4
 801df00:	462b      	mov	r3, r5
 801df02:	1812      	adds	r2, r2, r0
 801df04:	eb41 0303 	adc.w	r3, r1, r3
 801df08:	f04f 0000 	mov.w	r0, #0
 801df0c:	f04f 0100 	mov.w	r1, #0
 801df10:	0119      	lsls	r1, r3, #4
 801df12:	ea41 7112 	orr.w	r1, r1, r2, lsr #28
 801df16:	0110      	lsls	r0, r2, #4
 801df18:	4602      	mov	r2, r0
 801df1a:	460b      	mov	r3, r1
 801df1c:	eb18 0102 	adds.w	r1, r8, r2
 801df20:	6039      	str	r1, [r7, #0]
 801df22:	eb49 0303 	adc.w	r3, r9, r3
 801df26:	607b      	str	r3, [r7, #4]
 801df28:	e9d7 3400 	ldrd	r3, r4, [r7]
 801df2c:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58

	for (months=0; days_in_month[months] <= remdays; months++)
 801df30:	2300      	movs	r3, #0
 801df32:	643b      	str	r3, [r7, #64]	; 0x40
 801df34:	e00a      	b.n	801df4c <__secs_to_tm+0x24c>
		remdays -= days_in_month[months];
 801df36:	4a26      	ldr	r2, [pc, #152]	; (801dfd0 <__secs_to_tm+0x2d0>)
 801df38:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801df3a:	4413      	add	r3, r2
 801df3c:	781b      	ldrb	r3, [r3, #0]
 801df3e:	461a      	mov	r2, r3
 801df40:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801df42:	1a9b      	subs	r3, r3, r2
 801df44:	62bb      	str	r3, [r7, #40]	; 0x28
	for (months=0; days_in_month[months] <= remdays; months++)
 801df46:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801df48:	3301      	adds	r3, #1
 801df4a:	643b      	str	r3, [r7, #64]	; 0x40
 801df4c:	4a20      	ldr	r2, [pc, #128]	; (801dfd0 <__secs_to_tm+0x2d0>)
 801df4e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801df50:	4413      	add	r3, r2
 801df52:	781b      	ldrb	r3, [r3, #0]
 801df54:	461a      	mov	r2, r3
 801df56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801df58:	4293      	cmp	r3, r2
 801df5a:	daec      	bge.n	801df36 <__secs_to_tm+0x236>

	if (months >= 10) {
 801df5c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801df5e:	2b09      	cmp	r3, #9
 801df60:	dd0a      	ble.n	801df78 <__secs_to_tm+0x278>
		months -= 12;
 801df62:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801df64:	3b0c      	subs	r3, #12
 801df66:	643b      	str	r3, [r7, #64]	; 0x40
		years++;
 801df68:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 801df6c:	f112 0a01 	adds.w	sl, r2, #1
 801df70:	f143 0b00 	adc.w	fp, r3, #0
 801df74:	e9c7 ab16 	strd	sl, fp, [r7, #88]	; 0x58
	}

	if (years+100 > INT_MAX || years+100 < INT_MIN)
 801df78:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 801df7c:	4815      	ldr	r0, [pc, #84]	; (801dfd4 <__secs_to_tm+0x2d4>)
 801df7e:	f04f 0100 	mov.w	r1, #0
 801df82:	4290      	cmp	r0, r2
 801df84:	eb71 0303 	sbcs.w	r3, r1, r3
 801df88:	db07      	blt.n	801df9a <__secs_to_tm+0x29a>
 801df8a:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 801df8e:	4812      	ldr	r0, [pc, #72]	; (801dfd8 <__secs_to_tm+0x2d8>)
 801df90:	f04f 31ff 	mov.w	r1, #4294967295
 801df94:	4282      	cmp	r2, r0
 801df96:	418b      	sbcs	r3, r1
 801df98:	da20      	bge.n	801dfdc <__secs_to_tm+0x2dc>
		return -1;
 801df9a:	f04f 33ff 	mov.w	r3, #4294967295
 801df9e:	e060      	b.n	801e062 <__secs_to_tm+0x362>
 801dfa0:	fe1d7b00 	.word	0xfe1d7b00
 801dfa4:	00f1427f 	.word	0x00f1427f
 801dfa8:	c743a280 	.word	0xc743a280
 801dfac:	ffffffff 	.word	0xffffffff
 801dfb0:	ff0ebd7f 	.word	0xff0ebd7f
 801dfb4:	00015180 	.word	0x00015180
 801dfb8:	00023ab1 	.word	0x00023ab1
 801dfbc:	e5ac81fb 	.word	0xe5ac81fb
 801dfc0:	ffff7154 	.word	0xffff7154
 801dfc4:	166db073 	.word	0x166db073
 801dfc8:	fffffa4b 	.word	0xfffffa4b
 801dfcc:	b38cf9b1 	.word	0xb38cf9b1
 801dfd0:	080242ec 	.word	0x080242ec
 801dfd4:	7fffff9b 	.word	0x7fffff9b
 801dfd8:	7fffff9c 	.word	0x7fffff9c

	tm->tm_year = years + 100;
 801dfdc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801dfde:	3364      	adds	r3, #100	; 0x64
 801dfe0:	461a      	mov	r2, r3
 801dfe2:	69fb      	ldr	r3, [r7, #28]
 801dfe4:	615a      	str	r2, [r3, #20]
	tm->tm_mon = months + 2;
 801dfe6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801dfe8:	1c9a      	adds	r2, r3, #2
 801dfea:	69fb      	ldr	r3, [r7, #28]
 801dfec:	611a      	str	r2, [r3, #16]
	tm->tm_mday = remdays + 1;
 801dfee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801dff0:	1c5a      	adds	r2, r3, #1
 801dff2:	69fb      	ldr	r3, [r7, #28]
 801dff4:	60da      	str	r2, [r3, #12]
	tm->tm_wday = wday;
 801dff6:	69fb      	ldr	r3, [r7, #28]
 801dff8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801dffa:	619a      	str	r2, [r3, #24]
	tm->tm_yday = yday;
 801dffc:	69fb      	ldr	r3, [r7, #28]
 801dffe:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801e000:	61da      	str	r2, [r3, #28]

	tm->tm_hour = remsecs / 3600;
 801e002:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e004:	4a19      	ldr	r2, [pc, #100]	; (801e06c <__secs_to_tm+0x36c>)
 801e006:	fb82 1203 	smull	r1, r2, r2, r3
 801e00a:	441a      	add	r2, r3
 801e00c:	12d2      	asrs	r2, r2, #11
 801e00e:	17db      	asrs	r3, r3, #31
 801e010:	1ad2      	subs	r2, r2, r3
 801e012:	69fb      	ldr	r3, [r7, #28]
 801e014:	609a      	str	r2, [r3, #8]
	tm->tm_min = remsecs / 60 % 60;
 801e016:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e018:	4a15      	ldr	r2, [pc, #84]	; (801e070 <__secs_to_tm+0x370>)
 801e01a:	fb82 1203 	smull	r1, r2, r2, r3
 801e01e:	441a      	add	r2, r3
 801e020:	1152      	asrs	r2, r2, #5
 801e022:	17db      	asrs	r3, r3, #31
 801e024:	1ad2      	subs	r2, r2, r3
 801e026:	4b12      	ldr	r3, [pc, #72]	; (801e070 <__secs_to_tm+0x370>)
 801e028:	fb83 1302 	smull	r1, r3, r3, r2
 801e02c:	4413      	add	r3, r2
 801e02e:	1159      	asrs	r1, r3, #5
 801e030:	17d3      	asrs	r3, r2, #31
 801e032:	1ac9      	subs	r1, r1, r3
 801e034:	460b      	mov	r3, r1
 801e036:	011b      	lsls	r3, r3, #4
 801e038:	1a5b      	subs	r3, r3, r1
 801e03a:	009b      	lsls	r3, r3, #2
 801e03c:	1ad1      	subs	r1, r2, r3
 801e03e:	69fb      	ldr	r3, [r7, #28]
 801e040:	6059      	str	r1, [r3, #4]
	tm->tm_sec = remsecs % 60;
 801e042:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801e044:	4b0a      	ldr	r3, [pc, #40]	; (801e070 <__secs_to_tm+0x370>)
 801e046:	fb83 1302 	smull	r1, r3, r3, r2
 801e04a:	4413      	add	r3, r2
 801e04c:	1159      	asrs	r1, r3, #5
 801e04e:	17d3      	asrs	r3, r2, #31
 801e050:	1ac9      	subs	r1, r1, r3
 801e052:	460b      	mov	r3, r1
 801e054:	011b      	lsls	r3, r3, #4
 801e056:	1a5b      	subs	r3, r3, r1
 801e058:	009b      	lsls	r3, r3, #2
 801e05a:	1ad1      	subs	r1, r2, r3
 801e05c:	69fb      	ldr	r3, [r7, #28]
 801e05e:	6019      	str	r1, [r3, #0]

	return 0;
 801e060:	2300      	movs	r3, #0
}
 801e062:	4618      	mov	r0, r3
 801e064:	3768      	adds	r7, #104	; 0x68
 801e066:	46bd      	mov	sp, r7
 801e068:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 801e06c:	91a2b3c5 	.word	0x91a2b3c5
 801e070:	88888889 	.word	0x88888889

0801e074 <__tm_to_secs>:
#include "time_impl.h"

long long __tm_to_secs(const struct tm *tm)
{
 801e074:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 801e078:	b094      	sub	sp, #80	; 0x50
 801e07a:	af00      	add	r7, sp, #0
 801e07c:	6278      	str	r0, [r7, #36]	; 0x24
 801e07e:	4b88      	ldr	r3, [pc, #544]	; (801e2a0 <__tm_to_secs+0x22c>)
 801e080:	681b      	ldr	r3, [r3, #0]
 801e082:	64fb      	str	r3, [r7, #76]	; 0x4c
 801e084:	f04f 0300 	mov.w	r3, #0
	int is_leap;
	long long year = tm->tm_year;
 801e088:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e08a:	695b      	ldr	r3, [r3, #20]
 801e08c:	461a      	mov	r2, r3
 801e08e:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801e092:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	int month = tm->tm_mon;
 801e096:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e098:	691b      	ldr	r3, [r3, #16]
 801e09a:	633b      	str	r3, [r7, #48]	; 0x30
	if (month >= 12 || month < 0) {
 801e09c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e09e:	2b0b      	cmp	r3, #11
 801e0a0:	dc02      	bgt.n	801e0a8 <__tm_to_secs+0x34>
 801e0a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e0a4:	2b00      	cmp	r3, #0
 801e0a6:	da28      	bge.n	801e0fa <__tm_to_secs+0x86>
		int adj = month / 12;
 801e0a8:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801e0aa:	4b7e      	ldr	r3, [pc, #504]	; (801e2a4 <__tm_to_secs+0x230>)
 801e0ac:	fb83 2301 	smull	r2, r3, r3, r1
 801e0b0:	105a      	asrs	r2, r3, #1
 801e0b2:	17cb      	asrs	r3, r1, #31
 801e0b4:	1ad3      	subs	r3, r2, r3
 801e0b6:	637b      	str	r3, [r7, #52]	; 0x34
		month %= 12;
 801e0b8:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801e0ba:	4b7a      	ldr	r3, [pc, #488]	; (801e2a4 <__tm_to_secs+0x230>)
 801e0bc:	fb83 2301 	smull	r2, r3, r3, r1
 801e0c0:	105a      	asrs	r2, r3, #1
 801e0c2:	17cb      	asrs	r3, r1, #31
 801e0c4:	1ad2      	subs	r2, r2, r3
 801e0c6:	4613      	mov	r3, r2
 801e0c8:	005b      	lsls	r3, r3, #1
 801e0ca:	4413      	add	r3, r2
 801e0cc:	009b      	lsls	r3, r3, #2
 801e0ce:	1acb      	subs	r3, r1, r3
 801e0d0:	633b      	str	r3, [r7, #48]	; 0x30
		if (month < 0) {
 801e0d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e0d4:	2b00      	cmp	r3, #0
 801e0d6:	da05      	bge.n	801e0e4 <__tm_to_secs+0x70>
			adj--;
 801e0d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e0da:	3b01      	subs	r3, #1
 801e0dc:	637b      	str	r3, [r7, #52]	; 0x34
			month += 12;
 801e0de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e0e0:	330c      	adds	r3, #12
 801e0e2:	633b      	str	r3, [r7, #48]	; 0x30
		}
		year += adj;
 801e0e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e0e6:	4618      	mov	r0, r3
 801e0e8:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801e0ec:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801e0f0:	1814      	adds	r4, r2, r0
 801e0f2:	eb43 0501 	adc.w	r5, r3, r1
 801e0f6:	e9c7 450e 	strd	r4, r5, [r7, #56]	; 0x38
	}
	long long t = __year_to_secs(year, &is_leap);
 801e0fa:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801e0fe:	461a      	mov	r2, r3
 801e100:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801e104:	f000 f8d0 	bl	801e2a8 <__year_to_secs>
 801e108:	e9c7 0110 	strd	r0, r1, [r7, #64]	; 0x40
	t += __month_to_secs(month, is_leap);
 801e10c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e10e:	4619      	mov	r1, r3
 801e110:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801e112:	f000 ff59 	bl	801efc8 <__month_to_secs>
 801e116:	4603      	mov	r3, r0
 801e118:	4618      	mov	r0, r3
 801e11a:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801e11e:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 801e122:	eb12 0800 	adds.w	r8, r2, r0
 801e126:	eb43 0901 	adc.w	r9, r3, r1
 801e12a:	e9c7 8910 	strd	r8, r9, [r7, #64]	; 0x40
	t += 86400LL * (tm->tm_mday-1);
 801e12e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e130:	68db      	ldr	r3, [r3, #12]
 801e132:	3b01      	subs	r3, #1
 801e134:	461a      	mov	r2, r3
 801e136:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801e13a:	4610      	mov	r0, r2
 801e13c:	4619      	mov	r1, r3
 801e13e:	1804      	adds	r4, r0, r0
 801e140:	61bc      	str	r4, [r7, #24]
 801e142:	4149      	adcs	r1, r1
 801e144:	61f9      	str	r1, [r7, #28]
 801e146:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 801e14a:	1880      	adds	r0, r0, r2
 801e14c:	eb43 0101 	adc.w	r1, r3, r1
 801e150:	f04f 0200 	mov.w	r2, #0
 801e154:	f04f 0300 	mov.w	r3, #0
 801e158:	010b      	lsls	r3, r1, #4
 801e15a:	ea43 7310 	orr.w	r3, r3, r0, lsr #28
 801e15e:	0102      	lsls	r2, r0, #4
 801e160:	1a12      	subs	r2, r2, r0
 801e162:	eb63 0301 	sbc.w	r3, r3, r1
 801e166:	f04f 0000 	mov.w	r0, #0
 801e16a:	f04f 0100 	mov.w	r1, #0
 801e16e:	0119      	lsls	r1, r3, #4
 801e170:	ea41 7112 	orr.w	r1, r1, r2, lsr #28
 801e174:	0110      	lsls	r0, r2, #4
 801e176:	1a80      	subs	r0, r0, r2
 801e178:	eb61 0103 	sbc.w	r1, r1, r3
 801e17c:	f04f 0200 	mov.w	r2, #0
 801e180:	f04f 0300 	mov.w	r3, #0
 801e184:	01cb      	lsls	r3, r1, #7
 801e186:	ea43 6350 	orr.w	r3, r3, r0, lsr #25
 801e18a:	01c2      	lsls	r2, r0, #7
 801e18c:	4610      	mov	r0, r2
 801e18e:	4619      	mov	r1, r3
 801e190:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 801e194:	1814      	adds	r4, r2, r0
 801e196:	613c      	str	r4, [r7, #16]
 801e198:	414b      	adcs	r3, r1
 801e19a:	617b      	str	r3, [r7, #20]
 801e19c:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 801e1a0:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
	t += 3600LL * tm->tm_hour;
 801e1a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e1a6:	689b      	ldr	r3, [r3, #8]
 801e1a8:	4618      	mov	r0, r3
 801e1aa:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801e1ae:	4602      	mov	r2, r0
 801e1b0:	460b      	mov	r3, r1
 801e1b2:	f04f 0400 	mov.w	r4, #0
 801e1b6:	f04f 0500 	mov.w	r5, #0
 801e1ba:	00dd      	lsls	r5, r3, #3
 801e1bc:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
 801e1c0:	00d4      	lsls	r4, r2, #3
 801e1c2:	4622      	mov	r2, r4
 801e1c4:	462b      	mov	r3, r5
 801e1c6:	1a12      	subs	r2, r2, r0
 801e1c8:	eb63 0301 	sbc.w	r3, r3, r1
 801e1cc:	f04f 0400 	mov.w	r4, #0
 801e1d0:	f04f 0500 	mov.w	r5, #0
 801e1d4:	015d      	lsls	r5, r3, #5
 801e1d6:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 801e1da:	0154      	lsls	r4, r2, #5
 801e1dc:	4622      	mov	r2, r4
 801e1de:	462b      	mov	r3, r5
 801e1e0:	1812      	adds	r2, r2, r0
 801e1e2:	eb41 0303 	adc.w	r3, r1, r3
 801e1e6:	f04f 0000 	mov.w	r0, #0
 801e1ea:	f04f 0100 	mov.w	r1, #0
 801e1ee:	0119      	lsls	r1, r3, #4
 801e1f0:	ea41 7112 	orr.w	r1, r1, r2, lsr #28
 801e1f4:	0110      	lsls	r0, r2, #4
 801e1f6:	4602      	mov	r2, r0
 801e1f8:	460b      	mov	r3, r1
 801e1fa:	4610      	mov	r0, r2
 801e1fc:	4619      	mov	r1, r3
 801e1fe:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 801e202:	1814      	adds	r4, r2, r0
 801e204:	60bc      	str	r4, [r7, #8]
 801e206:	414b      	adcs	r3, r1
 801e208:	60fb      	str	r3, [r7, #12]
 801e20a:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 801e20e:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
	t += 60LL * tm->tm_min;
 801e212:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e214:	685b      	ldr	r3, [r3, #4]
 801e216:	461c      	mov	r4, r3
 801e218:	ea4f 75e4 	mov.w	r5, r4, asr #31
 801e21c:	4622      	mov	r2, r4
 801e21e:	462b      	mov	r3, r5
 801e220:	f04f 0000 	mov.w	r0, #0
 801e224:	f04f 0100 	mov.w	r1, #0
 801e228:	0119      	lsls	r1, r3, #4
 801e22a:	ea41 7112 	orr.w	r1, r1, r2, lsr #28
 801e22e:	0110      	lsls	r0, r2, #4
 801e230:	4602      	mov	r2, r0
 801e232:	460b      	mov	r3, r1
 801e234:	1b12      	subs	r2, r2, r4
 801e236:	eb63 0305 	sbc.w	r3, r3, r5
 801e23a:	f04f 0000 	mov.w	r0, #0
 801e23e:	f04f 0100 	mov.w	r1, #0
 801e242:	0099      	lsls	r1, r3, #2
 801e244:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 801e248:	0090      	lsls	r0, r2, #2
 801e24a:	4602      	mov	r2, r0
 801e24c:	460b      	mov	r3, r1
 801e24e:	4610      	mov	r0, r2
 801e250:	4619      	mov	r1, r3
 801e252:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 801e256:	1814      	adds	r4, r2, r0
 801e258:	603c      	str	r4, [r7, #0]
 801e25a:	414b      	adcs	r3, r1
 801e25c:	607b      	str	r3, [r7, #4]
 801e25e:	e9d7 3400 	ldrd	r3, r4, [r7]
 801e262:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
	t += tm->tm_sec;
 801e266:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e268:	681b      	ldr	r3, [r3, #0]
 801e26a:	461a      	mov	r2, r3
 801e26c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801e270:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
 801e274:	eb10 0a02 	adds.w	sl, r0, r2
 801e278:	eb41 0b03 	adc.w	fp, r1, r3
 801e27c:	e9c7 ab10 	strd	sl, fp, [r7, #64]	; 0x40
	return t;
 801e280:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
}
 801e284:	4906      	ldr	r1, [pc, #24]	; (801e2a0 <__tm_to_secs+0x22c>)
 801e286:	6808      	ldr	r0, [r1, #0]
 801e288:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801e28a:	4048      	eors	r0, r1
 801e28c:	d001      	beq.n	801e292 <__tm_to_secs+0x21e>
 801e28e:	f7e6 f8ab 	bl	80043e8 <__stack_chk_fail>
 801e292:	4610      	mov	r0, r2
 801e294:	4619      	mov	r1, r3
 801e296:	3750      	adds	r7, #80	; 0x50
 801e298:	46bd      	mov	sp, r7
 801e29a:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 801e29e:	bf00      	nop
 801e2a0:	080231f8 	.word	0x080231f8
 801e2a4:	2aaaaaab 	.word	0x2aaaaaab

0801e2a8 <__year_to_secs>:
long long __year_to_secs(long long year, int *is_leap)
{
 801e2a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e2ac:	b095      	sub	sp, #84	; 0x54
 801e2ae:	af00      	add	r7, sp, #0
 801e2b0:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 801e2b4:	627a      	str	r2, [r7, #36]	; 0x24
 801e2b6:	4b94      	ldr	r3, [pc, #592]	; (801e508 <__year_to_secs+0x260>)
 801e2b8:	681b      	ldr	r3, [r3, #0]
 801e2ba:	64fb      	str	r3, [r7, #76]	; 0x4c
 801e2bc:	f04f 0300 	mov.w	r3, #0
	if (year-2ULL <= 136) {
 801e2c0:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e2c4:	1e91      	subs	r1, r2, #2
 801e2c6:	61b9      	str	r1, [r7, #24]
 801e2c8:	f143 33ff 	adc.w	r3, r3, #4294967295
 801e2cc:	61fb      	str	r3, [r7, #28]
 801e2ce:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801e2d2:	2b00      	cmp	r3, #0
 801e2d4:	bf08      	it	eq
 801e2d6:	2a89      	cmpeq	r2, #137	; 0x89
 801e2d8:	d228      	bcs.n	801e32c <__year_to_secs+0x84>
		int y = year;
 801e2da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e2dc:	64bb      	str	r3, [r7, #72]	; 0x48
		int leaps = (y-68)>>2;
 801e2de:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801e2e0:	3b44      	subs	r3, #68	; 0x44
 801e2e2:	109b      	asrs	r3, r3, #2
 801e2e4:	637b      	str	r3, [r7, #52]	; 0x34
		if (!((y-68)&3)) {
 801e2e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801e2e8:	f003 0303 	and.w	r3, r3, #3
 801e2ec:	2b00      	cmp	r3, #0
 801e2ee:	d109      	bne.n	801e304 <__year_to_secs+0x5c>
			leaps--;
 801e2f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e2f2:	3b01      	subs	r3, #1
 801e2f4:	637b      	str	r3, [r7, #52]	; 0x34
			if (is_leap) *is_leap = 1;
 801e2f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e2f8:	2b00      	cmp	r3, #0
 801e2fa:	d009      	beq.n	801e310 <__year_to_secs+0x68>
 801e2fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e2fe:	2201      	movs	r2, #1
 801e300:	601a      	str	r2, [r3, #0]
 801e302:	e005      	b.n	801e310 <__year_to_secs+0x68>
		} else if (is_leap) *is_leap = 0;
 801e304:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e306:	2b00      	cmp	r3, #0
 801e308:	d002      	beq.n	801e310 <__year_to_secs+0x68>
 801e30a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e30c:	2200      	movs	r2, #0
 801e30e:	601a      	str	r2, [r3, #0]
		return 31536000*(y-70) + 86400*leaps;
 801e310:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801e312:	3b46      	subs	r3, #70	; 0x46
 801e314:	4a7d      	ldr	r2, [pc, #500]	; (801e50c <__year_to_secs+0x264>)
 801e316:	fb02 f203 	mul.w	r2, r2, r3
 801e31a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e31c:	497c      	ldr	r1, [pc, #496]	; (801e510 <__year_to_secs+0x268>)
 801e31e:	fb01 f303 	mul.w	r3, r1, r3
 801e322:	4413      	add	r3, r2
 801e324:	469a      	mov	sl, r3
 801e326:	ea4f 7bea 	mov.w	fp, sl, asr #31
 801e32a:	e0da      	b.n	801e4e2 <__year_to_secs+0x23a>
	}

	int cycles, centuries, leaps, rem;

	if (!is_leap) is_leap = &(int){0};
 801e32c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e32e:	2b00      	cmp	r3, #0
 801e330:	d104      	bne.n	801e33c <__year_to_secs+0x94>
 801e332:	2300      	movs	r3, #0
 801e334:	633b      	str	r3, [r7, #48]	; 0x30
 801e336:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801e33a:	627b      	str	r3, [r7, #36]	; 0x24
	cycles = (year-100) / 400;
 801e33c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e340:	f1b2 0164 	subs.w	r1, r2, #100	; 0x64
 801e344:	6139      	str	r1, [r7, #16]
 801e346:	f143 33ff 	adc.w	r3, r3, #4294967295
 801e34a:	617b      	str	r3, [r7, #20]
 801e34c:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801e350:	f04f 0300 	mov.w	r3, #0
 801e354:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801e358:	f7e2 feb8 	bl	80010cc <__aeabi_ldivmod>
 801e35c:	4602      	mov	r2, r0
 801e35e:	460b      	mov	r3, r1
 801e360:	4613      	mov	r3, r2
 801e362:	63bb      	str	r3, [r7, #56]	; 0x38
	rem = (year-100) % 400;
 801e364:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e368:	f1b2 0164 	subs.w	r1, r2, #100	; 0x64
 801e36c:	60b9      	str	r1, [r7, #8]
 801e36e:	f143 33ff 	adc.w	r3, r3, #4294967295
 801e372:	60fb      	str	r3, [r7, #12]
 801e374:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801e378:	f04f 0300 	mov.w	r3, #0
 801e37c:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801e380:	f7e2 fea4 	bl	80010cc <__aeabi_ldivmod>
 801e384:	4613      	mov	r3, r2
 801e386:	647b      	str	r3, [r7, #68]	; 0x44
	if (rem < 0) {
 801e388:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e38a:	2b00      	cmp	r3, #0
 801e38c:	da06      	bge.n	801e39c <__year_to_secs+0xf4>
		cycles--;
 801e38e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e390:	3b01      	subs	r3, #1
 801e392:	63bb      	str	r3, [r7, #56]	; 0x38
		rem += 400;
 801e394:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e396:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 801e39a:	647b      	str	r3, [r7, #68]	; 0x44
	}
	if (!rem) {
 801e39c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e39e:	2b00      	cmp	r3, #0
 801e3a0:	d107      	bne.n	801e3b2 <__year_to_secs+0x10a>
		*is_leap = 1;
 801e3a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e3a4:	2201      	movs	r2, #1
 801e3a6:	601a      	str	r2, [r3, #0]
		centuries = 0;
 801e3a8:	2300      	movs	r3, #0
 801e3aa:	63fb      	str	r3, [r7, #60]	; 0x3c
		leaps = 0;
 801e3ac:	2300      	movs	r3, #0
 801e3ae:	643b      	str	r3, [r7, #64]	; 0x40
 801e3b0:	e037      	b.n	801e422 <__year_to_secs+0x17a>
	} else {
		if (rem >= 200) {
 801e3b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e3b4:	2bc7      	cmp	r3, #199	; 0xc7
 801e3b6:	dd10      	ble.n	801e3da <__year_to_secs+0x132>
			if (rem >= 300) centuries = 3, rem -= 300;
 801e3b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e3ba:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 801e3be:	db06      	blt.n	801e3ce <__year_to_secs+0x126>
 801e3c0:	2303      	movs	r3, #3
 801e3c2:	63fb      	str	r3, [r7, #60]	; 0x3c
 801e3c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e3c6:	f5a3 7396 	sub.w	r3, r3, #300	; 0x12c
 801e3ca:	647b      	str	r3, [r7, #68]	; 0x44
 801e3cc:	e010      	b.n	801e3f0 <__year_to_secs+0x148>
			else centuries = 2, rem -= 200;
 801e3ce:	2302      	movs	r3, #2
 801e3d0:	63fb      	str	r3, [r7, #60]	; 0x3c
 801e3d2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e3d4:	3bc8      	subs	r3, #200	; 0xc8
 801e3d6:	647b      	str	r3, [r7, #68]	; 0x44
 801e3d8:	e00a      	b.n	801e3f0 <__year_to_secs+0x148>
		} else {
			if (rem >= 100) centuries = 1, rem -= 100;
 801e3da:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e3dc:	2b63      	cmp	r3, #99	; 0x63
 801e3de:	dd05      	ble.n	801e3ec <__year_to_secs+0x144>
 801e3e0:	2301      	movs	r3, #1
 801e3e2:	63fb      	str	r3, [r7, #60]	; 0x3c
 801e3e4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e3e6:	3b64      	subs	r3, #100	; 0x64
 801e3e8:	647b      	str	r3, [r7, #68]	; 0x44
 801e3ea:	e001      	b.n	801e3f0 <__year_to_secs+0x148>
			else centuries = 0;
 801e3ec:	2300      	movs	r3, #0
 801e3ee:	63fb      	str	r3, [r7, #60]	; 0x3c
		}
		if (!rem) {
 801e3f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e3f2:	2b00      	cmp	r3, #0
 801e3f4:	d105      	bne.n	801e402 <__year_to_secs+0x15a>
			*is_leap = 0;
 801e3f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e3f8:	2200      	movs	r2, #0
 801e3fa:	601a      	str	r2, [r3, #0]
			leaps = 0;
 801e3fc:	2300      	movs	r3, #0
 801e3fe:	643b      	str	r3, [r7, #64]	; 0x40
 801e400:	e00f      	b.n	801e422 <__year_to_secs+0x17a>
		} else {
			leaps = rem / 4U;
 801e402:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e404:	089b      	lsrs	r3, r3, #2
 801e406:	643b      	str	r3, [r7, #64]	; 0x40
			rem %= 4U;
 801e408:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e40a:	f003 0303 	and.w	r3, r3, #3
 801e40e:	647b      	str	r3, [r7, #68]	; 0x44
			*is_leap = !rem;
 801e410:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e412:	2b00      	cmp	r3, #0
 801e414:	bf0c      	ite	eq
 801e416:	2301      	moveq	r3, #1
 801e418:	2300      	movne	r3, #0
 801e41a:	b2db      	uxtb	r3, r3
 801e41c:	461a      	mov	r2, r3
 801e41e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e420:	601a      	str	r2, [r3, #0]
		}
	}

	leaps += 97*cycles + 24*centuries - *is_leap;
 801e422:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801e424:	4613      	mov	r3, r2
 801e426:	005b      	lsls	r3, r3, #1
 801e428:	4413      	add	r3, r2
 801e42a:	015b      	lsls	r3, r3, #5
 801e42c:	1899      	adds	r1, r3, r2
 801e42e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801e430:	4613      	mov	r3, r2
 801e432:	005b      	lsls	r3, r3, #1
 801e434:	4413      	add	r3, r2
 801e436:	00db      	lsls	r3, r3, #3
 801e438:	18ca      	adds	r2, r1, r3
 801e43a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e43c:	681b      	ldr	r3, [r3, #0]
 801e43e:	1ad3      	subs	r3, r2, r3
 801e440:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801e442:	4413      	add	r3, r2
 801e444:	643b      	str	r3, [r7, #64]	; 0x40

	return (year-100) * 31536000LL + leaps * 86400LL + 946684800 + 86400;
 801e446:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e44a:	f1b2 0464 	subs.w	r4, r2, #100	; 0x64
 801e44e:	f143 35ff 	adc.w	r5, r3, #4294967295
 801e452:	4b2e      	ldr	r3, [pc, #184]	; (801e50c <__year_to_secs+0x264>)
 801e454:	fb03 f205 	mul.w	r2, r3, r5
 801e458:	2300      	movs	r3, #0
 801e45a:	fb03 f304 	mul.w	r3, r3, r4
 801e45e:	4413      	add	r3, r2
 801e460:	4a2a      	ldr	r2, [pc, #168]	; (801e50c <__year_to_secs+0x264>)
 801e462:	fba4 4502 	umull	r4, r5, r4, r2
 801e466:	442b      	add	r3, r5
 801e468:	461d      	mov	r5, r3
 801e46a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e46c:	461a      	mov	r2, r3
 801e46e:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801e472:	4610      	mov	r0, r2
 801e474:	4619      	mov	r1, r3
 801e476:	1806      	adds	r6, r0, r0
 801e478:	603e      	str	r6, [r7, #0]
 801e47a:	4149      	adcs	r1, r1
 801e47c:	6079      	str	r1, [r7, #4]
 801e47e:	e9d7 0100 	ldrd	r0, r1, [r7]
 801e482:	1880      	adds	r0, r0, r2
 801e484:	eb43 0101 	adc.w	r1, r3, r1
 801e488:	f04f 0200 	mov.w	r2, #0
 801e48c:	f04f 0300 	mov.w	r3, #0
 801e490:	010b      	lsls	r3, r1, #4
 801e492:	ea43 7310 	orr.w	r3, r3, r0, lsr #28
 801e496:	0102      	lsls	r2, r0, #4
 801e498:	1a12      	subs	r2, r2, r0
 801e49a:	eb63 0301 	sbc.w	r3, r3, r1
 801e49e:	f04f 0000 	mov.w	r0, #0
 801e4a2:	f04f 0100 	mov.w	r1, #0
 801e4a6:	0119      	lsls	r1, r3, #4
 801e4a8:	ea41 7112 	orr.w	r1, r1, r2, lsr #28
 801e4ac:	0110      	lsls	r0, r2, #4
 801e4ae:	1a80      	subs	r0, r0, r2
 801e4b0:	eb61 0103 	sbc.w	r1, r1, r3
 801e4b4:	f04f 0200 	mov.w	r2, #0
 801e4b8:	f04f 0300 	mov.w	r3, #0
 801e4bc:	01cb      	lsls	r3, r1, #7
 801e4be:	ea43 6350 	orr.w	r3, r3, r0, lsr #25
 801e4c2:	01c2      	lsls	r2, r0, #7
 801e4c4:	4610      	mov	r0, r2
 801e4c6:	4619      	mov	r1, r3
 801e4c8:	4602      	mov	r2, r0
 801e4ca:	460b      	mov	r3, r1
 801e4cc:	eb14 0802 	adds.w	r8, r4, r2
 801e4d0:	eb45 0903 	adc.w	r9, r5, r3
 801e4d4:	a30a      	add	r3, pc, #40	; (adr r3, 801e500 <__year_to_secs+0x258>)
 801e4d6:	e9d3 2300 	ldrd	r2, r3, [r3]
 801e4da:	eb18 0a02 	adds.w	sl, r8, r2
 801e4de:	eb49 0b03 	adc.w	fp, r9, r3
 801e4e2:	4652      	mov	r2, sl
 801e4e4:	465b      	mov	r3, fp
}
 801e4e6:	4908      	ldr	r1, [pc, #32]	; (801e508 <__year_to_secs+0x260>)
 801e4e8:	6808      	ldr	r0, [r1, #0]
 801e4ea:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801e4ec:	4048      	eors	r0, r1
 801e4ee:	d001      	beq.n	801e4f4 <__year_to_secs+0x24c>
 801e4f0:	f7e5 ff7a 	bl	80043e8 <__stack_chk_fail>
 801e4f4:	4610      	mov	r0, r2
 801e4f6:	4619      	mov	r1, r3
 801e4f8:	3754      	adds	r7, #84	; 0x54
 801e4fa:	46bd      	mov	sp, r7
 801e4fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801e500:	386e9500 	.word	0x386e9500
 801e504:	00000000 	.word	0x00000000
 801e508:	080231fc 	.word	0x080231fc
 801e50c:	01e13380 	.word	0x01e13380
 801e510:	00015180 	.word	0x00015180

0801e514 <__asctime_r>:
#include <langinfo.h>
#include "locale_impl.h"
#include "atomic.h"

char *__asctime_r(const struct tm *restrict tm, char *restrict buf)
{
 801e514:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e516:	b089      	sub	sp, #36	; 0x24
 801e518:	af06      	add	r7, sp, #24
 801e51a:	6078      	str	r0, [r7, #4]
 801e51c:	6039      	str	r1, [r7, #0]
	if (snprintf(buf, 26, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
		__nl_langinfo_l(ABDAY_1+tm->tm_wday, C_LOCALE),
 801e51e:	687b      	ldr	r3, [r7, #4]
 801e520:	699b      	ldr	r3, [r3, #24]
	if (snprintf(buf, 26, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
 801e522:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 801e526:	491a      	ldr	r1, [pc, #104]	; (801e590 <__asctime_r+0x7c>)
 801e528:	4618      	mov	r0, r3
 801e52a:	f7fc f8e7 	bl	801a6fc <__nl_langinfo_l>
 801e52e:	4606      	mov	r6, r0
		__nl_langinfo_l(ABMON_1+tm->tm_mon, C_LOCALE),
 801e530:	687b      	ldr	r3, [r7, #4]
 801e532:	691a      	ldr	r2, [r3, #16]
	if (snprintf(buf, 26, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
 801e534:	4b17      	ldr	r3, [pc, #92]	; (801e594 <__asctime_r+0x80>)
 801e536:	4413      	add	r3, r2
 801e538:	4915      	ldr	r1, [pc, #84]	; (801e590 <__asctime_r+0x7c>)
 801e53a:	4618      	mov	r0, r3
 801e53c:	f7fc f8de 	bl	801a6fc <__nl_langinfo_l>
 801e540:	4605      	mov	r5, r0
 801e542:	687b      	ldr	r3, [r7, #4]
 801e544:	68db      	ldr	r3, [r3, #12]
 801e546:	687a      	ldr	r2, [r7, #4]
 801e548:	6892      	ldr	r2, [r2, #8]
 801e54a:	6879      	ldr	r1, [r7, #4]
 801e54c:	6849      	ldr	r1, [r1, #4]
 801e54e:	6878      	ldr	r0, [r7, #4]
 801e550:	6800      	ldr	r0, [r0, #0]
		tm->tm_mday, tm->tm_hour,
		tm->tm_min, tm->tm_sec,
		1900 + tm->tm_year) >= 26)
 801e552:	687c      	ldr	r4, [r7, #4]
 801e554:	6964      	ldr	r4, [r4, #20]
	if (snprintf(buf, 26, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
 801e556:	f204 746c 	addw	r4, r4, #1900	; 0x76c
 801e55a:	9405      	str	r4, [sp, #20]
 801e55c:	9004      	str	r0, [sp, #16]
 801e55e:	9103      	str	r1, [sp, #12]
 801e560:	9202      	str	r2, [sp, #8]
 801e562:	9301      	str	r3, [sp, #4]
 801e564:	9500      	str	r5, [sp, #0]
 801e566:	4633      	mov	r3, r6
 801e568:	4a0b      	ldr	r2, [pc, #44]	; (801e598 <__asctime_r+0x84>)
 801e56a:	211a      	movs	r1, #26
 801e56c:	6838      	ldr	r0, [r7, #0]
 801e56e:	f7fc f95b 	bl	801a828 <snprintf>
 801e572:	4603      	mov	r3, r0
 801e574:	2b19      	cmp	r3, #25
 801e576:	dd06      	ble.n	801e586 <__asctime_r+0x72>
		 * on other implementations (e.g. stack smashing..).
		 */
#ifndef __LITEOS__
		a_crash();
#else
		errno = EOVERFLOW;
 801e578:	f7f0 ffac 	bl	800f4d4 <__errno_location>
 801e57c:	4603      	mov	r3, r0
 801e57e:	224b      	movs	r2, #75	; 0x4b
 801e580:	601a      	str	r2, [r3, #0]
		return NULL;
 801e582:	2300      	movs	r3, #0
 801e584:	e000      	b.n	801e588 <__asctime_r+0x74>
#endif
	}
	return buf;
 801e586:	683b      	ldr	r3, [r7, #0]
}
 801e588:	4618      	mov	r0, r3
 801e58a:	370c      	adds	r7, #12
 801e58c:	46bd      	mov	sp, r7
 801e58e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e590:	080242fc 	.word	0x080242fc
 801e594:	0002000e 	.word	0x0002000e
 801e598:	08023200 	.word	0x08023200

0801e59c <tolower>:
#include <ctype.h>

int tolower(int c)
{
 801e59c:	b480      	push	{r7}
 801e59e:	b083      	sub	sp, #12
 801e5a0:	af00      	add	r7, sp, #0
 801e5a2:	6078      	str	r0, [r7, #4]
	if (isupper(c)) return c | 32;
 801e5a4:	687b      	ldr	r3, [r7, #4]
 801e5a6:	3b41      	subs	r3, #65	; 0x41
 801e5a8:	2b19      	cmp	r3, #25
 801e5aa:	d803      	bhi.n	801e5b4 <tolower+0x18>
 801e5ac:	687b      	ldr	r3, [r7, #4]
 801e5ae:	f043 0320 	orr.w	r3, r3, #32
 801e5b2:	e000      	b.n	801e5b6 <tolower+0x1a>
	return c;
 801e5b4:	687b      	ldr	r3, [r7, #4]
}
 801e5b6:	4618      	mov	r0, r3
 801e5b8:	370c      	adds	r7, #12
 801e5ba:	46bd      	mov	sp, r7
 801e5bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e5c0:	4770      	bx	lr

0801e5c2 <StringToDigital>:
    }
    return TRUE;
}

STATIC INLINE INT32 StringToDigital(CHAR high, CHAR low)
{
 801e5c2:	b480      	push	{r7}
 801e5c4:	b083      	sub	sp, #12
 801e5c6:	af00      	add	r7, sp, #0
 801e5c8:	4603      	mov	r3, r0
 801e5ca:	460a      	mov	r2, r1
 801e5cc:	71fb      	strb	r3, [r7, #7]
 801e5ce:	4613      	mov	r3, r2
 801e5d0:	71bb      	strb	r3, [r7, #6]
    /* 10: decimal base number */
    return ((high - '0') * 10) + (low - '0');
 801e5d2:	79fb      	ldrb	r3, [r7, #7]
 801e5d4:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 801e5d8:	4613      	mov	r3, r2
 801e5da:	009b      	lsls	r3, r3, #2
 801e5dc:	4413      	add	r3, r2
 801e5de:	005b      	lsls	r3, r3, #1
 801e5e0:	461a      	mov	r2, r3
 801e5e2:	79bb      	ldrb	r3, [r7, #6]
 801e5e4:	3b30      	subs	r3, #48	; 0x30
 801e5e6:	4413      	add	r3, r2
}
 801e5e8:	4618      	mov	r0, r3
 801e5ea:	370c      	adds	r7, #12
 801e5ec:	46bd      	mov	sp, r7
 801e5ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e5f2:	4770      	bx	lr

0801e5f4 <DstForwardSecondGet>:
INT32 g_dstForwardSeconds = 0;
STATIC CHAR g_strDstStart[DST_SET_LENGTH_MAX] = {0};
STATIC CHAR g_strDstEnd[DST_SET_LENGTH_MAX] = {0};

INT32 DstForwardSecondGet(VOID)
{
 801e5f4:	b480      	push	{r7}
 801e5f6:	af00      	add	r7, sp, #0
    return g_dstForwardSeconds;
 801e5f8:	4b03      	ldr	r3, [pc, #12]	; (801e608 <DstForwardSecondGet+0x14>)
 801e5fa:	681b      	ldr	r3, [r3, #0]
}
 801e5fc:	4618      	mov	r0, r3
 801e5fe:	46bd      	mov	sp, r7
 801e600:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e604:	4770      	bx	lr
 801e606:	bf00      	nop
 801e608:	2000345c 	.word	0x2000345c

0801e60c <GetMonthFromString>:

STATIC INT32 GetMonthFromString(const CHAR *strMonth)
{
 801e60c:	b580      	push	{r7, lr}
 801e60e:	b084      	sub	sp, #16
 801e610:	af00      	add	r7, sp, #0
 801e612:	6078      	str	r0, [r7, #4]
    UINT32 index;
    for (index = 0; index < sizeof(g_strMonth) / sizeof(CHAR *); index++) {
 801e614:	2300      	movs	r3, #0
 801e616:	60fb      	str	r3, [r7, #12]
 801e618:	e010      	b.n	801e63c <GetMonthFromString+0x30>
        if (strncmp(strMonth, g_strMonth[index], MONTH_NAME_LEN) == 0) {
 801e61a:	4a0d      	ldr	r2, [pc, #52]	; (801e650 <GetMonthFromString+0x44>)
 801e61c:	68fb      	ldr	r3, [r7, #12]
 801e61e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e622:	2203      	movs	r2, #3
 801e624:	4619      	mov	r1, r3
 801e626:	6878      	ldr	r0, [r7, #4]
 801e628:	f7fa fefe 	bl	8019428 <strncmp>
 801e62c:	4603      	mov	r3, r0
 801e62e:	2b00      	cmp	r3, #0
 801e630:	d101      	bne.n	801e636 <GetMonthFromString+0x2a>
            /* A legal month is from 0 to 11. */
            return (int)index;
 801e632:	68fb      	ldr	r3, [r7, #12]
 801e634:	e007      	b.n	801e646 <GetMonthFromString+0x3a>
    for (index = 0; index < sizeof(g_strMonth) / sizeof(CHAR *); index++) {
 801e636:	68fb      	ldr	r3, [r7, #12]
 801e638:	3301      	adds	r3, #1
 801e63a:	60fb      	str	r3, [r7, #12]
 801e63c:	68fb      	ldr	r3, [r7, #12]
 801e63e:	2b0b      	cmp	r3, #11
 801e640:	d9eb      	bls.n	801e61a <GetMonthFromString+0xe>
        }
    }

    return -1;
 801e642:	f04f 33ff 	mov.w	r3, #4294967295
}
 801e646:	4618      	mov	r0, r3
 801e648:	3710      	adds	r7, #16
 801e64a:	46bd      	mov	sp, r7
 801e64c:	bd80      	pop	{r7, pc}
 801e64e:	bf00      	nop
 801e650:	20000574 	.word	0x20000574

0801e654 <GetWeekDayFromString>:

STATIC INT32 GetWeekDayFromString(const CHAR *strWeekDay)
{
 801e654:	b580      	push	{r7, lr}
 801e656:	b084      	sub	sp, #16
 801e658:	af00      	add	r7, sp, #0
 801e65a:	6078      	str	r0, [r7, #4]
    UINT32 index;
    for (index = 0; index < sizeof(g_strWeekDay) / sizeof(CHAR *); index++) {
 801e65c:	2300      	movs	r3, #0
 801e65e:	60fb      	str	r3, [r7, #12]
 801e660:	e010      	b.n	801e684 <GetWeekDayFromString+0x30>
        if (strncmp(strWeekDay, g_strWeekDay[index], MONTH_NAME_LEN) == 0) {
 801e662:	4a0d      	ldr	r2, [pc, #52]	; (801e698 <GetWeekDayFromString+0x44>)
 801e664:	68fb      	ldr	r3, [r7, #12]
 801e666:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e66a:	2203      	movs	r2, #3
 801e66c:	4619      	mov	r1, r3
 801e66e:	6878      	ldr	r0, [r7, #4]
 801e670:	f7fa feda 	bl	8019428 <strncmp>
 801e674:	4603      	mov	r3, r0
 801e676:	2b00      	cmp	r3, #0
 801e678:	d101      	bne.n	801e67e <GetWeekDayFromString+0x2a>
            /* Day of the week (0-6, Sunday = 0) */
            return (INT32)index;
 801e67a:	68fb      	ldr	r3, [r7, #12]
 801e67c:	e007      	b.n	801e68e <GetWeekDayFromString+0x3a>
    for (index = 0; index < sizeof(g_strWeekDay) / sizeof(CHAR *); index++) {
 801e67e:	68fb      	ldr	r3, [r7, #12]
 801e680:	3301      	adds	r3, #1
 801e682:	60fb      	str	r3, [r7, #12]
 801e684:	68fb      	ldr	r3, [r7, #12]
 801e686:	2b06      	cmp	r3, #6
 801e688:	d9eb      	bls.n	801e662 <GetWeekDayFromString+0xe>
        }
    }

    return -1;
 801e68a:	f04f 33ff 	mov.w	r3, #4294967295
}
 801e68e:	4618      	mov	r0, r3
 801e690:	3710      	adds	r7, #16
 801e692:	46bd      	mov	sp, r7
 801e694:	bd80      	pop	{r7, pc}
 801e696:	bf00      	nop
 801e698:	200005b8 	.word	0x200005b8

0801e69c <GetMonthWeekFromString>:

STATIC INT32 GetMonthWeekFromString(const CHAR *strMonthWeek)
{
 801e69c:	b580      	push	{r7, lr}
 801e69e:	b084      	sub	sp, #16
 801e6a0:	af00      	add	r7, sp, #0
 801e6a2:	6078      	str	r0, [r7, #4]
    UINT32 index;
    for (index = 0; index < sizeof(g_strMonthWeek) / sizeof(CHAR *); index++) {
 801e6a4:	2300      	movs	r3, #0
 801e6a6:	60fb      	str	r3, [r7, #12]
 801e6a8:	e011      	b.n	801e6ce <GetMonthWeekFromString+0x32>
        if (strncmp(strMonthWeek, g_strMonthWeek[index], MONTH_NAME_LEN) == 0) {
 801e6aa:	4a0d      	ldr	r2, [pc, #52]	; (801e6e0 <GetMonthWeekFromString+0x44>)
 801e6ac:	68fb      	ldr	r3, [r7, #12]
 801e6ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e6b2:	2203      	movs	r2, #3
 801e6b4:	4619      	mov	r1, r3
 801e6b6:	6878      	ldr	r0, [r7, #4]
 801e6b8:	f7fa feb6 	bl	8019428 <strncmp>
 801e6bc:	4603      	mov	r3, r0
 801e6be:	2b00      	cmp	r3, #0
 801e6c0:	d102      	bne.n	801e6c8 <GetMonthWeekFromString+0x2c>
            /* Month of the week (1-5) */
            return (INT32)(index + 1);
 801e6c2:	68fb      	ldr	r3, [r7, #12]
 801e6c4:	3301      	adds	r3, #1
 801e6c6:	e007      	b.n	801e6d8 <GetMonthWeekFromString+0x3c>
    for (index = 0; index < sizeof(g_strMonthWeek) / sizeof(CHAR *); index++) {
 801e6c8:	68fb      	ldr	r3, [r7, #12]
 801e6ca:	3301      	adds	r3, #1
 801e6cc:	60fb      	str	r3, [r7, #12]
 801e6ce:	68fb      	ldr	r3, [r7, #12]
 801e6d0:	2b04      	cmp	r3, #4
 801e6d2:	d9ea      	bls.n	801e6aa <GetMonthWeekFromString+0xe>
        }
    }

    return -1;
 801e6d4:	f04f 33ff 	mov.w	r3, #4294967295
}
 801e6d8:	4618      	mov	r0, r3
 801e6da:	3710      	adds	r7, #16
 801e6dc:	46bd      	mov	sp, r7
 801e6de:	bd80      	pop	{r7, pc}
 801e6e0:	200005a4 	.word	0x200005a4

0801e6e4 <CheckTimeVaild>:

STATIC INLINE INT32 CheckTimeVaild(const CHAR *strTimeString)
{
 801e6e4:	b480      	push	{r7}
 801e6e6:	b083      	sub	sp, #12
 801e6e8:	af00      	add	r7, sp, #0
 801e6ea:	6078      	str	r0, [r7, #4]
    if (((strTimeString[0] < '0') || (strTimeString[0] > '9')) ||
 801e6ec:	687b      	ldr	r3, [r7, #4]
 801e6ee:	781b      	ldrb	r3, [r3, #0]
 801e6f0:	2b2f      	cmp	r3, #47	; 0x2f
 801e6f2:	d90d      	bls.n	801e710 <CheckTimeVaild+0x2c>
 801e6f4:	687b      	ldr	r3, [r7, #4]
 801e6f6:	781b      	ldrb	r3, [r3, #0]
 801e6f8:	2b39      	cmp	r3, #57	; 0x39
 801e6fa:	d809      	bhi.n	801e710 <CheckTimeVaild+0x2c>
        ((strTimeString[1] < '0') || (strTimeString[1] > '9'))) {
 801e6fc:	687b      	ldr	r3, [r7, #4]
 801e6fe:	3301      	adds	r3, #1
 801e700:	781b      	ldrb	r3, [r3, #0]
    if (((strTimeString[0] < '0') || (strTimeString[0] > '9')) ||
 801e702:	2b2f      	cmp	r3, #47	; 0x2f
 801e704:	d904      	bls.n	801e710 <CheckTimeVaild+0x2c>
        ((strTimeString[1] < '0') || (strTimeString[1] > '9'))) {
 801e706:	687b      	ldr	r3, [r7, #4]
 801e708:	3301      	adds	r3, #1
 801e70a:	781b      	ldrb	r3, [r3, #0]
 801e70c:	2b39      	cmp	r3, #57	; 0x39
 801e70e:	d902      	bls.n	801e716 <CheckTimeVaild+0x32>
        return -1;
 801e710:	f04f 33ff 	mov.w	r3, #4294967295
 801e714:	e000      	b.n	801e718 <CheckTimeVaild+0x34>
    }
    return 0;
 801e716:	2300      	movs	r3, #0
}
 801e718:	4618      	mov	r0, r3
 801e71a:	370c      	adds	r7, #12
 801e71c:	46bd      	mov	sp, r7
 801e71e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e722:	4770      	bx	lr

0801e724 <GetMonthDayFromString>:

/* Day of the month 1 ~ 31 */
STATIC INT32 GetMonthDayFromString(INT32 month, const CHAR *strMonDay)
{
 801e724:	b580      	push	{r7, lr}
 801e726:	b084      	sub	sp, #16
 801e728:	af00      	add	r7, sp, #0
 801e72a:	6078      	str	r0, [r7, #4]
 801e72c:	6039      	str	r1, [r7, #0]
    INT32 monDay;

    if (CheckTimeVaild(strMonDay)) {
 801e72e:	6838      	ldr	r0, [r7, #0]
 801e730:	f7ff ffd8 	bl	801e6e4 <CheckTimeVaild>
 801e734:	4603      	mov	r3, r0
 801e736:	2b00      	cmp	r3, #0
 801e738:	d002      	beq.n	801e740 <GetMonthDayFromString+0x1c>
        return -1;
 801e73a:	f04f 33ff 	mov.w	r3, #4294967295
 801e73e:	e023      	b.n	801e788 <GetMonthDayFromString+0x64>
    }

    monDay = StringToDigital(strMonDay[0], strMonDay[1]);
 801e740:	683b      	ldr	r3, [r7, #0]
 801e742:	781a      	ldrb	r2, [r3, #0]
 801e744:	683b      	ldr	r3, [r7, #0]
 801e746:	3301      	adds	r3, #1
 801e748:	781b      	ldrb	r3, [r3, #0]
 801e74a:	4619      	mov	r1, r3
 801e74c:	4610      	mov	r0, r2
 801e74e:	f7ff ff38 	bl	801e5c2 <StringToDigital>
 801e752:	60f8      	str	r0, [r7, #12]
    if (monDay > 31) {
 801e754:	68fb      	ldr	r3, [r7, #12]
 801e756:	2b1f      	cmp	r3, #31
 801e758:	dd02      	ble.n	801e760 <GetMonthDayFromString+0x3c>
        return -1;
 801e75a:	f04f 33ff 	mov.w	r3, #4294967295
 801e75e:	e013      	b.n	801e788 <GetMonthDayFromString+0x64>
    }

    /* Not every year have 29 days in Feb when set DST. */
    if ((monDay == 29) && ((month + 1) == 2)) {
 801e760:	68fb      	ldr	r3, [r7, #12]
 801e762:	2b1d      	cmp	r3, #29
 801e764:	d105      	bne.n	801e772 <GetMonthDayFromString+0x4e>
 801e766:	687b      	ldr	r3, [r7, #4]
 801e768:	2b01      	cmp	r3, #1
 801e76a:	d102      	bne.n	801e772 <GetMonthDayFromString+0x4e>
        return -1;
 801e76c:	f04f 33ff 	mov.w	r3, #4294967295
 801e770:	e00a      	b.n	801e788 <GetMonthDayFromString+0x64>
    }

    if (monDay > g_monLengths[0][month]) {
 801e772:	4a07      	ldr	r2, [pc, #28]	; (801e790 <GetMonthDayFromString+0x6c>)
 801e774:	687b      	ldr	r3, [r7, #4]
 801e776:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e77a:	68fa      	ldr	r2, [r7, #12]
 801e77c:	429a      	cmp	r2, r3
 801e77e:	dd02      	ble.n	801e786 <GetMonthDayFromString+0x62>
        return -1;
 801e780:	f04f 33ff 	mov.w	r3, #4294967295
 801e784:	e000      	b.n	801e788 <GetMonthDayFromString+0x64>
    }

    /* Day of the month (1-31) */
    return monDay;
 801e786:	68fb      	ldr	r3, [r7, #12]
}
 801e788:	4618      	mov	r0, r3
 801e78a:	3710      	adds	r7, #16
 801e78c:	46bd      	mov	sp, r7
 801e78e:	bd80      	pop	{r7, pc}
 801e790:	08024314 	.word	0x08024314

0801e794 <GetDaySecondsFromString>:
 * 0~23 for hours per day
 * 0~59 for minutes per hour
 * 0~59 for seconds per minute
 */
STATIC INT32 GetDaySecondsFromString(const CHAR *strTimeString)
{
 801e794:	b580      	push	{r7, lr}
 801e796:	b086      	sub	sp, #24
 801e798:	af00      	add	r7, sp, #0
 801e79a:	6078      	str	r0, [r7, #4]
    INT32 hour, min, sec;

    if (CheckTimeVaild(strTimeString)) {
 801e79c:	6878      	ldr	r0, [r7, #4]
 801e79e:	f7ff ffa1 	bl	801e6e4 <CheckTimeVaild>
 801e7a2:	4603      	mov	r3, r0
 801e7a4:	2b00      	cmp	r3, #0
 801e7a6:	d002      	beq.n	801e7ae <GetDaySecondsFromString+0x1a>
        return -1;
 801e7a8:	f04f 33ff 	mov.w	r3, #4294967295
 801e7ac:	e06a      	b.n	801e884 <GetDaySecondsFromString+0xf0>
    }

    if (CheckTimeVaild(strTimeString + 3)) {
 801e7ae:	687b      	ldr	r3, [r7, #4]
 801e7b0:	3303      	adds	r3, #3
 801e7b2:	4618      	mov	r0, r3
 801e7b4:	f7ff ff96 	bl	801e6e4 <CheckTimeVaild>
 801e7b8:	4603      	mov	r3, r0
 801e7ba:	2b00      	cmp	r3, #0
 801e7bc:	d002      	beq.n	801e7c4 <GetDaySecondsFromString+0x30>
        return -1;
 801e7be:	f04f 33ff 	mov.w	r3, #4294967295
 801e7c2:	e05f      	b.n	801e884 <GetDaySecondsFromString+0xf0>
    }

    if (CheckTimeVaild(strTimeString + 6)) {
 801e7c4:	687b      	ldr	r3, [r7, #4]
 801e7c6:	3306      	adds	r3, #6
 801e7c8:	4618      	mov	r0, r3
 801e7ca:	f7ff ff8b 	bl	801e6e4 <CheckTimeVaild>
 801e7ce:	4603      	mov	r3, r0
 801e7d0:	2b00      	cmp	r3, #0
 801e7d2:	d002      	beq.n	801e7da <GetDaySecondsFromString+0x46>
        return -1;
 801e7d4:	f04f 33ff 	mov.w	r3, #4294967295
 801e7d8:	e054      	b.n	801e884 <GetDaySecondsFromString+0xf0>
    }

    if ((strTimeString[2] != ':') || (strTimeString[5] != ':')) {
 801e7da:	687b      	ldr	r3, [r7, #4]
 801e7dc:	3302      	adds	r3, #2
 801e7de:	781b      	ldrb	r3, [r3, #0]
 801e7e0:	2b3a      	cmp	r3, #58	; 0x3a
 801e7e2:	d104      	bne.n	801e7ee <GetDaySecondsFromString+0x5a>
 801e7e4:	687b      	ldr	r3, [r7, #4]
 801e7e6:	3305      	adds	r3, #5
 801e7e8:	781b      	ldrb	r3, [r3, #0]
 801e7ea:	2b3a      	cmp	r3, #58	; 0x3a
 801e7ec:	d002      	beq.n	801e7f4 <GetDaySecondsFromString+0x60>
        return -1;
 801e7ee:	f04f 33ff 	mov.w	r3, #4294967295
 801e7f2:	e047      	b.n	801e884 <GetDaySecondsFromString+0xf0>
    }

    hour = StringToDigital(strTimeString[0], strTimeString[1]);
 801e7f4:	687b      	ldr	r3, [r7, #4]
 801e7f6:	781a      	ldrb	r2, [r3, #0]
 801e7f8:	687b      	ldr	r3, [r7, #4]
 801e7fa:	3301      	adds	r3, #1
 801e7fc:	781b      	ldrb	r3, [r3, #0]
 801e7fe:	4619      	mov	r1, r3
 801e800:	4610      	mov	r0, r2
 801e802:	f7ff fede 	bl	801e5c2 <StringToDigital>
 801e806:	60f8      	str	r0, [r7, #12]
    min = StringToDigital(strTimeString[3], strTimeString[4]);
 801e808:	687b      	ldr	r3, [r7, #4]
 801e80a:	3303      	adds	r3, #3
 801e80c:	781a      	ldrb	r2, [r3, #0]
 801e80e:	687b      	ldr	r3, [r7, #4]
 801e810:	3304      	adds	r3, #4
 801e812:	781b      	ldrb	r3, [r3, #0]
 801e814:	4619      	mov	r1, r3
 801e816:	4610      	mov	r0, r2
 801e818:	f7ff fed3 	bl	801e5c2 <StringToDigital>
 801e81c:	6138      	str	r0, [r7, #16]
    sec = StringToDigital(strTimeString[6], strTimeString[7]);
 801e81e:	687b      	ldr	r3, [r7, #4]
 801e820:	3306      	adds	r3, #6
 801e822:	781a      	ldrb	r2, [r3, #0]
 801e824:	687b      	ldr	r3, [r7, #4]
 801e826:	3307      	adds	r3, #7
 801e828:	781b      	ldrb	r3, [r3, #0]
 801e82a:	4619      	mov	r1, r3
 801e82c:	4610      	mov	r0, r2
 801e82e:	f7ff fec8 	bl	801e5c2 <StringToDigital>
 801e832:	6178      	str	r0, [r7, #20]
    /* Hours (0-23) */
    if ((hour < 0) || (hour > 23)) {
 801e834:	68fb      	ldr	r3, [r7, #12]
 801e836:	2b00      	cmp	r3, #0
 801e838:	db02      	blt.n	801e840 <GetDaySecondsFromString+0xac>
 801e83a:	68fb      	ldr	r3, [r7, #12]
 801e83c:	2b17      	cmp	r3, #23
 801e83e:	dd02      	ble.n	801e846 <GetDaySecondsFromString+0xb2>
        return -1;
 801e840:	f04f 33ff 	mov.w	r3, #4294967295
 801e844:	e01e      	b.n	801e884 <GetDaySecondsFromString+0xf0>
    }

    /* Minutes (0-59) */
    if ((min < 0) || (min > 59)) {
 801e846:	693b      	ldr	r3, [r7, #16]
 801e848:	2b00      	cmp	r3, #0
 801e84a:	db02      	blt.n	801e852 <GetDaySecondsFromString+0xbe>
 801e84c:	693b      	ldr	r3, [r7, #16]
 801e84e:	2b3b      	cmp	r3, #59	; 0x3b
 801e850:	dd02      	ble.n	801e858 <GetDaySecondsFromString+0xc4>
        return -1;
 801e852:	f04f 33ff 	mov.w	r3, #4294967295
 801e856:	e015      	b.n	801e884 <GetDaySecondsFromString+0xf0>
    }

    /* Seconds (0-59), not consider of the leap seconds in DST. */
    if ((sec < 0) || (sec > 59)) {
 801e858:	697b      	ldr	r3, [r7, #20]
 801e85a:	2b00      	cmp	r3, #0
 801e85c:	db02      	blt.n	801e864 <GetDaySecondsFromString+0xd0>
 801e85e:	697b      	ldr	r3, [r7, #20]
 801e860:	2b3b      	cmp	r3, #59	; 0x3b
 801e862:	dd02      	ble.n	801e86a <GetDaySecondsFromString+0xd6>
        return -1;
 801e864:	f04f 33ff 	mov.w	r3, #4294967295
 801e868:	e00c      	b.n	801e884 <GetDaySecondsFromString+0xf0>
    }

    return hour * 3600 + min * 60 + sec;
 801e86a:	68fb      	ldr	r3, [r7, #12]
 801e86c:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 801e870:	fb02 f103 	mul.w	r1, r2, r3
 801e874:	693a      	ldr	r2, [r7, #16]
 801e876:	4613      	mov	r3, r2
 801e878:	011b      	lsls	r3, r3, #4
 801e87a:	1a9b      	subs	r3, r3, r2
 801e87c:	009b      	lsls	r3, r3, #2
 801e87e:	18ca      	adds	r2, r1, r3
 801e880:	697b      	ldr	r3, [r7, #20]
 801e882:	4413      	add	r3, r2
}
 801e884:	4618      	mov	r0, r3
 801e886:	3718      	adds	r7, #24
 801e888:	46bd      	mov	sp, r7
 801e88a:	bd80      	pop	{r7, pc}

0801e88c <DstGetDayOfMonth>:

STATIC INT32 DstGetDayOfMonth(INT32 year, INT32 month, INT32 mweek, INT32 wday)
{
 801e88c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801e890:	b098      	sub	sp, #96	; 0x60
 801e892:	af00      	add	r7, sp, #0
 801e894:	60f8      	str	r0, [r7, #12]
 801e896:	60b9      	str	r1, [r7, #8]
 801e898:	607a      	str	r2, [r7, #4]
 801e89a:	603b      	str	r3, [r7, #0]
 801e89c:	4b64      	ldr	r3, [pc, #400]	; (801ea30 <DstGetDayOfMonth+0x1a4>)
 801e89e:	681b      	ldr	r3, [r3, #0]
 801e8a0:	65fb      	str	r3, [r7, #92]	; 0x5c
 801e8a2:	f04f 0300 	mov.w	r3, #0
#define FIRST_DAY 4   /* the first day of 1970.1.1 is Thursday. */
    INT32 firstWeekDay; /* First week day in this month of the specified year. */
    INT32 firstMdayOfTargetWday; /* First target month day in this month of the specified year. */
    INT32 targetMdayOfTargetWday; /* The target month day specified by user. */
    struct tm time = {0};
 801e8a6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801e8aa:	222c      	movs	r2, #44	; 0x2c
 801e8ac:	2100      	movs	r1, #0
 801e8ae:	4618      	mov	r0, r3
 801e8b0:	f7ef ffc8 	bl	800e844 <memset>
    INT64 seconds, days;

    time.tm_year = year;
 801e8b4:	68fb      	ldr	r3, [r7, #12]
 801e8b6:	647b      	str	r3, [r7, #68]	; 0x44
    time.tm_mon = month;
 801e8b8:	68bb      	ldr	r3, [r7, #8]
 801e8ba:	643b      	str	r3, [r7, #64]	; 0x40
    time.tm_mday = 1;
 801e8bc:	2301      	movs	r3, #1
 801e8be:	63fb      	str	r3, [r7, #60]	; 0x3c
    /* 14: Hour-value range is [0,23] */
    time.tm_hour = 14;
 801e8c0:	230e      	movs	r3, #14
 801e8c2:	63bb      	str	r3, [r7, #56]	; 0x38
    time.tm_isdst = 0;
 801e8c4:	2300      	movs	r3, #0
 801e8c6:	653b      	str	r3, [r7, #80]	; 0x50
#ifdef LOSCFG_AARCH64
    seconds = mktime(&time);
#else
    seconds = mktime64(&time);
 801e8c8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801e8cc:	4618      	mov	r0, r3
 801e8ce:	f7ff f8df 	bl	801da90 <mktime64>
 801e8d2:	e9c7 0108 	strd	r0, r1, [r7, #32]
#endif
    if (seconds == -1) {
 801e8d6:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801e8da:	f1b3 3fff 	cmp.w	r3, #4294967295
 801e8de:	bf08      	it	eq
 801e8e0:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 801e8e4:	d102      	bne.n	801e8ec <DstGetDayOfMonth+0x60>
        return -1;
 801e8e6:	f04f 33ff 	mov.w	r3, #4294967295
 801e8ea:	e095      	b.n	801ea18 <DstGetDayOfMonth+0x18c>
    }
    days = seconds / SECSPERDAY;
 801e8ec:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801e8f0:	4a50      	ldr	r2, [pc, #320]	; (801ea34 <DstGetDayOfMonth+0x1a8>)
 801e8f2:	f04f 0300 	mov.w	r3, #0
 801e8f6:	f7e2 fbe9 	bl	80010cc <__aeabi_ldivmod>
 801e8fa:	4602      	mov	r2, r0
 801e8fc:	460b      	mov	r3, r1
 801e8fe:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
    if (days < 0) {
 801e902:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e906:	2a00      	cmp	r2, #0
 801e908:	f173 0300 	sbcs.w	r3, r3, #0
 801e90c:	da19      	bge.n	801e942 <DstGetDayOfMonth+0xb6>
        days = -days;
 801e90e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e912:	4252      	negs	r2, r2
 801e914:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 801e918:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
        firstWeekDay = DAYSPERWEEK - (days - (DAYSPERWEEK - FIRST_DAY)) % DAYSPERWEEK;
 801e91c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e920:	f1b2 0803 	subs.w	r8, r2, #3
 801e924:	f143 39ff 	adc.w	r9, r3, #4294967295
 801e928:	f04f 0207 	mov.w	r2, #7
 801e92c:	f04f 0300 	mov.w	r3, #0
 801e930:	4640      	mov	r0, r8
 801e932:	4649      	mov	r1, r9
 801e934:	f7e2 fbca 	bl	80010cc <__aeabi_ldivmod>
 801e938:	4613      	mov	r3, r2
 801e93a:	f1c3 0307 	rsb	r3, r3, #7
 801e93e:	617b      	str	r3, [r7, #20]
 801e940:	e018      	b.n	801e974 <DstGetDayOfMonth+0xe8>
    } else {
        if (days > FIRST_DAY) {
 801e942:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e946:	2a05      	cmp	r2, #5
 801e948:	f173 0300 	sbcs.w	r3, r3, #0
 801e94c:	db10      	blt.n	801e970 <DstGetDayOfMonth+0xe4>
            firstWeekDay = 1 + (days - FIRST_DAY) % DAYSPERWEEK;
 801e94e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e952:	1f14      	subs	r4, r2, #4
 801e954:	f143 35ff 	adc.w	r5, r3, #4294967295
 801e958:	f04f 0207 	mov.w	r2, #7
 801e95c:	f04f 0300 	mov.w	r3, #0
 801e960:	4620      	mov	r0, r4
 801e962:	4629      	mov	r1, r5
 801e964:	f7e2 fbb2 	bl	80010cc <__aeabi_ldivmod>
 801e968:	4613      	mov	r3, r2
 801e96a:	3301      	adds	r3, #1
 801e96c:	617b      	str	r3, [r7, #20]
 801e96e:	e001      	b.n	801e974 <DstGetDayOfMonth+0xe8>
        } else {
            firstWeekDay = FIRST_DAY;
 801e970:	2304      	movs	r3, #4
 801e972:	617b      	str	r3, [r7, #20]
        }
    }

    firstMdayOfTargetWday = 1 + (DAYSPERWEEK + wday - firstWeekDay) % DAYSPERWEEK;
 801e974:	683b      	ldr	r3, [r7, #0]
 801e976:	1dda      	adds	r2, r3, #7
 801e978:	697b      	ldr	r3, [r7, #20]
 801e97a:	1ad2      	subs	r2, r2, r3
 801e97c:	4b2e      	ldr	r3, [pc, #184]	; (801ea38 <DstGetDayOfMonth+0x1ac>)
 801e97e:	fb83 1302 	smull	r1, r3, r3, r2
 801e982:	4413      	add	r3, r2
 801e984:	1099      	asrs	r1, r3, #2
 801e986:	17d3      	asrs	r3, r2, #31
 801e988:	1ac9      	subs	r1, r1, r3
 801e98a:	460b      	mov	r3, r1
 801e98c:	00db      	lsls	r3, r3, #3
 801e98e:	1a5b      	subs	r3, r3, r1
 801e990:	1ad1      	subs	r1, r2, r3
 801e992:	1c4b      	adds	r3, r1, #1
 801e994:	61fb      	str	r3, [r7, #28]
    /*
     * Users may use 5th weekday to represent the last week of this month
     * for example "Oct-5th-Fri", but there does not exist the 5th Friday in October, so the last monweek is 4th.
     */
    targetMdayOfTargetWday = firstMdayOfTargetWday + (mweek - 1) * DAYSPERWEEK;
 801e996:	687b      	ldr	r3, [r7, #4]
 801e998:	1e5a      	subs	r2, r3, #1
 801e99a:	4613      	mov	r3, r2
 801e99c:	00db      	lsls	r3, r3, #3
 801e99e:	1a9b      	subs	r3, r3, r2
 801e9a0:	69fa      	ldr	r2, [r7, #28]
 801e9a2:	4413      	add	r3, r2
 801e9a4:	61bb      	str	r3, [r7, #24]
    if (targetMdayOfTargetWday > g_monLengths[(INT32)isleap(year + TM_YEAR_BASE)][month]) {
 801e9a6:	68fb      	ldr	r3, [r7, #12]
 801e9a8:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 801e9ac:	f003 0303 	and.w	r3, r3, #3
 801e9b0:	2b00      	cmp	r3, #0
 801e9b2:	d120      	bne.n	801e9f6 <DstGetDayOfMonth+0x16a>
 801e9b4:	68fb      	ldr	r3, [r7, #12]
 801e9b6:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 801e9ba:	4b20      	ldr	r3, [pc, #128]	; (801ea3c <DstGetDayOfMonth+0x1b0>)
 801e9bc:	fb83 1302 	smull	r1, r3, r3, r2
 801e9c0:	1159      	asrs	r1, r3, #5
 801e9c2:	17d3      	asrs	r3, r2, #31
 801e9c4:	1acb      	subs	r3, r1, r3
 801e9c6:	2164      	movs	r1, #100	; 0x64
 801e9c8:	fb01 f303 	mul.w	r3, r1, r3
 801e9cc:	1ad3      	subs	r3, r2, r3
 801e9ce:	2b00      	cmp	r3, #0
 801e9d0:	d10f      	bne.n	801e9f2 <DstGetDayOfMonth+0x166>
 801e9d2:	68fb      	ldr	r3, [r7, #12]
 801e9d4:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 801e9d8:	4b18      	ldr	r3, [pc, #96]	; (801ea3c <DstGetDayOfMonth+0x1b0>)
 801e9da:	fb83 1302 	smull	r1, r3, r3, r2
 801e9de:	11d9      	asrs	r1, r3, #7
 801e9e0:	17d3      	asrs	r3, r2, #31
 801e9e2:	1acb      	subs	r3, r1, r3
 801e9e4:	f44f 71c8 	mov.w	r1, #400	; 0x190
 801e9e8:	fb01 f303 	mul.w	r3, r1, r3
 801e9ec:	1ad3      	subs	r3, r2, r3
 801e9ee:	2b00      	cmp	r3, #0
 801e9f0:	d101      	bne.n	801e9f6 <DstGetDayOfMonth+0x16a>
 801e9f2:	2201      	movs	r2, #1
 801e9f4:	e000      	b.n	801e9f8 <DstGetDayOfMonth+0x16c>
 801e9f6:	2200      	movs	r2, #0
 801e9f8:	4911      	ldr	r1, [pc, #68]	; (801ea40 <DstGetDayOfMonth+0x1b4>)
 801e9fa:	4613      	mov	r3, r2
 801e9fc:	005b      	lsls	r3, r3, #1
 801e9fe:	4413      	add	r3, r2
 801ea00:	009b      	lsls	r3, r3, #2
 801ea02:	68ba      	ldr	r2, [r7, #8]
 801ea04:	4413      	add	r3, r2
 801ea06:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801ea0a:	69ba      	ldr	r2, [r7, #24]
 801ea0c:	429a      	cmp	r2, r3
 801ea0e:	dd02      	ble.n	801ea16 <DstGetDayOfMonth+0x18a>
        targetMdayOfTargetWday -= 7;
 801ea10:	69bb      	ldr	r3, [r7, #24]
 801ea12:	3b07      	subs	r3, #7
 801ea14:	61bb      	str	r3, [r7, #24]
    }

    return targetMdayOfTargetWday;
 801ea16:	69bb      	ldr	r3, [r7, #24]
}
 801ea18:	4a05      	ldr	r2, [pc, #20]	; (801ea30 <DstGetDayOfMonth+0x1a4>)
 801ea1a:	6811      	ldr	r1, [r2, #0]
 801ea1c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801ea1e:	4051      	eors	r1, r2
 801ea20:	d001      	beq.n	801ea26 <DstGetDayOfMonth+0x19a>
 801ea22:	f7e5 fce1 	bl	80043e8 <__stack_chk_fail>
 801ea26:	4618      	mov	r0, r3
 801ea28:	3760      	adds	r7, #96	; 0x60
 801ea2a:	46bd      	mov	sp, r7
 801ea2c:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 801ea30:	080232ac 	.word	0x080232ac
 801ea34:	00015180 	.word	0x00015180
 801ea38:	92492493 	.word	0x92492493
 801ea3c:	51eb851f 	.word	0x51eb851f
 801ea40:	08024314 	.word	0x08024314

0801ea44 <DateDecode>:
 * idx 012345678901234
 * 2.  Oct-1st-Fri 02:59:59
 * idx 12345678901234567890
 */
STATIC INT32 DateDecode(INT32 year, const CHAR *dstString, INT32 *month, INT32 *monDay, INT32 *sec)
{
 801ea44:	b580      	push	{r7, lr}
 801ea46:	b086      	sub	sp, #24
 801ea48:	af00      	add	r7, sp, #0
 801ea4a:	60f8      	str	r0, [r7, #12]
 801ea4c:	60b9      	str	r1, [r7, #8]
 801ea4e:	607a      	str	r2, [r7, #4]
 801ea50:	603b      	str	r3, [r7, #0]
    INT32 monWeek, weekDay;
    /* For example "Feb-03 03:00:00" */
    if (strlen(dstString) == DST_STR_LEN_FORMAT_MDAY) {
 801ea52:	68b8      	ldr	r0, [r7, #8]
 801ea54:	f7f0 f819 	bl	800ea8a <strlen>
 801ea58:	4603      	mov	r3, r0
 801ea5a:	2b0f      	cmp	r3, #15
 801ea5c:	d13d      	bne.n	801eada <DateDecode+0x96>
        if ((dstString[3] != '-') || (dstString[6] != ' ')) {
 801ea5e:	68bb      	ldr	r3, [r7, #8]
 801ea60:	3303      	adds	r3, #3
 801ea62:	781b      	ldrb	r3, [r3, #0]
 801ea64:	2b2d      	cmp	r3, #45	; 0x2d
 801ea66:	d104      	bne.n	801ea72 <DateDecode+0x2e>
 801ea68:	68bb      	ldr	r3, [r7, #8]
 801ea6a:	3306      	adds	r3, #6
 801ea6c:	781b      	ldrb	r3, [r3, #0]
 801ea6e:	2b20      	cmp	r3, #32
 801ea70:	d002      	beq.n	801ea78 <DateDecode+0x34>
            return -1;
 801ea72:	f04f 33ff 	mov.w	r3, #4294967295
 801ea76:	e096      	b.n	801eba6 <DateDecode+0x162>
        }

        *month = GetMonthFromString(&dstString[0]);
 801ea78:	68b8      	ldr	r0, [r7, #8]
 801ea7a:	f7ff fdc7 	bl	801e60c <GetMonthFromString>
 801ea7e:	4602      	mov	r2, r0
 801ea80:	687b      	ldr	r3, [r7, #4]
 801ea82:	601a      	str	r2, [r3, #0]
        if (*month == -1) {
 801ea84:	687b      	ldr	r3, [r7, #4]
 801ea86:	681b      	ldr	r3, [r3, #0]
 801ea88:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ea8c:	d102      	bne.n	801ea94 <DateDecode+0x50>
            return -1;
 801ea8e:	f04f 33ff 	mov.w	r3, #4294967295
 801ea92:	e088      	b.n	801eba6 <DateDecode+0x162>
        }

        *monDay = GetMonthDayFromString(*month, &dstString[4]);
 801ea94:	687b      	ldr	r3, [r7, #4]
 801ea96:	681a      	ldr	r2, [r3, #0]
 801ea98:	68bb      	ldr	r3, [r7, #8]
 801ea9a:	3304      	adds	r3, #4
 801ea9c:	4619      	mov	r1, r3
 801ea9e:	4610      	mov	r0, r2
 801eaa0:	f7ff fe40 	bl	801e724 <GetMonthDayFromString>
 801eaa4:	4602      	mov	r2, r0
 801eaa6:	683b      	ldr	r3, [r7, #0]
 801eaa8:	601a      	str	r2, [r3, #0]
        if (*monDay == -1) {
 801eaaa:	683b      	ldr	r3, [r7, #0]
 801eaac:	681b      	ldr	r3, [r3, #0]
 801eaae:	f1b3 3fff 	cmp.w	r3, #4294967295
 801eab2:	d102      	bne.n	801eaba <DateDecode+0x76>
            return -1;
 801eab4:	f04f 33ff 	mov.w	r3, #4294967295
 801eab8:	e075      	b.n	801eba6 <DateDecode+0x162>
        }

        *sec = GetDaySecondsFromString(&dstString[7]);
 801eaba:	68bb      	ldr	r3, [r7, #8]
 801eabc:	3307      	adds	r3, #7
 801eabe:	4618      	mov	r0, r3
 801eac0:	f7ff fe68 	bl	801e794 <GetDaySecondsFromString>
 801eac4:	4602      	mov	r2, r0
 801eac6:	6a3b      	ldr	r3, [r7, #32]
 801eac8:	601a      	str	r2, [r3, #0]
        if (*sec == -1) {
 801eaca:	6a3b      	ldr	r3, [r7, #32]
 801eacc:	681b      	ldr	r3, [r3, #0]
 801eace:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ead2:	d167      	bne.n	801eba4 <DateDecode+0x160>
            return -1;
 801ead4:	f04f 33ff 	mov.w	r3, #4294967295
 801ead8:	e065      	b.n	801eba6 <DateDecode+0x162>
        }
    } else if (strlen(dstString) == DST_STR_LEN_FORMAT_WDAY) {
 801eada:	68b8      	ldr	r0, [r7, #8]
 801eadc:	f7ef ffd5 	bl	800ea8a <strlen>
 801eae0:	4603      	mov	r3, r0
 801eae2:	2b14      	cmp	r3, #20
 801eae4:	d15b      	bne.n	801eb9e <DateDecode+0x15a>
        /* For example "Oct-1st-Fri 02:59:59" */
        if ((dstString[3] != '-') || (dstString[7] != '-') || (dstString[11] != ' ')) {
 801eae6:	68bb      	ldr	r3, [r7, #8]
 801eae8:	3303      	adds	r3, #3
 801eaea:	781b      	ldrb	r3, [r3, #0]
 801eaec:	2b2d      	cmp	r3, #45	; 0x2d
 801eaee:	d109      	bne.n	801eb04 <DateDecode+0xc0>
 801eaf0:	68bb      	ldr	r3, [r7, #8]
 801eaf2:	3307      	adds	r3, #7
 801eaf4:	781b      	ldrb	r3, [r3, #0]
 801eaf6:	2b2d      	cmp	r3, #45	; 0x2d
 801eaf8:	d104      	bne.n	801eb04 <DateDecode+0xc0>
 801eafa:	68bb      	ldr	r3, [r7, #8]
 801eafc:	330b      	adds	r3, #11
 801eafe:	781b      	ldrb	r3, [r3, #0]
 801eb00:	2b20      	cmp	r3, #32
 801eb02:	d002      	beq.n	801eb0a <DateDecode+0xc6>
            return -1;
 801eb04:	f04f 33ff 	mov.w	r3, #4294967295
 801eb08:	e04d      	b.n	801eba6 <DateDecode+0x162>
        }

        *month = GetMonthFromString(&dstString[0]);
 801eb0a:	68b8      	ldr	r0, [r7, #8]
 801eb0c:	f7ff fd7e 	bl	801e60c <GetMonthFromString>
 801eb10:	4602      	mov	r2, r0
 801eb12:	687b      	ldr	r3, [r7, #4]
 801eb14:	601a      	str	r2, [r3, #0]
        if (*month == -1) {
 801eb16:	687b      	ldr	r3, [r7, #4]
 801eb18:	681b      	ldr	r3, [r3, #0]
 801eb1a:	f1b3 3fff 	cmp.w	r3, #4294967295
 801eb1e:	d102      	bne.n	801eb26 <DateDecode+0xe2>
            return -1;
 801eb20:	f04f 33ff 	mov.w	r3, #4294967295
 801eb24:	e03f      	b.n	801eba6 <DateDecode+0x162>
        }

        monWeek = GetMonthWeekFromString(&dstString[4]);
 801eb26:	68bb      	ldr	r3, [r7, #8]
 801eb28:	3304      	adds	r3, #4
 801eb2a:	4618      	mov	r0, r3
 801eb2c:	f7ff fdb6 	bl	801e69c <GetMonthWeekFromString>
 801eb30:	6138      	str	r0, [r7, #16]
        if (monWeek == -1) {
 801eb32:	693b      	ldr	r3, [r7, #16]
 801eb34:	f1b3 3fff 	cmp.w	r3, #4294967295
 801eb38:	d102      	bne.n	801eb40 <DateDecode+0xfc>
            return -1;
 801eb3a:	f04f 33ff 	mov.w	r3, #4294967295
 801eb3e:	e032      	b.n	801eba6 <DateDecode+0x162>
        }

        weekDay = GetWeekDayFromString(&dstString[8]);
 801eb40:	68bb      	ldr	r3, [r7, #8]
 801eb42:	3308      	adds	r3, #8
 801eb44:	4618      	mov	r0, r3
 801eb46:	f7ff fd85 	bl	801e654 <GetWeekDayFromString>
 801eb4a:	6178      	str	r0, [r7, #20]
        if (weekDay == -1) {
 801eb4c:	697b      	ldr	r3, [r7, #20]
 801eb4e:	f1b3 3fff 	cmp.w	r3, #4294967295
 801eb52:	d102      	bne.n	801eb5a <DateDecode+0x116>
            return -1;
 801eb54:	f04f 33ff 	mov.w	r3, #4294967295
 801eb58:	e025      	b.n	801eba6 <DateDecode+0x162>
        }

        *sec = GetDaySecondsFromString(&dstString[12]);
 801eb5a:	68bb      	ldr	r3, [r7, #8]
 801eb5c:	330c      	adds	r3, #12
 801eb5e:	4618      	mov	r0, r3
 801eb60:	f7ff fe18 	bl	801e794 <GetDaySecondsFromString>
 801eb64:	4602      	mov	r2, r0
 801eb66:	6a3b      	ldr	r3, [r7, #32]
 801eb68:	601a      	str	r2, [r3, #0]
        if (*sec == -1) {
 801eb6a:	6a3b      	ldr	r3, [r7, #32]
 801eb6c:	681b      	ldr	r3, [r3, #0]
 801eb6e:	f1b3 3fff 	cmp.w	r3, #4294967295
 801eb72:	d102      	bne.n	801eb7a <DateDecode+0x136>
            return -1;
 801eb74:	f04f 33ff 	mov.w	r3, #4294967295
 801eb78:	e015      	b.n	801eba6 <DateDecode+0x162>
        }

        *monDay = DstGetDayOfMonth(year, *month, monWeek, weekDay);
 801eb7a:	687b      	ldr	r3, [r7, #4]
 801eb7c:	6819      	ldr	r1, [r3, #0]
 801eb7e:	697b      	ldr	r3, [r7, #20]
 801eb80:	693a      	ldr	r2, [r7, #16]
 801eb82:	68f8      	ldr	r0, [r7, #12]
 801eb84:	f7ff fe82 	bl	801e88c <DstGetDayOfMonth>
 801eb88:	4602      	mov	r2, r0
 801eb8a:	683b      	ldr	r3, [r7, #0]
 801eb8c:	601a      	str	r2, [r3, #0]
        if (*monDay  == -1) {
 801eb8e:	683b      	ldr	r3, [r7, #0]
 801eb90:	681b      	ldr	r3, [r3, #0]
 801eb92:	f1b3 3fff 	cmp.w	r3, #4294967295
 801eb96:	d105      	bne.n	801eba4 <DateDecode+0x160>
            return -1;
 801eb98:	f04f 33ff 	mov.w	r3, #4294967295
 801eb9c:	e003      	b.n	801eba6 <DateDecode+0x162>
        }
    } else {
        return -1;
 801eb9e:	f04f 33ff 	mov.w	r3, #4294967295
 801eba2:	e000      	b.n	801eba6 <DateDecode+0x162>
    }

    return 0;
 801eba4:	2300      	movs	r3, #0
}
 801eba6:	4618      	mov	r0, r3
 801eba8:	3718      	adds	r7, #24
 801ebaa:	46bd      	mov	sp, r7
 801ebac:	bd80      	pop	{r7, pc}
	...

0801ebb0 <DstConfigDecode>:

STATIC INT64 DstConfigDecode(INT32 year, const CHAR *dstString)
{
 801ebb0:	b5b0      	push	{r4, r5, r7, lr}
 801ebb2:	b096      	sub	sp, #88	; 0x58
 801ebb4:	af02      	add	r7, sp, #8
 801ebb6:	6078      	str	r0, [r7, #4]
 801ebb8:	6039      	str	r1, [r7, #0]
 801ebba:	4b2a      	ldr	r3, [pc, #168]	; (801ec64 <DstConfigDecode+0xb4>)
 801ebbc:	681b      	ldr	r3, [r3, #0]
 801ebbe:	64fb      	str	r3, [r7, #76]	; 0x4c
 801ebc0:	f04f 0300 	mov.w	r3, #0
    INT32 month, monDay, sec;
    INT32 ret;
    struct tm time = {0};
 801ebc4:	f107 0320 	add.w	r3, r7, #32
 801ebc8:	222c      	movs	r2, #44	; 0x2c
 801ebca:	2100      	movs	r1, #0
 801ebcc:	4618      	mov	r0, r3
 801ebce:	f7ef fe39 	bl	800e844 <memset>
    INT64 dstSeconds;

    ret = DateDecode(year, dstString, &month, &monDay, &sec);
 801ebd2:	f107 010c 	add.w	r1, r7, #12
 801ebd6:	f107 0208 	add.w	r2, r7, #8
 801ebda:	f107 0310 	add.w	r3, r7, #16
 801ebde:	9300      	str	r3, [sp, #0]
 801ebe0:	460b      	mov	r3, r1
 801ebe2:	6839      	ldr	r1, [r7, #0]
 801ebe4:	6878      	ldr	r0, [r7, #4]
 801ebe6:	f7ff ff2d 	bl	801ea44 <DateDecode>
 801ebea:	6178      	str	r0, [r7, #20]
    if (ret == -1) {
 801ebec:	697b      	ldr	r3, [r7, #20]
 801ebee:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ebf2:	d104      	bne.n	801ebfe <DstConfigDecode+0x4e>
        return -1;
 801ebf4:	f04f 34ff 	mov.w	r4, #4294967295
 801ebf8:	f04f 35ff 	mov.w	r5, #4294967295
 801ebfc:	e024      	b.n	801ec48 <DstConfigDecode+0x98>
    }
    /* get the DST period */
    time.tm_year = year;
 801ebfe:	687b      	ldr	r3, [r7, #4]
 801ec00:	637b      	str	r3, [r7, #52]	; 0x34
    time.tm_mon = month;
 801ec02:	68bb      	ldr	r3, [r7, #8]
 801ec04:	633b      	str	r3, [r7, #48]	; 0x30
    time.tm_mday = monDay;
 801ec06:	68fb      	ldr	r3, [r7, #12]
 801ec08:	62fb      	str	r3, [r7, #44]	; 0x2c
    time.tm_isdst = 0;
 801ec0a:	2300      	movs	r3, #0
 801ec0c:	643b      	str	r3, [r7, #64]	; 0x40
#ifdef LOSCFG_AARCH64
    dstSeconds = mktime(&time);
#else
    dstSeconds = mktime64(&time);
 801ec0e:	f107 0320 	add.w	r3, r7, #32
 801ec12:	4618      	mov	r0, r3
 801ec14:	f7fe ff3c 	bl	801da90 <mktime64>
 801ec18:	e9c7 0106 	strd	r0, r1, [r7, #24]
#endif
    if (dstSeconds == -1) {
 801ec1c:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801ec20:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ec24:	bf08      	it	eq
 801ec26:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 801ec2a:	d104      	bne.n	801ec36 <DstConfigDecode+0x86>
        return -1;
 801ec2c:	f04f 34ff 	mov.w	r4, #4294967295
 801ec30:	f04f 35ff 	mov.w	r5, #4294967295
 801ec34:	e008      	b.n	801ec48 <DstConfigDecode+0x98>
    }

    return dstSeconds + sec;
 801ec36:	693b      	ldr	r3, [r7, #16]
 801ec38:	4618      	mov	r0, r3
 801ec3a:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801ec3e:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801ec42:	1884      	adds	r4, r0, r2
 801ec44:	eb41 0503 	adc.w	r5, r1, r3
 801ec48:	4622      	mov	r2, r4
 801ec4a:	462b      	mov	r3, r5
}
 801ec4c:	4905      	ldr	r1, [pc, #20]	; (801ec64 <DstConfigDecode+0xb4>)
 801ec4e:	6808      	ldr	r0, [r1, #0]
 801ec50:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801ec52:	4048      	eors	r0, r1
 801ec54:	d001      	beq.n	801ec5a <DstConfigDecode+0xaa>
 801ec56:	f7e5 fbc7 	bl	80043e8 <__stack_chk_fail>
 801ec5a:	4610      	mov	r0, r2
 801ec5c:	4619      	mov	r1, r3
 801ec5e:	3750      	adds	r7, #80	; 0x50
 801ec60:	46bd      	mov	sp, r7
 801ec62:	bdb0      	pop	{r4, r5, r7, pc}
 801ec64:	080232b0 	.word	0x080232b0

0801ec68 <CheckDstPeriodInner>:

    return TRUE;
}

STATIC BOOL CheckDstPeriodInner(const struct tm * const tm, INT64 seconds, INT64 dstStart, INT64 dstEnd)
{
 801ec68:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
 801ec6c:	b085      	sub	sp, #20
 801ec6e:	af00      	add	r7, sp, #0
 801ec70:	60f8      	str	r0, [r7, #12]
 801ec72:	e9c7 2300 	strd	r2, r3, [r7]
    if (tm != NULL) {
 801ec76:	68fb      	ldr	r3, [r7, #12]
 801ec78:	2b00      	cmp	r3, #0
 801ec7a:	d040      	beq.n	801ecfe <CheckDstPeriodInner+0x96>
        if (tm->tm_isdst < 0) {
 801ec7c:	68fb      	ldr	r3, [r7, #12]
 801ec7e:	6a1b      	ldr	r3, [r3, #32]
 801ec80:	2b00      	cmp	r3, #0
 801ec82:	da34      	bge.n	801ecee <CheckDstPeriodInner+0x86>
            /* it must to be. */
            if ((seconds >= dstStart) && (seconds < dstStart + g_dstForwardSeconds)) {
 801ec84:	e9d7 0100 	ldrd	r0, r1, [r7]
 801ec88:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801ec8c:	4290      	cmp	r0, r2
 801ec8e:	eb71 0303 	sbcs.w	r3, r1, r3
 801ec92:	db12      	blt.n	801ecba <CheckDstPeriodInner+0x52>
 801ec94:	4b26      	ldr	r3, [pc, #152]	; (801ed30 <CheckDstPeriodInner+0xc8>)
 801ec96:	681b      	ldr	r3, [r3, #0]
 801ec98:	4618      	mov	r0, r3
 801ec9a:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801ec9e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801eca2:	eb10 0802 	adds.w	r8, r0, r2
 801eca6:	eb41 0903 	adc.w	r9, r1, r3
 801ecaa:	e9d7 2300 	ldrd	r2, r3, [r7]
 801ecae:	4542      	cmp	r2, r8
 801ecb0:	eb73 0309 	sbcs.w	r3, r3, r9
 801ecb4:	da01      	bge.n	801ecba <CheckDstPeriodInner+0x52>
                return FALSE;
 801ecb6:	2300      	movs	r3, #0
 801ecb8:	e034      	b.n	801ed24 <CheckDstPeriodInner+0xbc>
            }

            /* determine the time period of the second pass, out of the DST period. */
            if ((seconds > dstEnd) && (seconds <= dstEnd + g_dstForwardSeconds)) {
 801ecba:	e9d7 2300 	ldrd	r2, r3, [r7]
 801ecbe:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 801ecc2:	4290      	cmp	r0, r2
 801ecc4:	eb71 0303 	sbcs.w	r3, r1, r3
 801ecc8:	da19      	bge.n	801ecfe <CheckDstPeriodInner+0x96>
 801ecca:	4b19      	ldr	r3, [pc, #100]	; (801ed30 <CheckDstPeriodInner+0xc8>)
 801eccc:	681b      	ldr	r3, [r3, #0]
 801ecce:	4618      	mov	r0, r3
 801ecd0:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801ecd4:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 801ecd8:	1884      	adds	r4, r0, r2
 801ecda:	eb41 0503 	adc.w	r5, r1, r3
 801ecde:	e9d7 2300 	ldrd	r2, r3, [r7]
 801ece2:	4294      	cmp	r4, r2
 801ece4:	eb75 0303 	sbcs.w	r3, r5, r3
 801ece8:	db09      	blt.n	801ecfe <CheckDstPeriodInner+0x96>
                return TRUE;
 801ecea:	2301      	movs	r3, #1
 801ecec:	e01a      	b.n	801ed24 <CheckDstPeriodInner+0xbc>
            }
        } else if (tm->tm_isdst > 0) {
 801ecee:	68fb      	ldr	r3, [r7, #12]
 801ecf0:	6a1b      	ldr	r3, [r3, #32]
 801ecf2:	2b00      	cmp	r3, #0
 801ecf4:	dd01      	ble.n	801ecfa <CheckDstPeriodInner+0x92>
            /* the logical judgment here is the opposite of common sense */
            return TRUE;
 801ecf6:	2301      	movs	r3, #1
 801ecf8:	e014      	b.n	801ed24 <CheckDstPeriodInner+0xbc>
        } else {
            /* tm->tm_isdst is zero */
            return FALSE;
 801ecfa:	2300      	movs	r3, #0
 801ecfc:	e012      	b.n	801ed24 <CheckDstPeriodInner+0xbc>
        }
    }

    if ((seconds < dstStart) || (seconds >= dstEnd)) {
 801ecfe:	e9d7 0100 	ldrd	r0, r1, [r7]
 801ed02:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801ed06:	4290      	cmp	r0, r2
 801ed08:	eb71 0303 	sbcs.w	r3, r1, r3
 801ed0c:	db07      	blt.n	801ed1e <CheckDstPeriodInner+0xb6>
 801ed0e:	e9d7 0100 	ldrd	r0, r1, [r7]
 801ed12:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 801ed16:	4290      	cmp	r0, r2
 801ed18:	eb71 0303 	sbcs.w	r3, r1, r3
 801ed1c:	db01      	blt.n	801ed22 <CheckDstPeriodInner+0xba>
        return FALSE; /* daylight saving time is not effect. */
 801ed1e:	2300      	movs	r3, #0
 801ed20:	e000      	b.n	801ed24 <CheckDstPeriodInner+0xbc>
    }

    return TRUE;
 801ed22:	2301      	movs	r3, #1
}
 801ed24:	4618      	mov	r0, r3
 801ed26:	3714      	adds	r7, #20
 801ed28:	46bd      	mov	sp, r7
 801ed2a:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
 801ed2e:	4770      	bx	lr
 801ed30:	2000345c 	.word	0x2000345c

0801ed34 <CheckWithinDstPeriod>:

BOOL CheckWithinDstPeriod(const struct tm * const tm, INT64 seconds)
{
 801ed34:	b580      	push	{r7, lr}
 801ed36:	b098      	sub	sp, #96	; 0x60
 801ed38:	af04      	add	r7, sp, #16
 801ed3a:	60f8      	str	r0, [r7, #12]
 801ed3c:	e9c7 2300 	strd	r2, r3, [r7]
 801ed40:	4b42      	ldr	r3, [pc, #264]	; (801ee4c <CheckWithinDstPeriod+0x118>)
 801ed42:	681b      	ldr	r3, [r3, #0]
 801ed44:	64fb      	str	r3, [r7, #76]	; 0x4c
 801ed46:	f04f 0300 	mov.w	r3, #0
    INT64 dstStart, dstEnd;
    struct tm time = {0};
 801ed4a:	f107 0320 	add.w	r3, r7, #32
 801ed4e:	222c      	movs	r2, #44	; 0x2c
 801ed50:	2100      	movs	r1, #0
 801ed52:	4618      	mov	r0, r3
 801ed54:	f7ef fd76 	bl	800e844 <memset>

    if (LIBC_LOCK(g_tzdstLock)) {
 801ed58:	483d      	ldr	r0, [pc, #244]	; (801ee50 <CheckWithinDstPeriod+0x11c>)
 801ed5a:	f000 f881 	bl	801ee60 <LibcLock>
 801ed5e:	4603      	mov	r3, r0
 801ed60:	2b00      	cmp	r3, #0
 801ed62:	d001      	beq.n	801ed68 <CheckWithinDstPeriod+0x34>
        return FALSE;
 801ed64:	2300      	movs	r3, #0
 801ed66:	e066      	b.n	801ee36 <CheckWithinDstPeriod+0x102>
    }
    if (g_isDstWork == FALSE) {
 801ed68:	4b3a      	ldr	r3, [pc, #232]	; (801ee54 <CheckWithinDstPeriod+0x120>)
 801ed6a:	681b      	ldr	r3, [r3, #0]
 801ed6c:	2b00      	cmp	r3, #0
 801ed6e:	d104      	bne.n	801ed7a <CheckWithinDstPeriod+0x46>
        (void)LIBC_UNLOCK(g_tzdstLock);
 801ed70:	4837      	ldr	r0, [pc, #220]	; (801ee50 <CheckWithinDstPeriod+0x11c>)
 801ed72:	f000 f89f 	bl	801eeb4 <LibcUnlock>
        return FALSE;
 801ed76:	2300      	movs	r3, #0
 801ed78:	e05d      	b.n	801ee36 <CheckWithinDstPeriod+0x102>
    }

    (void)LIBC_UNLOCK(g_tzdstLock);
 801ed7a:	4835      	ldr	r0, [pc, #212]	; (801ee50 <CheckWithinDstPeriod+0x11c>)
 801ed7c:	f000 f89a 	bl	801eeb4 <LibcUnlock>
    /* represent a local time. */
    if (tm != NULL) {
 801ed80:	68fb      	ldr	r3, [r7, #12]
 801ed82:	2b00      	cmp	r3, #0
 801ed84:	d01b      	beq.n	801edbe <CheckWithinDstPeriod+0x8a>
        (void)memcpy_s(&time, sizeof(struct tm), tm, sizeof(struct tm));
 801ed86:	f107 0020 	add.w	r0, r7, #32
 801ed8a:	232c      	movs	r3, #44	; 0x2c
 801ed8c:	68fa      	ldr	r2, [r7, #12]
 801ed8e:	212c      	movs	r1, #44	; 0x2c
 801ed90:	f7f7 fc04 	bl	801659c <memcpy_s>
        time.tm_isdst = 0;
 801ed94:	2300      	movs	r3, #0
 801ed96:	643b      	str	r3, [r7, #64]	; 0x40
        /* the input-param of seconds is unused in this case. */
#ifdef LOSCFG_AARCH64
        seconds = mktime(&time);
#else
        seconds = mktime64(&time);
 801ed98:	f107 0320 	add.w	r3, r7, #32
 801ed9c:	4618      	mov	r0, r3
 801ed9e:	f7fe fe77 	bl	801da90 <mktime64>
 801eda2:	4602      	mov	r2, r0
 801eda4:	460b      	mov	r3, r1
 801eda6:	e9c7 2300 	strd	r2, r3, [r7]
#endif
        if (seconds == -1) {
 801edaa:	e9d7 2300 	ldrd	r2, r3, [r7]
 801edae:	f1b3 3fff 	cmp.w	r3, #4294967295
 801edb2:	bf08      	it	eq
 801edb4:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 801edb8:	d10d      	bne.n	801edd6 <CheckWithinDstPeriod+0xa2>
            return FALSE;
 801edba:	2300      	movs	r3, #0
 801edbc:	e03b      	b.n	801ee36 <CheckWithinDstPeriod+0x102>
    } else {
        /* represent a standard time, not care TZ. */
#ifdef LOSCFG_AARCH64
        if (gmtime_r(&seconds, &time) == NULL) {
#else
        if (gmtime64_r(&seconds, &time) == NULL) {
 801edbe:	f107 0220 	add.w	r2, r7, #32
 801edc2:	463b      	mov	r3, r7
 801edc4:	4611      	mov	r1, r2
 801edc6:	4618      	mov	r0, r3
 801edc8:	f7fe fea8 	bl	801db1c <gmtime64_r>
 801edcc:	4603      	mov	r3, r0
 801edce:	2b00      	cmp	r3, #0
 801edd0:	d101      	bne.n	801edd6 <CheckWithinDstPeriod+0xa2>
#endif
            return FALSE;
 801edd2:	2300      	movs	r3, #0
 801edd4:	e02f      	b.n	801ee36 <CheckWithinDstPeriod+0x102>
        }
    }

    dstStart = DstConfigDecode(time.tm_year, g_strDstStart);
 801edd6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801edd8:	491f      	ldr	r1, [pc, #124]	; (801ee58 <CheckWithinDstPeriod+0x124>)
 801edda:	4618      	mov	r0, r3
 801eddc:	f7ff fee8 	bl	801ebb0 <DstConfigDecode>
 801ede0:	e9c7 0104 	strd	r0, r1, [r7, #16]
    dstEnd = DstConfigDecode(time.tm_year, g_strDstEnd);
 801ede4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ede6:	491d      	ldr	r1, [pc, #116]	; (801ee5c <CheckWithinDstPeriod+0x128>)
 801ede8:	4618      	mov	r0, r3
 801edea:	f7ff fee1 	bl	801ebb0 <DstConfigDecode>
 801edee:	e9c7 0106 	strd	r0, r1, [r7, #24]
    if ((dstStart == -1) || (dstEnd == -1)) {
 801edf2:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801edf6:	f1b3 3fff 	cmp.w	r3, #4294967295
 801edfa:	bf08      	it	eq
 801edfc:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 801ee00:	d007      	beq.n	801ee12 <CheckWithinDstPeriod+0xde>
 801ee02:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801ee06:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ee0a:	bf08      	it	eq
 801ee0c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 801ee10:	d101      	bne.n	801ee16 <CheckWithinDstPeriod+0xe2>
        return FALSE;
 801ee12:	2300      	movs	r3, #0
 801ee14:	e00f      	b.n	801ee36 <CheckWithinDstPeriod+0x102>
    }

    return CheckDstPeriodInner(tm, seconds, dstStart, dstEnd);
 801ee16:	e9d7 0100 	ldrd	r0, r1, [r7]
 801ee1a:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801ee1e:	e9cd 2302 	strd	r2, r3, [sp, #8]
 801ee22:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801ee26:	e9cd 2300 	strd	r2, r3, [sp]
 801ee2a:	4602      	mov	r2, r0
 801ee2c:	460b      	mov	r3, r1
 801ee2e:	68f8      	ldr	r0, [r7, #12]
 801ee30:	f7ff ff1a 	bl	801ec68 <CheckDstPeriodInner>
 801ee34:	4603      	mov	r3, r0
}
 801ee36:	4a05      	ldr	r2, [pc, #20]	; (801ee4c <CheckWithinDstPeriod+0x118>)
 801ee38:	6811      	ldr	r1, [r2, #0]
 801ee3a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801ee3c:	4051      	eors	r1, r2
 801ee3e:	d001      	beq.n	801ee44 <CheckWithinDstPeriod+0x110>
 801ee40:	f7e5 fad2 	bl	80043e8 <__stack_chk_fail>
 801ee44:	4618      	mov	r0, r3
 801ee46:	3750      	adds	r7, #80	; 0x50
 801ee48:	46bd      	mov	sp, r7
 801ee4a:	bd80      	pop	{r7, pc}
 801ee4c:	080232b4 	.word	0x080232b4
 801ee50:	20000570 	.word	0x20000570
 801ee54:	20003458 	.word	0x20003458
 801ee58:	20003460 	.word	0x20003460
 801ee5c:	20003478 	.word	0x20003478

0801ee60 <LibcLock>:
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

INT32 LibcLock(UINT32 *lock)
{
 801ee60:	b580      	push	{r7, lr}
 801ee62:	b082      	sub	sp, #8
 801ee64:	af00      	add	r7, sp, #0
 801ee66:	6078      	str	r0, [r7, #4]
    if (lock == NULL) {
 801ee68:	687b      	ldr	r3, [r7, #4]
 801ee6a:	2b00      	cmp	r3, #0
 801ee6c:	d102      	bne.n	801ee74 <LibcLock+0x14>
        return -1;
 801ee6e:	f04f 33ff 	mov.w	r3, #4294967295
 801ee72:	e01b      	b.n	801eeac <LibcLock+0x4c>
    }

    if (*lock == LIBC_LOCK_INITIALIZER) {
 801ee74:	687b      	ldr	r3, [r7, #4]
 801ee76:	681b      	ldr	r3, [r3, #0]
 801ee78:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ee7c:	d108      	bne.n	801ee90 <LibcLock+0x30>
        if (LOS_MuxCreate(lock) != LOS_OK) {
 801ee7e:	6878      	ldr	r0, [r7, #4]
 801ee80:	f7eb fd74 	bl	800a96c <LOS_MuxCreate>
 801ee84:	4603      	mov	r3, r0
 801ee86:	2b00      	cmp	r3, #0
 801ee88:	d002      	beq.n	801ee90 <LibcLock+0x30>
            return -1;
 801ee8a:	f04f 33ff 	mov.w	r3, #4294967295
 801ee8e:	e00d      	b.n	801eeac <LibcLock+0x4c>
        }
    }

    if (LOS_MuxPend(*lock, LOS_WAIT_FOREVER) != LOS_OK) {
 801ee90:	687b      	ldr	r3, [r7, #4]
 801ee92:	681b      	ldr	r3, [r3, #0]
 801ee94:	f04f 31ff 	mov.w	r1, #4294967295
 801ee98:	4618      	mov	r0, r3
 801ee9a:	f7ec f811 	bl	800aec0 <LOS_MuxPend>
 801ee9e:	4603      	mov	r3, r0
 801eea0:	2b00      	cmp	r3, #0
 801eea2:	d002      	beq.n	801eeaa <LibcLock+0x4a>
        return -1;
 801eea4:	f04f 33ff 	mov.w	r3, #4294967295
 801eea8:	e000      	b.n	801eeac <LibcLock+0x4c>
    } else {
        return 0;
 801eeaa:	2300      	movs	r3, #0
    }
}
 801eeac:	4618      	mov	r0, r3
 801eeae:	3708      	adds	r7, #8
 801eeb0:	46bd      	mov	sp, r7
 801eeb2:	bd80      	pop	{r7, pc}

0801eeb4 <LibcUnlock>:

INT32 LibcUnlock(const UINT32 *lock)
{
 801eeb4:	b580      	push	{r7, lr}
 801eeb6:	b082      	sub	sp, #8
 801eeb8:	af00      	add	r7, sp, #0
 801eeba:	6078      	str	r0, [r7, #4]
    if ((lock == NULL) || (*lock == LIBC_LOCK_INITIALIZER)) {
 801eebc:	687b      	ldr	r3, [r7, #4]
 801eebe:	2b00      	cmp	r3, #0
 801eec0:	d004      	beq.n	801eecc <LibcUnlock+0x18>
 801eec2:	687b      	ldr	r3, [r7, #4]
 801eec4:	681b      	ldr	r3, [r3, #0]
 801eec6:	f1b3 3fff 	cmp.w	r3, #4294967295
 801eeca:	d102      	bne.n	801eed2 <LibcUnlock+0x1e>
        return -1;
 801eecc:	f04f 33ff 	mov.w	r3, #4294967295
 801eed0:	e00b      	b.n	801eeea <LibcUnlock+0x36>
    }

    if (LOS_MuxPost(*lock) != LOS_OK) {
 801eed2:	687b      	ldr	r3, [r7, #4]
 801eed4:	681b      	ldr	r3, [r3, #0]
 801eed6:	4618      	mov	r0, r3
 801eed8:	f7ec f972 	bl	800b1c0 <LOS_MuxPost>
 801eedc:	4603      	mov	r3, r0
 801eede:	2b00      	cmp	r3, #0
 801eee0:	d002      	beq.n	801eee8 <LibcUnlock+0x34>
        return -1;
 801eee2:	f04f 33ff 	mov.w	r3, #4294967295
 801eee6:	e000      	b.n	801eeea <LibcUnlock+0x36>
    } else {
        return 0;
 801eee8:	2300      	movs	r3, #0
    }
}
 801eeea:	4618      	mov	r0, r3
 801eeec:	3708      	adds	r7, #8
 801eeee:	46bd      	mov	sp, r7
 801eef0:	bd80      	pop	{r7, pc}

0801eef2 <memchr>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) (((x)-ONES) & ~(x) & HIGHS)

void *memchr(const void *src, int c, size_t n)
{
 801eef2:	b480      	push	{r7}
 801eef4:	b089      	sub	sp, #36	; 0x24
 801eef6:	af00      	add	r7, sp, #0
 801eef8:	60f8      	str	r0, [r7, #12]
 801eefa:	60b9      	str	r1, [r7, #8]
 801eefc:	607a      	str	r2, [r7, #4]
	const unsigned char *s = src;
 801eefe:	68fb      	ldr	r3, [r7, #12]
 801ef00:	617b      	str	r3, [r7, #20]
	c = (unsigned char)c;
 801ef02:	68bb      	ldr	r3, [r7, #8]
 801ef04:	b2db      	uxtb	r3, r3
 801ef06:	60bb      	str	r3, [r7, #8]
#ifdef __GNUC__
	for (; ((uintptr_t)s & ALIGN) && n && *s != c; s++, n--);
 801ef08:	e005      	b.n	801ef16 <memchr+0x24>
 801ef0a:	697b      	ldr	r3, [r7, #20]
 801ef0c:	3301      	adds	r3, #1
 801ef0e:	617b      	str	r3, [r7, #20]
 801ef10:	687b      	ldr	r3, [r7, #4]
 801ef12:	3b01      	subs	r3, #1
 801ef14:	607b      	str	r3, [r7, #4]
 801ef16:	697b      	ldr	r3, [r7, #20]
 801ef18:	f003 0303 	and.w	r3, r3, #3
 801ef1c:	2b00      	cmp	r3, #0
 801ef1e:	d008      	beq.n	801ef32 <memchr+0x40>
 801ef20:	687b      	ldr	r3, [r7, #4]
 801ef22:	2b00      	cmp	r3, #0
 801ef24:	d005      	beq.n	801ef32 <memchr+0x40>
 801ef26:	697b      	ldr	r3, [r7, #20]
 801ef28:	781b      	ldrb	r3, [r3, #0]
 801ef2a:	461a      	mov	r2, r3
 801ef2c:	68bb      	ldr	r3, [r7, #8]
 801ef2e:	4293      	cmp	r3, r2
 801ef30:	d1eb      	bne.n	801ef0a <memchr+0x18>
	if (n && *s != c) {
 801ef32:	687b      	ldr	r3, [r7, #4]
 801ef34:	2b00      	cmp	r3, #0
 801ef36:	d031      	beq.n	801ef9c <memchr+0xaa>
 801ef38:	697b      	ldr	r3, [r7, #20]
 801ef3a:	781b      	ldrb	r3, [r3, #0]
 801ef3c:	461a      	mov	r2, r3
 801ef3e:	68bb      	ldr	r3, [r7, #8]
 801ef40:	4293      	cmp	r3, r2
 801ef42:	d02b      	beq.n	801ef9c <memchr+0xaa>
		typedef size_t __attribute__((__may_alias__)) word;
		const word *w;
		size_t k = ONES * c;
 801ef44:	68ba      	ldr	r2, [r7, #8]
 801ef46:	4613      	mov	r3, r2
 801ef48:	021b      	lsls	r3, r3, #8
 801ef4a:	4413      	add	r3, r2
 801ef4c:	041a      	lsls	r2, r3, #16
 801ef4e:	4413      	add	r3, r2
 801ef50:	61fb      	str	r3, [r7, #28]
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
 801ef52:	697b      	ldr	r3, [r7, #20]
 801ef54:	61bb      	str	r3, [r7, #24]
 801ef56:	e005      	b.n	801ef64 <memchr+0x72>
 801ef58:	69bb      	ldr	r3, [r7, #24]
 801ef5a:	3304      	adds	r3, #4
 801ef5c:	61bb      	str	r3, [r7, #24]
 801ef5e:	687b      	ldr	r3, [r7, #4]
 801ef60:	3b04      	subs	r3, #4
 801ef62:	607b      	str	r3, [r7, #4]
 801ef64:	687b      	ldr	r3, [r7, #4]
 801ef66:	2b03      	cmp	r3, #3
 801ef68:	d90f      	bls.n	801ef8a <memchr+0x98>
 801ef6a:	69bb      	ldr	r3, [r7, #24]
 801ef6c:	681a      	ldr	r2, [r3, #0]
 801ef6e:	69fb      	ldr	r3, [r7, #28]
 801ef70:	4053      	eors	r3, r2
 801ef72:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 801ef76:	69bb      	ldr	r3, [r7, #24]
 801ef78:	6819      	ldr	r1, [r3, #0]
 801ef7a:	69fb      	ldr	r3, [r7, #28]
 801ef7c:	404b      	eors	r3, r1
 801ef7e:	43db      	mvns	r3, r3
 801ef80:	4013      	ands	r3, r2
 801ef82:	f003 3380 	and.w	r3, r3, #2155905152	; 0x80808080
 801ef86:	2b00      	cmp	r3, #0
 801ef88:	d0e6      	beq.n	801ef58 <memchr+0x66>
		s = (const void *)w;
 801ef8a:	69bb      	ldr	r3, [r7, #24]
 801ef8c:	617b      	str	r3, [r7, #20]
	}
#endif
	for (; n && *s != c; s++, n--);
 801ef8e:	e005      	b.n	801ef9c <memchr+0xaa>
 801ef90:	697b      	ldr	r3, [r7, #20]
 801ef92:	3301      	adds	r3, #1
 801ef94:	617b      	str	r3, [r7, #20]
 801ef96:	687b      	ldr	r3, [r7, #4]
 801ef98:	3b01      	subs	r3, #1
 801ef9a:	607b      	str	r3, [r7, #4]
 801ef9c:	687b      	ldr	r3, [r7, #4]
 801ef9e:	2b00      	cmp	r3, #0
 801efa0:	d005      	beq.n	801efae <memchr+0xbc>
 801efa2:	697b      	ldr	r3, [r7, #20]
 801efa4:	781b      	ldrb	r3, [r3, #0]
 801efa6:	461a      	mov	r2, r3
 801efa8:	68bb      	ldr	r3, [r7, #8]
 801efaa:	4293      	cmp	r3, r2
 801efac:	d1f0      	bne.n	801ef90 <memchr+0x9e>
	return n ? (void *)s : 0;
 801efae:	687b      	ldr	r3, [r7, #4]
 801efb0:	2b00      	cmp	r3, #0
 801efb2:	d001      	beq.n	801efb8 <memchr+0xc6>
 801efb4:	697b      	ldr	r3, [r7, #20]
 801efb6:	e000      	b.n	801efba <memchr+0xc8>
 801efb8:	2300      	movs	r3, #0
}
 801efba:	4618      	mov	r0, r3
 801efbc:	3724      	adds	r7, #36	; 0x24
 801efbe:	46bd      	mov	sp, r7
 801efc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801efc4:	4770      	bx	lr
	...

0801efc8 <__month_to_secs>:
int __month_to_secs(int month, int is_leap)
{
 801efc8:	b480      	push	{r7}
 801efca:	b085      	sub	sp, #20
 801efcc:	af00      	add	r7, sp, #0
 801efce:	6078      	str	r0, [r7, #4]
 801efd0:	6039      	str	r1, [r7, #0]
	static const int secs_through_month[] = {
		0, 31*86400, 59*86400, 90*86400,
		120*86400, 151*86400, 181*86400, 212*86400,
		243*86400, 273*86400, 304*86400, 334*86400 };
	int t = secs_through_month[month];
 801efd2:	4a0b      	ldr	r2, [pc, #44]	; (801f000 <__month_to_secs+0x38>)
 801efd4:	687b      	ldr	r3, [r7, #4]
 801efd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801efda:	60fb      	str	r3, [r7, #12]
	if (is_leap && month >= 2) t+=86400;
 801efdc:	683b      	ldr	r3, [r7, #0]
 801efde:	2b00      	cmp	r3, #0
 801efe0:	d006      	beq.n	801eff0 <__month_to_secs+0x28>
 801efe2:	687b      	ldr	r3, [r7, #4]
 801efe4:	2b01      	cmp	r3, #1
 801efe6:	dd03      	ble.n	801eff0 <__month_to_secs+0x28>
 801efe8:	68fa      	ldr	r2, [r7, #12]
 801efea:	4b06      	ldr	r3, [pc, #24]	; (801f004 <__month_to_secs+0x3c>)
 801efec:	4413      	add	r3, r2
 801efee:	60fb      	str	r3, [r7, #12]
	return t;
 801eff0:	68fb      	ldr	r3, [r7, #12]
}
 801eff2:	4618      	mov	r0, r3
 801eff4:	3714      	adds	r7, #20
 801eff6:	46bd      	mov	sp, r7
 801eff8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801effc:	4770      	bx	lr
 801effe:	bf00      	nop
 801f000:	08024374 	.word	0x08024374
 801f004:	00015180 	.word	0x00015180

0801f008 <frexpl>:
#include "libm.h"

#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
long double frexpl(long double x, int *e)
{
 801f008:	b580      	push	{r7, lr}
 801f00a:	b084      	sub	sp, #16
 801f00c:	af00      	add	r7, sp, #0
 801f00e:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801f012:	607a      	str	r2, [r7, #4]
	return frexp(x, e);
 801f014:	687a      	ldr	r2, [r7, #4]
 801f016:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801f01a:	f000 f807 	bl	801f02c <frexp>
 801f01e:	4602      	mov	r2, r0
 801f020:	460b      	mov	r3, r1
}
 801f022:	4610      	mov	r0, r2
 801f024:	4619      	mov	r1, r3
 801f026:	3710      	adds	r7, #16
 801f028:	46bd      	mov	sp, r7
 801f02a:	bd80      	pop	{r7, pc}

0801f02c <frexp>:
#include <math.h>
#include <stdint.h>

double frexp(double x, int *e)
{
 801f02c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801f030:	b088      	sub	sp, #32
 801f032:	af00      	add	r7, sp, #0
 801f034:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801f038:	607a      	str	r2, [r7, #4]
	union { double d; uint64_t i; } y = { x };
 801f03a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801f03e:	e9c7 2306 	strd	r2, r3, [r7, #24]
	int ee = y.i>>52 & 0x7ff;
 801f042:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 801f046:	f04f 0200 	mov.w	r2, #0
 801f04a:	f04f 0300 	mov.w	r3, #0
 801f04e:	0d0a      	lsrs	r2, r1, #20
 801f050:	2300      	movs	r3, #0
 801f052:	4613      	mov	r3, r2
 801f054:	f3c3 030a 	ubfx	r3, r3, #0, #11
 801f058:	617b      	str	r3, [r7, #20]

	if (!ee) {
 801f05a:	697b      	ldr	r3, [r7, #20]
 801f05c:	2b00      	cmp	r3, #0
 801f05e:	d127      	bne.n	801f0b0 <frexp+0x84>
		if (x) {
 801f060:	f04f 0200 	mov.w	r2, #0
 801f064:	f04f 0300 	mov.w	r3, #0
 801f068:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801f06c:	f7e1 ffb4 	bl	8000fd8 <__aeabi_dcmpeq>
 801f070:	4603      	mov	r3, r0
 801f072:	2b00      	cmp	r3, #0
 801f074:	d116      	bne.n	801f0a4 <frexp+0x78>
			x = frexp(x*0x1p64, e);
 801f076:	f04f 0200 	mov.w	r2, #0
 801f07a:	4b23      	ldr	r3, [pc, #140]	; (801f108 <frexp+0xdc>)
 801f07c:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801f080:	f7e1 fa76 	bl	8000570 <__aeabi_dmul>
 801f084:	4602      	mov	r2, r0
 801f086:	460b      	mov	r3, r1
 801f088:	4610      	mov	r0, r2
 801f08a:	4619      	mov	r1, r3
 801f08c:	687a      	ldr	r2, [r7, #4]
 801f08e:	f7ff ffcd 	bl	801f02c <frexp>
 801f092:	e9c7 0102 	strd	r0, r1, [r7, #8]
			*e -= 64;
 801f096:	687b      	ldr	r3, [r7, #4]
 801f098:	681b      	ldr	r3, [r3, #0]
 801f09a:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
 801f09e:	687b      	ldr	r3, [r7, #4]
 801f0a0:	601a      	str	r2, [r3, #0]
 801f0a2:	e002      	b.n	801f0aa <frexp+0x7e>
		} else *e = 0;
 801f0a4:	687b      	ldr	r3, [r7, #4]
 801f0a6:	2200      	movs	r2, #0
 801f0a8:	601a      	str	r2, [r3, #0]
		return x;
 801f0aa:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801f0ae:	e024      	b.n	801f0fa <frexp+0xce>
	} else if (ee == 0x7ff) {
 801f0b0:	697b      	ldr	r3, [r7, #20]
 801f0b2:	f240 72ff 	movw	r2, #2047	; 0x7ff
 801f0b6:	4293      	cmp	r3, r2
 801f0b8:	d102      	bne.n	801f0c0 <frexp+0x94>
		return x;
 801f0ba:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801f0be:	e01c      	b.n	801f0fa <frexp+0xce>
	}

	*e = ee - 0x3fe;
 801f0c0:	697b      	ldr	r3, [r7, #20]
 801f0c2:	f2a3 32fe 	subw	r2, r3, #1022	; 0x3fe
 801f0c6:	687b      	ldr	r3, [r7, #4]
 801f0c8:	601a      	str	r2, [r3, #0]
	y.i &= 0x800fffffffffffffull;
 801f0ca:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801f0ce:	f04f 30ff 	mov.w	r0, #4294967295
 801f0d2:	490e      	ldr	r1, [pc, #56]	; (801f10c <frexp+0xe0>)
 801f0d4:	ea02 0800 	and.w	r8, r2, r0
 801f0d8:	ea03 0901 	and.w	r9, r3, r1
 801f0dc:	e9c7 8906 	strd	r8, r9, [r7, #24]
	y.i |= 0x3fe0000000000000ull;
 801f0e0:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801f0e4:	f04f 0000 	mov.w	r0, #0
 801f0e8:	4909      	ldr	r1, [pc, #36]	; (801f110 <frexp+0xe4>)
 801f0ea:	ea42 0400 	orr.w	r4, r2, r0
 801f0ee:	ea43 0501 	orr.w	r5, r3, r1
 801f0f2:	e9c7 4506 	strd	r4, r5, [r7, #24]
	return y.d;
 801f0f6:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
}
 801f0fa:	4610      	mov	r0, r2
 801f0fc:	4619      	mov	r1, r3
 801f0fe:	3720      	adds	r7, #32
 801f100:	46bd      	mov	sp, r7
 801f102:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 801f106:	bf00      	nop
 801f108:	43f00000 	.word	0x43f00000
 801f10c:	800fffff 	.word	0x800fffff
 801f110:	3fe00000 	.word	0x3fe00000

0801f114 <OsShellSourceInit>:
/* If not using console, then allocated shell struct will store in this global variable */
STATIC ShellCB *g_shellCB = NULL;
#endif

STATIC UINT32 OsShellSourceInit(VOID)
{
 801f114:	b580      	push	{r7, lr}
 801f116:	b082      	sub	sp, #8
 801f118:	af00      	add	r7, sp, #0
    UINT32 ret;

    if (g_shellSourceFlag) {
 801f11a:	4b10      	ldr	r3, [pc, #64]	; (801f15c <OsShellSourceInit+0x48>)
 801f11c:	681b      	ldr	r3, [r3, #0]
 801f11e:	2b00      	cmp	r3, #0
 801f120:	d001      	beq.n	801f126 <OsShellSourceInit+0x12>
        return LOS_OK;
 801f122:	2300      	movs	r3, #0
 801f124:	e015      	b.n	801f152 <OsShellSourceInit+0x3e>
    }

    ret = OsCmdInit();
 801f126:	f7f2 fc95 	bl	8011a54 <OsCmdInit>
 801f12a:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 801f12c:	687b      	ldr	r3, [r7, #4]
 801f12e:	2b00      	cmp	r3, #0
 801f130:	d001      	beq.n	801f136 <OsShellSourceInit+0x22>
        return ret;
 801f132:	687b      	ldr	r3, [r7, #4]
 801f134:	e00d      	b.n	801f152 <OsShellSourceInit+0x3e>
    }

    ret = OsShellSysCmdRegister();
 801f136:	f7f2 fa9f 	bl	8011678 <OsShellSysCmdRegister>
 801f13a:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 801f13c:	687b      	ldr	r3, [r7, #4]
 801f13e:	2b00      	cmp	r3, #0
 801f140:	d003      	beq.n	801f14a <OsShellSourceInit+0x36>
        OsCmdDeInit();
 801f142:	f7f2 fcb5 	bl	8011ab0 <OsCmdDeInit>
        return ret;
 801f146:	687b      	ldr	r3, [r7, #4]
 801f148:	e003      	b.n	801f152 <OsShellSourceInit+0x3e>
    }
    g_shellSourceFlag = TRUE;
 801f14a:	4b04      	ldr	r3, [pc, #16]	; (801f15c <OsShellSourceInit+0x48>)
 801f14c:	2201      	movs	r2, #1
 801f14e:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 801f150:	2300      	movs	r3, #0
}
 801f152:	4618      	mov	r0, r3
 801f154:	3708      	adds	r7, #8
 801f156:	46bd      	mov	sp, r7
 801f158:	bd80      	pop	{r7, pc}
 801f15a:	bf00      	nop
 801f15c:	20003490 	.word	0x20003490

0801f160 <OsShellSourceDeInit>:

STATIC VOID OsShellSourceDeInit(VOID)
{
 801f160:	b580      	push	{r7, lr}
 801f162:	af00      	add	r7, sp, #0
    OsCmdDeInit();
 801f164:	f7f2 fca4 	bl	8011ab0 <OsCmdDeInit>
    OsShellSysCmdUnregister();
 801f168:	f7f2 fae2 	bl	8011730 <OsShellSysCmdUnregister>
    g_shellSourceFlag = FALSE;
 801f16c:	4b02      	ldr	r3, [pc, #8]	; (801f178 <OsShellSourceDeInit+0x18>)
 801f16e:	2200      	movs	r2, #0
 801f170:	601a      	str	r2, [r3, #0]
}
 801f172:	bf00      	nop
 801f174:	bd80      	pop	{r7, pc}
 801f176:	bf00      	nop
 801f178:	20003490 	.word	0x20003490

0801f17c <OsShellCreateTask>:

STATIC UINT32 OsShellCreateTask(ShellCB *shellCB)
{
 801f17c:	b580      	push	{r7, lr}
 801f17e:	b084      	sub	sp, #16
 801f180:	af00      	add	r7, sp, #0
 801f182:	6078      	str	r0, [r7, #4]
    UINT32 ret = ShellTaskInit(shellCB);
 801f184:	6878      	ldr	r0, [r7, #4]
 801f186:	f7f3 ff87 	bl	8013098 <ShellTaskInit>
 801f18a:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 801f18c:	68fb      	ldr	r3, [r7, #12]
 801f18e:	2b00      	cmp	r3, #0
 801f190:	d001      	beq.n	801f196 <OsShellCreateTask+0x1a>
        return ret;
 801f192:	68fb      	ldr	r3, [r7, #12]
 801f194:	e00c      	b.n	801f1b0 <OsShellCreateTask+0x34>
    }

    ret = ShellEntryInit(shellCB);
 801f196:	6878      	ldr	r0, [r7, #4]
 801f198:	f7f3 ffc4 	bl	8013124 <ShellEntryInit>
 801f19c:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 801f19e:	68fb      	ldr	r3, [r7, #12]
 801f1a0:	2b00      	cmp	r3, #0
 801f1a2:	d004      	beq.n	801f1ae <OsShellCreateTask+0x32>
        (VOID)LOS_TaskDelete(shellCB->shellTaskHandle);
 801f1a4:	687b      	ldr	r3, [r7, #4]
 801f1a6:	685b      	ldr	r3, [r3, #4]
 801f1a8:	4618      	mov	r0, r3
 801f1aa:	f7e4 fbdd 	bl	8003968 <LOS_TaskDelete>
    }
    return ret;
 801f1ae:	68fb      	ldr	r3, [r7, #12]
}
 801f1b0:	4618      	mov	r0, r3
 801f1b2:	3710      	adds	r7, #16
 801f1b4:	46bd      	mov	sp, r7
 801f1b6:	bd80      	pop	{r7, pc}

0801f1b8 <OsShellConsoleInit>:

STATIC INLINE UINT32 OsShellConsoleInit(INT32 consoleId, ShellCB *shellCB)
{
 801f1b8:	b480      	push	{r7}
 801f1ba:	b083      	sub	sp, #12
 801f1bc:	af00      	add	r7, sp, #0
 801f1be:	6078      	str	r0, [r7, #4]
 801f1c0:	6039      	str	r1, [r7, #0]
    g_shellCB = shellCB;
 801f1c2:	4a05      	ldr	r2, [pc, #20]	; (801f1d8 <OsShellConsoleInit+0x20>)
 801f1c4:	683b      	ldr	r3, [r7, #0]
 801f1c6:	6013      	str	r3, [r2, #0]
    return LOS_OK;
 801f1c8:	2300      	movs	r3, #0
}
 801f1ca:	4618      	mov	r0, r3
 801f1cc:	370c      	adds	r7, #12
 801f1ce:	46bd      	mov	sp, r7
 801f1d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f1d4:	4770      	bx	lr
 801f1d6:	bf00      	nop
 801f1d8:	20003494 	.word	0x20003494

0801f1dc <OsShellConsoleDeinit>:

STATIC INLINE VOID OsShellConsoleDeinit(INT32 consoleId)
{
 801f1dc:	b480      	push	{r7}
 801f1de:	b083      	sub	sp, #12
 801f1e0:	af00      	add	r7, sp, #0
 801f1e2:	6078      	str	r0, [r7, #4]
    g_shellCB = NULL;
 801f1e4:	4b04      	ldr	r3, [pc, #16]	; (801f1f8 <OsShellConsoleDeinit+0x1c>)
 801f1e6:	2200      	movs	r2, #0
 801f1e8:	601a      	str	r2, [r3, #0]
}
 801f1ea:	bf00      	nop
 801f1ec:	370c      	adds	r7, #12
 801f1ee:	46bd      	mov	sp, r7
 801f1f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f1f4:	4770      	bx	lr
 801f1f6:	bf00      	nop
 801f1f8:	20003494 	.word	0x20003494

0801f1fc <OsShellInit>:

UINT32 OsShellInit(INT32 consoleId)
{
 801f1fc:	b580      	push	{r7, lr}
 801f1fe:	b084      	sub	sp, #16
 801f200:	af00      	add	r7, sp, #0
 801f202:	6078      	str	r0, [r7, #4]
    UINT32 ret = LOS_NOK;
 801f204:	2301      	movs	r3, #1
 801f206:	60bb      	str	r3, [r7, #8]
    ShellCB *shellCB = NULL;
 801f208:	2300      	movs	r3, #0
 801f20a:	60fb      	str	r3, [r7, #12]

    if (OsShellSourceInit() != LOS_OK) {
 801f20c:	f7ff ff82 	bl	801f114 <OsShellSourceInit>
 801f210:	4603      	mov	r3, r0
 801f212:	2b00      	cmp	r3, #0
 801f214:	d001      	beq.n	801f21a <OsShellInit+0x1e>
        return ret;
 801f216:	68bb      	ldr	r3, [r7, #8]
 801f218:	e06b      	b.n	801f2f2 <OsShellInit+0xf6>
    }

    shellCB = LOS_MemAlloc(m_aucSysMem0, sizeof(ShellCB));
 801f21a:	4b38      	ldr	r3, [pc, #224]	; (801f2fc <OsShellInit+0x100>)
 801f21c:	681b      	ldr	r3, [r3, #0]
 801f21e:	f44f 7112 	mov.w	r1, #584	; 0x248
 801f222:	4618      	mov	r0, r3
 801f224:	f7e9 fbc0 	bl	80089a8 <LOS_MemAlloc>
 801f228:	60f8      	str	r0, [r7, #12]
    if (shellCB == NULL) {
 801f22a:	68fb      	ldr	r3, [r7, #12]
 801f22c:	2b00      	cmp	r3, #0
 801f22e:	d05c      	beq.n	801f2ea <OsShellInit+0xee>
        goto ERR_OUT_SOURCE_DEINIT;
    }
    (VOID)memset_s(shellCB, sizeof(ShellCB), 0, sizeof(ShellCB));
 801f230:	f44f 7312 	mov.w	r3, #584	; 0x248
 801f234:	2200      	movs	r2, #0
 801f236:	f44f 7112 	mov.w	r1, #584	; 0x248
 801f23a:	68f8      	ldr	r0, [r7, #12]
 801f23c:	f7f6 ff26 	bl	801608c <memset_s>

    if (OsShellConsoleInit(consoleId, shellCB) != LOS_OK) {
 801f240:	68f9      	ldr	r1, [r7, #12]
 801f242:	6878      	ldr	r0, [r7, #4]
 801f244:	f7ff ffb8 	bl	801f1b8 <OsShellConsoleInit>
 801f248:	4603      	mov	r3, r0
 801f24a:	2b00      	cmp	r3, #0
 801f24c:	d145      	bne.n	801f2da <OsShellInit+0xde>
        goto ERR_OUT_FREE_MEM;
    }

    if (LOS_MuxCreate(&shellCB->keyMutex) != LOS_OK) {
 801f24e:	68fb      	ldr	r3, [r7, #12]
 801f250:	332c      	adds	r3, #44	; 0x2c
 801f252:	4618      	mov	r0, r3
 801f254:	f7eb fb8a 	bl	800a96c <LOS_MuxCreate>
 801f258:	4603      	mov	r3, r0
 801f25a:	2b00      	cmp	r3, #0
 801f25c:	d138      	bne.n	801f2d0 <OsShellInit+0xd4>
        goto ERR_OUT_DEINIT_CONSOLE;
    }

    if (LOS_MuxCreate(&shellCB->historyMutex) != LOS_OK) {
 801f25e:	68fb      	ldr	r3, [r7, #12]
 801f260:	3330      	adds	r3, #48	; 0x30
 801f262:	4618      	mov	r0, r3
 801f264:	f7eb fb82 	bl	800a96c <LOS_MuxCreate>
 801f268:	4603      	mov	r3, r0
 801f26a:	2b00      	cmp	r3, #0
 801f26c:	d129      	bne.n	801f2c2 <OsShellInit+0xc6>
        goto ERR_OUT_DELETE_KEY_MUX;
    }

    if (strncpy_s(shellCB->shellWorkingDirectory, PATH_MAX, "/", 1) != EOK) {
 801f26e:	68fb      	ldr	r3, [r7, #12]
 801f270:	f503 70a2 	add.w	r0, r3, #324	; 0x144
 801f274:	2301      	movs	r3, #1
 801f276:	4a22      	ldr	r2, [pc, #136]	; (801f300 <OsShellInit+0x104>)
 801f278:	f44f 7182 	mov.w	r1, #260	; 0x104
 801f27c:	f7f6 fff4 	bl	8016268 <strncpy_s>
 801f280:	4603      	mov	r3, r0
 801f282:	2b00      	cmp	r3, #0
 801f284:	d114      	bne.n	801f2b0 <OsShellInit+0xb4>
        goto ERR_OUT_DELETE_HISTORY_MUX;
    }

    ret = OsShellKeyInit(shellCB);
 801f286:	68f8      	ldr	r0, [r7, #12]
 801f288:	f7f2 f95c 	bl	8011544 <OsShellKeyInit>
 801f28c:	60b8      	str	r0, [r7, #8]
    if (ret != LOS_OK) {
 801f28e:	68bb      	ldr	r3, [r7, #8]
 801f290:	2b00      	cmp	r3, #0
 801f292:	d10f      	bne.n	801f2b4 <OsShellInit+0xb8>
        goto ERR_OUT_DELETE_HISTORY_MUX;
    }

    ret = OsShellCreateTask(shellCB);
 801f294:	68f8      	ldr	r0, [r7, #12]
 801f296:	f7ff ff71 	bl	801f17c <OsShellCreateTask>
 801f29a:	60b8      	str	r0, [r7, #8]
    if (ret != LOS_OK) {
 801f29c:	68bb      	ldr	r3, [r7, #8]
 801f29e:	2b00      	cmp	r3, #0
 801f2a0:	d101      	bne.n	801f2a6 <OsShellInit+0xaa>
        goto ERR_OUT_DEINIT_KEY;
    }

    return LOS_OK;
 801f2a2:	2300      	movs	r3, #0
 801f2a4:	e025      	b.n	801f2f2 <OsShellInit+0xf6>
        goto ERR_OUT_DEINIT_KEY;
 801f2a6:	bf00      	nop

ERR_OUT_DEINIT_KEY:
    OsShellKeyDeInit(shellCB);
 801f2a8:	68f8      	ldr	r0, [r7, #12]
 801f2aa:	f7f2 f9d3 	bl	8011654 <OsShellKeyDeInit>
 801f2ae:	e002      	b.n	801f2b6 <OsShellInit+0xba>
        goto ERR_OUT_DELETE_HISTORY_MUX;
 801f2b0:	bf00      	nop
 801f2b2:	e000      	b.n	801f2b6 <OsShellInit+0xba>
        goto ERR_OUT_DELETE_HISTORY_MUX;
 801f2b4:	bf00      	nop
ERR_OUT_DELETE_HISTORY_MUX:
    (VOID)LOS_MuxDelete(shellCB->historyMutex);
 801f2b6:	68fb      	ldr	r3, [r7, #12]
 801f2b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801f2ba:	4618      	mov	r0, r3
 801f2bc:	f7eb fbf0 	bl	800aaa0 <LOS_MuxDelete>
 801f2c0:	e000      	b.n	801f2c4 <OsShellInit+0xc8>
        goto ERR_OUT_DELETE_KEY_MUX;
 801f2c2:	bf00      	nop
ERR_OUT_DELETE_KEY_MUX:
    (VOID)LOS_MuxDelete(shellCB->keyMutex);
 801f2c4:	68fb      	ldr	r3, [r7, #12]
 801f2c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801f2c8:	4618      	mov	r0, r3
 801f2ca:	f7eb fbe9 	bl	800aaa0 <LOS_MuxDelete>
 801f2ce:	e000      	b.n	801f2d2 <OsShellInit+0xd6>
        goto ERR_OUT_DEINIT_CONSOLE;
 801f2d0:	bf00      	nop
ERR_OUT_DEINIT_CONSOLE:
    OsShellConsoleDeinit(consoleId);
 801f2d2:	6878      	ldr	r0, [r7, #4]
 801f2d4:	f7ff ff82 	bl	801f1dc <OsShellConsoleDeinit>
 801f2d8:	e000      	b.n	801f2dc <OsShellInit+0xe0>
        goto ERR_OUT_FREE_MEM;
 801f2da:	bf00      	nop
ERR_OUT_FREE_MEM:
    (VOID)LOS_MemFree((VOID *)m_aucSysMem0, shellCB);
 801f2dc:	4b07      	ldr	r3, [pc, #28]	; (801f2fc <OsShellInit+0x100>)
 801f2de:	681b      	ldr	r3, [r3, #0]
 801f2e0:	68f9      	ldr	r1, [r7, #12]
 801f2e2:	4618      	mov	r0, r3
 801f2e4:	f7e9 fc18 	bl	8008b18 <LOS_MemFree>
 801f2e8:	e000      	b.n	801f2ec <OsShellInit+0xf0>
        goto ERR_OUT_SOURCE_DEINIT;
 801f2ea:	bf00      	nop
ERR_OUT_SOURCE_DEINIT:
    OsShellSourceDeInit();
 801f2ec:	f7ff ff38 	bl	801f160 <OsShellSourceDeInit>

    return ret;
 801f2f0:	68bb      	ldr	r3, [r7, #8]
}
 801f2f2:	4618      	mov	r0, r3
 801f2f4:	3710      	adds	r7, #16
 801f2f6:	46bd      	mov	sp, r7
 801f2f8:	bd80      	pop	{r7, pc}
 801f2fa:	bf00      	nop
 801f2fc:	200021b4 	.word	0x200021b4
 801f300:	080232bc 	.word	0x080232bc

0801f304 <wctomb>:
#include <stdlib.h>
#include <wchar.h>

int wctomb(char *s, wchar_t wc)
{
 801f304:	b580      	push	{r7, lr}
 801f306:	b082      	sub	sp, #8
 801f308:	af00      	add	r7, sp, #0
 801f30a:	6078      	str	r0, [r7, #4]
 801f30c:	6039      	str	r1, [r7, #0]
	if (!s) return 0;
 801f30e:	687b      	ldr	r3, [r7, #4]
 801f310:	2b00      	cmp	r3, #0
 801f312:	d101      	bne.n	801f318 <wctomb+0x14>
 801f314:	2300      	movs	r3, #0
 801f316:	e005      	b.n	801f324 <wctomb+0x20>
	return wcrtomb(s, wc, 0);
 801f318:	2200      	movs	r2, #0
 801f31a:	6839      	ldr	r1, [r7, #0]
 801f31c:	6878      	ldr	r0, [r7, #4]
 801f31e:	f000 faa3 	bl	801f868 <wcrtomb>
 801f322:	4603      	mov	r3, r0
}
 801f324:	4618      	mov	r0, r3
 801f326:	3708      	adds	r7, #8
 801f328:	46bd      	mov	sp, r7
 801f32a:	bd80      	pop	{r7, pc}

0801f32c <LOS_ListInit>:
{
 801f32c:	b480      	push	{r7}
 801f32e:	b083      	sub	sp, #12
 801f330:	af00      	add	r7, sp, #0
 801f332:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 801f334:	687b      	ldr	r3, [r7, #4]
 801f336:	687a      	ldr	r2, [r7, #4]
 801f338:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 801f33a:	687b      	ldr	r3, [r7, #4]
 801f33c:	687a      	ldr	r2, [r7, #4]
 801f33e:	601a      	str	r2, [r3, #0]
}
 801f340:	bf00      	nop
 801f342:	370c      	adds	r7, #12
 801f344:	46bd      	mov	sp, r7
 801f346:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f34a:	4770      	bx	lr

0801f34c <ArchCurrCpuid>:
{
 801f34c:	b480      	push	{r7}
 801f34e:	af00      	add	r7, sp, #0
    return 0;
 801f350:	2300      	movs	r3, #0
}
 801f352:	4618      	mov	r0, r3
 801f354:	46bd      	mov	sp, r7
 801f356:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f35a:	4770      	bx	lr

0801f35c <LOS_IntLock>:
{
 801f35c:	b580      	push	{r7, lr}
 801f35e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 801f360:	f7e1 fcb2 	bl	8000cc8 <ArchIntLock>
 801f364:	4603      	mov	r3, r0
}
 801f366:	4618      	mov	r0, r3
 801f368:	bd80      	pop	{r7, pc}

0801f36a <LOS_IntRestore>:
{
 801f36a:	b580      	push	{r7, lr}
 801f36c:	b082      	sub	sp, #8
 801f36e:	af00      	add	r7, sp, #0
 801f370:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 801f372:	6878      	ldr	r0, [r7, #4]
 801f374:	f7e1 fcb0 	bl	8000cd8 <ArchIntRestore>
}
 801f378:	bf00      	nop
 801f37a:	3708      	adds	r7, #8
 801f37c:	46bd      	mov	sp, r7
 801f37e:	bd80      	pop	{r7, pc}

0801f380 <ArchCurrTaskGet>:
{
 801f380:	b480      	push	{r7}
 801f382:	af00      	add	r7, sp, #0
    return g_runTask;
 801f384:	4b03      	ldr	r3, [pc, #12]	; (801f394 <ArchCurrTaskGet+0x14>)
 801f386:	681b      	ldr	r3, [r3, #0]
}
 801f388:	4618      	mov	r0, r3
 801f38a:	46bd      	mov	sp, r7
 801f38c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f390:	4770      	bx	lr
 801f392:	bf00      	nop
 801f394:	200033bc 	.word	0x200033bc

0801f398 <OsPercpuGet>:
{
 801f398:	b580      	push	{r7, lr}
 801f39a:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 801f39c:	f7ff ffd6 	bl	801f34c <ArchCurrCpuid>
 801f3a0:	4602      	mov	r2, r0
 801f3a2:	4613      	mov	r3, r2
 801f3a4:	00db      	lsls	r3, r3, #3
 801f3a6:	4413      	add	r3, r2
 801f3a8:	009b      	lsls	r3, r3, #2
 801f3aa:	4a02      	ldr	r2, [pc, #8]	; (801f3b4 <OsPercpuGet+0x1c>)
 801f3ac:	4413      	add	r3, r2
}
 801f3ae:	4618      	mov	r0, r3
 801f3b0:	bd80      	pop	{r7, pc}
 801f3b2:	bf00      	nop
 801f3b4:	200036fc 	.word	0x200036fc

0801f3b8 <OsPreemptableInSched>:
{
 801f3b8:	b580      	push	{r7, lr}
 801f3ba:	b082      	sub	sp, #8
 801f3bc:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 801f3be:	2300      	movs	r3, #0
 801f3c0:	607b      	str	r3, [r7, #4]
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 801f3c2:	f7ff ffe9 	bl	801f398 <OsPercpuGet>
 801f3c6:	4603      	mov	r3, r0
 801f3c8:	695b      	ldr	r3, [r3, #20]
 801f3ca:	2b00      	cmp	r3, #0
 801f3cc:	bf0c      	ite	eq
 801f3ce:	2301      	moveq	r3, #1
 801f3d0:	2300      	movne	r3, #0
 801f3d2:	b2db      	uxtb	r3, r3
 801f3d4:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 801f3d6:	687b      	ldr	r3, [r7, #4]
 801f3d8:	2b00      	cmp	r3, #0
 801f3da:	d104      	bne.n	801f3e6 <OsPreemptableInSched+0x2e>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 801f3dc:	f7ff ffdc 	bl	801f398 <OsPercpuGet>
 801f3e0:	4603      	mov	r3, r0
 801f3e2:	2201      	movs	r2, #1
 801f3e4:	621a      	str	r2, [r3, #32]
    return preemptable;
 801f3e6:	687b      	ldr	r3, [r7, #4]
}
 801f3e8:	4618      	mov	r0, r3
 801f3ea:	3708      	adds	r7, #8
 801f3ec:	46bd      	mov	sp, r7
 801f3ee:	bd80      	pop	{r7, pc}

0801f3f0 <LOS_Schedule>:
{
 801f3f0:	b580      	push	{r7, lr}
 801f3f2:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 801f3f4:	f7e3 f83a 	bl	800246c <IntActive>
 801f3f8:	4603      	mov	r3, r0
 801f3fa:	2b00      	cmp	r3, #0
 801f3fc:	d005      	beq.n	801f40a <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 801f3fe:	f7ff ffcb 	bl	801f398 <OsPercpuGet>
 801f402:	4603      	mov	r3, r0
 801f404:	2201      	movs	r2, #1
 801f406:	621a      	str	r2, [r3, #32]
        return;
 801f408:	e001      	b.n	801f40e <LOS_Schedule+0x1e>
    OsSchedPreempt();
 801f40a:	f7e8 ff5d 	bl	80082c8 <OsSchedPreempt>
}
 801f40e:	bd80      	pop	{r7, pc}

0801f410 <LOS_SpinLockSave>:
{
 801f410:	b580      	push	{r7, lr}
 801f412:	b082      	sub	sp, #8
 801f414:	af00      	add	r7, sp, #0
 801f416:	6078      	str	r0, [r7, #4]
 801f418:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 801f41a:	f7ff ff9f 	bl	801f35c <LOS_IntLock>
 801f41e:	4602      	mov	r2, r0
 801f420:	683b      	ldr	r3, [r7, #0]
 801f422:	601a      	str	r2, [r3, #0]
}
 801f424:	bf00      	nop
 801f426:	3708      	adds	r7, #8
 801f428:	46bd      	mov	sp, r7
 801f42a:	bd80      	pop	{r7, pc}

0801f42c <LOS_SpinUnlockRestore>:
{
 801f42c:	b580      	push	{r7, lr}
 801f42e:	b082      	sub	sp, #8
 801f430:	af00      	add	r7, sp, #0
 801f432:	6078      	str	r0, [r7, #4]
 801f434:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 801f436:	6838      	ldr	r0, [r7, #0]
 801f438:	f7ff ff97 	bl	801f36a <LOS_IntRestore>
}
 801f43c:	bf00      	nop
 801f43e:	3708      	adds	r7, #8
 801f440:	46bd      	mov	sp, r7
 801f442:	bd80      	pop	{r7, pc}

0801f444 <OsCurrTaskGet>:
{
 801f444:	b580      	push	{r7, lr}
 801f446:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 801f448:	f7ff ff9a 	bl	801f380 <ArchCurrTaskGet>
 801f44c:	4603      	mov	r3, r0
}
 801f44e:	4618      	mov	r0, r3
 801f450:	bd80      	pop	{r7, pc}

0801f452 <OsMuxDlockNodeInsertHook>:
{
 801f452:	b580      	push	{r7, lr}
 801f454:	b082      	sub	sp, #8
 801f456:	af00      	add	r7, sp, #0
 801f458:	6078      	str	r0, [r7, #4]
 801f45a:	6039      	str	r1, [r7, #0]
    OsMuxDlockNodeInsert(taskId, muxCB);
 801f45c:	6839      	ldr	r1, [r7, #0]
 801f45e:	6878      	ldr	r0, [r7, #4]
 801f460:	f7e6 fd3e 	bl	8005ee0 <OsMuxDlockNodeInsert>
}
 801f464:	bf00      	nop
 801f466:	3708      	adds	r7, #8
 801f468:	46bd      	mov	sp, r7
 801f46a:	bd80      	pop	{r7, pc}

0801f46c <LOS_MpSchedule>:
{
 801f46c:	b480      	push	{r7}
 801f46e:	b083      	sub	sp, #12
 801f470:	af00      	add	r7, sp, #0
 801f472:	6078      	str	r0, [r7, #4]
}
 801f474:	bf00      	nop
 801f476:	370c      	adds	r7, #12
 801f478:	46bd      	mov	sp, r7
 801f47a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f47e:	4770      	bx	lr

0801f480 <CheckMutexAttr>:
    attr->type = (UINT8)((attr->type & ~MUTEXATTR_TYPE_MASK) | (UINT32)type);
    return ENOERR;
}

STATIC UINT32 CheckMutexAttr(const pthread_mutexattr_t *attr)
{
 801f480:	b480      	push	{r7}
 801f482:	b083      	sub	sp, #12
 801f484:	af00      	add	r7, sp, #0
 801f486:	6078      	str	r0, [r7, #4]
    if (((INT8)(attr->type) < PTHREAD_MUTEX_NORMAL) ||
 801f488:	687b      	ldr	r3, [r7, #4]
 801f48a:	789b      	ldrb	r3, [r3, #2]
 801f48c:	b25b      	sxtb	r3, r3
 801f48e:	2b00      	cmp	r3, #0
 801f490:	db03      	blt.n	801f49a <CheckMutexAttr+0x1a>
        (attr->type > PTHREAD_MUTEX_ERRORCHECK)) {
 801f492:	687b      	ldr	r3, [r7, #4]
 801f494:	789b      	ldrb	r3, [r3, #2]
    if (((INT8)(attr->type) < PTHREAD_MUTEX_NORMAL) ||
 801f496:	2b02      	cmp	r3, #2
 801f498:	d901      	bls.n	801f49e <CheckMutexAttr+0x1e>
        return LOS_NOK;
 801f49a:	2301      	movs	r3, #1
 801f49c:	e016      	b.n	801f4cc <CheckMutexAttr+0x4c>
    }
    if (((INT8)(attr->prioceiling) < OS_TASK_PRIORITY_HIGHEST) ||
 801f49e:	687b      	ldr	r3, [r7, #4]
 801f4a0:	785b      	ldrb	r3, [r3, #1]
 801f4a2:	b25b      	sxtb	r3, r3
 801f4a4:	2b00      	cmp	r3, #0
 801f4a6:	db03      	blt.n	801f4b0 <CheckMutexAttr+0x30>
        (attr->prioceiling > OS_TASK_PRIORITY_LOWEST)) {
 801f4a8:	687b      	ldr	r3, [r7, #4]
 801f4aa:	785b      	ldrb	r3, [r3, #1]
    if (((INT8)(attr->prioceiling) < OS_TASK_PRIORITY_HIGHEST) ||
 801f4ac:	2b1f      	cmp	r3, #31
 801f4ae:	d901      	bls.n	801f4b4 <CheckMutexAttr+0x34>
        return LOS_NOK;
 801f4b0:	2301      	movs	r3, #1
 801f4b2:	e00b      	b.n	801f4cc <CheckMutexAttr+0x4c>
    }
    if (((INT8)(attr->protocol) < PTHREAD_PRIO_NONE) ||
 801f4b4:	687b      	ldr	r3, [r7, #4]
 801f4b6:	781b      	ldrb	r3, [r3, #0]
 801f4b8:	b25b      	sxtb	r3, r3
 801f4ba:	2b00      	cmp	r3, #0
 801f4bc:	db03      	blt.n	801f4c6 <CheckMutexAttr+0x46>
        (attr->protocol > PTHREAD_PRIO_PROTECT)) {
 801f4be:	687b      	ldr	r3, [r7, #4]
 801f4c0:	781b      	ldrb	r3, [r3, #0]
    if (((INT8)(attr->protocol) < PTHREAD_PRIO_NONE) ||
 801f4c2:	2b02      	cmp	r3, #2
 801f4c4:	d901      	bls.n	801f4ca <CheckMutexAttr+0x4a>
        return LOS_NOK;
 801f4c6:	2301      	movs	r3, #1
 801f4c8:	e000      	b.n	801f4cc <CheckMutexAttr+0x4c>
    }
    return LOS_OK;
 801f4ca:	2300      	movs	r3, #0
}
 801f4cc:	4618      	mov	r0, r3
 801f4ce:	370c      	adds	r7, #12
 801f4d0:	46bd      	mov	sp, r7
 801f4d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f4d6:	4770      	bx	lr

0801f4d8 <OsMuxPreCheck>:
    SCHEDULER_UNLOCK(intSave);
    return ENOERR;
}

UINT32 OsMuxPreCheck(const pthread_mutex_t *mutex, const LosTaskCB *runTask)
{
 801f4d8:	b580      	push	{r7, lr}
 801f4da:	b082      	sub	sp, #8
 801f4dc:	af00      	add	r7, sp, #0
 801f4de:	6078      	str	r0, [r7, #4]
 801f4e0:	6039      	str	r1, [r7, #0]
    if (mutex == NULL) {
 801f4e2:	687b      	ldr	r3, [r7, #4]
 801f4e4:	2b00      	cmp	r3, #0
 801f4e6:	d101      	bne.n	801f4ec <OsMuxPreCheck+0x14>
        return EINVAL;
 801f4e8:	2316      	movs	r3, #22
 801f4ea:	e010      	b.n	801f50e <OsMuxPreCheck+0x36>
    }

    if (OS_INT_ACTIVE) {
 801f4ec:	f7e2 ffbe 	bl	800246c <IntActive>
 801f4f0:	4603      	mov	r3, r0
 801f4f2:	2b00      	cmp	r3, #0
 801f4f4:	d001      	beq.n	801f4fa <OsMuxPreCheck+0x22>
        return EPERM;
 801f4f6:	2301      	movs	r3, #1
 801f4f8:	e009      	b.n	801f50e <OsMuxPreCheck+0x36>
    /* DO NOT recommend to use blocking API in system tasks */
    if (runTask->taskFlags & OS_TASK_FLAG_SYSTEM) {
        PRINT_DEBUG("Warning: DO NOT recommend to use %s in system tasks.\n", __FUNCTION__);
    }

    if (CheckMutexAttr(&mutex->stAttr) != LOS_OK) {
 801f4fa:	687b      	ldr	r3, [r7, #4]
 801f4fc:	4618      	mov	r0, r3
 801f4fe:	f7ff ffbf 	bl	801f480 <CheckMutexAttr>
 801f502:	4603      	mov	r3, r0
 801f504:	2b00      	cmp	r3, #0
 801f506:	d001      	beq.n	801f50c <OsMuxPreCheck+0x34>
        return EINVAL;
 801f508:	2316      	movs	r3, #22
 801f50a:	e000      	b.n	801f50e <OsMuxPreCheck+0x36>
    }

    return ENOERR;
 801f50c:	2300      	movs	r3, #0
}
 801f50e:	4618      	mov	r0, r3
 801f510:	3708      	adds	r7, #8
 801f512:	46bd      	mov	sp, r7
 801f514:	bd80      	pop	{r7, pc}

0801f516 <pthread_mutex_lock>:

/* Lock mutex, waiting for it if necessary. */
int pthread_mutex_lock(pthread_mutex_t *mutex)
{
 801f516:	b580      	push	{r7, lr}
 801f518:	b086      	sub	sp, #24
 801f51a:	af00      	add	r7, sp, #0
 801f51c:	6078      	str	r0, [r7, #4]
    MuxBaseCB *muxPended = NULL;
 801f51e:	2300      	movs	r3, #0
 801f520:	60fb      	str	r3, [r7, #12]
    LosTaskCB *runTask = NULL;
 801f522:	2300      	movs	r3, #0
 801f524:	613b      	str	r3, [r7, #16]
    UINT32 ret;

    runTask = (LosTaskCB*)OsCurrTaskGet();
 801f526:	f7ff ff8d 	bl	801f444 <OsCurrTaskGet>
 801f52a:	6138      	str	r0, [r7, #16]
    ret = OsMuxPreCheck(mutex, runTask);
 801f52c:	6939      	ldr	r1, [r7, #16]
 801f52e:	6878      	ldr	r0, [r7, #4]
 801f530:	f7ff ffd2 	bl	801f4d8 <OsMuxPreCheck>
 801f534:	6178      	str	r0, [r7, #20]
    if (ret != ENOERR) {
 801f536:	697b      	ldr	r3, [r7, #20]
 801f538:	2b00      	cmp	r3, #0
 801f53a:	d001      	beq.n	801f540 <pthread_mutex_lock+0x2a>
        return (INT32)ret;
 801f53c:	697b      	ldr	r3, [r7, #20]
 801f53e:	e01b      	b.n	801f578 <pthread_mutex_lock+0x62>
    }

    muxPended = &mutex->stLock;
 801f540:	687b      	ldr	r3, [r7, #4]
 801f542:	3304      	adds	r3, #4
 801f544:	60fb      	str	r3, [r7, #12]
    if ((mutex->stAttr.type == PTHREAD_MUTEX_ERRORCHECK) &&
 801f546:	687b      	ldr	r3, [r7, #4]
 801f548:	789b      	ldrb	r3, [r3, #2]
 801f54a:	2b02      	cmp	r3, #2
 801f54c:	d10a      	bne.n	801f564 <pthread_mutex_lock+0x4e>
        (muxPended->muxCount != 0) &&
 801f54e:	68fb      	ldr	r3, [r7, #12]
 801f550:	899b      	ldrh	r3, [r3, #12]
    if ((mutex->stAttr.type == PTHREAD_MUTEX_ERRORCHECK) &&
 801f552:	2b00      	cmp	r3, #0
 801f554:	d006      	beq.n	801f564 <pthread_mutex_lock+0x4e>
        (muxPended->owner == runTask)) {
 801f556:	68fb      	ldr	r3, [r7, #12]
 801f558:	689b      	ldr	r3, [r3, #8]
        (muxPended->muxCount != 0) &&
 801f55a:	693a      	ldr	r2, [r7, #16]
 801f55c:	429a      	cmp	r2, r3
 801f55e:	d101      	bne.n	801f564 <pthread_mutex_lock+0x4e>
        return EDEADLK;
 801f560:	2323      	movs	r3, #35	; 0x23
 801f562:	e009      	b.n	801f578 <pthread_mutex_lock+0x62>
    }

    ret = OsMuxPendForPosix(mutex, LOS_WAIT_FOREVER);
 801f564:	f04f 31ff 	mov.w	r1, #4294967295
 801f568:	6878      	ldr	r0, [r7, #4]
 801f56a:	f000 f84d 	bl	801f608 <OsMuxPendForPosix>
 801f56e:	6178      	str	r0, [r7, #20]
    return map_errno(ret);
 801f570:	6978      	ldr	r0, [r7, #20]
 801f572:	f000 fa49 	bl	801fa08 <map_errno>
 801f576:	4603      	mov	r3, r0
}
 801f578:	4618      	mov	r0, r3
 801f57a:	3718      	adds	r7, #24
 801f57c:	46bd      	mov	sp, r7
 801f57e:	bd80      	pop	{r7, pc}

0801f580 <pthread_mutex_unlock>:
    ret = OsMuxPendForPosix(mutex, 0);
    return map_errno(ret);
}

int pthread_mutex_unlock(pthread_mutex_t *mutex)
{
 801f580:	b580      	push	{r7, lr}
 801f582:	b084      	sub	sp, #16
 801f584:	af00      	add	r7, sp, #0
 801f586:	6078      	str	r0, [r7, #4]
    LosTaskCB *runTask = NULL;
 801f588:	2300      	movs	r3, #0
 801f58a:	60bb      	str	r3, [r7, #8]
    UINT32 ret;

    runTask = (LosTaskCB*)OsCurrTaskGet();
 801f58c:	f7ff ff5a 	bl	801f444 <OsCurrTaskGet>
 801f590:	60b8      	str	r0, [r7, #8]
    ret = OsMuxPreCheck(mutex, runTask);
 801f592:	68b9      	ldr	r1, [r7, #8]
 801f594:	6878      	ldr	r0, [r7, #4]
 801f596:	f7ff ff9f 	bl	801f4d8 <OsMuxPreCheck>
 801f59a:	60f8      	str	r0, [r7, #12]
    if (ret != ENOERR) {
 801f59c:	68fb      	ldr	r3, [r7, #12]
 801f59e:	2b00      	cmp	r3, #0
 801f5a0:	d001      	beq.n	801f5a6 <pthread_mutex_unlock+0x26>
        return (INT32)ret;
 801f5a2:	68fb      	ldr	r3, [r7, #12]
 801f5a4:	e003      	b.n	801f5ae <pthread_mutex_unlock+0x2e>
    }

    return OsMuxPostForPosix(mutex);
 801f5a6:	6878      	ldr	r0, [r7, #4]
 801f5a8:	f000 f8da 	bl	801f760 <OsMuxPostForPosix>
 801f5ac:	4603      	mov	r3, r0
}
 801f5ae:	4618      	mov	r0, r3
 801f5b0:	3710      	adds	r7, #16
 801f5b2:	46bd      	mov	sp, r7
 801f5b4:	bd80      	pop	{r7, pc}

0801f5b6 <OsMuxBitmapSet>:

STATIC VOID OsMuxBitmapSet(const pthread_mutex_t *mutex, const LosTaskCB *runTask, const MuxBaseCB *muxPended)
{
 801f5b6:	b580      	push	{r7, lr}
 801f5b8:	b084      	sub	sp, #16
 801f5ba:	af00      	add	r7, sp, #0
 801f5bc:	60f8      	str	r0, [r7, #12]
 801f5be:	60b9      	str	r1, [r7, #8]
 801f5c0:	607a      	str	r2, [r7, #4]
    if ((muxPended->owner->priority > runTask->priority) &&
 801f5c2:	687b      	ldr	r3, [r7, #4]
 801f5c4:	689b      	ldr	r3, [r3, #8]
 801f5c6:	88da      	ldrh	r2, [r3, #6]
 801f5c8:	68bb      	ldr	r3, [r7, #8]
 801f5ca:	88db      	ldrh	r3, [r3, #6]
 801f5cc:	429a      	cmp	r2, r3
 801f5ce:	d916      	bls.n	801f5fe <OsMuxBitmapSet+0x48>
        (mutex->stAttr.protocol == PTHREAD_PRIO_INHERIT)) {
 801f5d0:	68fb      	ldr	r3, [r7, #12]
 801f5d2:	781b      	ldrb	r3, [r3, #0]
    if ((muxPended->owner->priority > runTask->priority) &&
 801f5d4:	2b01      	cmp	r3, #1
 801f5d6:	d112      	bne.n	801f5fe <OsMuxBitmapSet+0x48>
        LOS_BitmapSet(&(muxPended->owner->priBitMap), muxPended->owner->priority);
 801f5d8:	687b      	ldr	r3, [r7, #4]
 801f5da:	689b      	ldr	r3, [r3, #8]
 801f5dc:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 801f5e0:	687b      	ldr	r3, [r7, #4]
 801f5e2:	689b      	ldr	r3, [r3, #8]
 801f5e4:	88db      	ldrh	r3, [r3, #6]
 801f5e6:	4619      	mov	r1, r3
 801f5e8:	4610      	mov	r0, r2
 801f5ea:	f7eb fea7 	bl	800b33c <LOS_BitmapSet>
        OsTaskPriModify(muxPended->owner, runTask->priority);
 801f5ee:	687b      	ldr	r3, [r7, #4]
 801f5f0:	689a      	ldr	r2, [r3, #8]
 801f5f2:	68bb      	ldr	r3, [r7, #8]
 801f5f4:	88db      	ldrh	r3, [r3, #6]
 801f5f6:	4619      	mov	r1, r3
 801f5f8:	4610      	mov	r0, r2
 801f5fa:	f7e3 fac9 	bl	8002b90 <OsTaskPriModify>
    }
}
 801f5fe:	bf00      	nop
 801f600:	3710      	adds	r7, #16
 801f602:	46bd      	mov	sp, r7
 801f604:	bd80      	pop	{r7, pc}
	...

0801f608 <OsMuxPendForPosix>:

STATIC UINT32 OsMuxPendForPosix(pthread_mutex_t *mutex, UINT32 timeout)
{
 801f608:	b580      	push	{r7, lr}
 801f60a:	b088      	sub	sp, #32
 801f60c:	af00      	add	r7, sp, #0
 801f60e:	6078      	str	r0, [r7, #4]
 801f610:	6039      	str	r1, [r7, #0]
 801f612:	4b50      	ldr	r3, [pc, #320]	; (801f754 <OsMuxPendForPosix+0x14c>)
 801f614:	681b      	ldr	r3, [r3, #0]
 801f616:	61fb      	str	r3, [r7, #28]
 801f618:	f04f 0300 	mov.w	r3, #0
    UINT32 retErr;
    UINT32 intSave;
    MuxBaseCB *muxPended = &mutex->stLock;
 801f61c:	687b      	ldr	r3, [r7, #4]
 801f61e:	3304      	adds	r3, #4
 801f620:	617b      	str	r3, [r7, #20]
    LosTaskCB *runTask = NULL;
 801f622:	2300      	movs	r3, #0
 801f624:	61bb      	str	r3, [r7, #24]

    SCHEDULER_LOCK(intSave);
 801f626:	f107 030c 	add.w	r3, r7, #12
 801f62a:	4619      	mov	r1, r3
 801f62c:	484a      	ldr	r0, [pc, #296]	; (801f758 <OsMuxPendForPosix+0x150>)
 801f62e:	f7ff feef 	bl	801f410 <LOS_SpinLockSave>
    if ((muxPended->muxList.pstPrev == NULL) ||
 801f632:	697b      	ldr	r3, [r7, #20]
 801f634:	681b      	ldr	r3, [r3, #0]
 801f636:	2b00      	cmp	r3, #0
 801f638:	d003      	beq.n	801f642 <OsMuxPendForPosix+0x3a>
        (muxPended->muxList.pstNext == NULL)) {
 801f63a:	697b      	ldr	r3, [r7, #20]
 801f63c:	685b      	ldr	r3, [r3, #4]
    if ((muxPended->muxList.pstPrev == NULL) ||
 801f63e:	2b00      	cmp	r3, #0
 801f640:	d109      	bne.n	801f656 <OsMuxPendForPosix+0x4e>
        /* This is for mutex macro initialization. */
        muxPended->muxCount = 0;
 801f642:	697b      	ldr	r3, [r7, #20]
 801f644:	2200      	movs	r2, #0
 801f646:	819a      	strh	r2, [r3, #12]
        muxPended->owner = NULL;
 801f648:	697b      	ldr	r3, [r7, #20]
 801f64a:	2200      	movs	r2, #0
 801f64c:	609a      	str	r2, [r3, #8]
        LOS_ListInit(&muxPended->muxList);
 801f64e:	697b      	ldr	r3, [r7, #20]
 801f650:	4618      	mov	r0, r3
 801f652:	f7ff fe6b 	bl	801f32c <LOS_ListInit>
    }
    runTask = OsCurrTaskGet();
 801f656:	f7ff fef5 	bl	801f444 <OsCurrTaskGet>
 801f65a:	61b8      	str	r0, [r7, #24]
    if (muxPended->muxCount == 0) {
 801f65c:	697b      	ldr	r3, [r7, #20]
 801f65e:	899b      	ldrh	r3, [r3, #12]
 801f660:	2b00      	cmp	r3, #0
 801f662:	d130      	bne.n	801f6c6 <OsMuxPendForPosix+0xbe>
        muxPended->muxCount++;
 801f664:	697b      	ldr	r3, [r7, #20]
 801f666:	899b      	ldrh	r3, [r3, #12]
 801f668:	3301      	adds	r3, #1
 801f66a:	b29a      	uxth	r2, r3
 801f66c:	697b      	ldr	r3, [r7, #20]
 801f66e:	819a      	strh	r2, [r3, #12]
        muxPended->owner = runTask;
 801f670:	697b      	ldr	r3, [r7, #20]
 801f672:	69ba      	ldr	r2, [r7, #24]
 801f674:	609a      	str	r2, [r3, #8]
        OsMuxDlockNodeInsertHook(runTask->taskId, muxPended);
 801f676:	69bb      	ldr	r3, [r7, #24]
 801f678:	695b      	ldr	r3, [r3, #20]
 801f67a:	6979      	ldr	r1, [r7, #20]
 801f67c:	4618      	mov	r0, r3
 801f67e:	f7ff fee8 	bl	801f452 <OsMuxDlockNodeInsertHook>

        if ((runTask->priority > mutex->stAttr.prioceiling) &&
 801f682:	69bb      	ldr	r3, [r7, #24]
 801f684:	88da      	ldrh	r2, [r3, #6]
 801f686:	687b      	ldr	r3, [r7, #4]
 801f688:	785b      	ldrb	r3, [r3, #1]
 801f68a:	b29b      	uxth	r3, r3
 801f68c:	429a      	cmp	r2, r3
 801f68e:	d913      	bls.n	801f6b8 <OsMuxPendForPosix+0xb0>
            (mutex->stAttr.protocol == PTHREAD_PRIO_PROTECT)) {
 801f690:	687b      	ldr	r3, [r7, #4]
 801f692:	781b      	ldrb	r3, [r3, #0]
        if ((runTask->priority > mutex->stAttr.prioceiling) &&
 801f694:	2b02      	cmp	r3, #2
 801f696:	d10f      	bne.n	801f6b8 <OsMuxPendForPosix+0xb0>
            LOS_BitmapSet(&runTask->priBitMap, runTask->priority);
 801f698:	69bb      	ldr	r3, [r7, #24]
 801f69a:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 801f69e:	69bb      	ldr	r3, [r7, #24]
 801f6a0:	88db      	ldrh	r3, [r3, #6]
 801f6a2:	4619      	mov	r1, r3
 801f6a4:	4610      	mov	r0, r2
 801f6a6:	f7eb fe49 	bl	800b33c <LOS_BitmapSet>
            OsTaskPriModify(runTask, mutex->stAttr.prioceiling);
 801f6aa:	687b      	ldr	r3, [r7, #4]
 801f6ac:	785b      	ldrb	r3, [r3, #1]
 801f6ae:	b29b      	uxth	r3, r3
 801f6b0:	4619      	mov	r1, r3
 801f6b2:	69b8      	ldr	r0, [r7, #24]
 801f6b4:	f7e3 fa6c 	bl	8002b90 <OsTaskPriModify>
        }

        SCHEDULER_UNLOCK(intSave);
 801f6b8:	68fb      	ldr	r3, [r7, #12]
 801f6ba:	4619      	mov	r1, r3
 801f6bc:	4826      	ldr	r0, [pc, #152]	; (801f758 <OsMuxPendForPosix+0x150>)
 801f6be:	f7ff feb5 	bl	801f42c <LOS_SpinUnlockRestore>
        return LOS_OK;
 801f6c2:	2300      	movs	r3, #0
 801f6c4:	e03b      	b.n	801f73e <OsMuxPendForPosix+0x136>
    }

    if ((muxPended->owner == runTask) &&
 801f6c6:	697b      	ldr	r3, [r7, #20]
 801f6c8:	689b      	ldr	r3, [r3, #8]
 801f6ca:	69ba      	ldr	r2, [r7, #24]
 801f6cc:	429a      	cmp	r2, r3
 801f6ce:	d110      	bne.n	801f6f2 <OsMuxPendForPosix+0xea>
        (mutex->stAttr.type == PTHREAD_MUTEX_RECURSIVE)) {
 801f6d0:	687b      	ldr	r3, [r7, #4]
 801f6d2:	789b      	ldrb	r3, [r3, #2]
    if ((muxPended->owner == runTask) &&
 801f6d4:	2b01      	cmp	r3, #1
 801f6d6:	d10c      	bne.n	801f6f2 <OsMuxPendForPosix+0xea>
        muxPended->muxCount++;
 801f6d8:	697b      	ldr	r3, [r7, #20]
 801f6da:	899b      	ldrh	r3, [r3, #12]
 801f6dc:	3301      	adds	r3, #1
 801f6de:	b29a      	uxth	r2, r3
 801f6e0:	697b      	ldr	r3, [r7, #20]
 801f6e2:	819a      	strh	r2, [r3, #12]
        SCHEDULER_UNLOCK(intSave);
 801f6e4:	68fb      	ldr	r3, [r7, #12]
 801f6e6:	4619      	mov	r1, r3
 801f6e8:	481b      	ldr	r0, [pc, #108]	; (801f758 <OsMuxPendForPosix+0x150>)
 801f6ea:	f7ff fe9f 	bl	801f42c <LOS_SpinUnlockRestore>
        return LOS_OK;
 801f6ee:	2300      	movs	r3, #0
 801f6f0:	e025      	b.n	801f73e <OsMuxPendForPosix+0x136>
    }

    if (!OsPreemptableInSched()) {
 801f6f2:	f7ff fe61 	bl	801f3b8 <OsPreemptableInSched>
 801f6f6:	4603      	mov	r3, r0
 801f6f8:	2b00      	cmp	r3, #0
 801f6fa:	d102      	bne.n	801f702 <OsMuxPendForPosix+0xfa>
        retErr = LOS_ERRNO_MUX_PEND_IN_LOCK;
 801f6fc:	4b17      	ldr	r3, [pc, #92]	; (801f75c <OsMuxPendForPosix+0x154>)
 801f6fe:	613b      	str	r3, [r7, #16]
        goto LOS_ERREND;
 801f700:	e017      	b.n	801f732 <OsMuxPendForPosix+0x12a>
    }

    OsMuxBitmapSet(mutex, runTask, muxPended);
 801f702:	697a      	ldr	r2, [r7, #20]
 801f704:	69b9      	ldr	r1, [r7, #24]
 801f706:	6878      	ldr	r0, [r7, #4]
 801f708:	f7ff ff55 	bl	801f5b6 <OsMuxBitmapSet>
    retErr = OsMuxPendOp(runTask, muxPended, timeout, &intSave);
 801f70c:	f107 030c 	add.w	r3, r7, #12
 801f710:	683a      	ldr	r2, [r7, #0]
 801f712:	6979      	ldr	r1, [r7, #20]
 801f714:	69b8      	ldr	r0, [r7, #24]
 801f716:	f7eb fb8b 	bl	800ae30 <OsMuxPendOp>
 801f71a:	6138      	str	r0, [r7, #16]
    if (retErr != LOS_OK) {
 801f71c:	693b      	ldr	r3, [r7, #16]
 801f71e:	2b00      	cmp	r3, #0
 801f720:	d106      	bne.n	801f730 <OsMuxPendForPosix+0x128>
        goto LOS_ERREND;
    }

    SCHEDULER_UNLOCK(intSave);
 801f722:	68fb      	ldr	r3, [r7, #12]
 801f724:	4619      	mov	r1, r3
 801f726:	480c      	ldr	r0, [pc, #48]	; (801f758 <OsMuxPendForPosix+0x150>)
 801f728:	f7ff fe80 	bl	801f42c <LOS_SpinUnlockRestore>
    return LOS_OK;
 801f72c:	2300      	movs	r3, #0
 801f72e:	e006      	b.n	801f73e <OsMuxPendForPosix+0x136>
        goto LOS_ERREND;
 801f730:	bf00      	nop

LOS_ERREND:
    SCHEDULER_UNLOCK(intSave);
 801f732:	68fb      	ldr	r3, [r7, #12]
 801f734:	4619      	mov	r1, r3
 801f736:	4808      	ldr	r0, [pc, #32]	; (801f758 <OsMuxPendForPosix+0x150>)
 801f738:	f7ff fe78 	bl	801f42c <LOS_SpinUnlockRestore>
    return retErr;
 801f73c:	693b      	ldr	r3, [r7, #16]
}
 801f73e:	4a05      	ldr	r2, [pc, #20]	; (801f754 <OsMuxPendForPosix+0x14c>)
 801f740:	6811      	ldr	r1, [r2, #0]
 801f742:	69fa      	ldr	r2, [r7, #28]
 801f744:	4051      	eors	r1, r2
 801f746:	d001      	beq.n	801f74c <OsMuxPendForPosix+0x144>
 801f748:	f7e4 fe4e 	bl	80043e8 <__stack_chk_fail>
 801f74c:	4618      	mov	r0, r3
 801f74e:	3720      	adds	r7, #32
 801f750:	46bd      	mov	sp, r7
 801f752:	bd80      	pop	{r7, pc}
 801f754:	080232c8 	.word	0x080232c8
 801f758:	20000764 	.word	0x20000764
 801f75c:	02001d06 	.word	0x02001d06

0801f760 <OsMuxPostForPosix>:

STATIC INT32 OsMuxPostForPosix(pthread_mutex_t *mutex)
{
 801f760:	b580      	push	{r7, lr}
 801f762:	b088      	sub	sp, #32
 801f764:	af00      	add	r7, sp, #0
 801f766:	6078      	str	r0, [r7, #4]
 801f768:	4b3d      	ldr	r3, [pc, #244]	; (801f860 <OsMuxPostForPosix+0x100>)
 801f76a:	681b      	ldr	r3, [r3, #0]
 801f76c:	61fb      	str	r3, [r7, #28]
 801f76e:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 ret;
    UINT16 bitMapPri;
    MuxBaseCB *muxPosted = &mutex->stLock;
 801f772:	687b      	ldr	r3, [r7, #4]
 801f774:	3304      	adds	r3, #4
 801f776:	613b      	str	r3, [r7, #16]
    LosTaskCB *runTask = NULL;
 801f778:	2300      	movs	r3, #0
 801f77a:	617b      	str	r3, [r7, #20]

    SCHEDULER_LOCK(intSave);
 801f77c:	f107 030c 	add.w	r3, r7, #12
 801f780:	4619      	mov	r1, r3
 801f782:	4838      	ldr	r0, [pc, #224]	; (801f864 <OsMuxPostForPosix+0x104>)
 801f784:	f7ff fe44 	bl	801f410 <LOS_SpinLockSave>

    if (muxPosted->muxCount == 0) {
 801f788:	693b      	ldr	r3, [r7, #16]
 801f78a:	899b      	ldrh	r3, [r3, #12]
 801f78c:	2b00      	cmp	r3, #0
 801f78e:	d106      	bne.n	801f79e <OsMuxPostForPosix+0x3e>
        SCHEDULER_UNLOCK(intSave);
 801f790:	68fb      	ldr	r3, [r7, #12]
 801f792:	4619      	mov	r1, r3
 801f794:	4833      	ldr	r0, [pc, #204]	; (801f864 <OsMuxPostForPosix+0x104>)
 801f796:	f7ff fe49 	bl	801f42c <LOS_SpinUnlockRestore>
        return EPERM;
 801f79a:	2301      	movs	r3, #1
 801f79c:	e054      	b.n	801f848 <OsMuxPostForPosix+0xe8>
    }

    runTask = OsCurrTaskGet();
 801f79e:	f7ff fe51 	bl	801f444 <OsCurrTaskGet>
 801f7a2:	6178      	str	r0, [r7, #20]
    if (muxPosted->owner != runTask) {
 801f7a4:	693b      	ldr	r3, [r7, #16]
 801f7a6:	689b      	ldr	r3, [r3, #8]
 801f7a8:	697a      	ldr	r2, [r7, #20]
 801f7aa:	429a      	cmp	r2, r3
 801f7ac:	d006      	beq.n	801f7bc <OsMuxPostForPosix+0x5c>
        SCHEDULER_UNLOCK(intSave);
 801f7ae:	68fb      	ldr	r3, [r7, #12]
 801f7b0:	4619      	mov	r1, r3
 801f7b2:	482c      	ldr	r0, [pc, #176]	; (801f864 <OsMuxPostForPosix+0x104>)
 801f7b4:	f7ff fe3a 	bl	801f42c <LOS_SpinUnlockRestore>
        return EPERM;
 801f7b8:	2301      	movs	r3, #1
 801f7ba:	e045      	b.n	801f848 <OsMuxPostForPosix+0xe8>
    }

    if ((--muxPosted->muxCount != 0) &&
 801f7bc:	693b      	ldr	r3, [r7, #16]
 801f7be:	899b      	ldrh	r3, [r3, #12]
 801f7c0:	3b01      	subs	r3, #1
 801f7c2:	b29a      	uxth	r2, r3
 801f7c4:	693b      	ldr	r3, [r7, #16]
 801f7c6:	819a      	strh	r2, [r3, #12]
 801f7c8:	693b      	ldr	r3, [r7, #16]
 801f7ca:	899b      	ldrh	r3, [r3, #12]
 801f7cc:	2b00      	cmp	r3, #0
 801f7ce:	d00a      	beq.n	801f7e6 <OsMuxPostForPosix+0x86>
        (mutex->stAttr.type == PTHREAD_MUTEX_RECURSIVE)) {
 801f7d0:	687b      	ldr	r3, [r7, #4]
 801f7d2:	789b      	ldrb	r3, [r3, #2]
    if ((--muxPosted->muxCount != 0) &&
 801f7d4:	2b01      	cmp	r3, #1
 801f7d6:	d106      	bne.n	801f7e6 <OsMuxPostForPosix+0x86>
        SCHEDULER_UNLOCK(intSave);
 801f7d8:	68fb      	ldr	r3, [r7, #12]
 801f7da:	4619      	mov	r1, r3
 801f7dc:	4821      	ldr	r0, [pc, #132]	; (801f864 <OsMuxPostForPosix+0x104>)
 801f7de:	f7ff fe25 	bl	801f42c <LOS_SpinUnlockRestore>
        return ENOERR;
 801f7e2:	2300      	movs	r3, #0
 801f7e4:	e030      	b.n	801f848 <OsMuxPostForPosix+0xe8>
    }

    if (mutex->stAttr.protocol == PTHREAD_PRIO_PROTECT) {
 801f7e6:	687b      	ldr	r3, [r7, #4]
 801f7e8:	781b      	ldrb	r3, [r3, #0]
 801f7ea:	2b02      	cmp	r3, #2
 801f7ec:	d115      	bne.n	801f81a <OsMuxPostForPosix+0xba>
        bitMapPri = LOS_HighBitGet(runTask->priBitMap);
 801f7ee:	697b      	ldr	r3, [r7, #20]
 801f7f0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801f7f2:	4618      	mov	r0, r3
 801f7f4:	f7eb fdd9 	bl	800b3aa <LOS_HighBitGet>
 801f7f8:	4603      	mov	r3, r0
 801f7fa:	817b      	strh	r3, [r7, #10]
        if (bitMapPri != LOS_INVALID_BIT_INDEX) {
 801f7fc:	897b      	ldrh	r3, [r7, #10]
 801f7fe:	2b20      	cmp	r3, #32
 801f800:	d00b      	beq.n	801f81a <OsMuxPostForPosix+0xba>
            LOS_BitmapClr(&runTask->priBitMap, bitMapPri);
 801f802:	697b      	ldr	r3, [r7, #20]
 801f804:	336c      	adds	r3, #108	; 0x6c
 801f806:	897a      	ldrh	r2, [r7, #10]
 801f808:	4611      	mov	r1, r2
 801f80a:	4618      	mov	r0, r3
 801f80c:	f7eb fdb1 	bl	800b372 <LOS_BitmapClr>
            OsTaskPriModify(runTask, bitMapPri);
 801f810:	897b      	ldrh	r3, [r7, #10]
 801f812:	4619      	mov	r1, r3
 801f814:	6978      	ldr	r0, [r7, #20]
 801f816:	f7e3 f9bb 	bl	8002b90 <OsTaskPriModify>
        }
    }

    /* Whether a task block the mutex lock. */
    ret = OsMuxPostOp(runTask, (MuxBaseCB *)muxPosted);
 801f81a:	6939      	ldr	r1, [r7, #16]
 801f81c:	6978      	ldr	r0, [r7, #20]
 801f81e:	f7eb fc70 	bl	800b102 <OsMuxPostOp>
 801f822:	61b8      	str	r0, [r7, #24]
    SCHEDULER_UNLOCK(intSave);
 801f824:	68fb      	ldr	r3, [r7, #12]
 801f826:	4619      	mov	r1, r3
 801f828:	480e      	ldr	r0, [pc, #56]	; (801f864 <OsMuxPostForPosix+0x104>)
 801f82a:	f7ff fdff 	bl	801f42c <LOS_SpinUnlockRestore>
    if ((ret == MUX_SCHEDULE) ||
 801f82e:	69bb      	ldr	r3, [r7, #24]
 801f830:	2b01      	cmp	r3, #1
 801f832:	d003      	beq.n	801f83c <OsMuxPostForPosix+0xdc>
        (mutex->stAttr.protocol == PTHREAD_PRIO_PROTECT)) {
 801f834:	687b      	ldr	r3, [r7, #4]
 801f836:	781b      	ldrb	r3, [r3, #0]
    if ((ret == MUX_SCHEDULE) ||
 801f838:	2b02      	cmp	r3, #2
 801f83a:	d104      	bne.n	801f846 <OsMuxPostForPosix+0xe6>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 801f83c:	2001      	movs	r0, #1
 801f83e:	f7ff fe15 	bl	801f46c <LOS_MpSchedule>
        LOS_Schedule();
 801f842:	f7ff fdd5 	bl	801f3f0 <LOS_Schedule>
    }

    return ENOERR;
 801f846:	2300      	movs	r3, #0
}
 801f848:	4a05      	ldr	r2, [pc, #20]	; (801f860 <OsMuxPostForPosix+0x100>)
 801f84a:	6811      	ldr	r1, [r2, #0]
 801f84c:	69fa      	ldr	r2, [r7, #28]
 801f84e:	4051      	eors	r1, r2
 801f850:	d001      	beq.n	801f856 <OsMuxPostForPosix+0xf6>
 801f852:	f7e4 fdc9 	bl	80043e8 <__stack_chk_fail>
 801f856:	4618      	mov	r0, r3
 801f858:	3720      	adds	r7, #32
 801f85a:	46bd      	mov	sp, r7
 801f85c:	bd80      	pop	{r7, pc}
 801f85e:	bf00      	nop
 801f860:	080232cc 	.word	0x080232cc
 801f864:	20000764 	.word	0x20000764

0801f868 <wcrtomb>:
#include <wchar.h>
#include <errno.h>
#include "internal.h"

size_t wcrtomb(char *restrict s, wchar_t wc, mbstate_t *restrict st)
{
 801f868:	b580      	push	{r7, lr}
 801f86a:	b084      	sub	sp, #16
 801f86c:	af00      	add	r7, sp, #0
 801f86e:	60f8      	str	r0, [r7, #12]
 801f870:	60b9      	str	r1, [r7, #8]
 801f872:	607a      	str	r2, [r7, #4]
	if (!s) return 1;
 801f874:	68fb      	ldr	r3, [r7, #12]
 801f876:	2b00      	cmp	r3, #0
 801f878:	d101      	bne.n	801f87e <wcrtomb+0x16>
 801f87a:	2301      	movs	r3, #1
 801f87c:	e08c      	b.n	801f998 <wcrtomb+0x130>
	if ((unsigned)wc < 0x80) {
 801f87e:	68bb      	ldr	r3, [r7, #8]
 801f880:	2b7f      	cmp	r3, #127	; 0x7f
 801f882:	d805      	bhi.n	801f890 <wcrtomb+0x28>
		*s = wc;
 801f884:	68bb      	ldr	r3, [r7, #8]
 801f886:	b2da      	uxtb	r2, r3
 801f888:	68fb      	ldr	r3, [r7, #12]
 801f88a:	701a      	strb	r2, [r3, #0]
		return 1;
 801f88c:	2301      	movs	r3, #1
 801f88e:	e083      	b.n	801f998 <wcrtomb+0x130>
			errno = EILSEQ;
			return -1;
		}
		*s = wc;
		return 1;
	} else if ((unsigned)wc < 0x800) {
 801f890:	68bb      	ldr	r3, [r7, #8]
 801f892:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 801f896:	d215      	bcs.n	801f8c4 <wcrtomb+0x5c>
		*s++ = 0xc0 | (wc>>6);
 801f898:	68bb      	ldr	r3, [r7, #8]
 801f89a:	099b      	lsrs	r3, r3, #6
 801f89c:	b2da      	uxtb	r2, r3
 801f89e:	68fb      	ldr	r3, [r7, #12]
 801f8a0:	1c59      	adds	r1, r3, #1
 801f8a2:	60f9      	str	r1, [r7, #12]
 801f8a4:	f062 023f 	orn	r2, r2, #63	; 0x3f
 801f8a8:	b2d2      	uxtb	r2, r2
 801f8aa:	701a      	strb	r2, [r3, #0]
		*s = 0x80 | (wc&0x3f);
 801f8ac:	68bb      	ldr	r3, [r7, #8]
 801f8ae:	b2db      	uxtb	r3, r3
 801f8b0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f8b4:	b2db      	uxtb	r3, r3
 801f8b6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f8ba:	b2da      	uxtb	r2, r3
 801f8bc:	68fb      	ldr	r3, [r7, #12]
 801f8be:	701a      	strb	r2, [r3, #0]
		return 2;
 801f8c0:	2302      	movs	r3, #2
 801f8c2:	e069      	b.n	801f998 <wcrtomb+0x130>
	} else if ((unsigned)wc < 0xd800 || (unsigned)wc-0xe000 < 0x2000) {
 801f8c4:	68bb      	ldr	r3, [r7, #8]
 801f8c6:	f5b3 4f58 	cmp.w	r3, #55296	; 0xd800
 801f8ca:	d305      	bcc.n	801f8d8 <wcrtomb+0x70>
 801f8cc:	68bb      	ldr	r3, [r7, #8]
 801f8ce:	f5a3 4360 	sub.w	r3, r3, #57344	; 0xe000
 801f8d2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 801f8d6:	d222      	bcs.n	801f91e <wcrtomb+0xb6>
		*s++ = 0xe0 | (wc>>12);
 801f8d8:	68bb      	ldr	r3, [r7, #8]
 801f8da:	0b1b      	lsrs	r3, r3, #12
 801f8dc:	b2da      	uxtb	r2, r3
 801f8de:	68fb      	ldr	r3, [r7, #12]
 801f8e0:	1c59      	adds	r1, r3, #1
 801f8e2:	60f9      	str	r1, [r7, #12]
 801f8e4:	f062 021f 	orn	r2, r2, #31
 801f8e8:	b2d2      	uxtb	r2, r2
 801f8ea:	701a      	strb	r2, [r3, #0]
		*s++ = 0x80 | ((wc>>6)&0x3f);
 801f8ec:	68bb      	ldr	r3, [r7, #8]
 801f8ee:	099b      	lsrs	r3, r3, #6
 801f8f0:	b2db      	uxtb	r3, r3
 801f8f2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f8f6:	b2da      	uxtb	r2, r3
 801f8f8:	68fb      	ldr	r3, [r7, #12]
 801f8fa:	1c59      	adds	r1, r3, #1
 801f8fc:	60f9      	str	r1, [r7, #12]
 801f8fe:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801f902:	b2d2      	uxtb	r2, r2
 801f904:	701a      	strb	r2, [r3, #0]
		*s = 0x80 | (wc&0x3f);
 801f906:	68bb      	ldr	r3, [r7, #8]
 801f908:	b2db      	uxtb	r3, r3
 801f90a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f90e:	b2db      	uxtb	r3, r3
 801f910:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f914:	b2da      	uxtb	r2, r3
 801f916:	68fb      	ldr	r3, [r7, #12]
 801f918:	701a      	strb	r2, [r3, #0]
		return 3;
 801f91a:	2303      	movs	r3, #3
 801f91c:	e03c      	b.n	801f998 <wcrtomb+0x130>
	} else if ((unsigned)wc-0x10000 < 0x100000) {
 801f91e:	68bb      	ldr	r3, [r7, #8]
 801f920:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
 801f924:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 801f928:	d22f      	bcs.n	801f98a <wcrtomb+0x122>
		*s++ = 0xf0 | (wc>>18);
 801f92a:	68bb      	ldr	r3, [r7, #8]
 801f92c:	0c9b      	lsrs	r3, r3, #18
 801f92e:	b2da      	uxtb	r2, r3
 801f930:	68fb      	ldr	r3, [r7, #12]
 801f932:	1c59      	adds	r1, r3, #1
 801f934:	60f9      	str	r1, [r7, #12]
 801f936:	f062 020f 	orn	r2, r2, #15
 801f93a:	b2d2      	uxtb	r2, r2
 801f93c:	701a      	strb	r2, [r3, #0]
		*s++ = 0x80 | ((wc>>12)&0x3f);
 801f93e:	68bb      	ldr	r3, [r7, #8]
 801f940:	0b1b      	lsrs	r3, r3, #12
 801f942:	b2db      	uxtb	r3, r3
 801f944:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f948:	b2da      	uxtb	r2, r3
 801f94a:	68fb      	ldr	r3, [r7, #12]
 801f94c:	1c59      	adds	r1, r3, #1
 801f94e:	60f9      	str	r1, [r7, #12]
 801f950:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801f954:	b2d2      	uxtb	r2, r2
 801f956:	701a      	strb	r2, [r3, #0]
		*s++ = 0x80 | ((wc>>6)&0x3f);
 801f958:	68bb      	ldr	r3, [r7, #8]
 801f95a:	099b      	lsrs	r3, r3, #6
 801f95c:	b2db      	uxtb	r3, r3
 801f95e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f962:	b2da      	uxtb	r2, r3
 801f964:	68fb      	ldr	r3, [r7, #12]
 801f966:	1c59      	adds	r1, r3, #1
 801f968:	60f9      	str	r1, [r7, #12]
 801f96a:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801f96e:	b2d2      	uxtb	r2, r2
 801f970:	701a      	strb	r2, [r3, #0]
		*s = 0x80 | (wc&0x3f);
 801f972:	68bb      	ldr	r3, [r7, #8]
 801f974:	b2db      	uxtb	r3, r3
 801f976:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f97a:	b2db      	uxtb	r3, r3
 801f97c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f980:	b2da      	uxtb	r2, r3
 801f982:	68fb      	ldr	r3, [r7, #12]
 801f984:	701a      	strb	r2, [r3, #0]
		return 4;
 801f986:	2304      	movs	r3, #4
 801f988:	e006      	b.n	801f998 <wcrtomb+0x130>
	}
	errno = EILSEQ;
 801f98a:	f7ef fda3 	bl	800f4d4 <__errno_location>
 801f98e:	4603      	mov	r3, r0
 801f990:	2254      	movs	r2, #84	; 0x54
 801f992:	601a      	str	r2, [r3, #0]
	return -1;
 801f994:	f04f 33ff 	mov.w	r3, #4294967295
}
 801f998:	4618      	mov	r0, r3
 801f99a:	3710      	adds	r7, #16
 801f99c:	46bd      	mov	sp, r7
 801f99e:	bd80      	pop	{r7, pc}

0801f9a0 <LOS_CppSystemInit>:
#endif /* __cplusplus */

typedef VOID (*InitFunc)(VOID);

LITE_OS_SEC_TEXT_MINOR INT32 LOS_CppSystemInit(UINTPTR initArrayStart, UINTPTR initArrayEnd, INT32 flag)
{
 801f9a0:	b580      	push	{r7, lr}
 801f9a2:	b088      	sub	sp, #32
 801f9a4:	af00      	add	r7, sp, #0
 801f9a6:	60f8      	str	r0, [r7, #12]
 801f9a8:	60b9      	str	r1, [r7, #8]
 801f9aa:	607a      	str	r2, [r7, #4]
    UINTPTR fastEnd    = (UINTPTR)&__fast_end;
 801f9ac:	4b15      	ldr	r3, [pc, #84]	; (801fa04 <LOS_CppSystemInit+0x64>)
 801f9ae:	61bb      	str	r3, [r7, #24]
    UINTPTR *start     = (UINTPTR *)initArrayStart;
 801f9b0:	68fb      	ldr	r3, [r7, #12]
 801f9b2:	617b      	str	r3, [r7, #20]
    InitFunc initFunc   = NULL;
 801f9b4:	2300      	movs	r3, #0
 801f9b6:	61fb      	str	r3, [r7, #28]

#ifdef LOSCFG_AARCH64
    __register_frame(__EH_FRAME_BEGIN__);
#endif

    for (; start != (UINTPTR *)initArrayEnd; ++start) {
 801f9b8:	e01b      	b.n	801f9f2 <LOS_CppSystemInit+0x52>
        if ((flag == BEFORE_SCATTER) && ((UINTPTR)*start > fastEnd)) {
 801f9ba:	687b      	ldr	r3, [r7, #4]
 801f9bc:	2b00      	cmp	r3, #0
 801f9be:	d104      	bne.n	801f9ca <LOS_CppSystemInit+0x2a>
 801f9c0:	697b      	ldr	r3, [r7, #20]
 801f9c2:	681b      	ldr	r3, [r3, #0]
 801f9c4:	69ba      	ldr	r2, [r7, #24]
 801f9c6:	429a      	cmp	r2, r3
 801f9c8:	d30d      	bcc.n	801f9e6 <LOS_CppSystemInit+0x46>
            continue;
        } else if ((flag == AFTER_SCATTER) && ((UINTPTR)*start <= fastEnd)) {
 801f9ca:	687b      	ldr	r3, [r7, #4]
 801f9cc:	2b01      	cmp	r3, #1
 801f9ce:	d104      	bne.n	801f9da <LOS_CppSystemInit+0x3a>
 801f9d0:	697b      	ldr	r3, [r7, #20]
 801f9d2:	681b      	ldr	r3, [r3, #0]
 801f9d4:	69ba      	ldr	r2, [r7, #24]
 801f9d6:	429a      	cmp	r2, r3
 801f9d8:	d207      	bcs.n	801f9ea <LOS_CppSystemInit+0x4a>
            continue;
        }

        initFunc = (InitFunc)(*start);
 801f9da:	697b      	ldr	r3, [r7, #20]
 801f9dc:	681b      	ldr	r3, [r3, #0]
 801f9de:	61fb      	str	r3, [r7, #28]
        initFunc();
 801f9e0:	69fb      	ldr	r3, [r7, #28]
 801f9e2:	4798      	blx	r3
 801f9e4:	e002      	b.n	801f9ec <LOS_CppSystemInit+0x4c>
            continue;
 801f9e6:	bf00      	nop
 801f9e8:	e000      	b.n	801f9ec <LOS_CppSystemInit+0x4c>
            continue;
 801f9ea:	bf00      	nop
    for (; start != (UINTPTR *)initArrayEnd; ++start) {
 801f9ec:	697b      	ldr	r3, [r7, #20]
 801f9ee:	3304      	adds	r3, #4
 801f9f0:	617b      	str	r3, [r7, #20]
 801f9f2:	68bb      	ldr	r3, [r7, #8]
 801f9f4:	697a      	ldr	r2, [r7, #20]
 801f9f6:	429a      	cmp	r2, r3
 801f9f8:	d1df      	bne.n	801f9ba <LOS_CppSystemInit+0x1a>
    }

    return 0;
 801f9fa:	2300      	movs	r3, #0
}
 801f9fc:	4618      	mov	r0, r3
 801f9fe:	3720      	adds	r7, #32
 801fa00:	46bd      	mov	sp, r7
 801fa02:	bd80      	pop	{r7, pc}
 801fa04:	20003df0 	.word	0x20003df0

0801fa08 <map_errno>:
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

int map_errno(UINT32 err)
{
 801fa08:	b580      	push	{r7, lr}
 801fa0a:	b082      	sub	sp, #8
 801fa0c:	af00      	add	r7, sp, #0
 801fa0e:	6078      	str	r0, [r7, #4]
    if (err == LOS_OK) {
 801fa10:	687b      	ldr	r3, [r7, #4]
 801fa12:	2b00      	cmp	r3, #0
 801fa14:	d101      	bne.n	801fa1a <map_errno+0x12>
        return ENOERR;
 801fa16:	2300      	movs	r3, #0
 801fa18:	e1c0      	b.n	801fd9c <map_errno+0x394>
    }
    switch (err) {
 801fa1a:	687b      	ldr	r3, [r7, #4]
 801fa1c:	f1b3 3fff 	cmp.w	r3, #4294967295
 801fa20:	f000 8155 	beq.w	801fcce <map_errno+0x2c6>
 801fa24:	687b      	ldr	r3, [r7, #4]
 801fa26:	4acb      	ldr	r2, [pc, #812]	; (801fd54 <map_errno+0x34c>)
 801fa28:	4293      	cmp	r3, r2
 801fa2a:	f000 8150 	beq.w	801fcce <map_errno+0x2c6>
 801fa2e:	687b      	ldr	r3, [r7, #4]
 801fa30:	4ac8      	ldr	r2, [pc, #800]	; (801fd54 <map_errno+0x34c>)
 801fa32:	4293      	cmp	r3, r2
 801fa34:	f200 81a8 	bhi.w	801fd88 <map_errno+0x380>
 801fa38:	687b      	ldr	r3, [r7, #4]
 801fa3a:	4ac7      	ldr	r2, [pc, #796]	; (801fd58 <map_errno+0x350>)
 801fa3c:	4293      	cmp	r3, r2
 801fa3e:	f000 8152 	beq.w	801fce6 <map_errno+0x2de>
 801fa42:	687b      	ldr	r3, [r7, #4]
 801fa44:	4ac4      	ldr	r2, [pc, #784]	; (801fd58 <map_errno+0x350>)
 801fa46:	4293      	cmp	r3, r2
 801fa48:	f200 819e 	bhi.w	801fd88 <map_errno+0x380>
 801fa4c:	687b      	ldr	r3, [r7, #4]
 801fa4e:	4ac3      	ldr	r2, [pc, #780]	; (801fd5c <map_errno+0x354>)
 801fa50:	4293      	cmp	r3, r2
 801fa52:	f200 8199 	bhi.w	801fd88 <map_errno+0x380>
 801fa56:	687b      	ldr	r3, [r7, #4]
 801fa58:	4ac1      	ldr	r2, [pc, #772]	; (801fd60 <map_errno+0x358>)
 801fa5a:	4293      	cmp	r3, r2
 801fa5c:	d81c      	bhi.n	801fa98 <map_errno+0x90>
 801fa5e:	687b      	ldr	r3, [r7, #4]
 801fa60:	4ac0      	ldr	r2, [pc, #768]	; (801fd64 <map_errno+0x35c>)
 801fa62:	4293      	cmp	r3, r2
 801fa64:	f000 816f 	beq.w	801fd46 <map_errno+0x33e>
 801fa68:	687b      	ldr	r3, [r7, #4]
 801fa6a:	4abe      	ldr	r2, [pc, #760]	; (801fd64 <map_errno+0x35c>)
 801fa6c:	4293      	cmp	r3, r2
 801fa6e:	f200 818b 	bhi.w	801fd88 <map_errno+0x380>
 801fa72:	687b      	ldr	r3, [r7, #4]
 801fa74:	4abc      	ldr	r2, [pc, #752]	; (801fd68 <map_errno+0x360>)
 801fa76:	4293      	cmp	r3, r2
 801fa78:	f200 8186 	bhi.w	801fd88 <map_errno+0x380>
 801fa7c:	687b      	ldr	r3, [r7, #4]
 801fa7e:	4abb      	ldr	r2, [pc, #748]	; (801fd6c <map_errno+0x364>)
 801fa80:	4293      	cmp	r3, r2
 801fa82:	d225      	bcs.n	801fad0 <map_errno+0xc8>
 801fa84:	687b      	ldr	r3, [r7, #4]
 801fa86:	4aba      	ldr	r2, [pc, #744]	; (801fd70 <map_errno+0x368>)
 801fa88:	4293      	cmp	r3, r2
 801fa8a:	f200 80d3 	bhi.w	801fc34 <map_errno+0x22c>
 801fa8e:	687b      	ldr	r3, [r7, #4]
 801fa90:	f1b3 2f02 	cmp.w	r3, #33554944	; 0x2000200
 801fa94:	d87a      	bhi.n	801fb8c <map_errno+0x184>
 801fa96:	e177      	b.n	801fd88 <map_errno+0x380>
 801fa98:	687a      	ldr	r2, [r7, #4]
 801fa9a:	4bb6      	ldr	r3, [pc, #728]	; (801fd74 <map_errno+0x36c>)
 801fa9c:	4413      	add	r3, r2
 801fa9e:	2b08      	cmp	r3, #8
 801faa0:	f200 8172 	bhi.w	801fd88 <map_errno+0x380>
 801faa4:	a201      	add	r2, pc, #4	; (adr r2, 801faac <map_errno+0xa4>)
 801faa6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801faaa:	bf00      	nop
 801faac:	0801fc93 	.word	0x0801fc93
 801fab0:	0801fc93 	.word	0x0801fc93
 801fab4:	0801fcab 	.word	0x0801fcab
 801fab8:	0801fc9f 	.word	0x0801fc9f
 801fabc:	0801fcc3 	.word	0x0801fcc3
 801fac0:	0801fcb7 	.word	0x0801fcb7
 801fac4:	0801fc9f 	.word	0x0801fc9f
 801fac8:	0801fd89 	.word	0x0801fd89
 801facc:	0801fc9f 	.word	0x0801fc9f
 801fad0:	687a      	ldr	r2, [r7, #4]
 801fad2:	4ba9      	ldr	r3, [pc, #676]	; (801fd78 <map_errno+0x370>)
 801fad4:	4413      	add	r3, r2
 801fad6:	2b08      	cmp	r3, #8
 801fad8:	f200 8156 	bhi.w	801fd88 <map_errno+0x380>
 801fadc:	a201      	add	r2, pc, #4	; (adr r2, 801fae4 <map_errno+0xdc>)
 801fade:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801fae2:	bf00      	nop
 801fae4:	0801fcff 	.word	0x0801fcff
 801fae8:	0801fd89 	.word	0x0801fd89
 801faec:	0801fcf3 	.word	0x0801fcf3
 801faf0:	0801fcff 	.word	0x0801fcff
 801faf4:	0801fd23 	.word	0x0801fd23
 801faf8:	0801fd17 	.word	0x0801fd17
 801fafc:	0801fd2f 	.word	0x0801fd2f
 801fb00:	0801fd3b 	.word	0x0801fd3b
 801fb04:	0801fd0b 	.word	0x0801fd0b
 801fb08:	687a      	ldr	r2, [r7, #4]
 801fb0a:	4b9c      	ldr	r3, [pc, #624]	; (801fd7c <map_errno+0x374>)
 801fb0c:	4413      	add	r3, r2
 801fb0e:	2b1b      	cmp	r3, #27
 801fb10:	f200 813a 	bhi.w	801fd88 <map_errno+0x380>
 801fb14:	a201      	add	r2, pc, #4	; (adr r2, 801fb1c <map_errno+0x114>)
 801fb16:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801fb1a:	bf00      	nop
 801fb1c:	0801fc63 	.word	0x0801fc63
 801fb20:	0801fc4b 	.word	0x0801fc4b
 801fb24:	0801fc7b 	.word	0x0801fc7b
 801fb28:	0801fd89 	.word	0x0801fd89
 801fb2c:	0801fd89 	.word	0x0801fd89
 801fb30:	0801fc6f 	.word	0x0801fc6f
 801fb34:	0801fd89 	.word	0x0801fd89
 801fb38:	0801fc87 	.word	0x0801fc87
 801fb3c:	0801fd89 	.word	0x0801fd89
 801fb40:	0801fd89 	.word	0x0801fd89
 801fb44:	0801fc4b 	.word	0x0801fc4b
 801fb48:	0801fc4b 	.word	0x0801fc4b
 801fb4c:	0801fc4b 	.word	0x0801fc4b
 801fb50:	0801fd89 	.word	0x0801fd89
 801fb54:	0801fd89 	.word	0x0801fd89
 801fb58:	0801fd89 	.word	0x0801fd89
 801fb5c:	0801fc4b 	.word	0x0801fc4b
 801fb60:	0801fc4b 	.word	0x0801fc4b
 801fb64:	0801fd89 	.word	0x0801fd89
 801fb68:	0801fc4b 	.word	0x0801fc4b
 801fb6c:	0801fc57 	.word	0x0801fc57
 801fb70:	0801fd89 	.word	0x0801fd89
 801fb74:	0801fc87 	.word	0x0801fc87
 801fb78:	0801fd89 	.word	0x0801fd89
 801fb7c:	0801fd89 	.word	0x0801fd89
 801fb80:	0801fd89 	.word	0x0801fd89
 801fb84:	0801fd89 	.word	0x0801fd89
 801fb88:	0801fc57 	.word	0x0801fc57
 801fb8c:	687a      	ldr	r2, [r7, #4]
 801fb8e:	f06f 2302 	mvn.w	r3, #33554944	; 0x2000200
 801fb92:	4413      	add	r3, r2
 801fb94:	2b24      	cmp	r3, #36	; 0x24
 801fb96:	f200 80f7 	bhi.w	801fd88 <map_errno+0x380>
 801fb9a:	a201      	add	r2, pc, #4	; (adr r2, 801fba0 <map_errno+0x198>)
 801fb9c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801fba0:	0801fccf 	.word	0x0801fccf
 801fba4:	0801fd89 	.word	0x0801fd89
 801fba8:	0801fccf 	.word	0x0801fccf
 801fbac:	0801fccf 	.word	0x0801fccf
 801fbb0:	0801fccf 	.word	0x0801fccf
 801fbb4:	0801fccf 	.word	0x0801fccf
 801fbb8:	0801fccf 	.word	0x0801fccf
 801fbbc:	0801fd89 	.word	0x0801fd89
 801fbc0:	0801fd89 	.word	0x0801fd89
 801fbc4:	0801fccf 	.word	0x0801fccf
 801fbc8:	0801fd89 	.word	0x0801fd89
 801fbcc:	0801fd89 	.word	0x0801fd89
 801fbd0:	0801fd89 	.word	0x0801fd89
 801fbd4:	0801fd89 	.word	0x0801fd89
 801fbd8:	0801fd89 	.word	0x0801fd89
 801fbdc:	0801fd89 	.word	0x0801fd89
 801fbe0:	0801fcdb 	.word	0x0801fcdb
 801fbe4:	0801fd89 	.word	0x0801fd89
 801fbe8:	0801fd89 	.word	0x0801fd89
 801fbec:	0801fd89 	.word	0x0801fd89
 801fbf0:	0801fd89 	.word	0x0801fd89
 801fbf4:	0801fd89 	.word	0x0801fd89
 801fbf8:	0801fd89 	.word	0x0801fd89
 801fbfc:	0801fd89 	.word	0x0801fd89
 801fc00:	0801fd89 	.word	0x0801fd89
 801fc04:	0801fd89 	.word	0x0801fd89
 801fc08:	0801fd89 	.word	0x0801fd89
 801fc0c:	0801fd89 	.word	0x0801fd89
 801fc10:	0801fd89 	.word	0x0801fd89
 801fc14:	0801fd89 	.word	0x0801fd89
 801fc18:	0801fd89 	.word	0x0801fd89
 801fc1c:	0801fccf 	.word	0x0801fccf
 801fc20:	0801fd89 	.word	0x0801fd89
 801fc24:	0801fd89 	.word	0x0801fd89
 801fc28:	0801fd89 	.word	0x0801fd89
 801fc2c:	0801fd89 	.word	0x0801fd89
 801fc30:	0801fcdb 	.word	0x0801fcdb
 801fc34:	687b      	ldr	r3, [r7, #4]
 801fc36:	4a52      	ldr	r2, [pc, #328]	; (801fd80 <map_errno+0x378>)
 801fc38:	4293      	cmp	r3, r2
 801fc3a:	f200 80a5 	bhi.w	801fd88 <map_errno+0x380>
 801fc3e:	687b      	ldr	r3, [r7, #4]
 801fc40:	4a50      	ldr	r2, [pc, #320]	; (801fd84 <map_errno+0x37c>)
 801fc42:	4293      	cmp	r3, r2
 801fc44:	f4bf af60 	bcs.w	801fb08 <map_errno+0x100>
 801fc48:	e09e      	b.n	801fd88 <map_errno+0x380>
        case LOS_ERRNO_QUEUE_WRITESIZE_ISZERO:
        case LOS_ERRNO_QUEUE_SIZE_TOO_BIG:
        case LOS_ERRNO_QUEUE_CREAT_PTR_NULL:
        case LOS_ERRNO_QUEUE_PARA_ISZERO:
        case LOS_ERRNO_QUEUE_WRITE_SIZE_TOO_BIG:
            errno = EINVAL;
 801fc4a:	f7ef fc43 	bl	800f4d4 <__errno_location>
 801fc4e:	4603      	mov	r3, r0
 801fc50:	2216      	movs	r2, #22
 801fc52:	601a      	str	r2, [r3, #0]
            break;
 801fc54:	e09e      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_QUEUE_ISFULL:
        case LOS_ERRNO_QUEUE_ISEMPTY:
            errno = EAGAIN;
 801fc56:	f7ef fc3d 	bl	800f4d4 <__errno_location>
 801fc5a:	4603      	mov	r3, r0
 801fc5c:	220b      	movs	r2, #11
 801fc5e:	601a      	str	r2, [r3, #0]
            break;
 801fc60:	e098      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_QUEUE_CREATE_NO_MEMORY:
            errno = ENOSPC;
 801fc62:	f7ef fc37 	bl	800f4d4 <__errno_location>
 801fc66:	4603      	mov	r3, r0
 801fc68:	221c      	movs	r2, #28
 801fc6a:	601a      	str	r2, [r3, #0]
            break;
 801fc6c:	e092      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_QUEUE_TIMEOUT:
            errno = ETIMEDOUT;
 801fc6e:	f7ef fc31 	bl	800f4d4 <__errno_location>
 801fc72:	4603      	mov	r3, r0
 801fc74:	226e      	movs	r2, #110	; 0x6e
 801fc76:	601a      	str	r2, [r3, #0]
            break;
 801fc78:	e08c      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_QUEUE_CB_UNAVAILABLE:
            errno = ENFILE;
 801fc7a:	f7ef fc2b 	bl	800f4d4 <__errno_location>
 801fc7e:	4603      	mov	r3, r0
 801fc80:	2217      	movs	r2, #23
 801fc82:	601a      	str	r2, [r3, #0]
            break;
 801fc84:	e086      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_QUEUE_READ_IN_INTERRUPT:
        case LOS_ERRNO_QUEUE_WRITE_IN_INTERRUPT:
            errno = EINTR;
 801fc86:	f7ef fc25 	bl	800f4d4 <__errno_location>
 801fc8a:	4603      	mov	r3, r0
 801fc8c:	2204      	movs	r2, #4
 801fc8e:	601a      	str	r2, [r3, #0]
            break;
 801fc90:	e080      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_MUX_INVALID:
        case LOS_ERRNO_MUX_PTR_NULL:
            errno = EINVAL;
 801fc92:	f7ef fc1f 	bl	800f4d4 <__errno_location>
 801fc96:	4603      	mov	r3, r0
 801fc98:	2216      	movs	r2, #22
 801fc9a:	601a      	str	r2, [r3, #0]
            break;
 801fc9c:	e07a      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_MUX_PENDED:
        case LOS_ERRNO_MUX_UNAVAILABLE:
        case LOS_ERRNO_MUX_TIMEOUT:
            errno = EBUSY;
 801fc9e:	f7ef fc19 	bl	800f4d4 <__errno_location>
 801fca2:	4603      	mov	r3, r0
 801fca4:	2210      	movs	r2, #16
 801fca6:	601a      	str	r2, [r3, #0]
            break;
 801fca8:	e074      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_MUX_ALL_BUSY:
            errno = EAGAIN;
 801fcaa:	f7ef fc13 	bl	800f4d4 <__errno_location>
 801fcae:	4603      	mov	r3, r0
 801fcb0:	220b      	movs	r2, #11
 801fcb2:	601a      	str	r2, [r3, #0]
            break;
 801fcb4:	e06e      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_MUX_PEND_IN_LOCK:
            errno = EDEADLK;
 801fcb6:	f7ef fc0d 	bl	800f4d4 <__errno_location>
 801fcba:	4603      	mov	r3, r0
 801fcbc:	2223      	movs	r2, #35	; 0x23
 801fcbe:	601a      	str	r2, [r3, #0]
            break;
 801fcc0:	e068      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_MUX_PEND_INTERR:
            errno = EPERM;
 801fcc2:	f7ef fc07 	bl	800f4d4 <__errno_location>
 801fcc6:	4603      	mov	r3, r0
 801fcc8:	2201      	movs	r2, #1
 801fcca:	601a      	str	r2, [r3, #0]
            break;
 801fccc:	e062      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_TSK_STKSZ_TOO_LARGE:
        case LOS_ERRNO_TSK_STKSZ_TOO_SMALL:
        case LOS_ERRNO_TSK_NOT_CREATED:
        case LOS_ERRNO_TSK_CPU_AFFINITY_MASK_ERR:
        case OS_ERROR:
            errno = EINVAL;
 801fcce:	f7ef fc01 	bl	800f4d4 <__errno_location>
 801fcd2:	4603      	mov	r3, r0
 801fcd4:	2216      	movs	r2, #22
 801fcd6:	601a      	str	r2, [r3, #0]
            break;
 801fcd8:	e05c      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_TSK_TCB_UNAVAILABLE:
        case LOS_ERRNO_TSK_MP_SYNC_RESOURCE:
            errno = ENOSPC;
 801fcda:	f7ef fbfb 	bl	800f4d4 <__errno_location>
 801fcde:	4603      	mov	r3, r0
 801fce0:	221c      	movs	r2, #28
 801fce2:	601a      	str	r2, [r3, #0]
            break;
 801fce4:	e056      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_TSK_NO_MEMORY:
            errno = ENOMEM;
 801fce6:	f7ef fbf5 	bl	800f4d4 <__errno_location>
 801fcea:	4603      	mov	r3, r0
 801fcec:	220c      	movs	r2, #12
 801fcee:	601a      	str	r2, [r3, #0]
            break;
 801fcf0:	e050      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_SEM_ALL_BUSY:
            errno = ENOSPC;
 801fcf2:	f7ef fbef 	bl	800f4d4 <__errno_location>
 801fcf6:	4603      	mov	r3, r0
 801fcf8:	221c      	movs	r2, #28
 801fcfa:	601a      	str	r2, [r3, #0]
            break;
 801fcfc:	e04a      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_SEM_INVALID:
        case LOS_ERRNO_SEM_UNAVAILABLE:
            errno = EINVAL;
 801fcfe:	f7ef fbe9 	bl	800f4d4 <__errno_location>
 801fd02:	4603      	mov	r3, r0
 801fd04:	2216      	movs	r2, #22
 801fd06:	601a      	str	r2, [r3, #0]
            break;
 801fd08:	e044      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_SEM_PENDED:
            errno = EBUSY;
 801fd0a:	f7ef fbe3 	bl	800f4d4 <__errno_location>
 801fd0e:	4603      	mov	r3, r0
 801fd10:	2210      	movs	r2, #16
 801fd12:	601a      	str	r2, [r3, #0]
            break;
 801fd14:	e03e      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_SEM_PEND_IN_LOCK:
            errno = EPERM;
 801fd16:	f7ef fbdd 	bl	800f4d4 <__errno_location>
 801fd1a:	4603      	mov	r3, r0
 801fd1c:	2201      	movs	r2, #1
 801fd1e:	601a      	str	r2, [r3, #0]
            break;
 801fd20:	e038      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_SEM_PEND_INTERR:
            errno = EINTR;
 801fd22:	f7ef fbd7 	bl	800f4d4 <__errno_location>
 801fd26:	4603      	mov	r3, r0
 801fd28:	2204      	movs	r2, #4
 801fd2a:	601a      	str	r2, [r3, #0]
            break;
 801fd2c:	e032      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_SEM_TIMEOUT:
            errno = ETIMEDOUT;
 801fd2e:	f7ef fbd1 	bl	800f4d4 <__errno_location>
 801fd32:	4603      	mov	r3, r0
 801fd34:	226e      	movs	r2, #110	; 0x6e
 801fd36:	601a      	str	r2, [r3, #0]
            break;
 801fd38:	e02c      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_SEM_OVERFLOW:
            errno = ENOSPC;
 801fd3a:	f7ef fbcb 	bl	800f4d4 <__errno_location>
 801fd3e:	4603      	mov	r3, r0
 801fd40:	221c      	movs	r2, #28
 801fd42:	601a      	str	r2, [r3, #0]
            break;
 801fd44:	e026      	b.n	801fd94 <map_errno+0x38c>
        case LOS_ERRNO_EVENT_SHOULD_NOT_DESTORY:
            errno = EBUSY;
 801fd46:	f7ef fbc5 	bl	800f4d4 <__errno_location>
 801fd4a:	4603      	mov	r3, r0
 801fd4c:	2210      	movs	r2, #16
 801fd4e:	601a      	str	r2, [r3, #0]
            break;
 801fd50:	e020      	b.n	801fd94 <map_errno+0x38c>
 801fd52:	bf00      	nop
 801fd54:	03000223 	.word	0x03000223
 801fd58:	03000200 	.word	0x03000200
 801fd5c:	02001d09 	.word	0x02001d09
 801fd60:	02001d00 	.word	0x02001d00
 801fd64:	02001c08 	.word	0x02001c08
 801fd68:	02000709 	.word	0x02000709
 801fd6c:	02000701 	.word	0x02000701
 801fd70:	02000225 	.word	0x02000225
 801fd74:	fdffe2ff 	.word	0xfdffe2ff
 801fd78:	fdfff8ff 	.word	0xfdfff8ff
 801fd7c:	fdfff9fe 	.word	0xfdfff9fe
 801fd80:	0200061d 	.word	0x0200061d
 801fd84:	02000602 	.word	0x02000602
        default:
            errno = EINVAL;
 801fd88:	f7ef fba4 	bl	800f4d4 <__errno_location>
 801fd8c:	4603      	mov	r3, r0
 801fd8e:	2216      	movs	r2, #22
 801fd90:	601a      	str	r2, [r3, #0]
            break;
 801fd92:	bf00      	nop
    }
    return errno;
 801fd94:	f7ef fb9e 	bl	800f4d4 <__errno_location>
 801fd98:	4603      	mov	r3, r0
 801fd9a:	681b      	ldr	r3, [r3, #0]
}
 801fd9c:	4618      	mov	r0, r3
 801fd9e:	3708      	adds	r7, #8
 801fda0:	46bd      	mov	sp, r7
 801fda2:	bd80      	pop	{r7, pc}
