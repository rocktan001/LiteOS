
../out/STM32F767_Fire/Huawei_LiteOS.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c8 <__text_start>:
 80001c8:	20003de0 	.word	0x20003de0
 80001cc:	2007fbff 	.word	0x2007fbff
 80001d0:	08024384 	.word	0x08024384
 80001d4:	20000000 	.word	0x20000000
 80001d8:	20000400 	.word	0x20000400
 80001dc:	08024784 	.word	0x08024784
 80001e0:	20000400 	.word	0x20000400
 80001e4:	20000724 	.word	0x20000724
 80001e8:	20000728 	.word	0x20000728
 80001ec:	200037e0 	.word	0x200037e0

080001f0 <__LOS_HEAP_ADDR_START__>:
 80001f0:	20003de0 	.word	0x20003de0

080001f4 <__LOS_HEAP_ADDR_END__>:
 80001f4:	2007fbff 	.word	0x2007fbff

080001f8 <__aeabi_drsub>:
 80001f8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80001fc:	e002      	b.n	8000204 <__adddf3>
 80001fe:	bf00      	nop

08000200 <__aeabi_dsub>:
 8000200:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000204 <__adddf3>:
 8000204:	b530      	push	{r4, r5, lr}
 8000206:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800020a:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800020e:	ea94 0f05 	teq	r4, r5
 8000212:	bf08      	it	eq
 8000214:	ea90 0f02 	teqeq	r0, r2
 8000218:	bf1f      	itttt	ne
 800021a:	ea54 0c00 	orrsne.w	ip, r4, r0
 800021e:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000222:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000226:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800022a:	f000 80e2 	beq.w	80003f2 <__adddf3+0x1ee>
 800022e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000232:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000236:	bfb8      	it	lt
 8000238:	426d      	neglt	r5, r5
 800023a:	dd0c      	ble.n	8000256 <__adddf3+0x52>
 800023c:	442c      	add	r4, r5
 800023e:	ea80 0202 	eor.w	r2, r0, r2
 8000242:	ea81 0303 	eor.w	r3, r1, r3
 8000246:	ea82 0000 	eor.w	r0, r2, r0
 800024a:	ea83 0101 	eor.w	r1, r3, r1
 800024e:	ea80 0202 	eor.w	r2, r0, r2
 8000252:	ea81 0303 	eor.w	r3, r1, r3
 8000256:	2d36      	cmp	r5, #54	; 0x36
 8000258:	bf88      	it	hi
 800025a:	bd30      	pophi	{r4, r5, pc}
 800025c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000260:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000264:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000268:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800026c:	d002      	beq.n	8000274 <__adddf3+0x70>
 800026e:	4240      	negs	r0, r0
 8000270:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000274:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000278:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800027c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000280:	d002      	beq.n	8000288 <__adddf3+0x84>
 8000282:	4252      	negs	r2, r2
 8000284:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000288:	ea94 0f05 	teq	r4, r5
 800028c:	f000 80a7 	beq.w	80003de <__adddf3+0x1da>
 8000290:	f1a4 0401 	sub.w	r4, r4, #1
 8000294:	f1d5 0e20 	rsbs	lr, r5, #32
 8000298:	db0d      	blt.n	80002b6 <__adddf3+0xb2>
 800029a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800029e:	fa22 f205 	lsr.w	r2, r2, r5
 80002a2:	1880      	adds	r0, r0, r2
 80002a4:	f141 0100 	adc.w	r1, r1, #0
 80002a8:	fa03 f20e 	lsl.w	r2, r3, lr
 80002ac:	1880      	adds	r0, r0, r2
 80002ae:	fa43 f305 	asr.w	r3, r3, r5
 80002b2:	4159      	adcs	r1, r3
 80002b4:	e00e      	b.n	80002d4 <__adddf3+0xd0>
 80002b6:	f1a5 0520 	sub.w	r5, r5, #32
 80002ba:	f10e 0e20 	add.w	lr, lr, #32
 80002be:	2a01      	cmp	r2, #1
 80002c0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80002c4:	bf28      	it	cs
 80002c6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80002ca:	fa43 f305 	asr.w	r3, r3, r5
 80002ce:	18c0      	adds	r0, r0, r3
 80002d0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80002d4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80002d8:	d507      	bpl.n	80002ea <__adddf3+0xe6>
 80002da:	f04f 0e00 	mov.w	lr, #0
 80002de:	f1dc 0c00 	rsbs	ip, ip, #0
 80002e2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80002e6:	eb6e 0101 	sbc.w	r1, lr, r1
 80002ea:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80002ee:	d31b      	bcc.n	8000328 <__adddf3+0x124>
 80002f0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80002f4:	d30c      	bcc.n	8000310 <__adddf3+0x10c>
 80002f6:	0849      	lsrs	r1, r1, #1
 80002f8:	ea5f 0030 	movs.w	r0, r0, rrx
 80002fc:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000300:	f104 0401 	add.w	r4, r4, #1
 8000304:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000308:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800030c:	f080 809a 	bcs.w	8000444 <__adddf3+0x240>
 8000310:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000314:	bf08      	it	eq
 8000316:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800031a:	f150 0000 	adcs.w	r0, r0, #0
 800031e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000322:	ea41 0105 	orr.w	r1, r1, r5
 8000326:	bd30      	pop	{r4, r5, pc}
 8000328:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800032c:	4140      	adcs	r0, r0
 800032e:	eb41 0101 	adc.w	r1, r1, r1
 8000332:	3c01      	subs	r4, #1
 8000334:	bf28      	it	cs
 8000336:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 800033a:	d2e9      	bcs.n	8000310 <__adddf3+0x10c>
 800033c:	f091 0f00 	teq	r1, #0
 8000340:	bf04      	itt	eq
 8000342:	4601      	moveq	r1, r0
 8000344:	2000      	moveq	r0, #0
 8000346:	fab1 f381 	clz	r3, r1
 800034a:	bf08      	it	eq
 800034c:	3320      	addeq	r3, #32
 800034e:	f1a3 030b 	sub.w	r3, r3, #11
 8000352:	f1b3 0220 	subs.w	r2, r3, #32
 8000356:	da0c      	bge.n	8000372 <__adddf3+0x16e>
 8000358:	320c      	adds	r2, #12
 800035a:	dd08      	ble.n	800036e <__adddf3+0x16a>
 800035c:	f102 0c14 	add.w	ip, r2, #20
 8000360:	f1c2 020c 	rsb	r2, r2, #12
 8000364:	fa01 f00c 	lsl.w	r0, r1, ip
 8000368:	fa21 f102 	lsr.w	r1, r1, r2
 800036c:	e00c      	b.n	8000388 <__adddf3+0x184>
 800036e:	f102 0214 	add.w	r2, r2, #20
 8000372:	bfd8      	it	le
 8000374:	f1c2 0c20 	rsble	ip, r2, #32
 8000378:	fa01 f102 	lsl.w	r1, r1, r2
 800037c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000380:	bfdc      	itt	le
 8000382:	ea41 010c 	orrle.w	r1, r1, ip
 8000386:	4090      	lslle	r0, r2
 8000388:	1ae4      	subs	r4, r4, r3
 800038a:	bfa2      	ittt	ge
 800038c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000390:	4329      	orrge	r1, r5
 8000392:	bd30      	popge	{r4, r5, pc}
 8000394:	ea6f 0404 	mvn.w	r4, r4
 8000398:	3c1f      	subs	r4, #31
 800039a:	da1c      	bge.n	80003d6 <__adddf3+0x1d2>
 800039c:	340c      	adds	r4, #12
 800039e:	dc0e      	bgt.n	80003be <__adddf3+0x1ba>
 80003a0:	f104 0414 	add.w	r4, r4, #20
 80003a4:	f1c4 0220 	rsb	r2, r4, #32
 80003a8:	fa20 f004 	lsr.w	r0, r0, r4
 80003ac:	fa01 f302 	lsl.w	r3, r1, r2
 80003b0:	ea40 0003 	orr.w	r0, r0, r3
 80003b4:	fa21 f304 	lsr.w	r3, r1, r4
 80003b8:	ea45 0103 	orr.w	r1, r5, r3
 80003bc:	bd30      	pop	{r4, r5, pc}
 80003be:	f1c4 040c 	rsb	r4, r4, #12
 80003c2:	f1c4 0220 	rsb	r2, r4, #32
 80003c6:	fa20 f002 	lsr.w	r0, r0, r2
 80003ca:	fa01 f304 	lsl.w	r3, r1, r4
 80003ce:	ea40 0003 	orr.w	r0, r0, r3
 80003d2:	4629      	mov	r1, r5
 80003d4:	bd30      	pop	{r4, r5, pc}
 80003d6:	fa21 f004 	lsr.w	r0, r1, r4
 80003da:	4629      	mov	r1, r5
 80003dc:	bd30      	pop	{r4, r5, pc}
 80003de:	f094 0f00 	teq	r4, #0
 80003e2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80003e6:	bf06      	itte	eq
 80003e8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80003ec:	3401      	addeq	r4, #1
 80003ee:	3d01      	subne	r5, #1
 80003f0:	e74e      	b.n	8000290 <__adddf3+0x8c>
 80003f2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80003f6:	bf18      	it	ne
 80003f8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80003fc:	d029      	beq.n	8000452 <__adddf3+0x24e>
 80003fe:	ea94 0f05 	teq	r4, r5
 8000402:	bf08      	it	eq
 8000404:	ea90 0f02 	teqeq	r0, r2
 8000408:	d005      	beq.n	8000416 <__adddf3+0x212>
 800040a:	ea54 0c00 	orrs.w	ip, r4, r0
 800040e:	bf04      	itt	eq
 8000410:	4619      	moveq	r1, r3
 8000412:	4610      	moveq	r0, r2
 8000414:	bd30      	pop	{r4, r5, pc}
 8000416:	ea91 0f03 	teq	r1, r3
 800041a:	bf1e      	ittt	ne
 800041c:	2100      	movne	r1, #0
 800041e:	2000      	movne	r0, #0
 8000420:	bd30      	popne	{r4, r5, pc}
 8000422:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000426:	d105      	bne.n	8000434 <__adddf3+0x230>
 8000428:	0040      	lsls	r0, r0, #1
 800042a:	4149      	adcs	r1, r1
 800042c:	bf28      	it	cs
 800042e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000432:	bd30      	pop	{r4, r5, pc}
 8000434:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000438:	bf3c      	itt	cc
 800043a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800043e:	bd30      	popcc	{r4, r5, pc}
 8000440:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000444:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000448:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800044c:	f04f 0000 	mov.w	r0, #0
 8000450:	bd30      	pop	{r4, r5, pc}
 8000452:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000456:	bf1a      	itte	ne
 8000458:	4619      	movne	r1, r3
 800045a:	4610      	movne	r0, r2
 800045c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000460:	bf1c      	itt	ne
 8000462:	460b      	movne	r3, r1
 8000464:	4602      	movne	r2, r0
 8000466:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800046a:	bf06      	itte	eq
 800046c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000470:	ea91 0f03 	teqeq	r1, r3
 8000474:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000478:	bd30      	pop	{r4, r5, pc}
 800047a:	bf00      	nop

0800047c <__aeabi_ui2d>:
 800047c:	f090 0f00 	teq	r0, #0
 8000480:	bf04      	itt	eq
 8000482:	2100      	moveq	r1, #0
 8000484:	4770      	bxeq	lr
 8000486:	b530      	push	{r4, r5, lr}
 8000488:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800048c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000490:	f04f 0500 	mov.w	r5, #0
 8000494:	f04f 0100 	mov.w	r1, #0
 8000498:	e750      	b.n	800033c <__adddf3+0x138>
 800049a:	bf00      	nop

0800049c <__aeabi_i2d>:
 800049c:	f090 0f00 	teq	r0, #0
 80004a0:	bf04      	itt	eq
 80004a2:	2100      	moveq	r1, #0
 80004a4:	4770      	bxeq	lr
 80004a6:	b530      	push	{r4, r5, lr}
 80004a8:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80004ac:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80004b0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80004b4:	bf48      	it	mi
 80004b6:	4240      	negmi	r0, r0
 80004b8:	f04f 0100 	mov.w	r1, #0
 80004bc:	e73e      	b.n	800033c <__adddf3+0x138>
 80004be:	bf00      	nop

080004c0 <__aeabi_f2d>:
 80004c0:	0042      	lsls	r2, r0, #1
 80004c2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80004c6:	ea4f 0131 	mov.w	r1, r1, rrx
 80004ca:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80004ce:	bf1f      	itttt	ne
 80004d0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80004d4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80004d8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80004dc:	4770      	bxne	lr
 80004de:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80004e2:	bf08      	it	eq
 80004e4:	4770      	bxeq	lr
 80004e6:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80004ea:	bf04      	itt	eq
 80004ec:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80004f0:	4770      	bxeq	lr
 80004f2:	b530      	push	{r4, r5, lr}
 80004f4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80004f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004fc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000500:	e71c      	b.n	800033c <__adddf3+0x138>
 8000502:	bf00      	nop

08000504 <__aeabi_ul2d>:
 8000504:	ea50 0201 	orrs.w	r2, r0, r1
 8000508:	bf08      	it	eq
 800050a:	4770      	bxeq	lr
 800050c:	b530      	push	{r4, r5, lr}
 800050e:	f04f 0500 	mov.w	r5, #0
 8000512:	e00a      	b.n	800052a <__aeabi_l2d+0x16>

08000514 <__aeabi_l2d>:
 8000514:	ea50 0201 	orrs.w	r2, r0, r1
 8000518:	bf08      	it	eq
 800051a:	4770      	bxeq	lr
 800051c:	b530      	push	{r4, r5, lr}
 800051e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000522:	d502      	bpl.n	800052a <__aeabi_l2d+0x16>
 8000524:	4240      	negs	r0, r0
 8000526:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800052a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800052e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000532:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000536:	f43f aed8 	beq.w	80002ea <__adddf3+0xe6>
 800053a:	f04f 0203 	mov.w	r2, #3
 800053e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000542:	bf18      	it	ne
 8000544:	3203      	addne	r2, #3
 8000546:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800054a:	bf18      	it	ne
 800054c:	3203      	addne	r2, #3
 800054e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000552:	f1c2 0320 	rsb	r3, r2, #32
 8000556:	fa00 fc03 	lsl.w	ip, r0, r3
 800055a:	fa20 f002 	lsr.w	r0, r0, r2
 800055e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000562:	ea40 000e 	orr.w	r0, r0, lr
 8000566:	fa21 f102 	lsr.w	r1, r1, r2
 800056a:	4414      	add	r4, r2
 800056c:	e6bd      	b.n	80002ea <__adddf3+0xe6>
 800056e:	bf00      	nop

08000570 <__aeabi_dmul>:
 8000570:	b570      	push	{r4, r5, r6, lr}
 8000572:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000576:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800057a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800057e:	bf1d      	ittte	ne
 8000580:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000584:	ea94 0f0c 	teqne	r4, ip
 8000588:	ea95 0f0c 	teqne	r5, ip
 800058c:	f000 f8de 	bleq	800074c <__aeabi_dmul+0x1dc>
 8000590:	442c      	add	r4, r5
 8000592:	ea81 0603 	eor.w	r6, r1, r3
 8000596:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800059a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800059e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80005a2:	bf18      	it	ne
 80005a4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80005a8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80005ac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80005b0:	d038      	beq.n	8000624 <__aeabi_dmul+0xb4>
 80005b2:	fba0 ce02 	umull	ip, lr, r0, r2
 80005b6:	f04f 0500 	mov.w	r5, #0
 80005ba:	fbe1 e502 	umlal	lr, r5, r1, r2
 80005be:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80005c2:	fbe0 e503 	umlal	lr, r5, r0, r3
 80005c6:	f04f 0600 	mov.w	r6, #0
 80005ca:	fbe1 5603 	umlal	r5, r6, r1, r3
 80005ce:	f09c 0f00 	teq	ip, #0
 80005d2:	bf18      	it	ne
 80005d4:	f04e 0e01 	orrne.w	lr, lr, #1
 80005d8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80005dc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80005e0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80005e4:	d204      	bcs.n	80005f0 <__aeabi_dmul+0x80>
 80005e6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80005ea:	416d      	adcs	r5, r5
 80005ec:	eb46 0606 	adc.w	r6, r6, r6
 80005f0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80005f4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80005f8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80005fc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000600:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000604:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000608:	bf88      	it	hi
 800060a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800060e:	d81e      	bhi.n	800064e <__aeabi_dmul+0xde>
 8000610:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000614:	bf08      	it	eq
 8000616:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800061a:	f150 0000 	adcs.w	r0, r0, #0
 800061e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000622:	bd70      	pop	{r4, r5, r6, pc}
 8000624:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000628:	ea46 0101 	orr.w	r1, r6, r1
 800062c:	ea40 0002 	orr.w	r0, r0, r2
 8000630:	ea81 0103 	eor.w	r1, r1, r3
 8000634:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000638:	bfc2      	ittt	gt
 800063a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800063e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000642:	bd70      	popgt	{r4, r5, r6, pc}
 8000644:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000648:	f04f 0e00 	mov.w	lr, #0
 800064c:	3c01      	subs	r4, #1
 800064e:	f300 80ab 	bgt.w	80007a8 <__aeabi_dmul+0x238>
 8000652:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000656:	bfde      	ittt	le
 8000658:	2000      	movle	r0, #0
 800065a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800065e:	bd70      	pople	{r4, r5, r6, pc}
 8000660:	f1c4 0400 	rsb	r4, r4, #0
 8000664:	3c20      	subs	r4, #32
 8000666:	da35      	bge.n	80006d4 <__aeabi_dmul+0x164>
 8000668:	340c      	adds	r4, #12
 800066a:	dc1b      	bgt.n	80006a4 <__aeabi_dmul+0x134>
 800066c:	f104 0414 	add.w	r4, r4, #20
 8000670:	f1c4 0520 	rsb	r5, r4, #32
 8000674:	fa00 f305 	lsl.w	r3, r0, r5
 8000678:	fa20 f004 	lsr.w	r0, r0, r4
 800067c:	fa01 f205 	lsl.w	r2, r1, r5
 8000680:	ea40 0002 	orr.w	r0, r0, r2
 8000684:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000688:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800068c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000690:	fa21 f604 	lsr.w	r6, r1, r4
 8000694:	eb42 0106 	adc.w	r1, r2, r6
 8000698:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800069c:	bf08      	it	eq
 800069e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006a2:	bd70      	pop	{r4, r5, r6, pc}
 80006a4:	f1c4 040c 	rsb	r4, r4, #12
 80006a8:	f1c4 0520 	rsb	r5, r4, #32
 80006ac:	fa00 f304 	lsl.w	r3, r0, r4
 80006b0:	fa20 f005 	lsr.w	r0, r0, r5
 80006b4:	fa01 f204 	lsl.w	r2, r1, r4
 80006b8:	ea40 0002 	orr.w	r0, r0, r2
 80006bc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80006c0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006c4:	f141 0100 	adc.w	r1, r1, #0
 80006c8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006cc:	bf08      	it	eq
 80006ce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006d2:	bd70      	pop	{r4, r5, r6, pc}
 80006d4:	f1c4 0520 	rsb	r5, r4, #32
 80006d8:	fa00 f205 	lsl.w	r2, r0, r5
 80006dc:	ea4e 0e02 	orr.w	lr, lr, r2
 80006e0:	fa20 f304 	lsr.w	r3, r0, r4
 80006e4:	fa01 f205 	lsl.w	r2, r1, r5
 80006e8:	ea43 0302 	orr.w	r3, r3, r2
 80006ec:	fa21 f004 	lsr.w	r0, r1, r4
 80006f0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80006f4:	fa21 f204 	lsr.w	r2, r1, r4
 80006f8:	ea20 0002 	bic.w	r0, r0, r2
 80006fc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000700:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000704:	bf08      	it	eq
 8000706:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800070a:	bd70      	pop	{r4, r5, r6, pc}
 800070c:	f094 0f00 	teq	r4, #0
 8000710:	d10f      	bne.n	8000732 <__aeabi_dmul+0x1c2>
 8000712:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000716:	0040      	lsls	r0, r0, #1
 8000718:	eb41 0101 	adc.w	r1, r1, r1
 800071c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000720:	bf08      	it	eq
 8000722:	3c01      	subeq	r4, #1
 8000724:	d0f7      	beq.n	8000716 <__aeabi_dmul+0x1a6>
 8000726:	ea41 0106 	orr.w	r1, r1, r6
 800072a:	f095 0f00 	teq	r5, #0
 800072e:	bf18      	it	ne
 8000730:	4770      	bxne	lr
 8000732:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000736:	0052      	lsls	r2, r2, #1
 8000738:	eb43 0303 	adc.w	r3, r3, r3
 800073c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000740:	bf08      	it	eq
 8000742:	3d01      	subeq	r5, #1
 8000744:	d0f7      	beq.n	8000736 <__aeabi_dmul+0x1c6>
 8000746:	ea43 0306 	orr.w	r3, r3, r6
 800074a:	4770      	bx	lr
 800074c:	ea94 0f0c 	teq	r4, ip
 8000750:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000754:	bf18      	it	ne
 8000756:	ea95 0f0c 	teqne	r5, ip
 800075a:	d00c      	beq.n	8000776 <__aeabi_dmul+0x206>
 800075c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000760:	bf18      	it	ne
 8000762:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000766:	d1d1      	bne.n	800070c <__aeabi_dmul+0x19c>
 8000768:	ea81 0103 	eor.w	r1, r1, r3
 800076c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000770:	f04f 0000 	mov.w	r0, #0
 8000774:	bd70      	pop	{r4, r5, r6, pc}
 8000776:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800077a:	bf06      	itte	eq
 800077c:	4610      	moveq	r0, r2
 800077e:	4619      	moveq	r1, r3
 8000780:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000784:	d019      	beq.n	80007ba <__aeabi_dmul+0x24a>
 8000786:	ea94 0f0c 	teq	r4, ip
 800078a:	d102      	bne.n	8000792 <__aeabi_dmul+0x222>
 800078c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000790:	d113      	bne.n	80007ba <__aeabi_dmul+0x24a>
 8000792:	ea95 0f0c 	teq	r5, ip
 8000796:	d105      	bne.n	80007a4 <__aeabi_dmul+0x234>
 8000798:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800079c:	bf1c      	itt	ne
 800079e:	4610      	movne	r0, r2
 80007a0:	4619      	movne	r1, r3
 80007a2:	d10a      	bne.n	80007ba <__aeabi_dmul+0x24a>
 80007a4:	ea81 0103 	eor.w	r1, r1, r3
 80007a8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007ac:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80007b0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80007b4:	f04f 0000 	mov.w	r0, #0
 80007b8:	bd70      	pop	{r4, r5, r6, pc}
 80007ba:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80007be:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80007c2:	bd70      	pop	{r4, r5, r6, pc}

080007c4 <__aeabi_ddiv>:
 80007c4:	b570      	push	{r4, r5, r6, lr}
 80007c6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80007ca:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80007ce:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80007d2:	bf1d      	ittte	ne
 80007d4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80007d8:	ea94 0f0c 	teqne	r4, ip
 80007dc:	ea95 0f0c 	teqne	r5, ip
 80007e0:	f000 f8a7 	bleq	8000932 <__aeabi_ddiv+0x16e>
 80007e4:	eba4 0405 	sub.w	r4, r4, r5
 80007e8:	ea81 0e03 	eor.w	lr, r1, r3
 80007ec:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80007f0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80007f4:	f000 8088 	beq.w	8000908 <__aeabi_ddiv+0x144>
 80007f8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80007fc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000800:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000804:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000808:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800080c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000810:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000814:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000818:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800081c:	429d      	cmp	r5, r3
 800081e:	bf08      	it	eq
 8000820:	4296      	cmpeq	r6, r2
 8000822:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000826:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800082a:	d202      	bcs.n	8000832 <__aeabi_ddiv+0x6e>
 800082c:	085b      	lsrs	r3, r3, #1
 800082e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000832:	1ab6      	subs	r6, r6, r2
 8000834:	eb65 0503 	sbc.w	r5, r5, r3
 8000838:	085b      	lsrs	r3, r3, #1
 800083a:	ea4f 0232 	mov.w	r2, r2, rrx
 800083e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000842:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000846:	ebb6 0e02 	subs.w	lr, r6, r2
 800084a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800084e:	bf22      	ittt	cs
 8000850:	1ab6      	subcs	r6, r6, r2
 8000852:	4675      	movcs	r5, lr
 8000854:	ea40 000c 	orrcs.w	r0, r0, ip
 8000858:	085b      	lsrs	r3, r3, #1
 800085a:	ea4f 0232 	mov.w	r2, r2, rrx
 800085e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000862:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000866:	bf22      	ittt	cs
 8000868:	1ab6      	subcs	r6, r6, r2
 800086a:	4675      	movcs	r5, lr
 800086c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000870:	085b      	lsrs	r3, r3, #1
 8000872:	ea4f 0232 	mov.w	r2, r2, rrx
 8000876:	ebb6 0e02 	subs.w	lr, r6, r2
 800087a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800087e:	bf22      	ittt	cs
 8000880:	1ab6      	subcs	r6, r6, r2
 8000882:	4675      	movcs	r5, lr
 8000884:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000888:	085b      	lsrs	r3, r3, #1
 800088a:	ea4f 0232 	mov.w	r2, r2, rrx
 800088e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000892:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000896:	bf22      	ittt	cs
 8000898:	1ab6      	subcs	r6, r6, r2
 800089a:	4675      	movcs	r5, lr
 800089c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80008a0:	ea55 0e06 	orrs.w	lr, r5, r6
 80008a4:	d018      	beq.n	80008d8 <__aeabi_ddiv+0x114>
 80008a6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80008aa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80008ae:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80008b2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80008b6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80008ba:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80008be:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80008c2:	d1c0      	bne.n	8000846 <__aeabi_ddiv+0x82>
 80008c4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80008c8:	d10b      	bne.n	80008e2 <__aeabi_ddiv+0x11e>
 80008ca:	ea41 0100 	orr.w	r1, r1, r0
 80008ce:	f04f 0000 	mov.w	r0, #0
 80008d2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80008d6:	e7b6      	b.n	8000846 <__aeabi_ddiv+0x82>
 80008d8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80008dc:	bf04      	itt	eq
 80008de:	4301      	orreq	r1, r0
 80008e0:	2000      	moveq	r0, #0
 80008e2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80008e6:	bf88      	it	hi
 80008e8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80008ec:	f63f aeaf 	bhi.w	800064e <__aeabi_dmul+0xde>
 80008f0:	ebb5 0c03 	subs.w	ip, r5, r3
 80008f4:	bf04      	itt	eq
 80008f6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80008fa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80008fe:	f150 0000 	adcs.w	r0, r0, #0
 8000902:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000906:	bd70      	pop	{r4, r5, r6, pc}
 8000908:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800090c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000910:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000914:	bfc2      	ittt	gt
 8000916:	ebd4 050c 	rsbsgt	r5, r4, ip
 800091a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800091e:	bd70      	popgt	{r4, r5, r6, pc}
 8000920:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000924:	f04f 0e00 	mov.w	lr, #0
 8000928:	3c01      	subs	r4, #1
 800092a:	e690      	b.n	800064e <__aeabi_dmul+0xde>
 800092c:	ea45 0e06 	orr.w	lr, r5, r6
 8000930:	e68d      	b.n	800064e <__aeabi_dmul+0xde>
 8000932:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000936:	ea94 0f0c 	teq	r4, ip
 800093a:	bf08      	it	eq
 800093c:	ea95 0f0c 	teqeq	r5, ip
 8000940:	f43f af3b 	beq.w	80007ba <__aeabi_dmul+0x24a>
 8000944:	ea94 0f0c 	teq	r4, ip
 8000948:	d10a      	bne.n	8000960 <__aeabi_ddiv+0x19c>
 800094a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800094e:	f47f af34 	bne.w	80007ba <__aeabi_dmul+0x24a>
 8000952:	ea95 0f0c 	teq	r5, ip
 8000956:	f47f af25 	bne.w	80007a4 <__aeabi_dmul+0x234>
 800095a:	4610      	mov	r0, r2
 800095c:	4619      	mov	r1, r3
 800095e:	e72c      	b.n	80007ba <__aeabi_dmul+0x24a>
 8000960:	ea95 0f0c 	teq	r5, ip
 8000964:	d106      	bne.n	8000974 <__aeabi_ddiv+0x1b0>
 8000966:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800096a:	f43f aefd 	beq.w	8000768 <__aeabi_dmul+0x1f8>
 800096e:	4610      	mov	r0, r2
 8000970:	4619      	mov	r1, r3
 8000972:	e722      	b.n	80007ba <__aeabi_dmul+0x24a>
 8000974:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000978:	bf18      	it	ne
 800097a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800097e:	f47f aec5 	bne.w	800070c <__aeabi_dmul+0x19c>
 8000982:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000986:	f47f af0d 	bne.w	80007a4 <__aeabi_dmul+0x234>
 800098a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800098e:	f47f aeeb 	bne.w	8000768 <__aeabi_dmul+0x1f8>
 8000992:	e712      	b.n	80007ba <__aeabi_dmul+0x24a>

08000994 <__aeabi_uldivmod>:
 8000994:	b953      	cbnz	r3, 80009ac <__aeabi_uldivmod+0x18>
 8000996:	b94a      	cbnz	r2, 80009ac <__aeabi_uldivmod+0x18>
 8000998:	2900      	cmp	r1, #0
 800099a:	bf08      	it	eq
 800099c:	2800      	cmpeq	r0, #0
 800099e:	bf1c      	itt	ne
 80009a0:	f04f 31ff 	movne.w	r1, #4294967295
 80009a4:	f04f 30ff 	movne.w	r0, #4294967295
 80009a8:	f000 b96e 	b.w	8000c88 <__aeabi_idiv0>
 80009ac:	f1ad 0c08 	sub.w	ip, sp, #8
 80009b0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80009b4:	f000 f806 	bl	80009c4 <__udivmoddi4>
 80009b8:	f8dd e004 	ldr.w	lr, [sp, #4]
 80009bc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80009c0:	b004      	add	sp, #16
 80009c2:	4770      	bx	lr

080009c4 <__udivmoddi4>:
 80009c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80009c8:	9d08      	ldr	r5, [sp, #32]
 80009ca:	4604      	mov	r4, r0
 80009cc:	468c      	mov	ip, r1
 80009ce:	2b00      	cmp	r3, #0
 80009d0:	f040 8083 	bne.w	8000ada <__udivmoddi4+0x116>
 80009d4:	428a      	cmp	r2, r1
 80009d6:	4617      	mov	r7, r2
 80009d8:	d947      	bls.n	8000a6a <__udivmoddi4+0xa6>
 80009da:	fab2 f282 	clz	r2, r2
 80009de:	b142      	cbz	r2, 80009f2 <__udivmoddi4+0x2e>
 80009e0:	f1c2 0020 	rsb	r0, r2, #32
 80009e4:	fa24 f000 	lsr.w	r0, r4, r0
 80009e8:	4091      	lsls	r1, r2
 80009ea:	4097      	lsls	r7, r2
 80009ec:	ea40 0c01 	orr.w	ip, r0, r1
 80009f0:	4094      	lsls	r4, r2
 80009f2:	ea4f 4817 	mov.w	r8, r7, lsr #16
 80009f6:	0c23      	lsrs	r3, r4, #16
 80009f8:	fbbc f6f8 	udiv	r6, ip, r8
 80009fc:	fa1f fe87 	uxth.w	lr, r7
 8000a00:	fb08 c116 	mls	r1, r8, r6, ip
 8000a04:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000a08:	fb06 f10e 	mul.w	r1, r6, lr
 8000a0c:	4299      	cmp	r1, r3
 8000a0e:	d909      	bls.n	8000a24 <__udivmoddi4+0x60>
 8000a10:	18fb      	adds	r3, r7, r3
 8000a12:	f106 30ff 	add.w	r0, r6, #4294967295
 8000a16:	f080 8119 	bcs.w	8000c4c <__udivmoddi4+0x288>
 8000a1a:	4299      	cmp	r1, r3
 8000a1c:	f240 8116 	bls.w	8000c4c <__udivmoddi4+0x288>
 8000a20:	3e02      	subs	r6, #2
 8000a22:	443b      	add	r3, r7
 8000a24:	1a5b      	subs	r3, r3, r1
 8000a26:	b2a4      	uxth	r4, r4
 8000a28:	fbb3 f0f8 	udiv	r0, r3, r8
 8000a2c:	fb08 3310 	mls	r3, r8, r0, r3
 8000a30:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000a34:	fb00 fe0e 	mul.w	lr, r0, lr
 8000a38:	45a6      	cmp	lr, r4
 8000a3a:	d909      	bls.n	8000a50 <__udivmoddi4+0x8c>
 8000a3c:	193c      	adds	r4, r7, r4
 8000a3e:	f100 33ff 	add.w	r3, r0, #4294967295
 8000a42:	f080 8105 	bcs.w	8000c50 <__udivmoddi4+0x28c>
 8000a46:	45a6      	cmp	lr, r4
 8000a48:	f240 8102 	bls.w	8000c50 <__udivmoddi4+0x28c>
 8000a4c:	3802      	subs	r0, #2
 8000a4e:	443c      	add	r4, r7
 8000a50:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000a54:	eba4 040e 	sub.w	r4, r4, lr
 8000a58:	2600      	movs	r6, #0
 8000a5a:	b11d      	cbz	r5, 8000a64 <__udivmoddi4+0xa0>
 8000a5c:	40d4      	lsrs	r4, r2
 8000a5e:	2300      	movs	r3, #0
 8000a60:	e9c5 4300 	strd	r4, r3, [r5]
 8000a64:	4631      	mov	r1, r6
 8000a66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000a6a:	b902      	cbnz	r2, 8000a6e <__udivmoddi4+0xaa>
 8000a6c:	deff      	udf	#255	; 0xff
 8000a6e:	fab2 f282 	clz	r2, r2
 8000a72:	2a00      	cmp	r2, #0
 8000a74:	d150      	bne.n	8000b18 <__udivmoddi4+0x154>
 8000a76:	1bcb      	subs	r3, r1, r7
 8000a78:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000a7c:	fa1f f887 	uxth.w	r8, r7
 8000a80:	2601      	movs	r6, #1
 8000a82:	fbb3 fcfe 	udiv	ip, r3, lr
 8000a86:	0c21      	lsrs	r1, r4, #16
 8000a88:	fb0e 331c 	mls	r3, lr, ip, r3
 8000a8c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000a90:	fb08 f30c 	mul.w	r3, r8, ip
 8000a94:	428b      	cmp	r3, r1
 8000a96:	d907      	bls.n	8000aa8 <__udivmoddi4+0xe4>
 8000a98:	1879      	adds	r1, r7, r1
 8000a9a:	f10c 30ff 	add.w	r0, ip, #4294967295
 8000a9e:	d202      	bcs.n	8000aa6 <__udivmoddi4+0xe2>
 8000aa0:	428b      	cmp	r3, r1
 8000aa2:	f200 80e9 	bhi.w	8000c78 <__udivmoddi4+0x2b4>
 8000aa6:	4684      	mov	ip, r0
 8000aa8:	1ac9      	subs	r1, r1, r3
 8000aaa:	b2a3      	uxth	r3, r4
 8000aac:	fbb1 f0fe 	udiv	r0, r1, lr
 8000ab0:	fb0e 1110 	mls	r1, lr, r0, r1
 8000ab4:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 8000ab8:	fb08 f800 	mul.w	r8, r8, r0
 8000abc:	45a0      	cmp	r8, r4
 8000abe:	d907      	bls.n	8000ad0 <__udivmoddi4+0x10c>
 8000ac0:	193c      	adds	r4, r7, r4
 8000ac2:	f100 33ff 	add.w	r3, r0, #4294967295
 8000ac6:	d202      	bcs.n	8000ace <__udivmoddi4+0x10a>
 8000ac8:	45a0      	cmp	r8, r4
 8000aca:	f200 80d9 	bhi.w	8000c80 <__udivmoddi4+0x2bc>
 8000ace:	4618      	mov	r0, r3
 8000ad0:	eba4 0408 	sub.w	r4, r4, r8
 8000ad4:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000ad8:	e7bf      	b.n	8000a5a <__udivmoddi4+0x96>
 8000ada:	428b      	cmp	r3, r1
 8000adc:	d909      	bls.n	8000af2 <__udivmoddi4+0x12e>
 8000ade:	2d00      	cmp	r5, #0
 8000ae0:	f000 80b1 	beq.w	8000c46 <__udivmoddi4+0x282>
 8000ae4:	2600      	movs	r6, #0
 8000ae6:	e9c5 0100 	strd	r0, r1, [r5]
 8000aea:	4630      	mov	r0, r6
 8000aec:	4631      	mov	r1, r6
 8000aee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000af2:	fab3 f683 	clz	r6, r3
 8000af6:	2e00      	cmp	r6, #0
 8000af8:	d14a      	bne.n	8000b90 <__udivmoddi4+0x1cc>
 8000afa:	428b      	cmp	r3, r1
 8000afc:	d302      	bcc.n	8000b04 <__udivmoddi4+0x140>
 8000afe:	4282      	cmp	r2, r0
 8000b00:	f200 80b8 	bhi.w	8000c74 <__udivmoddi4+0x2b0>
 8000b04:	1a84      	subs	r4, r0, r2
 8000b06:	eb61 0103 	sbc.w	r1, r1, r3
 8000b0a:	2001      	movs	r0, #1
 8000b0c:	468c      	mov	ip, r1
 8000b0e:	2d00      	cmp	r5, #0
 8000b10:	d0a8      	beq.n	8000a64 <__udivmoddi4+0xa0>
 8000b12:	e9c5 4c00 	strd	r4, ip, [r5]
 8000b16:	e7a5      	b.n	8000a64 <__udivmoddi4+0xa0>
 8000b18:	f1c2 0320 	rsb	r3, r2, #32
 8000b1c:	fa20 f603 	lsr.w	r6, r0, r3
 8000b20:	4097      	lsls	r7, r2
 8000b22:	fa01 f002 	lsl.w	r0, r1, r2
 8000b26:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000b2a:	40d9      	lsrs	r1, r3
 8000b2c:	4330      	orrs	r0, r6
 8000b2e:	0c03      	lsrs	r3, r0, #16
 8000b30:	fbb1 f6fe 	udiv	r6, r1, lr
 8000b34:	fa1f f887 	uxth.w	r8, r7
 8000b38:	fb0e 1116 	mls	r1, lr, r6, r1
 8000b3c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000b40:	fb06 f108 	mul.w	r1, r6, r8
 8000b44:	4299      	cmp	r1, r3
 8000b46:	fa04 f402 	lsl.w	r4, r4, r2
 8000b4a:	d909      	bls.n	8000b60 <__udivmoddi4+0x19c>
 8000b4c:	18fb      	adds	r3, r7, r3
 8000b4e:	f106 3cff 	add.w	ip, r6, #4294967295
 8000b52:	f080 808d 	bcs.w	8000c70 <__udivmoddi4+0x2ac>
 8000b56:	4299      	cmp	r1, r3
 8000b58:	f240 808a 	bls.w	8000c70 <__udivmoddi4+0x2ac>
 8000b5c:	3e02      	subs	r6, #2
 8000b5e:	443b      	add	r3, r7
 8000b60:	1a5b      	subs	r3, r3, r1
 8000b62:	b281      	uxth	r1, r0
 8000b64:	fbb3 f0fe 	udiv	r0, r3, lr
 8000b68:	fb0e 3310 	mls	r3, lr, r0, r3
 8000b6c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000b70:	fb00 f308 	mul.w	r3, r0, r8
 8000b74:	428b      	cmp	r3, r1
 8000b76:	d907      	bls.n	8000b88 <__udivmoddi4+0x1c4>
 8000b78:	1879      	adds	r1, r7, r1
 8000b7a:	f100 3cff 	add.w	ip, r0, #4294967295
 8000b7e:	d273      	bcs.n	8000c68 <__udivmoddi4+0x2a4>
 8000b80:	428b      	cmp	r3, r1
 8000b82:	d971      	bls.n	8000c68 <__udivmoddi4+0x2a4>
 8000b84:	3802      	subs	r0, #2
 8000b86:	4439      	add	r1, r7
 8000b88:	1acb      	subs	r3, r1, r3
 8000b8a:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8000b8e:	e778      	b.n	8000a82 <__udivmoddi4+0xbe>
 8000b90:	f1c6 0c20 	rsb	ip, r6, #32
 8000b94:	fa03 f406 	lsl.w	r4, r3, r6
 8000b98:	fa22 f30c 	lsr.w	r3, r2, ip
 8000b9c:	431c      	orrs	r4, r3
 8000b9e:	fa20 f70c 	lsr.w	r7, r0, ip
 8000ba2:	fa01 f306 	lsl.w	r3, r1, r6
 8000ba6:	ea4f 4e14 	mov.w	lr, r4, lsr #16
 8000baa:	fa21 f10c 	lsr.w	r1, r1, ip
 8000bae:	431f      	orrs	r7, r3
 8000bb0:	0c3b      	lsrs	r3, r7, #16
 8000bb2:	fbb1 f9fe 	udiv	r9, r1, lr
 8000bb6:	fa1f f884 	uxth.w	r8, r4
 8000bba:	fb0e 1119 	mls	r1, lr, r9, r1
 8000bbe:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8000bc2:	fb09 fa08 	mul.w	sl, r9, r8
 8000bc6:	458a      	cmp	sl, r1
 8000bc8:	fa02 f206 	lsl.w	r2, r2, r6
 8000bcc:	fa00 f306 	lsl.w	r3, r0, r6
 8000bd0:	d908      	bls.n	8000be4 <__udivmoddi4+0x220>
 8000bd2:	1861      	adds	r1, r4, r1
 8000bd4:	f109 30ff 	add.w	r0, r9, #4294967295
 8000bd8:	d248      	bcs.n	8000c6c <__udivmoddi4+0x2a8>
 8000bda:	458a      	cmp	sl, r1
 8000bdc:	d946      	bls.n	8000c6c <__udivmoddi4+0x2a8>
 8000bde:	f1a9 0902 	sub.w	r9, r9, #2
 8000be2:	4421      	add	r1, r4
 8000be4:	eba1 010a 	sub.w	r1, r1, sl
 8000be8:	b2bf      	uxth	r7, r7
 8000bea:	fbb1 f0fe 	udiv	r0, r1, lr
 8000bee:	fb0e 1110 	mls	r1, lr, r0, r1
 8000bf2:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8000bf6:	fb00 f808 	mul.w	r8, r0, r8
 8000bfa:	45b8      	cmp	r8, r7
 8000bfc:	d907      	bls.n	8000c0e <__udivmoddi4+0x24a>
 8000bfe:	19e7      	adds	r7, r4, r7
 8000c00:	f100 31ff 	add.w	r1, r0, #4294967295
 8000c04:	d22e      	bcs.n	8000c64 <__udivmoddi4+0x2a0>
 8000c06:	45b8      	cmp	r8, r7
 8000c08:	d92c      	bls.n	8000c64 <__udivmoddi4+0x2a0>
 8000c0a:	3802      	subs	r0, #2
 8000c0c:	4427      	add	r7, r4
 8000c0e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000c12:	eba7 0708 	sub.w	r7, r7, r8
 8000c16:	fba0 8902 	umull	r8, r9, r0, r2
 8000c1a:	454f      	cmp	r7, r9
 8000c1c:	46c6      	mov	lr, r8
 8000c1e:	4649      	mov	r1, r9
 8000c20:	d31a      	bcc.n	8000c58 <__udivmoddi4+0x294>
 8000c22:	d017      	beq.n	8000c54 <__udivmoddi4+0x290>
 8000c24:	b15d      	cbz	r5, 8000c3e <__udivmoddi4+0x27a>
 8000c26:	ebb3 020e 	subs.w	r2, r3, lr
 8000c2a:	eb67 0701 	sbc.w	r7, r7, r1
 8000c2e:	fa07 fc0c 	lsl.w	ip, r7, ip
 8000c32:	40f2      	lsrs	r2, r6
 8000c34:	ea4c 0202 	orr.w	r2, ip, r2
 8000c38:	40f7      	lsrs	r7, r6
 8000c3a:	e9c5 2700 	strd	r2, r7, [r5]
 8000c3e:	2600      	movs	r6, #0
 8000c40:	4631      	mov	r1, r6
 8000c42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c46:	462e      	mov	r6, r5
 8000c48:	4628      	mov	r0, r5
 8000c4a:	e70b      	b.n	8000a64 <__udivmoddi4+0xa0>
 8000c4c:	4606      	mov	r6, r0
 8000c4e:	e6e9      	b.n	8000a24 <__udivmoddi4+0x60>
 8000c50:	4618      	mov	r0, r3
 8000c52:	e6fd      	b.n	8000a50 <__udivmoddi4+0x8c>
 8000c54:	4543      	cmp	r3, r8
 8000c56:	d2e5      	bcs.n	8000c24 <__udivmoddi4+0x260>
 8000c58:	ebb8 0e02 	subs.w	lr, r8, r2
 8000c5c:	eb69 0104 	sbc.w	r1, r9, r4
 8000c60:	3801      	subs	r0, #1
 8000c62:	e7df      	b.n	8000c24 <__udivmoddi4+0x260>
 8000c64:	4608      	mov	r0, r1
 8000c66:	e7d2      	b.n	8000c0e <__udivmoddi4+0x24a>
 8000c68:	4660      	mov	r0, ip
 8000c6a:	e78d      	b.n	8000b88 <__udivmoddi4+0x1c4>
 8000c6c:	4681      	mov	r9, r0
 8000c6e:	e7b9      	b.n	8000be4 <__udivmoddi4+0x220>
 8000c70:	4666      	mov	r6, ip
 8000c72:	e775      	b.n	8000b60 <__udivmoddi4+0x19c>
 8000c74:	4630      	mov	r0, r6
 8000c76:	e74a      	b.n	8000b0e <__udivmoddi4+0x14a>
 8000c78:	f1ac 0c02 	sub.w	ip, ip, #2
 8000c7c:	4439      	add	r1, r7
 8000c7e:	e713      	b.n	8000aa8 <__udivmoddi4+0xe4>
 8000c80:	3802      	subs	r0, #2
 8000c82:	443c      	add	r4, r7
 8000c84:	e724      	b.n	8000ad0 <__udivmoddi4+0x10c>
 8000c86:	bf00      	nop

08000c88 <__aeabi_idiv0>:
 8000c88:	4770      	bx	lr
 8000c8a:	bf00      	nop

08000c8c <OsStartToRun>:
.type OsStartToRun, %function
.global OsStartToRun
OsStartToRun:
    .fnstart
    .cantunwind
    ldr     r4, =OS_NVIC_SYSPRI2
 8000c8c:	4c28      	ldr	r4, [pc, #160]	; (8000d30 <TaskSwitch+0x42>)
    ldr     r5, =OS_NVIC_PENDSV_PRI
 8000c8e:	4d29      	ldr	r5, [pc, #164]	; (8000d34 <TaskSwitch+0x46>)
    str     r5, [r4]
 8000c90:	6025      	str	r5, [r4, #0]

    ldr     r1, =g_oldTask
 8000c92:	4929      	ldr	r1, [pc, #164]	; (8000d38 <TaskSwitch+0x4a>)
    str     r0, [r1]
 8000c94:	6008      	str	r0, [r1, #0]

    ldr     r1, =g_runTask
 8000c96:	4929      	ldr	r1, [pc, #164]	; (8000d3c <TaskSwitch+0x4e>)
    str     r0, [r1]
 8000c98:	6008      	str	r0, [r1, #0]

    movs    r1, #2
 8000c9a:	2102      	movs	r1, #2
    msr     CONTROL, r1
 8000c9c:	f381 8814 	msr	CONTROL, r1
    ldrh    r7, [r0 , #4]
 8000ca0:	8887      	ldrh	r7, [r0, #4]

    movs    r6,  #OS_TASK_STATUS_RUNNING
 8000ca2:	2610      	movs	r6, #16
    strh    r6,  [r0 , #4]
 8000ca4:	8086      	strh	r6, [r0, #4]

    msr     psp, r3
    subs    r3, r3, #20
    ldr     r3,  [r3]
#else
    ldr     r12, [r0]
 8000ca6:	f8d0 c000 	ldr.w	ip, [r0]

    add     r12, r12, #36
 8000caa:	f10c 0c24 	add.w	ip, ip, #36	; 0x24
    /* __VFP_FP__ is set by -mfpu; __SOFTFP__ is set by -mfloat-abi=soft. */
#if defined(__VFP_FP__) && !defined(__SOFTFP__)
    add     r12, r12, #4
 8000cae:	f10c 0c04 	add.w	ip, ip, #4
#endif

    ldmfd   r12!, {R0-R7}
 8000cb2:	e8bc 00ff 	ldmia.w	ip!, {r0, r1, r2, r3, r4, r5, r6, r7}

    msr     psp, r12
 8000cb6:	f38c 8809 	msr	PSP, ip

#ifdef LOSCFG_ARCH_FPU_ENABLE
    vpush   {s0};
 8000cba:	ed2d 0a01 	vpush	{s0}
    vpop    {s0};
 8000cbe:	ecbd 0a01 	vpop	{s0}
#endif

#endif

    mov     lr, r5
 8000cc2:	46ae      	mov	lr, r5

    cpsie   I
 8000cc4:	b662      	cpsie	i
    bx      r6
 8000cc6:	4730      	bx	r6

08000cc8 <ArchIntLock>:
.type ArchIntLock, %function
.global ArchIntLock
ArchIntLock:
    .fnstart
    .cantunwind
    mrs     r0, PRIMASK
 8000cc8:	f3ef 8010 	mrs	r0, PRIMASK
    cpsid   I
 8000ccc:	b672      	cpsid	i
    bx      lr
 8000cce:	4770      	bx	lr

08000cd0 <ArchIntUnlock>:
.type ArchIntUnlock, %function
.global ArchIntUnlock
ArchIntUnlock:
    .fnstart
    .cantunwind
    mrs     r0, PRIMASK
 8000cd0:	f3ef 8010 	mrs	r0, PRIMASK
    cpsie   I
 8000cd4:	b662      	cpsie	i
    bx      lr
 8000cd6:	4770      	bx	lr

08000cd8 <ArchIntRestore>:
.type ArchIntRestore, %function
.global ArchIntRestore
ArchIntRestore:
    .fnstart
    .cantunwind
    msr     PRIMASK, r0
 8000cd8:	f380 8810 	msr	PRIMASK, r0
    bx      lr
 8000cdc:	4770      	bx	lr

08000cde <OsTaskSchedule>:
.type OsTaskSchedule, %function
.global OsTaskSchedule
OsTaskSchedule:
    .fnstart
    .cantunwind
    ldr     r2, =OS_NVIC_INT_CTRL
 8000cde:	4a18      	ldr	r2, [pc, #96]	; (8000d40 <TaskSwitch+0x52>)
    ldr     r3, =OS_NVIC_PENDSVSET
 8000ce0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    str     r3, [r2]
 8000ce4:	6013      	str	r3, [r2, #0]
    bx      lr
 8000ce6:	4770      	bx	lr

08000ce8 <osPendSV>:
.type osPendSV, %function
.global osPendSV
osPendSV:
    .fnstart
    .cantunwind
    mrs     r12, PRIMASK
 8000ce8:	f3ef 8c10 	mrs	ip, PRIMASK
    cpsid   I
 8000cec:	b672      	cpsid	i

08000cee <TaskSwitch>:

TaskSwitch:
    mrs     r0, psp
 8000cee:	f3ef 8009 	mrs	r0, PSP

    subs    r0, #36
#else
#if defined(__VFP_FP__) && !defined(__SOFTFP__)
    /* when enter the exc or interrut, lr's value is EXC_RETURN. If FPCA = 1, the 4's bit of EXC_RETURN is 0. */
    tst     lr, #0x10
 8000cf2:	f01e 0f10 	tst.w	lr, #16
    it      eq
 8000cf6:	bf08      	it	eq
    vstmdbeq  r0!, {d8-d15} /* push VFP registers. */
 8000cf8:	ed20 8b10 	vstmdbeq	r0!, {d8-d15}
    stmfd     r0!, {r14}
 8000cfc:	f840 ed04 	str.w	lr, [r0, #-4]!
#endif
    stmfd   r0!, {r4-r12}
 8000d00:	e920 1ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#endif
    ldr     r5, =g_oldTask
 8000d04:	4d0c      	ldr	r5, [pc, #48]	; (8000d38 <TaskSwitch+0x4a>)
    ldr     r1, [r5]
 8000d06:	6829      	ldr	r1, [r5, #0]
    str     r0, [r1]
 8000d08:	6008      	str	r0, [r1, #0]

    ldr     r0, =g_runTask
 8000d0a:	480c      	ldr	r0, [pc, #48]	; (8000d3c <TaskSwitch+0x4e>)
    ldr     r0, [r0]
 8000d0c:	6800      	ldr	r0, [r0, #0]
    /* g_oldTask = g_runTask */
    str     r0, [r5]
 8000d0e:	6028      	str	r0, [r5, #0]
    ldr     r1, [r0]
 8000d10:	6801      	ldr	r1, [r0, #0]
    subs    r1,  #36
    ldmfd   r1!, {r4-r7}

    adds    r1,   #20
#else
    ldmfd   r1!, {r4-r12}
 8000d12:	e8b1 1ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#endif

#if defined(__VFP_FP__) && !defined(__SOFTFP__)
    ldmfd   r1!, {r14}
 8000d16:	f851 eb04 	ldr.w	lr, [r1], #4
    tst     r14, #0x10
 8000d1a:	f01e 0f10 	tst.w	lr, #16
    it      eq
 8000d1e:	bf08      	it	eq
    vldmiaeq r1!, {d8-d15}
 8000d20:	ecb1 8b10 	vldmiaeq	r1!, {d8-d15}
#endif

    msr     psp,  r1
 8000d24:	f381 8809 	msr	PSP, r1

    msr     PRIMASK, r12
 8000d28:	f38c 8810 	msr	PRIMASK, ip
    bx      lr
 8000d2c:	4770      	bx	lr
 8000d2e:	0000      	.short	0x0000
    ldr     r4, =OS_NVIC_SYSPRI2
 8000d30:	e000ed20 	.word	0xe000ed20
    ldr     r5, =OS_NVIC_PENDSV_PRI
 8000d34:	f0f00000 	.word	0xf0f00000
    ldr     r1, =g_oldTask
 8000d38:	200033d0 	.word	0x200033d0
    ldr     r1, =g_runTask
 8000d3c:	200033cc 	.word	0x200033cc
    ldr     r2, =OS_NVIC_INT_CTRL
 8000d40:	e000ed04 	.word	0xe000ed04

08000d44 <OsExcNMI>:
    .type OsExcNMI, %function
    .global OsExcNMI
OsExcNMI:
    .fnstart
    .cantunwind
    MOV  R0, #OS_EXC_CAUSE_NMI
 8000d44:	f04f 0010 	mov.w	r0, #16
    MOV  R1, #0
 8000d48:	f04f 0100 	mov.w	r1, #0
    B    OsExcDispatch
 8000d4c:	e074      	b.n	8000e38 <OsExcDispatch>

08000d4e <OsExcHardFault>:
    .type OsExcHardFault, %function
    .global OsExcHardFault
OsExcHardFault:
    .fnstart
    .cantunwind
    MOV  R0, #OS_EXC_CAUSE_HARDFAULT
 8000d4e:	f04f 0011 	mov.w	r0, #17
    LDR  R2, =OS_NVIC_HFSR
 8000d52:	4a6e      	ldr	r2, [pc, #440]	; (8000f0c <HandleEntry+0xe>)
    LDR  R2, [R2]
 8000d54:	6812      	ldr	r2, [r2, #0]

    MOV  R1, #HF_DEBUGEVT
 8000d56:	f04f 0114 	mov.w	r1, #20
    ORR  R0, R0, R1, LSL #0x8
 8000d5a:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
    TST  R2, #0x80000000
 8000d5e:	f012 4f00 	tst.w	r2, #2147483648	; 0x80000000
    BNE  OsExcDispatch /* DEBUGEVT */
 8000d62:	d169      	bne.n	8000e38 <OsExcDispatch>

    AND  R0, #0x000000FF
 8000d64:	f000 00ff 	and.w	r0, r0, #255	; 0xff
    MOV  R1, #HF_VECTBL
 8000d68:	f04f 0115 	mov.w	r1, #21
    ORR  R0, R0, R1, LSL #0x8
 8000d6c:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
    TST  R2, #0x00000002
 8000d70:	f012 0f02 	tst.w	r2, #2
    BNE  OsExcDispatch /* VECTBL */
 8000d74:	d160      	bne.n	8000e38 <OsExcDispatch>

    /* if not DEBUGEVT and VECTBL then is FORCED */
    AND  R0, #0x000000FF
 8000d76:	f000 00ff 	and.w	r0, r0, #255	; 0xff

    MRS  R2, MSP
 8000d7a:	f3ef 8208 	mrs	r2, MSP
    LDR  R1, [R2, EXCEPT_FRAME_OFFSET_PC]
 8000d7e:	6991      	ldr	r1, [r2, #24]

    LDR  R2, =OS_NVIC_FSR
 8000d80:	4a63      	ldr	r2, [pc, #396]	; (8000f10 <HandleEntry+0x12>)
    LDR  R2, [R2]
 8000d82:	6812      	ldr	r2, [r2, #0]

    TST  R2, #0x8000 /* BFARVALID */
 8000d84:	f412 4f00 	tst.w	r2, #32768	; 0x8000
    BNE  HFBusFault /* BusFault */
 8000d88:	d106      	bne.n	8000d98 <HFBusFault>

    TST  R2, #0x80 /* MMARVALID */
 8000d8a:	f012 0f80 	tst.w	r2, #128	; 0x80
    BNE  HFMemFault /* MemFault */
 8000d8e:	d109      	bne.n	8000da4 <HFMemFault>

    MOV  R12,#0
 8000d90:	f04f 0c00 	mov.w	ip, #0
    B    OsHFExcCommonBMU
 8000d94:	f000 b80a 	b.w	8000dac <OsHFExcCommonBMU>

08000d98 <HFBusFault>:

    .type HFBusFault, %function
HFBusFault:
    .fnstart
    .cantunwind
    LDR  R1, =OS_NVIC_BFAR
 8000d98:	495e      	ldr	r1, [pc, #376]	; (8000f14 <HandleEntry+0x16>)
    LDR  R1, [R1]
 8000d9a:	6809      	ldr	r1, [r1, #0]
    MOV  R12, #OS_EXC_FLAG_FAULTADDR_VALID
 8000d9c:	f44f 3c80 	mov.w	ip, #65536	; 0x10000
    B    OsHFExcCommonBMU
 8000da0:	f000 b804 	b.w	8000dac <OsHFExcCommonBMU>

08000da4 <HFMemFault>:

    .type HFMemFault, %function
HFMemFault:
    .fnstart
    .cantunwind
    LDR  R1, =OS_NVIC_MMAR
 8000da4:	495c      	ldr	r1, [pc, #368]	; (8000f18 <HandleEntry+0x1a>)
    LDR  R1, [R1]
 8000da6:	6809      	ldr	r1, [r1, #0]
    MOV  R12, #OS_EXC_FLAG_FAULTADDR_VALID
 8000da8:	f44f 3c80 	mov.w	ip, #65536	; 0x10000

08000dac <OsHFExcCommonBMU>:
    .type OsHFExcCommonBMU, %function
    .global OsHFExcCommonBMU
OsHFExcCommonBMU:
    .fnstart
    .cantunwind
    CLZ  R2, R2
 8000dac:	fab2 f282 	clz	r2, r2
    LDR  R3, =g_excTbl
 8000db0:	4b5a      	ldr	r3, [pc, #360]	; (8000f1c <HandleEntry+0x1e>)
    ADD  R3, R3, R2
 8000db2:	4413      	add	r3, r2
    LDRB R2, [R3]
 8000db4:	781a      	ldrb	r2, [r3, #0]
    ORR  R0, R0, R2, LSL #0x8
 8000db6:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
    ORR  R0, R12
 8000dba:	ea40 000c 	orr.w	r0, r0, ip
    B    OsExcDispatch
 8000dbe:	e03b      	b.n	8000e38 <OsExcDispatch>

08000dc0 <OsExcSvcCall>:
    .type OsExcSvcCall, %function
    .global OsExcSvcCall
OsExcSvcCall:
    .fnstart
    .cantunwind
    TST   LR, #0x4
 8000dc0:	f01e 0f04 	tst.w	lr, #4
    ITE   EQ
 8000dc4:	bf0c      	ite	eq
    MRSEQ R0, MSP
 8000dc6:	f3ef 8008 	mrseq	r0, MSP
    MRSNE R0, PSP
 8000dca:	f3ef 8009 	mrsne	r0, PSP
    LDR   R1, [R0,#24]
 8000dce:	6981      	ldr	r1, [r0, #24]
    LDRB  R0, [R1,#-2]
 8000dd0:	f811 0c02 	ldrb.w	r0, [r1, #-2]
    MOV   R1, #0
 8000dd4:	f04f 0100 	mov.w	r1, #0
    B     OsExcDispatch
 8000dd8:	e02e      	b.n	8000e38 <OsExcDispatch>

08000dda <OsExcBusFault>:
    .type OsExcBusFault, %function
    .global OsExcBusFault
OsExcBusFault:
    .fnstart
    .cantunwind
    LDR  R0, =OS_NVIC_FSR
 8000dda:	484d      	ldr	r0, [pc, #308]	; (8000f10 <HandleEntry+0x12>)
    LDR  R0, [R0]
 8000ddc:	6800      	ldr	r0, [r0, #0]

    TST  R0, #0x8000 /* BFARVALID */
 8000dde:	f410 4f00 	tst.w	r0, #32768	; 0x8000
    BEQ  ExcBusNoAddr
 8000de2:	d006      	beq.n	8000df2 <ExcBusNoAddr>
    LDR  R1, =OS_NVIC_BFAR
 8000de4:	494b      	ldr	r1, [pc, #300]	; (8000f14 <HandleEntry+0x16>)
    LDR  R1, [R1]
 8000de6:	6809      	ldr	r1, [r1, #0]
    MOV  R12, #OS_EXC_FLAG_FAULTADDR_VALID
 8000de8:	f44f 3c80 	mov.w	ip, #65536	; 0x10000
    AND  R0, #0x1F00
 8000dec:	f400 50f8 	and.w	r0, r0, #7936	; 0x1f00

    B    OsExcCommonBMU
 8000df0:	e01b      	b.n	8000e2a <OsExcCommonBMU>

08000df2 <ExcBusNoAddr>:

    .type ExcBusNoAddr, %function
ExcBusNoAddr:
    .fnstart
    .cantunwind
    MOV  R12,#0
 8000df2:	f04f 0c00 	mov.w	ip, #0
    B    OsExcCommonBMU
 8000df6:	e018      	b.n	8000e2a <OsExcCommonBMU>

08000df8 <OsExcMemFault>:
    .type OsExcMemFault, %function
    .global OsExcMemFault
OsExcMemFault:
    .fnstart
    .cantunwind
    LDR  R0, =OS_NVIC_FSR
 8000df8:	4845      	ldr	r0, [pc, #276]	; (8000f10 <HandleEntry+0x12>)
    LDR  R0, [R0]
 8000dfa:	6800      	ldr	r0, [r0, #0]

    TST  R0, #0x80 /* MMARVALID */
 8000dfc:	f010 0f80 	tst.w	r0, #128	; 0x80
    BEQ  ExcMemNoAddr
 8000e00:	d006      	beq.n	8000e10 <ExcMemNoAddr>
    LDR  R1, =OS_NVIC_MMAR
 8000e02:	4945      	ldr	r1, [pc, #276]	; (8000f18 <HandleEntry+0x1a>)
    LDR  R1, [R1]
 8000e04:	6809      	ldr	r1, [r1, #0]
    MOV  R12, #OS_EXC_FLAG_FAULTADDR_VALID
 8000e06:	f44f 3c80 	mov.w	ip, #65536	; 0x10000
    AND  R0, #0x1B
 8000e0a:	f000 001b 	and.w	r0, r0, #27

    B    OsExcCommonBMU
 8000e0e:	e00c      	b.n	8000e2a <OsExcCommonBMU>

08000e10 <ExcMemNoAddr>:

    .type ExcMemNoAddr, %function
ExcMemNoAddr:
    .fnstart
    .cantunwind
    MOV  R12,#0
 8000e10:	f04f 0c00 	mov.w	ip, #0
    B    OsExcCommonBMU
 8000e14:	e009      	b.n	8000e2a <OsExcCommonBMU>

08000e16 <OsExcUsageFault>:
    .fnend

    .type OsExcUsageFault, %function
    .global OsExcUsageFault
OsExcUsageFault:
    LDR  R0, =OS_NVIC_FSR
 8000e16:	483e      	ldr	r0, [pc, #248]	; (8000f10 <HandleEntry+0x12>)
    LDR  R0, [R0]
 8000e18:	6800      	ldr	r0, [r0, #0]

    LDR  R1, =#0x030F
 8000e1a:	f240 310f 	movw	r1, #783	; 0x30f
    LSL  R1, #16
 8000e1e:	ea4f 4101 	mov.w	r1, r1, lsl #16
    AND  R0, R1
 8000e22:	ea00 0001 	and.w	r0, r0, r1
    MOV  R12, #0
 8000e26:	f04f 0c00 	mov.w	ip, #0

08000e2a <OsExcCommonBMU>:

OsExcCommonBMU:
    CLZ  R0, R0
 8000e2a:	fab0 f080 	clz	r0, r0
    LDR  R3, =g_excTbl
 8000e2e:	4b3b      	ldr	r3, [pc, #236]	; (8000f1c <HandleEntry+0x1e>)
    ADD  R3, R3, R0
 8000e30:	4403      	add	r3, r0
    LDRB R0, [R3]
 8000e32:	7818      	ldrb	r0, [r3, #0]
    ORR  R0, R0, R12
 8000e34:	ea40 000c 	orr.w	r0, r0, ip

08000e38 <OsExcDispatch>:

/* R0 -- EXCCAUSE(bit 16 is 1 if EXCADDR valid),  R1 -- EXCADDR */
OsExcDispatch:
    LDR   R2, =OS_NVIC_ACT_BASE
 8000e38:	4a39      	ldr	r2, [pc, #228]	; (8000f20 <HandleEntry+0x22>)
    MOV   R12, #8 /* R12 is hwi check loop counter */
 8000e3a:	f04f 0c08 	mov.w	ip, #8

08000e3e <HwiActiveCheck>:

HwiActiveCheck:
    LDR   R3, [R2] /* R3 store active hwi register when exc */
 8000e3e:	6813      	ldr	r3, [r2, #0]
    CMP   R3, #0
 8000e40:	2b00      	cmp	r3, #0
    BEQ   HwiActiveCheckNext
 8000e42:	d01e      	beq.n	8000e82 <HwiActiveCheckNext>

    /* exc occurred in IRQ */
    ORR   R0, #OS_EXC_FLAG_IN_HWI
 8000e44:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
    RBIT  R2, R3
 8000e48:	fa93 f2a3 	rbit	r2, r3
    CLZ   R2, R2
 8000e4c:	fab2 f282 	clz	r2, r2
    AND   R12, #1
 8000e50:	f00c 0c01 	and.w	ip, ip, #1
    ADD   R2, R2, R12, LSL #5 /* calculate R2 (hwi number) as pid, thrid parameter */
 8000e54:	eb02 124c 	add.w	r2, r2, ip, lsl #5

08000e58 <ExcInMSP>:

ExcInMSP:
    CMP   LR, #0xFFFFFFED
 8000e58:	f11e 0f13 	cmn.w	lr, #19
    BNE   NoFloatInMsp
 8000e5c:	d108      	bne.n	8000e70 <NoFloatInMsp>
    ADD   R3, R13, #104
 8000e5e:	ab1a      	add	r3, sp, #104	; 0x68
    PUSH  {R3}
 8000e60:	b408      	push	{r3}
    MRS   R12, PRIMASK /* store message-->exc: disable int */
 8000e62:	f3ef 8c10 	mrs	ip, PRIMASK
    PUSH  {R4-R12} /* store message-->exc: {R4-R12} */
 8000e66:	e92d 1ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    VPUSH {D8-D15}
 8000e6a:	ed2d 8b10 	vpush	{d8-d15}
    B     HandleEntry
 8000e6e:	e046      	b.n	8000efe <HandleEntry>

08000e70 <NoFloatInMsp>:

NoFloatInMsp:
    ADD   R3, R13, #32
 8000e70:	ab08      	add	r3, sp, #32
    PUSH  {R3} /* save IRQ SP, store message-->exc: MSP(R13) */
 8000e72:	b408      	push	{r3}

    MRS   R12, PRIMASK /* store message-->exc: disable int? */
 8000e74:	f3ef 8c10 	mrs	ip, PRIMASK
    PUSH  {R4-R12} /* store message-->exc: {R4-R12} */
 8000e78:	e92d 1ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    ORR   R0, R0, #OS_EXC_FLAG_NO_FLOAT
 8000e7c:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000
    B     HandleEntry
 8000e80:	e03d      	b.n	8000efe <HandleEntry>

08000e82 <HwiActiveCheckNext>:

HwiActiveCheckNext:
    ADD   R2, #4 /* next NVIC ACT ADDR */
 8000e82:	f102 0204 	add.w	r2, r2, #4
    SUBS  R12, #1
 8000e86:	f1bc 0c01 	subs.w	ip, ip, #1
    BNE   HwiActiveCheck
 8000e8a:	d1d8      	bne.n	8000e3e <HwiActiveCheck>

    /* NMI interrupt excption */
    LDR   R2, =OS_NVIC_SHCSRS
 8000e8c:	4a25      	ldr	r2, [pc, #148]	; (8000f24 <HandleEntry+0x26>)
    LDRH  R2,[R2]
 8000e8e:	8812      	ldrh	r2, [r2, #0]
    LDR   R3,=OS_NVIC_SHCSR_MASK
 8000e90:	f44f 6340 	mov.w	r3, #3072	; 0xc00
    AND   R2, R2,R3
 8000e94:	ea02 0203 	and.w	r2, r2, r3
    CMP   R2,#0
 8000e98:	2a00      	cmp	r2, #0
    BNE   ExcInMSP
 8000e9a:	d1dd      	bne.n	8000e58 <ExcInMSP>

    /* exc occurred in Task or Init or exc reserved for register info from task stack */
    LDR   R2, =g_taskScheduled
 8000e9c:	4a22      	ldr	r2, [pc, #136]	; (8000f28 <HandleEntry+0x2a>)
    LDR   R2, [R2]
 8000e9e:	6812      	ldr	r2, [r2, #0]
    TST   R2, #1 /*os scheduled */
 8000ea0:	f012 0f01 	tst.w	r2, #1
    BEQ   ExcInMSP /* if exc occurred in Init then branch */
 8000ea4:	d0d8      	beq.n	8000e58 <ExcInMSP>


    CMP   LR, #0xFFFFFFED /*auto push floating registers */
 8000ea6:	f11e 0f13 	cmn.w	lr, #19
    BNE   NoFloatInPsp
 8000eaa:	d116      	bne.n	8000eda <NoFloatInPsp>

    /* exc occurred in Task */
    MOV   R2,  R13
 8000eac:	466a      	mov	r2, sp
    SUB   R13, #96 /* add 8 Bytes reg(for STMFD) */
 8000eae:	b098      	sub	sp, #96	; 0x60

    MRS   R3,  PSP
 8000eb0:	f3ef 8309 	mrs	r3, PSP
    ADD   R12, R3, #104
 8000eb4:	f103 0c68 	add.w	ip, r3, #104	; 0x68
    PUSH  {R12} /* save task SP */
 8000eb8:	f84d cd04 	str.w	ip, [sp, #-4]!

    MRS   R12, PRIMASK
 8000ebc:	f3ef 8c10 	mrs	ip, PRIMASK
    PUSH  {R4-R12}
 8000ec0:	e92d 1ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    VPUSH {D8-D15}
 8000ec4:	ed2d 8b10 	vpush	{d8-d15}

    /* copy auto saved task register */
    LDMFD   R3!, {R4-R11} /* R4-R11 store PSP reg(auto push when exc in task) */
 8000ec8:	e8b3 0ff0 	ldmia.w	r3!, {r4, r5, r6, r7, r8, r9, sl, fp}
    VLDMIA  R3!, {D8-D15}
 8000ecc:	ecb3 8b10 	vldmia	r3!, {d8-d15}
    VSTMDB  R2!, {D8-D15}
 8000ed0:	ed22 8b10 	vstmdb	r2!, {d8-d15}
    STMFD   R2!, {R4-R11}
 8000ed4:	e922 0ff0 	stmdb	r2!, {r4, r5, r6, r7, r8, r9, sl, fp}
    B       HandleEntry
 8000ed8:	e011      	b.n	8000efe <HandleEntry>

08000eda <NoFloatInPsp>:

NoFloatInPsp:
    MOV   R2,  R13 /*no auto push floating registers */
 8000eda:	466a      	mov	r2, sp
    SUB   R13, #32 /* add 8 Bytes reg(for STMFD) */
 8000edc:	b088      	sub	sp, #32

    MRS   R3,  PSP
 8000ede:	f3ef 8309 	mrs	r3, PSP
    ADD   R12, R3, #32
 8000ee2:	f103 0c20 	add.w	ip, r3, #32
    PUSH  {R12} /* save task SP */
 8000ee6:	f84d cd04 	str.w	ip, [sp, #-4]!

    MRS   R12, PRIMASK
 8000eea:	f3ef 8c10 	mrs	ip, PRIMASK
    PUSH  {R4-R12}
 8000eee:	e92d 1ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    LDMFD R3, {R4-R11} /* R4-R11 store PSP reg(auto push when exc in task) */
 8000ef2:	e893 0ff0 	ldmia.w	r3, {r4, r5, r6, r7, r8, r9, sl, fp}
    STMFD R2!, {R4-R11}
 8000ef6:	e922 0ff0 	stmdb	r2!, {r4, r5, r6, r7, r8, r9, sl, fp}
    ORR   R0, R0, #OS_EXC_FLAG_NO_FLOAT
 8000efa:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000

08000efe <HandleEntry>:

HandleEntry:
    MOV   R3, R13 /* R13:the 4th param */
 8000efe:	466b      	mov	r3, sp
    CPSID I
 8000f00:	b672      	cpsid	i
    CPSID F
 8000f02:	b671      	cpsid	f
    B     OsExcHandleEntry
 8000f04:	f015 bbfc 	b.w	8016700 <OsExcHandleEntry>

    NOP
 8000f08:	bf00      	nop
 8000f0a:	0000      	.short	0x0000
    LDR  R2, =OS_NVIC_HFSR
 8000f0c:	e000ed2c 	.word	0xe000ed2c
    LDR  R2, =OS_NVIC_FSR
 8000f10:	e000ed28 	.word	0xe000ed28
    LDR  R1, =OS_NVIC_BFAR
 8000f14:	e000ed38 	.word	0xe000ed38
    LDR  R1, =OS_NVIC_MMAR
 8000f18:	e000ed34 	.word	0xe000ed34
    LDR  R3, =g_excTbl
 8000f1c:	2000050c 	.word	0x2000050c
    LDR   R2, =OS_NVIC_ACT_BASE
 8000f20:	e000e300 	.word	0xe000e300
    LDR   R2, =OS_NVIC_SHCSRS
 8000f24:	e000ed24 	.word	0xe000ed24
    LDR   R2, =g_taskScheduled
 8000f28:	200036dc 	.word	0x200036dc

08000f2c <__gedf2>:
 8000f2c:	f04f 3cff 	mov.w	ip, #4294967295
 8000f30:	e006      	b.n	8000f40 <__cmpdf2+0x4>
 8000f32:	bf00      	nop

08000f34 <__ledf2>:
 8000f34:	f04f 0c01 	mov.w	ip, #1
 8000f38:	e002      	b.n	8000f40 <__cmpdf2+0x4>
 8000f3a:	bf00      	nop

08000f3c <__cmpdf2>:
 8000f3c:	f04f 0c01 	mov.w	ip, #1
 8000f40:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000f44:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000f48:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000f4c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000f50:	bf18      	it	ne
 8000f52:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000f56:	d01b      	beq.n	8000f90 <__cmpdf2+0x54>
 8000f58:	b001      	add	sp, #4
 8000f5a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000f5e:	bf0c      	ite	eq
 8000f60:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000f64:	ea91 0f03 	teqne	r1, r3
 8000f68:	bf02      	ittt	eq
 8000f6a:	ea90 0f02 	teqeq	r0, r2
 8000f6e:	2000      	moveq	r0, #0
 8000f70:	4770      	bxeq	lr
 8000f72:	f110 0f00 	cmn.w	r0, #0
 8000f76:	ea91 0f03 	teq	r1, r3
 8000f7a:	bf58      	it	pl
 8000f7c:	4299      	cmppl	r1, r3
 8000f7e:	bf08      	it	eq
 8000f80:	4290      	cmpeq	r0, r2
 8000f82:	bf2c      	ite	cs
 8000f84:	17d8      	asrcs	r0, r3, #31
 8000f86:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000f8a:	f040 0001 	orr.w	r0, r0, #1
 8000f8e:	4770      	bx	lr
 8000f90:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000f94:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000f98:	d102      	bne.n	8000fa0 <__cmpdf2+0x64>
 8000f9a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000f9e:	d107      	bne.n	8000fb0 <__cmpdf2+0x74>
 8000fa0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000fa4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000fa8:	d1d6      	bne.n	8000f58 <__cmpdf2+0x1c>
 8000faa:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000fae:	d0d3      	beq.n	8000f58 <__cmpdf2+0x1c>
 8000fb0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000fb4:	4770      	bx	lr
 8000fb6:	bf00      	nop

08000fb8 <__aeabi_cdrcmple>:
 8000fb8:	4684      	mov	ip, r0
 8000fba:	4610      	mov	r0, r2
 8000fbc:	4662      	mov	r2, ip
 8000fbe:	468c      	mov	ip, r1
 8000fc0:	4619      	mov	r1, r3
 8000fc2:	4663      	mov	r3, ip
 8000fc4:	e000      	b.n	8000fc8 <__aeabi_cdcmpeq>
 8000fc6:	bf00      	nop

08000fc8 <__aeabi_cdcmpeq>:
 8000fc8:	b501      	push	{r0, lr}
 8000fca:	f7ff ffb7 	bl	8000f3c <__cmpdf2>
 8000fce:	2800      	cmp	r0, #0
 8000fd0:	bf48      	it	mi
 8000fd2:	f110 0f00 	cmnmi.w	r0, #0
 8000fd6:	bd01      	pop	{r0, pc}

08000fd8 <__aeabi_dcmpeq>:
 8000fd8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000fdc:	f7ff fff4 	bl	8000fc8 <__aeabi_cdcmpeq>
 8000fe0:	bf0c      	ite	eq
 8000fe2:	2001      	moveq	r0, #1
 8000fe4:	2000      	movne	r0, #0
 8000fe6:	f85d fb08 	ldr.w	pc, [sp], #8
 8000fea:	bf00      	nop

08000fec <__aeabi_dcmplt>:
 8000fec:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ff0:	f7ff ffea 	bl	8000fc8 <__aeabi_cdcmpeq>
 8000ff4:	bf34      	ite	cc
 8000ff6:	2001      	movcc	r0, #1
 8000ff8:	2000      	movcs	r0, #0
 8000ffa:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ffe:	bf00      	nop

08001000 <__aeabi_dcmple>:
 8001000:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001004:	f7ff ffe0 	bl	8000fc8 <__aeabi_cdcmpeq>
 8001008:	bf94      	ite	ls
 800100a:	2001      	movls	r0, #1
 800100c:	2000      	movhi	r0, #0
 800100e:	f85d fb08 	ldr.w	pc, [sp], #8
 8001012:	bf00      	nop

08001014 <__aeabi_dcmpge>:
 8001014:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001018:	f7ff ffce 	bl	8000fb8 <__aeabi_cdrcmple>
 800101c:	bf94      	ite	ls
 800101e:	2001      	movls	r0, #1
 8001020:	2000      	movhi	r0, #0
 8001022:	f85d fb08 	ldr.w	pc, [sp], #8
 8001026:	bf00      	nop

08001028 <__aeabi_dcmpgt>:
 8001028:	f84d ed08 	str.w	lr, [sp, #-8]!
 800102c:	f7ff ffc4 	bl	8000fb8 <__aeabi_cdrcmple>
 8001030:	bf34      	ite	cc
 8001032:	2001      	movcc	r0, #1
 8001034:	2000      	movcs	r0, #0
 8001036:	f85d fb08 	ldr.w	pc, [sp], #8
 800103a:	bf00      	nop

0800103c <__aeabi_d2iz>:
 800103c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8001040:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8001044:	d215      	bcs.n	8001072 <__aeabi_d2iz+0x36>
 8001046:	d511      	bpl.n	800106c <__aeabi_d2iz+0x30>
 8001048:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800104c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8001050:	d912      	bls.n	8001078 <__aeabi_d2iz+0x3c>
 8001052:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8001056:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800105a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800105e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8001062:	fa23 f002 	lsr.w	r0, r3, r2
 8001066:	bf18      	it	ne
 8001068:	4240      	negne	r0, r0
 800106a:	4770      	bx	lr
 800106c:	f04f 0000 	mov.w	r0, #0
 8001070:	4770      	bx	lr
 8001072:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8001076:	d105      	bne.n	8001084 <__aeabi_d2iz+0x48>
 8001078:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 800107c:	bf08      	it	eq
 800107e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8001082:	4770      	bx	lr
 8001084:	f04f 0000 	mov.w	r0, #0
 8001088:	4770      	bx	lr
 800108a:	bf00      	nop

0800108c <__aeabi_d2uiz>:
 800108c:	004a      	lsls	r2, r1, #1
 800108e:	d211      	bcs.n	80010b4 <__aeabi_d2uiz+0x28>
 8001090:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8001094:	d211      	bcs.n	80010ba <__aeabi_d2uiz+0x2e>
 8001096:	d50d      	bpl.n	80010b4 <__aeabi_d2uiz+0x28>
 8001098:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800109c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80010a0:	d40e      	bmi.n	80010c0 <__aeabi_d2uiz+0x34>
 80010a2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80010a6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80010aa:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80010ae:	fa23 f002 	lsr.w	r0, r3, r2
 80010b2:	4770      	bx	lr
 80010b4:	f04f 0000 	mov.w	r0, #0
 80010b8:	4770      	bx	lr
 80010ba:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80010be:	d102      	bne.n	80010c6 <__aeabi_d2uiz+0x3a>
 80010c0:	f04f 30ff 	mov.w	r0, #4294967295
 80010c4:	4770      	bx	lr
 80010c6:	f04f 0000 	mov.w	r0, #0
 80010ca:	4770      	bx	lr

080010cc <__aeabi_ldivmod>:
 80010cc:	b97b      	cbnz	r3, 80010ee <__aeabi_ldivmod+0x22>
 80010ce:	b972      	cbnz	r2, 80010ee <__aeabi_ldivmod+0x22>
 80010d0:	2900      	cmp	r1, #0
 80010d2:	bfbe      	ittt	lt
 80010d4:	2000      	movlt	r0, #0
 80010d6:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 80010da:	e006      	blt.n	80010ea <__aeabi_ldivmod+0x1e>
 80010dc:	bf08      	it	eq
 80010de:	2800      	cmpeq	r0, #0
 80010e0:	bf1c      	itt	ne
 80010e2:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 80010e6:	f04f 30ff 	movne.w	r0, #4294967295
 80010ea:	f7ff bdcd 	b.w	8000c88 <__aeabi_idiv0>
 80010ee:	f1ad 0c08 	sub.w	ip, sp, #8
 80010f2:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80010f6:	2900      	cmp	r1, #0
 80010f8:	db09      	blt.n	800110e <__aeabi_ldivmod+0x42>
 80010fa:	2b00      	cmp	r3, #0
 80010fc:	db1a      	blt.n	8001134 <__aeabi_ldivmod+0x68>
 80010fe:	f7ff fc61 	bl	80009c4 <__udivmoddi4>
 8001102:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001106:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800110a:	b004      	add	sp, #16
 800110c:	4770      	bx	lr
 800110e:	4240      	negs	r0, r0
 8001110:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8001114:	2b00      	cmp	r3, #0
 8001116:	db1b      	blt.n	8001150 <__aeabi_ldivmod+0x84>
 8001118:	f7ff fc54 	bl	80009c4 <__udivmoddi4>
 800111c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001120:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8001124:	b004      	add	sp, #16
 8001126:	4240      	negs	r0, r0
 8001128:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800112c:	4252      	negs	r2, r2
 800112e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8001132:	4770      	bx	lr
 8001134:	4252      	negs	r2, r2
 8001136:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800113a:	f7ff fc43 	bl	80009c4 <__udivmoddi4>
 800113e:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001142:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8001146:	b004      	add	sp, #16
 8001148:	4240      	negs	r0, r0
 800114a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800114e:	4770      	bx	lr
 8001150:	4252      	negs	r2, r2
 8001152:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8001156:	f7ff fc35 	bl	80009c4 <__udivmoddi4>
 800115a:	f8dd e004 	ldr.w	lr, [sp, #4]
 800115e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8001162:	b004      	add	sp, #16
 8001164:	4252      	negs	r2, r2
 8001166:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800116a:	4770      	bx	lr

0800116c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler: 
  cpsid i 
 800116c:	b672      	cpsid	i
  ldr   sp, =_estack      /* set stack pointer */
 800116e:	f8df d048 	ldr.w	sp, [pc, #72]	; 80011b8 <LoopFillZerobss+0x10>

  movs  r1, #0
 8001172:	2100      	movs	r1, #0
  b  LoopCopyVectorInit
 8001174:	e003      	b.n	800117e <LoopCopyVectorInit>

08001176 <CopyVectorInit>:

CopyVectorInit:
  ldr   r3, =_si_liteos_vector_data
 8001176:	4b11      	ldr	r3, [pc, #68]	; (80011bc <LoopFillZerobss+0x14>)
  ldr   r3, [r3, r1]
 8001178:	585b      	ldr	r3, [r3, r1]
  str   r3, [r0, r1]
 800117a:	5043      	str	r3, [r0, r1]
  adds   r1, r1, #4
 800117c:	3104      	adds	r1, #4

0800117e <LoopCopyVectorInit>:

LoopCopyVectorInit:
  ldr   r0, =_s_liteos_vector
 800117e:	4810      	ldr	r0, [pc, #64]	; (80011c0 <LoopFillZerobss+0x18>)
  ldr   r3, =_e_liteos_vector
 8001180:	4b10      	ldr	r3, [pc, #64]	; (80011c4 <LoopFillZerobss+0x1c>)
  adds   r2, r0, r1
 8001182:	1842      	adds	r2, r0, r1
  cmp   r2, r3
 8001184:	429a      	cmp	r2, r3
  bcc   CopyVectorInit
 8001186:	d3f6      	bcc.n	8001176 <CopyVectorInit>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8001188:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800118a:	e003      	b.n	8001194 <LoopCopyDataInit>

0800118c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800118c:	4b0e      	ldr	r3, [pc, #56]	; (80011c8 <LoopFillZerobss+0x20>)
  ldr  r3, [r3, r1]
 800118e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8001190:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8001192:	3104      	adds	r1, #4

08001194 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8001194:	480d      	ldr	r0, [pc, #52]	; (80011cc <LoopFillZerobss+0x24>)
  ldr  r3, =_edata
 8001196:	4b0e      	ldr	r3, [pc, #56]	; (80011d0 <LoopFillZerobss+0x28>)
  adds  r2, r0, r1
 8001198:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800119a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800119c:	d3f6      	bcc.n	800118c <CopyDataInit>
  ldr  r2, =_sbss
 800119e:	4a0d      	ldr	r2, [pc, #52]	; (80011d4 <LoopFillZerobss+0x2c>)
  b  LoopFillZerobss
 80011a0:	e002      	b.n	80011a8 <LoopFillZerobss>

080011a2 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80011a2:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80011a4:	f842 3b04 	str.w	r3, [r2], #4

080011a8 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80011a8:	4b0b      	ldr	r3, [pc, #44]	; (80011d8 <LoopFillZerobss+0x30>)
  cmp  r2, r3
 80011aa:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80011ac:	d3f9      	bcc.n	80011a2 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 80011ae:	f000 f829 	bl	8001204 <SystemInit>
/* Call static constructors */
/*    bl __libc_init_array */
/* Call the application's entry point.*/
  bl  main
 80011b2:	f000 f89b 	bl	80012ec <main>
  bx  lr    
 80011b6:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 80011b8:	20080000 	.word	0x20080000
  ldr   r3, =_si_liteos_vector_data
 80011bc:	08024384 	.word	0x08024384
  ldr   r0, =_s_liteos_vector
 80011c0:	20000000 	.word	0x20000000
  ldr   r3, =_e_liteos_vector
 80011c4:	20000400 	.word	0x20000400
  ldr  r3, =_sidata
 80011c8:	08024784 	.word	0x08024784
  ldr  r0, =_sdata
 80011cc:	20000400 	.word	0x20000400
  ldr  r3, =_edata
 80011d0:	20000724 	.word	0x20000724
  ldr  r2, =_sbss
 80011d4:	20000728 	.word	0x20000728
  ldr  r3, = _ebss
 80011d8:	200037e0 	.word	0x200037e0

080011dc <IrqEntryV7M_Handler>:
    .section  .text.IrqEntryV7M_Handler
  .weak  IrqEntryV7M_Handler
  .type  IrqEntryV7M_Handler, %function
IrqEntryV7M_Handler: 

   push  {r0, r1}                      /* 保存R0,R1 */
 80011dc:	b403      	push	{r0, r1}
   and.w  r0, lr, #4                   /* 判断中断返回使用MSP/PSP */
 80011de:	f00e 0004 	and.w	r0, lr, #4
   cmp  r0, #0                         /*判断逻辑 EXC_RETUR 第2位 */
 80011e2:	2800      	cmp	r0, #0
                                       /* 0=从主堆栈中做出栈操作，返回后使用MSP*/ 
                                       /* 1=从进程堆栈中做出栈操作，返回后使用PSP */
   beq SAVE_MSP
 80011e4:	d002      	beq.n	80011ec <SAVE_MSP>

080011e6 <SAVE_PSP>:

SAVE_PSP:     
   mrs  r0, psp                       /* 保存PSP进程堆栈指针到R0 */
 80011e6:	f3ef 8009 	mrs	r0, PSP
   b SAVE_END 
 80011ea:	e001      	b.n	80011f0 <SAVE_END>

080011ec <SAVE_MSP>:

SAVE_MSP:                             /* 只有ISR 被中断情况，才会用MSP */
   mrs  r0, msp                       /* 保存MSP中断堆栈指针到R0 */
 80011ec:	f3ef 8008 	mrs	r0, MSP

080011f0 <SAVE_END>:

SAVE_END:  
   ldr r0, [r0,#24]                   /* R0+4*6 => PC */
 80011f0:	6980      	ldr	r0, [r0, #24]
   ldr  r1, =g_interrupt_pc           /* g_interrupt_pc 地址赋值给R1 */
 80011f2:	4902      	ldr	r1, [pc, #8]	; (80011fc <SAVE_END+0xc>)
   str  r0, [r1]                      /* 把PC 值赋值g_interrupt_pc */
 80011f4:	6008      	str	r0, [r1, #0]
   pop  {r0,r1}                       /* 恢复RO,R1 */
 80011f6:	bc03      	pop	{r0, r1}
  
   b IrqEntryV7M
 80011f8:	f00f b86a 	b.w	80102d0 <IrqEntryV7M>
   ldr  r1, =g_interrupt_pc           /* g_interrupt_pc 地址赋值给R1 */
 80011fc:	20003764 	.word	0x20003764

08001200 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001200:	e7fe      	b.n	8001200 <ADC_IRQHandler>
	...

08001204 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8001204:	b480      	push	{r7}
 8001206:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001208:	4b15      	ldr	r3, [pc, #84]	; (8001260 <SystemInit+0x5c>)
 800120a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800120e:	4a14      	ldr	r2, [pc, #80]	; (8001260 <SystemInit+0x5c>)
 8001210:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001214:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001218:	4b12      	ldr	r3, [pc, #72]	; (8001264 <SystemInit+0x60>)
 800121a:	681b      	ldr	r3, [r3, #0]
 800121c:	4a11      	ldr	r2, [pc, #68]	; (8001264 <SystemInit+0x60>)
 800121e:	f043 0301 	orr.w	r3, r3, #1
 8001222:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8001224:	4b0f      	ldr	r3, [pc, #60]	; (8001264 <SystemInit+0x60>)
 8001226:	2200      	movs	r2, #0
 8001228:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800122a:	4b0e      	ldr	r3, [pc, #56]	; (8001264 <SystemInit+0x60>)
 800122c:	681a      	ldr	r2, [r3, #0]
 800122e:	490d      	ldr	r1, [pc, #52]	; (8001264 <SystemInit+0x60>)
 8001230:	4b0d      	ldr	r3, [pc, #52]	; (8001268 <SystemInit+0x64>)
 8001232:	4013      	ands	r3, r2
 8001234:	600b      	str	r3, [r1, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8001236:	4b0b      	ldr	r3, [pc, #44]	; (8001264 <SystemInit+0x60>)
 8001238:	4a0c      	ldr	r2, [pc, #48]	; (800126c <SystemInit+0x68>)
 800123a:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800123c:	4b09      	ldr	r3, [pc, #36]	; (8001264 <SystemInit+0x60>)
 800123e:	681b      	ldr	r3, [r3, #0]
 8001240:	4a08      	ldr	r2, [pc, #32]	; (8001264 <SystemInit+0x60>)
 8001242:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001246:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8001248:	4b06      	ldr	r3, [pc, #24]	; (8001264 <SystemInit+0x60>)
 800124a:	2200      	movs	r2, #0
 800124c:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800124e:	4b04      	ldr	r3, [pc, #16]	; (8001260 <SystemInit+0x5c>)
 8001250:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001254:	609a      	str	r2, [r3, #8]
#endif
}
 8001256:	bf00      	nop
 8001258:	46bd      	mov	sp, r7
 800125a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800125e:	4770      	bx	lr
 8001260:	e000ed00 	.word	0xe000ed00
 8001264:	40023800 	.word	0x40023800
 8001268:	fef6ffff 	.word	0xfef6ffff
 800126c:	24003010 	.word	0x24003010

08001270 <ArchCurrTaskSet>:
{
    return g_runTask;
}

STATIC INLINE VOID ArchCurrTaskSet(VOID *val)
{
 8001270:	b480      	push	{r7}
 8001272:	b083      	sub	sp, #12
 8001274:	af00      	add	r7, sp, #0
 8001276:	6078      	str	r0, [r7, #4]
    g_runTask = val;
 8001278:	4a04      	ldr	r2, [pc, #16]	; (800128c <ArchCurrTaskSet+0x1c>)
 800127a:	687b      	ldr	r3, [r7, #4]
 800127c:	6013      	str	r3, [r2, #0]
}
 800127e:	bf00      	nop
 8001280:	370c      	adds	r7, #12
 8001282:	46bd      	mov	sp, r7
 8001284:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001288:	4770      	bx	lr
 800128a:	bf00      	nop
 800128c:	200033cc 	.word	0x200033cc

08001290 <OsCurrTaskSet>:
{
    return (LosTaskCB *)ArchCurrTaskGet();
}

STATIC INLINE VOID OsCurrTaskSet(LosTaskCB *task)
{
 8001290:	b580      	push	{r7, lr}
 8001292:	b082      	sub	sp, #8
 8001294:	af00      	add	r7, sp, #0
 8001296:	6078      	str	r0, [r7, #4]
    ArchCurrTaskSet(task);
 8001298:	6878      	ldr	r0, [r7, #4]
 800129a:	f7ff ffe9 	bl	8001270 <ArchCurrTaskSet>
}
 800129e:	bf00      	nop
 80012a0:	3708      	adds	r7, #8
 80012a2:	46bd      	mov	sp, r7
 80012a4:	bd80      	pop	{r7, pc}
	...

080012a8 <BoardConfig>:
/* USER CODE BEGIN 0 */
// uint32_t pbuff[(32*1024*1024)/4] __attribute__((at(0xD0000000)));
/* USER CODE END 0 */

VOID BoardConfig(VOID)
{
 80012a8:	b480      	push	{r7}
 80012aa:	af00      	add	r7, sp, #0
    g_sys_mem_addr_end = __LOS_HEAP_ADDR_END__;
 80012ac:	4b04      	ldr	r3, [pc, #16]	; (80012c0 <BoardConfig+0x18>)
 80012ae:	681b      	ldr	r3, [r3, #0]
 80012b0:	4a04      	ldr	r2, [pc, #16]	; (80012c4 <BoardConfig+0x1c>)
 80012b2:	6013      	str	r3, [r2, #0]
}
 80012b4:	bf00      	nop
 80012b6:	46bd      	mov	sp, r7
 80012b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80012bc:	4770      	bx	lr
 80012be:	bf00      	nop
 80012c0:	080001f4 	.word	0x080001f4
 80012c4:	20000478 	.word	0x20000478

080012c8 <HardwareInit>:

INT32 HardwareInit(VOID)
{
 80012c8:	b580      	push	{r7, lr}
 80012ca:	af00      	add	r7, sp, #0
    (VOID)HAL_Init();
 80012cc:	f00a ffaa 	bl	800c224 <HAL_Init>
    SystemClock_Config();
 80012d0:	f000 fd62 	bl	8001d98 <SystemClock_Config>
    TimInit();
 80012d4:	f000 fb1e 	bl	8001914 <TimInit>
    MX_GPIO_Init();
 80012d8:	f000 f836 	bl	8001348 <MX_GPIO_Init>
    MX_USART1_UART_Init();
 80012dc:	f000 fbc4 	bl	8001a68 <MX_USART1_UART_Init>
    MX_FMC_Init();   
 80012e0:	f000 f91e 	bl	8001520 <MX_FMC_Init>
    return 0;
 80012e4:	2300      	movs	r3, #0
}
 80012e6:	4618      	mov	r0, r3
 80012e8:	bd80      	pop	{r7, pc}
	...

080012ec <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
INT32 main (VOID)
{
 80012ec:	b580      	push	{r7, lr}
 80012ee:	b082      	sub	sp, #8
 80012f0:	af00      	add	r7, sp, #0
#ifdef __GNUC__
    ArchStackGuardInit();
 80012f2:	f015 f93f 	bl	8016574 <ArchStackGuardInit>
#endif
    OsSetMainTask();
 80012f6:	f00a fddb 	bl	800beb0 <OsSetMainTask>
    OsCurrTaskSet(OsGetMainTask());
 80012fa:	f00a fdc9 	bl	800be90 <OsGetMainTask>
 80012fe:	4603      	mov	r3, r0
 8001300:	4618      	mov	r0, r3
 8001302:	f7ff ffc5 	bl	8001290 <OsCurrTaskSet>

    BoardConfig();
 8001306:	f7ff ffcf 	bl	80012a8 <BoardConfig>
    (VOID)HardwareInit();
 800130a:	f7ff ffdd 	bl	80012c8 <HardwareInit>

    PRINT_RELEASE("\n********Hello Huawei LiteOS********\n"
 800130e:	4b0a      	ldr	r3, [pc, #40]	; (8001338 <main+0x4c>)
 8001310:	4a0a      	ldr	r2, [pc, #40]	; (800133c <main+0x50>)
 8001312:	490b      	ldr	r1, [pc, #44]	; (8001340 <main+0x54>)
 8001314:	480b      	ldr	r0, [pc, #44]	; (8001344 <main+0x58>)
 8001316:	f003 fad3 	bl	80048c0 <dprintf>
                  "\nLiteOS Kernel Version : %s\n"
                  "build date : %s %s\n\n"
                  "**********************************\n",
                  HW_LITEOS_KERNEL_VERSION_STRING, __DATE__, __TIME__);

    UINT32 ret = OsMain();
 800131a:	f00a fed3 	bl	800c0c4 <OsMain>
 800131e:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 8001320:	687b      	ldr	r3, [r7, #4]
 8001322:	2b00      	cmp	r3, #0
 8001324:	d001      	beq.n	800132a <main+0x3e>
        return LOS_NOK;
 8001326:	2301      	movs	r3, #1
 8001328:	e002      	b.n	8001330 <main+0x44>
    }

    OsStart();
 800132a:	f00a fe17 	bl	800bf5c <OsStart>

    return LOS_OK;
 800132e:	2300      	movs	r3, #0
 8001330:	4618      	mov	r0, r3
 8001332:	3708      	adds	r7, #8
 8001334:	46bd      	mov	sp, r7
 8001336:	bd80      	pop	{r7, pc}
 8001338:	0801fd7c 	.word	0x0801fd7c
 800133c:	0801fd88 	.word	0x0801fd88
 8001340:	0801fd94 	.word	0x0801fd94
 8001344:	0801fd9c 	.word	0x0801fd9c

08001348 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8001348:	b580      	push	{r7, lr}
 800134a:	b090      	sub	sp, #64	; 0x40
 800134c:	af00      	add	r7, sp, #0
 800134e:	4b69      	ldr	r3, [pc, #420]	; (80014f4 <MX_GPIO_Init+0x1ac>)
 8001350:	681b      	ldr	r3, [r3, #0]
 8001352:	63fb      	str	r3, [r7, #60]	; 0x3c
 8001354:	f04f 0300 	mov.w	r3, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001358:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800135c:	2200      	movs	r2, #0
 800135e:	601a      	str	r2, [r3, #0]
 8001360:	605a      	str	r2, [r3, #4]
 8001362:	609a      	str	r2, [r3, #8]
 8001364:	60da      	str	r2, [r3, #12]
 8001366:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8001368:	4b63      	ldr	r3, [pc, #396]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800136a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800136c:	4a62      	ldr	r2, [pc, #392]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800136e:	f043 0320 	orr.w	r3, r3, #32
 8001372:	6313      	str	r3, [r2, #48]	; 0x30
 8001374:	4b60      	ldr	r3, [pc, #384]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001376:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001378:	f003 0320 	and.w	r3, r3, #32
 800137c:	607b      	str	r3, [r7, #4]
 800137e:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8001380:	4b5d      	ldr	r3, [pc, #372]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001382:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001384:	4a5c      	ldr	r2, [pc, #368]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001386:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800138a:	6313      	str	r3, [r2, #48]	; 0x30
 800138c:	4b5a      	ldr	r3, [pc, #360]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800138e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001390:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8001394:	60bb      	str	r3, [r7, #8]
 8001396:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001398:	4b57      	ldr	r3, [pc, #348]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800139a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800139c:	4a56      	ldr	r2, [pc, #344]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800139e:	f043 0304 	orr.w	r3, r3, #4
 80013a2:	6313      	str	r3, [r2, #48]	; 0x30
 80013a4:	4b54      	ldr	r3, [pc, #336]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013a8:	f003 0304 	and.w	r3, r3, #4
 80013ac:	60fb      	str	r3, [r7, #12]
 80013ae:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80013b0:	4b51      	ldr	r3, [pc, #324]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013b4:	4a50      	ldr	r2, [pc, #320]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013b6:	f043 0301 	orr.w	r3, r3, #1
 80013ba:	6313      	str	r3, [r2, #48]	; 0x30
 80013bc:	4b4e      	ldr	r3, [pc, #312]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013c0:	f003 0301 	and.w	r3, r3, #1
 80013c4:	613b      	str	r3, [r7, #16]
 80013c6:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 80013c8:	4b4b      	ldr	r3, [pc, #300]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013cc:	4a4a      	ldr	r2, [pc, #296]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013ce:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80013d2:	6313      	str	r3, [r2, #48]	; 0x30
 80013d4:	4b48      	ldr	r3, [pc, #288]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013d8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80013dc:	617b      	str	r3, [r7, #20]
 80013de:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80013e0:	4b45      	ldr	r3, [pc, #276]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013e4:	4a44      	ldr	r2, [pc, #272]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013e6:	f043 0310 	orr.w	r3, r3, #16
 80013ea:	6313      	str	r3, [r2, #48]	; 0x30
 80013ec:	4b42      	ldr	r3, [pc, #264]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013f0:	f003 0310 	and.w	r3, r3, #16
 80013f4:	61bb      	str	r3, [r7, #24]
 80013f6:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80013f8:	4b3f      	ldr	r3, [pc, #252]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80013fc:	4a3e      	ldr	r2, [pc, #248]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 80013fe:	f043 0308 	orr.w	r3, r3, #8
 8001402:	6313      	str	r3, [r2, #48]	; 0x30
 8001404:	4b3c      	ldr	r3, [pc, #240]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001406:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001408:	f003 0308 	and.w	r3, r3, #8
 800140c:	61fb      	str	r3, [r7, #28]
 800140e:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001410:	4b39      	ldr	r3, [pc, #228]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001412:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001414:	4a38      	ldr	r2, [pc, #224]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001416:	f043 0302 	orr.w	r3, r3, #2
 800141a:	6313      	str	r3, [r2, #48]	; 0x30
 800141c:	4b36      	ldr	r3, [pc, #216]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800141e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001420:	f003 0302 	and.w	r3, r3, #2
 8001424:	623b      	str	r3, [r7, #32]
 8001426:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOI_CLK_ENABLE();
 8001428:	4b33      	ldr	r3, [pc, #204]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800142a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800142c:	4a32      	ldr	r2, [pc, #200]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 800142e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001432:	6313      	str	r3, [r2, #48]	; 0x30
 8001434:	4b30      	ldr	r3, [pc, #192]	; (80014f8 <MX_GPIO_Init+0x1b0>)
 8001436:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001438:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800143c:	627b      	str	r3, [r7, #36]	; 0x24
 800143e:	6a7b      	ldr	r3, [r7, #36]	; 0x24

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 8001440:	2200      	movs	r2, #0
 8001442:	2110      	movs	r1, #16
 8001444:	482d      	ldr	r0, [pc, #180]	; (80014fc <MX_GPIO_Init+0x1b4>)
 8001446:	f00d f847 	bl	800e4d8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOH, GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12, GPIO_PIN_RESET);
 800144a:	2200      	movs	r2, #0
 800144c:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
 8001450:	482b      	ldr	r0, [pc, #172]	; (8001500 <MX_GPIO_Init+0x1b8>)
 8001452:	f00d f841 	bl	800e4d8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8001456:	2200      	movs	r2, #0
 8001458:	21c0      	movs	r1, #192	; 0xc0
 800145a:	482a      	ldr	r0, [pc, #168]	; (8001504 <MX_GPIO_Init+0x1bc>)
 800145c:	f00d f83c 	bl	800e4d8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOI, GPIO_PIN_7, GPIO_PIN_RESET);
 8001460:	2200      	movs	r2, #0
 8001462:	2180      	movs	r1, #128	; 0x80
 8001464:	4828      	ldr	r0, [pc, #160]	; (8001508 <MX_GPIO_Init+0x1c0>)
 8001466:	f00d f837 	bl	800e4d8 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PA4 */
  GPIO_InitStruct.Pin = GPIO_PIN_4;
 800146a:	2310      	movs	r3, #16
 800146c:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800146e:	2301      	movs	r3, #1
 8001470:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001472:	2300      	movs	r3, #0
 8001474:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001476:	2300      	movs	r3, #0
 8001478:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800147a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800147e:	4619      	mov	r1, r3
 8001480:	481e      	ldr	r0, [pc, #120]	; (80014fc <MX_GPIO_Init+0x1b4>)
 8001482:	f00c fe7d 	bl	800e180 <HAL_GPIO_Init>

  /*Configure GPIO pins : PH10 PH11 PH12 */
  GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
 8001486:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800148a:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800148c:	2301      	movs	r3, #1
 800148e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001490:	2300      	movs	r3, #0
 8001492:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001494:	2300      	movs	r3, #0
 8001496:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8001498:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800149c:	4619      	mov	r1, r3
 800149e:	4818      	ldr	r0, [pc, #96]	; (8001500 <MX_GPIO_Init+0x1b8>)
 80014a0:	f00c fe6e 	bl	800e180 <HAL_GPIO_Init>

  /*Configure GPIO pins : PB6 PB7 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 80014a4:	23c0      	movs	r3, #192	; 0xc0
 80014a6:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 80014a8:	2311      	movs	r3, #17
 80014aa:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80014ac:	2300      	movs	r3, #0
 80014ae:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80014b0:	2300      	movs	r3, #0
 80014b2:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80014b4:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80014b8:	4619      	mov	r1, r3
 80014ba:	4812      	ldr	r0, [pc, #72]	; (8001504 <MX_GPIO_Init+0x1bc>)
 80014bc:	f00c fe60 	bl	800e180 <HAL_GPIO_Init>

  /*Configure GPIO pin : PI7 */
  GPIO_InitStruct.Pin = GPIO_PIN_7;
 80014c0:	2380      	movs	r3, #128	; 0x80
 80014c2:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80014c4:	2301      	movs	r3, #1
 80014c6:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80014c8:	2300      	movs	r3, #0
 80014ca:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80014cc:	2300      	movs	r3, #0
 80014ce:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 80014d0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80014d4:	4619      	mov	r1, r3
 80014d6:	480c      	ldr	r0, [pc, #48]	; (8001508 <MX_GPIO_Init+0x1c0>)
 80014d8:	f00c fe52 	bl	800e180 <HAL_GPIO_Init>

}
 80014dc:	bf00      	nop
 80014de:	4b05      	ldr	r3, [pc, #20]	; (80014f4 <MX_GPIO_Init+0x1ac>)
 80014e0:	681a      	ldr	r2, [r3, #0]
 80014e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80014e4:	405a      	eors	r2, r3
 80014e6:	d001      	beq.n	80014ec <MX_GPIO_Init+0x1a4>
 80014e8:	f003 f878 	bl	80045dc <__stack_chk_fail>
 80014ec:	3740      	adds	r7, #64	; 0x40
 80014ee:	46bd      	mov	sp, r7
 80014f0:	bd80      	pop	{r7, pc}
 80014f2:	bf00      	nop
 80014f4:	0801fe18 	.word	0x0801fe18
 80014f8:	40023800 	.word	0x40023800
 80014fc:	40020000 	.word	0x40020000
 8001500:	40021c00 	.word	0x40021c00
 8001504:	40020400 	.word	0x40020400
 8001508:	40022000 	.word	0x40022000

0800150c <Error_Handler>:
uint32_t HAL_GetTick(void);
void SystemClock_Config(void);
void _Error_Handler(char const *, int);

STATIC INLINE VOID Error_Handler(VOID)
{
 800150c:	b580      	push	{r7, lr}
 800150e:	af00      	add	r7, sp, #0
    _Error_Handler(__FILE__, __LINE__);
 8001510:	213b      	movs	r1, #59	; 0x3b
 8001512:	4802      	ldr	r0, [pc, #8]	; (800151c <Error_Handler+0x10>)
 8001514:	f000 fc39 	bl	8001d8a <_Error_Handler>
}
 8001518:	bf00      	nop
 800151a:	bd80      	pop	{r7, pc}
 800151c:	0801fe1c 	.word	0x0801fe1c

08001520 <MX_FMC_Init>:

SDRAM_HandleTypeDef hsdram2;

/* FMC initialization function */
void MX_FMC_Init(void)
{
 8001520:	b580      	push	{r7, lr}
 8001522:	b08c      	sub	sp, #48	; 0x30
 8001524:	af00      	add	r7, sp, #0
 8001526:	4b4d      	ldr	r3, [pc, #308]	; (800165c <MX_FMC_Init+0x13c>)
 8001528:	681b      	ldr	r3, [r3, #0]
 800152a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800152c:	f04f 0300 	mov.w	r3, #0
  /* USER CODE BEGIN FMC_Init 0 */

  /* USER CODE END FMC_Init 0 */

  FMC_SDRAM_TimingTypeDef SdramTiming = {0};
 8001530:	f107 0310 	add.w	r3, r7, #16
 8001534:	2200      	movs	r2, #0
 8001536:	601a      	str	r2, [r3, #0]
 8001538:	605a      	str	r2, [r3, #4]
 800153a:	609a      	str	r2, [r3, #8]
 800153c:	60da      	str	r2, [r3, #12]
 800153e:	611a      	str	r2, [r3, #16]
 8001540:	615a      	str	r2, [r3, #20]
 8001542:	619a      	str	r2, [r3, #24]

  /* USER CODE END FMC_Init 1 */

  /** Perform the SDRAM2 memory initialization sequence
  */
  hsdram2.Instance = FMC_SDRAM_DEVICE;
 8001544:	4b46      	ldr	r3, [pc, #280]	; (8001660 <MX_FMC_Init+0x140>)
 8001546:	4a47      	ldr	r2, [pc, #284]	; (8001664 <MX_FMC_Init+0x144>)
 8001548:	601a      	str	r2, [r3, #0]
  /* hsdram2.Init */
  hsdram2.Init.SDBank = FMC_SDRAM_BANK2;
 800154a:	4b45      	ldr	r3, [pc, #276]	; (8001660 <MX_FMC_Init+0x140>)
 800154c:	2201      	movs	r2, #1
 800154e:	605a      	str	r2, [r3, #4]
  hsdram2.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
 8001550:	4b43      	ldr	r3, [pc, #268]	; (8001660 <MX_FMC_Init+0x140>)
 8001552:	2201      	movs	r2, #1
 8001554:	609a      	str	r2, [r3, #8]
  hsdram2.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
 8001556:	4b42      	ldr	r3, [pc, #264]	; (8001660 <MX_FMC_Init+0x140>)
 8001558:	2208      	movs	r2, #8
 800155a:	60da      	str	r2, [r3, #12]
  hsdram2.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
 800155c:	4b40      	ldr	r3, [pc, #256]	; (8001660 <MX_FMC_Init+0x140>)
 800155e:	2210      	movs	r2, #16
 8001560:	611a      	str	r2, [r3, #16]
  hsdram2.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8001562:	4b3f      	ldr	r3, [pc, #252]	; (8001660 <MX_FMC_Init+0x140>)
 8001564:	2240      	movs	r2, #64	; 0x40
 8001566:	615a      	str	r2, [r3, #20]
  hsdram2.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_3;
 8001568:	4b3d      	ldr	r3, [pc, #244]	; (8001660 <MX_FMC_Init+0x140>)
 800156a:	f44f 72c0 	mov.w	r2, #384	; 0x180
 800156e:	619a      	str	r2, [r3, #24]
  hsdram2.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 8001570:	4b3b      	ldr	r3, [pc, #236]	; (8001660 <MX_FMC_Init+0x140>)
 8001572:	2200      	movs	r2, #0
 8001574:	61da      	str	r2, [r3, #28]
  hsdram2.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
 8001576:	4b3a      	ldr	r3, [pc, #232]	; (8001660 <MX_FMC_Init+0x140>)
 8001578:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800157c:	621a      	str	r2, [r3, #32]
  hsdram2.Init.ReadBurst = FMC_SDRAM_RBURST_DISABLE;
 800157e:	4b38      	ldr	r3, [pc, #224]	; (8001660 <MX_FMC_Init+0x140>)
 8001580:	2200      	movs	r2, #0
 8001582:	625a      	str	r2, [r3, #36]	; 0x24
  hsdram2.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
 8001584:	4b36      	ldr	r3, [pc, #216]	; (8001660 <MX_FMC_Init+0x140>)
 8001586:	2200      	movs	r2, #0
 8001588:	629a      	str	r2, [r3, #40]	; 0x28
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
 800158a:	2302      	movs	r3, #2
 800158c:	613b      	str	r3, [r7, #16]
  SdramTiming.ExitSelfRefreshDelay = 9;
 800158e:	2309      	movs	r3, #9
 8001590:	617b      	str	r3, [r7, #20]
  SdramTiming.SelfRefreshTime = 6;
 8001592:	2306      	movs	r3, #6
 8001594:	61bb      	str	r3, [r7, #24]
  SdramTiming.RowCycleDelay = 8;
 8001596:	2308      	movs	r3, #8
 8001598:	61fb      	str	r3, [r7, #28]
  SdramTiming.WriteRecoveryTime = 3;
 800159a:	2303      	movs	r3, #3
 800159c:	623b      	str	r3, [r7, #32]
  SdramTiming.RPDelay = 3;
 800159e:	2303      	movs	r3, #3
 80015a0:	627b      	str	r3, [r7, #36]	; 0x24
  SdramTiming.RCDDelay = 3;
 80015a2:	2303      	movs	r3, #3
 80015a4:	62bb      	str	r3, [r7, #40]	; 0x28

  if (HAL_SDRAM_Init(&hsdram2, &SdramTiming) != HAL_OK)
 80015a6:	f107 0310 	add.w	r3, r7, #16
 80015aa:	4619      	mov	r1, r3
 80015ac:	482c      	ldr	r0, [pc, #176]	; (8001660 <MX_FMC_Init+0x140>)
 80015ae:	f00c fc61 	bl	800de74 <HAL_SDRAM_Init>
 80015b2:	4603      	mov	r3, r0
 80015b4:	2b00      	cmp	r3, #0
 80015b6:	d001      	beq.n	80015bc <MX_FMC_Init+0x9c>
  {
    Error_Handler( );
 80015b8:	f7ff ffa8 	bl	800150c <Error_Handler>
  }

  /* USER CODE BEGIN FMC_Init 2 */
// 第一步：给SDRAM提供时钟
  FMC_SDRAM_CommandTypeDef Command;
  Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 80015bc:	2301      	movs	r3, #1
 80015be:	603b      	str	r3, [r7, #0]
  Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK2;
 80015c0:	2308      	movs	r3, #8
 80015c2:	607b      	str	r3, [r7, #4]
  Command.AutoRefreshNumber = 1;
 80015c4:	2301      	movs	r3, #1
 80015c6:	60bb      	str	r3, [r7, #8]
  Command.ModeRegisterDefinition = 0;
 80015c8:	2300      	movs	r3, #0
 80015ca:	60fb      	str	r3, [r7, #12]
  
  HAL_SDRAM_SendCommand(&hsdram2,&Command,0xFFFF);
 80015cc:	463b      	mov	r3, r7
 80015ce:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80015d2:	4619      	mov	r1, r3
 80015d4:	4822      	ldr	r0, [pc, #136]	; (8001660 <MX_FMC_Init+0x140>)
 80015d6:	f00c fc7c 	bl	800ded2 <HAL_SDRAM_SendCommand>
  
  // 第二步：延时至少200us
  // SDRAM_delay(1);
  HAL_Delay(1);
 80015da:	2001      	movs	r0, #1
 80015dc:	f00a fe60 	bl	800c2a0 <HAL_Delay>
  
  // 第三步：对所有Banks预充电
  Command.CommandMode = FMC_SDRAM_CMD_PALL;
 80015e0:	2302      	movs	r3, #2
 80015e2:	603b      	str	r3, [r7, #0]
  Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK2;
 80015e4:	2308      	movs	r3, #8
 80015e6:	607b      	str	r3, [r7, #4]
  Command.AutoRefreshNumber = 1;
 80015e8:	2301      	movs	r3, #1
 80015ea:	60bb      	str	r3, [r7, #8]
  Command.ModeRegisterDefinition = 0;
 80015ec:	2300      	movs	r3, #0
 80015ee:	60fb      	str	r3, [r7, #12]
  
  HAL_SDRAM_SendCommand(&hsdram2,&Command,0xFFFF);
 80015f0:	463b      	mov	r3, r7
 80015f2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80015f6:	4619      	mov	r1, r3
 80015f8:	4819      	ldr	r0, [pc, #100]	; (8001660 <MX_FMC_Init+0x140>)
 80015fa:	f00c fc6a 	bl	800ded2 <HAL_SDRAM_SendCommand>
  
  // 第四步：插入8个自动刷新周期
  Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 80015fe:	2303      	movs	r3, #3
 8001600:	603b      	str	r3, [r7, #0]
  Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK2;
 8001602:	2308      	movs	r3, #8
 8001604:	607b      	str	r3, [r7, #4]
  Command.AutoRefreshNumber = 8;
 8001606:	2308      	movs	r3, #8
 8001608:	60bb      	str	r3, [r7, #8]
  Command.ModeRegisterDefinition = 0;
 800160a:	2300      	movs	r3, #0
 800160c:	60fb      	str	r3, [r7, #12]
  
  HAL_SDRAM_SendCommand(&hsdram2,&Command,0xFFFF);
 800160e:	463b      	mov	r3, r7
 8001610:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001614:	4619      	mov	r1, r3
 8001616:	4812      	ldr	r0, [pc, #72]	; (8001660 <MX_FMC_Init+0x140>)
 8001618:	f00c fc5b 	bl	800ded2 <HAL_SDRAM_SendCommand>
  
  // 第五步：编程SDRAM的加载模式寄存器
  Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
 800161c:	2304      	movs	r3, #4
 800161e:	603b      	str	r3, [r7, #0]
  Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK2;
 8001620:	2308      	movs	r3, #8
 8001622:	607b      	str	r3, [r7, #4]
  Command.AutoRefreshNumber = 1;
 8001624:	2301      	movs	r3, #1
 8001626:	60bb      	str	r3, [r7, #8]
  Command.ModeRegisterDefinition = 0x230;
 8001628:	f44f 730c 	mov.w	r3, #560	; 0x230
 800162c:	60fb      	str	r3, [r7, #12]
  
  HAL_SDRAM_SendCommand(&hsdram2,&Command,0xFFFF);
 800162e:	463b      	mov	r3, r7
 8001630:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001634:	4619      	mov	r1, r3
 8001636:	480a      	ldr	r0, [pc, #40]	; (8001660 <MX_FMC_Init+0x140>)
 8001638:	f00c fc4b 	bl	800ded2 <HAL_SDRAM_SendCommand>
  
  // 第六步：配置STM32FMC的SDRAM控制器的自动刷新周期
  HAL_SDRAM_ProgramRefreshRate( &hsdram2, 824);
 800163c:	f44f 714e 	mov.w	r1, #824	; 0x338
 8001640:	4807      	ldr	r0, [pc, #28]	; (8001660 <MX_FMC_Init+0x140>)
 8001642:	f00c fc77 	bl	800df34 <HAL_SDRAM_ProgramRefreshRate>

#if DEBUG_SDRAM_CHECK
  SDRAM_Test();
#endif  
  /* USER CODE END FMC_Init 2 */
}
 8001646:	bf00      	nop
 8001648:	4b04      	ldr	r3, [pc, #16]	; (800165c <MX_FMC_Init+0x13c>)
 800164a:	681a      	ldr	r2, [r3, #0]
 800164c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800164e:	405a      	eors	r2, r3
 8001650:	d001      	beq.n	8001656 <MX_FMC_Init+0x136>
 8001652:	f002 ffc3 	bl	80045dc <__stack_chk_fail>
 8001656:	3730      	adds	r7, #48	; 0x30
 8001658:	46bd      	mov	sp, r7
 800165a:	bd80      	pop	{r7, pc}
 800165c:	0801fe78 	.word	0x0801fe78
 8001660:	20003498 	.word	0x20003498
 8001664:	a0000140 	.word	0xa0000140

08001668 <HAL_FMC_MspInit>:

static uint32_t FMC_Initialized = 0;

static void HAL_FMC_MspInit(void){
 8001668:	b580      	push	{r7, lr}
 800166a:	b088      	sub	sp, #32
 800166c:	af00      	add	r7, sp, #0
 800166e:	4b48      	ldr	r3, [pc, #288]	; (8001790 <HAL_FMC_MspInit+0x128>)
 8001670:	681b      	ldr	r3, [r3, #0]
 8001672:	61fb      	str	r3, [r7, #28]
 8001674:	f04f 0300 	mov.w	r3, #0
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001678:	f107 0308 	add.w	r3, r7, #8
 800167c:	2200      	movs	r2, #0
 800167e:	601a      	str	r2, [r3, #0]
 8001680:	605a      	str	r2, [r3, #4]
 8001682:	609a      	str	r2, [r3, #8]
 8001684:	60da      	str	r2, [r3, #12]
 8001686:	611a      	str	r2, [r3, #16]
  if (FMC_Initialized) {
 8001688:	4b42      	ldr	r3, [pc, #264]	; (8001794 <HAL_FMC_MspInit+0x12c>)
 800168a:	681b      	ldr	r3, [r3, #0]
 800168c:	2b00      	cmp	r3, #0
 800168e:	d173      	bne.n	8001778 <HAL_FMC_MspInit+0x110>
    return;
  }
  FMC_Initialized = 1;
 8001690:	4b40      	ldr	r3, [pc, #256]	; (8001794 <HAL_FMC_MspInit+0x12c>)
 8001692:	2201      	movs	r2, #1
 8001694:	601a      	str	r2, [r3, #0]

  /* Peripheral clock enable */
  __HAL_RCC_FMC_CLK_ENABLE();
 8001696:	4b40      	ldr	r3, [pc, #256]	; (8001798 <HAL_FMC_MspInit+0x130>)
 8001698:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800169a:	4a3f      	ldr	r2, [pc, #252]	; (8001798 <HAL_FMC_MspInit+0x130>)
 800169c:	f043 0301 	orr.w	r3, r3, #1
 80016a0:	6393      	str	r3, [r2, #56]	; 0x38
 80016a2:	4b3d      	ldr	r3, [pc, #244]	; (8001798 <HAL_FMC_MspInit+0x130>)
 80016a4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80016a6:	f003 0301 	and.w	r3, r3, #1
 80016aa:	607b      	str	r3, [r7, #4]
 80016ac:	687b      	ldr	r3, [r7, #4]
  PG15   ------> FMC_SDNCAS
  PE0   ------> FMC_NBL0
  PE1   ------> FMC_NBL1
  */
  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 80016ae:	f64f 033f 	movw	r3, #63551	; 0xf83f
 80016b2:	60bb      	str	r3, [r7, #8]
                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11|GPIO_PIN_12
                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80016b4:	2302      	movs	r3, #2
 80016b6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80016b8:	2300      	movs	r3, #0
 80016ba:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80016bc:	2303      	movs	r3, #3
 80016be:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 80016c0:	230c      	movs	r3, #12
 80016c2:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 80016c4:	f107 0308 	add.w	r3, r7, #8
 80016c8:	4619      	mov	r1, r3
 80016ca:	4834      	ldr	r0, [pc, #208]	; (800179c <HAL_FMC_MspInit+0x134>)
 80016cc:	f00c fd58 	bl	800e180 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 80016d0:	2301      	movs	r3, #1
 80016d2:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80016d4:	2302      	movs	r3, #2
 80016d6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80016d8:	2300      	movs	r3, #0
 80016da:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80016dc:	2303      	movs	r3, #3
 80016de:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 80016e0:	230c      	movs	r3, #12
 80016e2:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80016e4:	f107 0308 	add.w	r3, r7, #8
 80016e8:	4619      	mov	r1, r3
 80016ea:	482d      	ldr	r0, [pc, #180]	; (80017a0 <HAL_FMC_MspInit+0x138>)
 80016ec:	f00c fd48 	bl	800e180 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4
 80016f0:	f248 1337 	movw	r3, #33079	; 0x8137
 80016f4:	60bb      	str	r3, [r7, #8]
                          |GPIO_PIN_5|GPIO_PIN_8|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80016f6:	2302      	movs	r3, #2
 80016f8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80016fa:	2300      	movs	r3, #0
 80016fc:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80016fe:	2303      	movs	r3, #3
 8001700:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8001702:	230c      	movs	r3, #12
 8001704:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8001706:	f107 0308 	add.w	r3, r7, #8
 800170a:	4619      	mov	r1, r3
 800170c:	4825      	ldr	r0, [pc, #148]	; (80017a4 <HAL_FMC_MspInit+0x13c>)
 800170e:	f00c fd37 	bl	800e180 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10
 8001712:	f64f 7383 	movw	r3, #65411	; 0xff83
 8001716:	60bb      	str	r3, [r7, #8]
                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001718:	2302      	movs	r3, #2
 800171a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800171c:	2300      	movs	r3, #0
 800171e:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001720:	2303      	movs	r3, #3
 8001722:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8001724:	230c      	movs	r3, #12
 8001726:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8001728:	f107 0308 	add.w	r3, r7, #8
 800172c:	4619      	mov	r1, r3
 800172e:	481e      	ldr	r0, [pc, #120]	; (80017a8 <HAL_FMC_MspInit+0x140>)
 8001730:	f00c fd26 	bl	800e180 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8001734:	23c0      	movs	r3, #192	; 0xc0
 8001736:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001738:	2302      	movs	r3, #2
 800173a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800173c:	2300      	movs	r3, #0
 800173e:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001740:	2303      	movs	r3, #3
 8001742:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8001744:	230c      	movs	r3, #12
 8001746:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8001748:	f107 0308 	add.w	r3, r7, #8
 800174c:	4619      	mov	r1, r3
 800174e:	4817      	ldr	r0, [pc, #92]	; (80017ac <HAL_FMC_MspInit+0x144>)
 8001750:	f00c fd16 	bl	800e180 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14
 8001754:	f24c 7303 	movw	r3, #50947	; 0xc703
 8001758:	60bb      	str	r3, [r7, #8]
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800175a:	2302      	movs	r3, #2
 800175c:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800175e:	2300      	movs	r3, #0
 8001760:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001762:	2303      	movs	r3, #3
 8001764:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8001766:	230c      	movs	r3, #12
 8001768:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800176a:	f107 0308 	add.w	r3, r7, #8
 800176e:	4619      	mov	r1, r3
 8001770:	480f      	ldr	r0, [pc, #60]	; (80017b0 <HAL_FMC_MspInit+0x148>)
 8001772:	f00c fd05 	bl	800e180 <HAL_GPIO_Init>
 8001776:	e000      	b.n	800177a <HAL_FMC_MspInit+0x112>
    return;
 8001778:	bf00      	nop

  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}
 800177a:	4b05      	ldr	r3, [pc, #20]	; (8001790 <HAL_FMC_MspInit+0x128>)
 800177c:	681a      	ldr	r2, [r3, #0]
 800177e:	69fb      	ldr	r3, [r7, #28]
 8001780:	405a      	eors	r2, r3
 8001782:	d001      	beq.n	8001788 <HAL_FMC_MspInit+0x120>
 8001784:	f002 ff2a 	bl	80045dc <__stack_chk_fail>
 8001788:	3720      	adds	r7, #32
 800178a:	46bd      	mov	sp, r7
 800178c:	bd80      	pop	{r7, pc}
 800178e:	bf00      	nop
 8001790:	0801fe7c 	.word	0x0801fe7c
 8001794:	20000728 	.word	0x20000728
 8001798:	40023800 	.word	0x40023800
 800179c:	40021400 	.word	0x40021400
 80017a0:	40020800 	.word	0x40020800
 80017a4:	40021800 	.word	0x40021800
 80017a8:	40021000 	.word	0x40021000
 80017ac:	40021c00 	.word	0x40021c00
 80017b0:	40020c00 	.word	0x40020c00

080017b4 <HAL_SDRAM_MspInit>:

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
 80017b4:	b580      	push	{r7, lr}
 80017b6:	b082      	sub	sp, #8
 80017b8:	af00      	add	r7, sp, #0
 80017ba:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN SDRAM_MspInit 0 */

  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
 80017bc:	f7ff ff54 	bl	8001668 <HAL_FMC_MspInit>
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
 80017c0:	bf00      	nop
 80017c2:	3708      	adds	r7, #8
 80017c4:	46bd      	mov	sp, r7
 80017c6:	bd80      	pop	{r7, pc}

080017c8 <Error_Handler>:
{
 80017c8:	b580      	push	{r7, lr}
 80017ca:	af00      	add	r7, sp, #0
    _Error_Handler(__FILE__, __LINE__);
 80017cc:	213b      	movs	r1, #59	; 0x3b
 80017ce:	4802      	ldr	r0, [pc, #8]	; (80017d8 <Error_Handler+0x10>)
 80017d0:	f000 fadb 	bl	8001d8a <_Error_Handler>
}
 80017d4:	bf00      	nop
 80017d6:	bd80      	pop	{r7, pc}
 80017d8:	0801fe80 	.word	0x0801fe80

080017dc <MX_TIM3_Init>:
TIM_HandleTypeDef htim3;

static UINT64 g_tim3_cycleTimes = 0;
/* TIM3 init function */
void MX_TIM3_Init(void)
{
 80017dc:	b580      	push	{r7, lr}
 80017de:	b088      	sub	sp, #32
 80017e0:	af00      	add	r7, sp, #0
 80017e2:	4b29      	ldr	r3, [pc, #164]	; (8001888 <MX_TIM3_Init+0xac>)
 80017e4:	681b      	ldr	r3, [r3, #0]
 80017e6:	61fb      	str	r3, [r7, #28]
 80017e8:	f04f 0300 	mov.w	r3, #0
    TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
 80017ec:	f107 030c 	add.w	r3, r7, #12
 80017f0:	2200      	movs	r2, #0
 80017f2:	601a      	str	r2, [r3, #0]
 80017f4:	605a      	str	r2, [r3, #4]
 80017f6:	609a      	str	r2, [r3, #8]
 80017f8:	60da      	str	r2, [r3, #12]
    TIM_MasterConfigTypeDef sMasterConfig = { 0 };
 80017fa:	463b      	mov	r3, r7
 80017fc:	2200      	movs	r2, #0
 80017fe:	601a      	str	r2, [r3, #0]
 8001800:	605a      	str	r2, [r3, #4]
 8001802:	609a      	str	r2, [r3, #8]
    /* 累计TIM_Period个后产生一个更新或者中断*/
    //定时器时钟源TIMxCLK = 2 * PCLK1  
    //              PCLK1 = HCLK / 4 
    //              => TIMxCLK=HCLK/2=SystemCoreClock/2=108MHz
    // 设定定时器频率为 = TIMxCLK/(TIM_Prescaler+1)=1000000Hz
    htim3.Instance = TIM3;
 8001804:	4b21      	ldr	r3, [pc, #132]	; (800188c <MX_TIM3_Init+0xb0>)
 8001806:	4a22      	ldr	r2, [pc, #136]	; (8001890 <MX_TIM3_Init+0xb4>)
 8001808:	601a      	str	r2, [r3, #0]
    htim3.Init.Prescaler = 108 - 1; // 5400 - 1, Set timer3 prescaler.
 800180a:	4b20      	ldr	r3, [pc, #128]	; (800188c <MX_TIM3_Init+0xb0>)
 800180c:	226b      	movs	r2, #107	; 0x6b
 800180e:	605a      	str	r2, [r3, #4]
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001810:	4b1e      	ldr	r3, [pc, #120]	; (800188c <MX_TIM3_Init+0xb0>)
 8001812:	2200      	movs	r2, #0
 8001814:	609a      	str	r2, [r3, #8]
    htim3.Init.Period = 50000 - 1; // 50000 - 1, Set timer3 period.
 8001816:	4b1d      	ldr	r3, [pc, #116]	; (800188c <MX_TIM3_Init+0xb0>)
 8001818:	f24c 324f 	movw	r2, #49999	; 0xc34f
 800181c:	60da      	str	r2, [r3, #12]

    /* Period (50000) / TIMxCLK(10000HZ) = 5s 产生一个中断*/
    htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800181e:	4b1b      	ldr	r3, [pc, #108]	; (800188c <MX_TIM3_Init+0xb0>)
 8001820:	2200      	movs	r2, #0
 8001822:	611a      	str	r2, [r3, #16]
    htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8001824:	4b19      	ldr	r3, [pc, #100]	; (800188c <MX_TIM3_Init+0xb0>)
 8001826:	2200      	movs	r2, #0
 8001828:	619a      	str	r2, [r3, #24]
    if (HAL_TIM_Base_Init(&htim3) != HAL_OK) {
 800182a:	4818      	ldr	r0, [pc, #96]	; (800188c <MX_TIM3_Init+0xb0>)
 800182c:	f00b f982 	bl	800cb34 <HAL_TIM_Base_Init>
 8001830:	4603      	mov	r3, r0
 8001832:	2b00      	cmp	r3, #0
 8001834:	d001      	beq.n	800183a <MX_TIM3_Init+0x5e>
        Error_Handler();
 8001836:	f7ff ffc7 	bl	80017c8 <Error_Handler>
    }
    sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800183a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800183e:	60fb      	str	r3, [r7, #12]
    if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK) {
 8001840:	f107 030c 	add.w	r3, r7, #12
 8001844:	4619      	mov	r1, r3
 8001846:	4811      	ldr	r0, [pc, #68]	; (800188c <MX_TIM3_Init+0xb0>)
 8001848:	f00b fb48 	bl	800cedc <HAL_TIM_ConfigClockSource>
 800184c:	4603      	mov	r3, r0
 800184e:	2b00      	cmp	r3, #0
 8001850:	d001      	beq.n	8001856 <MX_TIM3_Init+0x7a>
        Error_Handler();
 8001852:	f7ff ffb9 	bl	80017c8 <Error_Handler>
    }
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8001856:	2300      	movs	r3, #0
 8001858:	603b      	str	r3, [r7, #0]
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800185a:	2300      	movs	r3, #0
 800185c:	60bb      	str	r3, [r7, #8]
    if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK) {
 800185e:	463b      	mov	r3, r7
 8001860:	4619      	mov	r1, r3
 8001862:	480a      	ldr	r0, [pc, #40]	; (800188c <MX_TIM3_Init+0xb0>)
 8001864:	f00c fa4e 	bl	800dd04 <HAL_TIMEx_MasterConfigSynchronization>
 8001868:	4603      	mov	r3, r0
 800186a:	2b00      	cmp	r3, #0
 800186c:	d001      	beq.n	8001872 <MX_TIM3_Init+0x96>
        Error_Handler();
 800186e:	f7ff ffab 	bl	80017c8 <Error_Handler>
    }
}
 8001872:	bf00      	nop
 8001874:	4b04      	ldr	r3, [pc, #16]	; (8001888 <MX_TIM3_Init+0xac>)
 8001876:	681a      	ldr	r2, [r3, #0]
 8001878:	69fb      	ldr	r3, [r7, #28]
 800187a:	405a      	eors	r2, r3
 800187c:	d001      	beq.n	8001882 <MX_TIM3_Init+0xa6>
 800187e:	f002 fead 	bl	80045dc <__stack_chk_fail>
 8001882:	3720      	adds	r7, #32
 8001884:	46bd      	mov	sp, r7
 8001886:	bd80      	pop	{r7, pc}
 8001888:	0801fedc 	.word	0x0801fedc
 800188c:	200034d0 	.word	0x200034d0
 8001890:	40000400 	.word	0x40000400

08001894 <HAL_TIM_Base_MspInit>:


void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
 8001894:	b580      	push	{r7, lr}
 8001896:	b084      	sub	sp, #16
 8001898:	af00      	add	r7, sp, #0
 800189a:	6078      	str	r0, [r7, #4]

  if(tim_baseHandle->Instance==TIM3)
 800189c:	687b      	ldr	r3, [r7, #4]
 800189e:	681b      	ldr	r3, [r3, #0]
 80018a0:	4a0d      	ldr	r2, [pc, #52]	; (80018d8 <HAL_TIM_Base_MspInit+0x44>)
 80018a2:	4293      	cmp	r3, r2
 80018a4:	d113      	bne.n	80018ce <HAL_TIM_Base_MspInit+0x3a>
  {
  /* USER CODE BEGIN TIM3_MspInit 0 */

  /* USER CODE END TIM3_MspInit 0 */
    /* TIM3 clock enable */
    __HAL_RCC_TIM3_CLK_ENABLE();
 80018a6:	4b0d      	ldr	r3, [pc, #52]	; (80018dc <HAL_TIM_Base_MspInit+0x48>)
 80018a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80018aa:	4a0c      	ldr	r2, [pc, #48]	; (80018dc <HAL_TIM_Base_MspInit+0x48>)
 80018ac:	f043 0302 	orr.w	r3, r3, #2
 80018b0:	6413      	str	r3, [r2, #64]	; 0x40
 80018b2:	4b0a      	ldr	r3, [pc, #40]	; (80018dc <HAL_TIM_Base_MspInit+0x48>)
 80018b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80018b6:	f003 0302 	and.w	r3, r3, #2
 80018ba:	60fb      	str	r3, [r7, #12]
 80018bc:	68fb      	ldr	r3, [r7, #12]

    /* TIM3 interrupt Init */
    HAL_NVIC_SetPriority(TIM3_IRQn, 0, 3);
 80018be:	2203      	movs	r2, #3
 80018c0:	2100      	movs	r1, #0
 80018c2:	201d      	movs	r0, #29
 80018c4:	f00c fc2b 	bl	800e11e <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
 80018c8:	201d      	movs	r0, #29
 80018ca:	f00c fc41 	bl	800e150 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
}
 80018ce:	bf00      	nop
 80018d0:	3710      	adds	r7, #16
 80018d2:	46bd      	mov	sp, r7
 80018d4:	bd80      	pop	{r7, pc}
 80018d6:	bf00      	nop
 80018d8:	40000400 	.word	0x40000400
 80018dc:	40023800 	.word	0x40023800

080018e0 <TIM3_IRQHandler>:

/* *
 * @brief This function handles TIM3 global interrupt.
 */
void TIM3_IRQHandler(void)
{
 80018e0:	b5b0      	push	{r4, r5, r7, lr}
 80018e2:	af00      	add	r7, sp, #0
    /* USER CODE BEGIN TIM3_IRQn 0 */

    /* USER CODE END TIM3_IRQn 0 */
    // Fire_DEBUG_GPIOB6_TRIGGER(); 
    Fire_DEBUG_GPIOB7(1);
 80018e4:	2001      	movs	r0, #1
 80018e6:	f000 fa2d 	bl	8001d44 <Fire_DEBUG_GPIOB7>
    g_tim3_cycleTimes ++;
 80018ea:	4b08      	ldr	r3, [pc, #32]	; (800190c <TIM3_IRQHandler+0x2c>)
 80018ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80018f0:	1c54      	adds	r4, r2, #1
 80018f2:	f143 0500 	adc.w	r5, r3, #0
 80018f6:	4b05      	ldr	r3, [pc, #20]	; (800190c <TIM3_IRQHandler+0x2c>)
 80018f8:	e9c3 4500 	strd	r4, r5, [r3]
    HAL_TIM_IRQHandler(&htim3);
 80018fc:	4804      	ldr	r0, [pc, #16]	; (8001910 <TIM3_IRQHandler+0x30>)
 80018fe:	f00b f9cd 	bl	800cc9c <HAL_TIM_IRQHandler>
    Fire_DEBUG_GPIOB7(0);
 8001902:	2000      	movs	r0, #0
 8001904:	f000 fa1e 	bl	8001d44 <Fire_DEBUG_GPIOB7>
    /* USER CODE BEGIN TIM3_IRQn 1 */

    /* USER CODE END TIM3_IRQn 1 */
}
 8001908:	bf00      	nop
 800190a:	bdb0      	pop	{r4, r5, r7, pc}
 800190c:	20000730 	.word	0x20000730
 8001910:	200034d0 	.word	0x200034d0

08001914 <TimInit>:

/* USER CODE BEGIN 1 */
VOID TimInit(VOID)
{
 8001914:	b580      	push	{r7, lr}
 8001916:	af00      	add	r7, sp, #0
    MX_TIM3_Init();
 8001918:	f7ff ff60 	bl	80017dc <MX_TIM3_Init>
    
    // 开启定时器中断方式更新中断
    // (VOID)HAL_TIM_Base_Start_IT(&htim3);
    HAL_TIM_Base_Start(&htim3);
 800191c:	4802      	ldr	r0, [pc, #8]	; (8001928 <TimInit+0x14>)
 800191e:	f00b f951 	bl	800cbc4 <HAL_TIM_Base_Start>
}
 8001922:	bf00      	nop
 8001924:	bd80      	pop	{r7, pc}
 8001926:	bf00      	nop
 8001928:	200034d0 	.word	0x200034d0

0800192c <TimerHwiCreate>:

VOID TimerHwiCreate(VOID)
{
 800192c:	b580      	push	{r7, lr}
 800192e:	b084      	sub	sp, #16
 8001930:	af02      	add	r7, sp, #8
    UINT32 ret;

    ret = LOS_HwiCreate(TIM_IRQ, 0, 0, TIM3_IRQHandler, 0); // 16: cortex-m irq num shift
 8001932:	2300      	movs	r3, #0
 8001934:	9300      	str	r3, [sp, #0]
 8001936:	4b09      	ldr	r3, [pc, #36]	; (800195c <TimerHwiCreate+0x30>)
 8001938:	2200      	movs	r2, #0
 800193a:	2100      	movs	r1, #0
 800193c:	202d      	movs	r0, #45	; 0x2d
 800193e:	f000 fea7 	bl	8002690 <LOS_HwiCreate>
 8001942:	6078      	str	r0, [r7, #4]
    if (ret != 0) {
 8001944:	687b      	ldr	r3, [r7, #4]
 8001946:	2b00      	cmp	r3, #0
 8001948:	d004      	beq.n	8001954 <TimerHwiCreate+0x28>
        printf("ret of TIM3 LOS_HwiCreate = %#x\n", ret);
 800194a:	6879      	ldr	r1, [r7, #4]
 800194c:	4804      	ldr	r0, [pc, #16]	; (8001960 <TimerHwiCreate+0x34>)
 800194e:	f00e fbb7 	bl	80100c0 <printf>
        return;
 8001952:	bf00      	nop
    }

}
 8001954:	3708      	adds	r7, #8
 8001956:	46bd      	mov	sp, r7
 8001958:	bd80      	pop	{r7, pc}
 800195a:	bf00      	nop
 800195c:	080018e1 	.word	0x080018e1
 8001960:	0801fee0 	.word	0x0801fee0

08001964 <Hal_STM32F767_Get_Timer_CNT>:

/* 2022-04-07 tanzhongqiang  
    返回基础定时器CNT 值，每1us 更新一次。
*/
UINT64 Hal_STM32F767_Get_Timer_CNT(VOID)
{
 8001964:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
 8001968:	b083      	sub	sp, #12
 800196a:	af00      	add	r7, sp, #0
    static UINT64 bacCycle = 0;
    static UINT64 cycleTimes = 0;
    if (htim3.Instance == NULL) {
 800196c:	4b23      	ldr	r3, [pc, #140]	; (80019fc <Hal_STM32F767_Get_Timer_CNT+0x98>)
 800196e:	681b      	ldr	r3, [r3, #0]
 8001970:	2b00      	cmp	r3, #0
 8001972:	d104      	bne.n	800197e <Hal_STM32F767_Get_Timer_CNT+0x1a>
        return 0;
 8001974:	f04f 0400 	mov.w	r4, #0
 8001978:	f04f 0500 	mov.w	r5, #0
 800197c:	e034      	b.n	80019e8 <Hal_STM32F767_Get_Timer_CNT+0x84>
    }

    UINT64 swCycles = htim3.Instance->CNT;
 800197e:	4b1f      	ldr	r3, [pc, #124]	; (80019fc <Hal_STM32F767_Get_Timer_CNT+0x98>)
 8001980:	681b      	ldr	r3, [r3, #0]
 8001982:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001984:	461a      	mov	r2, r3
 8001986:	f04f 0300 	mov.w	r3, #0
 800198a:	e9c7 2300 	strd	r2, r3, [r7]

    if (swCycles < bacCycle) {
 800198e:	4b1c      	ldr	r3, [pc, #112]	; (8001a00 <Hal_STM32F767_Get_Timer_CNT+0x9c>)
 8001990:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001994:	e9d7 8900 	ldrd	r8, r9, [r7]
 8001998:	4599      	cmp	r9, r3
 800199a:	bf08      	it	eq
 800199c:	4590      	cmpeq	r8, r2
 800199e:	d208      	bcs.n	80019b2 <Hal_STM32F767_Get_Timer_CNT+0x4e>
        cycleTimes++;
 80019a0:	4b18      	ldr	r3, [pc, #96]	; (8001a04 <Hal_STM32F767_Get_Timer_CNT+0xa0>)
 80019a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80019a6:	1c50      	adds	r0, r2, #1
 80019a8:	f143 0100 	adc.w	r1, r3, #0
 80019ac:	4b15      	ldr	r3, [pc, #84]	; (8001a04 <Hal_STM32F767_Get_Timer_CNT+0xa0>)
 80019ae:	e9c3 0100 	strd	r0, r1, [r3]
    }
    bacCycle = swCycles;
 80019b2:	4913      	ldr	r1, [pc, #76]	; (8001a00 <Hal_STM32F767_Get_Timer_CNT+0x9c>)
 80019b4:	e9d7 2300 	ldrd	r2, r3, [r7]
 80019b8:	e9c1 2300 	strd	r2, r3, [r1]

    return (swCycles + cycleTimes * TIMER3_RELOAD);
 80019bc:	4b11      	ldr	r3, [pc, #68]	; (8001a04 <Hal_STM32F767_Get_Timer_CNT+0xa0>)
 80019be:	e9d3 2300 	ldrd	r2, r3, [r3]
 80019c2:	f24c 3150 	movw	r1, #50000	; 0xc350
 80019c6:	fb01 f003 	mul.w	r0, r1, r3
 80019ca:	2100      	movs	r1, #0
 80019cc:	fb01 f102 	mul.w	r1, r1, r2
 80019d0:	4401      	add	r1, r0
 80019d2:	f24c 3050 	movw	r0, #50000	; 0xc350
 80019d6:	fba2 2300 	umull	r2, r3, r2, r0
 80019da:	4419      	add	r1, r3
 80019dc:	460b      	mov	r3, r1
 80019de:	e9d7 0100 	ldrd	r0, r1, [r7]
 80019e2:	1814      	adds	r4, r2, r0
 80019e4:	eb43 0501 	adc.w	r5, r3, r1
 80019e8:	4622      	mov	r2, r4
 80019ea:	462b      	mov	r3, r5
}
 80019ec:	4610      	mov	r0, r2
 80019ee:	4619      	mov	r1, r3
 80019f0:	370c      	adds	r7, #12
 80019f2:	46bd      	mov	sp, r7
 80019f4:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
 80019f8:	4770      	bx	lr
 80019fa:	bf00      	nop
 80019fc:	200034d0 	.word	0x200034d0
 8001a00:	20000738 	.word	0x20000738
 8001a04:	20000740 	.word	0x20000740

08001a08 <GetTimerCycles>:

/* 
    2022-04-07 tanzhongqiang 要求返回对应SYSCLK 的cycles 。前置YSCLK 216MHZ.
*/
UINT64 GetTimerCycles(VOID)
{
 8001a08:	b5b0      	push	{r4, r5, r7, lr}
 8001a0a:	af00      	add	r7, sp, #0
#4  0x08013f36 in OsCpupIrqStart () at los_cpup.c:520
#5  0x08001f62 in OsIntHandle (hwiNum=45, hwiForm=0x20002490 <g_hwiForm+720>) at los_hwi.c:123
#6  0x0800f178 in IrqEntryV7M () at arm_nvic.c:100
* */

    return Hal_STM32F767_Get_Timer_CNT() * 216;// * 1000000;
 8001a0c:	f7ff ffaa 	bl	8001964 <Hal_STM32F767_Get_Timer_CNT>
 8001a10:	4602      	mov	r2, r0
 8001a12:	460b      	mov	r3, r1
 8001a14:	1894      	adds	r4, r2, r2
 8001a16:	eb43 0503 	adc.w	r5, r3, r3
 8001a1a:	4622      	mov	r2, r4
 8001a1c:	462b      	mov	r3, r5
 8001a1e:	1812      	adds	r2, r2, r0
 8001a20:	eb41 0303 	adc.w	r3, r1, r3
 8001a24:	f04f 0000 	mov.w	r0, #0
 8001a28:	f04f 0100 	mov.w	r1, #0
 8001a2c:	00d9      	lsls	r1, r3, #3
 8001a2e:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8001a32:	00d0      	lsls	r0, r2, #3
 8001a34:	1812      	adds	r2, r2, r0
 8001a36:	eb41 0303 	adc.w	r3, r1, r3
 8001a3a:	f04f 0000 	mov.w	r0, #0
 8001a3e:	f04f 0100 	mov.w	r1, #0
 8001a42:	00d9      	lsls	r1, r3, #3
 8001a44:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8001a48:	00d0      	lsls	r0, r2, #3
 8001a4a:	4602      	mov	r2, r0
 8001a4c:	460b      	mov	r3, r1
}
 8001a4e:	4610      	mov	r0, r2
 8001a50:	4619      	mov	r1, r3
 8001a52:	bdb0      	pop	{r4, r5, r7, pc}

08001a54 <Error_Handler>:
{
 8001a54:	b580      	push	{r7, lr}
 8001a56:	af00      	add	r7, sp, #0
    _Error_Handler(__FILE__, __LINE__);
 8001a58:	213b      	movs	r1, #59	; 0x3b
 8001a5a:	4802      	ldr	r0, [pc, #8]	; (8001a64 <Error_Handler+0x10>)
 8001a5c:	f000 f995 	bl	8001d8a <_Error_Handler>
}
 8001a60:	bf00      	nop
 8001a62:	bd80      	pop	{r7, pc}
 8001a64:	0801ff04 	.word	0x0801ff04

08001a68 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart1;

/* USART3 init function */

void MX_USART1_UART_Init(void)
{
 8001a68:	b580      	push	{r7, lr}
 8001a6a:	af00      	add	r7, sp, #0
  huart1.Instance = USART1;
 8001a6c:	4b14      	ldr	r3, [pc, #80]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a6e:	4a15      	ldr	r2, [pc, #84]	; (8001ac4 <MX_USART1_UART_Init+0x5c>)
 8001a70:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 8001a72:	4b13      	ldr	r3, [pc, #76]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a74:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8001a78:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8001a7a:	4b11      	ldr	r3, [pc, #68]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a7c:	2200      	movs	r2, #0
 8001a7e:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8001a80:	4b0f      	ldr	r3, [pc, #60]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a82:	2200      	movs	r2, #0
 8001a84:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8001a86:	4b0e      	ldr	r3, [pc, #56]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a88:	2200      	movs	r2, #0
 8001a8a:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8001a8c:	4b0c      	ldr	r3, [pc, #48]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a8e:	220c      	movs	r2, #12
 8001a90:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001a92:	4b0b      	ldr	r3, [pc, #44]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a94:	2200      	movs	r2, #0
 8001a96:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8001a98:	4b09      	ldr	r3, [pc, #36]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001a9a:	2200      	movs	r2, #0
 8001a9c:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001a9e:	4b08      	ldr	r3, [pc, #32]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001aa0:	2200      	movs	r2, #0
 8001aa2:	621a      	str	r2, [r3, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001aa4:	4b06      	ldr	r3, [pc, #24]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001aa6:	2200      	movs	r2, #0
 8001aa8:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8001aaa:	4805      	ldr	r0, [pc, #20]	; (8001ac0 <MX_USART1_UART_Init+0x58>)
 8001aac:	f00c fd46 	bl	800e53c <HAL_UART_Init>
 8001ab0:	4603      	mov	r3, r0
 8001ab2:	2b00      	cmp	r3, #0
 8001ab4:	d001      	beq.n	8001aba <MX_USART1_UART_Init+0x52>
  {
    Error_Handler();
 8001ab6:	f7ff ffcd 	bl	8001a54 <Error_Handler>
  }
}
 8001aba:	bf00      	nop
 8001abc:	bd80      	pop	{r7, pc}
 8001abe:	bf00      	nop
 8001ac0:	20003540 	.word	0x20003540
 8001ac4:	40011000 	.word	0x40011000

08001ac8 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8001ac8:	b580      	push	{r7, lr}
 8001aca:	b08a      	sub	sp, #40	; 0x28
 8001acc:	af00      	add	r7, sp, #0
 8001ace:	6078      	str	r0, [r7, #4]
 8001ad0:	4b22      	ldr	r3, [pc, #136]	; (8001b5c <HAL_UART_MspInit+0x94>)
 8001ad2:	681b      	ldr	r3, [r3, #0]
 8001ad4:	627b      	str	r3, [r7, #36]	; 0x24
 8001ad6:	f04f 0300 	mov.w	r3, #0

  GPIO_InitTypeDef GPIO_InitStructure = {0};
 8001ada:	f107 0310 	add.w	r3, r7, #16
 8001ade:	2200      	movs	r2, #0
 8001ae0:	601a      	str	r2, [r3, #0]
 8001ae2:	605a      	str	r2, [r3, #4]
 8001ae4:	609a      	str	r2, [r3, #8]
 8001ae6:	60da      	str	r2, [r3, #12]
 8001ae8:	611a      	str	r2, [r3, #16]
  if(uartHandle->Instance==USART1)
 8001aea:	687b      	ldr	r3, [r7, #4]
 8001aec:	681b      	ldr	r3, [r3, #0]
 8001aee:	4a1c      	ldr	r2, [pc, #112]	; (8001b60 <HAL_UART_MspInit+0x98>)
 8001af0:	4293      	cmp	r3, r2
 8001af2:	d128      	bne.n	8001b46 <HAL_UART_MspInit+0x7e>
  {
     /* Enable GPIOA clock */
      __HAL_RCC_GPIOA_CLK_ENABLE();
 8001af4:	4b1b      	ldr	r3, [pc, #108]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001af6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001af8:	4a1a      	ldr	r2, [pc, #104]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001afa:	f043 0301 	orr.w	r3, r3, #1
 8001afe:	6313      	str	r3, [r2, #48]	; 0x30
 8001b00:	4b18      	ldr	r3, [pc, #96]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001b02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001b04:	f003 0301 	and.w	r3, r3, #1
 8001b08:	60bb      	str	r3, [r7, #8]
 8001b0a:	68bb      	ldr	r3, [r7, #8]
      /* Enable USART1 clock */
      __HAL_RCC_USART1_CLK_ENABLE();
 8001b0c:	4b15      	ldr	r3, [pc, #84]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001b0e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001b10:	4a14      	ldr	r2, [pc, #80]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001b12:	f043 0310 	orr.w	r3, r3, #16
 8001b16:	6453      	str	r3, [r2, #68]	; 0x44
 8001b18:	4b12      	ldr	r3, [pc, #72]	; (8001b64 <HAL_UART_MspInit+0x9c>)
 8001b1a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001b1c:	f003 0310 	and.w	r3, r3, #16
 8001b20:	60fb      	str	r3, [r7, #12]
 8001b22:	68fb      	ldr	r3, [r7, #12]

      /* Configure USART1_TX (PA9) and USART1_RX (PA10) */
      GPIO_InitStructure.Pin = GPIO_PIN_9 | GPIO_PIN_10;
 8001b24:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8001b28:	613b      	str	r3, [r7, #16]
      GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
 8001b2a:	2302      	movs	r3, #2
 8001b2c:	617b      	str	r3, [r7, #20]
      GPIO_InitStructure.Pull = GPIO_PULLUP;
 8001b2e:	2301      	movs	r3, #1
 8001b30:	61bb      	str	r3, [r7, #24]
      GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
 8001b32:	2302      	movs	r3, #2
 8001b34:	61fb      	str	r3, [r7, #28]
      GPIO_InitStructure.Alternate = GPIO_AF7_USART1;
 8001b36:	2307      	movs	r3, #7
 8001b38:	623b      	str	r3, [r7, #32]
      HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001b3a:	f107 0310 	add.w	r3, r7, #16
 8001b3e:	4619      	mov	r1, r3
 8001b40:	4809      	ldr	r0, [pc, #36]	; (8001b68 <HAL_UART_MspInit+0xa0>)
 8001b42:	f00c fb1d 	bl	800e180 <HAL_GPIO_Init>
  }
}
 8001b46:	bf00      	nop
 8001b48:	4b04      	ldr	r3, [pc, #16]	; (8001b5c <HAL_UART_MspInit+0x94>)
 8001b4a:	681a      	ldr	r2, [r3, #0]
 8001b4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001b4e:	405a      	eors	r2, r3
 8001b50:	d001      	beq.n	8001b56 <HAL_UART_MspInit+0x8e>
 8001b52:	f002 fd43 	bl	80045dc <__stack_chk_fail>
 8001b56:	3728      	adds	r7, #40	; 0x28
 8001b58:	46bd      	mov	sp, r7
 8001b5a:	bd80      	pop	{r7, pc}
 8001b5c:	0801ff60 	.word	0x0801ff60
 8001b60:	40011000 	.word	0x40011000
 8001b64:	40023800 	.word	0x40023800
 8001b68:	40020000 	.word	0x40020000

08001b6c <UsartInit>:
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_9|GPIO_PIN_10);
  }
}

/* USER CODE BEGIN 1 */
VOID UsartInit(VOID) {
 8001b6c:	b580      	push	{r7, lr}
 8001b6e:	af00      	add	r7, sp, #0
    MX_USART1_UART_Init();
 8001b70:	f7ff ff7a 	bl	8001a68 <MX_USART1_UART_Init>
}
 8001b74:	bf00      	nop
 8001b76:	bd80      	pop	{r7, pc}

08001b78 <UsartWrite>:

VOID UsartWrite(const CHAR c)
{
 8001b78:	b580      	push	{r7, lr}
 8001b7a:	b082      	sub	sp, #8
 8001b7c:	af00      	add	r7, sp, #0
 8001b7e:	4603      	mov	r3, r0
 8001b80:	71fb      	strb	r3, [r7, #7]
    (VOID)HAL_UART_Transmit(&huart1, (UINT8 *)&c, 1, DEFAULT_TIMEOUT);
 8001b82:	1df9      	adds	r1, r7, #7
 8001b84:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001b88:	2201      	movs	r2, #1
 8001b8a:	4803      	ldr	r0, [pc, #12]	; (8001b98 <UsartWrite+0x20>)
 8001b8c:	f00c fd23 	bl	800e5d6 <HAL_UART_Transmit>
}
 8001b90:	bf00      	nop
 8001b92:	3708      	adds	r7, #8
 8001b94:	46bd      	mov	sp, r7
 8001b96:	bd80      	pop	{r7, pc}
 8001b98:	20003540 	.word	0x20003540

08001b9c <UsartRead>:

UINT8 UsartRead(VOID)
{
 8001b9c:	b580      	push	{r7, lr}
 8001b9e:	b082      	sub	sp, #8
 8001ba0:	af00      	add	r7, sp, #0
 8001ba2:	4b0c      	ldr	r3, [pc, #48]	; (8001bd4 <UsartRead+0x38>)
 8001ba4:	681b      	ldr	r3, [r3, #0]
 8001ba6:	607b      	str	r3, [r7, #4]
 8001ba8:	f04f 0300 	mov.w	r3, #0
    UINT8 ch;
    LedTaskTrigger();
 8001bac:	f000 fa52 	bl	8002054 <LedTaskTrigger>
    (VOID)HAL_UART_Receive(&huart1, &ch, sizeof(UINT8), 0);
 8001bb0:	1cf9      	adds	r1, r7, #3
 8001bb2:	2300      	movs	r3, #0
 8001bb4:	2201      	movs	r2, #1
 8001bb6:	4808      	ldr	r0, [pc, #32]	; (8001bd8 <UsartRead+0x3c>)
 8001bb8:	f00c fd9c 	bl	800e6f4 <HAL_UART_Receive>
    return ch;
 8001bbc:	78fb      	ldrb	r3, [r7, #3]
}
 8001bbe:	4a05      	ldr	r2, [pc, #20]	; (8001bd4 <UsartRead+0x38>)
 8001bc0:	6811      	ldr	r1, [r2, #0]
 8001bc2:	687a      	ldr	r2, [r7, #4]
 8001bc4:	4051      	eors	r1, r2
 8001bc6:	d001      	beq.n	8001bcc <UsartRead+0x30>
 8001bc8:	f002 fd08 	bl	80045dc <__stack_chk_fail>
 8001bcc:	4618      	mov	r0, r3
 8001bce:	3708      	adds	r7, #8
 8001bd0:	46bd      	mov	sp, r7
 8001bd2:	bd80      	pop	{r7, pc}
 8001bd4:	0801ff64 	.word	0x0801ff64
 8001bd8:	20003540 	.word	0x20003540

08001bdc <USART1_IdleCallback>:

//回调函数
void USART1_IdleCallback(uint8_t *pData,uint16_t len)
{
 8001bdc:	b480      	push	{r7}
 8001bde:	b083      	sub	sp, #12
 8001be0:	af00      	add	r7, sp, #0
 8001be2:	6078      	str	r0, [r7, #4]
 8001be4:	460b      	mov	r3, r1
 8001be6:	807b      	strh	r3, [r7, #2]
    while(__HAL_UART_GET_FLAG(&huart1,UART_FLAG_TC) != SET);
 8001be8:	bf00      	nop
 8001bea:	4b07      	ldr	r3, [pc, #28]	; (8001c08 <USART1_IdleCallback+0x2c>)
 8001bec:	681b      	ldr	r3, [r3, #0]
 8001bee:	69db      	ldr	r3, [r3, #28]
 8001bf0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8001bf4:	2b40      	cmp	r3, #64	; 0x40
 8001bf6:	d1f8      	bne.n	8001bea <USART1_IdleCallback+0xe>
    // HAL_UART_Transmit(&huart1,pData,len,1000);
}
 8001bf8:	bf00      	nop
 8001bfa:	bf00      	nop
 8001bfc:	370c      	adds	r7, #12
 8001bfe:	46bd      	mov	sp, r7
 8001c00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c04:	4770      	bx	lr
 8001c06:	bf00      	nop
 8001c08:	20003540 	.word	0x20003540

08001c0c <__USART1_IRQHandler>:

void __USART1_IRQHandler(void)
{
 8001c0c:	b580      	push	{r7, lr}
 8001c0e:	af00      	add	r7, sp, #0

    if(__HAL_UART_GET_FLAG(&huart1,UART_FLAG_ORE) != RESET) {
 8001c10:	4b1b      	ldr	r3, [pc, #108]	; (8001c80 <__USART1_IRQHandler+0x74>)
 8001c12:	681b      	ldr	r3, [r3, #0]
 8001c14:	69db      	ldr	r3, [r3, #28]
 8001c16:	f003 0308 	and.w	r3, r3, #8
 8001c1a:	2b08      	cmp	r3, #8
 8001c1c:	d104      	bne.n	8001c28 <__USART1_IRQHandler+0x1c>
        __HAL_UART_CLEAR_FLAG(&huart1, UART_CLEAR_OREF);
 8001c1e:	4b18      	ldr	r3, [pc, #96]	; (8001c80 <__USART1_IRQHandler+0x74>)
 8001c20:	681b      	ldr	r3, [r3, #0]
 8001c22:	2208      	movs	r2, #8
 8001c24:	621a      	str	r2, [r3, #32]
        goto out;
 8001c26:	e028      	b.n	8001c7a <__USART1_IRQHandler+0x6e>
    }

    //接收中断
    if(__HAL_UART_GET_FLAG(&huart1,UART_FLAG_RXNE) != RESET) {
 8001c28:	4b15      	ldr	r3, [pc, #84]	; (8001c80 <__USART1_IRQHandler+0x74>)
 8001c2a:	681b      	ldr	r3, [r3, #0]
 8001c2c:	69db      	ldr	r3, [r3, #28]
 8001c2e:	f003 0320 	and.w	r3, r3, #32
 8001c32:	2b20      	cmp	r3, #32
 8001c34:	d106      	bne.n	8001c44 <__USART1_IRQHandler+0x38>
        (VOID)uart_getc();
 8001c36:	f00e fe51 	bl	80108dc <uart_getc>
        __HAL_UART_CLEAR_FLAG(&huart1,UART_FLAG_RXNE);
 8001c3a:	4b11      	ldr	r3, [pc, #68]	; (8001c80 <__USART1_IRQHandler+0x74>)
 8001c3c:	681b      	ldr	r3, [r3, #0]
 8001c3e:	2220      	movs	r2, #32
 8001c40:	621a      	str	r2, [r3, #32]
        goto out;
 8001c42:	e01a      	b.n	8001c7a <__USART1_IRQHandler+0x6e>
    }
    //空闲中断
    if(__HAL_UART_GET_FLAG(&huart1,UART_FLAG_IDLE) != RESET) {
 8001c44:	4b0e      	ldr	r3, [pc, #56]	; (8001c80 <__USART1_IRQHandler+0x74>)
 8001c46:	681b      	ldr	r3, [r3, #0]
 8001c48:	69db      	ldr	r3, [r3, #28]
 8001c4a:	f003 0310 	and.w	r3, r3, #16
 8001c4e:	2b10      	cmp	r3, #16
 8001c50:	d10b      	bne.n	8001c6a <__USART1_IRQHandler+0x5e>
        //一帧数据接收完成  
        USART1_IdleCallback(aRxBuffer,rxConut);
 8001c52:	4b0c      	ldr	r3, [pc, #48]	; (8001c84 <__USART1_IRQHandler+0x78>)
 8001c54:	681b      	ldr	r3, [r3, #0]
 8001c56:	b29b      	uxth	r3, r3
 8001c58:	4619      	mov	r1, r3
 8001c5a:	480b      	ldr	r0, [pc, #44]	; (8001c88 <__USART1_IRQHandler+0x7c>)
 8001c5c:	f7ff ffbe 	bl	8001bdc <USART1_IdleCallback>
        __HAL_UART_CLEAR_FLAG(&huart1,UART_CLEAR_IDLEF);
 8001c60:	4b07      	ldr	r3, [pc, #28]	; (8001c80 <__USART1_IRQHandler+0x74>)
 8001c62:	681b      	ldr	r3, [r3, #0]
 8001c64:	2210      	movs	r2, #16
 8001c66:	621a      	str	r2, [r3, #32]
        goto out;
 8001c68:	e007      	b.n	8001c7a <__USART1_IRQHandler+0x6e>
    }

    while(1) {
        printf("huart1.Instance->ISR 0x%x\n",huart1.Instance->ISR);
 8001c6a:	4b05      	ldr	r3, [pc, #20]	; (8001c80 <__USART1_IRQHandler+0x74>)
 8001c6c:	681b      	ldr	r3, [r3, #0]
 8001c6e:	69db      	ldr	r3, [r3, #28]
 8001c70:	4619      	mov	r1, r3
 8001c72:	4806      	ldr	r0, [pc, #24]	; (8001c8c <__USART1_IRQHandler+0x80>)
 8001c74:	f00e fa24 	bl	80100c0 <printf>
 8001c78:	e7f7      	b.n	8001c6a <__USART1_IRQHandler+0x5e>
    }
    out:
    return;
 8001c7a:	bf00      	nop
}
 8001c7c:	bd80      	pop	{r7, pc}
 8001c7e:	bf00      	nop
 8001c80:	20003540 	.word	0x20003540
 8001c84:	20000748 	.word	0x20000748
 8001c88:	200035c4 	.word	0x200035c4
 8001c8c:	0801ff68 	.word	0x0801ff68

08001c90 <UsartHwi>:


INT32 UsartHwi(VOID)
{
 8001c90:	b580      	push	{r7, lr}
 8001c92:	b082      	sub	sp, #8
 8001c94:	af02      	add	r7, sp, #8
    if (huart1.Instance == NULL) {
 8001c96:	4b17      	ldr	r3, [pc, #92]	; (8001cf4 <UsartHwi+0x64>)
 8001c98:	681b      	ldr	r3, [r3, #0]
 8001c9a:	2b00      	cmp	r3, #0
 8001c9c:	d101      	bne.n	8001ca2 <UsartHwi+0x12>
        return LOS_NOK;
 8001c9e:	2301      	movs	r3, #1
 8001ca0:	e024      	b.n	8001cec <UsartHwi+0x5c>
    }
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8001ca2:	2025      	movs	r0, #37	; 0x25
 8001ca4:	f00c fa54 	bl	800e150 <HAL_NVIC_EnableIRQ>
    __HAL_UART_CLEAR_FLAG(&huart1, UART_FLAG_TC);
 8001ca8:	4b12      	ldr	r3, [pc, #72]	; (8001cf4 <UsartHwi+0x64>)
 8001caa:	681b      	ldr	r3, [r3, #0]
 8001cac:	2240      	movs	r2, #64	; 0x40
 8001cae:	621a      	str	r2, [r3, #32]
    (VOID)LOS_HwiCreate(NUM_HAL_INTERRUPT_UART, 0, 0, __USART1_IRQHandler, NULL);
 8001cb0:	2300      	movs	r3, #0
 8001cb2:	9300      	str	r3, [sp, #0]
 8001cb4:	4b10      	ldr	r3, [pc, #64]	; (8001cf8 <UsartHwi+0x68>)
 8001cb6:	2200      	movs	r2, #0
 8001cb8:	2100      	movs	r1, #0
 8001cba:	2035      	movs	r0, #53	; 0x35
 8001cbc:	f000 fce8 	bl	8002690 <LOS_HwiCreate>
    HAL_NVIC_SetPriority(USART1_IRQn, 15, 0U);
 8001cc0:	2200      	movs	r2, #0
 8001cc2:	210f      	movs	r1, #15
 8001cc4:	2025      	movs	r0, #37	; 0x25
 8001cc6:	f00c fa2a 	bl	800e11e <HAL_NVIC_SetPriority>

    __HAL_UART_ENABLE_IT(&huart1,UART_IT_RXNE);//接收中断
 8001cca:	4b0a      	ldr	r3, [pc, #40]	; (8001cf4 <UsartHwi+0x64>)
 8001ccc:	681b      	ldr	r3, [r3, #0]
 8001cce:	681a      	ldr	r2, [r3, #0]
 8001cd0:	4b08      	ldr	r3, [pc, #32]	; (8001cf4 <UsartHwi+0x64>)
 8001cd2:	681b      	ldr	r3, [r3, #0]
 8001cd4:	f042 0220 	orr.w	r2, r2, #32
 8001cd8:	601a      	str	r2, [r3, #0]
    __HAL_UART_ENABLE_IT(&huart1,UART_IT_IDLE);//空闲中断
 8001cda:	4b06      	ldr	r3, [pc, #24]	; (8001cf4 <UsartHwi+0x64>)
 8001cdc:	681b      	ldr	r3, [r3, #0]
 8001cde:	681a      	ldr	r2, [r3, #0]
 8001ce0:	4b04      	ldr	r3, [pc, #16]	; (8001cf4 <UsartHwi+0x64>)
 8001ce2:	681b      	ldr	r3, [r3, #0]
 8001ce4:	f042 0210 	orr.w	r2, r2, #16
 8001ce8:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 8001cea:	2300      	movs	r3, #0
}
 8001cec:	4618      	mov	r0, r3
 8001cee:	46bd      	mov	sp, r7
 8001cf0:	bd80      	pop	{r7, pc}
 8001cf2:	bf00      	nop
 8001cf4:	20003540 	.word	0x20003540
 8001cf8:	08001c0d 	.word	0x08001c0d

08001cfc <Fire_DEBUG_GPIOB6_TRIGGER>:

	HAL_GPIO_WritePin(LED_BLUE_GPIO_PORT,LED_BLUE_PIN,!on);
}

void Fire_DEBUG_GPIOB6_TRIGGER(void)
{
 8001cfc:	b580      	push	{r7, lr}
 8001cfe:	af00      	add	r7, sp, #0
    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_6);
 8001d00:	2140      	movs	r1, #64	; 0x40
 8001d02:	4802      	ldr	r0, [pc, #8]	; (8001d0c <Fire_DEBUG_GPIOB6_TRIGGER+0x10>)
 8001d04:	f00c fc00 	bl	800e508 <HAL_GPIO_TogglePin>
}
 8001d08:	bf00      	nop
 8001d0a:	bd80      	pop	{r7, pc}
 8001d0c:	40020400 	.word	0x40020400

08001d10 <Fire_DEBUG_GPIOB7_TRIGGER>:

void Fire_DEBUG_GPIOB7_TRIGGER(void)
{
 8001d10:	b580      	push	{r7, lr}
 8001d12:	af00      	add	r7, sp, #0
    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_7);
 8001d14:	2180      	movs	r1, #128	; 0x80
 8001d16:	4802      	ldr	r0, [pc, #8]	; (8001d20 <Fire_DEBUG_GPIOB7_TRIGGER+0x10>)
 8001d18:	f00c fbf6 	bl	800e508 <HAL_GPIO_TogglePin>
}
 8001d1c:	bf00      	nop
 8001d1e:	bd80      	pop	{r7, pc}
 8001d20:	40020400 	.word	0x40020400

08001d24 <Fire_DEBUG_GPIOB6>:
{
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, on);
}

void Fire_DEBUG_GPIOB6(int on)
{
 8001d24:	b580      	push	{r7, lr}
 8001d26:	b082      	sub	sp, #8
 8001d28:	af00      	add	r7, sp, #0
 8001d2a:	6078      	str	r0, [r7, #4]
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, on);
 8001d2c:	687b      	ldr	r3, [r7, #4]
 8001d2e:	461a      	mov	r2, r3
 8001d30:	2140      	movs	r1, #64	; 0x40
 8001d32:	4803      	ldr	r0, [pc, #12]	; (8001d40 <Fire_DEBUG_GPIOB6+0x1c>)
 8001d34:	f00c fbd0 	bl	800e4d8 <HAL_GPIO_WritePin>
}
 8001d38:	bf00      	nop
 8001d3a:	3708      	adds	r7, #8
 8001d3c:	46bd      	mov	sp, r7
 8001d3e:	bd80      	pop	{r7, pc}
 8001d40:	40020400 	.word	0x40020400

08001d44 <Fire_DEBUG_GPIOB7>:

void Fire_DEBUG_GPIOB7(int on)
{
 8001d44:	b580      	push	{r7, lr}
 8001d46:	b082      	sub	sp, #8
 8001d48:	af00      	add	r7, sp, #0
 8001d4a:	6078      	str	r0, [r7, #4]
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, on);
 8001d4c:	687b      	ldr	r3, [r7, #4]
 8001d4e:	461a      	mov	r2, r3
 8001d50:	2180      	movs	r1, #128	; 0x80
 8001d52:	4803      	ldr	r0, [pc, #12]	; (8001d60 <Fire_DEBUG_GPIOB7+0x1c>)
 8001d54:	f00c fbc0 	bl	800e4d8 <HAL_GPIO_WritePin>
}
 8001d58:	bf00      	nop
 8001d5a:	3708      	adds	r7, #8
 8001d5c:	46bd      	mov	sp, r7
 8001d5e:	bd80      	pop	{r7, pc}
 8001d60:	40020400 	.word	0x40020400

08001d64 <Error_Handler>:
{
 8001d64:	b580      	push	{r7, lr}
 8001d66:	af00      	add	r7, sp, #0
    _Error_Handler(__FILE__, __LINE__);
 8001d68:	213b      	movs	r1, #59	; 0x3b
 8001d6a:	4802      	ldr	r0, [pc, #8]	; (8001d74 <Error_Handler+0x10>)
 8001d6c:	f000 f80d 	bl	8001d8a <_Error_Handler>
}
 8001d70:	bf00      	nop
 8001d72:	bd80      	pop	{r7, pc}
 8001d74:	0801ff84 	.word	0x0801ff84

08001d78 <HAL_GetTick>:
 * --------------------------------------------------------------------------- */

#include "sys_init.h"
#include "los_sys.h"

uint32_t HAL_GetTick(void) {
 8001d78:	b580      	push	{r7, lr}
 8001d7a:	af00      	add	r7, sp, #0
#ifdef LOSCFG_PLATFORM_STM32F767_FIRE
    extern UINT64 Hal_STM32F767_Get_Timer_CNT(VOID);
    return Hal_STM32F767_Get_Timer_CNT();
 8001d7c:	f7ff fdf2 	bl	8001964 <Hal_STM32F767_Get_Timer_CNT>
 8001d80:	4602      	mov	r2, r0
 8001d82:	460b      	mov	r3, r1
 8001d84:	4613      	mov	r3, r2
#else
    return (UINT32)LOS_TickCountGet();
#endif    
}
 8001d86:	4618      	mov	r0, r3
 8001d88:	bd80      	pop	{r7, pc}

08001d8a <_Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  file: The file name as string.
  * @param  line: The line in file as a number.
  * @retval None
  */
void _Error_Handler(char const *file, int line) {
 8001d8a:	b480      	push	{r7}
 8001d8c:	b083      	sub	sp, #12
 8001d8e:	af00      	add	r7, sp, #0
 8001d90:	6078      	str	r0, [r7, #4]
 8001d92:	6039      	str	r1, [r7, #0]
    /* USER CODE BEGIN Error_Handler_Debug */
    /* User can add his own implementation to report the HAL error return state */
    (void)file;
    (void)line;
    while (1) {
 8001d94:	e7fe      	b.n	8001d94 <_Error_Handler+0xa>
	...

08001d98 <SystemClock_Config>:

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void) {
 8001d98:	b580      	push	{r7, lr}
 8001d9a:	b0ba      	sub	sp, #232	; 0xe8
 8001d9c:	af00      	add	r7, sp, #0
 8001d9e:	4b48      	ldr	r3, [pc, #288]	; (8001ec0 <SystemClock_Config+0x128>)
 8001da0:	681b      	ldr	r3, [r3, #0]
 8001da2:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8001da6:	f04f 0300 	mov.w	r3, #0
    RCC_OscInitTypeDef rccOscInitStruct = {0};
 8001daa:	f107 0320 	add.w	r3, r7, #32
 8001dae:	2234      	movs	r2, #52	; 0x34
 8001db0:	2100      	movs	r1, #0
 8001db2:	4618      	mov	r0, r3
 8001db4:	f00d faa8 	bl	800f308 <memset>
    RCC_ClkInitTypeDef rccClkInitStruct = {0};
 8001db8:	f107 030c 	add.w	r3, r7, #12
 8001dbc:	2200      	movs	r2, #0
 8001dbe:	601a      	str	r2, [r3, #0]
 8001dc0:	605a      	str	r2, [r3, #4]
 8001dc2:	609a      	str	r2, [r3, #8]
 8001dc4:	60da      	str	r2, [r3, #12]
 8001dc6:	611a      	str	r2, [r3, #16]
    RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001dc8:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8001dcc:	2290      	movs	r2, #144	; 0x90
 8001dce:	2100      	movs	r1, #0
 8001dd0:	4618      	mov	r0, r3
 8001dd2:	f00d fa99 	bl	800f308 <memset>

    /** Configure LSE Drive Capability
    */
    HAL_PWR_EnableBkUpAccess();
 8001dd6:	f00c f83d 	bl	800de54 <HAL_PWR_EnableBkUpAccess>
    /** Configure the main internal regulator output voltage
    */
    __HAL_RCC_PWR_CLK_ENABLE();
 8001dda:	4b3a      	ldr	r3, [pc, #232]	; (8001ec4 <SystemClock_Config+0x12c>)
 8001ddc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001dde:	4a39      	ldr	r2, [pc, #228]	; (8001ec4 <SystemClock_Config+0x12c>)
 8001de0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001de4:	6413      	str	r3, [r2, #64]	; 0x40
 8001de6:	4b37      	ldr	r3, [pc, #220]	; (8001ec4 <SystemClock_Config+0x12c>)
 8001de8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001dea:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001dee:	607b      	str	r3, [r7, #4]
 8001df0:	687b      	ldr	r3, [r7, #4]
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001df2:	4b35      	ldr	r3, [pc, #212]	; (8001ec8 <SystemClock_Config+0x130>)
 8001df4:	681b      	ldr	r3, [r3, #0]
 8001df6:	4a34      	ldr	r2, [pc, #208]	; (8001ec8 <SystemClock_Config+0x130>)
 8001df8:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8001dfc:	6013      	str	r3, [r2, #0]
 8001dfe:	4b32      	ldr	r3, [pc, #200]	; (8001ec8 <SystemClock_Config+0x130>)
 8001e00:	681b      	ldr	r3, [r3, #0]
 8001e02:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8001e06:	60bb      	str	r3, [r7, #8]
 8001e08:	68bb      	ldr	r3, [r7, #8]
    /** Initializes the RCC Oscillators according to the specified parameters
    * in the RCC_OscInitTypeDef structure.
    */

    rccOscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001e0a:	2301      	movs	r3, #1
 8001e0c:	623b      	str	r3, [r7, #32]
    rccOscInitStruct.HSEState = RCC_HSE_ON;
 8001e0e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001e12:	627b      	str	r3, [r7, #36]	; 0x24
    rccOscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001e14:	2302      	movs	r3, #2
 8001e16:	63bb      	str	r3, [r7, #56]	; 0x38
    rccOscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001e18:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8001e1c:	63fb      	str	r3, [r7, #60]	; 0x3c
    rccOscInitStruct.PLL.PLLM = 25;// 4, Division factor for PLL VCO iput clock.
 8001e1e:	2319      	movs	r3, #25
 8001e20:	643b      	str	r3, [r7, #64]	; 0x40
    rccOscInitStruct.PLL.PLLN = 432; // 216, Multiplication factor for PLL VCO output clock.
 8001e22:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
 8001e26:	647b      	str	r3, [r7, #68]	; 0x44
    rccOscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8001e28:	2302      	movs	r3, #2
 8001e2a:	64bb      	str	r3, [r7, #72]	; 0x48
    rccOscInitStruct.PLL.PLLQ = 2; // 9, Division factor for
 8001e2c:	2302      	movs	r3, #2
 8001e2e:	64fb      	str	r3, [r7, #76]	; 0x4c
    rccOscInitStruct.PLL.PLLR = 2;
 8001e30:	2302      	movs	r3, #2
 8001e32:	653b      	str	r3, [r7, #80]	; 0x50


    if (HAL_RCC_OscConfig(&rccOscInitStruct) != HAL_OK) {
 8001e34:	f107 0320 	add.w	r3, r7, #32
 8001e38:	4618      	mov	r0, r3
 8001e3a:	f00b facf 	bl	800d3dc <HAL_RCC_OscConfig>
 8001e3e:	4603      	mov	r3, r0
 8001e40:	2b00      	cmp	r3, #0
 8001e42:	d001      	beq.n	8001e48 <SystemClock_Config+0xb0>
        Error_Handler();
 8001e44:	f7ff ff8e 	bl	8001d64 <Error_Handler>
    }
    /** Activate the Over-Drive mode
    */
    if (HAL_PWREx_EnableOverDrive() != HAL_OK) {
 8001e48:	f00b fa78 	bl	800d33c <HAL_PWREx_EnableOverDrive>
 8001e4c:	4603      	mov	r3, r0
 8001e4e:	2b00      	cmp	r3, #0
 8001e50:	d001      	beq.n	8001e56 <SystemClock_Config+0xbe>
        Error_Handler();
 8001e52:	f7ff ff87 	bl	8001d64 <Error_Handler>
    }
    /** Initializes the CPU, AHB and APB buses clocks
    */
    rccClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
 8001e56:	230f      	movs	r3, #15
 8001e58:	60fb      	str	r3, [r7, #12]
                                  | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
    rccClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8001e5a:	2302      	movs	r3, #2
 8001e5c:	613b      	str	r3, [r7, #16]
    rccClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001e5e:	2300      	movs	r3, #0
 8001e60:	617b      	str	r3, [r7, #20]
    rccClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8001e62:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8001e66:	61bb      	str	r3, [r7, #24]
    rccClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8001e68:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001e6c:	61fb      	str	r3, [r7, #28]

    if (HAL_RCC_ClockConfig(&rccClkInitStruct, FLASH_LATENCY_7) != HAL_OK) {
 8001e6e:	f107 030c 	add.w	r3, r7, #12
 8001e72:	2107      	movs	r1, #7
 8001e74:	4618      	mov	r0, r3
 8001e76:	f00b fd5f 	bl	800d938 <HAL_RCC_ClockConfig>
 8001e7a:	4603      	mov	r3, r0
 8001e7c:	2b00      	cmp	r3, #0
 8001e7e:	d001      	beq.n	8001e84 <SystemClock_Config+0xec>
        Error_Handler();
 8001e80:	f7ff ff70 	bl	8001d64 <Error_Handler>
    }

    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8001e84:	2340      	movs	r3, #64	; 0x40
 8001e86:	657b      	str	r3, [r7, #84]	; 0x54
    PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 8001e88:	2300      	movs	r3, #0
 8001e8a:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001e8e:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8001e92:	4618      	mov	r0, r3
 8001e94:	f00a fa26 	bl	800c2e4 <HAL_RCCEx_PeriphCLKConfig>
 8001e98:	4603      	mov	r3, r0
 8001e9a:	2b00      	cmp	r3, #0
 8001e9c:	d001      	beq.n	8001ea2 <SystemClock_Config+0x10a>
    {
        Error_Handler();
 8001e9e:	f7ff ff61 	bl	8001d64 <Error_Handler>
    }
    /** Enables the Clock Security System
    */
    HAL_RCC_EnableCSS();
 8001ea2:	f00b fe35 	bl	800db10 <HAL_RCC_EnableCSS>
}
 8001ea6:	bf00      	nop
 8001ea8:	4b05      	ldr	r3, [pc, #20]	; (8001ec0 <SystemClock_Config+0x128>)
 8001eaa:	681a      	ldr	r2, [r3, #0]
 8001eac:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8001eb0:	405a      	eors	r2, r3
 8001eb2:	d001      	beq.n	8001eb8 <SystemClock_Config+0x120>
 8001eb4:	f002 fb92 	bl	80045dc <__stack_chk_fail>
 8001eb8:	37e8      	adds	r7, #232	; 0xe8
 8001eba:	46bd      	mov	sp, r7
 8001ebc:	bd80      	pop	{r7, pc}
 8001ebe:	bf00      	nop
 8001ec0:	0801ffe0 	.word	0x0801ffe0
 8001ec4:	40023800 	.word	0x40023800
 8001ec8:	40007000 	.word	0x40007000

08001ecc <HAL_MspInit>:

void HAL_MspInit(void)
{
 8001ecc:	b480      	push	{r7}
 8001ece:	b083      	sub	sp, #12
 8001ed0:	af00      	add	r7, sp, #0
    __HAL_RCC_PWR_CLK_ENABLE();
 8001ed2:	4b0f      	ldr	r3, [pc, #60]	; (8001f10 <HAL_MspInit+0x44>)
 8001ed4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001ed6:	4a0e      	ldr	r2, [pc, #56]	; (8001f10 <HAL_MspInit+0x44>)
 8001ed8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001edc:	6413      	str	r3, [r2, #64]	; 0x40
 8001ede:	4b0c      	ldr	r3, [pc, #48]	; (8001f10 <HAL_MspInit+0x44>)
 8001ee0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001ee2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001ee6:	603b      	str	r3, [r7, #0]
 8001ee8:	683b      	ldr	r3, [r7, #0]
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001eea:	4b09      	ldr	r3, [pc, #36]	; (8001f10 <HAL_MspInit+0x44>)
 8001eec:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001eee:	4a08      	ldr	r2, [pc, #32]	; (8001f10 <HAL_MspInit+0x44>)
 8001ef0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001ef4:	6453      	str	r3, [r2, #68]	; 0x44
 8001ef6:	4b06      	ldr	r3, [pc, #24]	; (8001f10 <HAL_MspInit+0x44>)
 8001ef8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001efa:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001efe:	607b      	str	r3, [r7, #4]
 8001f00:	687b      	ldr	r3, [r7, #4]
}
 8001f02:	bf00      	nop
 8001f04:	370c      	adds	r7, #12
 8001f06:	46bd      	mov	sp, r7
 8001f08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f0c:	4770      	bx	lr
 8001f0e:	bf00      	nop
 8001f10:	40023800 	.word	0x40023800

08001f14 <LedTask1>:
/* 等待的事件类型 */
#define EVENT_WAIT 0x00000001


STATIC UINT32 LedTask1(VOID)
{// 2022-3-31 tanzhongqiang 测试event 在中断，任务优先级方面的影响。在更高优先级没有让渡CPU情况，event 得不到响应。
 8001f14:	b580      	push	{r7, lr}
 8001f16:	b082      	sub	sp, #8
 8001f18:	af00      	add	r7, sp, #0

    UINT32 event;

    while (1) {          
        event = LOS_EventRead(&g_pevent, EVENT_WAIT, LOS_WAITMODE_AND, LOS_WAIT_FOREVER);
 8001f1a:	f04f 33ff 	mov.w	r3, #4294967295
 8001f1e:	2204      	movs	r2, #4
 8001f20:	2101      	movs	r1, #1
 8001f22:	480b      	ldr	r0, [pc, #44]	; (8001f50 <LedTask1+0x3c>)
 8001f24:	f003 f870 	bl	8005008 <LOS_EventRead>
 8001f28:	6078      	str	r0, [r7, #4]
        if (event == EVENT_WAIT) {
 8001f2a:	687b      	ldr	r3, [r7, #4]
 8001f2c:	2b01      	cmp	r3, #1
 8001f2e:	d109      	bne.n	8001f44 <LedTask1+0x30>
            LOS_EventClear(&g_pevent, ~g_pevent.uwEventID);
 8001f30:	4b07      	ldr	r3, [pc, #28]	; (8001f50 <LedTask1+0x3c>)
 8001f32:	681b      	ldr	r3, [r3, #0]
 8001f34:	43db      	mvns	r3, r3
 8001f36:	4619      	mov	r1, r3
 8001f38:	4805      	ldr	r0, [pc, #20]	; (8001f50 <LedTask1+0x3c>)
 8001f3a:	f003 f8eb 	bl	8005114 <LOS_EventClear>
            // printf("last_pc : 0x%x\n",g_interrupt_pc);  
            Fire_DEBUG_GPIOB6_TRIGGER();                 
 8001f3e:	f7ff fedd 	bl	8001cfc <Fire_DEBUG_GPIOB6_TRIGGER>
 8001f42:	e7ea      	b.n	8001f1a <LedTask1+0x6>
        }else{
            printf("event 0x%x\n",event);
 8001f44:	6879      	ldr	r1, [r7, #4]
 8001f46:	4803      	ldr	r0, [pc, #12]	; (8001f54 <LedTask1+0x40>)
 8001f48:	f00e f8ba 	bl	80100c0 <printf>
        event = LOS_EventRead(&g_pevent, EVENT_WAIT, LOS_WAITMODE_AND, LOS_WAIT_FOREVER);
 8001f4c:	e7e5      	b.n	8001f1a <LedTask1+0x6>
 8001f4e:	bf00      	nop
 8001f50:	2000074c 	.word	0x2000074c
 8001f54:	0801ffe4 	.word	0x0801ffe4

08001f58 <LedTask2>:
    return 0;
}

#if 1
STATIC UINT32 LedTask2(VOID)
{
 8001f58:	b580      	push	{r7, lr}
 8001f5a:	af00      	add	r7, sp, #0
    while (1) {       
        // LOS_TaskDelay(10); 
        LOS_TaskYield();   
 8001f5c:	f002 f878 	bl	8004050 <LOS_TaskYield>
        Fire_DEBUG_GPIOB7_TRIGGER();
 8001f60:	f7ff fed6 	bl	8001d10 <Fire_DEBUG_GPIOB7_TRIGGER>
        LedTaskTrigger();
 8001f64:	f000 f876 	bl	8002054 <LedTaskTrigger>
        LOS_TaskYield();   
 8001f68:	e7f8      	b.n	8001f5c <LedTask2+0x4>
	...

08001f6c <LedTaskCreate>:
    return 0;
}
#endif

STATIC UINT32 LedTaskCreate(VOID)
{
 8001f6c:	b580      	push	{r7, lr}
 8001f6e:	b08c      	sub	sp, #48	; 0x30
 8001f70:	af00      	add	r7, sp, #0
 8001f72:	4b2a      	ldr	r3, [pc, #168]	; (800201c <LedTaskCreate+0xb0>)
 8001f74:	681b      	ldr	r3, [r3, #0]
 8001f76:	62fb      	str	r3, [r7, #44]	; 0x2c
 8001f78:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    UINT32 taskId = 0;
 8001f7c:	2300      	movs	r3, #0
 8001f7e:	603b      	str	r3, [r7, #0]
    TSK_INIT_PARAM_S ledTaskParam;

       /* 事件初始化 */
    ret = LOS_EventInit(&g_pevent);
 8001f80:	4827      	ldr	r0, [pc, #156]	; (8002020 <LedTaskCreate+0xb4>)
 8001f82:	f002 fdad 	bl	8004ae0 <LOS_EventInit>
 8001f86:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 8001f88:	687b      	ldr	r3, [r7, #4]
 8001f8a:	2b00      	cmp	r3, #0
 8001f8c:	d005      	beq.n	8001f9a <LedTaskCreate+0x2e>
        printf("init event failed .\n");
 8001f8e:	4825      	ldr	r0, [pc, #148]	; (8002024 <LedTaskCreate+0xb8>)
 8001f90:	f00e f896 	bl	80100c0 <printf>
        return -1;
 8001f94:	f04f 33ff 	mov.w	r3, #4294967295
 8001f98:	e034      	b.n	8002004 <LedTaskCreate+0x98>
    }

    ret = (UINT32)memset_s(&ledTaskParam, sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
 8001f9a:	f107 0008 	add.w	r0, r7, #8
 8001f9e:	2324      	movs	r3, #36	; 0x24
 8001fa0:	2200      	movs	r2, #0
 8001fa2:	2124      	movs	r1, #36	; 0x24
 8001fa4:	f000 f87e 	bl	80020a4 <memset_s>
 8001fa8:	4603      	mov	r3, r0
 8001faa:	607b      	str	r3, [r7, #4]
    if (ret != EOK) {
 8001fac:	687b      	ldr	r3, [r7, #4]
 8001fae:	2b00      	cmp	r3, #0
 8001fb0:	d001      	beq.n	8001fb6 <LedTaskCreate+0x4a>
        return ret;
 8001fb2:	687b      	ldr	r3, [r7, #4]
 8001fb4:	e026      	b.n	8002004 <LedTaskCreate+0x98>
    }

    // LOS_TaskLock();
    ledTaskParam.pfnTaskEntry = (TSK_ENTRY_FUNC)LedTask1;
 8001fb6:	4b1c      	ldr	r3, [pc, #112]	; (8002028 <LedTaskCreate+0xbc>)
 8001fb8:	60bb      	str	r3, [r7, #8]
    ledTaskParam.uwStackSize = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
 8001fba:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8001fbe:	623b      	str	r3, [r7, #32]
    ledTaskParam.pcName = "ledTask1";
 8001fc0:	4b1a      	ldr	r3, [pc, #104]	; (800202c <LedTaskCreate+0xc0>)
 8001fc2:	627b      	str	r3, [r7, #36]	; 0x24
    ledTaskParam.usTaskPrio = LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
 8001fc4:	230a      	movs	r3, #10
 8001fc6:	81bb      	strh	r3, [r7, #12]
    ledTaskParam.uwResved = LOS_TASK_STATUS_DETACHED;
 8001fc8:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001fcc:	62bb      	str	r3, [r7, #40]	; 0x28
    LOS_TaskCreate(&taskId, &ledTaskParam);
 8001fce:	f107 0208 	add.w	r2, r7, #8
 8001fd2:	463b      	mov	r3, r7
 8001fd4:	4611      	mov	r1, r2
 8001fd6:	4618      	mov	r0, r3
 8001fd8:	f001 fda8 	bl	8003b2c <LOS_TaskCreate>

#if 1
    ledTaskParam.pfnTaskEntry = (TSK_ENTRY_FUNC)LedTask2;
 8001fdc:	4b14      	ldr	r3, [pc, #80]	; (8002030 <LedTaskCreate+0xc4>)
 8001fde:	60bb      	str	r3, [r7, #8]
    ledTaskParam.uwStackSize = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
 8001fe0:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8001fe4:	623b      	str	r3, [r7, #32]
    ledTaskParam.pcName = "ledTask2";
 8001fe6:	4b13      	ldr	r3, [pc, #76]	; (8002034 <LedTaskCreate+0xc8>)
 8001fe8:	627b      	str	r3, [r7, #36]	; 0x24
    ledTaskParam.usTaskPrio = LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
 8001fea:	230a      	movs	r3, #10
 8001fec:	81bb      	strh	r3, [r7, #12]
    ledTaskParam.uwResved = LOS_TASK_STATUS_DETACHED;
 8001fee:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001ff2:	62bb      	str	r3, [r7, #40]	; 0x28
    LOS_TaskCreate(&taskId, &ledTaskParam);
 8001ff4:	f107 0208 	add.w	r2, r7, #8
 8001ff8:	463b      	mov	r3, r7
 8001ffa:	4611      	mov	r1, r2
 8001ffc:	4618      	mov	r0, r3
 8001ffe:	f001 fd95 	bl	8003b2c <LOS_TaskCreate>
#endif 
    // LOS_TaskUnlock();
    return 0; 
 8002002:	2300      	movs	r3, #0
}
 8002004:	4a05      	ldr	r2, [pc, #20]	; (800201c <LedTaskCreate+0xb0>)
 8002006:	6811      	ldr	r1, [r2, #0]
 8002008:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800200a:	4051      	eors	r1, r2
 800200c:	d001      	beq.n	8002012 <LedTaskCreate+0xa6>
 800200e:	f002 fae5 	bl	80045dc <__stack_chk_fail>
 8002012:	4618      	mov	r0, r3
 8002014:	3730      	adds	r7, #48	; 0x30
 8002016:	46bd      	mov	sp, r7
 8002018:	bd80      	pop	{r7, pc}
 800201a:	bf00      	nop
 800201c:	08020020 	.word	0x08020020
 8002020:	2000074c 	.word	0x2000074c
 8002024:	0801fff0 	.word	0x0801fff0
 8002028:	08001f15 	.word	0x08001f15
 800202c:	08020008 	.word	0x08020008
 8002030:	08001f59 	.word	0x08001f59
 8002034:	08020014 	.word	0x08020014

08002038 <app_init>:

VOID app_init(VOID)
{
 8002038:	b580      	push	{r7, lr}
 800203a:	af00      	add	r7, sp, #0
    printf("app init!\n");
 800203c:	4804      	ldr	r0, [pc, #16]	; (8002050 <app_init+0x18>)
 800203e:	f00e f83f 	bl	80100c0 <printf>
    (VOID)LedTaskCreate();
 8002042:	f7ff ff93 	bl	8001f6c <LedTaskCreate>
    DemoEntry();
 8002046:	f00d f831 	bl	800f0ac <DemoEntry>
}
 800204a:	bf00      	nop
 800204c:	bd80      	pop	{r7, pc}
 800204e:	bf00      	nop
 8002050:	08020024 	.word	0x08020024

08002054 <LedTaskTrigger>:

void LedTaskTrigger(void)
{
 8002054:	b580      	push	{r7, lr}
 8002056:	af00      	add	r7, sp, #0
    LOS_EventWrite(&g_pevent, EVENT_WAIT);
 8002058:	2101      	movs	r1, #1
 800205a:	4802      	ldr	r0, [pc, #8]	; (8002064 <LedTaskTrigger+0x10>)
 800205c:	f002 ffe8 	bl	8005030 <LOS_EventWrite>
}
 8002060:	bf00      	nop
 8002062:	bd80      	pop	{r7, pc}
 8002064:	2000074c 	.word	0x2000074c

08002068 <SecMemsetError>:

/*
 * Handling errors
 */
SECUREC_INLINE errno_t SecMemsetError(void *dest, size_t destMax, int c)
{
 8002068:	b580      	push	{r7, lr}
 800206a:	b084      	sub	sp, #16
 800206c:	af00      	add	r7, sp, #0
 800206e:	60f8      	str	r0, [r7, #12]
 8002070:	60b9      	str	r1, [r7, #8]
 8002072:	607a      	str	r2, [r7, #4]
    /* Check destMax is 0 compatible with _sp macro */
    if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN) {
 8002074:	68bb      	ldr	r3, [r7, #8]
 8002076:	2b00      	cmp	r3, #0
 8002078:	d002      	beq.n	8002080 <SecMemsetError+0x18>
 800207a:	68bb      	ldr	r3, [r7, #8]
 800207c:	2b00      	cmp	r3, #0
 800207e:	da01      	bge.n	8002084 <SecMemsetError+0x1c>
        SECUREC_ERROR_INVALID_RANGE("memset_s");
        return ERANGE;
 8002080:	2322      	movs	r3, #34	; 0x22
 8002082:	e00b      	b.n	800209c <SecMemsetError+0x34>
    }
    if (dest == NULL) {
 8002084:	68fb      	ldr	r3, [r7, #12]
 8002086:	2b00      	cmp	r3, #0
 8002088:	d101      	bne.n	800208e <SecMemsetError+0x26>
        SECUREC_ERROR_INVALID_PARAMTER("memset_s");
        return EINVAL;
 800208a:	2316      	movs	r3, #22
 800208c:	e006      	b.n	800209c <SecMemsetError+0x34>
    }
    SECUREC_MEMSET_PREVENT_DSE(dest, c, destMax); /* Set entire buffer to value c */
 800208e:	68ba      	ldr	r2, [r7, #8]
 8002090:	6879      	ldr	r1, [r7, #4]
 8002092:	68f8      	ldr	r0, [r7, #12]
 8002094:	f00d f938 	bl	800f308 <memset>
 8002098:	68fb      	ldr	r3, [r7, #12]
    SECUREC_ERROR_INVALID_RANGE("memset_s");
    return ERANGE_AND_RESET;
 800209a:	23a2      	movs	r3, #162	; 0xa2
}
 800209c:	4618      	mov	r0, r3
 800209e:	3710      	adds	r7, #16
 80020a0:	46bd      	mov	sp, r7
 80020a2:	bd80      	pop	{r7, pc}

080020a4 <memset_s>:
 *    ERANGE_AND_RESET    count > destMax and destMax != 0 and destMax <= SECUREC_MEM_MAX_LEN and dest != NULL
 *
 *    if return ERANGE_AND_RESET then fill dest to c ,fill length is destMax
 */
errno_t memset_s(void *dest, size_t destMax, int c, size_t count)
{
 80020a4:	b580      	push	{r7, lr}
 80020a6:	b084      	sub	sp, #16
 80020a8:	af00      	add	r7, sp, #0
 80020aa:	60f8      	str	r0, [r7, #12]
 80020ac:	60b9      	str	r1, [r7, #8]
 80020ae:	607a      	str	r2, [r7, #4]
 80020b0:	603b      	str	r3, [r7, #0]
    if (SECUREC_MEMSET_PARAM_OK(dest, destMax, count)) {
 80020b2:	68bb      	ldr	r3, [r7, #8]
 80020b4:	43db      	mvns	r3, r3
 80020b6:	0fdb      	lsrs	r3, r3, #31
 80020b8:	b2db      	uxtb	r3, r3
 80020ba:	2b00      	cmp	r3, #0
 80020bc:	d009      	beq.n	80020d2 <memset_s+0x2e>
 80020be:	68fb      	ldr	r3, [r7, #12]
 80020c0:	2b00      	cmp	r3, #0
 80020c2:	bf14      	ite	ne
 80020c4:	2301      	movne	r3, #1
 80020c6:	2300      	moveq	r3, #0
 80020c8:	b2db      	uxtb	r3, r3
 80020ca:	2b00      	cmp	r3, #0
 80020cc:	d001      	beq.n	80020d2 <memset_s+0x2e>
 80020ce:	2301      	movs	r3, #1
 80020d0:	e000      	b.n	80020d4 <memset_s+0x30>
 80020d2:	2300      	movs	r3, #0
 80020d4:	2b00      	cmp	r3, #0
 80020d6:	d010      	beq.n	80020fa <memset_s+0x56>
 80020d8:	683a      	ldr	r2, [r7, #0]
 80020da:	68bb      	ldr	r3, [r7, #8]
 80020dc:	429a      	cmp	r2, r3
 80020de:	bf94      	ite	ls
 80020e0:	2301      	movls	r3, #1
 80020e2:	2300      	movhi	r3, #0
 80020e4:	b2db      	uxtb	r3, r3
 80020e6:	2b00      	cmp	r3, #0
 80020e8:	d007      	beq.n	80020fa <memset_s+0x56>
        SECUREC_MEMSET_PREVENT_DSE(dest, c, count);
 80020ea:	683a      	ldr	r2, [r7, #0]
 80020ec:	6879      	ldr	r1, [r7, #4]
 80020ee:	68f8      	ldr	r0, [r7, #12]
 80020f0:	f00d f90a 	bl	800f308 <memset>
 80020f4:	68fb      	ldr	r3, [r7, #12]
        return EOK;
 80020f6:	2300      	movs	r3, #0
 80020f8:	e005      	b.n	8002106 <memset_s+0x62>
    }
    /* Meet some runtime violation, return error code */
    return SecMemsetError(dest, destMax, c);
 80020fa:	687a      	ldr	r2, [r7, #4]
 80020fc:	68b9      	ldr	r1, [r7, #8]
 80020fe:	68f8      	ldr	r0, [r7, #12]
 8002100:	f7ff ffb2 	bl	8002068 <SecMemsetError>
 8002104:	4603      	mov	r3, r0
}
 8002106:	4618      	mov	r0, r3
 8002108:	3710      	adds	r7, #16
 800210a:	46bd      	mov	sp, r7
 800210c:	bd80      	pop	{r7, pc}

0800210e <ArchCurrCpuid>:

    return regMsp;
}

STATIC INLINE UINT32 ArchCurrCpuid(void)
{
 800210e:	b480      	push	{r7}
 8002110:	af00      	add	r7, sp, #0
    return 0;
 8002112:	2300      	movs	r3, #0
}
 8002114:	4618      	mov	r0, r3
 8002116:	46bd      	mov	sp, r7
 8002118:	f85d 7b04 	ldr.w	r7, [sp], #4
 800211c:	4770      	bx	lr

0800211e <LOS_IntLock>:
 * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_IntRestore
 * @since Huawei LiteOS V100R001C00
 */
STATIC INLINE UINT32 LOS_IntLock(VOID)
{
 800211e:	b580      	push	{r7, lr}
 8002120:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8002122:	f7fe fdd1 	bl	8000cc8 <ArchIntLock>
 8002126:	4603      	mov	r3, r0
}
 8002128:	4618      	mov	r0, r3
 800212a:	bd80      	pop	{r7, pc}

0800212c <LOS_IntRestore>:
 * <ul><li>los_hwi.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_IntLock
 * @since Huawei LiteOS V100R001C00
 */
STATIC INLINE VOID LOS_IntRestore(UINT32 intSave)
{
 800212c:	b580      	push	{r7, lr}
 800212e:	b082      	sub	sp, #8
 8002130:	af00      	add	r7, sp, #0
 8002132:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8002134:	6878      	ldr	r0, [r7, #4]
 8002136:	f7fe fdcf 	bl	8000cd8 <ArchIntRestore>
}
 800213a:	bf00      	nop
 800213c:	3708      	adds	r7, #8
 800213e:	46bd      	mov	sp, r7
 8002140:	bd80      	pop	{r7, pc}

08002142 <LOS_SpinLockSave>:
{
    (VOID)lock;
}

LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_SpinLockSave(SPIN_LOCK_S *lock, UINT32 *intSave)
{
 8002142:	b580      	push	{r7, lr}
 8002144:	b082      	sub	sp, #8
 8002146:	af00      	add	r7, sp, #0
 8002148:	6078      	str	r0, [r7, #4]
 800214a:	6039      	str	r1, [r7, #0]
    (VOID)lock;
    *intSave = LOS_IntLock();
 800214c:	f7ff ffe7 	bl	800211e <LOS_IntLock>
 8002150:	4602      	mov	r2, r0
 8002152:	683b      	ldr	r3, [r7, #0]
 8002154:	601a      	str	r2, [r3, #0]
}
 8002156:	bf00      	nop
 8002158:	3708      	adds	r7, #8
 800215a:	46bd      	mov	sp, r7
 800215c:	bd80      	pop	{r7, pc}

0800215e <LOS_SpinUnlockRestore>:

LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_SpinUnlockRestore(SPIN_LOCK_S *lock, UINT32 intSave)
{
 800215e:	b580      	push	{r7, lr}
 8002160:	b082      	sub	sp, #8
 8002162:	af00      	add	r7, sp, #0
 8002164:	6078      	str	r0, [r7, #4]
 8002166:	6039      	str	r1, [r7, #0]
    (VOID)lock;
    LOS_IntRestore(intSave);
 8002168:	6838      	ldr	r0, [r7, #0]
 800216a:	f7ff ffdf 	bl	800212c <LOS_IntRestore>
}
 800216e:	bf00      	nop
 8002170:	3708      	adds	r7, #8
 8002172:	46bd      	mov	sp, r7
 8002174:	bd80      	pop	{r7, pc}

08002176 <OsIrqNestingActive>:

typedef VOID (*HWI_PROC_FUNC0)(VOID);
typedef VOID (*HWI_PROC_FUNC2)(INT32, VOID *);

STATIC INLINE VOID OsIrqNestingActive(UINT32 hwiNum)
{
 8002176:	b480      	push	{r7}
 8002178:	b083      	sub	sp, #12
 800217a:	af00      	add	r7, sp, #0
 800217c:	6078      	str	r0, [r7, #4]
    /* preemption not allowed when handling tick interrupt */
    if (hwiNum != OS_TICK_INT_NUM) {
        (VOID)LOS_IntUnLock();
    }
#endif
}
 800217e:	bf00      	nop
 8002180:	370c      	adds	r7, #12
 8002182:	46bd      	mov	sp, r7
 8002184:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002188:	4770      	bx	lr

0800218a <OsIrqNestingInactive>:

STATIC INLINE VOID OsIrqNestingInactive(UINT32 hwiNum)
{
 800218a:	b480      	push	{r7}
 800218c:	b083      	sub	sp, #12
 800218e:	af00      	add	r7, sp, #0
 8002190:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_ARCH_INTERRUPT_PREEMPTION
    if (hwiNum != OS_TICK_INT_NUM) {
        (VOID)LOS_IntLock();
    }
#endif
}
 8002192:	bf00      	nop
 8002194:	370c      	adds	r7, #12
 8002196:	46bd      	mov	sp, r7
 8002198:	f85d 7b04 	ldr.w	r7, [sp], #4
 800219c:	4770      	bx	lr

0800219e <InterruptHandle>:
{
    g_intCount[ArchCurrCpuid()] = val;
}

STATIC INLINE VOID InterruptHandle(HwiHandleInfo *hwiForm)
{
 800219e:	b580      	push	{r7, lr}
 80021a0:	b086      	sub	sp, #24
 80021a2:	af00      	add	r7, sp, #0
 80021a4:	6078      	str	r0, [r7, #4]
    hwiForm->respCount++;
 80021a6:	687b      	ldr	r3, [r7, #4]
 80021a8:	68db      	ldr	r3, [r3, #12]
 80021aa:	1c5a      	adds	r2, r3, #1
 80021ac:	687b      	ldr	r3, [r7, #4]
 80021ae:	60da      	str	r2, [r3, #12]
#ifdef LOSCFG_SHARED_IRQ
    while (hwiForm->next != NULL) {
 80021b0:	e022      	b.n	80021f8 <InterruptHandle+0x5a>
        hwiForm = hwiForm->next;
 80021b2:	687b      	ldr	r3, [r7, #4]
 80021b4:	689b      	ldr	r3, [r3, #8]
 80021b6:	607b      	str	r3, [r7, #4]
#endif
        if (hwiForm->registerInfo) {
 80021b8:	687b      	ldr	r3, [r7, #4]
 80021ba:	685b      	ldr	r3, [r3, #4]
 80021bc:	2b00      	cmp	r3, #0
 80021be:	d013      	beq.n	80021e8 <InterruptHandle+0x4a>
            HWI_PROC_FUNC2 func = (HWI_PROC_FUNC2)hwiForm->hook;
 80021c0:	687b      	ldr	r3, [r7, #4]
 80021c2:	681b      	ldr	r3, [r3, #0]
 80021c4:	613b      	str	r3, [r7, #16]
            if (func != NULL) {
 80021c6:	693b      	ldr	r3, [r7, #16]
 80021c8:	2b00      	cmp	r3, #0
 80021ca:	d015      	beq.n	80021f8 <InterruptHandle+0x5a>
                UINTPTR *param = (UINTPTR *)(hwiForm->registerInfo);
 80021cc:	687b      	ldr	r3, [r7, #4]
 80021ce:	685b      	ldr	r3, [r3, #4]
 80021d0:	617b      	str	r3, [r7, #20]
                func((INT32)(*param), (VOID *)(*(param + 1)));
 80021d2:	697b      	ldr	r3, [r7, #20]
 80021d4:	681b      	ldr	r3, [r3, #0]
 80021d6:	461a      	mov	r2, r3
 80021d8:	697b      	ldr	r3, [r7, #20]
 80021da:	3304      	adds	r3, #4
 80021dc:	681b      	ldr	r3, [r3, #0]
 80021de:	4619      	mov	r1, r3
 80021e0:	693b      	ldr	r3, [r7, #16]
 80021e2:	4610      	mov	r0, r2
 80021e4:	4798      	blx	r3
 80021e6:	e007      	b.n	80021f8 <InterruptHandle+0x5a>
            }
        } else {
            HWI_PROC_FUNC0 func = (HWI_PROC_FUNC0)hwiForm->hook;
 80021e8:	687b      	ldr	r3, [r7, #4]
 80021ea:	681b      	ldr	r3, [r3, #0]
 80021ec:	60fb      	str	r3, [r7, #12]
            if (func != NULL) {
 80021ee:	68fb      	ldr	r3, [r7, #12]
 80021f0:	2b00      	cmp	r3, #0
 80021f2:	d001      	beq.n	80021f8 <InterruptHandle+0x5a>
                func();
 80021f4:	68fb      	ldr	r3, [r7, #12]
 80021f6:	4798      	blx	r3
    while (hwiForm->next != NULL) {
 80021f8:	687b      	ldr	r3, [r7, #4]
 80021fa:	689b      	ldr	r3, [r3, #8]
 80021fc:	2b00      	cmp	r3, #0
 80021fe:	d1d8      	bne.n	80021b2 <InterruptHandle+0x14>
            }
        }
#ifdef LOSCFG_SHARED_IRQ
    }
#endif
}
 8002200:	bf00      	nop
 8002202:	bf00      	nop
 8002204:	3718      	adds	r7, #24
 8002206:	46bd      	mov	sp, r7
 8002208:	bd80      	pop	{r7, pc}
	...

0800220c <OsIntHandle>:

VOID OsIntHandle(UINT32 hwiNum, HwiHandleInfo *hwiForm)
{
 800220c:	b590      	push	{r4, r7, lr}
 800220e:	b089      	sub	sp, #36	; 0x24
 8002210:	af00      	add	r7, sp, #0
 8002212:	6078      	str	r0, [r7, #4]
 8002214:	6039      	str	r1, [r7, #0]
 8002216:	4b3d      	ldr	r3, [pc, #244]	; (800230c <OsIntHandle+0x100>)
 8002218:	681b      	ldr	r3, [r3, #0]
 800221a:	61fb      	str	r3, [r7, #28]
 800221c:	f04f 0300 	mov.w	r3, #0
    size_t *intCnt = NULL;
 8002220:	2300      	movs	r3, #0
 8002222:	60bb      	str	r3, [r7, #8]

#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    OsCpupIrqStart();
 8002224:	f012 ff52 	bl	80150cc <OsCpupIrqStart>
#endif
    intCnt = &g_intCount[ArchCurrCpuid()];
 8002228:	f7ff ff71 	bl	800210e <ArchCurrCpuid>
 800222c:	4603      	mov	r3, r0
 800222e:	009b      	lsls	r3, r3, #2
 8002230:	4a37      	ldr	r2, [pc, #220]	; (8002310 <OsIntHandle+0x104>)
 8002232:	4413      	add	r3, r2
 8002234:	60bb      	str	r3, [r7, #8]
    *intCnt = *intCnt + 1;
 8002236:	68bb      	ldr	r3, [r7, #8]
 8002238:	681b      	ldr	r3, [r3, #0]
 800223a:	1c5a      	adds	r2, r3, #1
 800223c:	68bb      	ldr	r3, [r7, #8]
 800223e:	601a      	str	r2, [r3, #0]

#ifdef LOSCFG_DEBUG_SCHED_STATISTICS
    OsHwiStatistics(hwiNum);
 8002240:	6878      	ldr	r0, [r7, #4]
 8002242:	f005 fb2f 	bl	80078a4 <OsHwiStatistics>
#endif

#ifdef LOSCFG_KERNEL_LOWPOWER
    if (g_intWakeupHook != NULL) {
 8002246:	4b33      	ldr	r3, [pc, #204]	; (8002314 <OsIntHandle+0x108>)
 8002248:	681b      	ldr	r3, [r3, #0]
 800224a:	2b00      	cmp	r3, #0
 800224c:	d003      	beq.n	8002256 <OsIntHandle+0x4a>
        g_intWakeupHook(hwiNum);
 800224e:	4b31      	ldr	r3, [pc, #196]	; (8002314 <OsIntHandle+0x108>)
 8002250:	681b      	ldr	r3, [r3, #0]
 8002252:	6878      	ldr	r0, [r7, #4]
 8002254:	4798      	blx	r3
    }
#endif
    LOS_TRACE(HWI_RESPONSE_IN, hwiNum);
 8002256:	2300      	movs	r3, #0
 8002258:	617b      	str	r3, [r7, #20]
 800225a:	687b      	ldr	r3, [r7, #4]
 800225c:	61bb      	str	r3, [r7, #24]
 800225e:	2302      	movs	r3, #2
 8002260:	60fb      	str	r3, [r7, #12]
 8002262:	68fb      	ldr	r3, [r7, #12]
 8002264:	2b01      	cmp	r3, #1
 8002266:	d915      	bls.n	8002294 <OsIntHandle+0x88>
 8002268:	4b2b      	ldr	r3, [pc, #172]	; (8002318 <OsIntHandle+0x10c>)
 800226a:	681b      	ldr	r3, [r3, #0]
 800226c:	2b00      	cmp	r3, #0
 800226e:	d011      	beq.n	8002294 <OsIntHandle+0x88>
 8002270:	4b29      	ldr	r3, [pc, #164]	; (8002318 <OsIntHandle+0x10c>)
 8002272:	681c      	ldr	r4, [r3, #0]
 8002274:	69b9      	ldr	r1, [r7, #24]
 8002276:	68fb      	ldr	r3, [r7, #12]
 8002278:	2b02      	cmp	r3, #2
 800227a:	d904      	bls.n	8002286 <OsIntHandle+0x7a>
 800227c:	f107 0314 	add.w	r3, r7, #20
 8002280:	f103 0208 	add.w	r2, r3, #8
 8002284:	e000      	b.n	8002288 <OsIntHandle+0x7c>
 8002286:	2200      	movs	r2, #0
 8002288:	68fb      	ldr	r3, [r7, #12]
 800228a:	b29b      	uxth	r3, r3
 800228c:	3b02      	subs	r3, #2
 800228e:	b29b      	uxth	r3, r3
 8002290:	2024      	movs	r0, #36	; 0x24
 8002292:	47a0      	blx	r4

    OsIrqNestingActive(hwiNum);
 8002294:	6878      	ldr	r0, [r7, #4]
 8002296:	f7ff ff6e 	bl	8002176 <OsIrqNestingActive>
    InterruptHandle(hwiForm);
 800229a:	6838      	ldr	r0, [r7, #0]
 800229c:	f7ff ff7f 	bl	800219e <InterruptHandle>
    OsIrqNestingInactive(hwiNum);
 80022a0:	6878      	ldr	r0, [r7, #4]
 80022a2:	f7ff ff72 	bl	800218a <OsIrqNestingInactive>

    LOS_TRACE(HWI_RESPONSE_OUT, hwiNum);
 80022a6:	2300      	movs	r3, #0
 80022a8:	617b      	str	r3, [r7, #20]
 80022aa:	687b      	ldr	r3, [r7, #4]
 80022ac:	61bb      	str	r3, [r7, #24]
 80022ae:	2302      	movs	r3, #2
 80022b0:	613b      	str	r3, [r7, #16]
 80022b2:	693b      	ldr	r3, [r7, #16]
 80022b4:	2b01      	cmp	r3, #1
 80022b6:	d915      	bls.n	80022e4 <OsIntHandle+0xd8>
 80022b8:	4b17      	ldr	r3, [pc, #92]	; (8002318 <OsIntHandle+0x10c>)
 80022ba:	681b      	ldr	r3, [r3, #0]
 80022bc:	2b00      	cmp	r3, #0
 80022be:	d011      	beq.n	80022e4 <OsIntHandle+0xd8>
 80022c0:	4b15      	ldr	r3, [pc, #84]	; (8002318 <OsIntHandle+0x10c>)
 80022c2:	681c      	ldr	r4, [r3, #0]
 80022c4:	69b9      	ldr	r1, [r7, #24]
 80022c6:	693b      	ldr	r3, [r7, #16]
 80022c8:	2b02      	cmp	r3, #2
 80022ca:	d904      	bls.n	80022d6 <OsIntHandle+0xca>
 80022cc:	f107 0314 	add.w	r3, r7, #20
 80022d0:	f103 0208 	add.w	r2, r3, #8
 80022d4:	e000      	b.n	80022d8 <OsIntHandle+0xcc>
 80022d6:	2200      	movs	r2, #0
 80022d8:	693b      	ldr	r3, [r7, #16]
 80022da:	b29b      	uxth	r3, r3
 80022dc:	3b02      	subs	r3, #2
 80022de:	b29b      	uxth	r3, r3
 80022e0:	2025      	movs	r0, #37	; 0x25
 80022e2:	47a0      	blx	r4

    *intCnt = *intCnt - 1;
 80022e4:	68bb      	ldr	r3, [r7, #8]
 80022e6:	681b      	ldr	r3, [r3, #0]
 80022e8:	1e5a      	subs	r2, r3, #1
 80022ea:	68bb      	ldr	r3, [r7, #8]
 80022ec:	601a      	str	r2, [r3, #0]

#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    OsCpupIrqEnd(hwiNum);
 80022ee:	6878      	ldr	r0, [r7, #4]
 80022f0:	f012 fefe 	bl	80150f0 <OsCpupIrqEnd>
#endif
}
 80022f4:	bf00      	nop
 80022f6:	4b05      	ldr	r3, [pc, #20]	; (800230c <OsIntHandle+0x100>)
 80022f8:	681a      	ldr	r2, [r3, #0]
 80022fa:	69fb      	ldr	r3, [r7, #28]
 80022fc:	405a      	eors	r2, r3
 80022fe:	d001      	beq.n	8002304 <OsIntHandle+0xf8>
 8002300:	f002 f96c 	bl	80045dc <__stack_chk_fail>
 8002304:	3724      	adds	r7, #36	; 0x24
 8002306:	46bd      	mov	sp, r7
 8002308:	bd90      	pop	{r4, r7, pc}
 800230a:	bf00      	nop
 800230c:	08020030 	.word	0x08020030
 8002310:	2000075c 	.word	0x2000075c
 8002314:	20000760 	.word	0x20000760
 8002318:	20000768 	.word	0x20000768

0800231c <OsHwiCpIrqParam>:
    }
    return;
}

STATIC HWI_ARG_T OsHwiCpIrqParam(const HWI_IRQ_PARAM_S *irqParam)
{
 800231c:	b580      	push	{r7, lr}
 800231e:	b084      	sub	sp, #16
 8002320:	af00      	add	r7, sp, #0
 8002322:	6078      	str	r0, [r7, #4]
    HWI_IRQ_PARAM_S *paramByAlloc = NULL;
 8002324:	2300      	movs	r3, #0
 8002326:	60fb      	str	r3, [r7, #12]

    paramByAlloc = (HWI_IRQ_PARAM_S *)LOS_MemAlloc(m_aucSysMem0, sizeof(HWI_IRQ_PARAM_S));
 8002328:	4b0a      	ldr	r3, [pc, #40]	; (8002354 <OsHwiCpIrqParam+0x38>)
 800232a:	681b      	ldr	r3, [r3, #0]
 800232c:	210c      	movs	r1, #12
 800232e:	4618      	mov	r0, r3
 8002330:	f007 f870 	bl	8009414 <LOS_MemAlloc>
 8002334:	60f8      	str	r0, [r7, #12]
    if (paramByAlloc != NULL) {
 8002336:	68fb      	ldr	r3, [r7, #12]
 8002338:	2b00      	cmp	r3, #0
 800233a:	d005      	beq.n	8002348 <OsHwiCpIrqParam+0x2c>
        (VOID)memcpy_s(paramByAlloc, sizeof(HWI_IRQ_PARAM_S), irqParam, sizeof(HWI_IRQ_PARAM_S));
 800233c:	230c      	movs	r3, #12
 800233e:	687a      	ldr	r2, [r7, #4]
 8002340:	210c      	movs	r1, #12
 8002342:	68f8      	ldr	r0, [r7, #12]
 8002344:	f014 fea8 	bl	8017098 <memcpy_s>
    }

    return (HWI_ARG_T)paramByAlloc;
 8002348:	68fb      	ldr	r3, [r7, #12]
}
 800234a:	4618      	mov	r0, r3
 800234c:	3710      	adds	r7, #16
 800234e:	46bd      	mov	sp, r7
 8002350:	bd80      	pop	{r7, pc}
 8002352:	bf00      	nop
 8002354:	200021bc 	.word	0x200021bc

08002358 <OsFreeHwiNode>:
    HWI_UNLOCK(intSave);
    return LOS_OK;
}
#else /* LOSCFG_SHARED_IRQ */
STATIC INLINE UINT32 OsFreeHwiNode(HwiHandleInfo *head, HwiHandleInfo *hwiForm, UINT32 irqId)
{
 8002358:	b580      	push	{r7, lr}
 800235a:	b086      	sub	sp, #24
 800235c:	af00      	add	r7, sp, #0
 800235e:	60f8      	str	r0, [r7, #12]
 8002360:	60b9      	str	r1, [r7, #8]
 8002362:	607a      	str	r2, [r7, #4]
    UINT32 ret = LOS_OK;
 8002364:	2300      	movs	r3, #0
 8002366:	617b      	str	r3, [r7, #20]

    if (hwiForm->registerInfo != (HWI_ARG_T)NULL) {
 8002368:	68bb      	ldr	r3, [r7, #8]
 800236a:	685b      	ldr	r3, [r3, #4]
 800236c:	2b00      	cmp	r3, #0
 800236e:	d007      	beq.n	8002380 <OsFreeHwiNode+0x28>
        (VOID)LOS_MemFree(m_aucSysMem0, (VOID *)hwiForm->registerInfo);
 8002370:	4b15      	ldr	r3, [pc, #84]	; (80023c8 <OsFreeHwiNode+0x70>)
 8002372:	681a      	ldr	r2, [r3, #0]
 8002374:	68bb      	ldr	r3, [r7, #8]
 8002376:	685b      	ldr	r3, [r3, #4]
 8002378:	4619      	mov	r1, r3
 800237a:	4610      	mov	r0, r2
 800237c:	f007 f902 	bl	8009584 <LOS_MemFree>
    }

    (VOID)LOS_MemFree(m_aucSysMem0, hwiForm);
 8002380:	4b11      	ldr	r3, [pc, #68]	; (80023c8 <OsFreeHwiNode+0x70>)
 8002382:	681b      	ldr	r3, [r3, #0]
 8002384:	68b9      	ldr	r1, [r7, #8]
 8002386:	4618      	mov	r0, r3
 8002388:	f007 f8fc 	bl	8009584 <LOS_MemFree>

    if (head->next == NULL) {
 800238c:	68fb      	ldr	r3, [r7, #12]
 800238e:	689b      	ldr	r3, [r3, #8]
 8002390:	2b00      	cmp	r3, #0
 8002392:	d113      	bne.n	80023bc <OsFreeHwiNode+0x64>
        head->shareMode = 0;
 8002394:	68fb      	ldr	r3, [r7, #12]
 8002396:	2200      	movs	r2, #0
 8002398:	605a      	str	r2, [r3, #4]
        head->respCount = 0;
 800239a:	68fb      	ldr	r3, [r7, #12]
 800239c:	2200      	movs	r2, #0
 800239e:	60da      	str	r2, [r3, #12]
        if (g_hwiOps->disableIrq == NULL) {
 80023a0:	4b0a      	ldr	r3, [pc, #40]	; (80023cc <OsFreeHwiNode+0x74>)
 80023a2:	681b      	ldr	r3, [r3, #0]
 80023a4:	68db      	ldr	r3, [r3, #12]
 80023a6:	2b00      	cmp	r3, #0
 80023a8:	d103      	bne.n	80023b2 <OsFreeHwiNode+0x5a>
            ret = LOS_ERRNO_HWI_PROC_FUNC_NULL;
 80023aa:	4b09      	ldr	r3, [pc, #36]	; (80023d0 <OsFreeHwiNode+0x78>)
 80023ac:	617b      	str	r3, [r7, #20]
            return ret;
 80023ae:	697b      	ldr	r3, [r7, #20]
 80023b0:	e005      	b.n	80023be <OsFreeHwiNode+0x66>
        }
        g_hwiOps->disableIrq(irqId);
 80023b2:	4b06      	ldr	r3, [pc, #24]	; (80023cc <OsFreeHwiNode+0x74>)
 80023b4:	681b      	ldr	r3, [r3, #0]
 80023b6:	68db      	ldr	r3, [r3, #12]
 80023b8:	6878      	ldr	r0, [r7, #4]
 80023ba:	4798      	blx	r3
    }

    return ret;
 80023bc:	697b      	ldr	r3, [r7, #20]
}
 80023be:	4618      	mov	r0, r3
 80023c0:	3718      	adds	r7, #24
 80023c2:	46bd      	mov	sp, r7
 80023c4:	bd80      	pop	{r7, pc}
 80023c6:	bf00      	nop
 80023c8:	200021bc 	.word	0x200021bc
 80023cc:	20000764 	.word	0x20000764
 80023d0:	02000901 	.word	0x02000901

080023d4 <OsHwiDel>:

STATIC UINT32 OsHwiDel(HwiHandleInfo *head, const HWI_IRQ_PARAM_S *irqParam, UINT32 irqId)
{
 80023d4:	b580      	push	{r7, lr}
 80023d6:	b08a      	sub	sp, #40	; 0x28
 80023d8:	af00      	add	r7, sp, #0
 80023da:	60f8      	str	r0, [r7, #12]
 80023dc:	60b9      	str	r1, [r7, #8]
 80023de:	607a      	str	r2, [r7, #4]
 80023e0:	4b41      	ldr	r3, [pc, #260]	; (80024e8 <OsHwiDel+0x114>)
 80023e2:	681b      	ldr	r3, [r3, #0]
 80023e4:	627b      	str	r3, [r7, #36]	; 0x24
 80023e6:	f04f 0300 	mov.w	r3, #0
    HwiHandleInfo *hwiFormPrev = NULL;
 80023ea:	2300      	movs	r3, #0
 80023ec:	61bb      	str	r3, [r7, #24]
    HwiHandleInfo *hwiForm = NULL;
 80023ee:	2300      	movs	r3, #0
 80023f0:	61fb      	str	r3, [r7, #28]
    UINT32 intSave;
    UINT32 ret;

    HWI_LOCK(intSave);
 80023f2:	f107 0314 	add.w	r3, r7, #20
 80023f6:	4619      	mov	r1, r3
 80023f8:	483c      	ldr	r0, [pc, #240]	; (80024ec <OsHwiDel+0x118>)
 80023fa:	f7ff fea2 	bl	8002142 <LOS_SpinLockSave>

    if ((head->shareMode & IRQF_SHARED) && ((irqParam == NULL) || (irqParam->pDevId == NULL))) {
 80023fe:	68fb      	ldr	r3, [r7, #12]
 8002400:	685b      	ldr	r3, [r3, #4]
 8002402:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002406:	2b00      	cmp	r3, #0
 8002408:	d00d      	beq.n	8002426 <OsHwiDel+0x52>
 800240a:	68bb      	ldr	r3, [r7, #8]
 800240c:	2b00      	cmp	r3, #0
 800240e:	d003      	beq.n	8002418 <OsHwiDel+0x44>
 8002410:	68bb      	ldr	r3, [r7, #8]
 8002412:	685b      	ldr	r3, [r3, #4]
 8002414:	2b00      	cmp	r3, #0
 8002416:	d106      	bne.n	8002426 <OsHwiDel+0x52>
        HWI_UNLOCK(intSave);
 8002418:	697b      	ldr	r3, [r7, #20]
 800241a:	4619      	mov	r1, r3
 800241c:	4833      	ldr	r0, [pc, #204]	; (80024ec <OsHwiDel+0x118>)
 800241e:	f7ff fe9e 	bl	800215e <LOS_SpinUnlockRestore>
        return LOS_ERRNO_HWI_SHARED_ERROR;
 8002422:	4b33      	ldr	r3, [pc, #204]	; (80024f0 <OsHwiDel+0x11c>)
 8002424:	e054      	b.n	80024d0 <OsHwiDel+0xfc>
    }

    /* Non-shared interrupt. */
    if (!(head->shareMode & IRQF_SHARED)) {
 8002426:	68fb      	ldr	r3, [r7, #12]
 8002428:	685b      	ldr	r3, [r3, #4]
 800242a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800242e:	2b00      	cmp	r3, #0
 8002430:	d11d      	bne.n	800246e <OsHwiDel+0x9a>
        if (head->next == NULL) {
 8002432:	68fb      	ldr	r3, [r7, #12]
 8002434:	689b      	ldr	r3, [r3, #8]
 8002436:	2b00      	cmp	r3, #0
 8002438:	d106      	bne.n	8002448 <OsHwiDel+0x74>
            HWI_UNLOCK(intSave);
 800243a:	697b      	ldr	r3, [r7, #20]
 800243c:	4619      	mov	r1, r3
 800243e:	482b      	ldr	r0, [pc, #172]	; (80024ec <OsHwiDel+0x118>)
 8002440:	f7ff fe8d 	bl	800215e <LOS_SpinUnlockRestore>
            return LOS_ERRNO_HWI_HWINUM_UNCREATE;
 8002444:	4b2b      	ldr	r3, [pc, #172]	; (80024f4 <OsHwiDel+0x120>)
 8002446:	e043      	b.n	80024d0 <OsHwiDel+0xfc>
        }

        hwiForm = head->next;
 8002448:	68fb      	ldr	r3, [r7, #12]
 800244a:	689b      	ldr	r3, [r3, #8]
 800244c:	61fb      	str	r3, [r7, #28]
        head->next = NULL;
 800244e:	68fb      	ldr	r3, [r7, #12]
 8002450:	2200      	movs	r2, #0
 8002452:	609a      	str	r2, [r3, #8]
        ret = OsFreeHwiNode(head, hwiForm, irqId);
 8002454:	687a      	ldr	r2, [r7, #4]
 8002456:	69f9      	ldr	r1, [r7, #28]
 8002458:	68f8      	ldr	r0, [r7, #12]
 800245a:	f7ff ff7d 	bl	8002358 <OsFreeHwiNode>
 800245e:	6238      	str	r0, [r7, #32]
        HWI_UNLOCK(intSave);
 8002460:	697b      	ldr	r3, [r7, #20]
 8002462:	4619      	mov	r1, r3
 8002464:	4821      	ldr	r0, [pc, #132]	; (80024ec <OsHwiDel+0x118>)
 8002466:	f7ff fe7a 	bl	800215e <LOS_SpinUnlockRestore>
        return ret;
 800246a:	6a3b      	ldr	r3, [r7, #32]
 800246c:	e030      	b.n	80024d0 <OsHwiDel+0xfc>
    }

    /* Shared interrupt. */
    hwiFormPrev = head;
 800246e:	68fb      	ldr	r3, [r7, #12]
 8002470:	61bb      	str	r3, [r7, #24]
    hwiForm = head->next;
 8002472:	68fb      	ldr	r3, [r7, #12]
 8002474:	689b      	ldr	r3, [r3, #8]
 8002476:	61fb      	str	r3, [r7, #28]
    while (hwiForm != NULL) {
 8002478:	e00b      	b.n	8002492 <OsHwiDel+0xbe>
        if (((HWI_IRQ_PARAM_S *)(hwiForm->registerInfo))->pDevId == irqParam->pDevId) {
 800247a:	69fb      	ldr	r3, [r7, #28]
 800247c:	685b      	ldr	r3, [r3, #4]
 800247e:	685a      	ldr	r2, [r3, #4]
 8002480:	68bb      	ldr	r3, [r7, #8]
 8002482:	685b      	ldr	r3, [r3, #4]
 8002484:	429a      	cmp	r2, r3
 8002486:	d008      	beq.n	800249a <OsHwiDel+0xc6>
            break;
        }
        hwiFormPrev = hwiForm;
 8002488:	69fb      	ldr	r3, [r7, #28]
 800248a:	61bb      	str	r3, [r7, #24]
        hwiForm = hwiForm->next;
 800248c:	69fb      	ldr	r3, [r7, #28]
 800248e:	689b      	ldr	r3, [r3, #8]
 8002490:	61fb      	str	r3, [r7, #28]
    while (hwiForm != NULL) {
 8002492:	69fb      	ldr	r3, [r7, #28]
 8002494:	2b00      	cmp	r3, #0
 8002496:	d1f0      	bne.n	800247a <OsHwiDel+0xa6>
 8002498:	e000      	b.n	800249c <OsHwiDel+0xc8>
            break;
 800249a:	bf00      	nop
    }

    if (hwiForm == NULL) {
 800249c:	69fb      	ldr	r3, [r7, #28]
 800249e:	2b00      	cmp	r3, #0
 80024a0:	d106      	bne.n	80024b0 <OsHwiDel+0xdc>
        HWI_UNLOCK(intSave);
 80024a2:	697b      	ldr	r3, [r7, #20]
 80024a4:	4619      	mov	r1, r3
 80024a6:	4811      	ldr	r0, [pc, #68]	; (80024ec <OsHwiDel+0x118>)
 80024a8:	f7ff fe59 	bl	800215e <LOS_SpinUnlockRestore>
        return LOS_ERRNO_HWI_HWINUM_UNCREATE;
 80024ac:	4b11      	ldr	r3, [pc, #68]	; (80024f4 <OsHwiDel+0x120>)
 80024ae:	e00f      	b.n	80024d0 <OsHwiDel+0xfc>
    }

    hwiFormPrev->next = hwiForm->next;
 80024b0:	69fb      	ldr	r3, [r7, #28]
 80024b2:	689a      	ldr	r2, [r3, #8]
 80024b4:	69bb      	ldr	r3, [r7, #24]
 80024b6:	609a      	str	r2, [r3, #8]
    ret = OsFreeHwiNode(head, hwiForm, irqId);
 80024b8:	687a      	ldr	r2, [r7, #4]
 80024ba:	69f9      	ldr	r1, [r7, #28]
 80024bc:	68f8      	ldr	r0, [r7, #12]
 80024be:	f7ff ff4b 	bl	8002358 <OsFreeHwiNode>
 80024c2:	6238      	str	r0, [r7, #32]
    HWI_UNLOCK(intSave);
 80024c4:	697b      	ldr	r3, [r7, #20]
 80024c6:	4619      	mov	r1, r3
 80024c8:	4808      	ldr	r0, [pc, #32]	; (80024ec <OsHwiDel+0x118>)
 80024ca:	f7ff fe48 	bl	800215e <LOS_SpinUnlockRestore>
    return ret;
 80024ce:	6a3b      	ldr	r3, [r7, #32]
}
 80024d0:	4a05      	ldr	r2, [pc, #20]	; (80024e8 <OsHwiDel+0x114>)
 80024d2:	6811      	ldr	r1, [r2, #0]
 80024d4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80024d6:	4051      	eors	r1, r2
 80024d8:	d001      	beq.n	80024de <OsHwiDel+0x10a>
 80024da:	f002 f87f 	bl	80045dc <__stack_chk_fail>
 80024de:	4618      	mov	r0, r3
 80024e0:	3728      	adds	r7, #40	; 0x28
 80024e2:	46bd      	mov	sp, r7
 80024e4:	bd80      	pop	{r7, pc}
 80024e6:	bf00      	nop
 80024e8:	08020034 	.word	0x08020034
 80024ec:	20000758 	.word	0x20000758
 80024f0:	02000909 	.word	0x02000909
 80024f4:	0200090b 	.word	0x0200090b

080024f8 <OsHwiCreate>:

STATIC UINT32 OsHwiCreate(HwiHandleInfo *head, HWI_MODE_T hwiMode, HWI_PROC_FUNC hwiHandler,
                          const HWI_IRQ_PARAM_S *irqParam)
{
 80024f8:	b580      	push	{r7, lr}
 80024fa:	b08a      	sub	sp, #40	; 0x28
 80024fc:	af00      	add	r7, sp, #0
 80024fe:	60f8      	str	r0, [r7, #12]
 8002500:	607a      	str	r2, [r7, #4]
 8002502:	603b      	str	r3, [r7, #0]
 8002504:	460b      	mov	r3, r1
 8002506:	817b      	strh	r3, [r7, #10]
 8002508:	4b4f      	ldr	r3, [pc, #316]	; (8002648 <OsHwiCreate+0x150>)
 800250a:	681b      	ldr	r3, [r3, #0]
 800250c:	627b      	str	r3, [r7, #36]	; 0x24
 800250e:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    HwiHandleInfo *hwiFormNode = NULL;
 8002512:	2300      	movs	r3, #0
 8002514:	61fb      	str	r3, [r7, #28]
    HWI_IRQ_PARAM_S *hwiParam = NULL;
 8002516:	2300      	movs	r3, #0
 8002518:	623b      	str	r3, [r7, #32]
    HWI_MODE_T modeResult = hwiMode & IRQF_SHARED;
 800251a:	897b      	ldrh	r3, [r7, #10]
 800251c:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 8002520:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8002524:	827b      	strh	r3, [r7, #18]
    HwiHandleInfo *hwiForm = NULL;
 8002526:	2300      	movs	r3, #0
 8002528:	61bb      	str	r3, [r7, #24]

    if (modeResult && ((irqParam == NULL) || (irqParam->pDevId == NULL))) {
 800252a:	8a7b      	ldrh	r3, [r7, #18]
 800252c:	2b00      	cmp	r3, #0
 800252e:	d008      	beq.n	8002542 <OsHwiCreate+0x4a>
 8002530:	683b      	ldr	r3, [r7, #0]
 8002532:	2b00      	cmp	r3, #0
 8002534:	d003      	beq.n	800253e <OsHwiCreate+0x46>
 8002536:	683b      	ldr	r3, [r7, #0]
 8002538:	685b      	ldr	r3, [r3, #4]
 800253a:	2b00      	cmp	r3, #0
 800253c:	d101      	bne.n	8002542 <OsHwiCreate+0x4a>
        return LOS_ERRNO_HWI_SHARED_ERROR;
 800253e:	4b43      	ldr	r3, [pc, #268]	; (800264c <OsHwiCreate+0x154>)
 8002540:	e076      	b.n	8002630 <OsHwiCreate+0x138>
    }

    HWI_LOCK(intSave);
 8002542:	f107 0314 	add.w	r3, r7, #20
 8002546:	4619      	mov	r1, r3
 8002548:	4841      	ldr	r0, [pc, #260]	; (8002650 <OsHwiCreate+0x158>)
 800254a:	f7ff fdfa 	bl	8002142 <LOS_SpinLockSave>

    if ((head->next != NULL) && ((modeResult == 0) || (!(head->shareMode & IRQF_SHARED)))) {
 800254e:	68fb      	ldr	r3, [r7, #12]
 8002550:	689b      	ldr	r3, [r3, #8]
 8002552:	2b00      	cmp	r3, #0
 8002554:	d00f      	beq.n	8002576 <OsHwiCreate+0x7e>
 8002556:	8a7b      	ldrh	r3, [r7, #18]
 8002558:	2b00      	cmp	r3, #0
 800255a:	d005      	beq.n	8002568 <OsHwiCreate+0x70>
 800255c:	68fb      	ldr	r3, [r7, #12]
 800255e:	685b      	ldr	r3, [r3, #4]
 8002560:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002564:	2b00      	cmp	r3, #0
 8002566:	d106      	bne.n	8002576 <OsHwiCreate+0x7e>
        HWI_UNLOCK(intSave);
 8002568:	697b      	ldr	r3, [r7, #20]
 800256a:	4619      	mov	r1, r3
 800256c:	4838      	ldr	r0, [pc, #224]	; (8002650 <OsHwiCreate+0x158>)
 800256e:	f7ff fdf6 	bl	800215e <LOS_SpinUnlockRestore>
        return LOS_ERRNO_HWI_SHARED_ERROR;
 8002572:	4b36      	ldr	r3, [pc, #216]	; (800264c <OsHwiCreate+0x154>)
 8002574:	e05c      	b.n	8002630 <OsHwiCreate+0x138>
    }

    hwiForm = head;
 8002576:	68fb      	ldr	r3, [r7, #12]
 8002578:	61bb      	str	r3, [r7, #24]
    while (hwiForm->next != NULL) {
 800257a:	e012      	b.n	80025a2 <OsHwiCreate+0xaa>
        hwiForm = hwiForm->next;
 800257c:	69bb      	ldr	r3, [r7, #24]
 800257e:	689b      	ldr	r3, [r3, #8]
 8002580:	61bb      	str	r3, [r7, #24]
        hwiParam = (HWI_IRQ_PARAM_S *)(hwiForm->registerInfo);
 8002582:	69bb      	ldr	r3, [r7, #24]
 8002584:	685b      	ldr	r3, [r3, #4]
 8002586:	623b      	str	r3, [r7, #32]
        if (hwiParam->pDevId == irqParam->pDevId) {
 8002588:	6a3b      	ldr	r3, [r7, #32]
 800258a:	685a      	ldr	r2, [r3, #4]
 800258c:	683b      	ldr	r3, [r7, #0]
 800258e:	685b      	ldr	r3, [r3, #4]
 8002590:	429a      	cmp	r2, r3
 8002592:	d106      	bne.n	80025a2 <OsHwiCreate+0xaa>
            HWI_UNLOCK(intSave);
 8002594:	697b      	ldr	r3, [r7, #20]
 8002596:	4619      	mov	r1, r3
 8002598:	482d      	ldr	r0, [pc, #180]	; (8002650 <OsHwiCreate+0x158>)
 800259a:	f7ff fde0 	bl	800215e <LOS_SpinUnlockRestore>
            return LOS_ERRNO_HWI_ALREADY_CREATED;
 800259e:	4b2d      	ldr	r3, [pc, #180]	; (8002654 <OsHwiCreate+0x15c>)
 80025a0:	e046      	b.n	8002630 <OsHwiCreate+0x138>
    while (hwiForm->next != NULL) {
 80025a2:	69bb      	ldr	r3, [r7, #24]
 80025a4:	689b      	ldr	r3, [r3, #8]
 80025a6:	2b00      	cmp	r3, #0
 80025a8:	d1e8      	bne.n	800257c <OsHwiCreate+0x84>
        }
    }

    hwiFormNode = (HwiHandleInfo *)LOS_MemAlloc(m_aucSysMem0, sizeof(HwiHandleInfo));
 80025aa:	4b2b      	ldr	r3, [pc, #172]	; (8002658 <OsHwiCreate+0x160>)
 80025ac:	681b      	ldr	r3, [r3, #0]
 80025ae:	2110      	movs	r1, #16
 80025b0:	4618      	mov	r0, r3
 80025b2:	f006 ff2f 	bl	8009414 <LOS_MemAlloc>
 80025b6:	61f8      	str	r0, [r7, #28]
    if (hwiFormNode == NULL) {
 80025b8:	69fb      	ldr	r3, [r7, #28]
 80025ba:	2b00      	cmp	r3, #0
 80025bc:	d106      	bne.n	80025cc <OsHwiCreate+0xd4>
        HWI_UNLOCK(intSave);
 80025be:	697b      	ldr	r3, [r7, #20]
 80025c0:	4619      	mov	r1, r3
 80025c2:	4823      	ldr	r0, [pc, #140]	; (8002650 <OsHwiCreate+0x158>)
 80025c4:	f7ff fdcb 	bl	800215e <LOS_SpinUnlockRestore>
        return LOS_ERRNO_HWI_NO_MEMORY;
 80025c8:	4b24      	ldr	r3, [pc, #144]	; (800265c <OsHwiCreate+0x164>)
 80025ca:	e031      	b.n	8002630 <OsHwiCreate+0x138>
    }
    hwiForm->respCount = 0;
 80025cc:	69bb      	ldr	r3, [r7, #24]
 80025ce:	2200      	movs	r2, #0
 80025d0:	60da      	str	r2, [r3, #12]

    if (irqParam != NULL) {
 80025d2:	683b      	ldr	r3, [r7, #0]
 80025d4:	2b00      	cmp	r3, #0
 80025d6:	d016      	beq.n	8002606 <OsHwiCreate+0x10e>
        hwiFormNode->registerInfo = OsHwiCpIrqParam(irqParam);
 80025d8:	6838      	ldr	r0, [r7, #0]
 80025da:	f7ff fe9f 	bl	800231c <OsHwiCpIrqParam>
 80025de:	4602      	mov	r2, r0
 80025e0:	69fb      	ldr	r3, [r7, #28]
 80025e2:	605a      	str	r2, [r3, #4]
        if (hwiFormNode->registerInfo == (HWI_ARG_T)NULL) {
 80025e4:	69fb      	ldr	r3, [r7, #28]
 80025e6:	685b      	ldr	r3, [r3, #4]
 80025e8:	2b00      	cmp	r3, #0
 80025ea:	d10f      	bne.n	800260c <OsHwiCreate+0x114>
            HWI_UNLOCK(intSave);
 80025ec:	697b      	ldr	r3, [r7, #20]
 80025ee:	4619      	mov	r1, r3
 80025f0:	4817      	ldr	r0, [pc, #92]	; (8002650 <OsHwiCreate+0x158>)
 80025f2:	f7ff fdb4 	bl	800215e <LOS_SpinUnlockRestore>
            (VOID) LOS_MemFree(m_aucSysMem0, hwiFormNode);
 80025f6:	4b18      	ldr	r3, [pc, #96]	; (8002658 <OsHwiCreate+0x160>)
 80025f8:	681b      	ldr	r3, [r3, #0]
 80025fa:	69f9      	ldr	r1, [r7, #28]
 80025fc:	4618      	mov	r0, r3
 80025fe:	f006 ffc1 	bl	8009584 <LOS_MemFree>
            return LOS_ERRNO_HWI_NO_MEMORY;
 8002602:	4b16      	ldr	r3, [pc, #88]	; (800265c <OsHwiCreate+0x164>)
 8002604:	e014      	b.n	8002630 <OsHwiCreate+0x138>
        }
    } else {
        hwiFormNode->registerInfo = 0;
 8002606:	69fb      	ldr	r3, [r7, #28]
 8002608:	2200      	movs	r2, #0
 800260a:	605a      	str	r2, [r3, #4]
    }

    hwiFormNode->hook = hwiHandler;
 800260c:	69fb      	ldr	r3, [r7, #28]
 800260e:	687a      	ldr	r2, [r7, #4]
 8002610:	601a      	str	r2, [r3, #0]
    hwiFormNode->next = (struct tagHwiHandleForm *)NULL;
 8002612:	69fb      	ldr	r3, [r7, #28]
 8002614:	2200      	movs	r2, #0
 8002616:	609a      	str	r2, [r3, #8]
    hwiForm->next = hwiFormNode;
 8002618:	69bb      	ldr	r3, [r7, #24]
 800261a:	69fa      	ldr	r2, [r7, #28]
 800261c:	609a      	str	r2, [r3, #8]

    head->shareMode = modeResult;
 800261e:	8a7a      	ldrh	r2, [r7, #18]
 8002620:	68fb      	ldr	r3, [r7, #12]
 8002622:	605a      	str	r2, [r3, #4]

    HWI_UNLOCK(intSave);
 8002624:	697b      	ldr	r3, [r7, #20]
 8002626:	4619      	mov	r1, r3
 8002628:	4809      	ldr	r0, [pc, #36]	; (8002650 <OsHwiCreate+0x158>)
 800262a:	f7ff fd98 	bl	800215e <LOS_SpinUnlockRestore>
    return LOS_OK;
 800262e:	2300      	movs	r3, #0
}
 8002630:	4a05      	ldr	r2, [pc, #20]	; (8002648 <OsHwiCreate+0x150>)
 8002632:	6811      	ldr	r1, [r2, #0]
 8002634:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002636:	4051      	eors	r1, r2
 8002638:	d001      	beq.n	800263e <OsHwiCreate+0x146>
 800263a:	f001 ffcf 	bl	80045dc <__stack_chk_fail>
 800263e:	4618      	mov	r0, r3
 8002640:	3728      	adds	r7, #40	; 0x28
 8002642:	46bd      	mov	sp, r7
 8002644:	bd80      	pop	{r7, pc}
 8002646:	bf00      	nop
 8002648:	08020038 	.word	0x08020038
 800264c:	02000909 	.word	0x02000909
 8002650:	20000758 	.word	0x20000758
 8002654:	02000904 	.word	0x02000904
 8002658:	200021bc 	.word	0x200021bc
 800265c:	02000903 	.word	0x02000903

08002660 <IntActive>:
#endif

size_t IntActive()
{
 8002660:	b580      	push	{r7, lr}
 8002662:	b082      	sub	sp, #8
 8002664:	af00      	add	r7, sp, #0
    size_t intCount;
    UINT32 intSave = LOS_IntLock();
 8002666:	f7ff fd5a 	bl	800211e <LOS_IntLock>
 800266a:	6038      	str	r0, [r7, #0]

    intCount = g_intCount[ArchCurrCpuid()];
 800266c:	f7ff fd4f 	bl	800210e <ArchCurrCpuid>
 8002670:	4603      	mov	r3, r0
 8002672:	4a06      	ldr	r2, [pc, #24]	; (800268c <IntActive+0x2c>)
 8002674:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002678:	607b      	str	r3, [r7, #4]
    LOS_IntRestore(intSave);
 800267a:	6838      	ldr	r0, [r7, #0]
 800267c:	f7ff fd56 	bl	800212c <LOS_IntRestore>
    return intCount;
 8002680:	687b      	ldr	r3, [r7, #4]
}
 8002682:	4618      	mov	r0, r3
 8002684:	3708      	adds	r7, #8
 8002686:	46bd      	mov	sp, r7
 8002688:	bd80      	pop	{r7, pc}
 800268a:	bf00      	nop
 800268c:	2000075c 	.word	0x2000075c

08002690 <LOS_HwiCreate>:
LITE_OS_SEC_TEXT UINT32 LOS_HwiCreate(HWI_HANDLE_T hwiNum,
                                           HWI_PRIOR_T hwiPrio,
                                           HWI_MODE_T hwiMode,
                                           HWI_PROC_FUNC hwiHandler,
                                           HWI_IRQ_PARAM_S *irqParam)
{
 8002690:	b590      	push	{r4, r7, lr}
 8002692:	b08f      	sub	sp, #60	; 0x3c
 8002694:	af00      	add	r7, sp, #0
 8002696:	60f8      	str	r0, [r7, #12]
 8002698:	607b      	str	r3, [r7, #4]
 800269a:	460b      	mov	r3, r1
 800269c:	817b      	strh	r3, [r7, #10]
 800269e:	4613      	mov	r3, r2
 80026a0:	813b      	strh	r3, [r7, #8]
 80026a2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80026a4:	603b      	str	r3, [r7, #0]
 80026a6:	4b4e      	ldr	r3, [pc, #312]	; (80027e0 <LOS_HwiCreate+0x150>)
 80026a8:	681b      	ldr	r3, [r3, #0]
 80026aa:	637b      	str	r3, [r7, #52]	; 0x34
 80026ac:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    HwiHandleInfo *hwiForm = NULL;
 80026b0:	2300      	movs	r3, #0
 80026b2:	617b      	str	r3, [r7, #20]

    if (hwiHandler == NULL) {
 80026b4:	687b      	ldr	r3, [r7, #4]
 80026b6:	2b00      	cmp	r3, #0
 80026b8:	d101      	bne.n	80026be <LOS_HwiCreate+0x2e>
        return LOS_ERRNO_HWI_PROC_FUNC_NULL;
 80026ba:	4b4a      	ldr	r3, [pc, #296]	; (80027e4 <LOS_HwiCreate+0x154>)
 80026bc:	e084      	b.n	80027c8 <LOS_HwiCreate+0x138>
    }

    if ((g_hwiOps == NULL) || (g_hwiOps->getHandleForm == NULL)) {
 80026be:	4b4a      	ldr	r3, [pc, #296]	; (80027e8 <LOS_HwiCreate+0x158>)
 80026c0:	681b      	ldr	r3, [r3, #0]
 80026c2:	2b00      	cmp	r3, #0
 80026c4:	d004      	beq.n	80026d0 <LOS_HwiCreate+0x40>
 80026c6:	4b48      	ldr	r3, [pc, #288]	; (80027e8 <LOS_HwiCreate+0x158>)
 80026c8:	681b      	ldr	r3, [r3, #0]
 80026ca:	69db      	ldr	r3, [r3, #28]
 80026cc:	2b00      	cmp	r3, #0
 80026ce:	d101      	bne.n	80026d4 <LOS_HwiCreate+0x44>
        return LOS_ERRNO_HWI_PROC_FUNC_NULL;
 80026d0:	4b44      	ldr	r3, [pc, #272]	; (80027e4 <LOS_HwiCreate+0x154>)
 80026d2:	e079      	b.n	80027c8 <LOS_HwiCreate+0x138>
    }

    hwiForm = g_hwiOps->getHandleForm(hwiNum);
 80026d4:	4b44      	ldr	r3, [pc, #272]	; (80027e8 <LOS_HwiCreate+0x158>)
 80026d6:	681b      	ldr	r3, [r3, #0]
 80026d8:	69db      	ldr	r3, [r3, #28]
 80026da:	68f8      	ldr	r0, [r7, #12]
 80026dc:	4798      	blx	r3
 80026de:	6178      	str	r0, [r7, #20]
    if (hwiForm == NULL) {
 80026e0:	697b      	ldr	r3, [r7, #20]
 80026e2:	2b00      	cmp	r3, #0
 80026e4:	d101      	bne.n	80026ea <LOS_HwiCreate+0x5a>
        return LOS_ERRNO_HWI_NUM_INVALID;
 80026e6:	4b41      	ldr	r3, [pc, #260]	; (80027ec <LOS_HwiCreate+0x15c>)
 80026e8:	e06e      	b.n	80027c8 <LOS_HwiCreate+0x138>
    }
    LOS_TRACE(HWI_CREATE, hwiNum, hwiPrio, hwiMode, (UINTPTR)hwiHandler);
 80026ea:	2300      	movs	r3, #0
 80026ec:	623b      	str	r3, [r7, #32]
 80026ee:	68fb      	ldr	r3, [r7, #12]
 80026f0:	627b      	str	r3, [r7, #36]	; 0x24
 80026f2:	897b      	ldrh	r3, [r7, #10]
 80026f4:	62bb      	str	r3, [r7, #40]	; 0x28
 80026f6:	893b      	ldrh	r3, [r7, #8]
 80026f8:	62fb      	str	r3, [r7, #44]	; 0x2c
 80026fa:	687b      	ldr	r3, [r7, #4]
 80026fc:	633b      	str	r3, [r7, #48]	; 0x30
 80026fe:	2305      	movs	r3, #5
 8002700:	61bb      	str	r3, [r7, #24]
 8002702:	69bb      	ldr	r3, [r7, #24]
 8002704:	2b01      	cmp	r3, #1
 8002706:	d915      	bls.n	8002734 <LOS_HwiCreate+0xa4>
 8002708:	4b39      	ldr	r3, [pc, #228]	; (80027f0 <LOS_HwiCreate+0x160>)
 800270a:	681b      	ldr	r3, [r3, #0]
 800270c:	2b00      	cmp	r3, #0
 800270e:	d011      	beq.n	8002734 <LOS_HwiCreate+0xa4>
 8002710:	4b37      	ldr	r3, [pc, #220]	; (80027f0 <LOS_HwiCreate+0x160>)
 8002712:	681c      	ldr	r4, [r3, #0]
 8002714:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8002716:	69bb      	ldr	r3, [r7, #24]
 8002718:	2b02      	cmp	r3, #2
 800271a:	d904      	bls.n	8002726 <LOS_HwiCreate+0x96>
 800271c:	f107 0320 	add.w	r3, r7, #32
 8002720:	f103 0208 	add.w	r2, r3, #8
 8002724:	e000      	b.n	8002728 <LOS_HwiCreate+0x98>
 8002726:	2200      	movs	r2, #0
 8002728:	69bb      	ldr	r3, [r7, #24]
 800272a:	b29b      	uxth	r3, r3
 800272c:	3b02      	subs	r3, #2
 800272e:	b29b      	uxth	r3, r3
 8002730:	2020      	movs	r0, #32
 8002732:	47a0      	blx	r4

    ret = OsHwiCreate(hwiForm, hwiMode, hwiHandler, irqParam);
 8002734:	8939      	ldrh	r1, [r7, #8]
 8002736:	683b      	ldr	r3, [r7, #0]
 8002738:	687a      	ldr	r2, [r7, #4]
 800273a:	6978      	ldr	r0, [r7, #20]
 800273c:	f7ff fedc 	bl	80024f8 <OsHwiCreate>
 8002740:	6138      	str	r0, [r7, #16]
    LOS_TRACE(HWI_CREATE_SHARE, hwiNum, (UINTPTR)(irqParam != NULL ? irqParam->pDevId : NULL), ret);
 8002742:	2300      	movs	r3, #0
 8002744:	623b      	str	r3, [r7, #32]
 8002746:	68fb      	ldr	r3, [r7, #12]
 8002748:	627b      	str	r3, [r7, #36]	; 0x24
 800274a:	683b      	ldr	r3, [r7, #0]
 800274c:	2b00      	cmp	r3, #0
 800274e:	d002      	beq.n	8002756 <LOS_HwiCreate+0xc6>
 8002750:	683b      	ldr	r3, [r7, #0]
 8002752:	685b      	ldr	r3, [r3, #4]
 8002754:	e000      	b.n	8002758 <LOS_HwiCreate+0xc8>
 8002756:	2300      	movs	r3, #0
 8002758:	62bb      	str	r3, [r7, #40]	; 0x28
 800275a:	693b      	ldr	r3, [r7, #16]
 800275c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800275e:	2304      	movs	r3, #4
 8002760:	61fb      	str	r3, [r7, #28]
 8002762:	69fb      	ldr	r3, [r7, #28]
 8002764:	2b01      	cmp	r3, #1
 8002766:	d915      	bls.n	8002794 <LOS_HwiCreate+0x104>
 8002768:	4b21      	ldr	r3, [pc, #132]	; (80027f0 <LOS_HwiCreate+0x160>)
 800276a:	681b      	ldr	r3, [r3, #0]
 800276c:	2b00      	cmp	r3, #0
 800276e:	d011      	beq.n	8002794 <LOS_HwiCreate+0x104>
 8002770:	4b1f      	ldr	r3, [pc, #124]	; (80027f0 <LOS_HwiCreate+0x160>)
 8002772:	681c      	ldr	r4, [r3, #0]
 8002774:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8002776:	69fb      	ldr	r3, [r7, #28]
 8002778:	2b02      	cmp	r3, #2
 800277a:	d904      	bls.n	8002786 <LOS_HwiCreate+0xf6>
 800277c:	f107 0320 	add.w	r3, r7, #32
 8002780:	f103 0208 	add.w	r2, r3, #8
 8002784:	e000      	b.n	8002788 <LOS_HwiCreate+0xf8>
 8002786:	2200      	movs	r2, #0
 8002788:	69fb      	ldr	r3, [r7, #28]
 800278a:	b29b      	uxth	r3, r3
 800278c:	3b02      	subs	r3, #2
 800278e:	b29b      	uxth	r3, r3
 8002790:	2021      	movs	r0, #33	; 0x21
 8002792:	47a0      	blx	r4

    /* priority will be changed if setIrqPriority implemented,
     * but interrupt preemption only allowed when LOSCFG_ARCH_INTERRUPT_PREEMPTION enable */
    if ((ret == LOS_OK) && (g_hwiOps->setIrqPriority != NULL)) {
 8002794:	693b      	ldr	r3, [r7, #16]
 8002796:	2b00      	cmp	r3, #0
 8002798:	d115      	bne.n	80027c6 <LOS_HwiCreate+0x136>
 800279a:	4b13      	ldr	r3, [pc, #76]	; (80027e8 <LOS_HwiCreate+0x158>)
 800279c:	681b      	ldr	r3, [r3, #0]
 800279e:	691b      	ldr	r3, [r3, #16]
 80027a0:	2b00      	cmp	r3, #0
 80027a2:	d010      	beq.n	80027c6 <LOS_HwiCreate+0x136>
        ret = g_hwiOps->setIrqPriority(hwiNum, hwiPrio);
 80027a4:	4b10      	ldr	r3, [pc, #64]	; (80027e8 <LOS_HwiCreate+0x158>)
 80027a6:	681b      	ldr	r3, [r3, #0]
 80027a8:	691b      	ldr	r3, [r3, #16]
 80027aa:	897a      	ldrh	r2, [r7, #10]
 80027ac:	b2d2      	uxtb	r2, r2
 80027ae:	4611      	mov	r1, r2
 80027b0:	68f8      	ldr	r0, [r7, #12]
 80027b2:	4798      	blx	r3
 80027b4:	6138      	str	r0, [r7, #16]
        if (ret != LOS_OK) {
 80027b6:	693b      	ldr	r3, [r7, #16]
 80027b8:	2b00      	cmp	r3, #0
 80027ba:	d004      	beq.n	80027c6 <LOS_HwiCreate+0x136>
            (VOID)OsHwiDel(hwiForm, irqParam, hwiNum);
 80027bc:	68fa      	ldr	r2, [r7, #12]
 80027be:	6839      	ldr	r1, [r7, #0]
 80027c0:	6978      	ldr	r0, [r7, #20]
 80027c2:	f7ff fe07 	bl	80023d4 <OsHwiDel>
        }
    }
    return ret;
 80027c6:	693b      	ldr	r3, [r7, #16]
}
 80027c8:	4a05      	ldr	r2, [pc, #20]	; (80027e0 <LOS_HwiCreate+0x150>)
 80027ca:	6811      	ldr	r1, [r2, #0]
 80027cc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80027ce:	4051      	eors	r1, r2
 80027d0:	d001      	beq.n	80027d6 <LOS_HwiCreate+0x146>
 80027d2:	f001 ff03 	bl	80045dc <__stack_chk_fail>
 80027d6:	4618      	mov	r0, r3
 80027d8:	373c      	adds	r7, #60	; 0x3c
 80027da:	46bd      	mov	sp, r7
 80027dc:	bd90      	pop	{r4, r7, pc}
 80027de:	bf00      	nop
 80027e0:	0802003c 	.word	0x0802003c
 80027e4:	02000901 	.word	0x02000901
 80027e8:	20000764 	.word	0x20000764
 80027ec:	02000900 	.word	0x02000900
 80027f0:	20000768 	.word	0x20000768

080027f4 <LOS_HwiEnable>:

    return g_hwiOps->triggerIrq(hwiNum);
}

LITE_OS_SEC_TEXT UINT32 LOS_HwiEnable(HWI_HANDLE_T hwiNum)
{
 80027f4:	b590      	push	{r4, r7, lr}
 80027f6:	b087      	sub	sp, #28
 80027f8:	af00      	add	r7, sp, #0
 80027fa:	6078      	str	r0, [r7, #4]
 80027fc:	4b1f      	ldr	r3, [pc, #124]	; (800287c <LOS_HwiEnable+0x88>)
 80027fe:	681b      	ldr	r3, [r3, #0]
 8002800:	617b      	str	r3, [r7, #20]
 8002802:	f04f 0300 	mov.w	r3, #0
    if ((g_hwiOps == NULL) || (g_hwiOps->enableIrq == NULL)) {
 8002806:	4b1e      	ldr	r3, [pc, #120]	; (8002880 <LOS_HwiEnable+0x8c>)
 8002808:	681b      	ldr	r3, [r3, #0]
 800280a:	2b00      	cmp	r3, #0
 800280c:	d004      	beq.n	8002818 <LOS_HwiEnable+0x24>
 800280e:	4b1c      	ldr	r3, [pc, #112]	; (8002880 <LOS_HwiEnable+0x8c>)
 8002810:	681b      	ldr	r3, [r3, #0]
 8002812:	689b      	ldr	r3, [r3, #8]
 8002814:	2b00      	cmp	r3, #0
 8002816:	d101      	bne.n	800281c <LOS_HwiEnable+0x28>
        return LOS_ERRNO_HWI_PROC_FUNC_NULL;
 8002818:	4b1a      	ldr	r3, [pc, #104]	; (8002884 <LOS_HwiEnable+0x90>)
 800281a:	e024      	b.n	8002866 <LOS_HwiEnable+0x72>
    }
    LOS_TRACE(HWI_ENABLE, hwiNum);
 800281c:	2300      	movs	r3, #0
 800281e:	60fb      	str	r3, [r7, #12]
 8002820:	687b      	ldr	r3, [r7, #4]
 8002822:	613b      	str	r3, [r7, #16]
 8002824:	2302      	movs	r3, #2
 8002826:	60bb      	str	r3, [r7, #8]
 8002828:	68bb      	ldr	r3, [r7, #8]
 800282a:	2b01      	cmp	r3, #1
 800282c:	d915      	bls.n	800285a <LOS_HwiEnable+0x66>
 800282e:	4b16      	ldr	r3, [pc, #88]	; (8002888 <LOS_HwiEnable+0x94>)
 8002830:	681b      	ldr	r3, [r3, #0]
 8002832:	2b00      	cmp	r3, #0
 8002834:	d011      	beq.n	800285a <LOS_HwiEnable+0x66>
 8002836:	4b14      	ldr	r3, [pc, #80]	; (8002888 <LOS_HwiEnable+0x94>)
 8002838:	681c      	ldr	r4, [r3, #0]
 800283a:	6939      	ldr	r1, [r7, #16]
 800283c:	68bb      	ldr	r3, [r7, #8]
 800283e:	2b02      	cmp	r3, #2
 8002840:	d904      	bls.n	800284c <LOS_HwiEnable+0x58>
 8002842:	f107 030c 	add.w	r3, r7, #12
 8002846:	f103 0208 	add.w	r2, r3, #8
 800284a:	e000      	b.n	800284e <LOS_HwiEnable+0x5a>
 800284c:	2200      	movs	r2, #0
 800284e:	68bb      	ldr	r3, [r7, #8]
 8002850:	b29b      	uxth	r3, r3
 8002852:	3b02      	subs	r3, #2
 8002854:	b29b      	uxth	r3, r3
 8002856:	2026      	movs	r0, #38	; 0x26
 8002858:	47a0      	blx	r4

    return g_hwiOps->enableIrq(hwiNum);
 800285a:	4b09      	ldr	r3, [pc, #36]	; (8002880 <LOS_HwiEnable+0x8c>)
 800285c:	681b      	ldr	r3, [r3, #0]
 800285e:	689b      	ldr	r3, [r3, #8]
 8002860:	6878      	ldr	r0, [r7, #4]
 8002862:	4798      	blx	r3
 8002864:	4603      	mov	r3, r0
}
 8002866:	4a05      	ldr	r2, [pc, #20]	; (800287c <LOS_HwiEnable+0x88>)
 8002868:	6811      	ldr	r1, [r2, #0]
 800286a:	697a      	ldr	r2, [r7, #20]
 800286c:	4051      	eors	r1, r2
 800286e:	d001      	beq.n	8002874 <LOS_HwiEnable+0x80>
 8002870:	f001 feb4 	bl	80045dc <__stack_chk_fail>
 8002874:	4618      	mov	r0, r3
 8002876:	371c      	adds	r7, #28
 8002878:	46bd      	mov	sp, r7
 800287a:	bd90      	pop	{r4, r7, pc}
 800287c:	08020048 	.word	0x08020048
 8002880:	20000764 	.word	0x20000764
 8002884:	02000901 	.word	0x02000901
 8002888:	20000768 	.word	0x20000768

0800288c <LOS_IntWakeupHookReg>:
}
#endif

#ifdef LOSCFG_KERNEL_LOWPOWER
LITE_OS_SEC_TEXT_MINOR VOID LOS_IntWakeupHookReg(WAKEUPFROMINTHOOK hook)
{
 800288c:	b480      	push	{r7}
 800288e:	b083      	sub	sp, #12
 8002890:	af00      	add	r7, sp, #0
 8002892:	6078      	str	r0, [r7, #4]
    g_intWakeupHook = hook;
 8002894:	4a04      	ldr	r2, [pc, #16]	; (80028a8 <LOS_IntWakeupHookReg+0x1c>)
 8002896:	687b      	ldr	r3, [r7, #4]
 8002898:	6013      	str	r3, [r2, #0]
}
 800289a:	bf00      	nop
 800289c:	370c      	adds	r7, #12
 800289e:	46bd      	mov	sp, r7
 80028a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028a4:	4770      	bx	lr
 80028a6:	bf00      	nop
 80028a8:	20000760 	.word	0x20000760

080028ac <OsHwiInit>:
#endif

/* Initialization of the hardware interrupt */
LITE_OS_SEC_TEXT_INIT VOID OsHwiInit(VOID)
{
 80028ac:	b580      	push	{r7, lr}
 80028ae:	af00      	add	r7, sp, #0
    ArchIrqInit();
 80028b0:	f00d fe0e 	bl	80104d0 <ArchIrqInit>
    return;
 80028b4:	bf00      	nop
}
 80028b6:	bd80      	pop	{r7, pc}

080028b8 <LOS_Align>:
LMS_INIT_HOOK g_lmsMemInitHook = NULL;
LMS_FUNC_HOOK g_lmsMallocHook = NULL;
LMS_FUNC_HOOK g_lmsFreeHook = NULL;
#endif
LITE_OS_SEC_TEXT UINTPTR LOS_Align(UINTPTR addr, UINT32 boundary)
{
 80028b8:	b480      	push	{r7}
 80028ba:	b083      	sub	sp, #12
 80028bc:	af00      	add	r7, sp, #0
 80028be:	6078      	str	r0, [r7, #4]
 80028c0:	6039      	str	r1, [r7, #0]
    return (addr + boundary - 1) & ~((UINTPTR)(boundary - 1));
 80028c2:	687a      	ldr	r2, [r7, #4]
 80028c4:	683b      	ldr	r3, [r7, #0]
 80028c6:	4413      	add	r3, r2
 80028c8:	1e5a      	subs	r2, r3, #1
 80028ca:	683b      	ldr	r3, [r7, #0]
 80028cc:	425b      	negs	r3, r3
 80028ce:	4013      	ands	r3, r2
}
 80028d0:	4618      	mov	r0, r3
 80028d2:	370c      	adds	r7, #12
 80028d4:	46bd      	mov	sp, r7
 80028d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80028da:	4770      	bx	lr

080028dc <OsArraySort>:
}

#if defined(LOSCFG_DEBUG_SEMAPHORE) || defined(LOSCFG_DEBUG_MUTEX) || defined(LOSCFG_DEBUG_QUEUE)
VOID OsArraySort(UINT32 *sortArray, UINT32 start, UINT32 end,
                 const SortParam *sortParam, OsCompareFunc compareFunc)
{
 80028dc:	b580      	push	{r7, lr}
 80028de:	b08a      	sub	sp, #40	; 0x28
 80028e0:	af02      	add	r7, sp, #8
 80028e2:	60f8      	str	r0, [r7, #12]
 80028e4:	60b9      	str	r1, [r7, #8]
 80028e6:	607a      	str	r2, [r7, #4]
 80028e8:	603b      	str	r3, [r7, #0]
    UINT32 left = start;
 80028ea:	68bb      	ldr	r3, [r7, #8]
 80028ec:	613b      	str	r3, [r7, #16]
    UINT32 right = end;
 80028ee:	687b      	ldr	r3, [r7, #4]
 80028f0:	617b      	str	r3, [r7, #20]
    UINT32 idx = start;
 80028f2:	68bb      	ldr	r3, [r7, #8]
 80028f4:	61bb      	str	r3, [r7, #24]
    UINT32 pivot = sortArray[start];
 80028f6:	68bb      	ldr	r3, [r7, #8]
 80028f8:	009b      	lsls	r3, r3, #2
 80028fa:	68fa      	ldr	r2, [r7, #12]
 80028fc:	4413      	add	r3, r2
 80028fe:	681b      	ldr	r3, [r3, #0]
 8002900:	61fb      	str	r3, [r7, #28]

    while (left < right) {
 8002902:	e068      	b.n	80029d6 <OsArraySort+0xfa>
        while ((left < right) && (sortArray[right] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
               compareFunc(sortParam, sortArray[right], pivot)) {
            right--;
 8002904:	697b      	ldr	r3, [r7, #20]
 8002906:	3b01      	subs	r3, #1
 8002908:	617b      	str	r3, [r7, #20]
        while ((left < right) && (sortArray[right] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
 800290a:	693a      	ldr	r2, [r7, #16]
 800290c:	697b      	ldr	r3, [r7, #20]
 800290e:	429a      	cmp	r2, r3
 8002910:	d219      	bcs.n	8002946 <OsArraySort+0x6a>
 8002912:	697b      	ldr	r3, [r7, #20]
 8002914:	009b      	lsls	r3, r3, #2
 8002916:	68fa      	ldr	r2, [r7, #12]
 8002918:	4413      	add	r3, r2
 800291a:	681a      	ldr	r2, [r3, #0]
 800291c:	683b      	ldr	r3, [r7, #0]
 800291e:	689b      	ldr	r3, [r3, #8]
 8002920:	429a      	cmp	r2, r3
 8002922:	d210      	bcs.n	8002946 <OsArraySort+0x6a>
 8002924:	683b      	ldr	r3, [r7, #0]
 8002926:	689b      	ldr	r3, [r3, #8]
 8002928:	69fa      	ldr	r2, [r7, #28]
 800292a:	429a      	cmp	r2, r3
 800292c:	d20b      	bcs.n	8002946 <OsArraySort+0x6a>
               compareFunc(sortParam, sortArray[right], pivot)) {
 800292e:	697b      	ldr	r3, [r7, #20]
 8002930:	009b      	lsls	r3, r3, #2
 8002932:	68fa      	ldr	r2, [r7, #12]
 8002934:	4413      	add	r3, r2
 8002936:	6819      	ldr	r1, [r3, #0]
 8002938:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800293a:	69fa      	ldr	r2, [r7, #28]
 800293c:	6838      	ldr	r0, [r7, #0]
 800293e:	4798      	blx	r3
 8002940:	4603      	mov	r3, r0
        while ((left < right) && (sortArray[right] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
 8002942:	2b00      	cmp	r3, #0
 8002944:	d1de      	bne.n	8002904 <OsArraySort+0x28>
        }

        if (left < right) {
 8002946:	693a      	ldr	r2, [r7, #16]
 8002948:	697b      	ldr	r3, [r7, #20]
 800294a:	429a      	cmp	r2, r3
 800294c:	d212      	bcs.n	8002974 <OsArraySort+0x98>
            sortArray[left] = sortArray[right];
 800294e:	697b      	ldr	r3, [r7, #20]
 8002950:	009b      	lsls	r3, r3, #2
 8002952:	68fa      	ldr	r2, [r7, #12]
 8002954:	441a      	add	r2, r3
 8002956:	693b      	ldr	r3, [r7, #16]
 8002958:	009b      	lsls	r3, r3, #2
 800295a:	68f9      	ldr	r1, [r7, #12]
 800295c:	440b      	add	r3, r1
 800295e:	6812      	ldr	r2, [r2, #0]
 8002960:	601a      	str	r2, [r3, #0]
            idx = right;
 8002962:	697b      	ldr	r3, [r7, #20]
 8002964:	61bb      	str	r3, [r7, #24]
            left++;
 8002966:	693b      	ldr	r3, [r7, #16]
 8002968:	3301      	adds	r3, #1
 800296a:	613b      	str	r3, [r7, #16]
        }

        while ((left < right) && (sortArray[left] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
 800296c:	e002      	b.n	8002974 <OsArraySort+0x98>
               compareFunc(sortParam, pivot, sortArray[left])) {
            left++;
 800296e:	693b      	ldr	r3, [r7, #16]
 8002970:	3301      	adds	r3, #1
 8002972:	613b      	str	r3, [r7, #16]
        while ((left < right) && (sortArray[left] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
 8002974:	693a      	ldr	r2, [r7, #16]
 8002976:	697b      	ldr	r3, [r7, #20]
 8002978:	429a      	cmp	r2, r3
 800297a:	d219      	bcs.n	80029b0 <OsArraySort+0xd4>
 800297c:	693b      	ldr	r3, [r7, #16]
 800297e:	009b      	lsls	r3, r3, #2
 8002980:	68fa      	ldr	r2, [r7, #12]
 8002982:	4413      	add	r3, r2
 8002984:	681a      	ldr	r2, [r3, #0]
 8002986:	683b      	ldr	r3, [r7, #0]
 8002988:	689b      	ldr	r3, [r3, #8]
 800298a:	429a      	cmp	r2, r3
 800298c:	d210      	bcs.n	80029b0 <OsArraySort+0xd4>
 800298e:	683b      	ldr	r3, [r7, #0]
 8002990:	689b      	ldr	r3, [r3, #8]
 8002992:	69fa      	ldr	r2, [r7, #28]
 8002994:	429a      	cmp	r2, r3
 8002996:	d20b      	bcs.n	80029b0 <OsArraySort+0xd4>
               compareFunc(sortParam, pivot, sortArray[left])) {
 8002998:	693b      	ldr	r3, [r7, #16]
 800299a:	009b      	lsls	r3, r3, #2
 800299c:	68fa      	ldr	r2, [r7, #12]
 800299e:	4413      	add	r3, r2
 80029a0:	681a      	ldr	r2, [r3, #0]
 80029a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80029a4:	69f9      	ldr	r1, [r7, #28]
 80029a6:	6838      	ldr	r0, [r7, #0]
 80029a8:	4798      	blx	r3
 80029aa:	4603      	mov	r3, r0
        while ((left < right) && (sortArray[left] < sortParam->ctrlBlockCnt) && (pivot < sortParam->ctrlBlockCnt) &&
 80029ac:	2b00      	cmp	r3, #0
 80029ae:	d1de      	bne.n	800296e <OsArraySort+0x92>
        }

        if (left < right) {
 80029b0:	693a      	ldr	r2, [r7, #16]
 80029b2:	697b      	ldr	r3, [r7, #20]
 80029b4:	429a      	cmp	r2, r3
 80029b6:	d20e      	bcs.n	80029d6 <OsArraySort+0xfa>
            sortArray[right] = sortArray[left];
 80029b8:	693b      	ldr	r3, [r7, #16]
 80029ba:	009b      	lsls	r3, r3, #2
 80029bc:	68fa      	ldr	r2, [r7, #12]
 80029be:	441a      	add	r2, r3
 80029c0:	697b      	ldr	r3, [r7, #20]
 80029c2:	009b      	lsls	r3, r3, #2
 80029c4:	68f9      	ldr	r1, [r7, #12]
 80029c6:	440b      	add	r3, r1
 80029c8:	6812      	ldr	r2, [r2, #0]
 80029ca:	601a      	str	r2, [r3, #0]
            idx = left;
 80029cc:	693b      	ldr	r3, [r7, #16]
 80029ce:	61bb      	str	r3, [r7, #24]
            right--;
 80029d0:	697b      	ldr	r3, [r7, #20]
 80029d2:	3b01      	subs	r3, #1
 80029d4:	617b      	str	r3, [r7, #20]
    while (left < right) {
 80029d6:	693a      	ldr	r2, [r7, #16]
 80029d8:	697b      	ldr	r3, [r7, #20]
 80029da:	429a      	cmp	r2, r3
 80029dc:	d395      	bcc.n	800290a <OsArraySort+0x2e>
        }
    }

    sortArray[idx] = pivot;
 80029de:	69bb      	ldr	r3, [r7, #24]
 80029e0:	009b      	lsls	r3, r3, #2
 80029e2:	68fa      	ldr	r2, [r7, #12]
 80029e4:	4413      	add	r3, r2
 80029e6:	69fa      	ldr	r2, [r7, #28]
 80029e8:	601a      	str	r2, [r3, #0]

    if (start < idx) {
 80029ea:	68ba      	ldr	r2, [r7, #8]
 80029ec:	69bb      	ldr	r3, [r7, #24]
 80029ee:	429a      	cmp	r2, r3
 80029f0:	d208      	bcs.n	8002a04 <OsArraySort+0x128>
        OsArraySort(sortArray, start, idx - 1, sortParam, compareFunc);
 80029f2:	69bb      	ldr	r3, [r7, #24]
 80029f4:	1e5a      	subs	r2, r3, #1
 80029f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80029f8:	9300      	str	r3, [sp, #0]
 80029fa:	683b      	ldr	r3, [r7, #0]
 80029fc:	68b9      	ldr	r1, [r7, #8]
 80029fe:	68f8      	ldr	r0, [r7, #12]
 8002a00:	f7ff ff6c 	bl	80028dc <OsArraySort>
    }
    if (idx < end) {
 8002a04:	69ba      	ldr	r2, [r7, #24]
 8002a06:	687b      	ldr	r3, [r7, #4]
 8002a08:	429a      	cmp	r2, r3
 8002a0a:	d208      	bcs.n	8002a1e <OsArraySort+0x142>
        OsArraySort(sortArray, idx + 1, end, sortParam, compareFunc);
 8002a0c:	69bb      	ldr	r3, [r7, #24]
 8002a0e:	1c59      	adds	r1, r3, #1
 8002a10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002a12:	9300      	str	r3, [sp, #0]
 8002a14:	683b      	ldr	r3, [r7, #0]
 8002a16:	687a      	ldr	r2, [r7, #4]
 8002a18:	68f8      	ldr	r0, [r7, #12]
 8002a1a:	f7ff ff5f 	bl	80028dc <OsArraySort>
    }
}
 8002a1e:	bf00      	nop
 8002a20:	3720      	adds	r7, #32
 8002a22:	46bd      	mov	sp, r7
 8002a24:	bd80      	pop	{r7, pc}

08002a26 <LOS_ListInit>:
 * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_DL_LIST_HEAD
 * @since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_ListInit(LOS_DL_LIST *list)
{
 8002a26:	b480      	push	{r7}
 8002a28:	b083      	sub	sp, #12
 8002a2a:	af00      	add	r7, sp, #0
 8002a2c:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 8002a2e:	687b      	ldr	r3, [r7, #4]
 8002a30:	687a      	ldr	r2, [r7, #4]
 8002a32:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 8002a34:	687b      	ldr	r3, [r7, #4]
 8002a36:	687a      	ldr	r2, [r7, #4]
 8002a38:	601a      	str	r2, [r3, #0]
}
 8002a3a:	bf00      	nop
 8002a3c:	370c      	adds	r7, #12
 8002a3e:	46bd      	mov	sp, r7
 8002a40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a44:	4770      	bx	lr

08002a46 <LOS_ListAdd>:
 * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_ListDelete | LOS_ListTailInsert | LOS_ListHeadInsert
 * @since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_ListAdd(LOS_DL_LIST *list, LOS_DL_LIST *node)
{
 8002a46:	b480      	push	{r7}
 8002a48:	b083      	sub	sp, #12
 8002a4a:	af00      	add	r7, sp, #0
 8002a4c:	6078      	str	r0, [r7, #4]
 8002a4e:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 8002a50:	687b      	ldr	r3, [r7, #4]
 8002a52:	685a      	ldr	r2, [r3, #4]
 8002a54:	683b      	ldr	r3, [r7, #0]
 8002a56:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 8002a58:	683b      	ldr	r3, [r7, #0]
 8002a5a:	687a      	ldr	r2, [r7, #4]
 8002a5c:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8002a5e:	687b      	ldr	r3, [r7, #4]
 8002a60:	685b      	ldr	r3, [r3, #4]
 8002a62:	683a      	ldr	r2, [r7, #0]
 8002a64:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 8002a66:	687b      	ldr	r3, [r7, #4]
 8002a68:	683a      	ldr	r2, [r7, #0]
 8002a6a:	605a      	str	r2, [r3, #4]
}
 8002a6c:	bf00      	nop
 8002a6e:	370c      	adds	r7, #12
 8002a70:	46bd      	mov	sp, r7
 8002a72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a76:	4770      	bx	lr

08002a78 <LOS_ListTailInsert>:
 * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_ListAdd | LOS_ListHeadInsert
 * @since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_ListTailInsert(LOS_DL_LIST *list, LOS_DL_LIST *node)
{
 8002a78:	b580      	push	{r7, lr}
 8002a7a:	b082      	sub	sp, #8
 8002a7c:	af00      	add	r7, sp, #0
 8002a7e:	6078      	str	r0, [r7, #4]
 8002a80:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 8002a82:	687b      	ldr	r3, [r7, #4]
 8002a84:	681b      	ldr	r3, [r3, #0]
 8002a86:	6839      	ldr	r1, [r7, #0]
 8002a88:	4618      	mov	r0, r3
 8002a8a:	f7ff ffdc 	bl	8002a46 <LOS_ListAdd>
}
 8002a8e:	bf00      	nop
 8002a90:	3708      	adds	r7, #8
 8002a92:	46bd      	mov	sp, r7
 8002a94:	bd80      	pop	{r7, pc}

08002a96 <LOS_ListDelete>:
 * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
 * @see LOS_ListAdd
 * @since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE STATIC INLINE VOID LOS_ListDelete(LOS_DL_LIST *node)
{
 8002a96:	b480      	push	{r7}
 8002a98:	b083      	sub	sp, #12
 8002a9a:	af00      	add	r7, sp, #0
 8002a9c:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8002a9e:	687b      	ldr	r3, [r7, #4]
 8002aa0:	685b      	ldr	r3, [r3, #4]
 8002aa2:	687a      	ldr	r2, [r7, #4]
 8002aa4:	6812      	ldr	r2, [r2, #0]
 8002aa6:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 8002aa8:	687b      	ldr	r3, [r7, #4]
 8002aaa:	681b      	ldr	r3, [r3, #0]
 8002aac:	687a      	ldr	r2, [r7, #4]
 8002aae:	6852      	ldr	r2, [r2, #4]
 8002ab0:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8002ab2:	687b      	ldr	r3, [r7, #4]
 8002ab4:	2200      	movs	r2, #0
 8002ab6:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 8002ab8:	687b      	ldr	r3, [r7, #4]
 8002aba:	2200      	movs	r2, #0
 8002abc:	601a      	str	r2, [r3, #0]
}
 8002abe:	bf00      	nop
 8002ac0:	370c      	adds	r7, #12
 8002ac2:	46bd      	mov	sp, r7
 8002ac4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ac8:	4770      	bx	lr

08002aca <LOS_ListEmpty>:
 * @par Dependency:
 * <ul><li>los_list.h: the header file that contains the API declaration.</li></ul>
 * @since Huawei LiteOS V100R001C00
 */
LITE_OS_SEC_ALW_INLINE STATIC INLINE BOOL LOS_ListEmpty(LOS_DL_LIST *list)
{
 8002aca:	b480      	push	{r7}
 8002acc:	b083      	sub	sp, #12
 8002ace:	af00      	add	r7, sp, #0
 8002ad0:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8002ad2:	687b      	ldr	r3, [r7, #4]
 8002ad4:	685b      	ldr	r3, [r3, #4]
 8002ad6:	687a      	ldr	r2, [r7, #4]
 8002ad8:	429a      	cmp	r2, r3
 8002ada:	bf0c      	ite	eq
 8002adc:	2301      	moveq	r3, #1
 8002ade:	2300      	movne	r3, #0
 8002ae0:	b2db      	uxtb	r3, r3
}
 8002ae2:	4618      	mov	r0, r3
 8002ae4:	370c      	adds	r7, #12
 8002ae6:	46bd      	mov	sp, r7
 8002ae8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002aec:	4770      	bx	lr

08002aee <ArchCurrCpuid>:
{
 8002aee:	b480      	push	{r7}
 8002af0:	af00      	add	r7, sp, #0
    return 0;
 8002af2:	2300      	movs	r3, #0
}
 8002af4:	4618      	mov	r0, r3
 8002af6:	46bd      	mov	sp, r7
 8002af8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002afc:	4770      	bx	lr

08002afe <LOS_IntLock>:
{
 8002afe:	b580      	push	{r7, lr}
 8002b00:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8002b02:	f7fe f8e1 	bl	8000cc8 <ArchIntLock>
 8002b06:	4603      	mov	r3, r0
}
 8002b08:	4618      	mov	r0, r3
 8002b0a:	bd80      	pop	{r7, pc}

08002b0c <LOS_IntUnLock>:
{
 8002b0c:	b580      	push	{r7, lr}
 8002b0e:	af00      	add	r7, sp, #0
    return ArchIntUnlock();
 8002b10:	f7fe f8de 	bl	8000cd0 <ArchIntUnlock>
 8002b14:	4603      	mov	r3, r0
}
 8002b16:	4618      	mov	r0, r3
 8002b18:	bd80      	pop	{r7, pc}

08002b1a <LOS_IntRestore>:
{
 8002b1a:	b580      	push	{r7, lr}
 8002b1c:	b082      	sub	sp, #8
 8002b1e:	af00      	add	r7, sp, #0
 8002b20:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8002b22:	6878      	ldr	r0, [r7, #4]
 8002b24:	f7fe f8d8 	bl	8000cd8 <ArchIntRestore>
}
 8002b28:	bf00      	nop
 8002b2a:	3708      	adds	r7, #8
 8002b2c:	46bd      	mov	sp, r7
 8002b2e:	bd80      	pop	{r7, pc}

08002b30 <ArchCurrTaskGet>:
{
 8002b30:	b480      	push	{r7}
 8002b32:	af00      	add	r7, sp, #0
    return g_runTask;
 8002b34:	4b03      	ldr	r3, [pc, #12]	; (8002b44 <ArchCurrTaskGet+0x14>)
 8002b36:	681b      	ldr	r3, [r3, #0]
}
 8002b38:	4618      	mov	r0, r3
 8002b3a:	46bd      	mov	sp, r7
 8002b3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b40:	4770      	bx	lr
 8002b42:	bf00      	nop
 8002b44:	200033cc 	.word	0x200033cc

08002b48 <OsPercpuGet>:

/* the kernel per-cpu structure */
extern Percpu g_percpu[LOSCFG_KERNEL_CORE_NUM];

STATIC INLINE Percpu *OsPercpuGet(VOID)
{
 8002b48:	b580      	push	{r7, lr}
 8002b4a:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 8002b4c:	f7ff ffcf 	bl	8002aee <ArchCurrCpuid>
 8002b50:	4602      	mov	r2, r0
 8002b52:	4613      	mov	r3, r2
 8002b54:	00db      	lsls	r3, r3, #3
 8002b56:	4413      	add	r3, r2
 8002b58:	009b      	lsls	r3, r3, #2
 8002b5a:	4a02      	ldr	r2, [pc, #8]	; (8002b64 <OsPercpuGet+0x1c>)
 8002b5c:	4413      	add	r3, r2
}
 8002b5e:	4618      	mov	r0, r3
 8002b60:	bd80      	pop	{r7, pc}
 8002b62:	bf00      	nop
 8002b64:	200036fc 	.word	0x200036fc

08002b68 <OsPreemptable>:
 * 判读正在运行的CPU 是否可以抢占。
 * 如果可以抢占，那么后面调度任务就可以把当前任务切换出去。
 * 如果不可以抢占，注意还要设置 percpu->schedFlag = INT_PEND_RESCH，表示期待合适机会调用。
 */
STATIC INLINE BOOL OsPreemptable(VOID)
{
 8002b68:	b580      	push	{r7, lr}
 8002b6a:	b082      	sub	sp, #8
 8002b6c:	af00      	add	r7, sp, #0
    /*
     * Unlike OsPreemptableInSched, the int may be not disabled when OsPreemptable
     * is called, needs manually disable interrupt, to prevent current task from
     * being migrated to another core, and get the wrong preemptable status.
     */
    UINT32 intSave = LOS_IntLock();
 8002b6e:	f7ff ffc6 	bl	8002afe <LOS_IntLock>
 8002b72:	6038      	str	r0, [r7, #0]
    BOOL preemptable = (OsPercpuGet()->taskLockCnt == 0);
 8002b74:	f7ff ffe8 	bl	8002b48 <OsPercpuGet>
 8002b78:	4603      	mov	r3, r0
 8002b7a:	695b      	ldr	r3, [r3, #20]
 8002b7c:	2b00      	cmp	r3, #0
 8002b7e:	bf0c      	ite	eq
 8002b80:	2301      	moveq	r3, #1
 8002b82:	2300      	movne	r3, #0
 8002b84:	b2db      	uxtb	r3, r3
 8002b86:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 8002b88:	687b      	ldr	r3, [r7, #4]
 8002b8a:	2b00      	cmp	r3, #0
 8002b8c:	d104      	bne.n	8002b98 <OsPreemptable+0x30>
        /* Set schedule flag if preemption is disabled */
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8002b8e:	f7ff ffdb 	bl	8002b48 <OsPercpuGet>
 8002b92:	4603      	mov	r3, r0
 8002b94:	2201      	movs	r2, #1
 8002b96:	621a      	str	r2, [r3, #32]
    }
    LOS_IntRestore(intSave);
 8002b98:	6838      	ldr	r0, [r7, #0]
 8002b9a:	f7ff ffbe 	bl	8002b1a <LOS_IntRestore>
    return preemptable;
 8002b9e:	687b      	ldr	r3, [r7, #4]
}
 8002ba0:	4618      	mov	r0, r3
 8002ba2:	3708      	adds	r7, #8
 8002ba4:	46bd      	mov	sp, r7
 8002ba6:	bd80      	pop	{r7, pc}

08002ba8 <OsPreemptableInSched>:

STATIC INLINE BOOL OsPreemptableInSched(VOID)
{
 8002ba8:	b580      	push	{r7, lr}
 8002baa:	b082      	sub	sp, #8
 8002bac:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 8002bae:	2300      	movs	r3, #0
 8002bb0:	607b      	str	r3, [r7, #4]
     * will increase by 1 in that case.
     */
    preemptable = (OsPercpuGet()->taskLockCnt == 1);

#else
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 8002bb2:	f7ff ffc9 	bl	8002b48 <OsPercpuGet>
 8002bb6:	4603      	mov	r3, r0
 8002bb8:	695b      	ldr	r3, [r3, #20]
 8002bba:	2b00      	cmp	r3, #0
 8002bbc:	bf0c      	ite	eq
 8002bbe:	2301      	moveq	r3, #1
 8002bc0:	2300      	movne	r3, #0
 8002bc2:	b2db      	uxtb	r3, r3
 8002bc4:	607b      	str	r3, [r7, #4]
#endif
    if (!preemptable) {
 8002bc6:	687b      	ldr	r3, [r7, #4]
 8002bc8:	2b00      	cmp	r3, #0
 8002bca:	d104      	bne.n	8002bd6 <OsPreemptableInSched+0x2e>
        /* Set schedule flag if preemption is disabled */
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8002bcc:	f7ff ffbc 	bl	8002b48 <OsPercpuGet>
 8002bd0:	4603      	mov	r3, r0
 8002bd2:	2201      	movs	r2, #1
 8002bd4:	621a      	str	r2, [r3, #32]
    }

    return preemptable;
 8002bd6:	687b      	ldr	r3, [r7, #4]
}
 8002bd8:	4618      	mov	r0, r3
 8002bda:	3708      	adds	r7, #8
 8002bdc:	46bd      	mov	sp, r7
 8002bde:	bd80      	pop	{r7, pc}

08002be0 <LOS_Schedule>:
 * 如果是任务到期，一定是在systick 中断里调用的。此时只做INT_PEND_RESCH 标记，期待适合机会再调度。
 * 每次中断到来，都会先处理中断注册ISR ，然后处理中断下半部。
 * 中断下半部处理任务信号后，如果INT_PEND_RESCH 标记了，就执行抢占调度(OsSchedPreempt)。
 */
STATIC INLINE VOID LOS_Schedule(VOID)
{
 8002be0:	b580      	push	{r7, lr}
 8002be2:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 8002be4:	f7ff fd3c 	bl	8002660 <IntActive>
 8002be8:	4603      	mov	r3, r0
 8002bea:	2b00      	cmp	r3, #0
 8002bec:	d005      	beq.n	8002bfa <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8002bee:	f7ff ffab 	bl	8002b48 <OsPercpuGet>
 8002bf2:	4603      	mov	r3, r0
 8002bf4:	2201      	movs	r2, #1
 8002bf6:	621a      	str	r2, [r3, #32]
        return;
 8002bf8:	e001      	b.n	8002bfe <LOS_Schedule+0x1e>
    /*
     * trigger schedule in task will also do the slice check
     * if necessary, it will give up the timeslice more in time.
     * otherwise, there's no other side effects.
     */
    OsSchedPreempt();
 8002bfa:	f006 f89b 	bl	8008d34 <OsSchedPreempt>
}
 8002bfe:	bd80      	pop	{r7, pc}

08002c00 <LOS_SpinLock>:
{
 8002c00:	b480      	push	{r7}
 8002c02:	b083      	sub	sp, #12
 8002c04:	af00      	add	r7, sp, #0
 8002c06:	6078      	str	r0, [r7, #4]
}
 8002c08:	bf00      	nop
 8002c0a:	370c      	adds	r7, #12
 8002c0c:	46bd      	mov	sp, r7
 8002c0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c12:	4770      	bx	lr

08002c14 <LOS_SpinUnlock>:
{
 8002c14:	b480      	push	{r7}
 8002c16:	b083      	sub	sp, #12
 8002c18:	af00      	add	r7, sp, #0
 8002c1a:	6078      	str	r0, [r7, #4]
}
 8002c1c:	bf00      	nop
 8002c1e:	370c      	adds	r7, #12
 8002c20:	46bd      	mov	sp, r7
 8002c22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c26:	4770      	bx	lr

08002c28 <LOS_SpinLockSave>:
{
 8002c28:	b580      	push	{r7, lr}
 8002c2a:	b082      	sub	sp, #8
 8002c2c:	af00      	add	r7, sp, #0
 8002c2e:	6078      	str	r0, [r7, #4]
 8002c30:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8002c32:	f7ff ff64 	bl	8002afe <LOS_IntLock>
 8002c36:	4602      	mov	r2, r0
 8002c38:	683b      	ldr	r3, [r7, #0]
 8002c3a:	601a      	str	r2, [r3, #0]
}
 8002c3c:	bf00      	nop
 8002c3e:	3708      	adds	r7, #8
 8002c40:	46bd      	mov	sp, r7
 8002c42:	bd80      	pop	{r7, pc}

08002c44 <LOS_SpinUnlockRestore>:
{
 8002c44:	b580      	push	{r7, lr}
 8002c46:	b082      	sub	sp, #8
 8002c48:	af00      	add	r7, sp, #0
 8002c4a:	6078      	str	r0, [r7, #4]
 8002c4c:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8002c4e:	6838      	ldr	r0, [r7, #0]
 8002c50:	f7ff ff63 	bl	8002b1a <LOS_IntRestore>
}
 8002c54:	bf00      	nop
 8002c56:	3708      	adds	r7, #8
 8002c58:	46bd      	mov	sp, r7
 8002c5a:	bd80      	pop	{r7, pc}

08002c5c <LOS_SpinHeld>:

LITE_OS_SEC_ALW_INLINE STATIC INLINE BOOL LOS_SpinHeld(const SPIN_LOCK_S *lock)
{
 8002c5c:	b480      	push	{r7}
 8002c5e:	b083      	sub	sp, #12
 8002c60:	af00      	add	r7, sp, #0
 8002c62:	6078      	str	r0, [r7, #4]
    (VOID)lock;
    return TRUE;
 8002c64:	2301      	movs	r3, #1
}
 8002c66:	4618      	mov	r0, r3
 8002c68:	370c      	adds	r7, #12
 8002c6a:	46bd      	mov	sp, r7
 8002c6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c70:	4770      	bx	lr

08002c72 <OsCurrTaskGet>:
{
 8002c72:	b580      	push	{r7, lr}
 8002c74:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 8002c76:	f7ff ff5b 	bl	8002b30 <ArchCurrTaskGet>
 8002c7a:	4603      	mov	r3, r0
}
 8002c7c:	4618      	mov	r0, r3
 8002c7e:	bd80      	pop	{r7, pc}

08002c80 <OsMuxDlockCheckInitHook>:
#endif /* __cplusplus */

/* Deadlock detection initialization interface */
extern UINT32 OsMuxDlockCheckInit(VOID);
STATIC INLINE UINT32 OsMuxDlockCheckInitHook(VOID)
{
 8002c80:	b580      	push	{r7, lr}
 8002c82:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_MUTEX_DEADLOCK
    return OsMuxDlockCheckInit();
 8002c84:	f003 fe1a 	bl	80068bc <OsMuxDlockCheckInit>
 8002c88:	4603      	mov	r3, r0
#else
    return LOS_OK;
#endif
}
 8002c8a:	4618      	mov	r0, r3
 8002c8c:	bd80      	pop	{r7, pc}

08002c8e <LOS_MpSchedule>:
extern VOID OsMpScheduleHandler(VOID);
extern VOID OsMpHaltHandler(VOID);
extern UINT32 OsMpInit(VOID);
#else
STATIC INLINE VOID LOS_MpSchedule(UINT32 target)
{
 8002c8e:	b480      	push	{r7}
 8002c90:	b083      	sub	sp, #12
 8002c92:	af00      	add	r7, sp, #0
 8002c94:	6078      	str	r0, [r7, #4]
    (VOID)target;
}
 8002c96:	bf00      	nop
 8002c98:	370c      	adds	r7, #12
 8002c9a:	46bd      	mov	sp, r7
 8002c9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ca0:	4770      	bx	lr
	...

08002ca4 <OsTaskCBRecycleToFree>:
    g_taskDelHook = hook;
}
#endif

LITE_OS_SEC_TEXT_INIT STATIC VOID OsTaskCBRecycleToFree(VOID)
{
 8002ca4:	b580      	push	{r7, lr}
 8002ca6:	b082      	sub	sp, #8
 8002ca8:	af00      	add	r7, sp, #0
    LosTaskCB *taskCB = NULL;
 8002caa:	2300      	movs	r3, #0
 8002cac:	603b      	str	r3, [r7, #0]
    VOID *poolTmp = NULL;
 8002cae:	2300      	movs	r3, #0
 8002cb0:	607b      	str	r3, [r7, #4]
#ifdef LOSCFG_TASK_STACK_PROTECT
    UINTPTR MMUProtectAddr;
#endif
    while (!LOS_ListEmpty(&g_taskRecycleList)) {
 8002cb2:	e01a      	b.n	8002cea <OsTaskCBRecycleToFree+0x46>
        poolTmp = (VOID *)m_aucSysMem1;
 8002cb4:	4b12      	ldr	r3, [pc, #72]	; (8002d00 <OsTaskCBRecycleToFree+0x5c>)
 8002cb6:	681b      	ldr	r3, [r3, #0]
 8002cb8:	607b      	str	r3, [r7, #4]
        taskCB = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&g_taskRecycleList));
 8002cba:	4b12      	ldr	r3, [pc, #72]	; (8002d04 <OsTaskCBRecycleToFree+0x60>)
 8002cbc:	685b      	ldr	r3, [r3, #4]
 8002cbe:	3b40      	subs	r3, #64	; 0x40
 8002cc0:	603b      	str	r3, [r7, #0]
        LOS_ListDelete(LOS_DL_LIST_FIRST(&g_taskRecycleList));
 8002cc2:	4b10      	ldr	r3, [pc, #64]	; (8002d04 <OsTaskCBRecycleToFree+0x60>)
 8002cc4:	685b      	ldr	r3, [r3, #4]
 8002cc6:	4618      	mov	r0, r3
 8002cc8:	f7ff fee5 	bl	8002a96 <LOS_ListDelete>
        LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
 8002ccc:	683b      	ldr	r3, [r7, #0]
 8002cce:	3340      	adds	r3, #64	; 0x40
 8002cd0:	4619      	mov	r1, r3
 8002cd2:	480d      	ldr	r0, [pc, #52]	; (8002d08 <OsTaskCBRecycleToFree+0x64>)
 8002cd4:	f7ff feb7 	bl	8002a46 <LOS_ListAdd>
#ifdef LOSCFG_EXC_INTERACTION
        if (taskCB->topOfStack < (UINTPTR)m_aucSysMem1) {
            poolTmp = (VOID *)m_aucSysMem0;
        }
#endif
        (VOID)LOS_MemFree(poolTmp, (VOID *)taskCB->topOfStack);
 8002cd8:	683b      	ldr	r3, [r7, #0]
 8002cda:	691b      	ldr	r3, [r3, #16]
 8002cdc:	4619      	mov	r1, r3
 8002cde:	6878      	ldr	r0, [r7, #4]
 8002ce0:	f006 fc50 	bl	8009584 <LOS_MemFree>
#endif
        taskCB->topOfStack = 0;
 8002ce4:	683b      	ldr	r3, [r7, #0]
 8002ce6:	2200      	movs	r2, #0
 8002ce8:	611a      	str	r2, [r3, #16]
    while (!LOS_ListEmpty(&g_taskRecycleList)) {
 8002cea:	4806      	ldr	r0, [pc, #24]	; (8002d04 <OsTaskCBRecycleToFree+0x60>)
 8002cec:	f7ff feed 	bl	8002aca <LOS_ListEmpty>
 8002cf0:	4603      	mov	r3, r0
 8002cf2:	2b00      	cmp	r3, #0
 8002cf4:	d0de      	beq.n	8002cb4 <OsTaskCBRecycleToFree+0x10>
    }
}
 8002cf6:	bf00      	nop
 8002cf8:	bf00      	nop
 8002cfa:	3708      	adds	r7, #8
 8002cfc:	46bd      	mov	sp, r7
 8002cfe:	bd80      	pop	{r7, pc}
 8002d00:	200021c0 	.word	0x200021c0
 8002d04:	200036c8 	.word	0x200036c8
 8002d08:	200036d0 	.word	0x200036d0

08002d0c <LOS_TaskResRecycle>:

VOID LOS_TaskResRecycle(VOID)
{
 8002d0c:	b580      	push	{r7, lr}
 8002d0e:	b082      	sub	sp, #8
 8002d10:	af00      	add	r7, sp, #0
 8002d12:	4b0e      	ldr	r3, [pc, #56]	; (8002d4c <LOS_TaskResRecycle+0x40>)
 8002d14:	681b      	ldr	r3, [r3, #0]
 8002d16:	607b      	str	r3, [r7, #4]
 8002d18:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    SCHEDULER_LOCK(intSave);
 8002d1c:	463b      	mov	r3, r7
 8002d1e:	4619      	mov	r1, r3
 8002d20:	480b      	ldr	r0, [pc, #44]	; (8002d50 <LOS_TaskResRecycle+0x44>)
 8002d22:	f7ff ff81 	bl	8002c28 <LOS_SpinLockSave>
    OsTaskCBRecycleToFree();
 8002d26:	f7ff ffbd 	bl	8002ca4 <OsTaskCBRecycleToFree>
    SCHEDULER_UNLOCK(intSave);
 8002d2a:	683b      	ldr	r3, [r7, #0]
 8002d2c:	4619      	mov	r1, r3
 8002d2e:	4808      	ldr	r0, [pc, #32]	; (8002d50 <LOS_TaskResRecycle+0x44>)
 8002d30:	f7ff ff88 	bl	8002c44 <LOS_SpinUnlockRestore>
}
 8002d34:	bf00      	nop
 8002d36:	4b05      	ldr	r3, [pc, #20]	; (8002d4c <LOS_TaskResRecycle+0x40>)
 8002d38:	681a      	ldr	r2, [r3, #0]
 8002d3a:	687b      	ldr	r3, [r7, #4]
 8002d3c:	405a      	eors	r2, r3
 8002d3e:	d001      	beq.n	8002d44 <LOS_TaskResRecycle+0x38>
 8002d40:	f001 fc4c 	bl	80045dc <__stack_chk_fail>
 8002d44:	3708      	adds	r7, #8
 8002d46:	46bd      	mov	sp, r7
 8002d48:	bd80      	pop	{r7, pc}
 8002d4a:	bf00      	nop
 8002d4c:	08020058 	.word	0x08020058
 8002d50:	20000770 	.word	0x20000770

08002d54 <OsIdleTask>:
    return FALSE;
}
#endif

LITE_OS_SEC_TEXT WEAK VOID OsIdleTask(VOID)
{
 8002d54:	b580      	push	{r7, lr}
 8002d56:	af00      	add	r7, sp, #0
    while (1) {
        LOS_TaskResRecycle();
 8002d58:	f7ff ffd8 	bl	8002d0c <LOS_TaskResRecycle>

        if (g_idleHandlerHook != NULL) {
 8002d5c:	4b07      	ldr	r3, [pc, #28]	; (8002d7c <OsIdleTask+0x28>)
 8002d5e:	681b      	ldr	r3, [r3, #0]
 8002d60:	2b00      	cmp	r3, #0
 8002d62:	d002      	beq.n	8002d6a <OsIdleTask+0x16>
            g_idleHandlerHook();
 8002d64:	4b05      	ldr	r3, [pc, #20]	; (8002d7c <OsIdleTask+0x28>)
 8002d66:	681b      	ldr	r3, [r3, #0]
 8002d68:	4798      	blx	r3
        }

#ifdef LOSCFG_KERNEL_LOWPOWER
        if (g_lowPowerHook != NULL) {
 8002d6a:	4b05      	ldr	r3, [pc, #20]	; (8002d80 <OsIdleTask+0x2c>)
 8002d6c:	681b      	ldr	r3, [r3, #0]
 8002d6e:	2b00      	cmp	r3, #0
 8002d70:	d0f2      	beq.n	8002d58 <OsIdleTask+0x4>
            g_lowPowerHook();
 8002d72:	4b03      	ldr	r3, [pc, #12]	; (8002d80 <OsIdleTask+0x2c>)
 8002d74:	681b      	ldr	r3, [r3, #0]
 8002d76:	4798      	blx	r3
        LOS_TaskResRecycle();
 8002d78:	e7ee      	b.n	8002d58 <OsIdleTask+0x4>
 8002d7a:	bf00      	nop
 8002d7c:	2000077c 	.word	0x2000077c
 8002d80:	20000778 	.word	0x20000778

08002d84 <OsTaskPriModify>:
 * Description : Change task priority.
 * Input       : taskCB    --- task control block
 *               priority  --- priority
 */
LITE_OS_SEC_TEXT_MINOR VOID OsTaskPriModify(LosTaskCB *taskCB, UINT16 priority)
{
 8002d84:	b590      	push	{r4, r7, lr}
 8002d86:	b08b      	sub	sp, #44	; 0x2c
 8002d88:	af00      	add	r7, sp, #0
 8002d8a:	6078      	str	r0, [r7, #4]
 8002d8c:	460b      	mov	r3, r1
 8002d8e:	807b      	strh	r3, [r7, #2]
 8002d90:	4b32      	ldr	r3, [pc, #200]	; (8002e5c <OsTaskPriModify+0xd8>)
 8002d92:	681b      	ldr	r3, [r3, #0]
 8002d94:	627b      	str	r3, [r7, #36]	; 0x24
 8002d96:	f04f 0300 	mov.w	r3, #0
    LOS_ASSERT(LOS_SpinHeld(&g_taskSpin));
 8002d9a:	4831      	ldr	r0, [pc, #196]	; (8002e60 <OsTaskPriModify+0xdc>)
 8002d9c:	f7ff ff5e 	bl	8002c5c <LOS_SpinHeld>
 8002da0:	4603      	mov	r3, r0
 8002da2:	2b00      	cmp	r3, #0
 8002da4:	d10b      	bne.n	8002dbe <OsTaskPriModify+0x3a>
 8002da6:	f7ff feaa 	bl	8002afe <LOS_IntLock>
 8002daa:	482e      	ldr	r0, [pc, #184]	; (8002e64 <OsTaskPriModify+0xe0>)
 8002dac:	f001 fd88 	bl	80048c0 <dprintf>
 8002db0:	4b2d      	ldr	r3, [pc, #180]	; (8002e68 <OsTaskPriModify+0xe4>)
 8002db2:	22b1      	movs	r2, #177	; 0xb1
 8002db4:	492d      	ldr	r1, [pc, #180]	; (8002e6c <OsTaskPriModify+0xe8>)
 8002db6:	482e      	ldr	r0, [pc, #184]	; (8002e70 <OsTaskPriModify+0xec>)
 8002db8:	f001 fd82 	bl	80048c0 <dprintf>
 8002dbc:	e7fe      	b.n	8002dbc <OsTaskPriModify+0x38>

    LOS_TRACE(TASK_PRIOSET, taskCB->taskId, taskCB->taskStatus, taskCB->priority, priority);
 8002dbe:	2300      	movs	r3, #0
 8002dc0:	613b      	str	r3, [r7, #16]
 8002dc2:	687b      	ldr	r3, [r7, #4]
 8002dc4:	695b      	ldr	r3, [r3, #20]
 8002dc6:	617b      	str	r3, [r7, #20]
 8002dc8:	687b      	ldr	r3, [r7, #4]
 8002dca:	889b      	ldrh	r3, [r3, #4]
 8002dcc:	61bb      	str	r3, [r7, #24]
 8002dce:	687b      	ldr	r3, [r7, #4]
 8002dd0:	88db      	ldrh	r3, [r3, #6]
 8002dd2:	61fb      	str	r3, [r7, #28]
 8002dd4:	887b      	ldrh	r3, [r7, #2]
 8002dd6:	623b      	str	r3, [r7, #32]
 8002dd8:	2305      	movs	r3, #5
 8002dda:	60fb      	str	r3, [r7, #12]
 8002ddc:	68fb      	ldr	r3, [r7, #12]
 8002dde:	2b01      	cmp	r3, #1
 8002de0:	d915      	bls.n	8002e0e <OsTaskPriModify+0x8a>
 8002de2:	4b24      	ldr	r3, [pc, #144]	; (8002e74 <OsTaskPriModify+0xf0>)
 8002de4:	681b      	ldr	r3, [r3, #0]
 8002de6:	2b00      	cmp	r3, #0
 8002de8:	d011      	beq.n	8002e0e <OsTaskPriModify+0x8a>
 8002dea:	4b22      	ldr	r3, [pc, #136]	; (8002e74 <OsTaskPriModify+0xf0>)
 8002dec:	681c      	ldr	r4, [r3, #0]
 8002dee:	6979      	ldr	r1, [r7, #20]
 8002df0:	68fb      	ldr	r3, [r7, #12]
 8002df2:	2b02      	cmp	r3, #2
 8002df4:	d904      	bls.n	8002e00 <OsTaskPriModify+0x7c>
 8002df6:	f107 0310 	add.w	r3, r7, #16
 8002dfa:	f103 0208 	add.w	r2, r3, #8
 8002dfe:	e000      	b.n	8002e02 <OsTaskPriModify+0x7e>
 8002e00:	2200      	movs	r2, #0
 8002e02:	68fb      	ldr	r3, [r7, #12]
 8002e04:	b29b      	uxth	r3, r3
 8002e06:	3b02      	subs	r3, #2
 8002e08:	b29b      	uxth	r3, r3
 8002e0a:	2041      	movs	r0, #65	; 0x41
 8002e0c:	47a0      	blx	r4

    if (taskCB->taskStatus & OS_TASK_STATUS_READY) {
 8002e0e:	687b      	ldr	r3, [r7, #4]
 8002e10:	889b      	ldrh	r3, [r3, #4]
 8002e12:	f003 0304 	and.w	r3, r3, #4
 8002e16:	2b00      	cmp	r3, #0
 8002e18:	d011      	beq.n	8002e3e <OsTaskPriModify+0xba>
        OsPriQueueDequeue(&taskCB->pendList);
 8002e1a:	687b      	ldr	r3, [r7, #4]
 8002e1c:	3340      	adds	r3, #64	; 0x40
 8002e1e:	4618      	mov	r0, r3
 8002e20:	f006 f936 	bl	8009090 <OsPriQueueDequeue>
        taskCB->priority = priority;
 8002e24:	687b      	ldr	r3, [r7, #4]
 8002e26:	887a      	ldrh	r2, [r7, #2]
 8002e28:	80da      	strh	r2, [r3, #6]
        OsPriQueueEnqueue(&taskCB->pendList, taskCB->priority);
 8002e2a:	687b      	ldr	r3, [r7, #4]
 8002e2c:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8002e30:	687b      	ldr	r3, [r7, #4]
 8002e32:	88db      	ldrh	r3, [r3, #6]
 8002e34:	4619      	mov	r1, r3
 8002e36:	4610      	mov	r0, r2
 8002e38:	f006 f8e8 	bl	800900c <OsPriQueueEnqueue>
    } else {
        taskCB->priority = priority;
    }
}
 8002e3c:	e002      	b.n	8002e44 <OsTaskPriModify+0xc0>
        taskCB->priority = priority;
 8002e3e:	687b      	ldr	r3, [r7, #4]
 8002e40:	887a      	ldrh	r2, [r7, #2]
 8002e42:	80da      	strh	r2, [r3, #6]
}
 8002e44:	bf00      	nop
 8002e46:	4b05      	ldr	r3, [pc, #20]	; (8002e5c <OsTaskPriModify+0xd8>)
 8002e48:	681a      	ldr	r2, [r3, #0]
 8002e4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002e4c:	405a      	eors	r2, r3
 8002e4e:	d001      	beq.n	8002e54 <OsTaskPriModify+0xd0>
 8002e50:	f001 fbc4 	bl	80045dc <__stack_chk_fail>
 8002e54:	372c      	adds	r7, #44	; 0x2c
 8002e56:	46bd      	mov	sp, r7
 8002e58:	bd90      	pop	{r4, r7, pc}
 8002e5a:	bf00      	nop
 8002e5c:	0802008c 	.word	0x0802008c
 8002e60:	20000770 	.word	0x20000770
 8002e64:	0802005c 	.word	0x0802005c
 8002e68:	080232c4 	.word	0x080232c4
 8002e6c:	08020064 	.word	0x08020064
 8002e70:	08020070 	.word	0x08020070
 8002e74:	20000768 	.word	0x20000768

08002e78 <OsTaskAdd2TimerList>:
 * Description : Add task to sorted delay list.
 * Input       : taskCB  --- task control block
 *               timeout --- wait time, ticks
 */
LITE_OS_SEC_TEXT VOID OsTaskAdd2TimerList(LosTaskCB *taskCB, UINT32 timeout)
{
 8002e78:	b580      	push	{r7, lr}
 8002e7a:	b082      	sub	sp, #8
 8002e7c:	af00      	add	r7, sp, #0
 8002e7e:	6078      	str	r0, [r7, #4]
 8002e80:	6039      	str	r1, [r7, #0]
    SET_SORTLIST_VALUE(&(taskCB->sortList), timeout);
 8002e82:	687b      	ldr	r3, [r7, #4]
 8002e84:	683a      	ldr	r2, [r7, #0]
 8002e86:	651a      	str	r2, [r3, #80]	; 0x50
    OsAdd2SortLink(&OsPercpuGet()->taskSortLink, &taskCB->sortList);
 8002e88:	f7ff fe5e 	bl	8002b48 <OsPercpuGet>
 8002e8c:	4603      	mov	r3, r0
 8002e8e:	461a      	mov	r2, r3
 8002e90:	687b      	ldr	r3, [r7, #4]
 8002e92:	3348      	adds	r3, #72	; 0x48
 8002e94:	4619      	mov	r1, r3
 8002e96:	4610      	mov	r0, r2
 8002e98:	f007 f96e 	bl	800a178 <OsAdd2SortLink>
#ifdef LOSCFG_KERNEL_SMP
    taskCB->timerCpu = ArchCurrCpuid();
#endif
}
 8002e9c:	bf00      	nop
 8002e9e:	3708      	adds	r7, #8
 8002ea0:	46bd      	mov	sp, r7
 8002ea2:	bd80      	pop	{r7, pc}

08002ea4 <OsTimerListDelete>:

LITE_OS_SEC_TEXT VOID OsTimerListDelete(LosTaskCB *taskCB)
{
 8002ea4:	b580      	push	{r7, lr}
 8002ea6:	b084      	sub	sp, #16
 8002ea8:	af00      	add	r7, sp, #0
 8002eaa:	6078      	str	r0, [r7, #4]
    SortLinkAttribute *sortLinkHeader = NULL;
 8002eac:	2300      	movs	r3, #0
 8002eae:	60fb      	str	r3, [r7, #12]
     * the task delay timer is on the specific processor,
     * we need delete the timer from that processor's sortlink.
     */
    sortLinkHeader = &g_percpu[taskCB->timerCpu].taskSortLink;
#else
    sortLinkHeader = &g_percpu[0].taskSortLink;
 8002eb0:	4b05      	ldr	r3, [pc, #20]	; (8002ec8 <OsTimerListDelete+0x24>)
 8002eb2:	60fb      	str	r3, [r7, #12]
#endif
    OsDeleteSortLink(sortLinkHeader, &taskCB->sortList);
 8002eb4:	687b      	ldr	r3, [r7, #4]
 8002eb6:	3348      	adds	r3, #72	; 0x48
 8002eb8:	4619      	mov	r1, r3
 8002eba:	68f8      	ldr	r0, [r7, #12]
 8002ebc:	f007 fa06 	bl	800a2cc <OsDeleteSortLink>
}
 8002ec0:	bf00      	nop
 8002ec2:	3710      	adds	r7, #16
 8002ec4:	46bd      	mov	sp, r7
 8002ec6:	bd80      	pop	{r7, pc}
 8002ec8:	200036fc 	.word	0x200036fc

08002ecc <OsTaskScan>:

LITE_OS_SEC_TEXT VOID OsTaskScan(VOID)
{
 8002ecc:	b580      	push	{r7, lr}
 8002ece:	b086      	sub	sp, #24
 8002ed0:	af00      	add	r7, sp, #0
    SortLinkList *sortList = NULL;
 8002ed2:	2300      	movs	r3, #0
 8002ed4:	607b      	str	r3, [r7, #4]
    LosTaskCB *taskCB = NULL;
 8002ed6:	2300      	movs	r3, #0
 8002ed8:	60fb      	str	r3, [r7, #12]
    BOOL needSchedule = FALSE;
 8002eda:	2300      	movs	r3, #0
 8002edc:	60bb      	str	r3, [r7, #8]
    UINT16 tempStatus;
    LOS_DL_LIST *listObject = NULL;
 8002ede:	2300      	movs	r3, #0
 8002ee0:	613b      	str	r3, [r7, #16]
    SortLinkAttribute *taskSortLink = NULL;
 8002ee2:	2300      	movs	r3, #0
 8002ee4:	617b      	str	r3, [r7, #20]

    taskSortLink = &OsPercpuGet()->taskSortLink;
 8002ee6:	f7ff fe2f 	bl	8002b48 <OsPercpuGet>
 8002eea:	4603      	mov	r3, r0
 8002eec:	617b      	str	r3, [r7, #20]
    SORTLINK_CURSOR_UPDATE(taskSortLink->cursor);
 8002eee:	697b      	ldr	r3, [r7, #20]
 8002ef0:	889b      	ldrh	r3, [r3, #4]
 8002ef2:	3301      	adds	r3, #1
 8002ef4:	b29b      	uxth	r3, r3
 8002ef6:	f003 0307 	and.w	r3, r3, #7
 8002efa:	b29a      	uxth	r2, r3
 8002efc:	697b      	ldr	r3, [r7, #20]
 8002efe:	809a      	strh	r2, [r3, #4]
    SORTLINK_LISTOBJ_GET(listObject, taskSortLink);
 8002f00:	697b      	ldr	r3, [r7, #20]
 8002f02:	681a      	ldr	r2, [r3, #0]
 8002f04:	697b      	ldr	r3, [r7, #20]
 8002f06:	889b      	ldrh	r3, [r3, #4]
 8002f08:	00db      	lsls	r3, r3, #3
 8002f0a:	4413      	add	r3, r2
 8002f0c:	613b      	str	r3, [r7, #16]
     * up by either timeout or corresponding ipc it's waiting.
     *
     * Now synchronize sortlink procedure is used, therefore the whole task scan needs
     * to be protected, preventing another core from doing sortlink deletion at same time.
     */
    LOS_SpinLock(&g_taskSpin);
 8002f0e:	4841      	ldr	r0, [pc, #260]	; (8003014 <OsTaskScan+0x148>)
 8002f10:	f7ff fe76 	bl	8002c00 <LOS_SpinLock>

    if (LOS_ListEmpty(listObject)) {
 8002f14:	6938      	ldr	r0, [r7, #16]
 8002f16:	f7ff fdd8 	bl	8002aca <LOS_ListEmpty>
 8002f1a:	4603      	mov	r3, r0
 8002f1c:	2b00      	cmp	r3, #0
 8002f1e:	d003      	beq.n	8002f28 <OsTaskScan+0x5c>
        LOS_SpinUnlock(&g_taskSpin);
 8002f20:	483c      	ldr	r0, [pc, #240]	; (8003014 <OsTaskScan+0x148>)
 8002f22:	f7ff fe77 	bl	8002c14 <LOS_SpinUnlock>
        return;
 8002f26:	e072      	b.n	800300e <OsTaskScan+0x142>
    }
    sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 8002f28:	693b      	ldr	r3, [r7, #16]
 8002f2a:	685b      	ldr	r3, [r3, #4]
 8002f2c:	607b      	str	r3, [r7, #4]
    ROLLNUM_DEC(sortList->idxRollNum);
 8002f2e:	687b      	ldr	r3, [r7, #4]
 8002f30:	689b      	ldr	r3, [r3, #8]
 8002f32:	1e5a      	subs	r2, r3, #1
 8002f34:	687b      	ldr	r3, [r7, #4]
 8002f36:	609a      	str	r2, [r3, #8]

    while (ROLLNUM(sortList->idxRollNum) == 0) {
 8002f38:	e056      	b.n	8002fe8 <OsTaskScan+0x11c>
        LOS_ListDelete(&sortList->sortLinkNode);
 8002f3a:	687b      	ldr	r3, [r7, #4]
 8002f3c:	4618      	mov	r0, r3
 8002f3e:	f7ff fdaa 	bl	8002a96 <LOS_ListDelete>
        taskCB = LOS_DL_LIST_ENTRY(sortList, LosTaskCB, sortList);
 8002f42:	687b      	ldr	r3, [r7, #4]
 8002f44:	3b48      	subs	r3, #72	; 0x48
 8002f46:	60fb      	str	r3, [r7, #12]
        taskCB->taskStatus &= ~OS_TASK_STATUS_PEND_TIME;
 8002f48:	68fb      	ldr	r3, [r7, #12]
 8002f4a:	889b      	ldrh	r3, [r3, #4]
 8002f4c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002f50:	b29a      	uxth	r2, r3
 8002f52:	68fb      	ldr	r3, [r7, #12]
 8002f54:	809a      	strh	r2, [r3, #4]
        tempStatus = taskCB->taskStatus;
 8002f56:	68fb      	ldr	r3, [r7, #12]
 8002f58:	889b      	ldrh	r3, [r3, #4]
 8002f5a:	807b      	strh	r3, [r7, #2]
        if (tempStatus & OS_TASK_STATUS_PEND) {
 8002f5c:	887b      	ldrh	r3, [r7, #2]
 8002f5e:	f003 0308 	and.w	r3, r3, #8
 8002f62:	2b00      	cmp	r3, #0
 8002f64:	d019      	beq.n	8002f9a <OsTaskScan+0xce>
            taskCB->taskStatus &= ~OS_TASK_STATUS_PEND;
 8002f66:	68fb      	ldr	r3, [r7, #12]
 8002f68:	889b      	ldrh	r3, [r3, #4]
 8002f6a:	f023 0308 	bic.w	r3, r3, #8
 8002f6e:	b29a      	uxth	r2, r3
 8002f70:	68fb      	ldr	r3, [r7, #12]
 8002f72:	809a      	strh	r2, [r3, #4]
            taskCB->taskStatus |= OS_TASK_STATUS_TIMEOUT;
 8002f74:	68fb      	ldr	r3, [r7, #12]
 8002f76:	889b      	ldrh	r3, [r3, #4]
 8002f78:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002f7c:	b29a      	uxth	r2, r3
 8002f7e:	68fb      	ldr	r3, [r7, #12]
 8002f80:	809a      	strh	r2, [r3, #4]
            LOS_ListDelete(&taskCB->pendList);
 8002f82:	68fb      	ldr	r3, [r7, #12]
 8002f84:	3340      	adds	r3, #64	; 0x40
 8002f86:	4618      	mov	r0, r3
 8002f88:	f7ff fd85 	bl	8002a96 <LOS_ListDelete>
            taskCB->taskSem = NULL;
 8002f8c:	68fb      	ldr	r3, [r7, #12]
 8002f8e:	2200      	movs	r2, #0
 8002f90:	61da      	str	r2, [r3, #28]
            taskCB->taskMux = NULL;
 8002f92:	68fb      	ldr	r3, [r7, #12]
 8002f94:	2200      	movs	r2, #0
 8002f96:	629a      	str	r2, [r3, #40]	; 0x28
 8002f98:	e006      	b.n	8002fa8 <OsTaskScan+0xdc>
        } else {
            taskCB->taskStatus &= ~OS_TASK_STATUS_DELAY;
 8002f9a:	68fb      	ldr	r3, [r7, #12]
 8002f9c:	889b      	ldrh	r3, [r3, #4]
 8002f9e:	f023 0320 	bic.w	r3, r3, #32
 8002fa2:	b29a      	uxth	r2, r3
 8002fa4:	68fb      	ldr	r3, [r7, #12]
 8002fa6:	809a      	strh	r2, [r3, #4]
        }

        if (!(tempStatus & OS_TASK_STATUS_SUSPEND)) {
 8002fa8:	887b      	ldrh	r3, [r7, #2]
 8002faa:	f003 0302 	and.w	r3, r3, #2
 8002fae:	2b00      	cmp	r3, #0
 8002fb0:	d111      	bne.n	8002fd6 <OsTaskScan+0x10a>
            taskCB->taskStatus |= OS_TASK_STATUS_READY;
 8002fb2:	68fb      	ldr	r3, [r7, #12]
 8002fb4:	889b      	ldrh	r3, [r3, #4]
 8002fb6:	f043 0304 	orr.w	r3, r3, #4
 8002fba:	b29a      	uxth	r2, r3
 8002fbc:	68fb      	ldr	r3, [r7, #12]
 8002fbe:	809a      	strh	r2, [r3, #4]
            OsPriQueueEnqueue(&taskCB->pendList, taskCB->priority);
 8002fc0:	68fb      	ldr	r3, [r7, #12]
 8002fc2:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8002fc6:	68fb      	ldr	r3, [r7, #12]
 8002fc8:	88db      	ldrh	r3, [r3, #6]
 8002fca:	4619      	mov	r1, r3
 8002fcc:	4610      	mov	r0, r2
 8002fce:	f006 f81d 	bl	800900c <OsPriQueueEnqueue>
            needSchedule = TRUE;
 8002fd2:	2301      	movs	r3, #1
 8002fd4:	60bb      	str	r3, [r7, #8]
        }

        if (LOS_ListEmpty(listObject)) {
 8002fd6:	6938      	ldr	r0, [r7, #16]
 8002fd8:	f7ff fd77 	bl	8002aca <LOS_ListEmpty>
 8002fdc:	4603      	mov	r3, r0
 8002fde:	2b00      	cmp	r3, #0
 8002fe0:	d109      	bne.n	8002ff6 <OsTaskScan+0x12a>
            break;
        }

        sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 8002fe2:	693b      	ldr	r3, [r7, #16]
 8002fe4:	685b      	ldr	r3, [r3, #4]
 8002fe6:	607b      	str	r3, [r7, #4]
    while (ROLLNUM(sortList->idxRollNum) == 0) {
 8002fe8:	687b      	ldr	r3, [r7, #4]
 8002fea:	689b      	ldr	r3, [r3, #8]
 8002fec:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8002ff0:	2b00      	cmp	r3, #0
 8002ff2:	d0a2      	beq.n	8002f3a <OsTaskScan+0x6e>
 8002ff4:	e000      	b.n	8002ff8 <OsTaskScan+0x12c>
            break;
 8002ff6:	bf00      	nop
    }

    LOS_SpinUnlock(&g_taskSpin);
 8002ff8:	4806      	ldr	r0, [pc, #24]	; (8003014 <OsTaskScan+0x148>)
 8002ffa:	f7ff fe0b 	bl	8002c14 <LOS_SpinUnlock>

    if (needSchedule != FALSE) {
 8002ffe:	68bb      	ldr	r3, [r7, #8]
 8003000:	2b00      	cmp	r3, #0
 8003002:	d004      	beq.n	800300e <OsTaskScan+0x142>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 8003004:	2001      	movs	r0, #1
 8003006:	f7ff fe42 	bl	8002c8e <LOS_MpSchedule>
        LOS_Schedule();
 800300a:	f7ff fde9 	bl	8002be0 <LOS_Schedule>
    }
}
 800300e:	3718      	adds	r7, #24
 8003010:	46bd      	mov	sp, r7
 8003012:	bd80      	pop	{r7, pc}
 8003014:	20000770 	.word	0x20000770

08003018 <OsTaskInit>:

LITE_OS_SEC_TEXT_INIT UINT32 OsTaskInit(VOID)
{
 8003018:	b580      	push	{r7, lr}
 800301a:	b084      	sub	sp, #16
 800301c:	af00      	add	r7, sp, #0
    UINT32 index;
    UINT32 ret;
    UINT32 size;

    size = (KERNEL_TSK_LIMIT + 1) * sizeof(LosTaskCB);
 800301e:	f44f 632a 	mov.w	r3, #2720	; 0xaa0
 8003022:	60bb      	str	r3, [r7, #8]
    /*
     * This memory is resident memory and is used to save the system resources
     * of task control block and will not be freed.
     */
    g_taskCBArray = (LosTaskCB *)LOS_MemAlloc(m_aucSysMem0, size);
 8003024:	4b3b      	ldr	r3, [pc, #236]	; (8003114 <OsTaskInit+0xfc>)
 8003026:	681b      	ldr	r3, [r3, #0]
 8003028:	68b9      	ldr	r1, [r7, #8]
 800302a:	4618      	mov	r0, r3
 800302c:	f006 f9f2 	bl	8009414 <LOS_MemAlloc>
 8003030:	4603      	mov	r3, r0
 8003032:	4a39      	ldr	r2, [pc, #228]	; (8003118 <OsTaskInit+0x100>)
 8003034:	6013      	str	r3, [r2, #0]
    if (g_taskCBArray == NULL) {
 8003036:	4b38      	ldr	r3, [pc, #224]	; (8003118 <OsTaskInit+0x100>)
 8003038:	681b      	ldr	r3, [r3, #0]
 800303a:	2b00      	cmp	r3, #0
 800303c:	d101      	bne.n	8003042 <OsTaskInit+0x2a>
        return LOS_ERRNO_TSK_NO_MEMORY;
 800303e:	4b37      	ldr	r3, [pc, #220]	; (800311c <OsTaskInit+0x104>)
 8003040:	e063      	b.n	800310a <OsTaskInit+0xf2>
    }
    (VOID)memset_s(g_taskCBArray, size, 0, size);
 8003042:	4b35      	ldr	r3, [pc, #212]	; (8003118 <OsTaskInit+0x100>)
 8003044:	6818      	ldr	r0, [r3, #0]
 8003046:	68bb      	ldr	r3, [r7, #8]
 8003048:	2200      	movs	r2, #0
 800304a:	68b9      	ldr	r1, [r7, #8]
 800304c:	f7ff f82a 	bl	80020a4 <memset_s>

    LOS_ListInit(&g_losFreeTask);
 8003050:	4833      	ldr	r0, [pc, #204]	; (8003120 <OsTaskInit+0x108>)
 8003052:	f7ff fce8 	bl	8002a26 <LOS_ListInit>
    LOS_ListInit(&g_taskRecycleList);
 8003056:	4833      	ldr	r0, [pc, #204]	; (8003124 <OsTaskInit+0x10c>)
 8003058:	f7ff fce5 	bl	8002a26 <LOS_ListInit>
    for (index = 0; index < KERNEL_TSK_LIMIT; index++) {
 800305c:	2300      	movs	r3, #0
 800305e:	607b      	str	r3, [r7, #4]
 8003060:	e023      	b.n	80030aa <OsTaskInit+0x92>
        g_taskCBArray[index].taskStatus = OS_TASK_STATUS_UNUSED;
 8003062:	4b2d      	ldr	r3, [pc, #180]	; (8003118 <OsTaskInit+0x100>)
 8003064:	6819      	ldr	r1, [r3, #0]
 8003066:	687a      	ldr	r2, [r7, #4]
 8003068:	4613      	mov	r3, r2
 800306a:	009b      	lsls	r3, r3, #2
 800306c:	4413      	add	r3, r2
 800306e:	015b      	lsls	r3, r3, #5
 8003070:	440b      	add	r3, r1
 8003072:	2201      	movs	r2, #1
 8003074:	809a      	strh	r2, [r3, #4]
        g_taskCBArray[index].taskId = index;
 8003076:	4b28      	ldr	r3, [pc, #160]	; (8003118 <OsTaskInit+0x100>)
 8003078:	6819      	ldr	r1, [r3, #0]
 800307a:	687a      	ldr	r2, [r7, #4]
 800307c:	4613      	mov	r3, r2
 800307e:	009b      	lsls	r3, r3, #2
 8003080:	4413      	add	r3, r2
 8003082:	015b      	lsls	r3, r3, #5
 8003084:	440b      	add	r3, r1
 8003086:	687a      	ldr	r2, [r7, #4]
 8003088:	615a      	str	r2, [r3, #20]
        LOS_ListTailInsert(&g_losFreeTask, &g_taskCBArray[index].pendList);
 800308a:	4b23      	ldr	r3, [pc, #140]	; (8003118 <OsTaskInit+0x100>)
 800308c:	6819      	ldr	r1, [r3, #0]
 800308e:	687a      	ldr	r2, [r7, #4]
 8003090:	4613      	mov	r3, r2
 8003092:	009b      	lsls	r3, r3, #2
 8003094:	4413      	add	r3, r2
 8003096:	015b      	lsls	r3, r3, #5
 8003098:	440b      	add	r3, r1
 800309a:	3340      	adds	r3, #64	; 0x40
 800309c:	4619      	mov	r1, r3
 800309e:	4820      	ldr	r0, [pc, #128]	; (8003120 <OsTaskInit+0x108>)
 80030a0:	f7ff fcea 	bl	8002a78 <LOS_ListTailInsert>
    for (index = 0; index < KERNEL_TSK_LIMIT; index++) {
 80030a4:	687b      	ldr	r3, [r7, #4]
 80030a6:	3301      	adds	r3, #1
 80030a8:	607b      	str	r3, [r7, #4]
 80030aa:	687b      	ldr	r3, [r7, #4]
 80030ac:	2b0f      	cmp	r3, #15
 80030ae:	d9d8      	bls.n	8003062 <OsTaskInit+0x4a>
    }

    ret = OsPriQueueInit();
 80030b0:	f005 ff3c 	bl	8008f2c <OsPriQueueInit>
 80030b4:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 80030b6:	68fb      	ldr	r3, [r7, #12]
 80030b8:	2b00      	cmp	r3, #0
 80030ba:	d001      	beq.n	80030c0 <OsTaskInit+0xa8>
        return LOS_ERRNO_TSK_NO_MEMORY;
 80030bc:	4b17      	ldr	r3, [pc, #92]	; (800311c <OsTaskInit+0x104>)
 80030be:	e024      	b.n	800310a <OsTaskInit+0xf2>
    }

    ret = OsMuxDlockCheckInitHook();
 80030c0:	f7ff fdde 	bl	8002c80 <OsMuxDlockCheckInitHook>
 80030c4:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 80030c6:	68fb      	ldr	r3, [r7, #12]
 80030c8:	2b00      	cmp	r3, #0
 80030ca:	d001      	beq.n	80030d0 <OsTaskInit+0xb8>
        return LOS_ERRNO_TSK_NO_MEMORY;
 80030cc:	4b13      	ldr	r3, [pc, #76]	; (800311c <OsTaskInit+0x104>)
 80030ce:	e01c      	b.n	800310a <OsTaskInit+0xf2>
    }

    /* init sortlink for each core */
    for (index = 0; index < LOSCFG_KERNEL_CORE_NUM; index++) {
 80030d0:	2300      	movs	r3, #0
 80030d2:	607b      	str	r3, [r7, #4]
 80030d4:	e012      	b.n	80030fc <OsTaskInit+0xe4>
        ret = OsSortLinkInit(&g_percpu[index].taskSortLink);
 80030d6:	687a      	ldr	r2, [r7, #4]
 80030d8:	4613      	mov	r3, r2
 80030da:	00db      	lsls	r3, r3, #3
 80030dc:	4413      	add	r3, r2
 80030de:	009b      	lsls	r3, r3, #2
 80030e0:	4a11      	ldr	r2, [pc, #68]	; (8003128 <OsTaskInit+0x110>)
 80030e2:	4413      	add	r3, r2
 80030e4:	4618      	mov	r0, r3
 80030e6:	f007 f811 	bl	800a10c <OsSortLinkInit>
 80030ea:	60f8      	str	r0, [r7, #12]
        if (ret != LOS_OK) {
 80030ec:	68fb      	ldr	r3, [r7, #12]
 80030ee:	2b00      	cmp	r3, #0
 80030f0:	d001      	beq.n	80030f6 <OsTaskInit+0xde>
            return LOS_ERRNO_TSK_NO_MEMORY;
 80030f2:	4b0a      	ldr	r3, [pc, #40]	; (800311c <OsTaskInit+0x104>)
 80030f4:	e009      	b.n	800310a <OsTaskInit+0xf2>
    for (index = 0; index < LOSCFG_KERNEL_CORE_NUM; index++) {
 80030f6:	687b      	ldr	r3, [r7, #4]
 80030f8:	3301      	adds	r3, #1
 80030fa:	607b      	str	r3, [r7, #4]
 80030fc:	687b      	ldr	r3, [r7, #4]
 80030fe:	2b00      	cmp	r3, #0
 8003100:	d0e9      	beq.n	80030d6 <OsTaskInit+0xbe>
        }
    }

    g_taskMaxNum = KERNEL_TSK_LIMIT;
 8003102:	4b0a      	ldr	r3, [pc, #40]	; (800312c <OsTaskInit+0x114>)
 8003104:	2210      	movs	r2, #16
 8003106:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 8003108:	2300      	movs	r3, #0
}
 800310a:	4618      	mov	r0, r3
 800310c:	3710      	adds	r7, #16
 800310e:	46bd      	mov	sp, r7
 8003110:	bd80      	pop	{r7, pc}
 8003112:	bf00      	nop
 8003114:	200021bc 	.word	0x200021bc
 8003118:	200036c4 	.word	0x200036c4
 800311c:	03000200 	.word	0x03000200
 8003120:	200036d0 	.word	0x200036d0
 8003124:	200036c8 	.word	0x200036c8
 8003128:	200036fc 	.word	0x200036fc
 800312c:	200036d8 	.word	0x200036d8

08003130 <OsGetIdleTaskId>:

UINT32 OsGetIdleTaskId(VOID)
{
 8003130:	b580      	push	{r7, lr}
 8003132:	b082      	sub	sp, #8
 8003134:	af00      	add	r7, sp, #0
    Percpu *perCpu = OsPercpuGet();
 8003136:	f7ff fd07 	bl	8002b48 <OsPercpuGet>
 800313a:	6078      	str	r0, [r7, #4]
    return perCpu->idleTaskId;
 800313c:	687b      	ldr	r3, [r7, #4]
 800313e:	691b      	ldr	r3, [r3, #16]
}
 8003140:	4618      	mov	r0, r3
 8003142:	3708      	adds	r7, #8
 8003144:	46bd      	mov	sp, r7
 8003146:	bd80      	pop	{r7, pc}

08003148 <OsIdleTaskCreate>:

LITE_OS_SEC_TEXT_INIT UINT32 OsIdleTaskCreate(VOID)
{
 8003148:	b580      	push	{r7, lr}
 800314a:	b08e      	sub	sp, #56	; 0x38
 800314c:	af00      	add	r7, sp, #0
 800314e:	4b26      	ldr	r3, [pc, #152]	; (80031e8 <OsIdleTaskCreate+0xa0>)
 8003150:	681b      	ldr	r3, [r3, #0]
 8003152:	637b      	str	r3, [r7, #52]	; 0x34
 8003154:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    TSK_INIT_PARAM_S taskInitParam;
    Percpu *perCpu = OsPercpuGet();
 8003158:	f7ff fcf6 	bl	8002b48 <OsPercpuGet>
 800315c:	6078      	str	r0, [r7, #4]
    UINT32 *idleTaskId = &perCpu->idleTaskId;
 800315e:	687b      	ldr	r3, [r7, #4]
 8003160:	3310      	adds	r3, #16
 8003162:	60bb      	str	r3, [r7, #8]

    (VOID)memset_s((VOID *)(&taskInitParam), sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
 8003164:	f107 0010 	add.w	r0, r7, #16
 8003168:	2324      	movs	r3, #36	; 0x24
 800316a:	2200      	movs	r2, #0
 800316c:	2124      	movs	r1, #36	; 0x24
 800316e:	f7fe ff99 	bl	80020a4 <memset_s>
    taskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)OsIdleTask;
 8003172:	4b1e      	ldr	r3, [pc, #120]	; (80031ec <OsIdleTaskCreate+0xa4>)
 8003174:	613b      	str	r3, [r7, #16]
    taskInitParam.uwStackSize = KERNEL_TSK_IDLE_STACK_SIZE;
 8003176:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800317a:	62bb      	str	r3, [r7, #40]	; 0x28
    taskInitParam.pcName = "IdleCore000";
 800317c:	4b1c      	ldr	r3, [pc, #112]	; (80031f0 <OsIdleTaskCreate+0xa8>)
 800317e:	62fb      	str	r3, [r7, #44]	; 0x2c
    taskInitParam.usTaskPrio = OS_TASK_PRIORITY_LOWEST;
 8003180:	231f      	movs	r3, #31
 8003182:	82bb      	strh	r3, [r7, #20]
#ifdef LOSCFG_KERNEL_SMP
    taskInitParam.usCpuAffiMask = CPUID_TO_AFFI_MASK(ArchCurrCpuid());
#endif
    ret = LOS_TaskCreate(idleTaskId, &taskInitParam);
 8003184:	f107 0310 	add.w	r3, r7, #16
 8003188:	4619      	mov	r1, r3
 800318a:	68b8      	ldr	r0, [r7, #8]
 800318c:	f000 fcce 	bl	8003b2c <LOS_TaskCreate>
 8003190:	60f8      	str	r0, [r7, #12]
    if (ret == LOS_OK) {
 8003192:	68fb      	ldr	r3, [r7, #12]
 8003194:	2b00      	cmp	r3, #0
 8003196:	d11a      	bne.n	80031ce <OsIdleTaskCreate+0x86>
        OS_TCB_FROM_TID(*idleTaskId)->taskFlags |= OS_TASK_FLAG_SYSTEM;
 8003198:	4b16      	ldr	r3, [pc, #88]	; (80031f4 <OsIdleTaskCreate+0xac>)
 800319a:	6819      	ldr	r1, [r3, #0]
 800319c:	68bb      	ldr	r3, [r7, #8]
 800319e:	681a      	ldr	r2, [r3, #0]
 80031a0:	4613      	mov	r3, r2
 80031a2:	009b      	lsls	r3, r3, #2
 80031a4:	4413      	add	r3, r2
 80031a6:	015b      	lsls	r3, r3, #5
 80031a8:	440b      	add	r3, r1
 80031aa:	689b      	ldr	r3, [r3, #8]
 80031ac:	f3c3 011e 	ubfx	r1, r3, #0, #31
 80031b0:	4b10      	ldr	r3, [pc, #64]	; (80031f4 <OsIdleTaskCreate+0xac>)
 80031b2:	6818      	ldr	r0, [r3, #0]
 80031b4:	68bb      	ldr	r3, [r7, #8]
 80031b6:	681a      	ldr	r2, [r3, #0]
 80031b8:	4613      	mov	r3, r2
 80031ba:	009b      	lsls	r3, r3, #2
 80031bc:	4413      	add	r3, r2
 80031be:	015b      	lsls	r3, r3, #5
 80031c0:	18c2      	adds	r2, r0, r3
 80031c2:	f041 0102 	orr.w	r1, r1, #2
 80031c6:	6893      	ldr	r3, [r2, #8]
 80031c8:	f361 031e 	bfi	r3, r1, #0, #31
 80031cc:	6093      	str	r3, [r2, #8]
    }

    return ret;
 80031ce:	68fb      	ldr	r3, [r7, #12]
}
 80031d0:	4a05      	ldr	r2, [pc, #20]	; (80031e8 <OsIdleTaskCreate+0xa0>)
 80031d2:	6811      	ldr	r1, [r2, #0]
 80031d4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80031d6:	4051      	eors	r1, r2
 80031d8:	d001      	beq.n	80031de <OsIdleTaskCreate+0x96>
 80031da:	f001 f9ff 	bl	80045dc <__stack_chk_fail>
 80031de:	4618      	mov	r0, r3
 80031e0:	3738      	adds	r7, #56	; 0x38
 80031e2:	46bd      	mov	sp, r7
 80031e4:	bd80      	pop	{r7, pc}
 80031e6:	bf00      	nop
 80031e8:	0802009c 	.word	0x0802009c
 80031ec:	08002d55 	.word	0x08002d55
 80031f0:	08020090 	.word	0x08020090
 80031f4:	200036c4 	.word	0x200036c4

080031f8 <LOS_CurTaskIDGet>:
/*
 * Description : get id of current running task.
 * Return      : task id
 */
LITE_OS_SEC_TEXT UINT32 LOS_CurTaskIDGet(VOID)
{
 80031f8:	b580      	push	{r7, lr}
 80031fa:	b082      	sub	sp, #8
 80031fc:	af00      	add	r7, sp, #0
    LosTaskCB *runTask = OsCurrTaskGet();
 80031fe:	f7ff fd38 	bl	8002c72 <OsCurrTaskGet>
 8003202:	6078      	str	r0, [r7, #4]

    if (runTask == NULL) {
 8003204:	687b      	ldr	r3, [r7, #4]
 8003206:	2b00      	cmp	r3, #0
 8003208:	d101      	bne.n	800320e <LOS_CurTaskIDGet+0x16>
        return LOS_ERRNO_TSK_ID_INVALID;
 800320a:	4b04      	ldr	r3, [pc, #16]	; (800321c <LOS_CurTaskIDGet+0x24>)
 800320c:	e001      	b.n	8003212 <LOS_CurTaskIDGet+0x1a>
    }
    return runTask->taskId;
 800320e:	687b      	ldr	r3, [r7, #4]
 8003210:	695b      	ldr	r3, [r3, #20]
}
 8003212:	4618      	mov	r0, r3
 8003214:	3708      	adds	r7, #8
 8003216:	46bd      	mov	sp, r7
 8003218:	bd80      	pop	{r7, pc}
 800321a:	bf00      	nop
 800321c:	02000207 	.word	0x02000207

08003220 <OsTaskStackCheck>:
    return NULL;
}

#ifdef LOSCFG_BASE_CORE_TSK_MONITOR
LITE_OS_SEC_TEXT STATIC VOID OsTaskStackCheck(const LosTaskCB *oldTask, const LosTaskCB *newTask)
{
 8003220:	b580      	push	{r7, lr}
 8003222:	b084      	sub	sp, #16
 8003224:	af02      	add	r7, sp, #8
 8003226:	6078      	str	r0, [r7, #4]
 8003228:	6039      	str	r1, [r7, #0]
    if (!OS_STACK_MAGIC_CHECK(oldTask->topOfStack)) {
 800322a:	687b      	ldr	r3, [r7, #4]
 800322c:	691b      	ldr	r3, [r3, #16]
 800322e:	681b      	ldr	r3, [r3, #0]
 8003230:	f1b3 3fcc 	cmp.w	r3, #3435973836	; 0xcccccccc
 8003234:	d007      	beq.n	8003246 <OsTaskStackCheck+0x26>
        LOS_Panic("CURRENT task ID: %s:%u stack overflow!\n", oldTask->taskName, oldTask->taskId);
 8003236:	687b      	ldr	r3, [r7, #4]
 8003238:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 800323a:	687b      	ldr	r3, [r7, #4]
 800323c:	695b      	ldr	r3, [r3, #20]
 800323e:	461a      	mov	r2, r3
 8003240:	4814      	ldr	r0, [pc, #80]	; (8003294 <OsTaskStackCheck+0x74>)
 8003242:	f001 f945 	bl	80044d0 <LOS_Panic>
    }

    if (((UINTPTR)(newTask->stackPointer) <= newTask->topOfStack) ||
 8003246:	683b      	ldr	r3, [r7, #0]
 8003248:	681b      	ldr	r3, [r3, #0]
 800324a:	461a      	mov	r2, r3
 800324c:	683b      	ldr	r3, [r7, #0]
 800324e:	691b      	ldr	r3, [r3, #16]
 8003250:	429a      	cmp	r2, r3
 8003252:	d909      	bls.n	8003268 <OsTaskStackCheck+0x48>
        ((UINTPTR)(newTask->stackPointer) > (newTask->topOfStack + newTask->stackSize))) {
 8003254:	683b      	ldr	r3, [r7, #0]
 8003256:	681b      	ldr	r3, [r3, #0]
 8003258:	4619      	mov	r1, r3
 800325a:	683b      	ldr	r3, [r7, #0]
 800325c:	691a      	ldr	r2, [r3, #16]
 800325e:	683b      	ldr	r3, [r7, #0]
 8003260:	68db      	ldr	r3, [r3, #12]
 8003262:	4413      	add	r3, r2
    if (((UINTPTR)(newTask->stackPointer) <= newTask->topOfStack) ||
 8003264:	4299      	cmp	r1, r3
 8003266:	d90c      	bls.n	8003282 <OsTaskStackCheck+0x62>
        LOS_Panic("HIGHEST task ID: %s:%u SP error! StackPointer: %p TopOfStack: %p\n",
 8003268:	683b      	ldr	r3, [r7, #0]
 800326a:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 800326c:	683b      	ldr	r3, [r7, #0]
 800326e:	695a      	ldr	r2, [r3, #20]
 8003270:	683b      	ldr	r3, [r7, #0]
 8003272:	6818      	ldr	r0, [r3, #0]
 8003274:	683b      	ldr	r3, [r7, #0]
 8003276:	691b      	ldr	r3, [r3, #16]
 8003278:	9300      	str	r3, [sp, #0]
 800327a:	4603      	mov	r3, r0
 800327c:	4806      	ldr	r0, [pc, #24]	; (8003298 <OsTaskStackCheck+0x78>)
 800327e:	f001 f927 	bl	80044d0 <LOS_Panic>
                  newTask->taskName, newTask->taskId, newTask->stackPointer, newTask->topOfStack);
    }

    if (OsExcStackCheckHook != NULL) {
 8003282:	4b06      	ldr	r3, [pc, #24]	; (800329c <OsTaskStackCheck+0x7c>)
 8003284:	2b00      	cmp	r3, #0
 8003286:	d001      	beq.n	800328c <OsTaskStackCheck+0x6c>
        OsExcStackCheckHook();
 8003288:	f3af 8000 	nop.w
    }
}
 800328c:	bf00      	nop
 800328e:	3708      	adds	r7, #8
 8003290:	46bd      	mov	sp, r7
 8003292:	bd80      	pop	{r7, pc}
 8003294:	080200a0 	.word	0x080200a0
 8003298:	080200c8 	.word	0x080200c8
 800329c:	00000000 	.word	0x00000000

080032a0 <OsTaskMonInit>:

LITE_OS_SEC_TEXT_MINOR VOID OsTaskMonInit(VOID)
{
 80032a0:	b480      	push	{r7}
 80032a2:	af00      	add	r7, sp, #0
    g_pfnUsrTskSwitchHook = NULL;
 80032a4:	4b03      	ldr	r3, [pc, #12]	; (80032b4 <OsTaskMonInit+0x14>)
 80032a6:	2200      	movs	r2, #0
 80032a8:	601a      	str	r2, [r3, #0]
}
 80032aa:	bf00      	nop
 80032ac:	46bd      	mov	sp, r7
 80032ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032b2:	4770      	bx	lr
 80032b4:	20000774 	.word	0x20000774

080032b8 <OsTaskSwitchCheck>:
{
    g_pfnUsrTskSwitchHook = hook;
}

LITE_OS_SEC_TEXT_MINOR VOID OsTaskSwitchCheck(const LosTaskCB *oldTask, const LosTaskCB *newTask)
{
 80032b8:	b580      	push	{r7, lr}
 80032ba:	b082      	sub	sp, #8
 80032bc:	af00      	add	r7, sp, #0
 80032be:	6078      	str	r0, [r7, #4]
 80032c0:	6039      	str	r1, [r7, #0]
    OsTaskStackCheck(oldTask, newTask);
 80032c2:	6839      	ldr	r1, [r7, #0]
 80032c4:	6878      	ldr	r0, [r7, #4]
 80032c6:	f7ff ffab 	bl	8003220 <OsTaskStackCheck>

    if (g_pfnUsrTskSwitchHook != NULL) {
 80032ca:	4b05      	ldr	r3, [pc, #20]	; (80032e0 <OsTaskSwitchCheck+0x28>)
 80032cc:	681b      	ldr	r3, [r3, #0]
 80032ce:	2b00      	cmp	r3, #0
 80032d0:	d002      	beq.n	80032d8 <OsTaskSwitchCheck+0x20>
        g_pfnUsrTskSwitchHook();
 80032d2:	4b03      	ldr	r3, [pc, #12]	; (80032e0 <OsTaskSwitchCheck+0x28>)
 80032d4:	681b      	ldr	r3, [r3, #0]
 80032d6:	4798      	blx	r3
    }
}
 80032d8:	bf00      	nop
 80032da:	3708      	adds	r7, #8
 80032dc:	46bd      	mov	sp, r7
 80032de:	bd80      	pop	{r7, pc}
 80032e0:	20000774 	.word	0x20000774

080032e4 <LOS_LowpowerHookReg>:
#endif /* LOSCFG_BASE_CORE_TSK_MONITOR */

#ifdef LOSCFG_KERNEL_LOWPOWER
LITE_OS_SEC_TEXT_MINOR VOID LOS_LowpowerHookReg(LOWPOWERIDLEHOOK hook)
{
 80032e4:	b480      	push	{r7}
 80032e6:	b083      	sub	sp, #12
 80032e8:	af00      	add	r7, sp, #0
 80032ea:	6078      	str	r0, [r7, #4]
    g_lowPowerHook = hook;
 80032ec:	4a04      	ldr	r2, [pc, #16]	; (8003300 <LOS_LowpowerHookReg+0x1c>)
 80032ee:	687b      	ldr	r3, [r7, #4]
 80032f0:	6013      	str	r3, [r2, #0]
}
 80032f2:	bf00      	nop
 80032f4:	370c      	adds	r7, #12
 80032f6:	46bd      	mov	sp, r7
 80032f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032fc:	4770      	bx	lr
 80032fe:	bf00      	nop
 8003300:	20000778 	.word	0x20000778

08003304 <OsTaskDeleteCheckDetached>:
{
    g_idleHandlerHook = hook;
}

STATIC BOOL OsTaskDeleteCheckDetached(const LosTaskCB *taskCB)
{
 8003304:	b480      	push	{r7}
 8003306:	b083      	sub	sp, #12
 8003308:	af00      	add	r7, sp, #0
 800330a:	6078      	str	r0, [r7, #4]
#if LOSCFG_COMPAT_POSIX
    return ((taskCB->taskFlags & OS_TASK_FLAG_DETACHED) != 0);
 800330c:	687b      	ldr	r3, [r7, #4]
 800330e:	689b      	ldr	r3, [r3, #8]
 8003310:	f3c3 031e 	ubfx	r3, r3, #0, #31
 8003314:	f003 0301 	and.w	r3, r3, #1
 8003318:	2b00      	cmp	r3, #0
 800331a:	bf14      	ite	ne
 800331c:	2301      	movne	r3, #1
 800331e:	2300      	moveq	r3, #0
 8003320:	b2db      	uxtb	r3, r3
#else
    return TRUE;
#endif
}
 8003322:	4618      	mov	r0, r3
 8003324:	370c      	adds	r7, #12
 8003326:	46bd      	mov	sp, r7
 8003328:	f85d 7b04 	ldr.w	r7, [sp], #4
 800332c:	4770      	bx	lr

0800332e <OsTaskDeleteDetached>:

STATIC VOID OsTaskDeleteDetached(const LosTaskCB *taskCB)
{
 800332e:	b580      	push	{r7, lr}
 8003330:	b084      	sub	sp, #16
 8003332:	af00      	add	r7, sp, #0
 8003334:	6078      	str	r0, [r7, #4]
    UINT32 intSave;
    intSave = LOS_IntLock();
 8003336:	f7ff fbe2 	bl	8002afe <LOS_IntLock>
 800333a:	60f8      	str	r0, [r7, #12]
    OsPercpuGet()->taskLockCnt = 0;
 800333c:	f7ff fc04 	bl	8002b48 <OsPercpuGet>
 8003340:	4603      	mov	r3, r0
 8003342:	2200      	movs	r2, #0
 8003344:	615a      	str	r2, [r3, #20]
    LOS_IntRestore(intSave);
 8003346:	68f8      	ldr	r0, [r7, #12]
 8003348:	f7ff fbe7 	bl	8002b1a <LOS_IntRestore>
    (VOID)LOS_TaskDelete(taskCB->taskId);
 800334c:	687b      	ldr	r3, [r7, #4]
 800334e:	695b      	ldr	r3, [r3, #20]
 8003350:	4618      	mov	r0, r3
 8003352:	f000 fc03 	bl	8003b5c <LOS_TaskDelete>
}
 8003356:	bf00      	nop
 8003358:	3710      	adds	r7, #16
 800335a:	46bd      	mov	sp, r7
 800335c:	bd80      	pop	{r7, pc}
	...

08003360 <OsTaskDeleteJoined>:

STATIC VOID OsTaskDeleteJoined(LosTaskCB *taskCB, VOID *ret)
{
 8003360:	b580      	push	{r7, lr}
 8003362:	b084      	sub	sp, #16
 8003364:	af00      	add	r7, sp, #0
 8003366:	6078      	str	r0, [r7, #4]
 8003368:	6039      	str	r1, [r7, #0]
#ifdef LOSCFG_COMPAT_POSIX
    UINT32 intSave;
    taskCB->threadJoinRetval = ret;
 800336a:	687b      	ldr	r3, [r7, #4]
 800336c:	683a      	ldr	r2, [r7, #0]
 800336e:	625a      	str	r2, [r3, #36]	; 0x24

    intSave = LOS_IntLock();
 8003370:	f7ff fbc5 	bl	8002afe <LOS_IntLock>
 8003374:	60f8      	str	r0, [r7, #12]
    OsPercpuGet()->taskLockCnt = 1;
 8003376:	f7ff fbe7 	bl	8002b48 <OsPercpuGet>
 800337a:	4603      	mov	r3, r0
 800337c:	2201      	movs	r2, #1
 800337e:	615a      	str	r2, [r3, #20]

    if (taskCB->threadJoin != NULL) {
 8003380:	687b      	ldr	r3, [r7, #4]
 8003382:	6a1b      	ldr	r3, [r3, #32]
 8003384:	2b00      	cmp	r3, #0
 8003386:	d011      	beq.n	80033ac <OsTaskDeleteJoined+0x4c>
        if (LOS_SemPost((UINT32)(((LosSemCB *)taskCB->threadJoin)->semId)) != LOS_OK) {
 8003388:	687b      	ldr	r3, [r7, #4]
 800338a:	6a1b      	ldr	r3, [r3, #32]
 800338c:	685b      	ldr	r3, [r3, #4]
 800338e:	4618      	mov	r0, r3
 8003390:	f002 f862 	bl	8005458 <LOS_SemPost>
 8003394:	4603      	mov	r3, r0
 8003396:	2b00      	cmp	r3, #0
 8003398:	d005      	beq.n	80033a6 <OsTaskDeleteJoined+0x46>
            PRINT_ERR("OsTaskEntry LOS_SemPost fail!\n");
 800339a:	480e      	ldr	r0, [pc, #56]	; (80033d4 <OsTaskDeleteJoined+0x74>)
 800339c:	f001 fa90 	bl	80048c0 <dprintf>
 80033a0:	480d      	ldr	r0, [pc, #52]	; (80033d8 <OsTaskDeleteJoined+0x78>)
 80033a2:	f001 fa8d 	bl	80048c0 <dprintf>
        }
        taskCB->threadJoin = NULL;
 80033a6:	687b      	ldr	r3, [r7, #4]
 80033a8:	2200      	movs	r2, #0
 80033aa:	621a      	str	r2, [r3, #32]
    }
    OsPercpuGet()->taskLockCnt = 0;
 80033ac:	f7ff fbcc 	bl	8002b48 <OsPercpuGet>
 80033b0:	4603      	mov	r3, r0
 80033b2:	2200      	movs	r2, #0
 80033b4:	615a      	str	r2, [r3, #20]

    LOS_SpinLock(&g_taskSpin);
 80033b6:	4809      	ldr	r0, [pc, #36]	; (80033dc <OsTaskDeleteJoined+0x7c>)
 80033b8:	f7ff fc22 	bl	8002c00 <LOS_SpinLock>
    OsSchedResched();
 80033bc:	f005 fbfc 	bl	8008bb8 <OsSchedResched>

    LOS_SpinUnlock(&g_taskSpin);
 80033c0:	4806      	ldr	r0, [pc, #24]	; (80033dc <OsTaskDeleteJoined+0x7c>)
 80033c2:	f7ff fc27 	bl	8002c14 <LOS_SpinUnlock>
    LOS_IntRestore(intSave);
 80033c6:	68f8      	ldr	r0, [r7, #12]
 80033c8:	f7ff fba7 	bl	8002b1a <LOS_IntRestore>
#endif
}
 80033cc:	bf00      	nop
 80033ce:	3710      	adds	r7, #16
 80033d0:	46bd      	mov	sp, r7
 80033d2:	bd80      	pop	{r7, pc}
 80033d4:	0802005c 	.word	0x0802005c
 80033d8:	0802010c 	.word	0x0802010c
 80033dc:	20000770 	.word	0x20000770

080033e0 <OsTaskEntry>:
/*
 * Description : All task entry
 * Input       : taskId     --- The ID of the task to be run
 */
LITE_OS_SEC_TEXT_INIT VOID OsTaskEntry(UINT32 taskId)
{
 80033e0:	b590      	push	{r4, r7, lr}
 80033e2:	b085      	sub	sp, #20
 80033e4:	af00      	add	r7, sp, #0
 80033e6:	6078      	str	r0, [r7, #4]
    LosTaskCB *taskCB = NULL;
 80033e8:	2300      	movs	r3, #0
 80033ea:	60bb      	str	r3, [r7, #8]
    VOID *ret = NULL;
 80033ec:	2300      	movs	r3, #0
 80033ee:	60fb      	str	r3, [r7, #12]

    LOS_ASSERT(OS_TSK_GET_INDEX(taskId) < g_taskMaxNum);
 80033f0:	4b1e      	ldr	r3, [pc, #120]	; (800346c <OsTaskEntry+0x8c>)
 80033f2:	681b      	ldr	r3, [r3, #0]
 80033f4:	687a      	ldr	r2, [r7, #4]
 80033f6:	429a      	cmp	r2, r3
 80033f8:	d30c      	bcc.n	8003414 <OsTaskEntry+0x34>
 80033fa:	f7ff fb80 	bl	8002afe <LOS_IntLock>
 80033fe:	481c      	ldr	r0, [pc, #112]	; (8003470 <OsTaskEntry+0x90>)
 8003400:	f001 fa5e 	bl	80048c0 <dprintf>
 8003404:	4b1b      	ldr	r3, [pc, #108]	; (8003474 <OsTaskEntry+0x94>)
 8003406:	f240 12e9 	movw	r2, #489	; 0x1e9
 800340a:	491b      	ldr	r1, [pc, #108]	; (8003478 <OsTaskEntry+0x98>)
 800340c:	481b      	ldr	r0, [pc, #108]	; (800347c <OsTaskEntry+0x9c>)
 800340e:	f001 fa57 	bl	80048c0 <dprintf>
 8003412:	e7fe      	b.n	8003412 <OsTaskEntry+0x32>
    /*
     * task scheduler needs to be protected throughout the whole process
     * from interrupt and other cores. release task spinlock and enable
     * interrupt in sequence at the task entry.
     */
    LOS_SpinUnlock(&g_taskSpin);
 8003414:	481a      	ldr	r0, [pc, #104]	; (8003480 <OsTaskEntry+0xa0>)
 8003416:	f7ff fbfd 	bl	8002c14 <LOS_SpinUnlock>
    (VOID)LOS_IntUnLock();
 800341a:	f7ff fb77 	bl	8002b0c <LOS_IntUnLock>

    taskCB = OS_TCB_FROM_TID(taskId);
 800341e:	4b19      	ldr	r3, [pc, #100]	; (8003484 <OsTaskEntry+0xa4>)
 8003420:	6819      	ldr	r1, [r3, #0]
 8003422:	687a      	ldr	r2, [r7, #4]
 8003424:	4613      	mov	r3, r2
 8003426:	009b      	lsls	r3, r3, #2
 8003428:	4413      	add	r3, r2
 800342a:	015b      	lsls	r3, r3, #5
 800342c:	440b      	add	r3, r1
 800342e:	60bb      	str	r3, [r7, #8]

#ifdef LOSCFG_OBSOLETE_API
    ret = taskCB->taskEntry(taskCB->args[0], taskCB->args[1], taskCB->args[2],
 8003430:	68bb      	ldr	r3, [r7, #8]
 8003432:	699c      	ldr	r4, [r3, #24]
 8003434:	68bb      	ldr	r3, [r7, #8]
 8003436:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8003438:	68bb      	ldr	r3, [r7, #8]
 800343a:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800343c:	68bb      	ldr	r3, [r7, #8]
 800343e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003440:	68bb      	ldr	r3, [r7, #8]
 8003442:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003444:	47a0      	blx	r4
 8003446:	60f8      	str	r0, [r7, #12]
        taskCB->args[3]); /* 0~3: just for args array index */
#else
    ret = taskCB->taskEntry(taskCB->args);
#endif

    if (OsTaskDeleteCheckDetached(taskCB)) {
 8003448:	68b8      	ldr	r0, [r7, #8]
 800344a:	f7ff ff5b 	bl	8003304 <OsTaskDeleteCheckDetached>
 800344e:	4603      	mov	r3, r0
 8003450:	2b00      	cmp	r3, #0
 8003452:	d003      	beq.n	800345c <OsTaskEntry+0x7c>
        OsTaskDeleteDetached(taskCB);
 8003454:	68b8      	ldr	r0, [r7, #8]
 8003456:	f7ff ff6a 	bl	800332e <OsTaskDeleteDetached>
    } else {
        OsTaskDeleteJoined(taskCB, ret);
    }
}
 800345a:	e003      	b.n	8003464 <OsTaskEntry+0x84>
        OsTaskDeleteJoined(taskCB, ret);
 800345c:	68f9      	ldr	r1, [r7, #12]
 800345e:	68b8      	ldr	r0, [r7, #8]
 8003460:	f7ff ff7e 	bl	8003360 <OsTaskDeleteJoined>
}
 8003464:	bf00      	nop
 8003466:	3714      	adds	r7, #20
 8003468:	46bd      	mov	sp, r7
 800346a:	bd90      	pop	{r4, r7, pc}
 800346c:	200036d8 	.word	0x200036d8
 8003470:	0802005c 	.word	0x0802005c
 8003474:	080232d4 	.word	0x080232d4
 8003478:	08020064 	.word	0x08020064
 800347c:	08020070 	.word	0x08020070
 8003480:	20000770 	.word	0x20000770
 8003484:	200036c4 	.word	0x200036c4

08003488 <OsTaskInitParamCheck>:

STATIC UINT32 OsTaskInitParamCheck(const TSK_INIT_PARAM_S *initParam)
{
 8003488:	b480      	push	{r7}
 800348a:	b083      	sub	sp, #12
 800348c:	af00      	add	r7, sp, #0
 800348e:	6078      	str	r0, [r7, #4]
    if (initParam == NULL) {
 8003490:	687b      	ldr	r3, [r7, #4]
 8003492:	2b00      	cmp	r3, #0
 8003494:	d101      	bne.n	800349a <OsTaskInitParamCheck+0x12>
        return LOS_ERRNO_TSK_PTR_NULL;
 8003496:	4b0d      	ldr	r3, [pc, #52]	; (80034cc <OsTaskInitParamCheck+0x44>)
 8003498:	e012      	b.n	80034c0 <OsTaskInitParamCheck+0x38>
    }

    if (initParam->pcName == NULL) {
 800349a:	687b      	ldr	r3, [r7, #4]
 800349c:	69db      	ldr	r3, [r3, #28]
 800349e:	2b00      	cmp	r3, #0
 80034a0:	d101      	bne.n	80034a6 <OsTaskInitParamCheck+0x1e>
        return LOS_ERRNO_TSK_NAME_EMPTY;
 80034a2:	4b0b      	ldr	r3, [pc, #44]	; (80034d0 <OsTaskInitParamCheck+0x48>)
 80034a4:	e00c      	b.n	80034c0 <OsTaskInitParamCheck+0x38>
    }

    if (initParam->pfnTaskEntry == NULL) {
 80034a6:	687b      	ldr	r3, [r7, #4]
 80034a8:	681b      	ldr	r3, [r3, #0]
 80034aa:	2b00      	cmp	r3, #0
 80034ac:	d101      	bne.n	80034b2 <OsTaskInitParamCheck+0x2a>
        return LOS_ERRNO_TSK_ENTRY_NULL;
 80034ae:	4b09      	ldr	r3, [pc, #36]	; (80034d4 <OsTaskInitParamCheck+0x4c>)
 80034b0:	e006      	b.n	80034c0 <OsTaskInitParamCheck+0x38>
    }

    if (initParam->usTaskPrio > OS_TASK_PRIORITY_LOWEST) {
 80034b2:	687b      	ldr	r3, [r7, #4]
 80034b4:	889b      	ldrh	r3, [r3, #4]
 80034b6:	2b1f      	cmp	r3, #31
 80034b8:	d901      	bls.n	80034be <OsTaskInitParamCheck+0x36>
        return LOS_ERRNO_TSK_PRIOR_ERROR;
 80034ba:	4b07      	ldr	r3, [pc, #28]	; (80034d8 <OsTaskInitParamCheck+0x50>)
 80034bc:	e000      	b.n	80034c0 <OsTaskInitParamCheck+0x38>
    }

    return LOS_OK;
 80034be:	2300      	movs	r3, #0
}
 80034c0:	4618      	mov	r0, r3
 80034c2:	370c      	adds	r7, #12
 80034c4:	46bd      	mov	sp, r7
 80034c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80034ca:	4770      	bx	lr
 80034cc:	02000201 	.word	0x02000201
 80034d0:	02000205 	.word	0x02000205
 80034d4:	02000204 	.word	0x02000204
 80034d8:	02000203 	.word	0x02000203

080034dc <OsTaskCreateParamCheck>:
}
#endif

LITE_OS_SEC_TEXT_INIT STATIC UINT32 OsTaskCreateParamCheck(const UINT32 *taskId,
    TSK_INIT_PARAM_S *initParam, VOID **pool)
{
 80034dc:	b590      	push	{r4, r7, lr}
 80034de:	b087      	sub	sp, #28
 80034e0:	af00      	add	r7, sp, #0
 80034e2:	60f8      	str	r0, [r7, #12]
 80034e4:	60b9      	str	r1, [r7, #8]
 80034e6:	607a      	str	r2, [r7, #4]
    UINT32 ret;
    UINT32 poolSize = OS_SYS_MEM_SIZE;
 80034e8:	4b20      	ldr	r3, [pc, #128]	; (800356c <OsTaskCreateParamCheck+0x90>)
 80034ea:	681a      	ldr	r2, [r3, #0]
 80034ec:	4b20      	ldr	r3, [pc, #128]	; (8003570 <OsTaskCreateParamCheck+0x94>)
 80034ee:	681b      	ldr	r3, [r3, #0]
 80034f0:	1ad3      	subs	r3, r2, r3
 80034f2:	3301      	adds	r3, #1
 80034f4:	613b      	str	r3, [r7, #16]
    *pool = (VOID *)m_aucSysMem1;
 80034f6:	4b1f      	ldr	r3, [pc, #124]	; (8003574 <OsTaskCreateParamCheck+0x98>)
 80034f8:	681a      	ldr	r2, [r3, #0]
 80034fa:	687b      	ldr	r3, [r7, #4]
 80034fc:	601a      	str	r2, [r3, #0]

    if (taskId == NULL) {
 80034fe:	68fb      	ldr	r3, [r7, #12]
 8003500:	2b00      	cmp	r3, #0
 8003502:	d101      	bne.n	8003508 <OsTaskCreateParamCheck+0x2c>
        return LOS_ERRNO_TSK_ID_INVALID;
 8003504:	4b1c      	ldr	r3, [pc, #112]	; (8003578 <OsTaskCreateParamCheck+0x9c>)
 8003506:	e02d      	b.n	8003564 <OsTaskCreateParamCheck+0x88>
    }

    ret = OsTaskInitParamCheck(initParam);
 8003508:	68b8      	ldr	r0, [r7, #8]
 800350a:	f7ff ffbd 	bl	8003488 <OsTaskInitParamCheck>
 800350e:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 8003510:	697b      	ldr	r3, [r7, #20]
 8003512:	2b00      	cmp	r3, #0
 8003514:	d001      	beq.n	800351a <OsTaskCreateParamCheck+0x3e>
        return ret;
 8003516:	697b      	ldr	r3, [r7, #20]
 8003518:	e024      	b.n	8003564 <OsTaskCreateParamCheck+0x88>
    }
#endif
#ifdef LOSCFG_TASK_STACK_PROTECT
    poolSize = (poolSize > (MMU_4K << 1)) ? (poolSize - (MMU_4K << 1)) : 0;
#endif
    if (initParam->uwStackSize > poolSize) {
 800351a:	68bb      	ldr	r3, [r7, #8]
 800351c:	699b      	ldr	r3, [r3, #24]
 800351e:	693a      	ldr	r2, [r7, #16]
 8003520:	429a      	cmp	r2, r3
 8003522:	d201      	bcs.n	8003528 <OsTaskCreateParamCheck+0x4c>
        return LOS_ERRNO_TSK_STKSZ_TOO_LARGE;
 8003524:	4b15      	ldr	r3, [pc, #84]	; (800357c <OsTaskCreateParamCheck+0xa0>)
 8003526:	e01d      	b.n	8003564 <OsTaskCreateParamCheck+0x88>
    }

    if (initParam->uwStackSize == 0) {
 8003528:	68bb      	ldr	r3, [r7, #8]
 800352a:	699b      	ldr	r3, [r3, #24]
 800352c:	2b00      	cmp	r3, #0
 800352e:	d103      	bne.n	8003538 <OsTaskCreateParamCheck+0x5c>
        initParam->uwStackSize = KERNEL_TSK_DEFAULT_STACK_SIZE;
 8003530:	68bb      	ldr	r3, [r7, #8]
 8003532:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 8003536:	619a      	str	r2, [r3, #24]
    }
    initParam->uwStackSize = (UINT32)ALIGN(initParam->uwStackSize, LOSCFG_STACK_POINT_ALIGN_SIZE);
 8003538:	68bb      	ldr	r3, [r7, #8]
 800353a:	699b      	ldr	r3, [r3, #24]
 800353c:	2108      	movs	r1, #8
 800353e:	4618      	mov	r0, r3
 8003540:	f7ff f9ba 	bl	80028b8 <LOS_Align>
 8003544:	4602      	mov	r2, r0
 8003546:	68bb      	ldr	r3, [r7, #8]
 8003548:	619a      	str	r2, [r3, #24]

    if (initParam->uwStackSize < LOS_TASK_MIN_STACK_SIZE) {
 800354a:	68bb      	ldr	r3, [r7, #8]
 800354c:	699c      	ldr	r4, [r3, #24]
 800354e:	2108      	movs	r1, #8
 8003550:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8003554:	f7ff f9b0 	bl	80028b8 <LOS_Align>
 8003558:	4603      	mov	r3, r0
 800355a:	429c      	cmp	r4, r3
 800355c:	d201      	bcs.n	8003562 <OsTaskCreateParamCheck+0x86>
        return LOS_ERRNO_TSK_STKSZ_TOO_SMALL;
 800355e:	4b08      	ldr	r3, [pc, #32]	; (8003580 <OsTaskCreateParamCheck+0xa4>)
 8003560:	e000      	b.n	8003564 <OsTaskCreateParamCheck+0x88>
    }

    return LOS_OK;
 8003562:	2300      	movs	r3, #0
}
 8003564:	4618      	mov	r0, r3
 8003566:	371c      	adds	r7, #28
 8003568:	46bd      	mov	sp, r7
 800356a:	bd90      	pop	{r4, r7, pc}
 800356c:	080001f4 	.word	0x080001f4
 8003570:	080001f0 	.word	0x080001f0
 8003574:	200021c0 	.word	0x200021c0
 8003578:	02000207 	.word	0x02000207
 800357c:	02000220 	.word	0x02000220
 8003580:	02000206 	.word	0x02000206

08003584 <OsTaskStackAlloc>:

LITE_OS_SEC_TEXT_INIT STATIC VOID OsTaskStackAlloc(VOID **topStack, UINT32 stackSize, VOID *pool)
{
 8003584:	b580      	push	{r7, lr}
 8003586:	b084      	sub	sp, #16
 8003588:	af00      	add	r7, sp, #0
 800358a:	60f8      	str	r0, [r7, #12]
 800358c:	60b9      	str	r1, [r7, #8]
 800358e:	607a      	str	r2, [r7, #4]
    } else {
        *topStack = (VOID *)(MMUProtectAddr + MMU_4K);
        OsTaskStackProtect(MMUProtectAddr, MMU_4K, ACCESS_PERM_RO_RO);
    }
#else
    *topStack = (VOID *)LOS_MemAllocAlign(pool, stackSize, LOSCFG_STACK_POINT_ALIGN_SIZE);
 8003590:	2208      	movs	r2, #8
 8003592:	68b9      	ldr	r1, [r7, #8]
 8003594:	6878      	ldr	r0, [r7, #4]
 8003596:	f005 ff9f 	bl	80094d8 <LOS_MemAllocAlign>
 800359a:	4602      	mov	r2, r0
 800359c:	68fb      	ldr	r3, [r7, #12]
 800359e:	601a      	str	r2, [r3, #0]
#endif
}
 80035a0:	bf00      	nop
 80035a2:	3710      	adds	r7, #16
 80035a4:	46bd      	mov	sp, r7
 80035a6:	bd80      	pop	{r7, pc}

080035a8 <OsTaskSyncCreate>:

    LOS_SpinLock(&g_taskSpin);
}
#else
STATIC INLINE UINT32 OsTaskSyncCreate(LosTaskCB *taskCB)
{
 80035a8:	b480      	push	{r7}
 80035aa:	b083      	sub	sp, #12
 80035ac:	af00      	add	r7, sp, #0
 80035ae:	6078      	str	r0, [r7, #4]
    (VOID)taskCB;
    return LOS_OK;
 80035b0:	2300      	movs	r3, #0
}
 80035b2:	4618      	mov	r0, r3
 80035b4:	370c      	adds	r7, #12
 80035b6:	46bd      	mov	sp, r7
 80035b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035bc:	4770      	bx	lr

080035be <OsTaskSyncDestroy>:

STATIC INLINE VOID OsTaskSyncDestroy(const LosTaskCB *taskCB)
{
 80035be:	b480      	push	{r7}
 80035c0:	b083      	sub	sp, #12
 80035c2:	af00      	add	r7, sp, #0
 80035c4:	6078      	str	r0, [r7, #4]
    (VOID)taskCB;
}
 80035c6:	bf00      	nop
 80035c8:	370c      	adds	r7, #12
 80035ca:	46bd      	mov	sp, r7
 80035cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035d0:	4770      	bx	lr

080035d2 <OsTaskSyncWake>:
    (VOID)taskCB;
    return LOS_OK;
}

STATIC INLINE VOID OsTaskSyncWake(const LosTaskCB *taskCB)
{
 80035d2:	b480      	push	{r7}
 80035d4:	b083      	sub	sp, #12
 80035d6:	af00      	add	r7, sp, #0
 80035d8:	6078      	str	r0, [r7, #4]
    (VOID)taskCB;
}
 80035da:	bf00      	nop
 80035dc:	370c      	adds	r7, #12
 80035de:	46bd      	mov	sp, r7
 80035e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035e4:	4770      	bx	lr
	...

080035e8 <OsTaskDelActionOnRun>:
#endif

STATIC VOID OsTaskDelActionOnRun(LosTaskCB *taskCB)
{
 80035e8:	b480      	push	{r7}
 80035ea:	b085      	sub	sp, #20
 80035ec:	af00      	add	r7, sp, #0
 80035ee:	6078      	str	r0, [r7, #4]
    LosTaskCB *runTask = NULL;
 80035f0:	2300      	movs	r3, #0
 80035f2:	60fb      	str	r3, [r7, #12]

    runTask = &g_taskCBArray[g_taskMaxNum];
 80035f4:	4b11      	ldr	r3, [pc, #68]	; (800363c <OsTaskDelActionOnRun+0x54>)
 80035f6:	6819      	ldr	r1, [r3, #0]
 80035f8:	4b11      	ldr	r3, [pc, #68]	; (8003640 <OsTaskDelActionOnRun+0x58>)
 80035fa:	681a      	ldr	r2, [r3, #0]
 80035fc:	4613      	mov	r3, r2
 80035fe:	009b      	lsls	r3, r3, #2
 8003600:	4413      	add	r3, r2
 8003602:	015b      	lsls	r3, r3, #5
 8003604:	440b      	add	r3, r1
 8003606:	60fb      	str	r3, [r7, #12]
    runTask->taskId = taskCB->taskId;
 8003608:	687b      	ldr	r3, [r7, #4]
 800360a:	695a      	ldr	r2, [r3, #20]
 800360c:	68fb      	ldr	r3, [r7, #12]
 800360e:	615a      	str	r2, [r3, #20]
    runTask->taskStatus = taskCB->taskStatus;
 8003610:	687b      	ldr	r3, [r7, #4]
 8003612:	889a      	ldrh	r2, [r3, #4]
 8003614:	68fb      	ldr	r3, [r7, #12]
 8003616:	809a      	strh	r2, [r3, #4]
    runTask->topOfStack = taskCB->topOfStack;
 8003618:	687b      	ldr	r3, [r7, #4]
 800361a:	691a      	ldr	r2, [r3, #16]
 800361c:	68fb      	ldr	r3, [r7, #12]
 800361e:	611a      	str	r2, [r3, #16]
    runTask->taskName = taskCB->taskName;
 8003620:	687b      	ldr	r3, [r7, #4]
 8003622:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8003624:	68fb      	ldr	r3, [r7, #12]
 8003626:	63da      	str	r2, [r3, #60]	; 0x3c
    taskCB->taskStatus = OS_TASK_STATUS_UNUSED;
 8003628:	687b      	ldr	r3, [r7, #4]
 800362a:	2201      	movs	r2, #1
 800362c:	809a      	strh	r2, [r3, #4]
}
 800362e:	bf00      	nop
 8003630:	3714      	adds	r7, #20
 8003632:	46bd      	mov	sp, r7
 8003634:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003638:	4770      	bx	lr
 800363a:	bf00      	nop
 800363c:	200036c4 	.word	0x200036c4
 8003640:	200036d8 	.word	0x200036d8

08003644 <OsTaskDelAction>:

LITE_OS_SEC_TEXT_INIT STATIC BOOL OsTaskDelAction(LosTaskCB *taskCB, BOOL useUsrStack)
{
 8003644:	b590      	push	{r4, r7, lr}
 8003646:	b08b      	sub	sp, #44	; 0x2c
 8003648:	af00      	add	r7, sp, #0
 800364a:	6078      	str	r0, [r7, #4]
 800364c:	6039      	str	r1, [r7, #0]
 800364e:	4b32      	ldr	r3, [pc, #200]	; (8003718 <OsTaskDelAction+0xd4>)
 8003650:	681b      	ldr	r3, [r3, #0]
 8003652:	627b      	str	r3, [r7, #36]	; 0x24
 8003654:	f04f 0300 	mov.w	r3, #0
    VOID *pool = (VOID *)m_aucSysMem1;
 8003658:	4b30      	ldr	r3, [pc, #192]	; (800371c <OsTaskDelAction+0xd8>)
 800365a:	681b      	ldr	r3, [r3, #0]
 800365c:	60bb      	str	r3, [r7, #8]
    UINTPTR taskStack;

    LOS_TRACE(TASK_DELETE, taskCB->taskId, taskCB->taskStatus, taskCB->usrStack);
 800365e:	2300      	movs	r3, #0
 8003660:	617b      	str	r3, [r7, #20]
 8003662:	687b      	ldr	r3, [r7, #4]
 8003664:	695b      	ldr	r3, [r3, #20]
 8003666:	61bb      	str	r3, [r7, #24]
 8003668:	687b      	ldr	r3, [r7, #4]
 800366a:	889b      	ldrh	r3, [r3, #4]
 800366c:	61fb      	str	r3, [r7, #28]
 800366e:	687b      	ldr	r3, [r7, #4]
 8003670:	7adb      	ldrb	r3, [r3, #11]
 8003672:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8003676:	b2db      	uxtb	r3, r3
 8003678:	623b      	str	r3, [r7, #32]
 800367a:	2304      	movs	r3, #4
 800367c:	60fb      	str	r3, [r7, #12]
 800367e:	68fb      	ldr	r3, [r7, #12]
 8003680:	2b01      	cmp	r3, #1
 8003682:	d915      	bls.n	80036b0 <OsTaskDelAction+0x6c>
 8003684:	4b26      	ldr	r3, [pc, #152]	; (8003720 <OsTaskDelAction+0xdc>)
 8003686:	681b      	ldr	r3, [r3, #0]
 8003688:	2b00      	cmp	r3, #0
 800368a:	d011      	beq.n	80036b0 <OsTaskDelAction+0x6c>
 800368c:	4b24      	ldr	r3, [pc, #144]	; (8003720 <OsTaskDelAction+0xdc>)
 800368e:	681c      	ldr	r4, [r3, #0]
 8003690:	69b9      	ldr	r1, [r7, #24]
 8003692:	68fb      	ldr	r3, [r7, #12]
 8003694:	2b02      	cmp	r3, #2
 8003696:	d904      	bls.n	80036a2 <OsTaskDelAction+0x5e>
 8003698:	f107 0314 	add.w	r3, r7, #20
 800369c:	f103 0208 	add.w	r2, r3, #8
 80036a0:	e000      	b.n	80036a4 <OsTaskDelAction+0x60>
 80036a2:	2200      	movs	r2, #0
 80036a4:	68fb      	ldr	r3, [r7, #12]
 80036a6:	b29b      	uxth	r3, r3
 80036a8:	3b02      	subs	r3, #2
 80036aa:	b29b      	uxth	r3, r3
 80036ac:	2042      	movs	r0, #66	; 0x42
 80036ae:	47a0      	blx	r4
#ifdef LOSCFG_KERNEL_INTERMIT
    if (g_taskDelHook != NULL) {
        g_taskDelHook(taskCB);
    }
#endif
    if (taskCB->taskStatus & OS_TASK_STATUS_RUNNING) {
 80036b0:	687b      	ldr	r3, [r7, #4]
 80036b2:	889b      	ldrh	r3, [r3, #4]
 80036b4:	f003 0310 	and.w	r3, r3, #16
 80036b8:	2b00      	cmp	r3, #0
 80036ba:	d00a      	beq.n	80036d2 <OsTaskDelAction+0x8e>
#ifdef LOSCFG_TASK_STATIC_ALLOCATION
        if (useUsrStack) {
            LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
        } else {
#endif
            LOS_ListTailInsert(&g_taskRecycleList, &taskCB->pendList);
 80036bc:	687b      	ldr	r3, [r7, #4]
 80036be:	3340      	adds	r3, #64	; 0x40
 80036c0:	4619      	mov	r1, r3
 80036c2:	4818      	ldr	r0, [pc, #96]	; (8003724 <OsTaskDelAction+0xe0>)
 80036c4:	f7ff f9d8 	bl	8002a78 <LOS_ListTailInsert>
#ifdef LOSCFG_TASK_STATIC_ALLOCATION
        }
#endif
        OsTaskDelActionOnRun(taskCB);
 80036c8:	6878      	ldr	r0, [r7, #4]
 80036ca:	f7ff ff8d 	bl	80035e8 <OsTaskDelActionOnRun>
        return TRUE;
 80036ce:	2301      	movs	r3, #1
 80036d0:	e017      	b.n	8003702 <OsTaskDelAction+0xbe>
    }

    taskCB->taskStatus = OS_TASK_STATUS_UNUSED;
 80036d2:	687b      	ldr	r3, [r7, #4]
 80036d4:	2201      	movs	r2, #1
 80036d6:	809a      	strh	r2, [r3, #4]
    LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
 80036d8:	687b      	ldr	r3, [r7, #4]
 80036da:	3340      	adds	r3, #64	; 0x40
 80036dc:	4619      	mov	r1, r3
 80036de:	4812      	ldr	r0, [pc, #72]	; (8003728 <OsTaskDelAction+0xe4>)
 80036e0:	f7ff f9b1 	bl	8002a46 <LOS_ListAdd>
    if (useUsrStack == FALSE) {
 80036e4:	683b      	ldr	r3, [r7, #0]
 80036e6:	2b00      	cmp	r3, #0
 80036e8:	d107      	bne.n	80036fa <OsTaskDelAction+0xb6>
#ifdef LOSCFG_TASK_STACK_PROTECT
        taskStack = taskCB->topOfStack - MMU_4K;
        OsTaskStackProtect(taskStack, MMU_4K, ACCESS_PERM_RW_RW);
#else
        taskStack = taskCB->topOfStack;
 80036ea:	687b      	ldr	r3, [r7, #4]
 80036ec:	691b      	ldr	r3, [r3, #16]
 80036ee:	613b      	str	r3, [r7, #16]
#ifdef LOSCFG_EXC_INTERACTION
        if (taskStack < (UINTPTR)m_aucSysMem1) {
            pool = (VOID *)m_aucSysMem0;
        }
#endif
        (VOID)LOS_MemFree(pool, (VOID *)taskStack);
 80036f0:	693b      	ldr	r3, [r7, #16]
 80036f2:	4619      	mov	r1, r3
 80036f4:	68b8      	ldr	r0, [r7, #8]
 80036f6:	f005 ff45 	bl	8009584 <LOS_MemFree>
    }
    taskCB->topOfStack = 0;
 80036fa:	687b      	ldr	r3, [r7, #4]
 80036fc:	2200      	movs	r2, #0
 80036fe:	611a      	str	r2, [r3, #16]
    return FALSE;
 8003700:	2300      	movs	r3, #0
}
 8003702:	4a05      	ldr	r2, [pc, #20]	; (8003718 <OsTaskDelAction+0xd4>)
 8003704:	6811      	ldr	r1, [r2, #0]
 8003706:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003708:	4051      	eors	r1, r2
 800370a:	d001      	beq.n	8003710 <OsTaskDelAction+0xcc>
 800370c:	f000 ff66 	bl	80045dc <__stack_chk_fail>
 8003710:	4618      	mov	r0, r3
 8003712:	372c      	adds	r7, #44	; 0x2c
 8003714:	46bd      	mov	sp, r7
 8003716:	bd90      	pop	{r4, r7, pc}
 8003718:	0802012c 	.word	0x0802012c
 800371c:	200021c0 	.word	0x200021c0
 8003720:	20000768 	.word	0x20000768
 8003724:	200036c8 	.word	0x200036c8
 8003728:	200036d0 	.word	0x200036d0

0800372c <OsTaskDeleteCheckOnRun>:
 * 2. Do the deletion when preemption is disabled
 * 3. Do the deletion in hard-irq
 * then LOS_TaskDelete will directly return with 'ret' value.
 */
LITE_OS_SEC_TEXT_INIT STATIC BOOL OsTaskDeleteCheckOnRun(LosTaskCB *taskCB, UINT32 *ret)
{
 800372c:	b580      	push	{r7, lr}
 800372e:	b082      	sub	sp, #8
 8003730:	af00      	add	r7, sp, #0
 8003732:	6078      	str	r0, [r7, #4]
 8003734:	6039      	str	r1, [r7, #0]
    /* init default out return value */
    *ret = LOS_OK;
 8003736:	683b      	ldr	r3, [r7, #0]
 8003738:	2200      	movs	r2, #0
 800373a:	601a      	str	r2, [r3, #0]
        *ret = OsTaskSyncWait(taskCB);
        return FALSE;
    }
#endif

    if (!OsPreemptableInSched()) {
 800373c:	f7ff fa34 	bl	8002ba8 <OsPreemptableInSched>
 8003740:	4603      	mov	r3, r0
 8003742:	2b00      	cmp	r3, #0
 8003744:	d104      	bne.n	8003750 <OsTaskDeleteCheckOnRun+0x24>
        /* If the task is running and scheduler is locked then you can not delete it */
        *ret = LOS_ERRNO_TSK_DELETE_LOCKED;
 8003746:	683b      	ldr	r3, [r7, #0]
 8003748:	4a09      	ldr	r2, [pc, #36]	; (8003770 <OsTaskDeleteCheckOnRun+0x44>)
 800374a:	601a      	str	r2, [r3, #0]
        return FALSE;
 800374c:	2300      	movs	r3, #0
 800374e:	e00a      	b.n	8003766 <OsTaskDeleteCheckOnRun+0x3a>
    }

    if (OS_INT_ACTIVE) {
 8003750:	f7fe ff86 	bl	8002660 <IntActive>
 8003754:	4603      	mov	r3, r0
 8003756:	2b00      	cmp	r3, #0
 8003758:	d004      	beq.n	8003764 <OsTaskDeleteCheckOnRun+0x38>
        /*
         * delete running task in interrupt.
         * mask "kill" signal and later deletion will be handled.
         */
        taskCB->signal = SIGNAL_KILL;
 800375a:	687b      	ldr	r3, [r7, #4]
 800375c:	2201      	movs	r2, #1
 800375e:	671a      	str	r2, [r3, #112]	; 0x70
        return FALSE;
 8003760:	2300      	movs	r3, #0
 8003762:	e000      	b.n	8003766 <OsTaskDeleteCheckOnRun+0x3a>
    }

    return TRUE;
 8003764:	2301      	movs	r3, #1
}
 8003766:	4618      	mov	r0, r3
 8003768:	3708      	adds	r7, #8
 800376a:	46bd      	mov	sp, r7
 800376c:	bd80      	pop	{r7, pc}
 800376e:	bf00      	nop
 8003770:	0300020b 	.word	0x0300020b

08003774 <OsTaskCBInit>:

LITE_OS_SEC_TEXT_INIT STATIC VOID OsTaskCBInit(LosTaskCB *taskCB, const TSK_INIT_PARAM_S *initParam,
                                               VOID *stackPtr, const VOID *topStack, BOOL useUsrStack)
{
 8003774:	b580      	push	{r7, lr}
 8003776:	b084      	sub	sp, #16
 8003778:	af00      	add	r7, sp, #0
 800377a:	60f8      	str	r0, [r7, #12]
 800377c:	60b9      	str	r1, [r7, #8]
 800377e:	607a      	str	r2, [r7, #4]
 8003780:	603b      	str	r3, [r7, #0]
    taskCB->stackPointer = stackPtr;
 8003782:	68fb      	ldr	r3, [r7, #12]
 8003784:	687a      	ldr	r2, [r7, #4]
 8003786:	601a      	str	r2, [r3, #0]
#ifdef LOSCFG_OBSOLETE_API
    taskCB->args[0]      = initParam->auwArgs[0]; /* 0~3: just for args array index */
 8003788:	68bb      	ldr	r3, [r7, #8]
 800378a:	689a      	ldr	r2, [r3, #8]
 800378c:	68fb      	ldr	r3, [r7, #12]
 800378e:	62da      	str	r2, [r3, #44]	; 0x2c
    taskCB->args[1]      = initParam->auwArgs[1];
 8003790:	68bb      	ldr	r3, [r7, #8]
 8003792:	68da      	ldr	r2, [r3, #12]
 8003794:	68fb      	ldr	r3, [r7, #12]
 8003796:	631a      	str	r2, [r3, #48]	; 0x30
    taskCB->args[2]      = initParam->auwArgs[2];
 8003798:	68bb      	ldr	r3, [r7, #8]
 800379a:	691a      	ldr	r2, [r3, #16]
 800379c:	68fb      	ldr	r3, [r7, #12]
 800379e:	635a      	str	r2, [r3, #52]	; 0x34
    taskCB->args[3]      = initParam->auwArgs[3];
 80037a0:	68bb      	ldr	r3, [r7, #8]
 80037a2:	695a      	ldr	r2, [r3, #20]
 80037a4:	68fb      	ldr	r3, [r7, #12]
 80037a6:	639a      	str	r2, [r3, #56]	; 0x38
#else
    taskCB->args         = initParam->pArgs;
#endif
    taskCB->topOfStack   = (UINTPTR)topStack;
 80037a8:	683a      	ldr	r2, [r7, #0]
 80037aa:	68fb      	ldr	r3, [r7, #12]
 80037ac:	611a      	str	r2, [r3, #16]
    taskCB->stackSize    = initParam->uwStackSize;
 80037ae:	68bb      	ldr	r3, [r7, #8]
 80037b0:	699a      	ldr	r2, [r3, #24]
 80037b2:	68fb      	ldr	r3, [r7, #12]
 80037b4:	60da      	str	r2, [r3, #12]
    taskCB->taskSem      = NULL;
 80037b6:	68fb      	ldr	r3, [r7, #12]
 80037b8:	2200      	movs	r2, #0
 80037ba:	61da      	str	r2, [r3, #28]
#ifdef LOSCFG_COMPAT_POSIX
    taskCB->threadJoin   = NULL;
 80037bc:	68fb      	ldr	r3, [r7, #12]
 80037be:	2200      	movs	r2, #0
 80037c0:	621a      	str	r2, [r3, #32]
#endif
    taskCB->taskMux      = NULL;
 80037c2:	68fb      	ldr	r3, [r7, #12]
 80037c4:	2200      	movs	r2, #0
 80037c6:	629a      	str	r2, [r3, #40]	; 0x28
    taskCB->taskStatus   = OS_TASK_STATUS_SUSPEND;
 80037c8:	68fb      	ldr	r3, [r7, #12]
 80037ca:	2202      	movs	r2, #2
 80037cc:	809a      	strh	r2, [r3, #4]
    taskCB->priority     = initParam->usTaskPrio;
 80037ce:	68bb      	ldr	r3, [r7, #8]
 80037d0:	889a      	ldrh	r2, [r3, #4]
 80037d2:	68fb      	ldr	r3, [r7, #12]
 80037d4:	80da      	strh	r2, [r3, #6]
    taskCB->priBitMap    = 0;
 80037d6:	68fb      	ldr	r3, [r7, #12]
 80037d8:	2200      	movs	r2, #0
 80037da:	66da      	str	r2, [r3, #108]	; 0x6c
    taskCB->taskEntry    = initParam->pfnTaskEntry;
 80037dc:	68bb      	ldr	r3, [r7, #8]
 80037de:	681a      	ldr	r2, [r3, #0]
 80037e0:	68fb      	ldr	r3, [r7, #12]
 80037e2:	619a      	str	r2, [r3, #24]
#ifdef LOSCFG_BASE_IPC_EVENT
    LOS_ListInit(&taskCB->event.stEventList);
 80037e4:	68fb      	ldr	r3, [r7, #12]
 80037e6:	3358      	adds	r3, #88	; 0x58
 80037e8:	4618      	mov	r0, r3
 80037ea:	f7ff f91c 	bl	8002a26 <LOS_ListInit>
    taskCB->event.uwEventID = 0;
 80037ee:	68fb      	ldr	r3, [r7, #12]
 80037f0:	2200      	movs	r2, #0
 80037f2:	655a      	str	r2, [r3, #84]	; 0x54
    taskCB->eventMask    = 0;
 80037f4:	68fb      	ldr	r3, [r7, #12]
 80037f6:	2200      	movs	r2, #0
 80037f8:	661a      	str	r2, [r3, #96]	; 0x60
#endif

    taskCB->taskName     = initParam->pcName;
 80037fa:	68bb      	ldr	r3, [r7, #8]
 80037fc:	69da      	ldr	r2, [r3, #28]
 80037fe:	68fb      	ldr	r3, [r7, #12]
 8003800:	63da      	str	r2, [r3, #60]	; 0x3c
    taskCB->msg          = NULL;
 8003802:	68fb      	ldr	r3, [r7, #12]
 8003804:	2200      	movs	r2, #0
 8003806:	669a      	str	r2, [r3, #104]	; 0x68

     /* set the task is detached or joinable */
    taskCB->taskFlags    = ((initParam->uwResved == LOS_TASK_STATUS_DETACHED) ? OS_TASK_FLAG_DETACHED : 0);
 8003808:	68bb      	ldr	r3, [r7, #8]
 800380a:	6a1b      	ldr	r3, [r3, #32]
 800380c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003810:	d101      	bne.n	8003816 <OsTaskCBInit+0xa2>
 8003812:	2101      	movs	r1, #1
 8003814:	e000      	b.n	8003818 <OsTaskCBInit+0xa4>
 8003816:	2100      	movs	r1, #0
 8003818:	68fa      	ldr	r2, [r7, #12]
 800381a:	6893      	ldr	r3, [r2, #8]
 800381c:	f361 031e 	bfi	r3, r1, #0, #31
 8003820:	6093      	str	r3, [r2, #8]
    taskCB->usrStack     = useUsrStack ? 1 : 0; /* 0: dynamicly alloc stack space;1: user inputs stack space */
 8003822:	69bb      	ldr	r3, [r7, #24]
 8003824:	2b00      	cmp	r3, #0
 8003826:	bf14      	ite	ne
 8003828:	2301      	movne	r3, #1
 800382a:	2300      	moveq	r3, #0
 800382c:	b2d9      	uxtb	r1, r3
 800382e:	68fa      	ldr	r2, [r7, #12]
 8003830:	7ad3      	ldrb	r3, [r2, #11]
 8003832:	f361 13c7 	bfi	r3, r1, #7, #1
 8003836:	72d3      	strb	r3, [r2, #11]
    taskCB->signal       = SIGNAL_NONE;
 8003838:	68fb      	ldr	r3, [r7, #12]
 800383a:	2200      	movs	r2, #0
 800383c:	671a      	str	r2, [r3, #112]	; 0x70
    taskCB->lastCpu      = OS_TASK_INVALID_CPUID;
#endif
    taskCB->cpuAffiMask  = (initParam->usCpuAffiMask) ? initParam->usCpuAffiMask : LOSCFG_KERNEL_CPU_MASK;
#endif
#ifdef LOSCFG_BASE_CORE_TIMESLICE
    taskCB->timeSlice    = 0;
 800383e:	68fb      	ldr	r3, [r7, #12]
 8003840:	2200      	movs	r2, #0
 8003842:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
#ifdef LOSCFG_KERNEL_SMP_LOCKDEP
    taskCB->lockDep.waitLock  = NULL;
    taskCB->lockDep.lockDepth = 0;
#endif
#ifdef LOSCFG_DEBUG_SCHED_STATISTICS
    (VOID)memset_s(&taskCB->schedStat, sizeof(SchedStat), 0, sizeof(SchedStat));
 8003846:	68fb      	ldr	r3, [r7, #12]
 8003848:	f103 0078 	add.w	r0, r3, #120	; 0x78
 800384c:	2328      	movs	r3, #40	; 0x28
 800384e:	2200      	movs	r2, #0
 8003850:	2128      	movs	r1, #40	; 0x28
 8003852:	f7fe fc27 	bl	80020a4 <memset_s>
#endif
}
 8003856:	bf00      	nop
 8003858:	3710      	adds	r7, #16
 800385a:	46bd      	mov	sp, r7
 800385c:	bd80      	pop	{r7, pc}
	...

08003860 <OsTaskGetFreeTaskCB>:

STATIC UINT32 OsTaskGetFreeTaskCB(LosTaskCB **taskCB)
{
 8003860:	b580      	push	{r7, lr}
 8003862:	b082      	sub	sp, #8
 8003864:	af00      	add	r7, sp, #0
 8003866:	6078      	str	r0, [r7, #4]
    if (LOS_ListEmpty(&g_losFreeTask)) {
 8003868:	480e      	ldr	r0, [pc, #56]	; (80038a4 <OsTaskGetFreeTaskCB+0x44>)
 800386a:	f7ff f92e 	bl	8002aca <LOS_ListEmpty>
 800386e:	4603      	mov	r3, r0
 8003870:	2b00      	cmp	r3, #0
 8003872:	d001      	beq.n	8003878 <OsTaskGetFreeTaskCB+0x18>
        return LOS_ERRNO_TSK_TCB_UNAVAILABLE;
 8003874:	4b0c      	ldr	r3, [pc, #48]	; (80038a8 <OsTaskGetFreeTaskCB+0x48>)
 8003876:	e011      	b.n	800389c <OsTaskGetFreeTaskCB+0x3c>
    }

    *taskCB = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&g_losFreeTask));
 8003878:	4b0a      	ldr	r3, [pc, #40]	; (80038a4 <OsTaskGetFreeTaskCB+0x44>)
 800387a:	685b      	ldr	r3, [r3, #4]
 800387c:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
 8003880:	687b      	ldr	r3, [r7, #4]
 8003882:	601a      	str	r2, [r3, #0]
    if (*taskCB == NULL) {
 8003884:	687b      	ldr	r3, [r7, #4]
 8003886:	681b      	ldr	r3, [r3, #0]
 8003888:	2b00      	cmp	r3, #0
 800388a:	d101      	bne.n	8003890 <OsTaskGetFreeTaskCB+0x30>
        return LOS_ERRNO_TSK_PTR_NULL;
 800388c:	4b07      	ldr	r3, [pc, #28]	; (80038ac <OsTaskGetFreeTaskCB+0x4c>)
 800388e:	e005      	b.n	800389c <OsTaskGetFreeTaskCB+0x3c>
    }
    LOS_ListDelete(LOS_DL_LIST_FIRST(&g_losFreeTask));
 8003890:	4b04      	ldr	r3, [pc, #16]	; (80038a4 <OsTaskGetFreeTaskCB+0x44>)
 8003892:	685b      	ldr	r3, [r3, #4]
 8003894:	4618      	mov	r0, r3
 8003896:	f7ff f8fe 	bl	8002a96 <LOS_ListDelete>
    return LOS_OK;
 800389a:	2300      	movs	r3, #0
}
 800389c:	4618      	mov	r0, r3
 800389e:	3708      	adds	r7, #8
 80038a0:	46bd      	mov	sp, r7
 80038a2:	bd80      	pop	{r7, pc}
 80038a4:	200036d0 	.word	0x200036d0
 80038a8:	02000211 	.word	0x02000211
 80038ac:	02000201 	.word	0x02000201

080038b0 <OsTaskCreateOnly>:

STATIC UINT32 OsTaskCreateOnly(UINT32 *taskId, TSK_INIT_PARAM_S *initParam, VOID *topStack, BOOL useUsrStack)
{
 80038b0:	b590      	push	{r4, r7, lr}
 80038b2:	b08f      	sub	sp, #60	; 0x3c
 80038b4:	af02      	add	r7, sp, #8
 80038b6:	60f8      	str	r0, [r7, #12]
 80038b8:	60b9      	str	r1, [r7, #8]
 80038ba:	607a      	str	r2, [r7, #4]
 80038bc:	603b      	str	r3, [r7, #0]
 80038be:	4b4d      	ldr	r3, [pc, #308]	; (80039f4 <OsTaskCreateOnly+0x144>)
 80038c0:	681b      	ldr	r3, [r3, #0]
 80038c2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80038c4:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave, errRet;
    VOID *stackPtr = NULL;
 80038c8:	2300      	movs	r3, #0
 80038ca:	627b      	str	r3, [r7, #36]	; 0x24
    LosTaskCB *taskCB = NULL;
 80038cc:	2300      	movs	r3, #0
 80038ce:	61bb      	str	r3, [r7, #24]
    VOID *pool = NULL;
 80038d0:	2300      	movs	r3, #0
 80038d2:	61fb      	str	r3, [r7, #28]
#ifdef LOSCFG_TASK_STATIC_ALLOCATION
    if (useUsrStack) {
        errRet = OsTaskCreateParamCheckStatic(taskId, initParam, topStack);
    } else {
#endif
        errRet = OsTaskCreateParamCheck(taskId, initParam, &pool);
 80038d4:	f107 031c 	add.w	r3, r7, #28
 80038d8:	461a      	mov	r2, r3
 80038da:	68b9      	ldr	r1, [r7, #8]
 80038dc:	68f8      	ldr	r0, [r7, #12]
 80038de:	f7ff fdfd 	bl	80034dc <OsTaskCreateParamCheck>
 80038e2:	6238      	str	r0, [r7, #32]
#ifdef LOSCFG_TASK_STATIC_ALLOCATION
    }
#endif
    if (errRet != LOS_OK) {
 80038e4:	6a3b      	ldr	r3, [r7, #32]
 80038e6:	2b00      	cmp	r3, #0
 80038e8:	d001      	beq.n	80038ee <OsTaskCreateOnly+0x3e>
        return errRet;
 80038ea:	6a3b      	ldr	r3, [r7, #32]
 80038ec:	e077      	b.n	80039de <OsTaskCreateOnly+0x12e>
    }

    SCHEDULER_LOCK(intSave);
 80038ee:	f107 0314 	add.w	r3, r7, #20
 80038f2:	4619      	mov	r1, r3
 80038f4:	4840      	ldr	r0, [pc, #256]	; (80039f8 <OsTaskCreateOnly+0x148>)
 80038f6:	f7ff f997 	bl	8002c28 <LOS_SpinLockSave>
    errRet = OsTaskGetFreeTaskCB(&taskCB);
 80038fa:	f107 0318 	add.w	r3, r7, #24
 80038fe:	4618      	mov	r0, r3
 8003900:	f7ff ffae 	bl	8003860 <OsTaskGetFreeTaskCB>
 8003904:	6238      	str	r0, [r7, #32]
    if (errRet != LOS_OK) {
 8003906:	6a3b      	ldr	r3, [r7, #32]
 8003908:	2b00      	cmp	r3, #0
 800390a:	d161      	bne.n	80039d0 <OsTaskCreateOnly+0x120>
        goto LOS_ERREND;
    }
    SCHEDULER_UNLOCK(intSave);
 800390c:	697b      	ldr	r3, [r7, #20]
 800390e:	4619      	mov	r1, r3
 8003910:	4839      	ldr	r0, [pc, #228]	; (80039f8 <OsTaskCreateOnly+0x148>)
 8003912:	f7ff f997 	bl	8002c44 <LOS_SpinUnlockRestore>

    errRet = OsTaskSyncCreate(taskCB);
 8003916:	69bb      	ldr	r3, [r7, #24]
 8003918:	4618      	mov	r0, r3
 800391a:	f7ff fe45 	bl	80035a8 <OsTaskSyncCreate>
 800391e:	6238      	str	r0, [r7, #32]
    if (errRet != LOS_OK) {
 8003920:	6a3b      	ldr	r3, [r7, #32]
 8003922:	2b00      	cmp	r3, #0
 8003924:	d146      	bne.n	80039b4 <OsTaskCreateOnly+0x104>
        goto LOS_ERREND_REWIND_TCB;
    }

    if (useUsrStack == FALSE) {
 8003926:	683b      	ldr	r3, [r7, #0]
 8003928:	2b00      	cmp	r3, #0
 800392a:	d110      	bne.n	800394e <OsTaskCreateOnly+0x9e>
        OsTaskStackAlloc(&topStack, initParam->uwStackSize, pool);
 800392c:	68bb      	ldr	r3, [r7, #8]
 800392e:	6999      	ldr	r1, [r3, #24]
 8003930:	69fa      	ldr	r2, [r7, #28]
 8003932:	1d3b      	adds	r3, r7, #4
 8003934:	4618      	mov	r0, r3
 8003936:	f7ff fe25 	bl	8003584 <OsTaskStackAlloc>
        if (topStack == NULL) {
 800393a:	687b      	ldr	r3, [r7, #4]
 800393c:	2b00      	cmp	r3, #0
 800393e:	d106      	bne.n	800394e <OsTaskCreateOnly+0x9e>
            errRet = LOS_ERRNO_TSK_NO_MEMORY;
 8003940:	4b2e      	ldr	r3, [pc, #184]	; (80039fc <OsTaskCreateOnly+0x14c>)
 8003942:	623b      	str	r3, [r7, #32]
            OsTaskSyncDestroy(taskCB);
 8003944:	69bb      	ldr	r3, [r7, #24]
 8003946:	4618      	mov	r0, r3
 8003948:	f7ff fe39 	bl	80035be <OsTaskSyncDestroy>
            goto LOS_ERREND_REWIND_TCB;
 800394c:	e033      	b.n	80039b6 <OsTaskCreateOnly+0x106>
        }
    }
    stackPtr = OsTaskStackInit(taskCB->taskId, initParam->uwStackSize, topStack);
 800394e:	69bb      	ldr	r3, [r7, #24]
 8003950:	6958      	ldr	r0, [r3, #20]
 8003952:	68bb      	ldr	r3, [r7, #8]
 8003954:	699b      	ldr	r3, [r3, #24]
 8003956:	687a      	ldr	r2, [r7, #4]
 8003958:	4619      	mov	r1, r3
 800395a:	f012 fdad 	bl	80164b8 <OsTaskStackInit>
 800395e:	6278      	str	r0, [r7, #36]	; 0x24
    OsTaskCBInit(taskCB, initParam, stackPtr, topStack, useUsrStack);
 8003960:	69b8      	ldr	r0, [r7, #24]
 8003962:	687a      	ldr	r2, [r7, #4]
 8003964:	683b      	ldr	r3, [r7, #0]
 8003966:	9300      	str	r3, [sp, #0]
 8003968:	4613      	mov	r3, r2
 800396a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800396c:	68b9      	ldr	r1, [r7, #8]
 800396e:	f7ff ff01 	bl	8003774 <OsTaskCBInit>

    if (OsConsoleIDSetHook != NULL) {
 8003972:	4b23      	ldr	r3, [pc, #140]	; (8003a00 <OsTaskCreateOnly+0x150>)
 8003974:	2b00      	cmp	r3, #0
 8003976:	d009      	beq.n	800398c <OsTaskCreateOnly+0xdc>
        OsConsoleIDSetHook(taskCB->taskId, OsCurrTaskGet()->taskId);
 8003978:	69bb      	ldr	r3, [r7, #24]
 800397a:	695c      	ldr	r4, [r3, #20]
 800397c:	f7ff f979 	bl	8002c72 <OsCurrTaskGet>
 8003980:	4603      	mov	r3, r0
 8003982:	695b      	ldr	r3, [r3, #20]
 8003984:	4619      	mov	r1, r3
 8003986:	4620      	mov	r0, r4
 8003988:	f3af 8000 	nop.w
    }

#ifdef LOSCFG_KERNEL_CPUP
    OsCpupCB *cpup = OsCpupCBGet(taskCB->taskId);
 800398c:	69bb      	ldr	r3, [r7, #24]
 800398e:	695b      	ldr	r3, [r3, #20]
 8003990:	4618      	mov	r0, r3
 8003992:	f010 fd87 	bl	80144a4 <OsCpupCBGet>
 8003996:	62b8      	str	r0, [r7, #40]	; 0x28
    cpup->id = taskCB->taskId;
 8003998:	69bb      	ldr	r3, [r7, #24]
 800399a:	695a      	ldr	r2, [r3, #20]
 800399c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800399e:	601a      	str	r2, [r3, #0]
    cpup->status = taskCB->taskStatus;
 80039a0:	69bb      	ldr	r3, [r7, #24]
 80039a2:	889a      	ldrh	r2, [r3, #4]
 80039a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80039a6:	809a      	strh	r2, [r3, #4]
#endif

    *taskId = taskCB->taskId;
 80039a8:	69bb      	ldr	r3, [r7, #24]
 80039aa:	695a      	ldr	r2, [r3, #20]
 80039ac:	68fb      	ldr	r3, [r7, #12]
 80039ae:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 80039b0:	2300      	movs	r3, #0
 80039b2:	e014      	b.n	80039de <OsTaskCreateOnly+0x12e>
        goto LOS_ERREND_REWIND_TCB;
 80039b4:	bf00      	nop

LOS_ERREND_REWIND_TCB:
    SCHEDULER_LOCK(intSave);
 80039b6:	f107 0314 	add.w	r3, r7, #20
 80039ba:	4619      	mov	r1, r3
 80039bc:	480e      	ldr	r0, [pc, #56]	; (80039f8 <OsTaskCreateOnly+0x148>)
 80039be:	f7ff f933 	bl	8002c28 <LOS_SpinLockSave>
    LOS_ListAdd(&g_losFreeTask, &taskCB->pendList);
 80039c2:	69bb      	ldr	r3, [r7, #24]
 80039c4:	3340      	adds	r3, #64	; 0x40
 80039c6:	4619      	mov	r1, r3
 80039c8:	480e      	ldr	r0, [pc, #56]	; (8003a04 <OsTaskCreateOnly+0x154>)
 80039ca:	f7ff f83c 	bl	8002a46 <LOS_ListAdd>
 80039ce:	e000      	b.n	80039d2 <OsTaskCreateOnly+0x122>
        goto LOS_ERREND;
 80039d0:	bf00      	nop
LOS_ERREND:
    SCHEDULER_UNLOCK(intSave);
 80039d2:	697b      	ldr	r3, [r7, #20]
 80039d4:	4619      	mov	r1, r3
 80039d6:	4808      	ldr	r0, [pc, #32]	; (80039f8 <OsTaskCreateOnly+0x148>)
 80039d8:	f7ff f934 	bl	8002c44 <LOS_SpinUnlockRestore>
    return errRet;
 80039dc:	6a3b      	ldr	r3, [r7, #32]
}
 80039de:	4a05      	ldr	r2, [pc, #20]	; (80039f4 <OsTaskCreateOnly+0x144>)
 80039e0:	6811      	ldr	r1, [r2, #0]
 80039e2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80039e4:	4051      	eors	r1, r2
 80039e6:	d001      	beq.n	80039ec <OsTaskCreateOnly+0x13c>
 80039e8:	f000 fdf8 	bl	80045dc <__stack_chk_fail>
 80039ec:	4618      	mov	r0, r3
 80039ee:	3734      	adds	r7, #52	; 0x34
 80039f0:	46bd      	mov	sp, r7
 80039f2:	bd90      	pop	{r4, r7, pc}
 80039f4:	08020130 	.word	0x08020130
 80039f8:	20000770 	.word	0x20000770
 80039fc:	03000200 	.word	0x03000200
 8003a00:	00000000 	.word	0x00000000
 8003a04:	200036d0 	.word	0x200036d0

08003a08 <OsTaskResume>:

STATIC VOID OsTaskResume(const UINT32 *taskId)
{
 8003a08:	b590      	push	{r4, r7, lr}
 8003a0a:	b08b      	sub	sp, #44	; 0x2c
 8003a0c:	af00      	add	r7, sp, #0
 8003a0e:	6078      	str	r0, [r7, #4]
 8003a10:	4b39      	ldr	r3, [pc, #228]	; (8003af8 <OsTaskResume+0xf0>)
 8003a12:	681b      	ldr	r3, [r3, #0]
 8003a14:	627b      	str	r3, [r7, #36]	; 0x24
 8003a16:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosTaskCB *taskCB = NULL;
 8003a1a:	2300      	movs	r3, #0
 8003a1c:	60fb      	str	r3, [r7, #12]

    taskCB = OS_TCB_FROM_TID(*taskId);
 8003a1e:	4b37      	ldr	r3, [pc, #220]	; (8003afc <OsTaskResume+0xf4>)
 8003a20:	6819      	ldr	r1, [r3, #0]
 8003a22:	687b      	ldr	r3, [r7, #4]
 8003a24:	681a      	ldr	r2, [r3, #0]
 8003a26:	4613      	mov	r3, r2
 8003a28:	009b      	lsls	r3, r3, #2
 8003a2a:	4413      	add	r3, r2
 8003a2c:	015b      	lsls	r3, r3, #5
 8003a2e:	440b      	add	r3, r1
 8003a30:	60fb      	str	r3, [r7, #12]

    SCHEDULER_LOCK(intSave);
 8003a32:	f107 0308 	add.w	r3, r7, #8
 8003a36:	4619      	mov	r1, r3
 8003a38:	4831      	ldr	r0, [pc, #196]	; (8003b00 <OsTaskResume+0xf8>)
 8003a3a:	f7ff f8f5 	bl	8002c28 <LOS_SpinLockSave>

    taskCB->taskStatus &= ~OS_TASK_STATUS_SUSPEND;
 8003a3e:	68fb      	ldr	r3, [r7, #12]
 8003a40:	889b      	ldrh	r3, [r3, #4]
 8003a42:	f023 0302 	bic.w	r3, r3, #2
 8003a46:	b29a      	uxth	r2, r3
 8003a48:	68fb      	ldr	r3, [r7, #12]
 8003a4a:	809a      	strh	r2, [r3, #4]
    taskCB->taskStatus |= OS_TASK_STATUS_READY;
 8003a4c:	68fb      	ldr	r3, [r7, #12]
 8003a4e:	889b      	ldrh	r3, [r3, #4]
 8003a50:	f043 0304 	orr.w	r3, r3, #4
 8003a54:	b29a      	uxth	r2, r3
 8003a56:	68fb      	ldr	r3, [r7, #12]
 8003a58:	809a      	strh	r2, [r3, #4]
    OsPriQueueEnqueue(&taskCB->pendList, taskCB->priority);
 8003a5a:	68fb      	ldr	r3, [r7, #12]
 8003a5c:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8003a60:	68fb      	ldr	r3, [r7, #12]
 8003a62:	88db      	ldrh	r3, [r3, #6]
 8003a64:	4619      	mov	r1, r3
 8003a66:	4610      	mov	r0, r2
 8003a68:	f005 fad0 	bl	800900c <OsPriQueueEnqueue>

    SCHEDULER_UNLOCK(intSave);
 8003a6c:	68bb      	ldr	r3, [r7, #8]
 8003a6e:	4619      	mov	r1, r3
 8003a70:	4823      	ldr	r0, [pc, #140]	; (8003b00 <OsTaskResume+0xf8>)
 8003a72:	f7ff f8e7 	bl	8002c44 <LOS_SpinUnlockRestore>

    LOS_TRACE(TASK_CREATE, taskCB->taskId, taskCB->taskStatus, taskCB->priority);
 8003a76:	2300      	movs	r3, #0
 8003a78:	617b      	str	r3, [r7, #20]
 8003a7a:	68fb      	ldr	r3, [r7, #12]
 8003a7c:	695b      	ldr	r3, [r3, #20]
 8003a7e:	61bb      	str	r3, [r7, #24]
 8003a80:	68fb      	ldr	r3, [r7, #12]
 8003a82:	889b      	ldrh	r3, [r3, #4]
 8003a84:	61fb      	str	r3, [r7, #28]
 8003a86:	68fb      	ldr	r3, [r7, #12]
 8003a88:	88db      	ldrh	r3, [r3, #6]
 8003a8a:	623b      	str	r3, [r7, #32]
 8003a8c:	2304      	movs	r3, #4
 8003a8e:	613b      	str	r3, [r7, #16]
 8003a90:	693b      	ldr	r3, [r7, #16]
 8003a92:	2b01      	cmp	r3, #1
 8003a94:	d915      	bls.n	8003ac2 <OsTaskResume+0xba>
 8003a96:	4b1b      	ldr	r3, [pc, #108]	; (8003b04 <OsTaskResume+0xfc>)
 8003a98:	681b      	ldr	r3, [r3, #0]
 8003a9a:	2b00      	cmp	r3, #0
 8003a9c:	d011      	beq.n	8003ac2 <OsTaskResume+0xba>
 8003a9e:	4b19      	ldr	r3, [pc, #100]	; (8003b04 <OsTaskResume+0xfc>)
 8003aa0:	681c      	ldr	r4, [r3, #0]
 8003aa2:	69b9      	ldr	r1, [r7, #24]
 8003aa4:	693b      	ldr	r3, [r7, #16]
 8003aa6:	2b02      	cmp	r3, #2
 8003aa8:	d904      	bls.n	8003ab4 <OsTaskResume+0xac>
 8003aaa:	f107 0314 	add.w	r3, r7, #20
 8003aae:	f103 0208 	add.w	r2, r3, #8
 8003ab2:	e000      	b.n	8003ab6 <OsTaskResume+0xae>
 8003ab4:	2200      	movs	r2, #0
 8003ab6:	693b      	ldr	r3, [r7, #16]
 8003ab8:	b29b      	uxth	r3, r3
 8003aba:	3b02      	subs	r3, #2
 8003abc:	b29b      	uxth	r3, r3
 8003abe:	2040      	movs	r0, #64	; 0x40
 8003ac0:	47a0      	blx	r4

    /* in case created task not running on this core,
       schedule or not depends on other schedulers status. */
    LOS_MpSchedule(OS_MP_CPU_ALL);
 8003ac2:	2001      	movs	r0, #1
 8003ac4:	f7ff f8e3 	bl	8002c8e <LOS_MpSchedule>
    if (OS_SCHEDULER_ACTIVE) {
 8003ac8:	f7ff f811 	bl	8002aee <ArchCurrCpuid>
 8003acc:	4603      	mov	r3, r0
 8003ace:	2201      	movs	r2, #1
 8003ad0:	409a      	lsls	r2, r3
 8003ad2:	4b0d      	ldr	r3, [pc, #52]	; (8003b08 <OsTaskResume+0x100>)
 8003ad4:	681b      	ldr	r3, [r3, #0]
 8003ad6:	4013      	ands	r3, r2
 8003ad8:	2b00      	cmp	r3, #0
 8003ada:	d001      	beq.n	8003ae0 <OsTaskResume+0xd8>
        LOS_Schedule();
 8003adc:	f7ff f880 	bl	8002be0 <LOS_Schedule>
    }
}
 8003ae0:	bf00      	nop
 8003ae2:	4b05      	ldr	r3, [pc, #20]	; (8003af8 <OsTaskResume+0xf0>)
 8003ae4:	681a      	ldr	r2, [r3, #0]
 8003ae6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003ae8:	405a      	eors	r2, r3
 8003aea:	d001      	beq.n	8003af0 <OsTaskResume+0xe8>
 8003aec:	f000 fd76 	bl	80045dc <__stack_chk_fail>
 8003af0:	372c      	adds	r7, #44	; 0x2c
 8003af2:	46bd      	mov	sp, r7
 8003af4:	bd90      	pop	{r4, r7, pc}
 8003af6:	bf00      	nop
 8003af8:	08020134 	.word	0x08020134
 8003afc:	200036c4 	.word	0x200036c4
 8003b00:	20000770 	.word	0x20000770
 8003b04:	20000768 	.word	0x20000768
 8003b08:	200036dc 	.word	0x200036dc

08003b0c <LOS_TaskCreateOnly>:
    return LOS_OK;
}
#endif

LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreateOnly(UINT32 *taskId, TSK_INIT_PARAM_S *initParam)
{
 8003b0c:	b580      	push	{r7, lr}
 8003b0e:	b082      	sub	sp, #8
 8003b10:	af00      	add	r7, sp, #0
 8003b12:	6078      	str	r0, [r7, #4]
 8003b14:	6039      	str	r1, [r7, #0]
    return OsTaskCreateOnly(taskId, initParam, NULL, FALSE);
 8003b16:	2300      	movs	r3, #0
 8003b18:	2200      	movs	r2, #0
 8003b1a:	6839      	ldr	r1, [r7, #0]
 8003b1c:	6878      	ldr	r0, [r7, #4]
 8003b1e:	f7ff fec7 	bl	80038b0 <OsTaskCreateOnly>
 8003b22:	4603      	mov	r3, r0
}
 8003b24:	4618      	mov	r0, r3
 8003b26:	3708      	adds	r7, #8
 8003b28:	46bd      	mov	sp, r7
 8003b2a:	bd80      	pop	{r7, pc}

08003b2c <LOS_TaskCreate>:

LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskCreate(UINT32 *taskId, TSK_INIT_PARAM_S *initParam)
{
 8003b2c:	b580      	push	{r7, lr}
 8003b2e:	b084      	sub	sp, #16
 8003b30:	af00      	add	r7, sp, #0
 8003b32:	6078      	str	r0, [r7, #4]
 8003b34:	6039      	str	r1, [r7, #0]
    UINT32 ret;

    ret = LOS_TaskCreateOnly(taskId, initParam);
 8003b36:	6839      	ldr	r1, [r7, #0]
 8003b38:	6878      	ldr	r0, [r7, #4]
 8003b3a:	f7ff ffe7 	bl	8003b0c <LOS_TaskCreateOnly>
 8003b3e:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 8003b40:	68fb      	ldr	r3, [r7, #12]
 8003b42:	2b00      	cmp	r3, #0
 8003b44:	d001      	beq.n	8003b4a <LOS_TaskCreate+0x1e>
        return ret;
 8003b46:	68fb      	ldr	r3, [r7, #12]
 8003b48:	e003      	b.n	8003b52 <LOS_TaskCreate+0x26>
    }

    OsTaskResume(taskId);
 8003b4a:	6878      	ldr	r0, [r7, #4]
 8003b4c:	f7ff ff5c 	bl	8003a08 <OsTaskResume>

    return LOS_OK;
 8003b50:	2300      	movs	r3, #0
}
 8003b52:	4618      	mov	r0, r3
 8003b54:	3710      	adds	r7, #16
 8003b56:	46bd      	mov	sp, r7
 8003b58:	bd80      	pop	{r7, pc}
	...

08003b5c <LOS_TaskDelete>:

LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskDelete(UINT32 taskId)
{
 8003b5c:	b580      	push	{r7, lr}
 8003b5e:	b088      	sub	sp, #32
 8003b60:	af00      	add	r7, sp, #0
 8003b62:	6078      	str	r0, [r7, #4]
 8003b64:	4b56      	ldr	r3, [pc, #344]	; (8003cc0 <LOS_TaskDelete+0x164>)
 8003b66:	681b      	ldr	r3, [r3, #0]
 8003b68:	61fb      	str	r3, [r7, #28]
 8003b6a:	f04f 0300 	mov.w	r3, #0
    LosTaskCB *taskCB = NULL;
 8003b6e:	2300      	movs	r3, #0
 8003b70:	61bb      	str	r3, [r7, #24]
    UINT32 intSave;
    UINT32 errRet = LOS_OK;
 8003b72:	2300      	movs	r3, #0
 8003b74:	617b      	str	r3, [r7, #20]
    UINT16 tempStatus;

    if (OS_TASK_ID_CHECK_INVALID(taskId)) {
 8003b76:	4b53      	ldr	r3, [pc, #332]	; (8003cc4 <LOS_TaskDelete+0x168>)
 8003b78:	681b      	ldr	r3, [r3, #0]
 8003b7a:	687a      	ldr	r2, [r7, #4]
 8003b7c:	429a      	cmp	r2, r3
 8003b7e:	d301      	bcc.n	8003b84 <LOS_TaskDelete+0x28>
        return LOS_ERRNO_TSK_ID_INVALID;
 8003b80:	4b51      	ldr	r3, [pc, #324]	; (8003cc8 <LOS_TaskDelete+0x16c>)
 8003b82:	e092      	b.n	8003caa <LOS_TaskDelete+0x14e>
    }

    taskCB = OS_TCB_FROM_TID(taskId);
 8003b84:	4b51      	ldr	r3, [pc, #324]	; (8003ccc <LOS_TaskDelete+0x170>)
 8003b86:	6819      	ldr	r1, [r3, #0]
 8003b88:	687a      	ldr	r2, [r7, #4]
 8003b8a:	4613      	mov	r3, r2
 8003b8c:	009b      	lsls	r3, r3, #2
 8003b8e:	4413      	add	r3, r2
 8003b90:	015b      	lsls	r3, r3, #5
 8003b92:	440b      	add	r3, r1
 8003b94:	61bb      	str	r3, [r7, #24]
    if (taskCB->taskFlags & OS_TASK_FLAG_SYSTEM) {
 8003b96:	69bb      	ldr	r3, [r7, #24]
 8003b98:	689b      	ldr	r3, [r3, #8]
 8003b9a:	f3c3 031e 	ubfx	r3, r3, #0, #31
 8003b9e:	f003 0302 	and.w	r3, r3, #2
 8003ba2:	2b00      	cmp	r3, #0
 8003ba4:	d001      	beq.n	8003baa <LOS_TaskDelete+0x4e>
        return LOS_ERRNO_TSK_OPERATE_SYSTEM_TASK;
 8003ba6:	4b4a      	ldr	r3, [pc, #296]	; (8003cd0 <LOS_TaskDelete+0x174>)
 8003ba8:	e07f      	b.n	8003caa <LOS_TaskDelete+0x14e>
    }

    SCHEDULER_LOCK(intSave);
 8003baa:	f107 0310 	add.w	r3, r7, #16
 8003bae:	4619      	mov	r1, r3
 8003bb0:	4848      	ldr	r0, [pc, #288]	; (8003cd4 <LOS_TaskDelete+0x178>)
 8003bb2:	f7ff f839 	bl	8002c28 <LOS_SpinLockSave>

    tempStatus = taskCB->taskStatus;
 8003bb6:	69bb      	ldr	r3, [r7, #24]
 8003bb8:	889b      	ldrh	r3, [r3, #4]
 8003bba:	81fb      	strh	r3, [r7, #14]
    if (tempStatus & OS_TASK_STATUS_UNUSED) {
 8003bbc:	89fb      	ldrh	r3, [r7, #14]
 8003bbe:	f003 0301 	and.w	r3, r3, #1
 8003bc2:	2b00      	cmp	r3, #0
 8003bc4:	d002      	beq.n	8003bcc <LOS_TaskDelete+0x70>
        errRet = LOS_ERRNO_TSK_NOT_CREATED;
 8003bc6:	4b44      	ldr	r3, [pc, #272]	; (8003cd8 <LOS_TaskDelete+0x17c>)
 8003bc8:	617b      	str	r3, [r7, #20]
        goto LOS_RETURN;
 8003bca:	e068      	b.n	8003c9e <LOS_TaskDelete+0x142>
    }
    if ((tempStatus & OS_TASK_STATUS_RUNNING) &&
 8003bcc:	89fb      	ldrh	r3, [r7, #14]
 8003bce:	f003 0310 	and.w	r3, r3, #16
 8003bd2:	2b00      	cmp	r3, #0
 8003bd4:	d008      	beq.n	8003be8 <LOS_TaskDelete+0x8c>
        !OsTaskDeleteCheckOnRun(taskCB, &errRet)) {
 8003bd6:	f107 0314 	add.w	r3, r7, #20
 8003bda:	4619      	mov	r1, r3
 8003bdc:	69b8      	ldr	r0, [r7, #24]
 8003bde:	f7ff fda5 	bl	800372c <OsTaskDeleteCheckOnRun>
 8003be2:	4603      	mov	r3, r0
    if ((tempStatus & OS_TASK_STATUS_RUNNING) &&
 8003be4:	2b00      	cmp	r3, #0
 8003be6:	d057      	beq.n	8003c98 <LOS_TaskDelete+0x13c>
        goto LOS_RETURN;
    }

    if (tempStatus & OS_TASK_STATUS_READY) {
 8003be8:	89fb      	ldrh	r3, [r7, #14]
 8003bea:	f003 0304 	and.w	r3, r3, #4
 8003bee:	2b00      	cmp	r3, #0
 8003bf0:	d00c      	beq.n	8003c0c <LOS_TaskDelete+0xb0>
        OsPriQueueDequeue(&taskCB->pendList);
 8003bf2:	69bb      	ldr	r3, [r7, #24]
 8003bf4:	3340      	adds	r3, #64	; 0x40
 8003bf6:	4618      	mov	r0, r3
 8003bf8:	f005 fa4a 	bl	8009090 <OsPriQueueDequeue>
        taskCB->taskStatus &= ~OS_TASK_STATUS_READY;
 8003bfc:	69bb      	ldr	r3, [r7, #24]
 8003bfe:	889b      	ldrh	r3, [r3, #4]
 8003c00:	f023 0304 	bic.w	r3, r3, #4
 8003c04:	b29a      	uxth	r2, r3
 8003c06:	69bb      	ldr	r3, [r7, #24]
 8003c08:	809a      	strh	r2, [r3, #4]
 8003c0a:	e009      	b.n	8003c20 <LOS_TaskDelete+0xc4>
    } else if (tempStatus & OS_TASK_STATUS_PEND) {
 8003c0c:	89fb      	ldrh	r3, [r7, #14]
 8003c0e:	f003 0308 	and.w	r3, r3, #8
 8003c12:	2b00      	cmp	r3, #0
 8003c14:	d004      	beq.n	8003c20 <LOS_TaskDelete+0xc4>
        LOS_ListDelete(&taskCB->pendList);
 8003c16:	69bb      	ldr	r3, [r7, #24]
 8003c18:	3340      	adds	r3, #64	; 0x40
 8003c1a:	4618      	mov	r0, r3
 8003c1c:	f7fe ff3b 	bl	8002a96 <LOS_ListDelete>
    }

    if (tempStatus & (OS_TASK_STATUS_DELAY | OS_TASK_STATUS_PEND_TIME)) {
 8003c20:	89fb      	ldrh	r3, [r7, #14]
 8003c22:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
 8003c26:	2b00      	cmp	r3, #0
 8003c28:	d002      	beq.n	8003c30 <LOS_TaskDelete+0xd4>
        OsTimerListDelete(taskCB);
 8003c2a:	69b8      	ldr	r0, [r7, #24]
 8003c2c:	f7ff f93a 	bl	8002ea4 <OsTimerListDelete>
    }

    taskCB->taskStatus &= ~OS_TASK_STATUS_SUSPEND;
 8003c30:	69bb      	ldr	r3, [r7, #24]
 8003c32:	889b      	ldrh	r3, [r3, #4]
 8003c34:	f023 0302 	bic.w	r3, r3, #2
 8003c38:	b29a      	uxth	r2, r3
 8003c3a:	69bb      	ldr	r3, [r7, #24]
 8003c3c:	809a      	strh	r2, [r3, #4]
    taskCB->taskStatus |= OS_TASK_STATUS_UNUSED;
 8003c3e:	69bb      	ldr	r3, [r7, #24]
 8003c40:	889b      	ldrh	r3, [r3, #4]
 8003c42:	f043 0301 	orr.w	r3, r3, #1
 8003c46:	b29a      	uxth	r2, r3
 8003c48:	69bb      	ldr	r3, [r7, #24]
 8003c4a:	809a      	strh	r2, [r3, #4]
#ifdef LOSCFG_BASE_IPC_EVENT
    taskCB->event.uwEventID = OS_INVALID_VALUE;
 8003c4c:	69bb      	ldr	r3, [r7, #24]
 8003c4e:	f04f 32ff 	mov.w	r2, #4294967295
 8003c52:	655a      	str	r2, [r3, #84]	; 0x54
    taskCB->eventMask = 0;
 8003c54:	69bb      	ldr	r3, [r7, #24]
 8003c56:	2200      	movs	r2, #0
 8003c58:	661a      	str	r2, [r3, #96]	; 0x60
#endif
#ifdef LOSCFG_KERNEL_CPUP
    (VOID)memset_s((VOID *)OsCpupCBGet(taskCB->taskId), sizeof(OsCpupCB), 0, sizeof(OsCpupCB));
 8003c5a:	69bb      	ldr	r3, [r7, #24]
 8003c5c:	695b      	ldr	r3, [r3, #20]
 8003c5e:	4618      	mov	r0, r3
 8003c60:	f010 fc20 	bl	80144a4 <OsCpupCBGet>
 8003c64:	2378      	movs	r3, #120	; 0x78
 8003c66:	2200      	movs	r2, #0
 8003c68:	2178      	movs	r1, #120	; 0x78
 8003c6a:	f7fe fa1b 	bl	80020a4 <memset_s>
#endif
    OS_MEM_CLEAR(taskId);
 8003c6e:	6878      	ldr	r0, [r7, #4]
 8003c70:	f006 f9b4 	bl	8009fdc <OsMemTaskClear>

    OsTaskSyncWake(taskCB);
 8003c74:	69b8      	ldr	r0, [r7, #24]
 8003c76:	f7ff fcac 	bl	80035d2 <OsTaskSyncWake>
    if (OsTaskDelAction(taskCB, taskCB->usrStack)) {
 8003c7a:	69bb      	ldr	r3, [r7, #24]
 8003c7c:	7adb      	ldrb	r3, [r3, #11]
 8003c7e:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8003c82:	b2db      	uxtb	r3, r3
 8003c84:	4619      	mov	r1, r3
 8003c86:	69b8      	ldr	r0, [r7, #24]
 8003c88:	f7ff fcdc 	bl	8003644 <OsTaskDelAction>
 8003c8c:	4603      	mov	r3, r0
 8003c8e:	2b00      	cmp	r3, #0
 8003c90:	d004      	beq.n	8003c9c <LOS_TaskDelete+0x140>
        OsSchedResched();
 8003c92:	f004 ff91 	bl	8008bb8 <OsSchedResched>
 8003c96:	e002      	b.n	8003c9e <LOS_TaskDelete+0x142>
        goto LOS_RETURN;
 8003c98:	bf00      	nop
 8003c9a:	e000      	b.n	8003c9e <LOS_TaskDelete+0x142>
    }

LOS_RETURN:
 8003c9c:	bf00      	nop
    SCHEDULER_UNLOCK(intSave);
 8003c9e:	693b      	ldr	r3, [r7, #16]
 8003ca0:	4619      	mov	r1, r3
 8003ca2:	480c      	ldr	r0, [pc, #48]	; (8003cd4 <LOS_TaskDelete+0x178>)
 8003ca4:	f7fe ffce 	bl	8002c44 <LOS_SpinUnlockRestore>
    return errRet;
 8003ca8:	697b      	ldr	r3, [r7, #20]
}
 8003caa:	4a05      	ldr	r2, [pc, #20]	; (8003cc0 <LOS_TaskDelete+0x164>)
 8003cac:	6811      	ldr	r1, [r2, #0]
 8003cae:	69fa      	ldr	r2, [r7, #28]
 8003cb0:	4051      	eors	r1, r2
 8003cb2:	d001      	beq.n	8003cb8 <LOS_TaskDelete+0x15c>
 8003cb4:	f000 fc92 	bl	80045dc <__stack_chk_fail>
 8003cb8:	4618      	mov	r0, r3
 8003cba:	3720      	adds	r7, #32
 8003cbc:	46bd      	mov	sp, r7
 8003cbe:	bd80      	pop	{r7, pc}
 8003cc0:	08020138 	.word	0x08020138
 8003cc4:	200036d8 	.word	0x200036d8
 8003cc8:	02000207 	.word	0x02000207
 8003ccc:	200036c4 	.word	0x200036c4
 8003cd0:	02000214 	.word	0x02000214
 8003cd4:	20000770 	.word	0x20000770
 8003cd8:	0200020a 	.word	0x0200020a

08003cdc <OsTaskSuspendCheckOnRun>:
 * 2. Do the suspension when preemption is disabled
 * 3. Do the suspension in hard-irq
 * then LOS_TaskSuspend will directly return with 'ret' value.
 */
LITE_OS_SEC_TEXT_INIT STATIC BOOL OsTaskSuspendCheckOnRun(LosTaskCB *taskCB, UINT32 *ret)
{
 8003cdc:	b580      	push	{r7, lr}
 8003cde:	b082      	sub	sp, #8
 8003ce0:	af00      	add	r7, sp, #0
 8003ce2:	6078      	str	r0, [r7, #4]
 8003ce4:	6039      	str	r1, [r7, #0]
    /* init default out return value */
    *ret = LOS_OK;
 8003ce6:	683b      	ldr	r3, [r7, #0]
 8003ce8:	2200      	movs	r2, #0
 8003cea:	601a      	str	r2, [r3, #0]
        LOS_MpSchedule(taskCB->currCpu);
        return FALSE;
    }
#endif

    if (!OsPreemptableInSched()) {
 8003cec:	f7fe ff5c 	bl	8002ba8 <OsPreemptableInSched>
 8003cf0:	4603      	mov	r3, r0
 8003cf2:	2b00      	cmp	r3, #0
 8003cf4:	d104      	bne.n	8003d00 <OsTaskSuspendCheckOnRun+0x24>
        /* Suspending the current core's running task */
        *ret = LOS_ERRNO_TSK_SUSPEND_LOCKED;
 8003cf6:	683b      	ldr	r3, [r7, #0]
 8003cf8:	4a09      	ldr	r2, [pc, #36]	; (8003d20 <OsTaskSuspendCheckOnRun+0x44>)
 8003cfa:	601a      	str	r2, [r3, #0]
        return FALSE;
 8003cfc:	2300      	movs	r3, #0
 8003cfe:	e00a      	b.n	8003d16 <OsTaskSuspendCheckOnRun+0x3a>
    }

    if (OS_INT_ACTIVE) {
 8003d00:	f7fe fcae 	bl	8002660 <IntActive>
 8003d04:	4603      	mov	r3, r0
 8003d06:	2b00      	cmp	r3, #0
 8003d08:	d004      	beq.n	8003d14 <OsTaskSuspendCheckOnRun+0x38>
        /* suspend running task in interrupt */
        taskCB->signal = SIGNAL_SUSPEND;
 8003d0a:	687b      	ldr	r3, [r7, #4]
 8003d0c:	2202      	movs	r2, #2
 8003d0e:	671a      	str	r2, [r3, #112]	; 0x70
        return FALSE;
 8003d10:	2300      	movs	r3, #0
 8003d12:	e000      	b.n	8003d16 <OsTaskSuspendCheckOnRun+0x3a>
    }

    return TRUE;
 8003d14:	2301      	movs	r3, #1
}
 8003d16:	4618      	mov	r0, r3
 8003d18:	3708      	adds	r7, #8
 8003d1a:	46bd      	mov	sp, r7
 8003d1c:	bd80      	pop	{r7, pc}
 8003d1e:	bf00      	nop
 8003d20:	03000215 	.word	0x03000215

08003d24 <LOS_TaskSuspend>:

LITE_OS_SEC_TEXT_INIT UINT32 LOS_TaskSuspend(UINT32 taskId)
{
 8003d24:	b590      	push	{r4, r7, lr}
 8003d26:	b08f      	sub	sp, #60	; 0x3c
 8003d28:	af00      	add	r7, sp, #0
 8003d2a:	6078      	str	r0, [r7, #4]
 8003d2c:	4b54      	ldr	r3, [pc, #336]	; (8003e80 <LOS_TaskSuspend+0x15c>)
 8003d2e:	681b      	ldr	r3, [r3, #0]
 8003d30:	637b      	str	r3, [r7, #52]	; 0x34
 8003d32:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosTaskCB *taskCB = NULL;
 8003d36:	2300      	movs	r3, #0
 8003d38:	61bb      	str	r3, [r7, #24]
    LosTaskCB *runTask = NULL;
 8003d3a:	2300      	movs	r3, #0
 8003d3c:	61fb      	str	r3, [r7, #28]
    UINT16 tempStatus;
    UINT32 errRet = LOS_OK;
 8003d3e:	2300      	movs	r3, #0
 8003d40:	617b      	str	r3, [r7, #20]

    if (OS_TASK_ID_CHECK_INVALID(taskId)) {
 8003d42:	4b50      	ldr	r3, [pc, #320]	; (8003e84 <LOS_TaskSuspend+0x160>)
 8003d44:	681b      	ldr	r3, [r3, #0]
 8003d46:	687a      	ldr	r2, [r7, #4]
 8003d48:	429a      	cmp	r2, r3
 8003d4a:	d301      	bcc.n	8003d50 <LOS_TaskSuspend+0x2c>
        return LOS_ERRNO_TSK_ID_INVALID;
 8003d4c:	4b4e      	ldr	r3, [pc, #312]	; (8003e88 <LOS_TaskSuspend+0x164>)
 8003d4e:	e08b      	b.n	8003e68 <LOS_TaskSuspend+0x144>
    }

    taskCB = OS_TCB_FROM_TID(taskId);
 8003d50:	4b4e      	ldr	r3, [pc, #312]	; (8003e8c <LOS_TaskSuspend+0x168>)
 8003d52:	6819      	ldr	r1, [r3, #0]
 8003d54:	687a      	ldr	r2, [r7, #4]
 8003d56:	4613      	mov	r3, r2
 8003d58:	009b      	lsls	r3, r3, #2
 8003d5a:	4413      	add	r3, r2
 8003d5c:	015b      	lsls	r3, r3, #5
 8003d5e:	440b      	add	r3, r1
 8003d60:	61bb      	str	r3, [r7, #24]
    if (taskCB->taskFlags & OS_TASK_FLAG_SYSTEM) {
 8003d62:	69bb      	ldr	r3, [r7, #24]
 8003d64:	689b      	ldr	r3, [r3, #8]
 8003d66:	f3c3 031e 	ubfx	r3, r3, #0, #31
 8003d6a:	f003 0302 	and.w	r3, r3, #2
 8003d6e:	2b00      	cmp	r3, #0
 8003d70:	d001      	beq.n	8003d76 <LOS_TaskSuspend+0x52>
        return LOS_ERRNO_TSK_OPERATE_SYSTEM_TASK;
 8003d72:	4b47      	ldr	r3, [pc, #284]	; (8003e90 <LOS_TaskSuspend+0x16c>)
 8003d74:	e078      	b.n	8003e68 <LOS_TaskSuspend+0x144>
    }

    SCHEDULER_LOCK(intSave);
 8003d76:	f107 0310 	add.w	r3, r7, #16
 8003d7a:	4619      	mov	r1, r3
 8003d7c:	4845      	ldr	r0, [pc, #276]	; (8003e94 <LOS_TaskSuspend+0x170>)
 8003d7e:	f7fe ff53 	bl	8002c28 <LOS_SpinLockSave>
    tempStatus = taskCB->taskStatus;
 8003d82:	69bb      	ldr	r3, [r7, #24]
 8003d84:	889b      	ldrh	r3, [r3, #4]
 8003d86:	81fb      	strh	r3, [r7, #14]
    if (tempStatus & OS_TASK_STATUS_UNUSED) {
 8003d88:	89fb      	ldrh	r3, [r7, #14]
 8003d8a:	f003 0301 	and.w	r3, r3, #1
 8003d8e:	2b00      	cmp	r3, #0
 8003d90:	d002      	beq.n	8003d98 <LOS_TaskSuspend+0x74>
        errRet = LOS_ERRNO_TSK_NOT_CREATED;
 8003d92:	4b41      	ldr	r3, [pc, #260]	; (8003e98 <LOS_TaskSuspend+0x174>)
 8003d94:	617b      	str	r3, [r7, #20]
        goto LOS_RETURN;
 8003d96:	e061      	b.n	8003e5c <LOS_TaskSuspend+0x138>
    }

    if (tempStatus & OS_TASK_STATUS_SUSPEND) {
 8003d98:	89fb      	ldrh	r3, [r7, #14]
 8003d9a:	f003 0302 	and.w	r3, r3, #2
 8003d9e:	2b00      	cmp	r3, #0
 8003da0:	d002      	beq.n	8003da8 <LOS_TaskSuspend+0x84>
        errRet = LOS_ERRNO_TSK_ALREADY_SUSPENDED;
 8003da2:	4b3e      	ldr	r3, [pc, #248]	; (8003e9c <LOS_TaskSuspend+0x178>)
 8003da4:	617b      	str	r3, [r7, #20]
        goto LOS_RETURN;
 8003da6:	e059      	b.n	8003e5c <LOS_TaskSuspend+0x138>
    }

    if ((tempStatus & OS_TASK_STATUS_RUNNING) &&
 8003da8:	89fb      	ldrh	r3, [r7, #14]
 8003daa:	f003 0310 	and.w	r3, r3, #16
 8003dae:	2b00      	cmp	r3, #0
 8003db0:	d008      	beq.n	8003dc4 <LOS_TaskSuspend+0xa0>
        !OsTaskSuspendCheckOnRun(taskCB, &errRet)) {
 8003db2:	f107 0314 	add.w	r3, r7, #20
 8003db6:	4619      	mov	r1, r3
 8003db8:	69b8      	ldr	r0, [r7, #24]
 8003dba:	f7ff ff8f 	bl	8003cdc <OsTaskSuspendCheckOnRun>
 8003dbe:	4603      	mov	r3, r0
    if ((tempStatus & OS_TASK_STATUS_RUNNING) &&
 8003dc0:	2b00      	cmp	r3, #0
 8003dc2:	d048      	beq.n	8003e56 <LOS_TaskSuspend+0x132>
        goto LOS_RETURN;
    }

    if (tempStatus & OS_TASK_STATUS_READY) {
 8003dc4:	89fb      	ldrh	r3, [r7, #14]
 8003dc6:	f003 0304 	and.w	r3, r3, #4
 8003dca:	2b00      	cmp	r3, #0
 8003dcc:	d00b      	beq.n	8003de6 <LOS_TaskSuspend+0xc2>
        OsPriQueueDequeue(&taskCB->pendList);
 8003dce:	69bb      	ldr	r3, [r7, #24]
 8003dd0:	3340      	adds	r3, #64	; 0x40
 8003dd2:	4618      	mov	r0, r3
 8003dd4:	f005 f95c 	bl	8009090 <OsPriQueueDequeue>
        taskCB->taskStatus &= ~OS_TASK_STATUS_READY;
 8003dd8:	69bb      	ldr	r3, [r7, #24]
 8003dda:	889b      	ldrh	r3, [r3, #4]
 8003ddc:	f023 0304 	bic.w	r3, r3, #4
 8003de0:	b29a      	uxth	r2, r3
 8003de2:	69bb      	ldr	r3, [r7, #24]
 8003de4:	809a      	strh	r2, [r3, #4]
    }

    taskCB->taskStatus |= OS_TASK_STATUS_SUSPEND;
 8003de6:	69bb      	ldr	r3, [r7, #24]
 8003de8:	889b      	ldrh	r3, [r3, #4]
 8003dea:	f043 0302 	orr.w	r3, r3, #2
 8003dee:	b29a      	uxth	r2, r3
 8003df0:	69bb      	ldr	r3, [r7, #24]
 8003df2:	809a      	strh	r2, [r3, #4]

    runTask = OsCurrTaskGet();
 8003df4:	f7fe ff3d 	bl	8002c72 <OsCurrTaskGet>
 8003df8:	61f8      	str	r0, [r7, #28]

    LOS_TRACE(TASK_SUSPEND, taskCB->taskId, taskCB->taskStatus, runTask->taskId);
 8003dfa:	2300      	movs	r3, #0
 8003dfc:	627b      	str	r3, [r7, #36]	; 0x24
 8003dfe:	69bb      	ldr	r3, [r7, #24]
 8003e00:	695b      	ldr	r3, [r3, #20]
 8003e02:	62bb      	str	r3, [r7, #40]	; 0x28
 8003e04:	69bb      	ldr	r3, [r7, #24]
 8003e06:	889b      	ldrh	r3, [r3, #4]
 8003e08:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003e0a:	69fb      	ldr	r3, [r7, #28]
 8003e0c:	695b      	ldr	r3, [r3, #20]
 8003e0e:	633b      	str	r3, [r7, #48]	; 0x30
 8003e10:	2304      	movs	r3, #4
 8003e12:	623b      	str	r3, [r7, #32]
 8003e14:	6a3b      	ldr	r3, [r7, #32]
 8003e16:	2b01      	cmp	r3, #1
 8003e18:	d915      	bls.n	8003e46 <LOS_TaskSuspend+0x122>
 8003e1a:	4b21      	ldr	r3, [pc, #132]	; (8003ea0 <LOS_TaskSuspend+0x17c>)
 8003e1c:	681b      	ldr	r3, [r3, #0]
 8003e1e:	2b00      	cmp	r3, #0
 8003e20:	d011      	beq.n	8003e46 <LOS_TaskSuspend+0x122>
 8003e22:	4b1f      	ldr	r3, [pc, #124]	; (8003ea0 <LOS_TaskSuspend+0x17c>)
 8003e24:	681c      	ldr	r4, [r3, #0]
 8003e26:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8003e28:	6a3b      	ldr	r3, [r7, #32]
 8003e2a:	2b02      	cmp	r3, #2
 8003e2c:	d904      	bls.n	8003e38 <LOS_TaskSuspend+0x114>
 8003e2e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8003e32:	f103 0208 	add.w	r2, r3, #8
 8003e36:	e000      	b.n	8003e3a <LOS_TaskSuspend+0x116>
 8003e38:	2200      	movs	r2, #0
 8003e3a:	6a3b      	ldr	r3, [r7, #32]
 8003e3c:	b29b      	uxth	r3, r3
 8003e3e:	3b02      	subs	r3, #2
 8003e40:	b29b      	uxth	r3, r3
 8003e42:	2043      	movs	r0, #67	; 0x43
 8003e44:	47a0      	blx	r4

    if (taskId == runTask->taskId) {
 8003e46:	69fb      	ldr	r3, [r7, #28]
 8003e48:	695b      	ldr	r3, [r3, #20]
 8003e4a:	687a      	ldr	r2, [r7, #4]
 8003e4c:	429a      	cmp	r2, r3
 8003e4e:	d104      	bne.n	8003e5a <LOS_TaskSuspend+0x136>
        OsSchedResched();
 8003e50:	f004 feb2 	bl	8008bb8 <OsSchedResched>
 8003e54:	e002      	b.n	8003e5c <LOS_TaskSuspend+0x138>
        goto LOS_RETURN;
 8003e56:	bf00      	nop
 8003e58:	e000      	b.n	8003e5c <LOS_TaskSuspend+0x138>
    }

LOS_RETURN:
 8003e5a:	bf00      	nop
    SCHEDULER_UNLOCK(intSave);
 8003e5c:	693b      	ldr	r3, [r7, #16]
 8003e5e:	4619      	mov	r1, r3
 8003e60:	480c      	ldr	r0, [pc, #48]	; (8003e94 <LOS_TaskSuspend+0x170>)
 8003e62:	f7fe feef 	bl	8002c44 <LOS_SpinUnlockRestore>
    return errRet;
 8003e66:	697b      	ldr	r3, [r7, #20]
}
 8003e68:	4a05      	ldr	r2, [pc, #20]	; (8003e80 <LOS_TaskSuspend+0x15c>)
 8003e6a:	6811      	ldr	r1, [r2, #0]
 8003e6c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003e6e:	4051      	eors	r1, r2
 8003e70:	d001      	beq.n	8003e76 <LOS_TaskSuspend+0x152>
 8003e72:	f000 fbb3 	bl	80045dc <__stack_chk_fail>
 8003e76:	4618      	mov	r0, r3
 8003e78:	373c      	adds	r7, #60	; 0x3c
 8003e7a:	46bd      	mov	sp, r7
 8003e7c:	bd90      	pop	{r4, r7, pc}
 8003e7e:	bf00      	nop
 8003e80:	08020140 	.word	0x08020140
 8003e84:	200036d8 	.word	0x200036d8
 8003e88:	02000207 	.word	0x02000207
 8003e8c:	200036c4 	.word	0x200036c4
 8003e90:	02000214 	.word	0x02000214
 8003e94:	20000770 	.word	0x20000770
 8003e98:	0200020a 	.word	0x0200020a
 8003e9c:	02000208 	.word	0x02000208
 8003ea0:	20000768 	.word	0x20000768

08003ea4 <LOS_TaskDelay>:

LITE_OS_SEC_TEXT UINT32 LOS_TaskDelay(UINT32 tick)
{
 8003ea4:	b580      	push	{r7, lr}
 8003ea6:	b086      	sub	sp, #24
 8003ea8:	af00      	add	r7, sp, #0
 8003eaa:	6078      	str	r0, [r7, #4]
 8003eac:	4b27      	ldr	r3, [pc, #156]	; (8003f4c <LOS_TaskDelay+0xa8>)
 8003eae:	681b      	ldr	r3, [r3, #0]
 8003eb0:	617b      	str	r3, [r7, #20]
 8003eb2:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosTaskCB *runTask = NULL;
 8003eb6:	2300      	movs	r3, #0
 8003eb8:	613b      	str	r3, [r7, #16]

    if (OS_INT_ACTIVE) {
 8003eba:	f7fe fbd1 	bl	8002660 <IntActive>
 8003ebe:	4603      	mov	r3, r0
 8003ec0:	2b00      	cmp	r3, #0
 8003ec2:	d001      	beq.n	8003ec8 <LOS_TaskDelay+0x24>
        return LOS_ERRNO_TSK_DELAY_IN_INT;
 8003ec4:	4b22      	ldr	r3, [pc, #136]	; (8003f50 <LOS_TaskDelay+0xac>)
 8003ec6:	e035      	b.n	8003f34 <LOS_TaskDelay+0x90>
    }

    runTask = OsCurrTaskGet();
 8003ec8:	f7fe fed3 	bl	8002c72 <OsCurrTaskGet>
 8003ecc:	6138      	str	r0, [r7, #16]
    if (runTask->taskFlags & OS_TASK_FLAG_SYSTEM) {
 8003ece:	693b      	ldr	r3, [r7, #16]
 8003ed0:	689b      	ldr	r3, [r3, #8]
 8003ed2:	f3c3 031e 	ubfx	r3, r3, #0, #31
 8003ed6:	f003 0302 	and.w	r3, r3, #2
 8003eda:	2b00      	cmp	r3, #0
 8003edc:	d003      	beq.n	8003ee6 <LOS_TaskDelay+0x42>
        OsBackTrace();
 8003ede:	f000 fb1b 	bl	8004518 <LOS_BackTrace>
        return LOS_ERRNO_TSK_OPERATE_SYSTEM_TASK;
 8003ee2:	4b1c      	ldr	r3, [pc, #112]	; (8003f54 <LOS_TaskDelay+0xb0>)
 8003ee4:	e026      	b.n	8003f34 <LOS_TaskDelay+0x90>
    }

    if (!OsPreemptable()) {
 8003ee6:	f7fe fe3f 	bl	8002b68 <OsPreemptable>
 8003eea:	4603      	mov	r3, r0
 8003eec:	2b00      	cmp	r3, #0
 8003eee:	d101      	bne.n	8003ef4 <LOS_TaskDelay+0x50>
        return LOS_ERRNO_TSK_DELAY_IN_LOCK;
 8003ef0:	4b19      	ldr	r3, [pc, #100]	; (8003f58 <LOS_TaskDelay+0xb4>)
 8003ef2:	e01f      	b.n	8003f34 <LOS_TaskDelay+0x90>
    }

    if (tick == 0) {
 8003ef4:	687b      	ldr	r3, [r7, #4]
 8003ef6:	2b00      	cmp	r3, #0
 8003ef8:	d103      	bne.n	8003f02 <LOS_TaskDelay+0x5e>
        return LOS_TaskYield();
 8003efa:	f000 f8a9 	bl	8004050 <LOS_TaskYield>
 8003efe:	4603      	mov	r3, r0
 8003f00:	e018      	b.n	8003f34 <LOS_TaskDelay+0x90>
    } else {
        SCHEDULER_LOCK(intSave);
 8003f02:	f107 030c 	add.w	r3, r7, #12
 8003f06:	4619      	mov	r1, r3
 8003f08:	4814      	ldr	r0, [pc, #80]	; (8003f5c <LOS_TaskDelay+0xb8>)
 8003f0a:	f7fe fe8d 	bl	8002c28 <LOS_SpinLockSave>
        OsTaskAdd2TimerList(runTask, tick);
 8003f0e:	6879      	ldr	r1, [r7, #4]
 8003f10:	6938      	ldr	r0, [r7, #16]
 8003f12:	f7fe ffb1 	bl	8002e78 <OsTaskAdd2TimerList>
        runTask->taskStatus |= OS_TASK_STATUS_DELAY;
 8003f16:	693b      	ldr	r3, [r7, #16]
 8003f18:	889b      	ldrh	r3, [r3, #4]
 8003f1a:	f043 0320 	orr.w	r3, r3, #32
 8003f1e:	b29a      	uxth	r2, r3
 8003f20:	693b      	ldr	r3, [r7, #16]
 8003f22:	809a      	strh	r2, [r3, #4]
        OsSchedResched();
 8003f24:	f004 fe48 	bl	8008bb8 <OsSchedResched>
        SCHEDULER_UNLOCK(intSave);
 8003f28:	68fb      	ldr	r3, [r7, #12]
 8003f2a:	4619      	mov	r1, r3
 8003f2c:	480b      	ldr	r0, [pc, #44]	; (8003f5c <LOS_TaskDelay+0xb8>)
 8003f2e:	f7fe fe89 	bl	8002c44 <LOS_SpinUnlockRestore>
    }

    return LOS_OK;
 8003f32:	2300      	movs	r3, #0
}
 8003f34:	4a05      	ldr	r2, [pc, #20]	; (8003f4c <LOS_TaskDelay+0xa8>)
 8003f36:	6811      	ldr	r1, [r2, #0]
 8003f38:	697a      	ldr	r2, [r7, #20]
 8003f3a:	4051      	eors	r1, r2
 8003f3c:	d001      	beq.n	8003f42 <LOS_TaskDelay+0x9e>
 8003f3e:	f000 fb4d 	bl	80045dc <__stack_chk_fail>
 8003f42:	4618      	mov	r0, r3
 8003f44:	3718      	adds	r7, #24
 8003f46:	46bd      	mov	sp, r7
 8003f48:	bd80      	pop	{r7, pc}
 8003f4a:	bf00      	nop
 8003f4c:	08020144 	.word	0x08020144
 8003f50:	0300020d 	.word	0x0300020d
 8003f54:	02000214 	.word	0x02000214
 8003f58:	0200020e 	.word	0x0200020e
 8003f5c:	20000770 	.word	0x20000770

08003f60 <OsTaskWait>:
 *               taskStatus --- task status
 *               timeOut    ---  Expiry time
 * Return      : LOS_OK on success or LOS_NOK on failure
 */
VOID OsTaskWait(LOS_DL_LIST *list, UINT16 taskStatus, UINT32 timeout)
{
 8003f60:	b580      	push	{r7, lr}
 8003f62:	b086      	sub	sp, #24
 8003f64:	af00      	add	r7, sp, #0
 8003f66:	60f8      	str	r0, [r7, #12]
 8003f68:	460b      	mov	r3, r1
 8003f6a:	607a      	str	r2, [r7, #4]
 8003f6c:	817b      	strh	r3, [r7, #10]
    LosTaskCB *runTask = NULL;
 8003f6e:	2300      	movs	r3, #0
 8003f70:	613b      	str	r3, [r7, #16]
    LOS_DL_LIST *pendObj = NULL;
 8003f72:	2300      	movs	r3, #0
 8003f74:	617b      	str	r3, [r7, #20]

    runTask = OsCurrTaskGet();
 8003f76:	f7fe fe7c 	bl	8002c72 <OsCurrTaskGet>
 8003f7a:	6138      	str	r0, [r7, #16]
    runTask->taskStatus &= ~OS_TASK_STATUS_READY;
 8003f7c:	693b      	ldr	r3, [r7, #16]
 8003f7e:	889b      	ldrh	r3, [r3, #4]
 8003f80:	f023 0304 	bic.w	r3, r3, #4
 8003f84:	b29a      	uxth	r2, r3
 8003f86:	693b      	ldr	r3, [r7, #16]
 8003f88:	809a      	strh	r2, [r3, #4]
    pendObj = &runTask->pendList;
 8003f8a:	693b      	ldr	r3, [r7, #16]
 8003f8c:	3340      	adds	r3, #64	; 0x40
 8003f8e:	617b      	str	r3, [r7, #20]
    runTask->taskStatus |= taskStatus;
 8003f90:	693b      	ldr	r3, [r7, #16]
 8003f92:	889a      	ldrh	r2, [r3, #4]
 8003f94:	897b      	ldrh	r3, [r7, #10]
 8003f96:	4313      	orrs	r3, r2
 8003f98:	b29a      	uxth	r2, r3
 8003f9a:	693b      	ldr	r3, [r7, #16]
 8003f9c:	809a      	strh	r2, [r3, #4]
    LOS_ListTailInsert(list, pendObj);
 8003f9e:	6979      	ldr	r1, [r7, #20]
 8003fa0:	68f8      	ldr	r0, [r7, #12]
 8003fa2:	f7fe fd69 	bl	8002a78 <LOS_ListTailInsert>
    if (timeout != LOS_WAIT_FOREVER) {
 8003fa6:	687b      	ldr	r3, [r7, #4]
 8003fa8:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003fac:	d00a      	beq.n	8003fc4 <OsTaskWait+0x64>
        runTask->taskStatus |= OS_TASK_STATUS_PEND_TIME;
 8003fae:	693b      	ldr	r3, [r7, #16]
 8003fb0:	889b      	ldrh	r3, [r3, #4]
 8003fb2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003fb6:	b29a      	uxth	r2, r3
 8003fb8:	693b      	ldr	r3, [r7, #16]
 8003fba:	809a      	strh	r2, [r3, #4]
        OsTaskAdd2TimerList((LosTaskCB *)runTask, timeout);
 8003fbc:	6879      	ldr	r1, [r7, #4]
 8003fbe:	6938      	ldr	r0, [r7, #16]
 8003fc0:	f7fe ff5a 	bl	8002e78 <OsTaskAdd2TimerList>
    }
}
 8003fc4:	bf00      	nop
 8003fc6:	3718      	adds	r7, #24
 8003fc8:	46bd      	mov	sp, r7
 8003fca:	bd80      	pop	{r7, pc}

08003fcc <OsTaskWake>:
 * Description : delete the task from pendlist and also add to the priqueue
 * Input       : resumedTask --- resumed task
 *               taskStatus  --- task status
 */
VOID OsTaskWake(LosTaskCB *resumedTask, UINT16 taskStatus)
{
 8003fcc:	b580      	push	{r7, lr}
 8003fce:	b082      	sub	sp, #8
 8003fd0:	af00      	add	r7, sp, #0
 8003fd2:	6078      	str	r0, [r7, #4]
 8003fd4:	460b      	mov	r3, r1
 8003fd6:	807b      	strh	r3, [r7, #2]
    LOS_ListDelete(&resumedTask->pendList);
 8003fd8:	687b      	ldr	r3, [r7, #4]
 8003fda:	3340      	adds	r3, #64	; 0x40
 8003fdc:	4618      	mov	r0, r3
 8003fde:	f7fe fd5a 	bl	8002a96 <LOS_ListDelete>
    resumedTask->taskStatus &= ~taskStatus;
 8003fe2:	687b      	ldr	r3, [r7, #4]
 8003fe4:	889b      	ldrh	r3, [r3, #4]
 8003fe6:	b21a      	sxth	r2, r3
 8003fe8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8003fec:	43db      	mvns	r3, r3
 8003fee:	b21b      	sxth	r3, r3
 8003ff0:	4013      	ands	r3, r2
 8003ff2:	b21b      	sxth	r3, r3
 8003ff4:	b29a      	uxth	r2, r3
 8003ff6:	687b      	ldr	r3, [r7, #4]
 8003ff8:	809a      	strh	r2, [r3, #4]

    if (resumedTask->taskStatus & OS_TASK_STATUS_PEND_TIME) {
 8003ffa:	687b      	ldr	r3, [r7, #4]
 8003ffc:	889b      	ldrh	r3, [r3, #4]
 8003ffe:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8004002:	2b00      	cmp	r3, #0
 8004004:	d009      	beq.n	800401a <OsTaskWake+0x4e>
        OsTimerListDelete(resumedTask);
 8004006:	6878      	ldr	r0, [r7, #4]
 8004008:	f7fe ff4c 	bl	8002ea4 <OsTimerListDelete>
        resumedTask->taskStatus &= ~OS_TASK_STATUS_PEND_TIME;
 800400c:	687b      	ldr	r3, [r7, #4]
 800400e:	889b      	ldrh	r3, [r3, #4]
 8004010:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004014:	b29a      	uxth	r2, r3
 8004016:	687b      	ldr	r3, [r7, #4]
 8004018:	809a      	strh	r2, [r3, #4]
    }
    if (!(resumedTask->taskStatus & OS_TASK_STATUS_SUSPEND)) {
 800401a:	687b      	ldr	r3, [r7, #4]
 800401c:	889b      	ldrh	r3, [r3, #4]
 800401e:	f003 0302 	and.w	r3, r3, #2
 8004022:	2b00      	cmp	r3, #0
 8004024:	d10f      	bne.n	8004046 <OsTaskWake+0x7a>
        resumedTask->taskStatus |= OS_TASK_STATUS_READY;
 8004026:	687b      	ldr	r3, [r7, #4]
 8004028:	889b      	ldrh	r3, [r3, #4]
 800402a:	f043 0304 	orr.w	r3, r3, #4
 800402e:	b29a      	uxth	r2, r3
 8004030:	687b      	ldr	r3, [r7, #4]
 8004032:	809a      	strh	r2, [r3, #4]
        OsPriQueueEnqueue(&resumedTask->pendList, resumedTask->priority);
 8004034:	687b      	ldr	r3, [r7, #4]
 8004036:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800403a:	687b      	ldr	r3, [r7, #4]
 800403c:	88db      	ldrh	r3, [r3, #6]
 800403e:	4619      	mov	r1, r3
 8004040:	4610      	mov	r0, r2
 8004042:	f004 ffe3 	bl	800900c <OsPriQueueEnqueue>
    }
}
 8004046:	bf00      	nop
 8004048:	3708      	adds	r7, #8
 800404a:	46bd      	mov	sp, r7
 800404c:	bd80      	pop	{r7, pc}
	...

08004050 <LOS_TaskYield>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_TaskYield(VOID)
{
 8004050:	b580      	push	{r7, lr}
 8004052:	b084      	sub	sp, #16
 8004054:	af00      	add	r7, sp, #0
 8004056:	4b2e      	ldr	r3, [pc, #184]	; (8004110 <LOS_TaskYield+0xc0>)
 8004058:	681b      	ldr	r3, [r3, #0]
 800405a:	60fb      	str	r3, [r7, #12]
 800405c:	f04f 0300 	mov.w	r3, #0
    UINT32 tskCount;
    UINT32 intSave;
    LosTaskCB *runTask = NULL;
 8004060:	2300      	movs	r3, #0
 8004062:	607b      	str	r3, [r7, #4]

    if (OS_INT_ACTIVE) {
 8004064:	f7fe fafc 	bl	8002660 <IntActive>
 8004068:	4603      	mov	r3, r0
 800406a:	2b00      	cmp	r3, #0
 800406c:	d001      	beq.n	8004072 <LOS_TaskYield+0x22>
        return LOS_ERRNO_TSK_YIELD_IN_INT;
 800406e:	4b29      	ldr	r3, [pc, #164]	; (8004114 <LOS_TaskYield+0xc4>)
 8004070:	e042      	b.n	80040f8 <LOS_TaskYield+0xa8>
    }

    if (!OsPreemptable()) {
 8004072:	f7fe fd79 	bl	8002b68 <OsPreemptable>
 8004076:	4603      	mov	r3, r0
 8004078:	2b00      	cmp	r3, #0
 800407a:	d101      	bne.n	8004080 <LOS_TaskYield+0x30>
        return LOS_ERRNO_TSK_YIELD_IN_LOCK;
 800407c:	4b26      	ldr	r3, [pc, #152]	; (8004118 <LOS_TaskYield+0xc8>)
 800407e:	e03b      	b.n	80040f8 <LOS_TaskYield+0xa8>
    }

    runTask = OsCurrTaskGet();
 8004080:	f7fe fdf7 	bl	8002c72 <OsCurrTaskGet>
 8004084:	6078      	str	r0, [r7, #4]
    if (runTask->taskId >= g_taskMaxNum) {
 8004086:	687b      	ldr	r3, [r7, #4]
 8004088:	695a      	ldr	r2, [r3, #20]
 800408a:	4b24      	ldr	r3, [pc, #144]	; (800411c <LOS_TaskYield+0xcc>)
 800408c:	681b      	ldr	r3, [r3, #0]
 800408e:	429a      	cmp	r2, r3
 8004090:	d301      	bcc.n	8004096 <LOS_TaskYield+0x46>
        return LOS_ERRNO_TSK_ID_INVALID;
 8004092:	4b23      	ldr	r3, [pc, #140]	; (8004120 <LOS_TaskYield+0xd0>)
 8004094:	e030      	b.n	80040f8 <LOS_TaskYield+0xa8>
    }

    SCHEDULER_LOCK(intSave);
 8004096:	463b      	mov	r3, r7
 8004098:	4619      	mov	r1, r3
 800409a:	4822      	ldr	r0, [pc, #136]	; (8004124 <LOS_TaskYield+0xd4>)
 800409c:	f7fe fdc4 	bl	8002c28 <LOS_SpinLockSave>

#ifdef LOSCFG_BASE_CORE_TIMESLICE
    /* reset timeslice of yielded task */
    runTask->timeSlice = 0;
 80040a0:	687b      	ldr	r3, [r7, #4]
 80040a2:	2200      	movs	r2, #0
 80040a4:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
#endif
    tskCount = OsPriQueueSize(runTask->priority);
 80040a8:	687b      	ldr	r3, [r7, #4]
 80040aa:	88db      	ldrh	r3, [r3, #6]
 80040ac:	4618      	mov	r0, r3
 80040ae:	f005 f81b 	bl	80090e8 <OsPriQueueSize>
 80040b2:	60b8      	str	r0, [r7, #8]
    if (tskCount > 0) {
 80040b4:	68bb      	ldr	r3, [r7, #8]
 80040b6:	2b00      	cmp	r3, #0
 80040b8:	d018      	beq.n	80040ec <LOS_TaskYield+0x9c>
        runTask->taskStatus |= OS_TASK_STATUS_READY;
 80040ba:	687b      	ldr	r3, [r7, #4]
 80040bc:	889b      	ldrh	r3, [r3, #4]
 80040be:	f043 0304 	orr.w	r3, r3, #4
 80040c2:	b29a      	uxth	r2, r3
 80040c4:	687b      	ldr	r3, [r7, #4]
 80040c6:	809a      	strh	r2, [r3, #4]
        OsPriQueueEnqueue(&(runTask->pendList), runTask->priority);
 80040c8:	687b      	ldr	r3, [r7, #4]
 80040ca:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80040ce:	687b      	ldr	r3, [r7, #4]
 80040d0:	88db      	ldrh	r3, [r3, #6]
 80040d2:	4619      	mov	r1, r3
 80040d4:	4610      	mov	r0, r2
 80040d6:	f004 ff99 	bl	800900c <OsPriQueueEnqueue>
    } else {
        SCHEDULER_UNLOCK(intSave);
        return LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK;
    }
    OsSchedResched();
 80040da:	f004 fd6d 	bl	8008bb8 <OsSchedResched>
    SCHEDULER_UNLOCK(intSave);
 80040de:	683b      	ldr	r3, [r7, #0]
 80040e0:	4619      	mov	r1, r3
 80040e2:	4810      	ldr	r0, [pc, #64]	; (8004124 <LOS_TaskYield+0xd4>)
 80040e4:	f7fe fdae 	bl	8002c44 <LOS_SpinUnlockRestore>
    return LOS_OK;
 80040e8:	2300      	movs	r3, #0
 80040ea:	e005      	b.n	80040f8 <LOS_TaskYield+0xa8>
        SCHEDULER_UNLOCK(intSave);
 80040ec:	683b      	ldr	r3, [r7, #0]
 80040ee:	4619      	mov	r1, r3
 80040f0:	480c      	ldr	r0, [pc, #48]	; (8004124 <LOS_TaskYield+0xd4>)
 80040f2:	f7fe fda7 	bl	8002c44 <LOS_SpinUnlockRestore>
        return LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK;
 80040f6:	4b0c      	ldr	r3, [pc, #48]	; (8004128 <LOS_TaskYield+0xd8>)
}
 80040f8:	4a05      	ldr	r2, [pc, #20]	; (8004110 <LOS_TaskYield+0xc0>)
 80040fa:	6811      	ldr	r1, [r2, #0]
 80040fc:	68fa      	ldr	r2, [r7, #12]
 80040fe:	4051      	eors	r1, r2
 8004100:	d001      	beq.n	8004106 <LOS_TaskYield+0xb6>
 8004102:	f000 fa6b 	bl	80045dc <__stack_chk_fail>
 8004106:	4618      	mov	r0, r3
 8004108:	3710      	adds	r7, #16
 800410a:	46bd      	mov	sp, r7
 800410c:	bd80      	pop	{r7, pc}
 800410e:	bf00      	nop
 8004110:	08020150 	.word	0x08020150
 8004114:	02000224 	.word	0x02000224
 8004118:	0200020f 	.word	0x0200020f
 800411c:	200036d8 	.word	0x200036d8
 8004120:	02000207 	.word	0x02000207
 8004124:	20000770 	.word	0x20000770
 8004128:	02000210 	.word	0x02000210

0800412c <OsTaskProcSignal>:

/*
 * Description : Process pending signals tagged by others cores
 */
LITE_OS_SEC_TEXT_MINOR UINT32 OsTaskProcSignal(VOID)
{
 800412c:	b590      	push	{r4, r7, lr}
 800412e:	b087      	sub	sp, #28
 8004130:	af00      	add	r7, sp, #0
 8004132:	4b3d      	ldr	r3, [pc, #244]	; (8004228 <OsTaskProcSignal+0xfc>)
 8004134:	681b      	ldr	r3, [r3, #0]
 8004136:	617b      	str	r3, [r7, #20]
 8004138:	f04f 0300 	mov.w	r3, #0
    Percpu    *percpu = NULL;
 800413c:	2300      	movs	r3, #0
 800413e:	603b      	str	r3, [r7, #0]
    LosTaskCB *runTask = NULL;
 8004140:	2300      	movs	r3, #0
 8004142:	607b      	str	r3, [r7, #4]
    /*
     * private and uninterruptable, no protection needed.
     * while this task is always running when others cores see it,
     * so it keeps recieving signals while follow code excuting.
     */
    runTask = OsCurrTaskGet();
 8004144:	f7fe fd95 	bl	8002c72 <OsCurrTaskGet>
 8004148:	6078      	str	r0, [r7, #4]
    if (runTask->signal == SIGNAL_NONE) {
 800414a:	687b      	ldr	r3, [r7, #4]
 800414c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800414e:	2b00      	cmp	r3, #0
 8004150:	d02c      	beq.n	80041ac <OsTaskProcSignal+0x80>
        goto EXIT;
    }

    if (runTask->signal & SIGNAL_KILL) {
 8004152:	687b      	ldr	r3, [r7, #4]
 8004154:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004156:	f003 0301 	and.w	r3, r3, #1
 800415a:	2b00      	cmp	r3, #0
 800415c:	d014      	beq.n	8004188 <OsTaskProcSignal+0x5c>
        /*
         * clear the signal, and do the task deletion. if the signaled task has been
         * scheduled out, then this deletion will wait until next run.
         */
        runTask->signal = SIGNAL_NONE;
 800415e:	687b      	ldr	r3, [r7, #4]
 8004160:	2200      	movs	r2, #0
 8004162:	671a      	str	r2, [r3, #112]	; 0x70
        ret = LOS_TaskDelete(runTask->taskId);
 8004164:	687b      	ldr	r3, [r7, #4]
 8004166:	695b      	ldr	r3, [r3, #20]
 8004168:	4618      	mov	r0, r3
 800416a:	f7ff fcf7 	bl	8003b5c <LOS_TaskDelete>
 800416e:	60b8      	str	r0, [r7, #8]
        if (ret) {
 8004170:	68bb      	ldr	r3, [r7, #8]
 8004172:	2b00      	cmp	r3, #0
 8004174:	d01d      	beq.n	80041b2 <OsTaskProcSignal+0x86>
            PRINT_ERR("%s: tsk del fail err:0x%x\n", __FUNCTION__, ret);
 8004176:	482d      	ldr	r0, [pc, #180]	; (800422c <OsTaskProcSignal+0x100>)
 8004178:	f000 fba2 	bl	80048c0 <dprintf>
 800417c:	68ba      	ldr	r2, [r7, #8]
 800417e:	492c      	ldr	r1, [pc, #176]	; (8004230 <OsTaskProcSignal+0x104>)
 8004180:	482c      	ldr	r0, [pc, #176]	; (8004234 <OsTaskProcSignal+0x108>)
 8004182:	f000 fb9d 	bl	80048c0 <dprintf>
 8004186:	e014      	b.n	80041b2 <OsTaskProcSignal+0x86>
        }
    } else if (runTask->signal & SIGNAL_SUSPEND) {
 8004188:	687b      	ldr	r3, [r7, #4]
 800418a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800418c:	f003 0302 	and.w	r3, r3, #2
 8004190:	2b00      	cmp	r3, #0
 8004192:	d00d      	beq.n	80041b0 <OsTaskProcSignal+0x84>
        runTask->signal &= ~SIGNAL_SUSPEND;
 8004194:	687b      	ldr	r3, [r7, #4]
 8004196:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004198:	f023 0202 	bic.w	r2, r3, #2
 800419c:	687b      	ldr	r3, [r7, #4]
 800419e:	671a      	str	r2, [r3, #112]	; 0x70

        /* suspend killed task may fail, ignore the result */
        (VOID)LOS_TaskSuspend(runTask->taskId);
 80041a0:	687b      	ldr	r3, [r7, #4]
 80041a2:	695b      	ldr	r3, [r3, #20]
 80041a4:	4618      	mov	r0, r3
 80041a6:	f7ff fdbd 	bl	8003d24 <LOS_TaskSuspend>
 80041aa:	e002      	b.n	80041b2 <OsTaskProcSignal+0x86>
        goto EXIT;
 80041ac:	bf00      	nop
 80041ae:	e000      	b.n	80041b2 <OsTaskProcSignal+0x86>
        /* pri-queue has updated, notify the target cpu */
        LOS_MpSchedule((UINT32)runTask->cpuAffiMask);
#endif
    }

EXIT:
 80041b0:	bf00      	nop
    /* check if needs to schedule */
    percpu = OsPercpuGet();
 80041b2:	f7fe fcc9 	bl	8002b48 <OsPercpuGet>
 80041b6:	6038      	str	r0, [r7, #0]

    LOS_TRACE(TASK_SIGNAL, runTask->taskId, runTask->signal, percpu->schedFlag);
 80041b8:	2300      	movs	r3, #0
 80041ba:	613b      	str	r3, [r7, #16]
 80041bc:	2301      	movs	r3, #1
 80041be:	60fb      	str	r3, [r7, #12]
 80041c0:	68fb      	ldr	r3, [r7, #12]
 80041c2:	2b01      	cmp	r3, #1
 80041c4:	d915      	bls.n	80041f2 <OsTaskProcSignal+0xc6>
 80041c6:	4b1c      	ldr	r3, [pc, #112]	; (8004238 <OsTaskProcSignal+0x10c>)
 80041c8:	681b      	ldr	r3, [r3, #0]
 80041ca:	2b00      	cmp	r3, #0
 80041cc:	d011      	beq.n	80041f2 <OsTaskProcSignal+0xc6>
 80041ce:	4b1a      	ldr	r3, [pc, #104]	; (8004238 <OsTaskProcSignal+0x10c>)
 80041d0:	681c      	ldr	r4, [r3, #0]
 80041d2:	6979      	ldr	r1, [r7, #20]
 80041d4:	68fb      	ldr	r3, [r7, #12]
 80041d6:	2b02      	cmp	r3, #2
 80041d8:	d904      	bls.n	80041e4 <OsTaskProcSignal+0xb8>
 80041da:	f107 0310 	add.w	r3, r7, #16
 80041de:	f103 0208 	add.w	r2, r3, #8
 80041e2:	e000      	b.n	80041e6 <OsTaskProcSignal+0xba>
 80041e4:	2200      	movs	r2, #0
 80041e6:	68fb      	ldr	r3, [r7, #12]
 80041e8:	b29b      	uxth	r3, r3
 80041ea:	3b02      	subs	r3, #2
 80041ec:	b29b      	uxth	r3, r3
 80041ee:	2046      	movs	r0, #70	; 0x46
 80041f0:	47a0      	blx	r4

    if (OsPreemptable() && (percpu->schedFlag == INT_PEND_RESCH)) {
 80041f2:	f7fe fcb9 	bl	8002b68 <OsPreemptable>
 80041f6:	4603      	mov	r3, r0
 80041f8:	2b00      	cmp	r3, #0
 80041fa:	d008      	beq.n	800420e <OsTaskProcSignal+0xe2>
 80041fc:	683b      	ldr	r3, [r7, #0]
 80041fe:	6a1b      	ldr	r3, [r3, #32]
 8004200:	2b01      	cmp	r3, #1
 8004202:	d104      	bne.n	800420e <OsTaskProcSignal+0xe2>
        percpu->schedFlag = INT_NO_RESCH;
 8004204:	683b      	ldr	r3, [r7, #0]
 8004206:	2200      	movs	r2, #0
 8004208:	621a      	str	r2, [r3, #32]
        return INT_PEND_RESCH;
 800420a:	2301      	movs	r3, #1
 800420c:	e000      	b.n	8004210 <OsTaskProcSignal+0xe4>
    }

    return INT_NO_RESCH;
 800420e:	2300      	movs	r3, #0
}
 8004210:	4a05      	ldr	r2, [pc, #20]	; (8004228 <OsTaskProcSignal+0xfc>)
 8004212:	6811      	ldr	r1, [r2, #0]
 8004214:	697a      	ldr	r2, [r7, #20]
 8004216:	4051      	eors	r1, r2
 8004218:	d001      	beq.n	800421e <OsTaskProcSignal+0xf2>
 800421a:	f000 f9df 	bl	80045dc <__stack_chk_fail>
 800421e:	4618      	mov	r0, r3
 8004220:	371c      	adds	r7, #28
 8004222:	46bd      	mov	sp, r7
 8004224:	bd90      	pop	{r4, r7, pc}
 8004226:	bf00      	nop
 8004228:	08020194 	.word	0x08020194
 800422c:	0802005c 	.word	0x0802005c
 8004230:	080232e0 	.word	0x080232e0
 8004234:	08020178 	.word	0x08020178
 8004238:	20000768 	.word	0x20000768

0800423c <ArchCurrCpuid>:
{
 800423c:	b480      	push	{r7}
 800423e:	af00      	add	r7, sp, #0
    return 0;
 8004240:	2300      	movs	r3, #0
}
 8004242:	4618      	mov	r0, r3
 8004244:	46bd      	mov	sp, r7
 8004246:	f85d 7b04 	ldr.w	r7, [sp], #4
 800424a:	4770      	bx	lr

0800424c <LOS_IntLock>:
{
 800424c:	b580      	push	{r7, lr}
 800424e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8004250:	f7fc fd3a 	bl	8000cc8 <ArchIntLock>
 8004254:	4603      	mov	r3, r0
}
 8004256:	4618      	mov	r0, r3
 8004258:	bd80      	pop	{r7, pc}

0800425a <LOS_IntRestore>:
{
 800425a:	b580      	push	{r7, lr}
 800425c:	b082      	sub	sp, #8
 800425e:	af00      	add	r7, sp, #0
 8004260:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8004262:	6878      	ldr	r0, [r7, #4]
 8004264:	f7fc fd38 	bl	8000cd8 <ArchIntRestore>
}
 8004268:	bf00      	nop
 800426a:	3708      	adds	r7, #8
 800426c:	46bd      	mov	sp, r7
 800426e:	bd80      	pop	{r7, pc}

08004270 <LOS_SpinLockSave>:
{
 8004270:	b580      	push	{r7, lr}
 8004272:	b082      	sub	sp, #8
 8004274:	af00      	add	r7, sp, #0
 8004276:	6078      	str	r0, [r7, #4]
 8004278:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 800427a:	f7ff ffe7 	bl	800424c <LOS_IntLock>
 800427e:	4602      	mov	r2, r0
 8004280:	683b      	ldr	r3, [r7, #0]
 8004282:	601a      	str	r2, [r3, #0]
}
 8004284:	bf00      	nop
 8004286:	3708      	adds	r7, #8
 8004288:	46bd      	mov	sp, r7
 800428a:	bd80      	pop	{r7, pc}

0800428c <LOS_SpinUnlockRestore>:
{
 800428c:	b580      	push	{r7, lr}
 800428e:	b082      	sub	sp, #8
 8004290:	af00      	add	r7, sp, #0
 8004292:	6078      	str	r0, [r7, #4]
 8004294:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8004296:	6838      	ldr	r0, [r7, #0]
 8004298:	f7ff ffdf 	bl	800425a <LOS_IntRestore>
}
 800429c:	bf00      	nop
 800429e:	3708      	adds	r7, #8
 80042a0:	46bd      	mov	sp, r7
 80042a2:	bd80      	pop	{r7, pc}

080042a4 <OsTickHandler>:

/*
 * Description : Tick interruption handler
 */
LITE_OS_SEC_TEXT VOID OsTickHandler(VOID)
{
 80042a4:	b5b0      	push	{r4, r5, r7, lr}
 80042a6:	b082      	sub	sp, #8
 80042a8:	af00      	add	r7, sp, #0
 80042aa:	4b1c      	ldr	r3, [pc, #112]	; (800431c <OsTickHandler+0x78>)
 80042ac:	681b      	ldr	r3, [r3, #0]
 80042ae:	607b      	str	r3, [r7, #4]
 80042b0:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    TICK_LOCK(intSave);
 80042b4:	463b      	mov	r3, r7
 80042b6:	4619      	mov	r1, r3
 80042b8:	4819      	ldr	r0, [pc, #100]	; (8004320 <OsTickHandler+0x7c>)
 80042ba:	f7ff ffd9 	bl	8004270 <LOS_SpinLockSave>
    g_tickCount[ArchCurrCpuid()]++;
 80042be:	f7ff ffbd 	bl	800423c <ArchCurrCpuid>
 80042c2:	4601      	mov	r1, r0
 80042c4:	4a17      	ldr	r2, [pc, #92]	; (8004324 <OsTickHandler+0x80>)
 80042c6:	00cb      	lsls	r3, r1, #3
 80042c8:	4413      	add	r3, r2
 80042ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 80042ce:	1c54      	adds	r4, r2, #1
 80042d0:	f143 0500 	adc.w	r5, r3, #0
 80042d4:	4a13      	ldr	r2, [pc, #76]	; (8004324 <OsTickHandler+0x80>)
 80042d6:	00cb      	lsls	r3, r1, #3
 80042d8:	4413      	add	r3, r2
 80042da:	e9c3 4500 	strd	r4, r5, [r3]
    TICK_UNLOCK(intSave);
 80042de:	683b      	ldr	r3, [r7, #0]
 80042e0:	4619      	mov	r1, r3
 80042e2:	480f      	ldr	r0, [pc, #60]	; (8004320 <OsTickHandler+0x7c>)
 80042e4:	f7ff ffd2 	bl	800428c <LOS_SpinUnlockRestore>

#ifdef LOSCFG_KERNEL_TICKLESS
    if (g_tickWakeupHook != NULL) {
 80042e8:	4b0f      	ldr	r3, [pc, #60]	; (8004328 <OsTickHandler+0x84>)
 80042ea:	681b      	ldr	r3, [r3, #0]
 80042ec:	2b00      	cmp	r3, #0
 80042ee:	d004      	beq.n	80042fa <OsTickHandler+0x56>
        g_tickWakeupHook(LOS_TICK_INT_FLAG);
 80042f0:	4b0d      	ldr	r3, [pc, #52]	; (8004328 <OsTickHandler+0x84>)
 80042f2:	681b      	ldr	r3, [r3, #0]
 80042f4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 80042f8:	4798      	blx	r3
    }
#endif

#ifdef LOSCFG_BASE_CORE_TIMESLICE
    OsTimesliceCheck();
 80042fa:	f004 fd69 	bl	8008dd0 <OsTimesliceCheck>
#endif

    OsTaskScan(); /* task timeout scan */
 80042fe:	f7fe fde5 	bl	8002ecc <OsTaskScan>

#ifdef LOSCFG_BASE_CORE_SWTMR
    OsSwtmrScan();
 8004302:	f001 fb95 	bl	8005a30 <OsSwtmrScan>
#endif
}
 8004306:	bf00      	nop
 8004308:	4b04      	ldr	r3, [pc, #16]	; (800431c <OsTickHandler+0x78>)
 800430a:	681a      	ldr	r2, [r3, #0]
 800430c:	687b      	ldr	r3, [r7, #4]
 800430e:	405a      	eors	r2, r3
 8004310:	d001      	beq.n	8004316 <OsTickHandler+0x72>
 8004312:	f000 f963 	bl	80045dc <__stack_chk_fail>
 8004316:	3708      	adds	r7, #8
 8004318:	46bd      	mov	sp, r7
 800431a:	bdb0      	pop	{r4, r5, r7, pc}
 800431c:	08020198 	.word	0x08020198
 8004320:	20000788 	.word	0x20000788
 8004324:	20000780 	.word	0x20000780
 8004328:	2000078c 	.word	0x2000078c

0800432c <OsTickInit>:

LITE_OS_SEC_TEXT_INIT UINT32 OsTickInit(UINT32 systemClock, UINT32 tickPerSecond)
{
 800432c:	b580      	push	{r7, lr}
 800432e:	b082      	sub	sp, #8
 8004330:	af00      	add	r7, sp, #0
 8004332:	6078      	str	r0, [r7, #4]
 8004334:	6039      	str	r1, [r7, #0]
    if ((systemClock == 0) ||
 8004336:	687b      	ldr	r3, [r7, #4]
 8004338:	2b00      	cmp	r3, #0
 800433a:	d006      	beq.n	800434a <OsTickInit+0x1e>
 800433c:	683b      	ldr	r3, [r7, #0]
 800433e:	2b00      	cmp	r3, #0
 8004340:	d003      	beq.n	800434a <OsTickInit+0x1e>
        (tickPerSecond == 0) ||
 8004342:	683a      	ldr	r2, [r7, #0]
 8004344:	687b      	ldr	r3, [r7, #4]
 8004346:	429a      	cmp	r2, r3
 8004348:	d901      	bls.n	800434e <OsTickInit+0x22>
        (tickPerSecond > systemClock)) {
        return LOS_ERRNO_TICK_CFG_INVALID;
 800434a:	4b04      	ldr	r3, [pc, #16]	; (800435c <OsTickInit+0x30>)
 800434c:	e002      	b.n	8004354 <OsTickInit+0x28>
    }
    HalClockInit();
 800434e:	f00c f941 	bl	80105d4 <HalClockInit>

    return LOS_OK;
 8004352:	2300      	movs	r3, #0
}
 8004354:	4618      	mov	r0, r3
 8004356:	3708      	adds	r7, #8
 8004358:	46bd      	mov	sp, r7
 800435a:	bd80      	pop	{r7, pc}
 800435c:	02000400 	.word	0x02000400

08004360 <OsTickStart>:

LITE_OS_SEC_TEXT_INIT VOID OsTickStart(VOID)
{
 8004360:	b580      	push	{r7, lr}
 8004362:	af00      	add	r7, sp, #0
    HalClockStart();
 8004364:	f00c f95a 	bl	801061c <HalClockStart>
}
 8004368:	bf00      	nop
 800436a:	bd80      	pop	{r7, pc}

0800436c <LOS_TickCountGet>:

LITE_OS_SEC_TEXT_MINOR UINT64 LOS_TickCountGet(VOID)
{
 800436c:	b580      	push	{r7, lr}
 800436e:	b086      	sub	sp, #24
 8004370:	af00      	add	r7, sp, #0
 8004372:	4b11      	ldr	r3, [pc, #68]	; (80043b8 <LOS_TickCountGet+0x4c>)
 8004374:	681b      	ldr	r3, [r3, #0]
 8004376:	617b      	str	r3, [r7, #20]
 8004378:	f04f 0300 	mov.w	r3, #0

    /*
     * use core0's tick as system's timeline,
     * the tick needs to be atomic.
     */
    TICK_LOCK(intSave);
 800437c:	1d3b      	adds	r3, r7, #4
 800437e:	4619      	mov	r1, r3
 8004380:	480e      	ldr	r0, [pc, #56]	; (80043bc <LOS_TickCountGet+0x50>)
 8004382:	f7ff ff75 	bl	8004270 <LOS_SpinLockSave>
    tick = g_tickCount[0];
 8004386:	4b0e      	ldr	r3, [pc, #56]	; (80043c0 <LOS_TickCountGet+0x54>)
 8004388:	e9d3 2300 	ldrd	r2, r3, [r3]
 800438c:	e9c7 2302 	strd	r2, r3, [r7, #8]
    TICK_UNLOCK(intSave);
 8004390:	687b      	ldr	r3, [r7, #4]
 8004392:	4619      	mov	r1, r3
 8004394:	4809      	ldr	r0, [pc, #36]	; (80043bc <LOS_TickCountGet+0x50>)
 8004396:	f7ff ff79 	bl	800428c <LOS_SpinUnlockRestore>

    return tick;
 800439a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
}
 800439e:	4906      	ldr	r1, [pc, #24]	; (80043b8 <LOS_TickCountGet+0x4c>)
 80043a0:	6808      	ldr	r0, [r1, #0]
 80043a2:	6979      	ldr	r1, [r7, #20]
 80043a4:	4048      	eors	r0, r1
 80043a6:	d001      	beq.n	80043ac <LOS_TickCountGet+0x40>
 80043a8:	f000 f918 	bl	80045dc <__stack_chk_fail>
 80043ac:	4610      	mov	r0, r2
 80043ae:	4619      	mov	r1, r3
 80043b0:	3718      	adds	r7, #24
 80043b2:	46bd      	mov	sp, r7
 80043b4:	bd80      	pop	{r7, pc}
 80043b6:	bf00      	nop
 80043b8:	0802019c 	.word	0x0802019c
 80043bc:	20000788 	.word	0x20000788
 80043c0:	20000780 	.word	0x20000780

080043c4 <LOS_GetCpuCycle>:
{
    return g_sysClock / KERNEL_TICK_PER_SECOND;
}

LITE_OS_SEC_TEXT_MINOR VOID LOS_GetCpuCycle(UINT32 *highCnt, UINT32 *lowCnt)
{
 80043c4:	b580      	push	{r7, lr}
 80043c6:	b084      	sub	sp, #16
 80043c8:	af00      	add	r7, sp, #0
 80043ca:	6078      	str	r0, [r7, #4]
 80043cc:	6039      	str	r1, [r7, #0]
    UINT64 cycle;

    if ((highCnt == NULL) || (lowCnt == NULL)) {
 80043ce:	687b      	ldr	r3, [r7, #4]
 80043d0:	2b00      	cmp	r3, #0
 80043d2:	d014      	beq.n	80043fe <LOS_GetCpuCycle+0x3a>
 80043d4:	683b      	ldr	r3, [r7, #0]
 80043d6:	2b00      	cmp	r3, #0
 80043d8:	d011      	beq.n	80043fe <LOS_GetCpuCycle+0x3a>
        return;
    }
    cycle = HalClockGetCycles();
 80043da:	f00c f955 	bl	8010688 <HalClockGetCycles>
 80043de:	e9c7 0102 	strd	r0, r1, [r7, #8]

    /* get the high 32 bits */
    *highCnt = (UINT32)(cycle >> 32);
 80043e2:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 80043e6:	f04f 0200 	mov.w	r2, #0
 80043ea:	f04f 0300 	mov.w	r3, #0
 80043ee:	000a      	movs	r2, r1
 80043f0:	2300      	movs	r3, #0
 80043f2:	687b      	ldr	r3, [r7, #4]
 80043f4:	601a      	str	r2, [r3, #0]
    /* get the low 32 bits */
    *lowCnt = (UINT32)(cycle & 0xFFFFFFFFULL);
 80043f6:	68ba      	ldr	r2, [r7, #8]
 80043f8:	683b      	ldr	r3, [r7, #0]
 80043fa:	601a      	str	r2, [r3, #0]
 80043fc:	e000      	b.n	8004400 <LOS_GetCpuCycle+0x3c>
        return;
 80043fe:	bf00      	nop
}
 8004400:	3710      	adds	r7, #16
 8004402:	46bd      	mov	sp, r7
 8004404:	bd80      	pop	{r7, pc}
	...

08004408 <LOS_CurrNanosec>:

LITE_OS_SEC_TEXT_MINOR UINT64 LOS_CurrNanosec(VOID)
{
 8004408:	b5b0      	push	{r4, r5, r7, lr}
 800440a:	b082      	sub	sp, #8
 800440c:	af00      	add	r7, sp, #0
    UINT64 nanos;

    nanos = HalClockGetCycles() * (OS_SYS_NS_PER_SECOND / OS_SYS_NS_PER_MS) / (g_sysClock / OS_SYS_NS_PER_MS);
 800440e:	f00c f93b 	bl	8010688 <HalClockGetCycles>
 8004412:	4602      	mov	r2, r0
 8004414:	460b      	mov	r3, r1
 8004416:	f04f 0400 	mov.w	r4, #0
 800441a:	f04f 0500 	mov.w	r5, #0
 800441e:	015d      	lsls	r5, r3, #5
 8004420:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 8004424:	0154      	lsls	r4, r2, #5
 8004426:	4622      	mov	r2, r4
 8004428:	462b      	mov	r3, r5
 800442a:	1a12      	subs	r2, r2, r0
 800442c:	eb63 0301 	sbc.w	r3, r3, r1
 8004430:	f04f 0400 	mov.w	r4, #0
 8004434:	f04f 0500 	mov.w	r5, #0
 8004438:	009d      	lsls	r5, r3, #2
 800443a:	ea45 7592 	orr.w	r5, r5, r2, lsr #30
 800443e:	0094      	lsls	r4, r2, #2
 8004440:	4622      	mov	r2, r4
 8004442:	462b      	mov	r3, r5
 8004444:	1812      	adds	r2, r2, r0
 8004446:	eb41 0303 	adc.w	r3, r1, r3
 800444a:	f04f 0000 	mov.w	r0, #0
 800444e:	f04f 0100 	mov.w	r1, #0
 8004452:	00d9      	lsls	r1, r3, #3
 8004454:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8004458:	00d0      	lsls	r0, r2, #3
 800445a:	4602      	mov	r2, r0
 800445c:	460b      	mov	r3, r1
 800445e:	4610      	mov	r0, r2
 8004460:	4619      	mov	r1, r3
 8004462:	4b0b      	ldr	r3, [pc, #44]	; (8004490 <LOS_CurrNanosec+0x88>)
 8004464:	681b      	ldr	r3, [r3, #0]
 8004466:	4a0b      	ldr	r2, [pc, #44]	; (8004494 <LOS_CurrNanosec+0x8c>)
 8004468:	fba2 2303 	umull	r2, r3, r2, r3
 800446c:	0c9b      	lsrs	r3, r3, #18
 800446e:	461a      	mov	r2, r3
 8004470:	f04f 0300 	mov.w	r3, #0
 8004474:	f7fc fa8e 	bl	8000994 <__aeabi_uldivmod>
 8004478:	4602      	mov	r2, r0
 800447a:	460b      	mov	r3, r1
 800447c:	e9c7 2300 	strd	r2, r3, [r7]
    return nanos;
 8004480:	e9d7 2300 	ldrd	r2, r3, [r7]
}
 8004484:	4610      	mov	r0, r2
 8004486:	4619      	mov	r1, r3
 8004488:	3708      	adds	r7, #8
 800448a:	46bd      	mov	sp, r7
 800448c:	bdb0      	pop	{r4, r5, r7, pc}
 800448e:	bf00      	nop
 8004490:	200036e0 	.word	0x200036e0
 8004494:	431bde83 	.word	0x431bde83

08004498 <ArchHaltCpu>:
 */
extern VOID OsTaskBackTrace(UINT32 taskId);
VOID ArchExcInit(VOID);

STATIC INLINE VOID ArchHaltCpu(VOID)
{
 8004498:	b480      	push	{r7}
 800449a:	af00      	add	r7, sp, #0
    __asm__ __volatile__("swi 0");
 800449c:	df00      	svc	0
}
 800449e:	bf00      	nop
 80044a0:	46bd      	mov	sp, r7
 80044a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80044a6:	4770      	bx	lr

080044a8 <ArchCurrTaskGet>:
{
 80044a8:	b480      	push	{r7}
 80044aa:	af00      	add	r7, sp, #0
    return g_runTask;
 80044ac:	4b03      	ldr	r3, [pc, #12]	; (80044bc <ArchCurrTaskGet+0x14>)
 80044ae:	681b      	ldr	r3, [r3, #0]
}
 80044b0:	4618      	mov	r0, r3
 80044b2:	46bd      	mov	sp, r7
 80044b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80044b8:	4770      	bx	lr
 80044ba:	bf00      	nop
 80044bc:	200033cc 	.word	0x200033cc

080044c0 <OsCurrTaskGet>:
{
 80044c0:	b580      	push	{r7, lr}
 80044c2:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 80044c4:	f7ff fff0 	bl	80044a8 <ArchCurrTaskGet>
 80044c8:	4603      	mov	r3, r0
}
 80044ca:	4618      	mov	r0, r3
 80044cc:	bd80      	pop	{r7, pc}
	...

080044d0 <LOS_Panic>:
}

#endif

VOID LOS_Panic(const CHAR *fmt, ...)
{
 80044d0:	b40f      	push	{r0, r1, r2, r3}
 80044d2:	b580      	push	{r7, lr}
 80044d4:	b084      	sub	sp, #16
 80044d6:	af00      	add	r7, sp, #0
 80044d8:	69bb      	ldr	r3, [r7, #24]
 80044da:	607b      	str	r3, [r7, #4]
 80044dc:	4b0d      	ldr	r3, [pc, #52]	; (8004514 <LOS_Panic+0x44>)
 80044de:	681b      	ldr	r3, [r3, #0]
 80044e0:	60fb      	str	r3, [r7, #12]
 80044e2:	f04f 0300 	mov.w	r3, #0
    va_list ap;
    va_start(ap, fmt);
 80044e6:	f107 031c 	add.w	r3, r7, #28
 80044ea:	60bb      	str	r3, [r7, #8]
    UartVprintf(fmt, ap);
 80044ec:	68b9      	ldr	r1, [r7, #8]
 80044ee:	6878      	ldr	r0, [r7, #4]
 80044f0:	f000 f9d8 	bl	80048a4 <UartVprintf>
    va_end(ap);
    ArchHaltCpu();
 80044f4:	f7ff ffd0 	bl	8004498 <ArchHaltCpu>
}
 80044f8:	bf00      	nop
 80044fa:	4b06      	ldr	r3, [pc, #24]	; (8004514 <LOS_Panic+0x44>)
 80044fc:	681a      	ldr	r2, [r3, #0]
 80044fe:	68fb      	ldr	r3, [r7, #12]
 8004500:	405a      	eors	r2, r3
 8004502:	d001      	beq.n	8004508 <LOS_Panic+0x38>
 8004504:	f000 f86a 	bl	80045dc <__stack_chk_fail>
 8004508:	3710      	adds	r7, #16
 800450a:	46bd      	mov	sp, r7
 800450c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8004510:	b004      	add	sp, #16
 8004512:	4770      	bx	lr
 8004514:	080201a0 	.word	0x080201a0

08004518 <LOS_BackTrace>:

VOID LOS_BackTrace(VOID)
{
 8004518:	b580      	push	{r7, lr}
 800451a:	b082      	sub	sp, #8
 800451c:	af00      	add	r7, sp, #0
#ifdef LOSCFG_BACKTRACE
    LosTaskCB *runTask = OsCurrTaskGet();
 800451e:	f7ff ffcf 	bl	80044c0 <OsCurrTaskGet>
 8004522:	6078      	str	r0, [r7, #4]
    PrintExcInfo("runTask->taskName = %s\n""runTask->taskId = %u\n",
 8004524:	687b      	ldr	r3, [r7, #4]
 8004526:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8004528:	687b      	ldr	r3, [r7, #4]
 800452a:	695b      	ldr	r3, [r3, #20]
 800452c:	461a      	mov	r2, r3
 800452e:	4804      	ldr	r0, [pc, #16]	; (8004540 <LOS_BackTrace+0x28>)
 8004530:	f000 f9ea 	bl	8004908 <PrintExcInfo>
        runTask->taskName, runTask->taskId);
    ArchBackTrace();
 8004534:	f012 fb04 	bl	8016b40 <ArchBackTrace>
#endif
}
 8004538:	bf00      	nop
 800453a:	3708      	adds	r7, #8
 800453c:	46bd      	mov	sp, r7
 800453e:	bd80      	pop	{r7, pc}
 8004540:	080201a4 	.word	0x080201a4

08004544 <LOS_TaskBackTrace>:

VOID LOS_TaskBackTrace(UINT32 taskID)
{
 8004544:	b580      	push	{r7, lr}
 8004546:	b084      	sub	sp, #16
 8004548:	af00      	add	r7, sp, #0
 800454a:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_BACKTRACE
    LosTaskCB *taskCB = NULL;
 800454c:	2300      	movs	r3, #0
 800454e:	60fb      	str	r3, [r7, #12]

    if (taskID >= g_taskMaxNum) {
 8004550:	4b1c      	ldr	r3, [pc, #112]	; (80045c4 <LOS_TaskBackTrace+0x80>)
 8004552:	681b      	ldr	r3, [r3, #0]
 8004554:	687a      	ldr	r2, [r7, #4]
 8004556:	429a      	cmp	r2, r3
 8004558:	d306      	bcc.n	8004568 <LOS_TaskBackTrace+0x24>
        PRINT_ERR("\r\nTask PID is invalid!\n");
 800455a:	481b      	ldr	r0, [pc, #108]	; (80045c8 <LOS_TaskBackTrace+0x84>)
 800455c:	f000 f9b0 	bl	80048c0 <dprintf>
 8004560:	481a      	ldr	r0, [pc, #104]	; (80045cc <LOS_TaskBackTrace+0x88>)
 8004562:	f000 f9ad 	bl	80048c0 <dprintf>
        return;
 8004566:	e02a      	b.n	80045be <LOS_TaskBackTrace+0x7a>
    }
    taskCB = OS_TCB_FROM_TID(taskID);
 8004568:	4b19      	ldr	r3, [pc, #100]	; (80045d0 <LOS_TaskBackTrace+0x8c>)
 800456a:	6819      	ldr	r1, [r3, #0]
 800456c:	687a      	ldr	r2, [r7, #4]
 800456e:	4613      	mov	r3, r2
 8004570:	009b      	lsls	r3, r3, #2
 8004572:	4413      	add	r3, r2
 8004574:	015b      	lsls	r3, r3, #5
 8004576:	440b      	add	r3, r1
 8004578:	60fb      	str	r3, [r7, #12]
    if ((taskCB->taskStatus & OS_TASK_STATUS_UNUSED) ||
 800457a:	68fb      	ldr	r3, [r7, #12]
 800457c:	889b      	ldrh	r3, [r3, #4]
 800457e:	f003 0301 	and.w	r3, r3, #1
 8004582:	2b00      	cmp	r3, #0
 8004584:	d107      	bne.n	8004596 <LOS_TaskBackTrace+0x52>
        (taskCB->taskEntry == NULL) ||
 8004586:	68fb      	ldr	r3, [r7, #12]
 8004588:	699b      	ldr	r3, [r3, #24]
    if ((taskCB->taskStatus & OS_TASK_STATUS_UNUSED) ||
 800458a:	2b00      	cmp	r3, #0
 800458c:	d003      	beq.n	8004596 <LOS_TaskBackTrace+0x52>
        (taskCB->taskName == NULL)) {
 800458e:	68fb      	ldr	r3, [r7, #12]
 8004590:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
        (taskCB->taskEntry == NULL) ||
 8004592:	2b00      	cmp	r3, #0
 8004594:	d106      	bne.n	80045a4 <LOS_TaskBackTrace+0x60>
        PRINT_ERR("\r\nThe task is not created!\n");
 8004596:	480c      	ldr	r0, [pc, #48]	; (80045c8 <LOS_TaskBackTrace+0x84>)
 8004598:	f000 f992 	bl	80048c0 <dprintf>
 800459c:	480d      	ldr	r0, [pc, #52]	; (80045d4 <LOS_TaskBackTrace+0x90>)
 800459e:	f000 f98f 	bl	80048c0 <dprintf>
        return;
 80045a2:	e00c      	b.n	80045be <LOS_TaskBackTrace+0x7a>
    }
    PRINTK("TaskName = %s\n""TaskId = 0x%x\n",
 80045a4:	68fb      	ldr	r3, [r7, #12]
 80045a6:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80045a8:	68fb      	ldr	r3, [r7, #12]
 80045aa:	695b      	ldr	r3, [r3, #20]
 80045ac:	461a      	mov	r2, r3
 80045ae:	480a      	ldr	r0, [pc, #40]	; (80045d8 <LOS_TaskBackTrace+0x94>)
 80045b0:	f000 f986 	bl	80048c0 <dprintf>
        taskCB->taskName, taskCB->taskId);
    ArchBackTraceWithSp(taskCB->stackPointer);
 80045b4:	68fb      	ldr	r3, [r7, #12]
 80045b6:	681b      	ldr	r3, [r3, #0]
 80045b8:	4618      	mov	r0, r3
 80045ba:	f012 fad5 	bl	8016b68 <ArchBackTraceWithSp>
#else
    (VOID)taskID;
#endif
}
 80045be:	3710      	adds	r7, #16
 80045c0:	46bd      	mov	sp, r7
 80045c2:	bd80      	pop	{r7, pc}
 80045c4:	200036d8 	.word	0x200036d8
 80045c8:	080201d4 	.word	0x080201d4
 80045cc:	080201dc 	.word	0x080201dc
 80045d0:	200036c4 	.word	0x200036c4
 80045d4:	080201f4 	.word	0x080201f4
 80045d8:	08020210 	.word	0x08020210

080045dc <__stack_chk_fail>:

#ifdef __GNUC__
/* stack protector */
VOID __stack_chk_fail(VOID)
{
 80045dc:	b580      	push	{r7, lr}
 80045de:	af00      	add	r7, sp, #0
 80045e0:	4673      	mov	r3, lr
    /* __builtin_return_address is a builtin function, building in gcc */
    LOS_Panic("stack-protector: Kernel stack is corrupted in: %p\n",
 80045e2:	4619      	mov	r1, r3
 80045e4:	4802      	ldr	r0, [pc, #8]	; (80045f0 <__stack_chk_fail+0x14>)
 80045e6:	f7ff ff73 	bl	80044d0 <LOS_Panic>
              __builtin_return_address(0));
}
 80045ea:	bf00      	nop
 80045ec:	bd80      	pop	{r7, pc}
 80045ee:	bf00      	nop
 80045f0:	08020230 	.word	0x08020230

080045f4 <ErrorMsg>:
    CONSOLE_OUTPUT = 2,
    EXC_OUTPUT = 3
} OutputType;

STATIC VOID ErrorMsg(VOID)
{
 80045f4:	b580      	push	{r7, lr}
 80045f6:	b082      	sub	sp, #8
 80045f8:	af00      	add	r7, sp, #0
    const CHAR *p = "Output illegal string! vsnprintf_s failed!\n";
 80045fa:	4b07      	ldr	r3, [pc, #28]	; (8004618 <ErrorMsg+0x24>)
 80045fc:	607b      	str	r3, [r7, #4]
    UartPuts(p, (UINT32)strlen(p), UART_WITH_LOCK);
 80045fe:	6878      	ldr	r0, [r7, #4]
 8004600:	f00a ffa5 	bl	800f54e <strlen>
 8004604:	4603      	mov	r3, r0
 8004606:	2201      	movs	r2, #1
 8004608:	4619      	mov	r1, r3
 800460a:	6878      	ldr	r0, [r7, #4]
 800460c:	f00c fa06 	bl	8010a1c <UartPuts>
}
 8004610:	bf00      	nop
 8004612:	3708      	adds	r7, #8
 8004614:	46bd      	mov	sp, r7
 8004616:	bd80      	pop	{r7, pc}
 8004618:	08020264 	.word	0x08020264

0800461c <UartOutput>:

STATIC VOID UartOutput(const CHAR *str, UINT32 len, BOOL isLock)
{
 800461c:	b580      	push	{r7, lr}
 800461e:	b084      	sub	sp, #16
 8004620:	af00      	add	r7, sp, #0
 8004622:	60f8      	str	r0, [r7, #12]
 8004624:	60b9      	str	r1, [r7, #8]
 8004626:	607a      	str	r2, [r7, #4]
#ifdef LOSCFG_SHELL_DMESG
    if (!OsCheckUartLock()) {
 8004628:	f00c fce6 	bl	8010ff8 <OsCheckUartLock>
 800462c:	4603      	mov	r3, r0
 800462e:	2b00      	cmp	r3, #0
 8004630:	d104      	bne.n	800463c <UartOutput+0x20>
        UartPuts(str, len, isLock);
 8004632:	687a      	ldr	r2, [r7, #4]
 8004634:	68b9      	ldr	r1, [r7, #8]
 8004636:	68f8      	ldr	r0, [r7, #12]
 8004638:	f00c f9f0 	bl	8010a1c <UartPuts>
    }
    if (isLock != UART_WITHOUT_LOCK) {
 800463c:	687b      	ldr	r3, [r7, #4]
 800463e:	2b00      	cmp	r3, #0
 8004640:	d003      	beq.n	800464a <UartOutput+0x2e>
        (VOID)OsLogMemcpyRecord(str, len);
 8004642:	68b9      	ldr	r1, [r7, #8]
 8004644:	68f8      	ldr	r0, [r7, #12]
 8004646:	f00c ff23 	bl	8011490 <OsLogMemcpyRecord>
    }
#else
    UartPuts(str, len, isLock);
#endif
}
 800464a:	bf00      	nop
 800464c:	3710      	adds	r7, #16
 800464e:	46bd      	mov	sp, r7
 8004650:	bd80      	pop	{r7, pc}

08004652 <OutputControl>:

STATIC VOID OutputControl(const CHAR *str, UINT32 len, OutputType type)
{
 8004652:	b580      	push	{r7, lr}
 8004654:	b084      	sub	sp, #16
 8004656:	af00      	add	r7, sp, #0
 8004658:	60f8      	str	r0, [r7, #12]
 800465a:	60b9      	str	r1, [r7, #8]
 800465c:	607a      	str	r2, [r7, #4]
    switch (type) {
 800465e:	687b      	ldr	r3, [r7, #4]
 8004660:	2b02      	cmp	r3, #2
 8004662:	d803      	bhi.n	800466c <OutputControl+0x1a>
 8004664:	687b      	ldr	r3, [r7, #4]
 8004666:	2b00      	cmp	r3, #0
 8004668:	d104      	bne.n	8004674 <OutputControl+0x22>
            break;
        case EXC_OUTPUT:
            UartOutput(str, len, UART_WITHOUT_LOCK);
            break;
        default:
            break;
 800466a:	e00f      	b.n	800468c <OutputControl+0x3a>
    switch (type) {
 800466c:	687b      	ldr	r3, [r7, #4]
 800466e:	2b03      	cmp	r3, #3
 8004670:	d006      	beq.n	8004680 <OutputControl+0x2e>
            break;
 8004672:	e00b      	b.n	800468c <OutputControl+0x3a>
            UartOutput(str, len, UART_WITH_LOCK);
 8004674:	2201      	movs	r2, #1
 8004676:	68b9      	ldr	r1, [r7, #8]
 8004678:	68f8      	ldr	r0, [r7, #12]
 800467a:	f7ff ffcf 	bl	800461c <UartOutput>
            break;
 800467e:	e005      	b.n	800468c <OutputControl+0x3a>
            UartOutput(str, len, UART_WITHOUT_LOCK);
 8004680:	2200      	movs	r2, #0
 8004682:	68b9      	ldr	r1, [r7, #8]
 8004684:	68f8      	ldr	r0, [r7, #12]
 8004686:	f7ff ffc9 	bl	800461c <UartOutput>
            break;
 800468a:	bf00      	nop
    }
    return;
 800468c:	bf00      	nop
}
 800468e:	3710      	adds	r7, #16
 8004690:	46bd      	mov	sp, r7
 8004692:	bd80      	pop	{r7, pc}

08004694 <OsVprintfFree>:

STATIC VOID OsVprintfFree(CHAR *buf, UINT32 bufLen)
{
 8004694:	b580      	push	{r7, lr}
 8004696:	b082      	sub	sp, #8
 8004698:	af00      	add	r7, sp, #0
 800469a:	6078      	str	r0, [r7, #4]
 800469c:	6039      	str	r1, [r7, #0]
    if (bufLen != SIZEBUF) {
 800469e:	683b      	ldr	r3, [r7, #0]
 80046a0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80046a4:	d005      	beq.n	80046b2 <OsVprintfFree+0x1e>
        (VOID)LOS_MemFree(m_aucSysMem0, buf);
 80046a6:	4b05      	ldr	r3, [pc, #20]	; (80046bc <OsVprintfFree+0x28>)
 80046a8:	681b      	ldr	r3, [r3, #0]
 80046aa:	6879      	ldr	r1, [r7, #4]
 80046ac:	4618      	mov	r0, r3
 80046ae:	f004 ff69 	bl	8009584 <LOS_MemFree>
    }
}
 80046b2:	bf00      	nop
 80046b4:	3708      	adds	r7, #8
 80046b6:	46bd      	mov	sp, r7
 80046b8:	bd80      	pop	{r7, pc}
 80046ba:	bf00      	nop
 80046bc:	200021bc 	.word	0x200021bc

080046c0 <OsVprintf>:

STATIC VOID OsVprintf(const CHAR *fmt, va_list ap, OutputType type)
{
 80046c0:	b5b0      	push	{r4, r5, r7, lr}
 80046c2:	b0cc      	sub	sp, #304	; 0x130
 80046c4:	af02      	add	r7, sp, #8
 80046c6:	f107 030c 	add.w	r3, r7, #12
 80046ca:	6018      	str	r0, [r3, #0]
 80046cc:	f107 0308 	add.w	r3, r7, #8
 80046d0:	6019      	str	r1, [r3, #0]
 80046d2:	1d3b      	adds	r3, r7, #4
 80046d4:	601a      	str	r2, [r3, #0]
 80046d6:	4b6f      	ldr	r3, [pc, #444]	; (8004894 <OsVprintf+0x1d4>)
 80046d8:	681b      	ldr	r3, [r3, #0]
 80046da:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 80046de:	f04f 0300 	mov.w	r3, #0
    INT32 len;
    const CHAR *errMsgMalloc = "OsVprintf, malloc failed!\n";
 80046e2:	f107 031c 	add.w	r3, r7, #28
 80046e6:	4a6c      	ldr	r2, [pc, #432]	; (8004898 <OsVprintf+0x1d8>)
 80046e8:	601a      	str	r2, [r3, #0]
    const CHAR *errMsgLen = "OsVprintf, length overflow!\n";
 80046ea:	f107 0320 	add.w	r3, r7, #32
 80046ee:	4a6b      	ldr	r2, [pc, #428]	; (800489c <OsVprintf+0x1dc>)
 80046f0:	601a      	str	r2, [r3, #0]
    CHAR aBuf[SIZEBUF] = {0};
 80046f2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80046f6:	2200      	movs	r2, #0
 80046f8:	601a      	str	r2, [r3, #0]
 80046fa:	3304      	adds	r3, #4
 80046fc:	22fc      	movs	r2, #252	; 0xfc
 80046fe:	2100      	movs	r1, #0
 8004700:	4618      	mov	r0, r3
 8004702:	f00a fe01 	bl	800f308 <memset>
    CHAR *bBuf = NULL;
 8004706:	f107 0314 	add.w	r3, r7, #20
 800470a:	2200      	movs	r2, #0
 800470c:	601a      	str	r2, [r3, #0]
    UINT32 bufLen = SIZEBUF;
 800470e:	f107 0318 	add.w	r3, r7, #24
 8004712:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004716:	601a      	str	r2, [r3, #0]

    bBuf = aBuf;
 8004718:	f107 0314 	add.w	r3, r7, #20
 800471c:	f107 0224 	add.w	r2, r7, #36	; 0x24
 8004720:	601a      	str	r2, [r3, #0]
    len = vsnprintf_s(bBuf, bufLen, bufLen - 1, fmt, ap);
 8004722:	f107 0318 	add.w	r3, r7, #24
 8004726:	681b      	ldr	r3, [r3, #0]
 8004728:	1e5d      	subs	r5, r3, #1
 800472a:	f107 0410 	add.w	r4, r7, #16
 800472e:	f107 030c 	add.w	r3, r7, #12
 8004732:	f107 0118 	add.w	r1, r7, #24
 8004736:	f107 0014 	add.w	r0, r7, #20
 800473a:	f107 0208 	add.w	r2, r7, #8
 800473e:	6812      	ldr	r2, [r2, #0]
 8004740:	9200      	str	r2, [sp, #0]
 8004742:	681b      	ldr	r3, [r3, #0]
 8004744:	462a      	mov	r2, r5
 8004746:	6809      	ldr	r1, [r1, #0]
 8004748:	6800      	ldr	r0, [r0, #0]
 800474a:	f012 fa51 	bl	8016bf0 <vsnprintf_s>
 800474e:	6020      	str	r0, [r4, #0]
    if ((len == -1) && (*bBuf == '\0')) {
 8004750:	f107 0310 	add.w	r3, r7, #16
 8004754:	681b      	ldr	r3, [r3, #0]
 8004756:	f1b3 3fff 	cmp.w	r3, #4294967295
 800475a:	d16e      	bne.n	800483a <OsVprintf+0x17a>
 800475c:	f107 0314 	add.w	r3, r7, #20
 8004760:	681b      	ldr	r3, [r3, #0]
 8004762:	781b      	ldrb	r3, [r3, #0]
 8004764:	2b00      	cmp	r3, #0
 8004766:	d168      	bne.n	800483a <OsVprintf+0x17a>
        /* parameter is illegal or some features in fmt dont support */
        ErrorMsg();
 8004768:	f7ff ff44 	bl	80045f4 <ErrorMsg>
        return;
 800476c:	e086      	b.n	800487c <OsVprintf+0x1bc>
    }

    while (len == -1) {
        /* bBuf is not enough */
        OsVprintfFree(bBuf, bufLen);
 800476e:	f107 0218 	add.w	r2, r7, #24
 8004772:	f107 0314 	add.w	r3, r7, #20
 8004776:	6811      	ldr	r1, [r2, #0]
 8004778:	6818      	ldr	r0, [r3, #0]
 800477a:	f7ff ff8b 	bl	8004694 <OsVprintfFree>

        bufLen = bufLen << 1;
 800477e:	f107 0318 	add.w	r3, r7, #24
 8004782:	f107 0218 	add.w	r2, r7, #24
 8004786:	6812      	ldr	r2, [r2, #0]
 8004788:	0052      	lsls	r2, r2, #1
 800478a:	601a      	str	r2, [r3, #0]
        if ((INT32)bufLen <= 0) {
 800478c:	f107 0318 	add.w	r3, r7, #24
 8004790:	681b      	ldr	r3, [r3, #0]
 8004792:	2b00      	cmp	r3, #0
 8004794:	dc0c      	bgt.n	80047b0 <OsVprintf+0xf0>
            UartPuts(errMsgLen, (UINT32)strlen(errMsgLen), UART_WITH_LOCK);
 8004796:	f107 0320 	add.w	r3, r7, #32
 800479a:	6818      	ldr	r0, [r3, #0]
 800479c:	f00a fed7 	bl	800f54e <strlen>
 80047a0:	4601      	mov	r1, r0
 80047a2:	f107 0320 	add.w	r3, r7, #32
 80047a6:	2201      	movs	r2, #1
 80047a8:	6818      	ldr	r0, [r3, #0]
 80047aa:	f00c f937 	bl	8010a1c <UartPuts>
            return;
 80047ae:	e065      	b.n	800487c <OsVprintf+0x1bc>
        }
        bBuf = (CHAR *)LOS_MemAlloc(m_aucSysMem0, bufLen);
 80047b0:	4b3b      	ldr	r3, [pc, #236]	; (80048a0 <OsVprintf+0x1e0>)
 80047b2:	681a      	ldr	r2, [r3, #0]
 80047b4:	f107 0414 	add.w	r4, r7, #20
 80047b8:	f107 0318 	add.w	r3, r7, #24
 80047bc:	6819      	ldr	r1, [r3, #0]
 80047be:	4610      	mov	r0, r2
 80047c0:	f004 fe28 	bl	8009414 <LOS_MemAlloc>
 80047c4:	6020      	str	r0, [r4, #0]
        if (bBuf == NULL) {
 80047c6:	f107 0314 	add.w	r3, r7, #20
 80047ca:	681b      	ldr	r3, [r3, #0]
 80047cc:	2b00      	cmp	r3, #0
 80047ce:	d10c      	bne.n	80047ea <OsVprintf+0x12a>
            UartPuts(errMsgMalloc, (UINT32)strlen(errMsgMalloc), UART_WITH_LOCK);
 80047d0:	f107 031c 	add.w	r3, r7, #28
 80047d4:	6818      	ldr	r0, [r3, #0]
 80047d6:	f00a feba 	bl	800f54e <strlen>
 80047da:	4601      	mov	r1, r0
 80047dc:	f107 031c 	add.w	r3, r7, #28
 80047e0:	2201      	movs	r2, #1
 80047e2:	6818      	ldr	r0, [r3, #0]
 80047e4:	f00c f91a 	bl	8010a1c <UartPuts>
            return;
 80047e8:	e048      	b.n	800487c <OsVprintf+0x1bc>
        }
        len = vsnprintf_s(bBuf, bufLen, bufLen - 1, fmt, ap);
 80047ea:	f107 0318 	add.w	r3, r7, #24
 80047ee:	681b      	ldr	r3, [r3, #0]
 80047f0:	1e5d      	subs	r5, r3, #1
 80047f2:	f107 0410 	add.w	r4, r7, #16
 80047f6:	f107 030c 	add.w	r3, r7, #12
 80047fa:	f107 0118 	add.w	r1, r7, #24
 80047fe:	f107 0014 	add.w	r0, r7, #20
 8004802:	f107 0208 	add.w	r2, r7, #8
 8004806:	6812      	ldr	r2, [r2, #0]
 8004808:	9200      	str	r2, [sp, #0]
 800480a:	681b      	ldr	r3, [r3, #0]
 800480c:	462a      	mov	r2, r5
 800480e:	6809      	ldr	r1, [r1, #0]
 8004810:	6800      	ldr	r0, [r0, #0]
 8004812:	f012 f9ed 	bl	8016bf0 <vsnprintf_s>
 8004816:	6020      	str	r0, [r4, #0]
        if (*bBuf == '\0') {
 8004818:	f107 0314 	add.w	r3, r7, #20
 800481c:	681b      	ldr	r3, [r3, #0]
 800481e:	781b      	ldrb	r3, [r3, #0]
 8004820:	2b00      	cmp	r3, #0
 8004822:	d10a      	bne.n	800483a <OsVprintf+0x17a>
            /* parameter is illegal or some features in fmt dont support */
            (VOID)LOS_MemFree(m_aucSysMem0, bBuf);
 8004824:	4b1e      	ldr	r3, [pc, #120]	; (80048a0 <OsVprintf+0x1e0>)
 8004826:	681a      	ldr	r2, [r3, #0]
 8004828:	f107 0314 	add.w	r3, r7, #20
 800482c:	6819      	ldr	r1, [r3, #0]
 800482e:	4610      	mov	r0, r2
 8004830:	f004 fea8 	bl	8009584 <LOS_MemFree>
            ErrorMsg();
 8004834:	f7ff fede 	bl	80045f4 <ErrorMsg>
            return;
 8004838:	e020      	b.n	800487c <OsVprintf+0x1bc>
    while (len == -1) {
 800483a:	f107 0310 	add.w	r3, r7, #16
 800483e:	681b      	ldr	r3, [r3, #0]
 8004840:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004844:	d093      	beq.n	800476e <OsVprintf+0xae>
        }
    }
    *(bBuf + len) = '\0';
 8004846:	f107 0310 	add.w	r3, r7, #16
 800484a:	681b      	ldr	r3, [r3, #0]
 800484c:	f107 0214 	add.w	r2, r7, #20
 8004850:	6812      	ldr	r2, [r2, #0]
 8004852:	4413      	add	r3, r2
 8004854:	2200      	movs	r2, #0
 8004856:	701a      	strb	r2, [r3, #0]
    OutputControl(bBuf, len, type);
 8004858:	f107 0310 	add.w	r3, r7, #16
 800485c:	6819      	ldr	r1, [r3, #0]
 800485e:	1d3a      	adds	r2, r7, #4
 8004860:	f107 0314 	add.w	r3, r7, #20
 8004864:	6812      	ldr	r2, [r2, #0]
 8004866:	6818      	ldr	r0, [r3, #0]
 8004868:	f7ff fef3 	bl	8004652 <OutputControl>
    OsVprintfFree(bBuf, bufLen);
 800486c:	f107 0218 	add.w	r2, r7, #24
 8004870:	f107 0314 	add.w	r3, r7, #20
 8004874:	6811      	ldr	r1, [r2, #0]
 8004876:	6818      	ldr	r0, [r3, #0]
 8004878:	f7ff ff0c 	bl	8004694 <OsVprintfFree>
}
 800487c:	4b05      	ldr	r3, [pc, #20]	; (8004894 <OsVprintf+0x1d4>)
 800487e:	681a      	ldr	r2, [r3, #0]
 8004880:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8004884:	405a      	eors	r2, r3
 8004886:	d001      	beq.n	800488c <OsVprintf+0x1cc>
 8004888:	f7ff fea8 	bl	80045dc <__stack_chk_fail>
 800488c:	f507 7794 	add.w	r7, r7, #296	; 0x128
 8004890:	46bd      	mov	sp, r7
 8004892:	bdb0      	pop	{r4, r5, r7, pc}
 8004894:	080202cc 	.word	0x080202cc
 8004898:	08020290 	.word	0x08020290
 800489c:	080202ac 	.word	0x080202ac
 80048a0:	200021bc 	.word	0x200021bc

080048a4 <UartVprintf>:

VOID UartVprintf(const CHAR *fmt, va_list ap)
{
 80048a4:	b580      	push	{r7, lr}
 80048a6:	b082      	sub	sp, #8
 80048a8:	af00      	add	r7, sp, #0
 80048aa:	6078      	str	r0, [r7, #4]
 80048ac:	6039      	str	r1, [r7, #0]
    OsVprintf(fmt, ap, UART_OUTPUT);
 80048ae:	2201      	movs	r2, #1
 80048b0:	6839      	ldr	r1, [r7, #0]
 80048b2:	6878      	ldr	r0, [r7, #4]
 80048b4:	f7ff ff04 	bl	80046c0 <OsVprintf>
}
 80048b8:	bf00      	nop
 80048ba:	3708      	adds	r7, #8
 80048bc:	46bd      	mov	sp, r7
 80048be:	bd80      	pop	{r7, pc}

080048c0 <dprintf>:
    OsVprintf(fmt, ap, UART_OUTPUT);
    va_end(ap);
}

__attribute__ ((noinline)) VOID dprintf(const CHAR *fmt, ...)
{
 80048c0:	b40f      	push	{r0, r1, r2, r3}
 80048c2:	b580      	push	{r7, lr}
 80048c4:	b084      	sub	sp, #16
 80048c6:	af00      	add	r7, sp, #0
 80048c8:	69bb      	ldr	r3, [r7, #24]
 80048ca:	607b      	str	r3, [r7, #4]
 80048cc:	4b0d      	ldr	r3, [pc, #52]	; (8004904 <dprintf+0x44>)
 80048ce:	681b      	ldr	r3, [r3, #0]
 80048d0:	60fb      	str	r3, [r7, #12]
 80048d2:	f04f 0300 	mov.w	r3, #0
    va_list ap;
    va_start(ap, fmt);
 80048d6:	f107 031c 	add.w	r3, r7, #28
 80048da:	60bb      	str	r3, [r7, #8]
    OsVprintf(fmt, ap, CONSOLE_OUTPUT);
 80048dc:	2202      	movs	r2, #2
 80048de:	68b9      	ldr	r1, [r7, #8]
 80048e0:	6878      	ldr	r0, [r7, #4]
 80048e2:	f7ff feed 	bl	80046c0 <OsVprintf>
    va_end(ap);
}
 80048e6:	bf00      	nop
 80048e8:	4b06      	ldr	r3, [pc, #24]	; (8004904 <dprintf+0x44>)
 80048ea:	681a      	ldr	r2, [r3, #0]
 80048ec:	68fb      	ldr	r3, [r7, #12]
 80048ee:	405a      	eors	r2, r3
 80048f0:	d001      	beq.n	80048f6 <dprintf+0x36>
 80048f2:	f7ff fe73 	bl	80045dc <__stack_chk_fail>
 80048f6:	3710      	adds	r7, #16
 80048f8:	46bd      	mov	sp, r7
 80048fa:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 80048fe:	b004      	add	sp, #16
 8004900:	4770      	bx	lr
 8004902:	bf00      	nop
 8004904:	080202d4 	.word	0x080202d4

08004908 <PrintExcInfo>:
    OsVprintf(fmt, ap, EXC_OUTPUT);
    va_end(ap);
}

VOID PrintExcInfo(const CHAR *fmt, ...)
{
 8004908:	b40f      	push	{r0, r1, r2, r3}
 800490a:	b580      	push	{r7, lr}
 800490c:	b084      	sub	sp, #16
 800490e:	af00      	add	r7, sp, #0
 8004910:	69bb      	ldr	r3, [r7, #24]
 8004912:	607b      	str	r3, [r7, #4]
 8004914:	4b0d      	ldr	r3, [pc, #52]	; (800494c <PrintExcInfo+0x44>)
 8004916:	681b      	ldr	r3, [r3, #0]
 8004918:	60fb      	str	r3, [r7, #12]
 800491a:	f04f 0300 	mov.w	r3, #0
    va_list ap;
    va_start(ap, fmt);
 800491e:	f107 031c 	add.w	r3, r7, #28
 8004922:	60bb      	str	r3, [r7, #8]
    /* uart output without print-spinlock */
    OsVprintf(fmt, ap, EXC_OUTPUT);
 8004924:	2203      	movs	r2, #3
 8004926:	68b9      	ldr	r1, [r7, #8]
 8004928:	6878      	ldr	r0, [r7, #4]
 800492a:	f7ff fec9 	bl	80046c0 <OsVprintf>
#ifdef LOSCFG_SHELL_EXCINFO_DUMP
    WriteExcBufVa(fmt, ap);
#endif
    va_end(ap);
}
 800492e:	bf00      	nop
 8004930:	4b06      	ldr	r3, [pc, #24]	; (800494c <PrintExcInfo+0x44>)
 8004932:	681a      	ldr	r2, [r3, #0]
 8004934:	68fb      	ldr	r3, [r7, #12]
 8004936:	405a      	eors	r2, r3
 8004938:	d001      	beq.n	800493e <PrintExcInfo+0x36>
 800493a:	f7ff fe4f 	bl	80045dc <__stack_chk_fail>
 800493e:	3710      	adds	r7, #16
 8004940:	46bd      	mov	sp, r7
 8004942:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8004946:	b004      	add	sp, #16
 8004948:	4770      	bx	lr
 800494a:	bf00      	nop
 800494c:	080202dc 	.word	0x080202dc

08004950 <LOS_ListInit>:
{
 8004950:	b480      	push	{r7}
 8004952:	b083      	sub	sp, #12
 8004954:	af00      	add	r7, sp, #0
 8004956:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 8004958:	687b      	ldr	r3, [r7, #4]
 800495a:	687a      	ldr	r2, [r7, #4]
 800495c:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 800495e:	687b      	ldr	r3, [r7, #4]
 8004960:	687a      	ldr	r2, [r7, #4]
 8004962:	601a      	str	r2, [r3, #0]
}
 8004964:	bf00      	nop
 8004966:	370c      	adds	r7, #12
 8004968:	46bd      	mov	sp, r7
 800496a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800496e:	4770      	bx	lr

08004970 <LOS_ListEmpty>:
{
 8004970:	b480      	push	{r7}
 8004972:	b083      	sub	sp, #12
 8004974:	af00      	add	r7, sp, #0
 8004976:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8004978:	687b      	ldr	r3, [r7, #4]
 800497a:	685b      	ldr	r3, [r3, #4]
 800497c:	687a      	ldr	r2, [r7, #4]
 800497e:	429a      	cmp	r2, r3
 8004980:	bf0c      	ite	eq
 8004982:	2301      	moveq	r3, #1
 8004984:	2300      	movne	r3, #0
 8004986:	b2db      	uxtb	r3, r3
}
 8004988:	4618      	mov	r0, r3
 800498a:	370c      	adds	r7, #12
 800498c:	46bd      	mov	sp, r7
 800498e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004992:	4770      	bx	lr

08004994 <ArchCurrCpuid>:
{
 8004994:	b480      	push	{r7}
 8004996:	af00      	add	r7, sp, #0
    return 0;
 8004998:	2300      	movs	r3, #0
}
 800499a:	4618      	mov	r0, r3
 800499c:	46bd      	mov	sp, r7
 800499e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049a2:	4770      	bx	lr

080049a4 <ArchIntLocked>:
extern UINT32 ArchIntLock(VOID);
extern UINT32 ArchIntUnlock(VOID);
extern VOID ArchIntRestore(UINT32 intSave);

STATIC INLINE UINT32 ArchIntLocked(VOID)
{
 80049a4:	b480      	push	{r7}
 80049a6:	b083      	sub	sp, #12
 80049a8:	af00      	add	r7, sp, #0
    UINT32 intSave;

    __asm__ volatile("mrs %0, primask" : "=r" (intSave) : : "memory");
 80049aa:	f3ef 8310 	mrs	r3, PRIMASK
 80049ae:	607b      	str	r3, [r7, #4]

    return intSave;
 80049b0:	687b      	ldr	r3, [r7, #4]
}
 80049b2:	4618      	mov	r0, r3
 80049b4:	370c      	adds	r7, #12
 80049b6:	46bd      	mov	sp, r7
 80049b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049bc:	4770      	bx	lr

080049be <LOS_IntLock>:
{
 80049be:	b580      	push	{r7, lr}
 80049c0:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80049c2:	f7fc f981 	bl	8000cc8 <ArchIntLock>
 80049c6:	4603      	mov	r3, r0
}
 80049c8:	4618      	mov	r0, r3
 80049ca:	bd80      	pop	{r7, pc}

080049cc <LOS_IntRestore>:
{
 80049cc:	b580      	push	{r7, lr}
 80049ce:	b082      	sub	sp, #8
 80049d0:	af00      	add	r7, sp, #0
 80049d2:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80049d4:	6878      	ldr	r0, [r7, #4]
 80049d6:	f7fc f97f 	bl	8000cd8 <ArchIntRestore>
}
 80049da:	bf00      	nop
 80049dc:	3708      	adds	r7, #8
 80049de:	46bd      	mov	sp, r7
 80049e0:	bd80      	pop	{r7, pc}
	...

080049e4 <ArchCurrTaskGet>:
{
 80049e4:	b480      	push	{r7}
 80049e6:	af00      	add	r7, sp, #0
    return g_runTask;
 80049e8:	4b03      	ldr	r3, [pc, #12]	; (80049f8 <ArchCurrTaskGet+0x14>)
 80049ea:	681b      	ldr	r3, [r3, #0]
}
 80049ec:	4618      	mov	r0, r3
 80049ee:	46bd      	mov	sp, r7
 80049f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049f4:	4770      	bx	lr
 80049f6:	bf00      	nop
 80049f8:	200033cc 	.word	0x200033cc

080049fc <OsPercpuGet>:
{
 80049fc:	b580      	push	{r7, lr}
 80049fe:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 8004a00:	f7ff ffc8 	bl	8004994 <ArchCurrCpuid>
 8004a04:	4602      	mov	r2, r0
 8004a06:	4613      	mov	r3, r2
 8004a08:	00db      	lsls	r3, r3, #3
 8004a0a:	4413      	add	r3, r2
 8004a0c:	009b      	lsls	r3, r3, #2
 8004a0e:	4a02      	ldr	r2, [pc, #8]	; (8004a18 <OsPercpuGet+0x1c>)
 8004a10:	4413      	add	r3, r2
}
 8004a12:	4618      	mov	r0, r3
 8004a14:	bd80      	pop	{r7, pc}
 8004a16:	bf00      	nop
 8004a18:	200036fc 	.word	0x200036fc

08004a1c <OsPreemptableInSched>:
{
 8004a1c:	b580      	push	{r7, lr}
 8004a1e:	b082      	sub	sp, #8
 8004a20:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 8004a22:	2300      	movs	r3, #0
 8004a24:	607b      	str	r3, [r7, #4]
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 8004a26:	f7ff ffe9 	bl	80049fc <OsPercpuGet>
 8004a2a:	4603      	mov	r3, r0
 8004a2c:	695b      	ldr	r3, [r3, #20]
 8004a2e:	2b00      	cmp	r3, #0
 8004a30:	bf0c      	ite	eq
 8004a32:	2301      	moveq	r3, #1
 8004a34:	2300      	movne	r3, #0
 8004a36:	b2db      	uxtb	r3, r3
 8004a38:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 8004a3a:	687b      	ldr	r3, [r7, #4]
 8004a3c:	2b00      	cmp	r3, #0
 8004a3e:	d104      	bne.n	8004a4a <OsPreemptableInSched+0x2e>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8004a40:	f7ff ffdc 	bl	80049fc <OsPercpuGet>
 8004a44:	4603      	mov	r3, r0
 8004a46:	2201      	movs	r2, #1
 8004a48:	621a      	str	r2, [r3, #32]
    return preemptable;
 8004a4a:	687b      	ldr	r3, [r7, #4]
}
 8004a4c:	4618      	mov	r0, r3
 8004a4e:	3708      	adds	r7, #8
 8004a50:	46bd      	mov	sp, r7
 8004a52:	bd80      	pop	{r7, pc}

08004a54 <LOS_Schedule>:
{
 8004a54:	b580      	push	{r7, lr}
 8004a56:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 8004a58:	f7fd fe02 	bl	8002660 <IntActive>
 8004a5c:	4603      	mov	r3, r0
 8004a5e:	2b00      	cmp	r3, #0
 8004a60:	d005      	beq.n	8004a6e <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8004a62:	f7ff ffcb 	bl	80049fc <OsPercpuGet>
 8004a66:	4603      	mov	r3, r0
 8004a68:	2201      	movs	r2, #1
 8004a6a:	621a      	str	r2, [r3, #32]
        return;
 8004a6c:	e001      	b.n	8004a72 <LOS_Schedule+0x1e>
    OsSchedPreempt();
 8004a6e:	f004 f961 	bl	8008d34 <OsSchedPreempt>
}
 8004a72:	bd80      	pop	{r7, pc}

08004a74 <LOS_SpinLockSave>:
{
 8004a74:	b580      	push	{r7, lr}
 8004a76:	b082      	sub	sp, #8
 8004a78:	af00      	add	r7, sp, #0
 8004a7a:	6078      	str	r0, [r7, #4]
 8004a7c:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8004a7e:	f7ff ff9e 	bl	80049be <LOS_IntLock>
 8004a82:	4602      	mov	r2, r0
 8004a84:	683b      	ldr	r3, [r7, #0]
 8004a86:	601a      	str	r2, [r3, #0]
}
 8004a88:	bf00      	nop
 8004a8a:	3708      	adds	r7, #8
 8004a8c:	46bd      	mov	sp, r7
 8004a8e:	bd80      	pop	{r7, pc}

08004a90 <LOS_SpinUnlockRestore>:
{
 8004a90:	b580      	push	{r7, lr}
 8004a92:	b082      	sub	sp, #8
 8004a94:	af00      	add	r7, sp, #0
 8004a96:	6078      	str	r0, [r7, #4]
 8004a98:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8004a9a:	6838      	ldr	r0, [r7, #0]
 8004a9c:	f7ff ff96 	bl	80049cc <LOS_IntRestore>
}
 8004aa0:	bf00      	nop
 8004aa2:	3708      	adds	r7, #8
 8004aa4:	46bd      	mov	sp, r7
 8004aa6:	bd80      	pop	{r7, pc}

08004aa8 <LOS_SpinHeld>:
{
 8004aa8:	b480      	push	{r7}
 8004aaa:	b083      	sub	sp, #12
 8004aac:	af00      	add	r7, sp, #0
 8004aae:	6078      	str	r0, [r7, #4]
    return TRUE;
 8004ab0:	2301      	movs	r3, #1
}
 8004ab2:	4618      	mov	r0, r3
 8004ab4:	370c      	adds	r7, #12
 8004ab6:	46bd      	mov	sp, r7
 8004ab8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004abc:	4770      	bx	lr

08004abe <OsCurrTaskGet>:
{
 8004abe:	b580      	push	{r7, lr}
 8004ac0:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 8004ac2:	f7ff ff8f 	bl	80049e4 <ArchCurrTaskGet>
 8004ac6:	4603      	mov	r3, r0
}
 8004ac8:	4618      	mov	r0, r3
 8004aca:	bd80      	pop	{r7, pc}

08004acc <LOS_MpSchedule>:
{
 8004acc:	b480      	push	{r7}
 8004ace:	b083      	sub	sp, #12
 8004ad0:	af00      	add	r7, sp, #0
 8004ad2:	6078      	str	r0, [r7, #4]
}
 8004ad4:	bf00      	nop
 8004ad6:	370c      	adds	r7, #12
 8004ad8:	46bd      	mov	sp, r7
 8004ada:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ade:	4770      	bx	lr

08004ae0 <LOS_EventInit>:
extern "C" {
#endif
#endif /* __cplusplus */

LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventInit(PEVENT_CB_S eventCB)
{
 8004ae0:	b590      	push	{r4, r7, lr}
 8004ae2:	b089      	sub	sp, #36	; 0x24
 8004ae4:	af00      	add	r7, sp, #0
 8004ae6:	6078      	str	r0, [r7, #4]
 8004ae8:	4b21      	ldr	r3, [pc, #132]	; (8004b70 <LOS_EventInit+0x90>)
 8004aea:	681b      	ldr	r3, [r3, #0]
 8004aec:	61fb      	str	r3, [r7, #28]
 8004aee:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    LOS_TRACE(EVENT_CREATE, (UINTPTR)eventCB);
 8004af2:	2300      	movs	r3, #0
 8004af4:	617b      	str	r3, [r7, #20]
 8004af6:	687b      	ldr	r3, [r7, #4]
 8004af8:	61bb      	str	r3, [r7, #24]
 8004afa:	2302      	movs	r3, #2
 8004afc:	60fb      	str	r3, [r7, #12]
 8004afe:	68fb      	ldr	r3, [r7, #12]
 8004b00:	2b01      	cmp	r3, #1
 8004b02:	d916      	bls.n	8004b32 <LOS_EventInit+0x52>
 8004b04:	4b1b      	ldr	r3, [pc, #108]	; (8004b74 <LOS_EventInit+0x94>)
 8004b06:	681b      	ldr	r3, [r3, #0]
 8004b08:	2b00      	cmp	r3, #0
 8004b0a:	d012      	beq.n	8004b32 <LOS_EventInit+0x52>
 8004b0c:	4b19      	ldr	r3, [pc, #100]	; (8004b74 <LOS_EventInit+0x94>)
 8004b0e:	681c      	ldr	r4, [r3, #0]
 8004b10:	69b9      	ldr	r1, [r7, #24]
 8004b12:	68fb      	ldr	r3, [r7, #12]
 8004b14:	2b02      	cmp	r3, #2
 8004b16:	d904      	bls.n	8004b22 <LOS_EventInit+0x42>
 8004b18:	f107 0314 	add.w	r3, r7, #20
 8004b1c:	f103 0208 	add.w	r2, r3, #8
 8004b20:	e000      	b.n	8004b24 <LOS_EventInit+0x44>
 8004b22:	2200      	movs	r2, #0
 8004b24:	68fb      	ldr	r3, [r7, #12]
 8004b26:	b29b      	uxth	r3, r3
 8004b28:	3b02      	subs	r3, #2
 8004b2a:	b29b      	uxth	r3, r3
 8004b2c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8004b30:	47a0      	blx	r4

    if (eventCB == NULL) {
 8004b32:	687b      	ldr	r3, [r7, #4]
 8004b34:	2b00      	cmp	r3, #0
 8004b36:	d101      	bne.n	8004b3c <LOS_EventInit+0x5c>
        return LOS_ERRNO_EVENT_PTR_NULL;
 8004b38:	4b0f      	ldr	r3, [pc, #60]	; (8004b78 <LOS_EventInit+0x98>)
 8004b3a:	e00e      	b.n	8004b5a <LOS_EventInit+0x7a>
    }

    intSave = LOS_IntLock();
 8004b3c:	f7ff ff3f 	bl	80049be <LOS_IntLock>
 8004b40:	6138      	str	r0, [r7, #16]
    eventCB->uwEventID = 0;
 8004b42:	687b      	ldr	r3, [r7, #4]
 8004b44:	2200      	movs	r2, #0
 8004b46:	601a      	str	r2, [r3, #0]
    LOS_ListInit(&eventCB->stEventList);
 8004b48:	687b      	ldr	r3, [r7, #4]
 8004b4a:	3304      	adds	r3, #4
 8004b4c:	4618      	mov	r0, r3
 8004b4e:	f7ff feff 	bl	8004950 <LOS_ListInit>
    LOS_IntRestore(intSave);
 8004b52:	6938      	ldr	r0, [r7, #16]
 8004b54:	f7ff ff3a 	bl	80049cc <LOS_IntRestore>
    return LOS_OK;
 8004b58:	2300      	movs	r3, #0
}
 8004b5a:	4a05      	ldr	r2, [pc, #20]	; (8004b70 <LOS_EventInit+0x90>)
 8004b5c:	6811      	ldr	r1, [r2, #0]
 8004b5e:	69fa      	ldr	r2, [r7, #28]
 8004b60:	4051      	eors	r1, r2
 8004b62:	d001      	beq.n	8004b68 <LOS_EventInit+0x88>
 8004b64:	f7ff fd3a 	bl	80045dc <__stack_chk_fail>
 8004b68:	4618      	mov	r0, r3
 8004b6a:	3724      	adds	r7, #36	; 0x24
 8004b6c:	46bd      	mov	sp, r7
 8004b6e:	bd90      	pop	{r4, r7, pc}
 8004b70:	080202e0 	.word	0x080202e0
 8004b74:	20000768 	.word	0x20000768
 8004b78:	02001c06 	.word	0x02001c06

08004b7c <OsEventParamCheck>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventParamCheck(const VOID *ptr, UINT32 eventMask, UINT32 mode)
{
 8004b7c:	b480      	push	{r7}
 8004b7e:	b085      	sub	sp, #20
 8004b80:	af00      	add	r7, sp, #0
 8004b82:	60f8      	str	r0, [r7, #12]
 8004b84:	60b9      	str	r1, [r7, #8]
 8004b86:	607a      	str	r2, [r7, #4]
    if (ptr == NULL) {
 8004b88:	68fb      	ldr	r3, [r7, #12]
 8004b8a:	2b00      	cmp	r3, #0
 8004b8c:	d101      	bne.n	8004b92 <OsEventParamCheck+0x16>
        return LOS_ERRNO_EVENT_PTR_NULL;
 8004b8e:	4b15      	ldr	r3, [pc, #84]	; (8004be4 <OsEventParamCheck+0x68>)
 8004b90:	e022      	b.n	8004bd8 <OsEventParamCheck+0x5c>
    }

    if (eventMask == 0) {
 8004b92:	68bb      	ldr	r3, [r7, #8]
 8004b94:	2b00      	cmp	r3, #0
 8004b96:	d101      	bne.n	8004b9c <OsEventParamCheck+0x20>
        return LOS_ERRNO_EVENT_EVENTMASK_INVALID;
 8004b98:	4b13      	ldr	r3, [pc, #76]	; (8004be8 <OsEventParamCheck+0x6c>)
 8004b9a:	e01d      	b.n	8004bd8 <OsEventParamCheck+0x5c>
    }

    if (eventMask & LOS_ERRTYPE_ERROR) {
 8004b9c:	68bb      	ldr	r3, [r7, #8]
 8004b9e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004ba2:	2b00      	cmp	r3, #0
 8004ba4:	d001      	beq.n	8004baa <OsEventParamCheck+0x2e>
        return LOS_ERRNO_EVENT_SETBIT_INVALID;
 8004ba6:	4b11      	ldr	r3, [pc, #68]	; (8004bec <OsEventParamCheck+0x70>)
 8004ba8:	e016      	b.n	8004bd8 <OsEventParamCheck+0x5c>
    }

    if (((mode & LOS_WAITMODE_OR) && (mode & LOS_WAITMODE_AND)) ||
 8004baa:	687b      	ldr	r3, [r7, #4]
 8004bac:	f003 0302 	and.w	r3, r3, #2
 8004bb0:	2b00      	cmp	r3, #0
 8004bb2:	d004      	beq.n	8004bbe <OsEventParamCheck+0x42>
 8004bb4:	687b      	ldr	r3, [r7, #4]
 8004bb6:	f003 0304 	and.w	r3, r3, #4
 8004bba:	2b00      	cmp	r3, #0
 8004bbc:	d109      	bne.n	8004bd2 <OsEventParamCheck+0x56>
        (mode & ~(LOS_WAITMODE_OR | LOS_WAITMODE_AND | LOS_WAITMODE_CLR)) ||
 8004bbe:	687b      	ldr	r3, [r7, #4]
 8004bc0:	f023 0307 	bic.w	r3, r3, #7
    if (((mode & LOS_WAITMODE_OR) && (mode & LOS_WAITMODE_AND)) ||
 8004bc4:	2b00      	cmp	r3, #0
 8004bc6:	d104      	bne.n	8004bd2 <OsEventParamCheck+0x56>
        !(mode & (LOS_WAITMODE_OR | LOS_WAITMODE_AND))) {
 8004bc8:	687b      	ldr	r3, [r7, #4]
 8004bca:	f003 0306 	and.w	r3, r3, #6
        (mode & ~(LOS_WAITMODE_OR | LOS_WAITMODE_AND | LOS_WAITMODE_CLR)) ||
 8004bce:	2b00      	cmp	r3, #0
 8004bd0:	d101      	bne.n	8004bd6 <OsEventParamCheck+0x5a>
        return LOS_ERRNO_EVENT_FLAGS_INVALID;
 8004bd2:	4b07      	ldr	r3, [pc, #28]	; (8004bf0 <OsEventParamCheck+0x74>)
 8004bd4:	e000      	b.n	8004bd8 <OsEventParamCheck+0x5c>
    }
    return LOS_OK;
 8004bd6:	2300      	movs	r3, #0
}
 8004bd8:	4618      	mov	r0, r3
 8004bda:	3714      	adds	r7, #20
 8004bdc:	46bd      	mov	sp, r7
 8004bde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004be2:	4770      	bx	lr
 8004be4:	02001c06 	.word	0x02001c06
 8004be8:	02001c02 	.word	0x02001c02
 8004bec:	02001c00 	.word	0x02001c00
 8004bf0:	02001c04 	.word	0x02001c04

08004bf4 <OsEventPoll>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventPoll(UINT32 *eventId, UINT32 eventMask, UINT32 mode)
{
 8004bf4:	b580      	push	{r7, lr}
 8004bf6:	b086      	sub	sp, #24
 8004bf8:	af00      	add	r7, sp, #0
 8004bfa:	60f8      	str	r0, [r7, #12]
 8004bfc:	60b9      	str	r1, [r7, #8]
 8004bfe:	607a      	str	r2, [r7, #4]
    UINT32 ret = 0;
 8004c00:	2300      	movs	r3, #0
 8004c02:	617b      	str	r3, [r7, #20]

    LOS_ASSERT(ArchIntLocked());
 8004c04:	f7ff fece 	bl	80049a4 <ArchIntLocked>
 8004c08:	4603      	mov	r3, r0
 8004c0a:	2b00      	cmp	r3, #0
 8004c0c:	d10b      	bne.n	8004c26 <OsEventPoll+0x32>
 8004c0e:	f7ff fed6 	bl	80049be <LOS_IntLock>
 8004c12:	4828      	ldr	r0, [pc, #160]	; (8004cb4 <OsEventPoll+0xc0>)
 8004c14:	f7ff fe54 	bl	80048c0 <dprintf>
 8004c18:	4b27      	ldr	r3, [pc, #156]	; (8004cb8 <OsEventPoll+0xc4>)
 8004c1a:	2255      	movs	r2, #85	; 0x55
 8004c1c:	4927      	ldr	r1, [pc, #156]	; (8004cbc <OsEventPoll+0xc8>)
 8004c1e:	4828      	ldr	r0, [pc, #160]	; (8004cc0 <OsEventPoll+0xcc>)
 8004c20:	f7ff fe4e 	bl	80048c0 <dprintf>
 8004c24:	e7fe      	b.n	8004c24 <OsEventPoll+0x30>
    LOS_ASSERT(LOS_SpinHeld(&g_taskSpin));
 8004c26:	4827      	ldr	r0, [pc, #156]	; (8004cc4 <OsEventPoll+0xd0>)
 8004c28:	f7ff ff3e 	bl	8004aa8 <LOS_SpinHeld>
 8004c2c:	4603      	mov	r3, r0
 8004c2e:	2b00      	cmp	r3, #0
 8004c30:	d10b      	bne.n	8004c4a <OsEventPoll+0x56>
 8004c32:	f7ff fec4 	bl	80049be <LOS_IntLock>
 8004c36:	481f      	ldr	r0, [pc, #124]	; (8004cb4 <OsEventPoll+0xc0>)
 8004c38:	f7ff fe42 	bl	80048c0 <dprintf>
 8004c3c:	4b1e      	ldr	r3, [pc, #120]	; (8004cb8 <OsEventPoll+0xc4>)
 8004c3e:	2256      	movs	r2, #86	; 0x56
 8004c40:	491e      	ldr	r1, [pc, #120]	; (8004cbc <OsEventPoll+0xc8>)
 8004c42:	481f      	ldr	r0, [pc, #124]	; (8004cc0 <OsEventPoll+0xcc>)
 8004c44:	f7ff fe3c 	bl	80048c0 <dprintf>
 8004c48:	e7fe      	b.n	8004c48 <OsEventPoll+0x54>

    if (mode & LOS_WAITMODE_OR) {
 8004c4a:	687b      	ldr	r3, [r7, #4]
 8004c4c:	f003 0302 	and.w	r3, r3, #2
 8004c50:	2b00      	cmp	r3, #0
 8004c52:	d00b      	beq.n	8004c6c <OsEventPoll+0x78>
        if ((*eventId & eventMask) != 0) {
 8004c54:	68fb      	ldr	r3, [r7, #12]
 8004c56:	681a      	ldr	r2, [r3, #0]
 8004c58:	68bb      	ldr	r3, [r7, #8]
 8004c5a:	4013      	ands	r3, r2
 8004c5c:	2b00      	cmp	r3, #0
 8004c5e:	d014      	beq.n	8004c8a <OsEventPoll+0x96>
            ret = *eventId & eventMask;
 8004c60:	68fb      	ldr	r3, [r7, #12]
 8004c62:	681b      	ldr	r3, [r3, #0]
 8004c64:	68ba      	ldr	r2, [r7, #8]
 8004c66:	4013      	ands	r3, r2
 8004c68:	617b      	str	r3, [r7, #20]
 8004c6a:	e00e      	b.n	8004c8a <OsEventPoll+0x96>
        }
    } else {
        if ((eventMask != 0) && (eventMask == (*eventId & eventMask))) {
 8004c6c:	68bb      	ldr	r3, [r7, #8]
 8004c6e:	2b00      	cmp	r3, #0
 8004c70:	d00b      	beq.n	8004c8a <OsEventPoll+0x96>
 8004c72:	68fb      	ldr	r3, [r7, #12]
 8004c74:	681a      	ldr	r2, [r3, #0]
 8004c76:	68bb      	ldr	r3, [r7, #8]
 8004c78:	4013      	ands	r3, r2
 8004c7a:	68ba      	ldr	r2, [r7, #8]
 8004c7c:	429a      	cmp	r2, r3
 8004c7e:	d104      	bne.n	8004c8a <OsEventPoll+0x96>
            ret = *eventId & eventMask;
 8004c80:	68fb      	ldr	r3, [r7, #12]
 8004c82:	681b      	ldr	r3, [r3, #0]
 8004c84:	68ba      	ldr	r2, [r7, #8]
 8004c86:	4013      	ands	r3, r2
 8004c88:	617b      	str	r3, [r7, #20]
        }
    }

    if (ret && (mode & LOS_WAITMODE_CLR)) {
 8004c8a:	697b      	ldr	r3, [r7, #20]
 8004c8c:	2b00      	cmp	r3, #0
 8004c8e:	d00b      	beq.n	8004ca8 <OsEventPoll+0xb4>
 8004c90:	687b      	ldr	r3, [r7, #4]
 8004c92:	f003 0301 	and.w	r3, r3, #1
 8004c96:	2b00      	cmp	r3, #0
 8004c98:	d006      	beq.n	8004ca8 <OsEventPoll+0xb4>
        *eventId = *eventId & ~ret;
 8004c9a:	68fb      	ldr	r3, [r7, #12]
 8004c9c:	681a      	ldr	r2, [r3, #0]
 8004c9e:	697b      	ldr	r3, [r7, #20]
 8004ca0:	43db      	mvns	r3, r3
 8004ca2:	401a      	ands	r2, r3
 8004ca4:	68fb      	ldr	r3, [r7, #12]
 8004ca6:	601a      	str	r2, [r3, #0]
    }

    return ret;
 8004ca8:	697b      	ldr	r3, [r7, #20]
}
 8004caa:	4618      	mov	r0, r3
 8004cac:	3718      	adds	r7, #24
 8004cae:	46bd      	mov	sp, r7
 8004cb0:	bd80      	pop	{r7, pc}
 8004cb2:	bf00      	nop
 8004cb4:	080202e4 	.word	0x080202e4
 8004cb8:	080232f4 	.word	0x080232f4
 8004cbc:	080202ec 	.word	0x080202ec
 8004cc0:	080202f8 	.word	0x080202f8
 8004cc4:	20000770 	.word	0x20000770

08004cc8 <OsEventReadCheck>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventReadCheck(const PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode)
{
 8004cc8:	b580      	push	{r7, lr}
 8004cca:	b086      	sub	sp, #24
 8004ccc:	af00      	add	r7, sp, #0
 8004cce:	60f8      	str	r0, [r7, #12]
 8004cd0:	60b9      	str	r1, [r7, #8]
 8004cd2:	607a      	str	r2, [r7, #4]
    UINT32 ret;
    LosTaskCB *runTask = NULL;
 8004cd4:	2300      	movs	r3, #0
 8004cd6:	613b      	str	r3, [r7, #16]

    ret = OsEventParamCheck(eventCB, eventMask, mode);
 8004cd8:	687a      	ldr	r2, [r7, #4]
 8004cda:	68b9      	ldr	r1, [r7, #8]
 8004cdc:	68f8      	ldr	r0, [r7, #12]
 8004cde:	f7ff ff4d 	bl	8004b7c <OsEventParamCheck>
 8004ce2:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 8004ce4:	697b      	ldr	r3, [r7, #20]
 8004ce6:	2b00      	cmp	r3, #0
 8004ce8:	d001      	beq.n	8004cee <OsEventReadCheck+0x26>
        return ret;
 8004cea:	697b      	ldr	r3, [r7, #20]
 8004cec:	e00a      	b.n	8004d04 <OsEventReadCheck+0x3c>
    }

    if (OS_INT_ACTIVE) {
 8004cee:	f7fd fcb7 	bl	8002660 <IntActive>
 8004cf2:	4603      	mov	r3, r0
 8004cf4:	2b00      	cmp	r3, #0
 8004cf6:	d001      	beq.n	8004cfc <OsEventReadCheck+0x34>
        return LOS_ERRNO_EVENT_READ_IN_INTERRUPT;
 8004cf8:	4b04      	ldr	r3, [pc, #16]	; (8004d0c <OsEventReadCheck+0x44>)
 8004cfa:	e003      	b.n	8004d04 <OsEventReadCheck+0x3c>
    }

    runTask = OsCurrTaskGet();
 8004cfc:	f7ff fedf 	bl	8004abe <OsCurrTaskGet>
 8004d00:	6138      	str	r0, [r7, #16]
    if (runTask->taskFlags & OS_TASK_FLAG_SYSTEM) {
        PRINT_DEBUG("Warning: DO NOT recommend to use LOS_EventRead or OsEventReadOnce in system tasks.\n");
    }
    return LOS_OK;
 8004d02:	2300      	movs	r3, #0
}
 8004d04:	4618      	mov	r0, r3
 8004d06:	3718      	adds	r7, #24
 8004d08:	46bd      	mov	sp, r7
 8004d0a:	bd80      	pop	{r7, pc}
 8004d0c:	02001c03 	.word	0x02001c03

08004d10 <OsEventReadImp>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventReadImp(PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode,
                                              UINT32 timeout, BOOL once, UINT32 *intSave)
{
 8004d10:	b580      	push	{r7, lr}
 8004d12:	b086      	sub	sp, #24
 8004d14:	af00      	add	r7, sp, #0
 8004d16:	60f8      	str	r0, [r7, #12]
 8004d18:	60b9      	str	r1, [r7, #8]
 8004d1a:	607a      	str	r2, [r7, #4]
 8004d1c:	603b      	str	r3, [r7, #0]
    UINT32 ret = 0;
 8004d1e:	2300      	movs	r3, #0
 8004d20:	613b      	str	r3, [r7, #16]
    LosTaskCB *runTask = OsCurrTaskGet();
 8004d22:	f7ff fecc 	bl	8004abe <OsCurrTaskGet>
 8004d26:	6178      	str	r0, [r7, #20]

    if (once == FALSE) {
 8004d28:	6a3b      	ldr	r3, [r7, #32]
 8004d2a:	2b00      	cmp	r3, #0
 8004d2c:	d106      	bne.n	8004d3c <OsEventReadImp+0x2c>
        ret = OsEventPoll(&eventCB->uwEventID, eventMask, mode);
 8004d2e:	68fb      	ldr	r3, [r7, #12]
 8004d30:	687a      	ldr	r2, [r7, #4]
 8004d32:	68b9      	ldr	r1, [r7, #8]
 8004d34:	4618      	mov	r0, r3
 8004d36:	f7ff ff5d 	bl	8004bf4 <OsEventPoll>
 8004d3a:	6138      	str	r0, [r7, #16]
    }

    if (ret == 0) {
 8004d3c:	693b      	ldr	r3, [r7, #16]
 8004d3e:	2b00      	cmp	r3, #0
 8004d40:	d13a      	bne.n	8004db8 <OsEventReadImp+0xa8>
        if (timeout == 0) {
 8004d42:	683b      	ldr	r3, [r7, #0]
 8004d44:	2b00      	cmp	r3, #0
 8004d46:	d101      	bne.n	8004d4c <OsEventReadImp+0x3c>
            return ret;
 8004d48:	693b      	ldr	r3, [r7, #16]
 8004d4a:	e036      	b.n	8004dba <OsEventReadImp+0xaa>
        }

        if (!OsPreemptableInSched()) {
 8004d4c:	f7ff fe66 	bl	8004a1c <OsPreemptableInSched>
 8004d50:	4603      	mov	r3, r0
 8004d52:	2b00      	cmp	r3, #0
 8004d54:	d101      	bne.n	8004d5a <OsEventReadImp+0x4a>
            return LOS_ERRNO_EVENT_READ_IN_LOCK;
 8004d56:	4b1b      	ldr	r3, [pc, #108]	; (8004dc4 <OsEventReadImp+0xb4>)
 8004d58:	e02f      	b.n	8004dba <OsEventReadImp+0xaa>
        }

        runTask->eventMask = eventMask;
 8004d5a:	697b      	ldr	r3, [r7, #20]
 8004d5c:	68ba      	ldr	r2, [r7, #8]
 8004d5e:	661a      	str	r2, [r3, #96]	; 0x60
        runTask->eventMode = mode;
 8004d60:	697b      	ldr	r3, [r7, #20]
 8004d62:	687a      	ldr	r2, [r7, #4]
 8004d64:	665a      	str	r2, [r3, #100]	; 0x64

        OsTaskWait(&eventCB->stEventList, OS_TASK_STATUS_PEND, timeout);
 8004d66:	68fb      	ldr	r3, [r7, #12]
 8004d68:	3304      	adds	r3, #4
 8004d6a:	683a      	ldr	r2, [r7, #0]
 8004d6c:	2108      	movs	r1, #8
 8004d6e:	4618      	mov	r0, r3
 8004d70:	f7ff f8f6 	bl	8003f60 <OsTaskWait>

        /*
         * it will immediately do the scheduling, so there's no need to release the
         * task spinlock. when this task's been rescheduled, it will be holding the spinlock.
         */
        OsSchedResched();
 8004d74:	f003 ff20 	bl	8008bb8 <OsSchedResched>

        SCHEDULER_UNLOCK(*intSave);
 8004d78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004d7a:	681b      	ldr	r3, [r3, #0]
 8004d7c:	4619      	mov	r1, r3
 8004d7e:	4812      	ldr	r0, [pc, #72]	; (8004dc8 <OsEventReadImp+0xb8>)
 8004d80:	f7ff fe86 	bl	8004a90 <LOS_SpinUnlockRestore>
        SCHEDULER_LOCK(*intSave);
 8004d84:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8004d86:	4810      	ldr	r0, [pc, #64]	; (8004dc8 <OsEventReadImp+0xb8>)
 8004d88:	f7ff fe74 	bl	8004a74 <LOS_SpinLockSave>

        if (runTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
 8004d8c:	697b      	ldr	r3, [r7, #20]
 8004d8e:	889b      	ldrh	r3, [r3, #4]
 8004d90:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8004d94:	2b00      	cmp	r3, #0
 8004d96:	d008      	beq.n	8004daa <OsEventReadImp+0x9a>
            runTask->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
 8004d98:	697b      	ldr	r3, [r7, #20]
 8004d9a:	889b      	ldrh	r3, [r3, #4]
 8004d9c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004da0:	b29a      	uxth	r2, r3
 8004da2:	697b      	ldr	r3, [r7, #20]
 8004da4:	809a      	strh	r2, [r3, #4]
            return LOS_ERRNO_EVENT_READ_TIMEOUT;
 8004da6:	4b09      	ldr	r3, [pc, #36]	; (8004dcc <OsEventReadImp+0xbc>)
 8004da8:	e007      	b.n	8004dba <OsEventReadImp+0xaa>
        }

        ret = OsEventPoll(&eventCB->uwEventID, eventMask, mode);
 8004daa:	68fb      	ldr	r3, [r7, #12]
 8004dac:	687a      	ldr	r2, [r7, #4]
 8004dae:	68b9      	ldr	r1, [r7, #8]
 8004db0:	4618      	mov	r0, r3
 8004db2:	f7ff ff1f 	bl	8004bf4 <OsEventPoll>
 8004db6:	6138      	str	r0, [r7, #16]
    }
    return ret;
 8004db8:	693b      	ldr	r3, [r7, #16]
}
 8004dba:	4618      	mov	r0, r3
 8004dbc:	3718      	adds	r7, #24
 8004dbe:	46bd      	mov	sp, r7
 8004dc0:	bd80      	pop	{r7, pc}
 8004dc2:	bf00      	nop
 8004dc4:	02001c05 	.word	0x02001c05
 8004dc8:	20000770 	.word	0x20000770
 8004dcc:	02001c01 	.word	0x02001c01

08004dd0 <OsEventRead>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventRead(PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode,
                                           UINT32 timeout, BOOL once)
{
 8004dd0:	b590      	push	{r4, r7, lr}
 8004dd2:	b091      	sub	sp, #68	; 0x44
 8004dd4:	af02      	add	r7, sp, #8
 8004dd6:	60f8      	str	r0, [r7, #12]
 8004dd8:	60b9      	str	r1, [r7, #8]
 8004dda:	607a      	str	r2, [r7, #4]
 8004ddc:	603b      	str	r3, [r7, #0]
 8004dde:	4b2e      	ldr	r3, [pc, #184]	; (8004e98 <OsEventRead+0xc8>)
 8004de0:	681b      	ldr	r3, [r3, #0]
 8004de2:	637b      	str	r3, [r7, #52]	; 0x34
 8004de4:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    UINT32 intSave;

    ret = OsEventReadCheck(eventCB, eventMask, mode);
 8004de8:	687a      	ldr	r2, [r7, #4]
 8004dea:	68b9      	ldr	r1, [r7, #8]
 8004dec:	68f8      	ldr	r0, [r7, #12]
 8004dee:	f7ff ff6b 	bl	8004cc8 <OsEventReadCheck>
 8004df2:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 8004df4:	697b      	ldr	r3, [r7, #20]
 8004df6:	2b00      	cmp	r3, #0
 8004df8:	d001      	beq.n	8004dfe <OsEventRead+0x2e>
        return ret;
 8004dfa:	697b      	ldr	r3, [r7, #20]
 8004dfc:	e040      	b.n	8004e80 <OsEventRead+0xb0>
    }

    LOS_TRACE(EVENT_READ, (UINTPTR)eventCB, eventCB->uwEventID, eventMask, mode, timeout);
 8004dfe:	2300      	movs	r3, #0
 8004e00:	61fb      	str	r3, [r7, #28]
 8004e02:	68fb      	ldr	r3, [r7, #12]
 8004e04:	623b      	str	r3, [r7, #32]
 8004e06:	68fb      	ldr	r3, [r7, #12]
 8004e08:	681b      	ldr	r3, [r3, #0]
 8004e0a:	627b      	str	r3, [r7, #36]	; 0x24
 8004e0c:	68bb      	ldr	r3, [r7, #8]
 8004e0e:	62bb      	str	r3, [r7, #40]	; 0x28
 8004e10:	687b      	ldr	r3, [r7, #4]
 8004e12:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004e14:	683b      	ldr	r3, [r7, #0]
 8004e16:	633b      	str	r3, [r7, #48]	; 0x30
 8004e18:	2306      	movs	r3, #6
 8004e1a:	61bb      	str	r3, [r7, #24]
 8004e1c:	69bb      	ldr	r3, [r7, #24]
 8004e1e:	2b01      	cmp	r3, #1
 8004e20:	d916      	bls.n	8004e50 <OsEventRead+0x80>
 8004e22:	4b1e      	ldr	r3, [pc, #120]	; (8004e9c <OsEventRead+0xcc>)
 8004e24:	681b      	ldr	r3, [r3, #0]
 8004e26:	2b00      	cmp	r3, #0
 8004e28:	d012      	beq.n	8004e50 <OsEventRead+0x80>
 8004e2a:	4b1c      	ldr	r3, [pc, #112]	; (8004e9c <OsEventRead+0xcc>)
 8004e2c:	681c      	ldr	r4, [r3, #0]
 8004e2e:	6a39      	ldr	r1, [r7, #32]
 8004e30:	69bb      	ldr	r3, [r7, #24]
 8004e32:	2b02      	cmp	r3, #2
 8004e34:	d904      	bls.n	8004e40 <OsEventRead+0x70>
 8004e36:	f107 031c 	add.w	r3, r7, #28
 8004e3a:	f103 0208 	add.w	r2, r3, #8
 8004e3e:	e000      	b.n	8004e42 <OsEventRead+0x72>
 8004e40:	2200      	movs	r2, #0
 8004e42:	69bb      	ldr	r3, [r7, #24]
 8004e44:	b29b      	uxth	r3, r3
 8004e46:	3b02      	subs	r3, #2
 8004e48:	b29b      	uxth	r3, r3
 8004e4a:	f240 4002 	movw	r0, #1026	; 0x402
 8004e4e:	47a0      	blx	r4

    SCHEDULER_LOCK(intSave);
 8004e50:	f107 0310 	add.w	r3, r7, #16
 8004e54:	4619      	mov	r1, r3
 8004e56:	4812      	ldr	r0, [pc, #72]	; (8004ea0 <OsEventRead+0xd0>)
 8004e58:	f7ff fe0c 	bl	8004a74 <LOS_SpinLockSave>
    ret = OsEventReadImp(eventCB, eventMask, mode, timeout, once, &intSave);
 8004e5c:	f107 0310 	add.w	r3, r7, #16
 8004e60:	9301      	str	r3, [sp, #4]
 8004e62:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004e64:	9300      	str	r3, [sp, #0]
 8004e66:	683b      	ldr	r3, [r7, #0]
 8004e68:	687a      	ldr	r2, [r7, #4]
 8004e6a:	68b9      	ldr	r1, [r7, #8]
 8004e6c:	68f8      	ldr	r0, [r7, #12]
 8004e6e:	f7ff ff4f 	bl	8004d10 <OsEventReadImp>
 8004e72:	6178      	str	r0, [r7, #20]
    SCHEDULER_UNLOCK(intSave);
 8004e74:	693b      	ldr	r3, [r7, #16]
 8004e76:	4619      	mov	r1, r3
 8004e78:	4809      	ldr	r0, [pc, #36]	; (8004ea0 <OsEventRead+0xd0>)
 8004e7a:	f7ff fe09 	bl	8004a90 <LOS_SpinUnlockRestore>
    return ret;
 8004e7e:	697b      	ldr	r3, [r7, #20]
}
 8004e80:	4a05      	ldr	r2, [pc, #20]	; (8004e98 <OsEventRead+0xc8>)
 8004e82:	6811      	ldr	r1, [r2, #0]
 8004e84:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004e86:	4051      	eors	r1, r2
 8004e88:	d001      	beq.n	8004e8e <OsEventRead+0xbe>
 8004e8a:	f7ff fba7 	bl	80045dc <__stack_chk_fail>
 8004e8e:	4618      	mov	r0, r3
 8004e90:	373c      	adds	r7, #60	; 0x3c
 8004e92:	46bd      	mov	sp, r7
 8004e94:	bd90      	pop	{r4, r7, pc}
 8004e96:	bf00      	nop
 8004e98:	08020314 	.word	0x08020314
 8004e9c:	20000768 	.word	0x20000768
 8004ea0:	20000770 	.word	0x20000770

08004ea4 <OsEventWrite>:

LITE_OS_SEC_TEXT STATIC UINT32 OsEventWrite(PEVENT_CB_S eventCB, UINT32 events, BOOL once)
{
 8004ea4:	b590      	push	{r4, r7, lr}
 8004ea6:	b08f      	sub	sp, #60	; 0x3c
 8004ea8:	af00      	add	r7, sp, #0
 8004eaa:	60f8      	str	r0, [r7, #12]
 8004eac:	60b9      	str	r1, [r7, #8]
 8004eae:	607a      	str	r2, [r7, #4]
 8004eb0:	4b50      	ldr	r3, [pc, #320]	; (8004ff4 <OsEventWrite+0x150>)
 8004eb2:	681b      	ldr	r3, [r3, #0]
 8004eb4:	637b      	str	r3, [r7, #52]	; 0x34
 8004eb6:	f04f 0300 	mov.w	r3, #0
    LosTaskCB *resumedTask = NULL;
 8004eba:	2300      	movs	r3, #0
 8004ebc:	61bb      	str	r3, [r7, #24]
    LosTaskCB *nextTask = NULL;
 8004ebe:	2300      	movs	r3, #0
 8004ec0:	61fb      	str	r3, [r7, #28]
    UINT32 intSave;
    UINT8 exitFlag = 0;
 8004ec2:	2300      	movs	r3, #0
 8004ec4:	74fb      	strb	r3, [r7, #19]

    if (eventCB == NULL) {
 8004ec6:	68fb      	ldr	r3, [r7, #12]
 8004ec8:	2b00      	cmp	r3, #0
 8004eca:	d101      	bne.n	8004ed0 <OsEventWrite+0x2c>
        return LOS_ERRNO_EVENT_PTR_NULL;
 8004ecc:	4b4a      	ldr	r3, [pc, #296]	; (8004ff8 <OsEventWrite+0x154>)
 8004ece:	e085      	b.n	8004fdc <OsEventWrite+0x138>
    }

    if (events & LOS_ERRTYPE_ERROR) {
 8004ed0:	68bb      	ldr	r3, [r7, #8]
 8004ed2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004ed6:	2b00      	cmp	r3, #0
 8004ed8:	d001      	beq.n	8004ede <OsEventWrite+0x3a>
        return LOS_ERRNO_EVENT_SETBIT_INVALID;
 8004eda:	4b48      	ldr	r3, [pc, #288]	; (8004ffc <OsEventWrite+0x158>)
 8004edc:	e07e      	b.n	8004fdc <OsEventWrite+0x138>
    }

    LOS_TRACE(EVENT_WRITE, (UINTPTR)eventCB, eventCB->uwEventID, events);
 8004ede:	2300      	movs	r3, #0
 8004ee0:	627b      	str	r3, [r7, #36]	; 0x24
 8004ee2:	68fb      	ldr	r3, [r7, #12]
 8004ee4:	62bb      	str	r3, [r7, #40]	; 0x28
 8004ee6:	68fb      	ldr	r3, [r7, #12]
 8004ee8:	681b      	ldr	r3, [r3, #0]
 8004eea:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004eec:	68bb      	ldr	r3, [r7, #8]
 8004eee:	633b      	str	r3, [r7, #48]	; 0x30
 8004ef0:	2304      	movs	r3, #4
 8004ef2:	623b      	str	r3, [r7, #32]
 8004ef4:	6a3b      	ldr	r3, [r7, #32]
 8004ef6:	2b01      	cmp	r3, #1
 8004ef8:	d916      	bls.n	8004f28 <OsEventWrite+0x84>
 8004efa:	4b41      	ldr	r3, [pc, #260]	; (8005000 <OsEventWrite+0x15c>)
 8004efc:	681b      	ldr	r3, [r3, #0]
 8004efe:	2b00      	cmp	r3, #0
 8004f00:	d012      	beq.n	8004f28 <OsEventWrite+0x84>
 8004f02:	4b3f      	ldr	r3, [pc, #252]	; (8005000 <OsEventWrite+0x15c>)
 8004f04:	681c      	ldr	r4, [r3, #0]
 8004f06:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8004f08:	6a3b      	ldr	r3, [r7, #32]
 8004f0a:	2b02      	cmp	r3, #2
 8004f0c:	d904      	bls.n	8004f18 <OsEventWrite+0x74>
 8004f0e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8004f12:	f103 0208 	add.w	r2, r3, #8
 8004f16:	e000      	b.n	8004f1a <OsEventWrite+0x76>
 8004f18:	2200      	movs	r2, #0
 8004f1a:	6a3b      	ldr	r3, [r7, #32]
 8004f1c:	b29b      	uxth	r3, r3
 8004f1e:	3b02      	subs	r3, #2
 8004f20:	b29b      	uxth	r3, r3
 8004f22:	f240 4003 	movw	r0, #1027	; 0x403
 8004f26:	47a0      	blx	r4

    SCHEDULER_LOCK(intSave);
 8004f28:	f107 0314 	add.w	r3, r7, #20
 8004f2c:	4619      	mov	r1, r3
 8004f2e:	4835      	ldr	r0, [pc, #212]	; (8005004 <OsEventWrite+0x160>)
 8004f30:	f7ff fda0 	bl	8004a74 <LOS_SpinLockSave>

    eventCB->uwEventID |= events;
 8004f34:	68fb      	ldr	r3, [r7, #12]
 8004f36:	681a      	ldr	r2, [r3, #0]
 8004f38:	68bb      	ldr	r3, [r7, #8]
 8004f3a:	431a      	orrs	r2, r3
 8004f3c:	68fb      	ldr	r3, [r7, #12]
 8004f3e:	601a      	str	r2, [r3, #0]
    if (!LOS_ListEmpty(&eventCB->stEventList)) {
 8004f40:	68fb      	ldr	r3, [r7, #12]
 8004f42:	3304      	adds	r3, #4
 8004f44:	4618      	mov	r0, r3
 8004f46:	f7ff fd13 	bl	8004970 <LOS_ListEmpty>
 8004f4a:	4603      	mov	r3, r0
 8004f4c:	2b00      	cmp	r3, #0
 8004f4e:	d137      	bne.n	8004fc0 <OsEventWrite+0x11c>
        for (resumedTask = LOS_DL_LIST_ENTRY((&eventCB->stEventList)->pstNext, LosTaskCB, pendList);
 8004f50:	68fb      	ldr	r3, [r7, #12]
 8004f52:	689b      	ldr	r3, [r3, #8]
 8004f54:	3b40      	subs	r3, #64	; 0x40
 8004f56:	61bb      	str	r3, [r7, #24]
 8004f58:	e029      	b.n	8004fae <OsEventWrite+0x10a>
             &resumedTask->pendList != &eventCB->stEventList;) {
            nextTask = LOS_DL_LIST_ENTRY(resumedTask->pendList.pstNext, LosTaskCB, pendList);
 8004f5a:	69bb      	ldr	r3, [r7, #24]
 8004f5c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004f5e:	3b40      	subs	r3, #64	; 0x40
 8004f60:	61fb      	str	r3, [r7, #28]
            if (((resumedTask->eventMode & LOS_WAITMODE_OR) && ((resumedTask->eventMask & events) != 0)) ||
 8004f62:	69bb      	ldr	r3, [r7, #24]
 8004f64:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004f66:	f003 0302 	and.w	r3, r3, #2
 8004f6a:	2b00      	cmp	r3, #0
 8004f6c:	d005      	beq.n	8004f7a <OsEventWrite+0xd6>
 8004f6e:	69bb      	ldr	r3, [r7, #24]
 8004f70:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8004f72:	68bb      	ldr	r3, [r7, #8]
 8004f74:	4013      	ands	r3, r2
 8004f76:	2b00      	cmp	r3, #0
 8004f78:	d10e      	bne.n	8004f98 <OsEventWrite+0xf4>
                ((resumedTask->eventMode & LOS_WAITMODE_AND) &&
 8004f7a:	69bb      	ldr	r3, [r7, #24]
 8004f7c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004f7e:	f003 0304 	and.w	r3, r3, #4
            if (((resumedTask->eventMode & LOS_WAITMODE_OR) && ((resumedTask->eventMask & events) != 0)) ||
 8004f82:	2b00      	cmp	r3, #0
 8004f84:	d00e      	beq.n	8004fa4 <OsEventWrite+0x100>
                 ((resumedTask->eventMask & eventCB->uwEventID) == resumedTask->eventMask))) {
 8004f86:	69bb      	ldr	r3, [r7, #24]
 8004f88:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8004f8a:	68fb      	ldr	r3, [r7, #12]
 8004f8c:	681b      	ldr	r3, [r3, #0]
 8004f8e:	401a      	ands	r2, r3
 8004f90:	69bb      	ldr	r3, [r7, #24]
 8004f92:	6e1b      	ldr	r3, [r3, #96]	; 0x60
                ((resumedTask->eventMode & LOS_WAITMODE_AND) &&
 8004f94:	429a      	cmp	r2, r3
 8004f96:	d105      	bne.n	8004fa4 <OsEventWrite+0x100>
                exitFlag = 1;
 8004f98:	2301      	movs	r3, #1
 8004f9a:	74fb      	strb	r3, [r7, #19]
                OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
 8004f9c:	2108      	movs	r1, #8
 8004f9e:	69b8      	ldr	r0, [r7, #24]
 8004fa0:	f7ff f814 	bl	8003fcc <OsTaskWake>
            }
            if (once == TRUE) {
 8004fa4:	687b      	ldr	r3, [r7, #4]
 8004fa6:	2b01      	cmp	r3, #1
 8004fa8:	d009      	beq.n	8004fbe <OsEventWrite+0x11a>
                break;
            }
            resumedTask = nextTask;
 8004faa:	69fb      	ldr	r3, [r7, #28]
 8004fac:	61bb      	str	r3, [r7, #24]
             &resumedTask->pendList != &eventCB->stEventList;) {
 8004fae:	69bb      	ldr	r3, [r7, #24]
 8004fb0:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8004fb4:	68fb      	ldr	r3, [r7, #12]
 8004fb6:	3304      	adds	r3, #4
        for (resumedTask = LOS_DL_LIST_ENTRY((&eventCB->stEventList)->pstNext, LosTaskCB, pendList);
 8004fb8:	429a      	cmp	r2, r3
 8004fba:	d1ce      	bne.n	8004f5a <OsEventWrite+0xb6>
 8004fbc:	e000      	b.n	8004fc0 <OsEventWrite+0x11c>
                break;
 8004fbe:	bf00      	nop
        }
    }

    SCHEDULER_UNLOCK(intSave);
 8004fc0:	697b      	ldr	r3, [r7, #20]
 8004fc2:	4619      	mov	r1, r3
 8004fc4:	480f      	ldr	r0, [pc, #60]	; (8005004 <OsEventWrite+0x160>)
 8004fc6:	f7ff fd63 	bl	8004a90 <LOS_SpinUnlockRestore>

    if (exitFlag == 1) {
 8004fca:	7cfb      	ldrb	r3, [r7, #19]
 8004fcc:	2b01      	cmp	r3, #1
 8004fce:	d104      	bne.n	8004fda <OsEventWrite+0x136>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 8004fd0:	2001      	movs	r0, #1
 8004fd2:	f7ff fd7b 	bl	8004acc <LOS_MpSchedule>
        LOS_Schedule();
 8004fd6:	f7ff fd3d 	bl	8004a54 <LOS_Schedule>
    }
    return LOS_OK;
 8004fda:	2300      	movs	r3, #0
}
 8004fdc:	4a05      	ldr	r2, [pc, #20]	; (8004ff4 <OsEventWrite+0x150>)
 8004fde:	6811      	ldr	r1, [r2, #0]
 8004fe0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004fe2:	4051      	eors	r1, r2
 8004fe4:	d001      	beq.n	8004fea <OsEventWrite+0x146>
 8004fe6:	f7ff faf9 	bl	80045dc <__stack_chk_fail>
 8004fea:	4618      	mov	r0, r3
 8004fec:	373c      	adds	r7, #60	; 0x3c
 8004fee:	46bd      	mov	sp, r7
 8004ff0:	bd90      	pop	{r4, r7, pc}
 8004ff2:	bf00      	nop
 8004ff4:	08020318 	.word	0x08020318
 8004ff8:	02001c06 	.word	0x02001c06
 8004ffc:	02001c00 	.word	0x02001c00
 8005000:	20000768 	.word	0x20000768
 8005004:	20000770 	.word	0x20000770

08005008 <LOS_EventRead>:
    SCHEDULER_UNLOCK(intSave);
    return ret;
}

LITE_OS_SEC_TEXT UINT32 LOS_EventRead(PEVENT_CB_S eventCB, UINT32 eventMask, UINT32 mode, UINT32 timeout)
{
 8005008:	b580      	push	{r7, lr}
 800500a:	b086      	sub	sp, #24
 800500c:	af02      	add	r7, sp, #8
 800500e:	60f8      	str	r0, [r7, #12]
 8005010:	60b9      	str	r1, [r7, #8]
 8005012:	607a      	str	r2, [r7, #4]
 8005014:	603b      	str	r3, [r7, #0]
    return OsEventRead(eventCB, eventMask, mode, timeout, FALSE);
 8005016:	2300      	movs	r3, #0
 8005018:	9300      	str	r3, [sp, #0]
 800501a:	683b      	ldr	r3, [r7, #0]
 800501c:	687a      	ldr	r2, [r7, #4]
 800501e:	68b9      	ldr	r1, [r7, #8]
 8005020:	68f8      	ldr	r0, [r7, #12]
 8005022:	f7ff fed5 	bl	8004dd0 <OsEventRead>
 8005026:	4603      	mov	r3, r0
}
 8005028:	4618      	mov	r0, r3
 800502a:	3710      	adds	r7, #16
 800502c:	46bd      	mov	sp, r7
 800502e:	bd80      	pop	{r7, pc}

08005030 <LOS_EventWrite>:

LITE_OS_SEC_TEXT UINT32 LOS_EventWrite(PEVENT_CB_S eventCB, UINT32 events)
{
 8005030:	b580      	push	{r7, lr}
 8005032:	b082      	sub	sp, #8
 8005034:	af00      	add	r7, sp, #0
 8005036:	6078      	str	r0, [r7, #4]
 8005038:	6039      	str	r1, [r7, #0]
    return OsEventWrite(eventCB, events, FALSE);
 800503a:	2200      	movs	r2, #0
 800503c:	6839      	ldr	r1, [r7, #0]
 800503e:	6878      	ldr	r0, [r7, #4]
 8005040:	f7ff ff30 	bl	8004ea4 <OsEventWrite>
 8005044:	4603      	mov	r3, r0
}
 8005046:	4618      	mov	r0, r3
 8005048:	3708      	adds	r7, #8
 800504a:	46bd      	mov	sp, r7
 800504c:	bd80      	pop	{r7, pc}
	...

08005050 <LOS_EventDestroy>:

LITE_OS_SEC_TEXT_INIT UINT32 LOS_EventDestroy(PEVENT_CB_S eventCB)
{
 8005050:	b590      	push	{r4, r7, lr}
 8005052:	b08b      	sub	sp, #44	; 0x2c
 8005054:	af00      	add	r7, sp, #0
 8005056:	6078      	str	r0, [r7, #4]
 8005058:	4b29      	ldr	r3, [pc, #164]	; (8005100 <LOS_EventDestroy+0xb0>)
 800505a:	681b      	ldr	r3, [r3, #0]
 800505c:	627b      	str	r3, [r7, #36]	; 0x24
 800505e:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 ret = LOS_OK;
 8005062:	2300      	movs	r3, #0
 8005064:	613b      	str	r3, [r7, #16]

    if (eventCB == NULL) {
 8005066:	687b      	ldr	r3, [r7, #4]
 8005068:	2b00      	cmp	r3, #0
 800506a:	d101      	bne.n	8005070 <LOS_EventDestroy+0x20>
        return LOS_ERRNO_EVENT_PTR_NULL;
 800506c:	4b25      	ldr	r3, [pc, #148]	; (8005104 <LOS_EventDestroy+0xb4>)
 800506e:	e03b      	b.n	80050e8 <LOS_EventDestroy+0x98>
    }

    SCHEDULER_LOCK(intSave);
 8005070:	f107 030c 	add.w	r3, r7, #12
 8005074:	4619      	mov	r1, r3
 8005076:	4824      	ldr	r0, [pc, #144]	; (8005108 <LOS_EventDestroy+0xb8>)
 8005078:	f7ff fcfc 	bl	8004a74 <LOS_SpinLockSave>
    if (!LOS_ListEmpty(&eventCB->stEventList)) {
 800507c:	687b      	ldr	r3, [r7, #4]
 800507e:	3304      	adds	r3, #4
 8005080:	4618      	mov	r0, r3
 8005082:	f7ff fc75 	bl	8004970 <LOS_ListEmpty>
 8005086:	4603      	mov	r3, r0
 8005088:	2b00      	cmp	r3, #0
 800508a:	d102      	bne.n	8005092 <LOS_EventDestroy+0x42>
        ret = LOS_ERRNO_EVENT_SHOULD_NOT_DESTORY;
 800508c:	4b1f      	ldr	r3, [pc, #124]	; (800510c <LOS_EventDestroy+0xbc>)
 800508e:	613b      	str	r3, [r7, #16]
        goto OUT;
 8005090:	e002      	b.n	8005098 <LOS_EventDestroy+0x48>
    }

    eventCB->uwEventID = 0;
 8005092:	687b      	ldr	r3, [r7, #4]
 8005094:	2200      	movs	r2, #0
 8005096:	601a      	str	r2, [r3, #0]
OUT:
    SCHEDULER_UNLOCK(intSave);
 8005098:	68fb      	ldr	r3, [r7, #12]
 800509a:	4619      	mov	r1, r3
 800509c:	481a      	ldr	r0, [pc, #104]	; (8005108 <LOS_EventDestroy+0xb8>)
 800509e:	f7ff fcf7 	bl	8004a90 <LOS_SpinUnlockRestore>

    LOS_TRACE(EVENT_DELETE, (UINTPTR)eventCB, ret);
 80050a2:	2300      	movs	r3, #0
 80050a4:	61bb      	str	r3, [r7, #24]
 80050a6:	687b      	ldr	r3, [r7, #4]
 80050a8:	61fb      	str	r3, [r7, #28]
 80050aa:	693b      	ldr	r3, [r7, #16]
 80050ac:	623b      	str	r3, [r7, #32]
 80050ae:	2303      	movs	r3, #3
 80050b0:	617b      	str	r3, [r7, #20]
 80050b2:	697b      	ldr	r3, [r7, #20]
 80050b4:	2b01      	cmp	r3, #1
 80050b6:	d916      	bls.n	80050e6 <LOS_EventDestroy+0x96>
 80050b8:	4b15      	ldr	r3, [pc, #84]	; (8005110 <LOS_EventDestroy+0xc0>)
 80050ba:	681b      	ldr	r3, [r3, #0]
 80050bc:	2b00      	cmp	r3, #0
 80050be:	d012      	beq.n	80050e6 <LOS_EventDestroy+0x96>
 80050c0:	4b13      	ldr	r3, [pc, #76]	; (8005110 <LOS_EventDestroy+0xc0>)
 80050c2:	681c      	ldr	r4, [r3, #0]
 80050c4:	69f9      	ldr	r1, [r7, #28]
 80050c6:	697b      	ldr	r3, [r7, #20]
 80050c8:	2b02      	cmp	r3, #2
 80050ca:	d904      	bls.n	80050d6 <LOS_EventDestroy+0x86>
 80050cc:	f107 0318 	add.w	r3, r7, #24
 80050d0:	f103 0208 	add.w	r2, r3, #8
 80050d4:	e000      	b.n	80050d8 <LOS_EventDestroy+0x88>
 80050d6:	2200      	movs	r2, #0
 80050d8:	697b      	ldr	r3, [r7, #20]
 80050da:	b29b      	uxth	r3, r3
 80050dc:	3b02      	subs	r3, #2
 80050de:	b29b      	uxth	r3, r3
 80050e0:	f240 4001 	movw	r0, #1025	; 0x401
 80050e4:	47a0      	blx	r4
    return ret;
 80050e6:	693b      	ldr	r3, [r7, #16]
}
 80050e8:	4a05      	ldr	r2, [pc, #20]	; (8005100 <LOS_EventDestroy+0xb0>)
 80050ea:	6811      	ldr	r1, [r2, #0]
 80050ec:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80050ee:	4051      	eors	r1, r2
 80050f0:	d001      	beq.n	80050f6 <LOS_EventDestroy+0xa6>
 80050f2:	f7ff fa73 	bl	80045dc <__stack_chk_fail>
 80050f6:	4618      	mov	r0, r3
 80050f8:	372c      	adds	r7, #44	; 0x2c
 80050fa:	46bd      	mov	sp, r7
 80050fc:	bd90      	pop	{r4, r7, pc}
 80050fe:	bf00      	nop
 8005100:	08020320 	.word	0x08020320
 8005104:	02001c06 	.word	0x02001c06
 8005108:	20000770 	.word	0x20000770
 800510c:	02001c08 	.word	0x02001c08
 8005110:	20000768 	.word	0x20000768

08005114 <LOS_EventClear>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_EventClear(PEVENT_CB_S eventCB, UINT32 events)
{
 8005114:	b590      	push	{r4, r7, lr}
 8005116:	b08b      	sub	sp, #44	; 0x2c
 8005118:	af00      	add	r7, sp, #0
 800511a:	6078      	str	r0, [r7, #4]
 800511c:	6039      	str	r1, [r7, #0]
 800511e:	4b26      	ldr	r3, [pc, #152]	; (80051b8 <LOS_EventClear+0xa4>)
 8005120:	681b      	ldr	r3, [r3, #0]
 8005122:	627b      	str	r3, [r7, #36]	; 0x24
 8005124:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    if (eventCB == NULL) {
 8005128:	687b      	ldr	r3, [r7, #4]
 800512a:	2b00      	cmp	r3, #0
 800512c:	d101      	bne.n	8005132 <LOS_EventClear+0x1e>
        return LOS_ERRNO_EVENT_PTR_NULL;
 800512e:	4b23      	ldr	r3, [pc, #140]	; (80051bc <LOS_EventClear+0xa8>)
 8005130:	e036      	b.n	80051a0 <LOS_EventClear+0x8c>
    }

    LOS_TRACE(EVENT_CLEAR, (UINTPTR)eventCB, eventCB->uwEventID, events);
 8005132:	2300      	movs	r3, #0
 8005134:	617b      	str	r3, [r7, #20]
 8005136:	687b      	ldr	r3, [r7, #4]
 8005138:	61bb      	str	r3, [r7, #24]
 800513a:	687b      	ldr	r3, [r7, #4]
 800513c:	681b      	ldr	r3, [r3, #0]
 800513e:	61fb      	str	r3, [r7, #28]
 8005140:	683b      	ldr	r3, [r7, #0]
 8005142:	623b      	str	r3, [r7, #32]
 8005144:	2304      	movs	r3, #4
 8005146:	613b      	str	r3, [r7, #16]
 8005148:	693b      	ldr	r3, [r7, #16]
 800514a:	2b01      	cmp	r3, #1
 800514c:	d916      	bls.n	800517c <LOS_EventClear+0x68>
 800514e:	4b1c      	ldr	r3, [pc, #112]	; (80051c0 <LOS_EventClear+0xac>)
 8005150:	681b      	ldr	r3, [r3, #0]
 8005152:	2b00      	cmp	r3, #0
 8005154:	d012      	beq.n	800517c <LOS_EventClear+0x68>
 8005156:	4b1a      	ldr	r3, [pc, #104]	; (80051c0 <LOS_EventClear+0xac>)
 8005158:	681c      	ldr	r4, [r3, #0]
 800515a:	69b9      	ldr	r1, [r7, #24]
 800515c:	693b      	ldr	r3, [r7, #16]
 800515e:	2b02      	cmp	r3, #2
 8005160:	d904      	bls.n	800516c <LOS_EventClear+0x58>
 8005162:	f107 0314 	add.w	r3, r7, #20
 8005166:	f103 0208 	add.w	r2, r3, #8
 800516a:	e000      	b.n	800516e <LOS_EventClear+0x5a>
 800516c:	2200      	movs	r2, #0
 800516e:	693b      	ldr	r3, [r7, #16]
 8005170:	b29b      	uxth	r3, r3
 8005172:	3b02      	subs	r3, #2
 8005174:	b29b      	uxth	r3, r3
 8005176:	f240 4004 	movw	r0, #1028	; 0x404
 800517a:	47a0      	blx	r4

    SCHEDULER_LOCK(intSave);
 800517c:	f107 030c 	add.w	r3, r7, #12
 8005180:	4619      	mov	r1, r3
 8005182:	4810      	ldr	r0, [pc, #64]	; (80051c4 <LOS_EventClear+0xb0>)
 8005184:	f7ff fc76 	bl	8004a74 <LOS_SpinLockSave>
    eventCB->uwEventID &= events;
 8005188:	687b      	ldr	r3, [r7, #4]
 800518a:	681a      	ldr	r2, [r3, #0]
 800518c:	683b      	ldr	r3, [r7, #0]
 800518e:	401a      	ands	r2, r3
 8005190:	687b      	ldr	r3, [r7, #4]
 8005192:	601a      	str	r2, [r3, #0]
    SCHEDULER_UNLOCK(intSave);
 8005194:	68fb      	ldr	r3, [r7, #12]
 8005196:	4619      	mov	r1, r3
 8005198:	480a      	ldr	r0, [pc, #40]	; (80051c4 <LOS_EventClear+0xb0>)
 800519a:	f7ff fc79 	bl	8004a90 <LOS_SpinUnlockRestore>

    return LOS_OK;
 800519e:	2300      	movs	r3, #0
}
 80051a0:	4a05      	ldr	r2, [pc, #20]	; (80051b8 <LOS_EventClear+0xa4>)
 80051a2:	6811      	ldr	r1, [r2, #0]
 80051a4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80051a6:	4051      	eors	r1, r2
 80051a8:	d001      	beq.n	80051ae <LOS_EventClear+0x9a>
 80051aa:	f7ff fa17 	bl	80045dc <__stack_chk_fail>
 80051ae:	4618      	mov	r0, r3
 80051b0:	372c      	adds	r7, #44	; 0x2c
 80051b2:	46bd      	mov	sp, r7
 80051b4:	bd90      	pop	{r4, r7, pc}
 80051b6:	bf00      	nop
 80051b8:	08020324 	.word	0x08020324
 80051bc:	02001c06 	.word	0x02001c06
 80051c0:	20000768 	.word	0x20000768
 80051c4:	20000770 	.word	0x20000770

080051c8 <LOS_ListInit>:
{
 80051c8:	b480      	push	{r7}
 80051ca:	b083      	sub	sp, #12
 80051cc:	af00      	add	r7, sp, #0
 80051ce:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 80051d0:	687b      	ldr	r3, [r7, #4]
 80051d2:	687a      	ldr	r2, [r7, #4]
 80051d4:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 80051d6:	687b      	ldr	r3, [r7, #4]
 80051d8:	687a      	ldr	r2, [r7, #4]
 80051da:	601a      	str	r2, [r3, #0]
}
 80051dc:	bf00      	nop
 80051de:	370c      	adds	r7, #12
 80051e0:	46bd      	mov	sp, r7
 80051e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80051e6:	4770      	bx	lr

080051e8 <LOS_ListAdd>:
{
 80051e8:	b480      	push	{r7}
 80051ea:	b083      	sub	sp, #12
 80051ec:	af00      	add	r7, sp, #0
 80051ee:	6078      	str	r0, [r7, #4]
 80051f0:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 80051f2:	687b      	ldr	r3, [r7, #4]
 80051f4:	685a      	ldr	r2, [r3, #4]
 80051f6:	683b      	ldr	r3, [r7, #0]
 80051f8:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 80051fa:	683b      	ldr	r3, [r7, #0]
 80051fc:	687a      	ldr	r2, [r7, #4]
 80051fe:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8005200:	687b      	ldr	r3, [r7, #4]
 8005202:	685b      	ldr	r3, [r3, #4]
 8005204:	683a      	ldr	r2, [r7, #0]
 8005206:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 8005208:	687b      	ldr	r3, [r7, #4]
 800520a:	683a      	ldr	r2, [r7, #0]
 800520c:	605a      	str	r2, [r3, #4]
}
 800520e:	bf00      	nop
 8005210:	370c      	adds	r7, #12
 8005212:	46bd      	mov	sp, r7
 8005214:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005218:	4770      	bx	lr

0800521a <LOS_ListTailInsert>:
{
 800521a:	b580      	push	{r7, lr}
 800521c:	b082      	sub	sp, #8
 800521e:	af00      	add	r7, sp, #0
 8005220:	6078      	str	r0, [r7, #4]
 8005222:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 8005224:	687b      	ldr	r3, [r7, #4]
 8005226:	681b      	ldr	r3, [r3, #0]
 8005228:	6839      	ldr	r1, [r7, #0]
 800522a:	4618      	mov	r0, r3
 800522c:	f7ff ffdc 	bl	80051e8 <LOS_ListAdd>
}
 8005230:	bf00      	nop
 8005232:	3708      	adds	r7, #8
 8005234:	46bd      	mov	sp, r7
 8005236:	bd80      	pop	{r7, pc}

08005238 <LOS_ListEmpty>:
{
 8005238:	b480      	push	{r7}
 800523a:	b083      	sub	sp, #12
 800523c:	af00      	add	r7, sp, #0
 800523e:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8005240:	687b      	ldr	r3, [r7, #4]
 8005242:	685b      	ldr	r3, [r3, #4]
 8005244:	687a      	ldr	r2, [r7, #4]
 8005246:	429a      	cmp	r2, r3
 8005248:	bf0c      	ite	eq
 800524a:	2301      	moveq	r3, #1
 800524c:	2300      	movne	r3, #0
 800524e:	b2db      	uxtb	r3, r3
}
 8005250:	4618      	mov	r0, r3
 8005252:	370c      	adds	r7, #12
 8005254:	46bd      	mov	sp, r7
 8005256:	f85d 7b04 	ldr.w	r7, [sp], #4
 800525a:	4770      	bx	lr

0800525c <ArchCurrCpuid>:
{
 800525c:	b480      	push	{r7}
 800525e:	af00      	add	r7, sp, #0
    return 0;
 8005260:	2300      	movs	r3, #0
}
 8005262:	4618      	mov	r0, r3
 8005264:	46bd      	mov	sp, r7
 8005266:	f85d 7b04 	ldr.w	r7, [sp], #4
 800526a:	4770      	bx	lr

0800526c <LOS_IntLock>:
{
 800526c:	b580      	push	{r7, lr}
 800526e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8005270:	f7fb fd2a 	bl	8000cc8 <ArchIntLock>
 8005274:	4603      	mov	r3, r0
}
 8005276:	4618      	mov	r0, r3
 8005278:	bd80      	pop	{r7, pc}

0800527a <LOS_IntRestore>:
{
 800527a:	b580      	push	{r7, lr}
 800527c:	b082      	sub	sp, #8
 800527e:	af00      	add	r7, sp, #0
 8005280:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8005282:	6878      	ldr	r0, [r7, #4]
 8005284:	f7fb fd28 	bl	8000cd8 <ArchIntRestore>
}
 8005288:	bf00      	nop
 800528a:	3708      	adds	r7, #8
 800528c:	46bd      	mov	sp, r7
 800528e:	bd80      	pop	{r7, pc}

08005290 <OsSemDbgInitHook>:
#endif /* __cplusplus */

/* semaphore debug initialization interface */
extern UINT32 OsSemDbgInit(VOID);
STATIC INLINE UINT32 OsSemDbgInitHook(VOID)
{
 8005290:	b580      	push	{r7, lr}
 8005292:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_SEMAPHORE
    return OsSemDbgInit();
 8005294:	f001 fe9a 	bl	8006fcc <OsSemDbgInit>
 8005298:	4603      	mov	r3, r0
#else
    return LOS_OK;
#endif
}
 800529a:	4618      	mov	r0, r3
 800529c:	bd80      	pop	{r7, pc}

0800529e <OsSemDbgTimeUpdateHook>:
/* Update the last time the semaphore was executed */
extern VOID OsSemDbgTimeUpdate(UINT32 semId);
STATIC INLINE VOID OsSemDbgTimeUpdateHook(UINT32 semId)
{
 800529e:	b580      	push	{r7, lr}
 80052a0:	b082      	sub	sp, #8
 80052a2:	af00      	add	r7, sp, #0
 80052a4:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_DEBUG_SEMAPHORE
    OsSemDbgTimeUpdate(semId);
 80052a6:	6878      	ldr	r0, [r7, #4]
 80052a8:	f001 fec2 	bl	8007030 <OsSemDbgTimeUpdate>
#endif
    return;
 80052ac:	bf00      	nop
}
 80052ae:	3708      	adds	r7, #8
 80052b0:	46bd      	mov	sp, r7
 80052b2:	bd80      	pop	{r7, pc}

080052b4 <OsPercpuGet>:
{
 80052b4:	b580      	push	{r7, lr}
 80052b6:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 80052b8:	f7ff ffd0 	bl	800525c <ArchCurrCpuid>
 80052bc:	4602      	mov	r2, r0
 80052be:	4613      	mov	r3, r2
 80052c0:	00db      	lsls	r3, r3, #3
 80052c2:	4413      	add	r3, r2
 80052c4:	009b      	lsls	r3, r3, #2
 80052c6:	4a02      	ldr	r2, [pc, #8]	; (80052d0 <OsPercpuGet+0x1c>)
 80052c8:	4413      	add	r3, r2
}
 80052ca:	4618      	mov	r0, r3
 80052cc:	bd80      	pop	{r7, pc}
 80052ce:	bf00      	nop
 80052d0:	200036fc 	.word	0x200036fc

080052d4 <LOS_Schedule>:
{
 80052d4:	b580      	push	{r7, lr}
 80052d6:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 80052d8:	f7fd f9c2 	bl	8002660 <IntActive>
 80052dc:	4603      	mov	r3, r0
 80052de:	2b00      	cmp	r3, #0
 80052e0:	d005      	beq.n	80052ee <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 80052e2:	f7ff ffe7 	bl	80052b4 <OsPercpuGet>
 80052e6:	4603      	mov	r3, r0
 80052e8:	2201      	movs	r2, #1
 80052ea:	621a      	str	r2, [r3, #32]
        return;
 80052ec:	e001      	b.n	80052f2 <LOS_Schedule+0x1e>
    OsSchedPreempt();
 80052ee:	f003 fd21 	bl	8008d34 <OsSchedPreempt>
}
 80052f2:	bd80      	pop	{r7, pc}

080052f4 <LOS_SpinLockSave>:
{
 80052f4:	b580      	push	{r7, lr}
 80052f6:	b082      	sub	sp, #8
 80052f8:	af00      	add	r7, sp, #0
 80052fa:	6078      	str	r0, [r7, #4]
 80052fc:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 80052fe:	f7ff ffb5 	bl	800526c <LOS_IntLock>
 8005302:	4602      	mov	r2, r0
 8005304:	683b      	ldr	r3, [r7, #0]
 8005306:	601a      	str	r2, [r3, #0]
}
 8005308:	bf00      	nop
 800530a:	3708      	adds	r7, #8
 800530c:	46bd      	mov	sp, r7
 800530e:	bd80      	pop	{r7, pc}

08005310 <LOS_SpinUnlockRestore>:
{
 8005310:	b580      	push	{r7, lr}
 8005312:	b082      	sub	sp, #8
 8005314:	af00      	add	r7, sp, #0
 8005316:	6078      	str	r0, [r7, #4]
 8005318:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 800531a:	6838      	ldr	r0, [r7, #0]
 800531c:	f7ff ffad 	bl	800527a <LOS_IntRestore>
}
 8005320:	bf00      	nop
 8005322:	3708      	adds	r7, #8
 8005324:	46bd      	mov	sp, r7
 8005326:	bd80      	pop	{r7, pc}

08005328 <LOS_MpSchedule>:
{
 8005328:	b480      	push	{r7}
 800532a:	b083      	sub	sp, #12
 800532c:	af00      	add	r7, sp, #0
 800532e:	6078      	str	r0, [r7, #4]
}
 8005330:	bf00      	nop
 8005332:	370c      	adds	r7, #12
 8005334:	46bd      	mov	sp, r7
 8005336:	f85d 7b04 	ldr.w	r7, [sp], #4
 800533a:	4770      	bx	lr

0800533c <OsSemNodeRecycle>:

LITE_OS_SEC_DATA_INIT STATIC LOS_DL_LIST g_unusedSemList;
LITE_OS_SEC_BSS LosSemCB *g_allSem = NULL;

STATIC_INLINE VOID OsSemNodeRecycle(LosSemCB *semNode)
{
 800533c:	b580      	push	{r7, lr}
 800533e:	b082      	sub	sp, #8
 8005340:	af00      	add	r7, sp, #0
 8005342:	6078      	str	r0, [r7, #4]
    semNode->semStat = LOS_UNUSED;
 8005344:	687b      	ldr	r3, [r7, #4]
 8005346:	2200      	movs	r2, #0
 8005348:	701a      	strb	r2, [r3, #0]
    LOS_ListTailInsert(&g_unusedSemList, &semNode->semList);
 800534a:	687b      	ldr	r3, [r7, #4]
 800534c:	3308      	adds	r3, #8
 800534e:	4619      	mov	r1, r3
 8005350:	4803      	ldr	r0, [pc, #12]	; (8005360 <OsSemNodeRecycle+0x24>)
 8005352:	f7ff ff62 	bl	800521a <LOS_ListTailInsert>
}
 8005356:	bf00      	nop
 8005358:	3708      	adds	r7, #8
 800535a:	46bd      	mov	sp, r7
 800535c:	bd80      	pop	{r7, pc}
 800535e:	bf00      	nop
 8005360:	20000790 	.word	0x20000790

08005364 <OsSemInit>:

LITE_OS_SEC_TEXT_INIT UINT32 OsSemInit(VOID)
{
 8005364:	b580      	push	{r7, lr}
 8005366:	b082      	sub	sp, #8
 8005368:	af00      	add	r7, sp, #0
    LosSemCB *semNode = NULL;
 800536a:	2300      	movs	r3, #0
 800536c:	607b      	str	r3, [r7, #4]
    UINT16 index; // support at most 65536 semaphores

    /* system resident memory, don't free */
    g_allSem = (LosSemCB *)LOS_MemAlloc(m_aucSysMem0, (KERNEL_SEM_LIMIT * sizeof(LosSemCB)));
 800536e:	4b1a      	ldr	r3, [pc, #104]	; (80053d8 <OsSemInit+0x74>)
 8005370:	681b      	ldr	r3, [r3, #0]
 8005372:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8005376:	4618      	mov	r0, r3
 8005378:	f004 f84c 	bl	8009414 <LOS_MemAlloc>
 800537c:	4603      	mov	r3, r0
 800537e:	4a17      	ldr	r2, [pc, #92]	; (80053dc <OsSemInit+0x78>)
 8005380:	6013      	str	r3, [r2, #0]
    if (g_allSem == NULL) {
 8005382:	4b16      	ldr	r3, [pc, #88]	; (80053dc <OsSemInit+0x78>)
 8005384:	681b      	ldr	r3, [r3, #0]
 8005386:	2b00      	cmp	r3, #0
 8005388:	d101      	bne.n	800538e <OsSemInit+0x2a>
        return LOS_ERRNO_SEM_NO_MEMORY;
 800538a:	4b15      	ldr	r3, [pc, #84]	; (80053e0 <OsSemInit+0x7c>)
 800538c:	e01f      	b.n	80053ce <OsSemInit+0x6a>
    }

    LOS_ListInit(&g_unusedSemList);
 800538e:	4815      	ldr	r0, [pc, #84]	; (80053e4 <OsSemInit+0x80>)
 8005390:	f7ff ff1a 	bl	80051c8 <LOS_ListInit>

    for (index = 0; index < KERNEL_SEM_LIMIT; index++) {
 8005394:	2300      	movs	r3, #0
 8005396:	807b      	strh	r3, [r7, #2]
 8005398:	e00e      	b.n	80053b8 <OsSemInit+0x54>
        semNode = ((LosSemCB *)g_allSem) + index;
 800539a:	4b10      	ldr	r3, [pc, #64]	; (80053dc <OsSemInit+0x78>)
 800539c:	681a      	ldr	r2, [r3, #0]
 800539e:	887b      	ldrh	r3, [r7, #2]
 80053a0:	011b      	lsls	r3, r3, #4
 80053a2:	4413      	add	r3, r2
 80053a4:	607b      	str	r3, [r7, #4]
        semNode->semId = (UINT32)index;
 80053a6:	887a      	ldrh	r2, [r7, #2]
 80053a8:	687b      	ldr	r3, [r7, #4]
 80053aa:	605a      	str	r2, [r3, #4]
        OsSemNodeRecycle(semNode);
 80053ac:	6878      	ldr	r0, [r7, #4]
 80053ae:	f7ff ffc5 	bl	800533c <OsSemNodeRecycle>
    for (index = 0; index < KERNEL_SEM_LIMIT; index++) {
 80053b2:	887b      	ldrh	r3, [r7, #2]
 80053b4:	3301      	adds	r3, #1
 80053b6:	807b      	strh	r3, [r7, #2]
 80053b8:	887b      	ldrh	r3, [r7, #2]
 80053ba:	2b13      	cmp	r3, #19
 80053bc:	d9ed      	bls.n	800539a <OsSemInit+0x36>
    }

    if (OsSemDbgInitHook() != LOS_OK) {
 80053be:	f7ff ff67 	bl	8005290 <OsSemDbgInitHook>
 80053c2:	4603      	mov	r3, r0
 80053c4:	2b00      	cmp	r3, #0
 80053c6:	d001      	beq.n	80053cc <OsSemInit+0x68>
        return LOS_ERRNO_SEM_NO_MEMORY;
 80053c8:	4b05      	ldr	r3, [pc, #20]	; (80053e0 <OsSemInit+0x7c>)
 80053ca:	e000      	b.n	80053ce <OsSemInit+0x6a>
    }
    return LOS_OK;
 80053cc:	2300      	movs	r3, #0
}
 80053ce:	4618      	mov	r0, r3
 80053d0:	3708      	adds	r7, #8
 80053d2:	46bd      	mov	sp, r7
 80053d4:	bd80      	pop	{r7, pc}
 80053d6:	bf00      	nop
 80053d8:	200021bc 	.word	0x200021bc
 80053dc:	20000798 	.word	0x20000798
 80053e0:	02000700 	.word	0x02000700
 80053e4:	20000790 	.word	0x20000790

080053e8 <OsSemStateVerify>:
    }
    return OsSemCreate(count, OS_SEM_BINARY, semHandle);
}

STATIC_INLINE UINT32 OsSemStateVerify(UINT32 semId, const LosSemCB *semNode)
{
 80053e8:	b480      	push	{r7}
 80053ea:	b083      	sub	sp, #12
 80053ec:	af00      	add	r7, sp, #0
 80053ee:	6078      	str	r0, [r7, #4]
 80053f0:	6039      	str	r1, [r7, #0]
#ifndef LOSCFG_RESOURCE_ID_NOT_USE_HIGH_BITS
    if ((semNode->semStat == LOS_UNUSED) || (semNode->semId != semId)) {
 80053f2:	683b      	ldr	r3, [r7, #0]
 80053f4:	781b      	ldrb	r3, [r3, #0]
 80053f6:	2b00      	cmp	r3, #0
 80053f8:	d004      	beq.n	8005404 <OsSemStateVerify+0x1c>
 80053fa:	683b      	ldr	r3, [r7, #0]
 80053fc:	685b      	ldr	r3, [r3, #4]
 80053fe:	687a      	ldr	r2, [r7, #4]
 8005400:	429a      	cmp	r2, r3
 8005402:	d001      	beq.n	8005408 <OsSemStateVerify+0x20>
#else
    if (semNode->semStat == LOS_UNUSED) {
#endif
        return LOS_ERRNO_SEM_INVALID;
 8005404:	4b04      	ldr	r3, [pc, #16]	; (8005418 <OsSemStateVerify+0x30>)
 8005406:	e000      	b.n	800540a <OsSemStateVerify+0x22>
    }
    return LOS_OK;
 8005408:	2300      	movs	r3, #0
}
 800540a:	4618      	mov	r0, r3
 800540c:	370c      	adds	r7, #12
 800540e:	46bd      	mov	sp, r7
 8005410:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005414:	4770      	bx	lr
 8005416:	bf00      	nop
 8005418:	02000701 	.word	0x02000701

0800541c <OsSemGetCBWithCheck>:

STATIC UINT32 OsSemGetCBWithCheck(UINT32 semHandle, LosSemCB **semCB)
{
 800541c:	b480      	push	{r7}
 800541e:	b083      	sub	sp, #12
 8005420:	af00      	add	r7, sp, #0
 8005422:	6078      	str	r0, [r7, #4]
 8005424:	6039      	str	r1, [r7, #0]
    if (GET_SEM_INDEX(semHandle) >= (UINT32)KERNEL_SEM_LIMIT) {
 8005426:	687b      	ldr	r3, [r7, #4]
 8005428:	b29b      	uxth	r3, r3
 800542a:	2b13      	cmp	r3, #19
 800542c:	d901      	bls.n	8005432 <OsSemGetCBWithCheck+0x16>
        return LOS_ERRNO_SEM_INVALID;
 800542e:	4b08      	ldr	r3, [pc, #32]	; (8005450 <OsSemGetCBWithCheck+0x34>)
 8005430:	e008      	b.n	8005444 <OsSemGetCBWithCheck+0x28>
    }

    *semCB = GET_SEM(semHandle);
 8005432:	4b08      	ldr	r3, [pc, #32]	; (8005454 <OsSemGetCBWithCheck+0x38>)
 8005434:	681a      	ldr	r2, [r3, #0]
 8005436:	687b      	ldr	r3, [r7, #4]
 8005438:	b29b      	uxth	r3, r3
 800543a:	011b      	lsls	r3, r3, #4
 800543c:	441a      	add	r2, r3
 800543e:	683b      	ldr	r3, [r7, #0]
 8005440:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 8005442:	2300      	movs	r3, #0
}
 8005444:	4618      	mov	r0, r3
 8005446:	370c      	adds	r7, #12
 8005448:	46bd      	mov	sp, r7
 800544a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800544e:	4770      	bx	lr
 8005450:	02000701 	.word	0x02000701
 8005454:	20000798 	.word	0x20000798

08005458 <LOS_SemPost>:
    SCHEDULER_UNLOCK(intSave);
    return ret;
}

LITE_OS_SEC_TEXT UINT32 LOS_SemPost(UINT32 semHandle)
{
 8005458:	b590      	push	{r4, r7, lr}
 800545a:	b08f      	sub	sp, #60	; 0x3c
 800545c:	af00      	add	r7, sp, #0
 800545e:	6078      	str	r0, [r7, #4]
 8005460:	4b4a      	ldr	r3, [pc, #296]	; (800558c <LOS_SemPost+0x134>)
 8005462:	681b      	ldr	r3, [r3, #0]
 8005464:	637b      	str	r3, [r7, #52]	; 0x34
 8005466:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosSemCB *semPosted = NULL;
 800546a:	2300      	movs	r3, #0
 800546c:	617b      	str	r3, [r7, #20]
    LosTaskCB *resumedTask = NULL;
 800546e:	2300      	movs	r3, #0
 8005470:	61fb      	str	r3, [r7, #28]
    UINT16 maxCount;
    UINT32 ret;

    ret = OsSemGetCBWithCheck(semHandle, &semPosted);
 8005472:	f107 0314 	add.w	r3, r7, #20
 8005476:	4619      	mov	r1, r3
 8005478:	6878      	ldr	r0, [r7, #4]
 800547a:	f7ff ffcf 	bl	800541c <OsSemGetCBWithCheck>
 800547e:	61b8      	str	r0, [r7, #24]
    if (ret != LOS_OK) {
 8005480:	69bb      	ldr	r3, [r7, #24]
 8005482:	2b00      	cmp	r3, #0
 8005484:	d001      	beq.n	800548a <LOS_SemPost+0x32>
        return ret;
 8005486:	69bb      	ldr	r3, [r7, #24]
 8005488:	e074      	b.n	8005574 <LOS_SemPost+0x11c>
    }

    LOS_TRACE(SEM_POST, semHandle, semPosted->semType, semPosted->semCount);
 800548a:	2300      	movs	r3, #0
 800548c:	627b      	str	r3, [r7, #36]	; 0x24
 800548e:	687b      	ldr	r3, [r7, #4]
 8005490:	62bb      	str	r3, [r7, #40]	; 0x28
 8005492:	697b      	ldr	r3, [r7, #20]
 8005494:	785b      	ldrb	r3, [r3, #1]
 8005496:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005498:	697b      	ldr	r3, [r7, #20]
 800549a:	885b      	ldrh	r3, [r3, #2]
 800549c:	633b      	str	r3, [r7, #48]	; 0x30
 800549e:	2304      	movs	r3, #4
 80054a0:	623b      	str	r3, [r7, #32]
 80054a2:	6a3b      	ldr	r3, [r7, #32]
 80054a4:	2b01      	cmp	r3, #1
 80054a6:	d916      	bls.n	80054d6 <LOS_SemPost+0x7e>
 80054a8:	4b39      	ldr	r3, [pc, #228]	; (8005590 <LOS_SemPost+0x138>)
 80054aa:	681b      	ldr	r3, [r3, #0]
 80054ac:	2b00      	cmp	r3, #0
 80054ae:	d012      	beq.n	80054d6 <LOS_SemPost+0x7e>
 80054b0:	4b37      	ldr	r3, [pc, #220]	; (8005590 <LOS_SemPost+0x138>)
 80054b2:	681c      	ldr	r4, [r3, #0]
 80054b4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80054b6:	6a3b      	ldr	r3, [r7, #32]
 80054b8:	2b02      	cmp	r3, #2
 80054ba:	d904      	bls.n	80054c6 <LOS_SemPost+0x6e>
 80054bc:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80054c0:	f103 0208 	add.w	r2, r3, #8
 80054c4:	e000      	b.n	80054c8 <LOS_SemPost+0x70>
 80054c6:	2200      	movs	r2, #0
 80054c8:	6a3b      	ldr	r3, [r7, #32]
 80054ca:	b29b      	uxth	r3, r3
 80054cc:	3b02      	subs	r3, #2
 80054ce:	b29b      	uxth	r3, r3
 80054d0:	f640 0003 	movw	r0, #2051	; 0x803
 80054d4:	47a0      	blx	r4

    SCHEDULER_LOCK(intSave);
 80054d6:	f107 0310 	add.w	r3, r7, #16
 80054da:	4619      	mov	r1, r3
 80054dc:	482d      	ldr	r0, [pc, #180]	; (8005594 <LOS_SemPost+0x13c>)
 80054de:	f7ff ff09 	bl	80052f4 <LOS_SpinLockSave>

    ret = OsSemStateVerify(semHandle, semPosted);
 80054e2:	697b      	ldr	r3, [r7, #20]
 80054e4:	4619      	mov	r1, r3
 80054e6:	6878      	ldr	r0, [r7, #4]
 80054e8:	f7ff ff7e 	bl	80053e8 <OsSemStateVerify>
 80054ec:	61b8      	str	r0, [r7, #24]
    if (ret != LOS_OK) {
 80054ee:	69bb      	ldr	r3, [r7, #24]
 80054f0:	2b00      	cmp	r3, #0
 80054f2:	d138      	bne.n	8005566 <LOS_SemPost+0x10e>
        goto OUT;
    }

    /* Update the operate time, no matter the actual Post success or not */
    OsSemDbgTimeUpdateHook(semHandle);
 80054f4:	6878      	ldr	r0, [r7, #4]
 80054f6:	f7ff fed2 	bl	800529e <OsSemDbgTimeUpdateHook>

    maxCount = (semPosted->semType == OS_SEM_COUNTING) ? LOS_SEM_COUNT_MAX : OS_SEM_BINARY_COUNT_MAX;
 80054fa:	697b      	ldr	r3, [r7, #20]
 80054fc:	785b      	ldrb	r3, [r3, #1]
 80054fe:	2b00      	cmp	r3, #0
 8005500:	d102      	bne.n	8005508 <LOS_SemPost+0xb0>
 8005502:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8005506:	e000      	b.n	800550a <LOS_SemPost+0xb2>
 8005508:	2301      	movs	r3, #1
 800550a:	81fb      	strh	r3, [r7, #14]
    if (semPosted->semCount >= maxCount) {
 800550c:	697b      	ldr	r3, [r7, #20]
 800550e:	885b      	ldrh	r3, [r3, #2]
 8005510:	89fa      	ldrh	r2, [r7, #14]
 8005512:	429a      	cmp	r2, r3
 8005514:	d802      	bhi.n	800551c <LOS_SemPost+0xc4>
        ret = LOS_ERRNO_SEM_OVERFLOW;
 8005516:	4b20      	ldr	r3, [pc, #128]	; (8005598 <LOS_SemPost+0x140>)
 8005518:	61bb      	str	r3, [r7, #24]
        goto OUT;
 800551a:	e025      	b.n	8005568 <LOS_SemPost+0x110>
    }
    if (!LOS_ListEmpty(&semPosted->semList)) {
 800551c:	697b      	ldr	r3, [r7, #20]
 800551e:	3308      	adds	r3, #8
 8005520:	4618      	mov	r0, r3
 8005522:	f7ff fe89 	bl	8005238 <LOS_ListEmpty>
 8005526:	4603      	mov	r3, r0
 8005528:	2b00      	cmp	r3, #0
 800552a:	d116      	bne.n	800555a <LOS_SemPost+0x102>
        resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&(semPosted->semList)));
 800552c:	697b      	ldr	r3, [r7, #20]
 800552e:	68db      	ldr	r3, [r3, #12]
 8005530:	3b40      	subs	r3, #64	; 0x40
 8005532:	61fb      	str	r3, [r7, #28]
        resumedTask->taskSem = NULL;
 8005534:	69fb      	ldr	r3, [r7, #28]
 8005536:	2200      	movs	r2, #0
 8005538:	61da      	str	r2, [r3, #28]
        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
 800553a:	2108      	movs	r1, #8
 800553c:	69f8      	ldr	r0, [r7, #28]
 800553e:	f7fe fd45 	bl	8003fcc <OsTaskWake>

        SCHEDULER_UNLOCK(intSave);
 8005542:	693b      	ldr	r3, [r7, #16]
 8005544:	4619      	mov	r1, r3
 8005546:	4813      	ldr	r0, [pc, #76]	; (8005594 <LOS_SemPost+0x13c>)
 8005548:	f7ff fee2 	bl	8005310 <LOS_SpinUnlockRestore>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 800554c:	2001      	movs	r0, #1
 800554e:	f7ff feeb 	bl	8005328 <LOS_MpSchedule>
        LOS_Schedule();
 8005552:	f7ff febf 	bl	80052d4 <LOS_Schedule>
        return LOS_OK;
 8005556:	2300      	movs	r3, #0
 8005558:	e00c      	b.n	8005574 <LOS_SemPost+0x11c>
    } else {
        semPosted->semCount++;
 800555a:	697b      	ldr	r3, [r7, #20]
 800555c:	885a      	ldrh	r2, [r3, #2]
 800555e:	3201      	adds	r2, #1
 8005560:	b292      	uxth	r2, r2
 8005562:	805a      	strh	r2, [r3, #2]
 8005564:	e000      	b.n	8005568 <LOS_SemPost+0x110>
        goto OUT;
 8005566:	bf00      	nop
    }

OUT:
    SCHEDULER_UNLOCK(intSave);
 8005568:	693b      	ldr	r3, [r7, #16]
 800556a:	4619      	mov	r1, r3
 800556c:	4809      	ldr	r0, [pc, #36]	; (8005594 <LOS_SemPost+0x13c>)
 800556e:	f7ff fecf 	bl	8005310 <LOS_SpinUnlockRestore>
    return ret;
 8005572:	69bb      	ldr	r3, [r7, #24]
}
 8005574:	4a05      	ldr	r2, [pc, #20]	; (800558c <LOS_SemPost+0x134>)
 8005576:	6811      	ldr	r1, [r2, #0]
 8005578:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800557a:	4051      	eors	r1, r2
 800557c:	d001      	beq.n	8005582 <LOS_SemPost+0x12a>
 800557e:	f7ff f82d 	bl	80045dc <__stack_chk_fail>
 8005582:	4618      	mov	r0, r3
 8005584:	373c      	adds	r7, #60	; 0x3c
 8005586:	46bd      	mov	sp, r7
 8005588:	bd90      	pop	{r4, r7, pc}
 800558a:	bf00      	nop
 800558c:	0802034c 	.word	0x0802034c
 8005590:	20000768 	.word	0x20000768
 8005594:	20000770 	.word	0x20000770
 8005598:	02000708 	.word	0x02000708

0800559c <LOS_ListInit>:
{
 800559c:	b480      	push	{r7}
 800559e:	b083      	sub	sp, #12
 80055a0:	af00      	add	r7, sp, #0
 80055a2:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 80055a4:	687b      	ldr	r3, [r7, #4]
 80055a6:	687a      	ldr	r2, [r7, #4]
 80055a8:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 80055aa:	687b      	ldr	r3, [r7, #4]
 80055ac:	687a      	ldr	r2, [r7, #4]
 80055ae:	601a      	str	r2, [r3, #0]
}
 80055b0:	bf00      	nop
 80055b2:	370c      	adds	r7, #12
 80055b4:	46bd      	mov	sp, r7
 80055b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80055ba:	4770      	bx	lr

080055bc <LOS_ListAdd>:
{
 80055bc:	b480      	push	{r7}
 80055be:	b083      	sub	sp, #12
 80055c0:	af00      	add	r7, sp, #0
 80055c2:	6078      	str	r0, [r7, #4]
 80055c4:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 80055c6:	687b      	ldr	r3, [r7, #4]
 80055c8:	685a      	ldr	r2, [r3, #4]
 80055ca:	683b      	ldr	r3, [r7, #0]
 80055cc:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 80055ce:	683b      	ldr	r3, [r7, #0]
 80055d0:	687a      	ldr	r2, [r7, #4]
 80055d2:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 80055d4:	687b      	ldr	r3, [r7, #4]
 80055d6:	685b      	ldr	r3, [r3, #4]
 80055d8:	683a      	ldr	r2, [r7, #0]
 80055da:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 80055dc:	687b      	ldr	r3, [r7, #4]
 80055de:	683a      	ldr	r2, [r7, #0]
 80055e0:	605a      	str	r2, [r3, #4]
}
 80055e2:	bf00      	nop
 80055e4:	370c      	adds	r7, #12
 80055e6:	46bd      	mov	sp, r7
 80055e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80055ec:	4770      	bx	lr

080055ee <LOS_ListTailInsert>:
{
 80055ee:	b580      	push	{r7, lr}
 80055f0:	b082      	sub	sp, #8
 80055f2:	af00      	add	r7, sp, #0
 80055f4:	6078      	str	r0, [r7, #4]
 80055f6:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 80055f8:	687b      	ldr	r3, [r7, #4]
 80055fa:	681b      	ldr	r3, [r3, #0]
 80055fc:	6839      	ldr	r1, [r7, #0]
 80055fe:	4618      	mov	r0, r3
 8005600:	f7ff ffdc 	bl	80055bc <LOS_ListAdd>
}
 8005604:	bf00      	nop
 8005606:	3708      	adds	r7, #8
 8005608:	46bd      	mov	sp, r7
 800560a:	bd80      	pop	{r7, pc}

0800560c <LOS_ListDelete>:
{
 800560c:	b480      	push	{r7}
 800560e:	b083      	sub	sp, #12
 8005610:	af00      	add	r7, sp, #0
 8005612:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8005614:	687b      	ldr	r3, [r7, #4]
 8005616:	685b      	ldr	r3, [r3, #4]
 8005618:	687a      	ldr	r2, [r7, #4]
 800561a:	6812      	ldr	r2, [r2, #0]
 800561c:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 800561e:	687b      	ldr	r3, [r7, #4]
 8005620:	681b      	ldr	r3, [r3, #0]
 8005622:	687a      	ldr	r2, [r7, #4]
 8005624:	6852      	ldr	r2, [r2, #4]
 8005626:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8005628:	687b      	ldr	r3, [r7, #4]
 800562a:	2200      	movs	r2, #0
 800562c:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 800562e:	687b      	ldr	r3, [r7, #4]
 8005630:	2200      	movs	r2, #0
 8005632:	601a      	str	r2, [r3, #0]
}
 8005634:	bf00      	nop
 8005636:	370c      	adds	r7, #12
 8005638:	46bd      	mov	sp, r7
 800563a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800563e:	4770      	bx	lr

08005640 <LOS_ListEmpty>:
{
 8005640:	b480      	push	{r7}
 8005642:	b083      	sub	sp, #12
 8005644:	af00      	add	r7, sp, #0
 8005646:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8005648:	687b      	ldr	r3, [r7, #4]
 800564a:	685b      	ldr	r3, [r3, #4]
 800564c:	687a      	ldr	r2, [r7, #4]
 800564e:	429a      	cmp	r2, r3
 8005650:	bf0c      	ite	eq
 8005652:	2301      	moveq	r3, #1
 8005654:	2300      	movne	r3, #0
 8005656:	b2db      	uxtb	r3, r3
}
 8005658:	4618      	mov	r0, r3
 800565a:	370c      	adds	r7, #12
 800565c:	46bd      	mov	sp, r7
 800565e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005662:	4770      	bx	lr

08005664 <ArchCurrCpuid>:
{
 8005664:	b480      	push	{r7}
 8005666:	af00      	add	r7, sp, #0
    return 0;
 8005668:	2300      	movs	r3, #0
}
 800566a:	4618      	mov	r0, r3
 800566c:	46bd      	mov	sp, r7
 800566e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005672:	4770      	bx	lr

08005674 <LOS_IntLock>:
{
 8005674:	b580      	push	{r7, lr}
 8005676:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8005678:	f7fb fb26 	bl	8000cc8 <ArchIntLock>
 800567c:	4603      	mov	r3, r0
}
 800567e:	4618      	mov	r0, r3
 8005680:	bd80      	pop	{r7, pc}

08005682 <LOS_IntRestore>:
{
 8005682:	b580      	push	{r7, lr}
 8005684:	b082      	sub	sp, #8
 8005686:	af00      	add	r7, sp, #0
 8005688:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800568a:	6878      	ldr	r0, [r7, #4]
 800568c:	f7fb fb24 	bl	8000cd8 <ArchIntRestore>
}
 8005690:	bf00      	nop
 8005692:	3708      	adds	r7, #8
 8005694:	46bd      	mov	sp, r7
 8005696:	bd80      	pop	{r7, pc}

08005698 <LOS_SpinLock>:
{
 8005698:	b480      	push	{r7}
 800569a:	b083      	sub	sp, #12
 800569c:	af00      	add	r7, sp, #0
 800569e:	6078      	str	r0, [r7, #4]
}
 80056a0:	bf00      	nop
 80056a2:	370c      	adds	r7, #12
 80056a4:	46bd      	mov	sp, r7
 80056a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80056aa:	4770      	bx	lr

080056ac <LOS_SpinUnlock>:
{
 80056ac:	b480      	push	{r7}
 80056ae:	b083      	sub	sp, #12
 80056b0:	af00      	add	r7, sp, #0
 80056b2:	6078      	str	r0, [r7, #4]
}
 80056b4:	bf00      	nop
 80056b6:	370c      	adds	r7, #12
 80056b8:	46bd      	mov	sp, r7
 80056ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80056be:	4770      	bx	lr

080056c0 <LOS_SpinLockSave>:
{
 80056c0:	b580      	push	{r7, lr}
 80056c2:	b082      	sub	sp, #8
 80056c4:	af00      	add	r7, sp, #0
 80056c6:	6078      	str	r0, [r7, #4]
 80056c8:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 80056ca:	f7ff ffd3 	bl	8005674 <LOS_IntLock>
 80056ce:	4602      	mov	r2, r0
 80056d0:	683b      	ldr	r3, [r7, #0]
 80056d2:	601a      	str	r2, [r3, #0]
}
 80056d4:	bf00      	nop
 80056d6:	3708      	adds	r7, #8
 80056d8:	46bd      	mov	sp, r7
 80056da:	bd80      	pop	{r7, pc}

080056dc <LOS_SpinUnlockRestore>:
{
 80056dc:	b580      	push	{r7, lr}
 80056de:	b082      	sub	sp, #8
 80056e0:	af00      	add	r7, sp, #0
 80056e2:	6078      	str	r0, [r7, #4]
 80056e4:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 80056e6:	6838      	ldr	r0, [r7, #0]
 80056e8:	f7ff ffcb 	bl	8005682 <LOS_IntRestore>
}
 80056ec:	bf00      	nop
 80056ee:	3708      	adds	r7, #8
 80056f0:	46bd      	mov	sp, r7
 80056f2:	bd80      	pop	{r7, pc}

080056f4 <OsPercpuGet>:
{
 80056f4:	b580      	push	{r7, lr}
 80056f6:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 80056f8:	f7ff ffb4 	bl	8005664 <ArchCurrCpuid>
 80056fc:	4602      	mov	r2, r0
 80056fe:	4613      	mov	r3, r2
 8005700:	00db      	lsls	r3, r3, #3
 8005702:	4413      	add	r3, r2
 8005704:	009b      	lsls	r3, r3, #2
 8005706:	4a02      	ldr	r2, [pc, #8]	; (8005710 <OsPercpuGet+0x1c>)
 8005708:	4413      	add	r3, r2
}
 800570a:	4618      	mov	r0, r3
 800570c:	bd80      	pop	{r7, pc}
 800570e:	bf00      	nop
 8005710:	200036fc 	.word	0x200036fc

08005714 <OsSwtmrStart>:
/*
 * Description: Start Software Timer
 * Input      : swtmr --- Need to start software timer
 */
LITE_OS_SEC_TEXT VOID OsSwtmrStart(LosSwtmrCB *swtmr)
{
 8005714:	b580      	push	{r7, lr}
 8005716:	b082      	sub	sp, #8
 8005718:	af00      	add	r7, sp, #0
 800571a:	6078      	str	r0, [r7, #4]
    if ((swtmr->overrun == 0) && ((swtmr->mode == LOS_SWTMR_MODE_ONCE) ||
 800571c:	687b      	ldr	r3, [r7, #4]
 800571e:	7b9b      	ldrb	r3, [r3, #14]
 8005720:	2b00      	cmp	r3, #0
 8005722:	d110      	bne.n	8005746 <OsSwtmrStart+0x32>
 8005724:	687b      	ldr	r3, [r7, #4]
 8005726:	7b5b      	ldrb	r3, [r3, #13]
 8005728:	2b00      	cmp	r3, #0
 800572a:	d007      	beq.n	800573c <OsSwtmrStart+0x28>
        (swtmr->mode == LOS_SWTMR_MODE_OPP) ||
 800572c:	687b      	ldr	r3, [r7, #4]
 800572e:	7b5b      	ldrb	r3, [r3, #13]
    if ((swtmr->overrun == 0) && ((swtmr->mode == LOS_SWTMR_MODE_ONCE) ||
 8005730:	2b03      	cmp	r3, #3
 8005732:	d003      	beq.n	800573c <OsSwtmrStart+0x28>
        (swtmr->mode == LOS_SWTMR_MODE_NO_SELFDELETE))) {
 8005734:	687b      	ldr	r3, [r7, #4]
 8005736:	7b5b      	ldrb	r3, [r3, #13]
        (swtmr->mode == LOS_SWTMR_MODE_OPP) ||
 8005738:	2b02      	cmp	r3, #2
 800573a:	d104      	bne.n	8005746 <OsSwtmrStart+0x32>
        SET_SORTLIST_VALUE(&(swtmr->sortList), swtmr->expiry);
 800573c:	687b      	ldr	r3, [r7, #4]
 800573e:	699a      	ldr	r2, [r3, #24]
 8005740:	687b      	ldr	r3, [r7, #4]
 8005742:	609a      	str	r2, [r3, #8]
 8005744:	e003      	b.n	800574e <OsSwtmrStart+0x3a>
    } else {
        SET_SORTLIST_VALUE(&(swtmr->sortList), swtmr->interval);
 8005746:	687b      	ldr	r3, [r7, #4]
 8005748:	695a      	ldr	r2, [r3, #20]
 800574a:	687b      	ldr	r3, [r7, #4]
 800574c:	609a      	str	r2, [r3, #8]
    }

    OsAdd2SortLink(&OsPercpuGet()->swtmrSortLink, &swtmr->sortList);
 800574e:	f7ff ffd1 	bl	80056f4 <OsPercpuGet>
 8005752:	4603      	mov	r3, r0
 8005754:	3308      	adds	r3, #8
 8005756:	687a      	ldr	r2, [r7, #4]
 8005758:	4611      	mov	r1, r2
 800575a:	4618      	mov	r0, r3
 800575c:	f004 fd0c 	bl	800a178 <OsAdd2SortLink>

    swtmr->state = OS_SWTMR_STATUS_TICKING;
 8005760:	687b      	ldr	r3, [r7, #4]
 8005762:	2202      	movs	r2, #2
 8005764:	731a      	strb	r2, [r3, #12]

#ifdef LOSCFG_KERNEL_SMP
    swtmr->cpuid = ArchCurrCpuid();
#endif
}
 8005766:	bf00      	nop
 8005768:	3708      	adds	r7, #8
 800576a:	46bd      	mov	sp, r7
 800576c:	bd80      	pop	{r7, pc}
	...

08005770 <OsSwtmrDelete>:
/*
 * Description: Delete Software Timer
 * Input      : swtmr --- Need to delete software timer, When using, Ensure that it can't be NULL.
 */
STATIC INLINE VOID OsSwtmrDelete(LosSwtmrCB *swtmr)
{
 8005770:	b580      	push	{r7, lr}
 8005772:	b082      	sub	sp, #8
 8005774:	af00      	add	r7, sp, #0
 8005776:	6078      	str	r0, [r7, #4]
    /* insert to free list */
    LOS_ListTailInsert(&g_swtmrFreeList, &swtmr->sortList.sortLinkNode);
 8005778:	687b      	ldr	r3, [r7, #4]
 800577a:	4619      	mov	r1, r3
 800577c:	4804      	ldr	r0, [pc, #16]	; (8005790 <OsSwtmrDelete+0x20>)
 800577e:	f7ff ff36 	bl	80055ee <LOS_ListTailInsert>
    swtmr->state = OS_SWTMR_STATUS_UNUSED;
 8005782:	687b      	ldr	r3, [r7, #4]
 8005784:	2200      	movs	r2, #0
 8005786:	731a      	strb	r2, [r3, #12]
}
 8005788:	bf00      	nop
 800578a:	3708      	adds	r7, #8
 800578c:	46bd      	mov	sp, r7
 800578e:	bd80      	pop	{r7, pc}
 8005790:	200036f0 	.word	0x200036f0

08005794 <OsSwtmrUpdate>:

STATIC INLINE VOID OsSwtmrUpdate(LosSwtmrCB *swtmr)
{
 8005794:	b580      	push	{r7, lr}
 8005796:	b082      	sub	sp, #8
 8005798:	af00      	add	r7, sp, #0
 800579a:	6078      	str	r0, [r7, #4]
    if (swtmr->mode == LOS_SWTMR_MODE_ONCE) {
 800579c:	687b      	ldr	r3, [r7, #4]
 800579e:	7b5b      	ldrb	r3, [r3, #13]
 80057a0:	2b00      	cmp	r3, #0
 80057a2:	d117      	bne.n	80057d4 <OsSwtmrUpdate+0x40>
        OsSwtmrDelete(swtmr);
 80057a4:	6878      	ldr	r0, [r7, #4]
 80057a6:	f7ff ffe3 	bl	8005770 <OsSwtmrDelete>

        if (swtmr->timerId < (OS_SWTMR_MAX_TIMERID - KERNEL_SWTMR_LIMIT)) {
 80057aa:	687b      	ldr	r3, [r7, #4]
 80057ac:	8a1b      	ldrh	r3, [r3, #16]
 80057ae:	f64f 72df 	movw	r2, #65503	; 0xffdf
 80057b2:	4293      	cmp	r3, r2
 80057b4:	d806      	bhi.n	80057c4 <OsSwtmrUpdate+0x30>
            swtmr->timerId += KERNEL_SWTMR_LIMIT;
 80057b6:	687b      	ldr	r3, [r7, #4]
 80057b8:	8a1b      	ldrh	r3, [r3, #16]
 80057ba:	3310      	adds	r3, #16
 80057bc:	b29a      	uxth	r2, r3
 80057be:	687b      	ldr	r3, [r7, #4]
 80057c0:	821a      	strh	r2, [r3, #16]
        swtmr->state = OS_SWTMR_STATUS_CREATED;
    } else {
        swtmr->overrun++;
        OsSwtmrStart(swtmr);
    }
}
 80057c2:	e018      	b.n	80057f6 <OsSwtmrUpdate+0x62>
            swtmr->timerId %= KERNEL_SWTMR_LIMIT;
 80057c4:	687b      	ldr	r3, [r7, #4]
 80057c6:	8a1b      	ldrh	r3, [r3, #16]
 80057c8:	f003 030f 	and.w	r3, r3, #15
 80057cc:	b29a      	uxth	r2, r3
 80057ce:	687b      	ldr	r3, [r7, #4]
 80057d0:	821a      	strh	r2, [r3, #16]
}
 80057d2:	e010      	b.n	80057f6 <OsSwtmrUpdate+0x62>
    } else if (swtmr->mode == LOS_SWTMR_MODE_NO_SELFDELETE) {
 80057d4:	687b      	ldr	r3, [r7, #4]
 80057d6:	7b5b      	ldrb	r3, [r3, #13]
 80057d8:	2b02      	cmp	r3, #2
 80057da:	d103      	bne.n	80057e4 <OsSwtmrUpdate+0x50>
        swtmr->state = OS_SWTMR_STATUS_CREATED;
 80057dc:	687b      	ldr	r3, [r7, #4]
 80057de:	2201      	movs	r2, #1
 80057e0:	731a      	strb	r2, [r3, #12]
}
 80057e2:	e008      	b.n	80057f6 <OsSwtmrUpdate+0x62>
        swtmr->overrun++;
 80057e4:	687b      	ldr	r3, [r7, #4]
 80057e6:	7b9b      	ldrb	r3, [r3, #14]
 80057e8:	3301      	adds	r3, #1
 80057ea:	b2da      	uxtb	r2, r3
 80057ec:	687b      	ldr	r3, [r7, #4]
 80057ee:	739a      	strb	r2, [r3, #14]
        OsSwtmrStart(swtmr);
 80057f0:	6878      	ldr	r0, [r7, #4]
 80057f2:	f7ff ff8f 	bl	8005714 <OsSwtmrStart>
}
 80057f6:	bf00      	nop
 80057f8:	3708      	adds	r7, #8
 80057fa:	46bd      	mov	sp, r7
 80057fc:	bd80      	pop	{r7, pc}
	...

08005800 <OsSwtmrTask>:

#ifndef LOSCFG_BASE_CORE_SWTMR_IN_ISR
LITE_OS_SEC_TEXT VOID OsSwtmrTask(VOID)
{
 8005800:	b580      	push	{r7, lr}
 8005802:	b088      	sub	sp, #32
 8005804:	af00      	add	r7, sp, #0
 8005806:	4b18      	ldr	r3, [pc, #96]	; (8005868 <OsSwtmrTask+0x68>)
 8005808:	681b      	ldr	r3, [r3, #0]
 800580a:	61fb      	str	r3, [r7, #28]
 800580c:	f04f 0300 	mov.w	r3, #0
    UINT32 ret, swtmrHandlerQueue;
    SwtmrHandlerItemPtr swtmrHandler = NULL;
 8005810:	2300      	movs	r3, #0
 8005812:	607b      	str	r3, [r7, #4]
    UINT32 readSize;
    readSize = sizeof(CHAR *);
 8005814:	2304      	movs	r3, #4
 8005816:	60bb      	str	r3, [r7, #8]

    swtmrHandlerQueue = OsPercpuGet()->swtmrHandlerQueue;
 8005818:	f7ff ff6c 	bl	80056f4 <OsPercpuGet>
 800581c:	4603      	mov	r3, r0
 800581e:	699b      	ldr	r3, [r3, #24]
 8005820:	60fb      	str	r3, [r7, #12]
    for (;;) {
        ret = LOS_QueueReadCopy(swtmrHandlerQueue, &swtmrHandler, &readSize, LOS_WAIT_FOREVER);
 8005822:	f107 0208 	add.w	r2, r7, #8
 8005826:	1d39      	adds	r1, r7, #4
 8005828:	f04f 33ff 	mov.w	r3, #4294967295
 800582c:	68f8      	ldr	r0, [r7, #12]
 800582e:	f005 fc11 	bl	800b054 <LOS_QueueReadCopy>
 8005832:	6138      	str	r0, [r7, #16]
        if ((ret == LOS_OK) && (readSize == sizeof(CHAR *))) {
 8005834:	693b      	ldr	r3, [r7, #16]
 8005836:	2b00      	cmp	r3, #0
 8005838:	d1f3      	bne.n	8005822 <OsSwtmrTask+0x22>
 800583a:	68bb      	ldr	r3, [r7, #8]
 800583c:	2b04      	cmp	r3, #4
 800583e:	d1f0      	bne.n	8005822 <OsSwtmrTask+0x22>
            SWTMR_PROC_FUNC handler = swtmrHandler->handler;
 8005840:	687b      	ldr	r3, [r7, #4]
 8005842:	681b      	ldr	r3, [r3, #0]
 8005844:	617b      	str	r3, [r7, #20]
            UINTPTR arg = swtmrHandler->arg;
 8005846:	687b      	ldr	r3, [r7, #4]
 8005848:	685b      	ldr	r3, [r3, #4]
 800584a:	61bb      	str	r3, [r7, #24]
            (VOID)LOS_MemFree(m_aucSysMem0, swtmrHandler);
 800584c:	4b07      	ldr	r3, [pc, #28]	; (800586c <OsSwtmrTask+0x6c>)
 800584e:	681b      	ldr	r3, [r3, #0]
 8005850:	687a      	ldr	r2, [r7, #4]
 8005852:	4611      	mov	r1, r2
 8005854:	4618      	mov	r0, r3
 8005856:	f003 fe95 	bl	8009584 <LOS_MemFree>
            if (handler != NULL) {
 800585a:	697b      	ldr	r3, [r7, #20]
 800585c:	2b00      	cmp	r3, #0
 800585e:	d0e0      	beq.n	8005822 <OsSwtmrTask+0x22>
                handler(arg);
 8005860:	697b      	ldr	r3, [r7, #20]
 8005862:	69b8      	ldr	r0, [r7, #24]
 8005864:	4798      	blx	r3
        ret = LOS_QueueReadCopy(swtmrHandlerQueue, &swtmrHandler, &readSize, LOS_WAIT_FOREVER);
 8005866:	e7dc      	b.n	8005822 <OsSwtmrTask+0x22>
 8005868:	08020350 	.word	0x08020350
 800586c:	200021bc 	.word	0x200021bc

08005870 <OsSwtmrTaskCreate>:
    return FALSE;
}
#endif

LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrTaskCreate(VOID)
{
 8005870:	b580      	push	{r7, lr}
 8005872:	b08e      	sub	sp, #56	; 0x38
 8005874:	af00      	add	r7, sp, #0
 8005876:	4b2a      	ldr	r3, [pc, #168]	; (8005920 <OsSwtmrTaskCreate+0xb0>)
 8005878:	681b      	ldr	r3, [r3, #0]
 800587a:	637b      	str	r3, [r7, #52]	; 0x34
 800587c:	f04f 0300 	mov.w	r3, #0
    UINT32 ret, swtmrTaskId;
    TSK_INIT_PARAM_S swtmrTask;
    UINT32 cpuid = ArchCurrCpuid();
 8005880:	f7ff fef0 	bl	8005664 <ArchCurrCpuid>
 8005884:	60b8      	str	r0, [r7, #8]

    (VOID)memset_s(&swtmrTask, sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
 8005886:	f107 0010 	add.w	r0, r7, #16
 800588a:	2324      	movs	r3, #36	; 0x24
 800588c:	2200      	movs	r2, #0
 800588e:	2124      	movs	r1, #36	; 0x24
 8005890:	f7fc fc08 	bl	80020a4 <memset_s>
    swtmrTask.pfnTaskEntry = (TSK_ENTRY_FUNC)OsSwtmrTask;
 8005894:	4b23      	ldr	r3, [pc, #140]	; (8005924 <OsSwtmrTaskCreate+0xb4>)
 8005896:	613b      	str	r3, [r7, #16]
    swtmrTask.uwStackSize = KERNEL_TSK_SWTMR_STACK_SIZE;
 8005898:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800589c:	62bb      	str	r3, [r7, #40]	; 0x28
    swtmrTask.pcName = "Swt_Task";
 800589e:	4b22      	ldr	r3, [pc, #136]	; (8005928 <OsSwtmrTaskCreate+0xb8>)
 80058a0:	62fb      	str	r3, [r7, #44]	; 0x2c
    swtmrTask.usTaskPrio = 0;
 80058a2:	2300      	movs	r3, #0
 80058a4:	82bb      	strh	r3, [r7, #20]
    swtmrTask.uwResved = LOS_TASK_STATUS_DETACHED;
 80058a6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80058aa:	633b      	str	r3, [r7, #48]	; 0x30
#ifdef LOSCFG_KERNEL_SMP
    swtmrTask.usCpuAffiMask = CPUID_TO_AFFI_MASK(cpuid);
#endif
    ret = LOS_TaskCreate(&swtmrTaskId, &swtmrTask);
 80058ac:	f107 0210 	add.w	r2, r7, #16
 80058b0:	1d3b      	adds	r3, r7, #4
 80058b2:	4611      	mov	r1, r2
 80058b4:	4618      	mov	r0, r3
 80058b6:	f7fe f939 	bl	8003b2c <LOS_TaskCreate>
 80058ba:	60f8      	str	r0, [r7, #12]
    if (ret == LOS_OK) {
 80058bc:	68fb      	ldr	r3, [r7, #12]
 80058be:	2b00      	cmp	r3, #0
 80058c0:	d122      	bne.n	8005908 <OsSwtmrTaskCreate+0x98>
        g_percpu[cpuid].swtmrTaskId = swtmrTaskId;
 80058c2:	6879      	ldr	r1, [r7, #4]
 80058c4:	4819      	ldr	r0, [pc, #100]	; (800592c <OsSwtmrTaskCreate+0xbc>)
 80058c6:	68ba      	ldr	r2, [r7, #8]
 80058c8:	4613      	mov	r3, r2
 80058ca:	00db      	lsls	r3, r3, #3
 80058cc:	4413      	add	r3, r2
 80058ce:	009b      	lsls	r3, r3, #2
 80058d0:	4403      	add	r3, r0
 80058d2:	331c      	adds	r3, #28
 80058d4:	6019      	str	r1, [r3, #0]
        OS_TCB_FROM_TID(swtmrTaskId)->taskFlags |= OS_TASK_FLAG_SYSTEM;
 80058d6:	4b16      	ldr	r3, [pc, #88]	; (8005930 <OsSwtmrTaskCreate+0xc0>)
 80058d8:	6819      	ldr	r1, [r3, #0]
 80058da:	687a      	ldr	r2, [r7, #4]
 80058dc:	4613      	mov	r3, r2
 80058de:	009b      	lsls	r3, r3, #2
 80058e0:	4413      	add	r3, r2
 80058e2:	015b      	lsls	r3, r3, #5
 80058e4:	440b      	add	r3, r1
 80058e6:	689b      	ldr	r3, [r3, #8]
 80058e8:	f3c3 011e 	ubfx	r1, r3, #0, #31
 80058ec:	4b10      	ldr	r3, [pc, #64]	; (8005930 <OsSwtmrTaskCreate+0xc0>)
 80058ee:	6818      	ldr	r0, [r3, #0]
 80058f0:	687a      	ldr	r2, [r7, #4]
 80058f2:	4613      	mov	r3, r2
 80058f4:	009b      	lsls	r3, r3, #2
 80058f6:	4413      	add	r3, r2
 80058f8:	015b      	lsls	r3, r3, #5
 80058fa:	18c2      	adds	r2, r0, r3
 80058fc:	f041 0102 	orr.w	r1, r1, #2
 8005900:	6893      	ldr	r3, [r2, #8]
 8005902:	f361 031e 	bfi	r3, r1, #0, #31
 8005906:	6093      	str	r3, [r2, #8]
    }

    return ret;
 8005908:	68fb      	ldr	r3, [r7, #12]
}
 800590a:	4a05      	ldr	r2, [pc, #20]	; (8005920 <OsSwtmrTaskCreate+0xb0>)
 800590c:	6811      	ldr	r1, [r2, #0]
 800590e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8005910:	4051      	eors	r1, r2
 8005912:	d001      	beq.n	8005918 <OsSwtmrTaskCreate+0xa8>
 8005914:	f7fe fe62 	bl	80045dc <__stack_chk_fail>
 8005918:	4618      	mov	r0, r3
 800591a:	3738      	adds	r7, #56	; 0x38
 800591c:	46bd      	mov	sp, r7
 800591e:	bd80      	pop	{r7, pc}
 8005920:	08020360 	.word	0x08020360
 8005924:	08005801 	.word	0x08005801
 8005928:	08020354 	.word	0x08020354
 800592c:	200036fc 	.word	0x200036fc
 8005930:	200036c4 	.word	0x200036c4

08005934 <OsSwtmrInit>:
#endif

LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrInit(VOID)
{
 8005934:	b580      	push	{r7, lr}
 8005936:	b088      	sub	sp, #32
 8005938:	af02      	add	r7, sp, #8
    UINT32 size;
    UINT16 index;
    UINT32 ret;
    LosSwtmrCB *swtmr = NULL;
 800593a:	2300      	movs	r3, #0
 800593c:	60bb      	str	r3, [r7, #8]
    UINT32 cpuid = ArchCurrCpuid();
 800593e:	f7ff fe91 	bl	8005664 <ArchCurrCpuid>
 8005942:	60f8      	str	r0, [r7, #12]
    if (cpuid == 0) {
 8005944:	68fb      	ldr	r3, [r7, #12]
 8005946:	2b00      	cmp	r3, #0
 8005948:	d12e      	bne.n	80059a8 <OsSwtmrInit+0x74>
        size = sizeof(LosSwtmrCB) * KERNEL_SWTMR_LIMIT;
 800594a:	f44f 7310 	mov.w	r3, #576	; 0x240
 800594e:	613b      	str	r3, [r7, #16]
        swtmr = (LosSwtmrCB *)LOS_MemAlloc(m_aucSysMem0, size); /* system resident resource */
 8005950:	4b2f      	ldr	r3, [pc, #188]	; (8005a10 <OsSwtmrInit+0xdc>)
 8005952:	681b      	ldr	r3, [r3, #0]
 8005954:	6939      	ldr	r1, [r7, #16]
 8005956:	4618      	mov	r0, r3
 8005958:	f003 fd5c 	bl	8009414 <LOS_MemAlloc>
 800595c:	60b8      	str	r0, [r7, #8]
        if (swtmr == NULL) {
 800595e:	68bb      	ldr	r3, [r7, #8]
 8005960:	2b00      	cmp	r3, #0
 8005962:	d101      	bne.n	8005968 <OsSwtmrInit+0x34>
            return LOS_ERRNO_SWTMR_NO_MEMORY;
 8005964:	4b2b      	ldr	r3, [pc, #172]	; (8005a14 <OsSwtmrInit+0xe0>)
 8005966:	e04e      	b.n	8005a06 <OsSwtmrInit+0xd2>
        }

        (VOID)memset_s(swtmr, size, 0, size);
 8005968:	693b      	ldr	r3, [r7, #16]
 800596a:	2200      	movs	r2, #0
 800596c:	6939      	ldr	r1, [r7, #16]
 800596e:	68b8      	ldr	r0, [r7, #8]
 8005970:	f7fc fb98 	bl	80020a4 <memset_s>
        g_swtmrCBArray = swtmr;
 8005974:	4a28      	ldr	r2, [pc, #160]	; (8005a18 <OsSwtmrInit+0xe4>)
 8005976:	68bb      	ldr	r3, [r7, #8]
 8005978:	6013      	str	r3, [r2, #0]
        LOS_ListInit(&g_swtmrFreeList);
 800597a:	4828      	ldr	r0, [pc, #160]	; (8005a1c <OsSwtmrInit+0xe8>)
 800597c:	f7ff fe0e 	bl	800559c <LOS_ListInit>
        for (index = 0; index < KERNEL_SWTMR_LIMIT; index++, swtmr++) {
 8005980:	2300      	movs	r3, #0
 8005982:	80fb      	strh	r3, [r7, #6]
 8005984:	e00d      	b.n	80059a2 <OsSwtmrInit+0x6e>
            swtmr->timerId = index;
 8005986:	68bb      	ldr	r3, [r7, #8]
 8005988:	88fa      	ldrh	r2, [r7, #6]
 800598a:	821a      	strh	r2, [r3, #16]
            LOS_ListTailInsert(&g_swtmrFreeList, &swtmr->sortList.sortLinkNode);
 800598c:	68bb      	ldr	r3, [r7, #8]
 800598e:	4619      	mov	r1, r3
 8005990:	4822      	ldr	r0, [pc, #136]	; (8005a1c <OsSwtmrInit+0xe8>)
 8005992:	f7ff fe2c 	bl	80055ee <LOS_ListTailInsert>
        for (index = 0; index < KERNEL_SWTMR_LIMIT; index++, swtmr++) {
 8005996:	88fb      	ldrh	r3, [r7, #6]
 8005998:	3301      	adds	r3, #1
 800599a:	80fb      	strh	r3, [r7, #6]
 800599c:	68bb      	ldr	r3, [r7, #8]
 800599e:	3324      	adds	r3, #36	; 0x24
 80059a0:	60bb      	str	r3, [r7, #8]
 80059a2:	88fb      	ldrh	r3, [r7, #6]
 80059a4:	2b0f      	cmp	r3, #15
 80059a6:	d9ee      	bls.n	8005986 <OsSwtmrInit+0x52>
        }
    }

#ifndef LOSCFG_BASE_CORE_SWTMR_IN_ISR
    ret = LOS_QueueCreate(NULL, OS_SWTMR_HANDLE_QUEUE_SIZE, &g_percpu[cpuid].swtmrHandlerQueue, 0, sizeof(CHAR *));
 80059a8:	68fa      	ldr	r2, [r7, #12]
 80059aa:	4613      	mov	r3, r2
 80059ac:	00db      	lsls	r3, r3, #3
 80059ae:	4413      	add	r3, r2
 80059b0:	009b      	lsls	r3, r3, #2
 80059b2:	3318      	adds	r3, #24
 80059b4:	4a1a      	ldr	r2, [pc, #104]	; (8005a20 <OsSwtmrInit+0xec>)
 80059b6:	441a      	add	r2, r3
 80059b8:	2304      	movs	r3, #4
 80059ba:	9300      	str	r3, [sp, #0]
 80059bc:	2300      	movs	r3, #0
 80059be:	2110      	movs	r1, #16
 80059c0:	2000      	movs	r0, #0
 80059c2:	f005 f829 	bl	800aa18 <LOS_QueueCreate>
 80059c6:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 80059c8:	697b      	ldr	r3, [r7, #20]
 80059ca:	2b00      	cmp	r3, #0
 80059cc:	d001      	beq.n	80059d2 <OsSwtmrInit+0x9e>
        return LOS_ERRNO_SWTMR_QUEUE_CREATE_FAILED;
 80059ce:	4b15      	ldr	r3, [pc, #84]	; (8005a24 <OsSwtmrInit+0xf0>)
 80059d0:	e019      	b.n	8005a06 <OsSwtmrInit+0xd2>
    }

    ret = OsSwtmrTaskCreate();
 80059d2:	f7ff ff4d 	bl	8005870 <OsSwtmrTaskCreate>
 80059d6:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 80059d8:	697b      	ldr	r3, [r7, #20]
 80059da:	2b00      	cmp	r3, #0
 80059dc:	d001      	beq.n	80059e2 <OsSwtmrInit+0xae>
        return LOS_ERRNO_SWTMR_TASK_CREATE_FAILED;
 80059de:	4b12      	ldr	r3, [pc, #72]	; (8005a28 <OsSwtmrInit+0xf4>)
 80059e0:	e011      	b.n	8005a06 <OsSwtmrInit+0xd2>
    }
#endif

    ret = OsSortLinkInit(&g_percpu[cpuid].swtmrSortLink);
 80059e2:	68fa      	ldr	r2, [r7, #12]
 80059e4:	4613      	mov	r3, r2
 80059e6:	00db      	lsls	r3, r3, #3
 80059e8:	4413      	add	r3, r2
 80059ea:	009b      	lsls	r3, r3, #2
 80059ec:	3308      	adds	r3, #8
 80059ee:	4a0c      	ldr	r2, [pc, #48]	; (8005a20 <OsSwtmrInit+0xec>)
 80059f0:	4413      	add	r3, r2
 80059f2:	4618      	mov	r0, r3
 80059f4:	f004 fb8a 	bl	800a10c <OsSortLinkInit>
 80059f8:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 80059fa:	697b      	ldr	r3, [r7, #20]
 80059fc:	2b00      	cmp	r3, #0
 80059fe:	d001      	beq.n	8005a04 <OsSwtmrInit+0xd0>
        return LOS_ERRNO_SWTMR_SORTLINK_CREATE_FAILED;
 8005a00:	4b0a      	ldr	r3, [pc, #40]	; (8005a2c <OsSwtmrInit+0xf8>)
 8005a02:	e000      	b.n	8005a06 <OsSwtmrInit+0xd2>
    }

    return LOS_OK;
 8005a04:	2300      	movs	r3, #0
}
 8005a06:	4618      	mov	r0, r3
 8005a08:	3718      	adds	r7, #24
 8005a0a:	46bd      	mov	sp, r7
 8005a0c:	bd80      	pop	{r7, pc}
 8005a0e:	bf00      	nop
 8005a10:	200021bc 	.word	0x200021bc
 8005a14:	02000307 	.word	0x02000307
 8005a18:	2000079c 	.word	0x2000079c
 8005a1c:	200036f0 	.word	0x200036f0
 8005a20:	200036fc 	.word	0x200036fc
 8005a24:	0200030b 	.word	0x0200030b
 8005a28:	0200030c 	.word	0x0200030c
 8005a2c:	02000311 	.word	0x02000311

08005a30 <OsSwtmrScan>:
/*
 * Description: Tick interrupt interface module of software timer
 * Return     : LOS_OK on success or error code on failure
 */
LITE_OS_SEC_TEXT VOID OsSwtmrScan(VOID)
{
 8005a30:	b590      	push	{r4, r7, lr}
 8005a32:	b08b      	sub	sp, #44	; 0x2c
 8005a34:	af00      	add	r7, sp, #0
 8005a36:	4b53      	ldr	r3, [pc, #332]	; (8005b84 <OsSwtmrScan+0x154>)
 8005a38:	681b      	ldr	r3, [r3, #0]
 8005a3a:	627b      	str	r3, [r7, #36]	; 0x24
 8005a3c:	f04f 0300 	mov.w	r3, #0
    SortLinkList *sortList = NULL;
 8005a40:	2300      	movs	r3, #0
 8005a42:	60bb      	str	r3, [r7, #8]
    LosSwtmrCB *swtmr = NULL;
 8005a44:	2300      	movs	r3, #0
 8005a46:	60fb      	str	r3, [r7, #12]
    LOS_DL_LIST *listObject = NULL;
 8005a48:	2300      	movs	r3, #0
 8005a4a:	613b      	str	r3, [r7, #16]
    SortLinkAttribute* swtmrSortLink = &OsPercpuGet()->swtmrSortLink;
 8005a4c:	f7ff fe52 	bl	80056f4 <OsPercpuGet>
 8005a50:	4603      	mov	r3, r0
 8005a52:	3308      	adds	r3, #8
 8005a54:	617b      	str	r3, [r7, #20]

    SORTLINK_CURSOR_UPDATE(swtmrSortLink->cursor);
 8005a56:	697b      	ldr	r3, [r7, #20]
 8005a58:	889b      	ldrh	r3, [r3, #4]
 8005a5a:	3301      	adds	r3, #1
 8005a5c:	b29b      	uxth	r3, r3
 8005a5e:	f003 0307 	and.w	r3, r3, #7
 8005a62:	b29a      	uxth	r2, r3
 8005a64:	697b      	ldr	r3, [r7, #20]
 8005a66:	809a      	strh	r2, [r3, #4]
    SORTLINK_LISTOBJ_GET(listObject, swtmrSortLink);
 8005a68:	697b      	ldr	r3, [r7, #20]
 8005a6a:	681a      	ldr	r2, [r3, #0]
 8005a6c:	697b      	ldr	r3, [r7, #20]
 8005a6e:	889b      	ldrh	r3, [r3, #4]
 8005a70:	00db      	lsls	r3, r3, #3
 8005a72:	4413      	add	r3, r2
 8005a74:	613b      	str	r3, [r7, #16]

    /*
     * it needs to be carefully coped with, since the swtmr is in specific sortlink
     * while other cores still has the chance to process it, like stop the timer.
     */
    LOS_SpinLock(&g_swtmrSpin);
 8005a76:	4844      	ldr	r0, [pc, #272]	; (8005b88 <OsSwtmrScan+0x158>)
 8005a78:	f7ff fe0e 	bl	8005698 <LOS_SpinLock>

    if (LOS_ListEmpty(listObject)) {
 8005a7c:	6938      	ldr	r0, [r7, #16]
 8005a7e:	f7ff fddf 	bl	8005640 <LOS_ListEmpty>
 8005a82:	4603      	mov	r3, r0
 8005a84:	2b00      	cmp	r3, #0
 8005a86:	d003      	beq.n	8005a90 <OsSwtmrScan+0x60>
        LOS_SpinUnlock(&g_swtmrSpin);
 8005a88:	483f      	ldr	r0, [pc, #252]	; (8005b88 <OsSwtmrScan+0x158>)
 8005a8a:	f7ff fe0f 	bl	80056ac <LOS_SpinUnlock>
        return;
 8005a8e:	e06e      	b.n	8005b6e <OsSwtmrScan+0x13e>
    }
    sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 8005a90:	693b      	ldr	r3, [r7, #16]
 8005a92:	685b      	ldr	r3, [r3, #4]
 8005a94:	60bb      	str	r3, [r7, #8]
    ROLLNUM_DEC(sortList->idxRollNum);
 8005a96:	68bb      	ldr	r3, [r7, #8]
 8005a98:	689b      	ldr	r3, [r3, #8]
 8005a9a:	1e5a      	subs	r2, r3, #1
 8005a9c:	68bb      	ldr	r3, [r7, #8]
 8005a9e:	609a      	str	r2, [r3, #8]

    while (ROLLNUM(sortList->idxRollNum) == 0) {
 8005aa0:	e05a      	b.n	8005b58 <OsSwtmrScan+0x128>
        sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 8005aa2:	693b      	ldr	r3, [r7, #16]
 8005aa4:	685b      	ldr	r3, [r3, #4]
 8005aa6:	60bb      	str	r3, [r7, #8]
        LOS_ListDelete(&sortList->sortLinkNode);
 8005aa8:	68bb      	ldr	r3, [r7, #8]
 8005aaa:	4618      	mov	r0, r3
 8005aac:	f7ff fdae 	bl	800560c <LOS_ListDelete>
        swtmr = LOS_DL_LIST_ENTRY(sortList, LosSwtmrCB, sortList);
 8005ab0:	68bb      	ldr	r3, [r7, #8]
 8005ab2:	60fb      	str	r3, [r7, #12]

#ifndef LOSCFG_BASE_CORE_SWTMR_IN_ISR
        LOS_TRACE(SWTMR_EXPIRED, swtmr->timerId);
 8005ab4:	2300      	movs	r3, #0
 8005ab6:	61fb      	str	r3, [r7, #28]
 8005ab8:	68fb      	ldr	r3, [r7, #12]
 8005aba:	8a1b      	ldrh	r3, [r3, #16]
 8005abc:	623b      	str	r3, [r7, #32]
 8005abe:	2302      	movs	r3, #2
 8005ac0:	61bb      	str	r3, [r7, #24]
 8005ac2:	69bb      	ldr	r3, [r7, #24]
 8005ac4:	2b01      	cmp	r3, #1
 8005ac6:	d915      	bls.n	8005af4 <OsSwtmrScan+0xc4>
 8005ac8:	4b30      	ldr	r3, [pc, #192]	; (8005b8c <OsSwtmrScan+0x15c>)
 8005aca:	681b      	ldr	r3, [r3, #0]
 8005acc:	2b00      	cmp	r3, #0
 8005ace:	d011      	beq.n	8005af4 <OsSwtmrScan+0xc4>
 8005ad0:	4b2e      	ldr	r3, [pc, #184]	; (8005b8c <OsSwtmrScan+0x15c>)
 8005ad2:	681c      	ldr	r4, [r3, #0]
 8005ad4:	6a39      	ldr	r1, [r7, #32]
 8005ad6:	69bb      	ldr	r3, [r7, #24]
 8005ad8:	2b02      	cmp	r3, #2
 8005ada:	d904      	bls.n	8005ae6 <OsSwtmrScan+0xb6>
 8005adc:	f107 031c 	add.w	r3, r7, #28
 8005ae0:	f103 0208 	add.w	r2, r3, #8
 8005ae4:	e000      	b.n	8005ae8 <OsSwtmrScan+0xb8>
 8005ae6:	2200      	movs	r2, #0
 8005ae8:	69bb      	ldr	r3, [r7, #24]
 8005aea:	b29b      	uxth	r3, r3
 8005aec:	3b02      	subs	r3, #2
 8005aee:	b29b      	uxth	r3, r3
 8005af0:	2084      	movs	r0, #132	; 0x84
 8005af2:	47a0      	blx	r4
        SwtmrHandlerItemPtr swtmrHandler = (SwtmrHandlerItemPtr)LOS_MemAlloc(m_aucSysMem0, sizeof(SwtmrHandlerItem));
 8005af4:	4b26      	ldr	r3, [pc, #152]	; (8005b90 <OsSwtmrScan+0x160>)
 8005af6:	681b      	ldr	r3, [r3, #0]
 8005af8:	2108      	movs	r1, #8
 8005afa:	4618      	mov	r0, r3
 8005afc:	f003 fc8a 	bl	8009414 <LOS_MemAlloc>
 8005b00:	4603      	mov	r3, r0
 8005b02:	607b      	str	r3, [r7, #4]
        if (swtmrHandler != NULL) {
 8005b04:	687b      	ldr	r3, [r7, #4]
 8005b06:	2b00      	cmp	r3, #0
 8005b08:	d01a      	beq.n	8005b40 <OsSwtmrScan+0x110>
            swtmrHandler->handler = swtmr->handler;
 8005b0a:	687b      	ldr	r3, [r7, #4]
 8005b0c:	68fa      	ldr	r2, [r7, #12]
 8005b0e:	6a12      	ldr	r2, [r2, #32]
 8005b10:	601a      	str	r2, [r3, #0]
            swtmrHandler->arg = swtmr->arg;
 8005b12:	687b      	ldr	r3, [r7, #4]
 8005b14:	68fa      	ldr	r2, [r7, #12]
 8005b16:	69d2      	ldr	r2, [r2, #28]
 8005b18:	605a      	str	r2, [r3, #4]
            if (LOS_QueueWriteCopy(OsPercpuGet()->swtmrHandlerQueue, &swtmrHandler,
 8005b1a:	f7ff fdeb 	bl	80056f4 <OsPercpuGet>
 8005b1e:	4603      	mov	r3, r0
 8005b20:	6998      	ldr	r0, [r3, #24]
 8005b22:	1d39      	adds	r1, r7, #4
 8005b24:	2300      	movs	r3, #0
 8005b26:	2204      	movs	r2, #4
 8005b28:	f005 fab6 	bl	800b098 <LOS_QueueWriteCopy>
 8005b2c:	4603      	mov	r3, r0
 8005b2e:	2b00      	cmp	r3, #0
 8005b30:	d006      	beq.n	8005b40 <OsSwtmrScan+0x110>
                                   sizeof(CHAR *), LOS_NO_WAIT) != LOS_OK) {
                (VOID)LOS_MemFree(m_aucSysMem0, swtmrHandler);
 8005b32:	4b17      	ldr	r3, [pc, #92]	; (8005b90 <OsSwtmrScan+0x160>)
 8005b34:	681b      	ldr	r3, [r3, #0]
 8005b36:	687a      	ldr	r2, [r7, #4]
 8005b38:	4611      	mov	r1, r2
 8005b3a:	4618      	mov	r0, r3
 8005b3c:	f003 fd22 	bl	8009584 <LOS_MemFree>
            }
        }
        OsSwtmrUpdate(swtmr);
 8005b40:	68f8      	ldr	r0, [r7, #12]
 8005b42:	f7ff fe27 	bl	8005794 <OsSwtmrUpdate>

            LOS_SpinLock(&g_swtmrSpin);
        }
#endif

        if (LOS_ListEmpty(listObject)) {
 8005b46:	6938      	ldr	r0, [r7, #16]
 8005b48:	f7ff fd7a 	bl	8005640 <LOS_ListEmpty>
 8005b4c:	4603      	mov	r3, r0
 8005b4e:	2b00      	cmp	r3, #0
 8005b50:	d109      	bne.n	8005b66 <OsSwtmrScan+0x136>
            break;
        }

        sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 8005b52:	693b      	ldr	r3, [r7, #16]
 8005b54:	685b      	ldr	r3, [r3, #4]
 8005b56:	60bb      	str	r3, [r7, #8]
    while (ROLLNUM(sortList->idxRollNum) == 0) {
 8005b58:	68bb      	ldr	r3, [r7, #8]
 8005b5a:	689b      	ldr	r3, [r3, #8]
 8005b5c:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8005b60:	2b00      	cmp	r3, #0
 8005b62:	d09e      	beq.n	8005aa2 <OsSwtmrScan+0x72>
 8005b64:	e000      	b.n	8005b68 <OsSwtmrScan+0x138>
            break;
 8005b66:	bf00      	nop
    }

    LOS_SpinUnlock(&g_swtmrSpin);
 8005b68:	4807      	ldr	r0, [pc, #28]	; (8005b88 <OsSwtmrScan+0x158>)
 8005b6a:	f7ff fd9f 	bl	80056ac <LOS_SpinUnlock>
}
 8005b6e:	4b05      	ldr	r3, [pc, #20]	; (8005b84 <OsSwtmrScan+0x154>)
 8005b70:	681a      	ldr	r2, [r3, #0]
 8005b72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005b74:	405a      	eors	r2, r3
 8005b76:	d001      	beq.n	8005b7c <OsSwtmrScan+0x14c>
 8005b78:	f7fe fd30 	bl	80045dc <__stack_chk_fail>
 8005b7c:	372c      	adds	r7, #44	; 0x2c
 8005b7e:	46bd      	mov	sp, r7
 8005b80:	bd90      	pop	{r4, r7, pc}
 8005b82:	bf00      	nop
 8005b84:	08020364 	.word	0x08020364
 8005b88:	200007a0 	.word	0x200007a0
 8005b8c:	20000768 	.word	0x20000768
 8005b90:	200021bc 	.word	0x200021bc

08005b94 <OsSwtmrStop>:
/*
 * Description: Stop of Software Timer interface
 * Input      : swtmr --- the software timer control handler
 */
LITE_OS_SEC_TEXT STATIC VOID OsSwtmrStop(LosSwtmrCB *swtmr)
{
 8005b94:	b580      	push	{r7, lr}
 8005b96:	b084      	sub	sp, #16
 8005b98:	af00      	add	r7, sp, #0
 8005b9a:	6078      	str	r0, [r7, #4]
    SortLinkAttribute *sortLinkHeader = NULL;
 8005b9c:	2300      	movs	r3, #0
 8005b9e:	60fb      	str	r3, [r7, #12]
     * the timer is running on the specific processor,
     * we need delete the timer from that processor's sortlink.
     */
    sortLinkHeader = &g_percpu[swtmr->cpuid].swtmrSortLink;
#else
    sortLinkHeader = &g_percpu[0].swtmrSortLink;
 8005ba0:	4b08      	ldr	r3, [pc, #32]	; (8005bc4 <OsSwtmrStop+0x30>)
 8005ba2:	60fb      	str	r3, [r7, #12]
#endif
    OsDeleteSortLink(sortLinkHeader, &swtmr->sortList);
 8005ba4:	687b      	ldr	r3, [r7, #4]
 8005ba6:	4619      	mov	r1, r3
 8005ba8:	68f8      	ldr	r0, [r7, #12]
 8005baa:	f004 fb8f 	bl	800a2cc <OsDeleteSortLink>

    swtmr->state = OS_SWTMR_STATUS_CREATED;
 8005bae:	687b      	ldr	r3, [r7, #4]
 8005bb0:	2201      	movs	r2, #1
 8005bb2:	731a      	strb	r2, [r3, #12]
    swtmr->overrun = 0;
 8005bb4:	687b      	ldr	r3, [r7, #4]
 8005bb6:	2200      	movs	r2, #0
 8005bb8:	739a      	strb	r2, [r3, #14]
}
 8005bba:	bf00      	nop
 8005bbc:	3710      	adds	r7, #16
 8005bbe:	46bd      	mov	sp, r7
 8005bc0:	bd80      	pop	{r7, pc}
 8005bc2:	bf00      	nop
 8005bc4:	20003704 	.word	0x20003704

08005bc8 <LOS_SwtmrCreate>:
LITE_OS_SEC_TEXT_INIT UINT32 LOS_SwtmrCreate(UINT32 interval,
                                             UINT8 mode,
                                             SWTMR_PROC_FUNC handler,
                                             UINT16 *swtmrId,
                                             UINTPTR arg)
{
 8005bc8:	b590      	push	{r4, r7, lr}
 8005bca:	b08d      	sub	sp, #52	; 0x34
 8005bcc:	af00      	add	r7, sp, #0
 8005bce:	60f8      	str	r0, [r7, #12]
 8005bd0:	607a      	str	r2, [r7, #4]
 8005bd2:	603b      	str	r3, [r7, #0]
 8005bd4:	460b      	mov	r3, r1
 8005bd6:	72fb      	strb	r3, [r7, #11]
 8005bd8:	4b46      	ldr	r3, [pc, #280]	; (8005cf4 <LOS_SwtmrCreate+0x12c>)
 8005bda:	681b      	ldr	r3, [r3, #0]
 8005bdc:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005bde:	f04f 0300 	mov.w	r3, #0
    LosSwtmrCB *swtmr = NULL;
 8005be2:	2300      	movs	r3, #0
 8005be4:	61bb      	str	r3, [r7, #24]
    UINT32 intSave;
    SortLinkList *sortList = NULL;
 8005be6:	2300      	movs	r3, #0
 8005be8:	61fb      	str	r3, [r7, #28]

    if (interval == 0) {
 8005bea:	68fb      	ldr	r3, [r7, #12]
 8005bec:	2b00      	cmp	r3, #0
 8005bee:	d101      	bne.n	8005bf4 <LOS_SwtmrCreate+0x2c>
        return LOS_ERRNO_SWTMR_INTERVAL_NOT_SUITED;
 8005bf0:	4b41      	ldr	r3, [pc, #260]	; (8005cf8 <LOS_SwtmrCreate+0x130>)
 8005bf2:	e073      	b.n	8005cdc <LOS_SwtmrCreate+0x114>
    }

    if ((mode != LOS_SWTMR_MODE_ONCE) && (mode != LOS_SWTMR_MODE_PERIOD) &&
 8005bf4:	7afb      	ldrb	r3, [r7, #11]
 8005bf6:	2b00      	cmp	r3, #0
 8005bf8:	d007      	beq.n	8005c0a <LOS_SwtmrCreate+0x42>
 8005bfa:	7afb      	ldrb	r3, [r7, #11]
 8005bfc:	2b01      	cmp	r3, #1
 8005bfe:	d004      	beq.n	8005c0a <LOS_SwtmrCreate+0x42>
 8005c00:	7afb      	ldrb	r3, [r7, #11]
 8005c02:	2b02      	cmp	r3, #2
 8005c04:	d001      	beq.n	8005c0a <LOS_SwtmrCreate+0x42>
        (mode != LOS_SWTMR_MODE_NO_SELFDELETE)) {
        return LOS_ERRNO_SWTMR_MODE_INVALID;
 8005c06:	4b3d      	ldr	r3, [pc, #244]	; (8005cfc <LOS_SwtmrCreate+0x134>)
 8005c08:	e068      	b.n	8005cdc <LOS_SwtmrCreate+0x114>
    }

    if (handler == NULL) {
 8005c0a:	687b      	ldr	r3, [r7, #4]
 8005c0c:	2b00      	cmp	r3, #0
 8005c0e:	d101      	bne.n	8005c14 <LOS_SwtmrCreate+0x4c>
        return LOS_ERRNO_SWTMR_PTR_NULL;
 8005c10:	4b3b      	ldr	r3, [pc, #236]	; (8005d00 <LOS_SwtmrCreate+0x138>)
 8005c12:	e063      	b.n	8005cdc <LOS_SwtmrCreate+0x114>
    }

    if (swtmrId == NULL) {
 8005c14:	683b      	ldr	r3, [r7, #0]
 8005c16:	2b00      	cmp	r3, #0
 8005c18:	d101      	bne.n	8005c1e <LOS_SwtmrCreate+0x56>
        return LOS_ERRNO_SWTMR_RET_PTR_NULL;
 8005c1a:	4b3a      	ldr	r3, [pc, #232]	; (8005d04 <LOS_SwtmrCreate+0x13c>)
 8005c1c:	e05e      	b.n	8005cdc <LOS_SwtmrCreate+0x114>
    }

    SWTMR_LOCK(intSave);
 8005c1e:	f107 0314 	add.w	r3, r7, #20
 8005c22:	4619      	mov	r1, r3
 8005c24:	4838      	ldr	r0, [pc, #224]	; (8005d08 <LOS_SwtmrCreate+0x140>)
 8005c26:	f7ff fd4b 	bl	80056c0 <LOS_SpinLockSave>
    if (LOS_ListEmpty(&g_swtmrFreeList)) {
 8005c2a:	4838      	ldr	r0, [pc, #224]	; (8005d0c <LOS_SwtmrCreate+0x144>)
 8005c2c:	f7ff fd08 	bl	8005640 <LOS_ListEmpty>
 8005c30:	4603      	mov	r3, r0
 8005c32:	2b00      	cmp	r3, #0
 8005c34:	d006      	beq.n	8005c44 <LOS_SwtmrCreate+0x7c>
        SWTMR_UNLOCK(intSave);
 8005c36:	697b      	ldr	r3, [r7, #20]
 8005c38:	4619      	mov	r1, r3
 8005c3a:	4833      	ldr	r0, [pc, #204]	; (8005d08 <LOS_SwtmrCreate+0x140>)
 8005c3c:	f7ff fd4e 	bl	80056dc <LOS_SpinUnlockRestore>
        return LOS_ERRNO_SWTMR_MAXSIZE;
 8005c40:	4b33      	ldr	r3, [pc, #204]	; (8005d10 <LOS_SwtmrCreate+0x148>)
 8005c42:	e04b      	b.n	8005cdc <LOS_SwtmrCreate+0x114>
    }

    sortList = LOS_DL_LIST_ENTRY(g_swtmrFreeList.pstNext, SortLinkList, sortLinkNode);
 8005c44:	4b31      	ldr	r3, [pc, #196]	; (8005d0c <LOS_SwtmrCreate+0x144>)
 8005c46:	685b      	ldr	r3, [r3, #4]
 8005c48:	61fb      	str	r3, [r7, #28]
    swtmr = LOS_DL_LIST_ENTRY(sortList, LosSwtmrCB, sortList);
 8005c4a:	69fb      	ldr	r3, [r7, #28]
 8005c4c:	61bb      	str	r3, [r7, #24]
    LOS_ListDelete(LOS_DL_LIST_FIRST(&g_swtmrFreeList));
 8005c4e:	4b2f      	ldr	r3, [pc, #188]	; (8005d0c <LOS_SwtmrCreate+0x144>)
 8005c50:	685b      	ldr	r3, [r3, #4]
 8005c52:	4618      	mov	r0, r3
 8005c54:	f7ff fcda 	bl	800560c <LOS_ListDelete>
    SWTMR_UNLOCK(intSave);
 8005c58:	697b      	ldr	r3, [r7, #20]
 8005c5a:	4619      	mov	r1, r3
 8005c5c:	482a      	ldr	r0, [pc, #168]	; (8005d08 <LOS_SwtmrCreate+0x140>)
 8005c5e:	f7ff fd3d 	bl	80056dc <LOS_SpinUnlockRestore>

    swtmr->handler = handler;
 8005c62:	69bb      	ldr	r3, [r7, #24]
 8005c64:	687a      	ldr	r2, [r7, #4]
 8005c66:	621a      	str	r2, [r3, #32]
    swtmr->mode = mode;
 8005c68:	69bb      	ldr	r3, [r7, #24]
 8005c6a:	7afa      	ldrb	r2, [r7, #11]
 8005c6c:	735a      	strb	r2, [r3, #13]
    swtmr->overrun = 0;
 8005c6e:	69bb      	ldr	r3, [r7, #24]
 8005c70:	2200      	movs	r2, #0
 8005c72:	739a      	strb	r2, [r3, #14]
    swtmr->interval = interval;
 8005c74:	69bb      	ldr	r3, [r7, #24]
 8005c76:	68fa      	ldr	r2, [r7, #12]
 8005c78:	615a      	str	r2, [r3, #20]
    swtmr->expiry = interval;
 8005c7a:	69bb      	ldr	r3, [r7, #24]
 8005c7c:	68fa      	ldr	r2, [r7, #12]
 8005c7e:	619a      	str	r2, [r3, #24]
    swtmr->arg = arg;
 8005c80:	69bb      	ldr	r3, [r7, #24]
 8005c82:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8005c84:	61da      	str	r2, [r3, #28]
    swtmr->state = OS_SWTMR_STATUS_CREATED;
 8005c86:	69bb      	ldr	r3, [r7, #24]
 8005c88:	2201      	movs	r2, #1
 8005c8a:	731a      	strb	r2, [r3, #12]
    SET_SORTLIST_VALUE(&(swtmr->sortList), 0);
 8005c8c:	69bb      	ldr	r3, [r7, #24]
 8005c8e:	2200      	movs	r2, #0
 8005c90:	609a      	str	r2, [r3, #8]
    *swtmrId = swtmr->timerId;
 8005c92:	69bb      	ldr	r3, [r7, #24]
 8005c94:	8a1a      	ldrh	r2, [r3, #16]
 8005c96:	683b      	ldr	r3, [r7, #0]
 8005c98:	801a      	strh	r2, [r3, #0]
    LOS_TRACE(SWTMR_CREATE, swtmr->timerId);
 8005c9a:	2300      	movs	r3, #0
 8005c9c:	627b      	str	r3, [r7, #36]	; 0x24
 8005c9e:	69bb      	ldr	r3, [r7, #24]
 8005ca0:	8a1b      	ldrh	r3, [r3, #16]
 8005ca2:	62bb      	str	r3, [r7, #40]	; 0x28
 8005ca4:	2302      	movs	r3, #2
 8005ca6:	623b      	str	r3, [r7, #32]
 8005ca8:	6a3b      	ldr	r3, [r7, #32]
 8005caa:	2b01      	cmp	r3, #1
 8005cac:	d915      	bls.n	8005cda <LOS_SwtmrCreate+0x112>
 8005cae:	4b19      	ldr	r3, [pc, #100]	; (8005d14 <LOS_SwtmrCreate+0x14c>)
 8005cb0:	681b      	ldr	r3, [r3, #0]
 8005cb2:	2b00      	cmp	r3, #0
 8005cb4:	d011      	beq.n	8005cda <LOS_SwtmrCreate+0x112>
 8005cb6:	4b17      	ldr	r3, [pc, #92]	; (8005d14 <LOS_SwtmrCreate+0x14c>)
 8005cb8:	681c      	ldr	r4, [r3, #0]
 8005cba:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005cbc:	6a3b      	ldr	r3, [r7, #32]
 8005cbe:	2b02      	cmp	r3, #2
 8005cc0:	d904      	bls.n	8005ccc <LOS_SwtmrCreate+0x104>
 8005cc2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005cc6:	f103 0208 	add.w	r2, r3, #8
 8005cca:	e000      	b.n	8005cce <LOS_SwtmrCreate+0x106>
 8005ccc:	2200      	movs	r2, #0
 8005cce:	6a3b      	ldr	r3, [r7, #32]
 8005cd0:	b29b      	uxth	r3, r3
 8005cd2:	3b02      	subs	r3, #2
 8005cd4:	b29b      	uxth	r3, r3
 8005cd6:	2080      	movs	r0, #128	; 0x80
 8005cd8:	47a0      	blx	r4

    return LOS_OK;
 8005cda:	2300      	movs	r3, #0
}
 8005cdc:	4a05      	ldr	r2, [pc, #20]	; (8005cf4 <LOS_SwtmrCreate+0x12c>)
 8005cde:	6811      	ldr	r1, [r2, #0]
 8005ce0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005ce2:	4051      	eors	r1, r2
 8005ce4:	d001      	beq.n	8005cea <LOS_SwtmrCreate+0x122>
 8005ce6:	f7fe fc79 	bl	80045dc <__stack_chk_fail>
 8005cea:	4618      	mov	r0, r3
 8005cec:	3734      	adds	r7, #52	; 0x34
 8005cee:	46bd      	mov	sp, r7
 8005cf0:	bd90      	pop	{r4, r7, pc}
 8005cf2:	bf00      	nop
 8005cf4:	08020368 	.word	0x08020368
 8005cf8:	02000301 	.word	0x02000301
 8005cfc:	02000302 	.word	0x02000302
 8005d00:	02000300 	.word	0x02000300
 8005d04:	02000303 	.word	0x02000303
 8005d08:	200007a0 	.word	0x200007a0
 8005d0c:	200036f0 	.word	0x200036f0
 8005d10:	02000304 	.word	0x02000304
 8005d14:	20000768 	.word	0x20000768

08005d18 <LOS_SwtmrStart>:

LITE_OS_SEC_TEXT UINT32 LOS_SwtmrStart(UINT16 swtmrId)
{
 8005d18:	b590      	push	{r4, r7, lr}
 8005d1a:	b08f      	sub	sp, #60	; 0x3c
 8005d1c:	af00      	add	r7, sp, #0
 8005d1e:	4603      	mov	r3, r0
 8005d20:	80fb      	strh	r3, [r7, #6]
 8005d22:	4b42      	ldr	r3, [pc, #264]	; (8005e2c <LOS_SwtmrStart+0x114>)
 8005d24:	681b      	ldr	r3, [r3, #0]
 8005d26:	637b      	str	r3, [r7, #52]	; 0x34
 8005d28:	f04f 0300 	mov.w	r3, #0
    LosSwtmrCB *swtmr = NULL;
 8005d2c:	2300      	movs	r3, #0
 8005d2e:	617b      	str	r3, [r7, #20]
    UINT32 intSave;
    UINT32 ret = LOS_OK;
 8005d30:	2300      	movs	r3, #0
 8005d32:	613b      	str	r3, [r7, #16]
    UINT16 swtmrCBId;

    if (swtmrId >= OS_SWTMR_MAX_TIMERID) {
 8005d34:	88fb      	ldrh	r3, [r7, #6]
 8005d36:	f64f 72ef 	movw	r2, #65519	; 0xffef
 8005d3a:	4293      	cmp	r3, r2
 8005d3c:	d901      	bls.n	8005d42 <LOS_SwtmrStart+0x2a>
        return LOS_ERRNO_SWTMR_ID_INVALID;
 8005d3e:	4b3c      	ldr	r3, [pc, #240]	; (8005e30 <LOS_SwtmrStart+0x118>)
 8005d40:	e068      	b.n	8005e14 <LOS_SwtmrStart+0xfc>
    }

    SWTMR_LOCK(intSave);
 8005d42:	f107 030c 	add.w	r3, r7, #12
 8005d46:	4619      	mov	r1, r3
 8005d48:	483a      	ldr	r0, [pc, #232]	; (8005e34 <LOS_SwtmrStart+0x11c>)
 8005d4a:	f7ff fcb9 	bl	80056c0 <LOS_SpinLockSave>
    swtmrCBId = swtmrId % KERNEL_SWTMR_LIMIT;
 8005d4e:	88fb      	ldrh	r3, [r7, #6]
 8005d50:	f003 030f 	and.w	r3, r3, #15
 8005d54:	817b      	strh	r3, [r7, #10]
    swtmr = g_swtmrCBArray + swtmrCBId;
 8005d56:	4b38      	ldr	r3, [pc, #224]	; (8005e38 <LOS_SwtmrStart+0x120>)
 8005d58:	6819      	ldr	r1, [r3, #0]
 8005d5a:	897a      	ldrh	r2, [r7, #10]
 8005d5c:	4613      	mov	r3, r2
 8005d5e:	00db      	lsls	r3, r3, #3
 8005d60:	4413      	add	r3, r2
 8005d62:	009b      	lsls	r3, r3, #2
 8005d64:	440b      	add	r3, r1
 8005d66:	617b      	str	r3, [r7, #20]

    if (swtmr->timerId != swtmrId) {
 8005d68:	697b      	ldr	r3, [r7, #20]
 8005d6a:	8a1b      	ldrh	r3, [r3, #16]
 8005d6c:	88fa      	ldrh	r2, [r7, #6]
 8005d6e:	429a      	cmp	r2, r3
 8005d70:	d006      	beq.n	8005d80 <LOS_SwtmrStart+0x68>
        SWTMR_UNLOCK(intSave);
 8005d72:	68fb      	ldr	r3, [r7, #12]
 8005d74:	4619      	mov	r1, r3
 8005d76:	482f      	ldr	r0, [pc, #188]	; (8005e34 <LOS_SwtmrStart+0x11c>)
 8005d78:	f7ff fcb0 	bl	80056dc <LOS_SpinUnlockRestore>
        return LOS_ERRNO_SWTMR_ID_INVALID;
 8005d7c:	4b2c      	ldr	r3, [pc, #176]	; (8005e30 <LOS_SwtmrStart+0x118>)
 8005d7e:	e049      	b.n	8005e14 <LOS_SwtmrStart+0xfc>
    }

    switch (swtmr->state) {
 8005d80:	697b      	ldr	r3, [r7, #20]
 8005d82:	7b1b      	ldrb	r3, [r3, #12]
 8005d84:	2b02      	cmp	r3, #2
 8005d86:	d009      	beq.n	8005d9c <LOS_SwtmrStart+0x84>
 8005d88:	2b02      	cmp	r3, #2
 8005d8a:	dc0e      	bgt.n	8005daa <LOS_SwtmrStart+0x92>
 8005d8c:	2b00      	cmp	r3, #0
 8005d8e:	d002      	beq.n	8005d96 <LOS_SwtmrStart+0x7e>
 8005d90:	2b01      	cmp	r3, #1
 8005d92:	d006      	beq.n	8005da2 <LOS_SwtmrStart+0x8a>
 8005d94:	e009      	b.n	8005daa <LOS_SwtmrStart+0x92>
        case OS_SWTMR_STATUS_UNUSED:
            ret = LOS_ERRNO_SWTMR_NOT_CREATED;
 8005d96:	4b29      	ldr	r3, [pc, #164]	; (8005e3c <LOS_SwtmrStart+0x124>)
 8005d98:	613b      	str	r3, [r7, #16]
            break;
 8005d9a:	e009      	b.n	8005db0 <LOS_SwtmrStart+0x98>
        /*
         * If the status of swtmr is timing, it should stop the swtmr first,
         * then start the swtmr again.
         */
        case OS_SWTMR_STATUS_TICKING:
            OsSwtmrStop(swtmr);
 8005d9c:	6978      	ldr	r0, [r7, #20]
 8005d9e:	f7ff fef9 	bl	8005b94 <OsSwtmrStop>
            /* fall-through */
        case OS_SWTMR_STATUS_CREATED:
            OsSwtmrStart(swtmr);
 8005da2:	6978      	ldr	r0, [r7, #20]
 8005da4:	f7ff fcb6 	bl	8005714 <OsSwtmrStart>
            break;
 8005da8:	e002      	b.n	8005db0 <LOS_SwtmrStart+0x98>
        default:
            ret = LOS_ERRNO_SWTMR_STATUS_INVALID;
 8005daa:	4b25      	ldr	r3, [pc, #148]	; (8005e40 <LOS_SwtmrStart+0x128>)
 8005dac:	613b      	str	r3, [r7, #16]
            break;
 8005dae:	bf00      	nop
    }

    SWTMR_UNLOCK(intSave);
 8005db0:	68fb      	ldr	r3, [r7, #12]
 8005db2:	4619      	mov	r1, r3
 8005db4:	481f      	ldr	r0, [pc, #124]	; (8005e34 <LOS_SwtmrStart+0x11c>)
 8005db6:	f7ff fc91 	bl	80056dc <LOS_SpinUnlockRestore>
    LOS_TRACE(SWTMR_START, swtmr->timerId, swtmr->mode, swtmr->overrun, swtmr->interval, swtmr->expiry);
 8005dba:	2300      	movs	r3, #0
 8005dbc:	61fb      	str	r3, [r7, #28]
 8005dbe:	697b      	ldr	r3, [r7, #20]
 8005dc0:	8a1b      	ldrh	r3, [r3, #16]
 8005dc2:	623b      	str	r3, [r7, #32]
 8005dc4:	697b      	ldr	r3, [r7, #20]
 8005dc6:	7b5b      	ldrb	r3, [r3, #13]
 8005dc8:	627b      	str	r3, [r7, #36]	; 0x24
 8005dca:	697b      	ldr	r3, [r7, #20]
 8005dcc:	7b9b      	ldrb	r3, [r3, #14]
 8005dce:	62bb      	str	r3, [r7, #40]	; 0x28
 8005dd0:	697b      	ldr	r3, [r7, #20]
 8005dd2:	695b      	ldr	r3, [r3, #20]
 8005dd4:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005dd6:	697b      	ldr	r3, [r7, #20]
 8005dd8:	699b      	ldr	r3, [r3, #24]
 8005dda:	633b      	str	r3, [r7, #48]	; 0x30
 8005ddc:	2306      	movs	r3, #6
 8005dde:	61bb      	str	r3, [r7, #24]
 8005de0:	69bb      	ldr	r3, [r7, #24]
 8005de2:	2b01      	cmp	r3, #1
 8005de4:	d915      	bls.n	8005e12 <LOS_SwtmrStart+0xfa>
 8005de6:	4b17      	ldr	r3, [pc, #92]	; (8005e44 <LOS_SwtmrStart+0x12c>)
 8005de8:	681b      	ldr	r3, [r3, #0]
 8005dea:	2b00      	cmp	r3, #0
 8005dec:	d011      	beq.n	8005e12 <LOS_SwtmrStart+0xfa>
 8005dee:	4b15      	ldr	r3, [pc, #84]	; (8005e44 <LOS_SwtmrStart+0x12c>)
 8005df0:	681c      	ldr	r4, [r3, #0]
 8005df2:	6a39      	ldr	r1, [r7, #32]
 8005df4:	69bb      	ldr	r3, [r7, #24]
 8005df6:	2b02      	cmp	r3, #2
 8005df8:	d904      	bls.n	8005e04 <LOS_SwtmrStart+0xec>
 8005dfa:	f107 031c 	add.w	r3, r7, #28
 8005dfe:	f103 0208 	add.w	r2, r3, #8
 8005e02:	e000      	b.n	8005e06 <LOS_SwtmrStart+0xee>
 8005e04:	2200      	movs	r2, #0
 8005e06:	69bb      	ldr	r3, [r7, #24]
 8005e08:	b29b      	uxth	r3, r3
 8005e0a:	3b02      	subs	r3, #2
 8005e0c:	b29b      	uxth	r3, r3
 8005e0e:	2082      	movs	r0, #130	; 0x82
 8005e10:	47a0      	blx	r4
    return ret;
 8005e12:	693b      	ldr	r3, [r7, #16]
}
 8005e14:	4a05      	ldr	r2, [pc, #20]	; (8005e2c <LOS_SwtmrStart+0x114>)
 8005e16:	6811      	ldr	r1, [r2, #0]
 8005e18:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8005e1a:	4051      	eors	r1, r2
 8005e1c:	d001      	beq.n	8005e22 <LOS_SwtmrStart+0x10a>
 8005e1e:	f7fe fbdd 	bl	80045dc <__stack_chk_fail>
 8005e22:	4618      	mov	r0, r3
 8005e24:	373c      	adds	r7, #60	; 0x3c
 8005e26:	46bd      	mov	sp, r7
 8005e28:	bd90      	pop	{r4, r7, pc}
 8005e2a:	bf00      	nop
 8005e2c:	0802036c 	.word	0x0802036c
 8005e30:	02000305 	.word	0x02000305
 8005e34:	200007a0 	.word	0x200007a0
 8005e38:	2000079c 	.word	0x2000079c
 8005e3c:	02000306 	.word	0x02000306
 8005e40:	0200030e 	.word	0x0200030e
 8005e44:	20000768 	.word	0x20000768

08005e48 <LOS_ListEmpty>:
{
 8005e48:	b480      	push	{r7}
 8005e4a:	b083      	sub	sp, #12
 8005e4c:	af00      	add	r7, sp, #0
 8005e4e:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8005e50:	687b      	ldr	r3, [r7, #4]
 8005e52:	685b      	ldr	r3, [r3, #4]
 8005e54:	687a      	ldr	r2, [r7, #4]
 8005e56:	429a      	cmp	r2, r3
 8005e58:	bf0c      	ite	eq
 8005e5a:	2301      	moveq	r3, #1
 8005e5c:	2300      	movne	r3, #0
 8005e5e:	b2db      	uxtb	r3, r3
}
 8005e60:	4618      	mov	r0, r3
 8005e62:	370c      	adds	r7, #12
 8005e64:	46bd      	mov	sp, r7
 8005e66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e6a:	4770      	bx	lr

08005e6c <LOS_IntLock>:
{
 8005e6c:	b580      	push	{r7, lr}
 8005e6e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8005e70:	f7fa ff2a 	bl	8000cc8 <ArchIntLock>
 8005e74:	4603      	mov	r3, r0
}
 8005e76:	4618      	mov	r0, r3
 8005e78:	bd80      	pop	{r7, pc}

08005e7a <LOS_IntRestore>:
{
 8005e7a:	b580      	push	{r7, lr}
 8005e7c:	b082      	sub	sp, #8
 8005e7e:	af00      	add	r7, sp, #0
 8005e80:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8005e82:	6878      	ldr	r0, [r7, #4]
 8005e84:	f7fa ff28 	bl	8000cd8 <ArchIntRestore>
}
 8005e88:	bf00      	nop
 8005e8a:	3708      	adds	r7, #8
 8005e8c:	46bd      	mov	sp, r7
 8005e8e:	bd80      	pop	{r7, pc}

08005e90 <LOS_SpinLockSave>:
{
 8005e90:	b580      	push	{r7, lr}
 8005e92:	b082      	sub	sp, #8
 8005e94:	af00      	add	r7, sp, #0
 8005e96:	6078      	str	r0, [r7, #4]
 8005e98:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8005e9a:	f7ff ffe7 	bl	8005e6c <LOS_IntLock>
 8005e9e:	4602      	mov	r2, r0
 8005ea0:	683b      	ldr	r3, [r7, #0]
 8005ea2:	601a      	str	r2, [r3, #0]
}
 8005ea4:	bf00      	nop
 8005ea6:	3708      	adds	r7, #8
 8005ea8:	46bd      	mov	sp, r7
 8005eaa:	bd80      	pop	{r7, pc}

08005eac <LOS_SpinUnlockRestore>:
{
 8005eac:	b580      	push	{r7, lr}
 8005eae:	b082      	sub	sp, #8
 8005eb0:	af00      	add	r7, sp, #0
 8005eb2:	6078      	str	r0, [r7, #4]
 8005eb4:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8005eb6:	6838      	ldr	r0, [r7, #0]
 8005eb8:	f7ff ffdf 	bl	8005e7a <LOS_IntRestore>
}
 8005ebc:	bf00      	nop
 8005ebe:	3708      	adds	r7, #8
 8005ec0:	46bd      	mov	sp, r7
 8005ec2:	bd80      	pop	{r7, pc}

08005ec4 <QueueCompareValue>:
    UINT64  lastAccessTime; /* The last access time */
} QueueDebugCB;
STATIC QueueDebugCB *g_queueDebugArray = NULL;

STATIC BOOL QueueCompareValue(const SortParam *sortParam, UINT32 left, UINT32 right)
{
 8005ec4:	b490      	push	{r4, r7}
 8005ec6:	b084      	sub	sp, #16
 8005ec8:	af00      	add	r7, sp, #0
 8005eca:	60f8      	str	r0, [r7, #12]
 8005ecc:	60b9      	str	r1, [r7, #8]
 8005ece:	607a      	str	r2, [r7, #4]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 8005ed0:	68fb      	ldr	r3, [r7, #12]
 8005ed2:	681a      	ldr	r2, [r3, #0]
 8005ed4:	68fb      	ldr	r3, [r7, #12]
 8005ed6:	685b      	ldr	r3, [r3, #4]
 8005ed8:	68b9      	ldr	r1, [r7, #8]
 8005eda:	fb01 f103 	mul.w	r1, r1, r3
 8005ede:	68fb      	ldr	r3, [r7, #12]
 8005ee0:	68db      	ldr	r3, [r3, #12]
 8005ee2:	440b      	add	r3, r1
 8005ee4:	4413      	add	r3, r2
 8005ee6:	e9d3 2300 	ldrd	r2, r3, [r3]
            *((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, right)));
 8005eea:	68f9      	ldr	r1, [r7, #12]
 8005eec:	6808      	ldr	r0, [r1, #0]
 8005eee:	68f9      	ldr	r1, [r7, #12]
 8005ef0:	6849      	ldr	r1, [r1, #4]
 8005ef2:	687c      	ldr	r4, [r7, #4]
 8005ef4:	fb04 f401 	mul.w	r4, r4, r1
 8005ef8:	68f9      	ldr	r1, [r7, #12]
 8005efa:	68c9      	ldr	r1, [r1, #12]
 8005efc:	4421      	add	r1, r4
 8005efe:	4401      	add	r1, r0
 8005f00:	e9d1 0100 	ldrd	r0, r1, [r1]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 8005f04:	4299      	cmp	r1, r3
 8005f06:	bf08      	it	eq
 8005f08:	4290      	cmpeq	r0, r2
 8005f0a:	bf34      	ite	cc
 8005f0c:	2301      	movcc	r3, #1
 8005f0e:	2300      	movcs	r3, #0
 8005f10:	b2db      	uxtb	r3, r3
}
 8005f12:	4618      	mov	r0, r3
 8005f14:	3710      	adds	r7, #16
 8005f16:	46bd      	mov	sp, r7
 8005f18:	bc90      	pop	{r4, r7}
 8005f1a:	4770      	bx	lr

08005f1c <OsQueueDbgInit>:

UINT32 OsQueueDbgInit(VOID)
{
 8005f1c:	b580      	push	{r7, lr}
 8005f1e:	b082      	sub	sp, #8
 8005f20:	af00      	add	r7, sp, #0
    UINT32 size = LOSCFG_BASE_IPC_QUEUE_LIMIT * sizeof(QueueDebugCB);
 8005f22:	23a0      	movs	r3, #160	; 0xa0
 8005f24:	607b      	str	r3, [r7, #4]

    /* system resident memory, don't free */
    g_queueDebugArray = (QueueDebugCB *)LOS_MemAlloc(m_aucSysMem1, size);
 8005f26:	4b11      	ldr	r3, [pc, #68]	; (8005f6c <OsQueueDbgInit+0x50>)
 8005f28:	681b      	ldr	r3, [r3, #0]
 8005f2a:	6879      	ldr	r1, [r7, #4]
 8005f2c:	4618      	mov	r0, r3
 8005f2e:	f003 fa71 	bl	8009414 <LOS_MemAlloc>
 8005f32:	4603      	mov	r3, r0
 8005f34:	4a0e      	ldr	r2, [pc, #56]	; (8005f70 <OsQueueDbgInit+0x54>)
 8005f36:	6013      	str	r3, [r2, #0]
    if (g_queueDebugArray == NULL) {
 8005f38:	4b0d      	ldr	r3, [pc, #52]	; (8005f70 <OsQueueDbgInit+0x54>)
 8005f3a:	681b      	ldr	r3, [r3, #0]
 8005f3c:	2b00      	cmp	r3, #0
 8005f3e:	d108      	bne.n	8005f52 <OsQueueDbgInit+0x36>
        PRINT_ERR("%s: malloc failed!\n", __FUNCTION__);
 8005f40:	480c      	ldr	r0, [pc, #48]	; (8005f74 <OsQueueDbgInit+0x58>)
 8005f42:	f7fe fcbd 	bl	80048c0 <dprintf>
 8005f46:	490c      	ldr	r1, [pc, #48]	; (8005f78 <OsQueueDbgInit+0x5c>)
 8005f48:	480c      	ldr	r0, [pc, #48]	; (8005f7c <OsQueueDbgInit+0x60>)
 8005f4a:	f7fe fcb9 	bl	80048c0 <dprintf>
        return LOS_NOK;
 8005f4e:	2301      	movs	r3, #1
 8005f50:	e007      	b.n	8005f62 <OsQueueDbgInit+0x46>
    }
    (VOID)memset_s(g_queueDebugArray, size, 0, size);
 8005f52:	4b07      	ldr	r3, [pc, #28]	; (8005f70 <OsQueueDbgInit+0x54>)
 8005f54:	6818      	ldr	r0, [r3, #0]
 8005f56:	687b      	ldr	r3, [r7, #4]
 8005f58:	2200      	movs	r2, #0
 8005f5a:	6879      	ldr	r1, [r7, #4]
 8005f5c:	f7fc f8a2 	bl	80020a4 <memset_s>
    return LOS_OK;
 8005f60:	2300      	movs	r3, #0
}
 8005f62:	4618      	mov	r0, r3
 8005f64:	3708      	adds	r7, #8
 8005f66:	46bd      	mov	sp, r7
 8005f68:	bd80      	pop	{r7, pc}
 8005f6a:	bf00      	nop
 8005f6c:	200021c0 	.word	0x200021c0
 8005f70:	200007a4 	.word	0x200007a4
 8005f74:	0802037c 	.word	0x0802037c
 8005f78:	08023300 	.word	0x08023300
 8005f7c:	08020384 	.word	0x08020384

08005f80 <OsQueueDbgTimeUpdate>:

VOID OsQueueDbgTimeUpdate(UINT32 queueId)
{
 8005f80:	b580      	push	{r7, lr}
 8005f82:	b084      	sub	sp, #16
 8005f84:	af00      	add	r7, sp, #0
 8005f86:	6078      	str	r0, [r7, #4]
    QueueDebugCB *queueDebug = &g_queueDebugArray[GET_QUEUE_INDEX(queueId)];
 8005f88:	4b08      	ldr	r3, [pc, #32]	; (8005fac <OsQueueDbgTimeUpdate+0x2c>)
 8005f8a:	681a      	ldr	r2, [r3, #0]
 8005f8c:	687b      	ldr	r3, [r7, #4]
 8005f8e:	b29b      	uxth	r3, r3
 8005f90:	011b      	lsls	r3, r3, #4
 8005f92:	4413      	add	r3, r2
 8005f94:	60fb      	str	r3, [r7, #12]
    queueDebug->lastAccessTime = LOS_TickCountGet();
 8005f96:	f7fe f9e9 	bl	800436c <LOS_TickCountGet>
 8005f9a:	4602      	mov	r2, r0
 8005f9c:	460b      	mov	r3, r1
 8005f9e:	68f9      	ldr	r1, [r7, #12]
 8005fa0:	e9c1 2302 	strd	r2, r3, [r1, #8]
    return;
 8005fa4:	bf00      	nop
}
 8005fa6:	3710      	adds	r7, #16
 8005fa8:	46bd      	mov	sp, r7
 8005faa:	bd80      	pop	{r7, pc}
 8005fac:	200007a4 	.word	0x200007a4

08005fb0 <OsQueueDbgUpdate>:

VOID OsQueueDbgUpdate(UINT32 queueId, TSK_ENTRY_FUNC entry)
{
 8005fb0:	b580      	push	{r7, lr}
 8005fb2:	b084      	sub	sp, #16
 8005fb4:	af00      	add	r7, sp, #0
 8005fb6:	6078      	str	r0, [r7, #4]
 8005fb8:	6039      	str	r1, [r7, #0]
    QueueDebugCB *queueDebug = &g_queueDebugArray[GET_QUEUE_INDEX(queueId)];
 8005fba:	4b0a      	ldr	r3, [pc, #40]	; (8005fe4 <OsQueueDbgUpdate+0x34>)
 8005fbc:	681a      	ldr	r2, [r3, #0]
 8005fbe:	687b      	ldr	r3, [r7, #4]
 8005fc0:	b29b      	uxth	r3, r3
 8005fc2:	011b      	lsls	r3, r3, #4
 8005fc4:	4413      	add	r3, r2
 8005fc6:	60fb      	str	r3, [r7, #12]
    queueDebug->creator = entry;
 8005fc8:	68fb      	ldr	r3, [r7, #12]
 8005fca:	683a      	ldr	r2, [r7, #0]
 8005fcc:	601a      	str	r2, [r3, #0]
    queueDebug->lastAccessTime = LOS_TickCountGet();
 8005fce:	f7fe f9cd 	bl	800436c <LOS_TickCountGet>
 8005fd2:	4602      	mov	r2, r0
 8005fd4:	460b      	mov	r3, r1
 8005fd6:	68f9      	ldr	r1, [r7, #12]
 8005fd8:	e9c1 2302 	strd	r2, r3, [r1, #8]
    return;
 8005fdc:	bf00      	nop
}
 8005fde:	3710      	adds	r7, #16
 8005fe0:	46bd      	mov	sp, r7
 8005fe2:	bd80      	pop	{r7, pc}
 8005fe4:	200007a4 	.word	0x200007a4

08005fe8 <OsQueueInfoOutPut>:

STATIC INLINE VOID OsQueueInfoOutPut(const LosQueueCB *node)
{
 8005fe8:	b580      	push	{r7, lr}
 8005fea:	b084      	sub	sp, #16
 8005fec:	af02      	add	r7, sp, #8
 8005fee:	6078      	str	r0, [r7, #4]
    PRINTK("Queue ID <0x%x> may leak, queue len is 0x%x, "
 8005ff0:	687b      	ldr	r3, [r7, #4]
 8005ff2:	68d9      	ldr	r1, [r3, #12]
 8005ff4:	687b      	ldr	r3, [r7, #4]
 8005ff6:	88db      	ldrh	r3, [r3, #6]
 8005ff8:	461a      	mov	r2, r3
 8005ffa:	687b      	ldr	r3, [r7, #4]
 8005ffc:	8a9b      	ldrh	r3, [r3, #20]
 8005ffe:	4618      	mov	r0, r3
 8006000:	687b      	ldr	r3, [r7, #4]
 8006002:	8adb      	ldrh	r3, [r3, #22]
 8006004:	9300      	str	r3, [sp, #0]
 8006006:	4603      	mov	r3, r0
 8006008:	4803      	ldr	r0, [pc, #12]	; (8006018 <OsQueueInfoOutPut+0x30>)
 800600a:	f7fe fc59 	bl	80048c0 <dprintf>
           "readable cnt:0x%x, writeable cnt:0x%x, ",
           node->queueId,
           node->queueLen,
           node->readWriteableCnt[OS_QUEUE_READ],
           node->readWriteableCnt[OS_QUEUE_WRITE]);
}
 800600e:	bf00      	nop
 8006010:	3708      	adds	r7, #8
 8006012:	46bd      	mov	sp, r7
 8006014:	bd80      	pop	{r7, pc}
 8006016:	bf00      	nop
 8006018:	08020398 	.word	0x08020398

0800601c <OsQueueOpsOutput>:

STATIC INLINE VOID OsQueueOpsOutput(const QueueDebugCB *node)
{
 800601c:	b580      	push	{r7, lr}
 800601e:	b082      	sub	sp, #8
 8006020:	af00      	add	r7, sp, #0
 8006022:	6078      	str	r0, [r7, #4]
    PRINTK("TaskEntry of creator:0x%p, Latest operation time: 0x%llx\n",
 8006024:	687b      	ldr	r3, [r7, #4]
 8006026:	6819      	ldr	r1, [r3, #0]
 8006028:	687b      	ldr	r3, [r7, #4]
 800602a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800602e:	4803      	ldr	r0, [pc, #12]	; (800603c <OsQueueOpsOutput+0x20>)
 8006030:	f7fe fc46 	bl	80048c0 <dprintf>
           node->creator, node->lastAccessTime);
}
 8006034:	bf00      	nop
 8006036:	3708      	adds	r7, #8
 8006038:	46bd      	mov	sp, r7
 800603a:	bd80      	pop	{r7, pc}
 800603c:	080203f0 	.word	0x080203f0

08006040 <SortQueueIndexArray>:

STATIC VOID SortQueueIndexArray(UINT32 *indexArray, UINT32 count)
{
 8006040:	b580      	push	{r7, lr}
 8006042:	b09c      	sub	sp, #112	; 0x70
 8006044:	af02      	add	r7, sp, #8
 8006046:	6078      	str	r0, [r7, #4]
 8006048:	6039      	str	r1, [r7, #0]
 800604a:	4b46      	ldr	r3, [pc, #280]	; (8006164 <SortQueueIndexArray+0x124>)
 800604c:	681b      	ldr	r3, [r3, #0]
 800604e:	667b      	str	r3, [r7, #100]	; 0x64
 8006050:	f04f 0300 	mov.w	r3, #0
    LosQueueCB queueNode = {0};
 8006054:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8006058:	2230      	movs	r2, #48	; 0x30
 800605a:	2100      	movs	r1, #0
 800605c:	4618      	mov	r0, r3
 800605e:	f009 f953 	bl	800f308 <memset>
    QueueDebugCB queueDebugNode = {0};
 8006062:	f107 0310 	add.w	r3, r7, #16
 8006066:	2200      	movs	r2, #0
 8006068:	601a      	str	r2, [r3, #0]
 800606a:	605a      	str	r2, [r3, #4]
 800606c:	609a      	str	r2, [r3, #8]
 800606e:	60da      	str	r2, [r3, #12]
    UINT32 index, intSave;
    SortParam queueSortParam;
    queueSortParam.buf = (CHAR *)g_queueDebugArray;
 8006070:	4b3d      	ldr	r3, [pc, #244]	; (8006168 <SortQueueIndexArray+0x128>)
 8006072:	681b      	ldr	r3, [r3, #0]
 8006074:	627b      	str	r3, [r7, #36]	; 0x24
    queueSortParam.ctrlBlockSize = sizeof(QueueDebugCB);
 8006076:	2310      	movs	r3, #16
 8006078:	62bb      	str	r3, [r7, #40]	; 0x28
    queueSortParam.ctrlBlockCnt = LOSCFG_BASE_IPC_QUEUE_LIMIT;
 800607a:	230a      	movs	r3, #10
 800607c:	62fb      	str	r3, [r7, #44]	; 0x2c
    queueSortParam.sortElemOff = LOS_OFF_SET_OF(QueueDebugCB, lastAccessTime);
 800607e:	2308      	movs	r3, #8
 8006080:	633b      	str	r3, [r7, #48]	; 0x30

    if (count > 0) {
 8006082:	683b      	ldr	r3, [r7, #0]
 8006084:	2b00      	cmp	r3, #0
 8006086:	d05b      	beq.n	8006140 <SortQueueIndexArray+0x100>
        SCHEDULER_LOCK(intSave);
 8006088:	f107 0308 	add.w	r3, r7, #8
 800608c:	4619      	mov	r1, r3
 800608e:	4837      	ldr	r0, [pc, #220]	; (800616c <SortQueueIndexArray+0x12c>)
 8006090:	f7ff fefe 	bl	8005e90 <LOS_SpinLockSave>
        OsArraySort(indexArray, 0, count - 1, &queueSortParam, QueueCompareValue);
 8006094:	683b      	ldr	r3, [r7, #0]
 8006096:	1e5a      	subs	r2, r3, #1
 8006098:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800609c:	4934      	ldr	r1, [pc, #208]	; (8006170 <SortQueueIndexArray+0x130>)
 800609e:	9100      	str	r1, [sp, #0]
 80060a0:	2100      	movs	r1, #0
 80060a2:	6878      	ldr	r0, [r7, #4]
 80060a4:	f7fc fc1a 	bl	80028dc <OsArraySort>
        SCHEDULER_UNLOCK(intSave);
 80060a8:	68bb      	ldr	r3, [r7, #8]
 80060aa:	4619      	mov	r1, r3
 80060ac:	482f      	ldr	r0, [pc, #188]	; (800616c <SortQueueIndexArray+0x12c>)
 80060ae:	f7ff fefd 	bl	8005eac <LOS_SpinUnlockRestore>
        for (index = 0; index < count; index++) {
 80060b2:	2300      	movs	r3, #0
 80060b4:	60fb      	str	r3, [r7, #12]
 80060b6:	e03f      	b.n	8006138 <SortQueueIndexArray+0xf8>
            SCHEDULER_LOCK(intSave);
 80060b8:	f107 0308 	add.w	r3, r7, #8
 80060bc:	4619      	mov	r1, r3
 80060be:	482b      	ldr	r0, [pc, #172]	; (800616c <SortQueueIndexArray+0x12c>)
 80060c0:	f7ff fee6 	bl	8005e90 <LOS_SpinLockSave>
            (VOID)memcpy_s(&queueNode, sizeof(LosQueueCB),
 80060c4:	4b2b      	ldr	r3, [pc, #172]	; (8006174 <SortQueueIndexArray+0x134>)
 80060c6:	6819      	ldr	r1, [r3, #0]
                           GET_QUEUE_HANDLE(indexArray[index]), sizeof(LosQueueCB));
 80060c8:	68fb      	ldr	r3, [r7, #12]
 80060ca:	009b      	lsls	r3, r3, #2
 80060cc:	687a      	ldr	r2, [r7, #4]
 80060ce:	4413      	add	r3, r2
 80060d0:	681b      	ldr	r3, [r3, #0]
 80060d2:	b29a      	uxth	r2, r3
 80060d4:	4613      	mov	r3, r2
 80060d6:	005b      	lsls	r3, r3, #1
 80060d8:	4413      	add	r3, r2
 80060da:	011b      	lsls	r3, r3, #4
 80060dc:	18ca      	adds	r2, r1, r3
            (VOID)memcpy_s(&queueNode, sizeof(LosQueueCB),
 80060de:	f107 0034 	add.w	r0, r7, #52	; 0x34
 80060e2:	2330      	movs	r3, #48	; 0x30
 80060e4:	2130      	movs	r1, #48	; 0x30
 80060e6:	f010 ffd7 	bl	8017098 <memcpy_s>
            (VOID)memcpy_s(&queueDebugNode, sizeof(QueueDebugCB),
 80060ea:	4b1f      	ldr	r3, [pc, #124]	; (8006168 <SortQueueIndexArray+0x128>)
 80060ec:	681a      	ldr	r2, [r3, #0]
                           &g_queueDebugArray[indexArray[index]], sizeof(QueueDebugCB));
 80060ee:	68fb      	ldr	r3, [r7, #12]
 80060f0:	009b      	lsls	r3, r3, #2
 80060f2:	6879      	ldr	r1, [r7, #4]
 80060f4:	440b      	add	r3, r1
 80060f6:	681b      	ldr	r3, [r3, #0]
 80060f8:	011b      	lsls	r3, r3, #4
 80060fa:	441a      	add	r2, r3
            (VOID)memcpy_s(&queueDebugNode, sizeof(QueueDebugCB),
 80060fc:	f107 0010 	add.w	r0, r7, #16
 8006100:	2310      	movs	r3, #16
 8006102:	2110      	movs	r1, #16
 8006104:	f010 ffc8 	bl	8017098 <memcpy_s>
            SCHEDULER_UNLOCK(intSave);
 8006108:	68bb      	ldr	r3, [r7, #8]
 800610a:	4619      	mov	r1, r3
 800610c:	4817      	ldr	r0, [pc, #92]	; (800616c <SortQueueIndexArray+0x12c>)
 800610e:	f7ff fecd 	bl	8005eac <LOS_SpinUnlockRestore>
            if (queueNode.queueState == LOS_UNUSED) {
 8006112:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8006116:	2b00      	cmp	r3, #0
 8006118:	d00a      	beq.n	8006130 <SortQueueIndexArray+0xf0>
                continue;
            }
            OsQueueInfoOutPut(&queueNode);
 800611a:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800611e:	4618      	mov	r0, r3
 8006120:	f7ff ff62 	bl	8005fe8 <OsQueueInfoOutPut>
            OsQueueOpsOutput(&queueDebugNode);
 8006124:	f107 0310 	add.w	r3, r7, #16
 8006128:	4618      	mov	r0, r3
 800612a:	f7ff ff77 	bl	800601c <OsQueueOpsOutput>
 800612e:	e000      	b.n	8006132 <SortQueueIndexArray+0xf2>
                continue;
 8006130:	bf00      	nop
        for (index = 0; index < count; index++) {
 8006132:	68fb      	ldr	r3, [r7, #12]
 8006134:	3301      	adds	r3, #1
 8006136:	60fb      	str	r3, [r7, #12]
 8006138:	68fa      	ldr	r2, [r7, #12]
 800613a:	683b      	ldr	r3, [r7, #0]
 800613c:	429a      	cmp	r2, r3
 800613e:	d3bb      	bcc.n	80060b8 <SortQueueIndexArray+0x78>
        }
    }
    (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, indexArray);
 8006140:	4b0d      	ldr	r3, [pc, #52]	; (8006178 <SortQueueIndexArray+0x138>)
 8006142:	681b      	ldr	r3, [r3, #0]
 8006144:	6879      	ldr	r1, [r7, #4]
 8006146:	4618      	mov	r0, r3
 8006148:	f003 fa1c 	bl	8009584 <LOS_MemFree>
}
 800614c:	bf00      	nop
 800614e:	4b05      	ldr	r3, [pc, #20]	; (8006164 <SortQueueIndexArray+0x124>)
 8006150:	681a      	ldr	r2, [r3, #0]
 8006152:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006154:	405a      	eors	r2, r3
 8006156:	d001      	beq.n	800615c <SortQueueIndexArray+0x11c>
 8006158:	f7fe fa40 	bl	80045dc <__stack_chk_fail>
 800615c:	3768      	adds	r7, #104	; 0x68
 800615e:	46bd      	mov	sp, r7
 8006160:	bd80      	pop	{r7, pc}
 8006162:	bf00      	nop
 8006164:	0802042c 	.word	0x0802042c
 8006168:	200007a4 	.word	0x200007a4
 800616c:	20000770 	.word	0x20000770
 8006170:	08005ec5 	.word	0x08005ec5
 8006174:	200021c4 	.word	0x200021c4
 8006178:	080001f0 	.word	0x080001f0

0800617c <OsQueueCheck>:

VOID OsQueueCheck(VOID)
{
 800617c:	b580      	push	{r7, lr}
 800617e:	b096      	sub	sp, #88	; 0x58
 8006180:	af00      	add	r7, sp, #0
 8006182:	4b57      	ldr	r3, [pc, #348]	; (80062e0 <OsQueueCheck+0x164>)
 8006184:	681b      	ldr	r3, [r3, #0]
 8006186:	657b      	str	r3, [r7, #84]	; 0x54
 8006188:	f04f 0300 	mov.w	r3, #0
    LosQueueCB queueNode = {0};
 800618c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8006190:	2230      	movs	r2, #48	; 0x30
 8006192:	2100      	movs	r1, #0
 8006194:	4618      	mov	r0, r3
 8006196:	f009 f8b7 	bl	800f308 <memset>
    QueueDebugCB queueDebugNode = {0};
 800619a:	f107 0310 	add.w	r3, r7, #16
 800619e:	2200      	movs	r2, #0
 80061a0:	601a      	str	r2, [r3, #0]
 80061a2:	605a      	str	r2, [r3, #4]
 80061a4:	609a      	str	r2, [r3, #8]
 80061a6:	60da      	str	r2, [r3, #12]
    UINT32 index, intSave;
    UINT32 count = 0;
 80061a8:	2300      	movs	r3, #0
 80061aa:	60bb      	str	r3, [r7, #8]
    /*
     * This return value does not need to be judged immediately,
     * and the following code logic has already distinguished the return value from null and non-empty,
     * and there is no case of accessing the null pointer.
     */
    UINT32 *indexArray = (UINT32 *)LOS_MemAlloc((VOID *)OS_SYS_MEM_ADDR, LOSCFG_BASE_IPC_QUEUE_LIMIT * sizeof(UINT32));
 80061ac:	4b4d      	ldr	r3, [pc, #308]	; (80062e4 <OsQueueCheck+0x168>)
 80061ae:	681b      	ldr	r3, [r3, #0]
 80061b0:	2128      	movs	r1, #40	; 0x28
 80061b2:	4618      	mov	r0, r3
 80061b4:	f003 f92e 	bl	8009414 <LOS_MemAlloc>
 80061b8:	60f8      	str	r0, [r7, #12]

    for (index = 0; index < LOSCFG_BASE_IPC_QUEUE_LIMIT; index++) {
 80061ba:	2300      	movs	r3, #0
 80061bc:	607b      	str	r3, [r7, #4]
 80061be:	e079      	b.n	80062b4 <OsQueueCheck+0x138>
        SCHEDULER_LOCK(intSave);
 80061c0:	463b      	mov	r3, r7
 80061c2:	4619      	mov	r1, r3
 80061c4:	4848      	ldr	r0, [pc, #288]	; (80062e8 <OsQueueCheck+0x16c>)
 80061c6:	f7ff fe63 	bl	8005e90 <LOS_SpinLockSave>
        (VOID)memcpy_s(&queueNode, sizeof(LosQueueCB),
 80061ca:	4b48      	ldr	r3, [pc, #288]	; (80062ec <OsQueueCheck+0x170>)
 80061cc:	6819      	ldr	r1, [r3, #0]
                       GET_QUEUE_HANDLE(index), sizeof(LosQueueCB));
 80061ce:	687b      	ldr	r3, [r7, #4]
 80061d0:	b29a      	uxth	r2, r3
 80061d2:	4613      	mov	r3, r2
 80061d4:	005b      	lsls	r3, r3, #1
 80061d6:	4413      	add	r3, r2
 80061d8:	011b      	lsls	r3, r3, #4
 80061da:	18ca      	adds	r2, r1, r3
        (VOID)memcpy_s(&queueNode, sizeof(LosQueueCB),
 80061dc:	f107 0024 	add.w	r0, r7, #36	; 0x24
 80061e0:	2330      	movs	r3, #48	; 0x30
 80061e2:	2130      	movs	r1, #48	; 0x30
 80061e4:	f010 ff58 	bl	8017098 <memcpy_s>
        (VOID)memcpy_s(&queueDebugNode, sizeof(QueueDebugCB),
 80061e8:	4b41      	ldr	r3, [pc, #260]	; (80062f0 <OsQueueCheck+0x174>)
 80061ea:	681a      	ldr	r2, [r3, #0]
                       &g_queueDebugArray[index], sizeof(QueueDebugCB));
 80061ec:	687b      	ldr	r3, [r7, #4]
 80061ee:	011b      	lsls	r3, r3, #4
 80061f0:	441a      	add	r2, r3
        (VOID)memcpy_s(&queueDebugNode, sizeof(QueueDebugCB),
 80061f2:	f107 0010 	add.w	r0, r7, #16
 80061f6:	2310      	movs	r3, #16
 80061f8:	2110      	movs	r1, #16
 80061fa:	f010 ff4d 	bl	8017098 <memcpy_s>
        SCHEDULER_UNLOCK(intSave);
 80061fe:	683b      	ldr	r3, [r7, #0]
 8006200:	4619      	mov	r1, r3
 8006202:	4839      	ldr	r0, [pc, #228]	; (80062e8 <OsQueueCheck+0x16c>)
 8006204:	f7ff fe52 	bl	8005eac <LOS_SpinUnlockRestore>
        if ((queueNode.queueState == LOS_UNUSED) ||
 8006208:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800620c:	2b00      	cmp	r3, #0
 800620e:	d04d      	beq.n	80062ac <OsQueueCheck+0x130>
            ((queueNode.queueState == LOS_USED) && (queueDebugNode.creator == NULL))) {
 8006210:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
        if ((queueNode.queueState == LOS_UNUSED) ||
 8006214:	2b01      	cmp	r3, #1
 8006216:	d102      	bne.n	800621e <OsQueueCheck+0xa2>
            ((queueNode.queueState == LOS_USED) && (queueDebugNode.creator == NULL))) {
 8006218:	693b      	ldr	r3, [r7, #16]
 800621a:	2b00      	cmp	r3, #0
 800621c:	d046      	beq.n	80062ac <OsQueueCheck+0x130>
            continue;
        }
        if ((queueNode.queueState == LOS_USED) &&
 800621e:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8006222:	2b01      	cmp	r3, #1
 8006224:	d12a      	bne.n	800627c <OsQueueCheck+0x100>
            (queueNode.queueLen == queueNode.readWriteableCnt[OS_QUEUE_WRITE]) &&
 8006226:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 8006228:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
        if ((queueNode.queueState == LOS_USED) &&
 800622a:	429a      	cmp	r2, r3
 800622c:	d126      	bne.n	800627c <OsQueueCheck+0x100>
            LOS_ListEmpty(&queueNode.readWriteList[OS_QUEUE_READ]) &&
 800622e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8006232:	3318      	adds	r3, #24
 8006234:	4618      	mov	r0, r3
 8006236:	f7ff fe07 	bl	8005e48 <LOS_ListEmpty>
 800623a:	4603      	mov	r3, r0
            (queueNode.queueLen == queueNode.readWriteableCnt[OS_QUEUE_WRITE]) &&
 800623c:	2b00      	cmp	r3, #0
 800623e:	d01d      	beq.n	800627c <OsQueueCheck+0x100>
            LOS_ListEmpty(&queueNode.readWriteList[OS_QUEUE_WRITE]) &&
 8006240:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8006244:	3320      	adds	r3, #32
 8006246:	4618      	mov	r0, r3
 8006248:	f7ff fdfe 	bl	8005e48 <LOS_ListEmpty>
 800624c:	4603      	mov	r3, r0
            LOS_ListEmpty(&queueNode.readWriteList[OS_QUEUE_READ]) &&
 800624e:	2b00      	cmp	r3, #0
 8006250:	d014      	beq.n	800627c <OsQueueCheck+0x100>
            LOS_ListEmpty(&queueNode.memList)) {
 8006252:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8006256:	3328      	adds	r3, #40	; 0x28
 8006258:	4618      	mov	r0, r3
 800625a:	f7ff fdf5 	bl	8005e48 <LOS_ListEmpty>
 800625e:	4603      	mov	r3, r0
            LOS_ListEmpty(&queueNode.readWriteList[OS_QUEUE_WRITE]) &&
 8006260:	2b00      	cmp	r3, #0
 8006262:	d00b      	beq.n	800627c <OsQueueCheck+0x100>
            PRINTK("Queue ID <0x%x> may leak, No task uses it, "
 8006264:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006266:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 8006268:	4619      	mov	r1, r3
 800626a:	4822      	ldr	r0, [pc, #136]	; (80062f4 <OsQueueCheck+0x178>)
 800626c:	f7fe fb28 	bl	80048c0 <dprintf>
                   "QueueLen is 0x%x, ",
                   queueNode.queueId,
                   queueNode.queueLen);
            OsQueueOpsOutput(&queueDebugNode);
 8006270:	f107 0310 	add.w	r3, r7, #16
 8006274:	4618      	mov	r0, r3
 8006276:	f7ff fed1 	bl	800601c <OsQueueOpsOutput>
 800627a:	e018      	b.n	80062ae <OsQueueCheck+0x132>
        } else {
            if (indexArray != NULL) {
 800627c:	68fb      	ldr	r3, [r7, #12]
 800627e:	2b00      	cmp	r3, #0
 8006280:	d009      	beq.n	8006296 <OsQueueCheck+0x11a>
                *(indexArray + count) = index;
 8006282:	68bb      	ldr	r3, [r7, #8]
 8006284:	009b      	lsls	r3, r3, #2
 8006286:	68fa      	ldr	r2, [r7, #12]
 8006288:	4413      	add	r3, r2
 800628a:	687a      	ldr	r2, [r7, #4]
 800628c:	601a      	str	r2, [r3, #0]
                count++;
 800628e:	68bb      	ldr	r3, [r7, #8]
 8006290:	3301      	adds	r3, #1
 8006292:	60bb      	str	r3, [r7, #8]
 8006294:	e00b      	b.n	80062ae <OsQueueCheck+0x132>
            } else {
                OsQueueInfoOutPut(&queueNode);
 8006296:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800629a:	4618      	mov	r0, r3
 800629c:	f7ff fea4 	bl	8005fe8 <OsQueueInfoOutPut>
                OsQueueOpsOutput(&queueDebugNode);
 80062a0:	f107 0310 	add.w	r3, r7, #16
 80062a4:	4618      	mov	r0, r3
 80062a6:	f7ff feb9 	bl	800601c <OsQueueOpsOutput>
 80062aa:	e000      	b.n	80062ae <OsQueueCheck+0x132>
            continue;
 80062ac:	bf00      	nop
    for (index = 0; index < LOSCFG_BASE_IPC_QUEUE_LIMIT; index++) {
 80062ae:	687b      	ldr	r3, [r7, #4]
 80062b0:	3301      	adds	r3, #1
 80062b2:	607b      	str	r3, [r7, #4]
 80062b4:	687b      	ldr	r3, [r7, #4]
 80062b6:	2b09      	cmp	r3, #9
 80062b8:	d982      	bls.n	80061c0 <OsQueueCheck+0x44>
            }
        }
    }

    if (indexArray != NULL) {
 80062ba:	68fb      	ldr	r3, [r7, #12]
 80062bc:	2b00      	cmp	r3, #0
 80062be:	d004      	beq.n	80062ca <OsQueueCheck+0x14e>
        SortQueueIndexArray(indexArray, count);
 80062c0:	68b9      	ldr	r1, [r7, #8]
 80062c2:	68f8      	ldr	r0, [r7, #12]
 80062c4:	f7ff febc 	bl	8006040 <SortQueueIndexArray>
    }

    return;
 80062c8:	bf00      	nop
 80062ca:	bf00      	nop
}
 80062cc:	4b04      	ldr	r3, [pc, #16]	; (80062e0 <OsQueueCheck+0x164>)
 80062ce:	681a      	ldr	r2, [r3, #0]
 80062d0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80062d2:	405a      	eors	r2, r3
 80062d4:	d001      	beq.n	80062da <OsQueueCheck+0x15e>
 80062d6:	f7fe f981 	bl	80045dc <__stack_chk_fail>
 80062da:	3758      	adds	r7, #88	; 0x58
 80062dc:	46bd      	mov	sp, r7
 80062de:	bd80      	pop	{r7, pc}
 80062e0:	08020470 	.word	0x08020470
 80062e4:	080001f0 	.word	0x080001f0
 80062e8:	20000770 	.word	0x20000770
 80062ec:	200021c4 	.word	0x200021c4
 80062f0:	200007a4 	.word	0x200007a4
 80062f4:	08020430 	.word	0x08020430

080062f8 <OsShellCmdQueueInfoGet>:

#ifdef LOSCFG_SHELL
LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdQueueInfoGet(UINT32 argc, const CHAR **argv)
{
 80062f8:	b580      	push	{r7, lr}
 80062fa:	b082      	sub	sp, #8
 80062fc:	af00      	add	r7, sp, #0
 80062fe:	6078      	str	r0, [r7, #4]
 8006300:	6039      	str	r1, [r7, #0]
    if (argc > 0) {
 8006302:	687b      	ldr	r3, [r7, #4]
 8006304:	2b00      	cmp	r3, #0
 8006306:	d005      	beq.n	8006314 <OsShellCmdQueueInfoGet+0x1c>
        PRINTK("\nUsage: queue\n");
 8006308:	4807      	ldr	r0, [pc, #28]	; (8006328 <OsShellCmdQueueInfoGet+0x30>)
 800630a:	f7fe fad9 	bl	80048c0 <dprintf>
        return OS_ERROR;
 800630e:	f04f 33ff 	mov.w	r3, #4294967295
 8006312:	e005      	b.n	8006320 <OsShellCmdQueueInfoGet+0x28>
    }
    PRINTK("used queues information: \n");
 8006314:	4805      	ldr	r0, [pc, #20]	; (800632c <OsShellCmdQueueInfoGet+0x34>)
 8006316:	f7fe fad3 	bl	80048c0 <dprintf>
    OsQueueCheck();
 800631a:	f7ff ff2f 	bl	800617c <OsQueueCheck>
    return LOS_OK;
 800631e:	2300      	movs	r3, #0
}
 8006320:	4618      	mov	r0, r3
 8006322:	3708      	adds	r7, #8
 8006324:	46bd      	mov	sp, r7
 8006326:	bd80      	pop	{r7, pc}
 8006328:	08020474 	.word	0x08020474
 800632c:	08020484 	.word	0x08020484

08006330 <LOS_IntLock>:
{
 8006330:	b580      	push	{r7, lr}
 8006332:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8006334:	f7fa fcc8 	bl	8000cc8 <ArchIntLock>
 8006338:	4603      	mov	r3, r0
}
 800633a:	4618      	mov	r0, r3
 800633c:	bd80      	pop	{r7, pc}

0800633e <LOS_IntRestore>:
{
 800633e:	b580      	push	{r7, lr}
 8006340:	b082      	sub	sp, #8
 8006342:	af00      	add	r7, sp, #0
 8006344:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8006346:	6878      	ldr	r0, [r7, #4]
 8006348:	f7fa fcc6 	bl	8000cd8 <ArchIntRestore>
}
 800634c:	bf00      	nop
 800634e:	3708      	adds	r7, #8
 8006350:	46bd      	mov	sp, r7
 8006352:	bd80      	pop	{r7, pc}

08006354 <LOS_SpinLockSave>:
{
 8006354:	b580      	push	{r7, lr}
 8006356:	b082      	sub	sp, #8
 8006358:	af00      	add	r7, sp, #0
 800635a:	6078      	str	r0, [r7, #4]
 800635c:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 800635e:	f7ff ffe7 	bl	8006330 <LOS_IntLock>
 8006362:	4602      	mov	r2, r0
 8006364:	683b      	ldr	r3, [r7, #0]
 8006366:	601a      	str	r2, [r3, #0]
}
 8006368:	bf00      	nop
 800636a:	3708      	adds	r7, #8
 800636c:	46bd      	mov	sp, r7
 800636e:	bd80      	pop	{r7, pc}

08006370 <LOS_SpinUnlockRestore>:
{
 8006370:	b580      	push	{r7, lr}
 8006372:	b082      	sub	sp, #8
 8006374:	af00      	add	r7, sp, #0
 8006376:	6078      	str	r0, [r7, #4]
 8006378:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 800637a:	6838      	ldr	r0, [r7, #0]
 800637c:	f7ff ffdf 	bl	800633e <LOS_IntRestore>
}
 8006380:	bf00      	nop
 8006382:	3708      	adds	r7, #8
 8006384:	46bd      	mov	sp, r7
 8006386:	bd80      	pop	{r7, pc}

08006388 <MuxCompareValue>:
    UINT64  lastAccessTime; /* The last access time */
} MuxDebugCB;
STATIC MuxDebugCB *g_muxDebugArray = NULL;

STATIC BOOL MuxCompareValue(const SortParam *sortParam, UINT32 left, UINT32 right)
{
 8006388:	b490      	push	{r4, r7}
 800638a:	b084      	sub	sp, #16
 800638c:	af00      	add	r7, sp, #0
 800638e:	60f8      	str	r0, [r7, #12]
 8006390:	60b9      	str	r1, [r7, #8]
 8006392:	607a      	str	r2, [r7, #4]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 8006394:	68fb      	ldr	r3, [r7, #12]
 8006396:	681a      	ldr	r2, [r3, #0]
 8006398:	68fb      	ldr	r3, [r7, #12]
 800639a:	685b      	ldr	r3, [r3, #4]
 800639c:	68b9      	ldr	r1, [r7, #8]
 800639e:	fb01 f103 	mul.w	r1, r1, r3
 80063a2:	68fb      	ldr	r3, [r7, #12]
 80063a4:	68db      	ldr	r3, [r3, #12]
 80063a6:	440b      	add	r3, r1
 80063a8:	4413      	add	r3, r2
 80063aa:	e9d3 2300 	ldrd	r2, r3, [r3]
            *((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, right)));
 80063ae:	68f9      	ldr	r1, [r7, #12]
 80063b0:	6808      	ldr	r0, [r1, #0]
 80063b2:	68f9      	ldr	r1, [r7, #12]
 80063b4:	6849      	ldr	r1, [r1, #4]
 80063b6:	687c      	ldr	r4, [r7, #4]
 80063b8:	fb04 f401 	mul.w	r4, r4, r1
 80063bc:	68f9      	ldr	r1, [r7, #12]
 80063be:	68c9      	ldr	r1, [r1, #12]
 80063c0:	4421      	add	r1, r4
 80063c2:	4401      	add	r1, r0
 80063c4:	e9d1 0100 	ldrd	r0, r1, [r1]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 80063c8:	4299      	cmp	r1, r3
 80063ca:	bf08      	it	eq
 80063cc:	4290      	cmpeq	r0, r2
 80063ce:	bf34      	ite	cc
 80063d0:	2301      	movcc	r3, #1
 80063d2:	2300      	movcs	r3, #0
 80063d4:	b2db      	uxtb	r3, r3
}
 80063d6:	4618      	mov	r0, r3
 80063d8:	3710      	adds	r7, #16
 80063da:	46bd      	mov	sp, r7
 80063dc:	bc90      	pop	{r4, r7}
 80063de:	4770      	bx	lr

080063e0 <OsMuxDbgInit>:

UINT32 OsMuxDbgInit(VOID)
{
 80063e0:	b580      	push	{r7, lr}
 80063e2:	b082      	sub	sp, #8
 80063e4:	af00      	add	r7, sp, #0
    UINT32 size = LOSCFG_BASE_IPC_MUX_LIMIT * sizeof(MuxDebugCB);
 80063e6:	f44f 73a0 	mov.w	r3, #320	; 0x140
 80063ea:	607b      	str	r3, [r7, #4]
    /* system resident memory, don't free */
    g_muxDebugArray = (MuxDebugCB *)LOS_MemAlloc(m_aucSysMem1, size);
 80063ec:	4b10      	ldr	r3, [pc, #64]	; (8006430 <OsMuxDbgInit+0x50>)
 80063ee:	681b      	ldr	r3, [r3, #0]
 80063f0:	6879      	ldr	r1, [r7, #4]
 80063f2:	4618      	mov	r0, r3
 80063f4:	f003 f80e 	bl	8009414 <LOS_MemAlloc>
 80063f8:	4603      	mov	r3, r0
 80063fa:	4a0e      	ldr	r2, [pc, #56]	; (8006434 <OsMuxDbgInit+0x54>)
 80063fc:	6013      	str	r3, [r2, #0]
    if (g_muxDebugArray == NULL) {
 80063fe:	4b0d      	ldr	r3, [pc, #52]	; (8006434 <OsMuxDbgInit+0x54>)
 8006400:	681b      	ldr	r3, [r3, #0]
 8006402:	2b00      	cmp	r3, #0
 8006404:	d108      	bne.n	8006418 <OsMuxDbgInit+0x38>
        PRINT_ERR("%s: malloc failed!\n", __FUNCTION__);
 8006406:	480c      	ldr	r0, [pc, #48]	; (8006438 <OsMuxDbgInit+0x58>)
 8006408:	f7fe fa5a 	bl	80048c0 <dprintf>
 800640c:	490b      	ldr	r1, [pc, #44]	; (800643c <OsMuxDbgInit+0x5c>)
 800640e:	480c      	ldr	r0, [pc, #48]	; (8006440 <OsMuxDbgInit+0x60>)
 8006410:	f7fe fa56 	bl	80048c0 <dprintf>
        return LOS_NOK;
 8006414:	2301      	movs	r3, #1
 8006416:	e007      	b.n	8006428 <OsMuxDbgInit+0x48>
    }
    (VOID)memset_s(g_muxDebugArray, size, 0, size);
 8006418:	4b06      	ldr	r3, [pc, #24]	; (8006434 <OsMuxDbgInit+0x54>)
 800641a:	6818      	ldr	r0, [r3, #0]
 800641c:	687b      	ldr	r3, [r7, #4]
 800641e:	2200      	movs	r2, #0
 8006420:	6879      	ldr	r1, [r7, #4]
 8006422:	f7fb fe3f 	bl	80020a4 <memset_s>
    return LOS_OK;
 8006426:	2300      	movs	r3, #0
}
 8006428:	4618      	mov	r0, r3
 800642a:	3708      	adds	r7, #8
 800642c:	46bd      	mov	sp, r7
 800642e:	bd80      	pop	{r7, pc}
 8006430:	200021c0 	.word	0x200021c0
 8006434:	200007a8 	.word	0x200007a8
 8006438:	080204a8 	.word	0x080204a8
 800643c:	08023310 	.word	0x08023310
 8006440:	080204b0 	.word	0x080204b0

08006444 <OsMuxDbgTimeUpdate>:

VOID OsMuxDbgTimeUpdate(UINT32 muxId)
{
 8006444:	b580      	push	{r7, lr}
 8006446:	b084      	sub	sp, #16
 8006448:	af00      	add	r7, sp, #0
 800644a:	6078      	str	r0, [r7, #4]
    MuxDebugCB *muxDebug = &g_muxDebugArray[GET_MUX_INDEX(muxId)];
 800644c:	4b08      	ldr	r3, [pc, #32]	; (8006470 <OsMuxDbgTimeUpdate+0x2c>)
 800644e:	681a      	ldr	r2, [r3, #0]
 8006450:	687b      	ldr	r3, [r7, #4]
 8006452:	b29b      	uxth	r3, r3
 8006454:	011b      	lsls	r3, r3, #4
 8006456:	4413      	add	r3, r2
 8006458:	60fb      	str	r3, [r7, #12]
    muxDebug->lastAccessTime = LOS_TickCountGet();
 800645a:	f7fd ff87 	bl	800436c <LOS_TickCountGet>
 800645e:	4602      	mov	r2, r0
 8006460:	460b      	mov	r3, r1
 8006462:	68f9      	ldr	r1, [r7, #12]
 8006464:	e9c1 2302 	strd	r2, r3, [r1, #8]
}
 8006468:	bf00      	nop
 800646a:	3710      	adds	r7, #16
 800646c:	46bd      	mov	sp, r7
 800646e:	bd80      	pop	{r7, pc}
 8006470:	200007a8 	.word	0x200007a8

08006474 <OsMuxDbgUpdate>:

VOID OsMuxDbgUpdate(UINT32 muxId, TSK_ENTRY_FUNC creator)
{
 8006474:	b580      	push	{r7, lr}
 8006476:	b084      	sub	sp, #16
 8006478:	af00      	add	r7, sp, #0
 800647a:	6078      	str	r0, [r7, #4]
 800647c:	6039      	str	r1, [r7, #0]
    MuxDebugCB *muxDebug = &g_muxDebugArray[GET_MUX_INDEX(muxId)];
 800647e:	4b0a      	ldr	r3, [pc, #40]	; (80064a8 <OsMuxDbgUpdate+0x34>)
 8006480:	681a      	ldr	r2, [r3, #0]
 8006482:	687b      	ldr	r3, [r7, #4]
 8006484:	b29b      	uxth	r3, r3
 8006486:	011b      	lsls	r3, r3, #4
 8006488:	4413      	add	r3, r2
 800648a:	60fb      	str	r3, [r7, #12]
    muxDebug->creator = creator;
 800648c:	68fb      	ldr	r3, [r7, #12]
 800648e:	683a      	ldr	r2, [r7, #0]
 8006490:	601a      	str	r2, [r3, #0]
    muxDebug->lastAccessTime = LOS_TickCountGet();
 8006492:	f7fd ff6b 	bl	800436c <LOS_TickCountGet>
 8006496:	4602      	mov	r2, r0
 8006498:	460b      	mov	r3, r1
 800649a:	68f9      	ldr	r1, [r7, #12]
 800649c:	e9c1 2302 	strd	r2, r3, [r1, #8]
}
 80064a0:	bf00      	nop
 80064a2:	3710      	adds	r7, #16
 80064a4:	46bd      	mov	sp, r7
 80064a6:	bd80      	pop	{r7, pc}
 80064a8:	200007a8 	.word	0x200007a8

080064ac <SortMuxIndexArray>:

STATIC VOID SortMuxIndexArray(UINT32 *indexArray, UINT32 count)
{
 80064ac:	b5b0      	push	{r4, r5, r7, lr}
 80064ae:	b096      	sub	sp, #88	; 0x58
 80064b0:	af04      	add	r7, sp, #16
 80064b2:	6078      	str	r0, [r7, #4]
 80064b4:	6039      	str	r1, [r7, #0]
 80064b6:	4b4f      	ldr	r3, [pc, #316]	; (80065f4 <SortMuxIndexArray+0x148>)
 80064b8:	681b      	ldr	r3, [r3, #0]
 80064ba:	647b      	str	r3, [r7, #68]	; 0x44
 80064bc:	f04f 0300 	mov.w	r3, #0
    LosMuxCB muxNode = {{0, 0}, 0, 0, 0, 0};
 80064c0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80064c4:	2200      	movs	r2, #0
 80064c6:	601a      	str	r2, [r3, #0]
 80064c8:	605a      	str	r2, [r3, #4]
 80064ca:	609a      	str	r2, [r3, #8]
 80064cc:	60da      	str	r2, [r3, #12]
 80064ce:	611a      	str	r2, [r3, #16]
    MuxDebugCB muxDebugNode = {0};
 80064d0:	f107 0310 	add.w	r3, r7, #16
 80064d4:	2200      	movs	r2, #0
 80064d6:	601a      	str	r2, [r3, #0]
 80064d8:	605a      	str	r2, [r3, #4]
 80064da:	609a      	str	r2, [r3, #8]
 80064dc:	60da      	str	r2, [r3, #12]
    UINT32 index, intSave;
    SortParam muxSortParam;
    muxSortParam.buf = (CHAR *)g_muxDebugArray;
 80064de:	4b46      	ldr	r3, [pc, #280]	; (80065f8 <SortMuxIndexArray+0x14c>)
 80064e0:	681b      	ldr	r3, [r3, #0]
 80064e2:	623b      	str	r3, [r7, #32]
    muxSortParam.ctrlBlockSize = sizeof(MuxDebugCB);
 80064e4:	2310      	movs	r3, #16
 80064e6:	627b      	str	r3, [r7, #36]	; 0x24
    muxSortParam.ctrlBlockCnt = LOSCFG_BASE_IPC_MUX_LIMIT;
 80064e8:	2314      	movs	r3, #20
 80064ea:	62bb      	str	r3, [r7, #40]	; 0x28
    muxSortParam.sortElemOff = LOS_OFF_SET_OF(MuxDebugCB, lastAccessTime);
 80064ec:	2308      	movs	r3, #8
 80064ee:	62fb      	str	r3, [r7, #44]	; 0x2c

    if (count > 0) {
 80064f0:	683b      	ldr	r3, [r7, #0]
 80064f2:	2b00      	cmp	r3, #0
 80064f4:	d06c      	beq.n	80065d0 <SortMuxIndexArray+0x124>
        SCHEDULER_LOCK(intSave);
 80064f6:	f107 0308 	add.w	r3, r7, #8
 80064fa:	4619      	mov	r1, r3
 80064fc:	483f      	ldr	r0, [pc, #252]	; (80065fc <SortMuxIndexArray+0x150>)
 80064fe:	f7ff ff29 	bl	8006354 <LOS_SpinLockSave>
        OsArraySort(indexArray, 0, count - 1, &muxSortParam, MuxCompareValue);
 8006502:	683b      	ldr	r3, [r7, #0]
 8006504:	1e5a      	subs	r2, r3, #1
 8006506:	f107 0320 	add.w	r3, r7, #32
 800650a:	493d      	ldr	r1, [pc, #244]	; (8006600 <SortMuxIndexArray+0x154>)
 800650c:	9100      	str	r1, [sp, #0]
 800650e:	2100      	movs	r1, #0
 8006510:	6878      	ldr	r0, [r7, #4]
 8006512:	f7fc f9e3 	bl	80028dc <OsArraySort>
        SCHEDULER_UNLOCK(intSave);
 8006516:	68bb      	ldr	r3, [r7, #8]
 8006518:	4619      	mov	r1, r3
 800651a:	4838      	ldr	r0, [pc, #224]	; (80065fc <SortMuxIndexArray+0x150>)
 800651c:	f7ff ff28 	bl	8006370 <LOS_SpinUnlockRestore>
        for (index = 0; index < count; index++) {
 8006520:	2300      	movs	r3, #0
 8006522:	60fb      	str	r3, [r7, #12]
 8006524:	e050      	b.n	80065c8 <SortMuxIndexArray+0x11c>
            SCHEDULER_LOCK(intSave);
 8006526:	f107 0308 	add.w	r3, r7, #8
 800652a:	4619      	mov	r1, r3
 800652c:	4833      	ldr	r0, [pc, #204]	; (80065fc <SortMuxIndexArray+0x150>)
 800652e:	f7ff ff11 	bl	8006354 <LOS_SpinLockSave>
            (VOID)memcpy_s(&muxNode, sizeof(LosMuxCB),
 8006532:	4b34      	ldr	r3, [pc, #208]	; (8006604 <SortMuxIndexArray+0x158>)
 8006534:	6819      	ldr	r1, [r3, #0]
                           GET_MUX(indexArray[index]), sizeof(LosMuxCB));
 8006536:	68fb      	ldr	r3, [r7, #12]
 8006538:	009b      	lsls	r3, r3, #2
 800653a:	687a      	ldr	r2, [r7, #4]
 800653c:	4413      	add	r3, r2
 800653e:	681b      	ldr	r3, [r3, #0]
 8006540:	b29a      	uxth	r2, r3
 8006542:	4613      	mov	r3, r2
 8006544:	009b      	lsls	r3, r3, #2
 8006546:	4413      	add	r3, r2
 8006548:	009b      	lsls	r3, r3, #2
 800654a:	18ca      	adds	r2, r1, r3
            (VOID)memcpy_s(&muxNode, sizeof(LosMuxCB),
 800654c:	f107 0030 	add.w	r0, r7, #48	; 0x30
 8006550:	2314      	movs	r3, #20
 8006552:	2114      	movs	r1, #20
 8006554:	f010 fda0 	bl	8017098 <memcpy_s>
            (VOID)memcpy_s(&muxDebugNode, sizeof(MuxDebugCB),
 8006558:	4b27      	ldr	r3, [pc, #156]	; (80065f8 <SortMuxIndexArray+0x14c>)
 800655a:	681a      	ldr	r2, [r3, #0]
                           &g_muxDebugArray[indexArray[index]], sizeof(MuxDebugCB));
 800655c:	68fb      	ldr	r3, [r7, #12]
 800655e:	009b      	lsls	r3, r3, #2
 8006560:	6879      	ldr	r1, [r7, #4]
 8006562:	440b      	add	r3, r1
 8006564:	681b      	ldr	r3, [r3, #0]
 8006566:	011b      	lsls	r3, r3, #4
 8006568:	441a      	add	r2, r3
            (VOID)memcpy_s(&muxDebugNode, sizeof(MuxDebugCB),
 800656a:	f107 0010 	add.w	r0, r7, #16
 800656e:	2310      	movs	r3, #16
 8006570:	2110      	movs	r1, #16
 8006572:	f010 fd91 	bl	8017098 <memcpy_s>
            SCHEDULER_UNLOCK(intSave);
 8006576:	68bb      	ldr	r3, [r7, #8]
 8006578:	4619      	mov	r1, r3
 800657a:	4820      	ldr	r0, [pc, #128]	; (80065fc <SortMuxIndexArray+0x150>)
 800657c:	f7ff fef8 	bl	8006370 <LOS_SpinUnlockRestore>
            /*
             * muxStat may be altered after the g_taskSpin is unlocked in OsMutexCheck.
             * We should recheck the muxStat before the print.
             */
            if ((muxNode.muxStat != LOS_USED) ||
 8006580:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 8006584:	2b01      	cmp	r3, #1
 8006586:	d11b      	bne.n	80065c0 <SortMuxIndexArray+0x114>
                ((muxNode.muxStat == LOS_USED) && ((muxDebugNode.creator == NULL) || (muxNode.owner == NULL)))) {
 8006588:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
            if ((muxNode.muxStat != LOS_USED) ||
 800658c:	2b01      	cmp	r3, #1
 800658e:	d105      	bne.n	800659c <SortMuxIndexArray+0xf0>
                ((muxNode.muxStat == LOS_USED) && ((muxDebugNode.creator == NULL) || (muxNode.owner == NULL)))) {
 8006590:	693b      	ldr	r3, [r7, #16]
 8006592:	2b00      	cmp	r3, #0
 8006594:	d014      	beq.n	80065c0 <SortMuxIndexArray+0x114>
 8006596:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006598:	2b00      	cmp	r3, #0
 800659a:	d011      	beq.n	80065c0 <SortMuxIndexArray+0x114>
                continue;
            }
            PRINTK("Mutex ID <0x%x> may leak, TaskID of owner:0x%x, TaskEntry of owner: %p,"
 800659c:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800659e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80065a0:	695c      	ldr	r4, [r3, #20]
 80065a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80065a4:	699d      	ldr	r5, [r3, #24]
 80065a6:	6939      	ldr	r1, [r7, #16]
 80065a8:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 80065ac:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80065b0:	9100      	str	r1, [sp, #0]
 80065b2:	462b      	mov	r3, r5
 80065b4:	4622      	mov	r2, r4
 80065b6:	4601      	mov	r1, r0
 80065b8:	4813      	ldr	r0, [pc, #76]	; (8006608 <SortMuxIndexArray+0x15c>)
 80065ba:	f7fe f981 	bl	80048c0 <dprintf>
 80065be:	e000      	b.n	80065c2 <SortMuxIndexArray+0x116>
                continue;
 80065c0:	bf00      	nop
        for (index = 0; index < count; index++) {
 80065c2:	68fb      	ldr	r3, [r7, #12]
 80065c4:	3301      	adds	r3, #1
 80065c6:	60fb      	str	r3, [r7, #12]
 80065c8:	68fa      	ldr	r2, [r7, #12]
 80065ca:	683b      	ldr	r3, [r7, #0]
 80065cc:	429a      	cmp	r2, r3
 80065ce:	d3aa      	bcc.n	8006526 <SortMuxIndexArray+0x7a>
                   "TaskEntry of creator: %p,Latest operation time: 0x%llx\n",
                   muxNode.muxId, muxNode.owner->taskId, muxNode.owner->taskEntry, muxDebugNode.creator,
                   muxDebugNode.lastAccessTime);
        }
    }
    (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, indexArray);
 80065d0:	4b0e      	ldr	r3, [pc, #56]	; (800660c <SortMuxIndexArray+0x160>)
 80065d2:	681b      	ldr	r3, [r3, #0]
 80065d4:	6879      	ldr	r1, [r7, #4]
 80065d6:	4618      	mov	r0, r3
 80065d8:	f002 ffd4 	bl	8009584 <LOS_MemFree>
}
 80065dc:	bf00      	nop
 80065de:	4b05      	ldr	r3, [pc, #20]	; (80065f4 <SortMuxIndexArray+0x148>)
 80065e0:	681a      	ldr	r2, [r3, #0]
 80065e2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80065e4:	405a      	eors	r2, r3
 80065e6:	d001      	beq.n	80065ec <SortMuxIndexArray+0x140>
 80065e8:	f7fd fff8 	bl	80045dc <__stack_chk_fail>
 80065ec:	3748      	adds	r7, #72	; 0x48
 80065ee:	46bd      	mov	sp, r7
 80065f0:	bdb0      	pop	{r4, r5, r7, pc}
 80065f2:	bf00      	nop
 80065f4:	08020544 	.word	0x08020544
 80065f8:	200007a8 	.word	0x200007a8
 80065fc:	20000770 	.word	0x20000770
 8006600:	08006389 	.word	0x08006389
 8006604:	200021d0 	.word	0x200021d0
 8006608:	080204c4 	.word	0x080204c4
 800660c:	080001f0 	.word	0x080001f0

08006610 <OsMutexCheck>:

VOID OsMutexCheck(VOID)
{
 8006610:	b5b0      	push	{r4, r5, r7, lr}
 8006612:	b092      	sub	sp, #72	; 0x48
 8006614:	af04      	add	r7, sp, #16
 8006616:	4b4c      	ldr	r3, [pc, #304]	; (8006748 <OsMutexCheck+0x138>)
 8006618:	681b      	ldr	r3, [r3, #0]
 800661a:	637b      	str	r3, [r7, #52]	; 0x34
 800661c:	f04f 0300 	mov.w	r3, #0
    LosMuxCB muxNode = {{0, 0}, 0, 0, 0, 0};
 8006620:	f107 0320 	add.w	r3, r7, #32
 8006624:	2200      	movs	r2, #0
 8006626:	601a      	str	r2, [r3, #0]
 8006628:	605a      	str	r2, [r3, #4]
 800662a:	609a      	str	r2, [r3, #8]
 800662c:	60da      	str	r2, [r3, #12]
 800662e:	611a      	str	r2, [r3, #16]
    MuxDebugCB muxDebugNode = {0};
 8006630:	f107 0310 	add.w	r3, r7, #16
 8006634:	2200      	movs	r2, #0
 8006636:	601a      	str	r2, [r3, #0]
 8006638:	605a      	str	r2, [r3, #4]
 800663a:	609a      	str	r2, [r3, #8]
 800663c:	60da      	str	r2, [r3, #12]
    UINT32 index, intSave;
    UINT32 count = 0;
 800663e:	2300      	movs	r3, #0
 8006640:	60bb      	str	r3, [r7, #8]
    /*
     * This return value does not need to be judged immediately,
     * and the following code logic has already distinguished the return value from null and non-empty,
     * and there is no case of accessing the null pointer.
     */
    UINT32 *indexArray = (UINT32 *)LOS_MemAlloc((VOID *)OS_SYS_MEM_ADDR, LOSCFG_BASE_IPC_MUX_LIMIT * sizeof(UINT32));
 8006642:	4b42      	ldr	r3, [pc, #264]	; (800674c <OsMutexCheck+0x13c>)
 8006644:	681b      	ldr	r3, [r3, #0]
 8006646:	2150      	movs	r1, #80	; 0x50
 8006648:	4618      	mov	r0, r3
 800664a:	f002 fee3 	bl	8009414 <LOS_MemAlloc>
 800664e:	60f8      	str	r0, [r7, #12]

    for (index = 0; index < LOSCFG_BASE_IPC_MUX_LIMIT; index++) {
 8006650:	2300      	movs	r3, #0
 8006652:	607b      	str	r3, [r7, #4]
 8006654:	e063      	b.n	800671e <OsMutexCheck+0x10e>
        SCHEDULER_LOCK(intSave);
 8006656:	463b      	mov	r3, r7
 8006658:	4619      	mov	r1, r3
 800665a:	483d      	ldr	r0, [pc, #244]	; (8006750 <OsMutexCheck+0x140>)
 800665c:	f7ff fe7a 	bl	8006354 <LOS_SpinLockSave>
        (VOID)memcpy_s(&muxNode, sizeof(LosMuxCB), GET_MUX(index), sizeof(LosMuxCB));
 8006660:	4b3c      	ldr	r3, [pc, #240]	; (8006754 <OsMutexCheck+0x144>)
 8006662:	6819      	ldr	r1, [r3, #0]
 8006664:	687b      	ldr	r3, [r7, #4]
 8006666:	b29a      	uxth	r2, r3
 8006668:	4613      	mov	r3, r2
 800666a:	009b      	lsls	r3, r3, #2
 800666c:	4413      	add	r3, r2
 800666e:	009b      	lsls	r3, r3, #2
 8006670:	18ca      	adds	r2, r1, r3
 8006672:	f107 0020 	add.w	r0, r7, #32
 8006676:	2314      	movs	r3, #20
 8006678:	2114      	movs	r1, #20
 800667a:	f010 fd0d 	bl	8017098 <memcpy_s>
        (VOID)memcpy_s(&muxDebugNode, sizeof(MuxDebugCB), &g_muxDebugArray[index], sizeof(MuxDebugCB));
 800667e:	4b36      	ldr	r3, [pc, #216]	; (8006758 <OsMutexCheck+0x148>)
 8006680:	681a      	ldr	r2, [r3, #0]
 8006682:	687b      	ldr	r3, [r7, #4]
 8006684:	011b      	lsls	r3, r3, #4
 8006686:	441a      	add	r2, r3
 8006688:	f107 0010 	add.w	r0, r7, #16
 800668c:	2310      	movs	r3, #16
 800668e:	2110      	movs	r1, #16
 8006690:	f010 fd02 	bl	8017098 <memcpy_s>
        SCHEDULER_UNLOCK(intSave);
 8006694:	683b      	ldr	r3, [r7, #0]
 8006696:	4619      	mov	r1, r3
 8006698:	482d      	ldr	r0, [pc, #180]	; (8006750 <OsMutexCheck+0x140>)
 800669a:	f7ff fe69 	bl	8006370 <LOS_SpinUnlockRestore>

        if ((muxNode.muxStat != LOS_USED) ||
 800669e:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80066a2:	2b01      	cmp	r3, #1
 80066a4:	d137      	bne.n	8006716 <OsMutexCheck+0x106>
            ((muxNode.muxStat == LOS_USED) && (muxDebugNode.creator == NULL))) {
 80066a6:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
        if ((muxNode.muxStat != LOS_USED) ||
 80066aa:	2b01      	cmp	r3, #1
 80066ac:	d102      	bne.n	80066b4 <OsMutexCheck+0xa4>
            ((muxNode.muxStat == LOS_USED) && (muxDebugNode.creator == NULL))) {
 80066ae:	693b      	ldr	r3, [r7, #16]
 80066b0:	2b00      	cmp	r3, #0
 80066b2:	d030      	beq.n	8006716 <OsMutexCheck+0x106>
            continue;
        } else if ((muxNode.muxStat == LOS_USED) && (muxNode.owner == NULL)) {
 80066b4:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80066b8:	2b01      	cmp	r3, #1
 80066ba:	d10d      	bne.n	80066d8 <OsMutexCheck+0xc8>
 80066bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80066be:	2b00      	cmp	r3, #0
 80066c0:	d10a      	bne.n	80066d8 <OsMutexCheck+0xc8>
            PRINTK("Mutex ID <0x%x> may leak, Owner is null, TaskEntry of creator: %p,"
 80066c2:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80066c4:	6938      	ldr	r0, [r7, #16]
 80066c6:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 80066ca:	e9cd 2300 	strd	r2, r3, [sp]
 80066ce:	4602      	mov	r2, r0
 80066d0:	4822      	ldr	r0, [pc, #136]	; (800675c <OsMutexCheck+0x14c>)
 80066d2:	f7fe f8f5 	bl	80048c0 <dprintf>
 80066d6:	e01f      	b.n	8006718 <OsMutexCheck+0x108>
                   "Latest operation time: 0x%llx\n",
                   muxNode.muxId, muxDebugNode.creator, muxDebugNode.lastAccessTime);
        } else {
            if (indexArray != NULL) {
 80066d8:	68fb      	ldr	r3, [r7, #12]
 80066da:	2b00      	cmp	r3, #0
 80066dc:	d009      	beq.n	80066f2 <OsMutexCheck+0xe2>
                *(indexArray + count) = index;
 80066de:	68bb      	ldr	r3, [r7, #8]
 80066e0:	009b      	lsls	r3, r3, #2
 80066e2:	68fa      	ldr	r2, [r7, #12]
 80066e4:	4413      	add	r3, r2
 80066e6:	687a      	ldr	r2, [r7, #4]
 80066e8:	601a      	str	r2, [r3, #0]
                count++;
 80066ea:	68bb      	ldr	r3, [r7, #8]
 80066ec:	3301      	adds	r3, #1
 80066ee:	60bb      	str	r3, [r7, #8]
 80066f0:	e012      	b.n	8006718 <OsMutexCheck+0x108>
            } else {
                PRINTK("Mutex ID <0x%x> may leak, TaskID of owner:0x%x, TaskEntry of owner: %p,"
 80066f2:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80066f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80066f6:	695c      	ldr	r4, [r3, #20]
 80066f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80066fa:	699d      	ldr	r5, [r3, #24]
 80066fc:	6939      	ldr	r1, [r7, #16]
 80066fe:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8006702:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8006706:	9100      	str	r1, [sp, #0]
 8006708:	462b      	mov	r3, r5
 800670a:	4622      	mov	r2, r4
 800670c:	4601      	mov	r1, r0
 800670e:	4814      	ldr	r0, [pc, #80]	; (8006760 <OsMutexCheck+0x150>)
 8006710:	f7fe f8d6 	bl	80048c0 <dprintf>
 8006714:	e000      	b.n	8006718 <OsMutexCheck+0x108>
            continue;
 8006716:	bf00      	nop
    for (index = 0; index < LOSCFG_BASE_IPC_MUX_LIMIT; index++) {
 8006718:	687b      	ldr	r3, [r7, #4]
 800671a:	3301      	adds	r3, #1
 800671c:	607b      	str	r3, [r7, #4]
 800671e:	687b      	ldr	r3, [r7, #4]
 8006720:	2b13      	cmp	r3, #19
 8006722:	d998      	bls.n	8006656 <OsMutexCheck+0x46>
                       muxDebugNode.lastAccessTime);
            }
        }
    }

    if (indexArray != NULL) {
 8006724:	68fb      	ldr	r3, [r7, #12]
 8006726:	2b00      	cmp	r3, #0
 8006728:	d003      	beq.n	8006732 <OsMutexCheck+0x122>
        SortMuxIndexArray(indexArray, count);
 800672a:	68b9      	ldr	r1, [r7, #8]
 800672c:	68f8      	ldr	r0, [r7, #12]
 800672e:	f7ff febd 	bl	80064ac <SortMuxIndexArray>
    }
}
 8006732:	bf00      	nop
 8006734:	4b04      	ldr	r3, [pc, #16]	; (8006748 <OsMutexCheck+0x138>)
 8006736:	681a      	ldr	r2, [r3, #0]
 8006738:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800673a:	405a      	eors	r2, r3
 800673c:	d001      	beq.n	8006742 <OsMutexCheck+0x132>
 800673e:	f7fd ff4d 	bl	80045dc <__stack_chk_fail>
 8006742:	3738      	adds	r7, #56	; 0x38
 8006744:	46bd      	mov	sp, r7
 8006746:	bdb0      	pop	{r4, r5, r7, pc}
 8006748:	080205ac 	.word	0x080205ac
 800674c:	080001f0 	.word	0x080001f0
 8006750:	20000770 	.word	0x20000770
 8006754:	200021d0 	.word	0x200021d0
 8006758:	200007a8 	.word	0x200007a8
 800675c:	08020548 	.word	0x08020548
 8006760:	080204c4 	.word	0x080204c4

08006764 <OsShellCmdMuxInfoGet>:

#ifdef LOSCFG_SHELL
LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdMuxInfoGet(UINT32 argc, const CHAR **argv)
{
 8006764:	b580      	push	{r7, lr}
 8006766:	b082      	sub	sp, #8
 8006768:	af00      	add	r7, sp, #0
 800676a:	6078      	str	r0, [r7, #4]
 800676c:	6039      	str	r1, [r7, #0]
    if (argc > 0) {
 800676e:	687b      	ldr	r3, [r7, #4]
 8006770:	2b00      	cmp	r3, #0
 8006772:	d005      	beq.n	8006780 <OsShellCmdMuxInfoGet+0x1c>
        PRINTK("\nUsage: mutex\n");
 8006774:	4807      	ldr	r0, [pc, #28]	; (8006794 <OsShellCmdMuxInfoGet+0x30>)
 8006776:	f7fe f8a3 	bl	80048c0 <dprintf>
        return OS_ERROR;
 800677a:	f04f 33ff 	mov.w	r3, #4294967295
 800677e:	e005      	b.n	800678c <OsShellCmdMuxInfoGet+0x28>
    }
    PRINTK("used mutexs information: \n");
 8006780:	4805      	ldr	r0, [pc, #20]	; (8006798 <OsShellCmdMuxInfoGet+0x34>)
 8006782:	f7fe f89d 	bl	80048c0 <dprintf>
    OsMutexCheck();
 8006786:	f7ff ff43 	bl	8006610 <OsMutexCheck>
    return LOS_OK;
 800678a:	2300      	movs	r3, #0
}
 800678c:	4618      	mov	r0, r3
 800678e:	3708      	adds	r7, #8
 8006790:	46bd      	mov	sp, r7
 8006792:	bd80      	pop	{r7, pc}
 8006794:	080205b0 	.word	0x080205b0
 8006798:	080205c0 	.word	0x080205c0

0800679c <LOS_ListInit>:
{
 800679c:	b480      	push	{r7}
 800679e:	b083      	sub	sp, #12
 80067a0:	af00      	add	r7, sp, #0
 80067a2:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 80067a4:	687b      	ldr	r3, [r7, #4]
 80067a6:	687a      	ldr	r2, [r7, #4]
 80067a8:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 80067aa:	687b      	ldr	r3, [r7, #4]
 80067ac:	687a      	ldr	r2, [r7, #4]
 80067ae:	601a      	str	r2, [r3, #0]
}
 80067b0:	bf00      	nop
 80067b2:	370c      	adds	r7, #12
 80067b4:	46bd      	mov	sp, r7
 80067b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067ba:	4770      	bx	lr

080067bc <LOS_ListAdd>:
{
 80067bc:	b480      	push	{r7}
 80067be:	b083      	sub	sp, #12
 80067c0:	af00      	add	r7, sp, #0
 80067c2:	6078      	str	r0, [r7, #4]
 80067c4:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 80067c6:	687b      	ldr	r3, [r7, #4]
 80067c8:	685a      	ldr	r2, [r3, #4]
 80067ca:	683b      	ldr	r3, [r7, #0]
 80067cc:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 80067ce:	683b      	ldr	r3, [r7, #0]
 80067d0:	687a      	ldr	r2, [r7, #4]
 80067d2:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 80067d4:	687b      	ldr	r3, [r7, #4]
 80067d6:	685b      	ldr	r3, [r3, #4]
 80067d8:	683a      	ldr	r2, [r7, #0]
 80067da:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 80067dc:	687b      	ldr	r3, [r7, #4]
 80067de:	683a      	ldr	r2, [r7, #0]
 80067e0:	605a      	str	r2, [r3, #4]
}
 80067e2:	bf00      	nop
 80067e4:	370c      	adds	r7, #12
 80067e6:	46bd      	mov	sp, r7
 80067e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067ec:	4770      	bx	lr

080067ee <LOS_ListTailInsert>:
{
 80067ee:	b580      	push	{r7, lr}
 80067f0:	b082      	sub	sp, #8
 80067f2:	af00      	add	r7, sp, #0
 80067f4:	6078      	str	r0, [r7, #4]
 80067f6:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 80067f8:	687b      	ldr	r3, [r7, #4]
 80067fa:	681b      	ldr	r3, [r3, #0]
 80067fc:	6839      	ldr	r1, [r7, #0]
 80067fe:	4618      	mov	r0, r3
 8006800:	f7ff ffdc 	bl	80067bc <LOS_ListAdd>
}
 8006804:	bf00      	nop
 8006806:	3708      	adds	r7, #8
 8006808:	46bd      	mov	sp, r7
 800680a:	bd80      	pop	{r7, pc}

0800680c <LOS_ListDelete>:
{
 800680c:	b480      	push	{r7}
 800680e:	b083      	sub	sp, #12
 8006810:	af00      	add	r7, sp, #0
 8006812:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8006814:	687b      	ldr	r3, [r7, #4]
 8006816:	685b      	ldr	r3, [r3, #4]
 8006818:	687a      	ldr	r2, [r7, #4]
 800681a:	6812      	ldr	r2, [r2, #0]
 800681c:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 800681e:	687b      	ldr	r3, [r7, #4]
 8006820:	681b      	ldr	r3, [r3, #0]
 8006822:	687a      	ldr	r2, [r7, #4]
 8006824:	6852      	ldr	r2, [r2, #4]
 8006826:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8006828:	687b      	ldr	r3, [r7, #4]
 800682a:	2200      	movs	r2, #0
 800682c:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 800682e:	687b      	ldr	r3, [r7, #4]
 8006830:	2200      	movs	r2, #0
 8006832:	601a      	str	r2, [r3, #0]
}
 8006834:	bf00      	nop
 8006836:	370c      	adds	r7, #12
 8006838:	46bd      	mov	sp, r7
 800683a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800683e:	4770      	bx	lr

08006840 <LOS_ListEmpty>:
{
 8006840:	b480      	push	{r7}
 8006842:	b083      	sub	sp, #12
 8006844:	af00      	add	r7, sp, #0
 8006846:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8006848:	687b      	ldr	r3, [r7, #4]
 800684a:	685b      	ldr	r3, [r3, #4]
 800684c:	687a      	ldr	r2, [r7, #4]
 800684e:	429a      	cmp	r2, r3
 8006850:	bf0c      	ite	eq
 8006852:	2301      	moveq	r3, #1
 8006854:	2300      	movne	r3, #0
 8006856:	b2db      	uxtb	r3, r3
}
 8006858:	4618      	mov	r0, r3
 800685a:	370c      	adds	r7, #12
 800685c:	46bd      	mov	sp, r7
 800685e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006862:	4770      	bx	lr

08006864 <LOS_IntLock>:
{
 8006864:	b580      	push	{r7, lr}
 8006866:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8006868:	f7fa fa2e 	bl	8000cc8 <ArchIntLock>
 800686c:	4603      	mov	r3, r0
}
 800686e:	4618      	mov	r0, r3
 8006870:	bd80      	pop	{r7, pc}

08006872 <LOS_IntRestore>:
{
 8006872:	b580      	push	{r7, lr}
 8006874:	b082      	sub	sp, #8
 8006876:	af00      	add	r7, sp, #0
 8006878:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800687a:	6878      	ldr	r0, [r7, #4]
 800687c:	f7fa fa2c 	bl	8000cd8 <ArchIntRestore>
}
 8006880:	bf00      	nop
 8006882:	3708      	adds	r7, #8
 8006884:	46bd      	mov	sp, r7
 8006886:	bd80      	pop	{r7, pc}

08006888 <LOS_SpinLockSave>:
{
 8006888:	b580      	push	{r7, lr}
 800688a:	b082      	sub	sp, #8
 800688c:	af00      	add	r7, sp, #0
 800688e:	6078      	str	r0, [r7, #4]
 8006890:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8006892:	f7ff ffe7 	bl	8006864 <LOS_IntLock>
 8006896:	4602      	mov	r2, r0
 8006898:	683b      	ldr	r3, [r7, #0]
 800689a:	601a      	str	r2, [r3, #0]
}
 800689c:	bf00      	nop
 800689e:	3708      	adds	r7, #8
 80068a0:	46bd      	mov	sp, r7
 80068a2:	bd80      	pop	{r7, pc}

080068a4 <LOS_SpinUnlockRestore>:
{
 80068a4:	b580      	push	{r7, lr}
 80068a6:	b082      	sub	sp, #8
 80068a8:	af00      	add	r7, sp, #0
 80068aa:	6078      	str	r0, [r7, #4]
 80068ac:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 80068ae:	6838      	ldr	r0, [r7, #0]
 80068b0:	f7ff ffdf 	bl	8006872 <LOS_IntRestore>
}
 80068b4:	bf00      	nop
 80068b6:	3708      	adds	r7, #8
 80068b8:	46bd      	mov	sp, r7
 80068ba:	bd80      	pop	{r7, pc}

080068bc <OsMuxDlockCheckInit>:
 * The unit is tick.
 */
#define OS_MUX_DEADLOCK_CHECK_THRESHOLD 60000

UINT32 OsMuxDlockCheckInit(VOID)
{
 80068bc:	b580      	push	{r7, lr}
 80068be:	b082      	sub	sp, #8
 80068c0:	af00      	add	r7, sp, #0
    UINT32 index;
    UINT32 size = (LOSCFG_BASE_CORE_TSK_LIMIT + 1) * sizeof(MuxDLinkCB);
 80068c2:	f44f 7388 	mov.w	r3, #272	; 0x110
 80068c6:	607b      	str	r3, [r7, #4]

    /* system resident memory, don't free */
    g_muxDeadlockCBArray = (MuxDLinkCB *)LOS_MemAlloc(m_aucSysMem1, size);
 80068c8:	4b1b      	ldr	r3, [pc, #108]	; (8006938 <OsMuxDlockCheckInit+0x7c>)
 80068ca:	681b      	ldr	r3, [r3, #0]
 80068cc:	6879      	ldr	r1, [r7, #4]
 80068ce:	4618      	mov	r0, r3
 80068d0:	f002 fda0 	bl	8009414 <LOS_MemAlloc>
 80068d4:	4603      	mov	r3, r0
 80068d6:	4a19      	ldr	r2, [pc, #100]	; (800693c <OsMuxDlockCheckInit+0x80>)
 80068d8:	6013      	str	r3, [r2, #0]
    if (g_muxDeadlockCBArray == NULL) {
 80068da:	4b18      	ldr	r3, [pc, #96]	; (800693c <OsMuxDlockCheckInit+0x80>)
 80068dc:	681b      	ldr	r3, [r3, #0]
 80068de:	2b00      	cmp	r3, #0
 80068e0:	d108      	bne.n	80068f4 <OsMuxDlockCheckInit+0x38>
        PRINT_ERR("%s: malloc failed!\n", __FUNCTION__);
 80068e2:	4817      	ldr	r0, [pc, #92]	; (8006940 <OsMuxDlockCheckInit+0x84>)
 80068e4:	f7fd ffec 	bl	80048c0 <dprintf>
 80068e8:	4916      	ldr	r1, [pc, #88]	; (8006944 <OsMuxDlockCheckInit+0x88>)
 80068ea:	4817      	ldr	r0, [pc, #92]	; (8006948 <OsMuxDlockCheckInit+0x8c>)
 80068ec:	f7fd ffe8 	bl	80048c0 <dprintf>
        return LOS_NOK;
 80068f0:	2301      	movs	r3, #1
 80068f2:	e01c      	b.n	800692e <OsMuxDlockCheckInit+0x72>
    }

    for (index = 0; index < LOSCFG_BASE_CORE_TSK_LIMIT + 1; index++) {
 80068f4:	2300      	movs	r3, #0
 80068f6:	603b      	str	r3, [r7, #0]
 80068f8:	e015      	b.n	8006926 <OsMuxDlockCheckInit+0x6a>
        g_muxDeadlockCBArray[index].lastAccessTime = 0;
 80068fa:	4b10      	ldr	r3, [pc, #64]	; (800693c <OsMuxDlockCheckInit+0x80>)
 80068fc:	681a      	ldr	r2, [r3, #0]
 80068fe:	683b      	ldr	r3, [r7, #0]
 8006900:	011b      	lsls	r3, r3, #4
 8006902:	18d1      	adds	r1, r2, r3
 8006904:	f04f 0200 	mov.w	r2, #0
 8006908:	f04f 0300 	mov.w	r3, #0
 800690c:	e9c1 2302 	strd	r2, r3, [r1, #8]
        LOS_ListInit(&g_muxDeadlockCBArray[index].muxListHead);
 8006910:	4b0a      	ldr	r3, [pc, #40]	; (800693c <OsMuxDlockCheckInit+0x80>)
 8006912:	681a      	ldr	r2, [r3, #0]
 8006914:	683b      	ldr	r3, [r7, #0]
 8006916:	011b      	lsls	r3, r3, #4
 8006918:	4413      	add	r3, r2
 800691a:	4618      	mov	r0, r3
 800691c:	f7ff ff3e 	bl	800679c <LOS_ListInit>
    for (index = 0; index < LOSCFG_BASE_CORE_TSK_LIMIT + 1; index++) {
 8006920:	683b      	ldr	r3, [r7, #0]
 8006922:	3301      	adds	r3, #1
 8006924:	603b      	str	r3, [r7, #0]
 8006926:	683b      	ldr	r3, [r7, #0]
 8006928:	2b10      	cmp	r3, #16
 800692a:	d9e6      	bls.n	80068fa <OsMuxDlockCheckInit+0x3e>
    }
    return LOS_OK;
 800692c:	2300      	movs	r3, #0
}
 800692e:	4618      	mov	r0, r3
 8006930:	3708      	adds	r7, #8
 8006932:	46bd      	mov	sp, r7
 8006934:	bd80      	pop	{r7, pc}
 8006936:	bf00      	nop
 8006938:	200021c0 	.word	0x200021c0
 800693c:	200007ac 	.word	0x200007ac
 8006940:	080205e4 	.word	0x080205e4
 8006944:	08023320 	.word	0x08023320
 8006948:	080205ec 	.word	0x080205ec

0800694c <OsMuxDlockNodeInsert>:

VOID OsMuxDlockNodeInsert(UINT32 taskId, VOID *muxCB)
{
 800694c:	b580      	push	{r7, lr}
 800694e:	b084      	sub	sp, #16
 8006950:	af00      	add	r7, sp, #0
 8006952:	6078      	str	r0, [r7, #4]
 8006954:	6039      	str	r1, [r7, #0]
    MuxDLinkNode *muxDLNode = NULL;
 8006956:	2300      	movs	r3, #0
 8006958:	60fb      	str	r3, [r7, #12]

    if ((taskId > LOSCFG_BASE_CORE_TSK_LIMIT) || (muxCB == NULL)) {
 800695a:	687b      	ldr	r3, [r7, #4]
 800695c:	2b10      	cmp	r3, #16
 800695e:	d821      	bhi.n	80069a4 <OsMuxDlockNodeInsert+0x58>
 8006960:	683b      	ldr	r3, [r7, #0]
 8006962:	2b00      	cmp	r3, #0
 8006964:	d01e      	beq.n	80069a4 <OsMuxDlockNodeInsert+0x58>
        return;
    }

    muxDLNode = (MuxDLinkNode *)LOS_MemAlloc(m_aucSysMem1, sizeof(MuxDLinkNode));
 8006966:	4b12      	ldr	r3, [pc, #72]	; (80069b0 <OsMuxDlockNodeInsert+0x64>)
 8006968:	681b      	ldr	r3, [r3, #0]
 800696a:	210c      	movs	r1, #12
 800696c:	4618      	mov	r0, r3
 800696e:	f002 fd51 	bl	8009414 <LOS_MemAlloc>
 8006972:	60f8      	str	r0, [r7, #12]
    if (muxDLNode == NULL) {
 8006974:	68fb      	ldr	r3, [r7, #12]
 8006976:	2b00      	cmp	r3, #0
 8006978:	d016      	beq.n	80069a8 <OsMuxDlockNodeInsert+0x5c>
        return;
    }
    (VOID)memset_s(muxDLNode, sizeof(MuxDLinkNode), 0, sizeof(MuxDLinkNode));
 800697a:	230c      	movs	r3, #12
 800697c:	2200      	movs	r2, #0
 800697e:	210c      	movs	r1, #12
 8006980:	68f8      	ldr	r0, [r7, #12]
 8006982:	f7fb fb8f 	bl	80020a4 <memset_s>
    muxDLNode->muxCB = muxCB;
 8006986:	68fb      	ldr	r3, [r7, #12]
 8006988:	683a      	ldr	r2, [r7, #0]
 800698a:	609a      	str	r2, [r3, #8]

    LOS_ListTailInsert(&g_muxDeadlockCBArray[taskId].muxListHead, &muxDLNode->muxList);
 800698c:	4b09      	ldr	r3, [pc, #36]	; (80069b4 <OsMuxDlockNodeInsert+0x68>)
 800698e:	681a      	ldr	r2, [r3, #0]
 8006990:	687b      	ldr	r3, [r7, #4]
 8006992:	011b      	lsls	r3, r3, #4
 8006994:	4413      	add	r3, r2
 8006996:	461a      	mov	r2, r3
 8006998:	68fb      	ldr	r3, [r7, #12]
 800699a:	4619      	mov	r1, r3
 800699c:	4610      	mov	r0, r2
 800699e:	f7ff ff26 	bl	80067ee <LOS_ListTailInsert>
 80069a2:	e002      	b.n	80069aa <OsMuxDlockNodeInsert+0x5e>
        return;
 80069a4:	bf00      	nop
 80069a6:	e000      	b.n	80069aa <OsMuxDlockNodeInsert+0x5e>
        return;
 80069a8:	bf00      	nop
}
 80069aa:	3710      	adds	r7, #16
 80069ac:	46bd      	mov	sp, r7
 80069ae:	bd80      	pop	{r7, pc}
 80069b0:	200021c0 	.word	0x200021c0
 80069b4:	200007ac 	.word	0x200007ac

080069b8 <OsMuxDlockNodeDelete>:

VOID OsMuxDlockNodeDelete(UINT32 taskId, const VOID *muxCB)
{
 80069b8:	b580      	push	{r7, lr}
 80069ba:	b086      	sub	sp, #24
 80069bc:	af00      	add	r7, sp, #0
 80069be:	6078      	str	r0, [r7, #4]
 80069c0:	6039      	str	r1, [r7, #0]
    MuxDLinkCB *muxDLCB = NULL;
 80069c2:	2300      	movs	r3, #0
 80069c4:	613b      	str	r3, [r7, #16]
    LOS_DL_LIST *list = NULL;
 80069c6:	2300      	movs	r3, #0
 80069c8:	60fb      	str	r3, [r7, #12]
    MuxDLinkNode *muxDLNode = NULL;
 80069ca:	2300      	movs	r3, #0
 80069cc:	617b      	str	r3, [r7, #20]

    if ((taskId > LOSCFG_BASE_CORE_TSK_LIMIT) || (muxCB == NULL)) {
 80069ce:	687b      	ldr	r3, [r7, #4]
 80069d0:	2b10      	cmp	r3, #16
 80069d2:	d826      	bhi.n	8006a22 <OsMuxDlockNodeDelete+0x6a>
 80069d4:	683b      	ldr	r3, [r7, #0]
 80069d6:	2b00      	cmp	r3, #0
 80069d8:	d023      	beq.n	8006a22 <OsMuxDlockNodeDelete+0x6a>
        return;
    }

    muxDLCB = &g_muxDeadlockCBArray[taskId];
 80069da:	4b14      	ldr	r3, [pc, #80]	; (8006a2c <OsMuxDlockNodeDelete+0x74>)
 80069dc:	681a      	ldr	r2, [r3, #0]
 80069de:	687b      	ldr	r3, [r7, #4]
 80069e0:	011b      	lsls	r3, r3, #4
 80069e2:	4413      	add	r3, r2
 80069e4:	613b      	str	r3, [r7, #16]
    LOS_DL_LIST_FOR_EACH(list, &muxDLCB->muxListHead) {
 80069e6:	693b      	ldr	r3, [r7, #16]
 80069e8:	685b      	ldr	r3, [r3, #4]
 80069ea:	60fb      	str	r3, [r7, #12]
 80069ec:	e014      	b.n	8006a18 <OsMuxDlockNodeDelete+0x60>
        muxDLNode = LOS_DL_LIST_ENTRY(list, MuxDLinkNode, muxList);
 80069ee:	68fb      	ldr	r3, [r7, #12]
 80069f0:	617b      	str	r3, [r7, #20]
        if (muxDLNode->muxCB == muxCB) {
 80069f2:	697b      	ldr	r3, [r7, #20]
 80069f4:	689b      	ldr	r3, [r3, #8]
 80069f6:	683a      	ldr	r2, [r7, #0]
 80069f8:	429a      	cmp	r2, r3
 80069fa:	d10a      	bne.n	8006a12 <OsMuxDlockNodeDelete+0x5a>
            LOS_ListDelete(&muxDLNode->muxList);
 80069fc:	697b      	ldr	r3, [r7, #20]
 80069fe:	4618      	mov	r0, r3
 8006a00:	f7ff ff04 	bl	800680c <LOS_ListDelete>
            (VOID)LOS_MemFree(m_aucSysMem1, muxDLNode);
 8006a04:	4b0a      	ldr	r3, [pc, #40]	; (8006a30 <OsMuxDlockNodeDelete+0x78>)
 8006a06:	681b      	ldr	r3, [r3, #0]
 8006a08:	6979      	ldr	r1, [r7, #20]
 8006a0a:	4618      	mov	r0, r3
 8006a0c:	f002 fdba 	bl	8009584 <LOS_MemFree>
            return;
 8006a10:	e008      	b.n	8006a24 <OsMuxDlockNodeDelete+0x6c>
    LOS_DL_LIST_FOR_EACH(list, &muxDLCB->muxListHead) {
 8006a12:	68fb      	ldr	r3, [r7, #12]
 8006a14:	685b      	ldr	r3, [r3, #4]
 8006a16:	60fb      	str	r3, [r7, #12]
 8006a18:	693b      	ldr	r3, [r7, #16]
 8006a1a:	68fa      	ldr	r2, [r7, #12]
 8006a1c:	429a      	cmp	r2, r3
 8006a1e:	d1e6      	bne.n	80069ee <OsMuxDlockNodeDelete+0x36>
 8006a20:	e000      	b.n	8006a24 <OsMuxDlockNodeDelete+0x6c>
        return;
 8006a22:	bf00      	nop
        }
    }
}
 8006a24:	3718      	adds	r7, #24
 8006a26:	46bd      	mov	sp, r7
 8006a28:	bd80      	pop	{r7, pc}
 8006a2a:	bf00      	nop
 8006a2c:	200007ac 	.word	0x200007ac
 8006a30:	200021c0 	.word	0x200021c0

08006a34 <OsTaskTimeUpdate>:

VOID OsTaskTimeUpdate(UINT32 taskId, UINT64 tickCount)
{
 8006a34:	b480      	push	{r7}
 8006a36:	b085      	sub	sp, #20
 8006a38:	af00      	add	r7, sp, #0
 8006a3a:	60f8      	str	r0, [r7, #12]
 8006a3c:	e9c7 2300 	strd	r2, r3, [r7]
    if (taskId > LOSCFG_BASE_CORE_TSK_LIMIT) {
 8006a40:	68fb      	ldr	r3, [r7, #12]
 8006a42:	2b10      	cmp	r3, #16
 8006a44:	d809      	bhi.n	8006a5a <OsTaskTimeUpdate+0x26>
        return;
    }

    g_muxDeadlockCBArray[taskId].lastAccessTime = tickCount;
 8006a46:	4b08      	ldr	r3, [pc, #32]	; (8006a68 <OsTaskTimeUpdate+0x34>)
 8006a48:	681a      	ldr	r2, [r3, #0]
 8006a4a:	68fb      	ldr	r3, [r7, #12]
 8006a4c:	011b      	lsls	r3, r3, #4
 8006a4e:	18d1      	adds	r1, r2, r3
 8006a50:	e9d7 2300 	ldrd	r2, r3, [r7]
 8006a54:	e9c1 2302 	strd	r2, r3, [r1, #8]
 8006a58:	e000      	b.n	8006a5c <OsTaskTimeUpdate+0x28>
        return;
 8006a5a:	bf00      	nop
}
 8006a5c:	3714      	adds	r7, #20
 8006a5e:	46bd      	mov	sp, r7
 8006a60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a64:	4770      	bx	lr
 8006a66:	bf00      	nop
 8006a68:	200007ac 	.word	0x200007ac

08006a6c <OsDeadlockBackTrace>:

STATIC VOID OsDeadlockBackTrace(const LosTaskCB *taskCB)
{
 8006a6c:	b580      	push	{r7, lr}
 8006a6e:	b084      	sub	sp, #16
 8006a70:	af00      	add	r7, sp, #0
 8006a72:	6078      	str	r0, [r7, #4]
    TaskContext *context = NULL;
 8006a74:	2300      	movs	r3, #0
 8006a76:	60fb      	str	r3, [r7, #12]

    PRINTK("*******backtrace begin*******\n");
 8006a78:	4807      	ldr	r0, [pc, #28]	; (8006a98 <OsDeadlockBackTrace+0x2c>)
 8006a7a:	f7fd ff21 	bl	80048c0 <dprintf>
    context = (TaskContext *)taskCB->stackPointer;
 8006a7e:	687b      	ldr	r3, [r7, #4]
 8006a80:	681b      	ldr	r3, [r3, #0]
 8006a82:	60fb      	str	r3, [r7, #12]
    ArchBackTraceWithSp(context);
 8006a84:	68f8      	ldr	r0, [r7, #12]
 8006a86:	f010 f86f 	bl	8016b68 <ArchBackTraceWithSp>
    PRINTK("********backtrace end********\n");
 8006a8a:	4804      	ldr	r0, [pc, #16]	; (8006a9c <OsDeadlockBackTrace+0x30>)
 8006a8c:	f7fd ff18 	bl	80048c0 <dprintf>
    return;
 8006a90:	bf00      	nop
}
 8006a92:	3710      	adds	r7, #16
 8006a94:	46bd      	mov	sp, r7
 8006a96:	bd80      	pop	{r7, pc}
 8006a98:	08020600 	.word	0x08020600
 8006a9c:	08020620 	.word	0x08020620

08006aa0 <OsMutexPendTaskList>:

STATIC VOID OsMutexPendTaskList(LOS_DL_LIST *list)
{
 8006aa0:	b580      	push	{r7, lr}
 8006aa2:	b08a      	sub	sp, #40	; 0x28
 8006aa4:	af00      	add	r7, sp, #0
 8006aa6:	6078      	str	r0, [r7, #4]
 8006aa8:	4b31      	ldr	r3, [pc, #196]	; (8006b70 <OsMutexPendTaskList+0xd0>)
 8006aaa:	681b      	ldr	r3, [r3, #0]
 8006aac:	627b      	str	r3, [r7, #36]	; 0x24
 8006aae:	f04f 0300 	mov.w	r3, #0
    LOS_DL_LIST *listTmp = NULL;
 8006ab2:	2300      	movs	r3, #0
 8006ab4:	613b      	str	r3, [r7, #16]
    LosTaskCB *pendedTask = NULL;
 8006ab6:	2300      	movs	r3, #0
 8006ab8:	61bb      	str	r3, [r7, #24]
    CHAR *name = NULL;
 8006aba:	2300      	movs	r3, #0
 8006abc:	61fb      	str	r3, [r7, #28]
    UINT32 index = 0;
 8006abe:	2300      	movs	r3, #0
 8006ac0:	617b      	str	r3, [r7, #20]
    UINT32 id, intSave;

    SCHEDULER_LOCK(intSave);
 8006ac2:	f107 030c 	add.w	r3, r7, #12
 8006ac6:	4619      	mov	r1, r3
 8006ac8:	482a      	ldr	r0, [pc, #168]	; (8006b74 <OsMutexPendTaskList+0xd4>)
 8006aca:	f7ff fedd 	bl	8006888 <LOS_SpinLockSave>
    if (LOS_ListEmpty(list) == TRUE) {
 8006ace:	6878      	ldr	r0, [r7, #4]
 8006ad0:	f7ff feb6 	bl	8006840 <LOS_ListEmpty>
 8006ad4:	4603      	mov	r3, r0
 8006ad6:	2b01      	cmp	r3, #1
 8006ad8:	d108      	bne.n	8006aec <OsMutexPendTaskList+0x4c>
        SCHEDULER_UNLOCK(intSave);
 8006ada:	68fb      	ldr	r3, [r7, #12]
 8006adc:	4619      	mov	r1, r3
 8006ade:	4825      	ldr	r0, [pc, #148]	; (8006b74 <OsMutexPendTaskList+0xd4>)
 8006ae0:	f7ff fee0 	bl	80068a4 <LOS_SpinUnlockRestore>
        PRINTK("Pended Task: null\n");
 8006ae4:	4824      	ldr	r0, [pc, #144]	; (8006b78 <OsMutexPendTaskList+0xd8>)
 8006ae6:	f7fd feeb 	bl	80048c0 <dprintf>
 8006aea:	e036      	b.n	8006b5a <OsMutexPendTaskList+0xba>
        return;
    }

    LOS_DL_LIST_FOR_EACH(listTmp, list) {
 8006aec:	687b      	ldr	r3, [r7, #4]
 8006aee:	685b      	ldr	r3, [r3, #4]
 8006af0:	613b      	str	r3, [r7, #16]
 8006af2:	e029      	b.n	8006b48 <OsMutexPendTaskList+0xa8>
        pendedTask = OS_TCB_FROM_PENDLIST(listTmp);
 8006af4:	693b      	ldr	r3, [r7, #16]
 8006af6:	3b40      	subs	r3, #64	; 0x40
 8006af8:	61bb      	str	r3, [r7, #24]
        name = pendedTask->taskName;
 8006afa:	69bb      	ldr	r3, [r7, #24]
 8006afc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006afe:	61fb      	str	r3, [r7, #28]
        id = pendedTask->taskId;
 8006b00:	69bb      	ldr	r3, [r7, #24]
 8006b02:	695b      	ldr	r3, [r3, #20]
 8006b04:	623b      	str	r3, [r7, #32]
        SCHEDULER_UNLOCK(intSave);
 8006b06:	68fb      	ldr	r3, [r7, #12]
 8006b08:	4619      	mov	r1, r3
 8006b0a:	481a      	ldr	r0, [pc, #104]	; (8006b74 <OsMutexPendTaskList+0xd4>)
 8006b0c:	f7ff feca 	bl	80068a4 <LOS_SpinUnlockRestore>
        if (index == 0) {
 8006b10:	697b      	ldr	r3, [r7, #20]
 8006b12:	2b00      	cmp	r3, #0
 8006b14:	d106      	bne.n	8006b24 <OsMutexPendTaskList+0x84>
            PRINTK("Pended task: %u. name:%-15s, id:0x%-5x\n", index, name, id);
 8006b16:	6a3b      	ldr	r3, [r7, #32]
 8006b18:	69fa      	ldr	r2, [r7, #28]
 8006b1a:	6979      	ldr	r1, [r7, #20]
 8006b1c:	4817      	ldr	r0, [pc, #92]	; (8006b7c <OsMutexPendTaskList+0xdc>)
 8006b1e:	f7fd fecf 	bl	80048c0 <dprintf>
 8006b22:	e005      	b.n	8006b30 <OsMutexPendTaskList+0x90>
        } else {
            PRINTK("             %u. name:%-15s, id:0x%-5x\n", index, name, id);
 8006b24:	6a3b      	ldr	r3, [r7, #32]
 8006b26:	69fa      	ldr	r2, [r7, #28]
 8006b28:	6979      	ldr	r1, [r7, #20]
 8006b2a:	4815      	ldr	r0, [pc, #84]	; (8006b80 <OsMutexPendTaskList+0xe0>)
 8006b2c:	f7fd fec8 	bl	80048c0 <dprintf>
        }
        index++;
 8006b30:	697b      	ldr	r3, [r7, #20]
 8006b32:	3301      	adds	r3, #1
 8006b34:	617b      	str	r3, [r7, #20]
        SCHEDULER_LOCK(intSave);
 8006b36:	f107 030c 	add.w	r3, r7, #12
 8006b3a:	4619      	mov	r1, r3
 8006b3c:	480d      	ldr	r0, [pc, #52]	; (8006b74 <OsMutexPendTaskList+0xd4>)
 8006b3e:	f7ff fea3 	bl	8006888 <LOS_SpinLockSave>
    LOS_DL_LIST_FOR_EACH(listTmp, list) {
 8006b42:	693b      	ldr	r3, [r7, #16]
 8006b44:	685b      	ldr	r3, [r3, #4]
 8006b46:	613b      	str	r3, [r7, #16]
 8006b48:	693a      	ldr	r2, [r7, #16]
 8006b4a:	687b      	ldr	r3, [r7, #4]
 8006b4c:	429a      	cmp	r2, r3
 8006b4e:	d1d1      	bne.n	8006af4 <OsMutexPendTaskList+0x54>
    }
    SCHEDULER_UNLOCK(intSave);
 8006b50:	68fb      	ldr	r3, [r7, #12]
 8006b52:	4619      	mov	r1, r3
 8006b54:	4807      	ldr	r0, [pc, #28]	; (8006b74 <OsMutexPendTaskList+0xd4>)
 8006b56:	f7ff fea5 	bl	80068a4 <LOS_SpinUnlockRestore>
}
 8006b5a:	4b05      	ldr	r3, [pc, #20]	; (8006b70 <OsMutexPendTaskList+0xd0>)
 8006b5c:	681a      	ldr	r2, [r3, #0]
 8006b5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006b60:	405a      	eors	r2, r3
 8006b62:	d001      	beq.n	8006b68 <OsMutexPendTaskList+0xc8>
 8006b64:	f7fd fd3a 	bl	80045dc <__stack_chk_fail>
 8006b68:	3728      	adds	r7, #40	; 0x28
 8006b6a:	46bd      	mov	sp, r7
 8006b6c:	bd80      	pop	{r7, pc}
 8006b6e:	bf00      	nop
 8006b70:	080206a4 	.word	0x080206a4
 8006b74:	20000770 	.word	0x20000770
 8006b78:	08020640 	.word	0x08020640
 8006b7c:	08020654 	.word	0x08020654
 8006b80:	0802067c 	.word	0x0802067c

08006b84 <OsTaskHoldMutexList>:

STATIC VOID OsTaskHoldMutexList(MuxDLinkCB *muxDLCB)
{
 8006b84:	b580      	push	{r7, lr}
 8006b86:	b08c      	sub	sp, #48	; 0x30
 8006b88:	af00      	add	r7, sp, #0
 8006b8a:	6078      	str	r0, [r7, #4]
 8006b8c:	4b38      	ldr	r3, [pc, #224]	; (8006c70 <OsTaskHoldMutexList+0xec>)
 8006b8e:	681b      	ldr	r3, [r3, #0]
 8006b90:	62fb      	str	r3, [r7, #44]	; 0x2c
 8006b92:	f04f 0300 	mov.w	r3, #0
    UINT32 index = 0;
 8006b96:	2300      	movs	r3, #0
 8006b98:	613b      	str	r3, [r7, #16]
    MuxDLinkNode *muxDLNode = NULL;
 8006b9a:	2300      	movs	r3, #0
 8006b9c:	61bb      	str	r3, [r7, #24]
    CHAR *ownerName = NULL;
 8006b9e:	2300      	movs	r3, #0
 8006ba0:	61fb      	str	r3, [r7, #28]
    LosMuxCB *muxCB = NULL;
 8006ba2:	2300      	movs	r3, #0
 8006ba4:	623b      	str	r3, [r7, #32]
    LOS_DL_LIST *list = NULL;
 8006ba6:	2300      	movs	r3, #0
 8006ba8:	617b      	str	r3, [r7, #20]
    LOS_DL_LIST *listTmp = NULL;
 8006baa:	2300      	movs	r3, #0
 8006bac:	627b      	str	r3, [r7, #36]	; 0x24
    UINT32 count, intSave;

    SCHEDULER_LOCK(intSave);
 8006bae:	f107 030c 	add.w	r3, r7, #12
 8006bb2:	4619      	mov	r1, r3
 8006bb4:	482f      	ldr	r0, [pc, #188]	; (8006c74 <OsTaskHoldMutexList+0xf0>)
 8006bb6:	f7ff fe67 	bl	8006888 <LOS_SpinLockSave>
    if (LOS_ListEmpty(&muxDLCB->muxListHead) == TRUE) {
 8006bba:	687b      	ldr	r3, [r7, #4]
 8006bbc:	4618      	mov	r0, r3
 8006bbe:	f7ff fe3f 	bl	8006840 <LOS_ListEmpty>
 8006bc2:	4603      	mov	r3, r0
 8006bc4:	2b01      	cmp	r3, #1
 8006bc6:	d108      	bne.n	8006bda <OsTaskHoldMutexList+0x56>
        SCHEDULER_UNLOCK(intSave);
 8006bc8:	68fb      	ldr	r3, [r7, #12]
 8006bca:	4619      	mov	r1, r3
 8006bcc:	4829      	ldr	r0, [pc, #164]	; (8006c74 <OsTaskHoldMutexList+0xf0>)
 8006bce:	f7ff fe69 	bl	80068a4 <LOS_SpinUnlockRestore>
        PRINTK("null\n");
 8006bd2:	4829      	ldr	r0, [pc, #164]	; (8006c78 <OsTaskHoldMutexList+0xf4>)
 8006bd4:	f7fd fe74 	bl	80048c0 <dprintf>
            index++;
            SCHEDULER_LOCK(intSave);
        }
        SCHEDULER_UNLOCK(intSave);
    }
}
 8006bd8:	e03e      	b.n	8006c58 <OsTaskHoldMutexList+0xd4>
        LOS_DL_LIST_FOR_EACH(list, &muxDLCB->muxListHead) {
 8006bda:	687b      	ldr	r3, [r7, #4]
 8006bdc:	685b      	ldr	r3, [r3, #4]
 8006bde:	617b      	str	r3, [r7, #20]
 8006be0:	e031      	b.n	8006c46 <OsTaskHoldMutexList+0xc2>
            muxDLNode = LOS_DL_LIST_ENTRY(list, MuxDLinkNode, muxList);
 8006be2:	697b      	ldr	r3, [r7, #20]
 8006be4:	61bb      	str	r3, [r7, #24]
            muxCB = (LosMuxCB *)muxDLNode->muxCB;
 8006be6:	69bb      	ldr	r3, [r7, #24]
 8006be8:	689b      	ldr	r3, [r3, #8]
 8006bea:	623b      	str	r3, [r7, #32]
            count = muxCB->muxCount;
 8006bec:	6a3b      	ldr	r3, [r7, #32]
 8006bee:	899b      	ldrh	r3, [r3, #12]
 8006bf0:	62bb      	str	r3, [r7, #40]	; 0x28
            ownerName = muxCB->owner->taskName;
 8006bf2:	6a3b      	ldr	r3, [r7, #32]
 8006bf4:	689b      	ldr	r3, [r3, #8]
 8006bf6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006bf8:	61fb      	str	r3, [r7, #28]
            SCHEDULER_UNLOCK(intSave);
 8006bfa:	68fb      	ldr	r3, [r7, #12]
 8006bfc:	4619      	mov	r1, r3
 8006bfe:	481d      	ldr	r0, [pc, #116]	; (8006c74 <OsTaskHoldMutexList+0xf0>)
 8006c00:	f7ff fe50 	bl	80068a4 <LOS_SpinUnlockRestore>
            PRINTK("<Mutex%u info>\n", index);
 8006c04:	6939      	ldr	r1, [r7, #16]
 8006c06:	481d      	ldr	r0, [pc, #116]	; (8006c7c <OsTaskHoldMutexList+0xf8>)
 8006c08:	f7fd fe5a 	bl	80048c0 <dprintf>
            PRINTK("Ptr handle:%p\n", muxCB);
 8006c0c:	6a39      	ldr	r1, [r7, #32]
 8006c0e:	481c      	ldr	r0, [pc, #112]	; (8006c80 <OsTaskHoldMutexList+0xfc>)
 8006c10:	f7fd fe56 	bl	80048c0 <dprintf>
            PRINTK("Owner:%s\n", ownerName);
 8006c14:	69f9      	ldr	r1, [r7, #28]
 8006c16:	481b      	ldr	r0, [pc, #108]	; (8006c84 <OsTaskHoldMutexList+0x100>)
 8006c18:	f7fd fe52 	bl	80048c0 <dprintf>
            PRINTK("Count:%u\n", count);
 8006c1c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8006c1e:	481a      	ldr	r0, [pc, #104]	; (8006c88 <OsTaskHoldMutexList+0x104>)
 8006c20:	f7fd fe4e 	bl	80048c0 <dprintf>
            listTmp = &muxCB->muxList;
 8006c24:	6a3b      	ldr	r3, [r7, #32]
 8006c26:	627b      	str	r3, [r7, #36]	; 0x24
            OsMutexPendTaskList(listTmp);
 8006c28:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8006c2a:	f7ff ff39 	bl	8006aa0 <OsMutexPendTaskList>
            index++;
 8006c2e:	693b      	ldr	r3, [r7, #16]
 8006c30:	3301      	adds	r3, #1
 8006c32:	613b      	str	r3, [r7, #16]
            SCHEDULER_LOCK(intSave);
 8006c34:	f107 030c 	add.w	r3, r7, #12
 8006c38:	4619      	mov	r1, r3
 8006c3a:	480e      	ldr	r0, [pc, #56]	; (8006c74 <OsTaskHoldMutexList+0xf0>)
 8006c3c:	f7ff fe24 	bl	8006888 <LOS_SpinLockSave>
        LOS_DL_LIST_FOR_EACH(list, &muxDLCB->muxListHead) {
 8006c40:	697b      	ldr	r3, [r7, #20]
 8006c42:	685b      	ldr	r3, [r3, #4]
 8006c44:	617b      	str	r3, [r7, #20]
 8006c46:	687b      	ldr	r3, [r7, #4]
 8006c48:	697a      	ldr	r2, [r7, #20]
 8006c4a:	429a      	cmp	r2, r3
 8006c4c:	d1c9      	bne.n	8006be2 <OsTaskHoldMutexList+0x5e>
        SCHEDULER_UNLOCK(intSave);
 8006c4e:	68fb      	ldr	r3, [r7, #12]
 8006c50:	4619      	mov	r1, r3
 8006c52:	4808      	ldr	r0, [pc, #32]	; (8006c74 <OsTaskHoldMutexList+0xf0>)
 8006c54:	f7ff fe26 	bl	80068a4 <LOS_SpinUnlockRestore>
}
 8006c58:	bf00      	nop
 8006c5a:	4b05      	ldr	r3, [pc, #20]	; (8006c70 <OsTaskHoldMutexList+0xec>)
 8006c5c:	681a      	ldr	r2, [r3, #0]
 8006c5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006c60:	405a      	eors	r2, r3
 8006c62:	d001      	beq.n	8006c68 <OsTaskHoldMutexList+0xe4>
 8006c64:	f7fd fcba 	bl	80045dc <__stack_chk_fail>
 8006c68:	3730      	adds	r7, #48	; 0x30
 8006c6a:	46bd      	mov	sp, r7
 8006c6c:	bd80      	pop	{r7, pc}
 8006c6e:	bf00      	nop
 8006c70:	080206e8 	.word	0x080206e8
 8006c74:	20000770 	.word	0x20000770
 8006c78:	080206a8 	.word	0x080206a8
 8006c7c:	080206b0 	.word	0x080206b0
 8006c80:	080206c0 	.word	0x080206c0
 8006c84:	080206d0 	.word	0x080206d0
 8006c88:	080206dc 	.word	0x080206dc

08006c8c <OsMutexDlockCheck>:

VOID OsMutexDlockCheck(VOID)
{
 8006c8c:	b5b0      	push	{r4, r5, r7, lr}
 8006c8e:	b088      	sub	sp, #32
 8006c90:	af00      	add	r7, sp, #0
 8006c92:	4b38      	ldr	r3, [pc, #224]	; (8006d74 <OsMutexDlockCheck+0xe8>)
 8006c94:	681b      	ldr	r3, [r3, #0]
 8006c96:	61fb      	str	r3, [r7, #28]
 8006c98:	f04f 0300 	mov.w	r3, #0
    UINT32 loop, intSave;
    UINT32 taskId;
    CHAR *name = NULL;
 8006c9c:	2300      	movs	r3, #0
 8006c9e:	60fb      	str	r3, [r7, #12]
    LosTaskCB *taskCB = NULL;
 8006ca0:	2300      	movs	r3, #0
 8006ca2:	613b      	str	r3, [r7, #16]
    MuxDLinkCB *muxDLCB = NULL;
 8006ca4:	2300      	movs	r3, #0
 8006ca6:	617b      	str	r3, [r7, #20]

    SCHEDULER_LOCK(intSave);
 8006ca8:	1d3b      	adds	r3, r7, #4
 8006caa:	4619      	mov	r1, r3
 8006cac:	4832      	ldr	r0, [pc, #200]	; (8006d78 <OsMutexDlockCheck+0xec>)
 8006cae:	f7ff fdeb 	bl	8006888 <LOS_SpinLockSave>
    for (loop = 0; loop < g_taskMaxNum; loop++) {
 8006cb2:	2300      	movs	r3, #0
 8006cb4:	60bb      	str	r3, [r7, #8]
 8006cb6:	e048      	b.n	8006d4a <OsMutexDlockCheck+0xbe>
        taskCB = (LosTaskCB *)g_taskCBArray + loop;
 8006cb8:	4b30      	ldr	r3, [pc, #192]	; (8006d7c <OsMutexDlockCheck+0xf0>)
 8006cba:	6819      	ldr	r1, [r3, #0]
 8006cbc:	68ba      	ldr	r2, [r7, #8]
 8006cbe:	4613      	mov	r3, r2
 8006cc0:	009b      	lsls	r3, r3, #2
 8006cc2:	4413      	add	r3, r2
 8006cc4:	015b      	lsls	r3, r3, #5
 8006cc6:	440b      	add	r3, r1
 8006cc8:	613b      	str	r3, [r7, #16]
        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 8006cca:	693b      	ldr	r3, [r7, #16]
 8006ccc:	889b      	ldrh	r3, [r3, #4]
 8006cce:	f003 0301 	and.w	r3, r3, #1
 8006cd2:	2b00      	cmp	r3, #0
 8006cd4:	d135      	bne.n	8006d42 <OsMutexDlockCheck+0xb6>
            continue;
        }

        muxDLCB = &g_muxDeadlockCBArray[taskCB->taskId];
 8006cd6:	4b2a      	ldr	r3, [pc, #168]	; (8006d80 <OsMutexDlockCheck+0xf4>)
 8006cd8:	681a      	ldr	r2, [r3, #0]
 8006cda:	693b      	ldr	r3, [r7, #16]
 8006cdc:	695b      	ldr	r3, [r3, #20]
 8006cde:	011b      	lsls	r3, r3, #4
 8006ce0:	4413      	add	r3, r2
 8006ce2:	617b      	str	r3, [r7, #20]
        if ((LOS_TickCountGet() - muxDLCB->lastAccessTime) > OS_MUX_DEADLOCK_CHECK_THRESHOLD) {
 8006ce4:	f7fd fb42 	bl	800436c <LOS_TickCountGet>
 8006ce8:	697b      	ldr	r3, [r7, #20]
 8006cea:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8006cee:	1a84      	subs	r4, r0, r2
 8006cf0:	eb61 0503 	sbc.w	r5, r1, r3
 8006cf4:	f64e 2260 	movw	r2, #60000	; 0xea60
 8006cf8:	f04f 0300 	mov.w	r3, #0
 8006cfc:	42ab      	cmp	r3, r5
 8006cfe:	bf08      	it	eq
 8006d00:	42a2      	cmpeq	r2, r4
 8006d02:	d21f      	bcs.n	8006d44 <OsMutexDlockCheck+0xb8>
            name = taskCB->taskName;
 8006d04:	693b      	ldr	r3, [r7, #16]
 8006d06:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006d08:	60fb      	str	r3, [r7, #12]
            taskId = taskCB->taskId;
 8006d0a:	693b      	ldr	r3, [r7, #16]
 8006d0c:	695b      	ldr	r3, [r3, #20]
 8006d0e:	61bb      	str	r3, [r7, #24]
            SCHEDULER_UNLOCK(intSave);
 8006d10:	687b      	ldr	r3, [r7, #4]
 8006d12:	4619      	mov	r1, r3
 8006d14:	4818      	ldr	r0, [pc, #96]	; (8006d78 <OsMutexDlockCheck+0xec>)
 8006d16:	f7ff fdc5 	bl	80068a4 <LOS_SpinUnlockRestore>
            PRINTK("Task_name:%s, ID:0x%x, holds the Mutexs below:\n", name, taskId);
 8006d1a:	69ba      	ldr	r2, [r7, #24]
 8006d1c:	68f9      	ldr	r1, [r7, #12]
 8006d1e:	4819      	ldr	r0, [pc, #100]	; (8006d84 <OsMutexDlockCheck+0xf8>)
 8006d20:	f7fd fdce 	bl	80048c0 <dprintf>
            OsTaskHoldMutexList(muxDLCB);
 8006d24:	6978      	ldr	r0, [r7, #20]
 8006d26:	f7ff ff2d 	bl	8006b84 <OsTaskHoldMutexList>
            OsDeadlockBackTrace(taskCB);
 8006d2a:	6938      	ldr	r0, [r7, #16]
 8006d2c:	f7ff fe9e 	bl	8006a6c <OsDeadlockBackTrace>
            PRINTK("\n");
 8006d30:	4815      	ldr	r0, [pc, #84]	; (8006d88 <OsMutexDlockCheck+0xfc>)
 8006d32:	f7fd fdc5 	bl	80048c0 <dprintf>
            SCHEDULER_LOCK(intSave);
 8006d36:	1d3b      	adds	r3, r7, #4
 8006d38:	4619      	mov	r1, r3
 8006d3a:	480f      	ldr	r0, [pc, #60]	; (8006d78 <OsMutexDlockCheck+0xec>)
 8006d3c:	f7ff fda4 	bl	8006888 <LOS_SpinLockSave>
 8006d40:	e000      	b.n	8006d44 <OsMutexDlockCheck+0xb8>
            continue;
 8006d42:	bf00      	nop
    for (loop = 0; loop < g_taskMaxNum; loop++) {
 8006d44:	68bb      	ldr	r3, [r7, #8]
 8006d46:	3301      	adds	r3, #1
 8006d48:	60bb      	str	r3, [r7, #8]
 8006d4a:	4b10      	ldr	r3, [pc, #64]	; (8006d8c <OsMutexDlockCheck+0x100>)
 8006d4c:	681b      	ldr	r3, [r3, #0]
 8006d4e:	68ba      	ldr	r2, [r7, #8]
 8006d50:	429a      	cmp	r2, r3
 8006d52:	d3b1      	bcc.n	8006cb8 <OsMutexDlockCheck+0x2c>
        }
    }
    SCHEDULER_UNLOCK(intSave);
 8006d54:	687b      	ldr	r3, [r7, #4]
 8006d56:	4619      	mov	r1, r3
 8006d58:	4807      	ldr	r0, [pc, #28]	; (8006d78 <OsMutexDlockCheck+0xec>)
 8006d5a:	f7ff fda3 	bl	80068a4 <LOS_SpinUnlockRestore>
}
 8006d5e:	bf00      	nop
 8006d60:	4b04      	ldr	r3, [pc, #16]	; (8006d74 <OsMutexDlockCheck+0xe8>)
 8006d62:	681a      	ldr	r2, [r3, #0]
 8006d64:	69fb      	ldr	r3, [r7, #28]
 8006d66:	405a      	eors	r2, r3
 8006d68:	d001      	beq.n	8006d6e <OsMutexDlockCheck+0xe2>
 8006d6a:	f7fd fc37 	bl	80045dc <__stack_chk_fail>
 8006d6e:	3720      	adds	r7, #32
 8006d70:	46bd      	mov	sp, r7
 8006d72:	bdb0      	pop	{r4, r5, r7, pc}
 8006d74:	08020720 	.word	0x08020720
 8006d78:	20000770 	.word	0x20000770
 8006d7c:	200036c4 	.word	0x200036c4
 8006d80:	200007ac 	.word	0x200007ac
 8006d84:	080206ec 	.word	0x080206ec
 8006d88:	0802071c 	.word	0x0802071c
 8006d8c:	200036d8 	.word	0x200036d8

08006d90 <OsShellCmdMuxDeadlockCheck>:

#ifdef LOSCFG_SHELL
UINT32 OsShellCmdMuxDeadlockCheck(UINT32 argc, const CHAR **argv)
{
 8006d90:	b580      	push	{r7, lr}
 8006d92:	b082      	sub	sp, #8
 8006d94:	af00      	add	r7, sp, #0
 8006d96:	6078      	str	r0, [r7, #4]
 8006d98:	6039      	str	r1, [r7, #0]
    if (argc > 0) {
 8006d9a:	687b      	ldr	r3, [r7, #4]
 8006d9c:	2b00      	cmp	r3, #0
 8006d9e:	d005      	beq.n	8006dac <OsShellCmdMuxDeadlockCheck+0x1c>
        PRINTK("\nUsage: dlock\n");
 8006da0:	4809      	ldr	r0, [pc, #36]	; (8006dc8 <OsShellCmdMuxDeadlockCheck+0x38>)
 8006da2:	f7fd fd8d 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8006da6:	f04f 33ff 	mov.w	r3, #4294967295
 8006daa:	e008      	b.n	8006dbe <OsShellCmdMuxDeadlockCheck+0x2e>
    }
    PRINTK("Start mutexs deadlock check: \n");
 8006dac:	4807      	ldr	r0, [pc, #28]	; (8006dcc <OsShellCmdMuxDeadlockCheck+0x3c>)
 8006dae:	f7fd fd87 	bl	80048c0 <dprintf>
    OsMutexDlockCheck();
 8006db2:	f7ff ff6b 	bl	8006c8c <OsMutexDlockCheck>
    PRINTK("-----------End-----------\n");
 8006db6:	4806      	ldr	r0, [pc, #24]	; (8006dd0 <OsShellCmdMuxDeadlockCheck+0x40>)
 8006db8:	f7fd fd82 	bl	80048c0 <dprintf>
    return LOS_OK;
 8006dbc:	2300      	movs	r3, #0
}
 8006dbe:	4618      	mov	r0, r3
 8006dc0:	3708      	adds	r7, #8
 8006dc2:	46bd      	mov	sp, r7
 8006dc4:	bd80      	pop	{r7, pc}
 8006dc6:	bf00      	nop
 8006dc8:	08020724 	.word	0x08020724
 8006dcc:	08020734 	.word	0x08020734
 8006dd0:	08020754 	.word	0x08020754

08006dd4 <LOS_ListEmpty>:
{
 8006dd4:	b480      	push	{r7}
 8006dd6:	b083      	sub	sp, #12
 8006dd8:	af00      	add	r7, sp, #0
 8006dda:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8006ddc:	687b      	ldr	r3, [r7, #4]
 8006dde:	685b      	ldr	r3, [r3, #4]
 8006de0:	687a      	ldr	r2, [r7, #4]
 8006de2:	429a      	cmp	r2, r3
 8006de4:	bf0c      	ite	eq
 8006de6:	2301      	moveq	r3, #1
 8006de8:	2300      	movne	r3, #0
 8006dea:	b2db      	uxtb	r3, r3
}
 8006dec:	4618      	mov	r0, r3
 8006dee:	370c      	adds	r7, #12
 8006df0:	46bd      	mov	sp, r7
 8006df2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006df6:	4770      	bx	lr

08006df8 <LOS_IntLock>:
{
 8006df8:	b580      	push	{r7, lr}
 8006dfa:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8006dfc:	f7f9 ff64 	bl	8000cc8 <ArchIntLock>
 8006e00:	4603      	mov	r3, r0
}
 8006e02:	4618      	mov	r0, r3
 8006e04:	bd80      	pop	{r7, pc}

08006e06 <LOS_IntRestore>:
{
 8006e06:	b580      	push	{r7, lr}
 8006e08:	b082      	sub	sp, #8
 8006e0a:	af00      	add	r7, sp, #0
 8006e0c:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8006e0e:	6878      	ldr	r0, [r7, #4]
 8006e10:	f7f9 ff62 	bl	8000cd8 <ArchIntRestore>
}
 8006e14:	bf00      	nop
 8006e16:	3708      	adds	r7, #8
 8006e18:	46bd      	mov	sp, r7
 8006e1a:	bd80      	pop	{r7, pc}

08006e1c <LOS_SpinLockSave>:
{
 8006e1c:	b580      	push	{r7, lr}
 8006e1e:	b082      	sub	sp, #8
 8006e20:	af00      	add	r7, sp, #0
 8006e22:	6078      	str	r0, [r7, #4]
 8006e24:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8006e26:	f7ff ffe7 	bl	8006df8 <LOS_IntLock>
 8006e2a:	4602      	mov	r2, r0
 8006e2c:	683b      	ldr	r3, [r7, #0]
 8006e2e:	601a      	str	r2, [r3, #0]
}
 8006e30:	bf00      	nop
 8006e32:	3708      	adds	r7, #8
 8006e34:	46bd      	mov	sp, r7
 8006e36:	bd80      	pop	{r7, pc}

08006e38 <LOS_SpinUnlockRestore>:
{
 8006e38:	b580      	push	{r7, lr}
 8006e3a:	b082      	sub	sp, #8
 8006e3c:	af00      	add	r7, sp, #0
 8006e3e:	6078      	str	r0, [r7, #4]
 8006e40:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8006e42:	6838      	ldr	r0, [r7, #0]
 8006e44:	f7ff ffdf 	bl	8006e06 <LOS_IntRestore>
}
 8006e48:	bf00      	nop
 8006e4a:	3708      	adds	r7, #8
 8006e4c:	46bd      	mov	sp, r7
 8006e4e:	bd80      	pop	{r7, pc}

08006e50 <OsSemPendedTaskNamePrint>:

#ifdef LOSCFG_DEBUG_SEMAPHORE
#define OS_ALL_SEM_MASK 0xffffffff

STATIC VOID OsSemPendedTaskNamePrint(LosSemCB *semNode)
{
 8006e50:	b580      	push	{r7, lr}
 8006e52:	b098      	sub	sp, #96	; 0x60
 8006e54:	af00      	add	r7, sp, #0
 8006e56:	6078      	str	r0, [r7, #4]
 8006e58:	4b40      	ldr	r3, [pc, #256]	; (8006f5c <OsSemPendedTaskNamePrint+0x10c>)
 8006e5a:	681b      	ldr	r3, [r3, #0]
 8006e5c:	65fb      	str	r3, [r7, #92]	; 0x5c
 8006e5e:	f04f 0300 	mov.w	r3, #0
    LosTaskCB *tskCB = NULL;
 8006e62:	2300      	movs	r3, #0
 8006e64:	613b      	str	r3, [r7, #16]
    CHAR *nameArr[LOSCFG_BASE_CORE_TSK_LIMIT] = {0};
 8006e66:	f107 031c 	add.w	r3, r7, #28
 8006e6a:	2240      	movs	r2, #64	; 0x40
 8006e6c:	2100      	movs	r1, #0
 8006e6e:	4618      	mov	r0, r3
 8006e70:	f008 fa4a 	bl	800f308 <memset>
    UINT32 i, intSave;
    UINT32 num = 0;
 8006e74:	2300      	movs	r3, #0
 8006e76:	61bb      	str	r3, [r7, #24]

    SCHEDULER_LOCK(intSave);
 8006e78:	f107 030c 	add.w	r3, r7, #12
 8006e7c:	4619      	mov	r1, r3
 8006e7e:	4838      	ldr	r0, [pc, #224]	; (8006f60 <OsSemPendedTaskNamePrint+0x110>)
 8006e80:	f7ff ffcc 	bl	8006e1c <LOS_SpinLockSave>
    if ((semNode->semStat == LOS_UNUSED) || (LOS_ListEmpty(&semNode->semList))) {
 8006e84:	687b      	ldr	r3, [r7, #4]
 8006e86:	781b      	ldrb	r3, [r3, #0]
 8006e88:	2b00      	cmp	r3, #0
 8006e8a:	d007      	beq.n	8006e9c <OsSemPendedTaskNamePrint+0x4c>
 8006e8c:	687b      	ldr	r3, [r7, #4]
 8006e8e:	3308      	adds	r3, #8
 8006e90:	4618      	mov	r0, r3
 8006e92:	f7ff ff9f 	bl	8006dd4 <LOS_ListEmpty>
 8006e96:	4603      	mov	r3, r0
 8006e98:	2b00      	cmp	r3, #0
 8006e9a:	d005      	beq.n	8006ea8 <OsSemPendedTaskNamePrint+0x58>
        SCHEDULER_UNLOCK(intSave);
 8006e9c:	68fb      	ldr	r3, [r7, #12]
 8006e9e:	4619      	mov	r1, r3
 8006ea0:	482f      	ldr	r0, [pc, #188]	; (8006f60 <OsSemPendedTaskNamePrint+0x110>)
 8006ea2:	f7ff ffc9 	bl	8006e38 <LOS_SpinUnlockRestore>
 8006ea6:	e04e      	b.n	8006f46 <OsSemPendedTaskNamePrint+0xf6>
        return;
    }

    LOS_DL_LIST_FOR_EACH_ENTRY(tskCB, &semNode->semList, LosTaskCB, pendList) {
 8006ea8:	687b      	ldr	r3, [r7, #4]
 8006eaa:	68db      	ldr	r3, [r3, #12]
 8006eac:	3b40      	subs	r3, #64	; 0x40
 8006eae:	613b      	str	r3, [r7, #16]
 8006eb0:	e011      	b.n	8006ed6 <OsSemPendedTaskNamePrint+0x86>
        nameArr[num++] = tskCB->taskName;
 8006eb2:	69bb      	ldr	r3, [r7, #24]
 8006eb4:	1c5a      	adds	r2, r3, #1
 8006eb6:	61ba      	str	r2, [r7, #24]
 8006eb8:	693a      	ldr	r2, [r7, #16]
 8006eba:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8006ebc:	009b      	lsls	r3, r3, #2
 8006ebe:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8006ec2:	440b      	add	r3, r1
 8006ec4:	f843 2c44 	str.w	r2, [r3, #-68]
        if (num == LOSCFG_BASE_CORE_TSK_LIMIT) {
 8006ec8:	69bb      	ldr	r3, [r7, #24]
 8006eca:	2b10      	cmp	r3, #16
 8006ecc:	d00b      	beq.n	8006ee6 <OsSemPendedTaskNamePrint+0x96>
    LOS_DL_LIST_FOR_EACH_ENTRY(tskCB, &semNode->semList, LosTaskCB, pendList) {
 8006ece:	693b      	ldr	r3, [r7, #16]
 8006ed0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8006ed2:	3b40      	subs	r3, #64	; 0x40
 8006ed4:	613b      	str	r3, [r7, #16]
 8006ed6:	693b      	ldr	r3, [r7, #16]
 8006ed8:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8006edc:	687b      	ldr	r3, [r7, #4]
 8006ede:	3308      	adds	r3, #8
 8006ee0:	429a      	cmp	r2, r3
 8006ee2:	d1e6      	bne.n	8006eb2 <OsSemPendedTaskNamePrint+0x62>
 8006ee4:	e000      	b.n	8006ee8 <OsSemPendedTaskNamePrint+0x98>
            break;
 8006ee6:	bf00      	nop
        }
    }
    SCHEDULER_UNLOCK(intSave);
 8006ee8:	68fb      	ldr	r3, [r7, #12]
 8006eea:	4619      	mov	r1, r3
 8006eec:	481c      	ldr	r0, [pc, #112]	; (8006f60 <OsSemPendedTaskNamePrint+0x110>)
 8006eee:	f7ff ffa3 	bl	8006e38 <LOS_SpinUnlockRestore>

    PRINTK("Pended task list : ");
 8006ef2:	481c      	ldr	r0, [pc, #112]	; (8006f64 <OsSemPendedTaskNamePrint+0x114>)
 8006ef4:	f7fd fce4 	bl	80048c0 <dprintf>
    for (i = 0; i < num; i++) {
 8006ef8:	2300      	movs	r3, #0
 8006efa:	617b      	str	r3, [r7, #20]
 8006efc:	e01c      	b.n	8006f38 <OsSemPendedTaskNamePrint+0xe8>
        if (i == 0) {
 8006efe:	697b      	ldr	r3, [r7, #20]
 8006f00:	2b00      	cmp	r3, #0
 8006f02:	d10b      	bne.n	8006f1c <OsSemPendedTaskNamePrint+0xcc>
            PRINTK("%s\n", nameArr[i]);
 8006f04:	697b      	ldr	r3, [r7, #20]
 8006f06:	009b      	lsls	r3, r3, #2
 8006f08:	f107 0260 	add.w	r2, r7, #96	; 0x60
 8006f0c:	4413      	add	r3, r2
 8006f0e:	f853 3c44 	ldr.w	r3, [r3, #-68]
 8006f12:	4619      	mov	r1, r3
 8006f14:	4814      	ldr	r0, [pc, #80]	; (8006f68 <OsSemPendedTaskNamePrint+0x118>)
 8006f16:	f7fd fcd3 	bl	80048c0 <dprintf>
 8006f1a:	e00a      	b.n	8006f32 <OsSemPendedTaskNamePrint+0xe2>
        } else {
            PRINTK(", %s", nameArr[i]);
 8006f1c:	697b      	ldr	r3, [r7, #20]
 8006f1e:	009b      	lsls	r3, r3, #2
 8006f20:	f107 0260 	add.w	r2, r7, #96	; 0x60
 8006f24:	4413      	add	r3, r2
 8006f26:	f853 3c44 	ldr.w	r3, [r3, #-68]
 8006f2a:	4619      	mov	r1, r3
 8006f2c:	480f      	ldr	r0, [pc, #60]	; (8006f6c <OsSemPendedTaskNamePrint+0x11c>)
 8006f2e:	f7fd fcc7 	bl	80048c0 <dprintf>
    for (i = 0; i < num; i++) {
 8006f32:	697b      	ldr	r3, [r7, #20]
 8006f34:	3301      	adds	r3, #1
 8006f36:	617b      	str	r3, [r7, #20]
 8006f38:	697a      	ldr	r2, [r7, #20]
 8006f3a:	69bb      	ldr	r3, [r7, #24]
 8006f3c:	429a      	cmp	r2, r3
 8006f3e:	d3de      	bcc.n	8006efe <OsSemPendedTaskNamePrint+0xae>
        }
    }
    PRINTK("\n");
 8006f40:	480b      	ldr	r0, [pc, #44]	; (8006f70 <OsSemPendedTaskNamePrint+0x120>)
 8006f42:	f7fd fcbd 	bl	80048c0 <dprintf>
}
 8006f46:	4b05      	ldr	r3, [pc, #20]	; (8006f5c <OsSemPendedTaskNamePrint+0x10c>)
 8006f48:	681a      	ldr	r2, [r3, #0]
 8006f4a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8006f4c:	405a      	eors	r2, r3
 8006f4e:	d001      	beq.n	8006f54 <OsSemPendedTaskNamePrint+0x104>
 8006f50:	f7fd fb44 	bl	80045dc <__stack_chk_fail>
 8006f54:	3760      	adds	r7, #96	; 0x60
 8006f56:	46bd      	mov	sp, r7
 8006f58:	bd80      	pop	{r7, pc}
 8006f5a:	bf00      	nop
 8006f5c:	0802079c 	.word	0x0802079c
 8006f60:	20000770 	.word	0x20000770
 8006f64:	08020778 	.word	0x08020778
 8006f68:	0802078c 	.word	0x0802078c
 8006f6c:	08020790 	.word	0x08020790
 8006f70:	08020798 	.word	0x08020798

08006f74 <SemCompareValue>:
    TSK_ENTRY_FUNC creator; /* The task entry who created this sem */
} SemDebugCB;
STATIC SemDebugCB *g_semDebugArray = NULL;

STATIC BOOL SemCompareValue(const SortParam *sortParam, UINT32 left, UINT32 right)
{
 8006f74:	b490      	push	{r4, r7}
 8006f76:	b084      	sub	sp, #16
 8006f78:	af00      	add	r7, sp, #0
 8006f7a:	60f8      	str	r0, [r7, #12]
 8006f7c:	60b9      	str	r1, [r7, #8]
 8006f7e:	607a      	str	r2, [r7, #4]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 8006f80:	68fb      	ldr	r3, [r7, #12]
 8006f82:	681a      	ldr	r2, [r3, #0]
 8006f84:	68fb      	ldr	r3, [r7, #12]
 8006f86:	685b      	ldr	r3, [r3, #4]
 8006f88:	68b9      	ldr	r1, [r7, #8]
 8006f8a:	fb01 f103 	mul.w	r1, r1, r3
 8006f8e:	68fb      	ldr	r3, [r7, #12]
 8006f90:	68db      	ldr	r3, [r3, #12]
 8006f92:	440b      	add	r3, r1
 8006f94:	4413      	add	r3, r2
 8006f96:	e9d3 2300 	ldrd	r2, r3, [r3]
            *((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, right)));
 8006f9a:	68f9      	ldr	r1, [r7, #12]
 8006f9c:	6808      	ldr	r0, [r1, #0]
 8006f9e:	68f9      	ldr	r1, [r7, #12]
 8006fa0:	6849      	ldr	r1, [r1, #4]
 8006fa2:	687c      	ldr	r4, [r7, #4]
 8006fa4:	fb04 f401 	mul.w	r4, r4, r1
 8006fa8:	68f9      	ldr	r1, [r7, #12]
 8006faa:	68c9      	ldr	r1, [r1, #12]
 8006fac:	4421      	add	r1, r4
 8006fae:	4401      	add	r1, r0
 8006fb0:	e9d1 0100 	ldrd	r0, r1, [r1]
    return (*((UINT64 *)(VOID *)SORT_ELEM_ADDR(sortParam, left)) >
 8006fb4:	4299      	cmp	r1, r3
 8006fb6:	bf08      	it	eq
 8006fb8:	4290      	cmpeq	r0, r2
 8006fba:	bf34      	ite	cc
 8006fbc:	2301      	movcc	r3, #1
 8006fbe:	2300      	movcs	r3, #0
 8006fc0:	b2db      	uxtb	r3, r3
}
 8006fc2:	4618      	mov	r0, r3
 8006fc4:	3710      	adds	r7, #16
 8006fc6:	46bd      	mov	sp, r7
 8006fc8:	bc90      	pop	{r4, r7}
 8006fca:	4770      	bx	lr

08006fcc <OsSemDbgInit>:

UINT32 OsSemDbgInit(VOID)
{
 8006fcc:	b580      	push	{r7, lr}
 8006fce:	b082      	sub	sp, #8
 8006fd0:	af00      	add	r7, sp, #0
    UINT32 size = LOSCFG_BASE_IPC_SEM_LIMIT * sizeof(SemDebugCB);
 8006fd2:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8006fd6:	607b      	str	r3, [r7, #4]
    /* system resident memory, don't free */
    g_semDebugArray = (SemDebugCB *)LOS_MemAlloc(m_aucSysMem1, size);
 8006fd8:	4b10      	ldr	r3, [pc, #64]	; (800701c <OsSemDbgInit+0x50>)
 8006fda:	681b      	ldr	r3, [r3, #0]
 8006fdc:	6879      	ldr	r1, [r7, #4]
 8006fde:	4618      	mov	r0, r3
 8006fe0:	f002 fa18 	bl	8009414 <LOS_MemAlloc>
 8006fe4:	4603      	mov	r3, r0
 8006fe6:	4a0e      	ldr	r2, [pc, #56]	; (8007020 <OsSemDbgInit+0x54>)
 8006fe8:	6013      	str	r3, [r2, #0]
    if (g_semDebugArray == NULL) {
 8006fea:	4b0d      	ldr	r3, [pc, #52]	; (8007020 <OsSemDbgInit+0x54>)
 8006fec:	681b      	ldr	r3, [r3, #0]
 8006fee:	2b00      	cmp	r3, #0
 8006ff0:	d108      	bne.n	8007004 <OsSemDbgInit+0x38>
        PRINT_ERR("%s: malloc failed!\n", __FUNCTION__);
 8006ff2:	480c      	ldr	r0, [pc, #48]	; (8007024 <OsSemDbgInit+0x58>)
 8006ff4:	f7fd fc64 	bl	80048c0 <dprintf>
 8006ff8:	490b      	ldr	r1, [pc, #44]	; (8007028 <OsSemDbgInit+0x5c>)
 8006ffa:	480c      	ldr	r0, [pc, #48]	; (800702c <OsSemDbgInit+0x60>)
 8006ffc:	f7fd fc60 	bl	80048c0 <dprintf>
        return LOS_NOK;
 8007000:	2301      	movs	r3, #1
 8007002:	e007      	b.n	8007014 <OsSemDbgInit+0x48>
    }
    (VOID)memset_s(g_semDebugArray, size, 0, size);
 8007004:	4b06      	ldr	r3, [pc, #24]	; (8007020 <OsSemDbgInit+0x54>)
 8007006:	6818      	ldr	r0, [r3, #0]
 8007008:	687b      	ldr	r3, [r7, #4]
 800700a:	2200      	movs	r2, #0
 800700c:	6879      	ldr	r1, [r7, #4]
 800700e:	f7fb f849 	bl	80020a4 <memset_s>
    return LOS_OK;
 8007012:	2300      	movs	r3, #0
}
 8007014:	4618      	mov	r0, r3
 8007016:	3708      	adds	r7, #8
 8007018:	46bd      	mov	sp, r7
 800701a:	bd80      	pop	{r7, pc}
 800701c:	200021c0 	.word	0x200021c0
 8007020:	200007b0 	.word	0x200007b0
 8007024:	080207a0 	.word	0x080207a0
 8007028:	08023334 	.word	0x08023334
 800702c:	080207a8 	.word	0x080207a8

08007030 <OsSemDbgTimeUpdate>:

VOID OsSemDbgTimeUpdate(UINT32 semId)
{
 8007030:	b580      	push	{r7, lr}
 8007032:	b084      	sub	sp, #16
 8007034:	af00      	add	r7, sp, #0
 8007036:	6078      	str	r0, [r7, #4]
    SemDebugCB *semDebug = &g_semDebugArray[GET_SEM_INDEX(semId)];
 8007038:	4b0a      	ldr	r3, [pc, #40]	; (8007064 <OsSemDbgTimeUpdate+0x34>)
 800703a:	6819      	ldr	r1, [r3, #0]
 800703c:	687b      	ldr	r3, [r7, #4]
 800703e:	b29a      	uxth	r2, r3
 8007040:	4613      	mov	r3, r2
 8007042:	005b      	lsls	r3, r3, #1
 8007044:	4413      	add	r3, r2
 8007046:	00db      	lsls	r3, r3, #3
 8007048:	440b      	add	r3, r1
 800704a:	60fb      	str	r3, [r7, #12]
    semDebug->lastAccessTime = LOS_TickCountGet();
 800704c:	f7fd f98e 	bl	800436c <LOS_TickCountGet>
 8007050:	4602      	mov	r2, r0
 8007052:	460b      	mov	r3, r1
 8007054:	68f9      	ldr	r1, [r7, #12]
 8007056:	e9c1 2302 	strd	r2, r3, [r1, #8]
    return;
 800705a:	bf00      	nop
}
 800705c:	3710      	adds	r7, #16
 800705e:	46bd      	mov	sp, r7
 8007060:	bd80      	pop	{r7, pc}
 8007062:	bf00      	nop
 8007064:	200007b0 	.word	0x200007b0

08007068 <OsSemSort>:
    semDebug->origSemCount = count;
    return;
}

STATIC VOID OsSemSort(UINT32 *semIndexArray, UINT32 usedCount)
{
 8007068:	b5b0      	push	{r4, r5, r7, lr}
 800706a:	b09a      	sub	sp, #104	; 0x68
 800706c:	af04      	add	r7, sp, #16
 800706e:	6078      	str	r0, [r7, #4]
 8007070:	6039      	str	r1, [r7, #0]
 8007072:	4b53      	ldr	r3, [pc, #332]	; (80071c0 <OsSemSort+0x158>)
 8007074:	681b      	ldr	r3, [r3, #0]
 8007076:	657b      	str	r3, [r7, #84]	; 0x54
 8007078:	f04f 0300 	mov.w	r3, #0
    UINT32 i, intSave;
    LosSemCB *semCB = NULL;
 800707c:	2300      	movs	r3, #0
 800707e:	617b      	str	r3, [r7, #20]
    LosSemCB semNode = {0};
 8007080:	f107 0318 	add.w	r3, r7, #24
 8007084:	2200      	movs	r2, #0
 8007086:	601a      	str	r2, [r3, #0]
 8007088:	605a      	str	r2, [r3, #4]
 800708a:	609a      	str	r2, [r3, #8]
 800708c:	60da      	str	r2, [r3, #12]
    SemDebugCB semDebug = {0};
 800708e:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8007092:	2200      	movs	r2, #0
 8007094:	601a      	str	r2, [r3, #0]
 8007096:	605a      	str	r2, [r3, #4]
 8007098:	609a      	str	r2, [r3, #8]
 800709a:	60da      	str	r2, [r3, #12]
 800709c:	611a      	str	r2, [r3, #16]
 800709e:	615a      	str	r2, [r3, #20]
    SortParam semSortParam;
    semSortParam.buf = (CHAR *)g_semDebugArray;
 80070a0:	4b48      	ldr	r3, [pc, #288]	; (80071c4 <OsSemSort+0x15c>)
 80070a2:	681b      	ldr	r3, [r3, #0]
 80070a4:	62bb      	str	r3, [r7, #40]	; 0x28
    semSortParam.ctrlBlockSize = sizeof(SemDebugCB);
 80070a6:	2318      	movs	r3, #24
 80070a8:	62fb      	str	r3, [r7, #44]	; 0x2c
    semSortParam.ctrlBlockCnt = LOSCFG_BASE_IPC_SEM_LIMIT;
 80070aa:	2314      	movs	r3, #20
 80070ac:	633b      	str	r3, [r7, #48]	; 0x30
    semSortParam.sortElemOff = LOS_OFF_SET_OF(SemDebugCB, lastAccessTime);
 80070ae:	2308      	movs	r3, #8
 80070b0:	637b      	str	r3, [r7, #52]	; 0x34

    /* It will Print out ALL the Used Semaphore List. */
    PRINTK("Used Semaphore List: \n");
 80070b2:	4845      	ldr	r0, [pc, #276]	; (80071c8 <OsSemSort+0x160>)
 80070b4:	f7fd fc04 	bl	80048c0 <dprintf>
    PRINTK("\r\n   SemID    Count    OriginalCount   Creater(TaskEntry)    LastAccessTime\n");
 80070b8:	4844      	ldr	r0, [pc, #272]	; (80071cc <OsSemSort+0x164>)
 80070ba:	f7fd fc01 	bl	80048c0 <dprintf>
    PRINTK("   ------   ------   -------------   ------------------    --------------   \n");
 80070be:	4844      	ldr	r0, [pc, #272]	; (80071d0 <OsSemSort+0x168>)
 80070c0:	f7fd fbfe 	bl	80048c0 <dprintf>

    SCHEDULER_LOCK(intSave);
 80070c4:	f107 030c 	add.w	r3, r7, #12
 80070c8:	4619      	mov	r1, r3
 80070ca:	4842      	ldr	r0, [pc, #264]	; (80071d4 <OsSemSort+0x16c>)
 80070cc:	f7ff fea6 	bl	8006e1c <LOS_SpinLockSave>
    OsArraySort(semIndexArray, 0, usedCount - 1, &semSortParam, SemCompareValue);
 80070d0:	683b      	ldr	r3, [r7, #0]
 80070d2:	1e5a      	subs	r2, r3, #1
 80070d4:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80070d8:	493f      	ldr	r1, [pc, #252]	; (80071d8 <OsSemSort+0x170>)
 80070da:	9100      	str	r1, [sp, #0]
 80070dc:	2100      	movs	r1, #0
 80070de:	6878      	ldr	r0, [r7, #4]
 80070e0:	f7fb fbfc 	bl	80028dc <OsArraySort>
    SCHEDULER_UNLOCK(intSave);
 80070e4:	68fb      	ldr	r3, [r7, #12]
 80070e6:	4619      	mov	r1, r3
 80070e8:	483a      	ldr	r0, [pc, #232]	; (80071d4 <OsSemSort+0x16c>)
 80070ea:	f7ff fea5 	bl	8006e38 <LOS_SpinUnlockRestore>
    for (i = 0; i < usedCount; i++) {
 80070ee:	2300      	movs	r3, #0
 80070f0:	613b      	str	r3, [r7, #16]
 80070f2:	e056      	b.n	80071a2 <OsSemSort+0x13a>
        semCB = GET_SEM(semIndexArray[i]);
 80070f4:	4b39      	ldr	r3, [pc, #228]	; (80071dc <OsSemSort+0x174>)
 80070f6:	681a      	ldr	r2, [r3, #0]
 80070f8:	693b      	ldr	r3, [r7, #16]
 80070fa:	009b      	lsls	r3, r3, #2
 80070fc:	6879      	ldr	r1, [r7, #4]
 80070fe:	440b      	add	r3, r1
 8007100:	681b      	ldr	r3, [r3, #0]
 8007102:	b29b      	uxth	r3, r3
 8007104:	011b      	lsls	r3, r3, #4
 8007106:	4413      	add	r3, r2
 8007108:	617b      	str	r3, [r7, #20]
        SCHEDULER_LOCK(intSave);
 800710a:	f107 030c 	add.w	r3, r7, #12
 800710e:	4619      	mov	r1, r3
 8007110:	4830      	ldr	r0, [pc, #192]	; (80071d4 <OsSemSort+0x16c>)
 8007112:	f7ff fe83 	bl	8006e1c <LOS_SpinLockSave>
        (VOID)memcpy_s(&semNode, sizeof(LosSemCB), semCB, sizeof(LosSemCB));
 8007116:	f107 0018 	add.w	r0, r7, #24
 800711a:	2310      	movs	r3, #16
 800711c:	697a      	ldr	r2, [r7, #20]
 800711e:	2110      	movs	r1, #16
 8007120:	f00f ffba 	bl	8017098 <memcpy_s>
        (VOID)memcpy_s(&semDebug, sizeof(SemDebugCB), &g_semDebugArray[semIndexArray[i]], sizeof(SemDebugCB));
 8007124:	4b27      	ldr	r3, [pc, #156]	; (80071c4 <OsSemSort+0x15c>)
 8007126:	6819      	ldr	r1, [r3, #0]
 8007128:	693b      	ldr	r3, [r7, #16]
 800712a:	009b      	lsls	r3, r3, #2
 800712c:	687a      	ldr	r2, [r7, #4]
 800712e:	4413      	add	r3, r2
 8007130:	681a      	ldr	r2, [r3, #0]
 8007132:	4613      	mov	r3, r2
 8007134:	005b      	lsls	r3, r3, #1
 8007136:	4413      	add	r3, r2
 8007138:	00db      	lsls	r3, r3, #3
 800713a:	18ca      	adds	r2, r1, r3
 800713c:	f107 0038 	add.w	r0, r7, #56	; 0x38
 8007140:	2318      	movs	r3, #24
 8007142:	2118      	movs	r1, #24
 8007144:	f00f ffa8 	bl	8017098 <memcpy_s>
        SCHEDULER_UNLOCK(intSave);
 8007148:	68fb      	ldr	r3, [r7, #12]
 800714a:	4619      	mov	r1, r3
 800714c:	4821      	ldr	r0, [pc, #132]	; (80071d4 <OsSemSort+0x16c>)
 800714e:	f7ff fe73 	bl	8006e38 <LOS_SpinUnlockRestore>
        if ((semNode.semStat != LOS_USED) || (semDebug.creator == NULL)) {
 8007152:	7e3b      	ldrb	r3, [r7, #24]
 8007154:	2b01      	cmp	r3, #1
 8007156:	d120      	bne.n	800719a <OsSemSort+0x132>
 8007158:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800715a:	2b00      	cmp	r3, #0
 800715c:	d01d      	beq.n	800719a <OsSemSort+0x132>
            continue;
        }
        PRINTK("   0x%-07x0x%-07u0x%-14u%-22p0x%llx\n", semNode.semId, semDebug.origSemCount,
 800715e:	69f8      	ldr	r0, [r7, #28]
 8007160:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 8007162:	461c      	mov	r4, r3
 8007164:	8b7b      	ldrh	r3, [r7, #26]
 8007166:	461d      	mov	r5, r3
 8007168:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800716a:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800716e:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8007172:	9100      	str	r1, [sp, #0]
 8007174:	462b      	mov	r3, r5
 8007176:	4622      	mov	r2, r4
 8007178:	4601      	mov	r1, r0
 800717a:	4819      	ldr	r0, [pc, #100]	; (80071e0 <OsSemSort+0x178>)
 800717c:	f7fd fba0 	bl	80048c0 <dprintf>
               semNode.semCount, semDebug.creator, semDebug.lastAccessTime);
        if (!LOS_ListEmpty(&semNode.semList)) {
 8007180:	f107 0318 	add.w	r3, r7, #24
 8007184:	3308      	adds	r3, #8
 8007186:	4618      	mov	r0, r3
 8007188:	f7ff fe24 	bl	8006dd4 <LOS_ListEmpty>
 800718c:	4603      	mov	r3, r0
 800718e:	2b00      	cmp	r3, #0
 8007190:	d104      	bne.n	800719c <OsSemSort+0x134>
            OsSemPendedTaskNamePrint(semCB);
 8007192:	6978      	ldr	r0, [r7, #20]
 8007194:	f7ff fe5c 	bl	8006e50 <OsSemPendedTaskNamePrint>
 8007198:	e000      	b.n	800719c <OsSemSort+0x134>
            continue;
 800719a:	bf00      	nop
    for (i = 0; i < usedCount; i++) {
 800719c:	693b      	ldr	r3, [r7, #16]
 800719e:	3301      	adds	r3, #1
 80071a0:	613b      	str	r3, [r7, #16]
 80071a2:	693a      	ldr	r2, [r7, #16]
 80071a4:	683b      	ldr	r3, [r7, #0]
 80071a6:	429a      	cmp	r2, r3
 80071a8:	d3a4      	bcc.n	80070f4 <OsSemSort+0x8c>
        }
    }
}
 80071aa:	bf00      	nop
 80071ac:	4b04      	ldr	r3, [pc, #16]	; (80071c0 <OsSemSort+0x158>)
 80071ae:	681a      	ldr	r2, [r3, #0]
 80071b0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80071b2:	405a      	eors	r2, r3
 80071b4:	d001      	beq.n	80071ba <OsSemSort+0x152>
 80071b6:	f7fd fa11 	bl	80045dc <__stack_chk_fail>
 80071ba:	3758      	adds	r7, #88	; 0x58
 80071bc:	46bd      	mov	sp, r7
 80071be:	bdb0      	pop	{r4, r5, r7, pc}
 80071c0:	0802089c 	.word	0x0802089c
 80071c4:	200007b0 	.word	0x200007b0
 80071c8:	080207bc 	.word	0x080207bc
 80071cc:	080207d4 	.word	0x080207d4
 80071d0:	08020824 	.word	0x08020824
 80071d4:	20000770 	.word	0x20000770
 80071d8:	08006f75 	.word	0x08006f75
 80071dc:	20000798 	.word	0x20000798
 80071e0:	08020874 	.word	0x08020874

080071e4 <OsSemInfoGetFullData>:

UINT32 OsSemInfoGetFullData(VOID)
{
 80071e4:	b580      	push	{r7, lr}
 80071e6:	b088      	sub	sp, #32
 80071e8:	af00      	add	r7, sp, #0
 80071ea:	4b52      	ldr	r3, [pc, #328]	; (8007334 <OsSemInfoGetFullData+0x150>)
 80071ec:	681b      	ldr	r3, [r3, #0]
 80071ee:	61fb      	str	r3, [r7, #28]
 80071f0:	f04f 0300 	mov.w	r3, #0
    UINT32 usedSemCnt = 0;
 80071f4:	2300      	movs	r3, #0
 80071f6:	607b      	str	r3, [r7, #4]
    LosSemCB *semNode = NULL;
 80071f8:	2300      	movs	r3, #0
 80071fa:	613b      	str	r3, [r7, #16]
    SemDebugCB *semDebug = NULL;
 80071fc:	2300      	movs	r3, #0
 80071fe:	617b      	str	r3, [r7, #20]
    UINT32 i;
    UINT32 *semIndexArray = NULL;
 8007200:	2300      	movs	r3, #0
 8007202:	61bb      	str	r3, [r7, #24]
    UINT32 count, intSave;

    SCHEDULER_LOCK(intSave);
 8007204:	463b      	mov	r3, r7
 8007206:	4619      	mov	r1, r3
 8007208:	484b      	ldr	r0, [pc, #300]	; (8007338 <OsSemInfoGetFullData+0x154>)
 800720a:	f7ff fe07 	bl	8006e1c <LOS_SpinLockSave>
    /* Get the used semaphore count. */
    for (i = 0; i < LOSCFG_BASE_IPC_SEM_LIMIT; i++) {
 800720e:	2300      	movs	r3, #0
 8007210:	60bb      	str	r3, [r7, #8]
 8007212:	e01d      	b.n	8007250 <OsSemInfoGetFullData+0x6c>
        semNode = GET_SEM(i);
 8007214:	4b49      	ldr	r3, [pc, #292]	; (800733c <OsSemInfoGetFullData+0x158>)
 8007216:	681a      	ldr	r2, [r3, #0]
 8007218:	68bb      	ldr	r3, [r7, #8]
 800721a:	b29b      	uxth	r3, r3
 800721c:	011b      	lsls	r3, r3, #4
 800721e:	4413      	add	r3, r2
 8007220:	613b      	str	r3, [r7, #16]
        semDebug = &g_semDebugArray[i];
 8007222:	4b47      	ldr	r3, [pc, #284]	; (8007340 <OsSemInfoGetFullData+0x15c>)
 8007224:	6819      	ldr	r1, [r3, #0]
 8007226:	68ba      	ldr	r2, [r7, #8]
 8007228:	4613      	mov	r3, r2
 800722a:	005b      	lsls	r3, r3, #1
 800722c:	4413      	add	r3, r2
 800722e:	00db      	lsls	r3, r3, #3
 8007230:	440b      	add	r3, r1
 8007232:	617b      	str	r3, [r7, #20]
        if ((semNode->semStat == LOS_USED) && (semDebug->creator != NULL)) {
 8007234:	693b      	ldr	r3, [r7, #16]
 8007236:	781b      	ldrb	r3, [r3, #0]
 8007238:	2b01      	cmp	r3, #1
 800723a:	d106      	bne.n	800724a <OsSemInfoGetFullData+0x66>
 800723c:	697b      	ldr	r3, [r7, #20]
 800723e:	691b      	ldr	r3, [r3, #16]
 8007240:	2b00      	cmp	r3, #0
 8007242:	d002      	beq.n	800724a <OsSemInfoGetFullData+0x66>
            usedSemCnt++;
 8007244:	687b      	ldr	r3, [r7, #4]
 8007246:	3301      	adds	r3, #1
 8007248:	607b      	str	r3, [r7, #4]
    for (i = 0; i < LOSCFG_BASE_IPC_SEM_LIMIT; i++) {
 800724a:	68bb      	ldr	r3, [r7, #8]
 800724c:	3301      	adds	r3, #1
 800724e:	60bb      	str	r3, [r7, #8]
 8007250:	68bb      	ldr	r3, [r7, #8]
 8007252:	2b13      	cmp	r3, #19
 8007254:	d9de      	bls.n	8007214 <OsSemInfoGetFullData+0x30>
        }
    }
    SCHEDULER_UNLOCK(intSave);
 8007256:	683b      	ldr	r3, [r7, #0]
 8007258:	4619      	mov	r1, r3
 800725a:	4837      	ldr	r0, [pc, #220]	; (8007338 <OsSemInfoGetFullData+0x154>)
 800725c:	f7ff fdec 	bl	8006e38 <LOS_SpinUnlockRestore>

    if (usedSemCnt > 0) {
 8007260:	687b      	ldr	r3, [r7, #4]
 8007262:	2b00      	cmp	r3, #0
 8007264:	d05a      	beq.n	800731c <OsSemInfoGetFullData+0x138>
        semIndexArray = (UINT32 *)LOS_MemAlloc((VOID *)OS_SYS_MEM_ADDR, usedSemCnt * sizeof(UINT32));
 8007266:	4b37      	ldr	r3, [pc, #220]	; (8007344 <OsSemInfoGetFullData+0x160>)
 8007268:	681b      	ldr	r3, [r3, #0]
 800726a:	461a      	mov	r2, r3
 800726c:	687b      	ldr	r3, [r7, #4]
 800726e:	009b      	lsls	r3, r3, #2
 8007270:	4619      	mov	r1, r3
 8007272:	4610      	mov	r0, r2
 8007274:	f002 f8ce 	bl	8009414 <LOS_MemAlloc>
 8007278:	61b8      	str	r0, [r7, #24]
        if (semIndexArray == NULL) {
 800727a:	69bb      	ldr	r3, [r7, #24]
 800727c:	2b00      	cmp	r3, #0
 800727e:	d105      	bne.n	800728c <OsSemInfoGetFullData+0xa8>
            PRINTK("LOS_MemAlloc failed in %s \n", __func__);
 8007280:	4931      	ldr	r1, [pc, #196]	; (8007348 <OsSemInfoGetFullData+0x164>)
 8007282:	4832      	ldr	r0, [pc, #200]	; (800734c <OsSemInfoGetFullData+0x168>)
 8007284:	f7fd fb1c 	bl	80048c0 <dprintf>
            return LOS_NOK;
 8007288:	2301      	movs	r3, #1
 800728a:	e048      	b.n	800731e <OsSemInfoGetFullData+0x13a>
        }

        /* Fill the semIndexArray with the real index. */
        count = 0;
 800728c:	2300      	movs	r3, #0
 800728e:	60fb      	str	r3, [r7, #12]

        SCHEDULER_LOCK(intSave);
 8007290:	463b      	mov	r3, r7
 8007292:	4619      	mov	r1, r3
 8007294:	4828      	ldr	r0, [pc, #160]	; (8007338 <OsSemInfoGetFullData+0x154>)
 8007296:	f7ff fdc1 	bl	8006e1c <LOS_SpinLockSave>
        for (i = 0; i < LOSCFG_BASE_IPC_SEM_LIMIT; i++) {
 800729a:	2300      	movs	r3, #0
 800729c:	60bb      	str	r3, [r7, #8]
 800729e:	e029      	b.n	80072f4 <OsSemInfoGetFullData+0x110>
            semNode = GET_SEM(i);
 80072a0:	4b26      	ldr	r3, [pc, #152]	; (800733c <OsSemInfoGetFullData+0x158>)
 80072a2:	681a      	ldr	r2, [r3, #0]
 80072a4:	68bb      	ldr	r3, [r7, #8]
 80072a6:	b29b      	uxth	r3, r3
 80072a8:	011b      	lsls	r3, r3, #4
 80072aa:	4413      	add	r3, r2
 80072ac:	613b      	str	r3, [r7, #16]
            semDebug = &g_semDebugArray[i];
 80072ae:	4b24      	ldr	r3, [pc, #144]	; (8007340 <OsSemInfoGetFullData+0x15c>)
 80072b0:	6819      	ldr	r1, [r3, #0]
 80072b2:	68ba      	ldr	r2, [r7, #8]
 80072b4:	4613      	mov	r3, r2
 80072b6:	005b      	lsls	r3, r3, #1
 80072b8:	4413      	add	r3, r2
 80072ba:	00db      	lsls	r3, r3, #3
 80072bc:	440b      	add	r3, r1
 80072be:	617b      	str	r3, [r7, #20]
            if ((semNode->semStat != LOS_USED) || (semDebug->creator == NULL)) {
 80072c0:	693b      	ldr	r3, [r7, #16]
 80072c2:	781b      	ldrb	r3, [r3, #0]
 80072c4:	2b01      	cmp	r3, #1
 80072c6:	d111      	bne.n	80072ec <OsSemInfoGetFullData+0x108>
 80072c8:	697b      	ldr	r3, [r7, #20]
 80072ca:	691b      	ldr	r3, [r3, #16]
 80072cc:	2b00      	cmp	r3, #0
 80072ce:	d00d      	beq.n	80072ec <OsSemInfoGetFullData+0x108>
                continue;
            }
            *(semIndexArray + count) = i;
 80072d0:	68fb      	ldr	r3, [r7, #12]
 80072d2:	009b      	lsls	r3, r3, #2
 80072d4:	69ba      	ldr	r2, [r7, #24]
 80072d6:	4413      	add	r3, r2
 80072d8:	68ba      	ldr	r2, [r7, #8]
 80072da:	601a      	str	r2, [r3, #0]
            count++;
 80072dc:	68fb      	ldr	r3, [r7, #12]
 80072de:	3301      	adds	r3, #1
 80072e0:	60fb      	str	r3, [r7, #12]
            /* if the count is touched usedSemCnt break. */
            if (count >= usedSemCnt) {
 80072e2:	68fa      	ldr	r2, [r7, #12]
 80072e4:	687b      	ldr	r3, [r7, #4]
 80072e6:	429a      	cmp	r2, r3
 80072e8:	d208      	bcs.n	80072fc <OsSemInfoGetFullData+0x118>
 80072ea:	e000      	b.n	80072ee <OsSemInfoGetFullData+0x10a>
                continue;
 80072ec:	bf00      	nop
        for (i = 0; i < LOSCFG_BASE_IPC_SEM_LIMIT; i++) {
 80072ee:	68bb      	ldr	r3, [r7, #8]
 80072f0:	3301      	adds	r3, #1
 80072f2:	60bb      	str	r3, [r7, #8]
 80072f4:	68bb      	ldr	r3, [r7, #8]
 80072f6:	2b13      	cmp	r3, #19
 80072f8:	d9d2      	bls.n	80072a0 <OsSemInfoGetFullData+0xbc>
 80072fa:	e000      	b.n	80072fe <OsSemInfoGetFullData+0x11a>
                break;
 80072fc:	bf00      	nop
            }
        }
        SCHEDULER_UNLOCK(intSave);
 80072fe:	683b      	ldr	r3, [r7, #0]
 8007300:	4619      	mov	r1, r3
 8007302:	480d      	ldr	r0, [pc, #52]	; (8007338 <OsSemInfoGetFullData+0x154>)
 8007304:	f7ff fd98 	bl	8006e38 <LOS_SpinUnlockRestore>
        OsSemSort(semIndexArray, count);
 8007308:	68f9      	ldr	r1, [r7, #12]
 800730a:	69b8      	ldr	r0, [r7, #24]
 800730c:	f7ff feac 	bl	8007068 <OsSemSort>

        /* free the index array. */
        (VOID)LOS_MemFree((VOID *)OS_SYS_MEM_ADDR, semIndexArray);
 8007310:	4b0c      	ldr	r3, [pc, #48]	; (8007344 <OsSemInfoGetFullData+0x160>)
 8007312:	681b      	ldr	r3, [r3, #0]
 8007314:	69b9      	ldr	r1, [r7, #24]
 8007316:	4618      	mov	r0, r3
 8007318:	f002 f934 	bl	8009584 <LOS_MemFree>
    }
    return LOS_OK;
 800731c:	2300      	movs	r3, #0
}
 800731e:	4a05      	ldr	r2, [pc, #20]	; (8007334 <OsSemInfoGetFullData+0x150>)
 8007320:	6811      	ldr	r1, [r2, #0]
 8007322:	69fa      	ldr	r2, [r7, #28]
 8007324:	4051      	eors	r1, r2
 8007326:	d001      	beq.n	800732c <OsSemInfoGetFullData+0x148>
 8007328:	f7fd f958 	bl	80045dc <__stack_chk_fail>
 800732c:	4618      	mov	r0, r3
 800732e:	3720      	adds	r7, #32
 8007330:	46bd      	mov	sp, r7
 8007332:	bd80      	pop	{r7, pc}
 8007334:	080208bc 	.word	0x080208bc
 8007338:	20000770 	.word	0x20000770
 800733c:	20000798 	.word	0x20000798
 8007340:	200007b0 	.word	0x200007b0
 8007344:	080001f0 	.word	0x080001f0
 8007348:	08023344 	.word	0x08023344
 800734c:	080208a0 	.word	0x080208a0

08007350 <OsSemInfoOutput>:

#ifdef LOSCFG_SHELL
STATIC UINT32 OsSemInfoOutput(size_t semId)
{
 8007350:	b580      	push	{r7, lr}
 8007352:	b08c      	sub	sp, #48	; 0x30
 8007354:	af00      	add	r7, sp, #0
 8007356:	6078      	str	r0, [r7, #4]
 8007358:	4b4e      	ldr	r3, [pc, #312]	; (8007494 <OsSemInfoOutput+0x144>)
 800735a:	681b      	ldr	r3, [r3, #0]
 800735c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800735e:	f04f 0300 	mov.w	r3, #0
    UINT32 loop, semCnt, intSave;
    LosSemCB *semCB = NULL;
 8007362:	2300      	movs	r3, #0
 8007364:	61bb      	str	r3, [r7, #24]
    LosSemCB semNode = {0};
 8007366:	f107 031c 	add.w	r3, r7, #28
 800736a:	2200      	movs	r2, #0
 800736c:	601a      	str	r2, [r3, #0]
 800736e:	605a      	str	r2, [r3, #4]
 8007370:	609a      	str	r2, [r3, #8]
 8007372:	60da      	str	r2, [r3, #12]

    if (semId == OS_ALL_SEM_MASK) {
 8007374:	687b      	ldr	r3, [r7, #4]
 8007376:	f1b3 3fff 	cmp.w	r3, #4294967295
 800737a:	d13f      	bne.n	80073fc <OsSemInfoOutput+0xac>
        for (loop = 0, semCnt = 0; loop < LOSCFG_BASE_IPC_SEM_LIMIT; loop++) {
 800737c:	2300      	movs	r3, #0
 800737e:	613b      	str	r3, [r7, #16]
 8007380:	2300      	movs	r3, #0
 8007382:	617b      	str	r3, [r7, #20]
 8007384:	e031      	b.n	80073ea <OsSemInfoOutput+0x9a>
            semCB = GET_SEM(loop);
 8007386:	4b44      	ldr	r3, [pc, #272]	; (8007498 <OsSemInfoOutput+0x148>)
 8007388:	681a      	ldr	r2, [r3, #0]
 800738a:	693b      	ldr	r3, [r7, #16]
 800738c:	b29b      	uxth	r3, r3
 800738e:	011b      	lsls	r3, r3, #4
 8007390:	4413      	add	r3, r2
 8007392:	61bb      	str	r3, [r7, #24]
            SCHEDULER_LOCK(intSave);
 8007394:	f107 030c 	add.w	r3, r7, #12
 8007398:	4619      	mov	r1, r3
 800739a:	4840      	ldr	r0, [pc, #256]	; (800749c <OsSemInfoOutput+0x14c>)
 800739c:	f7ff fd3e 	bl	8006e1c <LOS_SpinLockSave>
            if (semCB->semStat == LOS_USED) {
 80073a0:	69bb      	ldr	r3, [r7, #24]
 80073a2:	781b      	ldrb	r3, [r3, #0]
 80073a4:	2b01      	cmp	r3, #1
 80073a6:	d118      	bne.n	80073da <OsSemInfoOutput+0x8a>
                (VOID)memcpy_s(&semNode, sizeof(LosSemCB), semCB, sizeof(LosSemCB));
 80073a8:	f107 001c 	add.w	r0, r7, #28
 80073ac:	2310      	movs	r3, #16
 80073ae:	69ba      	ldr	r2, [r7, #24]
 80073b0:	2110      	movs	r1, #16
 80073b2:	f00f fe71 	bl	8017098 <memcpy_s>
                SCHEDULER_UNLOCK(intSave);
 80073b6:	68fb      	ldr	r3, [r7, #12]
 80073b8:	4619      	mov	r1, r3
 80073ba:	4838      	ldr	r0, [pc, #224]	; (800749c <OsSemInfoOutput+0x14c>)
 80073bc:	f7ff fd3c 	bl	8006e38 <LOS_SpinUnlockRestore>
                semCnt++;
 80073c0:	697b      	ldr	r3, [r7, #20]
 80073c2:	3301      	adds	r3, #1
 80073c4:	617b      	str	r3, [r7, #20]
                PRINTK("\r\n   SemID       Count\n   ----------  -----\n");
 80073c6:	4836      	ldr	r0, [pc, #216]	; (80074a0 <OsSemInfoOutput+0x150>)
 80073c8:	f7fd fa7a 	bl	80048c0 <dprintf>
                PRINTK("   0x%08x  %u\n", semNode.semId, semNode.semCount);
 80073cc:	6a3b      	ldr	r3, [r7, #32]
 80073ce:	8bfa      	ldrh	r2, [r7, #30]
 80073d0:	4619      	mov	r1, r3
 80073d2:	4834      	ldr	r0, [pc, #208]	; (80074a4 <OsSemInfoOutput+0x154>)
 80073d4:	f7fd fa74 	bl	80048c0 <dprintf>
                continue;
 80073d8:	e004      	b.n	80073e4 <OsSemInfoOutput+0x94>
            }
            SCHEDULER_UNLOCK(intSave);
 80073da:	68fb      	ldr	r3, [r7, #12]
 80073dc:	4619      	mov	r1, r3
 80073de:	482f      	ldr	r0, [pc, #188]	; (800749c <OsSemInfoOutput+0x14c>)
 80073e0:	f7ff fd2a 	bl	8006e38 <LOS_SpinUnlockRestore>
        for (loop = 0, semCnt = 0; loop < LOSCFG_BASE_IPC_SEM_LIMIT; loop++) {
 80073e4:	693b      	ldr	r3, [r7, #16]
 80073e6:	3301      	adds	r3, #1
 80073e8:	613b      	str	r3, [r7, #16]
 80073ea:	693b      	ldr	r3, [r7, #16]
 80073ec:	2b13      	cmp	r3, #19
 80073ee:	d9ca      	bls.n	8007386 <OsSemInfoOutput+0x36>
        }
        PRINTK("   SemUsingNum    :  %u\n\n", semCnt);
 80073f0:	6979      	ldr	r1, [r7, #20]
 80073f2:	482d      	ldr	r0, [pc, #180]	; (80074a8 <OsSemInfoOutput+0x158>)
 80073f4:	f7fd fa64 	bl	80048c0 <dprintf>
        return LOS_OK;
 80073f8:	2300      	movs	r3, #0
 80073fa:	e03f      	b.n	800747c <OsSemInfoOutput+0x12c>
    } else {
        semCB = GET_SEM(semId);
 80073fc:	4b26      	ldr	r3, [pc, #152]	; (8007498 <OsSemInfoOutput+0x148>)
 80073fe:	681a      	ldr	r2, [r3, #0]
 8007400:	687b      	ldr	r3, [r7, #4]
 8007402:	b29b      	uxth	r3, r3
 8007404:	011b      	lsls	r3, r3, #4
 8007406:	4413      	add	r3, r2
 8007408:	61bb      	str	r3, [r7, #24]
        SCHEDULER_LOCK(intSave);
 800740a:	f107 030c 	add.w	r3, r7, #12
 800740e:	4619      	mov	r1, r3
 8007410:	4822      	ldr	r0, [pc, #136]	; (800749c <OsSemInfoOutput+0x14c>)
 8007412:	f7ff fd03 	bl	8006e1c <LOS_SpinLockSave>
        (VOID)memcpy_s(&semNode, sizeof(LosSemCB), semCB, sizeof(LosSemCB));
 8007416:	f107 001c 	add.w	r0, r7, #28
 800741a:	2310      	movs	r3, #16
 800741c:	69ba      	ldr	r2, [r7, #24]
 800741e:	2110      	movs	r1, #16
 8007420:	f00f fe3a 	bl	8017098 <memcpy_s>
        SCHEDULER_UNLOCK(intSave);
 8007424:	68fb      	ldr	r3, [r7, #12]
 8007426:	4619      	mov	r1, r3
 8007428:	481c      	ldr	r0, [pc, #112]	; (800749c <OsSemInfoOutput+0x14c>)
 800742a:	f7ff fd05 	bl	8006e38 <LOS_SpinUnlockRestore>
        if ((semNode.semId != semId) || (semNode.semStat != LOS_USED)) {
 800742e:	6a3b      	ldr	r3, [r7, #32]
 8007430:	687a      	ldr	r2, [r7, #4]
 8007432:	429a      	cmp	r2, r3
 8007434:	d102      	bne.n	800743c <OsSemInfoOutput+0xec>
 8007436:	7f3b      	ldrb	r3, [r7, #28]
 8007438:	2b01      	cmp	r3, #1
 800743a:	d004      	beq.n	8007446 <OsSemInfoOutput+0xf6>
            PRINTK("\nThe semaphore is not in use!\n");
 800743c:	481b      	ldr	r0, [pc, #108]	; (80074ac <OsSemInfoOutput+0x15c>)
 800743e:	f7fd fa3f 	bl	80048c0 <dprintf>
            return LOS_OK;
 8007442:	2300      	movs	r3, #0
 8007444:	e01a      	b.n	800747c <OsSemInfoOutput+0x12c>
        }

        PRINTK("\r\n   SemID       Count\n   ----------  -----\n");
 8007446:	4816      	ldr	r0, [pc, #88]	; (80074a0 <OsSemInfoOutput+0x150>)
 8007448:	f7fd fa3a 	bl	80048c0 <dprintf>
        PRINTK("   0x%08x      0x%u\n", semNode.semId, semNode.semCount);
 800744c:	6a3b      	ldr	r3, [r7, #32]
 800744e:	8bfa      	ldrh	r2, [r7, #30]
 8007450:	4619      	mov	r1, r3
 8007452:	4817      	ldr	r0, [pc, #92]	; (80074b0 <OsSemInfoOutput+0x160>)
 8007454:	f7fd fa34 	bl	80048c0 <dprintf>

        if (LOS_ListEmpty(&semNode.semList)) {
 8007458:	f107 031c 	add.w	r3, r7, #28
 800745c:	3308      	adds	r3, #8
 800745e:	4618      	mov	r0, r3
 8007460:	f7ff fcb8 	bl	8006dd4 <LOS_ListEmpty>
 8007464:	4603      	mov	r3, r0
 8007466:	2b00      	cmp	r3, #0
 8007468:	d004      	beq.n	8007474 <OsSemInfoOutput+0x124>
            PRINTK("No task is pended on this semaphore!\n");
 800746a:	4812      	ldr	r0, [pc, #72]	; (80074b4 <OsSemInfoOutput+0x164>)
 800746c:	f7fd fa28 	bl	80048c0 <dprintf>
            return LOS_OK;
 8007470:	2300      	movs	r3, #0
 8007472:	e003      	b.n	800747c <OsSemInfoOutput+0x12c>
        } else {
            OsSemPendedTaskNamePrint(semCB);
 8007474:	69b8      	ldr	r0, [r7, #24]
 8007476:	f7ff fceb 	bl	8006e50 <OsSemPendedTaskNamePrint>
        }
    }
    return LOS_OK;
 800747a:	2300      	movs	r3, #0
}
 800747c:	4a05      	ldr	r2, [pc, #20]	; (8007494 <OsSemInfoOutput+0x144>)
 800747e:	6811      	ldr	r1, [r2, #0]
 8007480:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007482:	4051      	eors	r1, r2
 8007484:	d001      	beq.n	800748a <OsSemInfoOutput+0x13a>
 8007486:	f7fd f8a9 	bl	80045dc <__stack_chk_fail>
 800748a:	4618      	mov	r0, r3
 800748c:	3730      	adds	r7, #48	; 0x30
 800748e:	46bd      	mov	sp, r7
 8007490:	bd80      	pop	{r7, pc}
 8007492:	bf00      	nop
 8007494:	0802097c 	.word	0x0802097c
 8007498:	20000798 	.word	0x20000798
 800749c:	20000770 	.word	0x20000770
 80074a0:	080208c0 	.word	0x080208c0
 80074a4:	080208f0 	.word	0x080208f0
 80074a8:	08020900 	.word	0x08020900
 80074ac:	0802091c 	.word	0x0802091c
 80074b0:	0802093c 	.word	0x0802093c
 80074b4:	08020954 	.word	0x08020954

080074b8 <OsShellCmdSemInfoGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdSemInfoGet(UINT32 argc, const CHAR **argv)
{
 80074b8:	b580      	push	{r7, lr}
 80074ba:	b086      	sub	sp, #24
 80074bc:	af00      	add	r7, sp, #0
 80074be:	6078      	str	r0, [r7, #4]
 80074c0:	6039      	str	r1, [r7, #0]
 80074c2:	4b27      	ldr	r3, [pc, #156]	; (8007560 <OsShellCmdSemInfoGet+0xa8>)
 80074c4:	681b      	ldr	r3, [r3, #0]
 80074c6:	617b      	str	r3, [r7, #20]
 80074c8:	f04f 0300 	mov.w	r3, #0
    size_t semId;
    CHAR *endPtr = NULL;
 80074cc:	2300      	movs	r3, #0
 80074ce:	60bb      	str	r3, [r7, #8]
    UINT32 ret;

    if (argc > 1) {
 80074d0:	687b      	ldr	r3, [r7, #4]
 80074d2:	2b01      	cmp	r3, #1
 80074d4:	d905      	bls.n	80074e2 <OsShellCmdSemInfoGet+0x2a>
        PRINTK("\nUsage: sem [fulldata|ID]\n");
 80074d6:	4823      	ldr	r0, [pc, #140]	; (8007564 <OsShellCmdSemInfoGet+0xac>)
 80074d8:	f7fd f9f2 	bl	80048c0 <dprintf>
        return OS_ERROR;
 80074dc:	f04f 33ff 	mov.w	r3, #4294967295
 80074e0:	e033      	b.n	800754a <OsShellCmdSemInfoGet+0x92>
    }

    if (argc == 0) {
 80074e2:	687b      	ldr	r3, [r7, #4]
 80074e4:	2b00      	cmp	r3, #0
 80074e6:	d103      	bne.n	80074f0 <OsShellCmdSemInfoGet+0x38>
        semId = OS_ALL_SEM_MASK;
 80074e8:	f04f 33ff 	mov.w	r3, #4294967295
 80074ec:	60fb      	str	r3, [r7, #12]
 80074ee:	e027      	b.n	8007540 <OsShellCmdSemInfoGet+0x88>
    } else {
        if (strcmp(argv[0], "fulldata") == 0) {
 80074f0:	683b      	ldr	r3, [r7, #0]
 80074f2:	681b      	ldr	r3, [r3, #0]
 80074f4:	491c      	ldr	r1, [pc, #112]	; (8007568 <OsShellCmdSemInfoGet+0xb0>)
 80074f6:	4618      	mov	r0, r3
 80074f8:	f008 f807 	bl	800f50a <strcmp>
 80074fc:	4603      	mov	r3, r0
 80074fe:	2b00      	cmp	r3, #0
 8007500:	d104      	bne.n	800750c <OsShellCmdSemInfoGet+0x54>
            ret = OsSemInfoGetFullData();
 8007502:	f7ff fe6f 	bl	80071e4 <OsSemInfoGetFullData>
 8007506:	6138      	str	r0, [r7, #16]
            return ret;
 8007508:	693b      	ldr	r3, [r7, #16]
 800750a:	e01e      	b.n	800754a <OsShellCmdSemInfoGet+0x92>
        }

        semId = strtoul(argv[0], &endPtr, 0);
 800750c:	683b      	ldr	r3, [r7, #0]
 800750e:	681b      	ldr	r3, [r3, #0]
 8007510:	f107 0108 	add.w	r1, r7, #8
 8007514:	2200      	movs	r2, #0
 8007516:	4618      	mov	r0, r3
 8007518:	f008 f89c 	bl	800f654 <strtoul>
 800751c:	60f8      	str	r0, [r7, #12]
        if ((*endPtr != 0) || (GET_SEM_INDEX(semId) >= LOSCFG_BASE_IPC_SEM_LIMIT)) {
 800751e:	68bb      	ldr	r3, [r7, #8]
 8007520:	781b      	ldrb	r3, [r3, #0]
 8007522:	2b00      	cmp	r3, #0
 8007524:	d103      	bne.n	800752e <OsShellCmdSemInfoGet+0x76>
 8007526:	68fb      	ldr	r3, [r7, #12]
 8007528:	b29b      	uxth	r3, r3
 800752a:	2b13      	cmp	r3, #19
 800752c:	d908      	bls.n	8007540 <OsShellCmdSemInfoGet+0x88>
            PRINTK("\nsem ID can't access %s.\n", argv[0]);
 800752e:	683b      	ldr	r3, [r7, #0]
 8007530:	681b      	ldr	r3, [r3, #0]
 8007532:	4619      	mov	r1, r3
 8007534:	480d      	ldr	r0, [pc, #52]	; (800756c <OsShellCmdSemInfoGet+0xb4>)
 8007536:	f7fd f9c3 	bl	80048c0 <dprintf>
            return OS_ERROR;
 800753a:	f04f 33ff 	mov.w	r3, #4294967295
 800753e:	e004      	b.n	800754a <OsShellCmdSemInfoGet+0x92>
        }
    }

    ret = OsSemInfoOutput(semId);
 8007540:	68f8      	ldr	r0, [r7, #12]
 8007542:	f7ff ff05 	bl	8007350 <OsSemInfoOutput>
 8007546:	6138      	str	r0, [r7, #16]
    return ret;
 8007548:	693b      	ldr	r3, [r7, #16]
}
 800754a:	4a05      	ldr	r2, [pc, #20]	; (8007560 <OsShellCmdSemInfoGet+0xa8>)
 800754c:	6811      	ldr	r1, [r2, #0]
 800754e:	697a      	ldr	r2, [r7, #20]
 8007550:	4051      	eors	r1, r2
 8007552:	d001      	beq.n	8007558 <OsShellCmdSemInfoGet+0xa0>
 8007554:	f7fd f842 	bl	80045dc <__stack_chk_fail>
 8007558:	4618      	mov	r0, r3
 800755a:	3718      	adds	r7, #24
 800755c:	46bd      	mov	sp, r7
 800755e:	bd80      	pop	{r7, pc}
 8007560:	080209c4 	.word	0x080209c4
 8007564:	08020980 	.word	0x08020980
 8007568:	0802099c 	.word	0x0802099c
 800756c:	080209a8 	.word	0x080209a8

08007570 <ArchCurrCpuid>:
{
 8007570:	b480      	push	{r7}
 8007572:	af00      	add	r7, sp, #0
    return 0;
 8007574:	2300      	movs	r3, #0
}
 8007576:	4618      	mov	r0, r3
 8007578:	46bd      	mov	sp, r7
 800757a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800757e:	4770      	bx	lr

08007580 <OsSchedStatisticsPerCpu>:
STATIC BOOL g_statisticsStartFlag = FALSE;
STATIC UINT64 g_statisticsStartTime;
STATIC StatPercpu g_statPercpu[LOSCFG_KERNEL_CORE_NUM];

STATIC VOID OsSchedStatisticsPerCpu(const LosTaskCB *runTask, const LosTaskCB *newTask)
{
 8007580:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007584:	b08d      	sub	sp, #52	; 0x34
 8007586:	af00      	add	r7, sp, #0
 8007588:	6178      	str	r0, [r7, #20]
 800758a:	6139      	str	r1, [r7, #16]
    UINT32 cpuId;
    UINT32 idleTaskId;
    UINT64 now, runtime;

    if (g_statisticsStartFlag != TRUE) {
 800758c:	4b96      	ldr	r3, [pc, #600]	; (80077e8 <OsSchedStatisticsPerCpu+0x268>)
 800758e:	681b      	ldr	r3, [r3, #0]
 8007590:	2b01      	cmp	r3, #1
 8007592:	f040 8121 	bne.w	80077d8 <OsSchedStatisticsPerCpu+0x258>
        return;
    }

    cpuId = ArchCurrCpuid();
 8007596:	f7ff ffeb 	bl	8007570 <ArchCurrCpuid>
 800759a:	61b8      	str	r0, [r7, #24]
    idleTaskId = OsGetIdleTaskId();
 800759c:	f7fb fdc8 	bl	8003130 <OsGetIdleTaskId>
 80075a0:	61f8      	str	r0, [r7, #28]
    now = LOS_CurrNanosec();
 80075a2:	f7fc ff31 	bl	8004408 <LOS_CurrNanosec>
 80075a6:	e9c7 0108 	strd	r0, r1, [r7, #32]

    g_statPercpu[cpuId].contexSwitch++;
 80075aa:	4990      	ldr	r1, [pc, #576]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 80075ac:	69ba      	ldr	r2, [r7, #24]
 80075ae:	4613      	mov	r3, r2
 80075b0:	00db      	lsls	r3, r3, #3
 80075b2:	1a9b      	subs	r3, r3, r2
 80075b4:	00db      	lsls	r3, r3, #3
 80075b6:	440b      	add	r3, r1
 80075b8:	3330      	adds	r3, #48	; 0x30
 80075ba:	681b      	ldr	r3, [r3, #0]
 80075bc:	1c59      	adds	r1, r3, #1
 80075be:	488b      	ldr	r0, [pc, #556]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 80075c0:	69ba      	ldr	r2, [r7, #24]
 80075c2:	4613      	mov	r3, r2
 80075c4:	00db      	lsls	r3, r3, #3
 80075c6:	1a9b      	subs	r3, r3, r2
 80075c8:	00db      	lsls	r3, r3, #3
 80075ca:	4403      	add	r3, r0
 80075cc:	3330      	adds	r3, #48	; 0x30
 80075ce:	6019      	str	r1, [r3, #0]

    if ((runTask->taskId != idleTaskId) && (newTask->taskId == idleTaskId)) {
 80075d0:	697b      	ldr	r3, [r7, #20]
 80075d2:	695b      	ldr	r3, [r3, #20]
 80075d4:	69fa      	ldr	r2, [r7, #28]
 80075d6:	429a      	cmp	r2, r3
 80075d8:	d011      	beq.n	80075fe <OsSchedStatisticsPerCpu+0x7e>
 80075da:	693b      	ldr	r3, [r7, #16]
 80075dc:	695b      	ldr	r3, [r3, #20]
 80075de:	69fa      	ldr	r2, [r7, #28]
 80075e0:	429a      	cmp	r2, r3
 80075e2:	d10c      	bne.n	80075fe <OsSchedStatisticsPerCpu+0x7e>
        g_statPercpu[cpuId].idleStarttime = now;
 80075e4:	4981      	ldr	r1, [pc, #516]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 80075e6:	69ba      	ldr	r2, [r7, #24]
 80075e8:	4613      	mov	r3, r2
 80075ea:	00db      	lsls	r3, r3, #3
 80075ec:	1a9b      	subs	r3, r3, r2
 80075ee:	00db      	lsls	r3, r3, #3
 80075f0:	440b      	add	r3, r1
 80075f2:	f103 0108 	add.w	r1, r3, #8
 80075f6:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80075fa:	e9c1 2300 	strd	r2, r3, [r1]
    }

    if ((runTask->taskId == idleTaskId) && (newTask->taskId != idleTaskId)) {
 80075fe:	697b      	ldr	r3, [r7, #20]
 8007600:	695b      	ldr	r3, [r3, #20]
 8007602:	69fa      	ldr	r2, [r7, #28]
 8007604:	429a      	cmp	r2, r3
 8007606:	d143      	bne.n	8007690 <OsSchedStatisticsPerCpu+0x110>
 8007608:	693b      	ldr	r3, [r7, #16]
 800760a:	695b      	ldr	r3, [r3, #20]
 800760c:	69fa      	ldr	r2, [r7, #28]
 800760e:	429a      	cmp	r2, r3
 8007610:	d03e      	beq.n	8007690 <OsSchedStatisticsPerCpu+0x110>
        runtime = now - g_statPercpu[cpuId].idleStarttime;
 8007612:	4976      	ldr	r1, [pc, #472]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 8007614:	69ba      	ldr	r2, [r7, #24]
 8007616:	4613      	mov	r3, r2
 8007618:	00db      	lsls	r3, r3, #3
 800761a:	1a9b      	subs	r3, r3, r2
 800761c:	00db      	lsls	r3, r3, #3
 800761e:	440b      	add	r3, r1
 8007620:	3308      	adds	r3, #8
 8007622:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007626:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800762a:	1a86      	subs	r6, r0, r2
 800762c:	603e      	str	r6, [r7, #0]
 800762e:	eb61 0303 	sbc.w	r3, r1, r3
 8007632:	607b      	str	r3, [r7, #4]
 8007634:	e9d7 2300 	ldrd	r2, r3, [r7]
 8007638:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
        g_statPercpu[cpuId].idleRuntime += runtime;
 800763c:	496b      	ldr	r1, [pc, #428]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 800763e:	69ba      	ldr	r2, [r7, #24]
 8007640:	4613      	mov	r3, r2
 8007642:	00db      	lsls	r3, r3, #3
 8007644:	1a9b      	subs	r3, r3, r2
 8007646:	00db      	lsls	r3, r3, #3
 8007648:	440b      	add	r3, r1
 800764a:	e9d3 0100 	ldrd	r0, r1, [r3]
 800764e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8007652:	1886      	adds	r6, r0, r2
 8007654:	60be      	str	r6, [r7, #8]
 8007656:	eb41 0303 	adc.w	r3, r1, r3
 800765a:	60fb      	str	r3, [r7, #12]
 800765c:	4963      	ldr	r1, [pc, #396]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 800765e:	69ba      	ldr	r2, [r7, #24]
 8007660:	4613      	mov	r3, r2
 8007662:	00db      	lsls	r3, r3, #3
 8007664:	1a9b      	subs	r3, r3, r2
 8007666:	00db      	lsls	r3, r3, #3
 8007668:	440b      	add	r3, r1
 800766a:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 800766e:	e9c3 1200 	strd	r1, r2, [r3]
        g_statPercpu[cpuId].idleStarttime = 0;
 8007672:	495e      	ldr	r1, [pc, #376]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 8007674:	69ba      	ldr	r2, [r7, #24]
 8007676:	4613      	mov	r3, r2
 8007678:	00db      	lsls	r3, r3, #3
 800767a:	1a9b      	subs	r3, r3, r2
 800767c:	00db      	lsls	r3, r3, #3
 800767e:	440b      	add	r3, r1
 8007680:	f103 0108 	add.w	r1, r3, #8
 8007684:	f04f 0200 	mov.w	r2, #0
 8007688:	f04f 0300 	mov.w	r3, #0
 800768c:	e9c1 2300 	strd	r2, r3, [r1]
    }

    if ((runTask->priority >= HIGHTASKPRI) && (newTask->priority < HIGHTASKPRI)) {
 8007690:	697b      	ldr	r3, [r7, #20]
 8007692:	88db      	ldrh	r3, [r3, #6]
 8007694:	2b0f      	cmp	r3, #15
 8007696:	d910      	bls.n	80076ba <OsSchedStatisticsPerCpu+0x13a>
 8007698:	693b      	ldr	r3, [r7, #16]
 800769a:	88db      	ldrh	r3, [r3, #6]
 800769c:	2b0f      	cmp	r3, #15
 800769e:	d80c      	bhi.n	80076ba <OsSchedStatisticsPerCpu+0x13a>
        g_statPercpu[cpuId].highTaskStarttime = now;
 80076a0:	4952      	ldr	r1, [pc, #328]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 80076a2:	69ba      	ldr	r2, [r7, #24]
 80076a4:	4613      	mov	r3, r2
 80076a6:	00db      	lsls	r3, r3, #3
 80076a8:	1a9b      	subs	r3, r3, r2
 80076aa:	00db      	lsls	r3, r3, #3
 80076ac:	440b      	add	r3, r1
 80076ae:	f103 0118 	add.w	r1, r3, #24
 80076b2:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80076b6:	e9c1 2300 	strd	r2, r3, [r1]
    }

    if ((runTask->priority < HIGHTASKPRI) && (newTask->priority >= HIGHTASKPRI)) {
 80076ba:	697b      	ldr	r3, [r7, #20]
 80076bc:	88db      	ldrh	r3, [r3, #6]
 80076be:	2b0f      	cmp	r3, #15
 80076c0:	d83e      	bhi.n	8007740 <OsSchedStatisticsPerCpu+0x1c0>
 80076c2:	693b      	ldr	r3, [r7, #16]
 80076c4:	88db      	ldrh	r3, [r3, #6]
 80076c6:	2b0f      	cmp	r3, #15
 80076c8:	d93a      	bls.n	8007740 <OsSchedStatisticsPerCpu+0x1c0>
        runtime = now - g_statPercpu[cpuId].highTaskStarttime;
 80076ca:	4948      	ldr	r1, [pc, #288]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 80076cc:	69ba      	ldr	r2, [r7, #24]
 80076ce:	4613      	mov	r3, r2
 80076d0:	00db      	lsls	r3, r3, #3
 80076d2:	1a9b      	subs	r3, r3, r2
 80076d4:	00db      	lsls	r3, r3, #3
 80076d6:	440b      	add	r3, r1
 80076d8:	3318      	adds	r3, #24
 80076da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80076de:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 80076e2:	ebb0 0a02 	subs.w	sl, r0, r2
 80076e6:	eb61 0b03 	sbc.w	fp, r1, r3
 80076ea:	e9c7 ab0a 	strd	sl, fp, [r7, #40]	; 0x28
        g_statPercpu[cpuId].highTaskRuntime += runtime;
 80076ee:	493f      	ldr	r1, [pc, #252]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 80076f0:	69ba      	ldr	r2, [r7, #24]
 80076f2:	4613      	mov	r3, r2
 80076f4:	00db      	lsls	r3, r3, #3
 80076f6:	1a9b      	subs	r3, r3, r2
 80076f8:	00db      	lsls	r3, r3, #3
 80076fa:	440b      	add	r3, r1
 80076fc:	3310      	adds	r3, #16
 80076fe:	e9d3 0100 	ldrd	r0, r1, [r3]
 8007702:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8007706:	eb10 0802 	adds.w	r8, r0, r2
 800770a:	eb41 0903 	adc.w	r9, r1, r3
 800770e:	4937      	ldr	r1, [pc, #220]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 8007710:	69ba      	ldr	r2, [r7, #24]
 8007712:	4613      	mov	r3, r2
 8007714:	00db      	lsls	r3, r3, #3
 8007716:	1a9b      	subs	r3, r3, r2
 8007718:	00db      	lsls	r3, r3, #3
 800771a:	440b      	add	r3, r1
 800771c:	3310      	adds	r3, #16
 800771e:	e9c3 8900 	strd	r8, r9, [r3]
        g_statPercpu[cpuId].highTaskStarttime = 0;
 8007722:	4932      	ldr	r1, [pc, #200]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 8007724:	69ba      	ldr	r2, [r7, #24]
 8007726:	4613      	mov	r3, r2
 8007728:	00db      	lsls	r3, r3, #3
 800772a:	1a9b      	subs	r3, r3, r2
 800772c:	00db      	lsls	r3, r3, #3
 800772e:	440b      	add	r3, r1
 8007730:	f103 0118 	add.w	r1, r3, #24
 8007734:	f04f 0200 	mov.w	r2, #0
 8007738:	f04f 0300 	mov.w	r3, #0
 800773c:	e9c1 2300 	strd	r2, r3, [r1]
    }

    if (newTask->priority < HIGHTASKPRI) {
 8007740:	693b      	ldr	r3, [r7, #16]
 8007742:	88db      	ldrh	r3, [r3, #6]
 8007744:	2b0f      	cmp	r3, #15
 8007746:	d812      	bhi.n	800776e <OsSchedStatisticsPerCpu+0x1ee>
        g_statPercpu[cpuId].highTaskSwitch++;
 8007748:	4928      	ldr	r1, [pc, #160]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 800774a:	69ba      	ldr	r2, [r7, #24]
 800774c:	4613      	mov	r3, r2
 800774e:	00db      	lsls	r3, r3, #3
 8007750:	1a9b      	subs	r3, r3, r2
 8007752:	00db      	lsls	r3, r3, #3
 8007754:	440b      	add	r3, r1
 8007756:	332c      	adds	r3, #44	; 0x2c
 8007758:	681b      	ldr	r3, [r3, #0]
 800775a:	1c59      	adds	r1, r3, #1
 800775c:	4823      	ldr	r0, [pc, #140]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 800775e:	69ba      	ldr	r2, [r7, #24]
 8007760:	4613      	mov	r3, r2
 8007762:	00db      	lsls	r3, r3, #3
 8007764:	1a9b      	subs	r3, r3, r2
 8007766:	00db      	lsls	r3, r3, #3
 8007768:	4403      	add	r3, r0
 800776a:	332c      	adds	r3, #44	; 0x2c
 800776c:	6019      	str	r1, [r3, #0]
    }

    if (newTask->taskId != idleTaskId) {
 800776e:	693b      	ldr	r3, [r7, #16]
 8007770:	695b      	ldr	r3, [r3, #20]
 8007772:	69fa      	ldr	r2, [r7, #28]
 8007774:	429a      	cmp	r2, r3
 8007776:	d031      	beq.n	80077dc <OsSchedStatisticsPerCpu+0x25c>
        g_statPercpu[cpuId].sumPriority += newTask->priority;
 8007778:	491c      	ldr	r1, [pc, #112]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 800777a:	69ba      	ldr	r2, [r7, #24]
 800777c:	4613      	mov	r3, r2
 800777e:	00db      	lsls	r3, r3, #3
 8007780:	1a9b      	subs	r3, r3, r2
 8007782:	00db      	lsls	r3, r3, #3
 8007784:	440b      	add	r3, r1
 8007786:	3320      	adds	r3, #32
 8007788:	e9d3 0100 	ldrd	r0, r1, [r3]
 800778c:	693b      	ldr	r3, [r7, #16]
 800778e:	88db      	ldrh	r3, [r3, #6]
 8007790:	b29a      	uxth	r2, r3
 8007792:	f04f 0300 	mov.w	r3, #0
 8007796:	1884      	adds	r4, r0, r2
 8007798:	eb41 0503 	adc.w	r5, r1, r3
 800779c:	4913      	ldr	r1, [pc, #76]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 800779e:	69ba      	ldr	r2, [r7, #24]
 80077a0:	4613      	mov	r3, r2
 80077a2:	00db      	lsls	r3, r3, #3
 80077a4:	1a9b      	subs	r3, r3, r2
 80077a6:	00db      	lsls	r3, r3, #3
 80077a8:	440b      	add	r3, r1
 80077aa:	3320      	adds	r3, #32
 80077ac:	e9c3 4500 	strd	r4, r5, [r3]
        g_statPercpu[cpuId].prioritySwitch++;
 80077b0:	490e      	ldr	r1, [pc, #56]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 80077b2:	69ba      	ldr	r2, [r7, #24]
 80077b4:	4613      	mov	r3, r2
 80077b6:	00db      	lsls	r3, r3, #3
 80077b8:	1a9b      	subs	r3, r3, r2
 80077ba:	00db      	lsls	r3, r3, #3
 80077bc:	440b      	add	r3, r1
 80077be:	3328      	adds	r3, #40	; 0x28
 80077c0:	681b      	ldr	r3, [r3, #0]
 80077c2:	1c59      	adds	r1, r3, #1
 80077c4:	4809      	ldr	r0, [pc, #36]	; (80077ec <OsSchedStatisticsPerCpu+0x26c>)
 80077c6:	69ba      	ldr	r2, [r7, #24]
 80077c8:	4613      	mov	r3, r2
 80077ca:	00db      	lsls	r3, r3, #3
 80077cc:	1a9b      	subs	r3, r3, r2
 80077ce:	00db      	lsls	r3, r3, #3
 80077d0:	4403      	add	r3, r0
 80077d2:	3328      	adds	r3, #40	; 0x28
 80077d4:	6019      	str	r1, [r3, #0]
    }

    return;
 80077d6:	e001      	b.n	80077dc <OsSchedStatisticsPerCpu+0x25c>
        return;
 80077d8:	bf00      	nop
 80077da:	e000      	b.n	80077de <OsSchedStatisticsPerCpu+0x25e>
    return;
 80077dc:	bf00      	nop
}
 80077de:	3734      	adds	r7, #52	; 0x34
 80077e0:	46bd      	mov	sp, r7
 80077e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80077e6:	bf00      	nop
 80077e8:	200007b4 	.word	0x200007b4
 80077ec:	200007b8 	.word	0x200007b8

080077f0 <OsSchedStatistics>:

LITE_OS_SEC_TEXT_MINOR VOID OsSchedStatistics(LosTaskCB *runTask, LosTaskCB *newTask)
{
 80077f0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80077f4:	b08c      	sub	sp, #48	; 0x30
 80077f6:	af00      	add	r7, sp, #0
 80077f8:	6078      	str	r0, [r7, #4]
 80077fa:	6039      	str	r1, [r7, #0]
    UINT64 runtime;
    UINT32 cpuId = ArchCurrCpuid();
 80077fc:	f7ff feb8 	bl	8007570 <ArchCurrCpuid>
 8007800:	60f8      	str	r0, [r7, #12]
    UINT64 now = LOS_CurrNanosec();
 8007802:	f7fc fe01 	bl	8004408 <LOS_CurrNanosec>
 8007806:	e9c7 0108 	strd	r0, r1, [r7, #32]

    SchedStat *schedRun = &runTask->schedStat;
 800780a:	687b      	ldr	r3, [r7, #4]
 800780c:	3378      	adds	r3, #120	; 0x78
 800780e:	613b      	str	r3, [r7, #16]
    SchedStat *schedNew = &newTask->schedStat;
 8007810:	683b      	ldr	r3, [r7, #0]
 8007812:	3378      	adds	r3, #120	; 0x78
 8007814:	617b      	str	r3, [r7, #20]
    SchedPercpu *cpuRun = &schedRun->schedPercpu[cpuId];
 8007816:	68fb      	ldr	r3, [r7, #12]
 8007818:	011b      	lsls	r3, r3, #4
 800781a:	3318      	adds	r3, #24
 800781c:	693a      	ldr	r2, [r7, #16]
 800781e:	4413      	add	r3, r2
 8007820:	61bb      	str	r3, [r7, #24]
    SchedPercpu *cpuNew = &schedNew->schedPercpu[cpuId];
 8007822:	68fb      	ldr	r3, [r7, #12]
 8007824:	011b      	lsls	r3, r3, #4
 8007826:	3318      	adds	r3, #24
 8007828:	697a      	ldr	r2, [r7, #20]
 800782a:	4413      	add	r3, r2
 800782c:	61fb      	str	r3, [r7, #28]

    /* calculate one chance of running time */
    runtime = now - schedRun->startRuntime;
 800782e:	693b      	ldr	r3, [r7, #16]
 8007830:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007834:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8007838:	ebb0 0a02 	subs.w	sl, r0, r2
 800783c:	eb61 0b03 	sbc.w	fp, r1, r3
 8007840:	e9c7 ab0a 	strd	sl, fp, [r7, #40]	; 0x28

    /* add running timer to running task statistics */
    cpuRun->runtime += runtime;
 8007844:	69bb      	ldr	r3, [r7, #24]
 8007846:	e9d3 0100 	ldrd	r0, r1, [r3]
 800784a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 800784e:	eb10 0802 	adds.w	r8, r0, r2
 8007852:	eb41 0903 	adc.w	r9, r1, r3
 8007856:	69bb      	ldr	r3, [r7, #24]
 8007858:	e9c3 8900 	strd	r8, r9, [r3]
    schedRun->allRuntime += runtime;
 800785c:	693b      	ldr	r3, [r7, #16]
 800785e:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8007862:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8007866:	1884      	adds	r4, r0, r2
 8007868:	eb41 0503 	adc.w	r5, r1, r3
 800786c:	693b      	ldr	r3, [r7, #16]
 800786e:	e9c3 4502 	strd	r4, r5, [r3, #8]

    /* add context switch counters and schedule start time */
    cpuNew->contexSwitch++;
 8007872:	69fb      	ldr	r3, [r7, #28]
 8007874:	689b      	ldr	r3, [r3, #8]
 8007876:	1c5a      	adds	r2, r3, #1
 8007878:	69fb      	ldr	r3, [r7, #28]
 800787a:	609a      	str	r2, [r3, #8]
    schedNew->allContextSwitch++;
 800787c:	697b      	ldr	r3, [r7, #20]
 800787e:	691b      	ldr	r3, [r3, #16]
 8007880:	1c5a      	adds	r2, r3, #1
 8007882:	697b      	ldr	r3, [r7, #20]
 8007884:	611a      	str	r2, [r3, #16]
    schedNew->startRuntime = now;
 8007886:	6979      	ldr	r1, [r7, #20]
 8007888:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800788c:	e9c1 2300 	strd	r2, r3, [r1]
    OsSchedStatisticsPerCpu(runTask, newTask);
 8007890:	6839      	ldr	r1, [r7, #0]
 8007892:	6878      	ldr	r0, [r7, #4]
 8007894:	f7ff fe74 	bl	8007580 <OsSchedStatisticsPerCpu>
}
 8007898:	bf00      	nop
 800789a:	3730      	adds	r7, #48	; 0x30
 800789c:	46bd      	mov	sp, r7
 800789e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
	...

080078a4 <OsHwiStatistics>:

LITE_OS_SEC_TEXT_MINOR VOID OsHwiStatistics(size_t intNum)
{
 80078a4:	b580      	push	{r7, lr}
 80078a6:	b084      	sub	sp, #16
 80078a8:	af00      	add	r7, sp, #0
 80078aa:	6078      	str	r0, [r7, #4]
    UINT32 cpuId = ArchCurrCpuid();
 80078ac:	f7ff fe60 	bl	8007570 <ArchCurrCpuid>
 80078b0:	60f8      	str	r0, [r7, #12]

    if ((g_statisticsStartFlag != TRUE) || (intNum == OS_TICK_INT_NUM)) {
 80078b2:	4b0f      	ldr	r3, [pc, #60]	; (80078f0 <OsHwiStatistics+0x4c>)
 80078b4:	681b      	ldr	r3, [r3, #0]
 80078b6:	2b01      	cmp	r3, #1
 80078b8:	d116      	bne.n	80078e8 <OsHwiStatistics+0x44>
 80078ba:	687b      	ldr	r3, [r7, #4]
 80078bc:	2b0f      	cmp	r3, #15
 80078be:	d013      	beq.n	80078e8 <OsHwiStatistics+0x44>
        return;
    }

    g_statPercpu[cpuId].hwiNum++;
 80078c0:	490c      	ldr	r1, [pc, #48]	; (80078f4 <OsHwiStatistics+0x50>)
 80078c2:	68fa      	ldr	r2, [r7, #12]
 80078c4:	4613      	mov	r3, r2
 80078c6:	00db      	lsls	r3, r3, #3
 80078c8:	1a9b      	subs	r3, r3, r2
 80078ca:	00db      	lsls	r3, r3, #3
 80078cc:	440b      	add	r3, r1
 80078ce:	3334      	adds	r3, #52	; 0x34
 80078d0:	681b      	ldr	r3, [r3, #0]
 80078d2:	1c59      	adds	r1, r3, #1
 80078d4:	4807      	ldr	r0, [pc, #28]	; (80078f4 <OsHwiStatistics+0x50>)
 80078d6:	68fa      	ldr	r2, [r7, #12]
 80078d8:	4613      	mov	r3, r2
 80078da:	00db      	lsls	r3, r3, #3
 80078dc:	1a9b      	subs	r3, r3, r2
 80078de:	00db      	lsls	r3, r3, #3
 80078e0:	4403      	add	r3, r0
 80078e2:	3334      	adds	r3, #52	; 0x34
 80078e4:	6019      	str	r1, [r3, #0]
    /* 16: 0~15 is ipi interrupts */
    if (intNum < 16) {
        g_statPercpu[cpuId].ipiIrqNum++;
    }
#endif
    return;
 80078e6:	e000      	b.n	80078ea <OsHwiStatistics+0x46>
        return;
 80078e8:	bf00      	nop
}
 80078ea:	3710      	adds	r7, #16
 80078ec:	46bd      	mov	sp, r7
 80078ee:	bd80      	pop	{r7, pc}
 80078f0:	200007b4 	.word	0x200007b4
 80078f4:	200007b8 	.word	0x200007b8

080078f8 <LOS_IntLock>:
{
 80078f8:	b580      	push	{r7, lr}
 80078fa:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80078fc:	f7f9 f9e4 	bl	8000cc8 <ArchIntLock>
 8007900:	4603      	mov	r3, r0
}
 8007902:	4618      	mov	r0, r3
 8007904:	bd80      	pop	{r7, pc}

08007906 <LOS_IntRestore>:
{
 8007906:	b580      	push	{r7, lr}
 8007908:	b082      	sub	sp, #8
 800790a:	af00      	add	r7, sp, #0
 800790c:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800790e:	6878      	ldr	r0, [r7, #4]
 8007910:	f7f9 f9e2 	bl	8000cd8 <ArchIntRestore>
}
 8007914:	bf00      	nop
 8007916:	3708      	adds	r7, #8
 8007918:	46bd      	mov	sp, r7
 800791a:	bd80      	pop	{r7, pc}

0800791c <OsGetHwiForm>:
 * will not respond. eg: Used for arm(cortex-a/r)/arm64.
 */
extern VOID OsIntEntry(VOID);

STATIC INLINE HwiHandleInfo *OsGetHwiForm(UINT32 hwiNum)
{
 800791c:	b580      	push	{r7, lr}
 800791e:	b082      	sub	sp, #8
 8007920:	af00      	add	r7, sp, #0
 8007922:	6078      	str	r0, [r7, #4]
    if ((g_hwiOps == NULL) || (g_hwiOps->getHandleForm == NULL)) {
 8007924:	4b0a      	ldr	r3, [pc, #40]	; (8007950 <OsGetHwiForm+0x34>)
 8007926:	681b      	ldr	r3, [r3, #0]
 8007928:	2b00      	cmp	r3, #0
 800792a:	d004      	beq.n	8007936 <OsGetHwiForm+0x1a>
 800792c:	4b08      	ldr	r3, [pc, #32]	; (8007950 <OsGetHwiForm+0x34>)
 800792e:	681b      	ldr	r3, [r3, #0]
 8007930:	69db      	ldr	r3, [r3, #28]
 8007932:	2b00      	cmp	r3, #0
 8007934:	d101      	bne.n	800793a <OsGetHwiForm+0x1e>
        return NULL;
 8007936:	2300      	movs	r3, #0
 8007938:	e005      	b.n	8007946 <OsGetHwiForm+0x2a>
    }
    return g_hwiOps->getHandleForm(hwiNum);
 800793a:	4b05      	ldr	r3, [pc, #20]	; (8007950 <OsGetHwiForm+0x34>)
 800793c:	681b      	ldr	r3, [r3, #0]
 800793e:	69db      	ldr	r3, [r3, #28]
 8007940:	6878      	ldr	r0, [r7, #4]
 8007942:	4798      	blx	r3
 8007944:	4603      	mov	r3, r0
}
 8007946:	4618      	mov	r0, r3
 8007948:	3708      	adds	r7, #8
 800794a:	46bd      	mov	sp, r7
 800794c:	bd80      	pop	{r7, pc}
 800794e:	bf00      	nop
 8007950:	20000764 	.word	0x20000764

08007954 <OsGetHwiFormCnt>:

STATIC INLINE UINT32 OsGetHwiFormCnt(UINT32 hwiNum)
{
 8007954:	b580      	push	{r7, lr}
 8007956:	b084      	sub	sp, #16
 8007958:	af00      	add	r7, sp, #0
 800795a:	6078      	str	r0, [r7, #4]
    HwiHandleInfo *hwiForm = OsGetHwiForm(hwiNum);
 800795c:	6878      	ldr	r0, [r7, #4]
 800795e:	f7ff ffdd 	bl	800791c <OsGetHwiForm>
 8007962:	60f8      	str	r0, [r7, #12]

    if (hwiForm == NULL) {
 8007964:	68fb      	ldr	r3, [r7, #12]
 8007966:	2b00      	cmp	r3, #0
 8007968:	d101      	bne.n	800796e <OsGetHwiFormCnt+0x1a>
        return LOS_ERRNO_HWI_NUM_INVALID;
 800796a:	4b04      	ldr	r3, [pc, #16]	; (800797c <OsGetHwiFormCnt+0x28>)
 800796c:	e001      	b.n	8007972 <OsGetHwiFormCnt+0x1e>
    }
    return hwiForm->respCount;
 800796e:	68fb      	ldr	r3, [r7, #12]
 8007970:	68db      	ldr	r3, [r3, #12]
}
 8007972:	4618      	mov	r0, r3
 8007974:	3710      	adds	r7, #16
 8007976:	46bd      	mov	sp, r7
 8007978:	bd80      	pop	{r7, pc}
 800797a:	bf00      	nop
 800797c:	02000900 	.word	0x02000900

08007980 <OsIntIsRegisted>:
    }
    return g_hwiOps->getCurIrqNum();
}

STATIC INLINE BOOL OsIntIsRegisted(UINT32 num)
{
 8007980:	b580      	push	{r7, lr}
 8007982:	b084      	sub	sp, #16
 8007984:	af00      	add	r7, sp, #0
 8007986:	6078      	str	r0, [r7, #4]
    HwiHandleInfo *hwiForm = OsGetHwiForm(num);
 8007988:	6878      	ldr	r0, [r7, #4]
 800798a:	f7ff ffc7 	bl	800791c <OsGetHwiForm>
 800798e:	60f8      	str	r0, [r7, #12]

    if (hwiForm == NULL) {
 8007990:	68fb      	ldr	r3, [r7, #12]
 8007992:	2b00      	cmp	r3, #0
 8007994:	d101      	bne.n	800799a <OsIntIsRegisted+0x1a>
        return false;
 8007996:	2300      	movs	r3, #0
 8007998:	e006      	b.n	80079a8 <OsIntIsRegisted+0x28>
    }
#ifdef LOSCFG_SHARED_IRQ
    return (hwiForm->next != NULL);
 800799a:	68fb      	ldr	r3, [r7, #12]
 800799c:	689b      	ldr	r3, [r3, #8]
 800799e:	2b00      	cmp	r3, #0
 80079a0:	bf14      	ite	ne
 80079a2:	2301      	movne	r3, #1
 80079a4:	2300      	moveq	r3, #0
 80079a6:	b2db      	uxtb	r3, r3
#else
    return (hwiForm->hook != NULL);
#endif
}
 80079a8:	4618      	mov	r0, r3
 80079aa:	3710      	adds	r7, #16
 80079ac:	46bd      	mov	sp, r7
 80079ae:	bd80      	pop	{r7, pc}

080079b0 <OsShellCmdHwiInfoTitle>:
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

LITE_OS_SEC_TEXT_MINOR STATIC VOID OsShellCmdHwiInfoTitle(VOID)
{
 80079b0:	b580      	push	{r7, lr}
 80079b2:	af00      	add	r7, sp, #0
#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    PRINTK("InterruptNo     Share     ResponseCount     CYCLECOST     CPUUSE     CPUUSE10s     CPUUSE1s     Name"
 80079b4:	4803      	ldr	r0, [pc, #12]	; (80079c4 <OsShellCmdHwiInfoTitle+0x14>)
 80079b6:	f7fc ff83 	bl	80048c0 <dprintf>
           "             DevId\n");
    PRINTK("-----------     -----     -------------     ---------     ------     ---------     --------     ---------"
 80079ba:	4803      	ldr	r0, [pc, #12]	; (80079c8 <OsShellCmdHwiInfoTitle+0x18>)
 80079bc:	f7fc ff80 	bl	80048c0 <dprintf>

#else
    PRINTK("InterruptNo     Share     ResponseCount     Name             DevId\n");
    PRINTK("-----------     -----     -------------     ---------        --------\n");
#endif
}
 80079c0:	bf00      	nop
 80079c2:	bd80      	pop	{r7, pc}
 80079c4:	080209cc 	.word	0x080209cc
 80079c8:	08020a44 	.word	0x08020a44

080079cc <GetHwiShare>:

STATIC BOOL GetHwiShare(const HwiHandleInfo *hwiForm)
{
 80079cc:	b480      	push	{r7}
 80079ce:	b083      	sub	sp, #12
 80079d0:	af00      	add	r7, sp, #0
 80079d2:	6078      	str	r0, [r7, #4]
#ifndef LOSCFG_SHARED_IRQ
    return false;
#else
    return (hwiForm->shareMode);
 80079d4:	687b      	ldr	r3, [r7, #4]
 80079d6:	685b      	ldr	r3, [r3, #4]
#endif
}
 80079d8:	4618      	mov	r0, r3
 80079da:	370c      	adds	r7, #12
 80079dc:	46bd      	mov	sp, r7
 80079de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079e2:	4770      	bx	lr

080079e4 <OsShellCmdHwi>:
#ifdef LOSCFG_CPUP_INCLUDE_IRQ
STATIC CPUP_INFO_S g_hwiCpupAll[LOSCFG_PLATFORM_HWI_LIMIT];
STATIC CPUP_INFO_S g_hwiCpup10s[LOSCFG_PLATFORM_HWI_LIMIT];
STATIC CPUP_INFO_S g_hwiCpup1s[LOSCFG_PLATFORM_HWI_LIMIT];
LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdHwi(INT32 argc, const CHAR **argv)
{
 80079e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80079e6:	b093      	sub	sp, #76	; 0x4c
 80079e8:	af08      	add	r7, sp, #32
 80079ea:	60f8      	str	r0, [r7, #12]
 80079ec:	60b9      	str	r1, [r7, #8]
    UINT32 i, intSave;
    UINT64 cycles = 0;
 80079ee:	f04f 0200 	mov.w	r2, #0
 80079f2:	f04f 0300 	mov.w	r3, #0
 80079f6:	e9c7 2308 	strd	r2, r3, [r7, #32]
    size_t size = sizeof(CPUP_INFO_S) * LOSCFG_PLATFORM_HWI_LIMIT;
 80079fa:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80079fe:	61bb      	str	r3, [r7, #24]
    HwiHandleInfo *hwiForm = NULL;
 8007a00:	2300      	movs	r3, #0
 8007a02:	617b      	str	r3, [r7, #20]

    (VOID)argv;
    if (argc > 0) {
 8007a04:	68fb      	ldr	r3, [r7, #12]
 8007a06:	2b00      	cmp	r3, #0
 8007a08:	dd05      	ble.n	8007a16 <OsShellCmdHwi+0x32>
        PRINTK("\nUsage: hwi\n");
 8007a0a:	4881      	ldr	r0, [pc, #516]	; (8007c10 <OsShellCmdHwi+0x22c>)
 8007a0c:	f7fc ff58 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8007a10:	f04f 33ff 	mov.w	r3, #4294967295
 8007a14:	e0f7      	b.n	8007c06 <OsShellCmdHwi+0x222>
    }

    (VOID)memset_s(g_hwiCpupAll, size, 0, size);
 8007a16:	69bb      	ldr	r3, [r7, #24]
 8007a18:	2200      	movs	r2, #0
 8007a1a:	69b9      	ldr	r1, [r7, #24]
 8007a1c:	487d      	ldr	r0, [pc, #500]	; (8007c14 <OsShellCmdHwi+0x230>)
 8007a1e:	f7fa fb41 	bl	80020a4 <memset_s>
    (VOID)memset_s(g_hwiCpup10s, size, 0, size);
 8007a22:	69bb      	ldr	r3, [r7, #24]
 8007a24:	2200      	movs	r2, #0
 8007a26:	69b9      	ldr	r1, [r7, #24]
 8007a28:	487b      	ldr	r0, [pc, #492]	; (8007c18 <OsShellCmdHwi+0x234>)
 8007a2a:	f7fa fb3b 	bl	80020a4 <memset_s>
    (VOID)memset_s(g_hwiCpup1s, size, 0, size);
 8007a2e:	69bb      	ldr	r3, [r7, #24]
 8007a30:	2200      	movs	r2, #0
 8007a32:	69b9      	ldr	r1, [r7, #24]
 8007a34:	4879      	ldr	r0, [pc, #484]	; (8007c1c <OsShellCmdHwi+0x238>)
 8007a36:	f7fa fb35 	bl	80020a4 <memset_s>

    intSave = LOS_IntLock();
 8007a3a:	f7ff ff5d 	bl	80078f8 <LOS_IntLock>
 8007a3e:	61f8      	str	r0, [r7, #28]
    (VOID)LOS_AllCpuUsage(LOSCFG_PLATFORM_HWI_LIMIT, g_hwiCpupAll, CPUP_ALL_TIME, 0);
 8007a40:	2300      	movs	r3, #0
 8007a42:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007a46:	4973      	ldr	r1, [pc, #460]	; (8007c14 <OsShellCmdHwi+0x230>)
 8007a48:	f44f 7080 	mov.w	r0, #256	; 0x100
 8007a4c:	f00d fa2a 	bl	8014ea4 <LOS_AllCpuUsage>
    (VOID)LOS_AllCpuUsage(LOSCFG_PLATFORM_HWI_LIMIT, g_hwiCpup10s, CPUP_LAST_TEN_SECONDS, 0);
 8007a50:	2300      	movs	r3, #0
 8007a52:	2200      	movs	r2, #0
 8007a54:	4970      	ldr	r1, [pc, #448]	; (8007c18 <OsShellCmdHwi+0x234>)
 8007a56:	f44f 7080 	mov.w	r0, #256	; 0x100
 8007a5a:	f00d fa23 	bl	8014ea4 <LOS_AllCpuUsage>
    (VOID)LOS_AllCpuUsage(LOSCFG_PLATFORM_HWI_LIMIT, g_hwiCpup1s, CPUP_LAST_ONE_SECONDS, 0);
 8007a5e:	2300      	movs	r3, #0
 8007a60:	2201      	movs	r2, #1
 8007a62:	496e      	ldr	r1, [pc, #440]	; (8007c1c <OsShellCmdHwi+0x238>)
 8007a64:	f44f 7080 	mov.w	r0, #256	; 0x100
 8007a68:	f00d fa1c 	bl	8014ea4 <LOS_AllCpuUsage>
    LOS_IntRestore(intSave);
 8007a6c:	69f8      	ldr	r0, [r7, #28]
 8007a6e:	f7ff ff4a 	bl	8007906 <LOS_IntRestore>

    OsShellCmdHwiInfoTitle();
 8007a72:	f7ff ff9d 	bl	80079b0 <OsShellCmdHwiInfoTitle>
    for (i = 0; i < LOSCFG_PLATFORM_HWI_LIMIT; i++) {
 8007a76:	2300      	movs	r3, #0
 8007a78:	613b      	str	r3, [r7, #16]
 8007a7a:	e0bf      	b.n	8007bfc <OsShellCmdHwi+0x218>
        if (!HWI_IS_REGISTED(i)) {
 8007a7c:	6938      	ldr	r0, [r7, #16]
 8007a7e:	f7ff ff7f 	bl	8007980 <OsIntIsRegisted>
 8007a82:	4603      	mov	r3, r0
 8007a84:	2b00      	cmp	r3, #0
 8007a86:	f000 80b5 	beq.w	8007bf4 <OsShellCmdHwi+0x210>
            continue;
        }

        if (OsGetHwiFormCnt(i)) {
 8007a8a:	6938      	ldr	r0, [r7, #16]
 8007a8c:	f7ff ff62 	bl	8007954 <OsGetHwiFormCnt>
 8007a90:	4603      	mov	r3, r0
 8007a92:	2b00      	cmp	r3, #0
 8007a94:	d018      	beq.n	8007ac8 <OsShellCmdHwi+0xe4>
            cycles = (OsCpupCBGet(g_taskMaxNum + i))->allTime / OsGetHwiFormCnt(i);
 8007a96:	4b62      	ldr	r3, [pc, #392]	; (8007c20 <OsShellCmdHwi+0x23c>)
 8007a98:	681a      	ldr	r2, [r3, #0]
 8007a9a:	693b      	ldr	r3, [r7, #16]
 8007a9c:	4413      	add	r3, r2
 8007a9e:	4618      	mov	r0, r3
 8007aa0:	f00c fd00 	bl	80144a4 <OsCpupCBGet>
 8007aa4:	4603      	mov	r3, r0
 8007aa6:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 8007aaa:	6938      	ldr	r0, [r7, #16]
 8007aac:	f7ff ff52 	bl	8007954 <OsGetHwiFormCnt>
 8007ab0:	4603      	mov	r3, r0
 8007ab2:	461a      	mov	r2, r3
 8007ab4:	f04f 0300 	mov.w	r3, #0
 8007ab8:	4620      	mov	r0, r4
 8007aba:	4629      	mov	r1, r5
 8007abc:	f7f8 ff6a 	bl	8000994 <__aeabi_uldivmod>
 8007ac0:	4602      	mov	r2, r0
 8007ac2:	460b      	mov	r3, r1
 8007ac4:	e9c7 2308 	strd	r2, r3, [r7, #32]
        }

        /* Different cores has different hwi form implementation */
        hwiForm = OsGetHwiForm(i);
 8007ac8:	6938      	ldr	r0, [r7, #16]
 8007aca:	f7ff ff27 	bl	800791c <OsGetHwiForm>
 8007ace:	6178      	str	r0, [r7, #20]
        PRINTK("%-8u\t  %-s\t  %-10u\t    %-10llu   %2u.%-7u %2u.%-7u    %2u.%-6u",
 8007ad0:	6978      	ldr	r0, [r7, #20]
 8007ad2:	f7ff ff7b 	bl	80079cc <GetHwiShare>
 8007ad6:	4603      	mov	r3, r0
 8007ad8:	2b00      	cmp	r3, #0
 8007ada:	d002      	beq.n	8007ae2 <OsShellCmdHwi+0xfe>
 8007adc:	4b51      	ldr	r3, [pc, #324]	; (8007c24 <OsShellCmdHwi+0x240>)
 8007ade:	607b      	str	r3, [r7, #4]
 8007ae0:	e001      	b.n	8007ae6 <OsShellCmdHwi+0x102>
 8007ae2:	4b51      	ldr	r3, [pc, #324]	; (8007c28 <OsShellCmdHwi+0x244>)
 8007ae4:	607b      	str	r3, [r7, #4]
 8007ae6:	6938      	ldr	r0, [r7, #16]
 8007ae8:	f7ff ff34 	bl	8007954 <OsGetHwiFormCnt>
 8007aec:	4684      	mov	ip, r0
 8007aee:	4a49      	ldr	r2, [pc, #292]	; (8007c14 <OsShellCmdHwi+0x230>)
 8007af0:	693b      	ldr	r3, [r7, #16]
 8007af2:	00db      	lsls	r3, r3, #3
 8007af4:	4413      	add	r3, r2
 8007af6:	685b      	ldr	r3, [r3, #4]
 8007af8:	4a4c      	ldr	r2, [pc, #304]	; (8007c2c <OsShellCmdHwi+0x248>)
 8007afa:	fba2 2303 	umull	r2, r3, r2, r3
 8007afe:	08dd      	lsrs	r5, r3, #3
 8007b00:	4a44      	ldr	r2, [pc, #272]	; (8007c14 <OsShellCmdHwi+0x230>)
 8007b02:	693b      	ldr	r3, [r7, #16]
 8007b04:	00db      	lsls	r3, r3, #3
 8007b06:	4413      	add	r3, r2
 8007b08:	6859      	ldr	r1, [r3, #4]
 8007b0a:	4b48      	ldr	r3, [pc, #288]	; (8007c2c <OsShellCmdHwi+0x248>)
 8007b0c:	fba3 2301 	umull	r2, r3, r3, r1
 8007b10:	08da      	lsrs	r2, r3, #3
 8007b12:	4613      	mov	r3, r2
 8007b14:	009b      	lsls	r3, r3, #2
 8007b16:	4413      	add	r3, r2
 8007b18:	005b      	lsls	r3, r3, #1
 8007b1a:	1aca      	subs	r2, r1, r3
 8007b1c:	493e      	ldr	r1, [pc, #248]	; (8007c18 <OsShellCmdHwi+0x234>)
 8007b1e:	693b      	ldr	r3, [r7, #16]
 8007b20:	00db      	lsls	r3, r3, #3
 8007b22:	440b      	add	r3, r1
 8007b24:	685b      	ldr	r3, [r3, #4]
 8007b26:	4941      	ldr	r1, [pc, #260]	; (8007c2c <OsShellCmdHwi+0x248>)
 8007b28:	fba1 1303 	umull	r1, r3, r1, r3
 8007b2c:	08de      	lsrs	r6, r3, #3
 8007b2e:	493a      	ldr	r1, [pc, #232]	; (8007c18 <OsShellCmdHwi+0x234>)
 8007b30:	693b      	ldr	r3, [r7, #16]
 8007b32:	00db      	lsls	r3, r3, #3
 8007b34:	440b      	add	r3, r1
 8007b36:	6858      	ldr	r0, [r3, #4]
 8007b38:	4b3c      	ldr	r3, [pc, #240]	; (8007c2c <OsShellCmdHwi+0x248>)
 8007b3a:	fba3 1300 	umull	r1, r3, r3, r0
 8007b3e:	08d9      	lsrs	r1, r3, #3
 8007b40:	460b      	mov	r3, r1
 8007b42:	009b      	lsls	r3, r3, #2
 8007b44:	440b      	add	r3, r1
 8007b46:	005b      	lsls	r3, r3, #1
 8007b48:	1ac1      	subs	r1, r0, r3
 8007b4a:	4834      	ldr	r0, [pc, #208]	; (8007c1c <OsShellCmdHwi+0x238>)
 8007b4c:	693b      	ldr	r3, [r7, #16]
 8007b4e:	00db      	lsls	r3, r3, #3
 8007b50:	4403      	add	r3, r0
 8007b52:	685b      	ldr	r3, [r3, #4]
 8007b54:	4835      	ldr	r0, [pc, #212]	; (8007c2c <OsShellCmdHwi+0x248>)
 8007b56:	fba0 0303 	umull	r0, r3, r0, r3
 8007b5a:	08db      	lsrs	r3, r3, #3
 8007b5c:	603b      	str	r3, [r7, #0]
 8007b5e:	482f      	ldr	r0, [pc, #188]	; (8007c1c <OsShellCmdHwi+0x238>)
 8007b60:	693b      	ldr	r3, [r7, #16]
 8007b62:	00db      	lsls	r3, r3, #3
 8007b64:	4403      	add	r3, r0
 8007b66:	685c      	ldr	r4, [r3, #4]
 8007b68:	4b30      	ldr	r3, [pc, #192]	; (8007c2c <OsShellCmdHwi+0x248>)
 8007b6a:	fba3 0304 	umull	r0, r3, r3, r4
 8007b6e:	08d8      	lsrs	r0, r3, #3
 8007b70:	4603      	mov	r3, r0
 8007b72:	009b      	lsls	r3, r3, #2
 8007b74:	4403      	add	r3, r0
 8007b76:	005b      	lsls	r3, r3, #1
 8007b78:	1ae0      	subs	r0, r4, r3
 8007b7a:	9007      	str	r0, [sp, #28]
 8007b7c:	683b      	ldr	r3, [r7, #0]
 8007b7e:	9306      	str	r3, [sp, #24]
 8007b80:	9105      	str	r1, [sp, #20]
 8007b82:	9604      	str	r6, [sp, #16]
 8007b84:	9203      	str	r2, [sp, #12]
 8007b86:	9502      	str	r5, [sp, #8]
 8007b88:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8007b8c:	e9cd 2300 	strd	r2, r3, [sp]
 8007b90:	4663      	mov	r3, ip
 8007b92:	687a      	ldr	r2, [r7, #4]
 8007b94:	6939      	ldr	r1, [r7, #16]
 8007b96:	4826      	ldr	r0, [pc, #152]	; (8007c30 <OsShellCmdHwi+0x24c>)
 8007b98:	f7fc fe92 	bl	80048c0 <dprintf>
               i, GetHwiShare(hwiForm) ? "Y" : "N", OsGetHwiFormCnt(i), cycles,
               g_hwiCpupAll[i].uwUsage / LOS_CPUP_PRECISION_MULT, g_hwiCpupAll[i].uwUsage % LOS_CPUP_PRECISION_MULT,
               g_hwiCpup10s[i].uwUsage / LOS_CPUP_PRECISION_MULT, g_hwiCpup10s[i].uwUsage % LOS_CPUP_PRECISION_MULT,
               g_hwiCpup1s[i].uwUsage / LOS_CPUP_PRECISION_MULT, g_hwiCpup1s[i].uwUsage % LOS_CPUP_PRECISION_MULT);
#ifdef LOSCFG_SHARED_IRQ
        hwiForm = hwiForm->next;
 8007b9c:	697b      	ldr	r3, [r7, #20]
 8007b9e:	689b      	ldr	r3, [r3, #8]
 8007ba0:	617b      	str	r3, [r7, #20]
#endif
        if ((hwiForm->registerInfo != 0) && ((HWI_IRQ_PARAM_S *)hwiForm->registerInfo)->pName != NULL) {
 8007ba2:	697b      	ldr	r3, [r7, #20]
 8007ba4:	685b      	ldr	r3, [r3, #4]
 8007ba6:	2b00      	cmp	r3, #0
 8007ba8:	d00f      	beq.n	8007bca <OsShellCmdHwi+0x1e6>
 8007baa:	697b      	ldr	r3, [r7, #20]
 8007bac:	685b      	ldr	r3, [r3, #4]
 8007bae:	689b      	ldr	r3, [r3, #8]
 8007bb0:	2b00      	cmp	r3, #0
 8007bb2:	d00a      	beq.n	8007bca <OsShellCmdHwi+0x1e6>
            PRINTK("\t %-16s 0x%-.8x\n",
 8007bb4:	697b      	ldr	r3, [r7, #20]
 8007bb6:	685b      	ldr	r3, [r3, #4]
 8007bb8:	6899      	ldr	r1, [r3, #8]
 8007bba:	697b      	ldr	r3, [r7, #20]
 8007bbc:	685b      	ldr	r3, [r3, #4]
 8007bbe:	685b      	ldr	r3, [r3, #4]
 8007bc0:	461a      	mov	r2, r3
 8007bc2:	481c      	ldr	r0, [pc, #112]	; (8007c34 <OsShellCmdHwi+0x250>)
 8007bc4:	f7fc fe7c 	bl	80048c0 <dprintf>
 8007bc8:	e002      	b.n	8007bd0 <OsShellCmdHwi+0x1ec>
                   ((HWI_IRQ_PARAM_S *)hwiForm->registerInfo)->pName,
                   ((HWI_IRQ_PARAM_S *)hwiForm->registerInfo)->pDevId);
        } else {
            PRINTK("\n");
 8007bca:	481b      	ldr	r0, [pc, #108]	; (8007c38 <OsShellCmdHwi+0x254>)
 8007bcc:	f7fc fe78 	bl	80048c0 <dprintf>
        }
#ifdef LOSCFG_SHARED_IRQ
        while ((hwiForm = hwiForm->next) != NULL) {
 8007bd0:	e009      	b.n	8007be6 <OsShellCmdHwi+0x202>
            PRINTK("\t\t\t\t\t\t\t\t\t\t\t\t %-16s 0x%-.8x\n",
 8007bd2:	697b      	ldr	r3, [r7, #20]
 8007bd4:	685b      	ldr	r3, [r3, #4]
 8007bd6:	6899      	ldr	r1, [r3, #8]
 8007bd8:	697b      	ldr	r3, [r7, #20]
 8007bda:	685b      	ldr	r3, [r3, #4]
 8007bdc:	685b      	ldr	r3, [r3, #4]
 8007bde:	461a      	mov	r2, r3
 8007be0:	4816      	ldr	r0, [pc, #88]	; (8007c3c <OsShellCmdHwi+0x258>)
 8007be2:	f7fc fe6d 	bl	80048c0 <dprintf>
        while ((hwiForm = hwiForm->next) != NULL) {
 8007be6:	697b      	ldr	r3, [r7, #20]
 8007be8:	689b      	ldr	r3, [r3, #8]
 8007bea:	617b      	str	r3, [r7, #20]
 8007bec:	697b      	ldr	r3, [r7, #20]
 8007bee:	2b00      	cmp	r3, #0
 8007bf0:	d1ef      	bne.n	8007bd2 <OsShellCmdHwi+0x1ee>
 8007bf2:	e000      	b.n	8007bf6 <OsShellCmdHwi+0x212>
            continue;
 8007bf4:	bf00      	nop
    for (i = 0; i < LOSCFG_PLATFORM_HWI_LIMIT; i++) {
 8007bf6:	693b      	ldr	r3, [r7, #16]
 8007bf8:	3301      	adds	r3, #1
 8007bfa:	613b      	str	r3, [r7, #16]
 8007bfc:	693b      	ldr	r3, [r7, #16]
 8007bfe:	2bff      	cmp	r3, #255	; 0xff
 8007c00:	f67f af3c 	bls.w	8007a7c <OsShellCmdHwi+0x98>
                   ((HWI_IRQ_PARAM_S *)hwiForm->registerInfo)->pName,
                   ((HWI_IRQ_PARAM_S *)hwiForm->registerInfo)->pDevId);
        }
#endif
    }
    return 0;
 8007c04:	2300      	movs	r3, #0
}
 8007c06:	4618      	mov	r0, r3
 8007c08:	372c      	adds	r7, #44	; 0x2c
 8007c0a:	46bd      	mov	sp, r7
 8007c0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007c0e:	bf00      	nop
 8007c10:	08020ac0 	.word	0x08020ac0
 8007c14:	200007f0 	.word	0x200007f0
 8007c18:	20000ff0 	.word	0x20000ff0
 8007c1c:	200017f0 	.word	0x200017f0
 8007c20:	200036d8 	.word	0x200036d8
 8007c24:	08020ad0 	.word	0x08020ad0
 8007c28:	08020ad4 	.word	0x08020ad4
 8007c2c:	cccccccd 	.word	0xcccccccd
 8007c30:	08020ad8 	.word	0x08020ad8
 8007c34:	08020b18 	.word	0x08020b18
 8007c38:	08020b2c 	.word	0x08020b2c
 8007c3c:	08020b30 	.word	0x08020b30

08007c40 <OsShellCmdMemCheck>:

#define MEM_SIZE_1K 0x400
#define MEM_SIZE_1M 0x100000

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdMemCheck(INT32 argc, const CHAR *argv[])
{
 8007c40:	b580      	push	{r7, lr}
 8007c42:	b082      	sub	sp, #8
 8007c44:	af00      	add	r7, sp, #0
 8007c46:	6078      	str	r0, [r7, #4]
 8007c48:	6039      	str	r1, [r7, #0]
    if (argc > 0) {
 8007c4a:	687b      	ldr	r3, [r7, #4]
 8007c4c:	2b00      	cmp	r3, #0
 8007c4e:	dd05      	ble.n	8007c5c <OsShellCmdMemCheck+0x1c>
        PRINTK("\nUsage: memcheck\n");
 8007c50:	4806      	ldr	r0, [pc, #24]	; (8007c6c <OsShellCmdMemCheck+0x2c>)
 8007c52:	f7fc fe35 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8007c56:	f04f 33ff 	mov.w	r3, #4294967295
 8007c5a:	e002      	b.n	8007c62 <OsShellCmdMemCheck+0x22>
    }

    OsMemIntegrityMultiCheck();
 8007c5c:	f001 fdc4 	bl	80097e8 <OsMemIntegrityMultiCheck>
    return 0;
 8007c60:	2300      	movs	r3, #0
}
 8007c62:	4618      	mov	r0, r3
 8007c64:	3708      	adds	r7, #8
 8007c66:	46bd      	mov	sp, r7
 8007c68:	bd80      	pop	{r7, pc}
 8007c6a:	bf00      	nop
 8007c6c:	08020b50 	.word	0x08020b50

08007c70 <OsShellCmdSectionInfo>:

    return 0;
}

LITE_OS_SEC_TEXT_MINOR STATIC VOID OsShellCmdSectionInfo(INT32 argc, const CHAR *argv[])
{
 8007c70:	b580      	push	{r7, lr}
 8007c72:	b088      	sub	sp, #32
 8007c74:	af02      	add	r7, sp, #8
 8007c76:	6078      	str	r0, [r7, #4]
 8007c78:	6039      	str	r1, [r7, #0]
    size_t textLen = &__text_end - &__text_start;
 8007c7a:	4a2a      	ldr	r2, [pc, #168]	; (8007d24 <OsShellCmdSectionInfo+0xb4>)
 8007c7c:	4b2a      	ldr	r3, [pc, #168]	; (8007d28 <OsShellCmdSectionInfo+0xb8>)
 8007c7e:	1ad3      	subs	r3, r2, r3
 8007c80:	60bb      	str	r3, [r7, #8]
    size_t dataLen = &__ram_data_end - &__ram_data_start;
 8007c82:	4a2a      	ldr	r2, [pc, #168]	; (8007d2c <OsShellCmdSectionInfo+0xbc>)
 8007c84:	4b2a      	ldr	r3, [pc, #168]	; (8007d30 <OsShellCmdSectionInfo+0xc0>)
 8007c86:	1ad3      	subs	r3, r2, r3
 8007c88:	60fb      	str	r3, [r7, #12]
    size_t rodataLen = &__rodata_end - &__rodata_start;
 8007c8a:	4a2a      	ldr	r2, [pc, #168]	; (8007d34 <OsShellCmdSectionInfo+0xc4>)
 8007c8c:	4b2a      	ldr	r3, [pc, #168]	; (8007d38 <OsShellCmdSectionInfo+0xc8>)
 8007c8e:	1ad3      	subs	r3, r2, r3
 8007c90:	613b      	str	r3, [r7, #16]
    size_t bssLen = &__bss_end - &__bss_start;
 8007c92:	4a2a      	ldr	r2, [pc, #168]	; (8007d3c <OsShellCmdSectionInfo+0xcc>)
 8007c94:	4b2a      	ldr	r3, [pc, #168]	; (8007d40 <OsShellCmdSectionInfo+0xd0>)
 8007c96:	1ad3      	subs	r3, r2, r3
 8007c98:	617b      	str	r3, [r7, #20]
    textLen += &__fast_text_end - &__fast_text_start;
    dataLen += &__fast_data_end - &__fast_data_start;
    rodataLen += &__fast_rodata_end - &__fast_rodata_start;
#endif

    PRINTK("\r\n        text         data          rodata        bss\n");
 8007c9a:	482a      	ldr	r0, [pc, #168]	; (8007d44 <OsShellCmdSectionInfo+0xd4>)
 8007c9c:	f7fc fe10 	bl	80048c0 <dprintf>
    if ((argc == 1) && (strcmp(argv[0], "-k") == 0)) {
 8007ca0:	687b      	ldr	r3, [r7, #4]
 8007ca2:	2b01      	cmp	r3, #1
 8007ca4:	d116      	bne.n	8007cd4 <OsShellCmdSectionInfo+0x64>
 8007ca6:	683b      	ldr	r3, [r7, #0]
 8007ca8:	681b      	ldr	r3, [r3, #0]
 8007caa:	4927      	ldr	r1, [pc, #156]	; (8007d48 <OsShellCmdSectionInfo+0xd8>)
 8007cac:	4618      	mov	r0, r3
 8007cae:	f007 fc2c 	bl	800f50a <strcmp>
 8007cb2:	4603      	mov	r3, r0
 8007cb4:	2b00      	cmp	r3, #0
 8007cb6:	d10d      	bne.n	8007cd4 <OsShellCmdSectionInfo+0x64>
        PRINTK("Mem:    %-9lu    %-10lu    %-10lu    %-10lu\n", textLen / MEM_SIZE_1K, dataLen / MEM_SIZE_1K,
 8007cb8:	68bb      	ldr	r3, [r7, #8]
 8007cba:	0a99      	lsrs	r1, r3, #10
 8007cbc:	68fb      	ldr	r3, [r7, #12]
 8007cbe:	0a9a      	lsrs	r2, r3, #10
 8007cc0:	693b      	ldr	r3, [r7, #16]
 8007cc2:	0a98      	lsrs	r0, r3, #10
 8007cc4:	697b      	ldr	r3, [r7, #20]
 8007cc6:	0a9b      	lsrs	r3, r3, #10
 8007cc8:	9300      	str	r3, [sp, #0]
 8007cca:	4603      	mov	r3, r0
 8007ccc:	481f      	ldr	r0, [pc, #124]	; (8007d4c <OsShellCmdSectionInfo+0xdc>)
 8007cce:	f7fc fdf7 	bl	80048c0 <dprintf>
 8007cd2:	e022      	b.n	8007d1a <OsShellCmdSectionInfo+0xaa>
               rodataLen / MEM_SIZE_1K, bssLen / MEM_SIZE_1K);
    } else if ((argc == 1) && (strcmp(argv[0], "-m") == 0)) {
 8007cd4:	687b      	ldr	r3, [r7, #4]
 8007cd6:	2b01      	cmp	r3, #1
 8007cd8:	d116      	bne.n	8007d08 <OsShellCmdSectionInfo+0x98>
 8007cda:	683b      	ldr	r3, [r7, #0]
 8007cdc:	681b      	ldr	r3, [r3, #0]
 8007cde:	491c      	ldr	r1, [pc, #112]	; (8007d50 <OsShellCmdSectionInfo+0xe0>)
 8007ce0:	4618      	mov	r0, r3
 8007ce2:	f007 fc12 	bl	800f50a <strcmp>
 8007ce6:	4603      	mov	r3, r0
 8007ce8:	2b00      	cmp	r3, #0
 8007cea:	d10d      	bne.n	8007d08 <OsShellCmdSectionInfo+0x98>
        PRINTK("Mem:    %-9lu    %-10lu    %-10lu    %-10lu\n", textLen / MEM_SIZE_1M, dataLen / MEM_SIZE_1M,
 8007cec:	68bb      	ldr	r3, [r7, #8]
 8007cee:	0d19      	lsrs	r1, r3, #20
 8007cf0:	68fb      	ldr	r3, [r7, #12]
 8007cf2:	0d1a      	lsrs	r2, r3, #20
 8007cf4:	693b      	ldr	r3, [r7, #16]
 8007cf6:	0d18      	lsrs	r0, r3, #20
 8007cf8:	697b      	ldr	r3, [r7, #20]
 8007cfa:	0d1b      	lsrs	r3, r3, #20
 8007cfc:	9300      	str	r3, [sp, #0]
 8007cfe:	4603      	mov	r3, r0
 8007d00:	4812      	ldr	r0, [pc, #72]	; (8007d4c <OsShellCmdSectionInfo+0xdc>)
 8007d02:	f7fc fddd 	bl	80048c0 <dprintf>
 8007d06:	e008      	b.n	8007d1a <OsShellCmdSectionInfo+0xaa>
               rodataLen / MEM_SIZE_1M, bssLen / MEM_SIZE_1M);
    } else {
        PRINTK("Mem:    %-9lu    %-10lu    %-10lu    %-10lu\n", textLen, dataLen, rodataLen, bssLen);
 8007d08:	697b      	ldr	r3, [r7, #20]
 8007d0a:	9300      	str	r3, [sp, #0]
 8007d0c:	693b      	ldr	r3, [r7, #16]
 8007d0e:	68fa      	ldr	r2, [r7, #12]
 8007d10:	68b9      	ldr	r1, [r7, #8]
 8007d12:	480e      	ldr	r0, [pc, #56]	; (8007d4c <OsShellCmdSectionInfo+0xdc>)
 8007d14:	f7fc fdd4 	bl	80048c0 <dprintf>
    }
}
 8007d18:	bf00      	nop
 8007d1a:	bf00      	nop
 8007d1c:	3718      	adds	r7, #24
 8007d1e:	46bd      	mov	sp, r7
 8007d20:	bd80      	pop	{r7, pc}
 8007d22:	bf00      	nop
 8007d24:	0801fd7c 	.word	0x0801fd7c
 8007d28:	080001c8 	.word	0x080001c8
 8007d2c:	20000724 	.word	0x20000724
 8007d30:	20000400 	.word	0x20000400
 8007d34:	0802437c 	.word	0x0802437c
 8007d38:	0801fd7c 	.word	0x0801fd7c
 8007d3c:	200037e0 	.word	0x200037e0
 8007d40:	20000728 	.word	0x20000728
 8007d44:	08020bc4 	.word	0x08020bc4
 8007d48:	08020bfc 	.word	0x08020bfc
 8007d4c:	08020c00 	.word	0x08020c00
 8007d50:	08020c30 	.word	0x08020c30

08007d54 <OsShellCmdFreeInfo>:

LITE_OS_SEC_TEXT_MINOR STATIC UINT32 OsShellCmdFreeInfo(INT32 argc, const CHAR *argv[])
{
 8007d54:	b580      	push	{r7, lr}
 8007d56:	b086      	sub	sp, #24
 8007d58:	af00      	add	r7, sp, #0
 8007d5a:	6078      	str	r0, [r7, #4]
 8007d5c:	6039      	str	r1, [r7, #0]
    UINT32 memUsed0 = LOS_MemTotalUsedGet(m_aucSysMem0);
    UINT32 totalMem0 = LOS_MemPoolSizeGet(m_aucSysMem0);
    UINT32 freeMem0 = totalMem0 - memUsed0;
#endif

    UINT32 memUsed = LOS_MemTotalUsedGet(m_aucSysMem1);
 8007d5e:	4b37      	ldr	r3, [pc, #220]	; (8007e3c <OsShellCmdFreeInfo+0xe8>)
 8007d60:	681b      	ldr	r3, [r3, #0]
 8007d62:	4618      	mov	r0, r3
 8007d64:	f001 fcc4 	bl	80096f0 <LOS_MemTotalUsedGet>
 8007d68:	60f8      	str	r0, [r7, #12]
    UINT32 totalMem = LOS_MemPoolSizeGet(m_aucSysMem1);
 8007d6a:	4b34      	ldr	r3, [pc, #208]	; (8007e3c <OsShellCmdFreeInfo+0xe8>)
 8007d6c:	681b      	ldr	r3, [r3, #0]
 8007d6e:	4618      	mov	r0, r3
 8007d70:	f001 fcf6 	bl	8009760 <LOS_MemPoolSizeGet>
 8007d74:	6138      	str	r0, [r7, #16]
    UINT32 freeMem = totalMem - memUsed;
 8007d76:	693a      	ldr	r2, [r7, #16]
 8007d78:	68fb      	ldr	r3, [r7, #12]
 8007d7a:	1ad3      	subs	r3, r2, r3
 8007d7c:	617b      	str	r3, [r7, #20]

    if ((argc == 0) ||
 8007d7e:	687b      	ldr	r3, [r7, #4]
 8007d80:	2b00      	cmp	r3, #0
 8007d82:	d017      	beq.n	8007db4 <OsShellCmdFreeInfo+0x60>
 8007d84:	687b      	ldr	r3, [r7, #4]
 8007d86:	2b01      	cmp	r3, #1
 8007d88:	d108      	bne.n	8007d9c <OsShellCmdFreeInfo+0x48>
        ((argc == 1) && (strcmp(argv[0], "-k") == 0)) ||
 8007d8a:	683b      	ldr	r3, [r7, #0]
 8007d8c:	681b      	ldr	r3, [r3, #0]
 8007d8e:	492c      	ldr	r1, [pc, #176]	; (8007e40 <OsShellCmdFreeInfo+0xec>)
 8007d90:	4618      	mov	r0, r3
 8007d92:	f007 fbba 	bl	800f50a <strcmp>
 8007d96:	4603      	mov	r3, r0
 8007d98:	2b00      	cmp	r3, #0
 8007d9a:	d00b      	beq.n	8007db4 <OsShellCmdFreeInfo+0x60>
 8007d9c:	687b      	ldr	r3, [r7, #4]
 8007d9e:	2b01      	cmp	r3, #1
 8007da0:	d10b      	bne.n	8007dba <OsShellCmdFreeInfo+0x66>
        ((argc == 1) && (strcmp(argv[0], "-m") == 0))) {
 8007da2:	683b      	ldr	r3, [r7, #0]
 8007da4:	681b      	ldr	r3, [r3, #0]
 8007da6:	4927      	ldr	r1, [pc, #156]	; (8007e44 <OsShellCmdFreeInfo+0xf0>)
 8007da8:	4618      	mov	r0, r3
 8007daa:	f007 fbae 	bl	800f50a <strcmp>
 8007dae:	4603      	mov	r3, r0
 8007db0:	2b00      	cmp	r3, #0
 8007db2:	d102      	bne.n	8007dba <OsShellCmdFreeInfo+0x66>
#ifdef LOSCFG_EXC_INTERACTION
        PRINTK("\r\n***** Mem:system mem      Mem1:exception interaction mem *****\n");
#endif
        PRINTK("\r\n        total        used          free\n");
 8007db4:	4824      	ldr	r0, [pc, #144]	; (8007e48 <OsShellCmdFreeInfo+0xf4>)
 8007db6:	f7fc fd83 	bl	80048c0 <dprintf>
    }

    if ((argc == 1) && (strcmp(argv[0], "-k") == 0)) {
 8007dba:	687b      	ldr	r3, [r7, #4]
 8007dbc:	2b01      	cmp	r3, #1
 8007dbe:	d112      	bne.n	8007de6 <OsShellCmdFreeInfo+0x92>
 8007dc0:	683b      	ldr	r3, [r7, #0]
 8007dc2:	681b      	ldr	r3, [r3, #0]
 8007dc4:	491e      	ldr	r1, [pc, #120]	; (8007e40 <OsShellCmdFreeInfo+0xec>)
 8007dc6:	4618      	mov	r0, r3
 8007dc8:	f007 fb9f 	bl	800f50a <strcmp>
 8007dcc:	4603      	mov	r3, r0
 8007dce:	2b00      	cmp	r3, #0
 8007dd0:	d109      	bne.n	8007de6 <OsShellCmdFreeInfo+0x92>
        PRINTK("Mem:    %-9u    %-10u    %-10u\n", totalMem / MEM_SIZE_1K, memUsed / MEM_SIZE_1K,
 8007dd2:	693b      	ldr	r3, [r7, #16]
 8007dd4:	0a99      	lsrs	r1, r3, #10
 8007dd6:	68fb      	ldr	r3, [r7, #12]
 8007dd8:	0a9a      	lsrs	r2, r3, #10
 8007dda:	697b      	ldr	r3, [r7, #20]
 8007ddc:	0a9b      	lsrs	r3, r3, #10
 8007dde:	481b      	ldr	r0, [pc, #108]	; (8007e4c <OsShellCmdFreeInfo+0xf8>)
 8007de0:	f7fc fd6e 	bl	80048c0 <dprintf>
 8007de4:	e025      	b.n	8007e32 <OsShellCmdFreeInfo+0xde>
               freeMem / MEM_SIZE_1K);
#ifdef LOSCFG_EXC_INTERACTION
        PRINTK("Mem1:   %-9u    %-10u    %-10u\n", totalMem0 / MEM_SIZE_1K, memUsed0 / MEM_SIZE_1K,
               freeMem0 / MEM_SIZE_1K);
#endif
    } else if ((argc == 1) && (strcmp(argv[0], "-m") == 0)) {
 8007de6:	687b      	ldr	r3, [r7, #4]
 8007de8:	2b01      	cmp	r3, #1
 8007dea:	d112      	bne.n	8007e12 <OsShellCmdFreeInfo+0xbe>
 8007dec:	683b      	ldr	r3, [r7, #0]
 8007dee:	681b      	ldr	r3, [r3, #0]
 8007df0:	4914      	ldr	r1, [pc, #80]	; (8007e44 <OsShellCmdFreeInfo+0xf0>)
 8007df2:	4618      	mov	r0, r3
 8007df4:	f007 fb89 	bl	800f50a <strcmp>
 8007df8:	4603      	mov	r3, r0
 8007dfa:	2b00      	cmp	r3, #0
 8007dfc:	d109      	bne.n	8007e12 <OsShellCmdFreeInfo+0xbe>
        PRINTK("Mem:    %-9u    %-10u    %-10u\n", totalMem / MEM_SIZE_1M, memUsed / MEM_SIZE_1M,
 8007dfe:	693b      	ldr	r3, [r7, #16]
 8007e00:	0d19      	lsrs	r1, r3, #20
 8007e02:	68fb      	ldr	r3, [r7, #12]
 8007e04:	0d1a      	lsrs	r2, r3, #20
 8007e06:	697b      	ldr	r3, [r7, #20]
 8007e08:	0d1b      	lsrs	r3, r3, #20
 8007e0a:	4810      	ldr	r0, [pc, #64]	; (8007e4c <OsShellCmdFreeInfo+0xf8>)
 8007e0c:	f7fc fd58 	bl	80048c0 <dprintf>
 8007e10:	e00f      	b.n	8007e32 <OsShellCmdFreeInfo+0xde>
               freeMem / MEM_SIZE_1M);
#ifdef LOSCFG_EXC_INTERACTION
        PRINTK("Mem1:   %-9u    %-10u    %-10u\n", totalMem0 / MEM_SIZE_1M, memUsed0 / MEM_SIZE_1M,
               freeMem0 / MEM_SIZE_1M);
#endif
    } else if (argc == 0) {
 8007e12:	687b      	ldr	r3, [r7, #4]
 8007e14:	2b00      	cmp	r3, #0
 8007e16:	d106      	bne.n	8007e26 <OsShellCmdFreeInfo+0xd2>
        PRINTK("Mem:    %-9u    %-10u    %-10u\n", totalMem, memUsed, freeMem);
 8007e18:	697b      	ldr	r3, [r7, #20]
 8007e1a:	68fa      	ldr	r2, [r7, #12]
 8007e1c:	6939      	ldr	r1, [r7, #16]
 8007e1e:	480b      	ldr	r0, [pc, #44]	; (8007e4c <OsShellCmdFreeInfo+0xf8>)
 8007e20:	f7fc fd4e 	bl	80048c0 <dprintf>
 8007e24:	e005      	b.n	8007e32 <OsShellCmdFreeInfo+0xde>
#ifdef LOSCFG_EXC_INTERACTION
        PRINTK("Mem1:   %-9u    %-10u    %-10u\n", totalMem0, memUsed0, freeMem0);
#endif
    } else {
        PRINTK("\nUsage: free or free [-k/-m]\n");
 8007e26:	480a      	ldr	r0, [pc, #40]	; (8007e50 <OsShellCmdFreeInfo+0xfc>)
 8007e28:	f7fc fd4a 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8007e2c:	f04f 33ff 	mov.w	r3, #4294967295
 8007e30:	e000      	b.n	8007e34 <OsShellCmdFreeInfo+0xe0>
    }
    return 0;
 8007e32:	2300      	movs	r3, #0
}
 8007e34:	4618      	mov	r0, r3
 8007e36:	3718      	adds	r7, #24
 8007e38:	46bd      	mov	sp, r7
 8007e3a:	bd80      	pop	{r7, pc}
 8007e3c:	200021c0 	.word	0x200021c0
 8007e40:	08020bfc 	.word	0x08020bfc
 8007e44:	08020c30 	.word	0x08020c30
 8007e48:	08020c34 	.word	0x08020c34
 8007e4c:	08020c60 	.word	0x08020c60
 8007e50:	08020c80 	.word	0x08020c80

08007e54 <OsShellCmdFree>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdFree(INT32 argc, const CHAR *argv[])
{
 8007e54:	b580      	push	{r7, lr}
 8007e56:	b082      	sub	sp, #8
 8007e58:	af00      	add	r7, sp, #0
 8007e5a:	6078      	str	r0, [r7, #4]
 8007e5c:	6039      	str	r1, [r7, #0]
    if (argc > 1) {
 8007e5e:	687b      	ldr	r3, [r7, #4]
 8007e60:	2b01      	cmp	r3, #1
 8007e62:	dd05      	ble.n	8007e70 <OsShellCmdFree+0x1c>
        PRINTK("\nUsage: free or free [-k/-m]\n");
 8007e64:	480c      	ldr	r0, [pc, #48]	; (8007e98 <OsShellCmdFree+0x44>)
 8007e66:	f7fc fd2b 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8007e6a:	f04f 33ff 	mov.w	r3, #4294967295
 8007e6e:	e00e      	b.n	8007e8e <OsShellCmdFree+0x3a>
    }
    if (OsShellCmdFreeInfo(argc, argv) != 0) {
 8007e70:	6839      	ldr	r1, [r7, #0]
 8007e72:	6878      	ldr	r0, [r7, #4]
 8007e74:	f7ff ff6e 	bl	8007d54 <OsShellCmdFreeInfo>
 8007e78:	4603      	mov	r3, r0
 8007e7a:	2b00      	cmp	r3, #0
 8007e7c:	d002      	beq.n	8007e84 <OsShellCmdFree+0x30>
        return OS_ERROR;
 8007e7e:	f04f 33ff 	mov.w	r3, #4294967295
 8007e82:	e004      	b.n	8007e8e <OsShellCmdFree+0x3a>
    }
    OsShellCmdSectionInfo(argc, argv);
 8007e84:	6839      	ldr	r1, [r7, #0]
 8007e86:	6878      	ldr	r0, [r7, #4]
 8007e88:	f7ff fef2 	bl	8007c70 <OsShellCmdSectionInfo>
    return 0;
 8007e8c:	2300      	movs	r3, #0
}
 8007e8e:	4618      	mov	r0, r3
 8007e90:	3708      	adds	r7, #8
 8007e92:	46bd      	mov	sp, r7
 8007e94:	bd80      	pop	{r7, pc}
 8007e96:	bf00      	nop
 8007e98:	08020c80 	.word	0x08020c80

08007e9c <OsShellCmdUname>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdUname(INT32 argc, const CHAR *argv[])
{
 8007e9c:	b580      	push	{r7, lr}
 8007e9e:	b084      	sub	sp, #16
 8007ea0:	af02      	add	r7, sp, #8
 8007ea2:	6078      	str	r0, [r7, #4]
 8007ea4:	6039      	str	r1, [r7, #0]
    if (argc == 0) {
 8007ea6:	687b      	ldr	r3, [r7, #4]
 8007ea8:	2b00      	cmp	r3, #0
 8007eaa:	d104      	bne.n	8007eb6 <OsShellCmdUname+0x1a>
        PRINTK("Huawei LiteOS\n");
 8007eac:	4833      	ldr	r0, [pc, #204]	; (8007f7c <OsShellCmdUname+0xe0>)
 8007eae:	f7fc fd07 	bl	80048c0 <dprintf>
        return 0;
 8007eb2:	2300      	movs	r3, #0
 8007eb4:	e05e      	b.n	8007f74 <OsShellCmdUname+0xd8>
    }

    if (argc == 1) {
 8007eb6:	687b      	ldr	r3, [r7, #4]
 8007eb8:	2b01      	cmp	r3, #1
 8007eba:	d153      	bne.n	8007f64 <OsShellCmdUname+0xc8>
        if (strcmp(argv[0], "-a") == 0) {
 8007ebc:	683b      	ldr	r3, [r7, #0]
 8007ebe:	681b      	ldr	r3, [r3, #0]
 8007ec0:	492f      	ldr	r1, [pc, #188]	; (8007f80 <OsShellCmdUname+0xe4>)
 8007ec2:	4618      	mov	r0, r3
 8007ec4:	f007 fb21 	bl	800f50a <strcmp>
 8007ec8:	4603      	mov	r3, r0
 8007eca:	2b00      	cmp	r3, #0
 8007ecc:	d10b      	bne.n	8007ee6 <OsShellCmdUname+0x4a>
            PRINTK("%s %s %s %s %s\n", HW_LITEOS_VER, HW_LITEOS_SYSNAME, HW_LITEOS_KERNEL_VERSION_STRING,
 8007ece:	4b2d      	ldr	r3, [pc, #180]	; (8007f84 <OsShellCmdUname+0xe8>)
 8007ed0:	9301      	str	r3, [sp, #4]
 8007ed2:	4b2d      	ldr	r3, [pc, #180]	; (8007f88 <OsShellCmdUname+0xec>)
 8007ed4:	9300      	str	r3, [sp, #0]
 8007ed6:	4b2d      	ldr	r3, [pc, #180]	; (8007f8c <OsShellCmdUname+0xf0>)
 8007ed8:	4a2d      	ldr	r2, [pc, #180]	; (8007f90 <OsShellCmdUname+0xf4>)
 8007eda:	492e      	ldr	r1, [pc, #184]	; (8007f94 <OsShellCmdUname+0xf8>)
 8007edc:	482e      	ldr	r0, [pc, #184]	; (8007f98 <OsShellCmdUname+0xfc>)
 8007ede:	f7fc fcef 	bl	80048c0 <dprintf>
                   __DATE__, __TIME__);
            return 0;
 8007ee2:	2300      	movs	r3, #0
 8007ee4:	e046      	b.n	8007f74 <OsShellCmdUname+0xd8>
        } else if (strcmp(argv[0], "-s") == 0) {
 8007ee6:	683b      	ldr	r3, [r7, #0]
 8007ee8:	681b      	ldr	r3, [r3, #0]
 8007eea:	492c      	ldr	r1, [pc, #176]	; (8007f9c <OsShellCmdUname+0x100>)
 8007eec:	4618      	mov	r0, r3
 8007eee:	f007 fb0c 	bl	800f50a <strcmp>
 8007ef2:	4603      	mov	r3, r0
 8007ef4:	2b00      	cmp	r3, #0
 8007ef6:	d104      	bne.n	8007f02 <OsShellCmdUname+0x66>
            PRINTK("Huawei LiteOS\n");
 8007ef8:	4820      	ldr	r0, [pc, #128]	; (8007f7c <OsShellCmdUname+0xe0>)
 8007efa:	f7fc fce1 	bl	80048c0 <dprintf>
            return 0;
 8007efe:	2300      	movs	r3, #0
 8007f00:	e038      	b.n	8007f74 <OsShellCmdUname+0xd8>
        } else if (strcmp(argv[0], "-t") == 0) {
 8007f02:	683b      	ldr	r3, [r7, #0]
 8007f04:	681b      	ldr	r3, [r3, #0]
 8007f06:	4926      	ldr	r1, [pc, #152]	; (8007fa0 <OsShellCmdUname+0x104>)
 8007f08:	4618      	mov	r0, r3
 8007f0a:	f007 fafe 	bl	800f50a <strcmp>
 8007f0e:	4603      	mov	r3, r0
 8007f10:	2b00      	cmp	r3, #0
 8007f12:	d106      	bne.n	8007f22 <OsShellCmdUname+0x86>
            PRINTK("build date : %s %s", __DATE__, __TIME__);
 8007f14:	4a1b      	ldr	r2, [pc, #108]	; (8007f84 <OsShellCmdUname+0xe8>)
 8007f16:	491c      	ldr	r1, [pc, #112]	; (8007f88 <OsShellCmdUname+0xec>)
 8007f18:	4822      	ldr	r0, [pc, #136]	; (8007fa4 <OsShellCmdUname+0x108>)
 8007f1a:	f7fc fcd1 	bl	80048c0 <dprintf>
            return 0;
 8007f1e:	2300      	movs	r3, #0
 8007f20:	e028      	b.n	8007f74 <OsShellCmdUname+0xd8>
        } else if (strcmp(argv[0], "-v") == 0) {
 8007f22:	683b      	ldr	r3, [r7, #0]
 8007f24:	681b      	ldr	r3, [r3, #0]
 8007f26:	4920      	ldr	r1, [pc, #128]	; (8007fa8 <OsShellCmdUname+0x10c>)
 8007f28:	4618      	mov	r0, r3
 8007f2a:	f007 faee 	bl	800f50a <strcmp>
 8007f2e:	4603      	mov	r3, r0
 8007f30:	2b00      	cmp	r3, #0
 8007f32:	d109      	bne.n	8007f48 <OsShellCmdUname+0xac>
            PRINTK("%s %s %s %s\n", HW_LITEOS_SYSNAME, HW_LITEOS_KERNEL_VERSION_STRING,
 8007f34:	4b13      	ldr	r3, [pc, #76]	; (8007f84 <OsShellCmdUname+0xe8>)
 8007f36:	9300      	str	r3, [sp, #0]
 8007f38:	4b13      	ldr	r3, [pc, #76]	; (8007f88 <OsShellCmdUname+0xec>)
 8007f3a:	4a14      	ldr	r2, [pc, #80]	; (8007f8c <OsShellCmdUname+0xf0>)
 8007f3c:	4914      	ldr	r1, [pc, #80]	; (8007f90 <OsShellCmdUname+0xf4>)
 8007f3e:	481b      	ldr	r0, [pc, #108]	; (8007fac <OsShellCmdUname+0x110>)
 8007f40:	f7fc fcbe 	bl	80048c0 <dprintf>
                   __DATE__, __TIME__);
            return 0;
 8007f44:	2300      	movs	r3, #0
 8007f46:	e015      	b.n	8007f74 <OsShellCmdUname+0xd8>
        } else if (strcmp(argv[0], "--help") == 0) {
 8007f48:	683b      	ldr	r3, [r7, #0]
 8007f4a:	681b      	ldr	r3, [r3, #0]
 8007f4c:	4918      	ldr	r1, [pc, #96]	; (8007fb0 <OsShellCmdUname+0x114>)
 8007f4e:	4618      	mov	r0, r3
 8007f50:	f007 fadb 	bl	800f50a <strcmp>
 8007f54:	4603      	mov	r3, r0
 8007f56:	2b00      	cmp	r3, #0
 8007f58:	d104      	bne.n	8007f64 <OsShellCmdUname+0xc8>
            PRINTK("-a,            print all information\n"
 8007f5a:	4816      	ldr	r0, [pc, #88]	; (8007fb4 <OsShellCmdUname+0x118>)
 8007f5c:	f7fc fcb0 	bl	80048c0 <dprintf>
                   "-s,            print the kernel name\n"
                   "-t,            print the build date\n"
                   "-v,            print the kernel version\n");
            return 0;
 8007f60:	2300      	movs	r3, #0
 8007f62:	e007      	b.n	8007f74 <OsShellCmdUname+0xd8>
        }
    }

    PRINTK("uname: invalid option %s\n"
 8007f64:	683b      	ldr	r3, [r7, #0]
 8007f66:	681b      	ldr	r3, [r3, #0]
 8007f68:	4619      	mov	r1, r3
 8007f6a:	4813      	ldr	r0, [pc, #76]	; (8007fb8 <OsShellCmdUname+0x11c>)
 8007f6c:	f7fc fca8 	bl	80048c0 <dprintf>
           "Try 'uname --help' for more information.\n",
           argv[0]);
    return OS_ERROR;
 8007f70:	f04f 33ff 	mov.w	r3, #4294967295
}
 8007f74:	4618      	mov	r0, r3
 8007f76:	3708      	adds	r7, #8
 8007f78:	46bd      	mov	sp, r7
 8007f7a:	bd80      	pop	{r7, pc}
 8007f7c:	08020ca0 	.word	0x08020ca0
 8007f80:	08020cb0 	.word	0x08020cb0
 8007f84:	08020d00 	.word	0x08020d00
 8007f88:	08020d0c 	.word	0x08020d0c
 8007f8c:	08020cb4 	.word	0x08020cb4
 8007f90:	08020cbc 	.word	0x08020cbc
 8007f94:	08020ccc 	.word	0x08020ccc
 8007f98:	08020cf0 	.word	0x08020cf0
 8007f9c:	08020d18 	.word	0x08020d18
 8007fa0:	08020d1c 	.word	0x08020d1c
 8007fa4:	08020d20 	.word	0x08020d20
 8007fa8:	08020d34 	.word	0x08020d34
 8007fac:	08020d38 	.word	0x08020d38
 8007fb0:	08020d48 	.word	0x08020d48
 8007fb4:	08020d50 	.word	0x08020d50
 8007fb8:	08020de8 	.word	0x08020de8

08007fbc <OsPrintSwtmrMsg>:
    "Created",
    "Ticking",
};

STATIC VOID OsPrintSwtmrMsg(const LosSwtmrCB *swtmr)
{
 8007fbc:	b5b0      	push	{r4, r5, r7, lr}
 8007fbe:	b086      	sub	sp, #24
 8007fc0:	af04      	add	r7, sp, #16
 8007fc2:	6078      	str	r0, [r7, #4]
    PRINTK("0x%08x  "
 8007fc4:	687b      	ldr	r3, [r7, #4]
 8007fc6:	8a1b      	ldrh	r3, [r3, #16]
 8007fc8:	f003 000f 	and.w	r0, r3, #15
 8007fcc:	687b      	ldr	r3, [r7, #4]
 8007fce:	7b1b      	ldrb	r3, [r3, #12]
 8007fd0:	461a      	mov	r2, r3
 8007fd2:	4613      	mov	r3, r2
 8007fd4:	005b      	lsls	r3, r3, #1
 8007fd6:	4413      	add	r3, r2
 8007fd8:	009b      	lsls	r3, r3, #2
 8007fda:	4a0f      	ldr	r2, [pc, #60]	; (8008018 <OsPrintSwtmrMsg+0x5c>)
 8007fdc:	189c      	adds	r4, r3, r2
 8007fde:	687b      	ldr	r3, [r7, #4]
 8007fe0:	7b5b      	ldrb	r3, [r3, #13]
 8007fe2:	461a      	mov	r2, r3
 8007fe4:	4613      	mov	r3, r2
 8007fe6:	005b      	lsls	r3, r3, #1
 8007fe8:	4413      	add	r3, r2
 8007fea:	009b      	lsls	r3, r3, #2
 8007fec:	4a0b      	ldr	r2, [pc, #44]	; (800801c <OsPrintSwtmrMsg+0x60>)
 8007fee:	189d      	adds	r5, r3, r2
 8007ff0:	687b      	ldr	r3, [r7, #4]
 8007ff2:	695b      	ldr	r3, [r3, #20]
 8007ff4:	687a      	ldr	r2, [r7, #4]
 8007ff6:	69d2      	ldr	r2, [r2, #28]
 8007ff8:	6879      	ldr	r1, [r7, #4]
 8007ffa:	6a09      	ldr	r1, [r1, #32]
 8007ffc:	9102      	str	r1, [sp, #8]
 8007ffe:	9201      	str	r2, [sp, #4]
 8008000:	9300      	str	r3, [sp, #0]
 8008002:	462b      	mov	r3, r5
 8008004:	4622      	mov	r2, r4
 8008006:	4601      	mov	r1, r0
 8008008:	4805      	ldr	r0, [pc, #20]	; (8008020 <OsPrintSwtmrMsg+0x64>)
 800800a:	f7fc fc59 	bl	80048c0 <dprintf>
           g_shellSwtmrStatus[swtmr->state],
           g_shellSwtmrMode[swtmr->mode],
           swtmr->interval,
           swtmr->arg,
           swtmr->handler);
}
 800800e:	bf00      	nop
 8008010:	3708      	adds	r7, #8
 8008012:	46bd      	mov	sp, r7
 8008014:	bdb0      	pop	{r4, r5, r7, pc}
 8008016:	bf00      	nop
 8008018:	20000454 	.word	0x20000454
 800801c:	20000424 	.word	0x20000424
 8008020:	08020e48 	.word	0x08020e48

08008024 <OsPrintSwtmrMsgHead>:

STATIC INLINE VOID OsPrintSwtmrMsgHead(VOID)
{
 8008024:	b580      	push	{r7, lr}
 8008026:	af00      	add	r7, sp, #0
    PRINTK("\r\nSwTmrID     State    Mode    Interval  Arg         handlerAddr\n");
 8008028:	4803      	ldr	r0, [pc, #12]	; (8008038 <OsPrintSwtmrMsgHead+0x14>)
 800802a:	f7fc fc49 	bl	80048c0 <dprintf>
    PRINTK("----------  -------  ------- --------- ----------  --------\n");
 800802e:	4803      	ldr	r0, [pc, #12]	; (800803c <OsPrintSwtmrMsgHead+0x18>)
 8008030:	f7fc fc46 	bl	80048c0 <dprintf>
}
 8008034:	bf00      	nop
 8008036:	bd80      	pop	{r7, pc}
 8008038:	08020e70 	.word	0x08020e70
 800803c:	08020eb4 	.word	0x08020eb4

08008040 <OsShellCmdSwtmrInfoGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdSwtmrInfoGet(INT32 argc, const UINT8 **argv)
{
 8008040:	b580      	push	{r7, lr}
 8008042:	b088      	sub	sp, #32
 8008044:	af00      	add	r7, sp, #0
 8008046:	6078      	str	r0, [r7, #4]
 8008048:	6039      	str	r1, [r7, #0]
 800804a:	4b4e      	ldr	r3, [pc, #312]	; (8008184 <OsShellCmdSwtmrInfoGet+0x144>)
 800804c:	681b      	ldr	r3, [r3, #0]
 800804e:	61fb      	str	r3, [r7, #28]
 8008050:	f04f 0300 	mov.w	r3, #0
#define OS_ALL_SWTMR_MASK 0xffffffff
    LosSwtmrCB *swtmr = g_swtmrCBArray;
 8008054:	4b4c      	ldr	r3, [pc, #304]	; (8008188 <OsShellCmdSwtmrInfoGet+0x148>)
 8008056:	681b      	ldr	r3, [r3, #0]
 8008058:	613b      	str	r3, [r7, #16]
    LosSwtmrCB *swtmr1 = g_swtmrCBArray;
 800805a:	4b4b      	ldr	r3, [pc, #300]	; (8008188 <OsShellCmdSwtmrInfoGet+0x148>)
 800805c:	681b      	ldr	r3, [r3, #0]
 800805e:	617b      	str	r3, [r7, #20]
    UINT16 index;
    size_t timerId;
    UINT16 num = 0;
 8008060:	2300      	movs	r3, #0
 8008062:	817b      	strh	r3, [r7, #10]
    CHAR *endPtr = NULL;
 8008064:	2300      	movs	r3, #0
 8008066:	60fb      	str	r3, [r7, #12]

    if (argc > 1) {
 8008068:	687b      	ldr	r3, [r7, #4]
 800806a:	2b01      	cmp	r3, #1
 800806c:	dd05      	ble.n	800807a <OsShellCmdSwtmrInfoGet+0x3a>
        PRINTK("\nUsage: swtmr [ID]\n");
 800806e:	4847      	ldr	r0, [pc, #284]	; (800818c <OsShellCmdSwtmrInfoGet+0x14c>)
 8008070:	f7fc fc26 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8008074:	f04f 33ff 	mov.w	r3, #4294967295
 8008078:	e078      	b.n	800816c <OsShellCmdSwtmrInfoGet+0x12c>
    }

    if (argc == 0) {
 800807a:	687b      	ldr	r3, [r7, #4]
 800807c:	2b00      	cmp	r3, #0
 800807e:	d103      	bne.n	8008088 <OsShellCmdSwtmrInfoGet+0x48>
        timerId = OS_ALL_SWTMR_MASK;
 8008080:	f04f 33ff 	mov.w	r3, #4294967295
 8008084:	61bb      	str	r3, [r7, #24]
 8008086:	e01b      	b.n	80080c0 <OsShellCmdSwtmrInfoGet+0x80>
    } else {
        timerId = strtoul((CHAR *)argv[0], &endPtr, 0);
 8008088:	683b      	ldr	r3, [r7, #0]
 800808a:	681b      	ldr	r3, [r3, #0]
 800808c:	f107 010c 	add.w	r1, r7, #12
 8008090:	2200      	movs	r2, #0
 8008092:	4618      	mov	r0, r3
 8008094:	f007 fade 	bl	800f654 <strtoul>
 8008098:	61b8      	str	r0, [r7, #24]
        if ((endPtr == NULL) || (*endPtr != 0) || (timerId > LOSCFG_BASE_CORE_SWTMR_LIMIT)) {
 800809a:	68fb      	ldr	r3, [r7, #12]
 800809c:	2b00      	cmp	r3, #0
 800809e:	d006      	beq.n	80080ae <OsShellCmdSwtmrInfoGet+0x6e>
 80080a0:	68fb      	ldr	r3, [r7, #12]
 80080a2:	781b      	ldrb	r3, [r3, #0]
 80080a4:	2b00      	cmp	r3, #0
 80080a6:	d102      	bne.n	80080ae <OsShellCmdSwtmrInfoGet+0x6e>
 80080a8:	69bb      	ldr	r3, [r7, #24]
 80080aa:	2b10      	cmp	r3, #16
 80080ac:	d908      	bls.n	80080c0 <OsShellCmdSwtmrInfoGet+0x80>
            PRINTK("\nswtmr ID can't access %s.\n", argv[0]);
 80080ae:	683b      	ldr	r3, [r7, #0]
 80080b0:	681b      	ldr	r3, [r3, #0]
 80080b2:	4619      	mov	r1, r3
 80080b4:	4836      	ldr	r0, [pc, #216]	; (8008190 <OsShellCmdSwtmrInfoGet+0x150>)
 80080b6:	f7fc fc03 	bl	80048c0 <dprintf>
            return OS_ERROR;
 80080ba:	f04f 33ff 	mov.w	r3, #4294967295
 80080be:	e055      	b.n	800816c <OsShellCmdSwtmrInfoGet+0x12c>
        }
    }

    for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr1++) {
 80080c0:	2300      	movs	r3, #0
 80080c2:	813b      	strh	r3, [r7, #8]
 80080c4:	e00c      	b.n	80080e0 <OsShellCmdSwtmrInfoGet+0xa0>
        if (swtmr1->state == 0) {
 80080c6:	697b      	ldr	r3, [r7, #20]
 80080c8:	7b1b      	ldrb	r3, [r3, #12]
 80080ca:	2b00      	cmp	r3, #0
 80080cc:	d102      	bne.n	80080d4 <OsShellCmdSwtmrInfoGet+0x94>
            num = num + 1;
 80080ce:	897b      	ldrh	r3, [r7, #10]
 80080d0:	3301      	adds	r3, #1
 80080d2:	817b      	strh	r3, [r7, #10]
    for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr1++) {
 80080d4:	893b      	ldrh	r3, [r7, #8]
 80080d6:	3301      	adds	r3, #1
 80080d8:	813b      	strh	r3, [r7, #8]
 80080da:	697b      	ldr	r3, [r7, #20]
 80080dc:	3324      	adds	r3, #36	; 0x24
 80080de:	617b      	str	r3, [r7, #20]
 80080e0:	893b      	ldrh	r3, [r7, #8]
 80080e2:	2b0f      	cmp	r3, #15
 80080e4:	d9ef      	bls.n	80080c6 <OsShellCmdSwtmrInfoGet+0x86>
        }
    }

    if (num == LOSCFG_BASE_CORE_SWTMR_LIMIT) {
 80080e6:	897b      	ldrh	r3, [r7, #10]
 80080e8:	2b10      	cmp	r3, #16
 80080ea:	d105      	bne.n	80080f8 <OsShellCmdSwtmrInfoGet+0xb8>
        PRINTK("\r\nThere is no swtmr was created!\n");
 80080ec:	4829      	ldr	r0, [pc, #164]	; (8008194 <OsShellCmdSwtmrInfoGet+0x154>)
 80080ee:	f7fc fbe7 	bl	80048c0 <dprintf>
        return OS_ERROR;
 80080f2:	f04f 33ff 	mov.w	r3, #4294967295
 80080f6:	e039      	b.n	800816c <OsShellCmdSwtmrInfoGet+0x12c>
    }

    OsPrintSwtmrMsgHead();
 80080f8:	f7ff ff94 	bl	8008024 <OsPrintSwtmrMsgHead>
    if (timerId == OS_ALL_SWTMR_MASK) {
 80080fc:	69bb      	ldr	r3, [r7, #24]
 80080fe:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008102:	d113      	bne.n	800812c <OsShellCmdSwtmrInfoGet+0xec>
        for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
 8008104:	2300      	movs	r3, #0
 8008106:	813b      	strh	r3, [r7, #8]
 8008108:	e00c      	b.n	8008124 <OsShellCmdSwtmrInfoGet+0xe4>
            if (swtmr->state != 0) {
 800810a:	693b      	ldr	r3, [r7, #16]
 800810c:	7b1b      	ldrb	r3, [r3, #12]
 800810e:	2b00      	cmp	r3, #0
 8008110:	d002      	beq.n	8008118 <OsShellCmdSwtmrInfoGet+0xd8>
                OsPrintSwtmrMsg(swtmr);
 8008112:	6938      	ldr	r0, [r7, #16]
 8008114:	f7ff ff52 	bl	8007fbc <OsPrintSwtmrMsg>
        for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
 8008118:	893b      	ldrh	r3, [r7, #8]
 800811a:	3301      	adds	r3, #1
 800811c:	813b      	strh	r3, [r7, #8]
 800811e:	693b      	ldr	r3, [r7, #16]
 8008120:	3324      	adds	r3, #36	; 0x24
 8008122:	613b      	str	r3, [r7, #16]
 8008124:	893b      	ldrh	r3, [r7, #8]
 8008126:	2b0f      	cmp	r3, #15
 8008128:	d9ef      	bls.n	800810a <OsShellCmdSwtmrInfoGet+0xca>
 800812a:	e01e      	b.n	800816a <OsShellCmdSwtmrInfoGet+0x12a>
            }
        }
    } else {
        for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
 800812c:	2300      	movs	r3, #0
 800812e:	813b      	strh	r3, [r7, #8]
 8008130:	e015      	b.n	800815e <OsShellCmdSwtmrInfoGet+0x11e>
            if ((timerId == (size_t)(swtmr->timerId % LOSCFG_BASE_CORE_SWTMR_LIMIT)) && (swtmr->state != 0)) {
 8008132:	693b      	ldr	r3, [r7, #16]
 8008134:	8a1b      	ldrh	r3, [r3, #16]
 8008136:	f003 030f 	and.w	r3, r3, #15
 800813a:	69ba      	ldr	r2, [r7, #24]
 800813c:	429a      	cmp	r2, r3
 800813e:	d108      	bne.n	8008152 <OsShellCmdSwtmrInfoGet+0x112>
 8008140:	693b      	ldr	r3, [r7, #16]
 8008142:	7b1b      	ldrb	r3, [r3, #12]
 8008144:	2b00      	cmp	r3, #0
 8008146:	d004      	beq.n	8008152 <OsShellCmdSwtmrInfoGet+0x112>
                OsPrintSwtmrMsg(swtmr);
 8008148:	6938      	ldr	r0, [r7, #16]
 800814a:	f7ff ff37 	bl	8007fbc <OsPrintSwtmrMsg>
                return LOS_OK;
 800814e:	2300      	movs	r3, #0
 8008150:	e00c      	b.n	800816c <OsShellCmdSwtmrInfoGet+0x12c>
        for (index = 0; index < LOSCFG_BASE_CORE_SWTMR_LIMIT; index++, swtmr++) {
 8008152:	893b      	ldrh	r3, [r7, #8]
 8008154:	3301      	adds	r3, #1
 8008156:	813b      	strh	r3, [r7, #8]
 8008158:	693b      	ldr	r3, [r7, #16]
 800815a:	3324      	adds	r3, #36	; 0x24
 800815c:	613b      	str	r3, [r7, #16]
 800815e:	893b      	ldrh	r3, [r7, #8]
 8008160:	2b0f      	cmp	r3, #15
 8008162:	d9e6      	bls.n	8008132 <OsShellCmdSwtmrInfoGet+0xf2>
            }
        }
        PRINTK("\r\nThe SwTimerID is not exist.\n");
 8008164:	480c      	ldr	r0, [pc, #48]	; (8008198 <OsShellCmdSwtmrInfoGet+0x158>)
 8008166:	f7fc fbab 	bl	80048c0 <dprintf>
    }
    return LOS_OK;
 800816a:	2300      	movs	r3, #0
}
 800816c:	4a05      	ldr	r2, [pc, #20]	; (8008184 <OsShellCmdSwtmrInfoGet+0x144>)
 800816e:	6811      	ldr	r1, [r2, #0]
 8008170:	69fa      	ldr	r2, [r7, #28]
 8008172:	4051      	eors	r1, r2
 8008174:	d001      	beq.n	800817a <OsShellCmdSwtmrInfoGet+0x13a>
 8008176:	f7fc fa31 	bl	80045dc <__stack_chk_fail>
 800817a:	4618      	mov	r0, r3
 800817c:	3720      	adds	r7, #32
 800817e:	46bd      	mov	sp, r7
 8008180:	bd80      	pop	{r7, pc}
 8008182:	bf00      	nop
 8008184:	08020f68 	.word	0x08020f68
 8008188:	2000079c 	.word	0x2000079c
 800818c:	08020ef4 	.word	0x08020ef4
 8008190:	08020f08 	.word	0x08020f08
 8008194:	08020f24 	.word	0x08020f24
 8008198:	08020f48 	.word	0x08020f48

0800819c <LOS_IntLock>:
{
 800819c:	b580      	push	{r7, lr}
 800819e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80081a0:	f7f8 fd92 	bl	8000cc8 <ArchIntLock>
 80081a4:	4603      	mov	r3, r0
}
 80081a6:	4618      	mov	r0, r3
 80081a8:	bd80      	pop	{r7, pc}

080081aa <LOS_IntRestore>:
{
 80081aa:	b580      	push	{r7, lr}
 80081ac:	b082      	sub	sp, #8
 80081ae:	af00      	add	r7, sp, #0
 80081b0:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80081b2:	6878      	ldr	r0, [r7, #4]
 80081b4:	f7f8 fd90 	bl	8000cd8 <ArchIntRestore>
}
 80081b8:	bf00      	nop
 80081ba:	3708      	adds	r7, #8
 80081bc:	46bd      	mov	sp, r7
 80081be:	bd80      	pop	{r7, pc}

080081c0 <OsShellCmdTaskCntGet>:
extern "C" {
#endif
#endif /* __cplusplus */

UINT32 OsShellCmdTaskCntGet(VOID)
{
 80081c0:	b580      	push	{r7, lr}
 80081c2:	b084      	sub	sp, #16
 80081c4:	af00      	add	r7, sp, #0
    UINT32 loop;
    UINT32 taskCnt = 0;
 80081c6:	2300      	movs	r3, #0
 80081c8:	607b      	str	r3, [r7, #4]
    UINT32 intSave;
    LosTaskCB *taskCB = NULL;
 80081ca:	2300      	movs	r3, #0
 80081cc:	60bb      	str	r3, [r7, #8]

    intSave = LOS_IntLock();
 80081ce:	f7ff ffe5 	bl	800819c <LOS_IntLock>
 80081d2:	60f8      	str	r0, [r7, #12]
    for (loop = 0; loop < g_taskMaxNum; loop++) {
 80081d4:	2300      	movs	r3, #0
 80081d6:	603b      	str	r3, [r7, #0]
 80081d8:	e016      	b.n	8008208 <OsShellCmdTaskCntGet+0x48>
        taskCB = (LosTaskCB *)g_taskCBArray + loop;
 80081da:	4b12      	ldr	r3, [pc, #72]	; (8008224 <OsShellCmdTaskCntGet+0x64>)
 80081dc:	6819      	ldr	r1, [r3, #0]
 80081de:	683a      	ldr	r2, [r7, #0]
 80081e0:	4613      	mov	r3, r2
 80081e2:	009b      	lsls	r3, r3, #2
 80081e4:	4413      	add	r3, r2
 80081e6:	015b      	lsls	r3, r3, #5
 80081e8:	440b      	add	r3, r1
 80081ea:	60bb      	str	r3, [r7, #8]
        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 80081ec:	68bb      	ldr	r3, [r7, #8]
 80081ee:	889b      	ldrh	r3, [r3, #4]
 80081f0:	f003 0301 	and.w	r3, r3, #1
 80081f4:	2b00      	cmp	r3, #0
 80081f6:	d103      	bne.n	8008200 <OsShellCmdTaskCntGet+0x40>
            continue;
        }
        taskCnt++;
 80081f8:	687b      	ldr	r3, [r7, #4]
 80081fa:	3301      	adds	r3, #1
 80081fc:	607b      	str	r3, [r7, #4]
 80081fe:	e000      	b.n	8008202 <OsShellCmdTaskCntGet+0x42>
            continue;
 8008200:	bf00      	nop
    for (loop = 0; loop < g_taskMaxNum; loop++) {
 8008202:	683b      	ldr	r3, [r7, #0]
 8008204:	3301      	adds	r3, #1
 8008206:	603b      	str	r3, [r7, #0]
 8008208:	4b07      	ldr	r3, [pc, #28]	; (8008228 <OsShellCmdTaskCntGet+0x68>)
 800820a:	681b      	ldr	r3, [r3, #0]
 800820c:	683a      	ldr	r2, [r7, #0]
 800820e:	429a      	cmp	r2, r3
 8008210:	d3e3      	bcc.n	80081da <OsShellCmdTaskCntGet+0x1a>
    }
    LOS_IntRestore(intSave);
 8008212:	68f8      	ldr	r0, [r7, #12]
 8008214:	f7ff ffc9 	bl	80081aa <LOS_IntRestore>
    return taskCnt;
 8008218:	687b      	ldr	r3, [r7, #4]
}
 800821a:	4618      	mov	r0, r3
 800821c:	3710      	adds	r7, #16
 800821e:	46bd      	mov	sp, r7
 8008220:	bd80      	pop	{r7, pc}
 8008222:	bf00      	nop
 8008224:	200036c4 	.word	0x200036c4
 8008228:	200036d8 	.word	0x200036d8

0800822c <OsShellCmdSemCntGet>:

#ifdef LOSCFG_BASE_IPC_SEM
UINT32 OsShellCmdSemCntGet(VOID)
{
 800822c:	b580      	push	{r7, lr}
 800822e:	b084      	sub	sp, #16
 8008230:	af00      	add	r7, sp, #0
    UINT32 loop;
    UINT32 semCnt = 0;
 8008232:	2300      	movs	r3, #0
 8008234:	607b      	str	r3, [r7, #4]
    UINT32 intSave;
    LosSemCB *semNode = NULL;
 8008236:	2300      	movs	r3, #0
 8008238:	60bb      	str	r3, [r7, #8]

    intSave = LOS_IntLock();
 800823a:	f7ff ffaf 	bl	800819c <LOS_IntLock>
 800823e:	60f8      	str	r0, [r7, #12]
    for (loop = 0; loop < LOSCFG_BASE_IPC_SEM_LIMIT; loop++) {
 8008240:	2300      	movs	r3, #0
 8008242:	603b      	str	r3, [r7, #0]
 8008244:	e010      	b.n	8008268 <OsShellCmdSemCntGet+0x3c>
        semNode = GET_SEM(loop);
 8008246:	4b0e      	ldr	r3, [pc, #56]	; (8008280 <OsShellCmdSemCntGet+0x54>)
 8008248:	681a      	ldr	r2, [r3, #0]
 800824a:	683b      	ldr	r3, [r7, #0]
 800824c:	b29b      	uxth	r3, r3
 800824e:	011b      	lsls	r3, r3, #4
 8008250:	4413      	add	r3, r2
 8008252:	60bb      	str	r3, [r7, #8]
        if (semNode->semStat == LOS_USED) {
 8008254:	68bb      	ldr	r3, [r7, #8]
 8008256:	781b      	ldrb	r3, [r3, #0]
 8008258:	2b01      	cmp	r3, #1
 800825a:	d102      	bne.n	8008262 <OsShellCmdSemCntGet+0x36>
            semCnt++;
 800825c:	687b      	ldr	r3, [r7, #4]
 800825e:	3301      	adds	r3, #1
 8008260:	607b      	str	r3, [r7, #4]
    for (loop = 0; loop < LOSCFG_BASE_IPC_SEM_LIMIT; loop++) {
 8008262:	683b      	ldr	r3, [r7, #0]
 8008264:	3301      	adds	r3, #1
 8008266:	603b      	str	r3, [r7, #0]
 8008268:	683b      	ldr	r3, [r7, #0]
 800826a:	2b13      	cmp	r3, #19
 800826c:	d9eb      	bls.n	8008246 <OsShellCmdSemCntGet+0x1a>
        }
    }
    LOS_IntRestore(intSave);
 800826e:	68f8      	ldr	r0, [r7, #12]
 8008270:	f7ff ff9b 	bl	80081aa <LOS_IntRestore>
    return semCnt;
 8008274:	687b      	ldr	r3, [r7, #4]
}
 8008276:	4618      	mov	r0, r3
 8008278:	3710      	adds	r7, #16
 800827a:	46bd      	mov	sp, r7
 800827c:	bd80      	pop	{r7, pc}
 800827e:	bf00      	nop
 8008280:	20000798 	.word	0x20000798

08008284 <OsShellCmdMuxCntGet>:
#endif

#ifdef LOSCFG_BASE_IPC_MUX
UINT32 OsShellCmdMuxCntGet(VOID)
{
 8008284:	b580      	push	{r7, lr}
 8008286:	b084      	sub	sp, #16
 8008288:	af00      	add	r7, sp, #0
    UINT32 loop;
    UINT32 muxCnt = 0;
 800828a:	2300      	movs	r3, #0
 800828c:	607b      	str	r3, [r7, #4]
    UINT32 intSave;
    LosMuxCB *muxNode = NULL;
 800828e:	2300      	movs	r3, #0
 8008290:	60bb      	str	r3, [r7, #8]

    intSave = LOS_IntLock();
 8008292:	f7ff ff83 	bl	800819c <LOS_IntLock>
 8008296:	60f8      	str	r0, [r7, #12]
    for (loop = 0; loop < LOSCFG_BASE_IPC_MUX_LIMIT; loop++) {
 8008298:	2300      	movs	r3, #0
 800829a:	603b      	str	r3, [r7, #0]
 800829c:	e013      	b.n	80082c6 <OsShellCmdMuxCntGet+0x42>
        muxNode = GET_MUX(loop);
 800829e:	4b0f      	ldr	r3, [pc, #60]	; (80082dc <OsShellCmdMuxCntGet+0x58>)
 80082a0:	6819      	ldr	r1, [r3, #0]
 80082a2:	683b      	ldr	r3, [r7, #0]
 80082a4:	b29a      	uxth	r2, r3
 80082a6:	4613      	mov	r3, r2
 80082a8:	009b      	lsls	r3, r3, #2
 80082aa:	4413      	add	r3, r2
 80082ac:	009b      	lsls	r3, r3, #2
 80082ae:	440b      	add	r3, r1
 80082b0:	60bb      	str	r3, [r7, #8]
        if (muxNode->muxStat == LOS_USED) {
 80082b2:	68bb      	ldr	r3, [r7, #8]
 80082b4:	7b9b      	ldrb	r3, [r3, #14]
 80082b6:	2b01      	cmp	r3, #1
 80082b8:	d102      	bne.n	80082c0 <OsShellCmdMuxCntGet+0x3c>
            muxCnt++;
 80082ba:	687b      	ldr	r3, [r7, #4]
 80082bc:	3301      	adds	r3, #1
 80082be:	607b      	str	r3, [r7, #4]
    for (loop = 0; loop < LOSCFG_BASE_IPC_MUX_LIMIT; loop++) {
 80082c0:	683b      	ldr	r3, [r7, #0]
 80082c2:	3301      	adds	r3, #1
 80082c4:	603b      	str	r3, [r7, #0]
 80082c6:	683b      	ldr	r3, [r7, #0]
 80082c8:	2b13      	cmp	r3, #19
 80082ca:	d9e8      	bls.n	800829e <OsShellCmdMuxCntGet+0x1a>
        }
    }
    LOS_IntRestore(intSave);
 80082cc:	68f8      	ldr	r0, [r7, #12]
 80082ce:	f7ff ff6c 	bl	80081aa <LOS_IntRestore>
    return muxCnt;
 80082d2:	687b      	ldr	r3, [r7, #4]
}
 80082d4:	4618      	mov	r0, r3
 80082d6:	3710      	adds	r7, #16
 80082d8:	46bd      	mov	sp, r7
 80082da:	bd80      	pop	{r7, pc}
 80082dc:	200021d0 	.word	0x200021d0

080082e0 <OsShellCmdQueueCntGet>:
#endif

#ifdef LOSCFG_BASE_IPC_QUEUE
UINT32 OsShellCmdQueueCntGet(VOID)
{
 80082e0:	b580      	push	{r7, lr}
 80082e2:	b084      	sub	sp, #16
 80082e4:	af00      	add	r7, sp, #0
    UINT32 loop;
    UINT32 queueCnt = 0;
 80082e6:	2300      	movs	r3, #0
 80082e8:	607b      	str	r3, [r7, #4]
    UINT32 intSave;
    LosQueueCB *queueCB = NULL;
 80082ea:	2300      	movs	r3, #0
 80082ec:	60bb      	str	r3, [r7, #8]

    intSave = LOS_IntLock();
 80082ee:	f7ff ff55 	bl	800819c <LOS_IntLock>
 80082f2:	60f8      	str	r0, [r7, #12]
    queueCB = g_allQueue;
 80082f4:	4b0e      	ldr	r3, [pc, #56]	; (8008330 <OsShellCmdQueueCntGet+0x50>)
 80082f6:	681b      	ldr	r3, [r3, #0]
 80082f8:	60bb      	str	r3, [r7, #8]
    for (loop = 0; loop < LOSCFG_BASE_IPC_QUEUE_LIMIT; loop++, queueCB++) {
 80082fa:	2300      	movs	r3, #0
 80082fc:	603b      	str	r3, [r7, #0]
 80082fe:	e00c      	b.n	800831a <OsShellCmdQueueCntGet+0x3a>
        if (queueCB->queueState == LOS_USED) {
 8008300:	68bb      	ldr	r3, [r7, #8]
 8008302:	791b      	ldrb	r3, [r3, #4]
 8008304:	2b01      	cmp	r3, #1
 8008306:	d102      	bne.n	800830e <OsShellCmdQueueCntGet+0x2e>
            queueCnt++;
 8008308:	687b      	ldr	r3, [r7, #4]
 800830a:	3301      	adds	r3, #1
 800830c:	607b      	str	r3, [r7, #4]
    for (loop = 0; loop < LOSCFG_BASE_IPC_QUEUE_LIMIT; loop++, queueCB++) {
 800830e:	683b      	ldr	r3, [r7, #0]
 8008310:	3301      	adds	r3, #1
 8008312:	603b      	str	r3, [r7, #0]
 8008314:	68bb      	ldr	r3, [r7, #8]
 8008316:	3330      	adds	r3, #48	; 0x30
 8008318:	60bb      	str	r3, [r7, #8]
 800831a:	683b      	ldr	r3, [r7, #0]
 800831c:	2b09      	cmp	r3, #9
 800831e:	d9ef      	bls.n	8008300 <OsShellCmdQueueCntGet+0x20>
        }
    }
    LOS_IntRestore(intSave);
 8008320:	68f8      	ldr	r0, [r7, #12]
 8008322:	f7ff ff42 	bl	80081aa <LOS_IntRestore>
    return queueCnt;
 8008326:	687b      	ldr	r3, [r7, #4]
}
 8008328:	4618      	mov	r0, r3
 800832a:	3710      	adds	r7, #16
 800832c:	46bd      	mov	sp, r7
 800832e:	bd80      	pop	{r7, pc}
 8008330:	200021c4 	.word	0x200021c4

08008334 <OsShellCmdSwtmrCntGet>:
#endif

#ifdef LOSCFG_BASE_CORE_SWTMR
UINT32 OsShellCmdSwtmrCntGet(VOID)
{
 8008334:	b580      	push	{r7, lr}
 8008336:	b084      	sub	sp, #16
 8008338:	af00      	add	r7, sp, #0
    UINT32 loop;
    UINT32 swtmrCnt = 0;
 800833a:	2300      	movs	r3, #0
 800833c:	607b      	str	r3, [r7, #4]
    UINT32 intSave;
    LosSwtmrCB *swtmrCB = NULL;
 800833e:	2300      	movs	r3, #0
 8008340:	60bb      	str	r3, [r7, #8]

    intSave = LOS_IntLock();
 8008342:	f7ff ff2b 	bl	800819c <LOS_IntLock>
 8008346:	60f8      	str	r0, [r7, #12]
    swtmrCB = g_swtmrCBArray;
 8008348:	4b0e      	ldr	r3, [pc, #56]	; (8008384 <OsShellCmdSwtmrCntGet+0x50>)
 800834a:	681b      	ldr	r3, [r3, #0]
 800834c:	60bb      	str	r3, [r7, #8]
    for (loop = 0; loop < LOSCFG_BASE_CORE_SWTMR_LIMIT; loop++, swtmrCB++) {
 800834e:	2300      	movs	r3, #0
 8008350:	603b      	str	r3, [r7, #0]
 8008352:	e00c      	b.n	800836e <OsShellCmdSwtmrCntGet+0x3a>
        if (swtmrCB->state != OS_SWTMR_STATUS_UNUSED) {
 8008354:	68bb      	ldr	r3, [r7, #8]
 8008356:	7b1b      	ldrb	r3, [r3, #12]
 8008358:	2b00      	cmp	r3, #0
 800835a:	d002      	beq.n	8008362 <OsShellCmdSwtmrCntGet+0x2e>
            swtmrCnt++;
 800835c:	687b      	ldr	r3, [r7, #4]
 800835e:	3301      	adds	r3, #1
 8008360:	607b      	str	r3, [r7, #4]
    for (loop = 0; loop < LOSCFG_BASE_CORE_SWTMR_LIMIT; loop++, swtmrCB++) {
 8008362:	683b      	ldr	r3, [r7, #0]
 8008364:	3301      	adds	r3, #1
 8008366:	603b      	str	r3, [r7, #0]
 8008368:	68bb      	ldr	r3, [r7, #8]
 800836a:	3324      	adds	r3, #36	; 0x24
 800836c:	60bb      	str	r3, [r7, #8]
 800836e:	683b      	ldr	r3, [r7, #0]
 8008370:	2b0f      	cmp	r3, #15
 8008372:	d9ef      	bls.n	8008354 <OsShellCmdSwtmrCntGet+0x20>
        }
    }
    LOS_IntRestore(intSave);
 8008374:	68f8      	ldr	r0, [r7, #12]
 8008376:	f7ff ff18 	bl	80081aa <LOS_IntRestore>
    return swtmrCnt;
 800837a:	687b      	ldr	r3, [r7, #4]
}
 800837c:	4618      	mov	r0, r3
 800837e:	3710      	adds	r7, #16
 8008380:	46bd      	mov	sp, r7
 8008382:	bd80      	pop	{r7, pc}
 8008384:	2000079c 	.word	0x2000079c

08008388 <OsShellCmdSystemInfoGet>:
#endif

LITE_OS_SEC_TEXT_MINOR VOID OsShellCmdSystemInfoGet(VOID)
{
 8008388:	b580      	push	{r7, lr}
 800838a:	af00      	add	r7, sp, #0
    PRINTK("\n   Module    Used      Total\n");
 800838c:	4817      	ldr	r0, [pc, #92]	; (80083ec <OsShellCmdSystemInfoGet+0x64>)
 800838e:	f7fc fa97 	bl	80048c0 <dprintf>
    PRINTK("--------------------------------\n");
 8008392:	4817      	ldr	r0, [pc, #92]	; (80083f0 <OsShellCmdSystemInfoGet+0x68>)
 8008394:	f7fc fa94 	bl	80048c0 <dprintf>
    PRINTK("   Task      %-10u%-10d\n",
 8008398:	f7ff ff12 	bl	80081c0 <OsShellCmdTaskCntGet>
 800839c:	4603      	mov	r3, r0
 800839e:	2210      	movs	r2, #16
 80083a0:	4619      	mov	r1, r3
 80083a2:	4814      	ldr	r0, [pc, #80]	; (80083f4 <OsShellCmdSystemInfoGet+0x6c>)
 80083a4:	f7fc fa8c 	bl	80048c0 <dprintf>
           OsShellCmdTaskCntGet(),
           LOSCFG_BASE_CORE_TSK_LIMIT);
#ifdef LOSCFG_BASE_IPC_SEM
    PRINTK("   Sem       %-10u%-10d\n",
 80083a8:	f7ff ff40 	bl	800822c <OsShellCmdSemCntGet>
 80083ac:	4603      	mov	r3, r0
 80083ae:	2214      	movs	r2, #20
 80083b0:	4619      	mov	r1, r3
 80083b2:	4811      	ldr	r0, [pc, #68]	; (80083f8 <OsShellCmdSystemInfoGet+0x70>)
 80083b4:	f7fc fa84 	bl	80048c0 <dprintf>
           OsShellCmdSemCntGet(),
           LOSCFG_BASE_IPC_SEM_LIMIT);
#endif
#ifdef LOSCFG_BASE_IPC_MUX
    PRINTK("   Mutex     %-10u%-10d\n",
 80083b8:	f7ff ff64 	bl	8008284 <OsShellCmdMuxCntGet>
 80083bc:	4603      	mov	r3, r0
 80083be:	2214      	movs	r2, #20
 80083c0:	4619      	mov	r1, r3
 80083c2:	480e      	ldr	r0, [pc, #56]	; (80083fc <OsShellCmdSystemInfoGet+0x74>)
 80083c4:	f7fc fa7c 	bl	80048c0 <dprintf>
           OsShellCmdMuxCntGet(),
           LOSCFG_BASE_IPC_MUX_LIMIT);
#endif
#ifdef LOSCFG_BASE_IPC_QUEUE
    PRINTK("   Queue     %-10u%-10d\n",
 80083c8:	f7ff ff8a 	bl	80082e0 <OsShellCmdQueueCntGet>
 80083cc:	4603      	mov	r3, r0
 80083ce:	220a      	movs	r2, #10
 80083d0:	4619      	mov	r1, r3
 80083d2:	480b      	ldr	r0, [pc, #44]	; (8008400 <OsShellCmdSystemInfoGet+0x78>)
 80083d4:	f7fc fa74 	bl	80048c0 <dprintf>
           OsShellCmdQueueCntGet(),
           LOSCFG_BASE_IPC_QUEUE_LIMIT);
#endif
#ifdef LOSCFG_BASE_CORE_SWTMR
    PRINTK("   SwTmr     %-10u%-10d\n",
 80083d8:	f7ff ffac 	bl	8008334 <OsShellCmdSwtmrCntGet>
 80083dc:	4603      	mov	r3, r0
 80083de:	2210      	movs	r2, #16
 80083e0:	4619      	mov	r1, r3
 80083e2:	4808      	ldr	r0, [pc, #32]	; (8008404 <OsShellCmdSystemInfoGet+0x7c>)
 80083e4:	f7fc fa6c 	bl	80048c0 <dprintf>
           OsShellCmdSwtmrCntGet(),
           LOSCFG_BASE_CORE_SWTMR_LIMIT);
#endif
}
 80083e8:	bf00      	nop
 80083ea:	bd80      	pop	{r7, pc}
 80083ec:	08020f74 	.word	0x08020f74
 80083f0:	08020f94 	.word	0x08020f94
 80083f4:	08020fb8 	.word	0x08020fb8
 80083f8:	08020fd4 	.word	0x08020fd4
 80083fc:	08020ff0 	.word	0x08020ff0
 8008400:	0802100c 	.word	0x0802100c
 8008404:	08021028 	.word	0x08021028

08008408 <OsShellCmdSystemInfo>:

INT32 OsShellCmdSystemInfo(INT32 argc, const CHAR **argv)
{
 8008408:	b580      	push	{r7, lr}
 800840a:	b082      	sub	sp, #8
 800840c:	af00      	add	r7, sp, #0
 800840e:	6078      	str	r0, [r7, #4]
 8008410:	6039      	str	r1, [r7, #0]
    if (argc == 0) {
 8008412:	687b      	ldr	r3, [r7, #4]
 8008414:	2b00      	cmp	r3, #0
 8008416:	d103      	bne.n	8008420 <OsShellCmdSystemInfo+0x18>
        OsShellCmdSystemInfoGet();
 8008418:	f7ff ffb6 	bl	8008388 <OsShellCmdSystemInfoGet>
        return 0;
 800841c:	2300      	movs	r3, #0
 800841e:	e007      	b.n	8008430 <OsShellCmdSystemInfo+0x28>
    }
    PRINTK("systeminfo: invalid option %s\n"
 8008420:	683b      	ldr	r3, [r7, #0]
 8008422:	681b      	ldr	r3, [r3, #0]
 8008424:	4619      	mov	r1, r3
 8008426:	4804      	ldr	r0, [pc, #16]	; (8008438 <OsShellCmdSystemInfo+0x30>)
 8008428:	f7fc fa4a 	bl	80048c0 <dprintf>
           "Systeminfo has NO ARGS.\n",
           argv[0]);
    return -1;
 800842c:	f04f 33ff 	mov.w	r3, #4294967295
}
 8008430:	4618      	mov	r0, r3
 8008432:	3708      	adds	r7, #8
 8008434:	46bd      	mov	sp, r7
 8008436:	bd80      	pop	{r7, pc}
 8008438:	08021044 	.word	0x08021044

0800843c <LOS_IntLock>:
{
 800843c:	b580      	push	{r7, lr}
 800843e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8008440:	f7f8 fc42 	bl	8000cc8 <ArchIntLock>
 8008444:	4603      	mov	r3, r0
}
 8008446:	4618      	mov	r0, r3
 8008448:	bd80      	pop	{r7, pc}

0800844a <LOS_IntRestore>:
{
 800844a:	b580      	push	{r7, lr}
 800844c:	b082      	sub	sp, #8
 800844e:	af00      	add	r7, sp, #0
 8008450:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8008452:	6878      	ldr	r0, [r7, #4]
 8008454:	f7f8 fc40 	bl	8000cd8 <ArchIntRestore>
}
 8008458:	bf00      	nop
 800845a:	3708      	adds	r7, #8
 800845c:	46bd      	mov	sp, r7
 800845e:	bd80      	pop	{r7, pc}

08008460 <LOS_SpinLockSave>:
{
 8008460:	b580      	push	{r7, lr}
 8008462:	b082      	sub	sp, #8
 8008464:	af00      	add	r7, sp, #0
 8008466:	6078      	str	r0, [r7, #4]
 8008468:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 800846a:	f7ff ffe7 	bl	800843c <LOS_IntLock>
 800846e:	4602      	mov	r2, r0
 8008470:	683b      	ldr	r3, [r7, #0]
 8008472:	601a      	str	r2, [r3, #0]
}
 8008474:	bf00      	nop
 8008476:	3708      	adds	r7, #8
 8008478:	46bd      	mov	sp, r7
 800847a:	bd80      	pop	{r7, pc}

0800847c <LOS_SpinUnlockRestore>:
{
 800847c:	b580      	push	{r7, lr}
 800847e:	b082      	sub	sp, #8
 8008480:	af00      	add	r7, sp, #0
 8008482:	6078      	str	r0, [r7, #4]
 8008484:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8008486:	6838      	ldr	r0, [r7, #0]
 8008488:	f7ff ffdf 	bl	800844a <LOS_IntRestore>
}
 800848c:	bf00      	nop
 800848e:	3708      	adds	r7, #8
 8008490:	46bd      	mov	sp, r7
 8008492:	bd80      	pop	{r7, pc}

08008494 <LOS_SpinHeld>:
{
 8008494:	b480      	push	{r7}
 8008496:	b083      	sub	sp, #12
 8008498:	af00      	add	r7, sp, #0
 800849a:	6078      	str	r0, [r7, #4]
    return TRUE;
 800849c:	2301      	movs	r3, #1
}
 800849e:	4618      	mov	r0, r3
 80084a0:	370c      	adds	r7, #12
 80084a2:	46bd      	mov	sp, r7
 80084a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80084a8:	4770      	bx	lr
	...

080084ac <OsShellCmdConvertTskStatus>:
#endif

LITE_OS_SEC_BSS STATIC UINT32 g_taskWaterLine[LOSCFG_BASE_CORE_TSK_LIMIT];

LITE_OS_SEC_TEXT_MINOR UINT8 *OsShellCmdConvertTskStatus(UINT16 taskStatus)
{
 80084ac:	b480      	push	{r7}
 80084ae:	b083      	sub	sp, #12
 80084b0:	af00      	add	r7, sp, #0
 80084b2:	4603      	mov	r3, r0
 80084b4:	80fb      	strh	r3, [r7, #6]
    if (taskStatus & OS_TASK_STATUS_RUNNING) {
 80084b6:	88fb      	ldrh	r3, [r7, #6]
 80084b8:	f003 0310 	and.w	r3, r3, #16
 80084bc:	2b00      	cmp	r3, #0
 80084be:	d001      	beq.n	80084c4 <OsShellCmdConvertTskStatus+0x18>
        return (UINT8 *)"Running";
 80084c0:	4b1b      	ldr	r3, [pc, #108]	; (8008530 <OsShellCmdConvertTskStatus+0x84>)
 80084c2:	e02f      	b.n	8008524 <OsShellCmdConvertTskStatus+0x78>
    } else if (taskStatus & OS_TASK_STATUS_READY) {
 80084c4:	88fb      	ldrh	r3, [r7, #6]
 80084c6:	f003 0304 	and.w	r3, r3, #4
 80084ca:	2b00      	cmp	r3, #0
 80084cc:	d001      	beq.n	80084d2 <OsShellCmdConvertTskStatus+0x26>
        return (UINT8 *)"Ready";
 80084ce:	4b19      	ldr	r3, [pc, #100]	; (8008534 <OsShellCmdConvertTskStatus+0x88>)
 80084d0:	e028      	b.n	8008524 <OsShellCmdConvertTskStatus+0x78>
    } else {
        if (taskStatus & OS_TASK_STATUS_DELAY) {
 80084d2:	88fb      	ldrh	r3, [r7, #6]
 80084d4:	f003 0320 	and.w	r3, r3, #32
 80084d8:	2b00      	cmp	r3, #0
 80084da:	d001      	beq.n	80084e0 <OsShellCmdConvertTskStatus+0x34>
            return (UINT8 *)"Delay";
 80084dc:	4b16      	ldr	r3, [pc, #88]	; (8008538 <OsShellCmdConvertTskStatus+0x8c>)
 80084de:	e021      	b.n	8008524 <OsShellCmdConvertTskStatus+0x78>
        } else if (taskStatus & OS_TASK_STATUS_PEND_TIME) {
 80084e0:	88fb      	ldrh	r3, [r7, #6]
 80084e2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80084e6:	2b00      	cmp	r3, #0
 80084e8:	d00d      	beq.n	8008506 <OsShellCmdConvertTskStatus+0x5a>
            if (taskStatus & OS_TASK_STATUS_SUSPEND) {
 80084ea:	88fb      	ldrh	r3, [r7, #6]
 80084ec:	f003 0302 	and.w	r3, r3, #2
 80084f0:	2b00      	cmp	r3, #0
 80084f2:	d001      	beq.n	80084f8 <OsShellCmdConvertTskStatus+0x4c>
                return (UINT8 *)"SuspendTime";
 80084f4:	4b11      	ldr	r3, [pc, #68]	; (800853c <OsShellCmdConvertTskStatus+0x90>)
 80084f6:	e015      	b.n	8008524 <OsShellCmdConvertTskStatus+0x78>
            } else if (taskStatus & OS_TASK_STATUS_PEND) {
 80084f8:	88fb      	ldrh	r3, [r7, #6]
 80084fa:	f003 0308 	and.w	r3, r3, #8
 80084fe:	2b00      	cmp	r3, #0
 8008500:	d00f      	beq.n	8008522 <OsShellCmdConvertTskStatus+0x76>
                return (UINT8 *)"PendTime";
 8008502:	4b0f      	ldr	r3, [pc, #60]	; (8008540 <OsShellCmdConvertTskStatus+0x94>)
 8008504:	e00e      	b.n	8008524 <OsShellCmdConvertTskStatus+0x78>
            }
        } else if (taskStatus & OS_TASK_STATUS_PEND) {
 8008506:	88fb      	ldrh	r3, [r7, #6]
 8008508:	f003 0308 	and.w	r3, r3, #8
 800850c:	2b00      	cmp	r3, #0
 800850e:	d001      	beq.n	8008514 <OsShellCmdConvertTskStatus+0x68>
            return (UINT8 *)"Pend";
 8008510:	4b0c      	ldr	r3, [pc, #48]	; (8008544 <OsShellCmdConvertTskStatus+0x98>)
 8008512:	e007      	b.n	8008524 <OsShellCmdConvertTskStatus+0x78>
        } else if (taskStatus & OS_TASK_STATUS_SUSPEND) {
 8008514:	88fb      	ldrh	r3, [r7, #6]
 8008516:	f003 0302 	and.w	r3, r3, #2
 800851a:	2b00      	cmp	r3, #0
 800851c:	d001      	beq.n	8008522 <OsShellCmdConvertTskStatus+0x76>
            return (UINT8 *)"Suspend";
 800851e:	4b0a      	ldr	r3, [pc, #40]	; (8008548 <OsShellCmdConvertTskStatus+0x9c>)
 8008520:	e000      	b.n	8008524 <OsShellCmdConvertTskStatus+0x78>
        }
    }

    return (UINT8 *)"Invalid";
 8008522:	4b0a      	ldr	r3, [pc, #40]	; (800854c <OsShellCmdConvertTskStatus+0xa0>)
}
 8008524:	4618      	mov	r0, r3
 8008526:	370c      	adds	r7, #12
 8008528:	46bd      	mov	sp, r7
 800852a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800852e:	4770      	bx	lr
 8008530:	08021088 	.word	0x08021088
 8008534:	08021090 	.word	0x08021090
 8008538:	08021098 	.word	0x08021098
 800853c:	080210a0 	.word	0x080210a0
 8008540:	080210ac 	.word	0x080210ac
 8008544:	080210b8 	.word	0x080210b8
 8008548:	080210c0 	.word	0x080210c0
 800854c:	080210c8 	.word	0x080210c8

08008550 <OsShellCmdTaskWaterLineGet>:

STATIC VOID OsShellCmdTaskWaterLineGet(const LosTaskCB *allTaskArray)
{
 8008550:	b580      	push	{r7, lr}
 8008552:	b084      	sub	sp, #16
 8008554:	af00      	add	r7, sp, #0
 8008556:	6078      	str	r0, [r7, #4]
    const LosTaskCB *taskCB = NULL;
 8008558:	2300      	movs	r3, #0
 800855a:	60fb      	str	r3, [r7, #12]
    UINT32 loop;

    for (loop = 0; loop < g_taskMaxNum; ++loop) {
 800855c:	2300      	movs	r3, #0
 800855e:	60bb      	str	r3, [r7, #8]
 8008560:	e024      	b.n	80085ac <OsShellCmdTaskWaterLineGet+0x5c>
        taskCB = allTaskArray + loop;
 8008562:	68ba      	ldr	r2, [r7, #8]
 8008564:	4613      	mov	r3, r2
 8008566:	009b      	lsls	r3, r3, #2
 8008568:	4413      	add	r3, r2
 800856a:	015b      	lsls	r3, r3, #5
 800856c:	461a      	mov	r2, r3
 800856e:	687b      	ldr	r3, [r7, #4]
 8008570:	4413      	add	r3, r2
 8008572:	60fb      	str	r3, [r7, #12]
        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 8008574:	68fb      	ldr	r3, [r7, #12]
 8008576:	889b      	ldrh	r3, [r3, #4]
 8008578:	f003 0301 	and.w	r3, r3, #1
 800857c:	2b00      	cmp	r3, #0
 800857e:	d111      	bne.n	80085a4 <OsShellCmdTaskWaterLineGet+0x54>
            continue;
        }

        (VOID)OsStackWaterLineGet((const UINTPTR *)((UINTPTR)taskCB->topOfStack + taskCB->stackSize),
 8008580:	68fb      	ldr	r3, [r7, #12]
 8008582:	691a      	ldr	r2, [r3, #16]
 8008584:	68fb      	ldr	r3, [r7, #12]
 8008586:	68db      	ldr	r3, [r3, #12]
 8008588:	4413      	add	r3, r2
 800858a:	4618      	mov	r0, r3
                                  (const UINTPTR *)taskCB->topOfStack, &g_taskWaterLine[taskCB->taskId]);
 800858c:	68fb      	ldr	r3, [r7, #12]
 800858e:	691b      	ldr	r3, [r3, #16]
        (VOID)OsStackWaterLineGet((const UINTPTR *)((UINTPTR)taskCB->topOfStack + taskCB->stackSize),
 8008590:	4619      	mov	r1, r3
                                  (const UINTPTR *)taskCB->topOfStack, &g_taskWaterLine[taskCB->taskId]);
 8008592:	68fb      	ldr	r3, [r7, #12]
 8008594:	695b      	ldr	r3, [r3, #20]
        (VOID)OsStackWaterLineGet((const UINTPTR *)((UINTPTR)taskCB->topOfStack + taskCB->stackSize),
 8008596:	009b      	lsls	r3, r3, #2
 8008598:	4a09      	ldr	r2, [pc, #36]	; (80085c0 <OsShellCmdTaskWaterLineGet+0x70>)
 800859a:	4413      	add	r3, r2
 800859c:	461a      	mov	r2, r3
 800859e:	f001 ffb0 	bl	800a502 <OsStackWaterLineGet>
 80085a2:	e000      	b.n	80085a6 <OsShellCmdTaskWaterLineGet+0x56>
            continue;
 80085a4:	bf00      	nop
    for (loop = 0; loop < g_taskMaxNum; ++loop) {
 80085a6:	68bb      	ldr	r3, [r7, #8]
 80085a8:	3301      	adds	r3, #1
 80085aa:	60bb      	str	r3, [r7, #8]
 80085ac:	4b05      	ldr	r3, [pc, #20]	; (80085c4 <OsShellCmdTaskWaterLineGet+0x74>)
 80085ae:	681b      	ldr	r3, [r3, #0]
 80085b0:	68ba      	ldr	r2, [r7, #8]
 80085b2:	429a      	cmp	r2, r3
 80085b4:	d3d5      	bcc.n	8008562 <OsShellCmdTaskWaterLineGet+0x12>
    }
}
 80085b6:	bf00      	nop
 80085b8:	bf00      	nop
 80085ba:	3710      	adds	r7, #16
 80085bc:	46bd      	mov	sp, r7
 80085be:	bd80      	pop	{r7, pc}
 80085c0:	20002170 	.word	0x20002170
 80085c4:	200036d8 	.word	0x200036d8

080085c8 <OsShellCmdTskInfoTitle>:
    WriteExcInfoToBuf("\n");
}
#endif

LITE_OS_SEC_TEXT_MINOR STATIC VOID OsShellCmdTskInfoTitle(VOID)
{
 80085c8:	b580      	push	{r7, lr}
 80085ca:	af00      	add	r7, sp, #0
    PRINTK("\r\nName                   TaskEntryAddr       TID    ");
 80085cc:	480f      	ldr	r0, [pc, #60]	; (800860c <OsShellCmdTskInfoTitle+0x44>)
 80085ce:	f7fc f977 	bl	80048c0 <dprintf>
#ifdef LOSCFG_KERNEL_SMP
    PRINTK("Affi    CPU    ");
#endif
    PRINTK("Priority   Status       "
 80085d2:	480f      	ldr	r0, [pc, #60]	; (8008610 <OsShellCmdTskInfoTitle+0x48>)
 80085d4:	f7fc f974 	bl	80048c0 <dprintf>
           "StackSize    WaterLine      StackPoint   TopOfStack   SemID        EventMask");

#ifdef LOSCFG_KERNEL_CPUP
    PRINTK("  CPUUSE  CPUUSE10s  CPUUSE1s  ");
 80085d8:	480e      	ldr	r0, [pc, #56]	; (8008614 <OsShellCmdTskInfoTitle+0x4c>)
 80085da:	f7fc f971 	bl	80048c0 <dprintf>
#endif /* LOSCFG_KERNEL_CPUP */
#ifdef LOSCFG_MEM_TASK_STAT
    PRINTK("   MEMUSE");
 80085de:	480e      	ldr	r0, [pc, #56]	; (8008618 <OsShellCmdTskInfoTitle+0x50>)
 80085e0:	f7fc f96e 	bl	80048c0 <dprintf>
#endif
    PRINTK("\n");
 80085e4:	480d      	ldr	r0, [pc, #52]	; (800861c <OsShellCmdTskInfoTitle+0x54>)
 80085e6:	f7fc f96b 	bl	80048c0 <dprintf>
    PRINTK("----                   -------------       ---    ");
 80085ea:	480d      	ldr	r0, [pc, #52]	; (8008620 <OsShellCmdTskInfoTitle+0x58>)
 80085ec:	f7fc f968 	bl	80048c0 <dprintf>
#ifdef LOSCFG_KERNEL_SMP
    PRINTK("-----   ----   ");
#endif
    PRINTK("--------   --------     "
 80085f0:	480c      	ldr	r0, [pc, #48]	; (8008624 <OsShellCmdTskInfoTitle+0x5c>)
 80085f2:	f7fc f965 	bl	80048c0 <dprintf>
           "---------    ----------     ----------   ----------   ----------   ---------");
#ifdef LOSCFG_KERNEL_CPUP
    PRINTK("  ------  ---------  --------  ");
 80085f6:	480c      	ldr	r0, [pc, #48]	; (8008628 <OsShellCmdTskInfoTitle+0x60>)
 80085f8:	f7fc f962 	bl	80048c0 <dprintf>
#endif /* LOSCFG_KERNEL_CPUP */
#ifdef LOSCFG_MEM_TASK_STAT
    PRINTK("   ------");
 80085fc:	480b      	ldr	r0, [pc, #44]	; (800862c <OsShellCmdTskInfoTitle+0x64>)
 80085fe:	f7fc f95f 	bl	80048c0 <dprintf>
#endif
    PRINTK("\n");
 8008602:	4806      	ldr	r0, [pc, #24]	; (800861c <OsShellCmdTskInfoTitle+0x54>)
 8008604:	f7fc f95c 	bl	80048c0 <dprintf>

#ifdef LOSCFG_SHELL_EXCINFO_DUMP
    OsShellCmdTskInfoTitleExc();
#endif
}
 8008608:	bf00      	nop
 800860a:	bd80      	pop	{r7, pc}
 800860c:	080210d0 	.word	0x080210d0
 8008610:	08021108 	.word	0x08021108
 8008614:	08021170 	.word	0x08021170
 8008618:	08021190 	.word	0x08021190
 800861c:	0802119c 	.word	0x0802119c
 8008620:	080211a0 	.word	0x080211a0
 8008624:	080211d4 	.word	0x080211d4
 8008628:	0802123c 	.word	0x0802123c
 800862c:	0802125c 	.word	0x0802125c

08008630 <OsGetSemID>:

LITE_OS_SEC_TEXT_MINOR STATIC INLINE UINT32 OsGetSemID(const LosTaskCB *taskCB)
{
 8008630:	b480      	push	{r7}
 8008632:	b085      	sub	sp, #20
 8008634:	af00      	add	r7, sp, #0
 8008636:	6078      	str	r0, [r7, #4]
    UINT32 semId = OS_INVALID_SEM_ID;
 8008638:	f04f 33ff 	mov.w	r3, #4294967295
 800863c:	60fb      	str	r3, [r7, #12]

    if (taskCB->taskSem != NULL) {
 800863e:	687b      	ldr	r3, [r7, #4]
 8008640:	69db      	ldr	r3, [r3, #28]
 8008642:	2b00      	cmp	r3, #0
 8008644:	d003      	beq.n	800864e <OsGetSemID+0x1e>
        semId = ((LosSemCB *)taskCB->taskSem)->semId;
 8008646:	687b      	ldr	r3, [r7, #4]
 8008648:	69db      	ldr	r3, [r3, #28]
 800864a:	685b      	ldr	r3, [r3, #4]
 800864c:	60fb      	str	r3, [r7, #12]
    }

    return semId;
 800864e:	68fb      	ldr	r3, [r7, #12]
}
 8008650:	4618      	mov	r0, r3
 8008652:	3714      	adds	r7, #20
 8008654:	46bd      	mov	sp, r7
 8008656:	f85d 7b04 	ldr.w	r7, [sp], #4
 800865a:	4770      	bx	lr

0800865c <OsShellCmdTskInfoData>:
    }
}
#endif

LITE_OS_SEC_TEXT_MINOR STATIC VOID OsShellCmdTskInfoData(const LosTaskCB *allTaskArray)
{
 800865c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800865e:	b08b      	sub	sp, #44	; 0x2c
 8008660:	af04      	add	r7, sp, #16
 8008662:	6078      	str	r0, [r7, #4]
    const LosTaskCB *taskCB = NULL;
 8008664:	2300      	movs	r3, #0
 8008666:	613b      	str	r3, [r7, #16]
    UINT32 loop;
    UINT32 semId;

    for (loop = 0; loop < g_taskMaxNum; ++loop) {
 8008668:	2300      	movs	r3, #0
 800866a:	60fb      	str	r3, [r7, #12]
 800866c:	e0a8      	b.n	80087c0 <OsShellCmdTskInfoData+0x164>
        taskCB = allTaskArray + loop;
 800866e:	68fa      	ldr	r2, [r7, #12]
 8008670:	4613      	mov	r3, r2
 8008672:	009b      	lsls	r3, r3, #2
 8008674:	4413      	add	r3, r2
 8008676:	015b      	lsls	r3, r3, #5
 8008678:	461a      	mov	r2, r3
 800867a:	687b      	ldr	r3, [r7, #4]
 800867c:	4413      	add	r3, r2
 800867e:	613b      	str	r3, [r7, #16]
        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 8008680:	693b      	ldr	r3, [r7, #16]
 8008682:	889b      	ldrh	r3, [r3, #4]
 8008684:	f003 0301 	and.w	r3, r3, #1
 8008688:	2b00      	cmp	r3, #0
 800868a:	f040 8095 	bne.w	80087b8 <OsShellCmdTskInfoData+0x15c>
            continue;
        }

        semId = OsGetSemID(taskCB);
 800868e:	6938      	ldr	r0, [r7, #16]
 8008690:	f7ff ffce 	bl	8008630 <OsGetSemID>
 8008694:	6178      	str	r0, [r7, #20]

        PRINTK("%-23s0x%-18.8x0x%-5x", taskCB->taskName, taskCB->taskEntry, taskCB->taskId);
 8008696:	693b      	ldr	r3, [r7, #16]
 8008698:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 800869a:	693b      	ldr	r3, [r7, #16]
 800869c:	699a      	ldr	r2, [r3, #24]
 800869e:	693b      	ldr	r3, [r7, #16]
 80086a0:	695b      	ldr	r3, [r3, #20]
 80086a2:	484d      	ldr	r0, [pc, #308]	; (80087d8 <OsShellCmdTskInfoData+0x17c>)
 80086a4:	f7fc f90c 	bl	80048c0 <dprintf>

#ifdef LOSCFG_KERNEL_SMP
        PRINTK("0x%04x  %4d   ", taskCB->cpuAffiMask, (INT16)(taskCB->currCpu));
#endif
        PRINTK("%-11u%-13s0x%-11x0x%-11x  0x%-.8x   0x%-.8x   0x%-11x", taskCB->priority,
 80086a8:	693b      	ldr	r3, [r7, #16]
 80086aa:	88db      	ldrh	r3, [r3, #6]
 80086ac:	461e      	mov	r6, r3
 80086ae:	693b      	ldr	r3, [r7, #16]
 80086b0:	889b      	ldrh	r3, [r3, #4]
 80086b2:	4618      	mov	r0, r3
 80086b4:	f7ff fefa 	bl	80084ac <OsShellCmdConvertTskStatus>
 80086b8:	4605      	mov	r5, r0
 80086ba:	693b      	ldr	r3, [r7, #16]
 80086bc:	68dc      	ldr	r4, [r3, #12]
 80086be:	693b      	ldr	r3, [r7, #16]
 80086c0:	695b      	ldr	r3, [r3, #20]
 80086c2:	4a46      	ldr	r2, [pc, #280]	; (80087dc <OsShellCmdTskInfoData+0x180>)
 80086c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80086c8:	693a      	ldr	r2, [r7, #16]
 80086ca:	6812      	ldr	r2, [r2, #0]
 80086cc:	6939      	ldr	r1, [r7, #16]
 80086ce:	6909      	ldr	r1, [r1, #16]
 80086d0:	6978      	ldr	r0, [r7, #20]
 80086d2:	9003      	str	r0, [sp, #12]
 80086d4:	9102      	str	r1, [sp, #8]
 80086d6:	9201      	str	r2, [sp, #4]
 80086d8:	9300      	str	r3, [sp, #0]
 80086da:	4623      	mov	r3, r4
 80086dc:	462a      	mov	r2, r5
 80086de:	4631      	mov	r1, r6
 80086e0:	483f      	ldr	r0, [pc, #252]	; (80087e0 <OsShellCmdTskInfoData+0x184>)
 80086e2:	f7fc f8ed 	bl	80048c0 <dprintf>
               OsShellCmdConvertTskStatus(taskCB->taskStatus), taskCB->stackSize,
               g_taskWaterLine[taskCB->taskId],
               taskCB->stackPointer, taskCB->topOfStack, semId);
#ifdef LOSCFG_BASE_IPC_EVENT
        PRINTK("0x%-6x", taskCB->eventMask);
 80086e6:	693b      	ldr	r3, [r7, #16]
 80086e8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80086ea:	4619      	mov	r1, r3
 80086ec:	483d      	ldr	r0, [pc, #244]	; (80087e4 <OsShellCmdTskInfoData+0x188>)
 80086ee:	f7fc f8e7 	bl	80048c0 <dprintf>
#endif

#ifdef LOSCFG_KERNEL_CPUP
        PRINTK(" %4u.%1u%9u.%1u%8u.%1u   ",
 80086f2:	693b      	ldr	r3, [r7, #16]
 80086f4:	695b      	ldr	r3, [r3, #20]
 80086f6:	4a3c      	ldr	r2, [pc, #240]	; (80087e8 <OsShellCmdTskInfoData+0x18c>)
 80086f8:	00db      	lsls	r3, r3, #3
 80086fa:	4413      	add	r3, r2
 80086fc:	685b      	ldr	r3, [r3, #4]
 80086fe:	4a3b      	ldr	r2, [pc, #236]	; (80087ec <OsShellCmdTskInfoData+0x190>)
 8008700:	fba2 2303 	umull	r2, r3, r2, r3
 8008704:	08de      	lsrs	r6, r3, #3
 8008706:	693b      	ldr	r3, [r7, #16]
 8008708:	695b      	ldr	r3, [r3, #20]
 800870a:	4a37      	ldr	r2, [pc, #220]	; (80087e8 <OsShellCmdTskInfoData+0x18c>)
 800870c:	00db      	lsls	r3, r3, #3
 800870e:	4413      	add	r3, r2
 8008710:	685a      	ldr	r2, [r3, #4]
 8008712:	4b36      	ldr	r3, [pc, #216]	; (80087ec <OsShellCmdTskInfoData+0x190>)
 8008714:	fba3 1302 	umull	r1, r3, r3, r2
 8008718:	08d8      	lsrs	r0, r3, #3
 800871a:	4603      	mov	r3, r0
 800871c:	009b      	lsls	r3, r3, #2
 800871e:	4403      	add	r3, r0
 8008720:	005b      	lsls	r3, r3, #1
 8008722:	1ad0      	subs	r0, r2, r3
 8008724:	693b      	ldr	r3, [r7, #16]
 8008726:	695b      	ldr	r3, [r3, #20]
 8008728:	4a31      	ldr	r2, [pc, #196]	; (80087f0 <OsShellCmdTskInfoData+0x194>)
 800872a:	00db      	lsls	r3, r3, #3
 800872c:	4413      	add	r3, r2
 800872e:	685b      	ldr	r3, [r3, #4]
 8008730:	4a2e      	ldr	r2, [pc, #184]	; (80087ec <OsShellCmdTskInfoData+0x190>)
 8008732:	fba2 2303 	umull	r2, r3, r2, r3
 8008736:	ea4f 0cd3 	mov.w	ip, r3, lsr #3
 800873a:	693b      	ldr	r3, [r7, #16]
 800873c:	695b      	ldr	r3, [r3, #20]
 800873e:	4a2c      	ldr	r2, [pc, #176]	; (80087f0 <OsShellCmdTskInfoData+0x194>)
 8008740:	00db      	lsls	r3, r3, #3
 8008742:	4413      	add	r3, r2
 8008744:	6859      	ldr	r1, [r3, #4]
 8008746:	4b29      	ldr	r3, [pc, #164]	; (80087ec <OsShellCmdTskInfoData+0x190>)
 8008748:	fba3 2301 	umull	r2, r3, r3, r1
 800874c:	08da      	lsrs	r2, r3, #3
 800874e:	4613      	mov	r3, r2
 8008750:	009b      	lsls	r3, r3, #2
 8008752:	4413      	add	r3, r2
 8008754:	005b      	lsls	r3, r3, #1
 8008756:	1aca      	subs	r2, r1, r3
 8008758:	693b      	ldr	r3, [r7, #16]
 800875a:	695b      	ldr	r3, [r3, #20]
 800875c:	4925      	ldr	r1, [pc, #148]	; (80087f4 <OsShellCmdTskInfoData+0x198>)
 800875e:	00db      	lsls	r3, r3, #3
 8008760:	440b      	add	r3, r1
 8008762:	685b      	ldr	r3, [r3, #4]
 8008764:	4921      	ldr	r1, [pc, #132]	; (80087ec <OsShellCmdTskInfoData+0x190>)
 8008766:	fba1 1303 	umull	r1, r3, r1, r3
 800876a:	08dd      	lsrs	r5, r3, #3
 800876c:	693b      	ldr	r3, [r7, #16]
 800876e:	695b      	ldr	r3, [r3, #20]
 8008770:	4920      	ldr	r1, [pc, #128]	; (80087f4 <OsShellCmdTskInfoData+0x198>)
 8008772:	00db      	lsls	r3, r3, #3
 8008774:	440b      	add	r3, r1
 8008776:	685c      	ldr	r4, [r3, #4]
 8008778:	4b1c      	ldr	r3, [pc, #112]	; (80087ec <OsShellCmdTskInfoData+0x190>)
 800877a:	fba3 1304 	umull	r1, r3, r3, r4
 800877e:	08d9      	lsrs	r1, r3, #3
 8008780:	460b      	mov	r3, r1
 8008782:	009b      	lsls	r3, r3, #2
 8008784:	440b      	add	r3, r1
 8008786:	005b      	lsls	r3, r3, #1
 8008788:	1ae1      	subs	r1, r4, r3
 800878a:	9102      	str	r1, [sp, #8]
 800878c:	9501      	str	r5, [sp, #4]
 800878e:	9200      	str	r2, [sp, #0]
 8008790:	4663      	mov	r3, ip
 8008792:	4602      	mov	r2, r0
 8008794:	4631      	mov	r1, r6
 8008796:	4818      	ldr	r0, [pc, #96]	; (80087f8 <OsShellCmdTskInfoData+0x19c>)
 8008798:	f7fc f892 	bl	80048c0 <dprintf>
               g_taskCpup10s[taskCB->taskId].uwUsage % LOS_CPUP_PRECISION_MULT,
               g_taskCpup1s[taskCB->taskId].uwUsage / LOS_CPUP_PRECISION_MULT,
               g_taskCpup1s[taskCB->taskId].uwUsage % LOS_CPUP_PRECISION_MULT);
#endif /* LOSCFG_KERNEL_CPUP */
#ifdef LOSCFG_MEM_TASK_STAT
        PRINTK("    %-11u", OsMemTaskUsage(taskCB->taskId));
 800879c:	693b      	ldr	r3, [r7, #16]
 800879e:	695b      	ldr	r3, [r3, #20]
 80087a0:	4618      	mov	r0, r3
 80087a2:	f001 fc01 	bl	8009fa8 <OsMemTaskUsage>
 80087a6:	4603      	mov	r3, r0
 80087a8:	4619      	mov	r1, r3
 80087aa:	4814      	ldr	r0, [pc, #80]	; (80087fc <OsShellCmdTskInfoData+0x1a0>)
 80087ac:	f7fc f888 	bl	80048c0 <dprintf>
#endif
        PRINTK("\n");
 80087b0:	4813      	ldr	r0, [pc, #76]	; (8008800 <OsShellCmdTskInfoData+0x1a4>)
 80087b2:	f7fc f885 	bl	80048c0 <dprintf>
 80087b6:	e000      	b.n	80087ba <OsShellCmdTskInfoData+0x15e>
            continue;
 80087b8:	bf00      	nop
    for (loop = 0; loop < g_taskMaxNum; ++loop) {
 80087ba:	68fb      	ldr	r3, [r7, #12]
 80087bc:	3301      	adds	r3, #1
 80087be:	60fb      	str	r3, [r7, #12]
 80087c0:	4b10      	ldr	r3, [pc, #64]	; (8008804 <OsShellCmdTskInfoData+0x1a8>)
 80087c2:	681b      	ldr	r3, [r3, #0]
 80087c4:	68fa      	ldr	r2, [r7, #12]
 80087c6:	429a      	cmp	r2, r3
 80087c8:	f4ff af51 	bcc.w	800866e <OsShellCmdTskInfoData+0x12>
    }

#ifdef LOSCFG_SHELL_EXCINFO_DUMP
    OsShellCmdTskInfoDataExc(allTaskArray);
#endif
}
 80087cc:	bf00      	nop
 80087ce:	bf00      	nop
 80087d0:	371c      	adds	r7, #28
 80087d2:	46bd      	mov	sp, r7
 80087d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80087d6:	bf00      	nop
 80087d8:	08021268 	.word	0x08021268
 80087dc:	20002170 	.word	0x20002170
 80087e0:	08021280 	.word	0x08021280
 80087e4:	080212b8 	.word	0x080212b8
 80087e8:	20001ff0 	.word	0x20001ff0
 80087ec:	cccccccd 	.word	0xcccccccd
 80087f0:	20002070 	.word	0x20002070
 80087f4:	200020f0 	.word	0x200020f0
 80087f8:	080212c0 	.word	0x080212c0
 80087fc:	080212dc 	.word	0x080212dc
 8008800:	0802119c 	.word	0x0802119c
 8008804:	200036d8 	.word	0x200036d8

08008808 <OsShellCmdTskInfoGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdTskInfoGet(UINT32 taskId)
{
 8008808:	b580      	push	{r7, lr}
 800880a:	b08a      	sub	sp, #40	; 0x28
 800880c:	af00      	add	r7, sp, #0
 800880e:	6078      	str	r0, [r7, #4]
 8008810:	4b4c      	ldr	r3, [pc, #304]	; (8008944 <OsShellCmdTskInfoGet+0x13c>)
 8008812:	681b      	ldr	r3, [r3, #0]
 8008814:	627b      	str	r3, [r7, #36]	; 0x24
 8008816:	f04f 0300 	mov.w	r3, #0
    BOOL backupFlag = TRUE;
 800881a:	2301      	movs	r3, #1
 800881c:	613b      	str	r3, [r7, #16]
    BOOL lockFlag = FALSE;
 800881e:	2300      	movs	r3, #0
 8008820:	617b      	str	r3, [r7, #20]
    UINT32 size, intSave;
    LosTaskCB *tcbArray = NULL;
 8008822:	2300      	movs	r3, #0
 8008824:	61bb      	str	r3, [r7, #24]
    INT32 ret;

    if (taskId == OS_ALL_TASK_MASK) {
 8008826:	687b      	ldr	r3, [r7, #4]
 8008828:	f1b3 3fff 	cmp.w	r3, #4294967295
 800882c:	d17b      	bne.n	8008926 <OsShellCmdTskInfoGet+0x11e>
        size = g_taskMaxNum * sizeof(LosTaskCB);
 800882e:	4b46      	ldr	r3, [pc, #280]	; (8008948 <OsShellCmdTskInfoGet+0x140>)
 8008830:	681a      	ldr	r2, [r3, #0]
 8008832:	4613      	mov	r3, r2
 8008834:	009b      	lsls	r3, r3, #2
 8008836:	4413      	add	r3, r2
 8008838:	015b      	lsls	r3, r3, #5
 800883a:	61fb      	str	r3, [r7, #28]
        tcbArray = (LosTaskCB *)LOS_MemAlloc(m_aucSysMem1, size);
 800883c:	4b43      	ldr	r3, [pc, #268]	; (800894c <OsShellCmdTskInfoGet+0x144>)
 800883e:	681b      	ldr	r3, [r3, #0]
 8008840:	69f9      	ldr	r1, [r7, #28]
 8008842:	4618      	mov	r0, r3
 8008844:	f000 fde6 	bl	8009414 <LOS_MemAlloc>
 8008848:	61b8      	str	r0, [r7, #24]
        if (tcbArray == NULL) {
 800884a:	69bb      	ldr	r3, [r7, #24]
 800884c:	2b00      	cmp	r3, #0
 800884e:	d107      	bne.n	8008860 <OsShellCmdTskInfoGet+0x58>
            PRINTK("Memory is not enough to save task info!\n");
 8008850:	483f      	ldr	r0, [pc, #252]	; (8008950 <OsShellCmdTskInfoGet+0x148>)
 8008852:	f7fc f835 	bl	80048c0 <dprintf>
            tcbArray = g_taskCBArray;
 8008856:	4b3f      	ldr	r3, [pc, #252]	; (8008954 <OsShellCmdTskInfoGet+0x14c>)
 8008858:	681b      	ldr	r3, [r3, #0]
 800885a:	61bb      	str	r3, [r7, #24]
            backupFlag = FALSE;
 800885c:	2300      	movs	r3, #0
 800885e:	613b      	str	r3, [r7, #16]
        }
#ifdef LOSCFG_KERNEL_CPUP
        (VOID)memset_s((VOID *)g_taskCpupAll, sizeof(g_taskCpupAll), 0, sizeof(g_taskCpupAll));
 8008860:	2380      	movs	r3, #128	; 0x80
 8008862:	2200      	movs	r2, #0
 8008864:	2180      	movs	r1, #128	; 0x80
 8008866:	483c      	ldr	r0, [pc, #240]	; (8008958 <OsShellCmdTskInfoGet+0x150>)
 8008868:	f7f9 fc1c 	bl	80020a4 <memset_s>
        (VOID)memset_s((VOID *)g_taskCpup10s, sizeof(g_taskCpup10s), 0, sizeof(g_taskCpup10s));
 800886c:	2380      	movs	r3, #128	; 0x80
 800886e:	2200      	movs	r2, #0
 8008870:	2180      	movs	r1, #128	; 0x80
 8008872:	483a      	ldr	r0, [pc, #232]	; (800895c <OsShellCmdTskInfoGet+0x154>)
 8008874:	f7f9 fc16 	bl	80020a4 <memset_s>
        (VOID)memset_s((VOID *)g_taskCpup1s, sizeof(g_taskCpup1s), 0, sizeof(g_taskCpup1s));
 8008878:	2380      	movs	r3, #128	; 0x80
 800887a:	2200      	movs	r2, #0
 800887c:	2180      	movs	r1, #128	; 0x80
 800887e:	4838      	ldr	r0, [pc, #224]	; (8008960 <OsShellCmdTskInfoGet+0x158>)
 8008880:	f7f9 fc10 	bl	80020a4 <memset_s>
#endif
        (VOID)memset_s((VOID *)g_taskWaterLine, sizeof(g_taskWaterLine), 0, sizeof(g_taskWaterLine));
 8008884:	2340      	movs	r3, #64	; 0x40
 8008886:	2200      	movs	r2, #0
 8008888:	2140      	movs	r1, #64	; 0x40
 800888a:	4836      	ldr	r0, [pc, #216]	; (8008964 <OsShellCmdTskInfoGet+0x15c>)
 800888c:	f7f9 fc0a 	bl	80020a4 <memset_s>

        if (LOS_SpinHeld(&g_taskSpin) == FALSE) {
 8008890:	4835      	ldr	r0, [pc, #212]	; (8008968 <OsShellCmdTskInfoGet+0x160>)
 8008892:	f7ff fdff 	bl	8008494 <LOS_SpinHeld>
 8008896:	4603      	mov	r3, r0
 8008898:	2b00      	cmp	r3, #0
 800889a:	d107      	bne.n	80088ac <OsShellCmdTskInfoGet+0xa4>
            SCHEDULER_LOCK(intSave);
 800889c:	f107 030c 	add.w	r3, r7, #12
 80088a0:	4619      	mov	r1, r3
 80088a2:	4831      	ldr	r0, [pc, #196]	; (8008968 <OsShellCmdTskInfoGet+0x160>)
 80088a4:	f7ff fddc 	bl	8008460 <LOS_SpinLockSave>
            lockFlag = TRUE;
 80088a8:	2301      	movs	r3, #1
 80088aa:	617b      	str	r3, [r7, #20]
        }
        if (backupFlag == TRUE) {
 80088ac:	693b      	ldr	r3, [r7, #16]
 80088ae:	2b01      	cmp	r3, #1
 80088b0:	d10c      	bne.n	80088cc <OsShellCmdTskInfoGet+0xc4>
            ret = memcpy_s(tcbArray, size, g_taskCBArray, size);
 80088b2:	4b28      	ldr	r3, [pc, #160]	; (8008954 <OsShellCmdTskInfoGet+0x14c>)
 80088b4:	681a      	ldr	r2, [r3, #0]
 80088b6:	69fb      	ldr	r3, [r7, #28]
 80088b8:	69f9      	ldr	r1, [r7, #28]
 80088ba:	69b8      	ldr	r0, [r7, #24]
 80088bc:	f00e fbec 	bl	8017098 <memcpy_s>
 80088c0:	6238      	str	r0, [r7, #32]
            if (ret != EOK) {
 80088c2:	6a3b      	ldr	r3, [r7, #32]
 80088c4:	2b00      	cmp	r3, #0
 80088c6:	d001      	beq.n	80088cc <OsShellCmdTskInfoGet+0xc4>
                return LOS_NOK;
 80088c8:	2301      	movs	r3, #1
 80088ca:	e030      	b.n	800892e <OsShellCmdTskInfoGet+0x126>
            }
        }
#ifdef LOSCFG_KERNEL_CPUP
        (VOID)LOS_AllCpuUsage(LOSCFG_BASE_CORE_TSK_LIMIT, g_taskCpupAll, CPUP_ALL_TIME, 1);
 80088cc:	2301      	movs	r3, #1
 80088ce:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80088d2:	4921      	ldr	r1, [pc, #132]	; (8008958 <OsShellCmdTskInfoGet+0x150>)
 80088d4:	2010      	movs	r0, #16
 80088d6:	f00c fae5 	bl	8014ea4 <LOS_AllCpuUsage>
        (VOID)LOS_AllCpuUsage(LOSCFG_BASE_CORE_TSK_LIMIT, g_taskCpup10s, CPUP_LAST_TEN_SECONDS, 1);
 80088da:	2301      	movs	r3, #1
 80088dc:	2200      	movs	r2, #0
 80088de:	491f      	ldr	r1, [pc, #124]	; (800895c <OsShellCmdTskInfoGet+0x154>)
 80088e0:	2010      	movs	r0, #16
 80088e2:	f00c fadf 	bl	8014ea4 <LOS_AllCpuUsage>
        (VOID)LOS_AllCpuUsage(LOSCFG_BASE_CORE_TSK_LIMIT, g_taskCpup1s, CPUP_LAST_ONE_SECONDS, 1);
 80088e6:	2301      	movs	r3, #1
 80088e8:	2201      	movs	r2, #1
 80088ea:	491d      	ldr	r1, [pc, #116]	; (8008960 <OsShellCmdTskInfoGet+0x158>)
 80088ec:	2010      	movs	r0, #16
 80088ee:	f00c fad9 	bl	8014ea4 <LOS_AllCpuUsage>
#endif
        OsShellCmdTaskWaterLineGet(tcbArray);
 80088f2:	69b8      	ldr	r0, [r7, #24]
 80088f4:	f7ff fe2c 	bl	8008550 <OsShellCmdTaskWaterLineGet>

        if (lockFlag == TRUE) {
 80088f8:	697b      	ldr	r3, [r7, #20]
 80088fa:	2b01      	cmp	r3, #1
 80088fc:	d104      	bne.n	8008908 <OsShellCmdTskInfoGet+0x100>
            SCHEDULER_UNLOCK(intSave);
 80088fe:	68fb      	ldr	r3, [r7, #12]
 8008900:	4619      	mov	r1, r3
 8008902:	4819      	ldr	r0, [pc, #100]	; (8008968 <OsShellCmdTskInfoGet+0x160>)
 8008904:	f7ff fdba 	bl	800847c <LOS_SpinUnlockRestore>
        }

        OsShellCmdTskInfoTitle();
 8008908:	f7ff fe5e 	bl	80085c8 <OsShellCmdTskInfoTitle>
        OsShellCmdTskInfoData(tcbArray);
 800890c:	69b8      	ldr	r0, [r7, #24]
 800890e:	f7ff fea5 	bl	800865c <OsShellCmdTskInfoData>

        if (backupFlag == TRUE) {
 8008912:	693b      	ldr	r3, [r7, #16]
 8008914:	2b01      	cmp	r3, #1
 8008916:	d109      	bne.n	800892c <OsShellCmdTskInfoGet+0x124>
            (VOID)LOS_MemFree(m_aucSysMem1, tcbArray);
 8008918:	4b0c      	ldr	r3, [pc, #48]	; (800894c <OsShellCmdTskInfoGet+0x144>)
 800891a:	681b      	ldr	r3, [r3, #0]
 800891c:	69b9      	ldr	r1, [r7, #24]
 800891e:	4618      	mov	r0, r3
 8008920:	f000 fe30 	bl	8009584 <LOS_MemFree>
 8008924:	e002      	b.n	800892c <OsShellCmdTskInfoGet+0x124>
        }
    } else {
        OsTaskBackTrace(taskId);
 8008926:	6878      	ldr	r0, [r7, #4]
 8008928:	f7fb fe0c 	bl	8004544 <LOS_TaskBackTrace>
    }

    return LOS_OK;
 800892c:	2300      	movs	r3, #0
}
 800892e:	4a05      	ldr	r2, [pc, #20]	; (8008944 <OsShellCmdTskInfoGet+0x13c>)
 8008930:	6811      	ldr	r1, [r2, #0]
 8008932:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008934:	4051      	eors	r1, r2
 8008936:	d001      	beq.n	800893c <OsShellCmdTskInfoGet+0x134>
 8008938:	f7fb fe50 	bl	80045dc <__stack_chk_fail>
 800893c:	4618      	mov	r0, r3
 800893e:	3728      	adds	r7, #40	; 0x28
 8008940:	46bd      	mov	sp, r7
 8008942:	bd80      	pop	{r7, pc}
 8008944:	08021314 	.word	0x08021314
 8008948:	200036d8 	.word	0x200036d8
 800894c:	200021c0 	.word	0x200021c0
 8008950:	080212e8 	.word	0x080212e8
 8008954:	200036c4 	.word	0x200036c4
 8008958:	20001ff0 	.word	0x20001ff0
 800895c:	20002070 	.word	0x20002070
 8008960:	200020f0 	.word	0x200020f0
 8008964:	20002170 	.word	0x20002170
 8008968:	20000770 	.word	0x20000770

0800896c <OsShellCmdDumpTask>:

#ifdef LOSCFG_SHELL
LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdDumpTask(INT32 argc, const CHAR **argv)
{
 800896c:	b580      	push	{r7, lr}
 800896e:	b086      	sub	sp, #24
 8008970:	af00      	add	r7, sp, #0
 8008972:	6078      	str	r0, [r7, #4]
 8008974:	6039      	str	r1, [r7, #0]
 8008976:	4b20      	ldr	r3, [pc, #128]	; (80089f8 <OsShellCmdDumpTask+0x8c>)
 8008978:	681b      	ldr	r3, [r3, #0]
 800897a:	617b      	str	r3, [r7, #20]
 800897c:	f04f 0300 	mov.w	r3, #0
    size_t taskId;
    CHAR *endPtr = NULL;
 8008980:	2300      	movs	r3, #0
 8008982:	60fb      	str	r3, [r7, #12]

    if (argc < 2) { /* 2:Just as number of parameters */
 8008984:	687b      	ldr	r3, [r7, #4]
 8008986:	2b01      	cmp	r3, #1
 8008988:	dc26      	bgt.n	80089d8 <OsShellCmdDumpTask+0x6c>
        if (argc == 0) {
 800898a:	687b      	ldr	r3, [r7, #4]
 800898c:	2b00      	cmp	r3, #0
 800898e:	d103      	bne.n	8008998 <OsShellCmdDumpTask+0x2c>
            taskId = OS_ALL_TASK_MASK;
 8008990:	f04f 33ff 	mov.w	r3, #4294967295
 8008994:	613b      	str	r3, [r7, #16]
 8008996:	e01a      	b.n	80089ce <OsShellCmdDumpTask+0x62>
        } else {
            taskId = strtoul(argv[0], &endPtr, 0);
 8008998:	683b      	ldr	r3, [r7, #0]
 800899a:	681b      	ldr	r3, [r3, #0]
 800899c:	f107 010c 	add.w	r1, r7, #12
 80089a0:	2200      	movs	r2, #0
 80089a2:	4618      	mov	r0, r3
 80089a4:	f006 fe56 	bl	800f654 <strtoul>
 80089a8:	6138      	str	r0, [r7, #16]
            if ((*endPtr != 0) || (taskId >= g_taskMaxNum)) {
 80089aa:	68fb      	ldr	r3, [r7, #12]
 80089ac:	781b      	ldrb	r3, [r3, #0]
 80089ae:	2b00      	cmp	r3, #0
 80089b0:	d104      	bne.n	80089bc <OsShellCmdDumpTask+0x50>
 80089b2:	4b12      	ldr	r3, [pc, #72]	; (80089fc <OsShellCmdDumpTask+0x90>)
 80089b4:	681b      	ldr	r3, [r3, #0]
 80089b6:	693a      	ldr	r2, [r7, #16]
 80089b8:	429a      	cmp	r2, r3
 80089ba:	d308      	bcc.n	80089ce <OsShellCmdDumpTask+0x62>
                PRINTK("\ntask ID can't access %s.\n", argv[0]);
 80089bc:	683b      	ldr	r3, [r7, #0]
 80089be:	681b      	ldr	r3, [r3, #0]
 80089c0:	4619      	mov	r1, r3
 80089c2:	480f      	ldr	r0, [pc, #60]	; (8008a00 <OsShellCmdDumpTask+0x94>)
 80089c4:	f7fb ff7c 	bl	80048c0 <dprintf>
                return OS_ERROR;
 80089c8:	f04f 33ff 	mov.w	r3, #4294967295
 80089cc:	e009      	b.n	80089e2 <OsShellCmdDumpTask+0x76>
            }
        }

        return OsShellCmdTskInfoGet((UINT32)taskId);
 80089ce:	6938      	ldr	r0, [r7, #16]
 80089d0:	f7ff ff1a 	bl	8008808 <OsShellCmdTskInfoGet>
 80089d4:	4603      	mov	r3, r0
 80089d6:	e004      	b.n	80089e2 <OsShellCmdDumpTask+0x76>
    } else {
        PRINTK("\nUsage: task or task ID\n");
 80089d8:	480a      	ldr	r0, [pc, #40]	; (8008a04 <OsShellCmdDumpTask+0x98>)
 80089da:	f7fb ff71 	bl	80048c0 <dprintf>
        return OS_ERROR;
 80089de:	f04f 33ff 	mov.w	r3, #4294967295
    }
}
 80089e2:	4a05      	ldr	r2, [pc, #20]	; (80089f8 <OsShellCmdDumpTask+0x8c>)
 80089e4:	6811      	ldr	r1, [r2, #0]
 80089e6:	697a      	ldr	r2, [r7, #20]
 80089e8:	4051      	eors	r1, r2
 80089ea:	d001      	beq.n	80089f0 <OsShellCmdDumpTask+0x84>
 80089ec:	f7fb fdf6 	bl	80045dc <__stack_chk_fail>
 80089f0:	4618      	mov	r0, r3
 80089f2:	3718      	adds	r7, #24
 80089f4:	46bd      	mov	sp, r7
 80089f6:	bd80      	pop	{r7, pc}
 80089f8:	08021350 	.word	0x08021350
 80089fc:	200036d8 	.word	0x200036d8
 8008a00:	08021318 	.word	0x08021318
 8008a04:	08021334 	.word	0x08021334

08008a08 <ArchCurrCpuid>:
{
 8008a08:	b480      	push	{r7}
 8008a0a:	af00      	add	r7, sp, #0
    return 0;
 8008a0c:	2300      	movs	r3, #0
}
 8008a0e:	4618      	mov	r0, r3
 8008a10:	46bd      	mov	sp, r7
 8008a12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a16:	4770      	bx	lr

08008a18 <LOS_IntLock>:
{
 8008a18:	b580      	push	{r7, lr}
 8008a1a:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8008a1c:	f7f8 f954 	bl	8000cc8 <ArchIntLock>
 8008a20:	4603      	mov	r3, r0
}
 8008a22:	4618      	mov	r0, r3
 8008a24:	bd80      	pop	{r7, pc}

08008a26 <LOS_IntRestore>:
{
 8008a26:	b580      	push	{r7, lr}
 8008a28:	b082      	sub	sp, #8
 8008a2a:	af00      	add	r7, sp, #0
 8008a2c:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8008a2e:	6878      	ldr	r0, [r7, #4]
 8008a30:	f7f8 f952 	bl	8000cd8 <ArchIntRestore>
}
 8008a34:	bf00      	nop
 8008a36:	3708      	adds	r7, #8
 8008a38:	46bd      	mov	sp, r7
 8008a3a:	bd80      	pop	{r7, pc}

08008a3c <ArchCurrTaskGet>:
{
 8008a3c:	b480      	push	{r7}
 8008a3e:	af00      	add	r7, sp, #0
    return g_runTask;
 8008a40:	4b03      	ldr	r3, [pc, #12]	; (8008a50 <ArchCurrTaskGet+0x14>)
 8008a42:	681b      	ldr	r3, [r3, #0]
}
 8008a44:	4618      	mov	r0, r3
 8008a46:	46bd      	mov	sp, r7
 8008a48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a4c:	4770      	bx	lr
 8008a4e:	bf00      	nop
 8008a50:	200033cc 	.word	0x200033cc

08008a54 <ArchCurrTaskSet>:
{
 8008a54:	b480      	push	{r7}
 8008a56:	b083      	sub	sp, #12
 8008a58:	af00      	add	r7, sp, #0
 8008a5a:	6078      	str	r0, [r7, #4]
    g_runTask = val;
 8008a5c:	4a04      	ldr	r2, [pc, #16]	; (8008a70 <ArchCurrTaskSet+0x1c>)
 8008a5e:	687b      	ldr	r3, [r7, #4]
 8008a60:	6013      	str	r3, [r2, #0]
}
 8008a62:	bf00      	nop
 8008a64:	370c      	adds	r7, #12
 8008a66:	46bd      	mov	sp, r7
 8008a68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a6c:	4770      	bx	lr
 8008a6e:	bf00      	nop
 8008a70:	200033cc 	.word	0x200033cc

08008a74 <OsPercpuGet>:
{
 8008a74:	b580      	push	{r7, lr}
 8008a76:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 8008a78:	f7ff ffc6 	bl	8008a08 <ArchCurrCpuid>
 8008a7c:	4602      	mov	r2, r0
 8008a7e:	4613      	mov	r3, r2
 8008a80:	00db      	lsls	r3, r3, #3
 8008a82:	4413      	add	r3, r2
 8008a84:	009b      	lsls	r3, r3, #2
 8008a86:	4a02      	ldr	r2, [pc, #8]	; (8008a90 <OsPercpuGet+0x1c>)
 8008a88:	4413      	add	r3, r2
}
 8008a8a:	4618      	mov	r0, r3
 8008a8c:	bd80      	pop	{r7, pc}
 8008a8e:	bf00      	nop
 8008a90:	200036fc 	.word	0x200036fc

08008a94 <OsPreemptable>:
{
 8008a94:	b580      	push	{r7, lr}
 8008a96:	b082      	sub	sp, #8
 8008a98:	af00      	add	r7, sp, #0
    UINT32 intSave = LOS_IntLock();
 8008a9a:	f7ff ffbd 	bl	8008a18 <LOS_IntLock>
 8008a9e:	6038      	str	r0, [r7, #0]
    BOOL preemptable = (OsPercpuGet()->taskLockCnt == 0);
 8008aa0:	f7ff ffe8 	bl	8008a74 <OsPercpuGet>
 8008aa4:	4603      	mov	r3, r0
 8008aa6:	695b      	ldr	r3, [r3, #20]
 8008aa8:	2b00      	cmp	r3, #0
 8008aaa:	bf0c      	ite	eq
 8008aac:	2301      	moveq	r3, #1
 8008aae:	2300      	movne	r3, #0
 8008ab0:	b2db      	uxtb	r3, r3
 8008ab2:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 8008ab4:	687b      	ldr	r3, [r7, #4]
 8008ab6:	2b00      	cmp	r3, #0
 8008ab8:	d104      	bne.n	8008ac4 <OsPreemptable+0x30>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8008aba:	f7ff ffdb 	bl	8008a74 <OsPercpuGet>
 8008abe:	4603      	mov	r3, r0
 8008ac0:	2201      	movs	r2, #1
 8008ac2:	621a      	str	r2, [r3, #32]
    LOS_IntRestore(intSave);
 8008ac4:	6838      	ldr	r0, [r7, #0]
 8008ac6:	f7ff ffae 	bl	8008a26 <LOS_IntRestore>
    return preemptable;
 8008aca:	687b      	ldr	r3, [r7, #4]
}
 8008acc:	4618      	mov	r0, r3
 8008ace:	3708      	adds	r7, #8
 8008ad0:	46bd      	mov	sp, r7
 8008ad2:	bd80      	pop	{r7, pc}

08008ad4 <OsPreemptableInSched>:
{
 8008ad4:	b580      	push	{r7, lr}
 8008ad6:	b082      	sub	sp, #8
 8008ad8:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 8008ada:	2300      	movs	r3, #0
 8008adc:	607b      	str	r3, [r7, #4]
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 8008ade:	f7ff ffc9 	bl	8008a74 <OsPercpuGet>
 8008ae2:	4603      	mov	r3, r0
 8008ae4:	695b      	ldr	r3, [r3, #20]
 8008ae6:	2b00      	cmp	r3, #0
 8008ae8:	bf0c      	ite	eq
 8008aea:	2301      	moveq	r3, #1
 8008aec:	2300      	movne	r3, #0
 8008aee:	b2db      	uxtb	r3, r3
 8008af0:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 8008af2:	687b      	ldr	r3, [r7, #4]
 8008af4:	2b00      	cmp	r3, #0
 8008af6:	d104      	bne.n	8008b02 <OsPreemptableInSched+0x2e>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8008af8:	f7ff ffbc 	bl	8008a74 <OsPercpuGet>
 8008afc:	4603      	mov	r3, r0
 8008afe:	2201      	movs	r2, #1
 8008b00:	621a      	str	r2, [r3, #32]
    return preemptable;
 8008b02:	687b      	ldr	r3, [r7, #4]
}
 8008b04:	4618      	mov	r0, r3
 8008b06:	3708      	adds	r7, #8
 8008b08:	46bd      	mov	sp, r7
 8008b0a:	bd80      	pop	{r7, pc}

08008b0c <LOS_Schedule>:
{
 8008b0c:	b580      	push	{r7, lr}
 8008b0e:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 8008b10:	f7f9 fda6 	bl	8002660 <IntActive>
 8008b14:	4603      	mov	r3, r0
 8008b16:	2b00      	cmp	r3, #0
 8008b18:	d005      	beq.n	8008b26 <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 8008b1a:	f7ff ffab 	bl	8008a74 <OsPercpuGet>
 8008b1e:	4603      	mov	r3, r0
 8008b20:	2201      	movs	r2, #1
 8008b22:	621a      	str	r2, [r3, #32]
        return;
 8008b24:	e001      	b.n	8008b2a <LOS_Schedule+0x1e>
    OsSchedPreempt();
 8008b26:	f000 f905 	bl	8008d34 <OsSchedPreempt>
}
 8008b2a:	bd80      	pop	{r7, pc}

08008b2c <LOS_SpinLockSave>:
{
 8008b2c:	b580      	push	{r7, lr}
 8008b2e:	b082      	sub	sp, #8
 8008b30:	af00      	add	r7, sp, #0
 8008b32:	6078      	str	r0, [r7, #4]
 8008b34:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8008b36:	f7ff ff6f 	bl	8008a18 <LOS_IntLock>
 8008b3a:	4602      	mov	r2, r0
 8008b3c:	683b      	ldr	r3, [r7, #0]
 8008b3e:	601a      	str	r2, [r3, #0]
}
 8008b40:	bf00      	nop
 8008b42:	3708      	adds	r7, #8
 8008b44:	46bd      	mov	sp, r7
 8008b46:	bd80      	pop	{r7, pc}

08008b48 <LOS_SpinUnlockRestore>:
{
 8008b48:	b580      	push	{r7, lr}
 8008b4a:	b082      	sub	sp, #8
 8008b4c:	af00      	add	r7, sp, #0
 8008b4e:	6078      	str	r0, [r7, #4]
 8008b50:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8008b52:	6838      	ldr	r0, [r7, #0]
 8008b54:	f7ff ff67 	bl	8008a26 <LOS_IntRestore>
}
 8008b58:	bf00      	nop
 8008b5a:	3708      	adds	r7, #8
 8008b5c:	46bd      	mov	sp, r7
 8008b5e:	bd80      	pop	{r7, pc}

08008b60 <LOS_SpinHeld>:
{
 8008b60:	b480      	push	{r7}
 8008b62:	b083      	sub	sp, #12
 8008b64:	af00      	add	r7, sp, #0
 8008b66:	6078      	str	r0, [r7, #4]
    return TRUE;
 8008b68:	2301      	movs	r3, #1
}
 8008b6a:	4618      	mov	r0, r3
 8008b6c:	370c      	adds	r7, #12
 8008b6e:	46bd      	mov	sp, r7
 8008b70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b74:	4770      	bx	lr

08008b76 <OsCurrTaskGet>:
{
 8008b76:	b580      	push	{r7, lr}
 8008b78:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 8008b7a:	f7ff ff5f 	bl	8008a3c <ArchCurrTaskGet>
 8008b7e:	4603      	mov	r3, r0
}
 8008b80:	4618      	mov	r0, r3
 8008b82:	bd80      	pop	{r7, pc}

08008b84 <OsCurrTaskSet>:
{
 8008b84:	b580      	push	{r7, lr}
 8008b86:	b082      	sub	sp, #8
 8008b88:	af00      	add	r7, sp, #0
 8008b8a:	6078      	str	r0, [r7, #4]
    ArchCurrTaskSet(task);
 8008b8c:	6878      	ldr	r0, [r7, #4]
 8008b8e:	f7ff ff61 	bl	8008a54 <ArchCurrTaskSet>
}
 8008b92:	bf00      	nop
 8008b94:	3708      	adds	r7, #8
 8008b96:	46bd      	mov	sp, r7
 8008b98:	bd80      	pop	{r7, pc}

08008b9a <OsTaskTimeUpdateHook>:
#endif
}
/* Update the last time the task was executed */
extern VOID OsTaskTimeUpdate(UINT32 taskId, UINT64 tickCount);
STATIC INLINE VOID OsTaskTimeUpdateHook(UINT32 taskId, UINT64 tickCount)
{
 8008b9a:	b580      	push	{r7, lr}
 8008b9c:	b084      	sub	sp, #16
 8008b9e:	af00      	add	r7, sp, #0
 8008ba0:	60f8      	str	r0, [r7, #12]
 8008ba2:	e9c7 2300 	strd	r2, r3, [r7]
#ifdef LOSCFG_DEBUG_MUTEX_DEADLOCK
    OsTaskTimeUpdate(taskId, tickCount);
 8008ba6:	e9d7 2300 	ldrd	r2, r3, [r7]
 8008baa:	68f8      	ldr	r0, [r7, #12]
 8008bac:	f7fd ff42 	bl	8006a34 <OsTaskTimeUpdate>
#endif
}
 8008bb0:	bf00      	nop
 8008bb2:	3710      	adds	r7, #16
 8008bb4:	46bd      	mov	sp, r7
 8008bb6:	bd80      	pop	{r7, pc}

08008bb8 <OsSchedResched>:
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

VOID OsSchedResched(VOID)
{
 8008bb8:	b590      	push	{r4, r7, lr}
 8008bba:	b08b      	sub	sp, #44	; 0x2c
 8008bbc:	af00      	add	r7, sp, #0
 8008bbe:	4b56      	ldr	r3, [pc, #344]	; (8008d18 <OsSchedResched+0x160>)
 8008bc0:	681b      	ldr	r3, [r3, #0]
 8008bc2:	627b      	str	r3, [r7, #36]	; 0x24
 8008bc4:	f04f 0300 	mov.w	r3, #0
    LosTaskCB *runTask = NULL;
 8008bc8:	2300      	movs	r3, #0
 8008bca:	603b      	str	r3, [r7, #0]
    LosTaskCB *newTask = NULL;
 8008bcc:	2300      	movs	r3, #0
 8008bce:	607b      	str	r3, [r7, #4]

    LOS_ASSERT(LOS_SpinHeld(&g_taskSpin));
 8008bd0:	4852      	ldr	r0, [pc, #328]	; (8008d1c <OsSchedResched+0x164>)
 8008bd2:	f7ff ffc5 	bl	8008b60 <LOS_SpinHeld>
 8008bd6:	4603      	mov	r3, r0
 8008bd8:	2b00      	cmp	r3, #0
 8008bda:	d10b      	bne.n	8008bf4 <OsSchedResched+0x3c>
 8008bdc:	f7ff ff1c 	bl	8008a18 <LOS_IntLock>
 8008be0:	484f      	ldr	r0, [pc, #316]	; (8008d20 <OsSchedResched+0x168>)
 8008be2:	f7fb fe6d 	bl	80048c0 <dprintf>
 8008be6:	4b4f      	ldr	r3, [pc, #316]	; (8008d24 <OsSchedResched+0x16c>)
 8008be8:	2233      	movs	r2, #51	; 0x33
 8008bea:	494f      	ldr	r1, [pc, #316]	; (8008d28 <OsSchedResched+0x170>)
 8008bec:	484f      	ldr	r0, [pc, #316]	; (8008d2c <OsSchedResched+0x174>)
 8008bee:	f7fb fe67 	bl	80048c0 <dprintf>
 8008bf2:	e7fe      	b.n	8008bf2 <OsSchedResched+0x3a>

    if (!OsPreemptableInSched()) {
 8008bf4:	f7ff ff6e 	bl	8008ad4 <OsPreemptableInSched>
 8008bf8:	4603      	mov	r3, r0
 8008bfa:	2b00      	cmp	r3, #0
 8008bfc:	d07e      	beq.n	8008cfc <OsSchedResched+0x144>
        return;
    }

    runTask = OsCurrTaskGet();
 8008bfe:	f7ff ffba 	bl	8008b76 <OsCurrTaskGet>
 8008c02:	6038      	str	r0, [r7, #0]
    newTask = OsGetTopTask();
 8008c04:	f000 fac2 	bl	800918c <OsGetTopTask>
 8008c08:	6078      	str	r0, [r7, #4]

    /* always be able to get one task */
    LOS_ASSERT(newTask != NULL);
 8008c0a:	687b      	ldr	r3, [r7, #4]
 8008c0c:	2b00      	cmp	r3, #0
 8008c0e:	d10b      	bne.n	8008c28 <OsSchedResched+0x70>
 8008c10:	f7ff ff02 	bl	8008a18 <LOS_IntLock>
 8008c14:	4842      	ldr	r0, [pc, #264]	; (8008d20 <OsSchedResched+0x168>)
 8008c16:	f7fb fe53 	bl	80048c0 <dprintf>
 8008c1a:	4b42      	ldr	r3, [pc, #264]	; (8008d24 <OsSchedResched+0x16c>)
 8008c1c:	223d      	movs	r2, #61	; 0x3d
 8008c1e:	4942      	ldr	r1, [pc, #264]	; (8008d28 <OsSchedResched+0x170>)
 8008c20:	4842      	ldr	r0, [pc, #264]	; (8008d2c <OsSchedResched+0x174>)
 8008c22:	f7fb fe4d 	bl	80048c0 <dprintf>
 8008c26:	e7fe      	b.n	8008c26 <OsSchedResched+0x6e>

    newTask->taskStatus &= ~OS_TASK_STATUS_READY;
 8008c28:	687b      	ldr	r3, [r7, #4]
 8008c2a:	889b      	ldrh	r3, [r3, #4]
 8008c2c:	f023 0304 	bic.w	r3, r3, #4
 8008c30:	b29a      	uxth	r2, r3
 8008c32:	687b      	ldr	r3, [r7, #4]
 8008c34:	809a      	strh	r2, [r3, #4]

    if (runTask == newTask) {
 8008c36:	683a      	ldr	r2, [r7, #0]
 8008c38:	687b      	ldr	r3, [r7, #4]
 8008c3a:	429a      	cmp	r2, r3
 8008c3c:	d060      	beq.n	8008d00 <OsSchedResched+0x148>
        return;
    }

    runTask->taskStatus &= ~OS_TASK_STATUS_RUNNING;
 8008c3e:	683b      	ldr	r3, [r7, #0]
 8008c40:	889b      	ldrh	r3, [r3, #4]
 8008c42:	f023 0310 	bic.w	r3, r3, #16
 8008c46:	b29a      	uxth	r2, r3
 8008c48:	683b      	ldr	r3, [r7, #0]
 8008c4a:	809a      	strh	r2, [r3, #4]
    newTask->taskStatus |= OS_TASK_STATUS_RUNNING;
 8008c4c:	687b      	ldr	r3, [r7, #4]
 8008c4e:	889b      	ldrh	r3, [r3, #4]
 8008c50:	f043 0310 	orr.w	r3, r3, #16
 8008c54:	b29a      	uxth	r2, r3
 8008c56:	687b      	ldr	r3, [r7, #4]
 8008c58:	809a      	strh	r2, [r3, #4]
    /* mask new running task's owner processor */
    runTask->currCpu = OS_TASK_INVALID_CPUID;
    newTask->currCpu = ArchCurrCpuid();
#endif

    OsTaskTimeUpdateHook(runTask->taskId, LOS_TickCountGet());
 8008c5a:	683b      	ldr	r3, [r7, #0]
 8008c5c:	695c      	ldr	r4, [r3, #20]
 8008c5e:	f7fb fb85 	bl	800436c <LOS_TickCountGet>
 8008c62:	4602      	mov	r2, r0
 8008c64:	460b      	mov	r3, r1
 8008c66:	4620      	mov	r0, r4
 8008c68:	f7ff ff97 	bl	8008b9a <OsTaskTimeUpdateHook>

#ifdef LOSCFG_KERNEL_CPUP
    OsTaskCycleEndStart(newTask);
 8008c6c:	6878      	ldr	r0, [r7, #4]
 8008c6e:	f00b febd 	bl	80149ec <OsTaskCycleEndStart>
#endif

#ifdef LOSCFG_BASE_CORE_TSK_MONITOR
    OsTaskSwitchCheck(runTask, newTask);
 8008c72:	6879      	ldr	r1, [r7, #4]
 8008c74:	6838      	ldr	r0, [r7, #0]
 8008c76:	f7fa fb1f 	bl	80032b8 <OsTaskSwitchCheck>
#endif

    LOS_TRACE(TASK_SWITCH, newTask->taskId, runTask->priority, runTask->taskStatus, newTask->priority,
 8008c7a:	2300      	movs	r3, #0
 8008c7c:	60fb      	str	r3, [r7, #12]
 8008c7e:	687b      	ldr	r3, [r7, #4]
 8008c80:	695b      	ldr	r3, [r3, #20]
 8008c82:	613b      	str	r3, [r7, #16]
 8008c84:	683b      	ldr	r3, [r7, #0]
 8008c86:	88db      	ldrh	r3, [r3, #6]
 8008c88:	617b      	str	r3, [r7, #20]
 8008c8a:	683b      	ldr	r3, [r7, #0]
 8008c8c:	889b      	ldrh	r3, [r3, #4]
 8008c8e:	61bb      	str	r3, [r7, #24]
 8008c90:	687b      	ldr	r3, [r7, #4]
 8008c92:	88db      	ldrh	r3, [r3, #6]
 8008c94:	61fb      	str	r3, [r7, #28]
 8008c96:	687b      	ldr	r3, [r7, #4]
 8008c98:	889b      	ldrh	r3, [r3, #4]
 8008c9a:	623b      	str	r3, [r7, #32]
 8008c9c:	2306      	movs	r3, #6
 8008c9e:	60bb      	str	r3, [r7, #8]
 8008ca0:	68bb      	ldr	r3, [r7, #8]
 8008ca2:	2b01      	cmp	r3, #1
 8008ca4:	d915      	bls.n	8008cd2 <OsSchedResched+0x11a>
 8008ca6:	4b22      	ldr	r3, [pc, #136]	; (8008d30 <OsSchedResched+0x178>)
 8008ca8:	681b      	ldr	r3, [r3, #0]
 8008caa:	2b00      	cmp	r3, #0
 8008cac:	d011      	beq.n	8008cd2 <OsSchedResched+0x11a>
 8008cae:	4b20      	ldr	r3, [pc, #128]	; (8008d30 <OsSchedResched+0x178>)
 8008cb0:	681c      	ldr	r4, [r3, #0]
 8008cb2:	6939      	ldr	r1, [r7, #16]
 8008cb4:	68bb      	ldr	r3, [r7, #8]
 8008cb6:	2b02      	cmp	r3, #2
 8008cb8:	d904      	bls.n	8008cc4 <OsSchedResched+0x10c>
 8008cba:	f107 030c 	add.w	r3, r7, #12
 8008cbe:	f103 0208 	add.w	r2, r3, #8
 8008cc2:	e000      	b.n	8008cc6 <OsSchedResched+0x10e>
 8008cc4:	2200      	movs	r2, #0
 8008cc6:	68bb      	ldr	r3, [r7, #8]
 8008cc8:	b29b      	uxth	r3, r3
 8008cca:	3b02      	subs	r3, #2
 8008ccc:	b29b      	uxth	r3, r3
 8008cce:	2045      	movs	r0, #69	; 0x45
 8008cd0:	47a0      	blx	r4
        newTask->taskStatus);

#ifdef LOSCFG_DEBUG_SCHED_STATISTICS
    OsSchedStatistics(runTask, newTask);
 8008cd2:	6879      	ldr	r1, [r7, #4]
 8008cd4:	6838      	ldr	r0, [r7, #0]
 8008cd6:	f7fe fd8b 	bl	80077f0 <OsSchedStatistics>
#endif

#ifdef LOSCFG_BASE_CORE_TIMESLICE
    if (newTask->timeSlice == 0) {
 8008cda:	687b      	ldr	r3, [r7, #4]
 8008cdc:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8008ce0:	2b00      	cmp	r3, #0
 8008ce2:	d103      	bne.n	8008cec <OsSchedResched+0x134>
        newTask->timeSlice = KERNEL_TIMESLICE_TIMEOUT;
 8008ce4:	687b      	ldr	r3, [r7, #4]
 8008ce6:	2202      	movs	r2, #2
 8008ce8:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
    }
#endif

    OsCurrTaskSet((VOID*)newTask);
 8008cec:	6878      	ldr	r0, [r7, #4]
 8008cee:	f7ff ff49 	bl	8008b84 <OsCurrTaskSet>

    /* do the task context switch */
    OsTaskSchedule(newTask, runTask);
 8008cf2:	6839      	ldr	r1, [r7, #0]
 8008cf4:	6878      	ldr	r0, [r7, #4]
 8008cf6:	f7f7 fff2 	bl	8000cde <OsTaskSchedule>
 8008cfa:	e002      	b.n	8008d02 <OsSchedResched+0x14a>
        return;
 8008cfc:	bf00      	nop
 8008cfe:	e000      	b.n	8008d02 <OsSchedResched+0x14a>
        return;
 8008d00:	bf00      	nop
}
 8008d02:	4b05      	ldr	r3, [pc, #20]	; (8008d18 <OsSchedResched+0x160>)
 8008d04:	681a      	ldr	r2, [r3, #0]
 8008d06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008d08:	405a      	eors	r2, r3
 8008d0a:	d001      	beq.n	8008d10 <OsSchedResched+0x158>
 8008d0c:	f7fb fc66 	bl	80045dc <__stack_chk_fail>
 8008d10:	372c      	adds	r7, #44	; 0x2c
 8008d12:	46bd      	mov	sp, r7
 8008d14:	bd90      	pop	{r4, r7, pc}
 8008d16:	bf00      	nop
 8008d18:	0802139c 	.word	0x0802139c
 8008d1c:	20000770 	.word	0x20000770
 8008d20:	0802135c 	.word	0x0802135c
 8008d24:	0802335c 	.word	0x0802335c
 8008d28:	08021364 	.word	0x08021364
 8008d2c:	08021380 	.word	0x08021380
 8008d30:	20000768 	.word	0x20000768

08008d34 <OsSchedPreempt>:

VOID OsSchedPreempt(VOID)
{
 8008d34:	b580      	push	{r7, lr}
 8008d36:	b084      	sub	sp, #16
 8008d38:	af00      	add	r7, sp, #0
 8008d3a:	4b23      	ldr	r3, [pc, #140]	; (8008dc8 <OsSchedPreempt+0x94>)
 8008d3c:	681b      	ldr	r3, [r3, #0]
 8008d3e:	60fb      	str	r3, [r7, #12]
 8008d40:	f04f 0300 	mov.w	r3, #0
    LosTaskCB *runTask = NULL;
 8008d44:	2300      	movs	r3, #0
 8008d46:	60bb      	str	r3, [r7, #8]
    UINT32 intSave;

    if (!OsPreemptable()) {
 8008d48:	f7ff fea4 	bl	8008a94 <OsPreemptable>
 8008d4c:	4603      	mov	r3, r0
 8008d4e:	2b00      	cmp	r3, #0
 8008d50:	d02e      	beq.n	8008db0 <OsSchedPreempt+0x7c>
        return;
    }

    SCHEDULER_LOCK(intSave);
 8008d52:	1d3b      	adds	r3, r7, #4
 8008d54:	4619      	mov	r1, r3
 8008d56:	481d      	ldr	r0, [pc, #116]	; (8008dcc <OsSchedPreempt+0x98>)
 8008d58:	f7ff fee8 	bl	8008b2c <LOS_SpinLockSave>

    /* add run task back to ready queue */
    runTask = OsCurrTaskGet();
 8008d5c:	f7ff ff0b 	bl	8008b76 <OsCurrTaskGet>
 8008d60:	60b8      	str	r0, [r7, #8]
    runTask->taskStatus |= OS_TASK_STATUS_READY;
 8008d62:	68bb      	ldr	r3, [r7, #8]
 8008d64:	889b      	ldrh	r3, [r3, #4]
 8008d66:	f043 0304 	orr.w	r3, r3, #4
 8008d6a:	b29a      	uxth	r2, r3
 8008d6c:	68bb      	ldr	r3, [r7, #8]
 8008d6e:	809a      	strh	r2, [r3, #4]

#ifdef LOSCFG_BASE_CORE_TIMESLICE
    if (runTask->timeSlice == 0) {
 8008d70:	68bb      	ldr	r3, [r7, #8]
 8008d72:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8008d76:	2b00      	cmp	r3, #0
 8008d78:	d109      	bne.n	8008d8e <OsSchedPreempt+0x5a>
        OsPriQueueEnqueue(&runTask->pendList, runTask->priority);
 8008d7a:	68bb      	ldr	r3, [r7, #8]
 8008d7c:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8008d80:	68bb      	ldr	r3, [r7, #8]
 8008d82:	88db      	ldrh	r3, [r3, #6]
 8008d84:	4619      	mov	r1, r3
 8008d86:	4610      	mov	r0, r2
 8008d88:	f000 f940 	bl	800900c <OsPriQueueEnqueue>
 8008d8c:	e008      	b.n	8008da0 <OsSchedPreempt+0x6c>
    } else {
#endif
        OsPriQueueEnqueueHead(&runTask->pendList, runTask->priority);
 8008d8e:	68bb      	ldr	r3, [r7, #8]
 8008d90:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8008d94:	68bb      	ldr	r3, [r7, #8]
 8008d96:	88db      	ldrh	r3, [r3, #6]
 8008d98:	4619      	mov	r1, r3
 8008d9a:	4610      	mov	r0, r2
 8008d9c:	f000 f8f4 	bl	8008f88 <OsPriQueueEnqueueHead>
#ifdef LOSCFG_BASE_CORE_TIMESLICE
    }
#endif

    /* reschedule to new thread */
    OsSchedResched();
 8008da0:	f7ff ff0a 	bl	8008bb8 <OsSchedResched>

    SCHEDULER_UNLOCK(intSave);
 8008da4:	687b      	ldr	r3, [r7, #4]
 8008da6:	4619      	mov	r1, r3
 8008da8:	4808      	ldr	r0, [pc, #32]	; (8008dcc <OsSchedPreempt+0x98>)
 8008daa:	f7ff fecd 	bl	8008b48 <LOS_SpinUnlockRestore>
 8008dae:	e000      	b.n	8008db2 <OsSchedPreempt+0x7e>
        return;
 8008db0:	bf00      	nop
}
 8008db2:	4b05      	ldr	r3, [pc, #20]	; (8008dc8 <OsSchedPreempt+0x94>)
 8008db4:	681a      	ldr	r2, [r3, #0]
 8008db6:	68fb      	ldr	r3, [r7, #12]
 8008db8:	405a      	eors	r2, r3
 8008dba:	d001      	beq.n	8008dc0 <OsSchedPreempt+0x8c>
 8008dbc:	f7fb fc0e 	bl	80045dc <__stack_chk_fail>
 8008dc0:	3710      	adds	r7, #16
 8008dc2:	46bd      	mov	sp, r7
 8008dc4:	bd80      	pop	{r7, pc}
 8008dc6:	bf00      	nop
 8008dc8:	080213a0 	.word	0x080213a0
 8008dcc:	20000770 	.word	0x20000770

08008dd0 <OsTimesliceCheck>:

#ifdef LOSCFG_BASE_CORE_TIMESLICE
LITE_OS_SEC_TEXT VOID OsTimesliceCheck(VOID)
{
 8008dd0:	b580      	push	{r7, lr}
 8008dd2:	b082      	sub	sp, #8
 8008dd4:	af00      	add	r7, sp, #0
    LosTaskCB *runTask = OsCurrTaskGet();
 8008dd6:	f7ff fece 	bl	8008b76 <OsCurrTaskGet>
 8008dda:	6078      	str	r0, [r7, #4]
    if (runTask->timeSlice != 0) {
 8008ddc:	687b      	ldr	r3, [r7, #4]
 8008dde:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8008de2:	2b00      	cmp	r3, #0
 8008de4:	d00e      	beq.n	8008e04 <OsTimesliceCheck+0x34>
        runTask->timeSlice--;
 8008de6:	687b      	ldr	r3, [r7, #4]
 8008de8:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8008dec:	3b01      	subs	r3, #1
 8008dee:	b29a      	uxth	r2, r3
 8008df0:	687b      	ldr	r3, [r7, #4]
 8008df2:	f8a3 2074 	strh.w	r2, [r3, #116]	; 0x74
        if (runTask->timeSlice == 0) {
 8008df6:	687b      	ldr	r3, [r7, #4]
 8008df8:	f8b3 3074 	ldrh.w	r3, [r3, #116]	; 0x74
 8008dfc:	2b00      	cmp	r3, #0
 8008dfe:	d101      	bne.n	8008e04 <OsTimesliceCheck+0x34>
            LOS_Schedule();
 8008e00:	f7ff fe84 	bl	8008b0c <LOS_Schedule>
        }
    }
}
 8008e04:	bf00      	nop
 8008e06:	3708      	adds	r7, #8
 8008e08:	46bd      	mov	sp, r7
 8008e0a:	bd80      	pop	{r7, pc}

08008e0c <LOS_ListInit>:
{
 8008e0c:	b480      	push	{r7}
 8008e0e:	b083      	sub	sp, #12
 8008e10:	af00      	add	r7, sp, #0
 8008e12:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 8008e14:	687b      	ldr	r3, [r7, #4]
 8008e16:	687a      	ldr	r2, [r7, #4]
 8008e18:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 8008e1a:	687b      	ldr	r3, [r7, #4]
 8008e1c:	687a      	ldr	r2, [r7, #4]
 8008e1e:	601a      	str	r2, [r3, #0]
}
 8008e20:	bf00      	nop
 8008e22:	370c      	adds	r7, #12
 8008e24:	46bd      	mov	sp, r7
 8008e26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e2a:	4770      	bx	lr

08008e2c <LOS_ListAdd>:
{
 8008e2c:	b480      	push	{r7}
 8008e2e:	b083      	sub	sp, #12
 8008e30:	af00      	add	r7, sp, #0
 8008e32:	6078      	str	r0, [r7, #4]
 8008e34:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 8008e36:	687b      	ldr	r3, [r7, #4]
 8008e38:	685a      	ldr	r2, [r3, #4]
 8008e3a:	683b      	ldr	r3, [r7, #0]
 8008e3c:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 8008e3e:	683b      	ldr	r3, [r7, #0]
 8008e40:	687a      	ldr	r2, [r7, #4]
 8008e42:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8008e44:	687b      	ldr	r3, [r7, #4]
 8008e46:	685b      	ldr	r3, [r3, #4]
 8008e48:	683a      	ldr	r2, [r7, #0]
 8008e4a:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 8008e4c:	687b      	ldr	r3, [r7, #4]
 8008e4e:	683a      	ldr	r2, [r7, #0]
 8008e50:	605a      	str	r2, [r3, #4]
}
 8008e52:	bf00      	nop
 8008e54:	370c      	adds	r7, #12
 8008e56:	46bd      	mov	sp, r7
 8008e58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e5c:	4770      	bx	lr

08008e5e <LOS_ListTailInsert>:
{
 8008e5e:	b580      	push	{r7, lr}
 8008e60:	b082      	sub	sp, #8
 8008e62:	af00      	add	r7, sp, #0
 8008e64:	6078      	str	r0, [r7, #4]
 8008e66:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 8008e68:	687b      	ldr	r3, [r7, #4]
 8008e6a:	681b      	ldr	r3, [r3, #0]
 8008e6c:	6839      	ldr	r1, [r7, #0]
 8008e6e:	4618      	mov	r0, r3
 8008e70:	f7ff ffdc 	bl	8008e2c <LOS_ListAdd>
}
 8008e74:	bf00      	nop
 8008e76:	3708      	adds	r7, #8
 8008e78:	46bd      	mov	sp, r7
 8008e7a:	bd80      	pop	{r7, pc}

08008e7c <LOS_ListHeadInsert>:
{
 8008e7c:	b580      	push	{r7, lr}
 8008e7e:	b082      	sub	sp, #8
 8008e80:	af00      	add	r7, sp, #0
 8008e82:	6078      	str	r0, [r7, #4]
 8008e84:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list, node);
 8008e86:	6839      	ldr	r1, [r7, #0]
 8008e88:	6878      	ldr	r0, [r7, #4]
 8008e8a:	f7ff ffcf 	bl	8008e2c <LOS_ListAdd>
}
 8008e8e:	bf00      	nop
 8008e90:	3708      	adds	r7, #8
 8008e92:	46bd      	mov	sp, r7
 8008e94:	bd80      	pop	{r7, pc}

08008e96 <LOS_ListDelete>:
{
 8008e96:	b480      	push	{r7}
 8008e98:	b083      	sub	sp, #12
 8008e9a:	af00      	add	r7, sp, #0
 8008e9c:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8008e9e:	687b      	ldr	r3, [r7, #4]
 8008ea0:	685b      	ldr	r3, [r3, #4]
 8008ea2:	687a      	ldr	r2, [r7, #4]
 8008ea4:	6812      	ldr	r2, [r2, #0]
 8008ea6:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 8008ea8:	687b      	ldr	r3, [r7, #4]
 8008eaa:	681b      	ldr	r3, [r3, #0]
 8008eac:	687a      	ldr	r2, [r7, #4]
 8008eae:	6852      	ldr	r2, [r2, #4]
 8008eb0:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8008eb2:	687b      	ldr	r3, [r7, #4]
 8008eb4:	2200      	movs	r2, #0
 8008eb6:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 8008eb8:	687b      	ldr	r3, [r7, #4]
 8008eba:	2200      	movs	r2, #0
 8008ebc:	601a      	str	r2, [r3, #0]
}
 8008ebe:	bf00      	nop
 8008ec0:	370c      	adds	r7, #12
 8008ec2:	46bd      	mov	sp, r7
 8008ec4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ec8:	4770      	bx	lr

08008eca <LOS_ListEmpty>:
{
 8008eca:	b480      	push	{r7}
 8008ecc:	b083      	sub	sp, #12
 8008ece:	af00      	add	r7, sp, #0
 8008ed0:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8008ed2:	687b      	ldr	r3, [r7, #4]
 8008ed4:	685b      	ldr	r3, [r3, #4]
 8008ed6:	687a      	ldr	r2, [r7, #4]
 8008ed8:	429a      	cmp	r2, r3
 8008eda:	bf0c      	ite	eq
 8008edc:	2301      	moveq	r3, #1
 8008ede:	2300      	movne	r3, #0
 8008ee0:	b2db      	uxtb	r3, r3
}
 8008ee2:	4618      	mov	r0, r3
 8008ee4:	370c      	adds	r7, #12
 8008ee6:	46bd      	mov	sp, r7
 8008ee8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008eec:	4770      	bx	lr

08008eee <ArchIntLocked>:
{
 8008eee:	b480      	push	{r7}
 8008ef0:	b083      	sub	sp, #12
 8008ef2:	af00      	add	r7, sp, #0
    __asm__ volatile("mrs %0, primask" : "=r" (intSave) : : "memory");
 8008ef4:	f3ef 8310 	mrs	r3, PRIMASK
 8008ef8:	607b      	str	r3, [r7, #4]
    return intSave;
 8008efa:	687b      	ldr	r3, [r7, #4]
}
 8008efc:	4618      	mov	r0, r3
 8008efe:	370c      	adds	r7, #12
 8008f00:	46bd      	mov	sp, r7
 8008f02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f06:	4770      	bx	lr

08008f08 <LOS_IntLock>:
{
 8008f08:	b580      	push	{r7, lr}
 8008f0a:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8008f0c:	f7f7 fedc 	bl	8000cc8 <ArchIntLock>
 8008f10:	4603      	mov	r3, r0
}
 8008f12:	4618      	mov	r0, r3
 8008f14:	bd80      	pop	{r7, pc}

08008f16 <LOS_SpinHeld>:
{
 8008f16:	b480      	push	{r7}
 8008f18:	b083      	sub	sp, #12
 8008f1a:	af00      	add	r7, sp, #0
 8008f1c:	6078      	str	r0, [r7, #4]
    return TRUE;
 8008f1e:	2301      	movs	r3, #1
}
 8008f20:	4618      	mov	r0, r3
 8008f22:	370c      	adds	r7, #12
 8008f24:	46bd      	mov	sp, r7
 8008f26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f2a:	4770      	bx	lr

08008f2c <OsPriQueueInit>:

LITE_OS_SEC_BSS LOS_DL_LIST *g_priQueueList = NULL;
STATIC LITE_OS_SEC_BSS UINT32 g_priQueueBitmap;

UINT32 OsPriQueueInit(VOID)
{
 8008f2c:	b580      	push	{r7, lr}
 8008f2e:	b082      	sub	sp, #8
 8008f30:	af00      	add	r7, sp, #0
    UINT32 priority;

    /* system resident resource */
    g_priQueueList = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, (OS_PRIORITY_QUEUE_NUM * sizeof(LOS_DL_LIST)));
 8008f32:	4b13      	ldr	r3, [pc, #76]	; (8008f80 <OsPriQueueInit+0x54>)
 8008f34:	681b      	ldr	r3, [r3, #0]
 8008f36:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008f3a:	4618      	mov	r0, r3
 8008f3c:	f000 fa6a 	bl	8009414 <LOS_MemAlloc>
 8008f40:	4603      	mov	r3, r0
 8008f42:	4a10      	ldr	r2, [pc, #64]	; (8008f84 <OsPriQueueInit+0x58>)
 8008f44:	6013      	str	r3, [r2, #0]
    if (g_priQueueList == NULL) {
 8008f46:	4b0f      	ldr	r3, [pc, #60]	; (8008f84 <OsPriQueueInit+0x58>)
 8008f48:	681b      	ldr	r3, [r3, #0]
 8008f4a:	2b00      	cmp	r3, #0
 8008f4c:	d101      	bne.n	8008f52 <OsPriQueueInit+0x26>
        return LOS_NOK;
 8008f4e:	2301      	movs	r3, #1
 8008f50:	e011      	b.n	8008f76 <OsPriQueueInit+0x4a>
    }

    for (priority = 0; priority < OS_PRIORITY_QUEUE_NUM; ++priority) {
 8008f52:	2300      	movs	r3, #0
 8008f54:	607b      	str	r3, [r7, #4]
 8008f56:	e00a      	b.n	8008f6e <OsPriQueueInit+0x42>
        LOS_ListInit(&g_priQueueList[priority]);
 8008f58:	4b0a      	ldr	r3, [pc, #40]	; (8008f84 <OsPriQueueInit+0x58>)
 8008f5a:	681a      	ldr	r2, [r3, #0]
 8008f5c:	687b      	ldr	r3, [r7, #4]
 8008f5e:	00db      	lsls	r3, r3, #3
 8008f60:	4413      	add	r3, r2
 8008f62:	4618      	mov	r0, r3
 8008f64:	f7ff ff52 	bl	8008e0c <LOS_ListInit>
    for (priority = 0; priority < OS_PRIORITY_QUEUE_NUM; ++priority) {
 8008f68:	687b      	ldr	r3, [r7, #4]
 8008f6a:	3301      	adds	r3, #1
 8008f6c:	607b      	str	r3, [r7, #4]
 8008f6e:	687b      	ldr	r3, [r7, #4]
 8008f70:	2b1f      	cmp	r3, #31
 8008f72:	d9f1      	bls.n	8008f58 <OsPriQueueInit+0x2c>
    }

    return LOS_OK;
 8008f74:	2300      	movs	r3, #0
}
 8008f76:	4618      	mov	r0, r3
 8008f78:	3708      	adds	r7, #8
 8008f7a:	46bd      	mov	sp, r7
 8008f7c:	bd80      	pop	{r7, pc}
 8008f7e:	bf00      	nop
 8008f80:	200021bc 	.word	0x200021bc
 8008f84:	200021b0 	.word	0x200021b0

08008f88 <OsPriQueueEnqueueHead>:

VOID OsPriQueueEnqueueHead(LOS_DL_LIST *priqueueItem, UINT32 priority)
{
 8008f88:	b580      	push	{r7, lr}
 8008f8a:	b082      	sub	sp, #8
 8008f8c:	af00      	add	r7, sp, #0
 8008f8e:	6078      	str	r0, [r7, #4]
 8008f90:	6039      	str	r1, [r7, #0]
    /*
     * Task control blocks are initd as zero. And when task is deleted,
     * and at the same time would be deleted from priority queue or
     * other lists, task pend node will restored as zero.
     */
    LOS_ASSERT(priqueueItem->pstNext == NULL);
 8008f92:	687b      	ldr	r3, [r7, #4]
 8008f94:	685b      	ldr	r3, [r3, #4]
 8008f96:	2b00      	cmp	r3, #0
 8008f98:	d00b      	beq.n	8008fb2 <OsPriQueueEnqueueHead+0x2a>
 8008f9a:	f7ff ffb5 	bl	8008f08 <LOS_IntLock>
 8008f9e:	4815      	ldr	r0, [pc, #84]	; (8008ff4 <OsPriQueueEnqueueHead+0x6c>)
 8008fa0:	f7fb fc8e 	bl	80048c0 <dprintf>
 8008fa4:	4b14      	ldr	r3, [pc, #80]	; (8008ff8 <OsPriQueueEnqueueHead+0x70>)
 8008fa6:	2247      	movs	r2, #71	; 0x47
 8008fa8:	4914      	ldr	r1, [pc, #80]	; (8008ffc <OsPriQueueEnqueueHead+0x74>)
 8008faa:	4815      	ldr	r0, [pc, #84]	; (8009000 <OsPriQueueEnqueueHead+0x78>)
 8008fac:	f7fb fc88 	bl	80048c0 <dprintf>
 8008fb0:	e7fe      	b.n	8008fb0 <OsPriQueueEnqueueHead+0x28>

    if (LOS_ListEmpty(&g_priQueueList[priority])) {
 8008fb2:	4b14      	ldr	r3, [pc, #80]	; (8009004 <OsPriQueueEnqueueHead+0x7c>)
 8008fb4:	681a      	ldr	r2, [r3, #0]
 8008fb6:	683b      	ldr	r3, [r7, #0]
 8008fb8:	00db      	lsls	r3, r3, #3
 8008fba:	4413      	add	r3, r2
 8008fbc:	4618      	mov	r0, r3
 8008fbe:	f7ff ff84 	bl	8008eca <LOS_ListEmpty>
 8008fc2:	4603      	mov	r3, r0
 8008fc4:	2b00      	cmp	r3, #0
 8008fc6:	d008      	beq.n	8008fda <OsPriQueueEnqueueHead+0x52>
        g_priQueueBitmap |= PRIQUEUE_PRIOR0_BIT >> priority;
 8008fc8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8008fcc:	683b      	ldr	r3, [r7, #0]
 8008fce:	40da      	lsrs	r2, r3
 8008fd0:	4b0d      	ldr	r3, [pc, #52]	; (8009008 <OsPriQueueEnqueueHead+0x80>)
 8008fd2:	681b      	ldr	r3, [r3, #0]
 8008fd4:	4313      	orrs	r3, r2
 8008fd6:	4a0c      	ldr	r2, [pc, #48]	; (8009008 <OsPriQueueEnqueueHead+0x80>)
 8008fd8:	6013      	str	r3, [r2, #0]
    }

    LOS_ListHeadInsert(&g_priQueueList[priority], priqueueItem);
 8008fda:	4b0a      	ldr	r3, [pc, #40]	; (8009004 <OsPriQueueEnqueueHead+0x7c>)
 8008fdc:	681a      	ldr	r2, [r3, #0]
 8008fde:	683b      	ldr	r3, [r7, #0]
 8008fe0:	00db      	lsls	r3, r3, #3
 8008fe2:	4413      	add	r3, r2
 8008fe4:	6879      	ldr	r1, [r7, #4]
 8008fe6:	4618      	mov	r0, r3
 8008fe8:	f7ff ff48 	bl	8008e7c <LOS_ListHeadInsert>
}
 8008fec:	bf00      	nop
 8008fee:	3708      	adds	r7, #8
 8008ff0:	46bd      	mov	sp, r7
 8008ff2:	bd80      	pop	{r7, pc}
 8008ff4:	080213a4 	.word	0x080213a4
 8008ff8:	0802336c 	.word	0x0802336c
 8008ffc:	080213ac 	.word	0x080213ac
 8009000:	080213cc 	.word	0x080213cc
 8009004:	200021b0 	.word	0x200021b0
 8009008:	200021b4 	.word	0x200021b4

0800900c <OsPriQueueEnqueue>:

VOID OsPriQueueEnqueue(LOS_DL_LIST *priqueueItem, UINT32 priority)
{
 800900c:	b580      	push	{r7, lr}
 800900e:	b082      	sub	sp, #8
 8009010:	af00      	add	r7, sp, #0
 8009012:	6078      	str	r0, [r7, #4]
 8009014:	6039      	str	r1, [r7, #0]
    /*
     * Task control blocks are initd as zero. And when task is deleted,
     * and at the same time would be deleted from priority queue or
     * other lists, task pend node will restored as zero.
     */
    LOS_ASSERT(priqueueItem->pstNext == NULL);
 8009016:	687b      	ldr	r3, [r7, #4]
 8009018:	685b      	ldr	r3, [r3, #4]
 800901a:	2b00      	cmp	r3, #0
 800901c:	d00b      	beq.n	8009036 <OsPriQueueEnqueue+0x2a>
 800901e:	f7ff ff73 	bl	8008f08 <LOS_IntLock>
 8009022:	4815      	ldr	r0, [pc, #84]	; (8009078 <OsPriQueueEnqueue+0x6c>)
 8009024:	f7fb fc4c 	bl	80048c0 <dprintf>
 8009028:	4b14      	ldr	r3, [pc, #80]	; (800907c <OsPriQueueEnqueue+0x70>)
 800902a:	2257      	movs	r2, #87	; 0x57
 800902c:	4914      	ldr	r1, [pc, #80]	; (8009080 <OsPriQueueEnqueue+0x74>)
 800902e:	4815      	ldr	r0, [pc, #84]	; (8009084 <OsPriQueueEnqueue+0x78>)
 8009030:	f7fb fc46 	bl	80048c0 <dprintf>
 8009034:	e7fe      	b.n	8009034 <OsPriQueueEnqueue+0x28>

    if (LOS_ListEmpty(&g_priQueueList[priority])) {
 8009036:	4b14      	ldr	r3, [pc, #80]	; (8009088 <OsPriQueueEnqueue+0x7c>)
 8009038:	681a      	ldr	r2, [r3, #0]
 800903a:	683b      	ldr	r3, [r7, #0]
 800903c:	00db      	lsls	r3, r3, #3
 800903e:	4413      	add	r3, r2
 8009040:	4618      	mov	r0, r3
 8009042:	f7ff ff42 	bl	8008eca <LOS_ListEmpty>
 8009046:	4603      	mov	r3, r0
 8009048:	2b00      	cmp	r3, #0
 800904a:	d008      	beq.n	800905e <OsPriQueueEnqueue+0x52>
        g_priQueueBitmap |= PRIQUEUE_PRIOR0_BIT >> priority;
 800904c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8009050:	683b      	ldr	r3, [r7, #0]
 8009052:	40da      	lsrs	r2, r3
 8009054:	4b0d      	ldr	r3, [pc, #52]	; (800908c <OsPriQueueEnqueue+0x80>)
 8009056:	681b      	ldr	r3, [r3, #0]
 8009058:	4313      	orrs	r3, r2
 800905a:	4a0c      	ldr	r2, [pc, #48]	; (800908c <OsPriQueueEnqueue+0x80>)
 800905c:	6013      	str	r3, [r2, #0]
    }

    LOS_ListTailInsert(&g_priQueueList[priority], priqueueItem);
 800905e:	4b0a      	ldr	r3, [pc, #40]	; (8009088 <OsPriQueueEnqueue+0x7c>)
 8009060:	681a      	ldr	r2, [r3, #0]
 8009062:	683b      	ldr	r3, [r7, #0]
 8009064:	00db      	lsls	r3, r3, #3
 8009066:	4413      	add	r3, r2
 8009068:	6879      	ldr	r1, [r7, #4]
 800906a:	4618      	mov	r0, r3
 800906c:	f7ff fef7 	bl	8008e5e <LOS_ListTailInsert>
}
 8009070:	bf00      	nop
 8009072:	3708      	adds	r7, #8
 8009074:	46bd      	mov	sp, r7
 8009076:	bd80      	pop	{r7, pc}
 8009078:	080213a4 	.word	0x080213a4
 800907c:	08023384 	.word	0x08023384
 8009080:	080213ac 	.word	0x080213ac
 8009084:	080213cc 	.word	0x080213cc
 8009088:	200021b0 	.word	0x200021b0
 800908c:	200021b4 	.word	0x200021b4

08009090 <OsPriQueueDequeue>:

VOID OsPriQueueDequeue(LOS_DL_LIST *priqueueItem)
{
 8009090:	b580      	push	{r7, lr}
 8009092:	b084      	sub	sp, #16
 8009094:	af00      	add	r7, sp, #0
 8009096:	6078      	str	r0, [r7, #4]
    LosTaskCB *runTask = NULL;
 8009098:	2300      	movs	r3, #0
 800909a:	60fb      	str	r3, [r7, #12]
    LOS_ListDelete(priqueueItem);
 800909c:	6878      	ldr	r0, [r7, #4]
 800909e:	f7ff fefa 	bl	8008e96 <LOS_ListDelete>

    runTask = LOS_DL_LIST_ENTRY(priqueueItem, LosTaskCB, pendList);
 80090a2:	687b      	ldr	r3, [r7, #4]
 80090a4:	3b40      	subs	r3, #64	; 0x40
 80090a6:	60fb      	str	r3, [r7, #12]
    if (LOS_ListEmpty(&g_priQueueList[runTask->priority])) {
 80090a8:	4b0d      	ldr	r3, [pc, #52]	; (80090e0 <OsPriQueueDequeue+0x50>)
 80090aa:	681a      	ldr	r2, [r3, #0]
 80090ac:	68fb      	ldr	r3, [r7, #12]
 80090ae:	88db      	ldrh	r3, [r3, #6]
 80090b0:	00db      	lsls	r3, r3, #3
 80090b2:	4413      	add	r3, r2
 80090b4:	4618      	mov	r0, r3
 80090b6:	f7ff ff08 	bl	8008eca <LOS_ListEmpty>
 80090ba:	4603      	mov	r3, r0
 80090bc:	2b00      	cmp	r3, #0
 80090be:	d00b      	beq.n	80090d8 <OsPriQueueDequeue+0x48>
        g_priQueueBitmap &= ~(PRIQUEUE_PRIOR0_BIT >> runTask->priority);
 80090c0:	68fb      	ldr	r3, [r7, #12]
 80090c2:	88db      	ldrh	r3, [r3, #6]
 80090c4:	461a      	mov	r2, r3
 80090c6:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 80090ca:	40d3      	lsrs	r3, r2
 80090cc:	43da      	mvns	r2, r3
 80090ce:	4b05      	ldr	r3, [pc, #20]	; (80090e4 <OsPriQueueDequeue+0x54>)
 80090d0:	681b      	ldr	r3, [r3, #0]
 80090d2:	4013      	ands	r3, r2
 80090d4:	4a03      	ldr	r2, [pc, #12]	; (80090e4 <OsPriQueueDequeue+0x54>)
 80090d6:	6013      	str	r3, [r2, #0]
    }
}
 80090d8:	bf00      	nop
 80090da:	3710      	adds	r7, #16
 80090dc:	46bd      	mov	sp, r7
 80090de:	bd80      	pop	{r7, pc}
 80090e0:	200021b0 	.word	0x200021b0
 80090e4:	200021b4 	.word	0x200021b4

080090e8 <OsPriQueueSize>:

    return NULL;
}

UINT32 OsPriQueueSize(UINT32 priority)
{
 80090e8:	b580      	push	{r7, lr}
 80090ea:	b084      	sub	sp, #16
 80090ec:	af00      	add	r7, sp, #0
 80090ee:	6078      	str	r0, [r7, #4]
    UINT32 itemCnt = 0;
 80090f0:	2300      	movs	r3, #0
 80090f2:	60bb      	str	r3, [r7, #8]
    LOS_DL_LIST *curNode = NULL;
 80090f4:	2300      	movs	r3, #0
 80090f6:	60fb      	str	r3, [r7, #12]
#ifdef LOSCFG_KERNEL_SMP
    LosTaskCB *task = NULL;
    UINT32 cpuId = ArchCurrCpuid();
#endif

    LOS_ASSERT(ArchIntLocked());
 80090f8:	f7ff fef9 	bl	8008eee <ArchIntLocked>
 80090fc:	4603      	mov	r3, r0
 80090fe:	2b00      	cmp	r3, #0
 8009100:	d10b      	bne.n	800911a <OsPriQueueSize+0x32>
 8009102:	f7ff ff01 	bl	8008f08 <LOS_IntLock>
 8009106:	481b      	ldr	r0, [pc, #108]	; (8009174 <OsPriQueueSize+0x8c>)
 8009108:	f7fb fbda 	bl	80048c0 <dprintf>
 800910c:	4b1a      	ldr	r3, [pc, #104]	; (8009178 <OsPriQueueSize+0x90>)
 800910e:	2280      	movs	r2, #128	; 0x80
 8009110:	491a      	ldr	r1, [pc, #104]	; (800917c <OsPriQueueSize+0x94>)
 8009112:	481b      	ldr	r0, [pc, #108]	; (8009180 <OsPriQueueSize+0x98>)
 8009114:	f7fb fbd4 	bl	80048c0 <dprintf>
 8009118:	e7fe      	b.n	8009118 <OsPriQueueSize+0x30>
    LOS_ASSERT(LOS_SpinHeld(&g_taskSpin));
 800911a:	481a      	ldr	r0, [pc, #104]	; (8009184 <OsPriQueueSize+0x9c>)
 800911c:	f7ff fefb 	bl	8008f16 <LOS_SpinHeld>
 8009120:	4603      	mov	r3, r0
 8009122:	2b00      	cmp	r3, #0
 8009124:	d10b      	bne.n	800913e <OsPriQueueSize+0x56>
 8009126:	f7ff feef 	bl	8008f08 <LOS_IntLock>
 800912a:	4812      	ldr	r0, [pc, #72]	; (8009174 <OsPriQueueSize+0x8c>)
 800912c:	f7fb fbc8 	bl	80048c0 <dprintf>
 8009130:	4b11      	ldr	r3, [pc, #68]	; (8009178 <OsPriQueueSize+0x90>)
 8009132:	2281      	movs	r2, #129	; 0x81
 8009134:	4911      	ldr	r1, [pc, #68]	; (800917c <OsPriQueueSize+0x94>)
 8009136:	4812      	ldr	r0, [pc, #72]	; (8009180 <OsPriQueueSize+0x98>)
 8009138:	f7fb fbc2 	bl	80048c0 <dprintf>
 800913c:	e7fe      	b.n	800913c <OsPriQueueSize+0x54>

    LOS_DL_LIST_FOR_EACH(curNode, &g_priQueueList[priority]) {
 800913e:	4b12      	ldr	r3, [pc, #72]	; (8009188 <OsPriQueueSize+0xa0>)
 8009140:	681a      	ldr	r2, [r3, #0]
 8009142:	687b      	ldr	r3, [r7, #4]
 8009144:	00db      	lsls	r3, r3, #3
 8009146:	4413      	add	r3, r2
 8009148:	685b      	ldr	r3, [r3, #4]
 800914a:	60fb      	str	r3, [r7, #12]
 800914c:	e005      	b.n	800915a <OsPriQueueSize+0x72>
        task = OS_TCB_FROM_PENDLIST(curNode);
        if (!(task->cpuAffiMask & (1U << cpuId))) {
            continue;
        }
#endif
        ++itemCnt;
 800914e:	68bb      	ldr	r3, [r7, #8]
 8009150:	3301      	adds	r3, #1
 8009152:	60bb      	str	r3, [r7, #8]
    LOS_DL_LIST_FOR_EACH(curNode, &g_priQueueList[priority]) {
 8009154:	68fb      	ldr	r3, [r7, #12]
 8009156:	685b      	ldr	r3, [r3, #4]
 8009158:	60fb      	str	r3, [r7, #12]
 800915a:	4b0b      	ldr	r3, [pc, #44]	; (8009188 <OsPriQueueSize+0xa0>)
 800915c:	681a      	ldr	r2, [r3, #0]
 800915e:	687b      	ldr	r3, [r7, #4]
 8009160:	00db      	lsls	r3, r3, #3
 8009162:	4413      	add	r3, r2
 8009164:	68fa      	ldr	r2, [r7, #12]
 8009166:	429a      	cmp	r2, r3
 8009168:	d1f1      	bne.n	800914e <OsPriQueueSize+0x66>
    }

    return itemCnt;
 800916a:	68bb      	ldr	r3, [r7, #8]
}
 800916c:	4618      	mov	r0, r3
 800916e:	3710      	adds	r7, #16
 8009170:	46bd      	mov	sp, r7
 8009172:	bd80      	pop	{r7, pc}
 8009174:	080213a4 	.word	0x080213a4
 8009178:	08023398 	.word	0x08023398
 800917c:	080213ac 	.word	0x080213ac
 8009180:	080213cc 	.word	0x080213cc
 8009184:	20000770 	.word	0x20000770
 8009188:	200021b0 	.word	0x200021b0

0800918c <OsGetTopTask>:

LITE_OS_SEC_TEXT_MINOR LosTaskCB *OsGetTopTask(VOID)
{
 800918c:	b580      	push	{r7, lr}
 800918e:	b084      	sub	sp, #16
 8009190:	af00      	add	r7, sp, #0
    UINT32 priority;
    UINT32 bitmap;
    LosTaskCB *newTask = NULL;
 8009192:	2300      	movs	r3, #0
 8009194:	60bb      	str	r3, [r7, #8]
#ifdef LOSCFG_KERNEL_SMP
    UINT32 cpuid = ArchCurrCpuid();
#endif

    bitmap = g_priQueueBitmap;
 8009196:	4b19      	ldr	r3, [pc, #100]	; (80091fc <OsGetTopTask+0x70>)
 8009198:	681b      	ldr	r3, [r3, #0]
 800919a:	607b      	str	r3, [r7, #4]

    while (bitmap) {
 800919c:	e025      	b.n	80091ea <OsGetTopTask+0x5e>
        priority = CLZ(bitmap);
 800919e:	687b      	ldr	r3, [r7, #4]
 80091a0:	fab3 f383 	clz	r3, r3
 80091a4:	60fb      	str	r3, [r7, #12]
        LOS_DL_LIST_FOR_EACH_ENTRY(newTask, &g_priQueueList[priority], LosTaskCB, pendList) {
 80091a6:	4b16      	ldr	r3, [pc, #88]	; (8009200 <OsGetTopTask+0x74>)
 80091a8:	681a      	ldr	r2, [r3, #0]
 80091aa:	68fb      	ldr	r3, [r7, #12]
 80091ac:	00db      	lsls	r3, r3, #3
 80091ae:	4413      	add	r3, r2
 80091b0:	685b      	ldr	r3, [r3, #4]
 80091b2:	3b40      	subs	r3, #64	; 0x40
 80091b4:	60bb      	str	r3, [r7, #8]
 80091b6:	bf00      	nop
 80091b8:	68bb      	ldr	r3, [r7, #8]
 80091ba:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80091be:	4b10      	ldr	r3, [pc, #64]	; (8009200 <OsGetTopTask+0x74>)
 80091c0:	6819      	ldr	r1, [r3, #0]
 80091c2:	68fb      	ldr	r3, [r7, #12]
 80091c4:	00db      	lsls	r3, r3, #3
 80091c6:	440b      	add	r3, r1
 80091c8:	429a      	cmp	r2, r3
 80091ca:	d005      	beq.n	80091d8 <OsGetTopTask+0x4c>
#ifdef LOSCFG_KERNEL_SMP
            if (newTask->cpuAffiMask & (1U << cpuid)) {
#endif
                OsPriQueueDequeue(&newTask->pendList);
 80091cc:	68bb      	ldr	r3, [r7, #8]
 80091ce:	3340      	adds	r3, #64	; 0x40
 80091d0:	4618      	mov	r0, r3
 80091d2:	f7ff ff5d 	bl	8009090 <OsPriQueueDequeue>
                goto OUT;
 80091d6:	e00c      	b.n	80091f2 <OsGetTopTask+0x66>
#ifdef LOSCFG_KERNEL_SMP
            }
#endif
        }
        bitmap &= ~(1U << (OS_PRIORITY_QUEUE_NUM - priority - 1));
 80091d8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 80091dc:	68fb      	ldr	r3, [r7, #12]
 80091de:	fa22 f303 	lsr.w	r3, r2, r3
 80091e2:	43db      	mvns	r3, r3
 80091e4:	687a      	ldr	r2, [r7, #4]
 80091e6:	4013      	ands	r3, r2
 80091e8:	607b      	str	r3, [r7, #4]
    while (bitmap) {
 80091ea:	687b      	ldr	r3, [r7, #4]
 80091ec:	2b00      	cmp	r3, #0
 80091ee:	d1d6      	bne.n	800919e <OsGetTopTask+0x12>
    }

OUT:
 80091f0:	bf00      	nop
    return newTask;
 80091f2:	68bb      	ldr	r3, [r7, #8]
}
 80091f4:	4618      	mov	r0, r3
 80091f6:	3710      	adds	r7, #16
 80091f8:	46bd      	mov	sp, r7
 80091fa:	bd80      	pop	{r7, pc}
 80091fc:	200021b4 	.word	0x200021b4
 8009200:	200021b0 	.word	0x200021b0

08009204 <OsSlabMemInit>:
extern VOID *OsSlabCtrlHdrGet(const VOID *pool);

#else /* !LOSCFG_KERNEL_MEM_SLAB_EXTENTION */

STATIC INLINE VOID OsSlabMemInit(VOID *pool, UINT32 size)
{
 8009204:	b480      	push	{r7}
 8009206:	b083      	sub	sp, #12
 8009208:	af00      	add	r7, sp, #0
 800920a:	6078      	str	r0, [r7, #4]
 800920c:	6039      	str	r1, [r7, #0]
}
 800920e:	bf00      	nop
 8009210:	370c      	adds	r7, #12
 8009212:	46bd      	mov	sp, r7
 8009214:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009218:	4770      	bx	lr

0800921a <OsSlabMemAlloc>:
STATIC INLINE VOID OsSlabMemDeinit(VOID *pool)
{
}

STATIC INLINE VOID *OsSlabMemAlloc(VOID *pool, UINT32 size)
{
 800921a:	b480      	push	{r7}
 800921c:	b083      	sub	sp, #12
 800921e:	af00      	add	r7, sp, #0
 8009220:	6078      	str	r0, [r7, #4]
 8009222:	6039      	str	r1, [r7, #0]
    return NULL;
 8009224:	2300      	movs	r3, #0
}
 8009226:	4618      	mov	r0, r3
 8009228:	370c      	adds	r7, #12
 800922a:	46bd      	mov	sp, r7
 800922c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009230:	4770      	bx	lr

08009232 <OsSlabMemFree>:

STATIC INLINE BOOL OsSlabMemFree(VOID *pool, VOID *ptr)
{
 8009232:	b480      	push	{r7}
 8009234:	b083      	sub	sp, #12
 8009236:	af00      	add	r7, sp, #0
 8009238:	6078      	str	r0, [r7, #4]
 800923a:	6039      	str	r1, [r7, #0]
    return FALSE;
 800923c:	2300      	movs	r3, #0
}
 800923e:	4618      	mov	r0, r3
 8009240:	370c      	adds	r7, #12
 8009242:	46bd      	mov	sp, r7
 8009244:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009248:	4770      	bx	lr

0800924a <LOS_IntLock>:
{
 800924a:	b580      	push	{r7, lr}
 800924c:	af00      	add	r7, sp, #0
    return ArchIntLock();
 800924e:	f7f7 fd3b 	bl	8000cc8 <ArchIntLock>
 8009252:	4603      	mov	r3, r0
}
 8009254:	4618      	mov	r0, r3
 8009256:	bd80      	pop	{r7, pc}

08009258 <LOS_IntRestore>:
{
 8009258:	b580      	push	{r7, lr}
 800925a:	b082      	sub	sp, #8
 800925c:	af00      	add	r7, sp, #0
 800925e:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8009260:	6878      	ldr	r0, [r7, #4]
 8009262:	f7f7 fd39 	bl	8000cd8 <ArchIntRestore>
}
 8009266:	bf00      	nop
 8009268:	3708      	adds	r7, #8
 800926a:	46bd      	mov	sp, r7
 800926c:	bd80      	pop	{r7, pc}

0800926e <LOS_SpinLockSave>:
{
 800926e:	b580      	push	{r7, lr}
 8009270:	b082      	sub	sp, #8
 8009272:	af00      	add	r7, sp, #0
 8009274:	6078      	str	r0, [r7, #4]
 8009276:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8009278:	f7ff ffe7 	bl	800924a <LOS_IntLock>
 800927c:	4602      	mov	r2, r0
 800927e:	683b      	ldr	r3, [r7, #0]
 8009280:	601a      	str	r2, [r3, #0]
}
 8009282:	bf00      	nop
 8009284:	3708      	adds	r7, #8
 8009286:	46bd      	mov	sp, r7
 8009288:	bd80      	pop	{r7, pc}

0800928a <LOS_SpinUnlockRestore>:
{
 800928a:	b580      	push	{r7, lr}
 800928c:	b082      	sub	sp, #8
 800928e:	af00      	add	r7, sp, #0
 8009290:	6078      	str	r0, [r7, #4]
 8009292:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8009294:	6838      	ldr	r0, [r7, #0]
 8009296:	f7ff ffdf 	bl	8009258 <LOS_IntRestore>
}
 800929a:	bf00      	nop
 800929c:	3708      	adds	r7, #8
 800929e:	46bd      	mov	sp, r7
 80092a0:	bd80      	pop	{r7, pc}

080092a2 <OsMemMulPoolInit>:
extern UINT32 OsMemMulPoolInit(VOID *pool, UINT32 size);
extern UINT32 OsMemMulPoolDeinit(const VOID *pool);
extern VOID *OsMemMulPoolHeadGet(VOID);
#else /* LOSCFG_MEM_MUL_POOL */
STATIC INLINE UINT32 OsMemMulPoolInit(VOID *pool, UINT32 size)
{
 80092a2:	b480      	push	{r7}
 80092a4:	b083      	sub	sp, #12
 80092a6:	af00      	add	r7, sp, #0
 80092a8:	6078      	str	r0, [r7, #4]
 80092aa:	6039      	str	r1, [r7, #0]
    return LOS_OK;
 80092ac:	2300      	movs	r3, #0
}
 80092ae:	4618      	mov	r0, r3
 80092b0:	370c      	adds	r7, #12
 80092b2:	46bd      	mov	sp, r7
 80092b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092b8:	4770      	bx	lr

080092ba <OsMemMulPoolDeinit>:

STATIC INLINE UINT32 OsMemMulPoolDeinit(const VOID *pool)
{
 80092ba:	b480      	push	{r7}
 80092bc:	b083      	sub	sp, #12
 80092be:	af00      	add	r7, sp, #0
 80092c0:	6078      	str	r0, [r7, #4]
    return LOS_OK;
 80092c2:	2300      	movs	r3, #0
}
 80092c4:	4618      	mov	r0, r3
 80092c6:	370c      	adds	r7, #12
 80092c8:	46bd      	mov	sp, r7
 80092ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092ce:	4770      	bx	lr

080092d0 <LOS_MemInit>:
#ifdef LOSCFG_EXC_INTERACTION
__attribute__((section(".data.init"))) UINTPTR g_excInteractMemSize = 0;
#endif

LITE_OS_SEC_TEXT_INIT UINT32 LOS_MemInit(VOID *pool, UINT32 size)
{
 80092d0:	b590      	push	{r4, r7, lr}
 80092d2:	b089      	sub	sp, #36	; 0x24
 80092d4:	af00      	add	r7, sp, #0
 80092d6:	6078      	str	r0, [r7, #4]
 80092d8:	6039      	str	r1, [r7, #0]
 80092da:	4b38      	ldr	r3, [pc, #224]	; (80093bc <LOS_MemInit+0xec>)
 80092dc:	681b      	ldr	r3, [r3, #0]
 80092de:	61fb      	str	r3, [r7, #28]
 80092e0:	f04f 0300 	mov.w	r3, #0
    UINT32 ret = LOS_NOK;
 80092e4:	2301      	movs	r3, #1
 80092e6:	60fb      	str	r3, [r7, #12]
    UINT32 intSave;

    if ((pool == NULL) || (size <= sizeof(struct LosHeapManager))) {
 80092e8:	687b      	ldr	r3, [r7, #4]
 80092ea:	2b00      	cmp	r3, #0
 80092ec:	d002      	beq.n	80092f4 <LOS_MemInit+0x24>
 80092ee:	683b      	ldr	r3, [r7, #0]
 80092f0:	2b9c      	cmp	r3, #156	; 0x9c
 80092f2:	d801      	bhi.n	80092f8 <LOS_MemInit+0x28>
        return ret;
 80092f4:	68fb      	ldr	r3, [r7, #12]
 80092f6:	e055      	b.n	80093a4 <LOS_MemInit+0xd4>
    }

    if (!IS_ALIGNED(size, OS_MEM_ALIGN_SIZE) || !IS_ALIGNED(pool, OS_MEM_ALIGN_SIZE)) {
 80092f8:	683b      	ldr	r3, [r7, #0]
 80092fa:	f003 0303 	and.w	r3, r3, #3
 80092fe:	2b00      	cmp	r3, #0
 8009300:	d104      	bne.n	800930c <LOS_MemInit+0x3c>
 8009302:	687b      	ldr	r3, [r7, #4]
 8009304:	f003 0303 	and.w	r3, r3, #3
 8009308:	2b00      	cmp	r3, #0
 800930a:	d005      	beq.n	8009318 <LOS_MemInit+0x48>
        PRINT_WARN("pool [%p, %p) size 0x%x should be aligned with OS_MEM_ALIGN_SIZE\n",
                   pool, (UINTPTR)pool + size, size);
        size = OS_MEM_ALIGN(size, OS_MEM_ALIGN_SIZE) - OS_MEM_ALIGN_SIZE;
 800930c:	683b      	ldr	r3, [r7, #0]
 800930e:	3303      	adds	r3, #3
 8009310:	f023 0303 	bic.w	r3, r3, #3
 8009314:	3b04      	subs	r3, #4
 8009316:	603b      	str	r3, [r7, #0]
    }

    MEM_LOCK(intSave);
 8009318:	f107 0308 	add.w	r3, r7, #8
 800931c:	4619      	mov	r1, r3
 800931e:	4828      	ldr	r0, [pc, #160]	; (80093c0 <LOS_MemInit+0xf0>)
 8009320:	f7ff ffa5 	bl	800926e <LOS_SpinLockSave>
    if (OsMemMulPoolInit(pool, size) != LOS_OK) {
 8009324:	6839      	ldr	r1, [r7, #0]
 8009326:	6878      	ldr	r0, [r7, #4]
 8009328:	f7ff ffbb 	bl	80092a2 <OsMemMulPoolInit>
 800932c:	4603      	mov	r3, r0
 800932e:	2b00      	cmp	r3, #0
 8009330:	d111      	bne.n	8009356 <LOS_MemInit+0x86>
        goto OUT;
    }

    if (OsHeapInit(pool, size) == FALSE) {
 8009332:	6839      	ldr	r1, [r7, #0]
 8009334:	6878      	ldr	r0, [r7, #4]
 8009336:	f000 fafc 	bl	8009932 <OsHeapInit>
 800933a:	4603      	mov	r3, r0
 800933c:	2b00      	cmp	r3, #0
 800933e:	d103      	bne.n	8009348 <LOS_MemInit+0x78>
        (VOID)OsMemMulPoolDeinit(pool);
 8009340:	6878      	ldr	r0, [r7, #4]
 8009342:	f7ff ffba 	bl	80092ba <OsMemMulPoolDeinit>
        goto OUT;
 8009346:	e007      	b.n	8009358 <LOS_MemInit+0x88>
    }

    OsSlabMemInit(pool, size);
 8009348:	6839      	ldr	r1, [r7, #0]
 800934a:	6878      	ldr	r0, [r7, #4]
 800934c:	f7ff ff5a 	bl	8009204 <OsSlabMemInit>
    ret = LOS_OK;
 8009350:	2300      	movs	r3, #0
 8009352:	60fb      	str	r3, [r7, #12]
 8009354:	e000      	b.n	8009358 <LOS_MemInit+0x88>
        goto OUT;
 8009356:	bf00      	nop
OUT:
    MEM_UNLOCK(intSave);
 8009358:	68bb      	ldr	r3, [r7, #8]
 800935a:	4619      	mov	r1, r3
 800935c:	4818      	ldr	r0, [pc, #96]	; (80093c0 <LOS_MemInit+0xf0>)
 800935e:	f7ff ff94 	bl	800928a <LOS_SpinUnlockRestore>

    LOS_TRACE(MEM_INFO_REQ, pool);
 8009362:	2300      	movs	r3, #0
 8009364:	617b      	str	r3, [r7, #20]
 8009366:	687b      	ldr	r3, [r7, #4]
 8009368:	61bb      	str	r3, [r7, #24]
 800936a:	2302      	movs	r3, #2
 800936c:	613b      	str	r3, [r7, #16]
 800936e:	693b      	ldr	r3, [r7, #16]
 8009370:	2b01      	cmp	r3, #1
 8009372:	d916      	bls.n	80093a2 <LOS_MemInit+0xd2>
 8009374:	4b13      	ldr	r3, [pc, #76]	; (80093c4 <LOS_MemInit+0xf4>)
 8009376:	681b      	ldr	r3, [r3, #0]
 8009378:	2b00      	cmp	r3, #0
 800937a:	d012      	beq.n	80093a2 <LOS_MemInit+0xd2>
 800937c:	4b11      	ldr	r3, [pc, #68]	; (80093c4 <LOS_MemInit+0xf4>)
 800937e:	681c      	ldr	r4, [r3, #0]
 8009380:	69b9      	ldr	r1, [r7, #24]
 8009382:	693b      	ldr	r3, [r7, #16]
 8009384:	2b02      	cmp	r3, #2
 8009386:	d904      	bls.n	8009392 <LOS_MemInit+0xc2>
 8009388:	f107 0314 	add.w	r3, r7, #20
 800938c:	f103 0208 	add.w	r2, r3, #8
 8009390:	e000      	b.n	8009394 <LOS_MemInit+0xc4>
 8009392:	2200      	movs	r2, #0
 8009394:	693b      	ldr	r3, [r7, #16]
 8009396:	b29b      	uxth	r3, r3
 8009398:	3b02      	subs	r3, #2
 800939a:	b29b      	uxth	r3, r3
 800939c:	f44f 7082 	mov.w	r0, #260	; 0x104
 80093a0:	47a0      	blx	r4
    return ret;
 80093a2:	68fb      	ldr	r3, [r7, #12]
}
 80093a4:	4a05      	ldr	r2, [pc, #20]	; (80093bc <LOS_MemInit+0xec>)
 80093a6:	6811      	ldr	r1, [r2, #0]
 80093a8:	69fa      	ldr	r2, [r7, #28]
 80093aa:	4051      	eors	r1, r2
 80093ac:	d001      	beq.n	80093b2 <LOS_MemInit+0xe2>
 80093ae:	f7fb f915 	bl	80045dc <__stack_chk_fail>
 80093b2:	4618      	mov	r0, r3
 80093b4:	3724      	adds	r7, #36	; 0x24
 80093b6:	46bd      	mov	sp, r7
 80093b8:	bd90      	pop	{r4, r7, pc}
 80093ba:	bf00      	nop
 80093bc:	080213e8 	.word	0x080213e8
 80093c0:	200021b8 	.word	0x200021b8
 80093c4:	20000768 	.word	0x20000768

080093c8 <OsMemSystemInit>:
/*
 * Description : Initialize Dynamic Memory pool
 * Return      : LOS_OK on success or error code on failure
 */
LITE_OS_SEC_TEXT_INIT UINT32 OsMemSystemInit(UINTPTR memStart)
{
 80093c8:	b580      	push	{r7, lr}
 80093ca:	b084      	sub	sp, #16
 80093cc:	af00      	add	r7, sp, #0
 80093ce:	6078      	str	r0, [r7, #4]
    UINT32 ret;
    UINT32 memSize;

    m_aucSysMem1 = (UINT8 *)memStart;
 80093d0:	687b      	ldr	r3, [r7, #4]
 80093d2:	4a0c      	ldr	r2, [pc, #48]	; (8009404 <OsMemSystemInit+0x3c>)
 80093d4:	6013      	str	r3, [r2, #0]
    memSize = OS_SYS_MEM_SIZE;
 80093d6:	4b0c      	ldr	r3, [pc, #48]	; (8009408 <OsMemSystemInit+0x40>)
 80093d8:	681a      	ldr	r2, [r3, #0]
 80093da:	4b0c      	ldr	r3, [pc, #48]	; (800940c <OsMemSystemInit+0x44>)
 80093dc:	681b      	ldr	r3, [r3, #0]
 80093de:	1ad3      	subs	r3, r2, r3
 80093e0:	3301      	adds	r3, #1
 80093e2:	60bb      	str	r3, [r7, #8]
    ret = LOS_MemInit((VOID *)m_aucSysMem1, memSize);
 80093e4:	4b07      	ldr	r3, [pc, #28]	; (8009404 <OsMemSystemInit+0x3c>)
 80093e6:	681b      	ldr	r3, [r3, #0]
 80093e8:	68b9      	ldr	r1, [r7, #8]
 80093ea:	4618      	mov	r0, r3
 80093ec:	f7ff ff70 	bl	80092d0 <LOS_MemInit>
 80093f0:	60f8      	str	r0, [r7, #12]
#ifndef LOSCFG_EXC_INTERACTION
    m_aucSysMem0 = m_aucSysMem1;
 80093f2:	4b04      	ldr	r3, [pc, #16]	; (8009404 <OsMemSystemInit+0x3c>)
 80093f4:	681b      	ldr	r3, [r3, #0]
 80093f6:	4a06      	ldr	r2, [pc, #24]	; (8009410 <OsMemSystemInit+0x48>)
 80093f8:	6013      	str	r3, [r2, #0]
#endif
    return ret;
 80093fa:	68fb      	ldr	r3, [r7, #12]
}
 80093fc:	4618      	mov	r0, r3
 80093fe:	3710      	adds	r7, #16
 8009400:	46bd      	mov	sp, r7
 8009402:	bd80      	pop	{r7, pc}
 8009404:	200021c0 	.word	0x200021c0
 8009408:	080001f4 	.word	0x080001f4
 800940c:	080001f0 	.word	0x080001f0
 8009410:	200021bc 	.word	0x200021bc

08009414 <LOS_MemAlloc>:
               pool, heapMan->size, status.totalUsedSize, status.totalFreeSize, status.maxFreeNodeSize,
               status.usedNodeNum, status.freeNodeNum);
}

LITE_OS_SEC_TEXT VOID *LOS_MemAlloc(VOID *pool, UINT32 size)
{
 8009414:	b590      	push	{r4, r7, lr}
 8009416:	b08b      	sub	sp, #44	; 0x2c
 8009418:	af00      	add	r7, sp, #0
 800941a:	6078      	str	r0, [r7, #4]
 800941c:	6039      	str	r1, [r7, #0]
 800941e:	4b2b      	ldr	r3, [pc, #172]	; (80094cc <LOS_MemAlloc+0xb8>)
 8009420:	681b      	ldr	r3, [r3, #0]
 8009422:	627b      	str	r3, [r7, #36]	; 0x24
 8009424:	f04f 0300 	mov.w	r3, #0
    VOID *ptr = NULL;
 8009428:	2300      	movs	r3, #0
 800942a:	60fb      	str	r3, [r7, #12]
    UINT32 intSave;

    if ((pool == NULL) || (size == 0)) {
 800942c:	687b      	ldr	r3, [r7, #4]
 800942e:	2b00      	cmp	r3, #0
 8009430:	d002      	beq.n	8009438 <LOS_MemAlloc+0x24>
 8009432:	683b      	ldr	r3, [r7, #0]
 8009434:	2b00      	cmp	r3, #0
 8009436:	d101      	bne.n	800943c <LOS_MemAlloc+0x28>
        return ptr;
 8009438:	68fb      	ldr	r3, [r7, #12]
 800943a:	e03c      	b.n	80094b6 <LOS_MemAlloc+0xa2>
    }

    MEM_LOCK(intSave);
 800943c:	f107 0308 	add.w	r3, r7, #8
 8009440:	4619      	mov	r1, r3
 8009442:	4823      	ldr	r0, [pc, #140]	; (80094d0 <LOS_MemAlloc+0xbc>)
 8009444:	f7ff ff13 	bl	800926e <LOS_SpinLockSave>

    ptr = OsSlabMemAlloc(pool, size);
 8009448:	6839      	ldr	r1, [r7, #0]
 800944a:	6878      	ldr	r0, [r7, #4]
 800944c:	f7ff fee5 	bl	800921a <OsSlabMemAlloc>
 8009450:	60f8      	str	r0, [r7, #12]
    if (ptr == NULL) {
 8009452:	68fb      	ldr	r3, [r7, #12]
 8009454:	2b00      	cmp	r3, #0
 8009456:	d104      	bne.n	8009462 <LOS_MemAlloc+0x4e>
        ptr = OsHeapAlloc(pool, size);
 8009458:	6839      	ldr	r1, [r7, #0]
 800945a:	6878      	ldr	r0, [r7, #4]
 800945c:	f000 faac 	bl	80099b8 <OsHeapAlloc>
 8009460:	60f8      	str	r0, [r7, #12]
    }

    MEM_UNLOCK(intSave);
 8009462:	68bb      	ldr	r3, [r7, #8]
 8009464:	4619      	mov	r1, r3
 8009466:	481a      	ldr	r0, [pc, #104]	; (80094d0 <LOS_MemAlloc+0xbc>)
 8009468:	f7ff ff0f 	bl	800928a <LOS_SpinUnlockRestore>

    LOS_TRACE(MEM_ALLOC, pool, (UINTPTR)ptr, size);
 800946c:	2300      	movs	r3, #0
 800946e:	617b      	str	r3, [r7, #20]
 8009470:	687b      	ldr	r3, [r7, #4]
 8009472:	61bb      	str	r3, [r7, #24]
 8009474:	68fb      	ldr	r3, [r7, #12]
 8009476:	61fb      	str	r3, [r7, #28]
 8009478:	683b      	ldr	r3, [r7, #0]
 800947a:	623b      	str	r3, [r7, #32]
 800947c:	2304      	movs	r3, #4
 800947e:	613b      	str	r3, [r7, #16]
 8009480:	693b      	ldr	r3, [r7, #16]
 8009482:	2b01      	cmp	r3, #1
 8009484:	d916      	bls.n	80094b4 <LOS_MemAlloc+0xa0>
 8009486:	4b13      	ldr	r3, [pc, #76]	; (80094d4 <LOS_MemAlloc+0xc0>)
 8009488:	681b      	ldr	r3, [r3, #0]
 800948a:	2b00      	cmp	r3, #0
 800948c:	d012      	beq.n	80094b4 <LOS_MemAlloc+0xa0>
 800948e:	4b11      	ldr	r3, [pc, #68]	; (80094d4 <LOS_MemAlloc+0xc0>)
 8009490:	681c      	ldr	r4, [r3, #0]
 8009492:	69b9      	ldr	r1, [r7, #24]
 8009494:	693b      	ldr	r3, [r7, #16]
 8009496:	2b02      	cmp	r3, #2
 8009498:	d904      	bls.n	80094a4 <LOS_MemAlloc+0x90>
 800949a:	f107 0314 	add.w	r3, r7, #20
 800949e:	f103 0208 	add.w	r2, r3, #8
 80094a2:	e000      	b.n	80094a6 <LOS_MemAlloc+0x92>
 80094a4:	2200      	movs	r2, #0
 80094a6:	693b      	ldr	r3, [r7, #16]
 80094a8:	b29b      	uxth	r3, r3
 80094aa:	3b02      	subs	r3, #2
 80094ac:	b29b      	uxth	r3, r3
 80094ae:	f44f 7080 	mov.w	r0, #256	; 0x100
 80094b2:	47a0      	blx	r4
    return ptr;
 80094b4:	68fb      	ldr	r3, [r7, #12]
}
 80094b6:	4a05      	ldr	r2, [pc, #20]	; (80094cc <LOS_MemAlloc+0xb8>)
 80094b8:	6811      	ldr	r1, [r2, #0]
 80094ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80094bc:	4051      	eors	r1, r2
 80094be:	d001      	beq.n	80094c4 <LOS_MemAlloc+0xb0>
 80094c0:	f7fb f88c 	bl	80045dc <__stack_chk_fail>
 80094c4:	4618      	mov	r0, r3
 80094c6:	372c      	adds	r7, #44	; 0x2c
 80094c8:	46bd      	mov	sp, r7
 80094ca:	bd90      	pop	{r4, r7, pc}
 80094cc:	080213f0 	.word	0x080213f0
 80094d0:	200021b8 	.word	0x200021b8
 80094d4:	20000768 	.word	0x20000768

080094d8 <LOS_MemAllocAlign>:

LITE_OS_SEC_TEXT VOID *LOS_MemAllocAlign(VOID *pool, UINT32 size, UINT32 boundary)
{
 80094d8:	b590      	push	{r4, r7, lr}
 80094da:	b08f      	sub	sp, #60	; 0x3c
 80094dc:	af00      	add	r7, sp, #0
 80094de:	60f8      	str	r0, [r7, #12]
 80094e0:	60b9      	str	r1, [r7, #8]
 80094e2:	607a      	str	r2, [r7, #4]
 80094e4:	4b24      	ldr	r3, [pc, #144]	; (8009578 <LOS_MemAllocAlign+0xa0>)
 80094e6:	681b      	ldr	r3, [r3, #0]
 80094e8:	637b      	str	r3, [r7, #52]	; 0x34
 80094ea:	f04f 0300 	mov.w	r3, #0
    VOID *ptr = NULL;
 80094ee:	2300      	movs	r3, #0
 80094f0:	61bb      	str	r3, [r7, #24]
    UINT32 intSave;

    MEM_LOCK(intSave);
 80094f2:	f107 0314 	add.w	r3, r7, #20
 80094f6:	4619      	mov	r1, r3
 80094f8:	4820      	ldr	r0, [pc, #128]	; (800957c <LOS_MemAllocAlign+0xa4>)
 80094fa:	f7ff feb8 	bl	800926e <LOS_SpinLockSave>
    ptr = OsHeapAllocAlign(pool, size, boundary);
 80094fe:	687a      	ldr	r2, [r7, #4]
 8009500:	68b9      	ldr	r1, [r7, #8]
 8009502:	68f8      	ldr	r0, [r7, #12]
 8009504:	f000 fb18 	bl	8009b38 <OsHeapAllocAlign>
 8009508:	61b8      	str	r0, [r7, #24]
    MEM_UNLOCK(intSave);
 800950a:	697b      	ldr	r3, [r7, #20]
 800950c:	4619      	mov	r1, r3
 800950e:	481b      	ldr	r0, [pc, #108]	; (800957c <LOS_MemAllocAlign+0xa4>)
 8009510:	f7ff febb 	bl	800928a <LOS_SpinUnlockRestore>

    LOS_TRACE(MEM_ALLOC_ALIGN, pool, (UINTPTR)ptr, size, boundary);
 8009514:	2300      	movs	r3, #0
 8009516:	623b      	str	r3, [r7, #32]
 8009518:	68fb      	ldr	r3, [r7, #12]
 800951a:	627b      	str	r3, [r7, #36]	; 0x24
 800951c:	69bb      	ldr	r3, [r7, #24]
 800951e:	62bb      	str	r3, [r7, #40]	; 0x28
 8009520:	68bb      	ldr	r3, [r7, #8]
 8009522:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009524:	687b      	ldr	r3, [r7, #4]
 8009526:	633b      	str	r3, [r7, #48]	; 0x30
 8009528:	2305      	movs	r3, #5
 800952a:	61fb      	str	r3, [r7, #28]
 800952c:	69fb      	ldr	r3, [r7, #28]
 800952e:	2b01      	cmp	r3, #1
 8009530:	d916      	bls.n	8009560 <LOS_MemAllocAlign+0x88>
 8009532:	4b13      	ldr	r3, [pc, #76]	; (8009580 <LOS_MemAllocAlign+0xa8>)
 8009534:	681b      	ldr	r3, [r3, #0]
 8009536:	2b00      	cmp	r3, #0
 8009538:	d012      	beq.n	8009560 <LOS_MemAllocAlign+0x88>
 800953a:	4b11      	ldr	r3, [pc, #68]	; (8009580 <LOS_MemAllocAlign+0xa8>)
 800953c:	681c      	ldr	r4, [r3, #0]
 800953e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8009540:	69fb      	ldr	r3, [r7, #28]
 8009542:	2b02      	cmp	r3, #2
 8009544:	d904      	bls.n	8009550 <LOS_MemAllocAlign+0x78>
 8009546:	f107 0320 	add.w	r3, r7, #32
 800954a:	f103 0208 	add.w	r2, r3, #8
 800954e:	e000      	b.n	8009552 <LOS_MemAllocAlign+0x7a>
 8009550:	2200      	movs	r2, #0
 8009552:	69fb      	ldr	r3, [r7, #28]
 8009554:	b29b      	uxth	r3, r3
 8009556:	3b02      	subs	r3, #2
 8009558:	b29b      	uxth	r3, r3
 800955a:	f240 1001 	movw	r0, #257	; 0x101
 800955e:	47a0      	blx	r4
    return ptr;
 8009560:	69bb      	ldr	r3, [r7, #24]
}
 8009562:	4a05      	ldr	r2, [pc, #20]	; (8009578 <LOS_MemAllocAlign+0xa0>)
 8009564:	6811      	ldr	r1, [r2, #0]
 8009566:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009568:	4051      	eors	r1, r2
 800956a:	d001      	beq.n	8009570 <LOS_MemAllocAlign+0x98>
 800956c:	f7fb f836 	bl	80045dc <__stack_chk_fail>
 8009570:	4618      	mov	r0, r3
 8009572:	373c      	adds	r7, #60	; 0x3c
 8009574:	46bd      	mov	sp, r7
 8009576:	bd90      	pop	{r4, r7, pc}
 8009578:	080213f4 	.word	0x080213f4
 800957c:	200021b8 	.word	0x200021b8
 8009580:	20000768 	.word	0x20000768

08009584 <LOS_MemFree>:
    LOS_TRACE(MEM_REALLOC, pool, (UINTPTR)ptr, size);
    return retPtr;
}

LITE_OS_SEC_TEXT UINT32 LOS_MemFree(VOID *pool, VOID *mem)
{
 8009584:	b590      	push	{r4, r7, lr}
 8009586:	b08b      	sub	sp, #44	; 0x2c
 8009588:	af00      	add	r7, sp, #0
 800958a:	6078      	str	r0, [r7, #4]
 800958c:	6039      	str	r1, [r7, #0]
 800958e:	4b2d      	ldr	r3, [pc, #180]	; (8009644 <LOS_MemFree+0xc0>)
 8009590:	681b      	ldr	r3, [r3, #0]
 8009592:	627b      	str	r3, [r7, #36]	; 0x24
 8009594:	f04f 0300 	mov.w	r3, #0
    BOOL ret = FALSE;
 8009598:	2300      	movs	r3, #0
 800959a:	613b      	str	r3, [r7, #16]
    UINT32 intSave;

    if ((pool == NULL) || (mem == NULL)) {
 800959c:	687b      	ldr	r3, [r7, #4]
 800959e:	2b00      	cmp	r3, #0
 80095a0:	d002      	beq.n	80095a8 <LOS_MemFree+0x24>
 80095a2:	683b      	ldr	r3, [r7, #0]
 80095a4:	2b00      	cmp	r3, #0
 80095a6:	d101      	bne.n	80095ac <LOS_MemFree+0x28>
        return LOS_NOK;
 80095a8:	2301      	movs	r3, #1
 80095aa:	e03f      	b.n	800962c <LOS_MemFree+0xa8>
    }

    MEM_LOCK(intSave);
 80095ac:	f107 030c 	add.w	r3, r7, #12
 80095b0:	4619      	mov	r1, r3
 80095b2:	4825      	ldr	r0, [pc, #148]	; (8009648 <LOS_MemFree+0xc4>)
 80095b4:	f7ff fe5b 	bl	800926e <LOS_SpinLockSave>

    ret = OsSlabMemFree(pool, mem);
 80095b8:	6839      	ldr	r1, [r7, #0]
 80095ba:	6878      	ldr	r0, [r7, #4]
 80095bc:	f7ff fe39 	bl	8009232 <OsSlabMemFree>
 80095c0:	6138      	str	r0, [r7, #16]
    if (ret != TRUE) {
 80095c2:	693b      	ldr	r3, [r7, #16]
 80095c4:	2b01      	cmp	r3, #1
 80095c6:	d004      	beq.n	80095d2 <LOS_MemFree+0x4e>
        ret = OsHeapFree(pool, mem);
 80095c8:	6839      	ldr	r1, [r7, #0]
 80095ca:	6878      	ldr	r0, [r7, #4]
 80095cc:	f000 fb5c 	bl	8009c88 <OsHeapFree>
 80095d0:	6138      	str	r0, [r7, #16]
    }

    MEM_UNLOCK(intSave);
 80095d2:	68fb      	ldr	r3, [r7, #12]
 80095d4:	4619      	mov	r1, r3
 80095d6:	481c      	ldr	r0, [pc, #112]	; (8009648 <LOS_MemFree+0xc4>)
 80095d8:	f7ff fe57 	bl	800928a <LOS_SpinUnlockRestore>

    LOS_TRACE(MEM_FREE, pool, (UINTPTR)mem);
 80095dc:	2300      	movs	r3, #0
 80095de:	61bb      	str	r3, [r7, #24]
 80095e0:	687b      	ldr	r3, [r7, #4]
 80095e2:	61fb      	str	r3, [r7, #28]
 80095e4:	683b      	ldr	r3, [r7, #0]
 80095e6:	623b      	str	r3, [r7, #32]
 80095e8:	2303      	movs	r3, #3
 80095ea:	617b      	str	r3, [r7, #20]
 80095ec:	697b      	ldr	r3, [r7, #20]
 80095ee:	2b01      	cmp	r3, #1
 80095f0:	d916      	bls.n	8009620 <LOS_MemFree+0x9c>
 80095f2:	4b16      	ldr	r3, [pc, #88]	; (800964c <LOS_MemFree+0xc8>)
 80095f4:	681b      	ldr	r3, [r3, #0]
 80095f6:	2b00      	cmp	r3, #0
 80095f8:	d012      	beq.n	8009620 <LOS_MemFree+0x9c>
 80095fa:	4b14      	ldr	r3, [pc, #80]	; (800964c <LOS_MemFree+0xc8>)
 80095fc:	681c      	ldr	r4, [r3, #0]
 80095fe:	69f9      	ldr	r1, [r7, #28]
 8009600:	697b      	ldr	r3, [r7, #20]
 8009602:	2b02      	cmp	r3, #2
 8009604:	d904      	bls.n	8009610 <LOS_MemFree+0x8c>
 8009606:	f107 0318 	add.w	r3, r7, #24
 800960a:	f103 0208 	add.w	r2, r3, #8
 800960e:	e000      	b.n	8009612 <LOS_MemFree+0x8e>
 8009610:	2200      	movs	r2, #0
 8009612:	697b      	ldr	r3, [r7, #20]
 8009614:	b29b      	uxth	r3, r3
 8009616:	3b02      	subs	r3, #2
 8009618:	b29b      	uxth	r3, r3
 800961a:	f240 1003 	movw	r0, #259	; 0x103
 800961e:	47a0      	blx	r4
    return (ret == TRUE ? LOS_OK : LOS_NOK);
 8009620:	693b      	ldr	r3, [r7, #16]
 8009622:	2b01      	cmp	r3, #1
 8009624:	bf14      	ite	ne
 8009626:	2301      	movne	r3, #1
 8009628:	2300      	moveq	r3, #0
 800962a:	b2db      	uxtb	r3, r3
}
 800962c:	4a05      	ldr	r2, [pc, #20]	; (8009644 <LOS_MemFree+0xc0>)
 800962e:	6811      	ldr	r1, [r2, #0]
 8009630:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009632:	4051      	eors	r1, r2
 8009634:	d001      	beq.n	800963a <LOS_MemFree+0xb6>
 8009636:	f7fa ffd1 	bl	80045dc <__stack_chk_fail>
 800963a:	4618      	mov	r0, r3
 800963c:	372c      	adds	r7, #44	; 0x2c
 800963e:	46bd      	mov	sp, r7
 8009640:	bd90      	pop	{r4, r7, pc}
 8009642:	bf00      	nop
 8009644:	08021454 	.word	0x08021454
 8009648:	200021b8 	.word	0x200021b8
 800964c:	20000768 	.word	0x20000768

08009650 <LOS_MemInfoGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_MemInfoGet(VOID *pool, LOS_MEM_POOL_STATUS *status)
{
 8009650:	b580      	push	{r7, lr}
 8009652:	b08c      	sub	sp, #48	; 0x30
 8009654:	af00      	add	r7, sp, #0
 8009656:	6078      	str	r0, [r7, #4]
 8009658:	6039      	str	r1, [r7, #0]
 800965a:	4b23      	ldr	r3, [pc, #140]	; (80096e8 <LOS_MemInfoGet+0x98>)
 800965c:	681b      	ldr	r3, [r3, #0]
 800965e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009660:	f04f 0300 	mov.w	r3, #0
    LosHeapStatus heapStatus;
    UINT32 err;
    UINT32 intSave;

    if ((pool == NULL) || (status == NULL)) {
 8009664:	687b      	ldr	r3, [r7, #4]
 8009666:	2b00      	cmp	r3, #0
 8009668:	d002      	beq.n	8009670 <LOS_MemInfoGet+0x20>
 800966a:	683b      	ldr	r3, [r7, #0]
 800966c:	2b00      	cmp	r3, #0
 800966e:	d101      	bne.n	8009674 <LOS_MemInfoGet+0x24>
        return LOS_NOK;
 8009670:	2301      	movs	r3, #1
 8009672:	e02e      	b.n	80096d2 <LOS_MemInfoGet+0x82>
    }

    MEM_LOCK(intSave);
 8009674:	f107 030c 	add.w	r3, r7, #12
 8009678:	4619      	mov	r1, r3
 800967a:	481c      	ldr	r0, [pc, #112]	; (80096ec <LOS_MemInfoGet+0x9c>)
 800967c:	f7ff fdf7 	bl	800926e <LOS_SpinLockSave>

    err = OsHeapStatisticsGet(pool, &heapStatus);
 8009680:	f107 0314 	add.w	r3, r7, #20
 8009684:	4619      	mov	r1, r3
 8009686:	6878      	ldr	r0, [r7, #4]
 8009688:	f000 fb76 	bl	8009d78 <OsHeapStatisticsGet>
 800968c:	6138      	str	r0, [r7, #16]
    if (err != LOS_OK) {
 800968e:	693b      	ldr	r3, [r7, #16]
 8009690:	2b00      	cmp	r3, #0
 8009692:	d006      	beq.n	80096a2 <LOS_MemInfoGet+0x52>
        MEM_UNLOCK(intSave);
 8009694:	68fb      	ldr	r3, [r7, #12]
 8009696:	4619      	mov	r1, r3
 8009698:	4814      	ldr	r0, [pc, #80]	; (80096ec <LOS_MemInfoGet+0x9c>)
 800969a:	f7ff fdf6 	bl	800928a <LOS_SpinUnlockRestore>
        return LOS_NOK;
 800969e:	2301      	movs	r3, #1
 80096a0:	e017      	b.n	80096d2 <LOS_MemInfoGet+0x82>
    }

    status->uwTotalUsedSize   = heapStatus.totalUsedSize;
 80096a2:	697a      	ldr	r2, [r7, #20]
 80096a4:	683b      	ldr	r3, [r7, #0]
 80096a6:	601a      	str	r2, [r3, #0]
    status->uwTotalFreeSize   = heapStatus.totalFreeSize;
 80096a8:	69ba      	ldr	r2, [r7, #24]
 80096aa:	683b      	ldr	r3, [r7, #0]
 80096ac:	605a      	str	r2, [r3, #4]
    status->uwMaxFreeNodeSize = heapStatus.maxFreeNodeSize;
 80096ae:	69fa      	ldr	r2, [r7, #28]
 80096b0:	683b      	ldr	r3, [r7, #0]
 80096b2:	609a      	str	r2, [r3, #8]
    status->uwUsedNodeNum  = heapStatus.usedNodeNum;
 80096b4:	6a3a      	ldr	r2, [r7, #32]
 80096b6:	683b      	ldr	r3, [r7, #0]
 80096b8:	60da      	str	r2, [r3, #12]
    status->uwFreeNodeNum  = heapStatus.freeNodeNum;
 80096ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80096bc:	683b      	ldr	r3, [r7, #0]
 80096be:	611a      	str	r2, [r3, #16]

#ifdef LOSCFG_MEM_TASK_STAT
    status->uwUsageWaterLine = heapStatus.usageWaterLine;
 80096c0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80096c2:	683b      	ldr	r3, [r7, #0]
 80096c4:	615a      	str	r2, [r3, #20]
#endif

    MEM_UNLOCK(intSave);
 80096c6:	68fb      	ldr	r3, [r7, #12]
 80096c8:	4619      	mov	r1, r3
 80096ca:	4808      	ldr	r0, [pc, #32]	; (80096ec <LOS_MemInfoGet+0x9c>)
 80096cc:	f7ff fddd 	bl	800928a <LOS_SpinUnlockRestore>
    return LOS_OK;
 80096d0:	2300      	movs	r3, #0
}
 80096d2:	4a05      	ldr	r2, [pc, #20]	; (80096e8 <LOS_MemInfoGet+0x98>)
 80096d4:	6811      	ldr	r1, [r2, #0]
 80096d6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80096d8:	4051      	eors	r1, r2
 80096da:	d001      	beq.n	80096e0 <LOS_MemInfoGet+0x90>
 80096dc:	f7fa ff7e 	bl	80045dc <__stack_chk_fail>
 80096e0:	4618      	mov	r0, r3
 80096e2:	3730      	adds	r7, #48	; 0x30
 80096e4:	46bd      	mov	sp, r7
 80096e6:	bd80      	pop	{r7, pc}
 80096e8:	08021458 	.word	0x08021458
 80096ec:	200021b8 	.word	0x200021b8

080096f0 <LOS_MemTotalUsedGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_MemTotalUsedGet(VOID *pool)
{
 80096f0:	b580      	push	{r7, lr}
 80096f2:	b08c      	sub	sp, #48	; 0x30
 80096f4:	af00      	add	r7, sp, #0
 80096f6:	6078      	str	r0, [r7, #4]
 80096f8:	4b17      	ldr	r3, [pc, #92]	; (8009758 <LOS_MemTotalUsedGet+0x68>)
 80096fa:	681b      	ldr	r3, [r3, #0]
 80096fc:	62fb      	str	r3, [r7, #44]	; 0x2c
 80096fe:	f04f 0300 	mov.w	r3, #0
    LosHeapStatus heapStatus;
    UINT32 err;
    UINT32 intSave;

    if (pool == NULL) {
 8009702:	687b      	ldr	r3, [r7, #4]
 8009704:	2b00      	cmp	r3, #0
 8009706:	d102      	bne.n	800970e <LOS_MemTotalUsedGet+0x1e>
        return OS_NULL_INT;
 8009708:	f04f 33ff 	mov.w	r3, #4294967295
 800970c:	e018      	b.n	8009740 <LOS_MemTotalUsedGet+0x50>
    }

    MEM_LOCK(intSave);
 800970e:	f107 030c 	add.w	r3, r7, #12
 8009712:	4619      	mov	r1, r3
 8009714:	4811      	ldr	r0, [pc, #68]	; (800975c <LOS_MemTotalUsedGet+0x6c>)
 8009716:	f7ff fdaa 	bl	800926e <LOS_SpinLockSave>
    err = OsHeapStatisticsGet(pool, &heapStatus);
 800971a:	f107 0314 	add.w	r3, r7, #20
 800971e:	4619      	mov	r1, r3
 8009720:	6878      	ldr	r0, [r7, #4]
 8009722:	f000 fb29 	bl	8009d78 <OsHeapStatisticsGet>
 8009726:	6138      	str	r0, [r7, #16]
    MEM_UNLOCK(intSave);
 8009728:	68fb      	ldr	r3, [r7, #12]
 800972a:	4619      	mov	r1, r3
 800972c:	480b      	ldr	r0, [pc, #44]	; (800975c <LOS_MemTotalUsedGet+0x6c>)
 800972e:	f7ff fdac 	bl	800928a <LOS_SpinUnlockRestore>

    if (err != LOS_OK) {
 8009732:	693b      	ldr	r3, [r7, #16]
 8009734:	2b00      	cmp	r3, #0
 8009736:	d002      	beq.n	800973e <LOS_MemTotalUsedGet+0x4e>
        return OS_NULL_INT;
 8009738:	f04f 33ff 	mov.w	r3, #4294967295
 800973c:	e000      	b.n	8009740 <LOS_MemTotalUsedGet+0x50>
    }

    return heapStatus.totalUsedSize;
 800973e:	697b      	ldr	r3, [r7, #20]
}
 8009740:	4a05      	ldr	r2, [pc, #20]	; (8009758 <LOS_MemTotalUsedGet+0x68>)
 8009742:	6811      	ldr	r1, [r2, #0]
 8009744:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009746:	4051      	eors	r1, r2
 8009748:	d001      	beq.n	800974e <LOS_MemTotalUsedGet+0x5e>
 800974a:	f7fa ff47 	bl	80045dc <__stack_chk_fail>
 800974e:	4618      	mov	r0, r3
 8009750:	3730      	adds	r7, #48	; 0x30
 8009752:	46bd      	mov	sp, r7
 8009754:	bd80      	pop	{r7, pc}
 8009756:	bf00      	nop
 8009758:	0802145c 	.word	0x0802145c
 800975c:	200021b8 	.word	0x200021b8

08009760 <LOS_MemPoolSizeGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_MemPoolSizeGet(const VOID *pool)
{
 8009760:	b480      	push	{r7}
 8009762:	b085      	sub	sp, #20
 8009764:	af00      	add	r7, sp, #0
 8009766:	6078      	str	r0, [r7, #4]
    struct LosHeapManager *heapManager = NULL;
 8009768:	2300      	movs	r3, #0
 800976a:	60fb      	str	r3, [r7, #12]

    if (pool == NULL) {
 800976c:	687b      	ldr	r3, [r7, #4]
 800976e:	2b00      	cmp	r3, #0
 8009770:	d102      	bne.n	8009778 <LOS_MemPoolSizeGet+0x18>
        return OS_NULL_INT;
 8009772:	f04f 33ff 	mov.w	r3, #4294967295
 8009776:	e003      	b.n	8009780 <LOS_MemPoolSizeGet+0x20>
    }

    heapManager = (struct LosHeapManager *)pool;
 8009778:	687b      	ldr	r3, [r7, #4]
 800977a:	60fb      	str	r3, [r7, #12]
    return heapManager->size;
 800977c:	68fb      	ldr	r3, [r7, #12]
 800977e:	689b      	ldr	r3, [r3, #8]
}
 8009780:	4618      	mov	r0, r3
 8009782:	3714      	adds	r7, #20
 8009784:	46bd      	mov	sp, r7
 8009786:	f85d 7b04 	ldr.w	r7, [sp], #4
 800978a:	4770      	bx	lr

0800978c <LOS_MemIntegrityCheck>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_MemIntegrityCheck(VOID *pool)
{
 800978c:	b580      	push	{r7, lr}
 800978e:	b086      	sub	sp, #24
 8009790:	af00      	add	r7, sp, #0
 8009792:	6078      	str	r0, [r7, #4]
 8009794:	4b12      	ldr	r3, [pc, #72]	; (80097e0 <LOS_MemIntegrityCheck+0x54>)
 8009796:	681b      	ldr	r3, [r3, #0]
 8009798:	617b      	str	r3, [r7, #20]
 800979a:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 ret;

    if (pool == NULL) {
 800979e:	687b      	ldr	r3, [r7, #4]
 80097a0:	2b00      	cmp	r3, #0
 80097a2:	d102      	bne.n	80097aa <LOS_MemIntegrityCheck+0x1e>
        return OS_NULL_INT;
 80097a4:	f04f 33ff 	mov.w	r3, #4294967295
 80097a8:	e00f      	b.n	80097ca <LOS_MemIntegrityCheck+0x3e>
    }

    MEM_LOCK(intSave);
 80097aa:	f107 030c 	add.w	r3, r7, #12
 80097ae:	4619      	mov	r1, r3
 80097b0:	480c      	ldr	r0, [pc, #48]	; (80097e4 <LOS_MemIntegrityCheck+0x58>)
 80097b2:	f7ff fd5c 	bl	800926e <LOS_SpinLockSave>
    ret = OsHeapIntegrityCheck(pool);
 80097b6:	6878      	ldr	r0, [r7, #4]
 80097b8:	f000 f8b0 	bl	800991c <OsHeapIntegrityCheck>
 80097bc:	6138      	str	r0, [r7, #16]
    MEM_UNLOCK(intSave);
 80097be:	68fb      	ldr	r3, [r7, #12]
 80097c0:	4619      	mov	r1, r3
 80097c2:	4808      	ldr	r0, [pc, #32]	; (80097e4 <LOS_MemIntegrityCheck+0x58>)
 80097c4:	f7ff fd61 	bl	800928a <LOS_SpinUnlockRestore>

    return ret;
 80097c8:	693b      	ldr	r3, [r7, #16]
}
 80097ca:	4a05      	ldr	r2, [pc, #20]	; (80097e0 <LOS_MemIntegrityCheck+0x54>)
 80097cc:	6811      	ldr	r1, [r2, #0]
 80097ce:	697a      	ldr	r2, [r7, #20]
 80097d0:	4051      	eors	r1, r2
 80097d2:	d001      	beq.n	80097d8 <LOS_MemIntegrityCheck+0x4c>
 80097d4:	f7fa ff02 	bl	80045dc <__stack_chk_fail>
 80097d8:	4618      	mov	r0, r3
 80097da:	3718      	adds	r7, #24
 80097dc:	46bd      	mov	sp, r7
 80097de:	bd80      	pop	{r7, pc}
 80097e0:	08021460 	.word	0x08021460
 80097e4:	200021b8 	.word	0x200021b8

080097e8 <OsMemIntegrityMultiCheck>:

VOID OsMemIntegrityMultiCheck(VOID)
{
 80097e8:	b580      	push	{r7, lr}
 80097ea:	af00      	add	r7, sp, #0
    if (LOS_MemIntegrityCheck(m_aucSysMem1) == LOS_OK) {
 80097ec:	4b06      	ldr	r3, [pc, #24]	; (8009808 <OsMemIntegrityMultiCheck+0x20>)
 80097ee:	681b      	ldr	r3, [r3, #0]
 80097f0:	4618      	mov	r0, r3
 80097f2:	f7ff ffcb 	bl	800978c <LOS_MemIntegrityCheck>
 80097f6:	4603      	mov	r3, r0
 80097f8:	2b00      	cmp	r3, #0
 80097fa:	d102      	bne.n	8009802 <OsMemIntegrityMultiCheck+0x1a>
        PRINTK("system memcheck over, all passed!\n");
 80097fc:	4803      	ldr	r0, [pc, #12]	; (800980c <OsMemIntegrityMultiCheck+0x24>)
 80097fe:	f7fb f85f 	bl	80048c0 <dprintf>
#ifdef LOSCFG_SHELL_EXCINFO_DUMP
        WriteExcInfoToBuf("exc interaction memcheck over, all passed!\n");
#endif
    }
#endif
}
 8009802:	bf00      	nop
 8009804:	bd80      	pop	{r7, pc}
 8009806:	bf00      	nop
 8009808:	200021c0 	.word	0x200021c0
 800980c:	08021464 	.word	0x08021464

08009810 <ArchCurrTaskGet>:
{
 8009810:	b480      	push	{r7}
 8009812:	af00      	add	r7, sp, #0
    return g_runTask;
 8009814:	4b03      	ldr	r3, [pc, #12]	; (8009824 <ArchCurrTaskGet+0x14>)
 8009816:	681b      	ldr	r3, [r3, #0]
}
 8009818:	4618      	mov	r0, r3
 800981a:	46bd      	mov	sp, r7
 800981c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009820:	4770      	bx	lr
 8009822:	bf00      	nop
 8009824:	200033cc 	.word	0x200033cc

08009828 <OsCurrTaskGet>:
{
 8009828:	b580      	push	{r7, lr}
 800982a:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 800982c:	f7ff fff0 	bl	8009810 <ArchCurrTaskGet>
 8009830:	4603      	mov	r3, r0
}
 8009832:	4618      	mov	r0, r3
 8009834:	bd80      	pop	{r7, pc}

08009836 <OsHeapPrvGetNext>:
 * Input       : struct LosHeapManager *heapMan --- Pointer to the manager,to distinguish heap
 *               struct LosHeapNode *node --- Size of memory in bytes to allocate
 * Return      : Pointer to next memory node
 */
struct LosHeapNode* OsHeapPrvGetNext(struct LosHeapManager *heapMan, struct LosHeapNode *node)
{
 8009836:	b480      	push	{r7}
 8009838:	b083      	sub	sp, #12
 800983a:	af00      	add	r7, sp, #0
 800983c:	6078      	str	r0, [r7, #4]
 800983e:	6039      	str	r1, [r7, #0]
    return (heapMan->tail == node) ? NULL : (struct LosHeapNode *)(UINTPTR)(node->data + node->size);
 8009840:	687b      	ldr	r3, [r7, #4]
 8009842:	685b      	ldr	r3, [r3, #4]
 8009844:	683a      	ldr	r2, [r7, #0]
 8009846:	429a      	cmp	r2, r3
 8009848:	d007      	beq.n	800985a <OsHeapPrvGetNext+0x24>
 800984a:	683b      	ldr	r3, [r7, #0]
 800984c:	330c      	adds	r3, #12
 800984e:	683a      	ldr	r2, [r7, #0]
 8009850:	6892      	ldr	r2, [r2, #8]
 8009852:	f3c2 021d 	ubfx	r2, r2, #0, #30
 8009856:	4413      	add	r3, r2
 8009858:	e000      	b.n	800985c <OsHeapPrvGetNext+0x26>
 800985a:	2300      	movs	r3, #0
}
 800985c:	4618      	mov	r0, r3
 800985e:	370c      	adds	r7, #12
 8009860:	46bd      	mov	sp, r7
 8009862:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009866:	4770      	bx	lr

08009868 <OsHeapStatInit>:

#ifdef LOSCFG_MEM_TASK_STAT

VOID OsHeapStatInit(struct LosHeapManager *heapMan, UINT32 size)
{
 8009868:	b580      	push	{r7, lr}
 800986a:	b082      	sub	sp, #8
 800986c:	af00      	add	r7, sp, #0
 800986e:	6078      	str	r0, [r7, #4]
 8009870:	6039      	str	r1, [r7, #0]
    (VOID)memset_s(&heapMan->stat, sizeof(Memstat), 0, sizeof(Memstat));
 8009872:	687b      	ldr	r3, [r7, #4]
 8009874:	f103 000c 	add.w	r0, r3, #12
 8009878:	2390      	movs	r3, #144	; 0x90
 800987a:	2200      	movs	r2, #0
 800987c:	2190      	movs	r1, #144	; 0x90
 800987e:	f7f8 fc11 	bl	80020a4 <memset_s>

    heapMan->stat.memTotalUsed = sizeof(struct LosHeapNode) + sizeof(struct LosHeapManager);
 8009882:	687b      	ldr	r3, [r7, #4]
 8009884:	22a8      	movs	r2, #168	; 0xa8
 8009886:	60da      	str	r2, [r3, #12]
    heapMan->stat.memTotalPeak = heapMan->stat.memTotalUsed;
 8009888:	687b      	ldr	r3, [r7, #4]
 800988a:	68da      	ldr	r2, [r3, #12]
 800988c:	687b      	ldr	r3, [r7, #4]
 800988e:	611a      	str	r2, [r3, #16]
}
 8009890:	bf00      	nop
 8009892:	3708      	adds	r7, #8
 8009894:	46bd      	mov	sp, r7
 8009896:	bd80      	pop	{r7, pc}

08009898 <OsHeapStatAddUsed>:

VOID OsHeapStatAddUsed(struct LosHeapManager *heapMan, struct LosHeapNode *node)
{
 8009898:	b580      	push	{r7, lr}
 800989a:	b084      	sub	sp, #16
 800989c:	af00      	add	r7, sp, #0
 800989e:	6078      	str	r0, [r7, #4]
 80098a0:	6039      	str	r1, [r7, #0]
    UINT32 taskId;
    UINT32 blockSize = sizeof(struct LosHeapNode) + node->size;
 80098a2:	683b      	ldr	r3, [r7, #0]
 80098a4:	689b      	ldr	r3, [r3, #8]
 80098a6:	f3c3 031d 	ubfx	r3, r3, #0, #30
 80098aa:	330c      	adds	r3, #12
 80098ac:	60fb      	str	r3, [r7, #12]

    if ((OsCurrTaskGet() != NULL) && OS_INT_INACTIVE) {
 80098ae:	f7ff ffbb 	bl	8009828 <OsCurrTaskGet>
 80098b2:	4603      	mov	r3, r0
 80098b4:	2b00      	cmp	r3, #0
 80098b6:	d008      	beq.n	80098ca <OsHeapStatAddUsed+0x32>
 80098b8:	f7f8 fed2 	bl	8002660 <IntActive>
 80098bc:	4603      	mov	r3, r0
 80098be:	2b00      	cmp	r3, #0
 80098c0:	d103      	bne.n	80098ca <OsHeapStatAddUsed+0x32>
        /*
         * after OsTaskInit, OsCurrTaskGet() is not null, but id is the same
         * as (LOSCFG_BASE_CORE_TSK_LIMIT + 1), so it will be recorded into
         * the last one of the array.
         */
        taskId = LOS_CurTaskIDGet();
 80098c2:	f7f9 fc99 	bl	80031f8 <LOS_CurTaskIDGet>
 80098c6:	60b8      	str	r0, [r7, #8]
 80098c8:	e001      	b.n	80098ce <OsHeapStatAddUsed+0x36>
    } else {
        taskId = TASK_NUM - 1;
 80098ca:	2310      	movs	r3, #16
 80098cc:	60bb      	str	r3, [r7, #8]
    }

    node->taskId = taskId;
 80098ce:	683b      	ldr	r3, [r7, #0]
 80098d0:	68ba      	ldr	r2, [r7, #8]
 80098d2:	605a      	str	r2, [r3, #4]
    OS_MEM_ADD_USED(&heapMan->stat, blockSize, taskId);
 80098d4:	687b      	ldr	r3, [r7, #4]
 80098d6:	330c      	adds	r3, #12
 80098d8:	68ba      	ldr	r2, [r7, #8]
 80098da:	68f9      	ldr	r1, [r7, #12]
 80098dc:	4618      	mov	r0, r3
 80098de:	f000 fabc 	bl	8009e5a <OsMemstatTaskUsedInc>
}
 80098e2:	bf00      	nop
 80098e4:	3710      	adds	r7, #16
 80098e6:	46bd      	mov	sp, r7
 80098e8:	bd80      	pop	{r7, pc}

080098ea <OsHeapStatDecUsed>:

VOID OsHeapStatDecUsed(struct LosHeapManager *heapMan, struct LosHeapNode *node)
{
 80098ea:	b580      	push	{r7, lr}
 80098ec:	b084      	sub	sp, #16
 80098ee:	af00      	add	r7, sp, #0
 80098f0:	6078      	str	r0, [r7, #4]
 80098f2:	6039      	str	r1, [r7, #0]
    UINT32 taskId = node->taskId;
 80098f4:	683b      	ldr	r3, [r7, #0]
 80098f6:	685b      	ldr	r3, [r3, #4]
 80098f8:	60bb      	str	r3, [r7, #8]
    UINT32 blockSize = sizeof(struct LosHeapNode) + node->size;
 80098fa:	683b      	ldr	r3, [r7, #0]
 80098fc:	689b      	ldr	r3, [r3, #8]
 80098fe:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009902:	330c      	adds	r3, #12
 8009904:	60fb      	str	r3, [r7, #12]

    OS_MEM_REDUCE_USED(&heapMan->stat, blockSize, taskId);
 8009906:	687b      	ldr	r3, [r7, #4]
 8009908:	330c      	adds	r3, #12
 800990a:	68ba      	ldr	r2, [r7, #8]
 800990c:	68f9      	ldr	r1, [r7, #12]
 800990e:	4618      	mov	r0, r3
 8009910:	f000 fae4 	bl	8009edc <OsMemstatTaskUsedDec>
}
 8009914:	bf00      	nop
 8009916:	3710      	adds	r7, #16
 8009918:	46bd      	mov	sp, r7
 800991a:	bd80      	pop	{r7, pc}

0800991c <OsHeapIntegrityCheck>:
}

#else /* LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK */

UINT32 OsHeapIntegrityCheck(struct LosHeapManager *heap)
{
 800991c:	b480      	push	{r7}
 800991e:	b083      	sub	sp, #12
 8009920:	af00      	add	r7, sp, #0
 8009922:	6078      	str	r0, [r7, #4]
    return LOS_OK;
 8009924:	2300      	movs	r3, #0
}
 8009926:	4618      	mov	r0, r3
 8009928:	370c      	adds	r7, #12
 800992a:	46bd      	mov	sp, r7
 800992c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009930:	4770      	bx	lr

08009932 <OsHeapInit>:
 * Input       : VOID *pool  --- begin address of the heap memory pool
 *               UITN32 size --- size of the heap memory pool
 * Return      : 1:success 0:error
 */
BOOL OsHeapInit(VOID *pool, UINT32 size)
{
 8009932:	b580      	push	{r7, lr}
 8009934:	b084      	sub	sp, #16
 8009936:	af00      	add	r7, sp, #0
 8009938:	6078      	str	r0, [r7, #4]
 800993a:	6039      	str	r1, [r7, #0]
    struct LosHeapNode *node = NULL;
 800993c:	2300      	movs	r3, #0
 800993e:	60bb      	str	r3, [r7, #8]
    struct LosHeapManager *heapMan = HEAP_CAST(struct LosHeapManager *, pool);
 8009940:	687b      	ldr	r3, [r7, #4]
 8009942:	60fb      	str	r3, [r7, #12]

    if ((heapMan == NULL) || (size <= (sizeof(struct LosHeapNode) + sizeof(struct LosHeapManager)))) {
 8009944:	68fb      	ldr	r3, [r7, #12]
 8009946:	2b00      	cmp	r3, #0
 8009948:	d002      	beq.n	8009950 <OsHeapInit+0x1e>
 800994a:	683b      	ldr	r3, [r7, #0]
 800994c:	2ba8      	cmp	r3, #168	; 0xa8
 800994e:	d801      	bhi.n	8009954 <OsHeapInit+0x22>
        return FALSE;
 8009950:	2300      	movs	r3, #0
 8009952:	e02c      	b.n	80099ae <OsHeapInit+0x7c>
    }

    (VOID)memset_s(pool, size, 0, size);
 8009954:	683b      	ldr	r3, [r7, #0]
 8009956:	2200      	movs	r2, #0
 8009958:	6839      	ldr	r1, [r7, #0]
 800995a:	6878      	ldr	r0, [r7, #4]
 800995c:	f7f8 fba2 	bl	80020a4 <memset_s>

    heapMan->size = size - sizeof(struct LosHeapManager);
 8009960:	683b      	ldr	r3, [r7, #0]
 8009962:	f1a3 029c 	sub.w	r2, r3, #156	; 0x9c
 8009966:	68fb      	ldr	r3, [r7, #12]
 8009968:	609a      	str	r2, [r3, #8]

    node = heapMan->head = (struct LosHeapNode *)((UINT8*)pool + sizeof(struct LosHeapManager));
 800996a:	687b      	ldr	r3, [r7, #4]
 800996c:	f103 029c 	add.w	r2, r3, #156	; 0x9c
 8009970:	68fb      	ldr	r3, [r7, #12]
 8009972:	601a      	str	r2, [r3, #0]
 8009974:	68fb      	ldr	r3, [r7, #12]
 8009976:	681b      	ldr	r3, [r3, #0]
 8009978:	60bb      	str	r3, [r7, #8]

    heapMan->tail = node;
 800997a:	68fb      	ldr	r3, [r7, #12]
 800997c:	68ba      	ldr	r2, [r7, #8]
 800997e:	605a      	str	r2, [r3, #4]

    node->used = 0;
 8009980:	68ba      	ldr	r2, [r7, #8]
 8009982:	7ad3      	ldrb	r3, [r2, #11]
 8009984:	f36f 1386 	bfc	r3, #6, #1
 8009988:	72d3      	strb	r3, [r2, #11]
    node->prev = NULL;
 800998a:	68bb      	ldr	r3, [r7, #8]
 800998c:	2200      	movs	r2, #0
 800998e:	601a      	str	r2, [r3, #0]
    node->size = heapMan->size - sizeof(struct LosHeapNode);
 8009990:	68fb      	ldr	r3, [r7, #12]
 8009992:	689b      	ldr	r3, [r3, #8]
 8009994:	3b0c      	subs	r3, #12
 8009996:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
 800999a:	68ba      	ldr	r2, [r7, #8]
 800999c:	6893      	ldr	r3, [r2, #8]
 800999e:	f361 031d 	bfi	r3, r1, #0, #30
 80099a2:	6093      	str	r3, [r2, #8]

    OsHeapStatInit(heapMan, size);
 80099a4:	6839      	ldr	r1, [r7, #0]
 80099a6:	68f8      	ldr	r0, [r7, #12]
 80099a8:	f7ff ff5e 	bl	8009868 <OsHeapStatInit>

    return TRUE;
 80099ac:	2301      	movs	r3, #1
}
 80099ae:	4618      	mov	r0, r3
 80099b0:	3710      	adds	r7, #16
 80099b2:	46bd      	mov	sp, r7
 80099b4:	bd80      	pop	{r7, pc}
	...

080099b8 <OsHeapAlloc>:
 * Input       : VOID *pool --- Pointer to the manager,to distinguish heap
 *               UINT32 size --- size of the heap memory pool
 * Return      : NULL:error, other value:the address of the memory we alloced
 */
VOID *OsHeapAlloc(VOID *pool, UINT32 size)
{
 80099b8:	b580      	push	{r7, lr}
 80099ba:	b088      	sub	sp, #32
 80099bc:	af00      	add	r7, sp, #0
 80099be:	6078      	str	r0, [r7, #4]
 80099c0:	6039      	str	r1, [r7, #0]
    struct LosHeapNode *node = NULL;
 80099c2:	2300      	movs	r3, #0
 80099c4:	60bb      	str	r3, [r7, #8]
    struct LosHeapNode *next = NULL;
 80099c6:	2300      	movs	r3, #0
 80099c8:	617b      	str	r3, [r7, #20]
    struct LosHeapNode *best = NULL;
 80099ca:	2300      	movs	r3, #0
 80099cc:	60fb      	str	r3, [r7, #12]
    VOID *ptr = NULL;
 80099ce:	2300      	movs	r3, #0
 80099d0:	613b      	str	r3, [r7, #16]
    UINT32 alignSize = ALIGNE(size);
 80099d2:	683b      	ldr	r3, [r7, #0]
 80099d4:	3303      	adds	r3, #3
 80099d6:	f023 0303 	bic.w	r3, r3, #3
 80099da:	61bb      	str	r3, [r7, #24]

    struct LosHeapManager *heapMan = HEAP_CAST(struct LosHeapManager *, pool);
 80099dc:	687b      	ldr	r3, [r7, #4]
 80099de:	61fb      	str	r3, [r7, #28]
    if ((heapMan == NULL) || (size > MALLOC_MAXSIZE)) {
 80099e0:	69fb      	ldr	r3, [r7, #28]
 80099e2:	2b00      	cmp	r3, #0
 80099e4:	d003      	beq.n	80099ee <OsHeapAlloc+0x36>
 80099e6:	683b      	ldr	r3, [r7, #0]
 80099e8:	f113 0f04 	cmn.w	r3, #4
 80099ec:	d901      	bls.n	80099f2 <OsHeapAlloc+0x3a>
        return NULL;
 80099ee:	2300      	movs	r3, #0
 80099f0:	e09a      	b.n	8009b28 <OsHeapAlloc+0x170>
    }

    if (OsHeapIntegrityCheck(heapMan) != LOS_OK) {
 80099f2:	69f8      	ldr	r0, [r7, #28]
 80099f4:	f7ff ff92 	bl	800991c <OsHeapIntegrityCheck>
 80099f8:	4603      	mov	r3, r0
 80099fa:	2b00      	cmp	r3, #0
 80099fc:	d001      	beq.n	8009a02 <OsHeapAlloc+0x4a>
        return NULL;
 80099fe:	2300      	movs	r3, #0
 8009a00:	e092      	b.n	8009b28 <OsHeapAlloc+0x170>
    }

    node = heapMan->tail;
 8009a02:	69fb      	ldr	r3, [r7, #28]
 8009a04:	685b      	ldr	r3, [r3, #4]
 8009a06:	60bb      	str	r3, [r7, #8]
    while (node != NULL) {
 8009a08:	e028      	b.n	8009a5c <OsHeapAlloc+0xa4>
        if ((node->used == 0) && (node->size >= alignSize) &&
 8009a0a:	68bb      	ldr	r3, [r7, #8]
 8009a0c:	7adb      	ldrb	r3, [r3, #11]
 8009a0e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009a12:	b2db      	uxtb	r3, r3
 8009a14:	2b00      	cmp	r3, #0
 8009a16:	d11e      	bne.n	8009a56 <OsHeapAlloc+0x9e>
 8009a18:	68bb      	ldr	r3, [r7, #8]
 8009a1a:	689b      	ldr	r3, [r3, #8]
 8009a1c:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009a20:	461a      	mov	r2, r3
 8009a22:	69bb      	ldr	r3, [r7, #24]
 8009a24:	4293      	cmp	r3, r2
 8009a26:	d816      	bhi.n	8009a56 <OsHeapAlloc+0x9e>
 8009a28:	68fb      	ldr	r3, [r7, #12]
 8009a2a:	2b00      	cmp	r3, #0
 8009a2c:	d009      	beq.n	8009a42 <OsHeapAlloc+0x8a>
            ((best == NULL) || (best->size > node->size))) {
 8009a2e:	68fb      	ldr	r3, [r7, #12]
 8009a30:	689b      	ldr	r3, [r3, #8]
 8009a32:	f3c3 021d 	ubfx	r2, r3, #0, #30
 8009a36:	68bb      	ldr	r3, [r7, #8]
 8009a38:	689b      	ldr	r3, [r3, #8]
 8009a3a:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009a3e:	429a      	cmp	r2, r3
 8009a40:	d909      	bls.n	8009a56 <OsHeapAlloc+0x9e>
            best = node;
 8009a42:	68bb      	ldr	r3, [r7, #8]
 8009a44:	60fb      	str	r3, [r7, #12]
            if (best->size == alignSize) {
 8009a46:	68fb      	ldr	r3, [r7, #12]
 8009a48:	689b      	ldr	r3, [r3, #8]
 8009a4a:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009a4e:	461a      	mov	r2, r3
 8009a50:	69bb      	ldr	r3, [r7, #24]
 8009a52:	4293      	cmp	r3, r2
 8009a54:	d053      	beq.n	8009afe <OsHeapAlloc+0x146>
                goto SIZE_MATCH;
            }
        }
        node = node->prev;
 8009a56:	68bb      	ldr	r3, [r7, #8]
 8009a58:	681b      	ldr	r3, [r3, #0]
 8009a5a:	60bb      	str	r3, [r7, #8]
    while (node != NULL) {
 8009a5c:	68bb      	ldr	r3, [r7, #8]
 8009a5e:	2b00      	cmp	r3, #0
 8009a60:	d1d3      	bne.n	8009a0a <OsHeapAlloc+0x52>
    }

    /* alloc failed */
    if (best == NULL) {
 8009a62:	68fb      	ldr	r3, [r7, #12]
 8009a64:	2b00      	cmp	r3, #0
 8009a66:	d107      	bne.n	8009a78 <OsHeapAlloc+0xc0>
        PRINT_ERR("there's not enough mem to alloc 0x%x Bytes!\n", alignSize);
 8009a68:	4831      	ldr	r0, [pc, #196]	; (8009b30 <OsHeapAlloc+0x178>)
 8009a6a:	f7fa ff29 	bl	80048c0 <dprintf>
 8009a6e:	69b9      	ldr	r1, [r7, #24]
 8009a70:	4830      	ldr	r0, [pc, #192]	; (8009b34 <OsHeapAlloc+0x17c>)
 8009a72:	f7fa ff25 	bl	80048c0 <dprintf>
        goto OUT;
 8009a76:	e056      	b.n	8009b26 <OsHeapAlloc+0x16e>
    }

    if ((best->size - alignSize) > sizeof(struct LosHeapNode)) {
 8009a78:	68fb      	ldr	r3, [r7, #12]
 8009a7a:	689b      	ldr	r3, [r3, #8]
 8009a7c:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009a80:	461a      	mov	r2, r3
 8009a82:	69bb      	ldr	r3, [r7, #24]
 8009a84:	1ad3      	subs	r3, r2, r3
 8009a86:	2b0c      	cmp	r3, #12
 8009a88:	d93b      	bls.n	8009b02 <OsHeapAlloc+0x14a>
        /* hole divide into 2 */
        node = (struct LosHeapNode*)(UINTPTR)(best->data + alignSize);
 8009a8a:	68fb      	ldr	r3, [r7, #12]
 8009a8c:	f103 020c 	add.w	r2, r3, #12
 8009a90:	69bb      	ldr	r3, [r7, #24]
 8009a92:	4413      	add	r3, r2
 8009a94:	60bb      	str	r3, [r7, #8]

        node->used = 0;
 8009a96:	68ba      	ldr	r2, [r7, #8]
 8009a98:	7ad3      	ldrb	r3, [r2, #11]
 8009a9a:	f36f 1386 	bfc	r3, #6, #1
 8009a9e:	72d3      	strb	r3, [r2, #11]
        node->size = best->size - alignSize - sizeof(struct LosHeapNode);
 8009aa0:	68fb      	ldr	r3, [r7, #12]
 8009aa2:	689b      	ldr	r3, [r3, #8]
 8009aa4:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009aa8:	461a      	mov	r2, r3
 8009aaa:	69bb      	ldr	r3, [r7, #24]
 8009aac:	1ad3      	subs	r3, r2, r3
 8009aae:	3b0c      	subs	r3, #12
 8009ab0:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
 8009ab4:	68ba      	ldr	r2, [r7, #8]
 8009ab6:	6893      	ldr	r3, [r2, #8]
 8009ab8:	f361 031d 	bfi	r3, r1, #0, #30
 8009abc:	6093      	str	r3, [r2, #8]
        node->prev = best;
 8009abe:	68bb      	ldr	r3, [r7, #8]
 8009ac0:	68fa      	ldr	r2, [r7, #12]
 8009ac2:	601a      	str	r2, [r3, #0]

        if (best != heapMan->tail) {
 8009ac4:	69fb      	ldr	r3, [r7, #28]
 8009ac6:	685b      	ldr	r3, [r3, #4]
 8009ac8:	68fa      	ldr	r2, [r7, #12]
 8009aca:	429a      	cmp	r2, r3
 8009acc:	d00b      	beq.n	8009ae6 <OsHeapAlloc+0x12e>
            next = OsHeapPrvGetNext(heapMan, node);
 8009ace:	68b9      	ldr	r1, [r7, #8]
 8009ad0:	69f8      	ldr	r0, [r7, #28]
 8009ad2:	f7ff feb0 	bl	8009836 <OsHeapPrvGetNext>
 8009ad6:	6178      	str	r0, [r7, #20]
            if (next != NULL) {
 8009ad8:	697b      	ldr	r3, [r7, #20]
 8009ada:	2b00      	cmp	r3, #0
 8009adc:	d006      	beq.n	8009aec <OsHeapAlloc+0x134>
                next->prev = node;
 8009ade:	697b      	ldr	r3, [r7, #20]
 8009ae0:	68ba      	ldr	r2, [r7, #8]
 8009ae2:	601a      	str	r2, [r3, #0]
 8009ae4:	e002      	b.n	8009aec <OsHeapAlloc+0x134>
            }
        } else {
            heapMan->tail = node;
 8009ae6:	69fb      	ldr	r3, [r7, #28]
 8009ae8:	68ba      	ldr	r2, [r7, #8]
 8009aea:	605a      	str	r2, [r3, #4]
        }

        best->size = alignSize;
 8009aec:	69bb      	ldr	r3, [r7, #24]
 8009aee:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
 8009af2:	68fa      	ldr	r2, [r7, #12]
 8009af4:	6893      	ldr	r3, [r2, #8]
 8009af6:	f361 031d 	bfi	r3, r1, #0, #30
 8009afa:	6093      	str	r3, [r2, #8]
 8009afc:	e002      	b.n	8009b04 <OsHeapAlloc+0x14c>
                goto SIZE_MATCH;
 8009afe:	bf00      	nop
 8009b00:	e000      	b.n	8009b04 <OsHeapAlloc+0x14c>
    }

SIZE_MATCH:
 8009b02:	bf00      	nop
    best->align = 0;
 8009b04:	68fa      	ldr	r2, [r7, #12]
 8009b06:	7ad3      	ldrb	r3, [r2, #11]
 8009b08:	f36f 13c7 	bfc	r3, #7, #1
 8009b0c:	72d3      	strb	r3, [r2, #11]
    best->used = 1;
 8009b0e:	68fa      	ldr	r2, [r7, #12]
 8009b10:	7ad3      	ldrb	r3, [r2, #11]
 8009b12:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009b16:	72d3      	strb	r3, [r2, #11]
    ptr = best->data;
 8009b18:	68fb      	ldr	r3, [r7, #12]
 8009b1a:	330c      	adds	r3, #12
 8009b1c:	613b      	str	r3, [r7, #16]

    OsHeapStatAddUsed(heapMan, best);
 8009b1e:	68f9      	ldr	r1, [r7, #12]
 8009b20:	69f8      	ldr	r0, [r7, #28]
 8009b22:	f7ff feb9 	bl	8009898 <OsHeapStatAddUsed>
OUT:
    return ptr;
 8009b26:	693b      	ldr	r3, [r7, #16]
}
 8009b28:	4618      	mov	r0, r3
 8009b2a:	3720      	adds	r7, #32
 8009b2c:	46bd      	mov	sp, r7
 8009b2e:	bd80      	pop	{r7, pc}
 8009b30:	08021488 	.word	0x08021488
 8009b34:	08021490 	.word	0x08021490

08009b38 <OsHeapAllocAlign>:
 *               UINT32 size   --- size of the heap memory pool
 *               UINT32 boundary --- boundary the heap needs align
 * Return      : NULL:error, other value:the address of the memory we alloced
 */
VOID* OsHeapAllocAlign(VOID *pool, UINT32 size, UINT32 boundary)
{
 8009b38:	b580      	push	{r7, lr}
 8009b3a:	b088      	sub	sp, #32
 8009b3c:	af00      	add	r7, sp, #0
 8009b3e:	60f8      	str	r0, [r7, #12]
 8009b40:	60b9      	str	r1, [r7, #8]
 8009b42:	607a      	str	r2, [r7, #4]
    UINT32 useSize;
    UINT32 gapSize;
    VOID *ptr = NULL;
 8009b44:	2300      	movs	r3, #0
 8009b46:	613b      	str	r3, [r7, #16]
    VOID *alignedPtr = NULL;
 8009b48:	2300      	movs	r3, #0
 8009b4a:	617b      	str	r3, [r7, #20]

    if ((pool == NULL) || (size == 0) || (boundary < sizeof(VOID *)) || !IS_ALIGNED(boundary, boundary)) {
 8009b4c:	68fb      	ldr	r3, [r7, #12]
 8009b4e:	2b00      	cmp	r3, #0
 8009b50:	d00b      	beq.n	8009b6a <OsHeapAllocAlign+0x32>
 8009b52:	68bb      	ldr	r3, [r7, #8]
 8009b54:	2b00      	cmp	r3, #0
 8009b56:	d008      	beq.n	8009b6a <OsHeapAllocAlign+0x32>
 8009b58:	687b      	ldr	r3, [r7, #4]
 8009b5a:	2b03      	cmp	r3, #3
 8009b5c:	d905      	bls.n	8009b6a <OsHeapAllocAlign+0x32>
 8009b5e:	687b      	ldr	r3, [r7, #4]
 8009b60:	1e5a      	subs	r2, r3, #1
 8009b62:	687b      	ldr	r3, [r7, #4]
 8009b64:	4013      	ands	r3, r2
 8009b66:	2b00      	cmp	r3, #0
 8009b68:	d001      	beq.n	8009b6e <OsHeapAllocAlign+0x36>
        return NULL;
 8009b6a:	2300      	movs	r3, #0
 8009b6c:	e032      	b.n	8009bd4 <OsHeapAllocAlign+0x9c>
    }

    /* worst case is that the node happen to be 4 bytes ahead of the boundary */
    useSize = (size + boundary) - sizeof(VOID*);
 8009b6e:	68ba      	ldr	r2, [r7, #8]
 8009b70:	687b      	ldr	r3, [r7, #4]
 8009b72:	4413      	add	r3, r2
 8009b74:	3b04      	subs	r3, #4
 8009b76:	61bb      	str	r3, [r7, #24]
    if (useSize < size) {
 8009b78:	69ba      	ldr	r2, [r7, #24]
 8009b7a:	68bb      	ldr	r3, [r7, #8]
 8009b7c:	429a      	cmp	r2, r3
 8009b7e:	d201      	bcs.n	8009b84 <OsHeapAllocAlign+0x4c>
        return NULL;
 8009b80:	2300      	movs	r3, #0
 8009b82:	e027      	b.n	8009bd4 <OsHeapAllocAlign+0x9c>
    }

    ptr = OsHeapAlloc(pool, useSize);
 8009b84:	69b9      	ldr	r1, [r7, #24]
 8009b86:	68f8      	ldr	r0, [r7, #12]
 8009b88:	f7ff ff16 	bl	80099b8 <OsHeapAlloc>
 8009b8c:	6138      	str	r0, [r7, #16]
    if (ptr != NULL) {
 8009b8e:	693b      	ldr	r3, [r7, #16]
 8009b90:	2b00      	cmp	r3, #0
 8009b92:	d01b      	beq.n	8009bcc <OsHeapAllocAlign+0x94>
        alignedPtr = (VOID *)(UINTPTR)OS_MEM_ALIGN(ptr, boundary);
 8009b94:	693a      	ldr	r2, [r7, #16]
 8009b96:	687b      	ldr	r3, [r7, #4]
 8009b98:	4413      	add	r3, r2
 8009b9a:	1e5a      	subs	r2, r3, #1
 8009b9c:	687b      	ldr	r3, [r7, #4]
 8009b9e:	425b      	negs	r3, r3
 8009ba0:	4013      	ands	r3, r2
 8009ba2:	617b      	str	r3, [r7, #20]
        if (alignedPtr == ptr) {
 8009ba4:	697a      	ldr	r2, [r7, #20]
 8009ba6:	693b      	ldr	r3, [r7, #16]
 8009ba8:	429a      	cmp	r2, r3
 8009baa:	d011      	beq.n	8009bd0 <OsHeapAllocAlign+0x98>
            goto OUT;
        }

        gapSize = (UINTPTR)alignedPtr - (UINTPTR)ptr;
 8009bac:	697a      	ldr	r2, [r7, #20]
 8009bae:	693b      	ldr	r3, [r7, #16]
 8009bb0:	1ad3      	subs	r3, r2, r3
 8009bb2:	61fb      	str	r3, [r7, #28]
        OS_MEM_SET_ALIGN_FLAG(gapSize);
 8009bb4:	69fb      	ldr	r3, [r7, #28]
 8009bb6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009bba:	61fb      	str	r3, [r7, #28]
        *((UINT32 *)((UINTPTR)alignedPtr - sizeof(UINTPTR))) = gapSize;
 8009bbc:	697b      	ldr	r3, [r7, #20]
 8009bbe:	3b04      	subs	r3, #4
 8009bc0:	461a      	mov	r2, r3
 8009bc2:	69fb      	ldr	r3, [r7, #28]
 8009bc4:	6013      	str	r3, [r2, #0]

        ptr = alignedPtr;
 8009bc6:	697b      	ldr	r3, [r7, #20]
 8009bc8:	613b      	str	r3, [r7, #16]
 8009bca:	e002      	b.n	8009bd2 <OsHeapAllocAlign+0x9a>
    }
OUT:
 8009bcc:	bf00      	nop
 8009bce:	e000      	b.n	8009bd2 <OsHeapAllocAlign+0x9a>
            goto OUT;
 8009bd0:	bf00      	nop
    return ptr;
 8009bd2:	693b      	ldr	r3, [r7, #16]
}
 8009bd4:	4618      	mov	r0, r3
 8009bd6:	3720      	adds	r7, #32
 8009bd8:	46bd      	mov	sp, r7
 8009bda:	bd80      	pop	{r7, pc}

08009bdc <OsHeapDoFree>:

STATIC VOID OsHeapDoFree(struct LosHeapManager *heapMan, struct LosHeapNode *curNode)
{
 8009bdc:	b580      	push	{r7, lr}
 8009bde:	b084      	sub	sp, #16
 8009be0:	af00      	add	r7, sp, #0
 8009be2:	6078      	str	r0, [r7, #4]
 8009be4:	6039      	str	r1, [r7, #0]
    struct LosHeapNode *node = curNode;
 8009be6:	683b      	ldr	r3, [r7, #0]
 8009be8:	60bb      	str	r3, [r7, #8]
    struct LosHeapNode *next = NULL;
 8009bea:	2300      	movs	r3, #0
 8009bec:	60fb      	str	r3, [r7, #12]
    /* set to unused status */
    node->used = 0;
 8009bee:	68ba      	ldr	r2, [r7, #8]
 8009bf0:	7ad3      	ldrb	r3, [r2, #11]
 8009bf2:	f36f 1386 	bfc	r3, #6, #1
 8009bf6:	72d3      	strb	r3, [r2, #11]

    /* unused region before and after combination */
    while ((node->prev) && (!node->prev->used)) {
 8009bf8:	e002      	b.n	8009c00 <OsHeapDoFree+0x24>
        node = node->prev;
 8009bfa:	68bb      	ldr	r3, [r7, #8]
 8009bfc:	681b      	ldr	r3, [r3, #0]
 8009bfe:	60bb      	str	r3, [r7, #8]
    while ((node->prev) && (!node->prev->used)) {
 8009c00:	68bb      	ldr	r3, [r7, #8]
 8009c02:	681b      	ldr	r3, [r3, #0]
 8009c04:	2b00      	cmp	r3, #0
 8009c06:	d007      	beq.n	8009c18 <OsHeapDoFree+0x3c>
 8009c08:	68bb      	ldr	r3, [r7, #8]
 8009c0a:	681b      	ldr	r3, [r3, #0]
 8009c0c:	7adb      	ldrb	r3, [r3, #11]
 8009c0e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009c12:	b2db      	uxtb	r3, r3
 8009c14:	2b00      	cmp	r3, #0
 8009c16:	d0f0      	beq.n	8009bfa <OsHeapDoFree+0x1e>
    }

    next = OsHeapPrvGetNext(heapMan, node);
 8009c18:	68b9      	ldr	r1, [r7, #8]
 8009c1a:	6878      	ldr	r0, [r7, #4]
 8009c1c:	f7ff fe0b 	bl	8009836 <OsHeapPrvGetNext>
 8009c20:	60f8      	str	r0, [r7, #12]
    while (next != NULL) {
 8009c22:	e029      	b.n	8009c78 <OsHeapDoFree+0x9c>
        if (next->used) {
 8009c24:	68fb      	ldr	r3, [r7, #12]
 8009c26:	7adb      	ldrb	r3, [r3, #11]
 8009c28:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009c2c:	b2db      	uxtb	r3, r3
 8009c2e:	2b00      	cmp	r3, #0
 8009c30:	d003      	beq.n	8009c3a <OsHeapDoFree+0x5e>
            next->prev = node;
 8009c32:	68fb      	ldr	r3, [r7, #12]
 8009c34:	68ba      	ldr	r2, [r7, #8]
 8009c36:	601a      	str	r2, [r3, #0]
            break;
 8009c38:	e022      	b.n	8009c80 <OsHeapDoFree+0xa4>
        }
        node->size += (sizeof(struct LosHeapNode) + next->size);
 8009c3a:	68bb      	ldr	r3, [r7, #8]
 8009c3c:	689b      	ldr	r3, [r3, #8]
 8009c3e:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009c42:	461a      	mov	r2, r3
 8009c44:	68fb      	ldr	r3, [r7, #12]
 8009c46:	689b      	ldr	r3, [r3, #8]
 8009c48:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009c4c:	4413      	add	r3, r2
 8009c4e:	330c      	adds	r3, #12
 8009c50:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
 8009c54:	68ba      	ldr	r2, [r7, #8]
 8009c56:	6893      	ldr	r3, [r2, #8]
 8009c58:	f361 031d 	bfi	r3, r1, #0, #30
 8009c5c:	6093      	str	r3, [r2, #8]
        if (heapMan->tail == next) {
 8009c5e:	687b      	ldr	r3, [r7, #4]
 8009c60:	685b      	ldr	r3, [r3, #4]
 8009c62:	68fa      	ldr	r2, [r7, #12]
 8009c64:	429a      	cmp	r2, r3
 8009c66:	d102      	bne.n	8009c6e <OsHeapDoFree+0x92>
            heapMan->tail = node;
 8009c68:	687b      	ldr	r3, [r7, #4]
 8009c6a:	68ba      	ldr	r2, [r7, #8]
 8009c6c:	605a      	str	r2, [r3, #4]
        }
        next = OsHeapPrvGetNext(heapMan, node);
 8009c6e:	68b9      	ldr	r1, [r7, #8]
 8009c70:	6878      	ldr	r0, [r7, #4]
 8009c72:	f7ff fde0 	bl	8009836 <OsHeapPrvGetNext>
 8009c76:	60f8      	str	r0, [r7, #12]
    while (next != NULL) {
 8009c78:	68fb      	ldr	r3, [r7, #12]
 8009c7a:	2b00      	cmp	r3, #0
 8009c7c:	d1d2      	bne.n	8009c24 <OsHeapDoFree+0x48>
    }
}
 8009c7e:	bf00      	nop
 8009c80:	bf00      	nop
 8009c82:	3710      	adds	r7, #16
 8009c84:	46bd      	mov	sp, r7
 8009c86:	bd80      	pop	{r7, pc}

08009c88 <OsHeapFree>:
 * Input       : VOID* pool --- Pointer to the manager,to distinguish heap
 *               VOID* ptr --- the pointer of heap memory we want to free
 * Return      : 1:success 0:error
 */
BOOL OsHeapFree(VOID *pool, const VOID *ptr)
{
 8009c88:	b580      	push	{r7, lr}
 8009c8a:	b086      	sub	sp, #24
 8009c8c:	af00      	add	r7, sp, #0
 8009c8e:	6078      	str	r0, [r7, #4]
 8009c90:	6039      	str	r1, [r7, #0]
    struct LosHeapNode *node = NULL;
 8009c92:	2300      	movs	r3, #0
 8009c94:	60fb      	str	r3, [r7, #12]

    UINT32 gapSize;
    BOOL ret = TRUE;
 8009c96:	2301      	movs	r3, #1
 8009c98:	60bb      	str	r3, [r7, #8]

    struct LosHeapManager *heapMan = HEAP_CAST(struct LosHeapManager *, pool);
 8009c9a:	687b      	ldr	r3, [r7, #4]
 8009c9c:	613b      	str	r3, [r7, #16]
    if ((heapMan == NULL) || (ptr == NULL)) {
 8009c9e:	693b      	ldr	r3, [r7, #16]
 8009ca0:	2b00      	cmp	r3, #0
 8009ca2:	d002      	beq.n	8009caa <OsHeapFree+0x22>
 8009ca4:	683b      	ldr	r3, [r7, #0]
 8009ca6:	2b00      	cmp	r3, #0
 8009ca8:	d101      	bne.n	8009cae <OsHeapFree+0x26>
        return LOS_NOK;
 8009caa:	2301      	movs	r3, #1
 8009cac:	e05b      	b.n	8009d66 <OsHeapFree+0xde>
    }

    /* find the real ptr through gap size */
    gapSize = *((UINT32 *)((UINTPTR)ptr - sizeof(UINTPTR)));
 8009cae:	683b      	ldr	r3, [r7, #0]
 8009cb0:	3b04      	subs	r3, #4
 8009cb2:	681b      	ldr	r3, [r3, #0]
 8009cb4:	617b      	str	r3, [r7, #20]
    if (OS_MEM_GET_ALIGN_FLAG(gapSize)) {
 8009cb6:	697b      	ldr	r3, [r7, #20]
 8009cb8:	2b00      	cmp	r3, #0
 8009cba:	da07      	bge.n	8009ccc <OsHeapFree+0x44>
        gapSize = OS_MEM_GET_ALIGN_GAPSIZE(gapSize);
 8009cbc:	697b      	ldr	r3, [r7, #20]
 8009cbe:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009cc2:	617b      	str	r3, [r7, #20]
        ptr = (VOID *)((UINTPTR)ptr - gapSize);
 8009cc4:	683a      	ldr	r2, [r7, #0]
 8009cc6:	697b      	ldr	r3, [r7, #20]
 8009cc8:	1ad3      	subs	r3, r2, r3
 8009cca:	603b      	str	r3, [r7, #0]
    }

    if (((UINTPTR)ptr < (UINTPTR)heapMan->head) ||
 8009ccc:	693b      	ldr	r3, [r7, #16]
 8009cce:	681b      	ldr	r3, [r3, #0]
 8009cd0:	461a      	mov	r2, r3
 8009cd2:	683b      	ldr	r3, [r7, #0]
 8009cd4:	429a      	cmp	r2, r3
 8009cd6:	d806      	bhi.n	8009ce6 <OsHeapFree+0x5e>
        ((UINTPTR)ptr > ((UINTPTR)heapMan->tail + sizeof(struct LosHeapNode)))) {
 8009cd8:	693b      	ldr	r3, [r7, #16]
 8009cda:	685b      	ldr	r3, [r3, #4]
 8009cdc:	f103 020c 	add.w	r2, r3, #12
 8009ce0:	683b      	ldr	r3, [r7, #0]
    if (((UINTPTR)ptr < (UINTPTR)heapMan->head) ||
 8009ce2:	429a      	cmp	r2, r3
 8009ce4:	d209      	bcs.n	8009cfa <OsHeapFree+0x72>
        PRINT_ERR("0x%lx out of range!\n", (UINTPTR)ptr);
 8009ce6:	4822      	ldr	r0, [pc, #136]	; (8009d70 <OsHeapFree+0xe8>)
 8009ce8:	f7fa fdea 	bl	80048c0 <dprintf>
 8009cec:	683b      	ldr	r3, [r7, #0]
 8009cee:	4619      	mov	r1, r3
 8009cf0:	4820      	ldr	r0, [pc, #128]	; (8009d74 <OsHeapFree+0xec>)
 8009cf2:	f7fa fde5 	bl	80048c0 <dprintf>
        return FALSE;
 8009cf6:	2300      	movs	r3, #0
 8009cf8:	e035      	b.n	8009d66 <OsHeapFree+0xde>
    }

    node = ((struct LosHeapNode *)ptr) - 1;
 8009cfa:	683b      	ldr	r3, [r7, #0]
 8009cfc:	3b0c      	subs	r3, #12
 8009cfe:	60fb      	str	r3, [r7, #12]
    /* check if the address is a node of the heap memory list */
    if ((node->used == 0) || (!((UINTPTR)node == (UINTPTR)heapMan->head) &&
 8009d00:	68fb      	ldr	r3, [r7, #12]
 8009d02:	7adb      	ldrb	r3, [r3, #11]
 8009d04:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009d08:	b2db      	uxtb	r3, r3
 8009d0a:	2b00      	cmp	r3, #0
 8009d0c:	d01f      	beq.n	8009d4e <OsHeapFree+0xc6>
 8009d0e:	693b      	ldr	r3, [r7, #16]
 8009d10:	681b      	ldr	r3, [r3, #0]
 8009d12:	461a      	mov	r2, r3
 8009d14:	68fb      	ldr	r3, [r7, #12]
 8009d16:	429a      	cmp	r2, r3
 8009d18:	d01c      	beq.n	8009d54 <OsHeapFree+0xcc>
        (((UINTPTR)node->prev < (UINTPTR)heapMan->head) ||
 8009d1a:	68fb      	ldr	r3, [r7, #12]
 8009d1c:	681b      	ldr	r3, [r3, #0]
 8009d1e:	461a      	mov	r2, r3
 8009d20:	693b      	ldr	r3, [r7, #16]
 8009d22:	681b      	ldr	r3, [r3, #0]
    if ((node->used == 0) || (!((UINTPTR)node == (UINTPTR)heapMan->head) &&
 8009d24:	429a      	cmp	r2, r3
 8009d26:	d312      	bcc.n	8009d4e <OsHeapFree+0xc6>
        ((UINTPTR)node->prev > ((UINTPTR)heapMan->tail + sizeof(struct LosHeapNode))) ||
 8009d28:	68fb      	ldr	r3, [r7, #12]
 8009d2a:	681b      	ldr	r3, [r3, #0]
 8009d2c:	461a      	mov	r2, r3
 8009d2e:	693b      	ldr	r3, [r7, #16]
 8009d30:	685b      	ldr	r3, [r3, #4]
 8009d32:	330c      	adds	r3, #12
        (((UINTPTR)node->prev < (UINTPTR)heapMan->head) ||
 8009d34:	429a      	cmp	r2, r3
 8009d36:	d80a      	bhi.n	8009d4e <OsHeapFree+0xc6>
        ((UINTPTR)OsHeapPrvGetNext(heapMan, node->prev) != (UINTPTR)node)))) {
 8009d38:	68fb      	ldr	r3, [r7, #12]
 8009d3a:	681b      	ldr	r3, [r3, #0]
 8009d3c:	4619      	mov	r1, r3
 8009d3e:	6938      	ldr	r0, [r7, #16]
 8009d40:	f7ff fd79 	bl	8009836 <OsHeapPrvGetNext>
 8009d44:	4603      	mov	r3, r0
 8009d46:	461a      	mov	r2, r3
 8009d48:	68fb      	ldr	r3, [r7, #12]
        ((UINTPTR)node->prev > ((UINTPTR)heapMan->tail + sizeof(struct LosHeapNode))) ||
 8009d4a:	429a      	cmp	r2, r3
 8009d4c:	d002      	beq.n	8009d54 <OsHeapFree+0xcc>
        ret = FALSE;
 8009d4e:	2300      	movs	r3, #0
 8009d50:	60bb      	str	r3, [r7, #8]
        goto OUT;
 8009d52:	e007      	b.n	8009d64 <OsHeapFree+0xdc>
    }

    OsHeapStatDecUsed(heapMan, node);
 8009d54:	68f9      	ldr	r1, [r7, #12]
 8009d56:	6938      	ldr	r0, [r7, #16]
 8009d58:	f7ff fdc7 	bl	80098ea <OsHeapStatDecUsed>
    OsHeapDoFree(heapMan, node);
 8009d5c:	68f9      	ldr	r1, [r7, #12]
 8009d5e:	6938      	ldr	r0, [r7, #16]
 8009d60:	f7ff ff3c 	bl	8009bdc <OsHeapDoFree>

OUT:
    return ret;
 8009d64:	68bb      	ldr	r3, [r7, #8]
}
 8009d66:	4618      	mov	r0, r3
 8009d68:	3718      	adds	r7, #24
 8009d6a:	46bd      	mov	sp, r7
 8009d6c:	bd80      	pop	{r7, pc}
 8009d6e:	bf00      	nop
 8009d70:	08021488 	.word	0x08021488
 8009d74:	080214c0 	.word	0x080214c0

08009d78 <OsHeapStatisticsGet>:
 * Input       : pool --- Pointer to the manager, to distinguish heap
 * Output      : status --- heap statistics
 * Return      : LOS_OK on success or error code on failure
 */
UINT32 OsHeapStatisticsGet(VOID *pool, LosHeapStatus *status)
{
 8009d78:	b480      	push	{r7}
 8009d7a:	b089      	sub	sp, #36	; 0x24
 8009d7c:	af00      	add	r7, sp, #0
 8009d7e:	6078      	str	r0, [r7, #4]
 8009d80:	6039      	str	r1, [r7, #0]
    UINT32 heapUsed = 0;
 8009d82:	2300      	movs	r3, #0
 8009d84:	60bb      	str	r3, [r7, #8]
    UINT32 maxFreeNodeSize = 0;
 8009d86:	2300      	movs	r3, #0
 8009d88:	60fb      	str	r3, [r7, #12]
    UINT32 freeNodeNum = 0;
 8009d8a:	2300      	movs	r3, #0
 8009d8c:	613b      	str	r3, [r7, #16]
    UINT32 usedNodeNum = 0;
 8009d8e:	2300      	movs	r3, #0
 8009d90:	617b      	str	r3, [r7, #20]

    struct LosHeapNode *node = NULL;
 8009d92:	2300      	movs	r3, #0
 8009d94:	61bb      	str	r3, [r7, #24]
    struct LosHeapManager *ramHeap = HEAP_CAST(struct LosHeapManager *, pool);
 8009d96:	687b      	ldr	r3, [r7, #4]
 8009d98:	61fb      	str	r3, [r7, #28]

    if (ramHeap == NULL) {
 8009d9a:	69fb      	ldr	r3, [r7, #28]
 8009d9c:	2b00      	cmp	r3, #0
 8009d9e:	d101      	bne.n	8009da4 <OsHeapStatisticsGet+0x2c>
        return LOS_NOK;
 8009da0:	2301      	movs	r3, #1
 8009da2:	e054      	b.n	8009e4e <OsHeapStatisticsGet+0xd6>
    }

    if (status == NULL) {
 8009da4:	683b      	ldr	r3, [r7, #0]
 8009da6:	2b00      	cmp	r3, #0
 8009da8:	d101      	bne.n	8009dae <OsHeapStatisticsGet+0x36>
        return LOS_NOK;
 8009daa:	2301      	movs	r3, #1
 8009dac:	e04f      	b.n	8009e4e <OsHeapStatisticsGet+0xd6>
    }

    /* heap manager header use heap space */
    heapUsed += sizeof(struct LosHeapManager);
 8009dae:	68bb      	ldr	r3, [r7, #8]
 8009db0:	339c      	adds	r3, #156	; 0x9c
 8009db2:	60bb      	str	r3, [r7, #8]

    node = ramHeap->tail;
 8009db4:	69fb      	ldr	r3, [r7, #28]
 8009db6:	685b      	ldr	r3, [r3, #4]
 8009db8:	61bb      	str	r3, [r7, #24]
    while (node != NULL) {
 8009dba:	e026      	b.n	8009e0a <OsHeapStatisticsGet+0x92>
        if (node->used) {
 8009dbc:	69bb      	ldr	r3, [r7, #24]
 8009dbe:	7adb      	ldrb	r3, [r3, #11]
 8009dc0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009dc4:	b2db      	uxtb	r3, r3
 8009dc6:	2b00      	cmp	r3, #0
 8009dc8:	d00c      	beq.n	8009de4 <OsHeapStatisticsGet+0x6c>
            heapUsed += (node->size + sizeof(struct LosHeapNode));
 8009dca:	69bb      	ldr	r3, [r7, #24]
 8009dcc:	689b      	ldr	r3, [r3, #8]
 8009dce:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009dd2:	461a      	mov	r2, r3
 8009dd4:	68bb      	ldr	r3, [r7, #8]
 8009dd6:	4413      	add	r3, r2
 8009dd8:	330c      	adds	r3, #12
 8009dda:	60bb      	str	r3, [r7, #8]
            usedNodeNum++;
 8009ddc:	697b      	ldr	r3, [r7, #20]
 8009dde:	3301      	adds	r3, #1
 8009de0:	617b      	str	r3, [r7, #20]
 8009de2:	e00f      	b.n	8009e04 <OsHeapStatisticsGet+0x8c>
        } else {
            if (node->size > maxFreeNodeSize) {
 8009de4:	69bb      	ldr	r3, [r7, #24]
 8009de6:	689b      	ldr	r3, [r3, #8]
 8009de8:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009dec:	461a      	mov	r2, r3
 8009dee:	68fb      	ldr	r3, [r7, #12]
 8009df0:	4293      	cmp	r3, r2
 8009df2:	d204      	bcs.n	8009dfe <OsHeapStatisticsGet+0x86>
                maxFreeNodeSize = node->size;
 8009df4:	69bb      	ldr	r3, [r7, #24]
 8009df6:	689b      	ldr	r3, [r3, #8]
 8009df8:	f3c3 031d 	ubfx	r3, r3, #0, #30
 8009dfc:	60fb      	str	r3, [r7, #12]
            }
            freeNodeNum++;
 8009dfe:	693b      	ldr	r3, [r7, #16]
 8009e00:	3301      	adds	r3, #1
 8009e02:	613b      	str	r3, [r7, #16]
        }
        node = node->prev;
 8009e04:	69bb      	ldr	r3, [r7, #24]
 8009e06:	681b      	ldr	r3, [r3, #0]
 8009e08:	61bb      	str	r3, [r7, #24]
    while (node != NULL) {
 8009e0a:	69bb      	ldr	r3, [r7, #24]
 8009e0c:	2b00      	cmp	r3, #0
 8009e0e:	d1d5      	bne.n	8009dbc <OsHeapStatisticsGet+0x44>
    }

    if (ramHeap->size < heapUsed) {
 8009e10:	69fb      	ldr	r3, [r7, #28]
 8009e12:	689b      	ldr	r3, [r3, #8]
 8009e14:	68ba      	ldr	r2, [r7, #8]
 8009e16:	429a      	cmp	r2, r3
 8009e18:	d901      	bls.n	8009e1e <OsHeapStatisticsGet+0xa6>
        return LOS_NOK;
 8009e1a:	2301      	movs	r3, #1
 8009e1c:	e017      	b.n	8009e4e <OsHeapStatisticsGet+0xd6>
    }

    status->totalUsedSize = heapUsed;
 8009e1e:	683b      	ldr	r3, [r7, #0]
 8009e20:	68ba      	ldr	r2, [r7, #8]
 8009e22:	601a      	str	r2, [r3, #0]
    status->maxFreeNodeSize = maxFreeNodeSize;
 8009e24:	683b      	ldr	r3, [r7, #0]
 8009e26:	68fa      	ldr	r2, [r7, #12]
 8009e28:	609a      	str	r2, [r3, #8]
    status->totalFreeSize = ramHeap->size - status->totalUsedSize;
 8009e2a:	69fb      	ldr	r3, [r7, #28]
 8009e2c:	689a      	ldr	r2, [r3, #8]
 8009e2e:	683b      	ldr	r3, [r7, #0]
 8009e30:	681b      	ldr	r3, [r3, #0]
 8009e32:	1ad2      	subs	r2, r2, r3
 8009e34:	683b      	ldr	r3, [r7, #0]
 8009e36:	605a      	str	r2, [r3, #4]
    status->usedNodeNum = usedNodeNum;
 8009e38:	683b      	ldr	r3, [r7, #0]
 8009e3a:	697a      	ldr	r2, [r7, #20]
 8009e3c:	60da      	str	r2, [r3, #12]
    status->freeNodeNum = freeNodeNum;
 8009e3e:	683b      	ldr	r3, [r7, #0]
 8009e40:	693a      	ldr	r2, [r7, #16]
 8009e42:	611a      	str	r2, [r3, #16]

#ifdef LOSCFG_MEM_TASK_STAT
    status->usageWaterLine = ramHeap->stat.memTotalPeak;
 8009e44:	69fb      	ldr	r3, [r7, #28]
 8009e46:	691a      	ldr	r2, [r3, #16]
 8009e48:	683b      	ldr	r3, [r7, #0]
 8009e4a:	615a      	str	r2, [r3, #20]
#endif

    return LOS_OK;
 8009e4c:	2300      	movs	r3, #0
}
 8009e4e:	4618      	mov	r0, r3
 8009e50:	3724      	adds	r7, #36	; 0x24
 8009e52:	46bd      	mov	sp, r7
 8009e54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e58:	4770      	bx	lr

08009e5a <OsMemstatTaskUsedInc>:

#define MIN_TASK_ID(x, y)               ((x) > (y) ? (y) : (x))
#define MAX_MEM_USE(x, y)               ((x) > (y) ? (x) : (y))

LITE_OS_SEC_TEXT_MINOR VOID OsMemstatTaskUsedInc(Memstat *stat, UINT32 usedSize, UINT32 taskId)
{
 8009e5a:	b480      	push	{r7}
 8009e5c:	b087      	sub	sp, #28
 8009e5e:	af00      	add	r7, sp, #0
 8009e60:	60f8      	str	r0, [r7, #12]
 8009e62:	60b9      	str	r1, [r7, #8]
 8009e64:	607a      	str	r2, [r7, #4]
    UINT32 record = MIN_TASK_ID(taskId, TASK_NUM - 1);
 8009e66:	687b      	ldr	r3, [r7, #4]
 8009e68:	2b10      	cmp	r3, #16
 8009e6a:	bf28      	it	cs
 8009e6c:	2310      	movcs	r3, #16
 8009e6e:	613b      	str	r3, [r7, #16]
    TaskMemUsedInfo *taskMemstats = stat->taskMemstats;
 8009e70:	68fb      	ldr	r3, [r7, #12]
 8009e72:	3308      	adds	r3, #8
 8009e74:	617b      	str	r3, [r7, #20]

    taskMemstats[record].memUsed += usedSize;
 8009e76:	693b      	ldr	r3, [r7, #16]
 8009e78:	00db      	lsls	r3, r3, #3
 8009e7a:	697a      	ldr	r2, [r7, #20]
 8009e7c:	4413      	add	r3, r2
 8009e7e:	6819      	ldr	r1, [r3, #0]
 8009e80:	693b      	ldr	r3, [r7, #16]
 8009e82:	00db      	lsls	r3, r3, #3
 8009e84:	697a      	ldr	r2, [r7, #20]
 8009e86:	4413      	add	r3, r2
 8009e88:	68ba      	ldr	r2, [r7, #8]
 8009e8a:	440a      	add	r2, r1
 8009e8c:	601a      	str	r2, [r3, #0]
    taskMemstats[record].memPeak = MAX_MEM_USE(taskMemstats[record].memPeak, taskMemstats[record].memUsed);
 8009e8e:	693b      	ldr	r3, [r7, #16]
 8009e90:	00db      	lsls	r3, r3, #3
 8009e92:	697a      	ldr	r2, [r7, #20]
 8009e94:	4413      	add	r3, r2
 8009e96:	6819      	ldr	r1, [r3, #0]
 8009e98:	693b      	ldr	r3, [r7, #16]
 8009e9a:	00db      	lsls	r3, r3, #3
 8009e9c:	697a      	ldr	r2, [r7, #20]
 8009e9e:	4413      	add	r3, r2
 8009ea0:	685a      	ldr	r2, [r3, #4]
 8009ea2:	693b      	ldr	r3, [r7, #16]
 8009ea4:	00db      	lsls	r3, r3, #3
 8009ea6:	6978      	ldr	r0, [r7, #20]
 8009ea8:	4403      	add	r3, r0
 8009eaa:	428a      	cmp	r2, r1
 8009eac:	bf38      	it	cc
 8009eae:	460a      	movcc	r2, r1
 8009eb0:	605a      	str	r2, [r3, #4]

    stat->memTotalUsed += usedSize;
 8009eb2:	68fb      	ldr	r3, [r7, #12]
 8009eb4:	681a      	ldr	r2, [r3, #0]
 8009eb6:	68bb      	ldr	r3, [r7, #8]
 8009eb8:	441a      	add	r2, r3
 8009eba:	68fb      	ldr	r3, [r7, #12]
 8009ebc:	601a      	str	r2, [r3, #0]
    stat->memTotalPeak = MAX_MEM_USE(stat->memTotalPeak, stat->memTotalUsed);
 8009ebe:	68fb      	ldr	r3, [r7, #12]
 8009ec0:	681a      	ldr	r2, [r3, #0]
 8009ec2:	68fb      	ldr	r3, [r7, #12]
 8009ec4:	685b      	ldr	r3, [r3, #4]
 8009ec6:	429a      	cmp	r2, r3
 8009ec8:	bf38      	it	cc
 8009eca:	461a      	movcc	r2, r3
 8009ecc:	68fb      	ldr	r3, [r7, #12]
 8009ece:	605a      	str	r2, [r3, #4]
}
 8009ed0:	bf00      	nop
 8009ed2:	371c      	adds	r7, #28
 8009ed4:	46bd      	mov	sp, r7
 8009ed6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009eda:	4770      	bx	lr

08009edc <OsMemstatTaskUsedDec>:

LITE_OS_SEC_TEXT_MINOR VOID OsMemstatTaskUsedDec(Memstat *stat, UINT32 usedSize, UINT32 taskId)
{
 8009edc:	b480      	push	{r7}
 8009ede:	b087      	sub	sp, #28
 8009ee0:	af00      	add	r7, sp, #0
 8009ee2:	60f8      	str	r0, [r7, #12]
 8009ee4:	60b9      	str	r1, [r7, #8]
 8009ee6:	607a      	str	r2, [r7, #4]
    UINT32 record = MIN_TASK_ID(taskId, TASK_NUM - 1);
 8009ee8:	687b      	ldr	r3, [r7, #4]
 8009eea:	2b10      	cmp	r3, #16
 8009eec:	bf28      	it	cs
 8009eee:	2310      	movcs	r3, #16
 8009ef0:	613b      	str	r3, [r7, #16]
    TaskMemUsedInfo *taskMemstats = stat->taskMemstats;
 8009ef2:	68fb      	ldr	r3, [r7, #12]
 8009ef4:	3308      	adds	r3, #8
 8009ef6:	617b      	str	r3, [r7, #20]

    if (taskMemstats[record].memUsed < usedSize) {
 8009ef8:	693b      	ldr	r3, [r7, #16]
 8009efa:	00db      	lsls	r3, r3, #3
 8009efc:	697a      	ldr	r2, [r7, #20]
 8009efe:	4413      	add	r3, r2
 8009f00:	681b      	ldr	r3, [r3, #0]
 8009f02:	68ba      	ldr	r2, [r7, #8]
 8009f04:	429a      	cmp	r2, r3
 8009f06:	d812      	bhi.n	8009f2e <OsMemstatTaskUsedDec+0x52>
        PRINT_INFO("mem used of current task '%s':0x%x, decrease size:0x%x\n",
                   OsCurrTaskGet()->taskName, taskMemstats[record].memUsed, usedSize);
        return;
    }

    taskMemstats[record].memUsed -= usedSize;
 8009f08:	693b      	ldr	r3, [r7, #16]
 8009f0a:	00db      	lsls	r3, r3, #3
 8009f0c:	697a      	ldr	r2, [r7, #20]
 8009f0e:	4413      	add	r3, r2
 8009f10:	6819      	ldr	r1, [r3, #0]
 8009f12:	693b      	ldr	r3, [r7, #16]
 8009f14:	00db      	lsls	r3, r3, #3
 8009f16:	697a      	ldr	r2, [r7, #20]
 8009f18:	4413      	add	r3, r2
 8009f1a:	68ba      	ldr	r2, [r7, #8]
 8009f1c:	1a8a      	subs	r2, r1, r2
 8009f1e:	601a      	str	r2, [r3, #0]
    stat->memTotalUsed -= usedSize;
 8009f20:	68fb      	ldr	r3, [r7, #12]
 8009f22:	681a      	ldr	r2, [r3, #0]
 8009f24:	68bb      	ldr	r3, [r7, #8]
 8009f26:	1ad2      	subs	r2, r2, r3
 8009f28:	68fb      	ldr	r3, [r7, #12]
 8009f2a:	601a      	str	r2, [r3, #0]
 8009f2c:	e000      	b.n	8009f30 <OsMemstatTaskUsedDec+0x54>
        return;
 8009f2e:	bf00      	nop
}
 8009f30:	371c      	adds	r7, #28
 8009f32:	46bd      	mov	sp, r7
 8009f34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f38:	4770      	bx	lr

08009f3a <OsMemstatTaskClear>:

LITE_OS_SEC_TEXT_MINOR VOID OsMemstatTaskClear(Memstat *stat, UINT32 taskId)
{
 8009f3a:	b480      	push	{r7}
 8009f3c:	b085      	sub	sp, #20
 8009f3e:	af00      	add	r7, sp, #0
 8009f40:	6078      	str	r0, [r7, #4]
 8009f42:	6039      	str	r1, [r7, #0]
    UINT32 record = MIN_TASK_ID(taskId, TASK_NUM - 1);
 8009f44:	683b      	ldr	r3, [r7, #0]
 8009f46:	2b10      	cmp	r3, #16
 8009f48:	bf28      	it	cs
 8009f4a:	2310      	movcs	r3, #16
 8009f4c:	60bb      	str	r3, [r7, #8]
    TaskMemUsedInfo *taskMemstats = stat->taskMemstats;
 8009f4e:	687b      	ldr	r3, [r7, #4]
 8009f50:	3308      	adds	r3, #8
 8009f52:	60fb      	str	r3, [r7, #12]
    if (taskMemstats[record].memUsed != 0) {
        PRINT_INFO("mem used of task '%s' is:0x%x, not zero when task being deleted\n",
                   OsCurrTaskGet()->taskName, taskMemstats[record].memUsed);
    }

    taskMemstats[record].memUsed = 0;
 8009f54:	68bb      	ldr	r3, [r7, #8]
 8009f56:	00db      	lsls	r3, r3, #3
 8009f58:	68fa      	ldr	r2, [r7, #12]
 8009f5a:	4413      	add	r3, r2
 8009f5c:	2200      	movs	r2, #0
 8009f5e:	601a      	str	r2, [r3, #0]
    taskMemstats[record].memPeak = 0;
 8009f60:	68bb      	ldr	r3, [r7, #8]
 8009f62:	00db      	lsls	r3, r3, #3
 8009f64:	68fa      	ldr	r2, [r7, #12]
 8009f66:	4413      	add	r3, r2
 8009f68:	2200      	movs	r2, #0
 8009f6a:	605a      	str	r2, [r3, #4]
}
 8009f6c:	bf00      	nop
 8009f6e:	3714      	adds	r7, #20
 8009f70:	46bd      	mov	sp, r7
 8009f72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f76:	4770      	bx	lr

08009f78 <OsMemstatTaskUsage>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsMemstatTaskUsage(const Memstat *stat, UINT32 taskId)
{
 8009f78:	b480      	push	{r7}
 8009f7a:	b085      	sub	sp, #20
 8009f7c:	af00      	add	r7, sp, #0
 8009f7e:	6078      	str	r0, [r7, #4]
 8009f80:	6039      	str	r1, [r7, #0]
    UINT32 record = MIN_TASK_ID(taskId, TASK_NUM - 1);
 8009f82:	683b      	ldr	r3, [r7, #0]
 8009f84:	2b10      	cmp	r3, #16
 8009f86:	bf28      	it	cs
 8009f88:	2310      	movcs	r3, #16
 8009f8a:	60bb      	str	r3, [r7, #8]
    const TaskMemUsedInfo *taskMemstats = stat->taskMemstats;
 8009f8c:	687b      	ldr	r3, [r7, #4]
 8009f8e:	3308      	adds	r3, #8
 8009f90:	60fb      	str	r3, [r7, #12]

    return taskMemstats[record].memUsed;
 8009f92:	68bb      	ldr	r3, [r7, #8]
 8009f94:	00db      	lsls	r3, r3, #3
 8009f96:	68fa      	ldr	r2, [r7, #12]
 8009f98:	4413      	add	r3, r2
 8009f9a:	681b      	ldr	r3, [r3, #0]
}
 8009f9c:	4618      	mov	r0, r3
 8009f9e:	3714      	adds	r7, #20
 8009fa0:	46bd      	mov	sp, r7
 8009fa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009fa6:	4770      	bx	lr

08009fa8 <OsMemTaskUsage>:

UINT32 OsMemTaskUsage(UINT32 taskId)
{
 8009fa8:	b580      	push	{r7, lr}
 8009faa:	b084      	sub	sp, #16
 8009fac:	af00      	add	r7, sp, #0
 8009fae:	6078      	str	r0, [r7, #4]
    LosMemPoolInfo *pool = NULL;
 8009fb0:	2300      	movs	r3, #0
 8009fb2:	60bb      	str	r3, [r7, #8]
    Memstat *stat = NULL;
 8009fb4:	2300      	movs	r3, #0
 8009fb6:	60fb      	str	r3, [r7, #12]

#ifndef LOSCFG_MEM_MUL_POOL
    /* If Multi-pool is not enabled, then trace SYSTEM MEM only */
    pool = (LosMemPoolInfo *)OS_SYS_MEM_ADDR;
 8009fb8:	4b07      	ldr	r3, [pc, #28]	; (8009fd8 <OsMemTaskUsage+0x30>)
 8009fba:	681b      	ldr	r3, [r3, #0]
 8009fbc:	60bb      	str	r3, [r7, #8]
    stat = &(pool->stat);
 8009fbe:	68bb      	ldr	r3, [r7, #8]
 8009fc0:	330c      	adds	r3, #12
 8009fc2:	60fb      	str	r3, [r7, #12]
    return OsMemstatTaskUsage(stat, taskId);
 8009fc4:	6879      	ldr	r1, [r7, #4]
 8009fc6:	68f8      	ldr	r0, [r7, #12]
 8009fc8:	f7ff ffd6 	bl	8009f78 <OsMemstatTaskUsage>
 8009fcc:	4603      	mov	r3, r0
        inUse += OsMemstatTaskUsage(stat, taskId);
        pool = pool->nextPool;
    }
    return inUse;
#endif
}
 8009fce:	4618      	mov	r0, r3
 8009fd0:	3710      	adds	r7, #16
 8009fd2:	46bd      	mov	sp, r7
 8009fd4:	bd80      	pop	{r7, pc}
 8009fd6:	bf00      	nop
 8009fd8:	080001f0 	.word	0x080001f0

08009fdc <OsMemTaskClear>:

VOID OsMemTaskClear(UINT32 taskId)
{
 8009fdc:	b580      	push	{r7, lr}
 8009fde:	b084      	sub	sp, #16
 8009fe0:	af00      	add	r7, sp, #0
 8009fe2:	6078      	str	r0, [r7, #4]
    LosMemPoolInfo *pool = NULL;
 8009fe4:	2300      	movs	r3, #0
 8009fe6:	60bb      	str	r3, [r7, #8]
    Memstat *stat = NULL;
 8009fe8:	2300      	movs	r3, #0
 8009fea:	60fb      	str	r3, [r7, #12]

#ifndef LOSCFG_MEM_MUL_POOL
    pool = (LosMemPoolInfo *)OS_SYS_MEM_ADDR;
 8009fec:	4b06      	ldr	r3, [pc, #24]	; (800a008 <OsMemTaskClear+0x2c>)
 8009fee:	681b      	ldr	r3, [r3, #0]
 8009ff0:	60bb      	str	r3, [r7, #8]
    stat = &(pool->stat);
 8009ff2:	68bb      	ldr	r3, [r7, #8]
 8009ff4:	330c      	adds	r3, #12
 8009ff6:	60fb      	str	r3, [r7, #12]
    OsMemstatTaskClear(stat, taskId);
 8009ff8:	6879      	ldr	r1, [r7, #4]
 8009ffa:	68f8      	ldr	r0, [r7, #12]
 8009ffc:	f7ff ff9d 	bl	8009f3a <OsMemstatTaskClear>
        stat = &(pool->stat);
        OsMemstatTaskClear(stat, taskId);
        pool = pool->nextPool;
    }
#endif
}
 800a000:	bf00      	nop
 800a002:	3710      	adds	r7, #16
 800a004:	46bd      	mov	sp, r7
 800a006:	bd80      	pop	{r7, pc}
 800a008:	080001f0 	.word	0x080001f0

0800a00c <LOS_ErrHandle>:
/* Hook function for error handling. */
LITE_OS_SEC_BSS LOS_ERRORHANDLE_FUNC g_usrErrFunc;

LITE_OS_SEC_TEXT_INIT UINT32 LOS_ErrHandle(CHAR *fileName, UINT32 lineNo, UINT32 errorNo,
                                           UINT32 paraLen, VOID *para)
{
 800a00c:	b590      	push	{r4, r7, lr}
 800a00e:	b087      	sub	sp, #28
 800a010:	af02      	add	r7, sp, #8
 800a012:	60f8      	str	r0, [r7, #12]
 800a014:	60b9      	str	r1, [r7, #8]
 800a016:	607a      	str	r2, [r7, #4]
 800a018:	603b      	str	r3, [r7, #0]
    if (g_usrErrFunc != NULL) {
 800a01a:	4b09      	ldr	r3, [pc, #36]	; (800a040 <LOS_ErrHandle+0x34>)
 800a01c:	681b      	ldr	r3, [r3, #0]
 800a01e:	2b00      	cmp	r3, #0
 800a020:	d008      	beq.n	800a034 <LOS_ErrHandle+0x28>
        g_usrErrFunc(fileName, lineNo, errorNo, paraLen, para);
 800a022:	4b07      	ldr	r3, [pc, #28]	; (800a040 <LOS_ErrHandle+0x34>)
 800a024:	681c      	ldr	r4, [r3, #0]
 800a026:	6a3b      	ldr	r3, [r7, #32]
 800a028:	9300      	str	r3, [sp, #0]
 800a02a:	683b      	ldr	r3, [r7, #0]
 800a02c:	687a      	ldr	r2, [r7, #4]
 800a02e:	68b9      	ldr	r1, [r7, #8]
 800a030:	68f8      	ldr	r0, [r7, #12]
 800a032:	47a0      	blx	r4
    }

    return LOS_OK;
 800a034:	2300      	movs	r3, #0
}
 800a036:	4618      	mov	r0, r3
 800a038:	3714      	adds	r7, #20
 800a03a:	46bd      	mov	sp, r7
 800a03c:	bd90      	pop	{r4, r7, pc}
 800a03e:	bf00      	nop
 800a040:	200036f8 	.word	0x200036f8

0800a044 <LOS_ListInit>:
{
 800a044:	b480      	push	{r7}
 800a046:	b083      	sub	sp, #12
 800a048:	af00      	add	r7, sp, #0
 800a04a:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 800a04c:	687b      	ldr	r3, [r7, #4]
 800a04e:	687a      	ldr	r2, [r7, #4]
 800a050:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 800a052:	687b      	ldr	r3, [r7, #4]
 800a054:	687a      	ldr	r2, [r7, #4]
 800a056:	601a      	str	r2, [r3, #0]
}
 800a058:	bf00      	nop
 800a05a:	370c      	adds	r7, #12
 800a05c:	46bd      	mov	sp, r7
 800a05e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a062:	4770      	bx	lr

0800a064 <LOS_ListAdd>:
{
 800a064:	b480      	push	{r7}
 800a066:	b083      	sub	sp, #12
 800a068:	af00      	add	r7, sp, #0
 800a06a:	6078      	str	r0, [r7, #4]
 800a06c:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 800a06e:	687b      	ldr	r3, [r7, #4]
 800a070:	685a      	ldr	r2, [r3, #4]
 800a072:	683b      	ldr	r3, [r7, #0]
 800a074:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 800a076:	683b      	ldr	r3, [r7, #0]
 800a078:	687a      	ldr	r2, [r7, #4]
 800a07a:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 800a07c:	687b      	ldr	r3, [r7, #4]
 800a07e:	685b      	ldr	r3, [r3, #4]
 800a080:	683a      	ldr	r2, [r7, #0]
 800a082:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 800a084:	687b      	ldr	r3, [r7, #4]
 800a086:	683a      	ldr	r2, [r7, #0]
 800a088:	605a      	str	r2, [r3, #4]
}
 800a08a:	bf00      	nop
 800a08c:	370c      	adds	r7, #12
 800a08e:	46bd      	mov	sp, r7
 800a090:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a094:	4770      	bx	lr

0800a096 <LOS_ListTailInsert>:
{
 800a096:	b580      	push	{r7, lr}
 800a098:	b082      	sub	sp, #8
 800a09a:	af00      	add	r7, sp, #0
 800a09c:	6078      	str	r0, [r7, #4]
 800a09e:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 800a0a0:	687b      	ldr	r3, [r7, #4]
 800a0a2:	681b      	ldr	r3, [r3, #0]
 800a0a4:	6839      	ldr	r1, [r7, #0]
 800a0a6:	4618      	mov	r0, r3
 800a0a8:	f7ff ffdc 	bl	800a064 <LOS_ListAdd>
}
 800a0ac:	bf00      	nop
 800a0ae:	3708      	adds	r7, #8
 800a0b0:	46bd      	mov	sp, r7
 800a0b2:	bd80      	pop	{r7, pc}

0800a0b4 <LOS_ListDelete>:
{
 800a0b4:	b480      	push	{r7}
 800a0b6:	b083      	sub	sp, #12
 800a0b8:	af00      	add	r7, sp, #0
 800a0ba:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 800a0bc:	687b      	ldr	r3, [r7, #4]
 800a0be:	685b      	ldr	r3, [r3, #4]
 800a0c0:	687a      	ldr	r2, [r7, #4]
 800a0c2:	6812      	ldr	r2, [r2, #0]
 800a0c4:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 800a0c6:	687b      	ldr	r3, [r7, #4]
 800a0c8:	681b      	ldr	r3, [r3, #0]
 800a0ca:	687a      	ldr	r2, [r7, #4]
 800a0cc:	6852      	ldr	r2, [r2, #4]
 800a0ce:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 800a0d0:	687b      	ldr	r3, [r7, #4]
 800a0d2:	2200      	movs	r2, #0
 800a0d4:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 800a0d6:	687b      	ldr	r3, [r7, #4]
 800a0d8:	2200      	movs	r2, #0
 800a0da:	601a      	str	r2, [r3, #0]
}
 800a0dc:	bf00      	nop
 800a0de:	370c      	adds	r7, #12
 800a0e0:	46bd      	mov	sp, r7
 800a0e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0e6:	4770      	bx	lr

0800a0e8 <LOS_ListEmpty>:
{
 800a0e8:	b480      	push	{r7}
 800a0ea:	b083      	sub	sp, #12
 800a0ec:	af00      	add	r7, sp, #0
 800a0ee:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 800a0f0:	687b      	ldr	r3, [r7, #4]
 800a0f2:	685b      	ldr	r3, [r3, #4]
 800a0f4:	687a      	ldr	r2, [r7, #4]
 800a0f6:	429a      	cmp	r2, r3
 800a0f8:	bf0c      	ite	eq
 800a0fa:	2301      	moveq	r3, #1
 800a0fc:	2300      	movne	r3, #0
 800a0fe:	b2db      	uxtb	r3, r3
}
 800a100:	4618      	mov	r0, r3
 800a102:	370c      	adds	r7, #12
 800a104:	46bd      	mov	sp, r7
 800a106:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a10a:	4770      	bx	lr

0800a10c <OsSortLinkInit>:
#define OS_INVALID_VALUE    0xFFFFFFFF

#ifdef LOSCFG_BASE_CORE_USE_MULTI_LIST

LITE_OS_SEC_TEXT_INIT UINT32 OsSortLinkInit(SortLinkAttribute *sortLinkHeader)
{
 800a10c:	b580      	push	{r7, lr}
 800a10e:	b086      	sub	sp, #24
 800a110:	af00      	add	r7, sp, #0
 800a112:	6078      	str	r0, [r7, #4]
    UINT32 size;
    LOS_DL_LIST *listObject = NULL;
 800a114:	2300      	movs	r3, #0
 800a116:	60fb      	str	r3, [r7, #12]
    UINT32 index;

    size = sizeof(LOS_DL_LIST) << OS_TSK_SORTLINK_LOGLEN;
 800a118:	2340      	movs	r3, #64	; 0x40
 800a11a:	617b      	str	r3, [r7, #20]
    listObject = (LOS_DL_LIST *)LOS_MemAlloc(m_aucSysMem0, size); /* system resident resource */
 800a11c:	4b15      	ldr	r3, [pc, #84]	; (800a174 <OsSortLinkInit+0x68>)
 800a11e:	681b      	ldr	r3, [r3, #0]
 800a120:	6979      	ldr	r1, [r7, #20]
 800a122:	4618      	mov	r0, r3
 800a124:	f7ff f976 	bl	8009414 <LOS_MemAlloc>
 800a128:	60f8      	str	r0, [r7, #12]
    if (listObject == NULL) {
 800a12a:	68fb      	ldr	r3, [r7, #12]
 800a12c:	2b00      	cmp	r3, #0
 800a12e:	d101      	bne.n	800a134 <OsSortLinkInit+0x28>
        return LOS_NOK;
 800a130:	2301      	movs	r3, #1
 800a132:	e01b      	b.n	800a16c <OsSortLinkInit+0x60>
    }

    (VOID)memset_s(listObject, size, 0, size);
 800a134:	697b      	ldr	r3, [r7, #20]
 800a136:	2200      	movs	r2, #0
 800a138:	6979      	ldr	r1, [r7, #20]
 800a13a:	68f8      	ldr	r0, [r7, #12]
 800a13c:	f7f7 ffb2 	bl	80020a4 <memset_s>
    sortLinkHeader->sortLink = listObject;
 800a140:	687b      	ldr	r3, [r7, #4]
 800a142:	68fa      	ldr	r2, [r7, #12]
 800a144:	601a      	str	r2, [r3, #0]
    sortLinkHeader->cursor = 0;
 800a146:	687b      	ldr	r3, [r7, #4]
 800a148:	2200      	movs	r2, #0
 800a14a:	809a      	strh	r2, [r3, #4]
    for (index = 0; index < OS_TSK_SORTLINK_LEN; index++, listObject++) {
 800a14c:	2300      	movs	r3, #0
 800a14e:	613b      	str	r3, [r7, #16]
 800a150:	e008      	b.n	800a164 <OsSortLinkInit+0x58>
        LOS_ListInit(listObject);
 800a152:	68f8      	ldr	r0, [r7, #12]
 800a154:	f7ff ff76 	bl	800a044 <LOS_ListInit>
    for (index = 0; index < OS_TSK_SORTLINK_LEN; index++, listObject++) {
 800a158:	693b      	ldr	r3, [r7, #16]
 800a15a:	3301      	adds	r3, #1
 800a15c:	613b      	str	r3, [r7, #16]
 800a15e:	68fb      	ldr	r3, [r7, #12]
 800a160:	3308      	adds	r3, #8
 800a162:	60fb      	str	r3, [r7, #12]
 800a164:	693b      	ldr	r3, [r7, #16]
 800a166:	2b07      	cmp	r3, #7
 800a168:	d9f3      	bls.n	800a152 <OsSortLinkInit+0x46>
    }
    return LOS_OK;
 800a16a:	2300      	movs	r3, #0
}
 800a16c:	4618      	mov	r0, r3
 800a16e:	3718      	adds	r7, #24
 800a170:	46bd      	mov	sp, r7
 800a172:	bd80      	pop	{r7, pc}
 800a174:	200021bc 	.word	0x200021bc

0800a178 <OsAdd2SortLink>:

LITE_OS_SEC_TEXT VOID OsAdd2SortLink(const SortLinkAttribute *sortLinkHeader, SortLinkList *sortList)
{
 800a178:	b580      	push	{r7, lr}
 800a17a:	b088      	sub	sp, #32
 800a17c:	af00      	add	r7, sp, #0
 800a17e:	6078      	str	r0, [r7, #4]
 800a180:	6039      	str	r1, [r7, #0]
    SortLinkList *listSorted = NULL;
 800a182:	2300      	movs	r3, #0
 800a184:	60fb      	str	r3, [r7, #12]
    LOS_DL_LIST *listObject = NULL;
 800a186:	2300      	movs	r3, #0
 800a188:	617b      	str	r3, [r7, #20]

    /*
     * huge rollnum could cause carry to invalid high bit
     * and eventually affect the calculation of sort index.
     */
    if (sortList->idxRollNum > OS_TSK_MAX_ROLLNUM) {
 800a18a:	683b      	ldr	r3, [r7, #0]
 800a18c:	689b      	ldr	r3, [r3, #8]
 800a18e:	f113 0f09 	cmn.w	r3, #9
 800a192:	d903      	bls.n	800a19c <OsAdd2SortLink+0x24>
        SET_SORTLIST_VALUE(sortList, OS_TSK_MAX_ROLLNUM);
 800a194:	683b      	ldr	r3, [r7, #0]
 800a196:	f06f 0208 	mvn.w	r2, #8
 800a19a:	609a      	str	r2, [r3, #8]
    }
    timeout = sortList->idxRollNum;
 800a19c:	683b      	ldr	r3, [r7, #0]
 800a19e:	689b      	ldr	r3, [r3, #8]
 800a1a0:	61bb      	str	r3, [r7, #24]
    sortIndex = timeout & OS_TSK_SORTLINK_MASK;
 800a1a2:	69bb      	ldr	r3, [r7, #24]
 800a1a4:	f003 0307 	and.w	r3, r3, #7
 800a1a8:	61fb      	str	r3, [r7, #28]
    rollNum = (timeout >> OS_TSK_SORTLINK_LOGLEN) + 1;
 800a1aa:	69bb      	ldr	r3, [r7, #24]
 800a1ac:	08db      	lsrs	r3, r3, #3
 800a1ae:	3301      	adds	r3, #1
 800a1b0:	613b      	str	r3, [r7, #16]
    if (sortIndex == 0) {
 800a1b2:	69fb      	ldr	r3, [r7, #28]
 800a1b4:	2b00      	cmp	r3, #0
 800a1b6:	d102      	bne.n	800a1be <OsAdd2SortLink+0x46>
        rollNum--;
 800a1b8:	693b      	ldr	r3, [r7, #16]
 800a1ba:	3b01      	subs	r3, #1
 800a1bc:	613b      	str	r3, [r7, #16]
    }
    EVALUATE_L(sortList->idxRollNum, rollNum);
 800a1be:	683b      	ldr	r3, [r7, #0]
 800a1c0:	689b      	ldr	r3, [r3, #8]
 800a1c2:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 800a1c6:	693b      	ldr	r3, [r7, #16]
 800a1c8:	431a      	orrs	r2, r3
 800a1ca:	683b      	ldr	r3, [r7, #0]
 800a1cc:	609a      	str	r2, [r3, #8]
    sortIndex = sortIndex + sortLinkHeader->cursor;
 800a1ce:	687b      	ldr	r3, [r7, #4]
 800a1d0:	889b      	ldrh	r3, [r3, #4]
 800a1d2:	461a      	mov	r2, r3
 800a1d4:	69fb      	ldr	r3, [r7, #28]
 800a1d6:	4413      	add	r3, r2
 800a1d8:	61fb      	str	r3, [r7, #28]
    sortIndex = sortIndex & OS_TSK_SORTLINK_MASK;
 800a1da:	69fb      	ldr	r3, [r7, #28]
 800a1dc:	f003 0307 	and.w	r3, r3, #7
 800a1e0:	61fb      	str	r3, [r7, #28]
    EVALUATE_H(sortList->idxRollNum, sortIndex);
 800a1e2:	683b      	ldr	r3, [r7, #0]
 800a1e4:	689b      	ldr	r3, [r3, #8]
 800a1e6:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 800a1ea:	69fb      	ldr	r3, [r7, #28]
 800a1ec:	075b      	lsls	r3, r3, #29
 800a1ee:	431a      	orrs	r2, r3
 800a1f0:	683b      	ldr	r3, [r7, #0]
 800a1f2:	609a      	str	r2, [r3, #8]

    listObject = sortLinkHeader->sortLink + sortIndex;
 800a1f4:	687b      	ldr	r3, [r7, #4]
 800a1f6:	681a      	ldr	r2, [r3, #0]
 800a1f8:	69fb      	ldr	r3, [r7, #28]
 800a1fa:	00db      	lsls	r3, r3, #3
 800a1fc:	4413      	add	r3, r2
 800a1fe:	617b      	str	r3, [r7, #20]
    if (listObject->pstNext == listObject) {
 800a200:	697b      	ldr	r3, [r7, #20]
 800a202:	685b      	ldr	r3, [r3, #4]
 800a204:	697a      	ldr	r2, [r7, #20]
 800a206:	429a      	cmp	r2, r3
 800a208:	d105      	bne.n	800a216 <OsAdd2SortLink+0x9e>
        LOS_ListTailInsert(listObject, &sortList->sortLinkNode);
 800a20a:	683b      	ldr	r3, [r7, #0]
 800a20c:	4619      	mov	r1, r3
 800a20e:	6978      	ldr	r0, [r7, #20]
 800a210:	f7ff ff41 	bl	800a096 <LOS_ListTailInsert>
            listSorted = LOS_DL_LIST_ENTRY(listSorted->sortLinkNode.pstNext, SortLinkList, sortLinkNode);
        } while (&listSorted->sortLinkNode != listObject);

        LOS_ListTailInsert(&listSorted->sortLinkNode, &sortList->sortLinkNode);
    }
}
 800a214:	e03b      	b.n	800a28e <OsAdd2SortLink+0x116>
        listSorted = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 800a216:	697b      	ldr	r3, [r7, #20]
 800a218:	685b      	ldr	r3, [r3, #4]
 800a21a:	60fb      	str	r3, [r7, #12]
            if (ROLLNUM(listSorted->idxRollNum) <= ROLLNUM(sortList->idxRollNum)) {
 800a21c:	68fb      	ldr	r3, [r7, #12]
 800a21e:	689b      	ldr	r3, [r3, #8]
 800a220:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 800a224:	683b      	ldr	r3, [r7, #0]
 800a226:	689b      	ldr	r3, [r3, #8]
 800a228:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 800a22c:	429a      	cmp	r2, r3
 800a22e:	d810      	bhi.n	800a252 <OsAdd2SortLink+0xda>
                ROLLNUM_SUB(sortList->idxRollNum, listSorted->idxRollNum);
 800a230:	683b      	ldr	r3, [r7, #0]
 800a232:	689b      	ldr	r3, [r3, #8]
 800a234:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 800a238:	683b      	ldr	r3, [r7, #0]
 800a23a:	689b      	ldr	r3, [r3, #8]
 800a23c:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 800a240:	68fb      	ldr	r3, [r7, #12]
 800a242:	689b      	ldr	r3, [r3, #8]
 800a244:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 800a248:	1acb      	subs	r3, r1, r3
 800a24a:	431a      	orrs	r2, r3
 800a24c:	683b      	ldr	r3, [r7, #0]
 800a24e:	609a      	str	r2, [r3, #8]
 800a250:	e010      	b.n	800a274 <OsAdd2SortLink+0xfc>
                ROLLNUM_SUB(listSorted->idxRollNum, sortList->idxRollNum);
 800a252:	68fb      	ldr	r3, [r7, #12]
 800a254:	689b      	ldr	r3, [r3, #8]
 800a256:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 800a25a:	68fb      	ldr	r3, [r7, #12]
 800a25c:	689b      	ldr	r3, [r3, #8]
 800a25e:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 800a262:	683b      	ldr	r3, [r7, #0]
 800a264:	689b      	ldr	r3, [r3, #8]
 800a266:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 800a26a:	1acb      	subs	r3, r1, r3
 800a26c:	431a      	orrs	r2, r3
 800a26e:	68fb      	ldr	r3, [r7, #12]
 800a270:	609a      	str	r2, [r3, #8]
                break;
 800a272:	e006      	b.n	800a282 <OsAdd2SortLink+0x10a>
            listSorted = LOS_DL_LIST_ENTRY(listSorted->sortLinkNode.pstNext, SortLinkList, sortLinkNode);
 800a274:	68fb      	ldr	r3, [r7, #12]
 800a276:	685b      	ldr	r3, [r3, #4]
 800a278:	60fb      	str	r3, [r7, #12]
        } while (&listSorted->sortLinkNode != listObject);
 800a27a:	68fb      	ldr	r3, [r7, #12]
 800a27c:	697a      	ldr	r2, [r7, #20]
 800a27e:	429a      	cmp	r2, r3
 800a280:	d1cc      	bne.n	800a21c <OsAdd2SortLink+0xa4>
        LOS_ListTailInsert(&listSorted->sortLinkNode, &sortList->sortLinkNode);
 800a282:	68fb      	ldr	r3, [r7, #12]
 800a284:	683a      	ldr	r2, [r7, #0]
 800a286:	4611      	mov	r1, r2
 800a288:	4618      	mov	r0, r3
 800a28a:	f7ff ff04 	bl	800a096 <LOS_ListTailInsert>
}
 800a28e:	bf00      	nop
 800a290:	3720      	adds	r7, #32
 800a292:	46bd      	mov	sp, r7
 800a294:	bd80      	pop	{r7, pc}

0800a296 <OsCheckSortLink>:

LITE_OS_SEC_TEXT STATIC VOID OsCheckSortLink(const LOS_DL_LIST *listHead, const LOS_DL_LIST *listNode)
{
 800a296:	b580      	push	{r7, lr}
 800a298:	b084      	sub	sp, #16
 800a29a:	af00      	add	r7, sp, #0
 800a29c:	6078      	str	r0, [r7, #4]
 800a29e:	6039      	str	r1, [r7, #0]
    LOS_DL_LIST *tmp = listNode->pstPrev;
 800a2a0:	683b      	ldr	r3, [r7, #0]
 800a2a2:	681b      	ldr	r3, [r3, #0]
 800a2a4:	60fb      	str	r3, [r7, #12]

    /* recursive check until double link round to itself */
    while (tmp != listNode) {
 800a2a6:	e006      	b.n	800a2b6 <OsCheckSortLink+0x20>
        if (tmp == listHead) {
 800a2a8:	68fa      	ldr	r2, [r7, #12]
 800a2aa:	687b      	ldr	r3, [r7, #4]
 800a2ac:	429a      	cmp	r2, r3
 800a2ae:	d009      	beq.n	800a2c4 <OsCheckSortLink+0x2e>
            return;
        }
        tmp = tmp->pstPrev;
 800a2b0:	68fb      	ldr	r3, [r7, #12]
 800a2b2:	681b      	ldr	r3, [r3, #0]
 800a2b4:	60fb      	str	r3, [r7, #12]
    while (tmp != listNode) {
 800a2b6:	68fa      	ldr	r2, [r7, #12]
 800a2b8:	683b      	ldr	r3, [r7, #0]
 800a2ba:	429a      	cmp	r2, r3
 800a2bc:	d1f4      	bne.n	800a2a8 <OsCheckSortLink+0x12>
    }

    /* delete invalid sortlink node */
    OsBackTrace();
 800a2be:	f7fa f92b 	bl	8004518 <LOS_BackTrace>
 800a2c2:	e000      	b.n	800a2c6 <OsCheckSortLink+0x30>
            return;
 800a2c4:	bf00      	nop
}
 800a2c6:	3710      	adds	r7, #16
 800a2c8:	46bd      	mov	sp, r7
 800a2ca:	bd80      	pop	{r7, pc}

0800a2cc <OsDeleteSortLink>:

LITE_OS_SEC_TEXT VOID OsDeleteSortLink(const SortLinkAttribute *sortLinkHeader, SortLinkList *sortList)
{
 800a2cc:	b580      	push	{r7, lr}
 800a2ce:	b086      	sub	sp, #24
 800a2d0:	af00      	add	r7, sp, #0
 800a2d2:	6078      	str	r0, [r7, #4]
 800a2d4:	6039      	str	r1, [r7, #0]
    LOS_DL_LIST *listObject = NULL;
 800a2d6:	2300      	movs	r3, #0
 800a2d8:	60fb      	str	r3, [r7, #12]
    SortLinkList *nextSortList = NULL;
 800a2da:	2300      	movs	r3, #0
 800a2dc:	613b      	str	r3, [r7, #16]
    UINT32 sortIndex;

    sortIndex = SORT_INDEX(sortList->idxRollNum);
 800a2de:	683b      	ldr	r3, [r7, #0]
 800a2e0:	689b      	ldr	r3, [r3, #8]
 800a2e2:	0f5b      	lsrs	r3, r3, #29
 800a2e4:	617b      	str	r3, [r7, #20]
    listObject = sortLinkHeader->sortLink + sortIndex;
 800a2e6:	687b      	ldr	r3, [r7, #4]
 800a2e8:	681a      	ldr	r2, [r3, #0]
 800a2ea:	697b      	ldr	r3, [r7, #20]
 800a2ec:	00db      	lsls	r3, r3, #3
 800a2ee:	4413      	add	r3, r2
 800a2f0:	60fb      	str	r3, [r7, #12]

    /* check if pstSortList node is on the right sortlink */
    OsCheckSortLink(listObject, &sortList->sortLinkNode);
 800a2f2:	683b      	ldr	r3, [r7, #0]
 800a2f4:	4619      	mov	r1, r3
 800a2f6:	68f8      	ldr	r0, [r7, #12]
 800a2f8:	f7ff ffcd 	bl	800a296 <OsCheckSortLink>

    if (listObject != sortList->sortLinkNode.pstNext) {
 800a2fc:	683b      	ldr	r3, [r7, #0]
 800a2fe:	685b      	ldr	r3, [r3, #4]
 800a300:	68fa      	ldr	r2, [r7, #12]
 800a302:	429a      	cmp	r2, r3
 800a304:	d012      	beq.n	800a32c <OsDeleteSortLink+0x60>
        nextSortList = LOS_DL_LIST_ENTRY(sortList->sortLinkNode.pstNext, SortLinkList, sortLinkNode);
 800a306:	683b      	ldr	r3, [r7, #0]
 800a308:	685b      	ldr	r3, [r3, #4]
 800a30a:	613b      	str	r3, [r7, #16]
        ROLLNUM_ADD(nextSortList->idxRollNum, sortList->idxRollNum);
 800a30c:	693b      	ldr	r3, [r7, #16]
 800a30e:	689b      	ldr	r3, [r3, #8]
 800a310:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 800a314:	693b      	ldr	r3, [r7, #16]
 800a316:	689b      	ldr	r3, [r3, #8]
 800a318:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 800a31c:	683b      	ldr	r3, [r7, #0]
 800a31e:	689b      	ldr	r3, [r3, #8]
 800a320:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 800a324:	440b      	add	r3, r1
 800a326:	431a      	orrs	r2, r3
 800a328:	693b      	ldr	r3, [r7, #16]
 800a32a:	609a      	str	r2, [r3, #8]
    }
    LOS_ListDelete(&sortList->sortLinkNode);
 800a32c:	683b      	ldr	r3, [r7, #0]
 800a32e:	4618      	mov	r0, r3
 800a330:	f7ff fec0 	bl	800a0b4 <LOS_ListDelete>
}
 800a334:	bf00      	nop
 800a336:	3718      	adds	r7, #24
 800a338:	46bd      	mov	sp, r7
 800a33a:	bd80      	pop	{r7, pc}

0800a33c <OsCalcExpierTime>:

LITE_OS_SEC_TEXT STATIC INLINE UINT32 OsCalcExpierTime(UINT32 rollNum, UINT32 sortIndex, UINT16 curSortIndex)
{
 800a33c:	b480      	push	{r7}
 800a33e:	b087      	sub	sp, #28
 800a340:	af00      	add	r7, sp, #0
 800a342:	60f8      	str	r0, [r7, #12]
 800a344:	60b9      	str	r1, [r7, #8]
 800a346:	4613      	mov	r3, r2
 800a348:	80fb      	strh	r3, [r7, #6]
    UINT32 expireTime;

    if (sortIndex > curSortIndex) {
 800a34a:	88fb      	ldrh	r3, [r7, #6]
 800a34c:	68ba      	ldr	r2, [r7, #8]
 800a34e:	429a      	cmp	r2, r3
 800a350:	d904      	bls.n	800a35c <OsCalcExpierTime+0x20>
        sortIndex = sortIndex - curSortIndex;
 800a352:	88fb      	ldrh	r3, [r7, #6]
 800a354:	68ba      	ldr	r2, [r7, #8]
 800a356:	1ad3      	subs	r3, r2, r3
 800a358:	60bb      	str	r3, [r7, #8]
 800a35a:	e004      	b.n	800a366 <OsCalcExpierTime+0x2a>
    } else {
        sortIndex = OS_TSK_SORTLINK_LEN - curSortIndex + sortIndex;
 800a35c:	88fb      	ldrh	r3, [r7, #6]
 800a35e:	68ba      	ldr	r2, [r7, #8]
 800a360:	1ad3      	subs	r3, r2, r3
 800a362:	3308      	adds	r3, #8
 800a364:	60bb      	str	r3, [r7, #8]
    }
    expireTime = ((rollNum - 1) << OS_TSK_SORTLINK_LOGLEN) + sortIndex;
 800a366:	68fb      	ldr	r3, [r7, #12]
 800a368:	3b01      	subs	r3, #1
 800a36a:	00db      	lsls	r3, r3, #3
 800a36c:	68ba      	ldr	r2, [r7, #8]
 800a36e:	4413      	add	r3, r2
 800a370:	617b      	str	r3, [r7, #20]
    return expireTime;
 800a372:	697b      	ldr	r3, [r7, #20]
}
 800a374:	4618      	mov	r0, r3
 800a376:	371c      	adds	r7, #28
 800a378:	46bd      	mov	sp, r7
 800a37a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a37e:	4770      	bx	lr

0800a380 <OsSortLinkGetNextExpireTime>:

LITE_OS_SEC_TEXT UINT32 OsSortLinkGetNextExpireTime(const SortLinkAttribute *sortLinkHeader)
{
 800a380:	b580      	push	{r7, lr}
 800a382:	b08a      	sub	sp, #40	; 0x28
 800a384:	af00      	add	r7, sp, #0
 800a386:	6078      	str	r0, [r7, #4]
    UINT16 cursor;
    UINT32 minSortIndex = OS_INVALID_VALUE;
 800a388:	f04f 33ff 	mov.w	r3, #4294967295
 800a38c:	613b      	str	r3, [r7, #16]
    UINT32 minRollNum = OS_TSK_LOW_BITS_MASK;
 800a38e:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
 800a392:	617b      	str	r3, [r7, #20]
    UINT32 expireTime = OS_INVALID_VALUE;
 800a394:	f04f 33ff 	mov.w	r3, #4294967295
 800a398:	61bb      	str	r3, [r7, #24]
    LOS_DL_LIST *listObject = NULL;
 800a39a:	2300      	movs	r3, #0
 800a39c:	623b      	str	r3, [r7, #32]
    SortLinkList *listSorted = NULL;
 800a39e:	2300      	movs	r3, #0
 800a3a0:	627b      	str	r3, [r7, #36]	; 0x24
    UINT32 i;

    cursor = (sortLinkHeader->cursor + 1) & OS_TSK_SORTLINK_MASK;
 800a3a2:	687b      	ldr	r3, [r7, #4]
 800a3a4:	889b      	ldrh	r3, [r3, #4]
 800a3a6:	3301      	adds	r3, #1
 800a3a8:	b29b      	uxth	r3, r3
 800a3aa:	f003 0307 	and.w	r3, r3, #7
 800a3ae:	81fb      	strh	r3, [r7, #14]

    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++) {
 800a3b0:	2300      	movs	r3, #0
 800a3b2:	61fb      	str	r3, [r7, #28]
 800a3b4:	e027      	b.n	800a406 <OsSortLinkGetNextExpireTime+0x86>
        listObject = sortLinkHeader->sortLink + ((cursor + i) & OS_TSK_SORTLINK_MASK);
 800a3b6:	687b      	ldr	r3, [r7, #4]
 800a3b8:	681a      	ldr	r2, [r3, #0]
 800a3ba:	89f9      	ldrh	r1, [r7, #14]
 800a3bc:	69fb      	ldr	r3, [r7, #28]
 800a3be:	440b      	add	r3, r1
 800a3c0:	f003 0307 	and.w	r3, r3, #7
 800a3c4:	00db      	lsls	r3, r3, #3
 800a3c6:	4413      	add	r3, r2
 800a3c8:	623b      	str	r3, [r7, #32]
        if (!LOS_ListEmpty(listObject)) {
 800a3ca:	6a38      	ldr	r0, [r7, #32]
 800a3cc:	f7ff fe8c 	bl	800a0e8 <LOS_ListEmpty>
 800a3d0:	4603      	mov	r3, r0
 800a3d2:	2b00      	cmp	r3, #0
 800a3d4:	d114      	bne.n	800a400 <OsSortLinkGetNextExpireTime+0x80>
            listSorted = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 800a3d6:	6a3b      	ldr	r3, [r7, #32]
 800a3d8:	685b      	ldr	r3, [r3, #4]
 800a3da:	627b      	str	r3, [r7, #36]	; 0x24
            if (minRollNum > ROLLNUM(listSorted->idxRollNum)) {
 800a3dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a3de:	689b      	ldr	r3, [r3, #8]
 800a3e0:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 800a3e4:	697a      	ldr	r2, [r7, #20]
 800a3e6:	429a      	cmp	r2, r3
 800a3e8:	d90a      	bls.n	800a400 <OsSortLinkGetNextExpireTime+0x80>
                minRollNum = ROLLNUM(listSorted->idxRollNum);
 800a3ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a3ec:	689b      	ldr	r3, [r3, #8]
 800a3ee:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 800a3f2:	617b      	str	r3, [r7, #20]
                minSortIndex = (cursor + i) & OS_TSK_SORTLINK_MASK;
 800a3f4:	89fa      	ldrh	r2, [r7, #14]
 800a3f6:	69fb      	ldr	r3, [r7, #28]
 800a3f8:	4413      	add	r3, r2
 800a3fa:	f003 0307 	and.w	r3, r3, #7
 800a3fe:	613b      	str	r3, [r7, #16]
    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++) {
 800a400:	69fb      	ldr	r3, [r7, #28]
 800a402:	3301      	adds	r3, #1
 800a404:	61fb      	str	r3, [r7, #28]
 800a406:	69fb      	ldr	r3, [r7, #28]
 800a408:	2b07      	cmp	r3, #7
 800a40a:	d9d4      	bls.n	800a3b6 <OsSortLinkGetNextExpireTime+0x36>
            }
        }
    }

    if (minRollNum != OS_TSK_LOW_BITS_MASK) {
 800a40c:	697b      	ldr	r3, [r7, #20]
 800a40e:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
 800a412:	4293      	cmp	r3, r2
 800a414:	d007      	beq.n	800a426 <OsSortLinkGetNextExpireTime+0xa6>
        expireTime = OsCalcExpierTime(minRollNum, minSortIndex, sortLinkHeader->cursor);
 800a416:	687b      	ldr	r3, [r7, #4]
 800a418:	889b      	ldrh	r3, [r3, #4]
 800a41a:	461a      	mov	r2, r3
 800a41c:	6939      	ldr	r1, [r7, #16]
 800a41e:	6978      	ldr	r0, [r7, #20]
 800a420:	f7ff ff8c 	bl	800a33c <OsCalcExpierTime>
 800a424:	61b8      	str	r0, [r7, #24]
    }

    return expireTime;
 800a426:	69bb      	ldr	r3, [r7, #24]
}
 800a428:	4618      	mov	r0, r3
 800a42a:	3728      	adds	r7, #40	; 0x28
 800a42c:	46bd      	mov	sp, r7
 800a42e:	bd80      	pop	{r7, pc}

0800a430 <OsSortLinkUpdateExpireTime>:

LITE_OS_SEC_TEXT VOID OsSortLinkUpdateExpireTime(UINT32 sleepTicks, SortLinkAttribute *sortLinkHeader)
{
 800a430:	b480      	push	{r7}
 800a432:	b089      	sub	sp, #36	; 0x24
 800a434:	af00      	add	r7, sp, #0
 800a436:	6078      	str	r0, [r7, #4]
 800a438:	6039      	str	r1, [r7, #0]
    SortLinkList *sortList = NULL;
 800a43a:	2300      	movs	r3, #0
 800a43c:	61bb      	str	r3, [r7, #24]
    LOS_DL_LIST *listObject = NULL;
 800a43e:	2300      	movs	r3, #0
 800a440:	61fb      	str	r3, [r7, #28]
    UINT32 i;
    UINT32 sortIndex;
    UINT32 rollNum;

    if (sleepTicks == 0) {
 800a442:	687b      	ldr	r3, [r7, #4]
 800a444:	2b00      	cmp	r3, #0
 800a446:	d056      	beq.n	800a4f6 <OsSortLinkUpdateExpireTime+0xc6>
        return;
    }
    sortIndex = sleepTicks & OS_TSK_SORTLINK_MASK;
 800a448:	687b      	ldr	r3, [r7, #4]
 800a44a:	f003 0307 	and.w	r3, r3, #7
 800a44e:	613b      	str	r3, [r7, #16]
    rollNum = (sleepTicks >> OS_TSK_SORTLINK_LOGLEN) + 1;
 800a450:	687b      	ldr	r3, [r7, #4]
 800a452:	08db      	lsrs	r3, r3, #3
 800a454:	3301      	adds	r3, #1
 800a456:	617b      	str	r3, [r7, #20]
    if (sortIndex == 0) {
 800a458:	693b      	ldr	r3, [r7, #16]
 800a45a:	2b00      	cmp	r3, #0
 800a45c:	d104      	bne.n	800a468 <OsSortLinkUpdateExpireTime+0x38>
        rollNum--;
 800a45e:	697b      	ldr	r3, [r7, #20]
 800a460:	3b01      	subs	r3, #1
 800a462:	617b      	str	r3, [r7, #20]
        sortIndex = OS_TSK_SORTLINK_LEN;
 800a464:	2308      	movs	r3, #8
 800a466:	613b      	str	r3, [r7, #16]
    }

    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++) {
 800a468:	2300      	movs	r3, #0
 800a46a:	60fb      	str	r3, [r7, #12]
 800a46c:	e032      	b.n	800a4d4 <OsSortLinkUpdateExpireTime+0xa4>
        listObject = sortLinkHeader->sortLink + ((sortLinkHeader->cursor + i) & OS_TSK_SORTLINK_MASK);
 800a46e:	683b      	ldr	r3, [r7, #0]
 800a470:	681a      	ldr	r2, [r3, #0]
 800a472:	683b      	ldr	r3, [r7, #0]
 800a474:	889b      	ldrh	r3, [r3, #4]
 800a476:	4619      	mov	r1, r3
 800a478:	68fb      	ldr	r3, [r7, #12]
 800a47a:	440b      	add	r3, r1
 800a47c:	f003 0307 	and.w	r3, r3, #7
 800a480:	00db      	lsls	r3, r3, #3
 800a482:	4413      	add	r3, r2
 800a484:	61fb      	str	r3, [r7, #28]
        if (listObject->pstNext != listObject) {
 800a486:	69fb      	ldr	r3, [r7, #28]
 800a488:	685b      	ldr	r3, [r3, #4]
 800a48a:	69fa      	ldr	r2, [r7, #28]
 800a48c:	429a      	cmp	r2, r3
 800a48e:	d01e      	beq.n	800a4ce <OsSortLinkUpdateExpireTime+0x9e>
            sortList = LOS_DL_LIST_ENTRY(listObject->pstNext, SortLinkList, sortLinkNode);
 800a490:	69fb      	ldr	r3, [r7, #28]
 800a492:	685b      	ldr	r3, [r3, #4]
 800a494:	61bb      	str	r3, [r7, #24]
            ROLLNUM_SUB(sortList->idxRollNum, rollNum - 1);
 800a496:	69bb      	ldr	r3, [r7, #24]
 800a498:	689b      	ldr	r3, [r3, #8]
 800a49a:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 800a49e:	69bb      	ldr	r3, [r7, #24]
 800a4a0:	689b      	ldr	r3, [r3, #8]
 800a4a2:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 800a4a6:	697b      	ldr	r3, [r7, #20]
 800a4a8:	3b01      	subs	r3, #1
 800a4aa:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 800a4ae:	1acb      	subs	r3, r1, r3
 800a4b0:	431a      	orrs	r2, r3
 800a4b2:	69bb      	ldr	r3, [r7, #24]
 800a4b4:	609a      	str	r2, [r3, #8]
            if ((i > 0) && (i < sortIndex)) {
 800a4b6:	68fb      	ldr	r3, [r7, #12]
 800a4b8:	2b00      	cmp	r3, #0
 800a4ba:	d008      	beq.n	800a4ce <OsSortLinkUpdateExpireTime+0x9e>
 800a4bc:	68fa      	ldr	r2, [r7, #12]
 800a4be:	693b      	ldr	r3, [r7, #16]
 800a4c0:	429a      	cmp	r2, r3
 800a4c2:	d204      	bcs.n	800a4ce <OsSortLinkUpdateExpireTime+0x9e>
                ROLLNUM_DEC(sortList->idxRollNum);
 800a4c4:	69bb      	ldr	r3, [r7, #24]
 800a4c6:	689b      	ldr	r3, [r3, #8]
 800a4c8:	1e5a      	subs	r2, r3, #1
 800a4ca:	69bb      	ldr	r3, [r7, #24]
 800a4cc:	609a      	str	r2, [r3, #8]
    for (i = 0; i < OS_TSK_SORTLINK_LEN; i++) {
 800a4ce:	68fb      	ldr	r3, [r7, #12]
 800a4d0:	3301      	adds	r3, #1
 800a4d2:	60fb      	str	r3, [r7, #12]
 800a4d4:	68fb      	ldr	r3, [r7, #12]
 800a4d6:	2b07      	cmp	r3, #7
 800a4d8:	d9c9      	bls.n	800a46e <OsSortLinkUpdateExpireTime+0x3e>
            }
        }
    }
    sortLinkHeader->cursor = (sortLinkHeader->cursor + sleepTicks - 1) % OS_TSK_SORTLINK_LEN;
 800a4da:	683b      	ldr	r3, [r7, #0]
 800a4dc:	889a      	ldrh	r2, [r3, #4]
 800a4de:	687b      	ldr	r3, [r7, #4]
 800a4e0:	b29b      	uxth	r3, r3
 800a4e2:	4413      	add	r3, r2
 800a4e4:	b29b      	uxth	r3, r3
 800a4e6:	3b01      	subs	r3, #1
 800a4e8:	b29b      	uxth	r3, r3
 800a4ea:	f003 0307 	and.w	r3, r3, #7
 800a4ee:	b29a      	uxth	r2, r3
 800a4f0:	683b      	ldr	r3, [r7, #0]
 800a4f2:	809a      	strh	r2, [r3, #4]
 800a4f4:	e000      	b.n	800a4f8 <OsSortLinkUpdateExpireTime+0xc8>
        return;
 800a4f6:	bf00      	nop
}
 800a4f8:	3724      	adds	r7, #36	; 0x24
 800a4fa:	46bd      	mov	sp, r7
 800a4fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a500:	4770      	bx	lr

0800a502 <OsStackWaterLineGet>:

const StackInfo *g_stackInfo = NULL;
UINT32 g_stackNum;

UINT32 OsStackWaterLineGet(const UINTPTR *stackBottom, const UINTPTR *stackTop, UINT32 *peakUsed)
{
 800a502:	b480      	push	{r7}
 800a504:	b087      	sub	sp, #28
 800a506:	af00      	add	r7, sp, #0
 800a508:	60f8      	str	r0, [r7, #12]
 800a50a:	60b9      	str	r1, [r7, #8]
 800a50c:	607a      	str	r2, [r7, #4]
    UINT32 size;
    const UINTPTR *tmp = NULL;
 800a50e:	2300      	movs	r3, #0
 800a510:	613b      	str	r3, [r7, #16]
    if (*stackTop == OS_STACK_MAGIC_WORD) {
 800a512:	68bb      	ldr	r3, [r7, #8]
 800a514:	681b      	ldr	r3, [r3, #0]
 800a516:	f1b3 3fcc 	cmp.w	r3, #3435973836	; 0xcccccccc
 800a51a:	d11e      	bne.n	800a55a <OsStackWaterLineGet+0x58>
        tmp = stackTop + 1;
 800a51c:	68bb      	ldr	r3, [r7, #8]
 800a51e:	3304      	adds	r3, #4
 800a520:	613b      	str	r3, [r7, #16]
        while ((tmp < stackBottom) && (*tmp == OS_STACK_INIT)) {
 800a522:	e002      	b.n	800a52a <OsStackWaterLineGet+0x28>
            tmp++;
 800a524:	693b      	ldr	r3, [r7, #16]
 800a526:	3304      	adds	r3, #4
 800a528:	613b      	str	r3, [r7, #16]
        while ((tmp < stackBottom) && (*tmp == OS_STACK_INIT)) {
 800a52a:	693a      	ldr	r2, [r7, #16]
 800a52c:	68fb      	ldr	r3, [r7, #12]
 800a52e:	429a      	cmp	r2, r3
 800a530:	d204      	bcs.n	800a53c <OsStackWaterLineGet+0x3a>
 800a532:	693b      	ldr	r3, [r7, #16]
 800a534:	681b      	ldr	r3, [r3, #0]
 800a536:	f1b3 3fca 	cmp.w	r3, #3402287818	; 0xcacacaca
 800a53a:	d0f3      	beq.n	800a524 <OsStackWaterLineGet+0x22>
        }
        size = (UINT32)((UINTPTR)stackBottom - (UINTPTR)tmp);
 800a53c:	68fa      	ldr	r2, [r7, #12]
 800a53e:	693b      	ldr	r3, [r7, #16]
 800a540:	1ad3      	subs	r3, r2, r3
 800a542:	617b      	str	r3, [r7, #20]
        *peakUsed = (size == 0) ? size : (size + sizeof(CHAR *));
 800a544:	697b      	ldr	r3, [r7, #20]
 800a546:	2b00      	cmp	r3, #0
 800a548:	d002      	beq.n	800a550 <OsStackWaterLineGet+0x4e>
 800a54a:	697b      	ldr	r3, [r7, #20]
 800a54c:	3304      	adds	r3, #4
 800a54e:	e000      	b.n	800a552 <OsStackWaterLineGet+0x50>
 800a550:	697b      	ldr	r3, [r7, #20]
 800a552:	687a      	ldr	r2, [r7, #4]
 800a554:	6013      	str	r3, [r2, #0]
        return LOS_OK;
 800a556:	2300      	movs	r3, #0
 800a558:	e004      	b.n	800a564 <OsStackWaterLineGet+0x62>
    } else {
        *peakUsed = OS_INVALID_WATERLINE;
 800a55a:	687b      	ldr	r3, [r7, #4]
 800a55c:	f04f 32ff 	mov.w	r2, #4294967295
 800a560:	601a      	str	r2, [r3, #0]
        return LOS_NOK;
 800a562:	2301      	movs	r3, #1
    }
}
 800a564:	4618      	mov	r0, r3
 800a566:	371c      	adds	r7, #28
 800a568:	46bd      	mov	sp, r7
 800a56a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a56e:	4770      	bx	lr

0800a570 <OsStackInit>:
    g_stackInfo = stackInfo;
    g_stackNum = stackNum;
}

VOID OsStackInit(VOID *stacktop, UINT32 stacksize)
{
 800a570:	b580      	push	{r7, lr}
 800a572:	b082      	sub	sp, #8
 800a574:	af00      	add	r7, sp, #0
 800a576:	6078      	str	r0, [r7, #4]
 800a578:	6039      	str	r1, [r7, #0]
    /* initialize the task stack, write magic num to stack top */
    (VOID)memset_s(stacktop, stacksize, (INT32)OS_STACK_INIT, stacksize);
 800a57a:	683b      	ldr	r3, [r7, #0]
 800a57c:	f04f 32ca 	mov.w	r2, #3402287818	; 0xcacacaca
 800a580:	6839      	ldr	r1, [r7, #0]
 800a582:	6878      	ldr	r0, [r7, #4]
 800a584:	f7f7 fd8e 	bl	80020a4 <memset_s>
    *((UINTPTR *)stacktop) = OS_STACK_MAGIC_WORD;
 800a588:	687b      	ldr	r3, [r7, #4]
 800a58a:	f04f 32cc 	mov.w	r2, #3435973836	; 0xcccccccc
 800a58e:	601a      	str	r2, [r3, #0]
}
 800a590:	bf00      	nop
 800a592:	3708      	adds	r7, #8
 800a594:	46bd      	mov	sp, r7
 800a596:	bd80      	pop	{r7, pc}

0800a598 <LOS_ListInit>:
{
 800a598:	b480      	push	{r7}
 800a59a:	b083      	sub	sp, #12
 800a59c:	af00      	add	r7, sp, #0
 800a59e:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 800a5a0:	687b      	ldr	r3, [r7, #4]
 800a5a2:	687a      	ldr	r2, [r7, #4]
 800a5a4:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 800a5a6:	687b      	ldr	r3, [r7, #4]
 800a5a8:	687a      	ldr	r2, [r7, #4]
 800a5aa:	601a      	str	r2, [r3, #0]
}
 800a5ac:	bf00      	nop
 800a5ae:	370c      	adds	r7, #12
 800a5b0:	46bd      	mov	sp, r7
 800a5b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a5b6:	4770      	bx	lr

0800a5b8 <LOS_ListAdd>:
{
 800a5b8:	b480      	push	{r7}
 800a5ba:	b083      	sub	sp, #12
 800a5bc:	af00      	add	r7, sp, #0
 800a5be:	6078      	str	r0, [r7, #4]
 800a5c0:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 800a5c2:	687b      	ldr	r3, [r7, #4]
 800a5c4:	685a      	ldr	r2, [r3, #4]
 800a5c6:	683b      	ldr	r3, [r7, #0]
 800a5c8:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 800a5ca:	683b      	ldr	r3, [r7, #0]
 800a5cc:	687a      	ldr	r2, [r7, #4]
 800a5ce:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 800a5d0:	687b      	ldr	r3, [r7, #4]
 800a5d2:	685b      	ldr	r3, [r3, #4]
 800a5d4:	683a      	ldr	r2, [r7, #0]
 800a5d6:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 800a5d8:	687b      	ldr	r3, [r7, #4]
 800a5da:	683a      	ldr	r2, [r7, #0]
 800a5dc:	605a      	str	r2, [r3, #4]
}
 800a5de:	bf00      	nop
 800a5e0:	370c      	adds	r7, #12
 800a5e2:	46bd      	mov	sp, r7
 800a5e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a5e8:	4770      	bx	lr

0800a5ea <LOS_ListTailInsert>:
{
 800a5ea:	b580      	push	{r7, lr}
 800a5ec:	b082      	sub	sp, #8
 800a5ee:	af00      	add	r7, sp, #0
 800a5f0:	6078      	str	r0, [r7, #4]
 800a5f2:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 800a5f4:	687b      	ldr	r3, [r7, #4]
 800a5f6:	681b      	ldr	r3, [r3, #0]
 800a5f8:	6839      	ldr	r1, [r7, #0]
 800a5fa:	4618      	mov	r0, r3
 800a5fc:	f7ff ffdc 	bl	800a5b8 <LOS_ListAdd>
}
 800a600:	bf00      	nop
 800a602:	3708      	adds	r7, #8
 800a604:	46bd      	mov	sp, r7
 800a606:	bd80      	pop	{r7, pc}

0800a608 <LOS_ListDelete>:
{
 800a608:	b480      	push	{r7}
 800a60a:	b083      	sub	sp, #12
 800a60c:	af00      	add	r7, sp, #0
 800a60e:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 800a610:	687b      	ldr	r3, [r7, #4]
 800a612:	685b      	ldr	r3, [r3, #4]
 800a614:	687a      	ldr	r2, [r7, #4]
 800a616:	6812      	ldr	r2, [r2, #0]
 800a618:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 800a61a:	687b      	ldr	r3, [r7, #4]
 800a61c:	681b      	ldr	r3, [r3, #0]
 800a61e:	687a      	ldr	r2, [r7, #4]
 800a620:	6852      	ldr	r2, [r2, #4]
 800a622:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 800a624:	687b      	ldr	r3, [r7, #4]
 800a626:	2200      	movs	r2, #0
 800a628:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 800a62a:	687b      	ldr	r3, [r7, #4]
 800a62c:	2200      	movs	r2, #0
 800a62e:	601a      	str	r2, [r3, #0]
}
 800a630:	bf00      	nop
 800a632:	370c      	adds	r7, #12
 800a634:	46bd      	mov	sp, r7
 800a636:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a63a:	4770      	bx	lr

0800a63c <LOS_ListEmpty>:
{
 800a63c:	b480      	push	{r7}
 800a63e:	b083      	sub	sp, #12
 800a640:	af00      	add	r7, sp, #0
 800a642:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 800a644:	687b      	ldr	r3, [r7, #4]
 800a646:	685b      	ldr	r3, [r3, #4]
 800a648:	687a      	ldr	r2, [r7, #4]
 800a64a:	429a      	cmp	r2, r3
 800a64c:	bf0c      	ite	eq
 800a64e:	2301      	moveq	r3, #1
 800a650:	2300      	movne	r3, #0
 800a652:	b2db      	uxtb	r3, r3
}
 800a654:	4618      	mov	r0, r3
 800a656:	370c      	adds	r7, #12
 800a658:	46bd      	mov	sp, r7
 800a65a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a65e:	4770      	bx	lr

0800a660 <ArchCurrCpuid>:
{
 800a660:	b480      	push	{r7}
 800a662:	af00      	add	r7, sp, #0
    return 0;
 800a664:	2300      	movs	r3, #0
}
 800a666:	4618      	mov	r0, r3
 800a668:	46bd      	mov	sp, r7
 800a66a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a66e:	4770      	bx	lr

0800a670 <LOS_IntLock>:
{
 800a670:	b580      	push	{r7, lr}
 800a672:	af00      	add	r7, sp, #0
    return ArchIntLock();
 800a674:	f7f6 fb28 	bl	8000cc8 <ArchIntLock>
 800a678:	4603      	mov	r3, r0
}
 800a67a:	4618      	mov	r0, r3
 800a67c:	bd80      	pop	{r7, pc}

0800a67e <LOS_IntRestore>:
{
 800a67e:	b580      	push	{r7, lr}
 800a680:	b082      	sub	sp, #8
 800a682:	af00      	add	r7, sp, #0
 800a684:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800a686:	6878      	ldr	r0, [r7, #4]
 800a688:	f7f6 fb26 	bl	8000cd8 <ArchIntRestore>
}
 800a68c:	bf00      	nop
 800a68e:	3708      	adds	r7, #8
 800a690:	46bd      	mov	sp, r7
 800a692:	bd80      	pop	{r7, pc}

0800a694 <ArchCurrTaskGet>:
{
 800a694:	b480      	push	{r7}
 800a696:	af00      	add	r7, sp, #0
    return g_runTask;
 800a698:	4b03      	ldr	r3, [pc, #12]	; (800a6a8 <ArchCurrTaskGet+0x14>)
 800a69a:	681b      	ldr	r3, [r3, #0]
}
 800a69c:	4618      	mov	r0, r3
 800a69e:	46bd      	mov	sp, r7
 800a6a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6a4:	4770      	bx	lr
 800a6a6:	bf00      	nop
 800a6a8:	200033cc 	.word	0x200033cc

0800a6ac <OsPercpuGet>:
{
 800a6ac:	b580      	push	{r7, lr}
 800a6ae:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 800a6b0:	f7ff ffd6 	bl	800a660 <ArchCurrCpuid>
 800a6b4:	4602      	mov	r2, r0
 800a6b6:	4613      	mov	r3, r2
 800a6b8:	00db      	lsls	r3, r3, #3
 800a6ba:	4413      	add	r3, r2
 800a6bc:	009b      	lsls	r3, r3, #2
 800a6be:	4a02      	ldr	r2, [pc, #8]	; (800a6c8 <OsPercpuGet+0x1c>)
 800a6c0:	4413      	add	r3, r2
}
 800a6c2:	4618      	mov	r0, r3
 800a6c4:	bd80      	pop	{r7, pc}
 800a6c6:	bf00      	nop
 800a6c8:	200036fc 	.word	0x200036fc

0800a6cc <OsPreemptableInSched>:
{
 800a6cc:	b580      	push	{r7, lr}
 800a6ce:	b082      	sub	sp, #8
 800a6d0:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 800a6d2:	2300      	movs	r3, #0
 800a6d4:	607b      	str	r3, [r7, #4]
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 800a6d6:	f7ff ffe9 	bl	800a6ac <OsPercpuGet>
 800a6da:	4603      	mov	r3, r0
 800a6dc:	695b      	ldr	r3, [r3, #20]
 800a6de:	2b00      	cmp	r3, #0
 800a6e0:	bf0c      	ite	eq
 800a6e2:	2301      	moveq	r3, #1
 800a6e4:	2300      	movne	r3, #0
 800a6e6:	b2db      	uxtb	r3, r3
 800a6e8:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 800a6ea:	687b      	ldr	r3, [r7, #4]
 800a6ec:	2b00      	cmp	r3, #0
 800a6ee:	d104      	bne.n	800a6fa <OsPreemptableInSched+0x2e>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 800a6f0:	f7ff ffdc 	bl	800a6ac <OsPercpuGet>
 800a6f4:	4603      	mov	r3, r0
 800a6f6:	2201      	movs	r2, #1
 800a6f8:	621a      	str	r2, [r3, #32]
    return preemptable;
 800a6fa:	687b      	ldr	r3, [r7, #4]
}
 800a6fc:	4618      	mov	r0, r3
 800a6fe:	3708      	adds	r7, #8
 800a700:	46bd      	mov	sp, r7
 800a702:	bd80      	pop	{r7, pc}

0800a704 <LOS_Schedule>:
{
 800a704:	b580      	push	{r7, lr}
 800a706:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 800a708:	f7f7 ffaa 	bl	8002660 <IntActive>
 800a70c:	4603      	mov	r3, r0
 800a70e:	2b00      	cmp	r3, #0
 800a710:	d005      	beq.n	800a71e <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 800a712:	f7ff ffcb 	bl	800a6ac <OsPercpuGet>
 800a716:	4603      	mov	r3, r0
 800a718:	2201      	movs	r2, #1
 800a71a:	621a      	str	r2, [r3, #32]
        return;
 800a71c:	e001      	b.n	800a722 <LOS_Schedule+0x1e>
    OsSchedPreempt();
 800a71e:	f7fe fb09 	bl	8008d34 <OsSchedPreempt>
}
 800a722:	bd80      	pop	{r7, pc}

0800a724 <LOS_SpinLockSave>:
{
 800a724:	b580      	push	{r7, lr}
 800a726:	b082      	sub	sp, #8
 800a728:	af00      	add	r7, sp, #0
 800a72a:	6078      	str	r0, [r7, #4]
 800a72c:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 800a72e:	f7ff ff9f 	bl	800a670 <LOS_IntLock>
 800a732:	4602      	mov	r2, r0
 800a734:	683b      	ldr	r3, [r7, #0]
 800a736:	601a      	str	r2, [r3, #0]
}
 800a738:	bf00      	nop
 800a73a:	3708      	adds	r7, #8
 800a73c:	46bd      	mov	sp, r7
 800a73e:	bd80      	pop	{r7, pc}

0800a740 <LOS_SpinUnlockRestore>:
{
 800a740:	b580      	push	{r7, lr}
 800a742:	b082      	sub	sp, #8
 800a744:	af00      	add	r7, sp, #0
 800a746:	6078      	str	r0, [r7, #4]
 800a748:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 800a74a:	6838      	ldr	r0, [r7, #0]
 800a74c:	f7ff ff97 	bl	800a67e <LOS_IntRestore>
}
 800a750:	bf00      	nop
 800a752:	3708      	adds	r7, #8
 800a754:	46bd      	mov	sp, r7
 800a756:	bd80      	pop	{r7, pc}

0800a758 <OsCurrTaskGet>:
{
 800a758:	b580      	push	{r7, lr}
 800a75a:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 800a75c:	f7ff ff9a 	bl	800a694 <ArchCurrTaskGet>
 800a760:	4603      	mov	r3, r0
}
 800a762:	4618      	mov	r0, r3
 800a764:	bd80      	pop	{r7, pc}

0800a766 <OsQueueDbgInitHook>:
#endif /* __cplusplus */

/* queue debug initialization interface */
extern UINT32 OsQueueDbgInit(VOID);
STATIC INLINE UINT32 OsQueueDbgInitHook(VOID)
{
 800a766:	b580      	push	{r7, lr}
 800a768:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_QUEUE
    return OsQueueDbgInit();
 800a76a:	f7fb fbd7 	bl	8005f1c <OsQueueDbgInit>
 800a76e:	4603      	mov	r3, r0
#else
    return LOS_OK;
#endif
}
 800a770:	4618      	mov	r0, r3
 800a772:	bd80      	pop	{r7, pc}

0800a774 <OsQueueDbgTimeUpdateHook>:
/* Update the last time the queue was executed */
extern VOID OsQueueDbgTimeUpdate(UINT32 queueId);
STATIC INLINE VOID OsQueueDbgTimeUpdateHook(UINT32 queueId)
{
 800a774:	b580      	push	{r7, lr}
 800a776:	b082      	sub	sp, #8
 800a778:	af00      	add	r7, sp, #0
 800a77a:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_DEBUG_QUEUE
    OsQueueDbgTimeUpdate(queueId);
 800a77c:	6878      	ldr	r0, [r7, #4]
 800a77e:	f7fb fbff 	bl	8005f80 <OsQueueDbgTimeUpdate>
#endif
}
 800a782:	bf00      	nop
 800a784:	3708      	adds	r7, #8
 800a786:	46bd      	mov	sp, r7
 800a788:	bd80      	pop	{r7, pc}

0800a78a <OsQueueDbgUpdateHook>:
/* Update the task  entry of  the queue debug info when created or deleted */
extern VOID OsQueueDbgUpdate(UINT32 queueId, TSK_ENTRY_FUNC entry);
STATIC INLINE VOID OsQueueDbgUpdateHook(UINT32 queueId, TSK_ENTRY_FUNC entry)
{
 800a78a:	b580      	push	{r7, lr}
 800a78c:	b082      	sub	sp, #8
 800a78e:	af00      	add	r7, sp, #0
 800a790:	6078      	str	r0, [r7, #4]
 800a792:	6039      	str	r1, [r7, #0]
#ifdef LOSCFG_DEBUG_QUEUE
    OsQueueDbgUpdate(queueId, entry);
 800a794:	6839      	ldr	r1, [r7, #0]
 800a796:	6878      	ldr	r0, [r7, #4]
 800a798:	f7fb fc0a 	bl	8005fb0 <OsQueueDbgUpdate>
#endif
}
 800a79c:	bf00      	nop
 800a79e:	3708      	adds	r7, #8
 800a7a0:	46bd      	mov	sp, r7
 800a7a2:	bd80      	pop	{r7, pc}

0800a7a4 <OsQueueCheckHook>:
/* check the leak of queue */
extern VOID OsQueueCheck(VOID);
STATIC INLINE VOID OsQueueCheckHook(VOID)
{
 800a7a4:	b580      	push	{r7, lr}
 800a7a6:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_QUEUE
    OsQueueCheck();
 800a7a8:	f7fb fce8 	bl	800617c <OsQueueCheck>
#endif
}
 800a7ac:	bf00      	nop
 800a7ae:	bd80      	pop	{r7, pc}

0800a7b0 <LOS_MpSchedule>:
{
 800a7b0:	b480      	push	{r7}
 800a7b2:	b083      	sub	sp, #12
 800a7b4:	af00      	add	r7, sp, #0
 800a7b6:	6078      	str	r0, [r7, #4]
}
 800a7b8:	bf00      	nop
 800a7ba:	370c      	adds	r7, #12
 800a7bc:	46bd      	mov	sp, r7
 800a7be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7c2:	4770      	bx	lr

0800a7c4 <OsQueueInit>:
/*
 * Description : queue initial
 * Return      : LOS_OK on success or error code on failure
 */
LITE_OS_SEC_TEXT_INIT UINT32 OsQueueInit(VOID)
{
 800a7c4:	b580      	push	{r7, lr}
 800a7c6:	b084      	sub	sp, #16
 800a7c8:	af00      	add	r7, sp, #0
    LosQueueCB *queueNode = NULL;
 800a7ca:	2300      	movs	r3, #0
 800a7cc:	60bb      	str	r3, [r7, #8]
    UINT32 index;
    UINT32 size;

    size = KERNEL_QUEUE_LIMIT * sizeof(LosQueueCB);
 800a7ce:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 800a7d2:	60fb      	str	r3, [r7, #12]
    /* system resident memory, don't free */
    g_allQueue = (LosQueueCB *)LOS_MemAlloc(m_aucSysMem0, size);
 800a7d4:	4b1f      	ldr	r3, [pc, #124]	; (800a854 <OsQueueInit+0x90>)
 800a7d6:	681b      	ldr	r3, [r3, #0]
 800a7d8:	68f9      	ldr	r1, [r7, #12]
 800a7da:	4618      	mov	r0, r3
 800a7dc:	f7fe fe1a 	bl	8009414 <LOS_MemAlloc>
 800a7e0:	4603      	mov	r3, r0
 800a7e2:	4a1d      	ldr	r2, [pc, #116]	; (800a858 <OsQueueInit+0x94>)
 800a7e4:	6013      	str	r3, [r2, #0]
    if (g_allQueue == NULL) {
 800a7e6:	4b1c      	ldr	r3, [pc, #112]	; (800a858 <OsQueueInit+0x94>)
 800a7e8:	681b      	ldr	r3, [r3, #0]
 800a7ea:	2b00      	cmp	r3, #0
 800a7ec:	d101      	bne.n	800a7f2 <OsQueueInit+0x2e>
        return LOS_ERRNO_QUEUE_NO_MEMORY;
 800a7ee:	4b1b      	ldr	r3, [pc, #108]	; (800a85c <OsQueueInit+0x98>)
 800a7f0:	e02c      	b.n	800a84c <OsQueueInit+0x88>
    }
    (VOID)memset_s(g_allQueue, size, 0, size);
 800a7f2:	4b19      	ldr	r3, [pc, #100]	; (800a858 <OsQueueInit+0x94>)
 800a7f4:	6818      	ldr	r0, [r3, #0]
 800a7f6:	68fb      	ldr	r3, [r7, #12]
 800a7f8:	2200      	movs	r2, #0
 800a7fa:	68f9      	ldr	r1, [r7, #12]
 800a7fc:	f7f7 fc52 	bl	80020a4 <memset_s>
    LOS_ListInit(&g_freeQueueList);
 800a800:	4817      	ldr	r0, [pc, #92]	; (800a860 <OsQueueInit+0x9c>)
 800a802:	f7ff fec9 	bl	800a598 <LOS_ListInit>
    for (index = 0; index < KERNEL_QUEUE_LIMIT; index++) {
 800a806:	2300      	movs	r3, #0
 800a808:	607b      	str	r3, [r7, #4]
 800a80a:	e014      	b.n	800a836 <OsQueueInit+0x72>
        queueNode = ((LosQueueCB *)g_allQueue) + index;
 800a80c:	4b12      	ldr	r3, [pc, #72]	; (800a858 <OsQueueInit+0x94>)
 800a80e:	6819      	ldr	r1, [r3, #0]
 800a810:	687a      	ldr	r2, [r7, #4]
 800a812:	4613      	mov	r3, r2
 800a814:	005b      	lsls	r3, r3, #1
 800a816:	4413      	add	r3, r2
 800a818:	011b      	lsls	r3, r3, #4
 800a81a:	440b      	add	r3, r1
 800a81c:	60bb      	str	r3, [r7, #8]
        queueNode->queueId = index;
 800a81e:	68bb      	ldr	r3, [r7, #8]
 800a820:	687a      	ldr	r2, [r7, #4]
 800a822:	60da      	str	r2, [r3, #12]
        LOS_ListTailInsert(&g_freeQueueList, &queueNode->readWriteList[OS_QUEUE_WRITE]);
 800a824:	68bb      	ldr	r3, [r7, #8]
 800a826:	3320      	adds	r3, #32
 800a828:	4619      	mov	r1, r3
 800a82a:	480d      	ldr	r0, [pc, #52]	; (800a860 <OsQueueInit+0x9c>)
 800a82c:	f7ff fedd 	bl	800a5ea <LOS_ListTailInsert>
    for (index = 0; index < KERNEL_QUEUE_LIMIT; index++) {
 800a830:	687b      	ldr	r3, [r7, #4]
 800a832:	3301      	adds	r3, #1
 800a834:	607b      	str	r3, [r7, #4]
 800a836:	687b      	ldr	r3, [r7, #4]
 800a838:	2b09      	cmp	r3, #9
 800a83a:	d9e7      	bls.n	800a80c <OsQueueInit+0x48>
    }

    if (OsQueueDbgInitHook() != LOS_OK) {
 800a83c:	f7ff ff93 	bl	800a766 <OsQueueDbgInitHook>
 800a840:	4603      	mov	r3, r0
 800a842:	2b00      	cmp	r3, #0
 800a844:	d001      	beq.n	800a84a <OsQueueInit+0x86>
        return LOS_ERRNO_QUEUE_NO_MEMORY;
 800a846:	4b05      	ldr	r3, [pc, #20]	; (800a85c <OsQueueInit+0x98>)
 800a848:	e000      	b.n	800a84c <OsQueueInit+0x88>
    }
    return LOS_OK;
 800a84a:	2300      	movs	r3, #0
}
 800a84c:	4618      	mov	r0, r3
 800a84e:	3710      	adds	r7, #16
 800a850:	46bd      	mov	sp, r7
 800a852:	bd80      	pop	{r7, pc}
 800a854:	200021bc 	.word	0x200021bc
 800a858:	200021c4 	.word	0x200021c4
 800a85c:	02000601 	.word	0x02000601
 800a860:	200021c8 	.word	0x200021c8

0800a864 <OsQueueCreateParameterCheck>:

STATIC INLINE UINT32 OsQueueCreateParameterCheck(UINT16 len, const UINT32 *queueId, UINT16 maxMsgSize)
{
 800a864:	b480      	push	{r7}
 800a866:	b083      	sub	sp, #12
 800a868:	af00      	add	r7, sp, #0
 800a86a:	4603      	mov	r3, r0
 800a86c:	6039      	str	r1, [r7, #0]
 800a86e:	80fb      	strh	r3, [r7, #6]
 800a870:	4613      	mov	r3, r2
 800a872:	80bb      	strh	r3, [r7, #4]
    if (queueId == NULL) {
 800a874:	683b      	ldr	r3, [r7, #0]
 800a876:	2b00      	cmp	r3, #0
 800a878:	d101      	bne.n	800a87e <OsQueueCreateParameterCheck+0x1a>
        return LOS_ERRNO_QUEUE_CREAT_PTR_NULL;
 800a87a:	4b0c      	ldr	r3, [pc, #48]	; (800a8ac <OsQueueCreateParameterCheck+0x48>)
 800a87c:	e00f      	b.n	800a89e <OsQueueCreateParameterCheck+0x3a>
    }

    if (maxMsgSize > (OS_NULL_SHORT - sizeof(UINT32))) {
 800a87e:	88bb      	ldrh	r3, [r7, #4]
 800a880:	f64f 72fb 	movw	r2, #65531	; 0xfffb
 800a884:	4293      	cmp	r3, r2
 800a886:	d901      	bls.n	800a88c <OsQueueCreateParameterCheck+0x28>
        return LOS_ERRNO_QUEUE_SIZE_TOO_BIG;
 800a888:	4b09      	ldr	r3, [pc, #36]	; (800a8b0 <OsQueueCreateParameterCheck+0x4c>)
 800a88a:	e008      	b.n	800a89e <OsQueueCreateParameterCheck+0x3a>
    }

    if ((len == 0) || (maxMsgSize == 0)) {
 800a88c:	88fb      	ldrh	r3, [r7, #6]
 800a88e:	2b00      	cmp	r3, #0
 800a890:	d002      	beq.n	800a898 <OsQueueCreateParameterCheck+0x34>
 800a892:	88bb      	ldrh	r3, [r7, #4]
 800a894:	2b00      	cmp	r3, #0
 800a896:	d101      	bne.n	800a89c <OsQueueCreateParameterCheck+0x38>
        return LOS_ERRNO_QUEUE_PARA_ISZERO;
 800a898:	4b06      	ldr	r3, [pc, #24]	; (800a8b4 <OsQueueCreateParameterCheck+0x50>)
 800a89a:	e000      	b.n	800a89e <OsQueueCreateParameterCheck+0x3a>
    }
    return LOS_OK;
 800a89c:	2300      	movs	r3, #0
}
 800a89e:	4618      	mov	r0, r3
 800a8a0:	370c      	adds	r7, #12
 800a8a2:	46bd      	mov	sp, r7
 800a8a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a8a8:	4770      	bx	lr
 800a8aa:	bf00      	nop
 800a8ac:	0200060c 	.word	0x0200060c
 800a8b0:	02000603 	.word	0x02000603
 800a8b4:	0200060d 	.word	0x0200060d

0800a8b8 <OsQueueCreateInternal>:

LITE_OS_SEC_TEXT_INIT STATIC UINT32 OsQueueCreateInternal(UINT16 len, UINT32 *queueId, UINT16 msgSize,
                                                          UINT8 *queue, UINT8 queueMemType)
{
 800a8b8:	b590      	push	{r4, r7, lr}
 800a8ba:	b091      	sub	sp, #68	; 0x44
 800a8bc:	af00      	add	r7, sp, #0
 800a8be:	60b9      	str	r1, [r7, #8]
 800a8c0:	607b      	str	r3, [r7, #4]
 800a8c2:	4603      	mov	r3, r0
 800a8c4:	81fb      	strh	r3, [r7, #14]
 800a8c6:	4613      	mov	r3, r2
 800a8c8:	81bb      	strh	r3, [r7, #12]
 800a8ca:	4b4e      	ldr	r3, [pc, #312]	; (800aa04 <OsQueueCreateInternal+0x14c>)
 800a8cc:	681b      	ldr	r3, [r3, #0]
 800a8ce:	63fb      	str	r3, [r7, #60]	; 0x3c
 800a8d0:	f04f 0300 	mov.w	r3, #0
    LosQueueCB *queueCB = NULL;
 800a8d4:	2300      	movs	r3, #0
 800a8d6:	61bb      	str	r3, [r7, #24]
    LOS_DL_LIST *unusedQueue = NULL;
 800a8d8:	2300      	movs	r3, #0
 800a8da:	61fb      	str	r3, [r7, #28]
    UINT32 intSave;

    SCHEDULER_LOCK(intSave);
 800a8dc:	f107 0314 	add.w	r3, r7, #20
 800a8e0:	4619      	mov	r1, r3
 800a8e2:	4849      	ldr	r0, [pc, #292]	; (800aa08 <OsQueueCreateInternal+0x150>)
 800a8e4:	f7ff ff1e 	bl	800a724 <LOS_SpinLockSave>
    if (LOS_ListEmpty(&g_freeQueueList)) {
 800a8e8:	4848      	ldr	r0, [pc, #288]	; (800aa0c <OsQueueCreateInternal+0x154>)
 800a8ea:	f7ff fea7 	bl	800a63c <LOS_ListEmpty>
 800a8ee:	4603      	mov	r3, r0
 800a8f0:	2b00      	cmp	r3, #0
 800a8f2:	d008      	beq.n	800a906 <OsQueueCreateInternal+0x4e>
        SCHEDULER_UNLOCK(intSave);
 800a8f4:	697b      	ldr	r3, [r7, #20]
 800a8f6:	4619      	mov	r1, r3
 800a8f8:	4843      	ldr	r0, [pc, #268]	; (800aa08 <OsQueueCreateInternal+0x150>)
 800a8fa:	f7ff ff21 	bl	800a740 <LOS_SpinUnlockRestore>
        OsQueueCheckHook();
 800a8fe:	f7ff ff51 	bl	800a7a4 <OsQueueCheckHook>
        return LOS_ERRNO_QUEUE_CB_UNAVAILABLE;
 800a902:	4b43      	ldr	r3, [pc, #268]	; (800aa10 <OsQueueCreateInternal+0x158>)
 800a904:	e072      	b.n	800a9ec <OsQueueCreateInternal+0x134>
    }

    unusedQueue = LOS_DL_LIST_FIRST(&g_freeQueueList);
 800a906:	4b41      	ldr	r3, [pc, #260]	; (800aa0c <OsQueueCreateInternal+0x154>)
 800a908:	685b      	ldr	r3, [r3, #4]
 800a90a:	61fb      	str	r3, [r7, #28]
    LOS_ListDelete(unusedQueue);
 800a90c:	69f8      	ldr	r0, [r7, #28]
 800a90e:	f7ff fe7b 	bl	800a608 <LOS_ListDelete>
    queueCB = GET_QUEUE_LIST(unusedQueue);
 800a912:	69fb      	ldr	r3, [r7, #28]
 800a914:	3b20      	subs	r3, #32
 800a916:	61bb      	str	r3, [r7, #24]
    queueCB->queueLen = len;
 800a918:	69bb      	ldr	r3, [r7, #24]
 800a91a:	89fa      	ldrh	r2, [r7, #14]
 800a91c:	80da      	strh	r2, [r3, #6]
    queueCB->queueSize = msgSize;
 800a91e:	69bb      	ldr	r3, [r7, #24]
 800a920:	89ba      	ldrh	r2, [r7, #12]
 800a922:	811a      	strh	r2, [r3, #8]
    queueCB->queueHandle = queue;
 800a924:	69bb      	ldr	r3, [r7, #24]
 800a926:	687a      	ldr	r2, [r7, #4]
 800a928:	601a      	str	r2, [r3, #0]
    queueCB->queueState = LOS_USED;
 800a92a:	69bb      	ldr	r3, [r7, #24]
 800a92c:	2201      	movs	r2, #1
 800a92e:	711a      	strb	r2, [r3, #4]
    queueCB->queueMemType = queueMemType;
 800a930:	69bb      	ldr	r3, [r7, #24]
 800a932:	f897 2050 	ldrb.w	r2, [r7, #80]	; 0x50
 800a936:	715a      	strb	r2, [r3, #5]
    queueCB->readWriteableCnt[OS_QUEUE_READ] = 0;
 800a938:	69bb      	ldr	r3, [r7, #24]
 800a93a:	2200      	movs	r2, #0
 800a93c:	829a      	strh	r2, [r3, #20]
    queueCB->readWriteableCnt[OS_QUEUE_WRITE] = len;
 800a93e:	69bb      	ldr	r3, [r7, #24]
 800a940:	89fa      	ldrh	r2, [r7, #14]
 800a942:	82da      	strh	r2, [r3, #22]
    queueCB->queueHead = 0;
 800a944:	69bb      	ldr	r3, [r7, #24]
 800a946:	2200      	movs	r2, #0
 800a948:	821a      	strh	r2, [r3, #16]
    queueCB->queueTail = 0;
 800a94a:	69bb      	ldr	r3, [r7, #24]
 800a94c:	2200      	movs	r2, #0
 800a94e:	825a      	strh	r2, [r3, #18]
    LOS_ListInit(&queueCB->readWriteList[OS_QUEUE_READ]);
 800a950:	69bb      	ldr	r3, [r7, #24]
 800a952:	3318      	adds	r3, #24
 800a954:	4618      	mov	r0, r3
 800a956:	f7ff fe1f 	bl	800a598 <LOS_ListInit>
    LOS_ListInit(&queueCB->readWriteList[OS_QUEUE_WRITE]);
 800a95a:	69bb      	ldr	r3, [r7, #24]
 800a95c:	3320      	adds	r3, #32
 800a95e:	4618      	mov	r0, r3
 800a960:	f7ff fe1a 	bl	800a598 <LOS_ListInit>
    LOS_ListInit(&queueCB->memList);
 800a964:	69bb      	ldr	r3, [r7, #24]
 800a966:	3328      	adds	r3, #40	; 0x28
 800a968:	4618      	mov	r0, r3
 800a96a:	f7ff fe15 	bl	800a598 <LOS_ListInit>

    OsQueueDbgUpdateHook(queueCB->queueId, OsCurrTaskGet()->taskEntry);
 800a96e:	69bb      	ldr	r3, [r7, #24]
 800a970:	68dc      	ldr	r4, [r3, #12]
 800a972:	f7ff fef1 	bl	800a758 <OsCurrTaskGet>
 800a976:	4603      	mov	r3, r0
 800a978:	699b      	ldr	r3, [r3, #24]
 800a97a:	4619      	mov	r1, r3
 800a97c:	4620      	mov	r0, r4
 800a97e:	f7ff ff04 	bl	800a78a <OsQueueDbgUpdateHook>
    SCHEDULER_UNLOCK(intSave);
 800a982:	697b      	ldr	r3, [r7, #20]
 800a984:	4619      	mov	r1, r3
 800a986:	4820      	ldr	r0, [pc, #128]	; (800aa08 <OsQueueCreateInternal+0x150>)
 800a988:	f7ff feda 	bl	800a740 <LOS_SpinUnlockRestore>

    *queueId = queueCB->queueId;
 800a98c:	69bb      	ldr	r3, [r7, #24]
 800a98e:	68da      	ldr	r2, [r3, #12]
 800a990:	68bb      	ldr	r3, [r7, #8]
 800a992:	601a      	str	r2, [r3, #0]

    LOS_TRACE(QUEUE_CREATE, *queueId, len, msgSize - sizeof(UINT32), (UINTPTR)queue, queueMemType);
 800a994:	2300      	movs	r3, #0
 800a996:	627b      	str	r3, [r7, #36]	; 0x24
 800a998:	68bb      	ldr	r3, [r7, #8]
 800a99a:	681b      	ldr	r3, [r3, #0]
 800a99c:	62bb      	str	r3, [r7, #40]	; 0x28
 800a99e:	89fb      	ldrh	r3, [r7, #14]
 800a9a0:	62fb      	str	r3, [r7, #44]	; 0x2c
 800a9a2:	89bb      	ldrh	r3, [r7, #12]
 800a9a4:	3b04      	subs	r3, #4
 800a9a6:	633b      	str	r3, [r7, #48]	; 0x30
 800a9a8:	687b      	ldr	r3, [r7, #4]
 800a9aa:	637b      	str	r3, [r7, #52]	; 0x34
 800a9ac:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800a9b0:	63bb      	str	r3, [r7, #56]	; 0x38
 800a9b2:	2306      	movs	r3, #6
 800a9b4:	623b      	str	r3, [r7, #32]
 800a9b6:	6a3b      	ldr	r3, [r7, #32]
 800a9b8:	2b01      	cmp	r3, #1
 800a9ba:	d916      	bls.n	800a9ea <OsQueueCreateInternal+0x132>
 800a9bc:	4b15      	ldr	r3, [pc, #84]	; (800aa14 <OsQueueCreateInternal+0x15c>)
 800a9be:	681b      	ldr	r3, [r3, #0]
 800a9c0:	2b00      	cmp	r3, #0
 800a9c2:	d012      	beq.n	800a9ea <OsQueueCreateInternal+0x132>
 800a9c4:	4b13      	ldr	r3, [pc, #76]	; (800aa14 <OsQueueCreateInternal+0x15c>)
 800a9c6:	681c      	ldr	r4, [r3, #0]
 800a9c8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800a9ca:	6a3b      	ldr	r3, [r7, #32]
 800a9cc:	2b02      	cmp	r3, #2
 800a9ce:	d904      	bls.n	800a9da <OsQueueCreateInternal+0x122>
 800a9d0:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800a9d4:	f103 0208 	add.w	r2, r3, #8
 800a9d8:	e000      	b.n	800a9dc <OsQueueCreateInternal+0x124>
 800a9da:	2200      	movs	r2, #0
 800a9dc:	6a3b      	ldr	r3, [r7, #32]
 800a9de:	b29b      	uxth	r3, r3
 800a9e0:	3b02      	subs	r3, #2
 800a9e2:	b29b      	uxth	r3, r3
 800a9e4:	f44f 7000 	mov.w	r0, #512	; 0x200
 800a9e8:	47a0      	blx	r4
    return LOS_OK;
 800a9ea:	2300      	movs	r3, #0
}
 800a9ec:	4a05      	ldr	r2, [pc, #20]	; (800aa04 <OsQueueCreateInternal+0x14c>)
 800a9ee:	6811      	ldr	r1, [r2, #0]
 800a9f0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800a9f2:	4051      	eors	r1, r2
 800a9f4:	d001      	beq.n	800a9fa <OsQueueCreateInternal+0x142>
 800a9f6:	f7f9 fdf1 	bl	80045dc <__stack_chk_fail>
 800a9fa:	4618      	mov	r0, r3
 800a9fc:	3744      	adds	r7, #68	; 0x44
 800a9fe:	46bd      	mov	sp, r7
 800aa00:	bd90      	pop	{r4, r7, pc}
 800aa02:	bf00      	nop
 800aa04:	080214d8 	.word	0x080214d8
 800aa08:	20000770 	.word	0x20000770
 800aa0c:	200021c8 	.word	0x200021c8
 800aa10:	02000604 	.word	0x02000604
 800aa14:	20000768 	.word	0x20000768

0800aa18 <LOS_QueueCreate>:
}
#endif

LITE_OS_SEC_TEXT_INIT UINT32 LOS_QueueCreate(const CHAR *queueName, UINT16 len, UINT32 *queueId,
                                             UINT32 flags, UINT16 maxMsgSize)
{
 800aa18:	b580      	push	{r7, lr}
 800aa1a:	b08a      	sub	sp, #40	; 0x28
 800aa1c:	af02      	add	r7, sp, #8
 800aa1e:	60f8      	str	r0, [r7, #12]
 800aa20:	607a      	str	r2, [r7, #4]
 800aa22:	603b      	str	r3, [r7, #0]
 800aa24:	460b      	mov	r3, r1
 800aa26:	817b      	strh	r3, [r7, #10]
    UINT32 ret;
    UINT8 *queueMem = NULL;
 800aa28:	2300      	movs	r3, #0
 800aa2a:	61bb      	str	r3, [r7, #24]
    UINT16 msgSize;
    (VOID)queueName;
    (VOID)flags;

    ret = OsQueueCreateParameterCheck(len, queueId, maxMsgSize);
 800aa2c:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 800aa2e:	897b      	ldrh	r3, [r7, #10]
 800aa30:	6879      	ldr	r1, [r7, #4]
 800aa32:	4618      	mov	r0, r3
 800aa34:	f7ff ff16 	bl	800a864 <OsQueueCreateParameterCheck>
 800aa38:	61f8      	str	r0, [r7, #28]
    if (ret != LOS_OK) {
 800aa3a:	69fb      	ldr	r3, [r7, #28]
 800aa3c:	2b00      	cmp	r3, #0
 800aa3e:	d001      	beq.n	800aa44 <LOS_QueueCreate+0x2c>
        return ret;
 800aa40:	69fb      	ldr	r3, [r7, #28]
 800aa42:	e026      	b.n	800aa92 <LOS_QueueCreate+0x7a>
    }

    msgSize = maxMsgSize + sizeof(UINT32);
 800aa44:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800aa46:	3304      	adds	r3, #4
 800aa48:	82fb      	strh	r3, [r7, #22]
    /*
     * Memory allocation is time-consuming, to shorten the time of disable interrupt,
     * move the memory allocation to here.
     */
    queueMem = (UINT8 *)LOS_MemAlloc(m_aucSysMem1, (UINT32)len * msgSize);
 800aa4a:	4b14      	ldr	r3, [pc, #80]	; (800aa9c <LOS_QueueCreate+0x84>)
 800aa4c:	6818      	ldr	r0, [r3, #0]
 800aa4e:	897b      	ldrh	r3, [r7, #10]
 800aa50:	8afa      	ldrh	r2, [r7, #22]
 800aa52:	fb02 f303 	mul.w	r3, r2, r3
 800aa56:	4619      	mov	r1, r3
 800aa58:	f7fe fcdc 	bl	8009414 <LOS_MemAlloc>
 800aa5c:	61b8      	str	r0, [r7, #24]
    if (queueMem == NULL) {
 800aa5e:	69bb      	ldr	r3, [r7, #24]
 800aa60:	2b00      	cmp	r3, #0
 800aa62:	d101      	bne.n	800aa68 <LOS_QueueCreate+0x50>
        return LOS_ERRNO_QUEUE_CREATE_NO_MEMORY;
 800aa64:	4b0e      	ldr	r3, [pc, #56]	; (800aaa0 <LOS_QueueCreate+0x88>)
 800aa66:	e014      	b.n	800aa92 <LOS_QueueCreate+0x7a>
    }

    ret = OsQueueCreateInternal(len, queueId, msgSize, queueMem, OS_QUEUE_ALLOC_DYNAMIC);
 800aa68:	8afa      	ldrh	r2, [r7, #22]
 800aa6a:	8978      	ldrh	r0, [r7, #10]
 800aa6c:	2300      	movs	r3, #0
 800aa6e:	9300      	str	r3, [sp, #0]
 800aa70:	69bb      	ldr	r3, [r7, #24]
 800aa72:	6879      	ldr	r1, [r7, #4]
 800aa74:	f7ff ff20 	bl	800a8b8 <OsQueueCreateInternal>
 800aa78:	61f8      	str	r0, [r7, #28]
    if (ret != LOS_OK) {
 800aa7a:	69fb      	ldr	r3, [r7, #28]
 800aa7c:	2b00      	cmp	r3, #0
 800aa7e:	d007      	beq.n	800aa90 <LOS_QueueCreate+0x78>
        (VOID)LOS_MemFree(m_aucSysMem1, queueMem);
 800aa80:	4b06      	ldr	r3, [pc, #24]	; (800aa9c <LOS_QueueCreate+0x84>)
 800aa82:	681b      	ldr	r3, [r3, #0]
 800aa84:	69b9      	ldr	r1, [r7, #24]
 800aa86:	4618      	mov	r0, r3
 800aa88:	f7fe fd7c 	bl	8009584 <LOS_MemFree>
        return ret;
 800aa8c:	69fb      	ldr	r3, [r7, #28]
 800aa8e:	e000      	b.n	800aa92 <LOS_QueueCreate+0x7a>
    }

    return LOS_OK;
 800aa90:	2300      	movs	r3, #0
}
 800aa92:	4618      	mov	r0, r3
 800aa94:	3720      	adds	r7, #32
 800aa96:	46bd      	mov	sp, r7
 800aa98:	bd80      	pop	{r7, pc}
 800aa9a:	bf00      	nop
 800aa9c:	200021c0 	.word	0x200021c0
 800aaa0:	02000602 	.word	0x02000602

0800aaa4 <OsQueueReadParameterCheck>:

LITE_OS_SEC_TEXT STATIC UINT32 OsQueueReadParameterCheck(UINT32 queueId, const VOID *bufferAddr,
                                                         const UINT32 *bufferSize, UINT32 timeout)
{
 800aaa4:	b580      	push	{r7, lr}
 800aaa6:	b084      	sub	sp, #16
 800aaa8:	af00      	add	r7, sp, #0
 800aaaa:	60f8      	str	r0, [r7, #12]
 800aaac:	60b9      	str	r1, [r7, #8]
 800aaae:	607a      	str	r2, [r7, #4]
 800aab0:	603b      	str	r3, [r7, #0]
    if (GET_QUEUE_INDEX(queueId) >= KERNEL_QUEUE_LIMIT) {
 800aab2:	68fb      	ldr	r3, [r7, #12]
 800aab4:	b29b      	uxth	r3, r3
 800aab6:	2b09      	cmp	r3, #9
 800aab8:	d901      	bls.n	800aabe <OsQueueReadParameterCheck+0x1a>
        return LOS_ERRNO_QUEUE_INVALID;
 800aaba:	4b14      	ldr	r3, [pc, #80]	; (800ab0c <OsQueueReadParameterCheck+0x68>)
 800aabc:	e021      	b.n	800ab02 <OsQueueReadParameterCheck+0x5e>
    }

    if ((bufferAddr == NULL) || (bufferSize == NULL)) {
 800aabe:	68bb      	ldr	r3, [r7, #8]
 800aac0:	2b00      	cmp	r3, #0
 800aac2:	d002      	beq.n	800aaca <OsQueueReadParameterCheck+0x26>
 800aac4:	687b      	ldr	r3, [r7, #4]
 800aac6:	2b00      	cmp	r3, #0
 800aac8:	d101      	bne.n	800aace <OsQueueReadParameterCheck+0x2a>
        return LOS_ERRNO_QUEUE_READ_PTR_NULL;
 800aaca:	4b11      	ldr	r3, [pc, #68]	; (800ab10 <OsQueueReadParameterCheck+0x6c>)
 800aacc:	e019      	b.n	800ab02 <OsQueueReadParameterCheck+0x5e>
    }

    if ((*bufferSize == 0) || (*bufferSize > (OS_NULL_SHORT - sizeof(UINT32)))) {
 800aace:	687b      	ldr	r3, [r7, #4]
 800aad0:	681b      	ldr	r3, [r3, #0]
 800aad2:	2b00      	cmp	r3, #0
 800aad4:	d005      	beq.n	800aae2 <OsQueueReadParameterCheck+0x3e>
 800aad6:	687b      	ldr	r3, [r7, #4]
 800aad8:	681b      	ldr	r3, [r3, #0]
 800aada:	f64f 72fb 	movw	r2, #65531	; 0xfffb
 800aade:	4293      	cmp	r3, r2
 800aae0:	d901      	bls.n	800aae6 <OsQueueReadParameterCheck+0x42>
        return LOS_ERRNO_QUEUE_READSIZE_IS_INVALID;
 800aae2:	4b0c      	ldr	r3, [pc, #48]	; (800ab14 <OsQueueReadParameterCheck+0x70>)
 800aae4:	e00d      	b.n	800ab02 <OsQueueReadParameterCheck+0x5e>
    }

    OsQueueDbgTimeUpdateHook(queueId);
 800aae6:	68f8      	ldr	r0, [r7, #12]
 800aae8:	f7ff fe44 	bl	800a774 <OsQueueDbgTimeUpdateHook>

    if (timeout != LOS_NO_WAIT) {
 800aaec:	683b      	ldr	r3, [r7, #0]
 800aaee:	2b00      	cmp	r3, #0
 800aaf0:	d006      	beq.n	800ab00 <OsQueueReadParameterCheck+0x5c>
        if (OS_INT_ACTIVE) {
 800aaf2:	f7f7 fdb5 	bl	8002660 <IntActive>
 800aaf6:	4603      	mov	r3, r0
 800aaf8:	2b00      	cmp	r3, #0
 800aafa:	d001      	beq.n	800ab00 <OsQueueReadParameterCheck+0x5c>
            return LOS_ERRNO_QUEUE_READ_IN_INTERRUPT;
 800aafc:	4b06      	ldr	r3, [pc, #24]	; (800ab18 <OsQueueReadParameterCheck+0x74>)
 800aafe:	e000      	b.n	800ab02 <OsQueueReadParameterCheck+0x5e>
        }
    }
    return LOS_OK;
 800ab00:	2300      	movs	r3, #0
}
 800ab02:	4618      	mov	r0, r3
 800ab04:	3710      	adds	r7, #16
 800ab06:	46bd      	mov	sp, r7
 800ab08:	bd80      	pop	{r7, pc}
 800ab0a:	bf00      	nop
 800ab0c:	0200060e 	.word	0x0200060e
 800ab10:	0200060f 	.word	0x0200060f
 800ab14:	02000610 	.word	0x02000610
 800ab18:	02000618 	.word	0x02000618

0800ab1c <OsQueueWriteParameterCheck>:

LITE_OS_SEC_TEXT STATIC UINT32 OsQueueWriteParameterCheck(UINT32 queueId, const VOID *bufferAddr,
                                                          const UINT32 *bufferSize, UINT32 timeout)
{
 800ab1c:	b580      	push	{r7, lr}
 800ab1e:	b084      	sub	sp, #16
 800ab20:	af00      	add	r7, sp, #0
 800ab22:	60f8      	str	r0, [r7, #12]
 800ab24:	60b9      	str	r1, [r7, #8]
 800ab26:	607a      	str	r2, [r7, #4]
 800ab28:	603b      	str	r3, [r7, #0]
    if (GET_QUEUE_INDEX(queueId) >= KERNEL_QUEUE_LIMIT) {
 800ab2a:	68fb      	ldr	r3, [r7, #12]
 800ab2c:	b29b      	uxth	r3, r3
 800ab2e:	2b09      	cmp	r3, #9
 800ab30:	d901      	bls.n	800ab36 <OsQueueWriteParameterCheck+0x1a>
        return LOS_ERRNO_QUEUE_INVALID;
 800ab32:	4b0f      	ldr	r3, [pc, #60]	; (800ab70 <OsQueueWriteParameterCheck+0x54>)
 800ab34:	e018      	b.n	800ab68 <OsQueueWriteParameterCheck+0x4c>
    }

    if (bufferAddr == NULL) {
 800ab36:	68bb      	ldr	r3, [r7, #8]
 800ab38:	2b00      	cmp	r3, #0
 800ab3a:	d101      	bne.n	800ab40 <OsQueueWriteParameterCheck+0x24>
        return LOS_ERRNO_QUEUE_WRITE_PTR_NULL;
 800ab3c:	4b0d      	ldr	r3, [pc, #52]	; (800ab74 <OsQueueWriteParameterCheck+0x58>)
 800ab3e:	e013      	b.n	800ab68 <OsQueueWriteParameterCheck+0x4c>
    }

    if (*bufferSize == 0) {
 800ab40:	687b      	ldr	r3, [r7, #4]
 800ab42:	681b      	ldr	r3, [r3, #0]
 800ab44:	2b00      	cmp	r3, #0
 800ab46:	d101      	bne.n	800ab4c <OsQueueWriteParameterCheck+0x30>
        return LOS_ERRNO_QUEUE_WRITESIZE_ISZERO;
 800ab48:	4b0b      	ldr	r3, [pc, #44]	; (800ab78 <OsQueueWriteParameterCheck+0x5c>)
 800ab4a:	e00d      	b.n	800ab68 <OsQueueWriteParameterCheck+0x4c>
    }

    OsQueueDbgTimeUpdateHook(queueId);
 800ab4c:	68f8      	ldr	r0, [r7, #12]
 800ab4e:	f7ff fe11 	bl	800a774 <OsQueueDbgTimeUpdateHook>

    if (timeout != LOS_NO_WAIT) {
 800ab52:	683b      	ldr	r3, [r7, #0]
 800ab54:	2b00      	cmp	r3, #0
 800ab56:	d006      	beq.n	800ab66 <OsQueueWriteParameterCheck+0x4a>
        if (OS_INT_ACTIVE) {
 800ab58:	f7f7 fd82 	bl	8002660 <IntActive>
 800ab5c:	4603      	mov	r3, r0
 800ab5e:	2b00      	cmp	r3, #0
 800ab60:	d001      	beq.n	800ab66 <OsQueueWriteParameterCheck+0x4a>
            return LOS_ERRNO_QUEUE_WRITE_IN_INTERRUPT;
 800ab62:	4b06      	ldr	r3, [pc, #24]	; (800ab7c <OsQueueWriteParameterCheck+0x60>)
 800ab64:	e000      	b.n	800ab68 <OsQueueWriteParameterCheck+0x4c>
        }
    }
    return LOS_OK;
 800ab66:	2300      	movs	r3, #0
}
 800ab68:	4618      	mov	r0, r3
 800ab6a:	3710      	adds	r7, #16
 800ab6c:	46bd      	mov	sp, r7
 800ab6e:	bd80      	pop	{r7, pc}
 800ab70:	0200060e 	.word	0x0200060e
 800ab74:	02000612 	.word	0x02000612
 800ab78:	02000613 	.word	0x02000613
 800ab7c:	02000609 	.word	0x02000609

0800ab80 <OsQueueBufferOperate>:

STATIC UINT32 OsQueueBufferOperate(LosQueueCB *queueCB, UINT32 operateType, VOID *bufferAddr, UINT32 *bufferSize)
{
 800ab80:	b580      	push	{r7, lr}
 800ab82:	b088      	sub	sp, #32
 800ab84:	af00      	add	r7, sp, #0
 800ab86:	60f8      	str	r0, [r7, #12]
 800ab88:	60b9      	str	r1, [r7, #8]
 800ab8a:	607a      	str	r2, [r7, #4]
 800ab8c:	603b      	str	r3, [r7, #0]
 800ab8e:	4b55      	ldr	r3, [pc, #340]	; (800ace4 <OsQueueBufferOperate+0x164>)
 800ab90:	681b      	ldr	r3, [r3, #0]
 800ab92:	61fb      	str	r3, [r7, #28]
 800ab94:	f04f 0300 	mov.w	r3, #0
    UINT8 *queueNode = NULL;
 800ab98:	2300      	movs	r3, #0
 800ab9a:	61bb      	str	r3, [r7, #24]
    UINT32 msgDataSize;
    UINT16 queuePosition;

    /* get the queue position */
    switch (OS_QUEUE_OPERATE_GET(operateType)) {
 800ab9c:	68bb      	ldr	r3, [r7, #8]
 800ab9e:	f003 0303 	and.w	r3, r3, #3
 800aba2:	2b03      	cmp	r3, #3
 800aba4:	d030      	beq.n	800ac08 <OsQueueBufferOperate+0x88>
 800aba6:	2b03      	cmp	r3, #3
 800aba8:	d843      	bhi.n	800ac32 <OsQueueBufferOperate+0xb2>
 800abaa:	2b00      	cmp	r3, #0
 800abac:	d002      	beq.n	800abb4 <OsQueueBufferOperate+0x34>
 800abae:	2b01      	cmp	r3, #1
 800abb0:	d015      	beq.n	800abde <OsQueueBufferOperate+0x5e>
 800abb2:	e03e      	b.n	800ac32 <OsQueueBufferOperate+0xb2>
        case OS_QUEUE_READ_HEAD:
            queuePosition = queueCB->queueHead;
 800abb4:	68fb      	ldr	r3, [r7, #12]
 800abb6:	8a1b      	ldrh	r3, [r3, #16]
 800abb8:	827b      	strh	r3, [r7, #18]
            ((queueCB->queueHead + 1) == queueCB->queueLen) ? (queueCB->queueHead = 0) : (queueCB->queueHead++);
 800abba:	68fb      	ldr	r3, [r7, #12]
 800abbc:	8a1b      	ldrh	r3, [r3, #16]
 800abbe:	3301      	adds	r3, #1
 800abc0:	68fa      	ldr	r2, [r7, #12]
 800abc2:	88d2      	ldrh	r2, [r2, #6]
 800abc4:	4293      	cmp	r3, r2
 800abc6:	d103      	bne.n	800abd0 <OsQueueBufferOperate+0x50>
 800abc8:	68fb      	ldr	r3, [r7, #12]
 800abca:	2200      	movs	r2, #0
 800abcc:	821a      	strh	r2, [r3, #16]
            break;
 800abce:	e032      	b.n	800ac36 <OsQueueBufferOperate+0xb6>
            ((queueCB->queueHead + 1) == queueCB->queueLen) ? (queueCB->queueHead = 0) : (queueCB->queueHead++);
 800abd0:	68fb      	ldr	r3, [r7, #12]
 800abd2:	8a1b      	ldrh	r3, [r3, #16]
 800abd4:	3301      	adds	r3, #1
 800abd6:	b29a      	uxth	r2, r3
 800abd8:	68fb      	ldr	r3, [r7, #12]
 800abda:	821a      	strh	r2, [r3, #16]
            break;
 800abdc:	e02b      	b.n	800ac36 <OsQueueBufferOperate+0xb6>
        case OS_QUEUE_WRITE_HEAD:
            (queueCB->queueHead == 0) ? (queueCB->queueHead = queueCB->queueLen - 1) : (--queueCB->queueHead);
 800abde:	68fb      	ldr	r3, [r7, #12]
 800abe0:	8a1b      	ldrh	r3, [r3, #16]
 800abe2:	2b00      	cmp	r3, #0
 800abe4:	d106      	bne.n	800abf4 <OsQueueBufferOperate+0x74>
 800abe6:	68fb      	ldr	r3, [r7, #12]
 800abe8:	88db      	ldrh	r3, [r3, #6]
 800abea:	3b01      	subs	r3, #1
 800abec:	b29a      	uxth	r2, r3
 800abee:	68fb      	ldr	r3, [r7, #12]
 800abf0:	821a      	strh	r2, [r3, #16]
 800abf2:	e005      	b.n	800ac00 <OsQueueBufferOperate+0x80>
 800abf4:	68fb      	ldr	r3, [r7, #12]
 800abf6:	8a1b      	ldrh	r3, [r3, #16]
 800abf8:	3b01      	subs	r3, #1
 800abfa:	b29a      	uxth	r2, r3
 800abfc:	68fb      	ldr	r3, [r7, #12]
 800abfe:	821a      	strh	r2, [r3, #16]
            queuePosition = queueCB->queueHead;
 800ac00:	68fb      	ldr	r3, [r7, #12]
 800ac02:	8a1b      	ldrh	r3, [r3, #16]
 800ac04:	827b      	strh	r3, [r7, #18]
            break;
 800ac06:	e016      	b.n	800ac36 <OsQueueBufferOperate+0xb6>
        case OS_QUEUE_WRITE_TAIL:
            queuePosition = queueCB->queueTail;
 800ac08:	68fb      	ldr	r3, [r7, #12]
 800ac0a:	8a5b      	ldrh	r3, [r3, #18]
 800ac0c:	827b      	strh	r3, [r7, #18]
            ((queueCB->queueTail + 1) == queueCB->queueLen) ? (queueCB->queueTail = 0) : (queueCB->queueTail++);
 800ac0e:	68fb      	ldr	r3, [r7, #12]
 800ac10:	8a5b      	ldrh	r3, [r3, #18]
 800ac12:	3301      	adds	r3, #1
 800ac14:	68fa      	ldr	r2, [r7, #12]
 800ac16:	88d2      	ldrh	r2, [r2, #6]
 800ac18:	4293      	cmp	r3, r2
 800ac1a:	d103      	bne.n	800ac24 <OsQueueBufferOperate+0xa4>
 800ac1c:	68fb      	ldr	r3, [r7, #12]
 800ac1e:	2200      	movs	r2, #0
 800ac20:	825a      	strh	r2, [r3, #18]
            break;
 800ac22:	e008      	b.n	800ac36 <OsQueueBufferOperate+0xb6>
            ((queueCB->queueTail + 1) == queueCB->queueLen) ? (queueCB->queueTail = 0) : (queueCB->queueTail++);
 800ac24:	68fb      	ldr	r3, [r7, #12]
 800ac26:	8a5b      	ldrh	r3, [r3, #18]
 800ac28:	3301      	adds	r3, #1
 800ac2a:	b29a      	uxth	r2, r3
 800ac2c:	68fb      	ldr	r3, [r7, #12]
 800ac2e:	825a      	strh	r2, [r3, #18]
            break;
 800ac30:	e001      	b.n	800ac36 <OsQueueBufferOperate+0xb6>
        default:  /* read tail, reserved. */
            return OS_QUEUE_OPERATE_ERROR_INVALID_TYPE;
 800ac32:	2301      	movs	r3, #1
 800ac34:	e04b      	b.n	800acce <OsQueueBufferOperate+0x14e>
    }

    queueNode = &(queueCB->queueHandle[(queuePosition * (queueCB->queueSize))]);
 800ac36:	68fb      	ldr	r3, [r7, #12]
 800ac38:	681b      	ldr	r3, [r3, #0]
 800ac3a:	8a7a      	ldrh	r2, [r7, #18]
 800ac3c:	68f9      	ldr	r1, [r7, #12]
 800ac3e:	8909      	ldrh	r1, [r1, #8]
 800ac40:	fb01 f202 	mul.w	r2, r1, r2
 800ac44:	4413      	add	r3, r2
 800ac46:	61bb      	str	r3, [r7, #24]

    if (OS_QUEUE_IS_READ(operateType)) {
 800ac48:	68bb      	ldr	r3, [r7, #8]
 800ac4a:	f003 0301 	and.w	r3, r3, #1
 800ac4e:	2b00      	cmp	r3, #0
 800ac50:	d11f      	bne.n	800ac92 <OsQueueBufferOperate+0x112>
        if (memcpy_s(&msgDataSize, sizeof(UINT32), queueNode + queueCB->queueSize - sizeof(UINT32),
 800ac52:	68fb      	ldr	r3, [r7, #12]
 800ac54:	891b      	ldrh	r3, [r3, #8]
 800ac56:	3b04      	subs	r3, #4
 800ac58:	69ba      	ldr	r2, [r7, #24]
 800ac5a:	441a      	add	r2, r3
 800ac5c:	f107 0014 	add.w	r0, r7, #20
 800ac60:	2304      	movs	r3, #4
 800ac62:	2104      	movs	r1, #4
 800ac64:	f00c fa18 	bl	8017098 <memcpy_s>
 800ac68:	4603      	mov	r3, r0
 800ac6a:	2b00      	cmp	r3, #0
 800ac6c:	d001      	beq.n	800ac72 <OsQueueBufferOperate+0xf2>
                     sizeof(UINT32)) != EOK) {
            return OS_QUEUE_OPERATE_ERROR_MEMCPYS_GETMSG;
 800ac6e:	2302      	movs	r3, #2
 800ac70:	e02d      	b.n	800acce <OsQueueBufferOperate+0x14e>
        }
        if (memcpy_s(bufferAddr, *bufferSize, queueNode, msgDataSize) != EOK) {
 800ac72:	683b      	ldr	r3, [r7, #0]
 800ac74:	6819      	ldr	r1, [r3, #0]
 800ac76:	697b      	ldr	r3, [r7, #20]
 800ac78:	69ba      	ldr	r2, [r7, #24]
 800ac7a:	6878      	ldr	r0, [r7, #4]
 800ac7c:	f00c fa0c 	bl	8017098 <memcpy_s>
 800ac80:	4603      	mov	r3, r0
 800ac82:	2b00      	cmp	r3, #0
 800ac84:	d001      	beq.n	800ac8a <OsQueueBufferOperate+0x10a>
            return OS_QUEUE_OPERATE_ERROR_MEMCPYS_MSG2BUF;
 800ac86:	2303      	movs	r3, #3
 800ac88:	e021      	b.n	800acce <OsQueueBufferOperate+0x14e>
        }

        *bufferSize = msgDataSize;
 800ac8a:	697a      	ldr	r2, [r7, #20]
 800ac8c:	683b      	ldr	r3, [r7, #0]
 800ac8e:	601a      	str	r2, [r3, #0]
 800ac90:	e01c      	b.n	800accc <OsQueueBufferOperate+0x14c>
    } else {
        if (memcpy_s(queueNode, queueCB->queueSize, bufferAddr, *bufferSize) != EOK) {
 800ac92:	68fb      	ldr	r3, [r7, #12]
 800ac94:	891b      	ldrh	r3, [r3, #8]
 800ac96:	4619      	mov	r1, r3
 800ac98:	683b      	ldr	r3, [r7, #0]
 800ac9a:	681b      	ldr	r3, [r3, #0]
 800ac9c:	687a      	ldr	r2, [r7, #4]
 800ac9e:	69b8      	ldr	r0, [r7, #24]
 800aca0:	f00c f9fa 	bl	8017098 <memcpy_s>
 800aca4:	4603      	mov	r3, r0
 800aca6:	2b00      	cmp	r3, #0
 800aca8:	d001      	beq.n	800acae <OsQueueBufferOperate+0x12e>
            return OS_QUEUE_OPERATE_ERROR_MEMCPYS_STRMSG;
 800acaa:	2304      	movs	r3, #4
 800acac:	e00f      	b.n	800acce <OsQueueBufferOperate+0x14e>
        }
        if (memcpy_s(queueNode + queueCB->queueSize - sizeof(UINT32), sizeof(UINT32), bufferSize,
 800acae:	68fb      	ldr	r3, [r7, #12]
 800acb0:	891b      	ldrh	r3, [r3, #8]
 800acb2:	3b04      	subs	r3, #4
 800acb4:	69ba      	ldr	r2, [r7, #24]
 800acb6:	18d0      	adds	r0, r2, r3
 800acb8:	2304      	movs	r3, #4
 800acba:	683a      	ldr	r2, [r7, #0]
 800acbc:	2104      	movs	r1, #4
 800acbe:	f00c f9eb 	bl	8017098 <memcpy_s>
 800acc2:	4603      	mov	r3, r0
 800acc4:	2b00      	cmp	r3, #0
 800acc6:	d001      	beq.n	800accc <OsQueueBufferOperate+0x14c>
                     sizeof(UINT32)) != EOK) {
            return OS_QUEUE_OPERATE_ERROR_MEMCPYS_STRMSGSIZE;
 800acc8:	2305      	movs	r3, #5
 800acca:	e000      	b.n	800acce <OsQueueBufferOperate+0x14e>
        }
    }
    return LOS_OK;
 800accc:	2300      	movs	r3, #0
}
 800acce:	4a05      	ldr	r2, [pc, #20]	; (800ace4 <OsQueueBufferOperate+0x164>)
 800acd0:	6811      	ldr	r1, [r2, #0]
 800acd2:	69fa      	ldr	r2, [r7, #28]
 800acd4:	4051      	eors	r1, r2
 800acd6:	d001      	beq.n	800acdc <OsQueueBufferOperate+0x15c>
 800acd8:	f7f9 fc80 	bl	80045dc <__stack_chk_fail>
 800acdc:	4618      	mov	r0, r3
 800acde:	3720      	adds	r7, #32
 800ace0:	46bd      	mov	sp, r7
 800ace2:	bd80      	pop	{r7, pc}
 800ace4:	080214dc 	.word	0x080214dc

0800ace8 <OsQueueBufferOperateErrProcess>:

STATIC VOID OsQueueBufferOperateErrProcess(UINT32 errorCode)
{
 800ace8:	b580      	push	{r7, lr}
 800acea:	b082      	sub	sp, #8
 800acec:	af00      	add	r7, sp, #0
 800acee:	6078      	str	r0, [r7, #4]
 800acf0:	687b      	ldr	r3, [r7, #4]
 800acf2:	2b05      	cmp	r3, #5
 800acf4:	d831      	bhi.n	800ad5a <OsQueueBufferOperateErrProcess+0x72>
 800acf6:	a201      	add	r2, pc, #4	; (adr r2, 800acfc <OsQueueBufferOperateErrProcess+0x14>)
 800acf8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800acfc:	0800ad6b 	.word	0x0800ad6b
 800ad00:	0800ad15 	.word	0x0800ad15
 800ad04:	0800ad23 	.word	0x0800ad23
 800ad08:	0800ad31 	.word	0x0800ad31
 800ad0c:	0800ad3f 	.word	0x0800ad3f
 800ad10:	0800ad4d 	.word	0x0800ad4d
    switch (errorCode) {
        case LOS_OK: break;
        case OS_QUEUE_OPERATE_ERROR_INVALID_TYPE:
            PRINT_ERR("invalid queue operate type!\n");
 800ad14:	4817      	ldr	r0, [pc, #92]	; (800ad74 <OsQueueBufferOperateErrProcess+0x8c>)
 800ad16:	f7f9 fdd3 	bl	80048c0 <dprintf>
 800ad1a:	4817      	ldr	r0, [pc, #92]	; (800ad78 <OsQueueBufferOperateErrProcess+0x90>)
 800ad1c:	f7f9 fdd0 	bl	80048c0 <dprintf>
            break;
 800ad20:	e024      	b.n	800ad6c <OsQueueBufferOperateErrProcess+0x84>
        case OS_QUEUE_OPERATE_ERROR_MEMCPYS_GETMSG:
            PRINT_ERR("get msgdatasize failed\n");
 800ad22:	4814      	ldr	r0, [pc, #80]	; (800ad74 <OsQueueBufferOperateErrProcess+0x8c>)
 800ad24:	f7f9 fdcc 	bl	80048c0 <dprintf>
 800ad28:	4814      	ldr	r0, [pc, #80]	; (800ad7c <OsQueueBufferOperateErrProcess+0x94>)
 800ad2a:	f7f9 fdc9 	bl	80048c0 <dprintf>
            break;
 800ad2e:	e01d      	b.n	800ad6c <OsQueueBufferOperateErrProcess+0x84>
        case OS_QUEUE_OPERATE_ERROR_MEMCPYS_MSG2BUF:
            PRINT_ERR("copy message to buffer failed\n");
 800ad30:	4810      	ldr	r0, [pc, #64]	; (800ad74 <OsQueueBufferOperateErrProcess+0x8c>)
 800ad32:	f7f9 fdc5 	bl	80048c0 <dprintf>
 800ad36:	4812      	ldr	r0, [pc, #72]	; (800ad80 <OsQueueBufferOperateErrProcess+0x98>)
 800ad38:	f7f9 fdc2 	bl	80048c0 <dprintf>
            break;
 800ad3c:	e016      	b.n	800ad6c <OsQueueBufferOperateErrProcess+0x84>
        case OS_QUEUE_OPERATE_ERROR_MEMCPYS_STRMSG:
            PRINT_ERR("store message failed\n");
 800ad3e:	480d      	ldr	r0, [pc, #52]	; (800ad74 <OsQueueBufferOperateErrProcess+0x8c>)
 800ad40:	f7f9 fdbe 	bl	80048c0 <dprintf>
 800ad44:	480f      	ldr	r0, [pc, #60]	; (800ad84 <OsQueueBufferOperateErrProcess+0x9c>)
 800ad46:	f7f9 fdbb 	bl	80048c0 <dprintf>
            break;
 800ad4a:	e00f      	b.n	800ad6c <OsQueueBufferOperateErrProcess+0x84>
        case OS_QUEUE_OPERATE_ERROR_MEMCPYS_STRMSGSIZE:
            PRINT_ERR("store message size failed\n");
 800ad4c:	4809      	ldr	r0, [pc, #36]	; (800ad74 <OsQueueBufferOperateErrProcess+0x8c>)
 800ad4e:	f7f9 fdb7 	bl	80048c0 <dprintf>
 800ad52:	480d      	ldr	r0, [pc, #52]	; (800ad88 <OsQueueBufferOperateErrProcess+0xa0>)
 800ad54:	f7f9 fdb4 	bl	80048c0 <dprintf>
            break;
 800ad58:	e008      	b.n	800ad6c <OsQueueBufferOperateErrProcess+0x84>
        default:
            PRINT_ERR("unknown queue operate ret %u\n", errorCode);
 800ad5a:	4806      	ldr	r0, [pc, #24]	; (800ad74 <OsQueueBufferOperateErrProcess+0x8c>)
 800ad5c:	f7f9 fdb0 	bl	80048c0 <dprintf>
 800ad60:	6879      	ldr	r1, [r7, #4]
 800ad62:	480a      	ldr	r0, [pc, #40]	; (800ad8c <OsQueueBufferOperateErrProcess+0xa4>)
 800ad64:	f7f9 fdac 	bl	80048c0 <dprintf>
            break;
 800ad68:	e000      	b.n	800ad6c <OsQueueBufferOperateErrProcess+0x84>
        case LOS_OK: break;
 800ad6a:	bf00      	nop
    }
}
 800ad6c:	bf00      	nop
 800ad6e:	3708      	adds	r7, #8
 800ad70:	46bd      	mov	sp, r7
 800ad72:	bd80      	pop	{r7, pc}
 800ad74:	080214e0 	.word	0x080214e0
 800ad78:	080214e8 	.word	0x080214e8
 800ad7c:	08021508 	.word	0x08021508
 800ad80:	08021520 	.word	0x08021520
 800ad84:	08021540 	.word	0x08021540
 800ad88:	08021558 	.word	0x08021558
 800ad8c:	08021574 	.word	0x08021574

0800ad90 <OsQueueOperateParamCheck>:

STATIC UINT32 OsQueueOperateParamCheck(const LosQueueCB *queueCB, UINT32 queueId,
                                       UINT32 operateType, const UINT32 *bufferSize)
{
 800ad90:	b480      	push	{r7}
 800ad92:	b085      	sub	sp, #20
 800ad94:	af00      	add	r7, sp, #0
 800ad96:	60f8      	str	r0, [r7, #12]
 800ad98:	60b9      	str	r1, [r7, #8]
 800ad9a:	607a      	str	r2, [r7, #4]
 800ad9c:	603b      	str	r3, [r7, #0]
    if ((queueCB->queueId != queueId) || (queueCB->queueState == LOS_UNUSED)) {
 800ad9e:	68fb      	ldr	r3, [r7, #12]
 800ada0:	68db      	ldr	r3, [r3, #12]
 800ada2:	68ba      	ldr	r2, [r7, #8]
 800ada4:	429a      	cmp	r2, r3
 800ada6:	d103      	bne.n	800adb0 <OsQueueOperateParamCheck+0x20>
 800ada8:	68fb      	ldr	r3, [r7, #12]
 800adaa:	791b      	ldrb	r3, [r3, #4]
 800adac:	2b00      	cmp	r3, #0
 800adae:	d101      	bne.n	800adb4 <OsQueueOperateParamCheck+0x24>
        return LOS_ERRNO_QUEUE_NOT_CREATE;
 800adb0:	4b12      	ldr	r3, [pc, #72]	; (800adfc <OsQueueOperateParamCheck+0x6c>)
 800adb2:	e01c      	b.n	800adee <OsQueueOperateParamCheck+0x5e>
    }

    if (OS_QUEUE_IS_READ(operateType) && (*bufferSize < (queueCB->queueSize - sizeof(UINT32)))) {
 800adb4:	687b      	ldr	r3, [r7, #4]
 800adb6:	f003 0301 	and.w	r3, r3, #1
 800adba:	2b00      	cmp	r3, #0
 800adbc:	d108      	bne.n	800add0 <OsQueueOperateParamCheck+0x40>
 800adbe:	683b      	ldr	r3, [r7, #0]
 800adc0:	681a      	ldr	r2, [r3, #0]
 800adc2:	68fb      	ldr	r3, [r7, #12]
 800adc4:	891b      	ldrh	r3, [r3, #8]
 800adc6:	3b04      	subs	r3, #4
 800adc8:	429a      	cmp	r2, r3
 800adca:	d201      	bcs.n	800add0 <OsQueueOperateParamCheck+0x40>
        return LOS_ERRNO_QUEUE_READ_SIZE_TOO_SMALL;
 800adcc:	4b0c      	ldr	r3, [pc, #48]	; (800ae00 <OsQueueOperateParamCheck+0x70>)
 800adce:	e00e      	b.n	800adee <OsQueueOperateParamCheck+0x5e>
    } else if (OS_QUEUE_IS_WRITE(operateType) && (*bufferSize > (queueCB->queueSize - sizeof(UINT32)))) {
 800add0:	687b      	ldr	r3, [r7, #4]
 800add2:	f003 0301 	and.w	r3, r3, #1
 800add6:	2b00      	cmp	r3, #0
 800add8:	d008      	beq.n	800adec <OsQueueOperateParamCheck+0x5c>
 800adda:	683b      	ldr	r3, [r7, #0]
 800addc:	681a      	ldr	r2, [r3, #0]
 800adde:	68fb      	ldr	r3, [r7, #12]
 800ade0:	891b      	ldrh	r3, [r3, #8]
 800ade2:	3b04      	subs	r3, #4
 800ade4:	429a      	cmp	r2, r3
 800ade6:	d901      	bls.n	800adec <OsQueueOperateParamCheck+0x5c>
        return LOS_ERRNO_QUEUE_WRITE_SIZE_TOO_BIG;
 800ade8:	4b06      	ldr	r3, [pc, #24]	; (800ae04 <OsQueueOperateParamCheck+0x74>)
 800adea:	e000      	b.n	800adee <OsQueueOperateParamCheck+0x5e>
    }
    return LOS_OK;
 800adec:	2300      	movs	r3, #0
}
 800adee:	4618      	mov	r0, r3
 800adf0:	3714      	adds	r7, #20
 800adf2:	46bd      	mov	sp, r7
 800adf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800adf8:	4770      	bx	lr
 800adfa:	bf00      	nop
 800adfc:	0200060a 	.word	0x0200060a
 800ae00:	0200061f 	.word	0x0200061f
 800ae04:	02000615 	.word	0x02000615

0800ae08 <OsQueueOperate>:

STATIC UINT32 OsQueueOperate(UINT32 queueId, UINT32 operateType, VOID *bufferAddr, UINT32 *bufferSize, UINT32 timeout)
{
 800ae08:	b590      	push	{r4, r7, lr}
 800ae0a:	b095      	sub	sp, #84	; 0x54
 800ae0c:	af00      	add	r7, sp, #0
 800ae0e:	60f8      	str	r0, [r7, #12]
 800ae10:	60b9      	str	r1, [r7, #8]
 800ae12:	607a      	str	r2, [r7, #4]
 800ae14:	603b      	str	r3, [r7, #0]
 800ae16:	4b87      	ldr	r3, [pc, #540]	; (800b034 <OsQueueOperate+0x22c>)
 800ae18:	681b      	ldr	r3, [r3, #0]
 800ae1a:	64fb      	str	r3, [r7, #76]	; 0x4c
 800ae1c:	f04f 0300 	mov.w	r3, #0
    LosQueueCB *queueCB = (LosQueueCB *)GET_QUEUE_HANDLE(queueId);
 800ae20:	4b85      	ldr	r3, [pc, #532]	; (800b038 <OsQueueOperate+0x230>)
 800ae22:	6819      	ldr	r1, [r3, #0]
 800ae24:	68fb      	ldr	r3, [r7, #12]
 800ae26:	b29a      	uxth	r2, r3
 800ae28:	4613      	mov	r3, r2
 800ae2a:	005b      	lsls	r3, r3, #1
 800ae2c:	4413      	add	r3, r2
 800ae2e:	011b      	lsls	r3, r3, #4
 800ae30:	440b      	add	r3, r1
 800ae32:	61fb      	str	r3, [r7, #28]
    UINT32 readWrite = OS_QUEUE_READ_WRITE_GET(operateType);
 800ae34:	68bb      	ldr	r3, [r7, #8]
 800ae36:	f003 0301 	and.w	r3, r3, #1
 800ae3a:	623b      	str	r3, [r7, #32]
    UINT32 errorCode = LOS_OK;
 800ae3c:	2300      	movs	r3, #0
 800ae3e:	617b      	str	r3, [r7, #20]
    UINT32 intSave, ret;

    LOS_TRACE(QUEUE_RW, queueId, queueCB->queueSize, *bufferSize, operateType,
 800ae40:	2300      	movs	r3, #0
 800ae42:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ae44:	68fb      	ldr	r3, [r7, #12]
 800ae46:	633b      	str	r3, [r7, #48]	; 0x30
 800ae48:	69fb      	ldr	r3, [r7, #28]
 800ae4a:	891b      	ldrh	r3, [r3, #8]
 800ae4c:	637b      	str	r3, [r7, #52]	; 0x34
 800ae4e:	683b      	ldr	r3, [r7, #0]
 800ae50:	681b      	ldr	r3, [r3, #0]
 800ae52:	63bb      	str	r3, [r7, #56]	; 0x38
 800ae54:	68bb      	ldr	r3, [r7, #8]
 800ae56:	63fb      	str	r3, [r7, #60]	; 0x3c
 800ae58:	69fb      	ldr	r3, [r7, #28]
 800ae5a:	8a9b      	ldrh	r3, [r3, #20]
 800ae5c:	643b      	str	r3, [r7, #64]	; 0x40
 800ae5e:	69fb      	ldr	r3, [r7, #28]
 800ae60:	8adb      	ldrh	r3, [r3, #22]
 800ae62:	647b      	str	r3, [r7, #68]	; 0x44
 800ae64:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800ae66:	64bb      	str	r3, [r7, #72]	; 0x48
 800ae68:	2308      	movs	r3, #8
 800ae6a:	627b      	str	r3, [r7, #36]	; 0x24
 800ae6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ae6e:	2b01      	cmp	r3, #1
 800ae70:	d916      	bls.n	800aea0 <OsQueueOperate+0x98>
 800ae72:	4b72      	ldr	r3, [pc, #456]	; (800b03c <OsQueueOperate+0x234>)
 800ae74:	681b      	ldr	r3, [r3, #0]
 800ae76:	2b00      	cmp	r3, #0
 800ae78:	d012      	beq.n	800aea0 <OsQueueOperate+0x98>
 800ae7a:	4b70      	ldr	r3, [pc, #448]	; (800b03c <OsQueueOperate+0x234>)
 800ae7c:	681c      	ldr	r4, [r3, #0]
 800ae7e:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800ae80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ae82:	2b02      	cmp	r3, #2
 800ae84:	d904      	bls.n	800ae90 <OsQueueOperate+0x88>
 800ae86:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ae8a:	f103 0208 	add.w	r2, r3, #8
 800ae8e:	e000      	b.n	800ae92 <OsQueueOperate+0x8a>
 800ae90:	2200      	movs	r2, #0
 800ae92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ae94:	b29b      	uxth	r3, r3
 800ae96:	3b02      	subs	r3, #2
 800ae98:	b29b      	uxth	r3, r3
 800ae9a:	f240 2002 	movw	r0, #514	; 0x202
 800ae9e:	47a0      	blx	r4
        queueCB->readWriteableCnt[OS_QUEUE_READ], queueCB->readWriteableCnt[OS_QUEUE_WRITE], timeout);

    SCHEDULER_LOCK(intSave);
 800aea0:	f107 0310 	add.w	r3, r7, #16
 800aea4:	4619      	mov	r1, r3
 800aea6:	4866      	ldr	r0, [pc, #408]	; (800b040 <OsQueueOperate+0x238>)
 800aea8:	f7ff fc3c 	bl	800a724 <LOS_SpinLockSave>
    ret = OsQueueOperateParamCheck(queueCB, queueId, operateType, bufferSize);
 800aeac:	683b      	ldr	r3, [r7, #0]
 800aeae:	68ba      	ldr	r2, [r7, #8]
 800aeb0:	68f9      	ldr	r1, [r7, #12]
 800aeb2:	69f8      	ldr	r0, [r7, #28]
 800aeb4:	f7ff ff6c 	bl	800ad90 <OsQueueOperateParamCheck>
 800aeb8:	61b8      	str	r0, [r7, #24]
    if (ret != LOS_OK) {
 800aeba:	69bb      	ldr	r3, [r7, #24]
 800aebc:	2b00      	cmp	r3, #0
 800aebe:	f040 80a4 	bne.w	800b00a <OsQueueOperate+0x202>
        goto QUEUE_END;
    }

    if (queueCB->readWriteableCnt[readWrite] == 0) {
 800aec2:	69fa      	ldr	r2, [r7, #28]
 800aec4:	6a3b      	ldr	r3, [r7, #32]
 800aec6:	3308      	adds	r3, #8
 800aec8:	005b      	lsls	r3, r3, #1
 800aeca:	4413      	add	r3, r2
 800aecc:	889b      	ldrh	r3, [r3, #4]
 800aece:	2b00      	cmp	r3, #0
 800aed0:	d13e      	bne.n	800af50 <OsQueueOperate+0x148>
        if (timeout == LOS_NO_WAIT) {
 800aed2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800aed4:	2b00      	cmp	r3, #0
 800aed6:	d109      	bne.n	800aeec <OsQueueOperate+0xe4>
            ret = OS_QUEUE_IS_READ(operateType) ? LOS_ERRNO_QUEUE_ISEMPTY : LOS_ERRNO_QUEUE_ISFULL;
 800aed8:	68bb      	ldr	r3, [r7, #8]
 800aeda:	f003 0301 	and.w	r3, r3, #1
 800aede:	2b00      	cmp	r3, #0
 800aee0:	d101      	bne.n	800aee6 <OsQueueOperate+0xde>
 800aee2:	4b58      	ldr	r3, [pc, #352]	; (800b044 <OsQueueOperate+0x23c>)
 800aee4:	e000      	b.n	800aee8 <OsQueueOperate+0xe0>
 800aee6:	4b58      	ldr	r3, [pc, #352]	; (800b048 <OsQueueOperate+0x240>)
 800aee8:	61bb      	str	r3, [r7, #24]
            goto QUEUE_END;
 800aeea:	e08f      	b.n	800b00c <OsQueueOperate+0x204>
        }

        if (!OsPreemptableInSched()) {
 800aeec:	f7ff fbee 	bl	800a6cc <OsPreemptableInSched>
 800aef0:	4603      	mov	r3, r0
 800aef2:	2b00      	cmp	r3, #0
 800aef4:	d102      	bne.n	800aefc <OsQueueOperate+0xf4>
            ret = LOS_ERRNO_QUEUE_PEND_IN_LOCK;
 800aef6:	4b55      	ldr	r3, [pc, #340]	; (800b04c <OsQueueOperate+0x244>)
 800aef8:	61bb      	str	r3, [r7, #24]
            goto QUEUE_END;
 800aefa:	e087      	b.n	800b00c <OsQueueOperate+0x204>
        }

        OsTaskWait(&queueCB->readWriteList[readWrite], OS_TASK_STATUS_PEND, timeout);
 800aefc:	6a3b      	ldr	r3, [r7, #32]
 800aefe:	3303      	adds	r3, #3
 800af00:	00db      	lsls	r3, r3, #3
 800af02:	69fa      	ldr	r2, [r7, #28]
 800af04:	4413      	add	r3, r2
 800af06:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800af08:	2108      	movs	r1, #8
 800af0a:	4618      	mov	r0, r3
 800af0c:	f7f9 f828 	bl	8003f60 <OsTaskWait>

        OsSchedResched();
 800af10:	f7fd fe52 	bl	8008bb8 <OsSchedResched>
        SCHEDULER_UNLOCK(intSave);
 800af14:	693b      	ldr	r3, [r7, #16]
 800af16:	4619      	mov	r1, r3
 800af18:	4849      	ldr	r0, [pc, #292]	; (800b040 <OsQueueOperate+0x238>)
 800af1a:	f7ff fc11 	bl	800a740 <LOS_SpinUnlockRestore>
        SCHEDULER_LOCK(intSave);
 800af1e:	f107 0310 	add.w	r3, r7, #16
 800af22:	4619      	mov	r1, r3
 800af24:	4846      	ldr	r0, [pc, #280]	; (800b040 <OsQueueOperate+0x238>)
 800af26:	f7ff fbfd 	bl	800a724 <LOS_SpinLockSave>

        if (OsCurrTaskGet()->taskStatus & OS_TASK_STATUS_TIMEOUT) {
 800af2a:	f7ff fc15 	bl	800a758 <OsCurrTaskGet>
 800af2e:	4603      	mov	r3, r0
 800af30:	889b      	ldrh	r3, [r3, #4]
 800af32:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800af36:	2b00      	cmp	r3, #0
 800af38:	d019      	beq.n	800af6e <OsQueueOperate+0x166>
            OsCurrTaskGet()->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
 800af3a:	f7ff fc0d 	bl	800a758 <OsCurrTaskGet>
 800af3e:	4603      	mov	r3, r0
 800af40:	889a      	ldrh	r2, [r3, #4]
 800af42:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800af46:	b292      	uxth	r2, r2
 800af48:	809a      	strh	r2, [r3, #4]
            ret = LOS_ERRNO_QUEUE_TIMEOUT;
 800af4a:	4b41      	ldr	r3, [pc, #260]	; (800b050 <OsQueueOperate+0x248>)
 800af4c:	61bb      	str	r3, [r7, #24]
            goto QUEUE_END;
 800af4e:	e05d      	b.n	800b00c <OsQueueOperate+0x204>
        }
    } else {
        queueCB->readWriteableCnt[readWrite]--;
 800af50:	69fa      	ldr	r2, [r7, #28]
 800af52:	6a3b      	ldr	r3, [r7, #32]
 800af54:	3308      	adds	r3, #8
 800af56:	005b      	lsls	r3, r3, #1
 800af58:	4413      	add	r3, r2
 800af5a:	889b      	ldrh	r3, [r3, #4]
 800af5c:	3b01      	subs	r3, #1
 800af5e:	b299      	uxth	r1, r3
 800af60:	69fa      	ldr	r2, [r7, #28]
 800af62:	6a3b      	ldr	r3, [r7, #32]
 800af64:	3308      	adds	r3, #8
 800af66:	005b      	lsls	r3, r3, #1
 800af68:	4413      	add	r3, r2
 800af6a:	460a      	mov	r2, r1
 800af6c:	809a      	strh	r2, [r3, #4]
    }

    /* It will cause double lock issue that print after SCHEDULER_LOCK,
     * so handle the return value errorCode after SCHEDULER_UNLOCK */
    errorCode = OsQueueBufferOperate(queueCB, operateType, bufferAddr, bufferSize);
 800af6e:	683b      	ldr	r3, [r7, #0]
 800af70:	687a      	ldr	r2, [r7, #4]
 800af72:	68b9      	ldr	r1, [r7, #8]
 800af74:	69f8      	ldr	r0, [r7, #28]
 800af76:	f7ff fe03 	bl	800ab80 <OsQueueBufferOperate>
 800af7a:	6178      	str	r0, [r7, #20]

    if (!LOS_ListEmpty(&queueCB->readWriteList[!readWrite])) {
 800af7c:	6a3b      	ldr	r3, [r7, #32]
 800af7e:	2b00      	cmp	r3, #0
 800af80:	bf0c      	ite	eq
 800af82:	2301      	moveq	r3, #1
 800af84:	2300      	movne	r3, #0
 800af86:	b2db      	uxtb	r3, r3
 800af88:	3303      	adds	r3, #3
 800af8a:	00db      	lsls	r3, r3, #3
 800af8c:	69fa      	ldr	r2, [r7, #28]
 800af8e:	4413      	add	r3, r2
 800af90:	4618      	mov	r0, r3
 800af92:	f7ff fb53 	bl	800a63c <LOS_ListEmpty>
 800af96:	4603      	mov	r3, r0
 800af98:	2b00      	cmp	r3, #0
 800af9a:	d11f      	bne.n	800afdc <OsQueueOperate+0x1d4>
        LosTaskCB *resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&queueCB->readWriteList[!readWrite]));
 800af9c:	6a3b      	ldr	r3, [r7, #32]
 800af9e:	2b00      	cmp	r3, #0
 800afa0:	bf0c      	ite	eq
 800afa2:	2301      	moveq	r3, #1
 800afa4:	2300      	movne	r3, #0
 800afa6:	b2db      	uxtb	r3, r3
 800afa8:	69fa      	ldr	r2, [r7, #28]
 800afaa:	3303      	adds	r3, #3
 800afac:	00db      	lsls	r3, r3, #3
 800afae:	4413      	add	r3, r2
 800afb0:	685b      	ldr	r3, [r3, #4]
 800afb2:	3b40      	subs	r3, #64	; 0x40
 800afb4:	62bb      	str	r3, [r7, #40]	; 0x28
        OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
 800afb6:	2108      	movs	r1, #8
 800afb8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800afba:	f7f9 f807 	bl	8003fcc <OsTaskWake>
        SCHEDULER_UNLOCK(intSave);
 800afbe:	693b      	ldr	r3, [r7, #16]
 800afc0:	4619      	mov	r1, r3
 800afc2:	481f      	ldr	r0, [pc, #124]	; (800b040 <OsQueueOperate+0x238>)
 800afc4:	f7ff fbbc 	bl	800a740 <LOS_SpinUnlockRestore>
        OsQueueBufferOperateErrProcess(errorCode);
 800afc8:	6978      	ldr	r0, [r7, #20]
 800afca:	f7ff fe8d 	bl	800ace8 <OsQueueBufferOperateErrProcess>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 800afce:	2001      	movs	r0, #1
 800afd0:	f7ff fbee 	bl	800a7b0 <LOS_MpSchedule>
        LOS_Schedule();
 800afd4:	f7ff fb96 	bl	800a704 <LOS_Schedule>
        return LOS_OK;
 800afd8:	2300      	movs	r3, #0
 800afda:	e020      	b.n	800b01e <OsQueueOperate+0x216>
    } else {
        queueCB->readWriteableCnt[!readWrite]++;
 800afdc:	6a3b      	ldr	r3, [r7, #32]
 800afde:	2b00      	cmp	r3, #0
 800afe0:	bf0c      	ite	eq
 800afe2:	2301      	moveq	r3, #1
 800afe4:	2300      	movne	r3, #0
 800afe6:	b2db      	uxtb	r3, r3
 800afe8:	461a      	mov	r2, r3
 800afea:	69f9      	ldr	r1, [r7, #28]
 800afec:	f102 0308 	add.w	r3, r2, #8
 800aff0:	005b      	lsls	r3, r3, #1
 800aff2:	440b      	add	r3, r1
 800aff4:	889b      	ldrh	r3, [r3, #4]
 800aff6:	3301      	adds	r3, #1
 800aff8:	b298      	uxth	r0, r3
 800affa:	69f9      	ldr	r1, [r7, #28]
 800affc:	f102 0308 	add.w	r3, r2, #8
 800b000:	005b      	lsls	r3, r3, #1
 800b002:	440b      	add	r3, r1
 800b004:	4602      	mov	r2, r0
 800b006:	809a      	strh	r2, [r3, #4]
 800b008:	e000      	b.n	800b00c <OsQueueOperate+0x204>
        goto QUEUE_END;
 800b00a:	bf00      	nop
    }

QUEUE_END:
    SCHEDULER_UNLOCK(intSave);
 800b00c:	693b      	ldr	r3, [r7, #16]
 800b00e:	4619      	mov	r1, r3
 800b010:	480b      	ldr	r0, [pc, #44]	; (800b040 <OsQueueOperate+0x238>)
 800b012:	f7ff fb95 	bl	800a740 <LOS_SpinUnlockRestore>
    OsQueueBufferOperateErrProcess(errorCode);
 800b016:	6978      	ldr	r0, [r7, #20]
 800b018:	f7ff fe66 	bl	800ace8 <OsQueueBufferOperateErrProcess>
    return ret;
 800b01c:	69bb      	ldr	r3, [r7, #24]
}
 800b01e:	4a05      	ldr	r2, [pc, #20]	; (800b034 <OsQueueOperate+0x22c>)
 800b020:	6811      	ldr	r1, [r2, #0]
 800b022:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800b024:	4051      	eors	r1, r2
 800b026:	d001      	beq.n	800b02c <OsQueueOperate+0x224>
 800b028:	f7f9 fad8 	bl	80045dc <__stack_chk_fail>
 800b02c:	4618      	mov	r0, r3
 800b02e:	3754      	adds	r7, #84	; 0x54
 800b030:	46bd      	mov	sp, r7
 800b032:	bd90      	pop	{r4, r7, pc}
 800b034:	08021594 	.word	0x08021594
 800b038:	200021c4 	.word	0x200021c4
 800b03c:	20000768 	.word	0x20000768
 800b040:	20000770 	.word	0x20000770
 800b044:	0200061d 	.word	0x0200061d
 800b048:	02000616 	.word	0x02000616
 800b04c:	02000606 	.word	0x02000606
 800b050:	02000607 	.word	0x02000607

0800b054 <LOS_QueueReadCopy>:

LITE_OS_SEC_TEXT UINT32 LOS_QueueReadCopy(UINT32 queueId,
                                          VOID *bufferAddr,
                                          UINT32 *bufferSize,
                                          UINT32 timeout)
{
 800b054:	b580      	push	{r7, lr}
 800b056:	b088      	sub	sp, #32
 800b058:	af02      	add	r7, sp, #8
 800b05a:	60f8      	str	r0, [r7, #12]
 800b05c:	60b9      	str	r1, [r7, #8]
 800b05e:	607a      	str	r2, [r7, #4]
 800b060:	603b      	str	r3, [r7, #0]
    UINT32 ret;
    UINT32 operateType;

    ret = OsQueueReadParameterCheck(queueId, bufferAddr, bufferSize, timeout);
 800b062:	683b      	ldr	r3, [r7, #0]
 800b064:	687a      	ldr	r2, [r7, #4]
 800b066:	68b9      	ldr	r1, [r7, #8]
 800b068:	68f8      	ldr	r0, [r7, #12]
 800b06a:	f7ff fd1b 	bl	800aaa4 <OsQueueReadParameterCheck>
 800b06e:	6138      	str	r0, [r7, #16]
    if (ret != LOS_OK) {
 800b070:	693b      	ldr	r3, [r7, #16]
 800b072:	2b00      	cmp	r3, #0
 800b074:	d001      	beq.n	800b07a <LOS_QueueReadCopy+0x26>
        return ret;
 800b076:	693b      	ldr	r3, [r7, #16]
 800b078:	e00a      	b.n	800b090 <LOS_QueueReadCopy+0x3c>
    }

    operateType = OS_QUEUE_OPERATE_TYPE(OS_QUEUE_READ, OS_QUEUE_HEAD);
 800b07a:	2300      	movs	r3, #0
 800b07c:	617b      	str	r3, [r7, #20]
    return OsQueueOperate(queueId, operateType, bufferAddr, bufferSize, timeout);
 800b07e:	683b      	ldr	r3, [r7, #0]
 800b080:	9300      	str	r3, [sp, #0]
 800b082:	687b      	ldr	r3, [r7, #4]
 800b084:	68ba      	ldr	r2, [r7, #8]
 800b086:	6979      	ldr	r1, [r7, #20]
 800b088:	68f8      	ldr	r0, [r7, #12]
 800b08a:	f7ff febd 	bl	800ae08 <OsQueueOperate>
 800b08e:	4603      	mov	r3, r0
}
 800b090:	4618      	mov	r0, r3
 800b092:	3718      	adds	r7, #24
 800b094:	46bd      	mov	sp, r7
 800b096:	bd80      	pop	{r7, pc}

0800b098 <LOS_QueueWriteCopy>:

LITE_OS_SEC_TEXT UINT32 LOS_QueueWriteCopy(UINT32 queueId,
                                           VOID *bufferAddr,
                                           UINT32 bufferSize,
                                           UINT32 timeout)
{
 800b098:	b580      	push	{r7, lr}
 800b09a:	b088      	sub	sp, #32
 800b09c:	af02      	add	r7, sp, #8
 800b09e:	60f8      	str	r0, [r7, #12]
 800b0a0:	60b9      	str	r1, [r7, #8]
 800b0a2:	607a      	str	r2, [r7, #4]
 800b0a4:	603b      	str	r3, [r7, #0]
    UINT32 ret;
    UINT32 operateType;

    ret = OsQueueWriteParameterCheck(queueId, bufferAddr, &bufferSize, timeout);
 800b0a6:	1d3a      	adds	r2, r7, #4
 800b0a8:	683b      	ldr	r3, [r7, #0]
 800b0aa:	68b9      	ldr	r1, [r7, #8]
 800b0ac:	68f8      	ldr	r0, [r7, #12]
 800b0ae:	f7ff fd35 	bl	800ab1c <OsQueueWriteParameterCheck>
 800b0b2:	6138      	str	r0, [r7, #16]
    if (ret != LOS_OK) {
 800b0b4:	693b      	ldr	r3, [r7, #16]
 800b0b6:	2b00      	cmp	r3, #0
 800b0b8:	d001      	beq.n	800b0be <LOS_QueueWriteCopy+0x26>
        return ret;
 800b0ba:	693b      	ldr	r3, [r7, #16]
 800b0bc:	e00b      	b.n	800b0d6 <LOS_QueueWriteCopy+0x3e>
    }

    operateType = OS_QUEUE_OPERATE_TYPE(OS_QUEUE_WRITE, OS_QUEUE_TAIL);
 800b0be:	2303      	movs	r3, #3
 800b0c0:	617b      	str	r3, [r7, #20]
    return OsQueueOperate(queueId, operateType, bufferAddr, &bufferSize, timeout);
 800b0c2:	1d3a      	adds	r2, r7, #4
 800b0c4:	683b      	ldr	r3, [r7, #0]
 800b0c6:	9300      	str	r3, [sp, #0]
 800b0c8:	4613      	mov	r3, r2
 800b0ca:	68ba      	ldr	r2, [r7, #8]
 800b0cc:	6979      	ldr	r1, [r7, #20]
 800b0ce:	68f8      	ldr	r0, [r7, #12]
 800b0d0:	f7ff fe9a 	bl	800ae08 <OsQueueOperate>
 800b0d4:	4603      	mov	r3, r0
}
 800b0d6:	4618      	mov	r0, r3
 800b0d8:	3718      	adds	r7, #24
 800b0da:	46bd      	mov	sp, r7
 800b0dc:	bd80      	pop	{r7, pc}

0800b0de <LOS_ListInit>:
{
 800b0de:	b480      	push	{r7}
 800b0e0:	b083      	sub	sp, #12
 800b0e2:	af00      	add	r7, sp, #0
 800b0e4:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 800b0e6:	687b      	ldr	r3, [r7, #4]
 800b0e8:	687a      	ldr	r2, [r7, #4]
 800b0ea:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 800b0ec:	687b      	ldr	r3, [r7, #4]
 800b0ee:	687a      	ldr	r2, [r7, #4]
 800b0f0:	601a      	str	r2, [r3, #0]
}
 800b0f2:	bf00      	nop
 800b0f4:	370c      	adds	r7, #12
 800b0f6:	46bd      	mov	sp, r7
 800b0f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b0fc:	4770      	bx	lr

0800b0fe <LOS_ListAdd>:
{
 800b0fe:	b480      	push	{r7}
 800b100:	b083      	sub	sp, #12
 800b102:	af00      	add	r7, sp, #0
 800b104:	6078      	str	r0, [r7, #4]
 800b106:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 800b108:	687b      	ldr	r3, [r7, #4]
 800b10a:	685a      	ldr	r2, [r3, #4]
 800b10c:	683b      	ldr	r3, [r7, #0]
 800b10e:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 800b110:	683b      	ldr	r3, [r7, #0]
 800b112:	687a      	ldr	r2, [r7, #4]
 800b114:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 800b116:	687b      	ldr	r3, [r7, #4]
 800b118:	685b      	ldr	r3, [r3, #4]
 800b11a:	683a      	ldr	r2, [r7, #0]
 800b11c:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 800b11e:	687b      	ldr	r3, [r7, #4]
 800b120:	683a      	ldr	r2, [r7, #0]
 800b122:	605a      	str	r2, [r3, #4]
}
 800b124:	bf00      	nop
 800b126:	370c      	adds	r7, #12
 800b128:	46bd      	mov	sp, r7
 800b12a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b12e:	4770      	bx	lr

0800b130 <LOS_ListTailInsert>:
{
 800b130:	b580      	push	{r7, lr}
 800b132:	b082      	sub	sp, #8
 800b134:	af00      	add	r7, sp, #0
 800b136:	6078      	str	r0, [r7, #4]
 800b138:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 800b13a:	687b      	ldr	r3, [r7, #4]
 800b13c:	681b      	ldr	r3, [r3, #0]
 800b13e:	6839      	ldr	r1, [r7, #0]
 800b140:	4618      	mov	r0, r3
 800b142:	f7ff ffdc 	bl	800b0fe <LOS_ListAdd>
}
 800b146:	bf00      	nop
 800b148:	3708      	adds	r7, #8
 800b14a:	46bd      	mov	sp, r7
 800b14c:	bd80      	pop	{r7, pc}

0800b14e <LOS_ListDelete>:
{
 800b14e:	b480      	push	{r7}
 800b150:	b083      	sub	sp, #12
 800b152:	af00      	add	r7, sp, #0
 800b154:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 800b156:	687b      	ldr	r3, [r7, #4]
 800b158:	685b      	ldr	r3, [r3, #4]
 800b15a:	687a      	ldr	r2, [r7, #4]
 800b15c:	6812      	ldr	r2, [r2, #0]
 800b15e:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 800b160:	687b      	ldr	r3, [r7, #4]
 800b162:	681b      	ldr	r3, [r3, #0]
 800b164:	687a      	ldr	r2, [r7, #4]
 800b166:	6852      	ldr	r2, [r2, #4]
 800b168:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 800b16a:	687b      	ldr	r3, [r7, #4]
 800b16c:	2200      	movs	r2, #0
 800b16e:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 800b170:	687b      	ldr	r3, [r7, #4]
 800b172:	2200      	movs	r2, #0
 800b174:	601a      	str	r2, [r3, #0]
}
 800b176:	bf00      	nop
 800b178:	370c      	adds	r7, #12
 800b17a:	46bd      	mov	sp, r7
 800b17c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b180:	4770      	bx	lr

0800b182 <LOS_ListEmpty>:
{
 800b182:	b480      	push	{r7}
 800b184:	b083      	sub	sp, #12
 800b186:	af00      	add	r7, sp, #0
 800b188:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 800b18a:	687b      	ldr	r3, [r7, #4]
 800b18c:	685b      	ldr	r3, [r3, #4]
 800b18e:	687a      	ldr	r2, [r7, #4]
 800b190:	429a      	cmp	r2, r3
 800b192:	bf0c      	ite	eq
 800b194:	2301      	moveq	r3, #1
 800b196:	2300      	movne	r3, #0
 800b198:	b2db      	uxtb	r3, r3
}
 800b19a:	4618      	mov	r0, r3
 800b19c:	370c      	adds	r7, #12
 800b19e:	46bd      	mov	sp, r7
 800b1a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b1a4:	4770      	bx	lr

0800b1a6 <ArchCurrCpuid>:
{
 800b1a6:	b480      	push	{r7}
 800b1a8:	af00      	add	r7, sp, #0
    return 0;
 800b1aa:	2300      	movs	r3, #0
}
 800b1ac:	4618      	mov	r0, r3
 800b1ae:	46bd      	mov	sp, r7
 800b1b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b1b4:	4770      	bx	lr

0800b1b6 <LOS_IntLock>:
{
 800b1b6:	b580      	push	{r7, lr}
 800b1b8:	af00      	add	r7, sp, #0
    return ArchIntLock();
 800b1ba:	f7f5 fd85 	bl	8000cc8 <ArchIntLock>
 800b1be:	4603      	mov	r3, r0
}
 800b1c0:	4618      	mov	r0, r3
 800b1c2:	bd80      	pop	{r7, pc}

0800b1c4 <LOS_IntRestore>:
{
 800b1c4:	b580      	push	{r7, lr}
 800b1c6:	b082      	sub	sp, #8
 800b1c8:	af00      	add	r7, sp, #0
 800b1ca:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 800b1cc:	6878      	ldr	r0, [r7, #4]
 800b1ce:	f7f5 fd83 	bl	8000cd8 <ArchIntRestore>
}
 800b1d2:	bf00      	nop
 800b1d4:	3708      	adds	r7, #8
 800b1d6:	46bd      	mov	sp, r7
 800b1d8:	bd80      	pop	{r7, pc}
	...

0800b1dc <ArchCurrTaskGet>:
{
 800b1dc:	b480      	push	{r7}
 800b1de:	af00      	add	r7, sp, #0
    return g_runTask;
 800b1e0:	4b03      	ldr	r3, [pc, #12]	; (800b1f0 <ArchCurrTaskGet+0x14>)
 800b1e2:	681b      	ldr	r3, [r3, #0]
}
 800b1e4:	4618      	mov	r0, r3
 800b1e6:	46bd      	mov	sp, r7
 800b1e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b1ec:	4770      	bx	lr
 800b1ee:	bf00      	nop
 800b1f0:	200033cc 	.word	0x200033cc

0800b1f4 <OsPercpuGet>:
{
 800b1f4:	b580      	push	{r7, lr}
 800b1f6:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 800b1f8:	f7ff ffd5 	bl	800b1a6 <ArchCurrCpuid>
 800b1fc:	4602      	mov	r2, r0
 800b1fe:	4613      	mov	r3, r2
 800b200:	00db      	lsls	r3, r3, #3
 800b202:	4413      	add	r3, r2
 800b204:	009b      	lsls	r3, r3, #2
 800b206:	4a02      	ldr	r2, [pc, #8]	; (800b210 <OsPercpuGet+0x1c>)
 800b208:	4413      	add	r3, r2
}
 800b20a:	4618      	mov	r0, r3
 800b20c:	bd80      	pop	{r7, pc}
 800b20e:	bf00      	nop
 800b210:	200036fc 	.word	0x200036fc

0800b214 <OsPreemptableInSched>:
{
 800b214:	b580      	push	{r7, lr}
 800b216:	b082      	sub	sp, #8
 800b218:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 800b21a:	2300      	movs	r3, #0
 800b21c:	607b      	str	r3, [r7, #4]
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 800b21e:	f7ff ffe9 	bl	800b1f4 <OsPercpuGet>
 800b222:	4603      	mov	r3, r0
 800b224:	695b      	ldr	r3, [r3, #20]
 800b226:	2b00      	cmp	r3, #0
 800b228:	bf0c      	ite	eq
 800b22a:	2301      	moveq	r3, #1
 800b22c:	2300      	movne	r3, #0
 800b22e:	b2db      	uxtb	r3, r3
 800b230:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 800b232:	687b      	ldr	r3, [r7, #4]
 800b234:	2b00      	cmp	r3, #0
 800b236:	d104      	bne.n	800b242 <OsPreemptableInSched+0x2e>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 800b238:	f7ff ffdc 	bl	800b1f4 <OsPercpuGet>
 800b23c:	4603      	mov	r3, r0
 800b23e:	2201      	movs	r2, #1
 800b240:	621a      	str	r2, [r3, #32]
    return preemptable;
 800b242:	687b      	ldr	r3, [r7, #4]
}
 800b244:	4618      	mov	r0, r3
 800b246:	3708      	adds	r7, #8
 800b248:	46bd      	mov	sp, r7
 800b24a:	bd80      	pop	{r7, pc}

0800b24c <LOS_Schedule>:
{
 800b24c:	b580      	push	{r7, lr}
 800b24e:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 800b250:	f7f7 fa06 	bl	8002660 <IntActive>
 800b254:	4603      	mov	r3, r0
 800b256:	2b00      	cmp	r3, #0
 800b258:	d005      	beq.n	800b266 <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 800b25a:	f7ff ffcb 	bl	800b1f4 <OsPercpuGet>
 800b25e:	4603      	mov	r3, r0
 800b260:	2201      	movs	r2, #1
 800b262:	621a      	str	r2, [r3, #32]
        return;
 800b264:	e001      	b.n	800b26a <LOS_Schedule+0x1e>
    OsSchedPreempt();
 800b266:	f7fd fd65 	bl	8008d34 <OsSchedPreempt>
}
 800b26a:	bd80      	pop	{r7, pc}

0800b26c <LOS_SpinLockSave>:
{
 800b26c:	b580      	push	{r7, lr}
 800b26e:	b082      	sub	sp, #8
 800b270:	af00      	add	r7, sp, #0
 800b272:	6078      	str	r0, [r7, #4]
 800b274:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 800b276:	f7ff ff9e 	bl	800b1b6 <LOS_IntLock>
 800b27a:	4602      	mov	r2, r0
 800b27c:	683b      	ldr	r3, [r7, #0]
 800b27e:	601a      	str	r2, [r3, #0]
}
 800b280:	bf00      	nop
 800b282:	3708      	adds	r7, #8
 800b284:	46bd      	mov	sp, r7
 800b286:	bd80      	pop	{r7, pc}

0800b288 <LOS_SpinUnlockRestore>:
{
 800b288:	b580      	push	{r7, lr}
 800b28a:	b082      	sub	sp, #8
 800b28c:	af00      	add	r7, sp, #0
 800b28e:	6078      	str	r0, [r7, #4]
 800b290:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 800b292:	6838      	ldr	r0, [r7, #0]
 800b294:	f7ff ff96 	bl	800b1c4 <LOS_IntRestore>
}
 800b298:	bf00      	nop
 800b29a:	3708      	adds	r7, #8
 800b29c:	46bd      	mov	sp, r7
 800b29e:	bd80      	pop	{r7, pc}

0800b2a0 <OsCurrTaskGet>:
{
 800b2a0:	b580      	push	{r7, lr}
 800b2a2:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 800b2a4:	f7ff ff9a 	bl	800b1dc <ArchCurrTaskGet>
 800b2a8:	4603      	mov	r3, r0
}
 800b2aa:	4618      	mov	r0, r3
 800b2ac:	bd80      	pop	{r7, pc}

0800b2ae <OsMuxDlockNodeInsertHook>:
{
 800b2ae:	b580      	push	{r7, lr}
 800b2b0:	b082      	sub	sp, #8
 800b2b2:	af00      	add	r7, sp, #0
 800b2b4:	6078      	str	r0, [r7, #4]
 800b2b6:	6039      	str	r1, [r7, #0]
    OsMuxDlockNodeInsert(taskId, muxCB);
 800b2b8:	6839      	ldr	r1, [r7, #0]
 800b2ba:	6878      	ldr	r0, [r7, #4]
 800b2bc:	f7fb fb46 	bl	800694c <OsMuxDlockNodeInsert>
}
 800b2c0:	bf00      	nop
 800b2c2:	3708      	adds	r7, #8
 800b2c4:	46bd      	mov	sp, r7
 800b2c6:	bd80      	pop	{r7, pc}

0800b2c8 <OsMuxDlockNodeDeleteHook>:
{
 800b2c8:	b580      	push	{r7, lr}
 800b2ca:	b082      	sub	sp, #8
 800b2cc:	af00      	add	r7, sp, #0
 800b2ce:	6078      	str	r0, [r7, #4]
 800b2d0:	6039      	str	r1, [r7, #0]
    OsMuxDlockNodeDelete(taskId, muxCB);
 800b2d2:	6839      	ldr	r1, [r7, #0]
 800b2d4:	6878      	ldr	r0, [r7, #4]
 800b2d6:	f7fb fb6f 	bl	80069b8 <OsMuxDlockNodeDelete>
}
 800b2da:	bf00      	nop
 800b2dc:	3708      	adds	r7, #8
 800b2de:	46bd      	mov	sp, r7
 800b2e0:	bd80      	pop	{r7, pc}

0800b2e2 <OsMuxDbgInitHook>:

/* mutex debug initialization interface */
extern UINT32 OsMuxDbgInit(VOID);
STATIC INLINE UINT32 OsMuxDbgInitHook(VOID)
{
 800b2e2:	b580      	push	{r7, lr}
 800b2e4:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_MUTEX
    return OsMuxDbgInit();
 800b2e6:	f7fb f87b 	bl	80063e0 <OsMuxDbgInit>
 800b2ea:	4603      	mov	r3, r0
#else
    return LOS_OK;
#endif
}
 800b2ec:	4618      	mov	r0, r3
 800b2ee:	bd80      	pop	{r7, pc}

0800b2f0 <OsMuxDbgTimeUpdateHook>:
/* Update the last time the mutex was executed */
extern VOID OsMuxDbgTimeUpdate(UINT32 muxId);
STATIC INLINE VOID OsMuxDbgTimeUpdateHook(UINT32 muxId)
{
 800b2f0:	b580      	push	{r7, lr}
 800b2f2:	b082      	sub	sp, #8
 800b2f4:	af00      	add	r7, sp, #0
 800b2f6:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_DEBUG_MUTEX
    OsMuxDbgTimeUpdate(muxId);
 800b2f8:	6878      	ldr	r0, [r7, #4]
 800b2fa:	f7fb f8a3 	bl	8006444 <OsMuxDbgTimeUpdate>
#endif
}
 800b2fe:	bf00      	nop
 800b300:	3708      	adds	r7, #8
 800b302:	46bd      	mov	sp, r7
 800b304:	bd80      	pop	{r7, pc}

0800b306 <OsMuxDbgUpdateHook>:
/* Update the MUX_DEBUG_CB of the mutex when created or deleted */
extern VOID OsMuxDbgUpdate(UINT32 muxID, TSK_ENTRY_FUNC creator);
STATIC INLINE VOID OsMuxDbgUpdateHook(UINT32 muxId, TSK_ENTRY_FUNC creator)
{
 800b306:	b580      	push	{r7, lr}
 800b308:	b082      	sub	sp, #8
 800b30a:	af00      	add	r7, sp, #0
 800b30c:	6078      	str	r0, [r7, #4]
 800b30e:	6039      	str	r1, [r7, #0]
#ifdef LOSCFG_DEBUG_MUTEX
    OsMuxDbgUpdate(muxId, creator);
 800b310:	6839      	ldr	r1, [r7, #0]
 800b312:	6878      	ldr	r0, [r7, #4]
 800b314:	f7fb f8ae 	bl	8006474 <OsMuxDbgUpdate>
#endif
}
 800b318:	bf00      	nop
 800b31a:	3708      	adds	r7, #8
 800b31c:	46bd      	mov	sp, r7
 800b31e:	bd80      	pop	{r7, pc}

0800b320 <OsMutexCheckHook>:
/* check the leak of mutex */
extern VOID OsMutexCheck(VOID);
STATIC INLINE VOID OsMutexCheckHook(VOID)
{
 800b320:	b580      	push	{r7, lr}
 800b322:	af00      	add	r7, sp, #0
#ifdef LOSCFG_DEBUG_MUTEX
    OsMutexCheck();
 800b324:	f7fb f974 	bl	8006610 <OsMutexCheck>
#endif
}
 800b328:	bf00      	nop
 800b32a:	bd80      	pop	{r7, pc}

0800b32c <LOS_MpSchedule>:
{
 800b32c:	b480      	push	{r7}
 800b32e:	b083      	sub	sp, #12
 800b330:	af00      	add	r7, sp, #0
 800b332:	6078      	str	r0, [r7, #4]
}
 800b334:	bf00      	nop
 800b336:	370c      	adds	r7, #12
 800b338:	46bd      	mov	sp, r7
 800b33a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b33e:	4770      	bx	lr

0800b340 <OsMuxInit>:
/*
 * Description  : Initializes the mutex
 * Return       : LOS_OK on success, or error code on failure
 */
LITE_OS_SEC_TEXT UINT32 OsMuxInit(VOID)
{
 800b340:	b580      	push	{r7, lr}
 800b342:	b082      	sub	sp, #8
 800b344:	af00      	add	r7, sp, #0
    LosMuxCB *muxNode = NULL;
 800b346:	2300      	movs	r3, #0
 800b348:	607b      	str	r3, [r7, #4]
    UINT32 index;

    LOS_ListInit(&g_unusedMuxList);
 800b34a:	481f      	ldr	r0, [pc, #124]	; (800b3c8 <OsMuxInit+0x88>)
 800b34c:	f7ff fec7 	bl	800b0de <LOS_ListInit>
    /* system resident memory, don't free */
    g_allMux = (LosMuxCB *)LOS_MemAlloc(m_aucSysMem0, (KERNEL_MUX_LIMIT * sizeof(LosMuxCB)));
 800b350:	4b1e      	ldr	r3, [pc, #120]	; (800b3cc <OsMuxInit+0x8c>)
 800b352:	681b      	ldr	r3, [r3, #0]
 800b354:	f44f 71c8 	mov.w	r1, #400	; 0x190
 800b358:	4618      	mov	r0, r3
 800b35a:	f7fe f85b 	bl	8009414 <LOS_MemAlloc>
 800b35e:	4603      	mov	r3, r0
 800b360:	4a1b      	ldr	r2, [pc, #108]	; (800b3d0 <OsMuxInit+0x90>)
 800b362:	6013      	str	r3, [r2, #0]
    if (g_allMux == NULL) {
 800b364:	4b1a      	ldr	r3, [pc, #104]	; (800b3d0 <OsMuxInit+0x90>)
 800b366:	681b      	ldr	r3, [r3, #0]
 800b368:	2b00      	cmp	r3, #0
 800b36a:	d101      	bne.n	800b370 <OsMuxInit+0x30>
        return LOS_ERRNO_MUX_NO_MEMORY;
 800b36c:	4b19      	ldr	r3, [pc, #100]	; (800b3d4 <OsMuxInit+0x94>)
 800b36e:	e027      	b.n	800b3c0 <OsMuxInit+0x80>
    }

    for (index = 0; index < KERNEL_MUX_LIMIT; index++) {
 800b370:	2300      	movs	r3, #0
 800b372:	603b      	str	r3, [r7, #0]
 800b374:	e019      	b.n	800b3aa <OsMuxInit+0x6a>
        muxNode = g_allMux + index;
 800b376:	4b16      	ldr	r3, [pc, #88]	; (800b3d0 <OsMuxInit+0x90>)
 800b378:	6819      	ldr	r1, [r3, #0]
 800b37a:	683a      	ldr	r2, [r7, #0]
 800b37c:	4613      	mov	r3, r2
 800b37e:	009b      	lsls	r3, r3, #2
 800b380:	4413      	add	r3, r2
 800b382:	009b      	lsls	r3, r3, #2
 800b384:	440b      	add	r3, r1
 800b386:	607b      	str	r3, [r7, #4]
        muxNode->muxId = index;
 800b388:	687b      	ldr	r3, [r7, #4]
 800b38a:	683a      	ldr	r2, [r7, #0]
 800b38c:	611a      	str	r2, [r3, #16]
        muxNode->owner = NULL;
 800b38e:	687b      	ldr	r3, [r7, #4]
 800b390:	2200      	movs	r2, #0
 800b392:	609a      	str	r2, [r3, #8]
        muxNode->muxStat = LOS_UNUSED;
 800b394:	687b      	ldr	r3, [r7, #4]
 800b396:	2200      	movs	r2, #0
 800b398:	739a      	strb	r2, [r3, #14]
        LOS_ListTailInsert(&g_unusedMuxList, &muxNode->muxList);
 800b39a:	687b      	ldr	r3, [r7, #4]
 800b39c:	4619      	mov	r1, r3
 800b39e:	480a      	ldr	r0, [pc, #40]	; (800b3c8 <OsMuxInit+0x88>)
 800b3a0:	f7ff fec6 	bl	800b130 <LOS_ListTailInsert>
    for (index = 0; index < KERNEL_MUX_LIMIT; index++) {
 800b3a4:	683b      	ldr	r3, [r7, #0]
 800b3a6:	3301      	adds	r3, #1
 800b3a8:	603b      	str	r3, [r7, #0]
 800b3aa:	683b      	ldr	r3, [r7, #0]
 800b3ac:	2b13      	cmp	r3, #19
 800b3ae:	d9e2      	bls.n	800b376 <OsMuxInit+0x36>
    }

    if (OsMuxDbgInitHook() != LOS_OK) {
 800b3b0:	f7ff ff97 	bl	800b2e2 <OsMuxDbgInitHook>
 800b3b4:	4603      	mov	r3, r0
 800b3b6:	2b00      	cmp	r3, #0
 800b3b8:	d001      	beq.n	800b3be <OsMuxInit+0x7e>
        return LOS_ERRNO_MUX_NO_MEMORY;
 800b3ba:	4b06      	ldr	r3, [pc, #24]	; (800b3d4 <OsMuxInit+0x94>)
 800b3bc:	e000      	b.n	800b3c0 <OsMuxInit+0x80>
    }
    return LOS_OK;
 800b3be:	2300      	movs	r3, #0
}
 800b3c0:	4618      	mov	r0, r3
 800b3c2:	3708      	adds	r7, #8
 800b3c4:	46bd      	mov	sp, r7
 800b3c6:	bd80      	pop	{r7, pc}
 800b3c8:	200021d4 	.word	0x200021d4
 800b3cc:	200021bc 	.word	0x200021bc
 800b3d0:	200021d0 	.word	0x200021d0
 800b3d4:	02001d00 	.word	0x02001d00

0800b3d8 <LOS_MuxCreate>:

LITE_OS_SEC_TEXT UINT32 LOS_MuxCreate(UINT32 *muxHandle)
{
 800b3d8:	b590      	push	{r4, r7, lr}
 800b3da:	b08f      	sub	sp, #60	; 0x3c
 800b3dc:	af02      	add	r7, sp, #8
 800b3de:	6078      	str	r0, [r7, #4]
 800b3e0:	4b42      	ldr	r3, [pc, #264]	; (800b4ec <LOS_MuxCreate+0x114>)
 800b3e2:	681b      	ldr	r3, [r3, #0]
 800b3e4:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b3e6:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosMuxCB *muxCreated = NULL;
 800b3ea:	2300      	movs	r3, #0
 800b3ec:	613b      	str	r3, [r7, #16]
    LOS_DL_LIST *unusedMux = NULL;
 800b3ee:	2300      	movs	r3, #0
 800b3f0:	617b      	str	r3, [r7, #20]
    UINT32 errNo;
    UINT32 errLine;

    if (muxHandle == NULL) {
 800b3f2:	687b      	ldr	r3, [r7, #4]
 800b3f4:	2b00      	cmp	r3, #0
 800b3f6:	d101      	bne.n	800b3fc <LOS_MuxCreate+0x24>
        return LOS_ERRNO_MUX_PTR_NULL;
 800b3f8:	4b3d      	ldr	r3, [pc, #244]	; (800b4f0 <LOS_MuxCreate+0x118>)
 800b3fa:	e06b      	b.n	800b4d4 <LOS_MuxCreate+0xfc>
    }

    SCHEDULER_LOCK(intSave);
 800b3fc:	f107 030c 	add.w	r3, r7, #12
 800b400:	4619      	mov	r1, r3
 800b402:	483c      	ldr	r0, [pc, #240]	; (800b4f4 <LOS_MuxCreate+0x11c>)
 800b404:	f7ff ff32 	bl	800b26c <LOS_SpinLockSave>
    if (LOS_ListEmpty(&g_unusedMuxList)) {
 800b408:	483b      	ldr	r0, [pc, #236]	; (800b4f8 <LOS_MuxCreate+0x120>)
 800b40a:	f7ff feba 	bl	800b182 <LOS_ListEmpty>
 800b40e:	4603      	mov	r3, r0
 800b410:	2b00      	cmp	r3, #0
 800b412:	d015      	beq.n	800b440 <LOS_MuxCreate+0x68>
        SCHEDULER_UNLOCK(intSave);
 800b414:	68fb      	ldr	r3, [r7, #12]
 800b416:	4619      	mov	r1, r3
 800b418:	4836      	ldr	r0, [pc, #216]	; (800b4f4 <LOS_MuxCreate+0x11c>)
 800b41a:	f7ff ff35 	bl	800b288 <LOS_SpinUnlockRestore>
        OsMutexCheckHook();
 800b41e:	f7ff ff7f 	bl	800b320 <OsMutexCheckHook>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_ALL_BUSY);
 800b422:	4b36      	ldr	r3, [pc, #216]	; (800b4fc <LOS_MuxCreate+0x124>)
 800b424:	61fb      	str	r3, [r7, #28]
 800b426:	4b36      	ldr	r3, [pc, #216]	; (800b500 <LOS_MuxCreate+0x128>)
 800b428:	623b      	str	r3, [r7, #32]
 800b42a:	bf00      	nop

    LOS_TRACE(MUX_CREATE, muxCreated->muxId);
    return LOS_OK;

ERR_HANDLER:
    OS_RETURN_ERROR_P2(errLine, errNo);
 800b42c:	2300      	movs	r3, #0
 800b42e:	9300      	str	r3, [sp, #0]
 800b430:	2300      	movs	r3, #0
 800b432:	69fa      	ldr	r2, [r7, #28]
 800b434:	6a39      	ldr	r1, [r7, #32]
 800b436:	4833      	ldr	r0, [pc, #204]	; (800b504 <LOS_MuxCreate+0x12c>)
 800b438:	f7fe fde8 	bl	800a00c <LOS_ErrHandle>
 800b43c:	69fb      	ldr	r3, [r7, #28]
 800b43e:	e049      	b.n	800b4d4 <LOS_MuxCreate+0xfc>
    unusedMux = LOS_DL_LIST_FIRST(&g_unusedMuxList);
 800b440:	4b2d      	ldr	r3, [pc, #180]	; (800b4f8 <LOS_MuxCreate+0x120>)
 800b442:	685b      	ldr	r3, [r3, #4]
 800b444:	617b      	str	r3, [r7, #20]
    LOS_ListDelete(unusedMux);
 800b446:	6978      	ldr	r0, [r7, #20]
 800b448:	f7ff fe81 	bl	800b14e <LOS_ListDelete>
    muxCreated = LOS_DL_LIST_ENTRY(unusedMux, LosMuxCB, muxList);
 800b44c:	697b      	ldr	r3, [r7, #20]
 800b44e:	613b      	str	r3, [r7, #16]
    muxCreated->muxCount = 0;
 800b450:	693b      	ldr	r3, [r7, #16]
 800b452:	2200      	movs	r2, #0
 800b454:	819a      	strh	r2, [r3, #12]
    muxCreated->muxStat = LOS_USED;
 800b456:	693b      	ldr	r3, [r7, #16]
 800b458:	2201      	movs	r2, #1
 800b45a:	739a      	strb	r2, [r3, #14]
    muxCreated->owner = NULL;
 800b45c:	693b      	ldr	r3, [r7, #16]
 800b45e:	2200      	movs	r2, #0
 800b460:	609a      	str	r2, [r3, #8]
    LOS_ListInit(&muxCreated->muxList);
 800b462:	693b      	ldr	r3, [r7, #16]
 800b464:	4618      	mov	r0, r3
 800b466:	f7ff fe3a 	bl	800b0de <LOS_ListInit>
    *muxHandle = muxCreated->muxId;
 800b46a:	693b      	ldr	r3, [r7, #16]
 800b46c:	691a      	ldr	r2, [r3, #16]
 800b46e:	687b      	ldr	r3, [r7, #4]
 800b470:	601a      	str	r2, [r3, #0]
    OsMuxDbgUpdateHook(muxCreated->muxId, OsCurrTaskGet()->taskEntry);
 800b472:	693b      	ldr	r3, [r7, #16]
 800b474:	691c      	ldr	r4, [r3, #16]
 800b476:	f7ff ff13 	bl	800b2a0 <OsCurrTaskGet>
 800b47a:	4603      	mov	r3, r0
 800b47c:	699b      	ldr	r3, [r3, #24]
 800b47e:	4619      	mov	r1, r3
 800b480:	4620      	mov	r0, r4
 800b482:	f7ff ff40 	bl	800b306 <OsMuxDbgUpdateHook>
    SCHEDULER_UNLOCK(intSave);
 800b486:	68fb      	ldr	r3, [r7, #12]
 800b488:	4619      	mov	r1, r3
 800b48a:	481a      	ldr	r0, [pc, #104]	; (800b4f4 <LOS_MuxCreate+0x11c>)
 800b48c:	f7ff fefc 	bl	800b288 <LOS_SpinUnlockRestore>
    LOS_TRACE(MUX_CREATE, muxCreated->muxId);
 800b490:	2300      	movs	r3, #0
 800b492:	627b      	str	r3, [r7, #36]	; 0x24
 800b494:	693b      	ldr	r3, [r7, #16]
 800b496:	691b      	ldr	r3, [r3, #16]
 800b498:	62bb      	str	r3, [r7, #40]	; 0x28
 800b49a:	2302      	movs	r3, #2
 800b49c:	61bb      	str	r3, [r7, #24]
 800b49e:	69bb      	ldr	r3, [r7, #24]
 800b4a0:	2b01      	cmp	r3, #1
 800b4a2:	d916      	bls.n	800b4d2 <LOS_MuxCreate+0xfa>
 800b4a4:	4b18      	ldr	r3, [pc, #96]	; (800b508 <LOS_MuxCreate+0x130>)
 800b4a6:	681b      	ldr	r3, [r3, #0]
 800b4a8:	2b00      	cmp	r3, #0
 800b4aa:	d012      	beq.n	800b4d2 <LOS_MuxCreate+0xfa>
 800b4ac:	4b16      	ldr	r3, [pc, #88]	; (800b508 <LOS_MuxCreate+0x130>)
 800b4ae:	681c      	ldr	r4, [r3, #0]
 800b4b0:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800b4b2:	69bb      	ldr	r3, [r7, #24]
 800b4b4:	2b02      	cmp	r3, #2
 800b4b6:	d904      	bls.n	800b4c2 <LOS_MuxCreate+0xea>
 800b4b8:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800b4bc:	f103 0208 	add.w	r2, r3, #8
 800b4c0:	e000      	b.n	800b4c4 <LOS_MuxCreate+0xec>
 800b4c2:	2200      	movs	r2, #0
 800b4c4:	69bb      	ldr	r3, [r7, #24]
 800b4c6:	b29b      	uxth	r3, r3
 800b4c8:	3b02      	subs	r3, #2
 800b4ca:	b29b      	uxth	r3, r3
 800b4cc:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800b4d0:	47a0      	blx	r4
    return LOS_OK;
 800b4d2:	2300      	movs	r3, #0
}
 800b4d4:	4a05      	ldr	r2, [pc, #20]	; (800b4ec <LOS_MuxCreate+0x114>)
 800b4d6:	6811      	ldr	r1, [r2, #0]
 800b4d8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b4da:	4051      	eors	r1, r2
 800b4dc:	d001      	beq.n	800b4e2 <LOS_MuxCreate+0x10a>
 800b4de:	f7f9 f87d 	bl	80045dc <__stack_chk_fail>
 800b4e2:	4618      	mov	r0, r3
 800b4e4:	3734      	adds	r7, #52	; 0x34
 800b4e6:	46bd      	mov	sp, r7
 800b4e8:	bd90      	pop	{r4, r7, pc}
 800b4ea:	bf00      	nop
 800b4ec:	080215bc 	.word	0x080215bc
 800b4f0:	02001d02 	.word	0x02001d02
 800b4f4:	20000770 	.word	0x20000770
 800b4f8:	200021d4 	.word	0x200021d4
 800b4fc:	02001d03 	.word	0x02001d03
 800b500:	a1b2c3f8 	.word	0xa1b2c3f8
 800b504:	080215a8 	.word	0x080215a8
 800b508:	20000768 	.word	0x20000768

0800b50c <LOS_MuxDelete>:

LITE_OS_SEC_TEXT UINT32 LOS_MuxDelete(UINT32 muxHandle)
{
 800b50c:	b590      	push	{r4, r7, lr}
 800b50e:	b091      	sub	sp, #68	; 0x44
 800b510:	af02      	add	r7, sp, #8
 800b512:	6078      	str	r0, [r7, #4]
 800b514:	4b56      	ldr	r3, [pc, #344]	; (800b670 <LOS_MuxDelete+0x164>)
 800b516:	681b      	ldr	r3, [r3, #0]
 800b518:	637b      	str	r3, [r7, #52]	; 0x34
 800b51a:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    LosMuxCB *muxDeleted = NULL;
 800b51e:	2300      	movs	r3, #0
 800b520:	61bb      	str	r3, [r7, #24]
    UINT32 errNo;
    UINT32 errLine;

    if (GET_MUX_INDEX(muxHandle) >= (UINT32)KERNEL_MUX_LIMIT) {
 800b522:	687b      	ldr	r3, [r7, #4]
 800b524:	b29b      	uxth	r3, r3
 800b526:	2b13      	cmp	r3, #19
 800b528:	d904      	bls.n	800b534 <LOS_MuxDelete+0x28>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_INVALID);
 800b52a:	4b52      	ldr	r3, [pc, #328]	; (800b674 <LOS_MuxDelete+0x168>)
 800b52c:	613b      	str	r3, [r7, #16]
 800b52e:	4b52      	ldr	r3, [pc, #328]	; (800b678 <LOS_MuxDelete+0x16c>)
 800b530:	617b      	str	r3, [r7, #20]
 800b532:	e088      	b.n	800b646 <LOS_MuxDelete+0x13a>
    }

    muxDeleted = GET_MUX(muxHandle);
 800b534:	4b51      	ldr	r3, [pc, #324]	; (800b67c <LOS_MuxDelete+0x170>)
 800b536:	6819      	ldr	r1, [r3, #0]
 800b538:	687b      	ldr	r3, [r7, #4]
 800b53a:	b29a      	uxth	r2, r3
 800b53c:	4613      	mov	r3, r2
 800b53e:	009b      	lsls	r3, r3, #2
 800b540:	4413      	add	r3, r2
 800b542:	009b      	lsls	r3, r3, #2
 800b544:	440b      	add	r3, r1
 800b546:	61bb      	str	r3, [r7, #24]

    LOS_TRACE(MUX_DELETE, muxHandle, muxDeleted->muxStat, muxDeleted->muxCount,
 800b548:	2300      	movs	r3, #0
 800b54a:	623b      	str	r3, [r7, #32]
 800b54c:	687b      	ldr	r3, [r7, #4]
 800b54e:	627b      	str	r3, [r7, #36]	; 0x24
 800b550:	69bb      	ldr	r3, [r7, #24]
 800b552:	7b9b      	ldrb	r3, [r3, #14]
 800b554:	62bb      	str	r3, [r7, #40]	; 0x28
 800b556:	69bb      	ldr	r3, [r7, #24]
 800b558:	899b      	ldrh	r3, [r3, #12]
 800b55a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b55c:	69bb      	ldr	r3, [r7, #24]
 800b55e:	689b      	ldr	r3, [r3, #8]
 800b560:	2b00      	cmp	r3, #0
 800b562:	d003      	beq.n	800b56c <LOS_MuxDelete+0x60>
 800b564:	69bb      	ldr	r3, [r7, #24]
 800b566:	689b      	ldr	r3, [r3, #8]
 800b568:	695b      	ldr	r3, [r3, #20]
 800b56a:	e001      	b.n	800b570 <LOS_MuxDelete+0x64>
 800b56c:	f04f 33ff 	mov.w	r3, #4294967295
 800b570:	633b      	str	r3, [r7, #48]	; 0x30
 800b572:	2305      	movs	r3, #5
 800b574:	61fb      	str	r3, [r7, #28]
 800b576:	69fb      	ldr	r3, [r7, #28]
 800b578:	2b01      	cmp	r3, #1
 800b57a:	d916      	bls.n	800b5aa <LOS_MuxDelete+0x9e>
 800b57c:	4b40      	ldr	r3, [pc, #256]	; (800b680 <LOS_MuxDelete+0x174>)
 800b57e:	681b      	ldr	r3, [r3, #0]
 800b580:	2b00      	cmp	r3, #0
 800b582:	d012      	beq.n	800b5aa <LOS_MuxDelete+0x9e>
 800b584:	4b3e      	ldr	r3, [pc, #248]	; (800b680 <LOS_MuxDelete+0x174>)
 800b586:	681c      	ldr	r4, [r3, #0]
 800b588:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800b58a:	69fb      	ldr	r3, [r7, #28]
 800b58c:	2b02      	cmp	r3, #2
 800b58e:	d904      	bls.n	800b59a <LOS_MuxDelete+0x8e>
 800b590:	f107 0320 	add.w	r3, r7, #32
 800b594:	f103 0208 	add.w	r2, r3, #8
 800b598:	e000      	b.n	800b59c <LOS_MuxDelete+0x90>
 800b59a:	2200      	movs	r2, #0
 800b59c:	69fb      	ldr	r3, [r7, #28]
 800b59e:	b29b      	uxth	r3, r3
 800b5a0:	3b02      	subs	r3, #2
 800b5a2:	b29b      	uxth	r3, r3
 800b5a4:	f241 0001 	movw	r0, #4097	; 0x1001
 800b5a8:	47a0      	blx	r4
        ((muxDeleted->owner == NULL) ? 0xFFFFFFFF : muxDeleted->owner->taskId));

    SCHEDULER_LOCK(intSave);
 800b5aa:	f107 030c 	add.w	r3, r7, #12
 800b5ae:	4619      	mov	r1, r3
 800b5b0:	4834      	ldr	r0, [pc, #208]	; (800b684 <LOS_MuxDelete+0x178>)
 800b5b2:	f7ff fe5b 	bl	800b26c <LOS_SpinLockSave>
    if ((muxDeleted->muxId != muxHandle) || (muxDeleted->muxStat == LOS_UNUSED)) {
 800b5b6:	69bb      	ldr	r3, [r7, #24]
 800b5b8:	691b      	ldr	r3, [r3, #16]
 800b5ba:	687a      	ldr	r2, [r7, #4]
 800b5bc:	429a      	cmp	r2, r3
 800b5be:	d103      	bne.n	800b5c8 <LOS_MuxDelete+0xbc>
 800b5c0:	69bb      	ldr	r3, [r7, #24]
 800b5c2:	7b9b      	ldrb	r3, [r3, #14]
 800b5c4:	2b00      	cmp	r3, #0
 800b5c6:	d109      	bne.n	800b5dc <LOS_MuxDelete+0xd0>
        SCHEDULER_UNLOCK(intSave);
 800b5c8:	68fb      	ldr	r3, [r7, #12]
 800b5ca:	4619      	mov	r1, r3
 800b5cc:	482d      	ldr	r0, [pc, #180]	; (800b684 <LOS_MuxDelete+0x178>)
 800b5ce:	f7ff fe5b 	bl	800b288 <LOS_SpinUnlockRestore>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_INVALID);
 800b5d2:	4b28      	ldr	r3, [pc, #160]	; (800b674 <LOS_MuxDelete+0x168>)
 800b5d4:	613b      	str	r3, [r7, #16]
 800b5d6:	4b28      	ldr	r3, [pc, #160]	; (800b678 <LOS_MuxDelete+0x16c>)
 800b5d8:	617b      	str	r3, [r7, #20]
 800b5da:	e034      	b.n	800b646 <LOS_MuxDelete+0x13a>
    }

    if (!LOS_ListEmpty(&muxDeleted->muxList) || muxDeleted->muxCount) {
 800b5dc:	69bb      	ldr	r3, [r7, #24]
 800b5de:	4618      	mov	r0, r3
 800b5e0:	f7ff fdcf 	bl	800b182 <LOS_ListEmpty>
 800b5e4:	4603      	mov	r3, r0
 800b5e6:	2b00      	cmp	r3, #0
 800b5e8:	d003      	beq.n	800b5f2 <LOS_MuxDelete+0xe6>
 800b5ea:	69bb      	ldr	r3, [r7, #24]
 800b5ec:	899b      	ldrh	r3, [r3, #12]
 800b5ee:	2b00      	cmp	r3, #0
 800b5f0:	d009      	beq.n	800b606 <LOS_MuxDelete+0xfa>
        SCHEDULER_UNLOCK(intSave);
 800b5f2:	68fb      	ldr	r3, [r7, #12]
 800b5f4:	4619      	mov	r1, r3
 800b5f6:	4823      	ldr	r0, [pc, #140]	; (800b684 <LOS_MuxDelete+0x178>)
 800b5f8:	f7ff fe46 	bl	800b288 <LOS_SpinUnlockRestore>
        OS_GOTO_ERR_HANDLER(LOS_ERRNO_MUX_PENDED);
 800b5fc:	4b22      	ldr	r3, [pc, #136]	; (800b688 <LOS_MuxDelete+0x17c>)
 800b5fe:	613b      	str	r3, [r7, #16]
 800b600:	4b1d      	ldr	r3, [pc, #116]	; (800b678 <LOS_MuxDelete+0x16c>)
 800b602:	617b      	str	r3, [r7, #20]
 800b604:	e01f      	b.n	800b646 <LOS_MuxDelete+0x13a>
    }

    LOS_ListTailInsert(&g_unusedMuxList, &muxDeleted->muxList);
 800b606:	69bb      	ldr	r3, [r7, #24]
 800b608:	4619      	mov	r1, r3
 800b60a:	4820      	ldr	r0, [pc, #128]	; (800b68c <LOS_MuxDelete+0x180>)
 800b60c:	f7ff fd90 	bl	800b130 <LOS_ListTailInsert>
    muxDeleted->muxStat = LOS_UNUSED;
 800b610:	69bb      	ldr	r3, [r7, #24]
 800b612:	2200      	movs	r2, #0
 800b614:	739a      	strb	r2, [r3, #14]
    muxDeleted->muxId = SET_MUX_ID(GET_MUX_COUNT(muxDeleted->muxId) + 1, GET_MUX_INDEX(muxDeleted->muxId));
 800b616:	69bb      	ldr	r3, [r7, #24]
 800b618:	691b      	ldr	r3, [r3, #16]
 800b61a:	0c1b      	lsrs	r3, r3, #16
 800b61c:	3301      	adds	r3, #1
 800b61e:	041a      	lsls	r2, r3, #16
 800b620:	69bb      	ldr	r3, [r7, #24]
 800b622:	691b      	ldr	r3, [r3, #16]
 800b624:	b29b      	uxth	r3, r3
 800b626:	431a      	orrs	r2, r3
 800b628:	69bb      	ldr	r3, [r7, #24]
 800b62a:	611a      	str	r2, [r3, #16]

    OsMuxDbgUpdateHook(muxDeleted->muxId, NULL);
 800b62c:	69bb      	ldr	r3, [r7, #24]
 800b62e:	691b      	ldr	r3, [r3, #16]
 800b630:	2100      	movs	r1, #0
 800b632:	4618      	mov	r0, r3
 800b634:	f7ff fe67 	bl	800b306 <OsMuxDbgUpdateHook>

    SCHEDULER_UNLOCK(intSave);
 800b638:	68fb      	ldr	r3, [r7, #12]
 800b63a:	4619      	mov	r1, r3
 800b63c:	4811      	ldr	r0, [pc, #68]	; (800b684 <LOS_MuxDelete+0x178>)
 800b63e:	f7ff fe23 	bl	800b288 <LOS_SpinUnlockRestore>

    return LOS_OK;
 800b642:	2300      	movs	r3, #0
 800b644:	e008      	b.n	800b658 <LOS_MuxDelete+0x14c>

ERR_HANDLER:
    OS_RETURN_ERROR_P2(errLine, errNo);
 800b646:	2300      	movs	r3, #0
 800b648:	9300      	str	r3, [sp, #0]
 800b64a:	2300      	movs	r3, #0
 800b64c:	693a      	ldr	r2, [r7, #16]
 800b64e:	6979      	ldr	r1, [r7, #20]
 800b650:	480f      	ldr	r0, [pc, #60]	; (800b690 <LOS_MuxDelete+0x184>)
 800b652:	f7fe fcdb 	bl	800a00c <LOS_ErrHandle>
 800b656:	693b      	ldr	r3, [r7, #16]
}
 800b658:	4a05      	ldr	r2, [pc, #20]	; (800b670 <LOS_MuxDelete+0x164>)
 800b65a:	6811      	ldr	r1, [r2, #0]
 800b65c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b65e:	4051      	eors	r1, r2
 800b660:	d001      	beq.n	800b666 <LOS_MuxDelete+0x15a>
 800b662:	f7f8 ffbb 	bl	80045dc <__stack_chk_fail>
 800b666:	4618      	mov	r0, r3
 800b668:	373c      	adds	r7, #60	; 0x3c
 800b66a:	46bd      	mov	sp, r7
 800b66c:	bd90      	pop	{r4, r7, pc}
 800b66e:	bf00      	nop
 800b670:	080215c0 	.word	0x080215c0
 800b674:	02001d01 	.word	0x02001d01
 800b678:	a1b2c3f8 	.word	0xa1b2c3f8
 800b67c:	200021d0 	.word	0x200021d0
 800b680:	20000768 	.word	0x20000768
 800b684:	20000770 	.word	0x20000770
 800b688:	02001d09 	.word	0x02001d09
 800b68c:	200021d4 	.word	0x200021d4
 800b690:	080215a8 	.word	0x080215a8

0800b694 <OsMuxParaCheck>:

LITE_OS_SEC_TEXT STATIC UINT32 OsMuxParaCheck(const LosMuxCB *muxCB, UINT32 muxHandle)
{
 800b694:	b580      	push	{r7, lr}
 800b696:	b084      	sub	sp, #16
 800b698:	af02      	add	r7, sp, #8
 800b69a:	6078      	str	r0, [r7, #4]
 800b69c:	6039      	str	r1, [r7, #0]
    if ((muxCB->muxStat == LOS_UNUSED) || (muxCB->muxId != muxHandle)) {
 800b69e:	687b      	ldr	r3, [r7, #4]
 800b6a0:	7b9b      	ldrb	r3, [r3, #14]
 800b6a2:	2b00      	cmp	r3, #0
 800b6a4:	d004      	beq.n	800b6b0 <OsMuxParaCheck+0x1c>
 800b6a6:	687b      	ldr	r3, [r7, #4]
 800b6a8:	691b      	ldr	r3, [r3, #16]
 800b6aa:	683a      	ldr	r2, [r7, #0]
 800b6ac:	429a      	cmp	r2, r3
 800b6ae:	d009      	beq.n	800b6c4 <OsMuxParaCheck+0x30>
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
 800b6b0:	2300      	movs	r3, #0
 800b6b2:	9300      	str	r3, [sp, #0]
 800b6b4:	2300      	movs	r3, #0
 800b6b6:	4a0c      	ldr	r2, [pc, #48]	; (800b6e8 <OsMuxParaCheck+0x54>)
 800b6b8:	490c      	ldr	r1, [pc, #48]	; (800b6ec <OsMuxParaCheck+0x58>)
 800b6ba:	480d      	ldr	r0, [pc, #52]	; (800b6f0 <OsMuxParaCheck+0x5c>)
 800b6bc:	f7fe fca6 	bl	800a00c <LOS_ErrHandle>
 800b6c0:	4b09      	ldr	r3, [pc, #36]	; (800b6e8 <OsMuxParaCheck+0x54>)
 800b6c2:	e00c      	b.n	800b6de <OsMuxParaCheck+0x4a>
    }

    OsMuxDbgTimeUpdateHook(muxCB->muxId);
 800b6c4:	687b      	ldr	r3, [r7, #4]
 800b6c6:	691b      	ldr	r3, [r3, #16]
 800b6c8:	4618      	mov	r0, r3
 800b6ca:	f7ff fe11 	bl	800b2f0 <OsMuxDbgTimeUpdateHook>

    if (OS_INT_ACTIVE) {
 800b6ce:	f7f6 ffc7 	bl	8002660 <IntActive>
 800b6d2:	4603      	mov	r3, r0
 800b6d4:	2b00      	cmp	r3, #0
 800b6d6:	d001      	beq.n	800b6dc <OsMuxParaCheck+0x48>
        return LOS_ERRNO_MUX_PEND_INTERR;
 800b6d8:	4b06      	ldr	r3, [pc, #24]	; (800b6f4 <OsMuxParaCheck+0x60>)
 800b6da:	e000      	b.n	800b6de <OsMuxParaCheck+0x4a>
    }
    return LOS_OK;
 800b6dc:	2300      	movs	r3, #0
}
 800b6de:	4618      	mov	r0, r3
 800b6e0:	3708      	adds	r7, #8
 800b6e2:	46bd      	mov	sp, r7
 800b6e4:	bd80      	pop	{r7, pc}
 800b6e6:	bf00      	nop
 800b6e8:	02001d01 	.word	0x02001d01
 800b6ec:	a1b2c3f8 	.word	0xa1b2c3f8
 800b6f0:	080215a8 	.word	0x080215a8
 800b6f4:	02001d05 	.word	0x02001d05

0800b6f8 <OsMuxBitmapSet>:

LITE_OS_SEC_TEXT STATIC VOID OsMuxBitmapSet(const LosTaskCB *runTask, const MuxBaseCB *muxPended)
{
 800b6f8:	b580      	push	{r7, lr}
 800b6fa:	b082      	sub	sp, #8
 800b6fc:	af00      	add	r7, sp, #0
 800b6fe:	6078      	str	r0, [r7, #4]
 800b700:	6039      	str	r1, [r7, #0]
    if (muxPended->owner->priority > runTask->priority) {
 800b702:	683b      	ldr	r3, [r7, #0]
 800b704:	689b      	ldr	r3, [r3, #8]
 800b706:	88da      	ldrh	r2, [r3, #6]
 800b708:	687b      	ldr	r3, [r7, #4]
 800b70a:	88db      	ldrh	r3, [r3, #6]
 800b70c:	429a      	cmp	r2, r3
 800b70e:	d912      	bls.n	800b736 <OsMuxBitmapSet+0x3e>
        LOS_BitmapSet(&(muxPended->owner->priBitMap), muxPended->owner->priority);
 800b710:	683b      	ldr	r3, [r7, #0]
 800b712:	689b      	ldr	r3, [r3, #8]
 800b714:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 800b718:	683b      	ldr	r3, [r7, #0]
 800b71a:	689b      	ldr	r3, [r3, #8]
 800b71c:	88db      	ldrh	r3, [r3, #6]
 800b71e:	4619      	mov	r1, r3
 800b720:	4610      	mov	r0, r2
 800b722:	f000 fb41 	bl	800bda8 <LOS_BitmapSet>
        OsTaskPriModify(muxPended->owner, runTask->priority);
 800b726:	683b      	ldr	r3, [r7, #0]
 800b728:	689a      	ldr	r2, [r3, #8]
 800b72a:	687b      	ldr	r3, [r7, #4]
 800b72c:	88db      	ldrh	r3, [r3, #6]
 800b72e:	4619      	mov	r1, r3
 800b730:	4610      	mov	r0, r2
 800b732:	f7f7 fb27 	bl	8002d84 <OsTaskPriModify>
    }
}
 800b736:	bf00      	nop
 800b738:	3708      	adds	r7, #8
 800b73a:	46bd      	mov	sp, r7
 800b73c:	bd80      	pop	{r7, pc}

0800b73e <OsMuxBitmapRestore>:

LITE_OS_SEC_TEXT STATIC VOID OsMuxBitmapRestore(const LosTaskCB *runTask, LosTaskCB *owner)
{
 800b73e:	b580      	push	{r7, lr}
 800b740:	b084      	sub	sp, #16
 800b742:	af00      	add	r7, sp, #0
 800b744:	6078      	str	r0, [r7, #4]
 800b746:	6039      	str	r1, [r7, #0]
    UINT16 bitMapPri;

    if (owner->priority >= runTask->priority) {
 800b748:	683b      	ldr	r3, [r7, #0]
 800b74a:	88da      	ldrh	r2, [r3, #6]
 800b74c:	687b      	ldr	r3, [r7, #4]
 800b74e:	88db      	ldrh	r3, [r3, #6]
 800b750:	429a      	cmp	r2, r3
 800b752:	d316      	bcc.n	800b782 <OsMuxBitmapRestore+0x44>
        bitMapPri = LOS_LowBitGet(owner->priBitMap);
 800b754:	683b      	ldr	r3, [r7, #0]
 800b756:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800b758:	4618      	mov	r0, r3
 800b75a:	f000 fb72 	bl	800be42 <LOS_LowBitGet>
 800b75e:	4603      	mov	r3, r0
 800b760:	81fb      	strh	r3, [r7, #14]
        if (bitMapPri != LOS_INVALID_BIT_INDEX) {
 800b762:	89fb      	ldrh	r3, [r7, #14]
 800b764:	2b20      	cmp	r3, #32
 800b766:	d020      	beq.n	800b7aa <OsMuxBitmapRestore+0x6c>
            LOS_BitmapClr(&(owner->priBitMap), bitMapPri);
 800b768:	683b      	ldr	r3, [r7, #0]
 800b76a:	336c      	adds	r3, #108	; 0x6c
 800b76c:	89fa      	ldrh	r2, [r7, #14]
 800b76e:	4611      	mov	r1, r2
 800b770:	4618      	mov	r0, r3
 800b772:	f000 fb34 	bl	800bdde <LOS_BitmapClr>
            OsTaskPriModify(owner, bitMapPri);
 800b776:	89fb      	ldrh	r3, [r7, #14]
 800b778:	4619      	mov	r1, r3
 800b77a:	6838      	ldr	r0, [r7, #0]
 800b77c:	f7f7 fb02 	bl	8002d84 <OsTaskPriModify>
    } else {
        if (LOS_HighBitGet(owner->priBitMap) != runTask->priority) {
            LOS_BitmapClr(&(owner->priBitMap), runTask->priority);
        }
    }
}
 800b780:	e013      	b.n	800b7aa <OsMuxBitmapRestore+0x6c>
        if (LOS_HighBitGet(owner->priBitMap) != runTask->priority) {
 800b782:	683b      	ldr	r3, [r7, #0]
 800b784:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800b786:	4618      	mov	r0, r3
 800b788:	f000 fb45 	bl	800be16 <LOS_HighBitGet>
 800b78c:	4603      	mov	r3, r0
 800b78e:	461a      	mov	r2, r3
 800b790:	687b      	ldr	r3, [r7, #4]
 800b792:	88db      	ldrh	r3, [r3, #6]
 800b794:	429a      	cmp	r2, r3
 800b796:	d008      	beq.n	800b7aa <OsMuxBitmapRestore+0x6c>
            LOS_BitmapClr(&(owner->priBitMap), runTask->priority);
 800b798:	683b      	ldr	r3, [r7, #0]
 800b79a:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 800b79e:	687b      	ldr	r3, [r7, #4]
 800b7a0:	88db      	ldrh	r3, [r3, #6]
 800b7a2:	4619      	mov	r1, r3
 800b7a4:	4610      	mov	r0, r2
 800b7a6:	f000 fb1a 	bl	800bdde <LOS_BitmapClr>
}
 800b7aa:	bf00      	nop
 800b7ac:	3710      	adds	r7, #16
 800b7ae:	46bd      	mov	sp, r7
 800b7b0:	bd80      	pop	{r7, pc}

0800b7b2 <OsMuxPendFindPosSub>:

#ifdef LOSCFG_MUTEX_WAITMODE_PRIO
LITE_OS_SEC_TEXT STATIC LOS_DL_LIST *OsMuxPendFindPosSub(const LosTaskCB *runTask, const MuxBaseCB *muxPended)
{
 800b7b2:	b480      	push	{r7}
 800b7b4:	b085      	sub	sp, #20
 800b7b6:	af00      	add	r7, sp, #0
 800b7b8:	6078      	str	r0, [r7, #4]
 800b7ba:	6039      	str	r1, [r7, #0]
    LosTaskCB *pendedTask = NULL;
 800b7bc:	2300      	movs	r3, #0
 800b7be:	60bb      	str	r3, [r7, #8]
    LOS_DL_LIST *node = NULL;
 800b7c0:	2300      	movs	r3, #0
 800b7c2:	60fb      	str	r3, [r7, #12]

    LOS_DL_LIST_FOR_EACH_ENTRY(pendedTask, &(muxPended->muxList), LosTaskCB, pendList) {
 800b7c4:	683b      	ldr	r3, [r7, #0]
 800b7c6:	685b      	ldr	r3, [r3, #4]
 800b7c8:	3b40      	subs	r3, #64	; 0x40
 800b7ca:	60bb      	str	r3, [r7, #8]
 800b7cc:	e018      	b.n	800b800 <OsMuxPendFindPosSub+0x4e>
        if (pendedTask->priority < runTask->priority) {
 800b7ce:	68bb      	ldr	r3, [r7, #8]
 800b7d0:	88da      	ldrh	r2, [r3, #6]
 800b7d2:	687b      	ldr	r3, [r7, #4]
 800b7d4:	88db      	ldrh	r3, [r3, #6]
 800b7d6:	429a      	cmp	r2, r3
 800b7d8:	d204      	bcs.n	800b7e4 <OsMuxPendFindPosSub+0x32>
    LOS_DL_LIST_FOR_EACH_ENTRY(pendedTask, &(muxPended->muxList), LosTaskCB, pendList) {
 800b7da:	68bb      	ldr	r3, [r7, #8]
 800b7dc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800b7de:	3b40      	subs	r3, #64	; 0x40
 800b7e0:	60bb      	str	r3, [r7, #8]
 800b7e2:	e00d      	b.n	800b800 <OsMuxPendFindPosSub+0x4e>
            continue;
        } else if (pendedTask->priority > runTask->priority) {
 800b7e4:	68bb      	ldr	r3, [r7, #8]
 800b7e6:	88da      	ldrh	r2, [r3, #6]
 800b7e8:	687b      	ldr	r3, [r7, #4]
 800b7ea:	88db      	ldrh	r3, [r3, #6]
 800b7ec:	429a      	cmp	r2, r3
 800b7ee:	d903      	bls.n	800b7f8 <OsMuxPendFindPosSub+0x46>
            node = &pendedTask->pendList;
 800b7f0:	68bb      	ldr	r3, [r7, #8]
 800b7f2:	3340      	adds	r3, #64	; 0x40
 800b7f4:	60fb      	str	r3, [r7, #12]
            break;
 800b7f6:	e009      	b.n	800b80c <OsMuxPendFindPosSub+0x5a>
        } else {
            node = pendedTask->pendList.pstNext;
 800b7f8:	68bb      	ldr	r3, [r7, #8]
 800b7fa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800b7fc:	60fb      	str	r3, [r7, #12]
            break;
 800b7fe:	e005      	b.n	800b80c <OsMuxPendFindPosSub+0x5a>
    LOS_DL_LIST_FOR_EACH_ENTRY(pendedTask, &(muxPended->muxList), LosTaskCB, pendList) {
 800b800:	68bb      	ldr	r3, [r7, #8]
 800b802:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800b806:	683b      	ldr	r3, [r7, #0]
 800b808:	429a      	cmp	r2, r3
 800b80a:	d1e0      	bne.n	800b7ce <OsMuxPendFindPosSub+0x1c>
        }
    }

    return node;
 800b80c:	68fb      	ldr	r3, [r7, #12]
}
 800b80e:	4618      	mov	r0, r3
 800b810:	3714      	adds	r7, #20
 800b812:	46bd      	mov	sp, r7
 800b814:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b818:	4770      	bx	lr

0800b81a <OsMuxPendFindPos>:

LITE_OS_SEC_TEXT STATIC LOS_DL_LIST *OsMuxPendFindPos(const LosTaskCB *runTask, MuxBaseCB *muxPended)
{
 800b81a:	b580      	push	{r7, lr}
 800b81c:	b086      	sub	sp, #24
 800b81e:	af00      	add	r7, sp, #0
 800b820:	6078      	str	r0, [r7, #4]
 800b822:	6039      	str	r1, [r7, #0]
    LOS_DL_LIST *node = NULL;
 800b824:	2300      	movs	r3, #0
 800b826:	60fb      	str	r3, [r7, #12]
    LosTaskCB *pendedTask1 = NULL;
 800b828:	2300      	movs	r3, #0
 800b82a:	613b      	str	r3, [r7, #16]
    LosTaskCB *pendedTask2 = NULL;
 800b82c:	2300      	movs	r3, #0
 800b82e:	617b      	str	r3, [r7, #20]

    if (LOS_ListEmpty(&muxPended->muxList)) {
 800b830:	683b      	ldr	r3, [r7, #0]
 800b832:	4618      	mov	r0, r3
 800b834:	f7ff fca5 	bl	800b182 <LOS_ListEmpty>
 800b838:	4603      	mov	r3, r0
 800b83a:	2b00      	cmp	r3, #0
 800b83c:	d002      	beq.n	800b844 <OsMuxPendFindPos+0x2a>
        node = &muxPended->muxList;
 800b83e:	683b      	ldr	r3, [r7, #0]
 800b840:	60fb      	str	r3, [r7, #12]
 800b842:	e025      	b.n	800b890 <OsMuxPendFindPos+0x76>
    } else {
        pendedTask1 = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&muxPended->muxList));
 800b844:	683b      	ldr	r3, [r7, #0]
 800b846:	685b      	ldr	r3, [r3, #4]
 800b848:	3b40      	subs	r3, #64	; 0x40
 800b84a:	613b      	str	r3, [r7, #16]
        pendedTask2 = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_LAST(&muxPended->muxList));
 800b84c:	683b      	ldr	r3, [r7, #0]
 800b84e:	681b      	ldr	r3, [r3, #0]
 800b850:	3b40      	subs	r3, #64	; 0x40
 800b852:	617b      	str	r3, [r7, #20]
        if ((pendedTask1 != NULL) && (pendedTask1->priority > runTask->priority)) {
 800b854:	693b      	ldr	r3, [r7, #16]
 800b856:	2b00      	cmp	r3, #0
 800b858:	d009      	beq.n	800b86e <OsMuxPendFindPos+0x54>
 800b85a:	693b      	ldr	r3, [r7, #16]
 800b85c:	88da      	ldrh	r2, [r3, #6]
 800b85e:	687b      	ldr	r3, [r7, #4]
 800b860:	88db      	ldrh	r3, [r3, #6]
 800b862:	429a      	cmp	r2, r3
 800b864:	d903      	bls.n	800b86e <OsMuxPendFindPos+0x54>
            node = muxPended->muxList.pstNext;
 800b866:	683b      	ldr	r3, [r7, #0]
 800b868:	685b      	ldr	r3, [r3, #4]
 800b86a:	60fb      	str	r3, [r7, #12]
 800b86c:	e010      	b.n	800b890 <OsMuxPendFindPos+0x76>
        } else if ((pendedTask2 != NULL) && (pendedTask2->priority <= runTask->priority)) {
 800b86e:	697b      	ldr	r3, [r7, #20]
 800b870:	2b00      	cmp	r3, #0
 800b872:	d008      	beq.n	800b886 <OsMuxPendFindPos+0x6c>
 800b874:	697b      	ldr	r3, [r7, #20]
 800b876:	88da      	ldrh	r2, [r3, #6]
 800b878:	687b      	ldr	r3, [r7, #4]
 800b87a:	88db      	ldrh	r3, [r3, #6]
 800b87c:	429a      	cmp	r2, r3
 800b87e:	d802      	bhi.n	800b886 <OsMuxPendFindPos+0x6c>
            node = &muxPended->muxList;
 800b880:	683b      	ldr	r3, [r7, #0]
 800b882:	60fb      	str	r3, [r7, #12]
 800b884:	e004      	b.n	800b890 <OsMuxPendFindPos+0x76>
        } else {
            node = OsMuxPendFindPosSub(runTask, muxPended);
 800b886:	6839      	ldr	r1, [r7, #0]
 800b888:	6878      	ldr	r0, [r7, #4]
 800b88a:	f7ff ff92 	bl	800b7b2 <OsMuxPendFindPosSub>
 800b88e:	60f8      	str	r0, [r7, #12]
        }
    }
    return node;
 800b890:	68fb      	ldr	r3, [r7, #12]
}
 800b892:	4618      	mov	r0, r3
 800b894:	3718      	adds	r7, #24
 800b896:	46bd      	mov	sp, r7
 800b898:	bd80      	pop	{r7, pc}
	...

0800b89c <OsMuxPendOp>:
}
#endif

LITE_OS_SEC_TEXT UINT32 OsMuxPendOp(LosTaskCB *runTask, MuxBaseCB *muxPended, UINT32 timeout,
                                    UINT32 *intSave)
{
 800b89c:	b580      	push	{r7, lr}
 800b89e:	b088      	sub	sp, #32
 800b8a0:	af00      	add	r7, sp, #0
 800b8a2:	60f8      	str	r0, [r7, #12]
 800b8a4:	60b9      	str	r1, [r7, #8]
 800b8a6:	607a      	str	r2, [r7, #4]
 800b8a8:	603b      	str	r3, [r7, #0]
    LOS_DL_LIST *node = NULL;
 800b8aa:	2300      	movs	r3, #0
 800b8ac:	61bb      	str	r3, [r7, #24]
    UINT32 ret = LOS_OK;
 800b8ae:	2300      	movs	r3, #0
 800b8b0:	617b      	str	r3, [r7, #20]
    LosTaskCB *owner = muxPended->owner;
 800b8b2:	68bb      	ldr	r3, [r7, #8]
 800b8b4:	689b      	ldr	r3, [r3, #8]
 800b8b6:	61fb      	str	r3, [r7, #28]

    runTask->taskMux = (VOID *)muxPended;
 800b8b8:	68fb      	ldr	r3, [r7, #12]
 800b8ba:	68ba      	ldr	r2, [r7, #8]
 800b8bc:	629a      	str	r2, [r3, #40]	; 0x28
    node = OsMuxPendFindPos(runTask, muxPended);
 800b8be:	68b9      	ldr	r1, [r7, #8]
 800b8c0:	68f8      	ldr	r0, [r7, #12]
 800b8c2:	f7ff ffaa 	bl	800b81a <OsMuxPendFindPos>
 800b8c6:	61b8      	str	r0, [r7, #24]
    OsTaskWait(node, OS_TASK_STATUS_PEND, timeout);
 800b8c8:	687a      	ldr	r2, [r7, #4]
 800b8ca:	2108      	movs	r1, #8
 800b8cc:	69b8      	ldr	r0, [r7, #24]
 800b8ce:	f7f8 fb47 	bl	8003f60 <OsTaskWait>
    OsSchedResched();
 800b8d2:	f7fd f971 	bl	8008bb8 <OsSchedResched>
    SCHEDULER_UNLOCK(*intSave);
 800b8d6:	683b      	ldr	r3, [r7, #0]
 800b8d8:	681b      	ldr	r3, [r3, #0]
 800b8da:	4619      	mov	r1, r3
 800b8dc:	4811      	ldr	r0, [pc, #68]	; (800b924 <OsMuxPendOp+0x88>)
 800b8de:	f7ff fcd3 	bl	800b288 <LOS_SpinUnlockRestore>
    SCHEDULER_LOCK(*intSave);
 800b8e2:	6839      	ldr	r1, [r7, #0]
 800b8e4:	480f      	ldr	r0, [pc, #60]	; (800b924 <OsMuxPendOp+0x88>)
 800b8e6:	f7ff fcc1 	bl	800b26c <LOS_SpinLockSave>

    if (runTask->taskStatus & OS_TASK_STATUS_TIMEOUT) {
 800b8ea:	68fb      	ldr	r3, [r7, #12]
 800b8ec:	889b      	ldrh	r3, [r3, #4]
 800b8ee:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b8f2:	2b00      	cmp	r3, #0
 800b8f4:	d008      	beq.n	800b908 <OsMuxPendOp+0x6c>
        runTask->taskStatus &= ~OS_TASK_STATUS_TIMEOUT;
 800b8f6:	68fb      	ldr	r3, [r7, #12]
 800b8f8:	889b      	ldrh	r3, [r3, #4]
 800b8fa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800b8fe:	b29a      	uxth	r2, r3
 800b900:	68fb      	ldr	r3, [r7, #12]
 800b902:	809a      	strh	r2, [r3, #4]
        ret = LOS_ERRNO_MUX_TIMEOUT;
 800b904:	4b08      	ldr	r3, [pc, #32]	; (800b928 <OsMuxPendOp+0x8c>)
 800b906:	617b      	str	r3, [r7, #20]
    }

    if (timeout != LOS_WAIT_FOREVER) {
 800b908:	687b      	ldr	r3, [r7, #4]
 800b90a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b90e:	d003      	beq.n	800b918 <OsMuxPendOp+0x7c>
        OsMuxBitmapRestore(runTask, owner);
 800b910:	69f9      	ldr	r1, [r7, #28]
 800b912:	68f8      	ldr	r0, [r7, #12]
 800b914:	f7ff ff13 	bl	800b73e <OsMuxBitmapRestore>
    }

    return ret;
 800b918:	697b      	ldr	r3, [r7, #20]
}
 800b91a:	4618      	mov	r0, r3
 800b91c:	3720      	adds	r7, #32
 800b91e:	46bd      	mov	sp, r7
 800b920:	bd80      	pop	{r7, pc}
 800b922:	bf00      	nop
 800b924:	20000770 	.word	0x20000770
 800b928:	02001d07 	.word	0x02001d07

0800b92c <LOS_MuxPend>:

LITE_OS_SEC_TEXT UINT32 LOS_MuxPend(UINT32 muxHandle, UINT32 timeout)
{
 800b92c:	b590      	push	{r4, r7, lr}
 800b92e:	b091      	sub	sp, #68	; 0x44
 800b930:	af02      	add	r7, sp, #8
 800b932:	6078      	str	r0, [r7, #4]
 800b934:	6039      	str	r1, [r7, #0]
 800b936:	4b5d      	ldr	r3, [pc, #372]	; (800baac <LOS_MuxPend+0x180>)
 800b938:	681b      	ldr	r3, [r3, #0]
 800b93a:	637b      	str	r3, [r7, #52]	; 0x34
 800b93c:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    UINT32 intSave;
    LosMuxCB *muxPended = NULL;
 800b940:	2300      	movs	r3, #0
 800b942:	617b      	str	r3, [r7, #20]
    LosTaskCB *runTask = NULL;
 800b944:	2300      	movs	r3, #0
 800b946:	61bb      	str	r3, [r7, #24]

    if (GET_MUX_INDEX(muxHandle) >= (UINT32)KERNEL_MUX_LIMIT) {
 800b948:	687b      	ldr	r3, [r7, #4]
 800b94a:	b29b      	uxth	r3, r3
 800b94c:	2b13      	cmp	r3, #19
 800b94e:	d909      	bls.n	800b964 <LOS_MuxPend+0x38>
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
 800b950:	2300      	movs	r3, #0
 800b952:	9300      	str	r3, [sp, #0]
 800b954:	2300      	movs	r3, #0
 800b956:	4a56      	ldr	r2, [pc, #344]	; (800bab0 <LOS_MuxPend+0x184>)
 800b958:	4956      	ldr	r1, [pc, #344]	; (800bab4 <LOS_MuxPend+0x188>)
 800b95a:	4857      	ldr	r0, [pc, #348]	; (800bab8 <LOS_MuxPend+0x18c>)
 800b95c:	f7fe fb56 	bl	800a00c <LOS_ErrHandle>
 800b960:	4b53      	ldr	r3, [pc, #332]	; (800bab0 <LOS_MuxPend+0x184>)
 800b962:	e098      	b.n	800ba96 <LOS_MuxPend+0x16a>
    }

    muxPended = GET_MUX(muxHandle);
 800b964:	4b55      	ldr	r3, [pc, #340]	; (800babc <LOS_MuxPend+0x190>)
 800b966:	6819      	ldr	r1, [r3, #0]
 800b968:	687b      	ldr	r3, [r7, #4]
 800b96a:	b29a      	uxth	r2, r3
 800b96c:	4613      	mov	r3, r2
 800b96e:	009b      	lsls	r3, r3, #2
 800b970:	4413      	add	r3, r2
 800b972:	009b      	lsls	r3, r3, #2
 800b974:	440b      	add	r3, r1
 800b976:	617b      	str	r3, [r7, #20]

    LOS_TRACE(MUX_PEND, muxHandle, muxPended->muxCount,
 800b978:	2300      	movs	r3, #0
 800b97a:	623b      	str	r3, [r7, #32]
 800b97c:	687b      	ldr	r3, [r7, #4]
 800b97e:	627b      	str	r3, [r7, #36]	; 0x24
 800b980:	697b      	ldr	r3, [r7, #20]
 800b982:	899b      	ldrh	r3, [r3, #12]
 800b984:	62bb      	str	r3, [r7, #40]	; 0x28
 800b986:	697b      	ldr	r3, [r7, #20]
 800b988:	689b      	ldr	r3, [r3, #8]
 800b98a:	2b00      	cmp	r3, #0
 800b98c:	d003      	beq.n	800b996 <LOS_MuxPend+0x6a>
 800b98e:	697b      	ldr	r3, [r7, #20]
 800b990:	689b      	ldr	r3, [r3, #8]
 800b992:	695b      	ldr	r3, [r3, #20]
 800b994:	e001      	b.n	800b99a <LOS_MuxPend+0x6e>
 800b996:	f04f 33ff 	mov.w	r3, #4294967295
 800b99a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b99c:	683b      	ldr	r3, [r7, #0]
 800b99e:	633b      	str	r3, [r7, #48]	; 0x30
 800b9a0:	2305      	movs	r3, #5
 800b9a2:	61fb      	str	r3, [r7, #28]
 800b9a4:	69fb      	ldr	r3, [r7, #28]
 800b9a6:	2b01      	cmp	r3, #1
 800b9a8:	d916      	bls.n	800b9d8 <LOS_MuxPend+0xac>
 800b9aa:	4b45      	ldr	r3, [pc, #276]	; (800bac0 <LOS_MuxPend+0x194>)
 800b9ac:	681b      	ldr	r3, [r3, #0]
 800b9ae:	2b00      	cmp	r3, #0
 800b9b0:	d012      	beq.n	800b9d8 <LOS_MuxPend+0xac>
 800b9b2:	4b43      	ldr	r3, [pc, #268]	; (800bac0 <LOS_MuxPend+0x194>)
 800b9b4:	681c      	ldr	r4, [r3, #0]
 800b9b6:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800b9b8:	69fb      	ldr	r3, [r7, #28]
 800b9ba:	2b02      	cmp	r3, #2
 800b9bc:	d904      	bls.n	800b9c8 <LOS_MuxPend+0x9c>
 800b9be:	f107 0320 	add.w	r3, r7, #32
 800b9c2:	f103 0208 	add.w	r2, r3, #8
 800b9c6:	e000      	b.n	800b9ca <LOS_MuxPend+0x9e>
 800b9c8:	2200      	movs	r2, #0
 800b9ca:	69fb      	ldr	r3, [r7, #28]
 800b9cc:	b29b      	uxth	r3, r3
 800b9ce:	3b02      	subs	r3, #2
 800b9d0:	b29b      	uxth	r3, r3
 800b9d2:	f241 0002 	movw	r0, #4098	; 0x1002
 800b9d6:	47a0      	blx	r4
        ((muxPended->owner == NULL) ? 0xFFFFFFFF : muxPended->owner->taskId), timeout);

    runTask = OsCurrTaskGet();
 800b9d8:	f7ff fc62 	bl	800b2a0 <OsCurrTaskGet>
 800b9dc:	61b8      	str	r0, [r7, #24]
    if (runTask->taskFlags & OS_TASK_FLAG_SYSTEM) {
        PRINT_DEBUG("Warning: DO NOT recommend to use %s in system tasks.\n", __FUNCTION__);
    }

    SCHEDULER_LOCK(intSave);
 800b9de:	f107 030c 	add.w	r3, r7, #12
 800b9e2:	4619      	mov	r1, r3
 800b9e4:	4837      	ldr	r0, [pc, #220]	; (800bac4 <LOS_MuxPend+0x198>)
 800b9e6:	f7ff fc41 	bl	800b26c <LOS_SpinLockSave>

    ret = OsMuxParaCheck(muxPended, muxHandle);
 800b9ea:	6879      	ldr	r1, [r7, #4]
 800b9ec:	6978      	ldr	r0, [r7, #20]
 800b9ee:	f7ff fe51 	bl	800b694 <OsMuxParaCheck>
 800b9f2:	6138      	str	r0, [r7, #16]
    if (ret != LOS_OK) {
 800b9f4:	693b      	ldr	r3, [r7, #16]
 800b9f6:	2b00      	cmp	r3, #0
 800b9f8:	d13c      	bne.n	800ba74 <LOS_MuxPend+0x148>
        goto OUT_UNLOCK;
    }

    if (muxPended->muxCount == 0) {
 800b9fa:	697b      	ldr	r3, [r7, #20]
 800b9fc:	899b      	ldrh	r3, [r3, #12]
 800b9fe:	2b00      	cmp	r3, #0
 800ba00:	d10f      	bne.n	800ba22 <LOS_MuxPend+0xf6>
        OsMuxDlockNodeInsertHook(runTask->taskId, muxPended);
 800ba02:	69bb      	ldr	r3, [r7, #24]
 800ba04:	695b      	ldr	r3, [r3, #20]
 800ba06:	6979      	ldr	r1, [r7, #20]
 800ba08:	4618      	mov	r0, r3
 800ba0a:	f7ff fc50 	bl	800b2ae <OsMuxDlockNodeInsertHook>
        muxPended->muxCount++;
 800ba0e:	697b      	ldr	r3, [r7, #20]
 800ba10:	899b      	ldrh	r3, [r3, #12]
 800ba12:	3301      	adds	r3, #1
 800ba14:	b29a      	uxth	r2, r3
 800ba16:	697b      	ldr	r3, [r7, #20]
 800ba18:	819a      	strh	r2, [r3, #12]
        muxPended->owner = runTask;
 800ba1a:	697b      	ldr	r3, [r7, #20]
 800ba1c:	69ba      	ldr	r2, [r7, #24]
 800ba1e:	609a      	str	r2, [r3, #8]
        goto OUT_UNLOCK;
 800ba20:	e029      	b.n	800ba76 <LOS_MuxPend+0x14a>
    }

    if (muxPended->owner == runTask) {
 800ba22:	697b      	ldr	r3, [r7, #20]
 800ba24:	689b      	ldr	r3, [r3, #8]
 800ba26:	69ba      	ldr	r2, [r7, #24]
 800ba28:	429a      	cmp	r2, r3
 800ba2a:	d106      	bne.n	800ba3a <LOS_MuxPend+0x10e>
        muxPended->muxCount++;
 800ba2c:	697b      	ldr	r3, [r7, #20]
 800ba2e:	899b      	ldrh	r3, [r3, #12]
 800ba30:	3301      	adds	r3, #1
 800ba32:	b29a      	uxth	r2, r3
 800ba34:	697b      	ldr	r3, [r7, #20]
 800ba36:	819a      	strh	r2, [r3, #12]
        goto OUT_UNLOCK;
 800ba38:	e01d      	b.n	800ba76 <LOS_MuxPend+0x14a>
    }

    if (!timeout) {
 800ba3a:	683b      	ldr	r3, [r7, #0]
 800ba3c:	2b00      	cmp	r3, #0
 800ba3e:	d102      	bne.n	800ba46 <LOS_MuxPend+0x11a>
        ret = LOS_ERRNO_MUX_UNAVAILABLE;
 800ba40:	4b21      	ldr	r3, [pc, #132]	; (800bac8 <LOS_MuxPend+0x19c>)
 800ba42:	613b      	str	r3, [r7, #16]
        goto OUT_UNLOCK;
 800ba44:	e017      	b.n	800ba76 <LOS_MuxPend+0x14a>
    }

    if (!OsPreemptableInSched()) {
 800ba46:	f7ff fbe5 	bl	800b214 <OsPreemptableInSched>
 800ba4a:	4603      	mov	r3, r0
 800ba4c:	2b00      	cmp	r3, #0
 800ba4e:	d104      	bne.n	800ba5a <LOS_MuxPend+0x12e>
        ret = LOS_ERRNO_MUX_PEND_IN_LOCK;
 800ba50:	4b1e      	ldr	r3, [pc, #120]	; (800bacc <LOS_MuxPend+0x1a0>)
 800ba52:	613b      	str	r3, [r7, #16]
        OsBackTrace();
 800ba54:	f7f8 fd60 	bl	8004518 <LOS_BackTrace>
        goto OUT_UNLOCK;
 800ba58:	e00d      	b.n	800ba76 <LOS_MuxPend+0x14a>
    }

    OsMuxBitmapSet(runTask, (MuxBaseCB *)muxPended);
 800ba5a:	6979      	ldr	r1, [r7, #20]
 800ba5c:	69b8      	ldr	r0, [r7, #24]
 800ba5e:	f7ff fe4b 	bl	800b6f8 <OsMuxBitmapSet>
    ret = OsMuxPendOp(runTask, (MuxBaseCB *)muxPended, timeout, &intSave);
 800ba62:	f107 030c 	add.w	r3, r7, #12
 800ba66:	683a      	ldr	r2, [r7, #0]
 800ba68:	6979      	ldr	r1, [r7, #20]
 800ba6a:	69b8      	ldr	r0, [r7, #24]
 800ba6c:	f7ff ff16 	bl	800b89c <OsMuxPendOp>
 800ba70:	6138      	str	r0, [r7, #16]
 800ba72:	e000      	b.n	800ba76 <LOS_MuxPend+0x14a>
        goto OUT_UNLOCK;
 800ba74:	bf00      	nop

OUT_UNLOCK:
    SCHEDULER_UNLOCK(intSave);
 800ba76:	68fb      	ldr	r3, [r7, #12]
 800ba78:	4619      	mov	r1, r3
 800ba7a:	4812      	ldr	r0, [pc, #72]	; (800bac4 <LOS_MuxPend+0x198>)
 800ba7c:	f7ff fc04 	bl	800b288 <LOS_SpinUnlockRestore>
    if (ret == LOS_ERRNO_MUX_PEND_IN_LOCK) {
 800ba80:	693b      	ldr	r3, [r7, #16]
 800ba82:	4a12      	ldr	r2, [pc, #72]	; (800bacc <LOS_MuxPend+0x1a0>)
 800ba84:	4293      	cmp	r3, r2
 800ba86:	d105      	bne.n	800ba94 <LOS_MuxPend+0x168>
        PRINT_ERR("!!!LOS_ERRNO_MUX_PEND_IN_LOCK!!!\n");
 800ba88:	4811      	ldr	r0, [pc, #68]	; (800bad0 <LOS_MuxPend+0x1a4>)
 800ba8a:	f7f8 ff19 	bl	80048c0 <dprintf>
 800ba8e:	4811      	ldr	r0, [pc, #68]	; (800bad4 <LOS_MuxPend+0x1a8>)
 800ba90:	f7f8 ff16 	bl	80048c0 <dprintf>
    }
    return ret;
 800ba94:	693b      	ldr	r3, [r7, #16]
}
 800ba96:	4a05      	ldr	r2, [pc, #20]	; (800baac <LOS_MuxPend+0x180>)
 800ba98:	6811      	ldr	r1, [r2, #0]
 800ba9a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ba9c:	4051      	eors	r1, r2
 800ba9e:	d001      	beq.n	800baa4 <LOS_MuxPend+0x178>
 800baa0:	f7f8 fd9c 	bl	80045dc <__stack_chk_fail>
 800baa4:	4618      	mov	r0, r3
 800baa6:	373c      	adds	r7, #60	; 0x3c
 800baa8:	46bd      	mov	sp, r7
 800baaa:	bd90      	pop	{r4, r7, pc}
 800baac:	080215f0 	.word	0x080215f0
 800bab0:	02001d01 	.word	0x02001d01
 800bab4:	a1b2c3f8 	.word	0xa1b2c3f8
 800bab8:	080215a8 	.word	0x080215a8
 800babc:	200021d0 	.word	0x200021d0
 800bac0:	20000768 	.word	0x20000768
 800bac4:	20000770 	.word	0x20000770
 800bac8:	02001d04 	.word	0x02001d04
 800bacc:	02001d06 	.word	0x02001d06
 800bad0:	080215c4 	.word	0x080215c4
 800bad4:	080215cc 	.word	0x080215cc

0800bad8 <OsMuxPostOpSub>:

LITE_OS_SEC_TEXT STATIC VOID OsMuxPostOpSub(LosTaskCB *runTask, MuxBaseCB *muxPosted)
{
 800bad8:	b580      	push	{r7, lr}
 800bada:	b084      	sub	sp, #16
 800badc:	af00      	add	r7, sp, #0
 800bade:	6078      	str	r0, [r7, #4]
 800bae0:	6039      	str	r1, [r7, #0]
    LosTaskCB *pendedTask = NULL;
 800bae2:	2300      	movs	r3, #0
 800bae4:	60fb      	str	r3, [r7, #12]
    UINT16 bitMapPri;

    if (!LOS_ListEmpty(&muxPosted->muxList)) {
 800bae6:	683b      	ldr	r3, [r7, #0]
 800bae8:	4618      	mov	r0, r3
 800baea:	f7ff fb4a 	bl	800b182 <LOS_ListEmpty>
 800baee:	4603      	mov	r3, r0
 800baf0:	2b00      	cmp	r3, #0
 800baf2:	d123      	bne.n	800bb3c <OsMuxPostOpSub+0x64>
        bitMapPri = LOS_HighBitGet(runTask->priBitMap);
 800baf4:	687b      	ldr	r3, [r7, #4]
 800baf6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800baf8:	4618      	mov	r0, r3
 800bafa:	f000 f98c 	bl	800be16 <LOS_HighBitGet>
 800bafe:	4603      	mov	r3, r0
 800bb00:	817b      	strh	r3, [r7, #10]
        LOS_DL_LIST_FOR_EACH_ENTRY(pendedTask, (&muxPosted->muxList), LosTaskCB, pendList) {
 800bb02:	683b      	ldr	r3, [r7, #0]
 800bb04:	685b      	ldr	r3, [r3, #4]
 800bb06:	3b40      	subs	r3, #64	; 0x40
 800bb08:	60fb      	str	r3, [r7, #12]
 800bb0a:	e011      	b.n	800bb30 <OsMuxPostOpSub+0x58>
            if (bitMapPri != pendedTask->priority) {
 800bb0c:	68fb      	ldr	r3, [r7, #12]
 800bb0e:	88db      	ldrh	r3, [r3, #6]
 800bb10:	897a      	ldrh	r2, [r7, #10]
 800bb12:	429a      	cmp	r2, r3
 800bb14:	d008      	beq.n	800bb28 <OsMuxPostOpSub+0x50>
                LOS_BitmapClr(&runTask->priBitMap, pendedTask->priority);
 800bb16:	687b      	ldr	r3, [r7, #4]
 800bb18:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 800bb1c:	68fb      	ldr	r3, [r7, #12]
 800bb1e:	88db      	ldrh	r3, [r3, #6]
 800bb20:	4619      	mov	r1, r3
 800bb22:	4610      	mov	r0, r2
 800bb24:	f000 f95b 	bl	800bdde <LOS_BitmapClr>
        LOS_DL_LIST_FOR_EACH_ENTRY(pendedTask, (&muxPosted->muxList), LosTaskCB, pendList) {
 800bb28:	68fb      	ldr	r3, [r7, #12]
 800bb2a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800bb2c:	3b40      	subs	r3, #64	; 0x40
 800bb2e:	60fb      	str	r3, [r7, #12]
 800bb30:	68fb      	ldr	r3, [r7, #12]
 800bb32:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800bb36:	683b      	ldr	r3, [r7, #0]
 800bb38:	429a      	cmp	r2, r3
 800bb3a:	d1e7      	bne.n	800bb0c <OsMuxPostOpSub+0x34>
            }
        }
    }
    bitMapPri = LOS_LowBitGet(runTask->priBitMap);
 800bb3c:	687b      	ldr	r3, [r7, #4]
 800bb3e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800bb40:	4618      	mov	r0, r3
 800bb42:	f000 f97e 	bl	800be42 <LOS_LowBitGet>
 800bb46:	4603      	mov	r3, r0
 800bb48:	817b      	strh	r3, [r7, #10]
    LOS_BitmapClr(&runTask->priBitMap, bitMapPri);
 800bb4a:	687b      	ldr	r3, [r7, #4]
 800bb4c:	336c      	adds	r3, #108	; 0x6c
 800bb4e:	897a      	ldrh	r2, [r7, #10]
 800bb50:	4611      	mov	r1, r2
 800bb52:	4618      	mov	r0, r3
 800bb54:	f000 f943 	bl	800bdde <LOS_BitmapClr>
    OsTaskPriModify(muxPosted->owner, bitMapPri);
 800bb58:	683b      	ldr	r3, [r7, #0]
 800bb5a:	689b      	ldr	r3, [r3, #8]
 800bb5c:	897a      	ldrh	r2, [r7, #10]
 800bb5e:	4611      	mov	r1, r2
 800bb60:	4618      	mov	r0, r3
 800bb62:	f7f7 f90f 	bl	8002d84 <OsTaskPriModify>
}
 800bb66:	bf00      	nop
 800bb68:	3710      	adds	r7, #16
 800bb6a:	46bd      	mov	sp, r7
 800bb6c:	bd80      	pop	{r7, pc}

0800bb6e <OsMuxPostOp>:

LITE_OS_SEC_TEXT UINT32 OsMuxPostOp(LosTaskCB *runTask, MuxBaseCB *muxPosted)
{
 800bb6e:	b580      	push	{r7, lr}
 800bb70:	b084      	sub	sp, #16
 800bb72:	af00      	add	r7, sp, #0
 800bb74:	6078      	str	r0, [r7, #4]
 800bb76:	6039      	str	r1, [r7, #0]
    LosTaskCB *resumedTask = NULL;
 800bb78:	2300      	movs	r3, #0
 800bb7a:	60fb      	str	r3, [r7, #12]

    if (LOS_ListEmpty(&muxPosted->muxList)) {
 800bb7c:	683b      	ldr	r3, [r7, #0]
 800bb7e:	4618      	mov	r0, r3
 800bb80:	f7ff faff 	bl	800b182 <LOS_ListEmpty>
 800bb84:	4603      	mov	r3, r0
 800bb86:	2b00      	cmp	r3, #0
 800bb88:	d00a      	beq.n	800bba0 <OsMuxPostOp+0x32>
        muxPosted->owner = NULL;
 800bb8a:	683b      	ldr	r3, [r7, #0]
 800bb8c:	2200      	movs	r2, #0
 800bb8e:	609a      	str	r2, [r3, #8]
        OsMuxDlockNodeDeleteHook(runTask->taskId, muxPosted);
 800bb90:	687b      	ldr	r3, [r7, #4]
 800bb92:	695b      	ldr	r3, [r3, #20]
 800bb94:	6839      	ldr	r1, [r7, #0]
 800bb96:	4618      	mov	r0, r3
 800bb98:	f7ff fb96 	bl	800b2c8 <OsMuxDlockNodeDeleteHook>
        return MUX_NO_SCHEDULE;
 800bb9c:	2302      	movs	r3, #2
 800bb9e:	e040      	b.n	800bc22 <OsMuxPostOp+0xb4>
    }

    resumedTask = OS_TCB_FROM_PENDLIST(LOS_DL_LIST_FIRST(&(muxPosted->muxList)));
 800bba0:	683b      	ldr	r3, [r7, #0]
 800bba2:	685b      	ldr	r3, [r3, #4]
 800bba4:	3b40      	subs	r3, #64	; 0x40
 800bba6:	60fb      	str	r3, [r7, #12]
#ifdef LOSCFG_MUTEX_WAITMODE_PRIO
    if (resumedTask->priority > runTask->priority) {
 800bba8:	68fb      	ldr	r3, [r7, #12]
 800bbaa:	88da      	ldrh	r2, [r3, #6]
 800bbac:	687b      	ldr	r3, [r7, #4]
 800bbae:	88db      	ldrh	r3, [r3, #6]
 800bbb0:	429a      	cmp	r2, r3
 800bbb2:	d914      	bls.n	800bbde <OsMuxPostOp+0x70>
        if (LOS_HighBitGet(runTask->priBitMap) != resumedTask->priority) {
 800bbb4:	687b      	ldr	r3, [r7, #4]
 800bbb6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800bbb8:	4618      	mov	r0, r3
 800bbba:	f000 f92c 	bl	800be16 <LOS_HighBitGet>
 800bbbe:	4603      	mov	r3, r0
 800bbc0:	461a      	mov	r2, r3
 800bbc2:	68fb      	ldr	r3, [r7, #12]
 800bbc4:	88db      	ldrh	r3, [r3, #6]
 800bbc6:	429a      	cmp	r2, r3
 800bbc8:	d011      	beq.n	800bbee <OsMuxPostOp+0x80>
            LOS_BitmapClr(&runTask->priBitMap, resumedTask->priority);
 800bbca:	687b      	ldr	r3, [r7, #4]
 800bbcc:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 800bbd0:	68fb      	ldr	r3, [r7, #12]
 800bbd2:	88db      	ldrh	r3, [r3, #6]
 800bbd4:	4619      	mov	r1, r3
 800bbd6:	4610      	mov	r0, r2
 800bbd8:	f000 f901 	bl	800bdde <LOS_BitmapClr>
 800bbdc:	e007      	b.n	800bbee <OsMuxPostOp+0x80>
        }
    } else if (runTask->priBitMap != 0) {
 800bbde:	687b      	ldr	r3, [r7, #4]
 800bbe0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800bbe2:	2b00      	cmp	r3, #0
 800bbe4:	d003      	beq.n	800bbee <OsMuxPostOp+0x80>
        OsMuxPostOpSub(runTask, muxPosted);
 800bbe6:	6839      	ldr	r1, [r7, #0]
 800bbe8:	6878      	ldr	r0, [r7, #4]
 800bbea:	f7ff ff75 	bl	800bad8 <OsMuxPostOpSub>
    if (runTask->priBitMap != 0) {
        OsMuxPostOpSub(runTask, muxPosted);
    }
#endif

    muxPosted->muxCount = 1;
 800bbee:	683b      	ldr	r3, [r7, #0]
 800bbf0:	2201      	movs	r2, #1
 800bbf2:	819a      	strh	r2, [r3, #12]
    muxPosted->owner = resumedTask;
 800bbf4:	683b      	ldr	r3, [r7, #0]
 800bbf6:	68fa      	ldr	r2, [r7, #12]
 800bbf8:	609a      	str	r2, [r3, #8]
    resumedTask->taskMux = NULL;
 800bbfa:	68fb      	ldr	r3, [r7, #12]
 800bbfc:	2200      	movs	r2, #0
 800bbfe:	629a      	str	r2, [r3, #40]	; 0x28
    OsMuxDlockNodeDeleteHook(runTask->taskId, muxPosted);
 800bc00:	687b      	ldr	r3, [r7, #4]
 800bc02:	695b      	ldr	r3, [r3, #20]
 800bc04:	6839      	ldr	r1, [r7, #0]
 800bc06:	4618      	mov	r0, r3
 800bc08:	f7ff fb5e 	bl	800b2c8 <OsMuxDlockNodeDeleteHook>
    OsMuxDlockNodeInsertHook(resumedTask->taskId, muxPosted);
 800bc0c:	68fb      	ldr	r3, [r7, #12]
 800bc0e:	695b      	ldr	r3, [r3, #20]
 800bc10:	6839      	ldr	r1, [r7, #0]
 800bc12:	4618      	mov	r0, r3
 800bc14:	f7ff fb4b 	bl	800b2ae <OsMuxDlockNodeInsertHook>

    OsTaskWake(resumedTask, OS_TASK_STATUS_PEND);
 800bc18:	2108      	movs	r1, #8
 800bc1a:	68f8      	ldr	r0, [r7, #12]
 800bc1c:	f7f8 f9d6 	bl	8003fcc <OsTaskWake>

    return MUX_SCHEDULE;
 800bc20:	2301      	movs	r3, #1
}
 800bc22:	4618      	mov	r0, r3
 800bc24:	3710      	adds	r7, #16
 800bc26:	46bd      	mov	sp, r7
 800bc28:	bd80      	pop	{r7, pc}
	...

0800bc2c <LOS_MuxPost>:

LITE_OS_SEC_TEXT UINT32 LOS_MuxPost(UINT32 muxHandle)
{
 800bc2c:	b590      	push	{r4, r7, lr}
 800bc2e:	b08f      	sub	sp, #60	; 0x3c
 800bc30:	af02      	add	r7, sp, #8
 800bc32:	6078      	str	r0, [r7, #4]
 800bc34:	4b55      	ldr	r3, [pc, #340]	; (800bd8c <LOS_MuxPost+0x160>)
 800bc36:	681b      	ldr	r3, [r3, #0]
 800bc38:	62fb      	str	r3, [r7, #44]	; 0x2c
 800bc3a:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    LosTaskCB *runTask = NULL;
 800bc3e:	2300      	movs	r3, #0
 800bc40:	60fb      	str	r3, [r7, #12]
    LosMuxCB *muxPosted = GET_MUX(muxHandle);
 800bc42:	4b53      	ldr	r3, [pc, #332]	; (800bd90 <LOS_MuxPost+0x164>)
 800bc44:	6819      	ldr	r1, [r3, #0]
 800bc46:	687b      	ldr	r3, [r7, #4]
 800bc48:	b29a      	uxth	r2, r3
 800bc4a:	4613      	mov	r3, r2
 800bc4c:	009b      	lsls	r3, r3, #2
 800bc4e:	4413      	add	r3, r2
 800bc50:	009b      	lsls	r3, r3, #2
 800bc52:	440b      	add	r3, r1
 800bc54:	613b      	str	r3, [r7, #16]
    UINT32 intSave;

    if (GET_MUX_INDEX(muxHandle) >= (UINT32)KERNEL_MUX_LIMIT) {
 800bc56:	687b      	ldr	r3, [r7, #4]
 800bc58:	b29b      	uxth	r3, r3
 800bc5a:	2b13      	cmp	r3, #19
 800bc5c:	d909      	bls.n	800bc72 <LOS_MuxPost+0x46>
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
 800bc5e:	2300      	movs	r3, #0
 800bc60:	9300      	str	r3, [sp, #0]
 800bc62:	2300      	movs	r3, #0
 800bc64:	4a4b      	ldr	r2, [pc, #300]	; (800bd94 <LOS_MuxPost+0x168>)
 800bc66:	494c      	ldr	r1, [pc, #304]	; (800bd98 <LOS_MuxPost+0x16c>)
 800bc68:	484c      	ldr	r0, [pc, #304]	; (800bd9c <LOS_MuxPost+0x170>)
 800bc6a:	f7fe f9cf 	bl	800a00c <LOS_ErrHandle>
 800bc6e:	4b49      	ldr	r3, [pc, #292]	; (800bd94 <LOS_MuxPost+0x168>)
 800bc70:	e081      	b.n	800bd76 <LOS_MuxPost+0x14a>
    }

    LOS_TRACE(MUX_POST, muxHandle, muxPosted->muxCount,
 800bc72:	2300      	movs	r3, #0
 800bc74:	61fb      	str	r3, [r7, #28]
 800bc76:	687b      	ldr	r3, [r7, #4]
 800bc78:	623b      	str	r3, [r7, #32]
 800bc7a:	693b      	ldr	r3, [r7, #16]
 800bc7c:	899b      	ldrh	r3, [r3, #12]
 800bc7e:	627b      	str	r3, [r7, #36]	; 0x24
 800bc80:	693b      	ldr	r3, [r7, #16]
 800bc82:	689b      	ldr	r3, [r3, #8]
 800bc84:	2b00      	cmp	r3, #0
 800bc86:	d003      	beq.n	800bc90 <LOS_MuxPost+0x64>
 800bc88:	693b      	ldr	r3, [r7, #16]
 800bc8a:	689b      	ldr	r3, [r3, #8]
 800bc8c:	695b      	ldr	r3, [r3, #20]
 800bc8e:	e001      	b.n	800bc94 <LOS_MuxPost+0x68>
 800bc90:	f04f 33ff 	mov.w	r3, #4294967295
 800bc94:	62bb      	str	r3, [r7, #40]	; 0x28
 800bc96:	2304      	movs	r3, #4
 800bc98:	617b      	str	r3, [r7, #20]
 800bc9a:	697b      	ldr	r3, [r7, #20]
 800bc9c:	2b01      	cmp	r3, #1
 800bc9e:	d916      	bls.n	800bcce <LOS_MuxPost+0xa2>
 800bca0:	4b3f      	ldr	r3, [pc, #252]	; (800bda0 <LOS_MuxPost+0x174>)
 800bca2:	681b      	ldr	r3, [r3, #0]
 800bca4:	2b00      	cmp	r3, #0
 800bca6:	d012      	beq.n	800bcce <LOS_MuxPost+0xa2>
 800bca8:	4b3d      	ldr	r3, [pc, #244]	; (800bda0 <LOS_MuxPost+0x174>)
 800bcaa:	681c      	ldr	r4, [r3, #0]
 800bcac:	6a39      	ldr	r1, [r7, #32]
 800bcae:	697b      	ldr	r3, [r7, #20]
 800bcb0:	2b02      	cmp	r3, #2
 800bcb2:	d904      	bls.n	800bcbe <LOS_MuxPost+0x92>
 800bcb4:	f107 031c 	add.w	r3, r7, #28
 800bcb8:	f103 0208 	add.w	r2, r3, #8
 800bcbc:	e000      	b.n	800bcc0 <LOS_MuxPost+0x94>
 800bcbe:	2200      	movs	r2, #0
 800bcc0:	697b      	ldr	r3, [r7, #20]
 800bcc2:	b29b      	uxth	r3, r3
 800bcc4:	3b02      	subs	r3, #2
 800bcc6:	b29b      	uxth	r3, r3
 800bcc8:	f241 0003 	movw	r0, #4099	; 0x1003
 800bccc:	47a0      	blx	r4
        ((muxPosted->owner == NULL) ? 0xFFFFFFFF : muxPosted->owner->taskId));

    SCHEDULER_LOCK(intSave);
 800bcce:	f107 0308 	add.w	r3, r7, #8
 800bcd2:	4619      	mov	r1, r3
 800bcd4:	4833      	ldr	r0, [pc, #204]	; (800bda4 <LOS_MuxPost+0x178>)
 800bcd6:	f7ff fac9 	bl	800b26c <LOS_SpinLockSave>

    ret = OsMuxParaCheck(muxPosted, muxHandle);
 800bcda:	6879      	ldr	r1, [r7, #4]
 800bcdc:	6938      	ldr	r0, [r7, #16]
 800bcde:	f7ff fcd9 	bl	800b694 <OsMuxParaCheck>
 800bce2:	61b8      	str	r0, [r7, #24]
    if (ret != LOS_OK) {
 800bce4:	69bb      	ldr	r3, [r7, #24]
 800bce6:	2b00      	cmp	r3, #0
 800bce8:	d006      	beq.n	800bcf8 <LOS_MuxPost+0xcc>
        SCHEDULER_UNLOCK(intSave);
 800bcea:	68bb      	ldr	r3, [r7, #8]
 800bcec:	4619      	mov	r1, r3
 800bcee:	482d      	ldr	r0, [pc, #180]	; (800bda4 <LOS_MuxPost+0x178>)
 800bcf0:	f7ff faca 	bl	800b288 <LOS_SpinUnlockRestore>
        return ret;
 800bcf4:	69bb      	ldr	r3, [r7, #24]
 800bcf6:	e03e      	b.n	800bd76 <LOS_MuxPost+0x14a>
    }

    runTask = OsCurrTaskGet();
 800bcf8:	f7ff fad2 	bl	800b2a0 <OsCurrTaskGet>
 800bcfc:	60f8      	str	r0, [r7, #12]
    if ((muxPosted->muxCount == 0) || (muxPosted->owner != runTask)) {
 800bcfe:	693b      	ldr	r3, [r7, #16]
 800bd00:	899b      	ldrh	r3, [r3, #12]
 800bd02:	2b00      	cmp	r3, #0
 800bd04:	d004      	beq.n	800bd10 <LOS_MuxPost+0xe4>
 800bd06:	693b      	ldr	r3, [r7, #16]
 800bd08:	689b      	ldr	r3, [r3, #8]
 800bd0a:	68fa      	ldr	r2, [r7, #12]
 800bd0c:	429a      	cmp	r2, r3
 800bd0e:	d00e      	beq.n	800bd2e <LOS_MuxPost+0x102>
        SCHEDULER_UNLOCK(intSave);
 800bd10:	68bb      	ldr	r3, [r7, #8]
 800bd12:	4619      	mov	r1, r3
 800bd14:	4823      	ldr	r0, [pc, #140]	; (800bda4 <LOS_MuxPost+0x178>)
 800bd16:	f7ff fab7 	bl	800b288 <LOS_SpinUnlockRestore>
        OS_RETURN_ERROR(LOS_ERRNO_MUX_INVALID);
 800bd1a:	2300      	movs	r3, #0
 800bd1c:	9300      	str	r3, [sp, #0]
 800bd1e:	2300      	movs	r3, #0
 800bd20:	4a1c      	ldr	r2, [pc, #112]	; (800bd94 <LOS_MuxPost+0x168>)
 800bd22:	491d      	ldr	r1, [pc, #116]	; (800bd98 <LOS_MuxPost+0x16c>)
 800bd24:	481d      	ldr	r0, [pc, #116]	; (800bd9c <LOS_MuxPost+0x170>)
 800bd26:	f7fe f971 	bl	800a00c <LOS_ErrHandle>
 800bd2a:	4b1a      	ldr	r3, [pc, #104]	; (800bd94 <LOS_MuxPost+0x168>)
 800bd2c:	e023      	b.n	800bd76 <LOS_MuxPost+0x14a>
    }

    if (--muxPosted->muxCount != 0) {
 800bd2e:	693b      	ldr	r3, [r7, #16]
 800bd30:	899b      	ldrh	r3, [r3, #12]
 800bd32:	3b01      	subs	r3, #1
 800bd34:	b29a      	uxth	r2, r3
 800bd36:	693b      	ldr	r3, [r7, #16]
 800bd38:	819a      	strh	r2, [r3, #12]
 800bd3a:	693b      	ldr	r3, [r7, #16]
 800bd3c:	899b      	ldrh	r3, [r3, #12]
 800bd3e:	2b00      	cmp	r3, #0
 800bd40:	d006      	beq.n	800bd50 <LOS_MuxPost+0x124>
        SCHEDULER_UNLOCK(intSave);
 800bd42:	68bb      	ldr	r3, [r7, #8]
 800bd44:	4619      	mov	r1, r3
 800bd46:	4817      	ldr	r0, [pc, #92]	; (800bda4 <LOS_MuxPost+0x178>)
 800bd48:	f7ff fa9e 	bl	800b288 <LOS_SpinUnlockRestore>
        return LOS_OK;
 800bd4c:	2300      	movs	r3, #0
 800bd4e:	e012      	b.n	800bd76 <LOS_MuxPost+0x14a>
    }

    ret = OsMuxPostOp(runTask, (MuxBaseCB *)muxPosted);
 800bd50:	6939      	ldr	r1, [r7, #16]
 800bd52:	68f8      	ldr	r0, [r7, #12]
 800bd54:	f7ff ff0b 	bl	800bb6e <OsMuxPostOp>
 800bd58:	61b8      	str	r0, [r7, #24]
    SCHEDULER_UNLOCK(intSave);
 800bd5a:	68bb      	ldr	r3, [r7, #8]
 800bd5c:	4619      	mov	r1, r3
 800bd5e:	4811      	ldr	r0, [pc, #68]	; (800bda4 <LOS_MuxPost+0x178>)
 800bd60:	f7ff fa92 	bl	800b288 <LOS_SpinUnlockRestore>
    if (ret == MUX_SCHEDULE) {
 800bd64:	69bb      	ldr	r3, [r7, #24]
 800bd66:	2b01      	cmp	r3, #1
 800bd68:	d104      	bne.n	800bd74 <LOS_MuxPost+0x148>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 800bd6a:	2001      	movs	r0, #1
 800bd6c:	f7ff fade 	bl	800b32c <LOS_MpSchedule>
        LOS_Schedule();
 800bd70:	f7ff fa6c 	bl	800b24c <LOS_Schedule>
    }

    return LOS_OK;
 800bd74:	2300      	movs	r3, #0
}
 800bd76:	4a05      	ldr	r2, [pc, #20]	; (800bd8c <LOS_MuxPost+0x160>)
 800bd78:	6811      	ldr	r1, [r2, #0]
 800bd7a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bd7c:	4051      	eors	r1, r2
 800bd7e:	d001      	beq.n	800bd84 <LOS_MuxPost+0x158>
 800bd80:	f7f8 fc2c 	bl	80045dc <__stack_chk_fail>
 800bd84:	4618      	mov	r0, r3
 800bd86:	3734      	adds	r7, #52	; 0x34
 800bd88:	46bd      	mov	sp, r7
 800bd8a:	bd90      	pop	{r4, r7, pc}
 800bd8c:	080215f4 	.word	0x080215f4
 800bd90:	200021d0 	.word	0x200021d0
 800bd94:	02001d01 	.word	0x02001d01
 800bd98:	a1b2c3f8 	.word	0xa1b2c3f8
 800bd9c:	080215a8 	.word	0x080215a8
 800bda0:	20000768 	.word	0x20000768
 800bda4:	20000770 	.word	0x20000770

0800bda8 <LOS_BitmapSet>:
#endif /* __cplusplus */

#define OS_BITMAP_MASK 0x1FU

VOID LOS_BitmapSet(UINT32 *bitmap, UINT16 pos)
{
 800bda8:	b480      	push	{r7}
 800bdaa:	b083      	sub	sp, #12
 800bdac:	af00      	add	r7, sp, #0
 800bdae:	6078      	str	r0, [r7, #4]
 800bdb0:	460b      	mov	r3, r1
 800bdb2:	807b      	strh	r3, [r7, #2]
    if (bitmap == NULL) {
 800bdb4:	687b      	ldr	r3, [r7, #4]
 800bdb6:	2b00      	cmp	r3, #0
 800bdb8:	d00b      	beq.n	800bdd2 <LOS_BitmapSet+0x2a>
        return;
    }

    *bitmap |= 1U << (pos & OS_BITMAP_MASK);
 800bdba:	687b      	ldr	r3, [r7, #4]
 800bdbc:	681a      	ldr	r2, [r3, #0]
 800bdbe:	887b      	ldrh	r3, [r7, #2]
 800bdc0:	f003 031f 	and.w	r3, r3, #31
 800bdc4:	2101      	movs	r1, #1
 800bdc6:	fa01 f303 	lsl.w	r3, r1, r3
 800bdca:	431a      	orrs	r2, r3
 800bdcc:	687b      	ldr	r3, [r7, #4]
 800bdce:	601a      	str	r2, [r3, #0]
 800bdd0:	e000      	b.n	800bdd4 <LOS_BitmapSet+0x2c>
        return;
 800bdd2:	bf00      	nop
}
 800bdd4:	370c      	adds	r7, #12
 800bdd6:	46bd      	mov	sp, r7
 800bdd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bddc:	4770      	bx	lr

0800bdde <LOS_BitmapClr>:

VOID LOS_BitmapClr(UINT32 *bitmap, UINT16 pos)
{
 800bdde:	b480      	push	{r7}
 800bde0:	b083      	sub	sp, #12
 800bde2:	af00      	add	r7, sp, #0
 800bde4:	6078      	str	r0, [r7, #4]
 800bde6:	460b      	mov	r3, r1
 800bde8:	807b      	strh	r3, [r7, #2]
    if (bitmap == NULL) {
 800bdea:	687b      	ldr	r3, [r7, #4]
 800bdec:	2b00      	cmp	r3, #0
 800bdee:	d00c      	beq.n	800be0a <LOS_BitmapClr+0x2c>
        return;
    }

    *bitmap &= ~(1U << (pos & OS_BITMAP_MASK));
 800bdf0:	687b      	ldr	r3, [r7, #4]
 800bdf2:	681a      	ldr	r2, [r3, #0]
 800bdf4:	887b      	ldrh	r3, [r7, #2]
 800bdf6:	f003 031f 	and.w	r3, r3, #31
 800bdfa:	2101      	movs	r1, #1
 800bdfc:	fa01 f303 	lsl.w	r3, r1, r3
 800be00:	43db      	mvns	r3, r3
 800be02:	401a      	ands	r2, r3
 800be04:	687b      	ldr	r3, [r7, #4]
 800be06:	601a      	str	r2, [r3, #0]
 800be08:	e000      	b.n	800be0c <LOS_BitmapClr+0x2e>
        return;
 800be0a:	bf00      	nop
}
 800be0c:	370c      	adds	r7, #12
 800be0e:	46bd      	mov	sp, r7
 800be10:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be14:	4770      	bx	lr

0800be16 <LOS_HighBitGet>:

UINT16 LOS_HighBitGet(UINT32 bitmap)
{
 800be16:	b480      	push	{r7}
 800be18:	b083      	sub	sp, #12
 800be1a:	af00      	add	r7, sp, #0
 800be1c:	6078      	str	r0, [r7, #4]
    if (bitmap == 0) {
 800be1e:	687b      	ldr	r3, [r7, #4]
 800be20:	2b00      	cmp	r3, #0
 800be22:	d101      	bne.n	800be28 <LOS_HighBitGet+0x12>
        return LOS_INVALID_BIT_INDEX;
 800be24:	2320      	movs	r3, #32
 800be26:	e006      	b.n	800be36 <LOS_HighBitGet+0x20>
    }

    return (OS_BITMAP_MASK - CLZ(bitmap));
 800be28:	687b      	ldr	r3, [r7, #4]
 800be2a:	fab3 f383 	clz	r3, r3
 800be2e:	b29b      	uxth	r3, r3
 800be30:	f1c3 031f 	rsb	r3, r3, #31
 800be34:	b29b      	uxth	r3, r3
}
 800be36:	4618      	mov	r0, r3
 800be38:	370c      	adds	r7, #12
 800be3a:	46bd      	mov	sp, r7
 800be3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be40:	4770      	bx	lr

0800be42 <LOS_LowBitGet>:

UINT16 LOS_LowBitGet(UINT32 bitmap)
{
 800be42:	b480      	push	{r7}
 800be44:	b083      	sub	sp, #12
 800be46:	af00      	add	r7, sp, #0
 800be48:	6078      	str	r0, [r7, #4]
    if (bitmap == 0) {
 800be4a:	687b      	ldr	r3, [r7, #4]
 800be4c:	2b00      	cmp	r3, #0
 800be4e:	d101      	bne.n	800be54 <LOS_LowBitGet+0x12>
        return LOS_INVALID_BIT_INDEX;
 800be50:	2320      	movs	r3, #32
 800be52:	e005      	b.n	800be60 <LOS_LowBitGet+0x1e>
    }

    return CTZ(bitmap);
 800be54:	687b      	ldr	r3, [r7, #4]
 800be56:	fa93 f3a3 	rbit	r3, r3
 800be5a:	fab3 f383 	clz	r3, r3
 800be5e:	b29b      	uxth	r3, r3
}
 800be60:	4618      	mov	r0, r3
 800be62:	370c      	adds	r7, #12
 800be64:	46bd      	mov	sp, r7
 800be66:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be6a:	4770      	bx	lr

0800be6c <ArchCurrCpuid>:
{
 800be6c:	b480      	push	{r7}
 800be6e:	af00      	add	r7, sp, #0
    return 0;
 800be70:	2300      	movs	r3, #0
}
 800be72:	4618      	mov	r0, r3
 800be74:	46bd      	mov	sp, r7
 800be76:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be7a:	4770      	bx	lr

0800be7c <LOS_SpinLock>:
{
 800be7c:	b480      	push	{r7}
 800be7e:	b083      	sub	sp, #12
 800be80:	af00      	add	r7, sp, #0
 800be82:	6078      	str	r0, [r7, #4]
}
 800be84:	bf00      	nop
 800be86:	370c      	adds	r7, #12
 800be88:	46bd      	mov	sp, r7
 800be8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be8e:	4770      	bx	lr

0800be90 <OsGetMainTask>:

/* temp task blocks for booting procedure */
LITE_OS_SEC_BSS STATIC LosTaskCB                g_mainTask[LOSCFG_KERNEL_CORE_NUM];

VOID *OsGetMainTask()
{
 800be90:	b580      	push	{r7, lr}
 800be92:	af00      	add	r7, sp, #0
    return (g_mainTask + ArchCurrCpuid());
 800be94:	f7ff ffea 	bl	800be6c <ArchCurrCpuid>
 800be98:	4602      	mov	r2, r0
 800be9a:	4613      	mov	r3, r2
 800be9c:	009b      	lsls	r3, r3, #2
 800be9e:	4413      	add	r3, r2
 800bea0:	015b      	lsls	r3, r3, #5
 800bea2:	461a      	mov	r2, r3
 800bea4:	4b01      	ldr	r3, [pc, #4]	; (800beac <OsGetMainTask+0x1c>)
 800bea6:	4413      	add	r3, r2
}
 800bea8:	4618      	mov	r0, r3
 800beaa:	bd80      	pop	{r7, pc}
 800beac:	200021e0 	.word	0x200021e0

0800beb0 <OsSetMainTask>:

VOID OsSetMainTask()
{
 800beb0:	b480      	push	{r7}
 800beb2:	b083      	sub	sp, #12
 800beb4:	af00      	add	r7, sp, #0
    UINT32 i;
    for (i = 0; i < LOSCFG_KERNEL_CORE_NUM; i++) {
 800beb6:	2300      	movs	r3, #0
 800beb8:	607b      	str	r3, [r7, #4]
 800beba:	e02a      	b.n	800bf12 <OsSetMainTask+0x62>
        g_mainTask[i].taskStatus = OS_TASK_STATUS_UNUSED;
 800bebc:	491a      	ldr	r1, [pc, #104]	; (800bf28 <OsSetMainTask+0x78>)
 800bebe:	687a      	ldr	r2, [r7, #4]
 800bec0:	4613      	mov	r3, r2
 800bec2:	009b      	lsls	r3, r3, #2
 800bec4:	4413      	add	r3, r2
 800bec6:	015b      	lsls	r3, r3, #5
 800bec8:	440b      	add	r3, r1
 800beca:	3304      	adds	r3, #4
 800becc:	2201      	movs	r2, #1
 800bece:	801a      	strh	r2, [r3, #0]
        g_mainTask[i].taskId = LOSCFG_BASE_CORE_TSK_LIMIT;
 800bed0:	4915      	ldr	r1, [pc, #84]	; (800bf28 <OsSetMainTask+0x78>)
 800bed2:	687a      	ldr	r2, [r7, #4]
 800bed4:	4613      	mov	r3, r2
 800bed6:	009b      	lsls	r3, r3, #2
 800bed8:	4413      	add	r3, r2
 800beda:	015b      	lsls	r3, r3, #5
 800bedc:	440b      	add	r3, r1
 800bede:	3314      	adds	r3, #20
 800bee0:	2210      	movs	r2, #16
 800bee2:	601a      	str	r2, [r3, #0]
        g_mainTask[i].priority = OS_TASK_PRIORITY_LOWEST + 1;
 800bee4:	4910      	ldr	r1, [pc, #64]	; (800bf28 <OsSetMainTask+0x78>)
 800bee6:	687a      	ldr	r2, [r7, #4]
 800bee8:	4613      	mov	r3, r2
 800beea:	009b      	lsls	r3, r3, #2
 800beec:	4413      	add	r3, r2
 800beee:	015b      	lsls	r3, r3, #5
 800bef0:	440b      	add	r3, r1
 800bef2:	3306      	adds	r3, #6
 800bef4:	2220      	movs	r2, #32
 800bef6:	801a      	strh	r2, [r3, #0]
        g_mainTask[i].taskName = "osMain";
 800bef8:	490b      	ldr	r1, [pc, #44]	; (800bf28 <OsSetMainTask+0x78>)
 800befa:	687a      	ldr	r2, [r7, #4]
 800befc:	4613      	mov	r3, r2
 800befe:	009b      	lsls	r3, r3, #2
 800bf00:	4413      	add	r3, r2
 800bf02:	015b      	lsls	r3, r3, #5
 800bf04:	440b      	add	r3, r1
 800bf06:	333c      	adds	r3, #60	; 0x3c
 800bf08:	4a08      	ldr	r2, [pc, #32]	; (800bf2c <OsSetMainTask+0x7c>)
 800bf0a:	601a      	str	r2, [r3, #0]
    for (i = 0; i < LOSCFG_KERNEL_CORE_NUM; i++) {
 800bf0c:	687b      	ldr	r3, [r7, #4]
 800bf0e:	3301      	adds	r3, #1
 800bf10:	607b      	str	r3, [r7, #4]
 800bf12:	687b      	ldr	r3, [r7, #4]
 800bf14:	2b00      	cmp	r3, #0
 800bf16:	d0d1      	beq.n	800bebc <OsSetMainTask+0xc>
#ifdef LOSCFG_KERNEL_SMP_LOCKDEP
        g_mainTask[i].lockDep.lockDepth = 0;
        g_mainTask[i].lockDep.waitLock = NULL;
#endif
    }
}
 800bf18:	bf00      	nop
 800bf1a:	bf00      	nop
 800bf1c:	370c      	adds	r7, #12
 800bf1e:	46bd      	mov	sp, r7
 800bf20:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf24:	4770      	bx	lr
 800bf26:	bf00      	nop
 800bf28:	200021e0 	.word	0x200021e0
 800bf2c:	080215f8 	.word	0x080215f8

0800bf30 <OsRegister>:

LITE_OS_SEC_TEXT_INIT STATIC VOID OsRegister(VOID)
{
 800bf30:	b480      	push	{r7}
 800bf32:	af00      	add	r7, sp, #0
    g_queueLimit            = LOSCFG_BASE_IPC_QUEUE_LIMIT;
#ifdef LOSCFG_BASE_CORE_TIMESLICE
    g_timeSliceTimeOut      = LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT;
#endif
#endif
    g_tickPerSecond         = LOSCFG_BASE_CORE_TICK_PER_SECOND;
 800bf34:	4b06      	ldr	r3, [pc, #24]	; (800bf50 <OsRegister+0x20>)
 800bf36:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800bf3a:	601a      	str	r2, [r3, #0]
    SET_SYS_CLOCK(OS_SYS_CLOCK);
 800bf3c:	4b05      	ldr	r3, [pc, #20]	; (800bf54 <OsRegister+0x24>)
 800bf3e:	681b      	ldr	r3, [r3, #0]
 800bf40:	4a05      	ldr	r2, [pc, #20]	; (800bf58 <OsRegister+0x28>)
 800bf42:	6013      	str	r3, [r2, #0]
    LOS_SET_NX_CFG(false);
#endif
    LOS_SET_DL_NX_HEAP_BASE(LOS_DL_HEAP_BASE);
    LOS_SET_DL_NX_HEAP_SIZE(LOS_DL_HEAP_SIZE);

    return;
 800bf44:	bf00      	nop
}
 800bf46:	46bd      	mov	sp, r7
 800bf48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf4c:	4770      	bx	lr
 800bf4e:	bf00      	nop
 800bf50:	200036e4 	.word	0x200036e4
 800bf54:	20000404 	.word	0x20000404
 800bf58:	200036e0 	.word	0x200036e0

0800bf5c <OsStart>:

LITE_OS_SEC_TEXT_INIT VOID OsStart(VOID)
{
 800bf5c:	b580      	push	{r7, lr}
 800bf5e:	b082      	sub	sp, #8
 800bf60:	af00      	add	r7, sp, #0
    LosTaskCB *taskCB = NULL;
 800bf62:	2300      	movs	r3, #0
 800bf64:	603b      	str	r3, [r7, #0]
    UINT32 cpuid = ArchCurrCpuid();
 800bf66:	f7ff ff81 	bl	800be6c <ArchCurrCpuid>
 800bf6a:	6078      	str	r0, [r7, #4]

    OsTickStart();
 800bf6c:	f7f8 f9f8 	bl	8004360 <OsTickStart>

    LOS_SpinLock(&g_taskSpin);
 800bf70:	480d      	ldr	r0, [pc, #52]	; (800bfa8 <OsStart+0x4c>)
 800bf72:	f7ff ff83 	bl	800be7c <LOS_SpinLock>
    taskCB = OsGetTopTask();
 800bf76:	f7fd f909 	bl	800918c <OsGetTopTask>
 800bf7a:	6038      	str	r0, [r7, #0]
     * attention: current cpu needs to be set, in case first task deletion
     * may fail because this flag mismatch with the real current cpu.
     */
    taskCB->currCpu = (UINT16)cpuid;
#endif
    OS_SCHEDULER_SET(cpuid);
 800bf7c:	2201      	movs	r2, #1
 800bf7e:	687b      	ldr	r3, [r7, #4]
 800bf80:	409a      	lsls	r2, r3
 800bf82:	4b0a      	ldr	r3, [pc, #40]	; (800bfac <OsStart+0x50>)
 800bf84:	681b      	ldr	r3, [r3, #0]
 800bf86:	4313      	orrs	r3, r2
 800bf88:	4a08      	ldr	r2, [pc, #32]	; (800bfac <OsStart+0x50>)
 800bf8a:	6013      	str	r3, [r2, #0]

    PRINTK("cpu %u entering scheduler\n", cpuid);
 800bf8c:	6879      	ldr	r1, [r7, #4]
 800bf8e:	4808      	ldr	r0, [pc, #32]	; (800bfb0 <OsStart+0x54>)
 800bf90:	f7f8 fc96 	bl	80048c0 <dprintf>

    taskCB->taskStatus = OS_TASK_STATUS_RUNNING;
 800bf94:	683b      	ldr	r3, [r7, #0]
 800bf96:	2210      	movs	r2, #16
 800bf98:	809a      	strh	r2, [r3, #4]

    OsStartToRun(taskCB);
 800bf9a:	6838      	ldr	r0, [r7, #0]
 800bf9c:	f7f4 fe76 	bl	8000c8c <OsStartToRun>
}
 800bfa0:	bf00      	nop
 800bfa2:	3708      	adds	r7, #8
 800bfa4:	46bd      	mov	sp, r7
 800bfa6:	bd80      	pop	{r7, pc}
 800bfa8:	20000770 	.word	0x20000770
 800bfac:	200036dc 	.word	0x200036dc
 800bfb0:	08021600 	.word	0x08021600

0800bfb4 <OsIpcInit>:

LITE_OS_SEC_TEXT_INIT STATIC UINT32 OsIpcInit(VOID)
{
 800bfb4:	b580      	push	{r7, lr}
 800bfb6:	b082      	sub	sp, #8
 800bfb8:	af00      	add	r7, sp, #0
    UINT32 ret = LOS_OK;
 800bfba:	2300      	movs	r3, #0
 800bfbc:	607b      	str	r3, [r7, #4]
#ifdef LOSCFG_BASE_IPC_SEM
    ret = OsSemInit();
 800bfbe:	f7f9 f9d1 	bl	8005364 <OsSemInit>
 800bfc2:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800bfc4:	687b      	ldr	r3, [r7, #4]
 800bfc6:	2b00      	cmp	r3, #0
 800bfc8:	d007      	beq.n	800bfda <OsIpcInit+0x26>
        PRINT_ERR("Sem init err.\n");
 800bfca:	4814      	ldr	r0, [pc, #80]	; (800c01c <OsIpcInit+0x68>)
 800bfcc:	f7f8 fc78 	bl	80048c0 <dprintf>
 800bfd0:	4813      	ldr	r0, [pc, #76]	; (800c020 <OsIpcInit+0x6c>)
 800bfd2:	f7f8 fc75 	bl	80048c0 <dprintf>
        return ret;
 800bfd6:	687b      	ldr	r3, [r7, #4]
 800bfd8:	e01c      	b.n	800c014 <OsIpcInit+0x60>
    }
#endif

#ifdef LOSCFG_BASE_IPC_MUX
    ret = OsMuxInit();
 800bfda:	f7ff f9b1 	bl	800b340 <OsMuxInit>
 800bfde:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800bfe0:	687b      	ldr	r3, [r7, #4]
 800bfe2:	2b00      	cmp	r3, #0
 800bfe4:	d007      	beq.n	800bff6 <OsIpcInit+0x42>
        PRINT_ERR("Mux init err.\n");
 800bfe6:	480d      	ldr	r0, [pc, #52]	; (800c01c <OsIpcInit+0x68>)
 800bfe8:	f7f8 fc6a 	bl	80048c0 <dprintf>
 800bfec:	480d      	ldr	r0, [pc, #52]	; (800c024 <OsIpcInit+0x70>)
 800bfee:	f7f8 fc67 	bl	80048c0 <dprintf>
        return ret;
 800bff2:	687b      	ldr	r3, [r7, #4]
 800bff4:	e00e      	b.n	800c014 <OsIpcInit+0x60>
    }
#endif

#ifdef LOSCFG_BASE_IPC_QUEUE
    ret = OsQueueInit();
 800bff6:	f7fe fbe5 	bl	800a7c4 <OsQueueInit>
 800bffa:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800bffc:	687b      	ldr	r3, [r7, #4]
 800bffe:	2b00      	cmp	r3, #0
 800c000:	d007      	beq.n	800c012 <OsIpcInit+0x5e>
        PRINT_ERR("Que init err.\n");
 800c002:	4806      	ldr	r0, [pc, #24]	; (800c01c <OsIpcInit+0x68>)
 800c004:	f7f8 fc5c 	bl	80048c0 <dprintf>
 800c008:	4807      	ldr	r0, [pc, #28]	; (800c028 <OsIpcInit+0x74>)
 800c00a:	f7f8 fc59 	bl	80048c0 <dprintf>
        return ret;
 800c00e:	687b      	ldr	r3, [r7, #4]
 800c010:	e000      	b.n	800c014 <OsIpcInit+0x60>
    }
#endif
    return ret;
 800c012:	687b      	ldr	r3, [r7, #4]
}
 800c014:	4618      	mov	r0, r3
 800c016:	3708      	adds	r7, #8
 800c018:	46bd      	mov	sp, r7
 800c01a:	bd80      	pop	{r7, pc}
 800c01c:	0802161c 	.word	0x0802161c
 800c020:	08021624 	.word	0x08021624
 800c024:	08021634 	.word	0x08021634
 800c028:	08021644 	.word	0x08021644

0800c02c <OsAppTaskCreate>:

#ifdef LOSCFG_PLATFORM_OSAPPINIT
STATIC UINT32 OsAppTaskCreate(VOID)
{
 800c02c:	b580      	push	{r7, lr}
 800c02e:	b08c      	sub	sp, #48	; 0x30
 800c030:	af00      	add	r7, sp, #0
 800c032:	4b15      	ldr	r3, [pc, #84]	; (800c088 <OsAppTaskCreate+0x5c>)
 800c034:	681b      	ldr	r3, [r3, #0]
 800c036:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c038:	f04f 0300 	mov.w	r3, #0
    UINT32 taskId;
    TSK_INIT_PARAM_S appTask;

    (VOID)memset_s(&appTask, sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
 800c03c:	f107 0008 	add.w	r0, r7, #8
 800c040:	2324      	movs	r3, #36	; 0x24
 800c042:	2200      	movs	r2, #0
 800c044:	2124      	movs	r1, #36	; 0x24
 800c046:	f7f6 f82d 	bl	80020a4 <memset_s>
    appTask.pfnTaskEntry = (TSK_ENTRY_FUNC)app_init;
 800c04a:	4b10      	ldr	r3, [pc, #64]	; (800c08c <OsAppTaskCreate+0x60>)
 800c04c:	60bb      	str	r3, [r7, #8]
    appTask.uwStackSize = LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE;
 800c04e:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800c052:	623b      	str	r3, [r7, #32]
    appTask.pcName = "app_Task";
 800c054:	4b0e      	ldr	r3, [pc, #56]	; (800c090 <OsAppTaskCreate+0x64>)
 800c056:	627b      	str	r3, [r7, #36]	; 0x24
    appTask.usTaskPrio = LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO;
 800c058:	230a      	movs	r3, #10
 800c05a:	81bb      	strh	r3, [r7, #12]
    appTask.uwResved = LOS_TASK_STATUS_DETACHED;
 800c05c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c060:	62bb      	str	r3, [r7, #40]	; 0x28
#ifdef LOSCFG_KERNEL_SMP
    appTask.usCpuAffiMask = CPUID_TO_AFFI_MASK(ArchCurrCpuid());
#endif
    return LOS_TaskCreate(&taskId, &appTask);
 800c062:	f107 0208 	add.w	r2, r7, #8
 800c066:	1d3b      	adds	r3, r7, #4
 800c068:	4611      	mov	r1, r2
 800c06a:	4618      	mov	r0, r3
 800c06c:	f7f7 fd5e 	bl	8003b2c <LOS_TaskCreate>
 800c070:	4603      	mov	r3, r0
}
 800c072:	4a05      	ldr	r2, [pc, #20]	; (800c088 <OsAppTaskCreate+0x5c>)
 800c074:	6811      	ldr	r1, [r2, #0]
 800c076:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c078:	4051      	eors	r1, r2
 800c07a:	d001      	beq.n	800c080 <OsAppTaskCreate+0x54>
 800c07c:	f7f8 faae 	bl	80045dc <__stack_chk_fail>
 800c080:	4618      	mov	r0, r3
 800c082:	3730      	adds	r7, #48	; 0x30
 800c084:	46bd      	mov	sp, r7
 800c086:	bd80      	pop	{r7, pc}
 800c088:	08021660 	.word	0x08021660
 800c08c:	08002039 	.word	0x08002039
 800c090:	08021654 	.word	0x08021654

0800c094 <OsAppInit>:

UINT32 OsAppInit(VOID)
{
 800c094:	b580      	push	{r7, lr}
 800c096:	b082      	sub	sp, #8
 800c098:	af00      	add	r7, sp, #0
    g_pstSystemWq = create_workqueue("system_wq");
#endif

#endif

    ret = OsAppTaskCreate();
 800c09a:	f7ff ffc7 	bl	800c02c <OsAppTaskCreate>
 800c09e:	6078      	str	r0, [r7, #4]
    PRINTK("OsAppInit\n");
 800c0a0:	4807      	ldr	r0, [pc, #28]	; (800c0c0 <OsAppInit+0x2c>)
 800c0a2:	f7f8 fc0d 	bl	80048c0 <dprintf>
    if (ret != LOS_OK) {
 800c0a6:	687b      	ldr	r3, [r7, #4]
 800c0a8:	2b00      	cmp	r3, #0
 800c0aa:	d001      	beq.n	800c0b0 <OsAppInit+0x1c>
        return ret;
 800c0ac:	687b      	ldr	r3, [r7, #4]
 800c0ae:	e002      	b.n	800c0b6 <OsAppInit+0x22>
    }

#ifdef LOSCFG_KERNEL_TICKLESS
    LOS_TicklessEnable();
 800c0b0:	f008 f844 	bl	801413c <LOS_TicklessEnable>
#endif
    return 0;
 800c0b4:	2300      	movs	r3, #0
}
 800c0b6:	4618      	mov	r0, r3
 800c0b8:	3708      	adds	r7, #8
 800c0ba:	46bd      	mov	sp, r7
 800c0bc:	bd80      	pop	{r7, pc}
 800c0be:	bf00      	nop
 800c0c0:	08021664 	.word	0x08021664

0800c0c4 <OsMain>:
#endif /* LOSCFG_PLATFORM_OSAPPINIT */

LITE_OS_SEC_TEXT_INIT UINT32 OsMain(VOID)
{
 800c0c4:	b580      	push	{r7, lr}
 800c0c6:	b082      	sub	sp, #8
 800c0c8:	af00      	add	r7, sp, #0

#ifdef LOSCFG_KERNEL_LMS
    OsLmsInit();
#endif

    ret = OsMemSystemInit((UINTPTR)OS_SYS_MEM_ADDR);
 800c0ca:	4b4c      	ldr	r3, [pc, #304]	; (800c1fc <OsMain+0x138>)
 800c0cc:	681b      	ldr	r3, [r3, #0]
 800c0ce:	4618      	mov	r0, r3
 800c0d0:	f7fd f97a 	bl	80093c8 <OsMemSystemInit>
 800c0d4:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800c0d6:	687b      	ldr	r3, [r7, #4]
 800c0d8:	2b00      	cmp	r3, #0
 800c0da:	d007      	beq.n	800c0ec <OsMain+0x28>
        PRINT_ERR("Mem init err.\n");
 800c0dc:	4848      	ldr	r0, [pc, #288]	; (800c200 <OsMain+0x13c>)
 800c0de:	f7f8 fbef 	bl	80048c0 <dprintf>
 800c0e2:	4848      	ldr	r0, [pc, #288]	; (800c204 <OsMain+0x140>)
 800c0e4:	f7f8 fbec 	bl	80048c0 <dprintf>
        return ret;
 800c0e8:	687b      	ldr	r3, [r7, #4]
 800c0ea:	e083      	b.n	800c1f4 <OsMain+0x130>
    }

    OsRegister();
 800c0ec:	f7ff ff20 	bl	800bf30 <OsRegister>
#ifdef LOSCFG_SHELL_LK
    OsLkLoggerInit(NULL);
#endif

#ifdef LOSCFG_SHELL_DMESG
    ret = OsDmesgInit();
 800c0f0:	f004 ff8e 	bl	8011010 <OsDmesgInit>
 800c0f4:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800c0f6:	687b      	ldr	r3, [r7, #4]
 800c0f8:	2b00      	cmp	r3, #0
 800c0fa:	d001      	beq.n	800c100 <OsMain+0x3c>
        return ret;
 800c0fc:	687b      	ldr	r3, [r7, #4]
 800c0fe:	e079      	b.n	800c1f4 <OsMain+0x130>
    }
#endif

    OsHwiInit();
 800c100:	f7f6 fbd4 	bl	80028ac <OsHwiInit>

    ArchExcInit();
 800c104:	f00a fd3c 	bl	8016b80 <ArchExcInit>

#if defined(LOSCFG_KERNEL_TICKLESS) && !defined(LOSCFG_KERNEL_POWER_MGR)
    OsLowpowerInit(NULL);
 800c108:	2000      	movs	r0, #0
 800c10a:	f004 fb5d 	bl	80107c8 <OsLowpowerInit>
#endif

    ret = OsTickInit(GET_SYS_CLOCK(), LOSCFG_BASE_CORE_TICK_PER_SECOND);
 800c10e:	4b3e      	ldr	r3, [pc, #248]	; (800c208 <OsMain+0x144>)
 800c110:	681b      	ldr	r3, [r3, #0]
 800c112:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800c116:	4618      	mov	r0, r3
 800c118:	f7f8 f908 	bl	800432c <OsTickInit>
 800c11c:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800c11e:	687b      	ldr	r3, [r7, #4]
 800c120:	2b00      	cmp	r3, #0
 800c122:	d007      	beq.n	800c134 <OsMain+0x70>
        PRINT_ERR("Tick init err.\n");
 800c124:	4836      	ldr	r0, [pc, #216]	; (800c200 <OsMain+0x13c>)
 800c126:	f7f8 fbcb 	bl	80048c0 <dprintf>
 800c12a:	4838      	ldr	r0, [pc, #224]	; (800c20c <OsMain+0x148>)
 800c12c:	f7f8 fbc8 	bl	80048c0 <dprintf>
        return ret;
 800c130:	687b      	ldr	r3, [r7, #4]
 800c132:	e05f      	b.n	800c1f4 <OsMain+0x130>
    }

#if defined(LOSCFG_DRIVERS_UART) || defined(LOSCFG_DRIVERS_SIMPLE_UART)
    uart_init();
 800c134:	f004 fc9a 	bl	8010a6c <uart_init>
#ifdef LOSCFG_SHELL
    uart_hwiCreate();
 800c138:	f004 fc10 	bl	801095c <uart_hwiCreate>
#endif /* LOSCFG_SHELL */
#endif /* LOSCFG_DRIVERS_SIMPLE_UART */

    ret = OsTaskInit();
 800c13c:	f7f6 ff6c 	bl	8003018 <OsTaskInit>
 800c140:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800c142:	687b      	ldr	r3, [r7, #4]
 800c144:	2b00      	cmp	r3, #0
 800c146:	d007      	beq.n	800c158 <OsMain+0x94>
        PRINT_ERR("Task init err.\n");
 800c148:	482d      	ldr	r0, [pc, #180]	; (800c200 <OsMain+0x13c>)
 800c14a:	f7f8 fbb9 	bl	80048c0 <dprintf>
 800c14e:	4830      	ldr	r0, [pc, #192]	; (800c210 <OsMain+0x14c>)
 800c150:	f7f8 fbb6 	bl	80048c0 <dprintf>
        return ret;
 800c154:	687b      	ldr	r3, [r7, #4]
 800c156:	e04d      	b.n	800c1f4 <OsMain+0x130>
    }

#ifdef LOSCFG_KERNEL_TRACE
    ret = LOS_TraceInit(NULL, LOS_TRACE_BUFFER_SIZE);
 800c158:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800c15c:	2000      	movs	r0, #0
 800c15e:	f009 fb1d 	bl	801579c <LOS_TraceInit>
 800c162:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800c164:	687b      	ldr	r3, [r7, #4]
 800c166:	2b00      	cmp	r3, #0
 800c168:	d007      	beq.n	800c17a <OsMain+0xb6>
        PRINT_ERR("Trace init err.\n");
 800c16a:	4825      	ldr	r0, [pc, #148]	; (800c200 <OsMain+0x13c>)
 800c16c:	f7f8 fba8 	bl	80048c0 <dprintf>
 800c170:	4828      	ldr	r0, [pc, #160]	; (800c214 <OsMain+0x150>)
 800c172:	f7f8 fba5 	bl	80048c0 <dprintf>
        return ret;
 800c176:	687b      	ldr	r3, [r7, #4]
 800c178:	e03c      	b.n	800c1f4 <OsMain+0x130>
    }
#endif

#ifdef LOSCFG_BASE_CORE_TSK_MONITOR
    OsTaskMonInit();
 800c17a:	f7f7 f891 	bl	80032a0 <OsTaskMonInit>
#endif

    ret = OsIpcInit();
 800c17e:	f7ff ff19 	bl	800bfb4 <OsIpcInit>
 800c182:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800c184:	687b      	ldr	r3, [r7, #4]
 800c186:	2b00      	cmp	r3, #0
 800c188:	d001      	beq.n	800c18e <OsMain+0xca>
        return ret;
 800c18a:	687b      	ldr	r3, [r7, #4]
 800c18c:	e032      	b.n	800c1f4 <OsMain+0x130>
     * 1. OsIpcInit
     * 2. OsCpupInit -> has first task creation
     * 3. other inits have task creation
     */
#ifdef LOSCFG_KERNEL_CPUP
    ret = OsCpupInit();
 800c18e:	f008 fabb 	bl	8014708 <OsCpupInit>
 800c192:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800c194:	687b      	ldr	r3, [r7, #4]
 800c196:	2b00      	cmp	r3, #0
 800c198:	d007      	beq.n	800c1aa <OsMain+0xe6>
        PRINT_ERR("Cpup init err.\n");
 800c19a:	4819      	ldr	r0, [pc, #100]	; (800c200 <OsMain+0x13c>)
 800c19c:	f7f8 fb90 	bl	80048c0 <dprintf>
 800c1a0:	481d      	ldr	r0, [pc, #116]	; (800c218 <OsMain+0x154>)
 800c1a2:	f7f8 fb8d 	bl	80048c0 <dprintf>
        return ret;
 800c1a6:	687b      	ldr	r3, [r7, #4]
 800c1a8:	e024      	b.n	800c1f4 <OsMain+0x130>
    }
#endif

#ifdef LOSCFG_BASE_CORE_SWTMR
    ret = OsSwtmrInit();
 800c1aa:	f7f9 fbc3 	bl	8005934 <OsSwtmrInit>
 800c1ae:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800c1b0:	687b      	ldr	r3, [r7, #4]
 800c1b2:	2b00      	cmp	r3, #0
 800c1b4:	d007      	beq.n	800c1c6 <OsMain+0x102>
        PRINT_ERR("Swtmr init err.\n");
 800c1b6:	4812      	ldr	r0, [pc, #72]	; (800c200 <OsMain+0x13c>)
 800c1b8:	f7f8 fb82 	bl	80048c0 <dprintf>
 800c1bc:	4817      	ldr	r0, [pc, #92]	; (800c21c <OsMain+0x158>)
 800c1be:	f7f8 fb7f 	bl	80048c0 <dprintf>
        return ret;
 800c1c2:	687b      	ldr	r3, [r7, #4]
 800c1c4:	e016      	b.n	800c1f4 <OsMain+0x130>
    if (ret != LOS_OK) {
        return ret;
    }
#endif

    ret = OsIdleTaskCreate();
 800c1c6:	f7f6 ffbf 	bl	8003148 <OsIdleTaskCreate>
 800c1ca:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800c1cc:	687b      	ldr	r3, [r7, #4]
 800c1ce:	2b00      	cmp	r3, #0
 800c1d0:	d007      	beq.n	800c1e2 <OsMain+0x11e>
        PRINT_ERR("Create idle task err.\n");
 800c1d2:	480b      	ldr	r0, [pc, #44]	; (800c200 <OsMain+0x13c>)
 800c1d4:	f7f8 fb74 	bl	80048c0 <dprintf>
 800c1d8:	4811      	ldr	r0, [pc, #68]	; (800c220 <OsMain+0x15c>)
 800c1da:	f7f8 fb71 	bl	80048c0 <dprintf>
        return ret;
 800c1de:	687b      	ldr	r3, [r7, #4]
 800c1e0:	e008      	b.n	800c1f4 <OsMain+0x130>
        return ret;
    }
#endif

#ifdef LOSCFG_PLATFORM_OSAPPINIT
    ret = OsAppInit();
 800c1e2:	f7ff ff57 	bl	800c094 <OsAppInit>
 800c1e6:	6078      	str	r0, [r7, #4]
#else /* LOSCFG_TEST */
    ret = OsTestInit();
#endif
    if (ret != LOS_OK) {
 800c1e8:	687b      	ldr	r3, [r7, #4]
 800c1ea:	2b00      	cmp	r3, #0
 800c1ec:	d001      	beq.n	800c1f2 <OsMain+0x12e>
        return ret;
 800c1ee:	687b      	ldr	r3, [r7, #4]
 800c1f0:	e000      	b.n	800c1f4 <OsMain+0x130>
    }

    return LOS_OK;
 800c1f2:	2300      	movs	r3, #0
}
 800c1f4:	4618      	mov	r0, r3
 800c1f6:	3708      	adds	r7, #8
 800c1f8:	46bd      	mov	sp, r7
 800c1fa:	bd80      	pop	{r7, pc}
 800c1fc:	080001f0 	.word	0x080001f0
 800c200:	0802161c 	.word	0x0802161c
 800c204:	08021670 	.word	0x08021670
 800c208:	200036e0 	.word	0x200036e0
 800c20c:	08021680 	.word	0x08021680
 800c210:	08021690 	.word	0x08021690
 800c214:	080216a0 	.word	0x080216a0
 800c218:	080216b4 	.word	0x080216b4
 800c21c:	080216c4 	.word	0x080216c4
 800c220:	080216d8 	.word	0x080216d8

0800c224 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800c224:	b580      	push	{r7, lr}
 800c226:	af00      	add	r7, sp, #0
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800c228:	2003      	movs	r0, #3
 800c22a:	f001 ff6d 	bl	800e108 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800c22e:	200f      	movs	r0, #15
 800c230:	f000 f806 	bl	800c240 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800c234:	f7f5 fe4a 	bl	8001ecc <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800c238:	2300      	movs	r3, #0
}
 800c23a:	4618      	mov	r0, r3
 800c23c:	bd80      	pop	{r7, pc}
	...

0800c240 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800c240:	b580      	push	{r7, lr}
 800c242:	b082      	sub	sp, #8
 800c244:	af00      	add	r7, sp, #0
 800c246:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800c248:	4b12      	ldr	r3, [pc, #72]	; (800c294 <HAL_InitTick+0x54>)
 800c24a:	681a      	ldr	r2, [r3, #0]
 800c24c:	4b12      	ldr	r3, [pc, #72]	; (800c298 <HAL_InitTick+0x58>)
 800c24e:	681b      	ldr	r3, [r3, #0]
 800c250:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800c254:	fbb1 f3f3 	udiv	r3, r1, r3
 800c258:	fbb2 f3f3 	udiv	r3, r2, r3
 800c25c:	4618      	mov	r0, r3
 800c25e:	f001 ff82 	bl	800e166 <HAL_SYSTICK_Config>
 800c262:	4603      	mov	r3, r0
 800c264:	2b00      	cmp	r3, #0
 800c266:	d001      	beq.n	800c26c <HAL_InitTick+0x2c>
  {
    return HAL_ERROR;
 800c268:	2301      	movs	r3, #1
 800c26a:	e00e      	b.n	800c28a <HAL_InitTick+0x4a>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800c26c:	687b      	ldr	r3, [r7, #4]
 800c26e:	2b0f      	cmp	r3, #15
 800c270:	d80a      	bhi.n	800c288 <HAL_InitTick+0x48>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800c272:	2200      	movs	r2, #0
 800c274:	6879      	ldr	r1, [r7, #4]
 800c276:	f04f 30ff 	mov.w	r0, #4294967295
 800c27a:	f001 ff50 	bl	800e11e <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800c27e:	4a07      	ldr	r2, [pc, #28]	; (800c29c <HAL_InitTick+0x5c>)
 800c280:	687b      	ldr	r3, [r7, #4]
 800c282:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 800c284:	2300      	movs	r3, #0
 800c286:	e000      	b.n	800c28a <HAL_InitTick+0x4a>
    return HAL_ERROR;
 800c288:	2301      	movs	r3, #1
}
 800c28a:	4618      	mov	r0, r3
 800c28c:	3708      	adds	r7, #8
 800c28e:	46bd      	mov	sp, r7
 800c290:	bd80      	pop	{r7, pc}
 800c292:	bf00      	nop
 800c294:	20000404 	.word	0x20000404
 800c298:	20000480 	.word	0x20000480
 800c29c:	2000047c 	.word	0x2000047c

0800c2a0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800c2a0:	b580      	push	{r7, lr}
 800c2a2:	b084      	sub	sp, #16
 800c2a4:	af00      	add	r7, sp, #0
 800c2a6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 800c2a8:	f7f5 fd66 	bl	8001d78 <HAL_GetTick>
 800c2ac:	60f8      	str	r0, [r7, #12]
  uint32_t wait = Delay;
 800c2ae:	687b      	ldr	r3, [r7, #4]
 800c2b0:	60bb      	str	r3, [r7, #8]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800c2b2:	68bb      	ldr	r3, [r7, #8]
 800c2b4:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c2b8:	d004      	beq.n	800c2c4 <HAL_Delay+0x24>
  {
    wait += (uint32_t)(uwTickFreq);
 800c2ba:	4b09      	ldr	r3, [pc, #36]	; (800c2e0 <HAL_Delay+0x40>)
 800c2bc:	681b      	ldr	r3, [r3, #0]
 800c2be:	68ba      	ldr	r2, [r7, #8]
 800c2c0:	4413      	add	r3, r2
 800c2c2:	60bb      	str	r3, [r7, #8]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800c2c4:	bf00      	nop
 800c2c6:	f7f5 fd57 	bl	8001d78 <HAL_GetTick>
 800c2ca:	4602      	mov	r2, r0
 800c2cc:	68fb      	ldr	r3, [r7, #12]
 800c2ce:	1ad3      	subs	r3, r2, r3
 800c2d0:	68ba      	ldr	r2, [r7, #8]
 800c2d2:	429a      	cmp	r2, r3
 800c2d4:	d8f7      	bhi.n	800c2c6 <HAL_Delay+0x26>
  {
  }
}
 800c2d6:	bf00      	nop
 800c2d8:	bf00      	nop
 800c2da:	3710      	adds	r7, #16
 800c2dc:	46bd      	mov	sp, r7
 800c2de:	bd80      	pop	{r7, pc}
 800c2e0:	20000480 	.word	0x20000480

0800c2e4 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800c2e4:	b580      	push	{r7, lr}
 800c2e6:	b088      	sub	sp, #32
 800c2e8:	af00      	add	r7, sp, #0
 800c2ea:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
 800c2ec:	2300      	movs	r3, #0
 800c2ee:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg0 = 0;
 800c2f0:	2300      	movs	r3, #0
 800c2f2:	61bb      	str	r3, [r7, #24]
  uint32_t tmpreg1 = 0;
 800c2f4:	2300      	movs	r3, #0
 800c2f6:	61fb      	str	r3, [r7, #28]
  uint32_t plli2sused = 0;
 800c2f8:	2300      	movs	r3, #0
 800c2fa:	60fb      	str	r3, [r7, #12]
  uint32_t pllsaiused = 0;
 800c2fc:	2300      	movs	r3, #0
 800c2fe:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 800c300:	687b      	ldr	r3, [r7, #4]
 800c302:	681b      	ldr	r3, [r3, #0]
 800c304:	f003 0301 	and.w	r3, r3, #1
 800c308:	2b00      	cmp	r3, #0
 800c30a:	d012      	beq.n	800c332 <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 800c30c:	4b69      	ldr	r3, [pc, #420]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c30e:	689b      	ldr	r3, [r3, #8]
 800c310:	4a68      	ldr	r2, [pc, #416]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c312:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800c316:	6093      	str	r3, [r2, #8]
 800c318:	4b66      	ldr	r3, [pc, #408]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c31a:	689a      	ldr	r2, [r3, #8]
 800c31c:	687b      	ldr	r3, [r7, #4]
 800c31e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c320:	4964      	ldr	r1, [pc, #400]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c322:	4313      	orrs	r3, r2
 800c324:	608b      	str	r3, [r1, #8]

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 800c326:	687b      	ldr	r3, [r7, #4]
 800c328:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c32a:	2b00      	cmp	r3, #0
 800c32c:	d101      	bne.n	800c332 <HAL_RCCEx_PeriphCLKConfig+0x4e>
    {
      plli2sused = 1;
 800c32e:	2301      	movs	r3, #1
 800c330:	60fb      	str	r3, [r7, #12]
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 800c332:	687b      	ldr	r3, [r7, #4]
 800c334:	681b      	ldr	r3, [r3, #0]
 800c336:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800c33a:	2b00      	cmp	r3, #0
 800c33c:	d017      	beq.n	800c36e <HAL_RCCEx_PeriphCLKConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800c33e:	4b5d      	ldr	r3, [pc, #372]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c340:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c344:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 800c348:	687b      	ldr	r3, [r7, #4]
 800c34a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c34c:	4959      	ldr	r1, [pc, #356]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c34e:	4313      	orrs	r3, r2
 800c350:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 800c354:	687b      	ldr	r3, [r7, #4]
 800c356:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c358:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800c35c:	d101      	bne.n	800c362 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      plli2sused = 1;
 800c35e:	2301      	movs	r3, #1
 800c360:	60fb      	str	r3, [r7, #12]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 800c362:	687b      	ldr	r3, [r7, #4]
 800c364:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c366:	2b00      	cmp	r3, #0
 800c368:	d101      	bne.n	800c36e <HAL_RCCEx_PeriphCLKConfig+0x8a>
    {
      pllsaiused = 1;
 800c36a:	2301      	movs	r3, #1
 800c36c:	613b      	str	r3, [r7, #16]
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 800c36e:	687b      	ldr	r3, [r7, #4]
 800c370:	681b      	ldr	r3, [r3, #0]
 800c372:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800c376:	2b00      	cmp	r3, #0
 800c378:	d017      	beq.n	800c3aa <HAL_RCCEx_PeriphCLKConfig+0xc6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 800c37a:	4b4e      	ldr	r3, [pc, #312]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c37c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c380:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 800c384:	687b      	ldr	r3, [r7, #4]
 800c386:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c388:	494a      	ldr	r1, [pc, #296]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c38a:	4313      	orrs	r3, r2
 800c38c:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 800c390:	687b      	ldr	r3, [r7, #4]
 800c392:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c394:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800c398:	d101      	bne.n	800c39e <HAL_RCCEx_PeriphCLKConfig+0xba>
    {
      plli2sused = 1;
 800c39a:	2301      	movs	r3, #1
 800c39c:	60fb      	str	r3, [r7, #12]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
 800c39e:	687b      	ldr	r3, [r7, #4]
 800c3a0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c3a2:	2b00      	cmp	r3, #0
 800c3a4:	d101      	bne.n	800c3aa <HAL_RCCEx_PeriphCLKConfig+0xc6>
    {
      pllsaiused = 1;
 800c3a6:	2301      	movs	r3, #1
 800c3a8:	613b      	str	r3, [r7, #16]
    }
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800c3aa:	687b      	ldr	r3, [r7, #4]
 800c3ac:	681b      	ldr	r3, [r3, #0]
 800c3ae:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800c3b2:	2b00      	cmp	r3, #0
 800c3b4:	d001      	beq.n	800c3ba <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
      plli2sused = 1;
 800c3b6:	2301      	movs	r3, #1
 800c3b8:	60fb      	str	r3, [r7, #12]
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800c3ba:	687b      	ldr	r3, [r7, #4]
 800c3bc:	681b      	ldr	r3, [r3, #0]
 800c3be:	f003 0320 	and.w	r3, r3, #32
 800c3c2:	2b00      	cmp	r3, #0
 800c3c4:	f000 808b 	beq.w	800c4de <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800c3c8:	4b3a      	ldr	r3, [pc, #232]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c3ca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c3cc:	4a39      	ldr	r2, [pc, #228]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c3ce:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c3d2:	6413      	str	r3, [r2, #64]	; 0x40
 800c3d4:	4b37      	ldr	r3, [pc, #220]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c3d6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c3d8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800c3dc:	60bb      	str	r3, [r7, #8]
 800c3de:	68bb      	ldr	r3, [r7, #8]

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 800c3e0:	4b35      	ldr	r3, [pc, #212]	; (800c4b8 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 800c3e2:	681b      	ldr	r3, [r3, #0]
 800c3e4:	4a34      	ldr	r2, [pc, #208]	; (800c4b8 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 800c3e6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800c3ea:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800c3ec:	f7f5 fcc4 	bl	8001d78 <HAL_GetTick>
 800c3f0:	6178      	str	r0, [r7, #20]

    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 800c3f2:	e008      	b.n	800c406 <HAL_RCCEx_PeriphCLKConfig+0x122>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800c3f4:	f7f5 fcc0 	bl	8001d78 <HAL_GetTick>
 800c3f8:	4602      	mov	r2, r0
 800c3fa:	697b      	ldr	r3, [r7, #20]
 800c3fc:	1ad3      	subs	r3, r2, r3
 800c3fe:	2b64      	cmp	r3, #100	; 0x64
 800c400:	d901      	bls.n	800c406 <HAL_RCCEx_PeriphCLKConfig+0x122>
      {
        return HAL_TIMEOUT;
 800c402:	2303      	movs	r3, #3
 800c404:	e38f      	b.n	800cb26 <HAL_RCCEx_PeriphCLKConfig+0x842>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 800c406:	4b2c      	ldr	r3, [pc, #176]	; (800c4b8 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 800c408:	681b      	ldr	r3, [r3, #0]
 800c40a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800c40e:	2b00      	cmp	r3, #0
 800c410:	d0f0      	beq.n	800c3f4 <HAL_RCCEx_PeriphCLKConfig+0x110>
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 800c412:	4b28      	ldr	r3, [pc, #160]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c414:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c416:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800c41a:	61bb      	str	r3, [r7, #24]

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800c41c:	69bb      	ldr	r3, [r7, #24]
 800c41e:	2b00      	cmp	r3, #0
 800c420:	d035      	beq.n	800c48e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
 800c422:	687b      	ldr	r3, [r7, #4]
 800c424:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c426:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800c42a:	69ba      	ldr	r2, [r7, #24]
 800c42c:	429a      	cmp	r2, r3
 800c42e:	d02e      	beq.n	800c48e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800c430:	4b20      	ldr	r3, [pc, #128]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c432:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c434:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800c438:	61bb      	str	r3, [r7, #24]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800c43a:	4b1e      	ldr	r3, [pc, #120]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c43c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c43e:	4a1d      	ldr	r2, [pc, #116]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c440:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800c444:	6713      	str	r3, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 800c446:	4b1b      	ldr	r3, [pc, #108]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c448:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c44a:	4a1a      	ldr	r2, [pc, #104]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c44c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800c450:	6713      	str	r3, [r2, #112]	; 0x70

      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg0;
 800c452:	4a18      	ldr	r2, [pc, #96]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c454:	69bb      	ldr	r3, [r7, #24]
 800c456:	6713      	str	r3, [r2, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 800c458:	4b16      	ldr	r3, [pc, #88]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c45a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c45c:	f003 0301 	and.w	r3, r3, #1
 800c460:	2b01      	cmp	r3, #1
 800c462:	d114      	bne.n	800c48e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800c464:	f7f5 fc88 	bl	8001d78 <HAL_GetTick>
 800c468:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800c46a:	e00a      	b.n	800c482 <HAL_RCCEx_PeriphCLKConfig+0x19e>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800c46c:	f7f5 fc84 	bl	8001d78 <HAL_GetTick>
 800c470:	4602      	mov	r2, r0
 800c472:	697b      	ldr	r3, [r7, #20]
 800c474:	1ad3      	subs	r3, r2, r3
 800c476:	f241 3288 	movw	r2, #5000	; 0x1388
 800c47a:	4293      	cmp	r3, r2
 800c47c:	d901      	bls.n	800c482 <HAL_RCCEx_PeriphCLKConfig+0x19e>
          {
            return HAL_TIMEOUT;
 800c47e:	2303      	movs	r3, #3
 800c480:	e351      	b.n	800cb26 <HAL_RCCEx_PeriphCLKConfig+0x842>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800c482:	4b0c      	ldr	r3, [pc, #48]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c484:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c486:	f003 0302 	and.w	r3, r3, #2
 800c48a:	2b00      	cmp	r3, #0
 800c48c:	d0ee      	beq.n	800c46c <HAL_RCCEx_PeriphCLKConfig+0x188>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800c48e:	687b      	ldr	r3, [r7, #4]
 800c490:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c492:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800c496:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800c49a:	d111      	bne.n	800c4c0 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
 800c49c:	4b05      	ldr	r3, [pc, #20]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c49e:	689b      	ldr	r3, [r3, #8]
 800c4a0:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 800c4a4:	687b      	ldr	r3, [r7, #4]
 800c4a6:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800c4a8:	4b04      	ldr	r3, [pc, #16]	; (800c4bc <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
 800c4aa:	400b      	ands	r3, r1
 800c4ac:	4901      	ldr	r1, [pc, #4]	; (800c4b4 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800c4ae:	4313      	orrs	r3, r2
 800c4b0:	608b      	str	r3, [r1, #8]
 800c4b2:	e00b      	b.n	800c4cc <HAL_RCCEx_PeriphCLKConfig+0x1e8>
 800c4b4:	40023800 	.word	0x40023800
 800c4b8:	40007000 	.word	0x40007000
 800c4bc:	0ffffcff 	.word	0x0ffffcff
 800c4c0:	4bb3      	ldr	r3, [pc, #716]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c4c2:	689b      	ldr	r3, [r3, #8]
 800c4c4:	4ab2      	ldr	r2, [pc, #712]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c4c6:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 800c4ca:	6093      	str	r3, [r2, #8]
 800c4cc:	4bb0      	ldr	r3, [pc, #704]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c4ce:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800c4d0:	687b      	ldr	r3, [r7, #4]
 800c4d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c4d4:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800c4d8:	49ad      	ldr	r1, [pc, #692]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c4da:	4313      	orrs	r3, r2
 800c4dc:	670b      	str	r3, [r1, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 800c4de:	687b      	ldr	r3, [r7, #4]
 800c4e0:	681b      	ldr	r3, [r3, #0]
 800c4e2:	f003 0310 	and.w	r3, r3, #16
 800c4e6:	2b00      	cmp	r3, #0
 800c4e8:	d010      	beq.n	800c50c <HAL_RCCEx_PeriphCLKConfig+0x228>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800c4ea:	4ba9      	ldr	r3, [pc, #676]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c4ec:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c4f0:	4aa7      	ldr	r2, [pc, #668]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c4f2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800c4f6:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 800c4fa:	4ba5      	ldr	r3, [pc, #660]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c4fc:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800c500:	687b      	ldr	r3, [r7, #4]
 800c502:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c504:	49a2      	ldr	r1, [pc, #648]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c506:	4313      	orrs	r3, r2
 800c508:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800c50c:	687b      	ldr	r3, [r7, #4]
 800c50e:	681b      	ldr	r3, [r3, #0]
 800c510:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800c514:	2b00      	cmp	r3, #0
 800c516:	d00a      	beq.n	800c52e <HAL_RCCEx_PeriphCLKConfig+0x24a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800c518:	4b9d      	ldr	r3, [pc, #628]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c51a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c51e:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 800c522:	687b      	ldr	r3, [r7, #4]
 800c524:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800c526:	499a      	ldr	r1, [pc, #616]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c528:	4313      	orrs	r3, r2
 800c52a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 800c52e:	687b      	ldr	r3, [r7, #4]
 800c530:	681b      	ldr	r3, [r3, #0]
 800c532:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800c536:	2b00      	cmp	r3, #0
 800c538:	d00a      	beq.n	800c550 <HAL_RCCEx_PeriphCLKConfig+0x26c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 800c53a:	4b95      	ldr	r3, [pc, #596]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c53c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c540:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
 800c544:	687b      	ldr	r3, [r7, #4]
 800c546:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800c548:	4991      	ldr	r1, [pc, #580]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c54a:	4313      	orrs	r3, r2
 800c54c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800c550:	687b      	ldr	r3, [r7, #4]
 800c552:	681b      	ldr	r3, [r3, #0]
 800c554:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800c558:	2b00      	cmp	r3, #0
 800c55a:	d00a      	beq.n	800c572 <HAL_RCCEx_PeriphCLKConfig+0x28e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800c55c:	4b8c      	ldr	r3, [pc, #560]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c55e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c562:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 800c566:	687b      	ldr	r3, [r7, #4]
 800c568:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c56a:	4989      	ldr	r1, [pc, #548]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c56c:	4313      	orrs	r3, r2
 800c56e:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 800c572:	687b      	ldr	r3, [r7, #4]
 800c574:	681b      	ldr	r3, [r3, #0]
 800c576:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800c57a:	2b00      	cmp	r3, #0
 800c57c:	d00a      	beq.n	800c594 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 800c57e:	4b84      	ldr	r3, [pc, #528]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c580:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c584:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 800c588:	687b      	ldr	r3, [r7, #4]
 800c58a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c58c:	4980      	ldr	r1, [pc, #512]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c58e:	4313      	orrs	r3, r2
 800c590:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800c594:	687b      	ldr	r3, [r7, #4]
 800c596:	681b      	ldr	r3, [r3, #0]
 800c598:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800c59c:	2b00      	cmp	r3, #0
 800c59e:	d00a      	beq.n	800c5b6 <HAL_RCCEx_PeriphCLKConfig+0x2d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800c5a0:	4b7b      	ldr	r3, [pc, #492]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c5a2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c5a6:	f023 0203 	bic.w	r2, r3, #3
 800c5aa:	687b      	ldr	r3, [r7, #4]
 800c5ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c5ae:	4978      	ldr	r1, [pc, #480]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c5b0:	4313      	orrs	r3, r2
 800c5b2:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800c5b6:	687b      	ldr	r3, [r7, #4]
 800c5b8:	681b      	ldr	r3, [r3, #0]
 800c5ba:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800c5be:	2b00      	cmp	r3, #0
 800c5c0:	d00a      	beq.n	800c5d8 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800c5c2:	4b73      	ldr	r3, [pc, #460]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c5c4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c5c8:	f023 020c 	bic.w	r2, r3, #12
 800c5cc:	687b      	ldr	r3, [r7, #4]
 800c5ce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c5d0:	496f      	ldr	r1, [pc, #444]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c5d2:	4313      	orrs	r3, r2
 800c5d4:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 800c5d8:	687b      	ldr	r3, [r7, #4]
 800c5da:	681b      	ldr	r3, [r3, #0]
 800c5dc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800c5e0:	2b00      	cmp	r3, #0
 800c5e2:	d00a      	beq.n	800c5fa <HAL_RCCEx_PeriphCLKConfig+0x316>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800c5e4:	4b6a      	ldr	r3, [pc, #424]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c5e6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c5ea:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 800c5ee:	687b      	ldr	r3, [r7, #4]
 800c5f0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c5f2:	4967      	ldr	r1, [pc, #412]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c5f4:	4313      	orrs	r3, r2
 800c5f6:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 800c5fa:	687b      	ldr	r3, [r7, #4]
 800c5fc:	681b      	ldr	r3, [r3, #0]
 800c5fe:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800c602:	2b00      	cmp	r3, #0
 800c604:	d00a      	beq.n	800c61c <HAL_RCCEx_PeriphCLKConfig+0x338>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 800c606:	4b62      	ldr	r3, [pc, #392]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c608:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c60c:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 800c610:	687b      	ldr	r3, [r7, #4]
 800c612:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c614:	495e      	ldr	r1, [pc, #376]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c616:	4313      	orrs	r3, r2
 800c618:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 800c61c:	687b      	ldr	r3, [r7, #4]
 800c61e:	681b      	ldr	r3, [r3, #0]
 800c620:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800c624:	2b00      	cmp	r3, #0
 800c626:	d00a      	beq.n	800c63e <HAL_RCCEx_PeriphCLKConfig+0x35a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 800c628:	4b59      	ldr	r3, [pc, #356]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c62a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c62e:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 800c632:	687b      	ldr	r3, [r7, #4]
 800c634:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800c636:	4956      	ldr	r1, [pc, #344]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c638:	4313      	orrs	r3, r2
 800c63a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 800c63e:	687b      	ldr	r3, [r7, #4]
 800c640:	681b      	ldr	r3, [r3, #0]
 800c642:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800c646:	2b00      	cmp	r3, #0
 800c648:	d00a      	beq.n	800c660 <HAL_RCCEx_PeriphCLKConfig+0x37c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 800c64a:	4b51      	ldr	r3, [pc, #324]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c64c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c650:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 800c654:	687b      	ldr	r3, [r7, #4]
 800c656:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800c658:	494d      	ldr	r1, [pc, #308]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c65a:	4313      	orrs	r3, r2
 800c65c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 800c660:	687b      	ldr	r3, [r7, #4]
 800c662:	681b      	ldr	r3, [r3, #0]
 800c664:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800c668:	2b00      	cmp	r3, #0
 800c66a:	d00a      	beq.n	800c682 <HAL_RCCEx_PeriphCLKConfig+0x39e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 800c66c:	4b48      	ldr	r3, [pc, #288]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c66e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c672:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 800c676:	687b      	ldr	r3, [r7, #4]
 800c678:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800c67a:	4945      	ldr	r1, [pc, #276]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c67c:	4313      	orrs	r3, r2
 800c67e:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 800c682:	687b      	ldr	r3, [r7, #4]
 800c684:	681b      	ldr	r3, [r3, #0]
 800c686:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800c68a:	2b00      	cmp	r3, #0
 800c68c:	d00a      	beq.n	800c6a4 <HAL_RCCEx_PeriphCLKConfig+0x3c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 800c68e:	4b40      	ldr	r3, [pc, #256]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c690:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c694:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 800c698:	687b      	ldr	r3, [r7, #4]
 800c69a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800c69c:	493c      	ldr	r1, [pc, #240]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c69e:	4313      	orrs	r3, r2
 800c6a0:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 800c6a4:	687b      	ldr	r3, [r7, #4]
 800c6a6:	681b      	ldr	r3, [r3, #0]
 800c6a8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800c6ac:	2b00      	cmp	r3, #0
 800c6ae:	d00a      	beq.n	800c6c6 <HAL_RCCEx_PeriphCLKConfig+0x3e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 800c6b0:	4b37      	ldr	r3, [pc, #220]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c6b2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c6b6:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
 800c6ba:	687b      	ldr	r3, [r7, #4]
 800c6bc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c6be:	4934      	ldr	r1, [pc, #208]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c6c0:	4313      	orrs	r3, r2
 800c6c2:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 800c6c6:	687b      	ldr	r3, [r7, #4]
 800c6c8:	681b      	ldr	r3, [r3, #0]
 800c6ca:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800c6ce:	2b00      	cmp	r3, #0
 800c6d0:	d011      	beq.n	800c6f6 <HAL_RCCEx_PeriphCLKConfig+0x412>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 800c6d2:	4b2f      	ldr	r3, [pc, #188]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c6d4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c6d8:	f023 6200 	bic.w	r2, r3, #134217728	; 0x8000000
 800c6dc:	687b      	ldr	r3, [r7, #4]
 800c6de:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c6e0:	492b      	ldr	r1, [pc, #172]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c6e2:	4313      	orrs	r3, r2
 800c6e4:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
 800c6e8:	687b      	ldr	r3, [r7, #4]
 800c6ea:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c6ec:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800c6f0:	d101      	bne.n	800c6f6 <HAL_RCCEx_PeriphCLKConfig+0x412>
    {
      pllsaiused = 1;
 800c6f2:	2301      	movs	r3, #1
 800c6f4:	613b      	str	r3, [r7, #16]
    }
  }

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	681b      	ldr	r3, [r3, #0]
 800c6fa:	f003 0308 	and.w	r3, r3, #8
 800c6fe:	2b00      	cmp	r3, #0
 800c700:	d001      	beq.n	800c706 <HAL_RCCEx_PeriphCLKConfig+0x422>
  {
    pllsaiused = 1;
 800c702:	2301      	movs	r3, #1
 800c704:	613b      	str	r3, [r7, #16]
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800c706:	687b      	ldr	r3, [r7, #4]
 800c708:	681b      	ldr	r3, [r3, #0]
 800c70a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800c70e:	2b00      	cmp	r3, #0
 800c710:	d00a      	beq.n	800c728 <HAL_RCCEx_PeriphCLKConfig+0x444>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 800c712:	4b1f      	ldr	r3, [pc, #124]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c714:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c718:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
 800c71c:	687b      	ldr	r3, [r7, #4]
 800c71e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c720:	491b      	ldr	r1, [pc, #108]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c722:	4313      	orrs	r3, r2
 800c724:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 800c728:	687b      	ldr	r3, [r7, #4]
 800c72a:	681b      	ldr	r3, [r3, #0]
 800c72c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800c730:	2b00      	cmp	r3, #0
 800c732:	d00b      	beq.n	800c74c <HAL_RCCEx_PeriphCLKConfig+0x468>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 800c734:	4b16      	ldr	r3, [pc, #88]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c736:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c73a:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
 800c73e:	687b      	ldr	r3, [r7, #4]
 800c740:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800c744:	4912      	ldr	r1, [pc, #72]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c746:	4313      	orrs	r3, r2
 800c748:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
 800c74c:	687b      	ldr	r3, [r7, #4]
 800c74e:	681b      	ldr	r3, [r3, #0]
 800c750:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 800c754:	2b00      	cmp	r3, #0
 800c756:	d00b      	beq.n	800c770 <HAL_RCCEx_PeriphCLKConfig+0x48c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    /* Configure the SDMMC2 clock source */
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
 800c758:	4b0d      	ldr	r3, [pc, #52]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c75a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c75e:	f023 5200 	bic.w	r2, r3, #536870912	; 0x20000000
 800c762:	687b      	ldr	r3, [r7, #4]
 800c764:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800c768:	4909      	ldr	r1, [pc, #36]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c76a:	4313      	orrs	r3, r2
 800c76c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*------------------------------------- DFSDM1 Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 800c770:	687b      	ldr	r3, [r7, #4]
 800c772:	681b      	ldr	r3, [r3, #0]
 800c774:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800c778:	2b00      	cmp	r3, #0
 800c77a:	d00f      	beq.n	800c79c <HAL_RCCEx_PeriphCLKConfig+0x4b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 800c77c:	4b04      	ldr	r3, [pc, #16]	; (800c790 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 800c77e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c782:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
 800c786:	687b      	ldr	r3, [r7, #4]
 800c788:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800c78c:	e002      	b.n	800c794 <HAL_RCCEx_PeriphCLKConfig+0x4b0>
 800c78e:	bf00      	nop
 800c790:	40023800 	.word	0x40023800
 800c794:	4986      	ldr	r1, [pc, #536]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c796:	4313      	orrs	r3, r2
 800c798:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }

  /*------------------------------------- DFSDM AUDIO Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO)
 800c79c:	687b      	ldr	r3, [r7, #4]
 800c79e:	681b      	ldr	r3, [r3, #0]
 800c7a0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800c7a4:	2b00      	cmp	r3, #0
 800c7a6:	d00b      	beq.n	800c7c0 <HAL_RCCEx_PeriphCLKConfig+0x4dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM interface clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 800c7a8:	4b81      	ldr	r3, [pc, #516]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c7aa:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c7ae:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
 800c7b2:	687b      	ldr	r3, [r7, #4]
 800c7b4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c7b8:	497d      	ldr	r1, [pc, #500]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c7ba:	4313      	orrs	r3, r2
 800c7bc:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 800c7c0:	68fb      	ldr	r3, [r7, #12]
 800c7c2:	2b01      	cmp	r3, #1
 800c7c4:	d006      	beq.n	800c7d4 <HAL_RCCEx_PeriphCLKConfig+0x4f0>
 800c7c6:	687b      	ldr	r3, [r7, #4]
 800c7c8:	681b      	ldr	r3, [r3, #0]
 800c7ca:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800c7ce:	2b00      	cmp	r3, #0
 800c7d0:	f000 80d6 	beq.w	800c980 <HAL_RCCEx_PeriphCLKConfig+0x69c>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 800c7d4:	4b76      	ldr	r3, [pc, #472]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c7d6:	681b      	ldr	r3, [r3, #0]
 800c7d8:	4a75      	ldr	r2, [pc, #468]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c7da:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800c7de:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800c7e0:	f7f5 faca 	bl	8001d78 <HAL_GetTick>
 800c7e4:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800c7e6:	e008      	b.n	800c7fa <HAL_RCCEx_PeriphCLKConfig+0x516>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 800c7e8:	f7f5 fac6 	bl	8001d78 <HAL_GetTick>
 800c7ec:	4602      	mov	r2, r0
 800c7ee:	697b      	ldr	r3, [r7, #20]
 800c7f0:	1ad3      	subs	r3, r2, r3
 800c7f2:	2b64      	cmp	r3, #100	; 0x64
 800c7f4:	d901      	bls.n	800c7fa <HAL_RCCEx_PeriphCLKConfig+0x516>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800c7f6:	2303      	movs	r3, #3
 800c7f8:	e195      	b.n	800cb26 <HAL_RCCEx_PeriphCLKConfig+0x842>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800c7fa:	4b6d      	ldr	r3, [pc, #436]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c7fc:	681b      	ldr	r3, [r3, #0]
 800c7fe:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800c802:	2b00      	cmp	r3, #0
 800c804:	d1f0      	bne.n	800c7e8 <HAL_RCCEx_PeriphCLKConfig+0x504>

    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 800c806:	687b      	ldr	r3, [r7, #4]
 800c808:	681b      	ldr	r3, [r3, #0]
 800c80a:	f003 0301 	and.w	r3, r3, #1
 800c80e:	2b00      	cmp	r3, #0
 800c810:	d021      	beq.n	800c856 <HAL_RCCEx_PeriphCLKConfig+0x572>
 800c812:	687b      	ldr	r3, [r7, #4]
 800c814:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c816:	2b00      	cmp	r3, #0
 800c818:	d11d      	bne.n	800c856 <HAL_RCCEx_PeriphCLKConfig+0x572>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 800c81a:	4b65      	ldr	r3, [pc, #404]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c81c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800c820:	0c1b      	lsrs	r3, r3, #16
 800c822:	f003 0303 	and.w	r3, r3, #3
 800c826:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 800c828:	4b61      	ldr	r3, [pc, #388]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c82a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800c82e:	0e1b      	lsrs	r3, r3, #24
 800c830:	f003 030f 	and.w	r3, r3, #15
 800c834:	61fb      	str	r3, [r7, #28]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 800c836:	687b      	ldr	r3, [r7, #4]
 800c838:	685b      	ldr	r3, [r3, #4]
 800c83a:	019a      	lsls	r2, r3, #6
 800c83c:	69bb      	ldr	r3, [r7, #24]
 800c83e:	041b      	lsls	r3, r3, #16
 800c840:	431a      	orrs	r2, r3
 800c842:	69fb      	ldr	r3, [r7, #28]
 800c844:	061b      	lsls	r3, r3, #24
 800c846:	431a      	orrs	r2, r3
 800c848:	687b      	ldr	r3, [r7, #4]
 800c84a:	689b      	ldr	r3, [r3, #8]
 800c84c:	071b      	lsls	r3, r3, #28
 800c84e:	4958      	ldr	r1, [pc, #352]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c850:	4313      	orrs	r3, r2
 800c852:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 800c856:	687b      	ldr	r3, [r7, #4]
 800c858:	681b      	ldr	r3, [r3, #0]
 800c85a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800c85e:	2b00      	cmp	r3, #0
 800c860:	d004      	beq.n	800c86c <HAL_RCCEx_PeriphCLKConfig+0x588>
 800c862:	687b      	ldr	r3, [r7, #4]
 800c864:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c866:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800c86a:	d00a      	beq.n	800c882 <HAL_RCCEx_PeriphCLKConfig+0x59e>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 800c86c:	687b      	ldr	r3, [r7, #4]
 800c86e:	681b      	ldr	r3, [r3, #0]
 800c870:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 800c874:	2b00      	cmp	r3, #0
 800c876:	d02e      	beq.n	800c8d6 <HAL_RCCEx_PeriphCLKConfig+0x5f2>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 800c878:	687b      	ldr	r3, [r7, #4]
 800c87a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c87c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800c880:	d129      	bne.n	800c8d6 <HAL_RCCEx_PeriphCLKConfig+0x5f2>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      /* Check for PLLI2S/DIVQ parameters */
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));

      /* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 800c882:	4b4b      	ldr	r3, [pc, #300]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c884:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800c888:	0c1b      	lsrs	r3, r3, #16
 800c88a:	f003 0303 	and.w	r3, r3, #3
 800c88e:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 800c890:	4b47      	ldr	r3, [pc, #284]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c892:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800c896:	0f1b      	lsrs	r3, r3, #28
 800c898:	f003 0307 	and.w	r3, r3, #7
 800c89c:	61fb      	str	r3, [r7, #28]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 800c89e:	687b      	ldr	r3, [r7, #4]
 800c8a0:	685b      	ldr	r3, [r3, #4]
 800c8a2:	019a      	lsls	r2, r3, #6
 800c8a4:	69bb      	ldr	r3, [r7, #24]
 800c8a6:	041b      	lsls	r3, r3, #16
 800c8a8:	431a      	orrs	r2, r3
 800c8aa:	687b      	ldr	r3, [r7, #4]
 800c8ac:	68db      	ldr	r3, [r3, #12]
 800c8ae:	061b      	lsls	r3, r3, #24
 800c8b0:	431a      	orrs	r2, r3
 800c8b2:	69fb      	ldr	r3, [r7, #28]
 800c8b4:	071b      	lsls	r3, r3, #28
 800c8b6:	493e      	ldr	r1, [pc, #248]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c8b8:	4313      	orrs	r3, r2
 800c8ba:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84

      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 800c8be:	4b3c      	ldr	r3, [pc, #240]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c8c0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c8c4:	f023 021f 	bic.w	r2, r3, #31
 800c8c8:	687b      	ldr	r3, [r7, #4]
 800c8ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c8cc:	3b01      	subs	r3, #1
 800c8ce:	4938      	ldr	r1, [pc, #224]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c8d0:	4313      	orrs	r3, r2
 800c8d2:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800c8d6:	687b      	ldr	r3, [r7, #4]
 800c8d8:	681b      	ldr	r3, [r3, #0]
 800c8da:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800c8de:	2b00      	cmp	r3, #0
 800c8e0:	d01d      	beq.n	800c91e <HAL_RCCEx_PeriphCLKConfig+0x63a>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));

     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 800c8e2:	4b33      	ldr	r3, [pc, #204]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c8e4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800c8e8:	0e1b      	lsrs	r3, r3, #24
 800c8ea:	f003 030f 	and.w	r3, r3, #15
 800c8ee:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 800c8f0:	4b2f      	ldr	r3, [pc, #188]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c8f2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800c8f6:	0f1b      	lsrs	r3, r3, #28
 800c8f8:	f003 0307 	and.w	r3, r3, #7
 800c8fc:	61fb      	str	r3, [r7, #28]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 800c8fe:	687b      	ldr	r3, [r7, #4]
 800c900:	685b      	ldr	r3, [r3, #4]
 800c902:	019a      	lsls	r2, r3, #6
 800c904:	687b      	ldr	r3, [r7, #4]
 800c906:	691b      	ldr	r3, [r3, #16]
 800c908:	041b      	lsls	r3, r3, #16
 800c90a:	431a      	orrs	r2, r3
 800c90c:	69bb      	ldr	r3, [r7, #24]
 800c90e:	061b      	lsls	r3, r3, #24
 800c910:	431a      	orrs	r2, r3
 800c912:	69fb      	ldr	r3, [r7, #28]
 800c914:	071b      	lsls	r3, r3, #28
 800c916:	4926      	ldr	r1, [pc, #152]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c918:	4313      	orrs	r3, r2
 800c91a:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 800c91e:	687b      	ldr	r3, [r7, #4]
 800c920:	681b      	ldr	r3, [r3, #0]
 800c922:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800c926:	2b00      	cmp	r3, #0
 800c928:	d011      	beq.n	800c94e <HAL_RCCEx_PeriphCLKConfig+0x66a>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));

      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) */
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 800c92a:	687b      	ldr	r3, [r7, #4]
 800c92c:	685b      	ldr	r3, [r3, #4]
 800c92e:	019a      	lsls	r2, r3, #6
 800c930:	687b      	ldr	r3, [r7, #4]
 800c932:	691b      	ldr	r3, [r3, #16]
 800c934:	041b      	lsls	r3, r3, #16
 800c936:	431a      	orrs	r2, r3
 800c938:	687b      	ldr	r3, [r7, #4]
 800c93a:	68db      	ldr	r3, [r3, #12]
 800c93c:	061b      	lsls	r3, r3, #24
 800c93e:	431a      	orrs	r2, r3
 800c940:	687b      	ldr	r3, [r7, #4]
 800c942:	689b      	ldr	r3, [r3, #8]
 800c944:	071b      	lsls	r3, r3, #28
 800c946:	491a      	ldr	r1, [pc, #104]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c948:	4313      	orrs	r3, r2
 800c94a:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 800c94e:	4b18      	ldr	r3, [pc, #96]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c950:	681b      	ldr	r3, [r3, #0]
 800c952:	4a17      	ldr	r2, [pc, #92]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c954:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800c958:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800c95a:	f7f5 fa0d 	bl	8001d78 <HAL_GetTick>
 800c95e:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 800c960:	e008      	b.n	800c974 <HAL_RCCEx_PeriphCLKConfig+0x690>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 800c962:	f7f5 fa09 	bl	8001d78 <HAL_GetTick>
 800c966:	4602      	mov	r2, r0
 800c968:	697b      	ldr	r3, [r7, #20]
 800c96a:	1ad3      	subs	r3, r2, r3
 800c96c:	2b64      	cmp	r3, #100	; 0x64
 800c96e:	d901      	bls.n	800c974 <HAL_RCCEx_PeriphCLKConfig+0x690>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800c970:	2303      	movs	r3, #3
 800c972:	e0d8      	b.n	800cb26 <HAL_RCCEx_PeriphCLKConfig+0x842>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 800c974:	4b0e      	ldr	r3, [pc, #56]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c976:	681b      	ldr	r3, [r3, #0]
 800c978:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800c97c:	2b00      	cmp	r3, #0
 800c97e:	d0f0      	beq.n	800c962 <HAL_RCCEx_PeriphCLKConfig+0x67e>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 800c980:	693b      	ldr	r3, [r7, #16]
 800c982:	2b01      	cmp	r3, #1
 800c984:	f040 80ce 	bne.w	800cb24 <HAL_RCCEx_PeriphCLKConfig+0x840>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE();
 800c988:	4b09      	ldr	r3, [pc, #36]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c98a:	681b      	ldr	r3, [r3, #0]
 800c98c:	4a08      	ldr	r2, [pc, #32]	; (800c9b0 <HAL_RCCEx_PeriphCLKConfig+0x6cc>)
 800c98e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800c992:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800c994:	f7f5 f9f0 	bl	8001d78 <HAL_GetTick>
 800c998:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 800c99a:	e00b      	b.n	800c9b4 <HAL_RCCEx_PeriphCLKConfig+0x6d0>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 800c99c:	f7f5 f9ec 	bl	8001d78 <HAL_GetTick>
 800c9a0:	4602      	mov	r2, r0
 800c9a2:	697b      	ldr	r3, [r7, #20]
 800c9a4:	1ad3      	subs	r3, r2, r3
 800c9a6:	2b64      	cmp	r3, #100	; 0x64
 800c9a8:	d904      	bls.n	800c9b4 <HAL_RCCEx_PeriphCLKConfig+0x6d0>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800c9aa:	2303      	movs	r3, #3
 800c9ac:	e0bb      	b.n	800cb26 <HAL_RCCEx_PeriphCLKConfig+0x842>
 800c9ae:	bf00      	nop
 800c9b0:	40023800 	.word	0x40023800
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 800c9b4:	4b5e      	ldr	r3, [pc, #376]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c9b6:	681b      	ldr	r3, [r3, #0]
 800c9b8:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800c9bc:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800c9c0:	d0ec      	beq.n	800c99c <HAL_RCCEx_PeriphCLKConfig+0x6b8>

    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));

    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 800c9c2:	687b      	ldr	r3, [r7, #4]
 800c9c4:	681b      	ldr	r3, [r3, #0]
 800c9c6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800c9ca:	2b00      	cmp	r3, #0
 800c9cc:	d003      	beq.n	800c9d6 <HAL_RCCEx_PeriphCLKConfig+0x6f2>
 800c9ce:	687b      	ldr	r3, [r7, #4]
 800c9d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c9d2:	2b00      	cmp	r3, #0
 800c9d4:	d009      	beq.n	800c9ea <HAL_RCCEx_PeriphCLKConfig+0x706>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 800c9d6:	687b      	ldr	r3, [r7, #4]
 800c9d8:	681b      	ldr	r3, [r3, #0]
 800c9da:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 800c9de:	2b00      	cmp	r3, #0
 800c9e0:	d02e      	beq.n	800ca40 <HAL_RCCEx_PeriphCLKConfig+0x75c>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 800c9e2:	687b      	ldr	r3, [r7, #4]
 800c9e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c9e6:	2b00      	cmp	r3, #0
 800c9e8:	d12a      	bne.n	800ca40 <HAL_RCCEx_PeriphCLKConfig+0x75c>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));

      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 800c9ea:	4b51      	ldr	r3, [pc, #324]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c9ec:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800c9f0:	0c1b      	lsrs	r3, r3, #16
 800c9f2:	f003 0303 	and.w	r3, r3, #3
 800c9f6:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 800c9f8:	4b4d      	ldr	r3, [pc, #308]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800c9fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800c9fe:	0f1b      	lsrs	r3, r3, #28
 800ca00:	f003 0307 	and.w	r3, r3, #7
 800ca04:	61fb      	str	r3, [r7, #28]
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 800ca06:	687b      	ldr	r3, [r7, #4]
 800ca08:	695b      	ldr	r3, [r3, #20]
 800ca0a:	019a      	lsls	r2, r3, #6
 800ca0c:	69bb      	ldr	r3, [r7, #24]
 800ca0e:	041b      	lsls	r3, r3, #16
 800ca10:	431a      	orrs	r2, r3
 800ca12:	687b      	ldr	r3, [r7, #4]
 800ca14:	699b      	ldr	r3, [r3, #24]
 800ca16:	061b      	lsls	r3, r3, #24
 800ca18:	431a      	orrs	r2, r3
 800ca1a:	69fb      	ldr	r3, [r7, #28]
 800ca1c:	071b      	lsls	r3, r3, #28
 800ca1e:	4944      	ldr	r1, [pc, #272]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800ca20:	4313      	orrs	r3, r2
 800ca22:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 800ca26:	4b42      	ldr	r3, [pc, #264]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800ca28:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ca2c:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
 800ca30:	687b      	ldr	r3, [r7, #4]
 800ca32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ca34:	3b01      	subs	r3, #1
 800ca36:	021b      	lsls	r3, r3, #8
 800ca38:	493d      	ldr	r1, [pc, #244]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800ca3a:	4313      	orrs	r3, r2
 800ca3c:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/
    /* In Case of PLLI2S is selected as source clock for CK48 */
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 800ca40:	687b      	ldr	r3, [r7, #4]
 800ca42:	681b      	ldr	r3, [r3, #0]
 800ca44:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800ca48:	2b00      	cmp	r3, #0
 800ca4a:	d022      	beq.n	800ca92 <HAL_RCCEx_PeriphCLKConfig+0x7ae>
 800ca4c:	687b      	ldr	r3, [r7, #4]
 800ca4e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800ca50:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800ca54:	d11d      	bne.n	800ca92 <HAL_RCCEx_PeriphCLKConfig+0x7ae>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 800ca56:	4b36      	ldr	r3, [pc, #216]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800ca58:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ca5c:	0e1b      	lsrs	r3, r3, #24
 800ca5e:	f003 030f 	and.w	r3, r3, #15
 800ca62:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 800ca64:	4b32      	ldr	r3, [pc, #200]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800ca66:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ca6a:	0f1b      	lsrs	r3, r3, #28
 800ca6c:	f003 0307 	and.w	r3, r3, #7
 800ca70:	61fb      	str	r3, [r7, #28]

      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 800ca72:	687b      	ldr	r3, [r7, #4]
 800ca74:	695b      	ldr	r3, [r3, #20]
 800ca76:	019a      	lsls	r2, r3, #6
 800ca78:	687b      	ldr	r3, [r7, #4]
 800ca7a:	6a1b      	ldr	r3, [r3, #32]
 800ca7c:	041b      	lsls	r3, r3, #16
 800ca7e:	431a      	orrs	r2, r3
 800ca80:	69bb      	ldr	r3, [r7, #24]
 800ca82:	061b      	lsls	r3, r3, #24
 800ca84:	431a      	orrs	r2, r3
 800ca86:	69fb      	ldr	r3, [r7, #28]
 800ca88:	071b      	lsls	r3, r3, #28
 800ca8a:	4929      	ldr	r1, [pc, #164]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800ca8c:	4313      	orrs	r3, r2
 800ca8e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    }

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 800ca92:	687b      	ldr	r3, [r7, #4]
 800ca94:	681b      	ldr	r3, [r3, #0]
 800ca96:	f003 0308 	and.w	r3, r3, #8
 800ca9a:	2b00      	cmp	r3, #0
 800ca9c:	d028      	beq.n	800caf0 <HAL_RCCEx_PeriphCLKConfig+0x80c>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));

      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 800ca9e:	4b24      	ldr	r3, [pc, #144]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800caa0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800caa4:	0e1b      	lsrs	r3, r3, #24
 800caa6:	f003 030f 	and.w	r3, r3, #15
 800caaa:	61bb      	str	r3, [r7, #24]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 800caac:	4b20      	ldr	r3, [pc, #128]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800caae:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800cab2:	0c1b      	lsrs	r3, r3, #16
 800cab4:	f003 0303 	and.w	r3, r3, #3
 800cab8:	61fb      	str	r3, [r7, #28]

      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 800caba:	687b      	ldr	r3, [r7, #4]
 800cabc:	695b      	ldr	r3, [r3, #20]
 800cabe:	019a      	lsls	r2, r3, #6
 800cac0:	69fb      	ldr	r3, [r7, #28]
 800cac2:	041b      	lsls	r3, r3, #16
 800cac4:	431a      	orrs	r2, r3
 800cac6:	69bb      	ldr	r3, [r7, #24]
 800cac8:	061b      	lsls	r3, r3, #24
 800caca:	431a      	orrs	r2, r3
 800cacc:	687b      	ldr	r3, [r7, #4]
 800cace:	69db      	ldr	r3, [r3, #28]
 800cad0:	071b      	lsls	r3, r3, #28
 800cad2:	4917      	ldr	r1, [pc, #92]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800cad4:	4313      	orrs	r3, r2
 800cad6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 800cada:	4b15      	ldr	r3, [pc, #84]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800cadc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800cae0:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 800cae4:	687b      	ldr	r3, [r7, #4]
 800cae6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800cae8:	4911      	ldr	r1, [pc, #68]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800caea:	4313      	orrs	r3, r2
 800caec:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  */

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
 800caf0:	4b0f      	ldr	r3, [pc, #60]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800caf2:	681b      	ldr	r3, [r3, #0]
 800caf4:	4a0e      	ldr	r2, [pc, #56]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800caf6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800cafa:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800cafc:	f7f5 f93c 	bl	8001d78 <HAL_GetTick>
 800cb00:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800cb02:	e008      	b.n	800cb16 <HAL_RCCEx_PeriphCLKConfig+0x832>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 800cb04:	f7f5 f938 	bl	8001d78 <HAL_GetTick>
 800cb08:	4602      	mov	r2, r0
 800cb0a:	697b      	ldr	r3, [r7, #20]
 800cb0c:	1ad3      	subs	r3, r2, r3
 800cb0e:	2b64      	cmp	r3, #100	; 0x64
 800cb10:	d901      	bls.n	800cb16 <HAL_RCCEx_PeriphCLKConfig+0x832>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800cb12:	2303      	movs	r3, #3
 800cb14:	e007      	b.n	800cb26 <HAL_RCCEx_PeriphCLKConfig+0x842>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800cb16:	4b06      	ldr	r3, [pc, #24]	; (800cb30 <HAL_RCCEx_PeriphCLKConfig+0x84c>)
 800cb18:	681b      	ldr	r3, [r3, #0]
 800cb1a:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800cb1e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800cb22:	d1ef      	bne.n	800cb04 <HAL_RCCEx_PeriphCLKConfig+0x820>
      }
    }
  }
  return HAL_OK;
 800cb24:	2300      	movs	r3, #0
}
 800cb26:	4618      	mov	r0, r3
 800cb28:	3720      	adds	r7, #32
 800cb2a:	46bd      	mov	sp, r7
 800cb2c:	bd80      	pop	{r7, pc}
 800cb2e:	bf00      	nop
 800cb30:	40023800 	.word	0x40023800

0800cb34 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 800cb34:	b580      	push	{r7, lr}
 800cb36:	b082      	sub	sp, #8
 800cb38:	af00      	add	r7, sp, #0
 800cb3a:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800cb3c:	687b      	ldr	r3, [r7, #4]
 800cb3e:	2b00      	cmp	r3, #0
 800cb40:	d101      	bne.n	800cb46 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 800cb42:	2301      	movs	r3, #1
 800cb44:	e039      	b.n	800cbba <HAL_TIM_Base_Init+0x86>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800cb46:	687b      	ldr	r3, [r7, #4]
 800cb48:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800cb4a:	2b00      	cmp	r3, #0
 800cb4c:	d105      	bne.n	800cb5a <HAL_TIM_Base_Init+0x26>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800cb4e:	687b      	ldr	r3, [r7, #4]
 800cb50:	2200      	movs	r2, #0
 800cb52:	63da      	str	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 800cb54:	6878      	ldr	r0, [r7, #4]
 800cb56:	f7f4 fe9d 	bl	8001894 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800cb5a:	687b      	ldr	r3, [r7, #4]
 800cb5c:	2202      	movs	r2, #2
 800cb5e:	641a      	str	r2, [r3, #64]	; 0x40

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800cb60:	687b      	ldr	r3, [r7, #4]
 800cb62:	681a      	ldr	r2, [r3, #0]
 800cb64:	687b      	ldr	r3, [r7, #4]
 800cb66:	3304      	adds	r3, #4
 800cb68:	4619      	mov	r1, r3
 800cb6a:	4610      	mov	r0, r2
 800cb6c:	f000 faac 	bl	800d0c8 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800cb70:	687b      	ldr	r3, [r7, #4]
 800cb72:	2201      	movs	r2, #1
 800cb74:	66da      	str	r2, [r3, #108]	; 0x6c

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800cb76:	687b      	ldr	r3, [r7, #4]
 800cb78:	2201      	movs	r2, #1
 800cb7a:	645a      	str	r2, [r3, #68]	; 0x44
 800cb7c:	687b      	ldr	r3, [r7, #4]
 800cb7e:	2201      	movs	r2, #1
 800cb80:	649a      	str	r2, [r3, #72]	; 0x48
 800cb82:	687b      	ldr	r3, [r7, #4]
 800cb84:	2201      	movs	r2, #1
 800cb86:	64da      	str	r2, [r3, #76]	; 0x4c
 800cb88:	687b      	ldr	r3, [r7, #4]
 800cb8a:	2201      	movs	r2, #1
 800cb8c:	651a      	str	r2, [r3, #80]	; 0x50
 800cb8e:	687b      	ldr	r3, [r7, #4]
 800cb90:	2201      	movs	r2, #1
 800cb92:	655a      	str	r2, [r3, #84]	; 0x54
 800cb94:	687b      	ldr	r3, [r7, #4]
 800cb96:	2201      	movs	r2, #1
 800cb98:	659a      	str	r2, [r3, #88]	; 0x58
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800cb9a:	687b      	ldr	r3, [r7, #4]
 800cb9c:	2201      	movs	r2, #1
 800cb9e:	65da      	str	r2, [r3, #92]	; 0x5c
 800cba0:	687b      	ldr	r3, [r7, #4]
 800cba2:	2201      	movs	r2, #1
 800cba4:	661a      	str	r2, [r3, #96]	; 0x60
 800cba6:	687b      	ldr	r3, [r7, #4]
 800cba8:	2201      	movs	r2, #1
 800cbaa:	665a      	str	r2, [r3, #100]	; 0x64
 800cbac:	687b      	ldr	r3, [r7, #4]
 800cbae:	2201      	movs	r2, #1
 800cbb0:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800cbb2:	687b      	ldr	r3, [r7, #4]
 800cbb4:	2201      	movs	r2, #1
 800cbb6:	641a      	str	r2, [r3, #64]	; 0x40

  return HAL_OK;
 800cbb8:	2300      	movs	r3, #0
}
 800cbba:	4618      	mov	r0, r3
 800cbbc:	3708      	adds	r7, #8
 800cbbe:	46bd      	mov	sp, r7
 800cbc0:	bd80      	pop	{r7, pc}
	...

0800cbc4 <HAL_TIM_Base_Start>:
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
 800cbc4:	b480      	push	{r7}
 800cbc6:	b085      	sub	sp, #20
 800cbc8:	af00      	add	r7, sp, #0
 800cbca:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 800cbcc:	687b      	ldr	r3, [r7, #4]
 800cbce:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800cbd0:	2b01      	cmp	r3, #1
 800cbd2:	d001      	beq.n	800cbd8 <HAL_TIM_Base_Start+0x14>
  {
    return HAL_ERROR;
 800cbd4:	2301      	movs	r3, #1
 800cbd6:	e04b      	b.n	800cc70 <HAL_TIM_Base_Start+0xac>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800cbd8:	687b      	ldr	r3, [r7, #4]
 800cbda:	2202      	movs	r2, #2
 800cbdc:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800cbde:	687b      	ldr	r3, [r7, #4]
 800cbe0:	681b      	ldr	r3, [r3, #0]
 800cbe2:	4a26      	ldr	r2, [pc, #152]	; (800cc7c <HAL_TIM_Base_Start+0xb8>)
 800cbe4:	4293      	cmp	r3, r2
 800cbe6:	d022      	beq.n	800cc2e <HAL_TIM_Base_Start+0x6a>
 800cbe8:	687b      	ldr	r3, [r7, #4]
 800cbea:	681b      	ldr	r3, [r3, #0]
 800cbec:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800cbf0:	d01d      	beq.n	800cc2e <HAL_TIM_Base_Start+0x6a>
 800cbf2:	687b      	ldr	r3, [r7, #4]
 800cbf4:	681b      	ldr	r3, [r3, #0]
 800cbf6:	4a22      	ldr	r2, [pc, #136]	; (800cc80 <HAL_TIM_Base_Start+0xbc>)
 800cbf8:	4293      	cmp	r3, r2
 800cbfa:	d018      	beq.n	800cc2e <HAL_TIM_Base_Start+0x6a>
 800cbfc:	687b      	ldr	r3, [r7, #4]
 800cbfe:	681b      	ldr	r3, [r3, #0]
 800cc00:	4a20      	ldr	r2, [pc, #128]	; (800cc84 <HAL_TIM_Base_Start+0xc0>)
 800cc02:	4293      	cmp	r3, r2
 800cc04:	d013      	beq.n	800cc2e <HAL_TIM_Base_Start+0x6a>
 800cc06:	687b      	ldr	r3, [r7, #4]
 800cc08:	681b      	ldr	r3, [r3, #0]
 800cc0a:	4a1f      	ldr	r2, [pc, #124]	; (800cc88 <HAL_TIM_Base_Start+0xc4>)
 800cc0c:	4293      	cmp	r3, r2
 800cc0e:	d00e      	beq.n	800cc2e <HAL_TIM_Base_Start+0x6a>
 800cc10:	687b      	ldr	r3, [r7, #4]
 800cc12:	681b      	ldr	r3, [r3, #0]
 800cc14:	4a1d      	ldr	r2, [pc, #116]	; (800cc8c <HAL_TIM_Base_Start+0xc8>)
 800cc16:	4293      	cmp	r3, r2
 800cc18:	d009      	beq.n	800cc2e <HAL_TIM_Base_Start+0x6a>
 800cc1a:	687b      	ldr	r3, [r7, #4]
 800cc1c:	681b      	ldr	r3, [r3, #0]
 800cc1e:	4a1c      	ldr	r2, [pc, #112]	; (800cc90 <HAL_TIM_Base_Start+0xcc>)
 800cc20:	4293      	cmp	r3, r2
 800cc22:	d004      	beq.n	800cc2e <HAL_TIM_Base_Start+0x6a>
 800cc24:	687b      	ldr	r3, [r7, #4]
 800cc26:	681b      	ldr	r3, [r3, #0]
 800cc28:	4a1a      	ldr	r2, [pc, #104]	; (800cc94 <HAL_TIM_Base_Start+0xd0>)
 800cc2a:	4293      	cmp	r3, r2
 800cc2c:	d115      	bne.n	800cc5a <HAL_TIM_Base_Start+0x96>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800cc2e:	687b      	ldr	r3, [r7, #4]
 800cc30:	681b      	ldr	r3, [r3, #0]
 800cc32:	689a      	ldr	r2, [r3, #8]
 800cc34:	4b18      	ldr	r3, [pc, #96]	; (800cc98 <HAL_TIM_Base_Start+0xd4>)
 800cc36:	4013      	ands	r3, r2
 800cc38:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800cc3a:	68fb      	ldr	r3, [r7, #12]
 800cc3c:	2b06      	cmp	r3, #6
 800cc3e:	d015      	beq.n	800cc6c <HAL_TIM_Base_Start+0xa8>
 800cc40:	68fb      	ldr	r3, [r7, #12]
 800cc42:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800cc46:	d011      	beq.n	800cc6c <HAL_TIM_Base_Start+0xa8>
    {
      __HAL_TIM_ENABLE(htim);
 800cc48:	687b      	ldr	r3, [r7, #4]
 800cc4a:	681b      	ldr	r3, [r3, #0]
 800cc4c:	681a      	ldr	r2, [r3, #0]
 800cc4e:	687b      	ldr	r3, [r7, #4]
 800cc50:	681b      	ldr	r3, [r3, #0]
 800cc52:	f042 0201 	orr.w	r2, r2, #1
 800cc56:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800cc58:	e008      	b.n	800cc6c <HAL_TIM_Base_Start+0xa8>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 800cc5a:	687b      	ldr	r3, [r7, #4]
 800cc5c:	681b      	ldr	r3, [r3, #0]
 800cc5e:	681a      	ldr	r2, [r3, #0]
 800cc60:	687b      	ldr	r3, [r7, #4]
 800cc62:	681b      	ldr	r3, [r3, #0]
 800cc64:	f042 0201 	orr.w	r2, r2, #1
 800cc68:	601a      	str	r2, [r3, #0]
 800cc6a:	e000      	b.n	800cc6e <HAL_TIM_Base_Start+0xaa>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800cc6c:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 800cc6e:	2300      	movs	r3, #0
}
 800cc70:	4618      	mov	r0, r3
 800cc72:	3714      	adds	r7, #20
 800cc74:	46bd      	mov	sp, r7
 800cc76:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc7a:	4770      	bx	lr
 800cc7c:	40010000 	.word	0x40010000
 800cc80:	40000400 	.word	0x40000400
 800cc84:	40000800 	.word	0x40000800
 800cc88:	40000c00 	.word	0x40000c00
 800cc8c:	40010400 	.word	0x40010400
 800cc90:	40014000 	.word	0x40014000
 800cc94:	40001800 	.word	0x40001800
 800cc98:	00010007 	.word	0x00010007

0800cc9c <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 800cc9c:	b580      	push	{r7, lr}
 800cc9e:	b082      	sub	sp, #8
 800cca0:	af00      	add	r7, sp, #0
 800cca2:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800cca4:	687b      	ldr	r3, [r7, #4]
 800cca6:	681b      	ldr	r3, [r3, #0]
 800cca8:	691b      	ldr	r3, [r3, #16]
 800ccaa:	f003 0302 	and.w	r3, r3, #2
 800ccae:	2b02      	cmp	r3, #2
 800ccb0:	d122      	bne.n	800ccf8 <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800ccb2:	687b      	ldr	r3, [r7, #4]
 800ccb4:	681b      	ldr	r3, [r3, #0]
 800ccb6:	68db      	ldr	r3, [r3, #12]
 800ccb8:	f003 0302 	and.w	r3, r3, #2
 800ccbc:	2b02      	cmp	r3, #2
 800ccbe:	d11b      	bne.n	800ccf8 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800ccc0:	687b      	ldr	r3, [r7, #4]
 800ccc2:	681b      	ldr	r3, [r3, #0]
 800ccc4:	f06f 0202 	mvn.w	r2, #2
 800ccc8:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800ccca:	687b      	ldr	r3, [r7, #4]
 800cccc:	2201      	movs	r2, #1
 800ccce:	61da      	str	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800ccd0:	687b      	ldr	r3, [r7, #4]
 800ccd2:	681b      	ldr	r3, [r3, #0]
 800ccd4:	699b      	ldr	r3, [r3, #24]
 800ccd6:	f003 0303 	and.w	r3, r3, #3
 800ccda:	2b00      	cmp	r3, #0
 800ccdc:	d003      	beq.n	800cce6 <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 800ccde:	6878      	ldr	r0, [r7, #4]
 800cce0:	f000 f9d4 	bl	800d08c <HAL_TIM_IC_CaptureCallback>
 800cce4:	e005      	b.n	800ccf2 <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800cce6:	6878      	ldr	r0, [r7, #4]
 800cce8:	f000 f9c6 	bl	800d078 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800ccec:	6878      	ldr	r0, [r7, #4]
 800ccee:	f000 f9d7 	bl	800d0a0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800ccf2:	687b      	ldr	r3, [r7, #4]
 800ccf4:	2200      	movs	r2, #0
 800ccf6:	61da      	str	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800ccf8:	687b      	ldr	r3, [r7, #4]
 800ccfa:	681b      	ldr	r3, [r3, #0]
 800ccfc:	691b      	ldr	r3, [r3, #16]
 800ccfe:	f003 0304 	and.w	r3, r3, #4
 800cd02:	2b04      	cmp	r3, #4
 800cd04:	d122      	bne.n	800cd4c <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 800cd06:	687b      	ldr	r3, [r7, #4]
 800cd08:	681b      	ldr	r3, [r3, #0]
 800cd0a:	68db      	ldr	r3, [r3, #12]
 800cd0c:	f003 0304 	and.w	r3, r3, #4
 800cd10:	2b04      	cmp	r3, #4
 800cd12:	d11b      	bne.n	800cd4c <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800cd14:	687b      	ldr	r3, [r7, #4]
 800cd16:	681b      	ldr	r3, [r3, #0]
 800cd18:	f06f 0204 	mvn.w	r2, #4
 800cd1c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800cd1e:	687b      	ldr	r3, [r7, #4]
 800cd20:	2202      	movs	r2, #2
 800cd22:	61da      	str	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800cd24:	687b      	ldr	r3, [r7, #4]
 800cd26:	681b      	ldr	r3, [r3, #0]
 800cd28:	699b      	ldr	r3, [r3, #24]
 800cd2a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800cd2e:	2b00      	cmp	r3, #0
 800cd30:	d003      	beq.n	800cd3a <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800cd32:	6878      	ldr	r0, [r7, #4]
 800cd34:	f000 f9aa 	bl	800d08c <HAL_TIM_IC_CaptureCallback>
 800cd38:	e005      	b.n	800cd46 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800cd3a:	6878      	ldr	r0, [r7, #4]
 800cd3c:	f000 f99c 	bl	800d078 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800cd40:	6878      	ldr	r0, [r7, #4]
 800cd42:	f000 f9ad 	bl	800d0a0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800cd46:	687b      	ldr	r3, [r7, #4]
 800cd48:	2200      	movs	r2, #0
 800cd4a:	61da      	str	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800cd4c:	687b      	ldr	r3, [r7, #4]
 800cd4e:	681b      	ldr	r3, [r3, #0]
 800cd50:	691b      	ldr	r3, [r3, #16]
 800cd52:	f003 0308 	and.w	r3, r3, #8
 800cd56:	2b08      	cmp	r3, #8
 800cd58:	d122      	bne.n	800cda0 <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800cd5a:	687b      	ldr	r3, [r7, #4]
 800cd5c:	681b      	ldr	r3, [r3, #0]
 800cd5e:	68db      	ldr	r3, [r3, #12]
 800cd60:	f003 0308 	and.w	r3, r3, #8
 800cd64:	2b08      	cmp	r3, #8
 800cd66:	d11b      	bne.n	800cda0 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800cd68:	687b      	ldr	r3, [r7, #4]
 800cd6a:	681b      	ldr	r3, [r3, #0]
 800cd6c:	f06f 0208 	mvn.w	r2, #8
 800cd70:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800cd72:	687b      	ldr	r3, [r7, #4]
 800cd74:	2204      	movs	r2, #4
 800cd76:	61da      	str	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800cd78:	687b      	ldr	r3, [r7, #4]
 800cd7a:	681b      	ldr	r3, [r3, #0]
 800cd7c:	69db      	ldr	r3, [r3, #28]
 800cd7e:	f003 0303 	and.w	r3, r3, #3
 800cd82:	2b00      	cmp	r3, #0
 800cd84:	d003      	beq.n	800cd8e <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800cd86:	6878      	ldr	r0, [r7, #4]
 800cd88:	f000 f980 	bl	800d08c <HAL_TIM_IC_CaptureCallback>
 800cd8c:	e005      	b.n	800cd9a <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800cd8e:	6878      	ldr	r0, [r7, #4]
 800cd90:	f000 f972 	bl	800d078 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800cd94:	6878      	ldr	r0, [r7, #4]
 800cd96:	f000 f983 	bl	800d0a0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800cd9a:	687b      	ldr	r3, [r7, #4]
 800cd9c:	2200      	movs	r2, #0
 800cd9e:	61da      	str	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800cda0:	687b      	ldr	r3, [r7, #4]
 800cda2:	681b      	ldr	r3, [r3, #0]
 800cda4:	691b      	ldr	r3, [r3, #16]
 800cda6:	f003 0310 	and.w	r3, r3, #16
 800cdaa:	2b10      	cmp	r3, #16
 800cdac:	d122      	bne.n	800cdf4 <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 800cdae:	687b      	ldr	r3, [r7, #4]
 800cdb0:	681b      	ldr	r3, [r3, #0]
 800cdb2:	68db      	ldr	r3, [r3, #12]
 800cdb4:	f003 0310 	and.w	r3, r3, #16
 800cdb8:	2b10      	cmp	r3, #16
 800cdba:	d11b      	bne.n	800cdf4 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800cdbc:	687b      	ldr	r3, [r7, #4]
 800cdbe:	681b      	ldr	r3, [r3, #0]
 800cdc0:	f06f 0210 	mvn.w	r2, #16
 800cdc4:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800cdc6:	687b      	ldr	r3, [r7, #4]
 800cdc8:	2208      	movs	r2, #8
 800cdca:	61da      	str	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800cdcc:	687b      	ldr	r3, [r7, #4]
 800cdce:	681b      	ldr	r3, [r3, #0]
 800cdd0:	69db      	ldr	r3, [r3, #28]
 800cdd2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800cdd6:	2b00      	cmp	r3, #0
 800cdd8:	d003      	beq.n	800cde2 <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800cdda:	6878      	ldr	r0, [r7, #4]
 800cddc:	f000 f956 	bl	800d08c <HAL_TIM_IC_CaptureCallback>
 800cde0:	e005      	b.n	800cdee <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800cde2:	6878      	ldr	r0, [r7, #4]
 800cde4:	f000 f948 	bl	800d078 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800cde8:	6878      	ldr	r0, [r7, #4]
 800cdea:	f000 f959 	bl	800d0a0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800cdee:	687b      	ldr	r3, [r7, #4]
 800cdf0:	2200      	movs	r2, #0
 800cdf2:	61da      	str	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800cdf4:	687b      	ldr	r3, [r7, #4]
 800cdf6:	681b      	ldr	r3, [r3, #0]
 800cdf8:	691b      	ldr	r3, [r3, #16]
 800cdfa:	f003 0301 	and.w	r3, r3, #1
 800cdfe:	2b01      	cmp	r3, #1
 800ce00:	d10e      	bne.n	800ce20 <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800ce02:	687b      	ldr	r3, [r7, #4]
 800ce04:	681b      	ldr	r3, [r3, #0]
 800ce06:	68db      	ldr	r3, [r3, #12]
 800ce08:	f003 0301 	and.w	r3, r3, #1
 800ce0c:	2b01      	cmp	r3, #1
 800ce0e:	d107      	bne.n	800ce20 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800ce10:	687b      	ldr	r3, [r7, #4]
 800ce12:	681b      	ldr	r3, [r3, #0]
 800ce14:	f06f 0201 	mvn.w	r2, #1
 800ce18:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800ce1a:	6878      	ldr	r0, [r7, #4]
 800ce1c:	f000 f922 	bl	800d064 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800ce20:	687b      	ldr	r3, [r7, #4]
 800ce22:	681b      	ldr	r3, [r3, #0]
 800ce24:	691b      	ldr	r3, [r3, #16]
 800ce26:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ce2a:	2b80      	cmp	r3, #128	; 0x80
 800ce2c:	d10e      	bne.n	800ce4c <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800ce2e:	687b      	ldr	r3, [r7, #4]
 800ce30:	681b      	ldr	r3, [r3, #0]
 800ce32:	68db      	ldr	r3, [r3, #12]
 800ce34:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ce38:	2b80      	cmp	r3, #128	; 0x80
 800ce3a:	d107      	bne.n	800ce4c <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800ce3c:	687b      	ldr	r3, [r7, #4]
 800ce3e:	681b      	ldr	r3, [r3, #0]
 800ce40:	f06f 0280 	mvn.w	r2, #128	; 0x80
 800ce44:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 800ce46:	6878      	ldr	r0, [r7, #4]
 800ce48:	f000 fff0 	bl	800de2c <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800ce4c:	687b      	ldr	r3, [r7, #4]
 800ce4e:	681b      	ldr	r3, [r3, #0]
 800ce50:	691b      	ldr	r3, [r3, #16]
 800ce52:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ce56:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800ce5a:	d10e      	bne.n	800ce7a <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800ce5c:	687b      	ldr	r3, [r7, #4]
 800ce5e:	681b      	ldr	r3, [r3, #0]
 800ce60:	68db      	ldr	r3, [r3, #12]
 800ce62:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ce66:	2b80      	cmp	r3, #128	; 0x80
 800ce68:	d107      	bne.n	800ce7a <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800ce6a:	687b      	ldr	r3, [r7, #4]
 800ce6c:	681b      	ldr	r3, [r3, #0]
 800ce6e:	f46f 7280 	mvn.w	r2, #256	; 0x100
 800ce72:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 800ce74:	6878      	ldr	r0, [r7, #4]
 800ce76:	f000 ffe3 	bl	800de40 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800ce7a:	687b      	ldr	r3, [r7, #4]
 800ce7c:	681b      	ldr	r3, [r3, #0]
 800ce7e:	691b      	ldr	r3, [r3, #16]
 800ce80:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ce84:	2b40      	cmp	r3, #64	; 0x40
 800ce86:	d10e      	bne.n	800cea6 <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 800ce88:	687b      	ldr	r3, [r7, #4]
 800ce8a:	681b      	ldr	r3, [r3, #0]
 800ce8c:	68db      	ldr	r3, [r3, #12]
 800ce8e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ce92:	2b40      	cmp	r3, #64	; 0x40
 800ce94:	d107      	bne.n	800cea6 <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800ce96:	687b      	ldr	r3, [r7, #4]
 800ce98:	681b      	ldr	r3, [r3, #0]
 800ce9a:	f06f 0240 	mvn.w	r2, #64	; 0x40
 800ce9e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 800cea0:	6878      	ldr	r0, [r7, #4]
 800cea2:	f000 f907 	bl	800d0b4 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800cea6:	687b      	ldr	r3, [r7, #4]
 800cea8:	681b      	ldr	r3, [r3, #0]
 800ceaa:	691b      	ldr	r3, [r3, #16]
 800ceac:	f003 0320 	and.w	r3, r3, #32
 800ceb0:	2b20      	cmp	r3, #32
 800ceb2:	d10e      	bne.n	800ced2 <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 800ceb4:	687b      	ldr	r3, [r7, #4]
 800ceb6:	681b      	ldr	r3, [r3, #0]
 800ceb8:	68db      	ldr	r3, [r3, #12]
 800ceba:	f003 0320 	and.w	r3, r3, #32
 800cebe:	2b20      	cmp	r3, #32
 800cec0:	d107      	bne.n	800ced2 <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800cec2:	687b      	ldr	r3, [r7, #4]
 800cec4:	681b      	ldr	r3, [r3, #0]
 800cec6:	f06f 0220 	mvn.w	r2, #32
 800ceca:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 800cecc:	6878      	ldr	r0, [r7, #4]
 800cece:	f000 ffa3 	bl	800de18 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 800ced2:	bf00      	nop
 800ced4:	3708      	adds	r7, #8
 800ced6:	46bd      	mov	sp, r7
 800ced8:	bd80      	pop	{r7, pc}
	...

0800cedc <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 800cedc:	b580      	push	{r7, lr}
 800cede:	b084      	sub	sp, #16
 800cee0:	af00      	add	r7, sp, #0
 800cee2:	6078      	str	r0, [r7, #4]
 800cee4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800cee6:	2300      	movs	r3, #0
 800cee8:	60bb      	str	r3, [r7, #8]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 800ceea:	687b      	ldr	r3, [r7, #4]
 800ceec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ceee:	2b01      	cmp	r3, #1
 800cef0:	d101      	bne.n	800cef6 <HAL_TIM_ConfigClockSource+0x1a>
 800cef2:	2302      	movs	r3, #2
 800cef4:	e0b0      	b.n	800d058 <HAL_TIM_ConfigClockSource+0x17c>
 800cef6:	687b      	ldr	r3, [r7, #4]
 800cef8:	2201      	movs	r2, #1
 800cefa:	63da      	str	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 800cefc:	687b      	ldr	r3, [r7, #4]
 800cefe:	2202      	movs	r2, #2
 800cf00:	641a      	str	r2, [r3, #64]	; 0x40

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 800cf02:	687b      	ldr	r3, [r7, #4]
 800cf04:	681b      	ldr	r3, [r3, #0]
 800cf06:	689b      	ldr	r3, [r3, #8]
 800cf08:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 800cf0a:	68fa      	ldr	r2, [r7, #12]
 800cf0c:	4b54      	ldr	r3, [pc, #336]	; (800d060 <HAL_TIM_ConfigClockSource+0x184>)
 800cf0e:	4013      	ands	r3, r2
 800cf10:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800cf12:	68fb      	ldr	r3, [r7, #12]
 800cf14:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800cf18:	60fb      	str	r3, [r7, #12]
  htim->Instance->SMCR = tmpsmcr;
 800cf1a:	687b      	ldr	r3, [r7, #4]
 800cf1c:	681b      	ldr	r3, [r3, #0]
 800cf1e:	68fa      	ldr	r2, [r7, #12]
 800cf20:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 800cf22:	683b      	ldr	r3, [r7, #0]
 800cf24:	681b      	ldr	r3, [r3, #0]
 800cf26:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800cf2a:	d03e      	beq.n	800cfaa <HAL_TIM_ConfigClockSource+0xce>
 800cf2c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800cf30:	f200 8087 	bhi.w	800d042 <HAL_TIM_ConfigClockSource+0x166>
 800cf34:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800cf38:	f000 8086 	beq.w	800d048 <HAL_TIM_ConfigClockSource+0x16c>
 800cf3c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800cf40:	d87f      	bhi.n	800d042 <HAL_TIM_ConfigClockSource+0x166>
 800cf42:	2b70      	cmp	r3, #112	; 0x70
 800cf44:	d01a      	beq.n	800cf7c <HAL_TIM_ConfigClockSource+0xa0>
 800cf46:	2b70      	cmp	r3, #112	; 0x70
 800cf48:	d87b      	bhi.n	800d042 <HAL_TIM_ConfigClockSource+0x166>
 800cf4a:	2b60      	cmp	r3, #96	; 0x60
 800cf4c:	d050      	beq.n	800cff0 <HAL_TIM_ConfigClockSource+0x114>
 800cf4e:	2b60      	cmp	r3, #96	; 0x60
 800cf50:	d877      	bhi.n	800d042 <HAL_TIM_ConfigClockSource+0x166>
 800cf52:	2b50      	cmp	r3, #80	; 0x50
 800cf54:	d03c      	beq.n	800cfd0 <HAL_TIM_ConfigClockSource+0xf4>
 800cf56:	2b50      	cmp	r3, #80	; 0x50
 800cf58:	d873      	bhi.n	800d042 <HAL_TIM_ConfigClockSource+0x166>
 800cf5a:	2b40      	cmp	r3, #64	; 0x40
 800cf5c:	d058      	beq.n	800d010 <HAL_TIM_ConfigClockSource+0x134>
 800cf5e:	2b40      	cmp	r3, #64	; 0x40
 800cf60:	d86f      	bhi.n	800d042 <HAL_TIM_ConfigClockSource+0x166>
 800cf62:	2b30      	cmp	r3, #48	; 0x30
 800cf64:	d064      	beq.n	800d030 <HAL_TIM_ConfigClockSource+0x154>
 800cf66:	2b30      	cmp	r3, #48	; 0x30
 800cf68:	d86b      	bhi.n	800d042 <HAL_TIM_ConfigClockSource+0x166>
 800cf6a:	2b20      	cmp	r3, #32
 800cf6c:	d060      	beq.n	800d030 <HAL_TIM_ConfigClockSource+0x154>
 800cf6e:	2b20      	cmp	r3, #32
 800cf70:	d867      	bhi.n	800d042 <HAL_TIM_ConfigClockSource+0x166>
 800cf72:	2b00      	cmp	r3, #0
 800cf74:	d05c      	beq.n	800d030 <HAL_TIM_ConfigClockSource+0x154>
 800cf76:	2b10      	cmp	r3, #16
 800cf78:	d05a      	beq.n	800d030 <HAL_TIM_ConfigClockSource+0x154>
 800cf7a:	e062      	b.n	800d042 <HAL_TIM_ConfigClockSource+0x166>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800cf7c:	687b      	ldr	r3, [r7, #4]
 800cf7e:	6818      	ldr	r0, [r3, #0]
 800cf80:	683b      	ldr	r3, [r7, #0]
 800cf82:	6899      	ldr	r1, [r3, #8]
 800cf84:	683b      	ldr	r3, [r7, #0]
 800cf86:	685a      	ldr	r2, [r3, #4]
 800cf88:	683b      	ldr	r3, [r7, #0]
 800cf8a:	68db      	ldr	r3, [r3, #12]
 800cf8c:	f000 f9b6 	bl	800d2fc <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
 800cf90:	687b      	ldr	r3, [r7, #4]
 800cf92:	681b      	ldr	r3, [r3, #0]
 800cf94:	689b      	ldr	r3, [r3, #8]
 800cf96:	60fb      	str	r3, [r7, #12]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800cf98:	68fb      	ldr	r3, [r7, #12]
 800cf9a:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 800cf9e:	60fb      	str	r3, [r7, #12]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 800cfa0:	687b      	ldr	r3, [r7, #4]
 800cfa2:	681b      	ldr	r3, [r3, #0]
 800cfa4:	68fa      	ldr	r2, [r7, #12]
 800cfa6:	609a      	str	r2, [r3, #8]
      break;
 800cfa8:	e04f      	b.n	800d04a <HAL_TIM_ConfigClockSource+0x16e>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800cfaa:	687b      	ldr	r3, [r7, #4]
 800cfac:	6818      	ldr	r0, [r3, #0]
 800cfae:	683b      	ldr	r3, [r7, #0]
 800cfb0:	6899      	ldr	r1, [r3, #8]
 800cfb2:	683b      	ldr	r3, [r7, #0]
 800cfb4:	685a      	ldr	r2, [r3, #4]
 800cfb6:	683b      	ldr	r3, [r7, #0]
 800cfb8:	68db      	ldr	r3, [r3, #12]
 800cfba:	f000 f99f 	bl	800d2fc <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800cfbe:	687b      	ldr	r3, [r7, #4]
 800cfc0:	681b      	ldr	r3, [r3, #0]
 800cfc2:	689a      	ldr	r2, [r3, #8]
 800cfc4:	687b      	ldr	r3, [r7, #4]
 800cfc6:	681b      	ldr	r3, [r3, #0]
 800cfc8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800cfcc:	609a      	str	r2, [r3, #8]
      break;
 800cfce:	e03c      	b.n	800d04a <HAL_TIM_ConfigClockSource+0x16e>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800cfd0:	687b      	ldr	r3, [r7, #4]
 800cfd2:	6818      	ldr	r0, [r3, #0]
 800cfd4:	683b      	ldr	r3, [r7, #0]
 800cfd6:	6859      	ldr	r1, [r3, #4]
 800cfd8:	683b      	ldr	r3, [r7, #0]
 800cfda:	68db      	ldr	r3, [r3, #12]
 800cfdc:	461a      	mov	r2, r3
 800cfde:	f000 f913 	bl	800d208 <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 800cfe2:	687b      	ldr	r3, [r7, #4]
 800cfe4:	681b      	ldr	r3, [r3, #0]
 800cfe6:	2150      	movs	r1, #80	; 0x50
 800cfe8:	4618      	mov	r0, r3
 800cfea:	f000 f96c 	bl	800d2c6 <TIM_ITRx_SetConfig>
      break;
 800cfee:	e02c      	b.n	800d04a <HAL_TIM_ConfigClockSource+0x16e>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 800cff0:	687b      	ldr	r3, [r7, #4]
 800cff2:	6818      	ldr	r0, [r3, #0]
 800cff4:	683b      	ldr	r3, [r7, #0]
 800cff6:	6859      	ldr	r1, [r3, #4]
 800cff8:	683b      	ldr	r3, [r7, #0]
 800cffa:	68db      	ldr	r3, [r3, #12]
 800cffc:	461a      	mov	r2, r3
 800cffe:	f000 f932 	bl	800d266 <TIM_TI2_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 800d002:	687b      	ldr	r3, [r7, #4]
 800d004:	681b      	ldr	r3, [r3, #0]
 800d006:	2160      	movs	r1, #96	; 0x60
 800d008:	4618      	mov	r0, r3
 800d00a:	f000 f95c 	bl	800d2c6 <TIM_ITRx_SetConfig>
      break;
 800d00e:	e01c      	b.n	800d04a <HAL_TIM_ConfigClockSource+0x16e>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800d010:	687b      	ldr	r3, [r7, #4]
 800d012:	6818      	ldr	r0, [r3, #0]
 800d014:	683b      	ldr	r3, [r7, #0]
 800d016:	6859      	ldr	r1, [r3, #4]
 800d018:	683b      	ldr	r3, [r7, #0]
 800d01a:	68db      	ldr	r3, [r3, #12]
 800d01c:	461a      	mov	r2, r3
 800d01e:	f000 f8f3 	bl	800d208 <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 800d022:	687b      	ldr	r3, [r7, #4]
 800d024:	681b      	ldr	r3, [r3, #0]
 800d026:	2140      	movs	r1, #64	; 0x40
 800d028:	4618      	mov	r0, r3
 800d02a:	f000 f94c 	bl	800d2c6 <TIM_ITRx_SetConfig>
      break;
 800d02e:	e00c      	b.n	800d04a <HAL_TIM_ConfigClockSource+0x16e>
    case TIM_CLOCKSOURCE_ITR3:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 800d030:	687b      	ldr	r3, [r7, #4]
 800d032:	681a      	ldr	r2, [r3, #0]
 800d034:	683b      	ldr	r3, [r7, #0]
 800d036:	681b      	ldr	r3, [r3, #0]
 800d038:	4619      	mov	r1, r3
 800d03a:	4610      	mov	r0, r2
 800d03c:	f000 f943 	bl	800d2c6 <TIM_ITRx_SetConfig>
      break;
 800d040:	e003      	b.n	800d04a <HAL_TIM_ConfigClockSource+0x16e>
    }

    default:
      status = HAL_ERROR;
 800d042:	2301      	movs	r3, #1
 800d044:	60bb      	str	r3, [r7, #8]
      break;
 800d046:	e000      	b.n	800d04a <HAL_TIM_ConfigClockSource+0x16e>
      break;
 800d048:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 800d04a:	687b      	ldr	r3, [r7, #4]
 800d04c:	2201      	movs	r2, #1
 800d04e:	641a      	str	r2, [r3, #64]	; 0x40

  __HAL_UNLOCK(htim);
 800d050:	687b      	ldr	r3, [r7, #4]
 800d052:	2200      	movs	r2, #0
 800d054:	63da      	str	r2, [r3, #60]	; 0x3c

  return status;
 800d056:	68bb      	ldr	r3, [r7, #8]
}
 800d058:	4618      	mov	r0, r3
 800d05a:	3710      	adds	r7, #16
 800d05c:	46bd      	mov	sp, r7
 800d05e:	bd80      	pop	{r7, pc}
 800d060:	fffeff88 	.word	0xfffeff88

0800d064 <HAL_TIM_PeriodElapsedCallback>:
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 800d064:	b480      	push	{r7}
 800d066:	b083      	sub	sp, #12
 800d068:	af00      	add	r7, sp, #0
 800d06a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   */
}
 800d06c:	bf00      	nop
 800d06e:	370c      	adds	r7, #12
 800d070:	46bd      	mov	sp, r7
 800d072:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d076:	4770      	bx	lr

0800d078 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 800d078:	b480      	push	{r7}
 800d07a:	b083      	sub	sp, #12
 800d07c:	af00      	add	r7, sp, #0
 800d07e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 800d080:	bf00      	nop
 800d082:	370c      	adds	r7, #12
 800d084:	46bd      	mov	sp, r7
 800d086:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d08a:	4770      	bx	lr

0800d08c <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 800d08c:	b480      	push	{r7}
 800d08e:	b083      	sub	sp, #12
 800d090:	af00      	add	r7, sp, #0
 800d092:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800d094:	bf00      	nop
 800d096:	370c      	adds	r7, #12
 800d098:	46bd      	mov	sp, r7
 800d09a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d09e:	4770      	bx	lr

0800d0a0 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800d0a0:	b480      	push	{r7}
 800d0a2:	b083      	sub	sp, #12
 800d0a4:	af00      	add	r7, sp, #0
 800d0a6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 800d0a8:	bf00      	nop
 800d0aa:	370c      	adds	r7, #12
 800d0ac:	46bd      	mov	sp, r7
 800d0ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0b2:	4770      	bx	lr

0800d0b4 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 800d0b4:	b480      	push	{r7}
 800d0b6:	b083      	sub	sp, #12
 800d0b8:	af00      	add	r7, sp, #0
 800d0ba:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 800d0bc:	bf00      	nop
 800d0be:	370c      	adds	r7, #12
 800d0c0:	46bd      	mov	sp, r7
 800d0c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0c6:	4770      	bx	lr

0800d0c8 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 800d0c8:	b480      	push	{r7}
 800d0ca:	b085      	sub	sp, #20
 800d0cc:	af00      	add	r7, sp, #0
 800d0ce:	6078      	str	r0, [r7, #4]
 800d0d0:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800d0d2:	687b      	ldr	r3, [r7, #4]
 800d0d4:	681b      	ldr	r3, [r3, #0]
 800d0d6:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800d0d8:	687b      	ldr	r3, [r7, #4]
 800d0da:	4a40      	ldr	r2, [pc, #256]	; (800d1dc <TIM_Base_SetConfig+0x114>)
 800d0dc:	4293      	cmp	r3, r2
 800d0de:	d013      	beq.n	800d108 <TIM_Base_SetConfig+0x40>
 800d0e0:	687b      	ldr	r3, [r7, #4]
 800d0e2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800d0e6:	d00f      	beq.n	800d108 <TIM_Base_SetConfig+0x40>
 800d0e8:	687b      	ldr	r3, [r7, #4]
 800d0ea:	4a3d      	ldr	r2, [pc, #244]	; (800d1e0 <TIM_Base_SetConfig+0x118>)
 800d0ec:	4293      	cmp	r3, r2
 800d0ee:	d00b      	beq.n	800d108 <TIM_Base_SetConfig+0x40>
 800d0f0:	687b      	ldr	r3, [r7, #4]
 800d0f2:	4a3c      	ldr	r2, [pc, #240]	; (800d1e4 <TIM_Base_SetConfig+0x11c>)
 800d0f4:	4293      	cmp	r3, r2
 800d0f6:	d007      	beq.n	800d108 <TIM_Base_SetConfig+0x40>
 800d0f8:	687b      	ldr	r3, [r7, #4]
 800d0fa:	4a3b      	ldr	r2, [pc, #236]	; (800d1e8 <TIM_Base_SetConfig+0x120>)
 800d0fc:	4293      	cmp	r3, r2
 800d0fe:	d003      	beq.n	800d108 <TIM_Base_SetConfig+0x40>
 800d100:	687b      	ldr	r3, [r7, #4]
 800d102:	4a3a      	ldr	r2, [pc, #232]	; (800d1ec <TIM_Base_SetConfig+0x124>)
 800d104:	4293      	cmp	r3, r2
 800d106:	d108      	bne.n	800d11a <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800d108:	68fb      	ldr	r3, [r7, #12]
 800d10a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800d10e:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800d110:	683b      	ldr	r3, [r7, #0]
 800d112:	685b      	ldr	r3, [r3, #4]
 800d114:	68fa      	ldr	r2, [r7, #12]
 800d116:	4313      	orrs	r3, r2
 800d118:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800d11a:	687b      	ldr	r3, [r7, #4]
 800d11c:	4a2f      	ldr	r2, [pc, #188]	; (800d1dc <TIM_Base_SetConfig+0x114>)
 800d11e:	4293      	cmp	r3, r2
 800d120:	d02b      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d122:	687b      	ldr	r3, [r7, #4]
 800d124:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800d128:	d027      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d12a:	687b      	ldr	r3, [r7, #4]
 800d12c:	4a2c      	ldr	r2, [pc, #176]	; (800d1e0 <TIM_Base_SetConfig+0x118>)
 800d12e:	4293      	cmp	r3, r2
 800d130:	d023      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d132:	687b      	ldr	r3, [r7, #4]
 800d134:	4a2b      	ldr	r2, [pc, #172]	; (800d1e4 <TIM_Base_SetConfig+0x11c>)
 800d136:	4293      	cmp	r3, r2
 800d138:	d01f      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d13a:	687b      	ldr	r3, [r7, #4]
 800d13c:	4a2a      	ldr	r2, [pc, #168]	; (800d1e8 <TIM_Base_SetConfig+0x120>)
 800d13e:	4293      	cmp	r3, r2
 800d140:	d01b      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d142:	687b      	ldr	r3, [r7, #4]
 800d144:	4a29      	ldr	r2, [pc, #164]	; (800d1ec <TIM_Base_SetConfig+0x124>)
 800d146:	4293      	cmp	r3, r2
 800d148:	d017      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d14a:	687b      	ldr	r3, [r7, #4]
 800d14c:	4a28      	ldr	r2, [pc, #160]	; (800d1f0 <TIM_Base_SetConfig+0x128>)
 800d14e:	4293      	cmp	r3, r2
 800d150:	d013      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d152:	687b      	ldr	r3, [r7, #4]
 800d154:	4a27      	ldr	r2, [pc, #156]	; (800d1f4 <TIM_Base_SetConfig+0x12c>)
 800d156:	4293      	cmp	r3, r2
 800d158:	d00f      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d15a:	687b      	ldr	r3, [r7, #4]
 800d15c:	4a26      	ldr	r2, [pc, #152]	; (800d1f8 <TIM_Base_SetConfig+0x130>)
 800d15e:	4293      	cmp	r3, r2
 800d160:	d00b      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d162:	687b      	ldr	r3, [r7, #4]
 800d164:	4a25      	ldr	r2, [pc, #148]	; (800d1fc <TIM_Base_SetConfig+0x134>)
 800d166:	4293      	cmp	r3, r2
 800d168:	d007      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d16a:	687b      	ldr	r3, [r7, #4]
 800d16c:	4a24      	ldr	r2, [pc, #144]	; (800d200 <TIM_Base_SetConfig+0x138>)
 800d16e:	4293      	cmp	r3, r2
 800d170:	d003      	beq.n	800d17a <TIM_Base_SetConfig+0xb2>
 800d172:	687b      	ldr	r3, [r7, #4]
 800d174:	4a23      	ldr	r2, [pc, #140]	; (800d204 <TIM_Base_SetConfig+0x13c>)
 800d176:	4293      	cmp	r3, r2
 800d178:	d108      	bne.n	800d18c <TIM_Base_SetConfig+0xc4>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800d17a:	68fb      	ldr	r3, [r7, #12]
 800d17c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800d180:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800d182:	683b      	ldr	r3, [r7, #0]
 800d184:	68db      	ldr	r3, [r3, #12]
 800d186:	68fa      	ldr	r2, [r7, #12]
 800d188:	4313      	orrs	r3, r2
 800d18a:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800d18c:	68fb      	ldr	r3, [r7, #12]
 800d18e:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800d192:	683b      	ldr	r3, [r7, #0]
 800d194:	695b      	ldr	r3, [r3, #20]
 800d196:	4313      	orrs	r3, r2
 800d198:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 800d19a:	687b      	ldr	r3, [r7, #4]
 800d19c:	68fa      	ldr	r2, [r7, #12]
 800d19e:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800d1a0:	683b      	ldr	r3, [r7, #0]
 800d1a2:	689a      	ldr	r2, [r3, #8]
 800d1a4:	687b      	ldr	r3, [r7, #4]
 800d1a6:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800d1a8:	683b      	ldr	r3, [r7, #0]
 800d1aa:	681a      	ldr	r2, [r3, #0]
 800d1ac:	687b      	ldr	r3, [r7, #4]
 800d1ae:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800d1b0:	687b      	ldr	r3, [r7, #4]
 800d1b2:	4a0a      	ldr	r2, [pc, #40]	; (800d1dc <TIM_Base_SetConfig+0x114>)
 800d1b4:	4293      	cmp	r3, r2
 800d1b6:	d003      	beq.n	800d1c0 <TIM_Base_SetConfig+0xf8>
 800d1b8:	687b      	ldr	r3, [r7, #4]
 800d1ba:	4a0c      	ldr	r2, [pc, #48]	; (800d1ec <TIM_Base_SetConfig+0x124>)
 800d1bc:	4293      	cmp	r3, r2
 800d1be:	d103      	bne.n	800d1c8 <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800d1c0:	683b      	ldr	r3, [r7, #0]
 800d1c2:	691a      	ldr	r2, [r3, #16]
 800d1c4:	687b      	ldr	r3, [r7, #4]
 800d1c6:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800d1c8:	687b      	ldr	r3, [r7, #4]
 800d1ca:	2201      	movs	r2, #1
 800d1cc:	615a      	str	r2, [r3, #20]
}
 800d1ce:	bf00      	nop
 800d1d0:	3714      	adds	r7, #20
 800d1d2:	46bd      	mov	sp, r7
 800d1d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1d8:	4770      	bx	lr
 800d1da:	bf00      	nop
 800d1dc:	40010000 	.word	0x40010000
 800d1e0:	40000400 	.word	0x40000400
 800d1e4:	40000800 	.word	0x40000800
 800d1e8:	40000c00 	.word	0x40000c00
 800d1ec:	40010400 	.word	0x40010400
 800d1f0:	40014000 	.word	0x40014000
 800d1f4:	40014400 	.word	0x40014400
 800d1f8:	40014800 	.word	0x40014800
 800d1fc:	40001800 	.word	0x40001800
 800d200:	40001c00 	.word	0x40001c00
 800d204:	40002000 	.word	0x40002000

0800d208 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800d208:	b480      	push	{r7}
 800d20a:	b087      	sub	sp, #28
 800d20c:	af00      	add	r7, sp, #0
 800d20e:	60f8      	str	r0, [r7, #12]
 800d210:	60b9      	str	r1, [r7, #8]
 800d212:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 800d214:	68fb      	ldr	r3, [r7, #12]
 800d216:	6a1b      	ldr	r3, [r3, #32]
 800d218:	613b      	str	r3, [r7, #16]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800d21a:	68fb      	ldr	r3, [r7, #12]
 800d21c:	6a1b      	ldr	r3, [r3, #32]
 800d21e:	f023 0201 	bic.w	r2, r3, #1
 800d222:	68fb      	ldr	r3, [r7, #12]
 800d224:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800d226:	68fb      	ldr	r3, [r7, #12]
 800d228:	699b      	ldr	r3, [r3, #24]
 800d22a:	617b      	str	r3, [r7, #20]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800d22c:	697b      	ldr	r3, [r7, #20]
 800d22e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800d232:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800d234:	687b      	ldr	r3, [r7, #4]
 800d236:	011b      	lsls	r3, r3, #4
 800d238:	697a      	ldr	r2, [r7, #20]
 800d23a:	4313      	orrs	r3, r2
 800d23c:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800d23e:	693b      	ldr	r3, [r7, #16]
 800d240:	f023 030a 	bic.w	r3, r3, #10
 800d244:	613b      	str	r3, [r7, #16]
  tmpccer |= TIM_ICPolarity;
 800d246:	693a      	ldr	r2, [r7, #16]
 800d248:	68bb      	ldr	r3, [r7, #8]
 800d24a:	4313      	orrs	r3, r2
 800d24c:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 800d24e:	68fb      	ldr	r3, [r7, #12]
 800d250:	697a      	ldr	r2, [r7, #20]
 800d252:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800d254:	68fb      	ldr	r3, [r7, #12]
 800d256:	693a      	ldr	r2, [r7, #16]
 800d258:	621a      	str	r2, [r3, #32]
}
 800d25a:	bf00      	nop
 800d25c:	371c      	adds	r7, #28
 800d25e:	46bd      	mov	sp, r7
 800d260:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d264:	4770      	bx	lr

0800d266 <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800d266:	b480      	push	{r7}
 800d268:	b087      	sub	sp, #28
 800d26a:	af00      	add	r7, sp, #0
 800d26c:	60f8      	str	r0, [r7, #12]
 800d26e:	60b9      	str	r1, [r7, #8]
 800d270:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800d272:	68fb      	ldr	r3, [r7, #12]
 800d274:	6a1b      	ldr	r3, [r3, #32]
 800d276:	f023 0210 	bic.w	r2, r3, #16
 800d27a:	68fb      	ldr	r3, [r7, #12]
 800d27c:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800d27e:	68fb      	ldr	r3, [r7, #12]
 800d280:	699b      	ldr	r3, [r3, #24]
 800d282:	613b      	str	r3, [r7, #16]
  tmpccer = TIMx->CCER;
 800d284:	68fb      	ldr	r3, [r7, #12]
 800d286:	6a1b      	ldr	r3, [r3, #32]
 800d288:	617b      	str	r3, [r7, #20]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800d28a:	693b      	ldr	r3, [r7, #16]
 800d28c:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 800d290:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800d292:	687b      	ldr	r3, [r7, #4]
 800d294:	031b      	lsls	r3, r3, #12
 800d296:	693a      	ldr	r2, [r7, #16]
 800d298:	4313      	orrs	r3, r2
 800d29a:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800d29c:	697b      	ldr	r3, [r7, #20]
 800d29e:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 800d2a2:	617b      	str	r3, [r7, #20]
  tmpccer |= (TIM_ICPolarity << 4U);
 800d2a4:	68bb      	ldr	r3, [r7, #8]
 800d2a6:	011b      	lsls	r3, r3, #4
 800d2a8:	697a      	ldr	r2, [r7, #20]
 800d2aa:	4313      	orrs	r3, r2
 800d2ac:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800d2ae:	68fb      	ldr	r3, [r7, #12]
 800d2b0:	693a      	ldr	r2, [r7, #16]
 800d2b2:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800d2b4:	68fb      	ldr	r3, [r7, #12]
 800d2b6:	697a      	ldr	r2, [r7, #20]
 800d2b8:	621a      	str	r2, [r3, #32]
}
 800d2ba:	bf00      	nop
 800d2bc:	371c      	adds	r7, #28
 800d2be:	46bd      	mov	sp, r7
 800d2c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d2c4:	4770      	bx	lr

0800d2c6 <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 800d2c6:	b480      	push	{r7}
 800d2c8:	b085      	sub	sp, #20
 800d2ca:	af00      	add	r7, sp, #0
 800d2cc:	6078      	str	r0, [r7, #4]
 800d2ce:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800d2d0:	687b      	ldr	r3, [r7, #4]
 800d2d2:	689b      	ldr	r3, [r3, #8]
 800d2d4:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 800d2d6:	68fb      	ldr	r3, [r7, #12]
 800d2d8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800d2dc:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800d2de:	683a      	ldr	r2, [r7, #0]
 800d2e0:	68fb      	ldr	r3, [r7, #12]
 800d2e2:	4313      	orrs	r3, r2
 800d2e4:	f043 0307 	orr.w	r3, r3, #7
 800d2e8:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800d2ea:	687b      	ldr	r3, [r7, #4]
 800d2ec:	68fa      	ldr	r2, [r7, #12]
 800d2ee:	609a      	str	r2, [r3, #8]
}
 800d2f0:	bf00      	nop
 800d2f2:	3714      	adds	r7, #20
 800d2f4:	46bd      	mov	sp, r7
 800d2f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d2fa:	4770      	bx	lr

0800d2fc <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 800d2fc:	b480      	push	{r7}
 800d2fe:	b087      	sub	sp, #28
 800d300:	af00      	add	r7, sp, #0
 800d302:	60f8      	str	r0, [r7, #12]
 800d304:	60b9      	str	r1, [r7, #8]
 800d306:	607a      	str	r2, [r7, #4]
 800d308:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 800d30a:	68fb      	ldr	r3, [r7, #12]
 800d30c:	689b      	ldr	r3, [r3, #8]
 800d30e:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800d310:	697b      	ldr	r3, [r7, #20]
 800d312:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800d316:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800d318:	683b      	ldr	r3, [r7, #0]
 800d31a:	021a      	lsls	r2, r3, #8
 800d31c:	687b      	ldr	r3, [r7, #4]
 800d31e:	431a      	orrs	r2, r3
 800d320:	68bb      	ldr	r3, [r7, #8]
 800d322:	4313      	orrs	r3, r2
 800d324:	697a      	ldr	r2, [r7, #20]
 800d326:	4313      	orrs	r3, r2
 800d328:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800d32a:	68fb      	ldr	r3, [r7, #12]
 800d32c:	697a      	ldr	r2, [r7, #20]
 800d32e:	609a      	str	r2, [r3, #8]
}
 800d330:	bf00      	nop
 800d332:	371c      	adds	r7, #28
 800d334:	46bd      	mov	sp, r7
 800d336:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d33a:	4770      	bx	lr

0800d33c <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 800d33c:	b580      	push	{r7, lr}
 800d33e:	b082      	sub	sp, #8
 800d340:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
 800d342:	2300      	movs	r3, #0
 800d344:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
 800d346:	4b23      	ldr	r3, [pc, #140]	; (800d3d4 <HAL_PWREx_EnableOverDrive+0x98>)
 800d348:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d34a:	4a22      	ldr	r2, [pc, #136]	; (800d3d4 <HAL_PWREx_EnableOverDrive+0x98>)
 800d34c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800d350:	6413      	str	r3, [r2, #64]	; 0x40
 800d352:	4b20      	ldr	r3, [pc, #128]	; (800d3d4 <HAL_PWREx_EnableOverDrive+0x98>)
 800d354:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d356:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d35a:	603b      	str	r3, [r7, #0]
 800d35c:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 800d35e:	4b1e      	ldr	r3, [pc, #120]	; (800d3d8 <HAL_PWREx_EnableOverDrive+0x9c>)
 800d360:	681b      	ldr	r3, [r3, #0]
 800d362:	4a1d      	ldr	r2, [pc, #116]	; (800d3d8 <HAL_PWREx_EnableOverDrive+0x9c>)
 800d364:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d368:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800d36a:	f7f4 fd05 	bl	8001d78 <HAL_GetTick>
 800d36e:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800d370:	e009      	b.n	800d386 <HAL_PWREx_EnableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800d372:	f7f4 fd01 	bl	8001d78 <HAL_GetTick>
 800d376:	4602      	mov	r2, r0
 800d378:	687b      	ldr	r3, [r7, #4]
 800d37a:	1ad3      	subs	r3, r2, r3
 800d37c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800d380:	d901      	bls.n	800d386 <HAL_PWREx_EnableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
 800d382:	2303      	movs	r3, #3
 800d384:	e022      	b.n	800d3cc <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800d386:	4b14      	ldr	r3, [pc, #80]	; (800d3d8 <HAL_PWREx_EnableOverDrive+0x9c>)
 800d388:	685b      	ldr	r3, [r3, #4]
 800d38a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800d38e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800d392:	d1ee      	bne.n	800d372 <HAL_PWREx_EnableOverDrive+0x36>
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800d394:	4b10      	ldr	r3, [pc, #64]	; (800d3d8 <HAL_PWREx_EnableOverDrive+0x9c>)
 800d396:	681b      	ldr	r3, [r3, #0]
 800d398:	4a0f      	ldr	r2, [pc, #60]	; (800d3d8 <HAL_PWREx_EnableOverDrive+0x9c>)
 800d39a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800d39e:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800d3a0:	f7f4 fcea 	bl	8001d78 <HAL_GetTick>
 800d3a4:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800d3a6:	e009      	b.n	800d3bc <HAL_PWREx_EnableOverDrive+0x80>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800d3a8:	f7f4 fce6 	bl	8001d78 <HAL_GetTick>
 800d3ac:	4602      	mov	r2, r0
 800d3ae:	687b      	ldr	r3, [r7, #4]
 800d3b0:	1ad3      	subs	r3, r2, r3
 800d3b2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800d3b6:	d901      	bls.n	800d3bc <HAL_PWREx_EnableOverDrive+0x80>
    {
      return HAL_TIMEOUT;
 800d3b8:	2303      	movs	r3, #3
 800d3ba:	e007      	b.n	800d3cc <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800d3bc:	4b06      	ldr	r3, [pc, #24]	; (800d3d8 <HAL_PWREx_EnableOverDrive+0x9c>)
 800d3be:	685b      	ldr	r3, [r3, #4]
 800d3c0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d3c4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800d3c8:	d1ee      	bne.n	800d3a8 <HAL_PWREx_EnableOverDrive+0x6c>
    }
  } 
  return HAL_OK;
 800d3ca:	2300      	movs	r3, #0
}
 800d3cc:	4618      	mov	r0, r3
 800d3ce:	3708      	adds	r7, #8
 800d3d0:	46bd      	mov	sp, r7
 800d3d2:	bd80      	pop	{r7, pc}
 800d3d4:	40023800 	.word	0x40023800
 800d3d8:	40007000 	.word	0x40007000

0800d3dc <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800d3dc:	b580      	push	{r7, lr}
 800d3de:	b086      	sub	sp, #24
 800d3e0:	af00      	add	r7, sp, #0
 800d3e2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;
 800d3e4:	2300      	movs	r3, #0
 800d3e6:	60fb      	str	r3, [r7, #12]

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800d3e8:	687b      	ldr	r3, [r7, #4]
 800d3ea:	2b00      	cmp	r3, #0
 800d3ec:	d101      	bne.n	800d3f2 <HAL_RCC_OscConfig+0x16>
  {
    return HAL_ERROR;
 800d3ee:	2301      	movs	r3, #1
 800d3f0:	e29b      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800d3f2:	687b      	ldr	r3, [r7, #4]
 800d3f4:	681b      	ldr	r3, [r3, #0]
 800d3f6:	f003 0301 	and.w	r3, r3, #1
 800d3fa:	2b00      	cmp	r3, #0
 800d3fc:	f000 8087 	beq.w	800d50e <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 800d400:	4b96      	ldr	r3, [pc, #600]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d402:	689b      	ldr	r3, [r3, #8]
 800d404:	f003 030c 	and.w	r3, r3, #12
 800d408:	2b04      	cmp	r3, #4
 800d40a:	d00c      	beq.n	800d426 <HAL_RCC_OscConfig+0x4a>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800d40c:	4b93      	ldr	r3, [pc, #588]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d40e:	689b      	ldr	r3, [r3, #8]
 800d410:	f003 030c 	and.w	r3, r3, #12
 800d414:	2b08      	cmp	r3, #8
 800d416:	d112      	bne.n	800d43e <HAL_RCC_OscConfig+0x62>
 800d418:	4b90      	ldr	r3, [pc, #576]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d41a:	685b      	ldr	r3, [r3, #4]
 800d41c:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800d420:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800d424:	d10b      	bne.n	800d43e <HAL_RCC_OscConfig+0x62>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800d426:	4b8d      	ldr	r3, [pc, #564]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d428:	681b      	ldr	r3, [r3, #0]
 800d42a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d42e:	2b00      	cmp	r3, #0
 800d430:	d06c      	beq.n	800d50c <HAL_RCC_OscConfig+0x130>
 800d432:	687b      	ldr	r3, [r7, #4]
 800d434:	685b      	ldr	r3, [r3, #4]
 800d436:	2b00      	cmp	r3, #0
 800d438:	d168      	bne.n	800d50c <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
 800d43a:	2301      	movs	r3, #1
 800d43c:	e275      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800d43e:	687b      	ldr	r3, [r7, #4]
 800d440:	685b      	ldr	r3, [r3, #4]
 800d442:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800d446:	d106      	bne.n	800d456 <HAL_RCC_OscConfig+0x7a>
 800d448:	4b84      	ldr	r3, [pc, #528]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d44a:	681b      	ldr	r3, [r3, #0]
 800d44c:	4a83      	ldr	r2, [pc, #524]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d44e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d452:	6013      	str	r3, [r2, #0]
 800d454:	e02e      	b.n	800d4b4 <HAL_RCC_OscConfig+0xd8>
 800d456:	687b      	ldr	r3, [r7, #4]
 800d458:	685b      	ldr	r3, [r3, #4]
 800d45a:	2b00      	cmp	r3, #0
 800d45c:	d10c      	bne.n	800d478 <HAL_RCC_OscConfig+0x9c>
 800d45e:	4b7f      	ldr	r3, [pc, #508]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d460:	681b      	ldr	r3, [r3, #0]
 800d462:	4a7e      	ldr	r2, [pc, #504]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d464:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800d468:	6013      	str	r3, [r2, #0]
 800d46a:	4b7c      	ldr	r3, [pc, #496]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d46c:	681b      	ldr	r3, [r3, #0]
 800d46e:	4a7b      	ldr	r2, [pc, #492]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d470:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800d474:	6013      	str	r3, [r2, #0]
 800d476:	e01d      	b.n	800d4b4 <HAL_RCC_OscConfig+0xd8>
 800d478:	687b      	ldr	r3, [r7, #4]
 800d47a:	685b      	ldr	r3, [r3, #4]
 800d47c:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800d480:	d10c      	bne.n	800d49c <HAL_RCC_OscConfig+0xc0>
 800d482:	4b76      	ldr	r3, [pc, #472]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d484:	681b      	ldr	r3, [r3, #0]
 800d486:	4a75      	ldr	r2, [pc, #468]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d488:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800d48c:	6013      	str	r3, [r2, #0]
 800d48e:	4b73      	ldr	r3, [pc, #460]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d490:	681b      	ldr	r3, [r3, #0]
 800d492:	4a72      	ldr	r2, [pc, #456]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d494:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d498:	6013      	str	r3, [r2, #0]
 800d49a:	e00b      	b.n	800d4b4 <HAL_RCC_OscConfig+0xd8>
 800d49c:	4b6f      	ldr	r3, [pc, #444]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d49e:	681b      	ldr	r3, [r3, #0]
 800d4a0:	4a6e      	ldr	r2, [pc, #440]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d4a2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800d4a6:	6013      	str	r3, [r2, #0]
 800d4a8:	4b6c      	ldr	r3, [pc, #432]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d4aa:	681b      	ldr	r3, [r3, #0]
 800d4ac:	4a6b      	ldr	r2, [pc, #428]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d4ae:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800d4b2:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800d4b4:	687b      	ldr	r3, [r7, #4]
 800d4b6:	685b      	ldr	r3, [r3, #4]
 800d4b8:	2b00      	cmp	r3, #0
 800d4ba:	d013      	beq.n	800d4e4 <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d4bc:	f7f4 fc5c 	bl	8001d78 <HAL_GetTick>
 800d4c0:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d4c2:	e008      	b.n	800d4d6 <HAL_RCC_OscConfig+0xfa>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800d4c4:	f7f4 fc58 	bl	8001d78 <HAL_GetTick>
 800d4c8:	4602      	mov	r2, r0
 800d4ca:	693b      	ldr	r3, [r7, #16]
 800d4cc:	1ad3      	subs	r3, r2, r3
 800d4ce:	2b64      	cmp	r3, #100	; 0x64
 800d4d0:	d901      	bls.n	800d4d6 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800d4d2:	2303      	movs	r3, #3
 800d4d4:	e229      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d4d6:	4b61      	ldr	r3, [pc, #388]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d4d8:	681b      	ldr	r3, [r3, #0]
 800d4da:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d4de:	2b00      	cmp	r3, #0
 800d4e0:	d0f0      	beq.n	800d4c4 <HAL_RCC_OscConfig+0xe8>
 800d4e2:	e014      	b.n	800d50e <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d4e4:	f7f4 fc48 	bl	8001d78 <HAL_GetTick>
 800d4e8:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800d4ea:	e008      	b.n	800d4fe <HAL_RCC_OscConfig+0x122>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800d4ec:	f7f4 fc44 	bl	8001d78 <HAL_GetTick>
 800d4f0:	4602      	mov	r2, r0
 800d4f2:	693b      	ldr	r3, [r7, #16]
 800d4f4:	1ad3      	subs	r3, r2, r3
 800d4f6:	2b64      	cmp	r3, #100	; 0x64
 800d4f8:	d901      	bls.n	800d4fe <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
 800d4fa:	2303      	movs	r3, #3
 800d4fc:	e215      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800d4fe:	4b57      	ldr	r3, [pc, #348]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d500:	681b      	ldr	r3, [r3, #0]
 800d502:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d506:	2b00      	cmp	r3, #0
 800d508:	d1f0      	bne.n	800d4ec <HAL_RCC_OscConfig+0x110>
 800d50a:	e000      	b.n	800d50e <HAL_RCC_OscConfig+0x132>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800d50c:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800d50e:	687b      	ldr	r3, [r7, #4]
 800d510:	681b      	ldr	r3, [r3, #0]
 800d512:	f003 0302 	and.w	r3, r3, #2
 800d516:	2b00      	cmp	r3, #0
 800d518:	d069      	beq.n	800d5ee <HAL_RCC_OscConfig+0x212>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 800d51a:	4b50      	ldr	r3, [pc, #320]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d51c:	689b      	ldr	r3, [r3, #8]
 800d51e:	f003 030c 	and.w	r3, r3, #12
 800d522:	2b00      	cmp	r3, #0
 800d524:	d00b      	beq.n	800d53e <HAL_RCC_OscConfig+0x162>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800d526:	4b4d      	ldr	r3, [pc, #308]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d528:	689b      	ldr	r3, [r3, #8]
 800d52a:	f003 030c 	and.w	r3, r3, #12
 800d52e:	2b08      	cmp	r3, #8
 800d530:	d11c      	bne.n	800d56c <HAL_RCC_OscConfig+0x190>
 800d532:	4b4a      	ldr	r3, [pc, #296]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d534:	685b      	ldr	r3, [r3, #4]
 800d536:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800d53a:	2b00      	cmp	r3, #0
 800d53c:	d116      	bne.n	800d56c <HAL_RCC_OscConfig+0x190>
    {
      /* When HSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800d53e:	4b47      	ldr	r3, [pc, #284]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d540:	681b      	ldr	r3, [r3, #0]
 800d542:	f003 0302 	and.w	r3, r3, #2
 800d546:	2b00      	cmp	r3, #0
 800d548:	d005      	beq.n	800d556 <HAL_RCC_OscConfig+0x17a>
 800d54a:	687b      	ldr	r3, [r7, #4]
 800d54c:	68db      	ldr	r3, [r3, #12]
 800d54e:	2b01      	cmp	r3, #1
 800d550:	d001      	beq.n	800d556 <HAL_RCC_OscConfig+0x17a>
      {
        return HAL_ERROR;
 800d552:	2301      	movs	r3, #1
 800d554:	e1e9      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800d556:	4b41      	ldr	r3, [pc, #260]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d558:	681b      	ldr	r3, [r3, #0]
 800d55a:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800d55e:	687b      	ldr	r3, [r7, #4]
 800d560:	691b      	ldr	r3, [r3, #16]
 800d562:	00db      	lsls	r3, r3, #3
 800d564:	493d      	ldr	r1, [pc, #244]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d566:	4313      	orrs	r3, r2
 800d568:	600b      	str	r3, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800d56a:	e040      	b.n	800d5ee <HAL_RCC_OscConfig+0x212>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 800d56c:	687b      	ldr	r3, [r7, #4]
 800d56e:	68db      	ldr	r3, [r3, #12]
 800d570:	2b00      	cmp	r3, #0
 800d572:	d023      	beq.n	800d5bc <HAL_RCC_OscConfig+0x1e0>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800d574:	4b39      	ldr	r3, [pc, #228]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d576:	681b      	ldr	r3, [r3, #0]
 800d578:	4a38      	ldr	r2, [pc, #224]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d57a:	f043 0301 	orr.w	r3, r3, #1
 800d57e:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d580:	f7f4 fbfa 	bl	8001d78 <HAL_GetTick>
 800d584:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800d586:	e008      	b.n	800d59a <HAL_RCC_OscConfig+0x1be>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800d588:	f7f4 fbf6 	bl	8001d78 <HAL_GetTick>
 800d58c:	4602      	mov	r2, r0
 800d58e:	693b      	ldr	r3, [r7, #16]
 800d590:	1ad3      	subs	r3, r2, r3
 800d592:	2b02      	cmp	r3, #2
 800d594:	d901      	bls.n	800d59a <HAL_RCC_OscConfig+0x1be>
          {
            return HAL_TIMEOUT;
 800d596:	2303      	movs	r3, #3
 800d598:	e1c7      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800d59a:	4b30      	ldr	r3, [pc, #192]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d59c:	681b      	ldr	r3, [r3, #0]
 800d59e:	f003 0302 	and.w	r3, r3, #2
 800d5a2:	2b00      	cmp	r3, #0
 800d5a4:	d0f0      	beq.n	800d588 <HAL_RCC_OscConfig+0x1ac>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800d5a6:	4b2d      	ldr	r3, [pc, #180]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d5a8:	681b      	ldr	r3, [r3, #0]
 800d5aa:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 800d5ae:	687b      	ldr	r3, [r7, #4]
 800d5b0:	691b      	ldr	r3, [r3, #16]
 800d5b2:	00db      	lsls	r3, r3, #3
 800d5b4:	4929      	ldr	r1, [pc, #164]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d5b6:	4313      	orrs	r3, r2
 800d5b8:	600b      	str	r3, [r1, #0]
 800d5ba:	e018      	b.n	800d5ee <HAL_RCC_OscConfig+0x212>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800d5bc:	4b27      	ldr	r3, [pc, #156]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d5be:	681b      	ldr	r3, [r3, #0]
 800d5c0:	4a26      	ldr	r2, [pc, #152]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d5c2:	f023 0301 	bic.w	r3, r3, #1
 800d5c6:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d5c8:	f7f4 fbd6 	bl	8001d78 <HAL_GetTick>
 800d5cc:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800d5ce:	e008      	b.n	800d5e2 <HAL_RCC_OscConfig+0x206>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800d5d0:	f7f4 fbd2 	bl	8001d78 <HAL_GetTick>
 800d5d4:	4602      	mov	r2, r0
 800d5d6:	693b      	ldr	r3, [r7, #16]
 800d5d8:	1ad3      	subs	r3, r2, r3
 800d5da:	2b02      	cmp	r3, #2
 800d5dc:	d901      	bls.n	800d5e2 <HAL_RCC_OscConfig+0x206>
          {
            return HAL_TIMEOUT;
 800d5de:	2303      	movs	r3, #3
 800d5e0:	e1a3      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800d5e2:	4b1e      	ldr	r3, [pc, #120]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d5e4:	681b      	ldr	r3, [r3, #0]
 800d5e6:	f003 0302 	and.w	r3, r3, #2
 800d5ea:	2b00      	cmp	r3, #0
 800d5ec:	d1f0      	bne.n	800d5d0 <HAL_RCC_OscConfig+0x1f4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800d5ee:	687b      	ldr	r3, [r7, #4]
 800d5f0:	681b      	ldr	r3, [r3, #0]
 800d5f2:	f003 0308 	and.w	r3, r3, #8
 800d5f6:	2b00      	cmp	r3, #0
 800d5f8:	d038      	beq.n	800d66c <HAL_RCC_OscConfig+0x290>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 800d5fa:	687b      	ldr	r3, [r7, #4]
 800d5fc:	695b      	ldr	r3, [r3, #20]
 800d5fe:	2b00      	cmp	r3, #0
 800d600:	d019      	beq.n	800d636 <HAL_RCC_OscConfig+0x25a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800d602:	4b16      	ldr	r3, [pc, #88]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d604:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d606:	4a15      	ldr	r2, [pc, #84]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d608:	f043 0301 	orr.w	r3, r3, #1
 800d60c:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d60e:	f7f4 fbb3 	bl	8001d78 <HAL_GetTick>
 800d612:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800d614:	e008      	b.n	800d628 <HAL_RCC_OscConfig+0x24c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800d616:	f7f4 fbaf 	bl	8001d78 <HAL_GetTick>
 800d61a:	4602      	mov	r2, r0
 800d61c:	693b      	ldr	r3, [r7, #16]
 800d61e:	1ad3      	subs	r3, r2, r3
 800d620:	2b02      	cmp	r3, #2
 800d622:	d901      	bls.n	800d628 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
 800d624:	2303      	movs	r3, #3
 800d626:	e180      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800d628:	4b0c      	ldr	r3, [pc, #48]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d62a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d62c:	f003 0302 	and.w	r3, r3, #2
 800d630:	2b00      	cmp	r3, #0
 800d632:	d0f0      	beq.n	800d616 <HAL_RCC_OscConfig+0x23a>
 800d634:	e01a      	b.n	800d66c <HAL_RCC_OscConfig+0x290>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800d636:	4b09      	ldr	r3, [pc, #36]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d638:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d63a:	4a08      	ldr	r2, [pc, #32]	; (800d65c <HAL_RCC_OscConfig+0x280>)
 800d63c:	f023 0301 	bic.w	r3, r3, #1
 800d640:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d642:	f7f4 fb99 	bl	8001d78 <HAL_GetTick>
 800d646:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800d648:	e00a      	b.n	800d660 <HAL_RCC_OscConfig+0x284>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800d64a:	f7f4 fb95 	bl	8001d78 <HAL_GetTick>
 800d64e:	4602      	mov	r2, r0
 800d650:	693b      	ldr	r3, [r7, #16]
 800d652:	1ad3      	subs	r3, r2, r3
 800d654:	2b02      	cmp	r3, #2
 800d656:	d903      	bls.n	800d660 <HAL_RCC_OscConfig+0x284>
        {
          return HAL_TIMEOUT;
 800d658:	2303      	movs	r3, #3
 800d65a:	e166      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
 800d65c:	40023800 	.word	0x40023800
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800d660:	4b92      	ldr	r3, [pc, #584]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d662:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d664:	f003 0302 	and.w	r3, r3, #2
 800d668:	2b00      	cmp	r3, #0
 800d66a:	d1ee      	bne.n	800d64a <HAL_RCC_OscConfig+0x26e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800d66c:	687b      	ldr	r3, [r7, #4]
 800d66e:	681b      	ldr	r3, [r3, #0]
 800d670:	f003 0304 	and.w	r3, r3, #4
 800d674:	2b00      	cmp	r3, #0
 800d676:	f000 80a4 	beq.w	800d7c2 <HAL_RCC_OscConfig+0x3e6>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 800d67a:	4b8c      	ldr	r3, [pc, #560]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d67c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d67e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d682:	2b00      	cmp	r3, #0
 800d684:	d10d      	bne.n	800d6a2 <HAL_RCC_OscConfig+0x2c6>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 800d686:	4b89      	ldr	r3, [pc, #548]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d688:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d68a:	4a88      	ldr	r2, [pc, #544]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d68c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800d690:	6413      	str	r3, [r2, #64]	; 0x40
 800d692:	4b86      	ldr	r3, [pc, #536]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d694:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d696:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d69a:	60bb      	str	r3, [r7, #8]
 800d69c:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800d69e:	2301      	movs	r3, #1
 800d6a0:	60fb      	str	r3, [r7, #12]
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800d6a2:	4b83      	ldr	r3, [pc, #524]	; (800d8b0 <HAL_RCC_OscConfig+0x4d4>)
 800d6a4:	681b      	ldr	r3, [r3, #0]
 800d6a6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800d6aa:	2b00      	cmp	r3, #0
 800d6ac:	d118      	bne.n	800d6e0 <HAL_RCC_OscConfig+0x304>
    {
      /* Enable write access to Backup domain */
      PWR->CR1 |= PWR_CR1_DBP;
 800d6ae:	4b80      	ldr	r3, [pc, #512]	; (800d8b0 <HAL_RCC_OscConfig+0x4d4>)
 800d6b0:	681b      	ldr	r3, [r3, #0]
 800d6b2:	4a7f      	ldr	r2, [pc, #508]	; (800d8b0 <HAL_RCC_OscConfig+0x4d4>)
 800d6b4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800d6b8:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800d6ba:	f7f4 fb5d 	bl	8001d78 <HAL_GetTick>
 800d6be:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800d6c0:	e008      	b.n	800d6d4 <HAL_RCC_OscConfig+0x2f8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800d6c2:	f7f4 fb59 	bl	8001d78 <HAL_GetTick>
 800d6c6:	4602      	mov	r2, r0
 800d6c8:	693b      	ldr	r3, [r7, #16]
 800d6ca:	1ad3      	subs	r3, r2, r3
 800d6cc:	2b64      	cmp	r3, #100	; 0x64
 800d6ce:	d901      	bls.n	800d6d4 <HAL_RCC_OscConfig+0x2f8>
        {
          return HAL_TIMEOUT;
 800d6d0:	2303      	movs	r3, #3
 800d6d2:	e12a      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800d6d4:	4b76      	ldr	r3, [pc, #472]	; (800d8b0 <HAL_RCC_OscConfig+0x4d4>)
 800d6d6:	681b      	ldr	r3, [r3, #0]
 800d6d8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800d6dc:	2b00      	cmp	r3, #0
 800d6de:	d0f0      	beq.n	800d6c2 <HAL_RCC_OscConfig+0x2e6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800d6e0:	687b      	ldr	r3, [r7, #4]
 800d6e2:	689b      	ldr	r3, [r3, #8]
 800d6e4:	2b01      	cmp	r3, #1
 800d6e6:	d106      	bne.n	800d6f6 <HAL_RCC_OscConfig+0x31a>
 800d6e8:	4b70      	ldr	r3, [pc, #448]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d6ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d6ec:	4a6f      	ldr	r2, [pc, #444]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d6ee:	f043 0301 	orr.w	r3, r3, #1
 800d6f2:	6713      	str	r3, [r2, #112]	; 0x70
 800d6f4:	e02d      	b.n	800d752 <HAL_RCC_OscConfig+0x376>
 800d6f6:	687b      	ldr	r3, [r7, #4]
 800d6f8:	689b      	ldr	r3, [r3, #8]
 800d6fa:	2b00      	cmp	r3, #0
 800d6fc:	d10c      	bne.n	800d718 <HAL_RCC_OscConfig+0x33c>
 800d6fe:	4b6b      	ldr	r3, [pc, #428]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d700:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d702:	4a6a      	ldr	r2, [pc, #424]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d704:	f023 0301 	bic.w	r3, r3, #1
 800d708:	6713      	str	r3, [r2, #112]	; 0x70
 800d70a:	4b68      	ldr	r3, [pc, #416]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d70c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d70e:	4a67      	ldr	r2, [pc, #412]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d710:	f023 0304 	bic.w	r3, r3, #4
 800d714:	6713      	str	r3, [r2, #112]	; 0x70
 800d716:	e01c      	b.n	800d752 <HAL_RCC_OscConfig+0x376>
 800d718:	687b      	ldr	r3, [r7, #4]
 800d71a:	689b      	ldr	r3, [r3, #8]
 800d71c:	2b05      	cmp	r3, #5
 800d71e:	d10c      	bne.n	800d73a <HAL_RCC_OscConfig+0x35e>
 800d720:	4b62      	ldr	r3, [pc, #392]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d722:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d724:	4a61      	ldr	r2, [pc, #388]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d726:	f043 0304 	orr.w	r3, r3, #4
 800d72a:	6713      	str	r3, [r2, #112]	; 0x70
 800d72c:	4b5f      	ldr	r3, [pc, #380]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d72e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d730:	4a5e      	ldr	r2, [pc, #376]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d732:	f043 0301 	orr.w	r3, r3, #1
 800d736:	6713      	str	r3, [r2, #112]	; 0x70
 800d738:	e00b      	b.n	800d752 <HAL_RCC_OscConfig+0x376>
 800d73a:	4b5c      	ldr	r3, [pc, #368]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d73c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d73e:	4a5b      	ldr	r2, [pc, #364]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d740:	f023 0301 	bic.w	r3, r3, #1
 800d744:	6713      	str	r3, [r2, #112]	; 0x70
 800d746:	4b59      	ldr	r3, [pc, #356]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d748:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d74a:	4a58      	ldr	r2, [pc, #352]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d74c:	f023 0304 	bic.w	r3, r3, #4
 800d750:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800d752:	687b      	ldr	r3, [r7, #4]
 800d754:	689b      	ldr	r3, [r3, #8]
 800d756:	2b00      	cmp	r3, #0
 800d758:	d015      	beq.n	800d786 <HAL_RCC_OscConfig+0x3aa>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d75a:	f7f4 fb0d 	bl	8001d78 <HAL_GetTick>
 800d75e:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800d760:	e00a      	b.n	800d778 <HAL_RCC_OscConfig+0x39c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800d762:	f7f4 fb09 	bl	8001d78 <HAL_GetTick>
 800d766:	4602      	mov	r2, r0
 800d768:	693b      	ldr	r3, [r7, #16]
 800d76a:	1ad3      	subs	r3, r2, r3
 800d76c:	f241 3288 	movw	r2, #5000	; 0x1388
 800d770:	4293      	cmp	r3, r2
 800d772:	d901      	bls.n	800d778 <HAL_RCC_OscConfig+0x39c>
        {
          return HAL_TIMEOUT;
 800d774:	2303      	movs	r3, #3
 800d776:	e0d8      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800d778:	4b4c      	ldr	r3, [pc, #304]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d77a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d77c:	f003 0302 	and.w	r3, r3, #2
 800d780:	2b00      	cmp	r3, #0
 800d782:	d0ee      	beq.n	800d762 <HAL_RCC_OscConfig+0x386>
 800d784:	e014      	b.n	800d7b0 <HAL_RCC_OscConfig+0x3d4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800d786:	f7f4 faf7 	bl	8001d78 <HAL_GetTick>
 800d78a:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800d78c:	e00a      	b.n	800d7a4 <HAL_RCC_OscConfig+0x3c8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800d78e:	f7f4 faf3 	bl	8001d78 <HAL_GetTick>
 800d792:	4602      	mov	r2, r0
 800d794:	693b      	ldr	r3, [r7, #16]
 800d796:	1ad3      	subs	r3, r2, r3
 800d798:	f241 3288 	movw	r2, #5000	; 0x1388
 800d79c:	4293      	cmp	r3, r2
 800d79e:	d901      	bls.n	800d7a4 <HAL_RCC_OscConfig+0x3c8>
        {
          return HAL_TIMEOUT;
 800d7a0:	2303      	movs	r3, #3
 800d7a2:	e0c2      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800d7a4:	4b41      	ldr	r3, [pc, #260]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d7a6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d7a8:	f003 0302 	and.w	r3, r3, #2
 800d7ac:	2b00      	cmp	r3, #0
 800d7ae:	d1ee      	bne.n	800d78e <HAL_RCC_OscConfig+0x3b2>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 800d7b0:	68fb      	ldr	r3, [r7, #12]
 800d7b2:	2b01      	cmp	r3, #1
 800d7b4:	d105      	bne.n	800d7c2 <HAL_RCC_OscConfig+0x3e6>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800d7b6:	4b3d      	ldr	r3, [pc, #244]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d7b8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d7ba:	4a3c      	ldr	r2, [pc, #240]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d7bc:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800d7c0:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800d7c2:	687b      	ldr	r3, [r7, #4]
 800d7c4:	699b      	ldr	r3, [r3, #24]
 800d7c6:	2b00      	cmp	r3, #0
 800d7c8:	f000 80ae 	beq.w	800d928 <HAL_RCC_OscConfig+0x54c>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800d7cc:	4b37      	ldr	r3, [pc, #220]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d7ce:	689b      	ldr	r3, [r3, #8]
 800d7d0:	f003 030c 	and.w	r3, r3, #12
 800d7d4:	2b08      	cmp	r3, #8
 800d7d6:	d06d      	beq.n	800d8b4 <HAL_RCC_OscConfig+0x4d8>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800d7d8:	687b      	ldr	r3, [r7, #4]
 800d7da:	699b      	ldr	r3, [r3, #24]
 800d7dc:	2b02      	cmp	r3, #2
 800d7de:	d14b      	bne.n	800d878 <HAL_RCC_OscConfig+0x49c>
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800d7e0:	4b32      	ldr	r3, [pc, #200]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d7e2:	681b      	ldr	r3, [r3, #0]
 800d7e4:	4a31      	ldr	r2, [pc, #196]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d7e6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800d7ea:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d7ec:	f7f4 fac4 	bl	8001d78 <HAL_GetTick>
 800d7f0:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d7f2:	e008      	b.n	800d806 <HAL_RCC_OscConfig+0x42a>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800d7f4:	f7f4 fac0 	bl	8001d78 <HAL_GetTick>
 800d7f8:	4602      	mov	r2, r0
 800d7fa:	693b      	ldr	r3, [r7, #16]
 800d7fc:	1ad3      	subs	r3, r2, r3
 800d7fe:	2b02      	cmp	r3, #2
 800d800:	d901      	bls.n	800d806 <HAL_RCC_OscConfig+0x42a>
          {
            return HAL_TIMEOUT;
 800d802:	2303      	movs	r3, #3
 800d804:	e091      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d806:	4b29      	ldr	r3, [pc, #164]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d808:	681b      	ldr	r3, [r3, #0]
 800d80a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d80e:	2b00      	cmp	r3, #0
 800d810:	d1f0      	bne.n	800d7f4 <HAL_RCC_OscConfig+0x418>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
#if defined (RCC_PLLCFGR_PLLR)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800d812:	687b      	ldr	r3, [r7, #4]
 800d814:	69da      	ldr	r2, [r3, #28]
 800d816:	687b      	ldr	r3, [r7, #4]
 800d818:	6a1b      	ldr	r3, [r3, #32]
 800d81a:	431a      	orrs	r2, r3
 800d81c:	687b      	ldr	r3, [r7, #4]
 800d81e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d820:	019b      	lsls	r3, r3, #6
 800d822:	431a      	orrs	r2, r3
 800d824:	687b      	ldr	r3, [r7, #4]
 800d826:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d828:	085b      	lsrs	r3, r3, #1
 800d82a:	3b01      	subs	r3, #1
 800d82c:	041b      	lsls	r3, r3, #16
 800d82e:	431a      	orrs	r2, r3
 800d830:	687b      	ldr	r3, [r7, #4]
 800d832:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d834:	061b      	lsls	r3, r3, #24
 800d836:	431a      	orrs	r2, r3
 800d838:	687b      	ldr	r3, [r7, #4]
 800d83a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d83c:	071b      	lsls	r3, r3, #28
 800d83e:	491b      	ldr	r1, [pc, #108]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d840:	4313      	orrs	r3, r2
 800d842:	604b      	str	r3, [r1, #4]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
#endif

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800d844:	4b19      	ldr	r3, [pc, #100]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d846:	681b      	ldr	r3, [r3, #0]
 800d848:	4a18      	ldr	r2, [pc, #96]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d84a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800d84e:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d850:	f7f4 fa92 	bl	8001d78 <HAL_GetTick>
 800d854:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800d856:	e008      	b.n	800d86a <HAL_RCC_OscConfig+0x48e>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800d858:	f7f4 fa8e 	bl	8001d78 <HAL_GetTick>
 800d85c:	4602      	mov	r2, r0
 800d85e:	693b      	ldr	r3, [r7, #16]
 800d860:	1ad3      	subs	r3, r2, r3
 800d862:	2b02      	cmp	r3, #2
 800d864:	d901      	bls.n	800d86a <HAL_RCC_OscConfig+0x48e>
          {
            return HAL_TIMEOUT;
 800d866:	2303      	movs	r3, #3
 800d868:	e05f      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800d86a:	4b10      	ldr	r3, [pc, #64]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d86c:	681b      	ldr	r3, [r3, #0]
 800d86e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d872:	2b00      	cmp	r3, #0
 800d874:	d0f0      	beq.n	800d858 <HAL_RCC_OscConfig+0x47c>
 800d876:	e057      	b.n	800d928 <HAL_RCC_OscConfig+0x54c>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800d878:	4b0c      	ldr	r3, [pc, #48]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d87a:	681b      	ldr	r3, [r3, #0]
 800d87c:	4a0b      	ldr	r2, [pc, #44]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d87e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800d882:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800d884:	f7f4 fa78 	bl	8001d78 <HAL_GetTick>
 800d888:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d88a:	e008      	b.n	800d89e <HAL_RCC_OscConfig+0x4c2>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800d88c:	f7f4 fa74 	bl	8001d78 <HAL_GetTick>
 800d890:	4602      	mov	r2, r0
 800d892:	693b      	ldr	r3, [r7, #16]
 800d894:	1ad3      	subs	r3, r2, r3
 800d896:	2b02      	cmp	r3, #2
 800d898:	d901      	bls.n	800d89e <HAL_RCC_OscConfig+0x4c2>
          {
            return HAL_TIMEOUT;
 800d89a:	2303      	movs	r3, #3
 800d89c:	e045      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800d89e:	4b03      	ldr	r3, [pc, #12]	; (800d8ac <HAL_RCC_OscConfig+0x4d0>)
 800d8a0:	681b      	ldr	r3, [r3, #0]
 800d8a2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800d8a6:	2b00      	cmp	r3, #0
 800d8a8:	d1f0      	bne.n	800d88c <HAL_RCC_OscConfig+0x4b0>
 800d8aa:	e03d      	b.n	800d928 <HAL_RCC_OscConfig+0x54c>
 800d8ac:	40023800 	.word	0x40023800
 800d8b0:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      pll_config = RCC->PLLCFGR;
 800d8b4:	4b1f      	ldr	r3, [pc, #124]	; (800d934 <HAL_RCC_OscConfig+0x558>)
 800d8b6:	685b      	ldr	r3, [r3, #4]
 800d8b8:	617b      	str	r3, [r7, #20]
#if defined (RCC_PLLCFGR_PLLR)
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800d8ba:	687b      	ldr	r3, [r7, #4]
 800d8bc:	699b      	ldr	r3, [r3, #24]
 800d8be:	2b01      	cmp	r3, #1
 800d8c0:	d030      	beq.n	800d924 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800d8c2:	697b      	ldr	r3, [r7, #20]
 800d8c4:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
 800d8c8:	687b      	ldr	r3, [r7, #4]
 800d8ca:	69db      	ldr	r3, [r3, #28]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800d8cc:	429a      	cmp	r2, r3
 800d8ce:	d129      	bne.n	800d924 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800d8d0:	697b      	ldr	r3, [r7, #20]
 800d8d2:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 800d8d6:	687b      	ldr	r3, [r7, #4]
 800d8d8:	6a1b      	ldr	r3, [r3, #32]
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800d8da:	429a      	cmp	r2, r3
 800d8dc:	d122      	bne.n	800d924 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 800d8de:	697a      	ldr	r2, [r7, #20]
 800d8e0:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800d8e4:	4013      	ands	r3, r2
 800d8e6:	687a      	ldr	r2, [r7, #4]
 800d8e8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800d8ea:	0192      	lsls	r2, r2, #6
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800d8ec:	4293      	cmp	r3, r2
 800d8ee:	d119      	bne.n	800d924 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 800d8f0:	697b      	ldr	r3, [r7, #20]
 800d8f2:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 800d8f6:	687b      	ldr	r3, [r7, #4]
 800d8f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d8fa:	085b      	lsrs	r3, r3, #1
 800d8fc:	3b01      	subs	r3, #1
 800d8fe:	041b      	lsls	r3, r3, #16
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 800d900:	429a      	cmp	r2, r3
 800d902:	d10f      	bne.n	800d924 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
 800d904:	697b      	ldr	r3, [r7, #20]
 800d906:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 800d90a:	687b      	ldr	r3, [r7, #4]
 800d90c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d90e:	061b      	lsls	r3, r3, #24
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 800d910:	429a      	cmp	r2, r3
 800d912:	d107      	bne.n	800d924 <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
 800d914:	697b      	ldr	r3, [r7, #20]
 800d916:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
 800d91a:	687b      	ldr	r3, [r7, #4]
 800d91c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d91e:	071b      	lsls	r3, r3, #28
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
 800d920:	429a      	cmp	r2, r3
 800d922:	d001      	beq.n	800d928 <HAL_RCC_OscConfig+0x54c>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
#endif
      {
        return HAL_ERROR;
 800d924:	2301      	movs	r3, #1
 800d926:	e000      	b.n	800d92a <HAL_RCC_OscConfig+0x54e>
      }
    }
  }
  return HAL_OK;
 800d928:	2300      	movs	r3, #0
}
 800d92a:	4618      	mov	r0, r3
 800d92c:	3718      	adds	r7, #24
 800d92e:	46bd      	mov	sp, r7
 800d930:	bd80      	pop	{r7, pc}
 800d932:	bf00      	nop
 800d934:	40023800 	.word	0x40023800

0800d938 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800d938:	b580      	push	{r7, lr}
 800d93a:	b084      	sub	sp, #16
 800d93c:	af00      	add	r7, sp, #0
 800d93e:	6078      	str	r0, [r7, #4]
 800d940:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 800d942:	2300      	movs	r3, #0
 800d944:	60fb      	str	r3, [r7, #12]

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 800d946:	687b      	ldr	r3, [r7, #4]
 800d948:	2b00      	cmp	r3, #0
 800d94a:	d101      	bne.n	800d950 <HAL_RCC_ClockConfig+0x18>
  {
    return HAL_ERROR;
 800d94c:	2301      	movs	r3, #1
 800d94e:	e0d0      	b.n	800daf2 <HAL_RCC_ClockConfig+0x1ba>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800d950:	4b6a      	ldr	r3, [pc, #424]	; (800dafc <HAL_RCC_ClockConfig+0x1c4>)
 800d952:	681b      	ldr	r3, [r3, #0]
 800d954:	f003 030f 	and.w	r3, r3, #15
 800d958:	683a      	ldr	r2, [r7, #0]
 800d95a:	429a      	cmp	r2, r3
 800d95c:	d910      	bls.n	800d980 <HAL_RCC_ClockConfig+0x48>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800d95e:	4b67      	ldr	r3, [pc, #412]	; (800dafc <HAL_RCC_ClockConfig+0x1c4>)
 800d960:	681b      	ldr	r3, [r3, #0]
 800d962:	f023 020f 	bic.w	r2, r3, #15
 800d966:	4965      	ldr	r1, [pc, #404]	; (800dafc <HAL_RCC_ClockConfig+0x1c4>)
 800d968:	683b      	ldr	r3, [r7, #0]
 800d96a:	4313      	orrs	r3, r2
 800d96c:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800d96e:	4b63      	ldr	r3, [pc, #396]	; (800dafc <HAL_RCC_ClockConfig+0x1c4>)
 800d970:	681b      	ldr	r3, [r3, #0]
 800d972:	f003 030f 	and.w	r3, r3, #15
 800d976:	683a      	ldr	r2, [r7, #0]
 800d978:	429a      	cmp	r2, r3
 800d97a:	d001      	beq.n	800d980 <HAL_RCC_ClockConfig+0x48>
    {
      return HAL_ERROR;
 800d97c:	2301      	movs	r3, #1
 800d97e:	e0b8      	b.n	800daf2 <HAL_RCC_ClockConfig+0x1ba>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800d980:	687b      	ldr	r3, [r7, #4]
 800d982:	681b      	ldr	r3, [r3, #0]
 800d984:	f003 0302 	and.w	r3, r3, #2
 800d988:	2b00      	cmp	r3, #0
 800d98a:	d020      	beq.n	800d9ce <HAL_RCC_ClockConfig+0x96>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800d98c:	687b      	ldr	r3, [r7, #4]
 800d98e:	681b      	ldr	r3, [r3, #0]
 800d990:	f003 0304 	and.w	r3, r3, #4
 800d994:	2b00      	cmp	r3, #0
 800d996:	d005      	beq.n	800d9a4 <HAL_RCC_ClockConfig+0x6c>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800d998:	4b59      	ldr	r3, [pc, #356]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800d99a:	689b      	ldr	r3, [r3, #8]
 800d99c:	4a58      	ldr	r2, [pc, #352]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800d99e:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 800d9a2:	6093      	str	r3, [r2, #8]
    }

    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800d9a4:	687b      	ldr	r3, [r7, #4]
 800d9a6:	681b      	ldr	r3, [r3, #0]
 800d9a8:	f003 0308 	and.w	r3, r3, #8
 800d9ac:	2b00      	cmp	r3, #0
 800d9ae:	d005      	beq.n	800d9bc <HAL_RCC_ClockConfig+0x84>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800d9b0:	4b53      	ldr	r3, [pc, #332]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800d9b2:	689b      	ldr	r3, [r3, #8]
 800d9b4:	4a52      	ldr	r2, [pc, #328]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800d9b6:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 800d9ba:	6093      	str	r3, [r2, #8]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800d9bc:	4b50      	ldr	r3, [pc, #320]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800d9be:	689b      	ldr	r3, [r3, #8]
 800d9c0:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800d9c4:	687b      	ldr	r3, [r7, #4]
 800d9c6:	689b      	ldr	r3, [r3, #8]
 800d9c8:	494d      	ldr	r1, [pc, #308]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800d9ca:	4313      	orrs	r3, r2
 800d9cc:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800d9ce:	687b      	ldr	r3, [r7, #4]
 800d9d0:	681b      	ldr	r3, [r3, #0]
 800d9d2:	f003 0301 	and.w	r3, r3, #1
 800d9d6:	2b00      	cmp	r3, #0
 800d9d8:	d040      	beq.n	800da5c <HAL_RCC_ClockConfig+0x124>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800d9da:	687b      	ldr	r3, [r7, #4]
 800d9dc:	685b      	ldr	r3, [r3, #4]
 800d9de:	2b01      	cmp	r3, #1
 800d9e0:	d107      	bne.n	800d9f2 <HAL_RCC_ClockConfig+0xba>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800d9e2:	4b47      	ldr	r3, [pc, #284]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800d9e4:	681b      	ldr	r3, [r3, #0]
 800d9e6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d9ea:	2b00      	cmp	r3, #0
 800d9ec:	d115      	bne.n	800da1a <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
 800d9ee:	2301      	movs	r3, #1
 800d9f0:	e07f      	b.n	800daf2 <HAL_RCC_ClockConfig+0x1ba>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800d9f2:	687b      	ldr	r3, [r7, #4]
 800d9f4:	685b      	ldr	r3, [r3, #4]
 800d9f6:	2b02      	cmp	r3, #2
 800d9f8:	d107      	bne.n	800da0a <HAL_RCC_ClockConfig+0xd2>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800d9fa:	4b41      	ldr	r3, [pc, #260]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800d9fc:	681b      	ldr	r3, [r3, #0]
 800d9fe:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800da02:	2b00      	cmp	r3, #0
 800da04:	d109      	bne.n	800da1a <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
 800da06:	2301      	movs	r3, #1
 800da08:	e073      	b.n	800daf2 <HAL_RCC_ClockConfig+0x1ba>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800da0a:	4b3d      	ldr	r3, [pc, #244]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800da0c:	681b      	ldr	r3, [r3, #0]
 800da0e:	f003 0302 	and.w	r3, r3, #2
 800da12:	2b00      	cmp	r3, #0
 800da14:	d101      	bne.n	800da1a <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
 800da16:	2301      	movs	r3, #1
 800da18:	e06b      	b.n	800daf2 <HAL_RCC_ClockConfig+0x1ba>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800da1a:	4b39      	ldr	r3, [pc, #228]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800da1c:	689b      	ldr	r3, [r3, #8]
 800da1e:	f023 0203 	bic.w	r2, r3, #3
 800da22:	687b      	ldr	r3, [r7, #4]
 800da24:	685b      	ldr	r3, [r3, #4]
 800da26:	4936      	ldr	r1, [pc, #216]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800da28:	4313      	orrs	r3, r2
 800da2a:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800da2c:	f7f4 f9a4 	bl	8001d78 <HAL_GetTick>
 800da30:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800da32:	e00a      	b.n	800da4a <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800da34:	f7f4 f9a0 	bl	8001d78 <HAL_GetTick>
 800da38:	4602      	mov	r2, r0
 800da3a:	68fb      	ldr	r3, [r7, #12]
 800da3c:	1ad3      	subs	r3, r2, r3
 800da3e:	f241 3288 	movw	r2, #5000	; 0x1388
 800da42:	4293      	cmp	r3, r2
 800da44:	d901      	bls.n	800da4a <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
 800da46:	2303      	movs	r3, #3
 800da48:	e053      	b.n	800daf2 <HAL_RCC_ClockConfig+0x1ba>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800da4a:	4b2d      	ldr	r3, [pc, #180]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800da4c:	689b      	ldr	r3, [r3, #8]
 800da4e:	f003 020c 	and.w	r2, r3, #12
 800da52:	687b      	ldr	r3, [r7, #4]
 800da54:	685b      	ldr	r3, [r3, #4]
 800da56:	009b      	lsls	r3, r3, #2
 800da58:	429a      	cmp	r2, r3
 800da5a:	d1eb      	bne.n	800da34 <HAL_RCC_ClockConfig+0xfc>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800da5c:	4b27      	ldr	r3, [pc, #156]	; (800dafc <HAL_RCC_ClockConfig+0x1c4>)
 800da5e:	681b      	ldr	r3, [r3, #0]
 800da60:	f003 030f 	and.w	r3, r3, #15
 800da64:	683a      	ldr	r2, [r7, #0]
 800da66:	429a      	cmp	r2, r3
 800da68:	d210      	bcs.n	800da8c <HAL_RCC_ClockConfig+0x154>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800da6a:	4b24      	ldr	r3, [pc, #144]	; (800dafc <HAL_RCC_ClockConfig+0x1c4>)
 800da6c:	681b      	ldr	r3, [r3, #0]
 800da6e:	f023 020f 	bic.w	r2, r3, #15
 800da72:	4922      	ldr	r1, [pc, #136]	; (800dafc <HAL_RCC_ClockConfig+0x1c4>)
 800da74:	683b      	ldr	r3, [r7, #0]
 800da76:	4313      	orrs	r3, r2
 800da78:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800da7a:	4b20      	ldr	r3, [pc, #128]	; (800dafc <HAL_RCC_ClockConfig+0x1c4>)
 800da7c:	681b      	ldr	r3, [r3, #0]
 800da7e:	f003 030f 	and.w	r3, r3, #15
 800da82:	683a      	ldr	r2, [r7, #0]
 800da84:	429a      	cmp	r2, r3
 800da86:	d001      	beq.n	800da8c <HAL_RCC_ClockConfig+0x154>
    {
      return HAL_ERROR;
 800da88:	2301      	movs	r3, #1
 800da8a:	e032      	b.n	800daf2 <HAL_RCC_ClockConfig+0x1ba>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800da8c:	687b      	ldr	r3, [r7, #4]
 800da8e:	681b      	ldr	r3, [r3, #0]
 800da90:	f003 0304 	and.w	r3, r3, #4
 800da94:	2b00      	cmp	r3, #0
 800da96:	d008      	beq.n	800daaa <HAL_RCC_ClockConfig+0x172>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800da98:	4b19      	ldr	r3, [pc, #100]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800da9a:	689b      	ldr	r3, [r3, #8]
 800da9c:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 800daa0:	687b      	ldr	r3, [r7, #4]
 800daa2:	68db      	ldr	r3, [r3, #12]
 800daa4:	4916      	ldr	r1, [pc, #88]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800daa6:	4313      	orrs	r3, r2
 800daa8:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800daaa:	687b      	ldr	r3, [r7, #4]
 800daac:	681b      	ldr	r3, [r3, #0]
 800daae:	f003 0308 	and.w	r3, r3, #8
 800dab2:	2b00      	cmp	r3, #0
 800dab4:	d009      	beq.n	800daca <HAL_RCC_ClockConfig+0x192>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800dab6:	4b12      	ldr	r3, [pc, #72]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800dab8:	689b      	ldr	r3, [r3, #8]
 800daba:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 800dabe:	687b      	ldr	r3, [r7, #4]
 800dac0:	691b      	ldr	r3, [r3, #16]
 800dac2:	00db      	lsls	r3, r3, #3
 800dac4:	490e      	ldr	r1, [pc, #56]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800dac6:	4313      	orrs	r3, r2
 800dac8:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800daca:	f000 f831 	bl	800db30 <HAL_RCC_GetSysClockFreq>
 800dace:	4602      	mov	r2, r0
 800dad0:	4b0b      	ldr	r3, [pc, #44]	; (800db00 <HAL_RCC_ClockConfig+0x1c8>)
 800dad2:	689b      	ldr	r3, [r3, #8]
 800dad4:	091b      	lsrs	r3, r3, #4
 800dad6:	f003 030f 	and.w	r3, r3, #15
 800dada:	490a      	ldr	r1, [pc, #40]	; (800db04 <HAL_RCC_ClockConfig+0x1cc>)
 800dadc:	5ccb      	ldrb	r3, [r1, r3]
 800dade:	fa22 f303 	lsr.w	r3, r2, r3
 800dae2:	4a09      	ldr	r2, [pc, #36]	; (800db08 <HAL_RCC_ClockConfig+0x1d0>)
 800dae4:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);
 800dae6:	4b09      	ldr	r3, [pc, #36]	; (800db0c <HAL_RCC_ClockConfig+0x1d4>)
 800dae8:	681b      	ldr	r3, [r3, #0]
 800daea:	4618      	mov	r0, r3
 800daec:	f7fe fba8 	bl	800c240 <HAL_InitTick>

  return HAL_OK;
 800daf0:	2300      	movs	r3, #0
}
 800daf2:	4618      	mov	r0, r3
 800daf4:	3710      	adds	r7, #16
 800daf6:	46bd      	mov	sp, r7
 800daf8:	bd80      	pop	{r7, pc}
 800dafa:	bf00      	nop
 800dafc:	40023c00 	.word	0x40023c00
 800db00:	40023800 	.word	0x40023800
 800db04:	080232ac 	.word	0x080232ac
 800db08:	20000404 	.word	0x20000404
 800db0c:	2000047c 	.word	0x2000047c

0800db10 <HAL_RCC_EnableCSS>:
  *         allowing the MCU to perform rescue operations. The CSSI is linked to
  *         the Cortex-M7 NMI (Non-Maskable Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
 800db10:	b480      	push	{r7}
 800db12:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_CSSON);
 800db14:	4b05      	ldr	r3, [pc, #20]	; (800db2c <HAL_RCC_EnableCSS+0x1c>)
 800db16:	681b      	ldr	r3, [r3, #0]
 800db18:	4a04      	ldr	r2, [pc, #16]	; (800db2c <HAL_RCC_EnableCSS+0x1c>)
 800db1a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800db1e:	6013      	str	r3, [r2, #0]
}
 800db20:	bf00      	nop
 800db22:	46bd      	mov	sp, r7
 800db24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db28:	4770      	bx	lr
 800db2a:	bf00      	nop
 800db2c:	40023800 	.word	0x40023800

0800db30 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800db30:	b5b0      	push	{r4, r5, r7, lr}
 800db32:	b084      	sub	sp, #16
 800db34:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
 800db36:	2100      	movs	r1, #0
 800db38:	60b9      	str	r1, [r7, #8]
 800db3a:	2100      	movs	r1, #0
 800db3c:	6039      	str	r1, [r7, #0]
 800db3e:	2100      	movs	r1, #0
 800db40:	60f9      	str	r1, [r7, #12]
  uint32_t sysclockfreq = 0;
 800db42:	2100      	movs	r1, #0
 800db44:	6079      	str	r1, [r7, #4]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800db46:	4952      	ldr	r1, [pc, #328]	; (800dc90 <HAL_RCC_GetSysClockFreq+0x160>)
 800db48:	6889      	ldr	r1, [r1, #8]
 800db4a:	f001 010c 	and.w	r1, r1, #12
 800db4e:	2908      	cmp	r1, #8
 800db50:	d00d      	beq.n	800db6e <HAL_RCC_GetSysClockFreq+0x3e>
 800db52:	2908      	cmp	r1, #8
 800db54:	f200 8094 	bhi.w	800dc80 <HAL_RCC_GetSysClockFreq+0x150>
 800db58:	2900      	cmp	r1, #0
 800db5a:	d002      	beq.n	800db62 <HAL_RCC_GetSysClockFreq+0x32>
 800db5c:	2904      	cmp	r1, #4
 800db5e:	d003      	beq.n	800db68 <HAL_RCC_GetSysClockFreq+0x38>
 800db60:	e08e      	b.n	800dc80 <HAL_RCC_GetSysClockFreq+0x150>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800db62:	4b4c      	ldr	r3, [pc, #304]	; (800dc94 <HAL_RCC_GetSysClockFreq+0x164>)
 800db64:	607b      	str	r3, [r7, #4]
      break;
 800db66:	e08e      	b.n	800dc86 <HAL_RCC_GetSysClockFreq+0x156>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 800db68:	4b4b      	ldr	r3, [pc, #300]	; (800dc98 <HAL_RCC_GetSysClockFreq+0x168>)
 800db6a:	607b      	str	r3, [r7, #4]
      break;
 800db6c:	e08b      	b.n	800dc86 <HAL_RCC_GetSysClockFreq+0x156>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800db6e:	4948      	ldr	r1, [pc, #288]	; (800dc90 <HAL_RCC_GetSysClockFreq+0x160>)
 800db70:	6849      	ldr	r1, [r1, #4]
 800db72:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 800db76:	60b9      	str	r1, [r7, #8]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800db78:	4945      	ldr	r1, [pc, #276]	; (800dc90 <HAL_RCC_GetSysClockFreq+0x160>)
 800db7a:	6849      	ldr	r1, [r1, #4]
 800db7c:	f401 0180 	and.w	r1, r1, #4194304	; 0x400000
 800db80:	2900      	cmp	r1, #0
 800db82:	d024      	beq.n	800dbce <HAL_RCC_GetSysClockFreq+0x9e>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800db84:	4942      	ldr	r1, [pc, #264]	; (800dc90 <HAL_RCC_GetSysClockFreq+0x160>)
 800db86:	6849      	ldr	r1, [r1, #4]
 800db88:	0989      	lsrs	r1, r1, #6
 800db8a:	4608      	mov	r0, r1
 800db8c:	f04f 0100 	mov.w	r1, #0
 800db90:	f240 14ff 	movw	r4, #511	; 0x1ff
 800db94:	f04f 0500 	mov.w	r5, #0
 800db98:	ea00 0204 	and.w	r2, r0, r4
 800db9c:	ea01 0305 	and.w	r3, r1, r5
 800dba0:	493d      	ldr	r1, [pc, #244]	; (800dc98 <HAL_RCC_GetSysClockFreq+0x168>)
 800dba2:	fb01 f003 	mul.w	r0, r1, r3
 800dba6:	2100      	movs	r1, #0
 800dba8:	fb01 f102 	mul.w	r1, r1, r2
 800dbac:	1844      	adds	r4, r0, r1
 800dbae:	493a      	ldr	r1, [pc, #232]	; (800dc98 <HAL_RCC_GetSysClockFreq+0x168>)
 800dbb0:	fba2 0101 	umull	r0, r1, r2, r1
 800dbb4:	1863      	adds	r3, r4, r1
 800dbb6:	4619      	mov	r1, r3
 800dbb8:	68bb      	ldr	r3, [r7, #8]
 800dbba:	461a      	mov	r2, r3
 800dbbc:	f04f 0300 	mov.w	r3, #0
 800dbc0:	f7f2 fee8 	bl	8000994 <__aeabi_uldivmod>
 800dbc4:	4602      	mov	r2, r0
 800dbc6:	460b      	mov	r3, r1
 800dbc8:	4613      	mov	r3, r2
 800dbca:	603b      	str	r3, [r7, #0]
 800dbcc:	e04a      	b.n	800dc64 <HAL_RCC_GetSysClockFreq+0x134>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800dbce:	4b30      	ldr	r3, [pc, #192]	; (800dc90 <HAL_RCC_GetSysClockFreq+0x160>)
 800dbd0:	685b      	ldr	r3, [r3, #4]
 800dbd2:	099b      	lsrs	r3, r3, #6
 800dbd4:	461a      	mov	r2, r3
 800dbd6:	f04f 0300 	mov.w	r3, #0
 800dbda:	f240 10ff 	movw	r0, #511	; 0x1ff
 800dbde:	f04f 0100 	mov.w	r1, #0
 800dbe2:	ea02 0400 	and.w	r4, r2, r0
 800dbe6:	ea03 0501 	and.w	r5, r3, r1
 800dbea:	4620      	mov	r0, r4
 800dbec:	4629      	mov	r1, r5
 800dbee:	f04f 0200 	mov.w	r2, #0
 800dbf2:	f04f 0300 	mov.w	r3, #0
 800dbf6:	014b      	lsls	r3, r1, #5
 800dbf8:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 800dbfc:	0142      	lsls	r2, r0, #5
 800dbfe:	4610      	mov	r0, r2
 800dc00:	4619      	mov	r1, r3
 800dc02:	1b00      	subs	r0, r0, r4
 800dc04:	eb61 0105 	sbc.w	r1, r1, r5
 800dc08:	f04f 0200 	mov.w	r2, #0
 800dc0c:	f04f 0300 	mov.w	r3, #0
 800dc10:	018b      	lsls	r3, r1, #6
 800dc12:	ea43 6390 	orr.w	r3, r3, r0, lsr #26
 800dc16:	0182      	lsls	r2, r0, #6
 800dc18:	1a12      	subs	r2, r2, r0
 800dc1a:	eb63 0301 	sbc.w	r3, r3, r1
 800dc1e:	f04f 0000 	mov.w	r0, #0
 800dc22:	f04f 0100 	mov.w	r1, #0
 800dc26:	00d9      	lsls	r1, r3, #3
 800dc28:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 800dc2c:	00d0      	lsls	r0, r2, #3
 800dc2e:	4602      	mov	r2, r0
 800dc30:	460b      	mov	r3, r1
 800dc32:	1912      	adds	r2, r2, r4
 800dc34:	eb45 0303 	adc.w	r3, r5, r3
 800dc38:	f04f 0000 	mov.w	r0, #0
 800dc3c:	f04f 0100 	mov.w	r1, #0
 800dc40:	0299      	lsls	r1, r3, #10
 800dc42:	ea41 5192 	orr.w	r1, r1, r2, lsr #22
 800dc46:	0290      	lsls	r0, r2, #10
 800dc48:	4602      	mov	r2, r0
 800dc4a:	460b      	mov	r3, r1
 800dc4c:	4610      	mov	r0, r2
 800dc4e:	4619      	mov	r1, r3
 800dc50:	68bb      	ldr	r3, [r7, #8]
 800dc52:	461a      	mov	r2, r3
 800dc54:	f04f 0300 	mov.w	r3, #0
 800dc58:	f7f2 fe9c 	bl	8000994 <__aeabi_uldivmod>
 800dc5c:	4602      	mov	r2, r0
 800dc5e:	460b      	mov	r3, r1
 800dc60:	4613      	mov	r3, r2
 800dc62:	603b      	str	r3, [r7, #0]
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 800dc64:	4b0a      	ldr	r3, [pc, #40]	; (800dc90 <HAL_RCC_GetSysClockFreq+0x160>)
 800dc66:	685b      	ldr	r3, [r3, #4]
 800dc68:	0c1b      	lsrs	r3, r3, #16
 800dc6a:	f003 0303 	and.w	r3, r3, #3
 800dc6e:	3301      	adds	r3, #1
 800dc70:	005b      	lsls	r3, r3, #1
 800dc72:	60fb      	str	r3, [r7, #12]

      sysclockfreq = pllvco / pllp;
 800dc74:	683a      	ldr	r2, [r7, #0]
 800dc76:	68fb      	ldr	r3, [r7, #12]
 800dc78:	fbb2 f3f3 	udiv	r3, r2, r3
 800dc7c:	607b      	str	r3, [r7, #4]
      break;
 800dc7e:	e002      	b.n	800dc86 <HAL_RCC_GetSysClockFreq+0x156>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 800dc80:	4b04      	ldr	r3, [pc, #16]	; (800dc94 <HAL_RCC_GetSysClockFreq+0x164>)
 800dc82:	607b      	str	r3, [r7, #4]
      break;
 800dc84:	bf00      	nop
    }
  }
  return sysclockfreq;
 800dc86:	687b      	ldr	r3, [r7, #4]
}
 800dc88:	4618      	mov	r0, r3
 800dc8a:	3710      	adds	r7, #16
 800dc8c:	46bd      	mov	sp, r7
 800dc8e:	bdb0      	pop	{r4, r5, r7, pc}
 800dc90:	40023800 	.word	0x40023800
 800dc94:	00f42400 	.word	0x00f42400
 800dc98:	017d7840 	.word	0x017d7840

0800dc9c <HAL_RCC_GetHCLKFreq>:
  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800dc9c:	b480      	push	{r7}
 800dc9e:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800dca0:	4b03      	ldr	r3, [pc, #12]	; (800dcb0 <HAL_RCC_GetHCLKFreq+0x14>)
 800dca2:	681b      	ldr	r3, [r3, #0]
}
 800dca4:	4618      	mov	r0, r3
 800dca6:	46bd      	mov	sp, r7
 800dca8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dcac:	4770      	bx	lr
 800dcae:	bf00      	nop
 800dcb0:	20000404 	.word	0x20000404

0800dcb4 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800dcb4:	b580      	push	{r7, lr}
 800dcb6:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800dcb8:	f7ff fff0 	bl	800dc9c <HAL_RCC_GetHCLKFreq>
 800dcbc:	4602      	mov	r2, r0
 800dcbe:	4b05      	ldr	r3, [pc, #20]	; (800dcd4 <HAL_RCC_GetPCLK1Freq+0x20>)
 800dcc0:	689b      	ldr	r3, [r3, #8]
 800dcc2:	0a9b      	lsrs	r3, r3, #10
 800dcc4:	f003 0307 	and.w	r3, r3, #7
 800dcc8:	4903      	ldr	r1, [pc, #12]	; (800dcd8 <HAL_RCC_GetPCLK1Freq+0x24>)
 800dcca:	5ccb      	ldrb	r3, [r1, r3]
 800dccc:	fa22 f303 	lsr.w	r3, r2, r3
}
 800dcd0:	4618      	mov	r0, r3
 800dcd2:	bd80      	pop	{r7, pc}
 800dcd4:	40023800 	.word	0x40023800
 800dcd8:	080232bc 	.word	0x080232bc

0800dcdc <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800dcdc:	b580      	push	{r7, lr}
 800dcde:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800dce0:	f7ff ffdc 	bl	800dc9c <HAL_RCC_GetHCLKFreq>
 800dce4:	4602      	mov	r2, r0
 800dce6:	4b05      	ldr	r3, [pc, #20]	; (800dcfc <HAL_RCC_GetPCLK2Freq+0x20>)
 800dce8:	689b      	ldr	r3, [r3, #8]
 800dcea:	0b5b      	lsrs	r3, r3, #13
 800dcec:	f003 0307 	and.w	r3, r3, #7
 800dcf0:	4903      	ldr	r1, [pc, #12]	; (800dd00 <HAL_RCC_GetPCLK2Freq+0x24>)
 800dcf2:	5ccb      	ldrb	r3, [r1, r3]
 800dcf4:	fa22 f303 	lsr.w	r3, r2, r3
}
 800dcf8:	4618      	mov	r0, r3
 800dcfa:	bd80      	pop	{r7, pc}
 800dcfc:	40023800 	.word	0x40023800
 800dd00:	080232bc 	.word	0x080232bc

0800dd04 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 800dd04:	b480      	push	{r7}
 800dd06:	b085      	sub	sp, #20
 800dd08:	af00      	add	r7, sp, #0
 800dd0a:	6078      	str	r0, [r7, #4]
 800dd0c:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 800dd0e:	687b      	ldr	r3, [r7, #4]
 800dd10:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800dd12:	2b01      	cmp	r3, #1
 800dd14:	d101      	bne.n	800dd1a <HAL_TIMEx_MasterConfigSynchronization+0x16>
 800dd16:	2302      	movs	r3, #2
 800dd18:	e069      	b.n	800ddee <HAL_TIMEx_MasterConfigSynchronization+0xea>
 800dd1a:	687b      	ldr	r3, [r7, #4]
 800dd1c:	2201      	movs	r2, #1
 800dd1e:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 800dd20:	687b      	ldr	r3, [r7, #4]
 800dd22:	2202      	movs	r2, #2
 800dd24:	641a      	str	r2, [r3, #64]	; 0x40

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800dd26:	687b      	ldr	r3, [r7, #4]
 800dd28:	681b      	ldr	r3, [r3, #0]
 800dd2a:	685b      	ldr	r3, [r3, #4]
 800dd2c:	60bb      	str	r3, [r7, #8]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800dd2e:	687b      	ldr	r3, [r7, #4]
 800dd30:	681b      	ldr	r3, [r3, #0]
 800dd32:	689b      	ldr	r3, [r3, #8]
 800dd34:	60fb      	str	r3, [r7, #12]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800dd36:	687b      	ldr	r3, [r7, #4]
 800dd38:	681b      	ldr	r3, [r3, #0]
 800dd3a:	4a30      	ldr	r2, [pc, #192]	; (800ddfc <HAL_TIMEx_MasterConfigSynchronization+0xf8>)
 800dd3c:	4293      	cmp	r3, r2
 800dd3e:	d004      	beq.n	800dd4a <HAL_TIMEx_MasterConfigSynchronization+0x46>
 800dd40:	687b      	ldr	r3, [r7, #4]
 800dd42:	681b      	ldr	r3, [r3, #0]
 800dd44:	4a2e      	ldr	r2, [pc, #184]	; (800de00 <HAL_TIMEx_MasterConfigSynchronization+0xfc>)
 800dd46:	4293      	cmp	r3, r2
 800dd48:	d108      	bne.n	800dd5c <HAL_TIMEx_MasterConfigSynchronization+0x58>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 800dd4a:	68bb      	ldr	r3, [r7, #8]
 800dd4c:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800dd50:	60bb      	str	r3, [r7, #8]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800dd52:	683b      	ldr	r3, [r7, #0]
 800dd54:	685b      	ldr	r3, [r3, #4]
 800dd56:	68ba      	ldr	r2, [r7, #8]
 800dd58:	4313      	orrs	r3, r2
 800dd5a:	60bb      	str	r3, [r7, #8]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800dd5c:	68bb      	ldr	r3, [r7, #8]
 800dd5e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800dd62:	60bb      	str	r3, [r7, #8]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800dd64:	683b      	ldr	r3, [r7, #0]
 800dd66:	681b      	ldr	r3, [r3, #0]
 800dd68:	68ba      	ldr	r2, [r7, #8]
 800dd6a:	4313      	orrs	r3, r2
 800dd6c:	60bb      	str	r3, [r7, #8]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800dd6e:	687b      	ldr	r3, [r7, #4]
 800dd70:	681b      	ldr	r3, [r3, #0]
 800dd72:	68ba      	ldr	r2, [r7, #8]
 800dd74:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800dd76:	687b      	ldr	r3, [r7, #4]
 800dd78:	681b      	ldr	r3, [r3, #0]
 800dd7a:	4a20      	ldr	r2, [pc, #128]	; (800ddfc <HAL_TIMEx_MasterConfigSynchronization+0xf8>)
 800dd7c:	4293      	cmp	r3, r2
 800dd7e:	d022      	beq.n	800ddc6 <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800dd80:	687b      	ldr	r3, [r7, #4]
 800dd82:	681b      	ldr	r3, [r3, #0]
 800dd84:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800dd88:	d01d      	beq.n	800ddc6 <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800dd8a:	687b      	ldr	r3, [r7, #4]
 800dd8c:	681b      	ldr	r3, [r3, #0]
 800dd8e:	4a1d      	ldr	r2, [pc, #116]	; (800de04 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 800dd90:	4293      	cmp	r3, r2
 800dd92:	d018      	beq.n	800ddc6 <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800dd94:	687b      	ldr	r3, [r7, #4]
 800dd96:	681b      	ldr	r3, [r3, #0]
 800dd98:	4a1b      	ldr	r2, [pc, #108]	; (800de08 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 800dd9a:	4293      	cmp	r3, r2
 800dd9c:	d013      	beq.n	800ddc6 <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800dd9e:	687b      	ldr	r3, [r7, #4]
 800dda0:	681b      	ldr	r3, [r3, #0]
 800dda2:	4a1a      	ldr	r2, [pc, #104]	; (800de0c <HAL_TIMEx_MasterConfigSynchronization+0x108>)
 800dda4:	4293      	cmp	r3, r2
 800dda6:	d00e      	beq.n	800ddc6 <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800dda8:	687b      	ldr	r3, [r7, #4]
 800ddaa:	681b      	ldr	r3, [r3, #0]
 800ddac:	4a14      	ldr	r2, [pc, #80]	; (800de00 <HAL_TIMEx_MasterConfigSynchronization+0xfc>)
 800ddae:	4293      	cmp	r3, r2
 800ddb0:	d009      	beq.n	800ddc6 <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800ddb2:	687b      	ldr	r3, [r7, #4]
 800ddb4:	681b      	ldr	r3, [r3, #0]
 800ddb6:	4a16      	ldr	r2, [pc, #88]	; (800de10 <HAL_TIMEx_MasterConfigSynchronization+0x10c>)
 800ddb8:	4293      	cmp	r3, r2
 800ddba:	d004      	beq.n	800ddc6 <HAL_TIMEx_MasterConfigSynchronization+0xc2>
 800ddbc:	687b      	ldr	r3, [r7, #4]
 800ddbe:	681b      	ldr	r3, [r3, #0]
 800ddc0:	4a14      	ldr	r2, [pc, #80]	; (800de14 <HAL_TIMEx_MasterConfigSynchronization+0x110>)
 800ddc2:	4293      	cmp	r3, r2
 800ddc4:	d10c      	bne.n	800dde0 <HAL_TIMEx_MasterConfigSynchronization+0xdc>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 800ddc6:	68fb      	ldr	r3, [r7, #12]
 800ddc8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800ddcc:	60fb      	str	r3, [r7, #12]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800ddce:	683b      	ldr	r3, [r7, #0]
 800ddd0:	689b      	ldr	r3, [r3, #8]
 800ddd2:	68fa      	ldr	r2, [r7, #12]
 800ddd4:	4313      	orrs	r3, r2
 800ddd6:	60fb      	str	r3, [r7, #12]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800ddd8:	687b      	ldr	r3, [r7, #4]
 800ddda:	681b      	ldr	r3, [r3, #0]
 800dddc:	68fa      	ldr	r2, [r7, #12]
 800ddde:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800dde0:	687b      	ldr	r3, [r7, #4]
 800dde2:	2201      	movs	r2, #1
 800dde4:	641a      	str	r2, [r3, #64]	; 0x40

  __HAL_UNLOCK(htim);
 800dde6:	687b      	ldr	r3, [r7, #4]
 800dde8:	2200      	movs	r2, #0
 800ddea:	63da      	str	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 800ddec:	2300      	movs	r3, #0
}
 800ddee:	4618      	mov	r0, r3
 800ddf0:	3714      	adds	r7, #20
 800ddf2:	46bd      	mov	sp, r7
 800ddf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ddf8:	4770      	bx	lr
 800ddfa:	bf00      	nop
 800ddfc:	40010000 	.word	0x40010000
 800de00:	40010400 	.word	0x40010400
 800de04:	40000400 	.word	0x40000400
 800de08:	40000800 	.word	0x40000800
 800de0c:	40000c00 	.word	0x40000c00
 800de10:	40014000 	.word	0x40014000
 800de14:	40001800 	.word	0x40001800

0800de18 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 800de18:	b480      	push	{r7}
 800de1a:	b083      	sub	sp, #12
 800de1c:	af00      	add	r7, sp, #0
 800de1e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 800de20:	bf00      	nop
 800de22:	370c      	adds	r7, #12
 800de24:	46bd      	mov	sp, r7
 800de26:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de2a:	4770      	bx	lr

0800de2c <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 800de2c:	b480      	push	{r7}
 800de2e:	b083      	sub	sp, #12
 800de30:	af00      	add	r7, sp, #0
 800de32:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 800de34:	bf00      	nop
 800de36:	370c      	adds	r7, #12
 800de38:	46bd      	mov	sp, r7
 800de3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de3e:	4770      	bx	lr

0800de40 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 800de40:	b480      	push	{r7}
 800de42:	b083      	sub	sp, #12
 800de44:	af00      	add	r7, sp, #0
 800de46:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 800de48:	bf00      	nop
 800de4a:	370c      	adds	r7, #12
 800de4c:	46bd      	mov	sp, r7
 800de4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de52:	4770      	bx	lr

0800de54 <HAL_PWR_EnableBkUpAccess>:
  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
  *         Backup Domain Access should be kept enabled.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 800de54:	b480      	push	{r7}
 800de56:	af00      	add	r7, sp, #0
  /* Enable access to RTC and backup registers */
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800de58:	4b05      	ldr	r3, [pc, #20]	; (800de70 <HAL_PWR_EnableBkUpAccess+0x1c>)
 800de5a:	681b      	ldr	r3, [r3, #0]
 800de5c:	4a04      	ldr	r2, [pc, #16]	; (800de70 <HAL_PWR_EnableBkUpAccess+0x1c>)
 800de5e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800de62:	6013      	str	r3, [r2, #0]
}
 800de64:	bf00      	nop
 800de66:	46bd      	mov	sp, r7
 800de68:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de6c:	4770      	bx	lr
 800de6e:	bf00      	nop
 800de70:	40007000 	.word	0x40007000

0800de74 <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing Pointer to SDRAM control timing structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{
 800de74:	b580      	push	{r7, lr}
 800de76:	b082      	sub	sp, #8
 800de78:	af00      	add	r7, sp, #0
 800de7a:	6078      	str	r0, [r7, #4]
 800de7c:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if (hsdram == NULL)
 800de7e:	687b      	ldr	r3, [r7, #4]
 800de80:	2b00      	cmp	r3, #0
 800de82:	d101      	bne.n	800de88 <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
 800de84:	2301      	movs	r3, #1
 800de86:	e020      	b.n	800deca <HAL_SDRAM_Init+0x56>
  }

  if (hsdram->State == HAL_SDRAM_STATE_RESET)
 800de88:	687b      	ldr	r3, [r7, #4]
 800de8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800de8c:	2b00      	cmp	r3, #0
 800de8e:	d105      	bne.n	800de9c <HAL_SDRAM_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
 800de90:	687b      	ldr	r3, [r7, #4]
 800de92:	2200      	movs	r2, #0
 800de94:	631a      	str	r2, [r3, #48]	; 0x30

    /* Init the low level hardware */
    hsdram->MspInitCallback(hsdram);
#else
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
 800de96:	6878      	ldr	r0, [r7, #4]
 800de98:	f7f3 fc8c 	bl	80017b4 <HAL_SDRAM_MspInit>
#endif /* USE_HAL_SDRAM_REGISTER_CALLBACKS */
  }

  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800de9c:	687b      	ldr	r3, [r7, #4]
 800de9e:	2202      	movs	r2, #2
 800dea0:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Initialize SDRAM control Interface */
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800dea2:	687b      	ldr	r3, [r7, #4]
 800dea4:	681a      	ldr	r2, [r3, #0]
 800dea6:	687b      	ldr	r3, [r7, #4]
 800dea8:	3304      	adds	r3, #4
 800deaa:	4619      	mov	r1, r3
 800deac:	4610      	mov	r0, r2
 800deae:	f001 f929 	bl	800f104 <FMC_SDRAM_Init>

  /* Initialize SDRAM timing Interface */
  (void)FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
 800deb2:	687b      	ldr	r3, [r7, #4]
 800deb4:	6818      	ldr	r0, [r3, #0]
 800deb6:	687b      	ldr	r3, [r7, #4]
 800deb8:	685b      	ldr	r3, [r3, #4]
 800deba:	461a      	mov	r2, r3
 800debc:	6839      	ldr	r1, [r7, #0]
 800debe:	f001 f97d 	bl	800f1bc <FMC_SDRAM_Timing_Init>
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 800dec2:	687b      	ldr	r3, [r7, #4]
 800dec4:	2201      	movs	r2, #1
 800dec6:	62da      	str	r2, [r3, #44]	; 0x2c

  return HAL_OK;
 800dec8:	2300      	movs	r3, #0
}
 800deca:	4618      	mov	r0, r3
 800decc:	3708      	adds	r7, #8
 800dece:	46bd      	mov	sp, r7
 800ded0:	bd80      	pop	{r7, pc}

0800ded2 <HAL_SDRAM_SendCommand>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command,
                                        uint32_t Timeout)
{
 800ded2:	b580      	push	{r7, lr}
 800ded4:	b086      	sub	sp, #24
 800ded6:	af00      	add	r7, sp, #0
 800ded8:	60f8      	str	r0, [r7, #12]
 800deda:	60b9      	str	r1, [r7, #8]
 800dedc:	607a      	str	r2, [r7, #4]
  HAL_SDRAM_StateTypeDef state = hsdram->State;
 800dede:	68fb      	ldr	r3, [r7, #12]
 800dee0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dee2:	617b      	str	r3, [r7, #20]

  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
 800dee4:	697b      	ldr	r3, [r7, #20]
 800dee6:	2b02      	cmp	r3, #2
 800dee8:	d101      	bne.n	800deee <HAL_SDRAM_SendCommand+0x1c>
  {
    return HAL_BUSY;
 800deea:	2302      	movs	r3, #2
 800deec:	e01e      	b.n	800df2c <HAL_SDRAM_SendCommand+0x5a>
  }
  else if ((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_PRECHARGED))
 800deee:	697b      	ldr	r3, [r7, #20]
 800def0:	2b01      	cmp	r3, #1
 800def2:	d002      	beq.n	800defa <HAL_SDRAM_SendCommand+0x28>
 800def4:	697b      	ldr	r3, [r7, #20]
 800def6:	2b05      	cmp	r3, #5
 800def8:	d115      	bne.n	800df26 <HAL_SDRAM_SendCommand+0x54>
  {
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800defa:	68fb      	ldr	r3, [r7, #12]
 800defc:	2202      	movs	r2, #2
 800defe:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Send SDRAM command */
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800df00:	68fb      	ldr	r3, [r7, #12]
 800df02:	681b      	ldr	r3, [r3, #0]
 800df04:	687a      	ldr	r2, [r7, #4]
 800df06:	68b9      	ldr	r1, [r7, #8]
 800df08:	4618      	mov	r0, r3
 800df0a:	f001 f9c1 	bl	800f290 <FMC_SDRAM_SendCommand>

    /* Update the SDRAM controller state state */
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800df0e:	68bb      	ldr	r3, [r7, #8]
 800df10:	681b      	ldr	r3, [r3, #0]
 800df12:	2b02      	cmp	r3, #2
 800df14:	d103      	bne.n	800df1e <HAL_SDRAM_SendCommand+0x4c>
    {
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800df16:	68fb      	ldr	r3, [r7, #12]
 800df18:	2205      	movs	r2, #5
 800df1a:	62da      	str	r2, [r3, #44]	; 0x2c
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800df1c:	e005      	b.n	800df2a <HAL_SDRAM_SendCommand+0x58>
    }
    else
    {
      hsdram->State = HAL_SDRAM_STATE_READY;
 800df1e:	68fb      	ldr	r3, [r7, #12]
 800df20:	2201      	movs	r2, #1
 800df22:	62da      	str	r2, [r3, #44]	; 0x2c
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800df24:	e001      	b.n	800df2a <HAL_SDRAM_SendCommand+0x58>
    }
  }
  else
  {
    return HAL_ERROR;
 800df26:	2301      	movs	r3, #1
 800df28:	e000      	b.n	800df2c <HAL_SDRAM_SendCommand+0x5a>
  }

  return HAL_OK;
 800df2a:	2300      	movs	r3, #0
}
 800df2c:	4618      	mov	r0, r3
 800df2e:	3718      	adds	r7, #24
 800df30:	46bd      	mov	sp, r7
 800df32:	bd80      	pop	{r7, pc}

0800df34 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 800df34:	b580      	push	{r7, lr}
 800df36:	b082      	sub	sp, #8
 800df38:	af00      	add	r7, sp, #0
 800df3a:	6078      	str	r0, [r7, #4]
 800df3c:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
 800df3e:	687b      	ldr	r3, [r7, #4]
 800df40:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800df42:	2b02      	cmp	r3, #2
 800df44:	d101      	bne.n	800df4a <HAL_SDRAM_ProgramRefreshRate+0x16>
  {
    return HAL_BUSY;
 800df46:	2302      	movs	r3, #2
 800df48:	e012      	b.n	800df70 <HAL_SDRAM_ProgramRefreshRate+0x3c>
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
 800df4a:	687b      	ldr	r3, [r7, #4]
 800df4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800df4e:	2b01      	cmp	r3, #1
 800df50:	d10d      	bne.n	800df6e <HAL_SDRAM_ProgramRefreshRate+0x3a>
  {
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800df52:	687b      	ldr	r3, [r7, #4]
 800df54:	2202      	movs	r2, #2
 800df56:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Program the refresh rate */
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
 800df58:	687b      	ldr	r3, [r7, #4]
 800df5a:	681b      	ldr	r3, [r3, #0]
 800df5c:	6839      	ldr	r1, [r7, #0]
 800df5e:	4618      	mov	r0, r3
 800df60:	f001 f9ba 	bl	800f2d8 <FMC_SDRAM_ProgramRefreshRate>

    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_READY;
 800df64:	687b      	ldr	r3, [r7, #4]
 800df66:	2201      	movs	r2, #1
 800df68:	62da      	str	r2, [r3, #44]	; 0x2c
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
 800df6a:	2300      	movs	r3, #0
 800df6c:	e000      	b.n	800df70 <HAL_SDRAM_ProgramRefreshRate+0x3c>
    return HAL_ERROR;
 800df6e:	2301      	movs	r3, #1
}
 800df70:	4618      	mov	r0, r3
 800df72:	3708      	adds	r7, #8
 800df74:	46bd      	mov	sp, r7
 800df76:	bd80      	pop	{r7, pc}

0800df78 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800df78:	b480      	push	{r7}
 800df7a:	b085      	sub	sp, #20
 800df7c:	af00      	add	r7, sp, #0
 800df7e:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800df80:	687b      	ldr	r3, [r7, #4]
 800df82:	f003 0307 	and.w	r3, r3, #7
 800df86:	60bb      	str	r3, [r7, #8]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800df88:	4b0b      	ldr	r3, [pc, #44]	; (800dfb8 <__NVIC_SetPriorityGrouping+0x40>)
 800df8a:	68db      	ldr	r3, [r3, #12]
 800df8c:	60fb      	str	r3, [r7, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800df8e:	68fa      	ldr	r2, [r7, #12]
 800df90:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800df94:	4013      	ands	r3, r2
 800df96:	60fb      	str	r3, [r7, #12]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800df98:	68bb      	ldr	r3, [r7, #8]
 800df9a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800df9c:	68fb      	ldr	r3, [r7, #12]
 800df9e:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
 800dfa0:	4b06      	ldr	r3, [pc, #24]	; (800dfbc <__NVIC_SetPriorityGrouping+0x44>)
 800dfa2:	4313      	orrs	r3, r2
 800dfa4:	60fb      	str	r3, [r7, #12]
  SCB->AIRCR =  reg_value;
 800dfa6:	4a04      	ldr	r2, [pc, #16]	; (800dfb8 <__NVIC_SetPriorityGrouping+0x40>)
 800dfa8:	68fb      	ldr	r3, [r7, #12]
 800dfaa:	60d3      	str	r3, [r2, #12]
}
 800dfac:	bf00      	nop
 800dfae:	3714      	adds	r7, #20
 800dfb0:	46bd      	mov	sp, r7
 800dfb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dfb6:	4770      	bx	lr
 800dfb8:	e000ed00 	.word	0xe000ed00
 800dfbc:	05fa0000 	.word	0x05fa0000

0800dfc0 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 800dfc0:	b480      	push	{r7}
 800dfc2:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800dfc4:	4b04      	ldr	r3, [pc, #16]	; (800dfd8 <__NVIC_GetPriorityGrouping+0x18>)
 800dfc6:	68db      	ldr	r3, [r3, #12]
 800dfc8:	0a1b      	lsrs	r3, r3, #8
 800dfca:	f003 0307 	and.w	r3, r3, #7
}
 800dfce:	4618      	mov	r0, r3
 800dfd0:	46bd      	mov	sp, r7
 800dfd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dfd6:	4770      	bx	lr
 800dfd8:	e000ed00 	.word	0xe000ed00

0800dfdc <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800dfdc:	b480      	push	{r7}
 800dfde:	b083      	sub	sp, #12
 800dfe0:	af00      	add	r7, sp, #0
 800dfe2:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 800dfe4:	687b      	ldr	r3, [r7, #4]
 800dfe6:	2b00      	cmp	r3, #0
 800dfe8:	db0a      	blt.n	800e000 <__NVIC_EnableIRQ+0x24>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800dfea:	687b      	ldr	r3, [r7, #4]
 800dfec:	f003 021f 	and.w	r2, r3, #31
 800dff0:	4906      	ldr	r1, [pc, #24]	; (800e00c <__NVIC_EnableIRQ+0x30>)
 800dff2:	687b      	ldr	r3, [r7, #4]
 800dff4:	095b      	lsrs	r3, r3, #5
 800dff6:	2001      	movs	r0, #1
 800dff8:	fa00 f202 	lsl.w	r2, r0, r2
 800dffc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 800e000:	bf00      	nop
 800e002:	370c      	adds	r7, #12
 800e004:	46bd      	mov	sp, r7
 800e006:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e00a:	4770      	bx	lr
 800e00c:	e000e100 	.word	0xe000e100

0800e010 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800e010:	b480      	push	{r7}
 800e012:	b083      	sub	sp, #12
 800e014:	af00      	add	r7, sp, #0
 800e016:	6078      	str	r0, [r7, #4]
 800e018:	6039      	str	r1, [r7, #0]
  if ((int32_t)(IRQn) >= 0)
 800e01a:	687b      	ldr	r3, [r7, #4]
 800e01c:	2b00      	cmp	r3, #0
 800e01e:	db09      	blt.n	800e034 <__NVIC_SetPriority+0x24>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800e020:	683b      	ldr	r3, [r7, #0]
 800e022:	b2da      	uxtb	r2, r3
 800e024:	490c      	ldr	r1, [pc, #48]	; (800e058 <__NVIC_SetPriority+0x48>)
 800e026:	687b      	ldr	r3, [r7, #4]
 800e028:	0112      	lsls	r2, r2, #4
 800e02a:	b2d2      	uxtb	r2, r2
 800e02c:	440b      	add	r3, r1
 800e02e:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 800e032:	e00a      	b.n	800e04a <__NVIC_SetPriority+0x3a>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800e034:	683b      	ldr	r3, [r7, #0]
 800e036:	b2da      	uxtb	r2, r3
 800e038:	4908      	ldr	r1, [pc, #32]	; (800e05c <__NVIC_SetPriority+0x4c>)
 800e03a:	687b      	ldr	r3, [r7, #4]
 800e03c:	f003 030f 	and.w	r3, r3, #15
 800e040:	3b04      	subs	r3, #4
 800e042:	0112      	lsls	r2, r2, #4
 800e044:	b2d2      	uxtb	r2, r2
 800e046:	440b      	add	r3, r1
 800e048:	761a      	strb	r2, [r3, #24]
}
 800e04a:	bf00      	nop
 800e04c:	370c      	adds	r7, #12
 800e04e:	46bd      	mov	sp, r7
 800e050:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e054:	4770      	bx	lr
 800e056:	bf00      	nop
 800e058:	e000e100 	.word	0xe000e100
 800e05c:	e000ed00 	.word	0xe000ed00

0800e060 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800e060:	b480      	push	{r7}
 800e062:	b089      	sub	sp, #36	; 0x24
 800e064:	af00      	add	r7, sp, #0
 800e066:	60f8      	str	r0, [r7, #12]
 800e068:	60b9      	str	r1, [r7, #8]
 800e06a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800e06c:	68fb      	ldr	r3, [r7, #12]
 800e06e:	f003 0307 	and.w	r3, r3, #7
 800e072:	617b      	str	r3, [r7, #20]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800e074:	697b      	ldr	r3, [r7, #20]
 800e076:	f1c3 0307 	rsb	r3, r3, #7
 800e07a:	2b04      	cmp	r3, #4
 800e07c:	bf28      	it	cs
 800e07e:	2304      	movcs	r3, #4
 800e080:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800e082:	697b      	ldr	r3, [r7, #20]
 800e084:	3304      	adds	r3, #4
 800e086:	2b06      	cmp	r3, #6
 800e088:	d902      	bls.n	800e090 <NVIC_EncodePriority+0x30>
 800e08a:	697b      	ldr	r3, [r7, #20]
 800e08c:	3b03      	subs	r3, #3
 800e08e:	e000      	b.n	800e092 <NVIC_EncodePriority+0x32>
 800e090:	2300      	movs	r3, #0
 800e092:	61fb      	str	r3, [r7, #28]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800e094:	2201      	movs	r2, #1
 800e096:	69bb      	ldr	r3, [r7, #24]
 800e098:	fa02 f303 	lsl.w	r3, r2, r3
 800e09c:	1e5a      	subs	r2, r3, #1
 800e09e:	68bb      	ldr	r3, [r7, #8]
 800e0a0:	401a      	ands	r2, r3
 800e0a2:	69fb      	ldr	r3, [r7, #28]
 800e0a4:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800e0a6:	2101      	movs	r1, #1
 800e0a8:	69fb      	ldr	r3, [r7, #28]
 800e0aa:	fa01 f303 	lsl.w	r3, r1, r3
 800e0ae:	1e59      	subs	r1, r3, #1
 800e0b0:	687b      	ldr	r3, [r7, #4]
 800e0b2:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800e0b4:	4313      	orrs	r3, r2
         );
}
 800e0b6:	4618      	mov	r0, r3
 800e0b8:	3724      	adds	r7, #36	; 0x24
 800e0ba:	46bd      	mov	sp, r7
 800e0bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e0c0:	4770      	bx	lr
	...

0800e0c4 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800e0c4:	b580      	push	{r7, lr}
 800e0c6:	b082      	sub	sp, #8
 800e0c8:	af00      	add	r7, sp, #0
 800e0ca:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800e0cc:	687b      	ldr	r3, [r7, #4]
 800e0ce:	3b01      	subs	r3, #1
 800e0d0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800e0d4:	d301      	bcc.n	800e0da <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800e0d6:	2301      	movs	r3, #1
 800e0d8:	e00f      	b.n	800e0fa <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800e0da:	4a0a      	ldr	r2, [pc, #40]	; (800e104 <SysTick_Config+0x40>)
 800e0dc:	687b      	ldr	r3, [r7, #4]
 800e0de:	3b01      	subs	r3, #1
 800e0e0:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800e0e2:	210f      	movs	r1, #15
 800e0e4:	f04f 30ff 	mov.w	r0, #4294967295
 800e0e8:	f7ff ff92 	bl	800e010 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800e0ec:	4b05      	ldr	r3, [pc, #20]	; (800e104 <SysTick_Config+0x40>)
 800e0ee:	2200      	movs	r2, #0
 800e0f0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800e0f2:	4b04      	ldr	r3, [pc, #16]	; (800e104 <SysTick_Config+0x40>)
 800e0f4:	2207      	movs	r2, #7
 800e0f6:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800e0f8:	2300      	movs	r3, #0
}
 800e0fa:	4618      	mov	r0, r3
 800e0fc:	3708      	adds	r7, #8
 800e0fe:	46bd      	mov	sp, r7
 800e100:	bd80      	pop	{r7, pc}
 800e102:	bf00      	nop
 800e104:	e000e010 	.word	0xe000e010

0800e108 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800e108:	b580      	push	{r7, lr}
 800e10a:	b082      	sub	sp, #8
 800e10c:	af00      	add	r7, sp, #0
 800e10e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800e110:	6878      	ldr	r0, [r7, #4]
 800e112:	f7ff ff31 	bl	800df78 <__NVIC_SetPriorityGrouping>
}
 800e116:	bf00      	nop
 800e118:	3708      	adds	r7, #8
 800e11a:	46bd      	mov	sp, r7
 800e11c:	bd80      	pop	{r7, pc}

0800e11e <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800e11e:	b580      	push	{r7, lr}
 800e120:	b086      	sub	sp, #24
 800e122:	af00      	add	r7, sp, #0
 800e124:	60f8      	str	r0, [r7, #12]
 800e126:	60b9      	str	r1, [r7, #8]
 800e128:	607a      	str	r2, [r7, #4]
  uint32_t prioritygroup = 0x00;
 800e12a:	2300      	movs	r3, #0
 800e12c:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800e12e:	f7ff ff47 	bl	800dfc0 <__NVIC_GetPriorityGrouping>
 800e132:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800e134:	687a      	ldr	r2, [r7, #4]
 800e136:	68b9      	ldr	r1, [r7, #8]
 800e138:	6978      	ldr	r0, [r7, #20]
 800e13a:	f7ff ff91 	bl	800e060 <NVIC_EncodePriority>
 800e13e:	4603      	mov	r3, r0
 800e140:	4619      	mov	r1, r3
 800e142:	68f8      	ldr	r0, [r7, #12]
 800e144:	f7ff ff64 	bl	800e010 <__NVIC_SetPriority>
}
 800e148:	bf00      	nop
 800e14a:	3718      	adds	r7, #24
 800e14c:	46bd      	mov	sp, r7
 800e14e:	bd80      	pop	{r7, pc}

0800e150 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800e150:	b580      	push	{r7, lr}
 800e152:	b082      	sub	sp, #8
 800e154:	af00      	add	r7, sp, #0
 800e156:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800e158:	6878      	ldr	r0, [r7, #4]
 800e15a:	f7ff ff3f 	bl	800dfdc <__NVIC_EnableIRQ>
}
 800e15e:	bf00      	nop
 800e160:	3708      	adds	r7, #8
 800e162:	46bd      	mov	sp, r7
 800e164:	bd80      	pop	{r7, pc}

0800e166 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800e166:	b580      	push	{r7, lr}
 800e168:	b082      	sub	sp, #8
 800e16a:	af00      	add	r7, sp, #0
 800e16c:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800e16e:	6878      	ldr	r0, [r7, #4]
 800e170:	f7ff ffa8 	bl	800e0c4 <SysTick_Config>
 800e174:	4603      	mov	r3, r0
}
 800e176:	4618      	mov	r0, r3
 800e178:	3708      	adds	r7, #8
 800e17a:	46bd      	mov	sp, r7
 800e17c:	bd80      	pop	{r7, pc}
	...

0800e180 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800e180:	b480      	push	{r7}
 800e182:	b089      	sub	sp, #36	; 0x24
 800e184:	af00      	add	r7, sp, #0
 800e186:	6078      	str	r0, [r7, #4]
 800e188:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00;
 800e18a:	2300      	movs	r3, #0
 800e18c:	613b      	str	r3, [r7, #16]
  uint32_t ioposition = 0x00;
 800e18e:	2300      	movs	r3, #0
 800e190:	61bb      	str	r3, [r7, #24]
  uint32_t iocurrent = 0x00;
 800e192:	2300      	movs	r3, #0
 800e194:	61fb      	str	r3, [r7, #28]
  uint32_t temp = 0x00;
 800e196:	2300      	movs	r3, #0
 800e198:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800e19a:	2300      	movs	r3, #0
 800e19c:	613b      	str	r3, [r7, #16]
 800e19e:	e175      	b.n	800e48c <HAL_GPIO_Init+0x30c>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 800e1a0:	2201      	movs	r2, #1
 800e1a2:	693b      	ldr	r3, [r7, #16]
 800e1a4:	fa02 f303 	lsl.w	r3, r2, r3
 800e1a8:	61bb      	str	r3, [r7, #24]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800e1aa:	683b      	ldr	r3, [r7, #0]
 800e1ac:	681b      	ldr	r3, [r3, #0]
 800e1ae:	69ba      	ldr	r2, [r7, #24]
 800e1b0:	4013      	ands	r3, r2
 800e1b2:	61fb      	str	r3, [r7, #28]

    if(iocurrent == ioposition)
 800e1b4:	69fa      	ldr	r2, [r7, #28]
 800e1b6:	69bb      	ldr	r3, [r7, #24]
 800e1b8:	429a      	cmp	r2, r3
 800e1ba:	f040 8164 	bne.w	800e486 <HAL_GPIO_Init+0x306>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800e1be:	683b      	ldr	r3, [r7, #0]
 800e1c0:	685b      	ldr	r3, [r3, #4]
 800e1c2:	f003 0303 	and.w	r3, r3, #3
 800e1c6:	2b01      	cmp	r3, #1
 800e1c8:	d005      	beq.n	800e1d6 <HAL_GPIO_Init+0x56>
 800e1ca:	683b      	ldr	r3, [r7, #0]
 800e1cc:	685b      	ldr	r3, [r3, #4]
 800e1ce:	f003 0303 	and.w	r3, r3, #3
 800e1d2:	2b02      	cmp	r3, #2
 800e1d4:	d130      	bne.n	800e238 <HAL_GPIO_Init+0xb8>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 800e1d6:	687b      	ldr	r3, [r7, #4]
 800e1d8:	689b      	ldr	r3, [r3, #8]
 800e1da:	617b      	str	r3, [r7, #20]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800e1dc:	693b      	ldr	r3, [r7, #16]
 800e1de:	005b      	lsls	r3, r3, #1
 800e1e0:	2203      	movs	r2, #3
 800e1e2:	fa02 f303 	lsl.w	r3, r2, r3
 800e1e6:	43db      	mvns	r3, r3
 800e1e8:	697a      	ldr	r2, [r7, #20]
 800e1ea:	4013      	ands	r3, r2
 800e1ec:	617b      	str	r3, [r7, #20]
        temp |= (GPIO_Init->Speed << (position * 2));
 800e1ee:	683b      	ldr	r3, [r7, #0]
 800e1f0:	68da      	ldr	r2, [r3, #12]
 800e1f2:	693b      	ldr	r3, [r7, #16]
 800e1f4:	005b      	lsls	r3, r3, #1
 800e1f6:	fa02 f303 	lsl.w	r3, r2, r3
 800e1fa:	697a      	ldr	r2, [r7, #20]
 800e1fc:	4313      	orrs	r3, r2
 800e1fe:	617b      	str	r3, [r7, #20]
        GPIOx->OSPEEDR = temp;
 800e200:	687b      	ldr	r3, [r7, #4]
 800e202:	697a      	ldr	r2, [r7, #20]
 800e204:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800e206:	687b      	ldr	r3, [r7, #4]
 800e208:	685b      	ldr	r3, [r3, #4]
 800e20a:	617b      	str	r3, [r7, #20]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800e20c:	2201      	movs	r2, #1
 800e20e:	693b      	ldr	r3, [r7, #16]
 800e210:	fa02 f303 	lsl.w	r3, r2, r3
 800e214:	43db      	mvns	r3, r3
 800e216:	697a      	ldr	r2, [r7, #20]
 800e218:	4013      	ands	r3, r2
 800e21a:	617b      	str	r3, [r7, #20]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800e21c:	683b      	ldr	r3, [r7, #0]
 800e21e:	685b      	ldr	r3, [r3, #4]
 800e220:	091b      	lsrs	r3, r3, #4
 800e222:	f003 0201 	and.w	r2, r3, #1
 800e226:	693b      	ldr	r3, [r7, #16]
 800e228:	fa02 f303 	lsl.w	r3, r2, r3
 800e22c:	697a      	ldr	r2, [r7, #20]
 800e22e:	4313      	orrs	r3, r2
 800e230:	617b      	str	r3, [r7, #20]
        GPIOx->OTYPER = temp;
 800e232:	687b      	ldr	r3, [r7, #4]
 800e234:	697a      	ldr	r2, [r7, #20]
 800e236:	605a      	str	r2, [r3, #4]
      }
      
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800e238:	683b      	ldr	r3, [r7, #0]
 800e23a:	685b      	ldr	r3, [r3, #4]
 800e23c:	f003 0303 	and.w	r3, r3, #3
 800e240:	2b03      	cmp	r3, #3
 800e242:	d017      	beq.n	800e274 <HAL_GPIO_Init+0xf4>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 800e244:	687b      	ldr	r3, [r7, #4]
 800e246:	68db      	ldr	r3, [r3, #12]
 800e248:	617b      	str	r3, [r7, #20]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 800e24a:	693b      	ldr	r3, [r7, #16]
 800e24c:	005b      	lsls	r3, r3, #1
 800e24e:	2203      	movs	r2, #3
 800e250:	fa02 f303 	lsl.w	r3, r2, r3
 800e254:	43db      	mvns	r3, r3
 800e256:	697a      	ldr	r2, [r7, #20]
 800e258:	4013      	ands	r3, r2
 800e25a:	617b      	str	r3, [r7, #20]
        temp |= ((GPIO_Init->Pull) << (position * 2));
 800e25c:	683b      	ldr	r3, [r7, #0]
 800e25e:	689a      	ldr	r2, [r3, #8]
 800e260:	693b      	ldr	r3, [r7, #16]
 800e262:	005b      	lsls	r3, r3, #1
 800e264:	fa02 f303 	lsl.w	r3, r2, r3
 800e268:	697a      	ldr	r2, [r7, #20]
 800e26a:	4313      	orrs	r3, r2
 800e26c:	617b      	str	r3, [r7, #20]
        GPIOx->PUPDR = temp;
 800e26e:	687b      	ldr	r3, [r7, #4]
 800e270:	697a      	ldr	r2, [r7, #20]
 800e272:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800e274:	683b      	ldr	r3, [r7, #0]
 800e276:	685b      	ldr	r3, [r3, #4]
 800e278:	f003 0303 	and.w	r3, r3, #3
 800e27c:	2b02      	cmp	r3, #2
 800e27e:	d123      	bne.n	800e2c8 <HAL_GPIO_Init+0x148>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 800e280:	693b      	ldr	r3, [r7, #16]
 800e282:	08da      	lsrs	r2, r3, #3
 800e284:	687b      	ldr	r3, [r7, #4]
 800e286:	3208      	adds	r2, #8
 800e288:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e28c:	617b      	str	r3, [r7, #20]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800e28e:	693b      	ldr	r3, [r7, #16]
 800e290:	f003 0307 	and.w	r3, r3, #7
 800e294:	009b      	lsls	r3, r3, #2
 800e296:	220f      	movs	r2, #15
 800e298:	fa02 f303 	lsl.w	r3, r2, r3
 800e29c:	43db      	mvns	r3, r3
 800e29e:	697a      	ldr	r2, [r7, #20]
 800e2a0:	4013      	ands	r3, r2
 800e2a2:	617b      	str	r3, [r7, #20]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800e2a4:	683b      	ldr	r3, [r7, #0]
 800e2a6:	691a      	ldr	r2, [r3, #16]
 800e2a8:	693b      	ldr	r3, [r7, #16]
 800e2aa:	f003 0307 	and.w	r3, r3, #7
 800e2ae:	009b      	lsls	r3, r3, #2
 800e2b0:	fa02 f303 	lsl.w	r3, r2, r3
 800e2b4:	697a      	ldr	r2, [r7, #20]
 800e2b6:	4313      	orrs	r3, r2
 800e2b8:	617b      	str	r3, [r7, #20]
        GPIOx->AFR[position >> 3] = temp;
 800e2ba:	693b      	ldr	r3, [r7, #16]
 800e2bc:	08da      	lsrs	r2, r3, #3
 800e2be:	687b      	ldr	r3, [r7, #4]
 800e2c0:	3208      	adds	r2, #8
 800e2c2:	6979      	ldr	r1, [r7, #20]
 800e2c4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }
      
      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800e2c8:	687b      	ldr	r3, [r7, #4]
 800e2ca:	681b      	ldr	r3, [r3, #0]
 800e2cc:	617b      	str	r3, [r7, #20]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 800e2ce:	693b      	ldr	r3, [r7, #16]
 800e2d0:	005b      	lsls	r3, r3, #1
 800e2d2:	2203      	movs	r2, #3
 800e2d4:	fa02 f303 	lsl.w	r3, r2, r3
 800e2d8:	43db      	mvns	r3, r3
 800e2da:	697a      	ldr	r2, [r7, #20]
 800e2dc:	4013      	ands	r3, r2
 800e2de:	617b      	str	r3, [r7, #20]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800e2e0:	683b      	ldr	r3, [r7, #0]
 800e2e2:	685b      	ldr	r3, [r3, #4]
 800e2e4:	f003 0203 	and.w	r2, r3, #3
 800e2e8:	693b      	ldr	r3, [r7, #16]
 800e2ea:	005b      	lsls	r3, r3, #1
 800e2ec:	fa02 f303 	lsl.w	r3, r2, r3
 800e2f0:	697a      	ldr	r2, [r7, #20]
 800e2f2:	4313      	orrs	r3, r2
 800e2f4:	617b      	str	r3, [r7, #20]
      GPIOx->MODER = temp;
 800e2f6:	687b      	ldr	r3, [r7, #4]
 800e2f8:	697a      	ldr	r2, [r7, #20]
 800e2fa:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 800e2fc:	683b      	ldr	r3, [r7, #0]
 800e2fe:	685b      	ldr	r3, [r3, #4]
 800e300:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800e304:	2b00      	cmp	r3, #0
 800e306:	f000 80be 	beq.w	800e486 <HAL_GPIO_Init+0x306>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800e30a:	4b66      	ldr	r3, [pc, #408]	; (800e4a4 <HAL_GPIO_Init+0x324>)
 800e30c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e30e:	4a65      	ldr	r2, [pc, #404]	; (800e4a4 <HAL_GPIO_Init+0x324>)
 800e310:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800e314:	6453      	str	r3, [r2, #68]	; 0x44
 800e316:	4b63      	ldr	r3, [pc, #396]	; (800e4a4 <HAL_GPIO_Init+0x324>)
 800e318:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e31a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800e31e:	60fb      	str	r3, [r7, #12]
 800e320:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 800e322:	4a61      	ldr	r2, [pc, #388]	; (800e4a8 <HAL_GPIO_Init+0x328>)
 800e324:	693b      	ldr	r3, [r7, #16]
 800e326:	089b      	lsrs	r3, r3, #2
 800e328:	3302      	adds	r3, #2
 800e32a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e32e:	617b      	str	r3, [r7, #20]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800e330:	693b      	ldr	r3, [r7, #16]
 800e332:	f003 0303 	and.w	r3, r3, #3
 800e336:	009b      	lsls	r3, r3, #2
 800e338:	220f      	movs	r2, #15
 800e33a:	fa02 f303 	lsl.w	r3, r2, r3
 800e33e:	43db      	mvns	r3, r3
 800e340:	697a      	ldr	r2, [r7, #20]
 800e342:	4013      	ands	r3, r2
 800e344:	617b      	str	r3, [r7, #20]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800e346:	687b      	ldr	r3, [r7, #4]
 800e348:	4a58      	ldr	r2, [pc, #352]	; (800e4ac <HAL_GPIO_Init+0x32c>)
 800e34a:	4293      	cmp	r3, r2
 800e34c:	d037      	beq.n	800e3be <HAL_GPIO_Init+0x23e>
 800e34e:	687b      	ldr	r3, [r7, #4]
 800e350:	4a57      	ldr	r2, [pc, #348]	; (800e4b0 <HAL_GPIO_Init+0x330>)
 800e352:	4293      	cmp	r3, r2
 800e354:	d031      	beq.n	800e3ba <HAL_GPIO_Init+0x23a>
 800e356:	687b      	ldr	r3, [r7, #4]
 800e358:	4a56      	ldr	r2, [pc, #344]	; (800e4b4 <HAL_GPIO_Init+0x334>)
 800e35a:	4293      	cmp	r3, r2
 800e35c:	d02b      	beq.n	800e3b6 <HAL_GPIO_Init+0x236>
 800e35e:	687b      	ldr	r3, [r7, #4]
 800e360:	4a55      	ldr	r2, [pc, #340]	; (800e4b8 <HAL_GPIO_Init+0x338>)
 800e362:	4293      	cmp	r3, r2
 800e364:	d025      	beq.n	800e3b2 <HAL_GPIO_Init+0x232>
 800e366:	687b      	ldr	r3, [r7, #4]
 800e368:	4a54      	ldr	r2, [pc, #336]	; (800e4bc <HAL_GPIO_Init+0x33c>)
 800e36a:	4293      	cmp	r3, r2
 800e36c:	d01f      	beq.n	800e3ae <HAL_GPIO_Init+0x22e>
 800e36e:	687b      	ldr	r3, [r7, #4]
 800e370:	4a53      	ldr	r2, [pc, #332]	; (800e4c0 <HAL_GPIO_Init+0x340>)
 800e372:	4293      	cmp	r3, r2
 800e374:	d019      	beq.n	800e3aa <HAL_GPIO_Init+0x22a>
 800e376:	687b      	ldr	r3, [r7, #4]
 800e378:	4a52      	ldr	r2, [pc, #328]	; (800e4c4 <HAL_GPIO_Init+0x344>)
 800e37a:	4293      	cmp	r3, r2
 800e37c:	d013      	beq.n	800e3a6 <HAL_GPIO_Init+0x226>
 800e37e:	687b      	ldr	r3, [r7, #4]
 800e380:	4a51      	ldr	r2, [pc, #324]	; (800e4c8 <HAL_GPIO_Init+0x348>)
 800e382:	4293      	cmp	r3, r2
 800e384:	d00d      	beq.n	800e3a2 <HAL_GPIO_Init+0x222>
 800e386:	687b      	ldr	r3, [r7, #4]
 800e388:	4a50      	ldr	r2, [pc, #320]	; (800e4cc <HAL_GPIO_Init+0x34c>)
 800e38a:	4293      	cmp	r3, r2
 800e38c:	d007      	beq.n	800e39e <HAL_GPIO_Init+0x21e>
 800e38e:	687b      	ldr	r3, [r7, #4]
 800e390:	4a4f      	ldr	r2, [pc, #316]	; (800e4d0 <HAL_GPIO_Init+0x350>)
 800e392:	4293      	cmp	r3, r2
 800e394:	d101      	bne.n	800e39a <HAL_GPIO_Init+0x21a>
 800e396:	2309      	movs	r3, #9
 800e398:	e012      	b.n	800e3c0 <HAL_GPIO_Init+0x240>
 800e39a:	230a      	movs	r3, #10
 800e39c:	e010      	b.n	800e3c0 <HAL_GPIO_Init+0x240>
 800e39e:	2308      	movs	r3, #8
 800e3a0:	e00e      	b.n	800e3c0 <HAL_GPIO_Init+0x240>
 800e3a2:	2307      	movs	r3, #7
 800e3a4:	e00c      	b.n	800e3c0 <HAL_GPIO_Init+0x240>
 800e3a6:	2306      	movs	r3, #6
 800e3a8:	e00a      	b.n	800e3c0 <HAL_GPIO_Init+0x240>
 800e3aa:	2305      	movs	r3, #5
 800e3ac:	e008      	b.n	800e3c0 <HAL_GPIO_Init+0x240>
 800e3ae:	2304      	movs	r3, #4
 800e3b0:	e006      	b.n	800e3c0 <HAL_GPIO_Init+0x240>
 800e3b2:	2303      	movs	r3, #3
 800e3b4:	e004      	b.n	800e3c0 <HAL_GPIO_Init+0x240>
 800e3b6:	2302      	movs	r3, #2
 800e3b8:	e002      	b.n	800e3c0 <HAL_GPIO_Init+0x240>
 800e3ba:	2301      	movs	r3, #1
 800e3bc:	e000      	b.n	800e3c0 <HAL_GPIO_Init+0x240>
 800e3be:	2300      	movs	r3, #0
 800e3c0:	693a      	ldr	r2, [r7, #16]
 800e3c2:	f002 0203 	and.w	r2, r2, #3
 800e3c6:	0092      	lsls	r2, r2, #2
 800e3c8:	4093      	lsls	r3, r2
 800e3ca:	697a      	ldr	r2, [r7, #20]
 800e3cc:	4313      	orrs	r3, r2
 800e3ce:	617b      	str	r3, [r7, #20]
        SYSCFG->EXTICR[position >> 2] = temp;
 800e3d0:	4935      	ldr	r1, [pc, #212]	; (800e4a8 <HAL_GPIO_Init+0x328>)
 800e3d2:	693b      	ldr	r3, [r7, #16]
 800e3d4:	089b      	lsrs	r3, r3, #2
 800e3d6:	3302      	adds	r3, #2
 800e3d8:	697a      	ldr	r2, [r7, #20]
 800e3da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800e3de:	4b3d      	ldr	r3, [pc, #244]	; (800e4d4 <HAL_GPIO_Init+0x354>)
 800e3e0:	689b      	ldr	r3, [r3, #8]
 800e3e2:	617b      	str	r3, [r7, #20]
        temp &= ~((uint32_t)iocurrent);
 800e3e4:	69fb      	ldr	r3, [r7, #28]
 800e3e6:	43db      	mvns	r3, r3
 800e3e8:	697a      	ldr	r2, [r7, #20]
 800e3ea:	4013      	ands	r3, r2
 800e3ec:	617b      	str	r3, [r7, #20]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 800e3ee:	683b      	ldr	r3, [r7, #0]
 800e3f0:	685b      	ldr	r3, [r3, #4]
 800e3f2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800e3f6:	2b00      	cmp	r3, #0
 800e3f8:	d003      	beq.n	800e402 <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
 800e3fa:	697a      	ldr	r2, [r7, #20]
 800e3fc:	69fb      	ldr	r3, [r7, #28]
 800e3fe:	4313      	orrs	r3, r2
 800e400:	617b      	str	r3, [r7, #20]
        }
        EXTI->RTSR = temp;
 800e402:	4a34      	ldr	r2, [pc, #208]	; (800e4d4 <HAL_GPIO_Init+0x354>)
 800e404:	697b      	ldr	r3, [r7, #20]
 800e406:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 800e408:	4b32      	ldr	r3, [pc, #200]	; (800e4d4 <HAL_GPIO_Init+0x354>)
 800e40a:	68db      	ldr	r3, [r3, #12]
 800e40c:	617b      	str	r3, [r7, #20]
        temp &= ~((uint32_t)iocurrent);
 800e40e:	69fb      	ldr	r3, [r7, #28]
 800e410:	43db      	mvns	r3, r3
 800e412:	697a      	ldr	r2, [r7, #20]
 800e414:	4013      	ands	r3, r2
 800e416:	617b      	str	r3, [r7, #20]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 800e418:	683b      	ldr	r3, [r7, #0]
 800e41a:	685b      	ldr	r3, [r3, #4]
 800e41c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800e420:	2b00      	cmp	r3, #0
 800e422:	d003      	beq.n	800e42c <HAL_GPIO_Init+0x2ac>
        {
          temp |= iocurrent;
 800e424:	697a      	ldr	r2, [r7, #20]
 800e426:	69fb      	ldr	r3, [r7, #28]
 800e428:	4313      	orrs	r3, r2
 800e42a:	617b      	str	r3, [r7, #20]
        }
        EXTI->FTSR = temp;
 800e42c:	4a29      	ldr	r2, [pc, #164]	; (800e4d4 <HAL_GPIO_Init+0x354>)
 800e42e:	697b      	ldr	r3, [r7, #20]
 800e430:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 800e432:	4b28      	ldr	r3, [pc, #160]	; (800e4d4 <HAL_GPIO_Init+0x354>)
 800e434:	685b      	ldr	r3, [r3, #4]
 800e436:	617b      	str	r3, [r7, #20]
        temp &= ~((uint32_t)iocurrent);
 800e438:	69fb      	ldr	r3, [r7, #28]
 800e43a:	43db      	mvns	r3, r3
 800e43c:	697a      	ldr	r2, [r7, #20]
 800e43e:	4013      	ands	r3, r2
 800e440:	617b      	str	r3, [r7, #20]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 800e442:	683b      	ldr	r3, [r7, #0]
 800e444:	685b      	ldr	r3, [r3, #4]
 800e446:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800e44a:	2b00      	cmp	r3, #0
 800e44c:	d003      	beq.n	800e456 <HAL_GPIO_Init+0x2d6>
        {
          temp |= iocurrent;
 800e44e:	697a      	ldr	r2, [r7, #20]
 800e450:	69fb      	ldr	r3, [r7, #28]
 800e452:	4313      	orrs	r3, r2
 800e454:	617b      	str	r3, [r7, #20]
        }
        EXTI->EMR = temp;
 800e456:	4a1f      	ldr	r2, [pc, #124]	; (800e4d4 <HAL_GPIO_Init+0x354>)
 800e458:	697b      	ldr	r3, [r7, #20]
 800e45a:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800e45c:	4b1d      	ldr	r3, [pc, #116]	; (800e4d4 <HAL_GPIO_Init+0x354>)
 800e45e:	681b      	ldr	r3, [r3, #0]
 800e460:	617b      	str	r3, [r7, #20]
        temp &= ~((uint32_t)iocurrent);
 800e462:	69fb      	ldr	r3, [r7, #28]
 800e464:	43db      	mvns	r3, r3
 800e466:	697a      	ldr	r2, [r7, #20]
 800e468:	4013      	ands	r3, r2
 800e46a:	617b      	str	r3, [r7, #20]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800e46c:	683b      	ldr	r3, [r7, #0]
 800e46e:	685b      	ldr	r3, [r3, #4]
 800e470:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800e474:	2b00      	cmp	r3, #0
 800e476:	d003      	beq.n	800e480 <HAL_GPIO_Init+0x300>
        {
          temp |= iocurrent;
 800e478:	697a      	ldr	r2, [r7, #20]
 800e47a:	69fb      	ldr	r3, [r7, #28]
 800e47c:	4313      	orrs	r3, r2
 800e47e:	617b      	str	r3, [r7, #20]
        }
        EXTI->IMR = temp;
 800e480:	4a14      	ldr	r2, [pc, #80]	; (800e4d4 <HAL_GPIO_Init+0x354>)
 800e482:	697b      	ldr	r3, [r7, #20]
 800e484:	6013      	str	r3, [r2, #0]
  for(position = 0; position < GPIO_NUMBER; position++)
 800e486:	693b      	ldr	r3, [r7, #16]
 800e488:	3301      	adds	r3, #1
 800e48a:	613b      	str	r3, [r7, #16]
 800e48c:	693b      	ldr	r3, [r7, #16]
 800e48e:	2b0f      	cmp	r3, #15
 800e490:	f67f ae86 	bls.w	800e1a0 <HAL_GPIO_Init+0x20>
      }
    }
  }
}
 800e494:	bf00      	nop
 800e496:	bf00      	nop
 800e498:	3724      	adds	r7, #36	; 0x24
 800e49a:	46bd      	mov	sp, r7
 800e49c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e4a0:	4770      	bx	lr
 800e4a2:	bf00      	nop
 800e4a4:	40023800 	.word	0x40023800
 800e4a8:	40013800 	.word	0x40013800
 800e4ac:	40020000 	.word	0x40020000
 800e4b0:	40020400 	.word	0x40020400
 800e4b4:	40020800 	.word	0x40020800
 800e4b8:	40020c00 	.word	0x40020c00
 800e4bc:	40021000 	.word	0x40021000
 800e4c0:	40021400 	.word	0x40021400
 800e4c4:	40021800 	.word	0x40021800
 800e4c8:	40021c00 	.word	0x40021c00
 800e4cc:	40022000 	.word	0x40022000
 800e4d0:	40022400 	.word	0x40022400
 800e4d4:	40013c00 	.word	0x40013c00

0800e4d8 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800e4d8:	b480      	push	{r7}
 800e4da:	b085      	sub	sp, #20
 800e4dc:	af00      	add	r7, sp, #0
 800e4de:	60f8      	str	r0, [r7, #12]
 800e4e0:	460b      	mov	r3, r1
 800e4e2:	607a      	str	r2, [r7, #4]
 800e4e4:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800e4e6:	687b      	ldr	r3, [r7, #4]
 800e4e8:	2b00      	cmp	r3, #0
 800e4ea:	d003      	beq.n	800e4f4 <HAL_GPIO_WritePin+0x1c>
  {
    GPIOx->BSRR = GPIO_Pin;
 800e4ec:	897a      	ldrh	r2, [r7, #10]
 800e4ee:	68fb      	ldr	r3, [r7, #12]
 800e4f0:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
  }
}
 800e4f2:	e003      	b.n	800e4fc <HAL_GPIO_WritePin+0x24>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 800e4f4:	897b      	ldrh	r3, [r7, #10]
 800e4f6:	041a      	lsls	r2, r3, #16
 800e4f8:	68fb      	ldr	r3, [r7, #12]
 800e4fa:	619a      	str	r2, [r3, #24]
}
 800e4fc:	bf00      	nop
 800e4fe:	3714      	adds	r7, #20
 800e500:	46bd      	mov	sp, r7
 800e502:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e506:	4770      	bx	lr

0800e508 <HAL_GPIO_TogglePin>:
  * @param  GPIOx Where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_Pin Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800e508:	b480      	push	{r7}
 800e50a:	b085      	sub	sp, #20
 800e50c:	af00      	add	r7, sp, #0
 800e50e:	6078      	str	r0, [r7, #4]
 800e510:	460b      	mov	r3, r1
 800e512:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 800e514:	687b      	ldr	r3, [r7, #4]
 800e516:	695b      	ldr	r3, [r3, #20]
 800e518:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 800e51a:	887a      	ldrh	r2, [r7, #2]
 800e51c:	68fb      	ldr	r3, [r7, #12]
 800e51e:	4013      	ands	r3, r2
 800e520:	041a      	lsls	r2, r3, #16
 800e522:	68fb      	ldr	r3, [r7, #12]
 800e524:	43d9      	mvns	r1, r3
 800e526:	887b      	ldrh	r3, [r7, #2]
 800e528:	400b      	ands	r3, r1
 800e52a:	431a      	orrs	r2, r3
 800e52c:	687b      	ldr	r3, [r7, #4]
 800e52e:	619a      	str	r2, [r3, #24]
}
 800e530:	bf00      	nop
 800e532:	3714      	adds	r7, #20
 800e534:	46bd      	mov	sp, r7
 800e536:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e53a:	4770      	bx	lr

0800e53c <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800e53c:	b580      	push	{r7, lr}
 800e53e:	b082      	sub	sp, #8
 800e540:	af00      	add	r7, sp, #0
 800e542:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 800e544:	687b      	ldr	r3, [r7, #4]
 800e546:	2b00      	cmp	r3, #0
 800e548:	d101      	bne.n	800e54e <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800e54a:	2301      	movs	r3, #1
 800e54c:	e03f      	b.n	800e5ce <HAL_UART_Init+0x92>
  {
    /* Check the parameters */
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 800e54e:	687b      	ldr	r3, [r7, #4]
 800e550:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e552:	2b00      	cmp	r3, #0
 800e554:	d105      	bne.n	800e562 <HAL_UART_Init+0x26>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800e556:	687b      	ldr	r3, [r7, #4]
 800e558:	2200      	movs	r2, #0
 800e55a:	675a      	str	r2, [r3, #116]	; 0x74

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800e55c:	6878      	ldr	r0, [r7, #4]
 800e55e:	f7f3 fab3 	bl	8001ac8 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800e562:	687b      	ldr	r3, [r7, #4]
 800e564:	2224      	movs	r2, #36	; 0x24
 800e566:	679a      	str	r2, [r3, #120]	; 0x78

  __HAL_UART_DISABLE(huart);
 800e568:	687b      	ldr	r3, [r7, #4]
 800e56a:	681b      	ldr	r3, [r3, #0]
 800e56c:	681a      	ldr	r2, [r3, #0]
 800e56e:	687b      	ldr	r3, [r7, #4]
 800e570:	681b      	ldr	r3, [r3, #0]
 800e572:	f022 0201 	bic.w	r2, r2, #1
 800e576:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800e578:	6878      	ldr	r0, [r7, #4]
 800e57a:	f000 f989 	bl	800e890 <UART_SetConfig>
 800e57e:	4603      	mov	r3, r0
 800e580:	2b01      	cmp	r3, #1
 800e582:	d101      	bne.n	800e588 <HAL_UART_Init+0x4c>
  {
    return HAL_ERROR;
 800e584:	2301      	movs	r3, #1
 800e586:	e022      	b.n	800e5ce <HAL_UART_Init+0x92>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800e588:	687b      	ldr	r3, [r7, #4]
 800e58a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e58c:	2b00      	cmp	r3, #0
 800e58e:	d002      	beq.n	800e596 <HAL_UART_Init+0x5a>
  {
    UART_AdvFeatureConfig(huart);
 800e590:	6878      	ldr	r0, [r7, #4]
 800e592:	f000 fbe1 	bl	800ed58 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800e596:	687b      	ldr	r3, [r7, #4]
 800e598:	681b      	ldr	r3, [r3, #0]
 800e59a:	685a      	ldr	r2, [r3, #4]
 800e59c:	687b      	ldr	r3, [r7, #4]
 800e59e:	681b      	ldr	r3, [r3, #0]
 800e5a0:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800e5a4:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800e5a6:	687b      	ldr	r3, [r7, #4]
 800e5a8:	681b      	ldr	r3, [r3, #0]
 800e5aa:	689a      	ldr	r2, [r3, #8]
 800e5ac:	687b      	ldr	r3, [r7, #4]
 800e5ae:	681b      	ldr	r3, [r3, #0]
 800e5b0:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800e5b4:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 800e5b6:	687b      	ldr	r3, [r7, #4]
 800e5b8:	681b      	ldr	r3, [r3, #0]
 800e5ba:	681a      	ldr	r2, [r3, #0]
 800e5bc:	687b      	ldr	r3, [r7, #4]
 800e5be:	681b      	ldr	r3, [r3, #0]
 800e5c0:	f042 0201 	orr.w	r2, r2, #1
 800e5c4:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 800e5c6:	6878      	ldr	r0, [r7, #4]
 800e5c8:	f000 fc68 	bl	800ee9c <UART_CheckIdleState>
 800e5cc:	4603      	mov	r3, r0
}
 800e5ce:	4618      	mov	r0, r3
 800e5d0:	3708      	adds	r7, #8
 800e5d2:	46bd      	mov	sp, r7
 800e5d4:	bd80      	pop	{r7, pc}

0800e5d6 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800e5d6:	b580      	push	{r7, lr}
 800e5d8:	b08a      	sub	sp, #40	; 0x28
 800e5da:	af02      	add	r7, sp, #8
 800e5dc:	60f8      	str	r0, [r7, #12]
 800e5de:	60b9      	str	r1, [r7, #8]
 800e5e0:	603b      	str	r3, [r7, #0]
 800e5e2:	4613      	mov	r3, r2
 800e5e4:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800e5e6:	68fb      	ldr	r3, [r7, #12]
 800e5e8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e5ea:	2b20      	cmp	r3, #32
 800e5ec:	d17d      	bne.n	800e6ea <HAL_UART_Transmit+0x114>
  {
    if ((pData == NULL) || (Size == 0U))
 800e5ee:	68bb      	ldr	r3, [r7, #8]
 800e5f0:	2b00      	cmp	r3, #0
 800e5f2:	d002      	beq.n	800e5fa <HAL_UART_Transmit+0x24>
 800e5f4:	88fb      	ldrh	r3, [r7, #6]
 800e5f6:	2b00      	cmp	r3, #0
 800e5f8:	d101      	bne.n	800e5fe <HAL_UART_Transmit+0x28>
    {
      return  HAL_ERROR;
 800e5fa:	2301      	movs	r3, #1
 800e5fc:	e076      	b.n	800e6ec <HAL_UART_Transmit+0x116>
    }

    __HAL_LOCK(huart);
 800e5fe:	68fb      	ldr	r3, [r7, #12]
 800e600:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e602:	2b01      	cmp	r3, #1
 800e604:	d101      	bne.n	800e60a <HAL_UART_Transmit+0x34>
 800e606:	2302      	movs	r3, #2
 800e608:	e070      	b.n	800e6ec <HAL_UART_Transmit+0x116>
 800e60a:	68fb      	ldr	r3, [r7, #12]
 800e60c:	2201      	movs	r2, #1
 800e60e:	675a      	str	r2, [r3, #116]	; 0x74

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800e610:	68fb      	ldr	r3, [r7, #12]
 800e612:	2200      	movs	r2, #0
 800e614:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800e618:	68fb      	ldr	r3, [r7, #12]
 800e61a:	2221      	movs	r2, #33	; 0x21
 800e61c:	679a      	str	r2, [r3, #120]	; 0x78

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800e61e:	f7f3 fbab 	bl	8001d78 <HAL_GetTick>
 800e622:	61f8      	str	r0, [r7, #28]

    huart->TxXferSize  = Size;
 800e624:	68fb      	ldr	r3, [r7, #12]
 800e626:	88fa      	ldrh	r2, [r7, #6]
 800e628:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    huart->TxXferCount = Size;
 800e62c:	68fb      	ldr	r3, [r7, #12]
 800e62e:	88fa      	ldrh	r2, [r7, #6]
 800e630:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800e634:	68fb      	ldr	r3, [r7, #12]
 800e636:	689b      	ldr	r3, [r3, #8]
 800e638:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800e63c:	d108      	bne.n	800e650 <HAL_UART_Transmit+0x7a>
 800e63e:	68fb      	ldr	r3, [r7, #12]
 800e640:	691b      	ldr	r3, [r3, #16]
 800e642:	2b00      	cmp	r3, #0
 800e644:	d104      	bne.n	800e650 <HAL_UART_Transmit+0x7a>
    {
      pdata8bits  = NULL;
 800e646:	2300      	movs	r3, #0
 800e648:	617b      	str	r3, [r7, #20]
      pdata16bits = (const uint16_t *) pData;
 800e64a:	68bb      	ldr	r3, [r7, #8]
 800e64c:	61bb      	str	r3, [r7, #24]
 800e64e:	e003      	b.n	800e658 <HAL_UART_Transmit+0x82>
    }
    else
    {
      pdata8bits  = pData;
 800e650:	68bb      	ldr	r3, [r7, #8]
 800e652:	617b      	str	r3, [r7, #20]
      pdata16bits = NULL;
 800e654:	2300      	movs	r3, #0
 800e656:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 800e658:	68fb      	ldr	r3, [r7, #12]
 800e65a:	2200      	movs	r2, #0
 800e65c:	675a      	str	r2, [r3, #116]	; 0x74

    while (huart->TxXferCount > 0U)
 800e65e:	e02c      	b.n	800e6ba <HAL_UART_Transmit+0xe4>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800e660:	683b      	ldr	r3, [r7, #0]
 800e662:	9300      	str	r3, [sp, #0]
 800e664:	69fb      	ldr	r3, [r7, #28]
 800e666:	2200      	movs	r2, #0
 800e668:	2180      	movs	r1, #128	; 0x80
 800e66a:	68f8      	ldr	r0, [r7, #12]
 800e66c:	f000 fc5e 	bl	800ef2c <UART_WaitOnFlagUntilTimeout>
 800e670:	4603      	mov	r3, r0
 800e672:	2b00      	cmp	r3, #0
 800e674:	d001      	beq.n	800e67a <HAL_UART_Transmit+0xa4>
      {
        return HAL_TIMEOUT;
 800e676:	2303      	movs	r3, #3
 800e678:	e038      	b.n	800e6ec <HAL_UART_Transmit+0x116>
      }
      if (pdata8bits == NULL)
 800e67a:	697b      	ldr	r3, [r7, #20]
 800e67c:	2b00      	cmp	r3, #0
 800e67e:	d10b      	bne.n	800e698 <HAL_UART_Transmit+0xc2>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800e680:	69bb      	ldr	r3, [r7, #24]
 800e682:	881b      	ldrh	r3, [r3, #0]
 800e684:	461a      	mov	r2, r3
 800e686:	68fb      	ldr	r3, [r7, #12]
 800e688:	681b      	ldr	r3, [r3, #0]
 800e68a:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800e68e:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 800e690:	69bb      	ldr	r3, [r7, #24]
 800e692:	3302      	adds	r3, #2
 800e694:	61bb      	str	r3, [r7, #24]
 800e696:	e007      	b.n	800e6a8 <HAL_UART_Transmit+0xd2>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800e698:	697b      	ldr	r3, [r7, #20]
 800e69a:	781a      	ldrb	r2, [r3, #0]
 800e69c:	68fb      	ldr	r3, [r7, #12]
 800e69e:	681b      	ldr	r3, [r3, #0]
 800e6a0:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 800e6a2:	697b      	ldr	r3, [r7, #20]
 800e6a4:	3301      	adds	r3, #1
 800e6a6:	617b      	str	r3, [r7, #20]
      }
      huart->TxXferCount--;
 800e6a8:	68fb      	ldr	r3, [r7, #12]
 800e6aa:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800e6ae:	b29b      	uxth	r3, r3
 800e6b0:	3b01      	subs	r3, #1
 800e6b2:	b29a      	uxth	r2, r3
 800e6b4:	68fb      	ldr	r3, [r7, #12]
 800e6b6:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    while (huart->TxXferCount > 0U)
 800e6ba:	68fb      	ldr	r3, [r7, #12]
 800e6bc:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800e6c0:	b29b      	uxth	r3, r3
 800e6c2:	2b00      	cmp	r3, #0
 800e6c4:	d1cc      	bne.n	800e660 <HAL_UART_Transmit+0x8a>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800e6c6:	683b      	ldr	r3, [r7, #0]
 800e6c8:	9300      	str	r3, [sp, #0]
 800e6ca:	69fb      	ldr	r3, [r7, #28]
 800e6cc:	2200      	movs	r2, #0
 800e6ce:	2140      	movs	r1, #64	; 0x40
 800e6d0:	68f8      	ldr	r0, [r7, #12]
 800e6d2:	f000 fc2b 	bl	800ef2c <UART_WaitOnFlagUntilTimeout>
 800e6d6:	4603      	mov	r3, r0
 800e6d8:	2b00      	cmp	r3, #0
 800e6da:	d001      	beq.n	800e6e0 <HAL_UART_Transmit+0x10a>
    {
      return HAL_TIMEOUT;
 800e6dc:	2303      	movs	r3, #3
 800e6de:	e005      	b.n	800e6ec <HAL_UART_Transmit+0x116>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 800e6e0:	68fb      	ldr	r3, [r7, #12]
 800e6e2:	2220      	movs	r2, #32
 800e6e4:	679a      	str	r2, [r3, #120]	; 0x78

    return HAL_OK;
 800e6e6:	2300      	movs	r3, #0
 800e6e8:	e000      	b.n	800e6ec <HAL_UART_Transmit+0x116>
  }
  else
  {
    return HAL_BUSY;
 800e6ea:	2302      	movs	r3, #2
  }
}
 800e6ec:	4618      	mov	r0, r3
 800e6ee:	3720      	adds	r7, #32
 800e6f0:	46bd      	mov	sp, r7
 800e6f2:	bd80      	pop	{r7, pc}

0800e6f4 <HAL_UART_Receive>:
  * @param Size    Amount of data elements (u8 or u16) to be received.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800e6f4:	b580      	push	{r7, lr}
 800e6f6:	b08a      	sub	sp, #40	; 0x28
 800e6f8:	af02      	add	r7, sp, #8
 800e6fa:	60f8      	str	r0, [r7, #12]
 800e6fc:	60b9      	str	r1, [r7, #8]
 800e6fe:	603b      	str	r3, [r7, #0]
 800e700:	4613      	mov	r3, r2
 800e702:	80fb      	strh	r3, [r7, #6]
  uint16_t *pdata16bits;
  uint16_t uhMask;
  uint32_t tickstart;

  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 800e704:	68fb      	ldr	r3, [r7, #12]
 800e706:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800e708:	2b20      	cmp	r3, #32
 800e70a:	f040 80bb 	bne.w	800e884 <HAL_UART_Receive+0x190>
  {
    if ((pData == NULL) || (Size == 0U))
 800e70e:	68bb      	ldr	r3, [r7, #8]
 800e710:	2b00      	cmp	r3, #0
 800e712:	d002      	beq.n	800e71a <HAL_UART_Receive+0x26>
 800e714:	88fb      	ldrh	r3, [r7, #6]
 800e716:	2b00      	cmp	r3, #0
 800e718:	d101      	bne.n	800e71e <HAL_UART_Receive+0x2a>
    {
      return  HAL_ERROR;
 800e71a:	2301      	movs	r3, #1
 800e71c:	e0b3      	b.n	800e886 <HAL_UART_Receive+0x192>
    }

    __HAL_LOCK(huart);
 800e71e:	68fb      	ldr	r3, [r7, #12]
 800e720:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e722:	2b01      	cmp	r3, #1
 800e724:	d101      	bne.n	800e72a <HAL_UART_Receive+0x36>
 800e726:	2302      	movs	r3, #2
 800e728:	e0ad      	b.n	800e886 <HAL_UART_Receive+0x192>
 800e72a:	68fb      	ldr	r3, [r7, #12]
 800e72c:	2201      	movs	r2, #1
 800e72e:	675a      	str	r2, [r3, #116]	; 0x74

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800e730:	68fb      	ldr	r3, [r7, #12]
 800e732:	2200      	movs	r2, #0
 800e734:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800e738:	68fb      	ldr	r3, [r7, #12]
 800e73a:	2222      	movs	r2, #34	; 0x22
 800e73c:	67da      	str	r2, [r3, #124]	; 0x7c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800e73e:	68fb      	ldr	r3, [r7, #12]
 800e740:	2200      	movs	r2, #0
 800e742:	661a      	str	r2, [r3, #96]	; 0x60

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800e744:	f7f3 fb18 	bl	8001d78 <HAL_GetTick>
 800e748:	61f8      	str	r0, [r7, #28]

    huart->RxXferSize  = Size;
 800e74a:	68fb      	ldr	r3, [r7, #12]
 800e74c:	88fa      	ldrh	r2, [r7, #6]
 800e74e:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
    huart->RxXferCount = Size;
 800e752:	68fb      	ldr	r3, [r7, #12]
 800e754:	88fa      	ldrh	r2, [r7, #6]
 800e756:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
 800e75a:	68fb      	ldr	r3, [r7, #12]
 800e75c:	689b      	ldr	r3, [r3, #8]
 800e75e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800e762:	d10e      	bne.n	800e782 <HAL_UART_Receive+0x8e>
 800e764:	68fb      	ldr	r3, [r7, #12]
 800e766:	691b      	ldr	r3, [r3, #16]
 800e768:	2b00      	cmp	r3, #0
 800e76a:	d105      	bne.n	800e778 <HAL_UART_Receive+0x84>
 800e76c:	68fb      	ldr	r3, [r7, #12]
 800e76e:	f240 12ff 	movw	r2, #511	; 0x1ff
 800e772:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800e776:	e02d      	b.n	800e7d4 <HAL_UART_Receive+0xe0>
 800e778:	68fb      	ldr	r3, [r7, #12]
 800e77a:	22ff      	movs	r2, #255	; 0xff
 800e77c:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800e780:	e028      	b.n	800e7d4 <HAL_UART_Receive+0xe0>
 800e782:	68fb      	ldr	r3, [r7, #12]
 800e784:	689b      	ldr	r3, [r3, #8]
 800e786:	2b00      	cmp	r3, #0
 800e788:	d10d      	bne.n	800e7a6 <HAL_UART_Receive+0xb2>
 800e78a:	68fb      	ldr	r3, [r7, #12]
 800e78c:	691b      	ldr	r3, [r3, #16]
 800e78e:	2b00      	cmp	r3, #0
 800e790:	d104      	bne.n	800e79c <HAL_UART_Receive+0xa8>
 800e792:	68fb      	ldr	r3, [r7, #12]
 800e794:	22ff      	movs	r2, #255	; 0xff
 800e796:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800e79a:	e01b      	b.n	800e7d4 <HAL_UART_Receive+0xe0>
 800e79c:	68fb      	ldr	r3, [r7, #12]
 800e79e:	227f      	movs	r2, #127	; 0x7f
 800e7a0:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800e7a4:	e016      	b.n	800e7d4 <HAL_UART_Receive+0xe0>
 800e7a6:	68fb      	ldr	r3, [r7, #12]
 800e7a8:	689b      	ldr	r3, [r3, #8]
 800e7aa:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800e7ae:	d10d      	bne.n	800e7cc <HAL_UART_Receive+0xd8>
 800e7b0:	68fb      	ldr	r3, [r7, #12]
 800e7b2:	691b      	ldr	r3, [r3, #16]
 800e7b4:	2b00      	cmp	r3, #0
 800e7b6:	d104      	bne.n	800e7c2 <HAL_UART_Receive+0xce>
 800e7b8:	68fb      	ldr	r3, [r7, #12]
 800e7ba:	227f      	movs	r2, #127	; 0x7f
 800e7bc:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800e7c0:	e008      	b.n	800e7d4 <HAL_UART_Receive+0xe0>
 800e7c2:	68fb      	ldr	r3, [r7, #12]
 800e7c4:	223f      	movs	r2, #63	; 0x3f
 800e7c6:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
 800e7ca:	e003      	b.n	800e7d4 <HAL_UART_Receive+0xe0>
 800e7cc:	68fb      	ldr	r3, [r7, #12]
 800e7ce:	2200      	movs	r2, #0
 800e7d0:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
    uhMask = huart->Mask;
 800e7d4:	68fb      	ldr	r3, [r7, #12]
 800e7d6:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800e7da:	827b      	strh	r3, [r7, #18]

    /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800e7dc:	68fb      	ldr	r3, [r7, #12]
 800e7de:	689b      	ldr	r3, [r3, #8]
 800e7e0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800e7e4:	d108      	bne.n	800e7f8 <HAL_UART_Receive+0x104>
 800e7e6:	68fb      	ldr	r3, [r7, #12]
 800e7e8:	691b      	ldr	r3, [r3, #16]
 800e7ea:	2b00      	cmp	r3, #0
 800e7ec:	d104      	bne.n	800e7f8 <HAL_UART_Receive+0x104>
    {
      pdata8bits  = NULL;
 800e7ee:	2300      	movs	r3, #0
 800e7f0:	617b      	str	r3, [r7, #20]
      pdata16bits = (uint16_t *) pData;
 800e7f2:	68bb      	ldr	r3, [r7, #8]
 800e7f4:	61bb      	str	r3, [r7, #24]
 800e7f6:	e003      	b.n	800e800 <HAL_UART_Receive+0x10c>
    }
    else
    {
      pdata8bits  = pData;
 800e7f8:	68bb      	ldr	r3, [r7, #8]
 800e7fa:	617b      	str	r3, [r7, #20]
      pdata16bits = NULL;
 800e7fc:	2300      	movs	r3, #0
 800e7fe:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 800e800:	68fb      	ldr	r3, [r7, #12]
 800e802:	2200      	movs	r2, #0
 800e804:	675a      	str	r2, [r3, #116]	; 0x74

    /* as long as data have to be received */
    while (huart->RxXferCount > 0U)
 800e806:	e032      	b.n	800e86e <HAL_UART_Receive+0x17a>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 800e808:	683b      	ldr	r3, [r7, #0]
 800e80a:	9300      	str	r3, [sp, #0]
 800e80c:	69fb      	ldr	r3, [r7, #28]
 800e80e:	2200      	movs	r2, #0
 800e810:	2120      	movs	r1, #32
 800e812:	68f8      	ldr	r0, [r7, #12]
 800e814:	f000 fb8a 	bl	800ef2c <UART_WaitOnFlagUntilTimeout>
 800e818:	4603      	mov	r3, r0
 800e81a:	2b00      	cmp	r3, #0
 800e81c:	d001      	beq.n	800e822 <HAL_UART_Receive+0x12e>
      {
        return HAL_TIMEOUT;
 800e81e:	2303      	movs	r3, #3
 800e820:	e031      	b.n	800e886 <HAL_UART_Receive+0x192>
      }
      if (pdata8bits == NULL)
 800e822:	697b      	ldr	r3, [r7, #20]
 800e824:	2b00      	cmp	r3, #0
 800e826:	d10c      	bne.n	800e842 <HAL_UART_Receive+0x14e>
      {
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 800e828:	68fb      	ldr	r3, [r7, #12]
 800e82a:	681b      	ldr	r3, [r3, #0]
 800e82c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e82e:	b29a      	uxth	r2, r3
 800e830:	8a7b      	ldrh	r3, [r7, #18]
 800e832:	4013      	ands	r3, r2
 800e834:	b29a      	uxth	r2, r3
 800e836:	69bb      	ldr	r3, [r7, #24]
 800e838:	801a      	strh	r2, [r3, #0]
        pdata16bits++;
 800e83a:	69bb      	ldr	r3, [r7, #24]
 800e83c:	3302      	adds	r3, #2
 800e83e:	61bb      	str	r3, [r7, #24]
 800e840:	e00c      	b.n	800e85c <HAL_UART_Receive+0x168>
      }
      else
      {
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 800e842:	68fb      	ldr	r3, [r7, #12]
 800e844:	681b      	ldr	r3, [r3, #0]
 800e846:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e848:	b2da      	uxtb	r2, r3
 800e84a:	8a7b      	ldrh	r3, [r7, #18]
 800e84c:	b2db      	uxtb	r3, r3
 800e84e:	4013      	ands	r3, r2
 800e850:	b2da      	uxtb	r2, r3
 800e852:	697b      	ldr	r3, [r7, #20]
 800e854:	701a      	strb	r2, [r3, #0]
        pdata8bits++;
 800e856:	697b      	ldr	r3, [r7, #20]
 800e858:	3301      	adds	r3, #1
 800e85a:	617b      	str	r3, [r7, #20]
      }
      huart->RxXferCount--;
 800e85c:	68fb      	ldr	r3, [r7, #12]
 800e85e:	f8b3 305a 	ldrh.w	r3, [r3, #90]	; 0x5a
 800e862:	b29b      	uxth	r3, r3
 800e864:	3b01      	subs	r3, #1
 800e866:	b29a      	uxth	r2, r3
 800e868:	68fb      	ldr	r3, [r7, #12]
 800e86a:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
    while (huart->RxXferCount > 0U)
 800e86e:	68fb      	ldr	r3, [r7, #12]
 800e870:	f8b3 305a 	ldrh.w	r3, [r3, #90]	; 0x5a
 800e874:	b29b      	uxth	r3, r3
 800e876:	2b00      	cmp	r3, #0
 800e878:	d1c6      	bne.n	800e808 <HAL_UART_Receive+0x114>
    }

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
 800e87a:	68fb      	ldr	r3, [r7, #12]
 800e87c:	2220      	movs	r2, #32
 800e87e:	67da      	str	r2, [r3, #124]	; 0x7c

    return HAL_OK;
 800e880:	2300      	movs	r3, #0
 800e882:	e000      	b.n	800e886 <HAL_UART_Receive+0x192>
  }
  else
  {
    return HAL_BUSY;
 800e884:	2302      	movs	r3, #2
  }
}
 800e886:	4618      	mov	r0, r3
 800e888:	3720      	adds	r7, #32
 800e88a:	46bd      	mov	sp, r7
 800e88c:	bd80      	pop	{r7, pc}
	...

0800e890 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 800e890:	b580      	push	{r7, lr}
 800e892:	b088      	sub	sp, #32
 800e894:	af00      	add	r7, sp, #0
 800e896:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 800e898:	2300      	movs	r3, #0
 800e89a:	613b      	str	r3, [r7, #16]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800e89c:	687b      	ldr	r3, [r7, #4]
 800e89e:	689a      	ldr	r2, [r3, #8]
 800e8a0:	687b      	ldr	r3, [r7, #4]
 800e8a2:	691b      	ldr	r3, [r3, #16]
 800e8a4:	431a      	orrs	r2, r3
 800e8a6:	687b      	ldr	r3, [r7, #4]
 800e8a8:	695b      	ldr	r3, [r3, #20]
 800e8aa:	431a      	orrs	r2, r3
 800e8ac:	687b      	ldr	r3, [r7, #4]
 800e8ae:	69db      	ldr	r3, [r3, #28]
 800e8b0:	4313      	orrs	r3, r2
 800e8b2:	61bb      	str	r3, [r7, #24]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800e8b4:	687b      	ldr	r3, [r7, #4]
 800e8b6:	681b      	ldr	r3, [r3, #0]
 800e8b8:	681a      	ldr	r2, [r3, #0]
 800e8ba:	4ba6      	ldr	r3, [pc, #664]	; (800eb54 <UART_SetConfig+0x2c4>)
 800e8bc:	4013      	ands	r3, r2
 800e8be:	687a      	ldr	r2, [r7, #4]
 800e8c0:	6812      	ldr	r2, [r2, #0]
 800e8c2:	69b9      	ldr	r1, [r7, #24]
 800e8c4:	430b      	orrs	r3, r1
 800e8c6:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800e8c8:	687b      	ldr	r3, [r7, #4]
 800e8ca:	681b      	ldr	r3, [r3, #0]
 800e8cc:	685b      	ldr	r3, [r3, #4]
 800e8ce:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 800e8d2:	687b      	ldr	r3, [r7, #4]
 800e8d4:	68da      	ldr	r2, [r3, #12]
 800e8d6:	687b      	ldr	r3, [r7, #4]
 800e8d8:	681b      	ldr	r3, [r3, #0]
 800e8da:	430a      	orrs	r2, r1
 800e8dc:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800e8de:	687b      	ldr	r3, [r7, #4]
 800e8e0:	699b      	ldr	r3, [r3, #24]
 800e8e2:	61bb      	str	r3, [r7, #24]

  tmpreg |= huart->Init.OneBitSampling;
 800e8e4:	687b      	ldr	r3, [r7, #4]
 800e8e6:	6a1b      	ldr	r3, [r3, #32]
 800e8e8:	69ba      	ldr	r2, [r7, #24]
 800e8ea:	4313      	orrs	r3, r2
 800e8ec:	61bb      	str	r3, [r7, #24]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800e8ee:	687b      	ldr	r3, [r7, #4]
 800e8f0:	681b      	ldr	r3, [r3, #0]
 800e8f2:	689b      	ldr	r3, [r3, #8]
 800e8f4:	f423 6130 	bic.w	r1, r3, #2816	; 0xb00
 800e8f8:	687b      	ldr	r3, [r7, #4]
 800e8fa:	681b      	ldr	r3, [r3, #0]
 800e8fc:	69ba      	ldr	r2, [r7, #24]
 800e8fe:	430a      	orrs	r2, r1
 800e900:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800e902:	687b      	ldr	r3, [r7, #4]
 800e904:	681b      	ldr	r3, [r3, #0]
 800e906:	4a94      	ldr	r2, [pc, #592]	; (800eb58 <UART_SetConfig+0x2c8>)
 800e908:	4293      	cmp	r3, r2
 800e90a:	d120      	bne.n	800e94e <UART_SetConfig+0xbe>
 800e90c:	4b93      	ldr	r3, [pc, #588]	; (800eb5c <UART_SetConfig+0x2cc>)
 800e90e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e912:	f003 0303 	and.w	r3, r3, #3
 800e916:	2b03      	cmp	r3, #3
 800e918:	d816      	bhi.n	800e948 <UART_SetConfig+0xb8>
 800e91a:	a201      	add	r2, pc, #4	; (adr r2, 800e920 <UART_SetConfig+0x90>)
 800e91c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e920:	0800e931 	.word	0x0800e931
 800e924:	0800e93d 	.word	0x0800e93d
 800e928:	0800e937 	.word	0x0800e937
 800e92c:	0800e943 	.word	0x0800e943
 800e930:	2301      	movs	r3, #1
 800e932:	60fb      	str	r3, [r7, #12]
 800e934:	e150      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e936:	2302      	movs	r3, #2
 800e938:	60fb      	str	r3, [r7, #12]
 800e93a:	e14d      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e93c:	2304      	movs	r3, #4
 800e93e:	60fb      	str	r3, [r7, #12]
 800e940:	e14a      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e942:	2308      	movs	r3, #8
 800e944:	60fb      	str	r3, [r7, #12]
 800e946:	e147      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e948:	2310      	movs	r3, #16
 800e94a:	60fb      	str	r3, [r7, #12]
 800e94c:	e144      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e94e:	687b      	ldr	r3, [r7, #4]
 800e950:	681b      	ldr	r3, [r3, #0]
 800e952:	4a83      	ldr	r2, [pc, #524]	; (800eb60 <UART_SetConfig+0x2d0>)
 800e954:	4293      	cmp	r3, r2
 800e956:	d132      	bne.n	800e9be <UART_SetConfig+0x12e>
 800e958:	4b80      	ldr	r3, [pc, #512]	; (800eb5c <UART_SetConfig+0x2cc>)
 800e95a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e95e:	f003 030c 	and.w	r3, r3, #12
 800e962:	2b0c      	cmp	r3, #12
 800e964:	d828      	bhi.n	800e9b8 <UART_SetConfig+0x128>
 800e966:	a201      	add	r2, pc, #4	; (adr r2, 800e96c <UART_SetConfig+0xdc>)
 800e968:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e96c:	0800e9a1 	.word	0x0800e9a1
 800e970:	0800e9b9 	.word	0x0800e9b9
 800e974:	0800e9b9 	.word	0x0800e9b9
 800e978:	0800e9b9 	.word	0x0800e9b9
 800e97c:	0800e9ad 	.word	0x0800e9ad
 800e980:	0800e9b9 	.word	0x0800e9b9
 800e984:	0800e9b9 	.word	0x0800e9b9
 800e988:	0800e9b9 	.word	0x0800e9b9
 800e98c:	0800e9a7 	.word	0x0800e9a7
 800e990:	0800e9b9 	.word	0x0800e9b9
 800e994:	0800e9b9 	.word	0x0800e9b9
 800e998:	0800e9b9 	.word	0x0800e9b9
 800e99c:	0800e9b3 	.word	0x0800e9b3
 800e9a0:	2300      	movs	r3, #0
 800e9a2:	60fb      	str	r3, [r7, #12]
 800e9a4:	e118      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e9a6:	2302      	movs	r3, #2
 800e9a8:	60fb      	str	r3, [r7, #12]
 800e9aa:	e115      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e9ac:	2304      	movs	r3, #4
 800e9ae:	60fb      	str	r3, [r7, #12]
 800e9b0:	e112      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e9b2:	2308      	movs	r3, #8
 800e9b4:	60fb      	str	r3, [r7, #12]
 800e9b6:	e10f      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e9b8:	2310      	movs	r3, #16
 800e9ba:	60fb      	str	r3, [r7, #12]
 800e9bc:	e10c      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e9be:	687b      	ldr	r3, [r7, #4]
 800e9c0:	681b      	ldr	r3, [r3, #0]
 800e9c2:	4a68      	ldr	r2, [pc, #416]	; (800eb64 <UART_SetConfig+0x2d4>)
 800e9c4:	4293      	cmp	r3, r2
 800e9c6:	d120      	bne.n	800ea0a <UART_SetConfig+0x17a>
 800e9c8:	4b64      	ldr	r3, [pc, #400]	; (800eb5c <UART_SetConfig+0x2cc>)
 800e9ca:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e9ce:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800e9d2:	2b30      	cmp	r3, #48	; 0x30
 800e9d4:	d013      	beq.n	800e9fe <UART_SetConfig+0x16e>
 800e9d6:	2b30      	cmp	r3, #48	; 0x30
 800e9d8:	d814      	bhi.n	800ea04 <UART_SetConfig+0x174>
 800e9da:	2b20      	cmp	r3, #32
 800e9dc:	d009      	beq.n	800e9f2 <UART_SetConfig+0x162>
 800e9de:	2b20      	cmp	r3, #32
 800e9e0:	d810      	bhi.n	800ea04 <UART_SetConfig+0x174>
 800e9e2:	2b00      	cmp	r3, #0
 800e9e4:	d002      	beq.n	800e9ec <UART_SetConfig+0x15c>
 800e9e6:	2b10      	cmp	r3, #16
 800e9e8:	d006      	beq.n	800e9f8 <UART_SetConfig+0x168>
 800e9ea:	e00b      	b.n	800ea04 <UART_SetConfig+0x174>
 800e9ec:	2300      	movs	r3, #0
 800e9ee:	60fb      	str	r3, [r7, #12]
 800e9f0:	e0f2      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e9f2:	2302      	movs	r3, #2
 800e9f4:	60fb      	str	r3, [r7, #12]
 800e9f6:	e0ef      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e9f8:	2304      	movs	r3, #4
 800e9fa:	60fb      	str	r3, [r7, #12]
 800e9fc:	e0ec      	b.n	800ebd8 <UART_SetConfig+0x348>
 800e9fe:	2308      	movs	r3, #8
 800ea00:	60fb      	str	r3, [r7, #12]
 800ea02:	e0e9      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ea04:	2310      	movs	r3, #16
 800ea06:	60fb      	str	r3, [r7, #12]
 800ea08:	e0e6      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ea0a:	687b      	ldr	r3, [r7, #4]
 800ea0c:	681b      	ldr	r3, [r3, #0]
 800ea0e:	4a56      	ldr	r2, [pc, #344]	; (800eb68 <UART_SetConfig+0x2d8>)
 800ea10:	4293      	cmp	r3, r2
 800ea12:	d120      	bne.n	800ea56 <UART_SetConfig+0x1c6>
 800ea14:	4b51      	ldr	r3, [pc, #324]	; (800eb5c <UART_SetConfig+0x2cc>)
 800ea16:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ea1a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800ea1e:	2bc0      	cmp	r3, #192	; 0xc0
 800ea20:	d013      	beq.n	800ea4a <UART_SetConfig+0x1ba>
 800ea22:	2bc0      	cmp	r3, #192	; 0xc0
 800ea24:	d814      	bhi.n	800ea50 <UART_SetConfig+0x1c0>
 800ea26:	2b80      	cmp	r3, #128	; 0x80
 800ea28:	d009      	beq.n	800ea3e <UART_SetConfig+0x1ae>
 800ea2a:	2b80      	cmp	r3, #128	; 0x80
 800ea2c:	d810      	bhi.n	800ea50 <UART_SetConfig+0x1c0>
 800ea2e:	2b00      	cmp	r3, #0
 800ea30:	d002      	beq.n	800ea38 <UART_SetConfig+0x1a8>
 800ea32:	2b40      	cmp	r3, #64	; 0x40
 800ea34:	d006      	beq.n	800ea44 <UART_SetConfig+0x1b4>
 800ea36:	e00b      	b.n	800ea50 <UART_SetConfig+0x1c0>
 800ea38:	2300      	movs	r3, #0
 800ea3a:	60fb      	str	r3, [r7, #12]
 800ea3c:	e0cc      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ea3e:	2302      	movs	r3, #2
 800ea40:	60fb      	str	r3, [r7, #12]
 800ea42:	e0c9      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ea44:	2304      	movs	r3, #4
 800ea46:	60fb      	str	r3, [r7, #12]
 800ea48:	e0c6      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ea4a:	2308      	movs	r3, #8
 800ea4c:	60fb      	str	r3, [r7, #12]
 800ea4e:	e0c3      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ea50:	2310      	movs	r3, #16
 800ea52:	60fb      	str	r3, [r7, #12]
 800ea54:	e0c0      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ea56:	687b      	ldr	r3, [r7, #4]
 800ea58:	681b      	ldr	r3, [r3, #0]
 800ea5a:	4a44      	ldr	r2, [pc, #272]	; (800eb6c <UART_SetConfig+0x2dc>)
 800ea5c:	4293      	cmp	r3, r2
 800ea5e:	d125      	bne.n	800eaac <UART_SetConfig+0x21c>
 800ea60:	4b3e      	ldr	r3, [pc, #248]	; (800eb5c <UART_SetConfig+0x2cc>)
 800ea62:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ea66:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800ea6a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800ea6e:	d017      	beq.n	800eaa0 <UART_SetConfig+0x210>
 800ea70:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800ea74:	d817      	bhi.n	800eaa6 <UART_SetConfig+0x216>
 800ea76:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800ea7a:	d00b      	beq.n	800ea94 <UART_SetConfig+0x204>
 800ea7c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800ea80:	d811      	bhi.n	800eaa6 <UART_SetConfig+0x216>
 800ea82:	2b00      	cmp	r3, #0
 800ea84:	d003      	beq.n	800ea8e <UART_SetConfig+0x1fe>
 800ea86:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800ea8a:	d006      	beq.n	800ea9a <UART_SetConfig+0x20a>
 800ea8c:	e00b      	b.n	800eaa6 <UART_SetConfig+0x216>
 800ea8e:	2300      	movs	r3, #0
 800ea90:	60fb      	str	r3, [r7, #12]
 800ea92:	e0a1      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ea94:	2302      	movs	r3, #2
 800ea96:	60fb      	str	r3, [r7, #12]
 800ea98:	e09e      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ea9a:	2304      	movs	r3, #4
 800ea9c:	60fb      	str	r3, [r7, #12]
 800ea9e:	e09b      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eaa0:	2308      	movs	r3, #8
 800eaa2:	60fb      	str	r3, [r7, #12]
 800eaa4:	e098      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eaa6:	2310      	movs	r3, #16
 800eaa8:	60fb      	str	r3, [r7, #12]
 800eaaa:	e095      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eaac:	687b      	ldr	r3, [r7, #4]
 800eaae:	681b      	ldr	r3, [r3, #0]
 800eab0:	4a2f      	ldr	r2, [pc, #188]	; (800eb70 <UART_SetConfig+0x2e0>)
 800eab2:	4293      	cmp	r3, r2
 800eab4:	d125      	bne.n	800eb02 <UART_SetConfig+0x272>
 800eab6:	4b29      	ldr	r3, [pc, #164]	; (800eb5c <UART_SetConfig+0x2cc>)
 800eab8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800eabc:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800eac0:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800eac4:	d017      	beq.n	800eaf6 <UART_SetConfig+0x266>
 800eac6:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800eaca:	d817      	bhi.n	800eafc <UART_SetConfig+0x26c>
 800eacc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800ead0:	d00b      	beq.n	800eaea <UART_SetConfig+0x25a>
 800ead2:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800ead6:	d811      	bhi.n	800eafc <UART_SetConfig+0x26c>
 800ead8:	2b00      	cmp	r3, #0
 800eada:	d003      	beq.n	800eae4 <UART_SetConfig+0x254>
 800eadc:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800eae0:	d006      	beq.n	800eaf0 <UART_SetConfig+0x260>
 800eae2:	e00b      	b.n	800eafc <UART_SetConfig+0x26c>
 800eae4:	2301      	movs	r3, #1
 800eae6:	60fb      	str	r3, [r7, #12]
 800eae8:	e076      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eaea:	2302      	movs	r3, #2
 800eaec:	60fb      	str	r3, [r7, #12]
 800eaee:	e073      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eaf0:	2304      	movs	r3, #4
 800eaf2:	60fb      	str	r3, [r7, #12]
 800eaf4:	e070      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eaf6:	2308      	movs	r3, #8
 800eaf8:	60fb      	str	r3, [r7, #12]
 800eafa:	e06d      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eafc:	2310      	movs	r3, #16
 800eafe:	60fb      	str	r3, [r7, #12]
 800eb00:	e06a      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eb02:	687b      	ldr	r3, [r7, #4]
 800eb04:	681b      	ldr	r3, [r3, #0]
 800eb06:	4a1b      	ldr	r2, [pc, #108]	; (800eb74 <UART_SetConfig+0x2e4>)
 800eb08:	4293      	cmp	r3, r2
 800eb0a:	d138      	bne.n	800eb7e <UART_SetConfig+0x2ee>
 800eb0c:	4b13      	ldr	r3, [pc, #76]	; (800eb5c <UART_SetConfig+0x2cc>)
 800eb0e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800eb12:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 800eb16:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800eb1a:	d017      	beq.n	800eb4c <UART_SetConfig+0x2bc>
 800eb1c:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800eb20:	d82a      	bhi.n	800eb78 <UART_SetConfig+0x2e8>
 800eb22:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800eb26:	d00b      	beq.n	800eb40 <UART_SetConfig+0x2b0>
 800eb28:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800eb2c:	d824      	bhi.n	800eb78 <UART_SetConfig+0x2e8>
 800eb2e:	2b00      	cmp	r3, #0
 800eb30:	d003      	beq.n	800eb3a <UART_SetConfig+0x2aa>
 800eb32:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800eb36:	d006      	beq.n	800eb46 <UART_SetConfig+0x2b6>
 800eb38:	e01e      	b.n	800eb78 <UART_SetConfig+0x2e8>
 800eb3a:	2300      	movs	r3, #0
 800eb3c:	60fb      	str	r3, [r7, #12]
 800eb3e:	e04b      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eb40:	2302      	movs	r3, #2
 800eb42:	60fb      	str	r3, [r7, #12]
 800eb44:	e048      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eb46:	2304      	movs	r3, #4
 800eb48:	60fb      	str	r3, [r7, #12]
 800eb4a:	e045      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eb4c:	2308      	movs	r3, #8
 800eb4e:	60fb      	str	r3, [r7, #12]
 800eb50:	e042      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eb52:	bf00      	nop
 800eb54:	efff69f3 	.word	0xefff69f3
 800eb58:	40011000 	.word	0x40011000
 800eb5c:	40023800 	.word	0x40023800
 800eb60:	40004400 	.word	0x40004400
 800eb64:	40004800 	.word	0x40004800
 800eb68:	40004c00 	.word	0x40004c00
 800eb6c:	40005000 	.word	0x40005000
 800eb70:	40011400 	.word	0x40011400
 800eb74:	40007800 	.word	0x40007800
 800eb78:	2310      	movs	r3, #16
 800eb7a:	60fb      	str	r3, [r7, #12]
 800eb7c:	e02c      	b.n	800ebd8 <UART_SetConfig+0x348>
 800eb7e:	687b      	ldr	r3, [r7, #4]
 800eb80:	681b      	ldr	r3, [r3, #0]
 800eb82:	4a72      	ldr	r2, [pc, #456]	; (800ed4c <UART_SetConfig+0x4bc>)
 800eb84:	4293      	cmp	r3, r2
 800eb86:	d125      	bne.n	800ebd4 <UART_SetConfig+0x344>
 800eb88:	4b71      	ldr	r3, [pc, #452]	; (800ed50 <UART_SetConfig+0x4c0>)
 800eb8a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800eb8e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800eb92:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800eb96:	d017      	beq.n	800ebc8 <UART_SetConfig+0x338>
 800eb98:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800eb9c:	d817      	bhi.n	800ebce <UART_SetConfig+0x33e>
 800eb9e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800eba2:	d00b      	beq.n	800ebbc <UART_SetConfig+0x32c>
 800eba4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800eba8:	d811      	bhi.n	800ebce <UART_SetConfig+0x33e>
 800ebaa:	2b00      	cmp	r3, #0
 800ebac:	d003      	beq.n	800ebb6 <UART_SetConfig+0x326>
 800ebae:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800ebb2:	d006      	beq.n	800ebc2 <UART_SetConfig+0x332>
 800ebb4:	e00b      	b.n	800ebce <UART_SetConfig+0x33e>
 800ebb6:	2300      	movs	r3, #0
 800ebb8:	60fb      	str	r3, [r7, #12]
 800ebba:	e00d      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ebbc:	2302      	movs	r3, #2
 800ebbe:	60fb      	str	r3, [r7, #12]
 800ebc0:	e00a      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ebc2:	2304      	movs	r3, #4
 800ebc4:	60fb      	str	r3, [r7, #12]
 800ebc6:	e007      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ebc8:	2308      	movs	r3, #8
 800ebca:	60fb      	str	r3, [r7, #12]
 800ebcc:	e004      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ebce:	2310      	movs	r3, #16
 800ebd0:	60fb      	str	r3, [r7, #12]
 800ebd2:	e001      	b.n	800ebd8 <UART_SetConfig+0x348>
 800ebd4:	2310      	movs	r3, #16
 800ebd6:	60fb      	str	r3, [r7, #12]

  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800ebd8:	687b      	ldr	r3, [r7, #4]
 800ebda:	69db      	ldr	r3, [r3, #28]
 800ebdc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800ebe0:	d15b      	bne.n	800ec9a <UART_SetConfig+0x40a>
 800ebe2:	68fb      	ldr	r3, [r7, #12]
 800ebe4:	2b08      	cmp	r3, #8
 800ebe6:	d828      	bhi.n	800ec3a <UART_SetConfig+0x3aa>
 800ebe8:	a201      	add	r2, pc, #4	; (adr r2, 800ebf0 <UART_SetConfig+0x360>)
 800ebea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ebee:	bf00      	nop
 800ebf0:	0800ec15 	.word	0x0800ec15
 800ebf4:	0800ec1d 	.word	0x0800ec1d
 800ebf8:	0800ec25 	.word	0x0800ec25
 800ebfc:	0800ec3b 	.word	0x0800ec3b
 800ec00:	0800ec2b 	.word	0x0800ec2b
 800ec04:	0800ec3b 	.word	0x0800ec3b
 800ec08:	0800ec3b 	.word	0x0800ec3b
 800ec0c:	0800ec3b 	.word	0x0800ec3b
 800ec10:	0800ec33 	.word	0x0800ec33
  {
    switch (clocksource)
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800ec14:	f7ff f84e 	bl	800dcb4 <HAL_RCC_GetPCLK1Freq>
 800ec18:	6178      	str	r0, [r7, #20]
        break;
 800ec1a:	e013      	b.n	800ec44 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800ec1c:	f7ff f85e 	bl	800dcdc <HAL_RCC_GetPCLK2Freq>
 800ec20:	6178      	str	r0, [r7, #20]
        break;
 800ec22:	e00f      	b.n	800ec44 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 800ec24:	4b4b      	ldr	r3, [pc, #300]	; (800ed54 <UART_SetConfig+0x4c4>)
 800ec26:	617b      	str	r3, [r7, #20]
        break;
 800ec28:	e00c      	b.n	800ec44 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800ec2a:	f7fe ff81 	bl	800db30 <HAL_RCC_GetSysClockFreq>
 800ec2e:	6178      	str	r0, [r7, #20]
        break;
 800ec30:	e008      	b.n	800ec44 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800ec32:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800ec36:	617b      	str	r3, [r7, #20]
        break;
 800ec38:	e004      	b.n	800ec44 <UART_SetConfig+0x3b4>
      default:
        pclk = 0U;
 800ec3a:	2300      	movs	r3, #0
 800ec3c:	617b      	str	r3, [r7, #20]
        ret = HAL_ERROR;
 800ec3e:	2301      	movs	r3, #1
 800ec40:	613b      	str	r3, [r7, #16]
        break;
 800ec42:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 800ec44:	697b      	ldr	r3, [r7, #20]
 800ec46:	2b00      	cmp	r3, #0
 800ec48:	d074      	beq.n	800ed34 <UART_SetConfig+0x4a4>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 800ec4a:	697b      	ldr	r3, [r7, #20]
 800ec4c:	005a      	lsls	r2, r3, #1
 800ec4e:	687b      	ldr	r3, [r7, #4]
 800ec50:	685b      	ldr	r3, [r3, #4]
 800ec52:	085b      	lsrs	r3, r3, #1
 800ec54:	441a      	add	r2, r3
 800ec56:	687b      	ldr	r3, [r7, #4]
 800ec58:	685b      	ldr	r3, [r3, #4]
 800ec5a:	fbb2 f3f3 	udiv	r3, r2, r3
 800ec5e:	61fb      	str	r3, [r7, #28]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800ec60:	69fb      	ldr	r3, [r7, #28]
 800ec62:	2b0f      	cmp	r3, #15
 800ec64:	d916      	bls.n	800ec94 <UART_SetConfig+0x404>
 800ec66:	69fb      	ldr	r3, [r7, #28]
 800ec68:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800ec6c:	d212      	bcs.n	800ec94 <UART_SetConfig+0x404>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800ec6e:	69fb      	ldr	r3, [r7, #28]
 800ec70:	b29b      	uxth	r3, r3
 800ec72:	f023 030f 	bic.w	r3, r3, #15
 800ec76:	817b      	strh	r3, [r7, #10]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800ec78:	69fb      	ldr	r3, [r7, #28]
 800ec7a:	085b      	lsrs	r3, r3, #1
 800ec7c:	b29b      	uxth	r3, r3
 800ec7e:	f003 0307 	and.w	r3, r3, #7
 800ec82:	b29a      	uxth	r2, r3
 800ec84:	897b      	ldrh	r3, [r7, #10]
 800ec86:	4313      	orrs	r3, r2
 800ec88:	817b      	strh	r3, [r7, #10]
        huart->Instance->BRR = brrtemp;
 800ec8a:	687b      	ldr	r3, [r7, #4]
 800ec8c:	681b      	ldr	r3, [r3, #0]
 800ec8e:	897a      	ldrh	r2, [r7, #10]
 800ec90:	60da      	str	r2, [r3, #12]
 800ec92:	e04f      	b.n	800ed34 <UART_SetConfig+0x4a4>
      }
      else
      {
        ret = HAL_ERROR;
 800ec94:	2301      	movs	r3, #1
 800ec96:	613b      	str	r3, [r7, #16]
 800ec98:	e04c      	b.n	800ed34 <UART_SetConfig+0x4a4>
 800ec9a:	68fb      	ldr	r3, [r7, #12]
 800ec9c:	2b08      	cmp	r3, #8
 800ec9e:	d828      	bhi.n	800ecf2 <UART_SetConfig+0x462>
 800eca0:	a201      	add	r2, pc, #4	; (adr r2, 800eca8 <UART_SetConfig+0x418>)
 800eca2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800eca6:	bf00      	nop
 800eca8:	0800eccd 	.word	0x0800eccd
 800ecac:	0800ecd5 	.word	0x0800ecd5
 800ecb0:	0800ecdd 	.word	0x0800ecdd
 800ecb4:	0800ecf3 	.word	0x0800ecf3
 800ecb8:	0800ece3 	.word	0x0800ece3
 800ecbc:	0800ecf3 	.word	0x0800ecf3
 800ecc0:	0800ecf3 	.word	0x0800ecf3
 800ecc4:	0800ecf3 	.word	0x0800ecf3
 800ecc8:	0800eceb 	.word	0x0800eceb
  else
  {
    switch (clocksource)
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800eccc:	f7fe fff2 	bl	800dcb4 <HAL_RCC_GetPCLK1Freq>
 800ecd0:	6178      	str	r0, [r7, #20]
        break;
 800ecd2:	e013      	b.n	800ecfc <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800ecd4:	f7ff f802 	bl	800dcdc <HAL_RCC_GetPCLK2Freq>
 800ecd8:	6178      	str	r0, [r7, #20]
        break;
 800ecda:	e00f      	b.n	800ecfc <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 800ecdc:	4b1d      	ldr	r3, [pc, #116]	; (800ed54 <UART_SetConfig+0x4c4>)
 800ecde:	617b      	str	r3, [r7, #20]
        break;
 800ece0:	e00c      	b.n	800ecfc <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800ece2:	f7fe ff25 	bl	800db30 <HAL_RCC_GetSysClockFreq>
 800ece6:	6178      	str	r0, [r7, #20]
        break;
 800ece8:	e008      	b.n	800ecfc <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800ecea:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800ecee:	617b      	str	r3, [r7, #20]
        break;
 800ecf0:	e004      	b.n	800ecfc <UART_SetConfig+0x46c>
      default:
        pclk = 0U;
 800ecf2:	2300      	movs	r3, #0
 800ecf4:	617b      	str	r3, [r7, #20]
        ret = HAL_ERROR;
 800ecf6:	2301      	movs	r3, #1
 800ecf8:	613b      	str	r3, [r7, #16]
        break;
 800ecfa:	bf00      	nop
    }

    if (pclk != 0U)
 800ecfc:	697b      	ldr	r3, [r7, #20]
 800ecfe:	2b00      	cmp	r3, #0
 800ed00:	d018      	beq.n	800ed34 <UART_SetConfig+0x4a4>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800ed02:	687b      	ldr	r3, [r7, #4]
 800ed04:	685b      	ldr	r3, [r3, #4]
 800ed06:	085a      	lsrs	r2, r3, #1
 800ed08:	697b      	ldr	r3, [r7, #20]
 800ed0a:	441a      	add	r2, r3
 800ed0c:	687b      	ldr	r3, [r7, #4]
 800ed0e:	685b      	ldr	r3, [r3, #4]
 800ed10:	fbb2 f3f3 	udiv	r3, r2, r3
 800ed14:	61fb      	str	r3, [r7, #28]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800ed16:	69fb      	ldr	r3, [r7, #28]
 800ed18:	2b0f      	cmp	r3, #15
 800ed1a:	d909      	bls.n	800ed30 <UART_SetConfig+0x4a0>
 800ed1c:	69fb      	ldr	r3, [r7, #28]
 800ed1e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800ed22:	d205      	bcs.n	800ed30 <UART_SetConfig+0x4a0>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 800ed24:	69fb      	ldr	r3, [r7, #28]
 800ed26:	b29a      	uxth	r2, r3
 800ed28:	687b      	ldr	r3, [r7, #4]
 800ed2a:	681b      	ldr	r3, [r3, #0]
 800ed2c:	60da      	str	r2, [r3, #12]
 800ed2e:	e001      	b.n	800ed34 <UART_SetConfig+0x4a4>
      }
      else
      {
        ret = HAL_ERROR;
 800ed30:	2301      	movs	r3, #1
 800ed32:	613b      	str	r3, [r7, #16]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 800ed34:	687b      	ldr	r3, [r7, #4]
 800ed36:	2200      	movs	r2, #0
 800ed38:	665a      	str	r2, [r3, #100]	; 0x64
  huart->TxISR = NULL;
 800ed3a:	687b      	ldr	r3, [r7, #4]
 800ed3c:	2200      	movs	r2, #0
 800ed3e:	669a      	str	r2, [r3, #104]	; 0x68

  return ret;
 800ed40:	693b      	ldr	r3, [r7, #16]
}
 800ed42:	4618      	mov	r0, r3
 800ed44:	3720      	adds	r7, #32
 800ed46:	46bd      	mov	sp, r7
 800ed48:	bd80      	pop	{r7, pc}
 800ed4a:	bf00      	nop
 800ed4c:	40007c00 	.word	0x40007c00
 800ed50:	40023800 	.word	0x40023800
 800ed54:	00f42400 	.word	0x00f42400

0800ed58 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 800ed58:	b480      	push	{r7}
 800ed5a:	b083      	sub	sp, #12
 800ed5c:	af00      	add	r7, sp, #0
 800ed5e:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800ed60:	687b      	ldr	r3, [r7, #4]
 800ed62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ed64:	f003 0301 	and.w	r3, r3, #1
 800ed68:	2b00      	cmp	r3, #0
 800ed6a:	d00a      	beq.n	800ed82 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800ed6c:	687b      	ldr	r3, [r7, #4]
 800ed6e:	681b      	ldr	r3, [r3, #0]
 800ed70:	685b      	ldr	r3, [r3, #4]
 800ed72:	f423 3100 	bic.w	r1, r3, #131072	; 0x20000
 800ed76:	687b      	ldr	r3, [r7, #4]
 800ed78:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800ed7a:	687b      	ldr	r3, [r7, #4]
 800ed7c:	681b      	ldr	r3, [r3, #0]
 800ed7e:	430a      	orrs	r2, r1
 800ed80:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800ed82:	687b      	ldr	r3, [r7, #4]
 800ed84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ed86:	f003 0302 	and.w	r3, r3, #2
 800ed8a:	2b00      	cmp	r3, #0
 800ed8c:	d00a      	beq.n	800eda4 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800ed8e:	687b      	ldr	r3, [r7, #4]
 800ed90:	681b      	ldr	r3, [r3, #0]
 800ed92:	685b      	ldr	r3, [r3, #4]
 800ed94:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 800ed98:	687b      	ldr	r3, [r7, #4]
 800ed9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ed9c:	687b      	ldr	r3, [r7, #4]
 800ed9e:	681b      	ldr	r3, [r3, #0]
 800eda0:	430a      	orrs	r2, r1
 800eda2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800eda4:	687b      	ldr	r3, [r7, #4]
 800eda6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800eda8:	f003 0304 	and.w	r3, r3, #4
 800edac:	2b00      	cmp	r3, #0
 800edae:	d00a      	beq.n	800edc6 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800edb0:	687b      	ldr	r3, [r7, #4]
 800edb2:	681b      	ldr	r3, [r3, #0]
 800edb4:	685b      	ldr	r3, [r3, #4]
 800edb6:	f423 2180 	bic.w	r1, r3, #262144	; 0x40000
 800edba:	687b      	ldr	r3, [r7, #4]
 800edbc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800edbe:	687b      	ldr	r3, [r7, #4]
 800edc0:	681b      	ldr	r3, [r3, #0]
 800edc2:	430a      	orrs	r2, r1
 800edc4:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800edc6:	687b      	ldr	r3, [r7, #4]
 800edc8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800edca:	f003 0308 	and.w	r3, r3, #8
 800edce:	2b00      	cmp	r3, #0
 800edd0:	d00a      	beq.n	800ede8 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800edd2:	687b      	ldr	r3, [r7, #4]
 800edd4:	681b      	ldr	r3, [r3, #0]
 800edd6:	685b      	ldr	r3, [r3, #4]
 800edd8:	f423 4100 	bic.w	r1, r3, #32768	; 0x8000
 800eddc:	687b      	ldr	r3, [r7, #4]
 800edde:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ede0:	687b      	ldr	r3, [r7, #4]
 800ede2:	681b      	ldr	r3, [r3, #0]
 800ede4:	430a      	orrs	r2, r1
 800ede6:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800ede8:	687b      	ldr	r3, [r7, #4]
 800edea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800edec:	f003 0310 	and.w	r3, r3, #16
 800edf0:	2b00      	cmp	r3, #0
 800edf2:	d00a      	beq.n	800ee0a <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800edf4:	687b      	ldr	r3, [r7, #4]
 800edf6:	681b      	ldr	r3, [r3, #0]
 800edf8:	689b      	ldr	r3, [r3, #8]
 800edfa:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 800edfe:	687b      	ldr	r3, [r7, #4]
 800ee00:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ee02:	687b      	ldr	r3, [r7, #4]
 800ee04:	681b      	ldr	r3, [r3, #0]
 800ee06:	430a      	orrs	r2, r1
 800ee08:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800ee0a:	687b      	ldr	r3, [r7, #4]
 800ee0c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ee0e:	f003 0320 	and.w	r3, r3, #32
 800ee12:	2b00      	cmp	r3, #0
 800ee14:	d00a      	beq.n	800ee2c <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800ee16:	687b      	ldr	r3, [r7, #4]
 800ee18:	681b      	ldr	r3, [r3, #0]
 800ee1a:	689b      	ldr	r3, [r3, #8]
 800ee1c:	f423 5100 	bic.w	r1, r3, #8192	; 0x2000
 800ee20:	687b      	ldr	r3, [r7, #4]
 800ee22:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800ee24:	687b      	ldr	r3, [r7, #4]
 800ee26:	681b      	ldr	r3, [r3, #0]
 800ee28:	430a      	orrs	r2, r1
 800ee2a:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800ee2c:	687b      	ldr	r3, [r7, #4]
 800ee2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ee30:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ee34:	2b00      	cmp	r3, #0
 800ee36:	d01a      	beq.n	800ee6e <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800ee38:	687b      	ldr	r3, [r7, #4]
 800ee3a:	681b      	ldr	r3, [r3, #0]
 800ee3c:	685b      	ldr	r3, [r3, #4]
 800ee3e:	f423 1180 	bic.w	r1, r3, #1048576	; 0x100000
 800ee42:	687b      	ldr	r3, [r7, #4]
 800ee44:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800ee46:	687b      	ldr	r3, [r7, #4]
 800ee48:	681b      	ldr	r3, [r3, #0]
 800ee4a:	430a      	orrs	r2, r1
 800ee4c:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800ee4e:	687b      	ldr	r3, [r7, #4]
 800ee50:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ee52:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800ee56:	d10a      	bne.n	800ee6e <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800ee58:	687b      	ldr	r3, [r7, #4]
 800ee5a:	681b      	ldr	r3, [r3, #0]
 800ee5c:	685b      	ldr	r3, [r3, #4]
 800ee5e:	f423 01c0 	bic.w	r1, r3, #6291456	; 0x600000
 800ee62:	687b      	ldr	r3, [r7, #4]
 800ee64:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800ee66:	687b      	ldr	r3, [r7, #4]
 800ee68:	681b      	ldr	r3, [r3, #0]
 800ee6a:	430a      	orrs	r2, r1
 800ee6c:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800ee6e:	687b      	ldr	r3, [r7, #4]
 800ee70:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ee72:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ee76:	2b00      	cmp	r3, #0
 800ee78:	d00a      	beq.n	800ee90 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800ee7a:	687b      	ldr	r3, [r7, #4]
 800ee7c:	681b      	ldr	r3, [r3, #0]
 800ee7e:	685b      	ldr	r3, [r3, #4]
 800ee80:	f423 2100 	bic.w	r1, r3, #524288	; 0x80000
 800ee84:	687b      	ldr	r3, [r7, #4]
 800ee86:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800ee88:	687b      	ldr	r3, [r7, #4]
 800ee8a:	681b      	ldr	r3, [r3, #0]
 800ee8c:	430a      	orrs	r2, r1
 800ee8e:	605a      	str	r2, [r3, #4]
  }
}
 800ee90:	bf00      	nop
 800ee92:	370c      	adds	r7, #12
 800ee94:	46bd      	mov	sp, r7
 800ee96:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee9a:	4770      	bx	lr

0800ee9c <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800ee9c:	b580      	push	{r7, lr}
 800ee9e:	b086      	sub	sp, #24
 800eea0:	af02      	add	r7, sp, #8
 800eea2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800eea4:	687b      	ldr	r3, [r7, #4]
 800eea6:	2200      	movs	r2, #0
 800eea8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 800eeac:	f7f2 ff64 	bl	8001d78 <HAL_GetTick>
 800eeb0:	60f8      	str	r0, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800eeb2:	687b      	ldr	r3, [r7, #4]
 800eeb4:	681b      	ldr	r3, [r3, #0]
 800eeb6:	681b      	ldr	r3, [r3, #0]
 800eeb8:	f003 0308 	and.w	r3, r3, #8
 800eebc:	2b08      	cmp	r3, #8
 800eebe:	d10e      	bne.n	800eede <UART_CheckIdleState+0x42>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800eec0:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800eec4:	9300      	str	r3, [sp, #0]
 800eec6:	68fb      	ldr	r3, [r7, #12]
 800eec8:	2200      	movs	r2, #0
 800eeca:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 800eece:	6878      	ldr	r0, [r7, #4]
 800eed0:	f000 f82c 	bl	800ef2c <UART_WaitOnFlagUntilTimeout>
 800eed4:	4603      	mov	r3, r0
 800eed6:	2b00      	cmp	r3, #0
 800eed8:	d001      	beq.n	800eede <UART_CheckIdleState+0x42>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800eeda:	2303      	movs	r3, #3
 800eedc:	e022      	b.n	800ef24 <UART_CheckIdleState+0x88>
    }
  }
#if defined(USART_ISR_REACK)

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800eede:	687b      	ldr	r3, [r7, #4]
 800eee0:	681b      	ldr	r3, [r3, #0]
 800eee2:	681b      	ldr	r3, [r3, #0]
 800eee4:	f003 0304 	and.w	r3, r3, #4
 800eee8:	2b04      	cmp	r3, #4
 800eeea:	d10e      	bne.n	800ef0a <UART_CheckIdleState+0x6e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800eeec:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800eef0:	9300      	str	r3, [sp, #0]
 800eef2:	68fb      	ldr	r3, [r7, #12]
 800eef4:	2200      	movs	r2, #0
 800eef6:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 800eefa:	6878      	ldr	r0, [r7, #4]
 800eefc:	f000 f816 	bl	800ef2c <UART_WaitOnFlagUntilTimeout>
 800ef00:	4603      	mov	r3, r0
 800ef02:	2b00      	cmp	r3, #0
 800ef04:	d001      	beq.n	800ef0a <UART_CheckIdleState+0x6e>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 800ef06:	2303      	movs	r3, #3
 800ef08:	e00c      	b.n	800ef24 <UART_CheckIdleState+0x88>
    }
  }
#endif

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 800ef0a:	687b      	ldr	r3, [r7, #4]
 800ef0c:	2220      	movs	r2, #32
 800ef0e:	679a      	str	r2, [r3, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
 800ef10:	687b      	ldr	r3, [r7, #4]
 800ef12:	2220      	movs	r2, #32
 800ef14:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800ef16:	687b      	ldr	r3, [r7, #4]
 800ef18:	2200      	movs	r2, #0
 800ef1a:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(huart);
 800ef1c:	687b      	ldr	r3, [r7, #4]
 800ef1e:	2200      	movs	r2, #0
 800ef20:	675a      	str	r2, [r3, #116]	; 0x74

  return HAL_OK;
 800ef22:	2300      	movs	r3, #0
}
 800ef24:	4618      	mov	r0, r3
 800ef26:	3710      	adds	r7, #16
 800ef28:	46bd      	mov	sp, r7
 800ef2a:	bd80      	pop	{r7, pc}

0800ef2c <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 800ef2c:	b580      	push	{r7, lr}
 800ef2e:	b09c      	sub	sp, #112	; 0x70
 800ef30:	af00      	add	r7, sp, #0
 800ef32:	60f8      	str	r0, [r7, #12]
 800ef34:	60b9      	str	r1, [r7, #8]
 800ef36:	607a      	str	r2, [r7, #4]
 800ef38:	603b      	str	r3, [r7, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800ef3a:	e0a3      	b.n	800f084 <UART_WaitOnFlagUntilTimeout+0x158>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800ef3c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800ef3e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ef42:	f000 809f 	beq.w	800f084 <UART_WaitOnFlagUntilTimeout+0x158>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ef46:	f7f2 ff17 	bl	8001d78 <HAL_GetTick>
 800ef4a:	4602      	mov	r2, r0
 800ef4c:	683b      	ldr	r3, [r7, #0]
 800ef4e:	1ad3      	subs	r3, r2, r3
 800ef50:	6fba      	ldr	r2, [r7, #120]	; 0x78
 800ef52:	429a      	cmp	r2, r3
 800ef54:	d302      	bcc.n	800ef5c <UART_WaitOnFlagUntilTimeout+0x30>
 800ef56:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800ef58:	2b00      	cmp	r3, #0
 800ef5a:	d13d      	bne.n	800efd8 <UART_WaitOnFlagUntilTimeout+0xac>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800ef5c:	68fb      	ldr	r3, [r7, #12]
 800ef5e:	681b      	ldr	r3, [r3, #0]
 800ef60:	62fb      	str	r3, [r7, #44]	; 0x2c
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ef62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ef64:	e853 3f00 	ldrex	r3, [r3]
 800ef68:	633b      	str	r3, [r7, #48]	; 0x30
   return(result);
 800ef6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ef6c:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800ef70:	61bb      	str	r3, [r7, #24]
 800ef72:	68fb      	ldr	r3, [r7, #12]
 800ef74:	681b      	ldr	r3, [r3, #0]
 800ef76:	461a      	mov	r2, r3
 800ef78:	69bb      	ldr	r3, [r7, #24]
 800ef7a:	623b      	str	r3, [r7, #32]
 800ef7c:	627a      	str	r2, [r7, #36]	; 0x24
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ef7e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800ef80:	6a3a      	ldr	r2, [r7, #32]
 800ef82:	e841 2300 	strex	r3, r2, [r1]
 800ef86:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 800ef88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ef8a:	2b00      	cmp	r3, #0
 800ef8c:	d1e6      	bne.n	800ef5c <UART_WaitOnFlagUntilTimeout+0x30>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ef8e:	68fb      	ldr	r3, [r7, #12]
 800ef90:	681b      	ldr	r3, [r3, #0]
 800ef92:	3308      	adds	r3, #8
 800ef94:	643b      	str	r3, [r7, #64]	; 0x40
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ef96:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ef98:	e853 3f00 	ldrex	r3, [r3]
 800ef9c:	647b      	str	r3, [r7, #68]	; 0x44
   return(result);
 800ef9e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800efa0:	f023 0301 	bic.w	r3, r3, #1
 800efa4:	61fb      	str	r3, [r7, #28]
 800efa6:	68fb      	ldr	r3, [r7, #12]
 800efa8:	681b      	ldr	r3, [r3, #0]
 800efaa:	3308      	adds	r3, #8
 800efac:	69fa      	ldr	r2, [r7, #28]
 800efae:	637a      	str	r2, [r7, #52]	; 0x34
 800efb0:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800efb2:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800efb4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800efb6:	e841 2300 	strex	r3, r2, [r1]
 800efba:	63fb      	str	r3, [r7, #60]	; 0x3c
   return(result);
 800efbc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800efbe:	2b00      	cmp	r3, #0
 800efc0:	d1e5      	bne.n	800ef8e <UART_WaitOnFlagUntilTimeout+0x62>

        huart->gState = HAL_UART_STATE_READY;
 800efc2:	68fb      	ldr	r3, [r7, #12]
 800efc4:	2220      	movs	r2, #32
 800efc6:	679a      	str	r2, [r3, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 800efc8:	68fb      	ldr	r3, [r7, #12]
 800efca:	2220      	movs	r2, #32
 800efcc:	67da      	str	r2, [r3, #124]	; 0x7c

        __HAL_UNLOCK(huart);
 800efce:	68fb      	ldr	r3, [r7, #12]
 800efd0:	2200      	movs	r2, #0
 800efd2:	675a      	str	r2, [r3, #116]	; 0x74

        return HAL_TIMEOUT;
 800efd4:	2303      	movs	r3, #3
 800efd6:	e065      	b.n	800f0a4 <UART_WaitOnFlagUntilTimeout+0x178>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800efd8:	68fb      	ldr	r3, [r7, #12]
 800efda:	681b      	ldr	r3, [r3, #0]
 800efdc:	681b      	ldr	r3, [r3, #0]
 800efde:	f003 0304 	and.w	r3, r3, #4
 800efe2:	2b00      	cmp	r3, #0
 800efe4:	d04e      	beq.n	800f084 <UART_WaitOnFlagUntilTimeout+0x158>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800efe6:	68fb      	ldr	r3, [r7, #12]
 800efe8:	681b      	ldr	r3, [r3, #0]
 800efea:	69db      	ldr	r3, [r3, #28]
 800efec:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800eff0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800eff4:	d146      	bne.n	800f084 <UART_WaitOnFlagUntilTimeout+0x158>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800eff6:	68fb      	ldr	r3, [r7, #12]
 800eff8:	681b      	ldr	r3, [r3, #0]
 800effa:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800effe:	621a      	str	r2, [r3, #32]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800f000:	68fb      	ldr	r3, [r7, #12]
 800f002:	681b      	ldr	r3, [r3, #0]
 800f004:	657b      	str	r3, [r7, #84]	; 0x54
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800f006:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f008:	e853 3f00 	ldrex	r3, [r3]
 800f00c:	65bb      	str	r3, [r7, #88]	; 0x58
   return(result);
 800f00e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f010:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800f014:	613b      	str	r3, [r7, #16]
 800f016:	68fb      	ldr	r3, [r7, #12]
 800f018:	681b      	ldr	r3, [r3, #0]
 800f01a:	461a      	mov	r2, r3
 800f01c:	693b      	ldr	r3, [r7, #16]
 800f01e:	64bb      	str	r3, [r7, #72]	; 0x48
 800f020:	64fa      	str	r2, [r7, #76]	; 0x4c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800f022:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800f024:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f026:	e841 2300 	strex	r3, r2, [r1]
 800f02a:	653b      	str	r3, [r7, #80]	; 0x50
   return(result);
 800f02c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f02e:	2b00      	cmp	r3, #0
 800f030:	d1e6      	bne.n	800f000 <UART_WaitOnFlagUntilTimeout+0xd4>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800f032:	68fb      	ldr	r3, [r7, #12]
 800f034:	681b      	ldr	r3, [r3, #0]
 800f036:	3308      	adds	r3, #8
 800f038:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800f03a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f03c:	e853 3f00 	ldrex	r3, [r3]
 800f040:	66fb      	str	r3, [r7, #108]	; 0x6c
   return(result);
 800f042:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f044:	f023 0301 	bic.w	r3, r3, #1
 800f048:	617b      	str	r3, [r7, #20]
 800f04a:	68fb      	ldr	r3, [r7, #12]
 800f04c:	681b      	ldr	r3, [r3, #0]
 800f04e:	3308      	adds	r3, #8
 800f050:	697a      	ldr	r2, [r7, #20]
 800f052:	65fa      	str	r2, [r7, #92]	; 0x5c
 800f054:	663b      	str	r3, [r7, #96]	; 0x60
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800f056:	6e39      	ldr	r1, [r7, #96]	; 0x60
 800f058:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800f05a:	e841 2300 	strex	r3, r2, [r1]
 800f05e:	667b      	str	r3, [r7, #100]	; 0x64
   return(result);
 800f060:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800f062:	2b00      	cmp	r3, #0
 800f064:	d1e5      	bne.n	800f032 <UART_WaitOnFlagUntilTimeout+0x106>

          huart->gState = HAL_UART_STATE_READY;
 800f066:	68fb      	ldr	r3, [r7, #12]
 800f068:	2220      	movs	r2, #32
 800f06a:	679a      	str	r2, [r3, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 800f06c:	68fb      	ldr	r3, [r7, #12]
 800f06e:	2220      	movs	r2, #32
 800f070:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800f072:	68fb      	ldr	r3, [r7, #12]
 800f074:	2220      	movs	r2, #32
 800f076:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800f07a:	68fb      	ldr	r3, [r7, #12]
 800f07c:	2200      	movs	r2, #0
 800f07e:	675a      	str	r2, [r3, #116]	; 0x74

          return HAL_TIMEOUT;
 800f080:	2303      	movs	r3, #3
 800f082:	e00f      	b.n	800f0a4 <UART_WaitOnFlagUntilTimeout+0x178>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800f084:	68fb      	ldr	r3, [r7, #12]
 800f086:	681b      	ldr	r3, [r3, #0]
 800f088:	69da      	ldr	r2, [r3, #28]
 800f08a:	68bb      	ldr	r3, [r7, #8]
 800f08c:	4013      	ands	r3, r2
 800f08e:	68ba      	ldr	r2, [r7, #8]
 800f090:	429a      	cmp	r2, r3
 800f092:	d101      	bne.n	800f098 <UART_WaitOnFlagUntilTimeout+0x16c>
 800f094:	2201      	movs	r2, #1
 800f096:	e000      	b.n	800f09a <UART_WaitOnFlagUntilTimeout+0x16e>
 800f098:	2200      	movs	r2, #0
 800f09a:	687b      	ldr	r3, [r7, #4]
 800f09c:	429a      	cmp	r2, r3
 800f09e:	f43f af4d 	beq.w	800ef3c <UART_WaitOnFlagUntilTimeout+0x10>
        }
      }
    }
  }
  return HAL_OK;
 800f0a2:	2300      	movs	r3, #0
}
 800f0a4:	4618      	mov	r0, r3
 800f0a6:	3770      	adds	r7, #112	; 0x70
 800f0a8:	46bd      	mov	sp, r7
 800f0aa:	bd80      	pop	{r7, pc}

0800f0ac <DemoEntry>:
    }
}
#endif /* LOSCFG_COMPONENTS_NETWORK */

VOID DemoEntry(VOID)
{
 800f0ac:	b580      	push	{r7, lr}
 800f0ae:	b082      	sub	sp, #8
 800f0b0:	af00      	add	r7, sp, #0
#ifndef LOSCFG_KERNEL_SMP
    printf("Hello, welcome to liteos demo!\n");
 800f0b2:	480f      	ldr	r0, [pc, #60]	; (800f0f0 <DemoEntry+0x44>)
 800f0b4:	f001 f804 	bl	80100c0 <printf>
#endif

#ifdef LOSCFG_SHELL
    (VOID)ShellQueueCreat();
 800f0b8:	f001 fc3c 	bl	8010934 <ShellQueueCreat>
    if (OsShellInit(0) != LOS_OK) {
 800f0bc:	2000      	movs	r0, #0
 800f0be:	f002 fd4f 	bl	8011b60 <OsShellInit>
 800f0c2:	4603      	mov	r3, r0
 800f0c4:	2b00      	cmp	r3, #0
 800f0c6:	d002      	beq.n	800f0ce <DemoEntry+0x22>
        printf("Shell init failed.\n");
 800f0c8:	480a      	ldr	r0, [pc, #40]	; (800f0f4 <DemoEntry+0x48>)
 800f0ca:	f000 fff9 	bl	80100c0 <printf>
    FileSystemInit();
#endif

#ifdef LOSCFG_KERNEL_CPPSUPPORT
    extern UINT32 __init_array_start, __init_array_end;
    INT32 ret = LOS_CppSystemInit((UINT32)&__init_array_start, (UINT32)&__init_array_end, NO_SCATTER);
 800f0ce:	4b0a      	ldr	r3, [pc, #40]	; (800f0f8 <DemoEntry+0x4c>)
 800f0d0:	490a      	ldr	r1, [pc, #40]	; (800f0fc <DemoEntry+0x50>)
 800f0d2:	2202      	movs	r2, #2
 800f0d4:	4618      	mov	r0, r3
 800f0d6:	f007 f9b5 	bl	8016444 <LOS_CppSystemInit>
 800f0da:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 800f0dc:	687b      	ldr	r3, [r7, #4]
 800f0de:	2b00      	cmp	r3, #0
 800f0e0:	d002      	beq.n	800f0e8 <DemoEntry+0x3c>
        printf("LiteOS Cpp Init fail.\n");
 800f0e2:	4807      	ldr	r0, [pc, #28]	; (800f100 <DemoEntry+0x54>)
 800f0e4:	f000 ffec 	bl	80100c0 <printf>
#endif

#ifdef LOSCFG_DEMOS_APRILTAG
    ApriltagDemoTask();
#endif
}
 800f0e8:	bf00      	nop
 800f0ea:	3708      	adds	r7, #8
 800f0ec:	46bd      	mov	sp, r7
 800f0ee:	bd80      	pop	{r7, pc}
 800f0f0:	080216f0 	.word	0x080216f0
 800f0f4:	08021710 	.word	0x08021710
 800f0f8:	08024384 	.word	0x08024384
 800f0fc:	08024384 	.word	0x08024384
 800f100:	08021724 	.word	0x08021724

0800f104 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 800f104:	b480      	push	{r7}
 800f106:	b083      	sub	sp, #12
 800f108:	af00      	add	r7, sp, #0
 800f10a:	6078      	str	r0, [r7, #4]
 800f10c:	6039      	str	r1, [r7, #0]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank == FMC_SDRAM_BANK1)
 800f10e:	683b      	ldr	r3, [r7, #0]
 800f110:	681b      	ldr	r3, [r3, #0]
 800f112:	2b00      	cmp	r3, #0
 800f114:	d121      	bne.n	800f15a <FMC_SDRAM_Init+0x56>
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800f116:	687b      	ldr	r3, [r7, #4]
 800f118:	681a      	ldr	r2, [r3, #0]
 800f11a:	4b27      	ldr	r3, [pc, #156]	; (800f1b8 <FMC_SDRAM_Init+0xb4>)
 800f11c:	4013      	ands	r3, r2
 800f11e:	683a      	ldr	r2, [r7, #0]
 800f120:	6851      	ldr	r1, [r2, #4]
 800f122:	683a      	ldr	r2, [r7, #0]
 800f124:	6892      	ldr	r2, [r2, #8]
 800f126:	4311      	orrs	r1, r2
 800f128:	683a      	ldr	r2, [r7, #0]
 800f12a:	68d2      	ldr	r2, [r2, #12]
 800f12c:	4311      	orrs	r1, r2
 800f12e:	683a      	ldr	r2, [r7, #0]
 800f130:	6912      	ldr	r2, [r2, #16]
 800f132:	4311      	orrs	r1, r2
 800f134:	683a      	ldr	r2, [r7, #0]
 800f136:	6952      	ldr	r2, [r2, #20]
 800f138:	4311      	orrs	r1, r2
 800f13a:	683a      	ldr	r2, [r7, #0]
 800f13c:	6992      	ldr	r2, [r2, #24]
 800f13e:	4311      	orrs	r1, r2
 800f140:	683a      	ldr	r2, [r7, #0]
 800f142:	69d2      	ldr	r2, [r2, #28]
 800f144:	4311      	orrs	r1, r2
 800f146:	683a      	ldr	r2, [r7, #0]
 800f148:	6a12      	ldr	r2, [r2, #32]
 800f14a:	4311      	orrs	r1, r2
 800f14c:	683a      	ldr	r2, [r7, #0]
 800f14e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800f150:	430a      	orrs	r2, r1
 800f152:	431a      	orrs	r2, r3
 800f154:	687b      	ldr	r3, [r7, #4]
 800f156:	601a      	str	r2, [r3, #0]
 800f158:	e026      	b.n	800f1a8 <FMC_SDRAM_Init+0xa4>
                Init->ReadBurst          |
                Init->ReadPipeDelay));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800f15a:	687b      	ldr	r3, [r7, #4]
 800f15c:	681b      	ldr	r3, [r3, #0]
 800f15e:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
 800f162:	683b      	ldr	r3, [r7, #0]
 800f164:	69d9      	ldr	r1, [r3, #28]
 800f166:	683b      	ldr	r3, [r7, #0]
 800f168:	6a1b      	ldr	r3, [r3, #32]
 800f16a:	4319      	orrs	r1, r3
 800f16c:	683b      	ldr	r3, [r7, #0]
 800f16e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f170:	430b      	orrs	r3, r1
 800f172:	431a      	orrs	r2, r3
 800f174:	687b      	ldr	r3, [r7, #4]
 800f176:	601a      	str	r2, [r3, #0]
               FMC_SDCR1_RPIPE,
               (Init->SDClockPeriod      |
                Init->ReadBurst          |
                Init->ReadPipeDelay));

    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 800f178:	687b      	ldr	r3, [r7, #4]
 800f17a:	685a      	ldr	r2, [r3, #4]
 800f17c:	4b0e      	ldr	r3, [pc, #56]	; (800f1b8 <FMC_SDRAM_Init+0xb4>)
 800f17e:	4013      	ands	r3, r2
 800f180:	683a      	ldr	r2, [r7, #0]
 800f182:	6851      	ldr	r1, [r2, #4]
 800f184:	683a      	ldr	r2, [r7, #0]
 800f186:	6892      	ldr	r2, [r2, #8]
 800f188:	4311      	orrs	r1, r2
 800f18a:	683a      	ldr	r2, [r7, #0]
 800f18c:	68d2      	ldr	r2, [r2, #12]
 800f18e:	4311      	orrs	r1, r2
 800f190:	683a      	ldr	r2, [r7, #0]
 800f192:	6912      	ldr	r2, [r2, #16]
 800f194:	4311      	orrs	r1, r2
 800f196:	683a      	ldr	r2, [r7, #0]
 800f198:	6952      	ldr	r2, [r2, #20]
 800f19a:	4311      	orrs	r1, r2
 800f19c:	683a      	ldr	r2, [r7, #0]
 800f19e:	6992      	ldr	r2, [r2, #24]
 800f1a0:	430a      	orrs	r2, r1
 800f1a2:	431a      	orrs	r2, r3
 800f1a4:	687b      	ldr	r3, [r7, #4]
 800f1a6:	605a      	str	r2, [r3, #4]
                Init->InternalBankNumber |
                Init->CASLatency         |
                Init->WriteProtection));
  }

  return HAL_OK;
 800f1a8:	2300      	movs	r3, #0
}
 800f1aa:	4618      	mov	r0, r3
 800f1ac:	370c      	adds	r7, #12
 800f1ae:	46bd      	mov	sp, r7
 800f1b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1b4:	4770      	bx	lr
 800f1b6:	bf00      	nop
 800f1b8:	ffff8000 	.word	0xffff8000

0800f1bc <FMC_SDRAM_Timing_Init>:
  * @param  Bank SDRAM bank number
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device,
                                        FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 800f1bc:	b480      	push	{r7}
 800f1be:	b085      	sub	sp, #20
 800f1c0:	af00      	add	r7, sp, #0
 800f1c2:	60f8      	str	r0, [r7, #12]
 800f1c4:	60b9      	str	r1, [r7, #8]
 800f1c6:	607a      	str	r2, [r7, #4]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));

  /* Set SDRAM device timing parameters */
  if (Bank == FMC_SDRAM_BANK1)
 800f1c8:	687b      	ldr	r3, [r7, #4]
 800f1ca:	2b00      	cmp	r3, #0
 800f1cc:	d128      	bne.n	800f220 <FMC_SDRAM_Timing_Init+0x64>
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 800f1ce:	68fb      	ldr	r3, [r7, #12]
 800f1d0:	689b      	ldr	r3, [r3, #8]
 800f1d2:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
 800f1d6:	68bb      	ldr	r3, [r7, #8]
 800f1d8:	681b      	ldr	r3, [r3, #0]
 800f1da:	1e59      	subs	r1, r3, #1
 800f1dc:	68bb      	ldr	r3, [r7, #8]
 800f1de:	685b      	ldr	r3, [r3, #4]
 800f1e0:	3b01      	subs	r3, #1
 800f1e2:	011b      	lsls	r3, r3, #4
 800f1e4:	4319      	orrs	r1, r3
 800f1e6:	68bb      	ldr	r3, [r7, #8]
 800f1e8:	689b      	ldr	r3, [r3, #8]
 800f1ea:	3b01      	subs	r3, #1
 800f1ec:	021b      	lsls	r3, r3, #8
 800f1ee:	4319      	orrs	r1, r3
 800f1f0:	68bb      	ldr	r3, [r7, #8]
 800f1f2:	68db      	ldr	r3, [r3, #12]
 800f1f4:	3b01      	subs	r3, #1
 800f1f6:	031b      	lsls	r3, r3, #12
 800f1f8:	4319      	orrs	r1, r3
 800f1fa:	68bb      	ldr	r3, [r7, #8]
 800f1fc:	691b      	ldr	r3, [r3, #16]
 800f1fe:	3b01      	subs	r3, #1
 800f200:	041b      	lsls	r3, r3, #16
 800f202:	4319      	orrs	r1, r3
 800f204:	68bb      	ldr	r3, [r7, #8]
 800f206:	695b      	ldr	r3, [r3, #20]
 800f208:	3b01      	subs	r3, #1
 800f20a:	051b      	lsls	r3, r3, #20
 800f20c:	4319      	orrs	r1, r3
 800f20e:	68bb      	ldr	r3, [r7, #8]
 800f210:	699b      	ldr	r3, [r3, #24]
 800f212:	3b01      	subs	r3, #1
 800f214:	061b      	lsls	r3, r3, #24
 800f216:	430b      	orrs	r3, r1
 800f218:	431a      	orrs	r2, r3
 800f21a:	68fb      	ldr	r3, [r7, #12]
 800f21c:	609a      	str	r2, [r3, #8]
 800f21e:	e02d      	b.n	800f27c <FMC_SDRAM_Timing_Init+0xc0>
                (((Timing->RPDelay) - 1U)              << FMC_SDTR1_TRP_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTR1_TRCD_Pos)));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 800f220:	68fb      	ldr	r3, [r7, #12]
 800f222:	689a      	ldr	r2, [r3, #8]
 800f224:	4b19      	ldr	r3, [pc, #100]	; (800f28c <FMC_SDRAM_Timing_Init+0xd0>)
 800f226:	4013      	ands	r3, r2
 800f228:	68ba      	ldr	r2, [r7, #8]
 800f22a:	68d2      	ldr	r2, [r2, #12]
 800f22c:	3a01      	subs	r2, #1
 800f22e:	0311      	lsls	r1, r2, #12
 800f230:	68ba      	ldr	r2, [r7, #8]
 800f232:	6952      	ldr	r2, [r2, #20]
 800f234:	3a01      	subs	r2, #1
 800f236:	0512      	lsls	r2, r2, #20
 800f238:	430a      	orrs	r2, r1
 800f23a:	431a      	orrs	r2, r3
 800f23c:	68fb      	ldr	r3, [r7, #12]
 800f23e:	609a      	str	r2, [r3, #8]
               FMC_SDTR1_TRC |
               FMC_SDTR1_TRP,
               (((Timing->RowCycleDelay) - 1U)         << FMC_SDTR1_TRC_Pos)  |
               (((Timing->RPDelay) - 1U)               << FMC_SDTR1_TRP_Pos));

    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
 800f240:	68fb      	ldr	r3, [r7, #12]
 800f242:	68db      	ldr	r3, [r3, #12]
 800f244:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
 800f248:	68bb      	ldr	r3, [r7, #8]
 800f24a:	681b      	ldr	r3, [r3, #0]
 800f24c:	1e59      	subs	r1, r3, #1
 800f24e:	68bb      	ldr	r3, [r7, #8]
 800f250:	685b      	ldr	r3, [r3, #4]
 800f252:	3b01      	subs	r3, #1
 800f254:	011b      	lsls	r3, r3, #4
 800f256:	4319      	orrs	r1, r3
 800f258:	68bb      	ldr	r3, [r7, #8]
 800f25a:	689b      	ldr	r3, [r3, #8]
 800f25c:	3b01      	subs	r3, #1
 800f25e:	021b      	lsls	r3, r3, #8
 800f260:	4319      	orrs	r1, r3
 800f262:	68bb      	ldr	r3, [r7, #8]
 800f264:	691b      	ldr	r3, [r3, #16]
 800f266:	3b01      	subs	r3, #1
 800f268:	041b      	lsls	r3, r3, #16
 800f26a:	4319      	orrs	r1, r3
 800f26c:	68bb      	ldr	r3, [r7, #8]
 800f26e:	699b      	ldr	r3, [r3, #24]
 800f270:	3b01      	subs	r3, #1
 800f272:	061b      	lsls	r3, r3, #24
 800f274:	430b      	orrs	r3, r1
 800f276:	431a      	orrs	r2, r3
 800f278:	68fb      	ldr	r3, [r7, #12]
 800f27a:	60da      	str	r2, [r3, #12]
                (((Timing->SelfRefreshTime) - 1U)      << FMC_SDTR1_TRAS_Pos) |
                (((Timing->WriteRecoveryTime) - 1U)    << FMC_SDTR1_TWR_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTR1_TRCD_Pos)));
  }

  return HAL_OK;
 800f27c:	2300      	movs	r3, #0
}
 800f27e:	4618      	mov	r0, r3
 800f280:	3714      	adds	r7, #20
 800f282:	46bd      	mov	sp, r7
 800f284:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f288:	4770      	bx	lr
 800f28a:	bf00      	nop
 800f28c:	ff0f0fff 	.word	0xff0f0fff

0800f290 <FMC_SDRAM_SendCommand>:
  * @param  Timeout Timeout wait value
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device,
                                        FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 800f290:	b480      	push	{r7}
 800f292:	b085      	sub	sp, #20
 800f294:	af00      	add	r7, sp, #0
 800f296:	60f8      	str	r0, [r7, #12]
 800f298:	60b9      	str	r1, [r7, #8]
 800f29a:	607a      	str	r2, [r7, #4]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));

  /* Set command register */
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | FMC_SDCMR_NRFS | FMC_SDCMR_MRD),
 800f29c:	68fb      	ldr	r3, [r7, #12]
 800f29e:	691a      	ldr	r2, [r3, #16]
 800f2a0:	4b0c      	ldr	r3, [pc, #48]	; (800f2d4 <FMC_SDRAM_SendCommand+0x44>)
 800f2a2:	4013      	ands	r3, r2
 800f2a4:	68ba      	ldr	r2, [r7, #8]
 800f2a6:	6811      	ldr	r1, [r2, #0]
 800f2a8:	68ba      	ldr	r2, [r7, #8]
 800f2aa:	6852      	ldr	r2, [r2, #4]
 800f2ac:	4311      	orrs	r1, r2
 800f2ae:	68ba      	ldr	r2, [r7, #8]
 800f2b0:	6892      	ldr	r2, [r2, #8]
 800f2b2:	3a01      	subs	r2, #1
 800f2b4:	0152      	lsls	r2, r2, #5
 800f2b6:	4311      	orrs	r1, r2
 800f2b8:	68ba      	ldr	r2, [r7, #8]
 800f2ba:	68d2      	ldr	r2, [r2, #12]
 800f2bc:	0252      	lsls	r2, r2, #9
 800f2be:	430a      	orrs	r2, r1
 800f2c0:	431a      	orrs	r2, r3
 800f2c2:	68fb      	ldr	r3, [r7, #12]
 800f2c4:	611a      	str	r2, [r3, #16]
             ((Command->CommandMode) | (Command->CommandTarget) |
              (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos) |
              ((Command->ModeRegisterDefinition) << FMC_SDCMR_MRD_Pos)));
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Timeout);
  return HAL_OK;
 800f2c6:	2300      	movs	r3, #0
}
 800f2c8:	4618      	mov	r0, r3
 800f2ca:	3714      	adds	r7, #20
 800f2cc:	46bd      	mov	sp, r7
 800f2ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f2d2:	4770      	bx	lr
 800f2d4:	ffc00000 	.word	0xffc00000

0800f2d8 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 800f2d8:	b480      	push	{r7}
 800f2da:	b083      	sub	sp, #12
 800f2dc:	af00      	add	r7, sp, #0
 800f2de:	6078      	str	r0, [r7, #4]
 800f2e0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));

  /* Set the refresh rate in command register */
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
 800f2e2:	687b      	ldr	r3, [r7, #4]
 800f2e4:	695a      	ldr	r2, [r3, #20]
 800f2e6:	4b07      	ldr	r3, [pc, #28]	; (800f304 <FMC_SDRAM_ProgramRefreshRate+0x2c>)
 800f2e8:	4013      	ands	r3, r2
 800f2ea:	683a      	ldr	r2, [r7, #0]
 800f2ec:	0052      	lsls	r2, r2, #1
 800f2ee:	431a      	orrs	r2, r3
 800f2f0:	687b      	ldr	r3, [r7, #4]
 800f2f2:	615a      	str	r2, [r3, #20]

  return HAL_OK;
 800f2f4:	2300      	movs	r3, #0
}
 800f2f6:	4618      	mov	r0, r3
 800f2f8:	370c      	adds	r7, #12
 800f2fa:	46bd      	mov	sp, r7
 800f2fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f300:	4770      	bx	lr
 800f302:	bf00      	nop
 800f304:	ffffc001 	.word	0xffffc001

0800f308 <memset>:
	return 0;
}
#endif

void *memset(void *dest, int c, size_t n)
{
 800f308:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
 800f30c:	b08b      	sub	sp, #44	; 0x2c
 800f30e:	af00      	add	r7, sp, #0
 800f310:	60f8      	str	r0, [r7, #12]
 800f312:	60b9      	str	r1, [r7, #8]
 800f314:	607a      	str	r2, [r7, #4]
	unsigned char *s = dest;
 800f316:	68fb      	ldr	r3, [r7, #12]
 800f318:	617b      	str	r3, [r7, #20]

	/* Fill head and tail with minimal branching. Each
	 * conditional ensures that all the subsequently used
	 * offsets are well-defined and in the dest region. */

	if (!n) return dest;
 800f31a:	687b      	ldr	r3, [r7, #4]
 800f31c:	2b00      	cmp	r3, #0
 800f31e:	d101      	bne.n	800f324 <memset+0x1c>
 800f320:	68fb      	ldr	r3, [r7, #12]
 800f322:	e0ec      	b.n	800f4fe <memset+0x1f6>
	s[0] = c;
 800f324:	68bb      	ldr	r3, [r7, #8]
 800f326:	b2da      	uxtb	r2, r3
 800f328:	697b      	ldr	r3, [r7, #20]
 800f32a:	701a      	strb	r2, [r3, #0]
	s[n-1] = c;
 800f32c:	687b      	ldr	r3, [r7, #4]
 800f32e:	3b01      	subs	r3, #1
 800f330:	697a      	ldr	r2, [r7, #20]
 800f332:	4413      	add	r3, r2
 800f334:	68ba      	ldr	r2, [r7, #8]
 800f336:	b2d2      	uxtb	r2, r2
 800f338:	701a      	strb	r2, [r3, #0]
	if (n <= 2) return dest;
 800f33a:	687b      	ldr	r3, [r7, #4]
 800f33c:	2b02      	cmp	r3, #2
 800f33e:	d801      	bhi.n	800f344 <memset+0x3c>
 800f340:	68fb      	ldr	r3, [r7, #12]
 800f342:	e0dc      	b.n	800f4fe <memset+0x1f6>
	s[1] = c;
 800f344:	697b      	ldr	r3, [r7, #20]
 800f346:	3301      	adds	r3, #1
 800f348:	68ba      	ldr	r2, [r7, #8]
 800f34a:	b2d2      	uxtb	r2, r2
 800f34c:	701a      	strb	r2, [r3, #0]
	s[2] = c;
 800f34e:	697b      	ldr	r3, [r7, #20]
 800f350:	3302      	adds	r3, #2
 800f352:	68ba      	ldr	r2, [r7, #8]
 800f354:	b2d2      	uxtb	r2, r2
 800f356:	701a      	strb	r2, [r3, #0]
	s[n-2] = c;
 800f358:	687b      	ldr	r3, [r7, #4]
 800f35a:	3b02      	subs	r3, #2
 800f35c:	697a      	ldr	r2, [r7, #20]
 800f35e:	4413      	add	r3, r2
 800f360:	68ba      	ldr	r2, [r7, #8]
 800f362:	b2d2      	uxtb	r2, r2
 800f364:	701a      	strb	r2, [r3, #0]
	s[n-3] = c;
 800f366:	687b      	ldr	r3, [r7, #4]
 800f368:	3b03      	subs	r3, #3
 800f36a:	697a      	ldr	r2, [r7, #20]
 800f36c:	4413      	add	r3, r2
 800f36e:	68ba      	ldr	r2, [r7, #8]
 800f370:	b2d2      	uxtb	r2, r2
 800f372:	701a      	strb	r2, [r3, #0]
	if (n <= 6) return dest;
 800f374:	687b      	ldr	r3, [r7, #4]
 800f376:	2b06      	cmp	r3, #6
 800f378:	d801      	bhi.n	800f37e <memset+0x76>
 800f37a:	68fb      	ldr	r3, [r7, #12]
 800f37c:	e0bf      	b.n	800f4fe <memset+0x1f6>
	s[3] = c;
 800f37e:	697b      	ldr	r3, [r7, #20]
 800f380:	3303      	adds	r3, #3
 800f382:	68ba      	ldr	r2, [r7, #8]
 800f384:	b2d2      	uxtb	r2, r2
 800f386:	701a      	strb	r2, [r3, #0]
	s[n-4] = c;
 800f388:	687b      	ldr	r3, [r7, #4]
 800f38a:	3b04      	subs	r3, #4
 800f38c:	697a      	ldr	r2, [r7, #20]
 800f38e:	4413      	add	r3, r2
 800f390:	68ba      	ldr	r2, [r7, #8]
 800f392:	b2d2      	uxtb	r2, r2
 800f394:	701a      	strb	r2, [r3, #0]
	if (n <= 8) return dest;
 800f396:	687b      	ldr	r3, [r7, #4]
 800f398:	2b08      	cmp	r3, #8
 800f39a:	d801      	bhi.n	800f3a0 <memset+0x98>
 800f39c:	68fb      	ldr	r3, [r7, #12]
 800f39e:	e0ae      	b.n	800f4fe <memset+0x1f6>
	/* Advance pointer to align it at a 4-byte boundary,
	 * and truncate n to a multiple of 4. The previous code
	 * already took care of any head/tail that get cut off
	 * by the alignment. */

	k = -(uintptr_t)s & 3;
 800f3a0:	697b      	ldr	r3, [r7, #20]
 800f3a2:	425b      	negs	r3, r3
 800f3a4:	f003 0303 	and.w	r3, r3, #3
 800f3a8:	61bb      	str	r3, [r7, #24]
	s += k;
 800f3aa:	697a      	ldr	r2, [r7, #20]
 800f3ac:	69bb      	ldr	r3, [r7, #24]
 800f3ae:	4413      	add	r3, r2
 800f3b0:	617b      	str	r3, [r7, #20]
	n -= k;
 800f3b2:	687a      	ldr	r2, [r7, #4]
 800f3b4:	69bb      	ldr	r3, [r7, #24]
 800f3b6:	1ad3      	subs	r3, r2, r3
 800f3b8:	607b      	str	r3, [r7, #4]
	n &= -4;
 800f3ba:	687b      	ldr	r3, [r7, #4]
 800f3bc:	f023 0303 	bic.w	r3, r3, #3
 800f3c0:	607b      	str	r3, [r7, #4]

#ifdef __GNUC__
	typedef uint32_t __attribute__((__may_alias__)) u32;
	typedef uint64_t __attribute__((__may_alias__)) u64;

	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
 800f3c2:	68bb      	ldr	r3, [r7, #8]
 800f3c4:	b2db      	uxtb	r3, r3
 800f3c6:	461a      	mov	r2, r3
 800f3c8:	4613      	mov	r3, r2
 800f3ca:	021b      	lsls	r3, r3, #8
 800f3cc:	4413      	add	r3, r2
 800f3ce:	041a      	lsls	r2, r3, #16
 800f3d0:	4413      	add	r3, r2
 800f3d2:	61fb      	str	r3, [r7, #28]
	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
	 * As in the initial byte-based head/tail fill, each
	 * conditional below ensures that the subsequent offsets
	 * are valid (e.g. !(n<=24) implies n>=28). */

	*(u32 *)(s+0) = c32;
 800f3d4:	697b      	ldr	r3, [r7, #20]
 800f3d6:	69fa      	ldr	r2, [r7, #28]
 800f3d8:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-4) = c32;
 800f3da:	687b      	ldr	r3, [r7, #4]
 800f3dc:	3b04      	subs	r3, #4
 800f3de:	697a      	ldr	r2, [r7, #20]
 800f3e0:	4413      	add	r3, r2
 800f3e2:	69fa      	ldr	r2, [r7, #28]
 800f3e4:	601a      	str	r2, [r3, #0]
	if (n <= 8) return dest;
 800f3e6:	687b      	ldr	r3, [r7, #4]
 800f3e8:	2b08      	cmp	r3, #8
 800f3ea:	d801      	bhi.n	800f3f0 <memset+0xe8>
 800f3ec:	68fb      	ldr	r3, [r7, #12]
 800f3ee:	e086      	b.n	800f4fe <memset+0x1f6>
	*(u32 *)(s+4) = c32;
 800f3f0:	697b      	ldr	r3, [r7, #20]
 800f3f2:	3304      	adds	r3, #4
 800f3f4:	69fa      	ldr	r2, [r7, #28]
 800f3f6:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+8) = c32;
 800f3f8:	697b      	ldr	r3, [r7, #20]
 800f3fa:	3308      	adds	r3, #8
 800f3fc:	69fa      	ldr	r2, [r7, #28]
 800f3fe:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-12) = c32;
 800f400:	687b      	ldr	r3, [r7, #4]
 800f402:	3b0c      	subs	r3, #12
 800f404:	697a      	ldr	r2, [r7, #20]
 800f406:	4413      	add	r3, r2
 800f408:	69fa      	ldr	r2, [r7, #28]
 800f40a:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-8) = c32;
 800f40c:	687b      	ldr	r3, [r7, #4]
 800f40e:	3b08      	subs	r3, #8
 800f410:	697a      	ldr	r2, [r7, #20]
 800f412:	4413      	add	r3, r2
 800f414:	69fa      	ldr	r2, [r7, #28]
 800f416:	601a      	str	r2, [r3, #0]
	if (n <= 24) return dest;
 800f418:	687b      	ldr	r3, [r7, #4]
 800f41a:	2b18      	cmp	r3, #24
 800f41c:	d801      	bhi.n	800f422 <memset+0x11a>
 800f41e:	68fb      	ldr	r3, [r7, #12]
 800f420:	e06d      	b.n	800f4fe <memset+0x1f6>
	*(u32 *)(s+12) = c32;
 800f422:	697b      	ldr	r3, [r7, #20]
 800f424:	330c      	adds	r3, #12
 800f426:	69fa      	ldr	r2, [r7, #28]
 800f428:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+16) = c32;
 800f42a:	697b      	ldr	r3, [r7, #20]
 800f42c:	3310      	adds	r3, #16
 800f42e:	69fa      	ldr	r2, [r7, #28]
 800f430:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+20) = c32;
 800f432:	697b      	ldr	r3, [r7, #20]
 800f434:	3314      	adds	r3, #20
 800f436:	69fa      	ldr	r2, [r7, #28]
 800f438:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+24) = c32;
 800f43a:	697b      	ldr	r3, [r7, #20]
 800f43c:	3318      	adds	r3, #24
 800f43e:	69fa      	ldr	r2, [r7, #28]
 800f440:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-28) = c32;
 800f442:	687b      	ldr	r3, [r7, #4]
 800f444:	3b1c      	subs	r3, #28
 800f446:	697a      	ldr	r2, [r7, #20]
 800f448:	4413      	add	r3, r2
 800f44a:	69fa      	ldr	r2, [r7, #28]
 800f44c:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-24) = c32;
 800f44e:	687b      	ldr	r3, [r7, #4]
 800f450:	3b18      	subs	r3, #24
 800f452:	697a      	ldr	r2, [r7, #20]
 800f454:	4413      	add	r3, r2
 800f456:	69fa      	ldr	r2, [r7, #28]
 800f458:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-20) = c32;
 800f45a:	687b      	ldr	r3, [r7, #4]
 800f45c:	3b14      	subs	r3, #20
 800f45e:	697a      	ldr	r2, [r7, #20]
 800f460:	4413      	add	r3, r2
 800f462:	69fa      	ldr	r2, [r7, #28]
 800f464:	601a      	str	r2, [r3, #0]
	*(u32 *)(s+n-16) = c32;
 800f466:	687b      	ldr	r3, [r7, #4]
 800f468:	3b10      	subs	r3, #16
 800f46a:	697a      	ldr	r2, [r7, #20]
 800f46c:	4413      	add	r3, r2
 800f46e:	69fa      	ldr	r2, [r7, #28]
 800f470:	601a      	str	r2, [r3, #0]

	/* Align to a multiple of 8 so we can fill 64 bits at a time,
	 * and avoid writing the same bytes twice as much as is
	 * practical without introducing additional branching. */

	k = 24 + ((uintptr_t)s & 4);
 800f472:	697b      	ldr	r3, [r7, #20]
 800f474:	f003 0304 	and.w	r3, r3, #4
 800f478:	3318      	adds	r3, #24
 800f47a:	61bb      	str	r3, [r7, #24]
	s += k;
 800f47c:	697a      	ldr	r2, [r7, #20]
 800f47e:	69bb      	ldr	r3, [r7, #24]
 800f480:	4413      	add	r3, r2
 800f482:	617b      	str	r3, [r7, #20]
	n -= k;
 800f484:	687a      	ldr	r2, [r7, #4]
 800f486:	69bb      	ldr	r3, [r7, #24]
 800f488:	1ad3      	subs	r3, r2, r3
 800f48a:	607b      	str	r3, [r7, #4]

	/* If this loop is reached, 28 tail bytes have already been
	 * filled, so any remainder when n drops below 32 can be
	 * safely ignored. */

	u64 c64 = c32 | ((u64)c32 << 32);
 800f48c:	69fb      	ldr	r3, [r7, #28]
 800f48e:	4618      	mov	r0, r3
 800f490:	f04f 0100 	mov.w	r1, #0
 800f494:	69fb      	ldr	r3, [r7, #28]
 800f496:	4698      	mov	r8, r3
 800f498:	f04f 0900 	mov.w	r9, #0
 800f49c:	f04f 0200 	mov.w	r2, #0
 800f4a0:	f04f 0300 	mov.w	r3, #0
 800f4a4:	4643      	mov	r3, r8
 800f4a6:	2200      	movs	r2, #0
 800f4a8:	ea40 0402 	orr.w	r4, r0, r2
 800f4ac:	ea41 0503 	orr.w	r5, r1, r3
 800f4b0:	e9c7 4508 	strd	r4, r5, [r7, #32]
	for (; n >= 32; n-=32, s+=32) {
 800f4b4:	e01f      	b.n	800f4f6 <memset+0x1ee>
		*(u64 *)(s+0) = c64;
 800f4b6:	6979      	ldr	r1, [r7, #20]
 800f4b8:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800f4bc:	e9c1 2300 	strd	r2, r3, [r1]
		*(u64 *)(s+8) = c64;
 800f4c0:	697b      	ldr	r3, [r7, #20]
 800f4c2:	f103 0108 	add.w	r1, r3, #8
 800f4c6:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800f4ca:	e9c1 2300 	strd	r2, r3, [r1]
		*(u64 *)(s+16) = c64;
 800f4ce:	697b      	ldr	r3, [r7, #20]
 800f4d0:	f103 0110 	add.w	r1, r3, #16
 800f4d4:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800f4d8:	e9c1 2300 	strd	r2, r3, [r1]
		*(u64 *)(s+24) = c64;
 800f4dc:	697b      	ldr	r3, [r7, #20]
 800f4de:	f103 0118 	add.w	r1, r3, #24
 800f4e2:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800f4e6:	e9c1 2300 	strd	r2, r3, [r1]
	for (; n >= 32; n-=32, s+=32) {
 800f4ea:	687b      	ldr	r3, [r7, #4]
 800f4ec:	3b20      	subs	r3, #32
 800f4ee:	607b      	str	r3, [r7, #4]
 800f4f0:	697b      	ldr	r3, [r7, #20]
 800f4f2:	3320      	adds	r3, #32
 800f4f4:	617b      	str	r3, [r7, #20]
 800f4f6:	687b      	ldr	r3, [r7, #4]
 800f4f8:	2b1f      	cmp	r3, #31
 800f4fa:	d8dc      	bhi.n	800f4b6 <memset+0x1ae>
#else
	/* Pure C fallback with no aliasing violations. */
	for (; n; n--, s++) *s = c;
#endif

	return dest;
 800f4fc:	68fb      	ldr	r3, [r7, #12]
}
 800f4fe:	4618      	mov	r0, r3
 800f500:	372c      	adds	r7, #44	; 0x2c
 800f502:	46bd      	mov	sp, r7
 800f504:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
 800f508:	4770      	bx	lr

0800f50a <strcmp>:
#include <string.h>

int strcmp(const char *l, const char *r)
{
 800f50a:	b480      	push	{r7}
 800f50c:	b083      	sub	sp, #12
 800f50e:	af00      	add	r7, sp, #0
 800f510:	6078      	str	r0, [r7, #4]
 800f512:	6039      	str	r1, [r7, #0]
	for (; *l==*r && *l; l++, r++);
 800f514:	e005      	b.n	800f522 <strcmp+0x18>
 800f516:	687b      	ldr	r3, [r7, #4]
 800f518:	3301      	adds	r3, #1
 800f51a:	607b      	str	r3, [r7, #4]
 800f51c:	683b      	ldr	r3, [r7, #0]
 800f51e:	3301      	adds	r3, #1
 800f520:	603b      	str	r3, [r7, #0]
 800f522:	687b      	ldr	r3, [r7, #4]
 800f524:	781a      	ldrb	r2, [r3, #0]
 800f526:	683b      	ldr	r3, [r7, #0]
 800f528:	781b      	ldrb	r3, [r3, #0]
 800f52a:	429a      	cmp	r2, r3
 800f52c:	d103      	bne.n	800f536 <strcmp+0x2c>
 800f52e:	687b      	ldr	r3, [r7, #4]
 800f530:	781b      	ldrb	r3, [r3, #0]
 800f532:	2b00      	cmp	r3, #0
 800f534:	d1ef      	bne.n	800f516 <strcmp+0xc>
	return *(unsigned char *)l - *(unsigned char *)r;
 800f536:	687b      	ldr	r3, [r7, #4]
 800f538:	781b      	ldrb	r3, [r3, #0]
 800f53a:	461a      	mov	r2, r3
 800f53c:	683b      	ldr	r3, [r7, #0]
 800f53e:	781b      	ldrb	r3, [r3, #0]
 800f540:	1ad3      	subs	r3, r2, r3
}
 800f542:	4618      	mov	r0, r3
 800f544:	370c      	adds	r7, #12
 800f546:	46bd      	mov	sp, r7
 800f548:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f54c:	4770      	bx	lr

0800f54e <strlen>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) (((x)-ONES) & ~(x) & HIGHS)

size_t strlen(const char *s)
{
 800f54e:	b480      	push	{r7}
 800f550:	b085      	sub	sp, #20
 800f552:	af00      	add	r7, sp, #0
 800f554:	6078      	str	r0, [r7, #4]
	const char *a = s;
 800f556:	687b      	ldr	r3, [r7, #4]
 800f558:	60fb      	str	r3, [r7, #12]
#ifdef __GNUC__
	typedef size_t __attribute__((__may_alias__)) word;
	const word *w;
	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
 800f55a:	e00a      	b.n	800f572 <strlen+0x24>
 800f55c:	687b      	ldr	r3, [r7, #4]
 800f55e:	781b      	ldrb	r3, [r3, #0]
 800f560:	2b00      	cmp	r3, #0
 800f562:	d103      	bne.n	800f56c <strlen+0x1e>
 800f564:	687a      	ldr	r2, [r7, #4]
 800f566:	68fb      	ldr	r3, [r7, #12]
 800f568:	1ad3      	subs	r3, r2, r3
 800f56a:	e026      	b.n	800f5ba <strlen+0x6c>
 800f56c:	687b      	ldr	r3, [r7, #4]
 800f56e:	3301      	adds	r3, #1
 800f570:	607b      	str	r3, [r7, #4]
 800f572:	687b      	ldr	r3, [r7, #4]
 800f574:	f003 0303 	and.w	r3, r3, #3
 800f578:	2b00      	cmp	r3, #0
 800f57a:	d1ef      	bne.n	800f55c <strlen+0xe>
	for (w = (const void *)s; !HASZERO(*w); w++);
 800f57c:	687b      	ldr	r3, [r7, #4]
 800f57e:	60bb      	str	r3, [r7, #8]
 800f580:	e002      	b.n	800f588 <strlen+0x3a>
 800f582:	68bb      	ldr	r3, [r7, #8]
 800f584:	3304      	adds	r3, #4
 800f586:	60bb      	str	r3, [r7, #8]
 800f588:	68bb      	ldr	r3, [r7, #8]
 800f58a:	681b      	ldr	r3, [r3, #0]
 800f58c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 800f590:	68bb      	ldr	r3, [r7, #8]
 800f592:	681b      	ldr	r3, [r3, #0]
 800f594:	43db      	mvns	r3, r3
 800f596:	4013      	ands	r3, r2
 800f598:	f003 3380 	and.w	r3, r3, #2155905152	; 0x80808080
 800f59c:	2b00      	cmp	r3, #0
 800f59e:	d0f0      	beq.n	800f582 <strlen+0x34>
	s = (const void *)w;
 800f5a0:	68bb      	ldr	r3, [r7, #8]
 800f5a2:	607b      	str	r3, [r7, #4]
#endif
	for (; *s; s++);
 800f5a4:	e002      	b.n	800f5ac <strlen+0x5e>
 800f5a6:	687b      	ldr	r3, [r7, #4]
 800f5a8:	3301      	adds	r3, #1
 800f5aa:	607b      	str	r3, [r7, #4]
 800f5ac:	687b      	ldr	r3, [r7, #4]
 800f5ae:	781b      	ldrb	r3, [r3, #0]
 800f5b0:	2b00      	cmp	r3, #0
 800f5b2:	d1f8      	bne.n	800f5a6 <strlen+0x58>
	return s-a;
 800f5b4:	687a      	ldr	r2, [r7, #4]
 800f5b6:	68fb      	ldr	r3, [r7, #12]
 800f5b8:	1ad3      	subs	r3, r2, r3
}
 800f5ba:	4618      	mov	r0, r3
 800f5bc:	3714      	adds	r7, #20
 800f5be:	46bd      	mov	sp, r7
 800f5c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f5c4:	4770      	bx	lr
	...

0800f5c8 <strtox>:
#include <inttypes.h>
#include <limits.h>
#include <ctype.h>

static unsigned long long strtox(const char *s, char **p, int base, unsigned long long lim)
{
 800f5c8:	b580      	push	{r7, lr}
 800f5ca:	b0b0      	sub	sp, #192	; 0xc0
 800f5cc:	af02      	add	r7, sp, #8
 800f5ce:	60f8      	str	r0, [r7, #12]
 800f5d0:	60b9      	str	r1, [r7, #8]
 800f5d2:	607a      	str	r2, [r7, #4]
 800f5d4:	4b1e      	ldr	r3, [pc, #120]	; (800f650 <strtox+0x88>)
 800f5d6:	681b      	ldr	r3, [r3, #0]
 800f5d8:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800f5dc:	f04f 0300 	mov.w	r3, #0
	FILE f;
	sh_fromstring(&f, s);
 800f5e0:	68fb      	ldr	r3, [r7, #12]
 800f5e2:	627b      	str	r3, [r7, #36]	; 0x24
 800f5e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f5e6:	653b      	str	r3, [r7, #80]	; 0x50
 800f5e8:	f04f 33ff 	mov.w	r3, #4294967295
 800f5ec:	62bb      	str	r3, [r7, #40]	; 0x28
	shlim(&f, 0);
 800f5ee:	f107 0320 	add.w	r3, r7, #32
 800f5f2:	2100      	movs	r1, #0
 800f5f4:	4618      	mov	r0, r3
 800f5f6:	f000 fc35 	bl	800fe64 <__shlim>
	unsigned long long y = __intscan(&f, base, 1, lim);
 800f5fa:	6879      	ldr	r1, [r7, #4]
 800f5fc:	f107 0020 	add.w	r0, r7, #32
 800f600:	e9d7 2330 	ldrd	r2, r3, [r7, #192]	; 0xc0
 800f604:	e9cd 2300 	strd	r2, r3, [sp]
 800f608:	2201      	movs	r2, #1
 800f60a:	f000 f84f 	bl	800f6ac <__intscan>
 800f60e:	e9c7 0106 	strd	r0, r1, [r7, #24]
	if (p) {
 800f612:	68bb      	ldr	r3, [r7, #8]
 800f614:	2b00      	cmp	r3, #0
 800f616:	d00b      	beq.n	800f630 <strtox+0x68>
		size_t cnt = shcnt(&f);
 800f618:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 800f61c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800f61e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f620:	1acb      	subs	r3, r1, r3
 800f622:	4413      	add	r3, r2
 800f624:	617b      	str	r3, [r7, #20]
		*p = (char *)s + cnt;
 800f626:	68fa      	ldr	r2, [r7, #12]
 800f628:	697b      	ldr	r3, [r7, #20]
 800f62a:	441a      	add	r2, r3
 800f62c:	68bb      	ldr	r3, [r7, #8]
 800f62e:	601a      	str	r2, [r3, #0]
	}
	return y;
 800f630:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
}
 800f634:	4906      	ldr	r1, [pc, #24]	; (800f650 <strtox+0x88>)
 800f636:	6808      	ldr	r0, [r1, #0]
 800f638:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
 800f63c:	4048      	eors	r0, r1
 800f63e:	d001      	beq.n	800f644 <strtox+0x7c>
 800f640:	f7f4 ffcc 	bl	80045dc <__stack_chk_fail>
 800f644:	4610      	mov	r0, r2
 800f646:	4619      	mov	r1, r3
 800f648:	37b8      	adds	r7, #184	; 0xb8
 800f64a:	46bd      	mov	sp, r7
 800f64c:	bd80      	pop	{r7, pc}
 800f64e:	bf00      	nop
 800f650:	0802173c 	.word	0x0802173c

0800f654 <strtoul>:
{
	return strtox(s, p, base, LLONG_MIN);
}

unsigned long strtoul(const char *restrict s, char **restrict p, int base)
{
 800f654:	b580      	push	{r7, lr}
 800f656:	b086      	sub	sp, #24
 800f658:	af02      	add	r7, sp, #8
 800f65a:	60f8      	str	r0, [r7, #12]
 800f65c:	60b9      	str	r1, [r7, #8]
 800f65e:	607a      	str	r2, [r7, #4]
	return strtox(s, p, base, ULONG_MAX);
 800f660:	f04f 32ff 	mov.w	r2, #4294967295
 800f664:	f04f 0300 	mov.w	r3, #0
 800f668:	e9cd 2300 	strd	r2, r3, [sp]
 800f66c:	687a      	ldr	r2, [r7, #4]
 800f66e:	68b9      	ldr	r1, [r7, #8]
 800f670:	68f8      	ldr	r0, [r7, #12]
 800f672:	f7ff ffa9 	bl	800f5c8 <strtox>
 800f676:	4602      	mov	r2, r0
 800f678:	460b      	mov	r3, r1
 800f67a:	4613      	mov	r3, r2
}
 800f67c:	4618      	mov	r0, r3
 800f67e:	3710      	adds	r7, #16
 800f680:	46bd      	mov	sp, r7
 800f682:	bd80      	pop	{r7, pc}

0800f684 <__isspace>:
 */
int   toupper(int);

#ifndef __cplusplus
static __inline int __isspace(int _c)
{
 800f684:	b480      	push	{r7}
 800f686:	b083      	sub	sp, #12
 800f688:	af00      	add	r7, sp, #0
 800f68a:	6078      	str	r0, [r7, #4]
	return _c == ' ' || (unsigned)_c-'\t' < 5;
 800f68c:	687b      	ldr	r3, [r7, #4]
 800f68e:	2b20      	cmp	r3, #32
 800f690:	d003      	beq.n	800f69a <__isspace+0x16>
 800f692:	687b      	ldr	r3, [r7, #4]
 800f694:	3b09      	subs	r3, #9
 800f696:	2b04      	cmp	r3, #4
 800f698:	d801      	bhi.n	800f69e <__isspace+0x1a>
 800f69a:	2301      	movs	r3, #1
 800f69c:	e000      	b.n	800f6a0 <__isspace+0x1c>
 800f69e:	2300      	movs	r3, #0
}
 800f6a0:	4618      	mov	r0, r3
 800f6a2:	370c      	adds	r7, #12
 800f6a4:	46bd      	mov	sp, r7
 800f6a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6aa:	4770      	bx	lr

0800f6ac <__intscan>:
-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
};

unsigned long long __intscan(FILE *f, unsigned base, int pok, unsigned long long lim)
{
 800f6ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f6b0:	b0a5      	sub	sp, #148	; 0x94
 800f6b2:	af00      	add	r7, sp, #0
 800f6b4:	66f8      	str	r0, [r7, #108]	; 0x6c
 800f6b6:	66b9      	str	r1, [r7, #104]	; 0x68
 800f6b8:	667a      	str	r2, [r7, #100]	; 0x64
	const unsigned char *val = table+1;
 800f6ba:	4ba0      	ldr	r3, [pc, #640]	; (800f93c <__intscan+0x290>)
 800f6bc:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
	int c, neg=0;
 800f6c0:	2300      	movs	r3, #0
 800f6c2:	67bb      	str	r3, [r7, #120]	; 0x78
	unsigned x;
	unsigned long long y;
	if (base > 36 || base == 1) {
 800f6c4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f6c6:	2b24      	cmp	r3, #36	; 0x24
 800f6c8:	d802      	bhi.n	800f6d0 <__intscan+0x24>
 800f6ca:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f6cc:	2b01      	cmp	r3, #1
 800f6ce:	d10b      	bne.n	800f6e8 <__intscan+0x3c>
		errno = EINVAL;
 800f6d0:	f000 fc62 	bl	800ff98 <__errno_location>
 800f6d4:	4603      	mov	r3, r0
 800f6d6:	2216      	movs	r2, #22
 800f6d8:	601a      	str	r2, [r3, #0]
		return 0;
 800f6da:	f04f 0300 	mov.w	r3, #0
 800f6de:	f04f 0400 	mov.w	r4, #0
 800f6e2:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
 800f6e6:	e3b4      	b.n	800fe52 <__intscan+0x7a6>
	}
	while (isspace((c=shgetc(f))));
 800f6e8:	bf00      	nop
 800f6ea:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f6ec:	685a      	ldr	r2, [r3, #4]
 800f6ee:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f6f0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f6f2:	429a      	cmp	r2, r3
 800f6f4:	d006      	beq.n	800f704 <__intscan+0x58>
 800f6f6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f6f8:	6859      	ldr	r1, [r3, #4]
 800f6fa:	1c4a      	adds	r2, r1, #1
 800f6fc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f6fe:	605a      	str	r2, [r3, #4]
 800f700:	780b      	ldrb	r3, [r1, #0]
 800f702:	e003      	b.n	800f70c <__intscan+0x60>
 800f704:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f706:	f000 fbd9 	bl	800febc <__shgetc>
 800f70a:	4603      	mov	r3, r0
 800f70c:	677b      	str	r3, [r7, #116]	; 0x74
 800f70e:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800f710:	f7ff ffb8 	bl	800f684 <__isspace>
 800f714:	4603      	mov	r3, r0
 800f716:	2b00      	cmp	r3, #0
 800f718:	d1e7      	bne.n	800f6ea <__intscan+0x3e>
	if (c=='+' || c=='-') {
 800f71a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f71c:	2b2b      	cmp	r3, #43	; 0x2b
 800f71e:	d002      	beq.n	800f726 <__intscan+0x7a>
 800f720:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f722:	2b2d      	cmp	r3, #45	; 0x2d
 800f724:	d119      	bne.n	800f75a <__intscan+0xae>
		neg = -(c=='-');
 800f726:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f728:	2b2d      	cmp	r3, #45	; 0x2d
 800f72a:	bf0c      	ite	eq
 800f72c:	2301      	moveq	r3, #1
 800f72e:	2300      	movne	r3, #0
 800f730:	b2db      	uxtb	r3, r3
 800f732:	425b      	negs	r3, r3
 800f734:	67bb      	str	r3, [r7, #120]	; 0x78
		c = shgetc(f);
 800f736:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f738:	685a      	ldr	r2, [r3, #4]
 800f73a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f73c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f73e:	429a      	cmp	r2, r3
 800f740:	d006      	beq.n	800f750 <__intscan+0xa4>
 800f742:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f744:	6859      	ldr	r1, [r3, #4]
 800f746:	1c4a      	adds	r2, r1, #1
 800f748:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f74a:	605a      	str	r2, [r3, #4]
 800f74c:	780b      	ldrb	r3, [r1, #0]
 800f74e:	e003      	b.n	800f758 <__intscan+0xac>
 800f750:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f752:	f000 fbb3 	bl	800febc <__shgetc>
 800f756:	4603      	mov	r3, r0
 800f758:	677b      	str	r3, [r7, #116]	; 0x74
	}
	if ((base == 0 || base == 16) && c=='0') {
 800f75a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f75c:	2b00      	cmp	r3, #0
 800f75e:	d002      	beq.n	800f766 <__intscan+0xba>
 800f760:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f762:	2b10      	cmp	r3, #16
 800f764:	d15c      	bne.n	800f820 <__intscan+0x174>
 800f766:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f768:	2b30      	cmp	r3, #48	; 0x30
 800f76a:	d159      	bne.n	800f820 <__intscan+0x174>
		c = shgetc(f);
 800f76c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f76e:	685a      	ldr	r2, [r3, #4]
 800f770:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f772:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f774:	429a      	cmp	r2, r3
 800f776:	d006      	beq.n	800f786 <__intscan+0xda>
 800f778:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f77a:	6859      	ldr	r1, [r3, #4]
 800f77c:	1c4a      	adds	r2, r1, #1
 800f77e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f780:	605a      	str	r2, [r3, #4]
 800f782:	780b      	ldrb	r3, [r1, #0]
 800f784:	e003      	b.n	800f78e <__intscan+0xe2>
 800f786:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f788:	f000 fb98 	bl	800febc <__shgetc>
 800f78c:	4603      	mov	r3, r0
 800f78e:	677b      	str	r3, [r7, #116]	; 0x74
		if ((c|32)=='x') {
 800f790:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f792:	f043 0320 	orr.w	r3, r3, #32
 800f796:	2b78      	cmp	r3, #120	; 0x78
 800f798:	d13c      	bne.n	800f814 <__intscan+0x168>
			c = shgetc(f);
 800f79a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f79c:	685a      	ldr	r2, [r3, #4]
 800f79e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f7a0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f7a2:	429a      	cmp	r2, r3
 800f7a4:	d006      	beq.n	800f7b4 <__intscan+0x108>
 800f7a6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f7a8:	6859      	ldr	r1, [r3, #4]
 800f7aa:	1c4a      	adds	r2, r1, #1
 800f7ac:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f7ae:	605a      	str	r2, [r3, #4]
 800f7b0:	780b      	ldrb	r3, [r1, #0]
 800f7b2:	e003      	b.n	800f7bc <__intscan+0x110>
 800f7b4:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f7b6:	f000 fb81 	bl	800febc <__shgetc>
 800f7ba:	4603      	mov	r3, r0
 800f7bc:	677b      	str	r3, [r7, #116]	; 0x74
			if (val[c]>=16) {
 800f7be:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800f7c0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f7c4:	4413      	add	r3, r2
 800f7c6:	781b      	ldrb	r3, [r3, #0]
 800f7c8:	2b0f      	cmp	r3, #15
 800f7ca:	d920      	bls.n	800f80e <__intscan+0x162>
				shunget(f);
 800f7cc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f7ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800f7d0:	2b00      	cmp	r3, #0
 800f7d2:	db04      	blt.n	800f7de <__intscan+0x132>
 800f7d4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f7d6:	685b      	ldr	r3, [r3, #4]
 800f7d8:	1e5a      	subs	r2, r3, #1
 800f7da:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f7dc:	605a      	str	r2, [r3, #4]
				if (pok) shunget(f);
 800f7de:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800f7e0:	2b00      	cmp	r3, #0
 800f7e2:	d009      	beq.n	800f7f8 <__intscan+0x14c>
 800f7e4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f7e6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800f7e8:	2b00      	cmp	r3, #0
 800f7ea:	db09      	blt.n	800f800 <__intscan+0x154>
 800f7ec:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f7ee:	685b      	ldr	r3, [r3, #4]
 800f7f0:	1e5a      	subs	r2, r3, #1
 800f7f2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f7f4:	605a      	str	r2, [r3, #4]
 800f7f6:	e003      	b.n	800f800 <__intscan+0x154>
				else shlim(f, 0);
 800f7f8:	2100      	movs	r1, #0
 800f7fa:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f7fc:	f000 fb32 	bl	800fe64 <__shlim>
				return 0;
 800f800:	f04f 0300 	mov.w	r3, #0
 800f804:	f04f 0400 	mov.w	r4, #0
 800f808:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
 800f80c:	e321      	b.n	800fe52 <__intscan+0x7a6>
			}
			base = 16;
 800f80e:	2310      	movs	r3, #16
 800f810:	66bb      	str	r3, [r7, #104]	; 0x68
		if ((c|32)=='x') {
 800f812:	e02c      	b.n	800f86e <__intscan+0x1c2>
		} else if (base == 0) {
 800f814:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f816:	2b00      	cmp	r3, #0
 800f818:	d129      	bne.n	800f86e <__intscan+0x1c2>
			base = 8;
 800f81a:	2308      	movs	r3, #8
 800f81c:	66bb      	str	r3, [r7, #104]	; 0x68
		if ((c|32)=='x') {
 800f81e:	e026      	b.n	800f86e <__intscan+0x1c2>
		}
	} else {
		if (base == 0) base = 10;
 800f820:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f822:	2b00      	cmp	r3, #0
 800f824:	d101      	bne.n	800f82a <__intscan+0x17e>
 800f826:	230a      	movs	r3, #10
 800f828:	66bb      	str	r3, [r7, #104]	; 0x68
		if (val[c] >= base) {
 800f82a:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800f82c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800f830:	4413      	add	r3, r2
 800f832:	781b      	ldrb	r3, [r3, #0]
 800f834:	461a      	mov	r2, r3
 800f836:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f838:	4293      	cmp	r3, r2
 800f83a:	d819      	bhi.n	800f870 <__intscan+0x1c4>
			shunget(f);
 800f83c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f83e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800f840:	2b00      	cmp	r3, #0
 800f842:	db04      	blt.n	800f84e <__intscan+0x1a2>
 800f844:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f846:	685b      	ldr	r3, [r3, #4]
 800f848:	1e5a      	subs	r2, r3, #1
 800f84a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f84c:	605a      	str	r2, [r3, #4]
			shlim(f, 0);
 800f84e:	2100      	movs	r1, #0
 800f850:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f852:	f000 fb07 	bl	800fe64 <__shlim>
			errno = EINVAL;
 800f856:	f000 fb9f 	bl	800ff98 <__errno_location>
 800f85a:	4603      	mov	r3, r0
 800f85c:	2216      	movs	r2, #22
 800f85e:	601a      	str	r2, [r3, #0]
			return 0;
 800f860:	f04f 0300 	mov.w	r3, #0
 800f864:	f04f 0400 	mov.w	r4, #0
 800f868:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
 800f86c:	e2f1      	b.n	800fe52 <__intscan+0x7a6>
		if ((c|32)=='x') {
 800f86e:	bf00      	nop
		}
	}
	if (base == 10) {
 800f870:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f872:	2b0a      	cmp	r3, #10
 800f874:	f040 80a6 	bne.w	800f9c4 <__intscan+0x318>
		for (x=0; c-'0'<10U && x<=UINT_MAX/10-1; c=shgetc(f))
 800f878:	2300      	movs	r3, #0
 800f87a:	67fb      	str	r3, [r7, #124]	; 0x7c
 800f87c:	e01b      	b.n	800f8b6 <__intscan+0x20a>
			x = x*10 + (c-'0');
 800f87e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800f880:	4613      	mov	r3, r2
 800f882:	009b      	lsls	r3, r3, #2
 800f884:	4413      	add	r3, r2
 800f886:	005b      	lsls	r3, r3, #1
 800f888:	461a      	mov	r2, r3
 800f88a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f88c:	4413      	add	r3, r2
 800f88e:	3b30      	subs	r3, #48	; 0x30
 800f890:	67fb      	str	r3, [r7, #124]	; 0x7c
		for (x=0; c-'0'<10U && x<=UINT_MAX/10-1; c=shgetc(f))
 800f892:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f894:	685a      	ldr	r2, [r3, #4]
 800f896:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f898:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f89a:	429a      	cmp	r2, r3
 800f89c:	d006      	beq.n	800f8ac <__intscan+0x200>
 800f89e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f8a0:	6859      	ldr	r1, [r3, #4]
 800f8a2:	1c4a      	adds	r2, r1, #1
 800f8a4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f8a6:	605a      	str	r2, [r3, #4]
 800f8a8:	780b      	ldrb	r3, [r1, #0]
 800f8aa:	e003      	b.n	800f8b4 <__intscan+0x208>
 800f8ac:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f8ae:	f000 fb05 	bl	800febc <__shgetc>
 800f8b2:	4603      	mov	r3, r0
 800f8b4:	677b      	str	r3, [r7, #116]	; 0x74
 800f8b6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f8b8:	3b30      	subs	r3, #48	; 0x30
 800f8ba:	2b09      	cmp	r3, #9
 800f8bc:	d803      	bhi.n	800f8c6 <__intscan+0x21a>
 800f8be:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800f8c0:	4b1f      	ldr	r3, [pc, #124]	; (800f940 <__intscan+0x294>)
 800f8c2:	429a      	cmp	r2, r3
 800f8c4:	d3db      	bcc.n	800f87e <__intscan+0x1d2>
		for (y=x; c-'0'<10U && y<=ULLONG_MAX/10 && 10*y<=ULLONG_MAX-(c-'0'); c=shgetc(f))
 800f8c6:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800f8c8:	461a      	mov	r2, r3
 800f8ca:	f04f 0300 	mov.w	r3, #0
 800f8ce:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88
 800f8d2:	e03c      	b.n	800f94e <__intscan+0x2a2>
			y = y*10 + (c-'0');
 800f8d4:	e9d7 4522 	ldrd	r4, r5, [r7, #136]	; 0x88
 800f8d8:	4622      	mov	r2, r4
 800f8da:	462b      	mov	r3, r5
 800f8dc:	f04f 0000 	mov.w	r0, #0
 800f8e0:	f04f 0100 	mov.w	r1, #0
 800f8e4:	0099      	lsls	r1, r3, #2
 800f8e6:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 800f8ea:	0090      	lsls	r0, r2, #2
 800f8ec:	4602      	mov	r2, r0
 800f8ee:	460b      	mov	r3, r1
 800f8f0:	1912      	adds	r2, r2, r4
 800f8f2:	eb45 0303 	adc.w	r3, r5, r3
 800f8f6:	1891      	adds	r1, r2, r2
 800f8f8:	6239      	str	r1, [r7, #32]
 800f8fa:	415b      	adcs	r3, r3
 800f8fc:	627b      	str	r3, [r7, #36]	; 0x24
 800f8fe:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800f902:	4610      	mov	r0, r2
 800f904:	4619      	mov	r1, r3
 800f906:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f908:	3b30      	subs	r3, #48	; 0x30
 800f90a:	461a      	mov	r2, r3
 800f90c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 800f910:	1884      	adds	r4, r0, r2
 800f912:	61bc      	str	r4, [r7, #24]
 800f914:	eb41 0303 	adc.w	r3, r1, r3
 800f918:	61fb      	str	r3, [r7, #28]
 800f91a:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 800f91e:	e9c7 3422 	strd	r3, r4, [r7, #136]	; 0x88
		for (y=x; c-'0'<10U && y<=ULLONG_MAX/10 && 10*y<=ULLONG_MAX-(c-'0'); c=shgetc(f))
 800f922:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f924:	685a      	ldr	r2, [r3, #4]
 800f926:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f928:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f92a:	429a      	cmp	r2, r3
 800f92c:	d00a      	beq.n	800f944 <__intscan+0x298>
 800f92e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f930:	6859      	ldr	r1, [r3, #4]
 800f932:	1c4a      	adds	r2, r1, #1
 800f934:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800f936:	605a      	str	r2, [r3, #4]
 800f938:	780b      	ldrb	r3, [r1, #0]
 800f93a:	e007      	b.n	800f94c <__intscan+0x2a0>
 800f93c:	080233a9 	.word	0x080233a9
 800f940:	19999999 	.word	0x19999999
 800f944:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800f946:	f000 fab9 	bl	800febc <__shgetc>
 800f94a:	4603      	mov	r3, r0
 800f94c:	677b      	str	r3, [r7, #116]	; 0x74
 800f94e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f950:	3b30      	subs	r3, #48	; 0x30
 800f952:	2b09      	cmp	r3, #9
 800f954:	d830      	bhi.n	800f9b8 <__intscan+0x30c>
 800f956:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	; 0x88
 800f95a:	f04f 3299 	mov.w	r2, #2576980377	; 0x99999999
 800f95e:	4bb5      	ldr	r3, [pc, #724]	; (800fc34 <__intscan+0x588>)
 800f960:	428b      	cmp	r3, r1
 800f962:	bf08      	it	eq
 800f964:	4282      	cmpeq	r2, r0
 800f966:	d327      	bcc.n	800f9b8 <__intscan+0x30c>
 800f968:	e9d7 4522 	ldrd	r4, r5, [r7, #136]	; 0x88
 800f96c:	4622      	mov	r2, r4
 800f96e:	462b      	mov	r3, r5
 800f970:	f04f 0000 	mov.w	r0, #0
 800f974:	f04f 0100 	mov.w	r1, #0
 800f978:	0099      	lsls	r1, r3, #2
 800f97a:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 800f97e:	0090      	lsls	r0, r2, #2
 800f980:	4602      	mov	r2, r0
 800f982:	460b      	mov	r3, r1
 800f984:	1912      	adds	r2, r2, r4
 800f986:	eb45 0303 	adc.w	r3, r5, r3
 800f98a:	1891      	adds	r1, r2, r2
 800f98c:	6139      	str	r1, [r7, #16]
 800f98e:	415b      	adcs	r3, r3
 800f990:	617b      	str	r3, [r7, #20]
 800f992:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800f996:	4610      	mov	r0, r2
 800f998:	4619      	mov	r1, r3
 800f99a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f99c:	3b30      	subs	r3, #48	; 0x30
 800f99e:	461a      	mov	r2, r3
 800f9a0:	ea4f 73e2 	mov.w	r3, r2, asr #31
 800f9a4:	43d4      	mvns	r4, r2
 800f9a6:	64bc      	str	r4, [r7, #72]	; 0x48
 800f9a8:	43db      	mvns	r3, r3
 800f9aa:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f9ac:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
 800f9b0:	428c      	cmp	r4, r1
 800f9b2:	bf08      	it	eq
 800f9b4:	4283      	cmpeq	r3, r0
 800f9b6:	d28d      	bcs.n	800f8d4 <__intscan+0x228>
		if (c-'0'>=10U) goto done;
 800f9b8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f9ba:	3b30      	subs	r3, #48	; 0x30
 800f9bc:	2b09      	cmp	r3, #9
 800f9be:	f240 81ac 	bls.w	800fd1a <__intscan+0x66e>
 800f9c2:	e1eb      	b.n	800fd9c <__intscan+0x6f0>
	} else if (!(base & (base-1))) {
 800f9c4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f9c6:	1e5a      	subs	r2, r3, #1
 800f9c8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f9ca:	4013      	ands	r3, r2
 800f9cc:	2b00      	cmp	r3, #0
 800f9ce:	f040 809d 	bne.w	800fb0c <__intscan+0x460>
		int bs = "\0\1\2\4\7\3\6\5"[(0x17*base)>>5&7];
 800f9d2:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800f9d4:	4613      	mov	r3, r2
 800f9d6:	005b      	lsls	r3, r3, #1
 800f9d8:	4413      	add	r3, r2
 800f9da:	00db      	lsls	r3, r3, #3
 800f9dc:	1a9b      	subs	r3, r3, r2
 800f9de:	095b      	lsrs	r3, r3, #5
 800f9e0:	f003 0207 	and.w	r2, r3, #7
 800f9e4:	4b94      	ldr	r3, [pc, #592]	; (800fc38 <__intscan+0x58c>)
 800f9e6:	5c9b      	ldrb	r3, [r3, r2]
 800f9e8:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
		for (x=0; val[c]<base && x<=UINT_MAX/32; c=shgetc(f))
 800f9ec:	2300      	movs	r3, #0
 800f9ee:	67fb      	str	r3, [r7, #124]	; 0x7c
 800f9f0:	e01d      	b.n	800fa2e <__intscan+0x382>
			x = x<<bs | val[c];
 800f9f2:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800f9f4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800f9f8:	fa02 f103 	lsl.w	r1, r2, r3
 800f9fc:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800f9fe:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800fa02:	4413      	add	r3, r2
 800fa04:	781b      	ldrb	r3, [r3, #0]
 800fa06:	430b      	orrs	r3, r1
 800fa08:	67fb      	str	r3, [r7, #124]	; 0x7c
		for (x=0; val[c]<base && x<=UINT_MAX/32; c=shgetc(f))
 800fa0a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fa0c:	685a      	ldr	r2, [r3, #4]
 800fa0e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fa10:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800fa12:	429a      	cmp	r2, r3
 800fa14:	d006      	beq.n	800fa24 <__intscan+0x378>
 800fa16:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fa18:	6859      	ldr	r1, [r3, #4]
 800fa1a:	1c4a      	adds	r2, r1, #1
 800fa1c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fa1e:	605a      	str	r2, [r3, #4]
 800fa20:	780b      	ldrb	r3, [r1, #0]
 800fa22:	e003      	b.n	800fa2c <__intscan+0x380>
 800fa24:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800fa26:	f000 fa49 	bl	800febc <__shgetc>
 800fa2a:	4603      	mov	r3, r0
 800fa2c:	677b      	str	r3, [r7, #116]	; 0x74
 800fa2e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800fa30:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800fa34:	4413      	add	r3, r2
 800fa36:	781b      	ldrb	r3, [r3, #0]
 800fa38:	461a      	mov	r2, r3
 800fa3a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fa3c:	4293      	cmp	r3, r2
 800fa3e:	d903      	bls.n	800fa48 <__intscan+0x39c>
 800fa40:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800fa42:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800fa46:	d3d4      	bcc.n	800f9f2 <__intscan+0x346>
		for (y=x; val[c]<base && y<=ULLONG_MAX>>bs; c=shgetc(f))
 800fa48:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800fa4a:	461a      	mov	r2, r3
 800fa4c:	f04f 0300 	mov.w	r3, #0
 800fa50:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88
 800fa54:	e033      	b.n	800fabe <__intscan+0x412>
			y = y<<bs | val[c];
 800fa56:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800fa5a:	f8d7 4084 	ldr.w	r4, [r7, #132]	; 0x84
 800fa5e:	f1a4 0120 	sub.w	r1, r4, #32
 800fa62:	f1c4 0020 	rsb	r0, r4, #32
 800fa66:	fa03 f904 	lsl.w	r9, r3, r4
 800fa6a:	fa02 f101 	lsl.w	r1, r2, r1
 800fa6e:	ea49 0901 	orr.w	r9, r9, r1
 800fa72:	fa22 f000 	lsr.w	r0, r2, r0
 800fa76:	ea49 0900 	orr.w	r9, r9, r0
 800fa7a:	fa02 f804 	lsl.w	r8, r2, r4
 800fa7e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800fa80:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800fa84:	4413      	add	r3, r2
 800fa86:	781b      	ldrb	r3, [r3, #0]
 800fa88:	b2da      	uxtb	r2, r3
 800fa8a:	f04f 0300 	mov.w	r3, #0
 800fa8e:	ea48 0502 	orr.w	r5, r8, r2
 800fa92:	ea49 0603 	orr.w	r6, r9, r3
 800fa96:	e9c7 5622 	strd	r5, r6, [r7, #136]	; 0x88
		for (y=x; val[c]<base && y<=ULLONG_MAX>>bs; c=shgetc(f))
 800fa9a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fa9c:	685a      	ldr	r2, [r3, #4]
 800fa9e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800faa0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800faa2:	429a      	cmp	r2, r3
 800faa4:	d006      	beq.n	800fab4 <__intscan+0x408>
 800faa6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800faa8:	6859      	ldr	r1, [r3, #4]
 800faaa:	1c4a      	adds	r2, r1, #1
 800faac:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800faae:	605a      	str	r2, [r3, #4]
 800fab0:	780b      	ldrb	r3, [r1, #0]
 800fab2:	e003      	b.n	800fabc <__intscan+0x410>
 800fab4:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800fab6:	f000 fa01 	bl	800febc <__shgetc>
 800faba:	4603      	mov	r3, r0
 800fabc:	677b      	str	r3, [r7, #116]	; 0x74
 800fabe:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800fac0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800fac4:	4413      	add	r3, r2
 800fac6:	781b      	ldrb	r3, [r3, #0]
 800fac8:	461a      	mov	r2, r3
 800faca:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800facc:	4293      	cmp	r3, r2
 800face:	f240 8124 	bls.w	800fd1a <__intscan+0x66e>
 800fad2:	f04f 32ff 	mov.w	r2, #4294967295
 800fad6:	f04f 33ff 	mov.w	r3, #4294967295
 800fada:	f8d7 4084 	ldr.w	r4, [r7, #132]	; 0x84
 800fade:	f1c4 0120 	rsb	r1, r4, #32
 800fae2:	f1a4 0020 	sub.w	r0, r4, #32
 800fae6:	fa22 fa04 	lsr.w	sl, r2, r4
 800faea:	fa03 f101 	lsl.w	r1, r3, r1
 800faee:	ea4a 0a01 	orr.w	sl, sl, r1
 800faf2:	fa23 f000 	lsr.w	r0, r3, r0
 800faf6:	ea4a 0a00 	orr.w	sl, sl, r0
 800fafa:	fa23 fb04 	lsr.w	fp, r3, r4
 800fafe:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800fb02:	459b      	cmp	fp, r3
 800fb04:	bf08      	it	eq
 800fb06:	4592      	cmpeq	sl, r2
 800fb08:	d2a5      	bcs.n	800fa56 <__intscan+0x3aa>
 800fb0a:	e106      	b.n	800fd1a <__intscan+0x66e>
	} else {
		for (x=0; val[c]<base && x<=UINT_MAX/36-1; c=shgetc(f))
 800fb0c:	2300      	movs	r3, #0
 800fb0e:	67fb      	str	r3, [r7, #124]	; 0x7c
 800fb10:	e01c      	b.n	800fb4c <__intscan+0x4a0>
			x = x*base + val[c];
 800fb12:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800fb14:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fb16:	fb03 f102 	mul.w	r1, r3, r2
 800fb1a:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800fb1c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800fb20:	4413      	add	r3, r2
 800fb22:	781b      	ldrb	r3, [r3, #0]
 800fb24:	440b      	add	r3, r1
 800fb26:	67fb      	str	r3, [r7, #124]	; 0x7c
		for (x=0; val[c]<base && x<=UINT_MAX/36-1; c=shgetc(f))
 800fb28:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fb2a:	685a      	ldr	r2, [r3, #4]
 800fb2c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fb2e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800fb30:	429a      	cmp	r2, r3
 800fb32:	d006      	beq.n	800fb42 <__intscan+0x496>
 800fb34:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fb36:	6859      	ldr	r1, [r3, #4]
 800fb38:	1c4a      	adds	r2, r1, #1
 800fb3a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fb3c:	605a      	str	r2, [r3, #4]
 800fb3e:	780b      	ldrb	r3, [r1, #0]
 800fb40:	e003      	b.n	800fb4a <__intscan+0x49e>
 800fb42:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800fb44:	f000 f9ba 	bl	800febc <__shgetc>
 800fb48:	4603      	mov	r3, r0
 800fb4a:	677b      	str	r3, [r7, #116]	; 0x74
 800fb4c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800fb4e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800fb52:	4413      	add	r3, r2
 800fb54:	781b      	ldrb	r3, [r3, #0]
 800fb56:	461a      	mov	r2, r3
 800fb58:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fb5a:	4293      	cmp	r3, r2
 800fb5c:	d903      	bls.n	800fb66 <__intscan+0x4ba>
 800fb5e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800fb60:	4b36      	ldr	r3, [pc, #216]	; (800fc3c <__intscan+0x590>)
 800fb62:	429a      	cmp	r2, r3
 800fb64:	d9d5      	bls.n	800fb12 <__intscan+0x466>
		for (y=x; val[c]<base && y<=ULLONG_MAX/base && base*y<=ULLONG_MAX-val[c]; c=shgetc(f))
 800fb66:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800fb68:	461a      	mov	r2, r3
 800fb6a:	f04f 0300 	mov.w	r3, #0
 800fb6e:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88
 800fb72:	e035      	b.n	800fbe0 <__intscan+0x534>
			y = y*base + val[c];
 800fb74:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fb76:	461a      	mov	r2, r3
 800fb78:	f04f 0300 	mov.w	r3, #0
 800fb7c:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800fb80:	fb03 f001 	mul.w	r0, r3, r1
 800fb84:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 800fb88:	fb02 f101 	mul.w	r1, r2, r1
 800fb8c:	1844      	adds	r4, r0, r1
 800fb8e:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800fb92:	fba1 0102 	umull	r0, r1, r1, r2
 800fb96:	1863      	adds	r3, r4, r1
 800fb98:	4619      	mov	r1, r3
 800fb9a:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800fb9c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800fba0:	4413      	add	r3, r2
 800fba2:	781b      	ldrb	r3, [r3, #0]
 800fba4:	b2da      	uxtb	r2, r3
 800fba6:	f04f 0300 	mov.w	r3, #0
 800fbaa:	1884      	adds	r4, r0, r2
 800fbac:	60bc      	str	r4, [r7, #8]
 800fbae:	eb41 0303 	adc.w	r3, r1, r3
 800fbb2:	60fb      	str	r3, [r7, #12]
 800fbb4:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800fbb8:	e9c7 3422 	strd	r3, r4, [r7, #136]	; 0x88
		for (y=x; val[c]<base && y<=ULLONG_MAX/base && base*y<=ULLONG_MAX-val[c]; c=shgetc(f))
 800fbbc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fbbe:	685a      	ldr	r2, [r3, #4]
 800fbc0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fbc2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800fbc4:	429a      	cmp	r2, r3
 800fbc6:	d006      	beq.n	800fbd6 <__intscan+0x52a>
 800fbc8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fbca:	6859      	ldr	r1, [r3, #4]
 800fbcc:	1c4a      	adds	r2, r1, #1
 800fbce:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fbd0:	605a      	str	r2, [r3, #4]
 800fbd2:	780b      	ldrb	r3, [r1, #0]
 800fbd4:	e003      	b.n	800fbde <__intscan+0x532>
 800fbd6:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800fbd8:	f000 f970 	bl	800febc <__shgetc>
 800fbdc:	4603      	mov	r3, r0
 800fbde:	677b      	str	r3, [r7, #116]	; 0x74
 800fbe0:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800fbe2:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800fbe6:	4413      	add	r3, r2
 800fbe8:	781b      	ldrb	r3, [r3, #0]
 800fbea:	461a      	mov	r2, r3
 800fbec:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fbee:	4293      	cmp	r3, r2
 800fbf0:	f240 8093 	bls.w	800fd1a <__intscan+0x66e>
 800fbf4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fbf6:	461c      	mov	r4, r3
 800fbf8:	f04f 0500 	mov.w	r5, #0
 800fbfc:	f04f 0a00 	mov.w	sl, #0
 800fc00:	f04f 0b00 	mov.w	fp, #0
 800fc04:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800fc08:	f04f 0000 	mov.w	r0, #0
 800fc0c:	f04f 0100 	mov.w	r1, #0
 800fc10:	0018      	movs	r0, r3
 800fc12:	2100      	movs	r1, #0
 800fc14:	f04f 0200 	mov.w	r2, #0
 800fc18:	f04f 0300 	mov.w	r3, #0
 800fc1c:	002a      	movs	r2, r5
 800fc1e:	2300      	movs	r3, #0
 800fc20:	2800      	cmp	r0, #0
 800fc22:	d10d      	bne.n	800fc40 <__intscan+0x594>
 800fc24:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800fc28:	fba3 2304 	umull	r2, r3, r3, r4
 800fc2c:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50
 800fc30:	e049      	b.n	800fcc6 <__intscan+0x61a>
 800fc32:	bf00      	nop
 800fc34:	19999999 	.word	0x19999999
 800fc38:	08021740 	.word	0x08021740
 800fc3c:	071c71c6 	.word	0x071c71c6
 800fc40:	4601      	mov	r1, r0
 800fc42:	4622      	mov	r2, r4
 800fc44:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800fc48:	fba3 8904 	umull	r8, r9, r3, r4
 800fc4c:	fba2 2301 	umull	r2, r3, r2, r1
 800fc50:	4610      	mov	r0, r2
 800fc52:	4619      	mov	r1, r3
 800fc54:	f04f 0200 	mov.w	r2, #0
 800fc58:	f04f 0300 	mov.w	r3, #0
 800fc5c:	464a      	mov	r2, r9
 800fc5e:	2300      	movs	r3, #0
 800fc60:	1886      	adds	r6, r0, r2
 800fc62:	603e      	str	r6, [r7, #0]
 800fc64:	eb41 0303 	adc.w	r3, r1, r3
 800fc68:	607b      	str	r3, [r7, #4]
 800fc6a:	e9d7 0100 	ldrd	r0, r1, [r7]
 800fc6e:	f04f 0200 	mov.w	r2, #0
 800fc72:	f04f 0300 	mov.w	r3, #0
 800fc76:	000a      	movs	r2, r1
 800fc78:	17cb      	asrs	r3, r1, #31
 800fc7a:	2a00      	cmp	r2, #0
 800fc7c:	d10e      	bne.n	800fc9c <__intscan+0x5f0>
 800fc7e:	f04f 0400 	mov.w	r4, #0
 800fc82:	f04f 0500 	mov.w	r5, #0
 800fc86:	0005      	movs	r5, r0
 800fc88:	2400      	movs	r4, #0
 800fc8a:	4642      	mov	r2, r8
 800fc8c:	f04f 0300 	mov.w	r3, #0
 800fc90:	ea44 0102 	orr.w	r1, r4, r2
 800fc94:	6539      	str	r1, [r7, #80]	; 0x50
 800fc96:	432b      	orrs	r3, r5
 800fc98:	657b      	str	r3, [r7, #84]	; 0x54
 800fc9a:	e014      	b.n	800fcc6 <__intscan+0x61a>
 800fc9c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800fca0:	fb05 f203 	mul.w	r2, r5, r3
 800fca4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800fca8:	fb04 f303 	mul.w	r3, r4, r3
 800fcac:	18d1      	adds	r1, r2, r3
 800fcae:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800fcb2:	fba3 2304 	umull	r2, r3, r3, r4
 800fcb6:	4419      	add	r1, r3
 800fcb8:	460b      	mov	r3, r1
 800fcba:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50
 800fcbe:	f04f 0a01 	mov.w	sl, #1
 800fcc2:	f04f 0b00 	mov.w	fp, #0
 800fcc6:	4652      	mov	r2, sl
 800fcc8:	465b      	mov	r3, fp
 800fcca:	4313      	orrs	r3, r2
 800fccc:	d125      	bne.n	800fd1a <__intscan+0x66e>
 800fcce:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fcd0:	461a      	mov	r2, r3
 800fcd2:	f04f 0300 	mov.w	r3, #0
 800fcd6:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800fcda:	fb03 f001 	mul.w	r0, r3, r1
 800fcde:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 800fce2:	fb02 f101 	mul.w	r1, r2, r1
 800fce6:	4408      	add	r0, r1
 800fce8:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800fcec:	fba1 4502 	umull	r4, r5, r1, r2
 800fcf0:	1943      	adds	r3, r0, r5
 800fcf2:	461d      	mov	r5, r3
 800fcf4:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800fcf6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800fcfa:	4413      	add	r3, r2
 800fcfc:	781b      	ldrb	r3, [r3, #0]
 800fcfe:	b2da      	uxtb	r2, r3
 800fd00:	f04f 0300 	mov.w	r3, #0
 800fd04:	43d1      	mvns	r1, r2
 800fd06:	6439      	str	r1, [r7, #64]	; 0x40
 800fd08:	43db      	mvns	r3, r3
 800fd0a:	647b      	str	r3, [r7, #68]	; 0x44
 800fd0c:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800fd10:	42ab      	cmp	r3, r5
 800fd12:	bf08      	it	eq
 800fd14:	42a2      	cmpeq	r2, r4
 800fd16:	f4bf af2d 	bcs.w	800fb74 <__intscan+0x4c8>
	}
	if (val[c]<base) {
 800fd1a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800fd1c:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800fd20:	4413      	add	r3, r2
 800fd22:	781b      	ldrb	r3, [r3, #0]
 800fd24:	461a      	mov	r2, r3
 800fd26:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fd28:	4293      	cmp	r3, r2
 800fd2a:	d936      	bls.n	800fd9a <__intscan+0x6ee>
		for (; val[c]<base; c=shgetc(f));
 800fd2c:	e011      	b.n	800fd52 <__intscan+0x6a6>
 800fd2e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fd30:	685a      	ldr	r2, [r3, #4]
 800fd32:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fd34:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800fd36:	429a      	cmp	r2, r3
 800fd38:	d006      	beq.n	800fd48 <__intscan+0x69c>
 800fd3a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fd3c:	685b      	ldr	r3, [r3, #4]
 800fd3e:	1c59      	adds	r1, r3, #1
 800fd40:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800fd42:	6051      	str	r1, [r2, #4]
 800fd44:	781b      	ldrb	r3, [r3, #0]
 800fd46:	e003      	b.n	800fd50 <__intscan+0x6a4>
 800fd48:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800fd4a:	f000 f8b7 	bl	800febc <__shgetc>
 800fd4e:	4603      	mov	r3, r0
 800fd50:	677b      	str	r3, [r7, #116]	; 0x74
 800fd52:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800fd54:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800fd58:	4413      	add	r3, r2
 800fd5a:	781b      	ldrb	r3, [r3, #0]
 800fd5c:	461a      	mov	r2, r3
 800fd5e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800fd60:	4293      	cmp	r3, r2
 800fd62:	d8e4      	bhi.n	800fd2e <__intscan+0x682>
		errno = ERANGE;
 800fd64:	f000 f918 	bl	800ff98 <__errno_location>
 800fd68:	4603      	mov	r3, r0
 800fd6a:	2222      	movs	r2, #34	; 0x22
 800fd6c:	601a      	str	r2, [r3, #0]
		y = lim;
 800fd6e:	e9d7 232e 	ldrd	r2, r3, [r7, #184]	; 0xb8
 800fd72:	e9c7 2322 	strd	r2, r3, [r7, #136]	; 0x88
		if (lim&1) neg = 0;
 800fd76:	e9d7 232e 	ldrd	r2, r3, [r7, #184]	; 0xb8
 800fd7a:	f04f 0001 	mov.w	r0, #1
 800fd7e:	f04f 0100 	mov.w	r1, #0
 800fd82:	ea02 0400 	and.w	r4, r2, r0
 800fd86:	63bc      	str	r4, [r7, #56]	; 0x38
 800fd88:	400b      	ands	r3, r1
 800fd8a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800fd8c:	e9d7 340e 	ldrd	r3, r4, [r7, #56]	; 0x38
 800fd90:	4323      	orrs	r3, r4
 800fd92:	d002      	beq.n	800fd9a <__intscan+0x6ee>
 800fd94:	2300      	movs	r3, #0
 800fd96:	67bb      	str	r3, [r7, #120]	; 0x78
 800fd98:	e000      	b.n	800fd9c <__intscan+0x6f0>
	}
done:
 800fd9a:	bf00      	nop
	shunget(f);
 800fd9c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fd9e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800fda0:	2b00      	cmp	r3, #0
 800fda2:	db04      	blt.n	800fdae <__intscan+0x702>
 800fda4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fda6:	685b      	ldr	r3, [r3, #4]
 800fda8:	1e5a      	subs	r2, r3, #1
 800fdaa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800fdac:	605a      	str	r2, [r3, #4]
	if (y>=lim) {
 800fdae:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	; 0x88
 800fdb2:	e9d7 232e 	ldrd	r2, r3, [r7, #184]	; 0xb8
 800fdb6:	4299      	cmp	r1, r3
 800fdb8:	bf08      	it	eq
 800fdba:	4290      	cmpeq	r0, r2
 800fdbc:	d331      	bcc.n	800fe22 <__intscan+0x776>
		if (!(lim&1) && !neg) {
 800fdbe:	e9d7 232e 	ldrd	r2, r3, [r7, #184]	; 0xb8
 800fdc2:	f04f 0001 	mov.w	r0, #1
 800fdc6:	f04f 0100 	mov.w	r1, #0
 800fdca:	ea02 0400 	and.w	r4, r2, r0
 800fdce:	633c      	str	r4, [r7, #48]	; 0x30
 800fdd0:	400b      	ands	r3, r1
 800fdd2:	637b      	str	r3, [r7, #52]	; 0x34
 800fdd4:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
 800fdd8:	4323      	orrs	r3, r4
 800fdda:	d110      	bne.n	800fdfe <__intscan+0x752>
 800fddc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800fdde:	2b00      	cmp	r3, #0
 800fde0:	d10d      	bne.n	800fdfe <__intscan+0x752>
			errno = ERANGE;
 800fde2:	f000 f8d9 	bl	800ff98 <__errno_location>
 800fde6:	4603      	mov	r3, r0
 800fde8:	2222      	movs	r2, #34	; 0x22
 800fdea:	601a      	str	r2, [r3, #0]
			return lim-1;
 800fdec:	e9d7 232e 	ldrd	r2, r3, [r7, #184]	; 0xb8
 800fdf0:	f112 31ff 	adds.w	r1, r2, #4294967295
 800fdf4:	65b9      	str	r1, [r7, #88]	; 0x58
 800fdf6:	f143 33ff 	adc.w	r3, r3, #4294967295
 800fdfa:	65fb      	str	r3, [r7, #92]	; 0x5c
 800fdfc:	e029      	b.n	800fe52 <__intscan+0x7a6>
		} else if (y>lim) {
 800fdfe:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800fe02:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	; 0xb8
 800fe06:	4299      	cmp	r1, r3
 800fe08:	bf08      	it	eq
 800fe0a:	4290      	cmpeq	r0, r2
 800fe0c:	d209      	bcs.n	800fe22 <__intscan+0x776>
			errno = ERANGE;
 800fe0e:	f000 f8c3 	bl	800ff98 <__errno_location>
 800fe12:	4603      	mov	r3, r0
 800fe14:	2222      	movs	r2, #34	; 0x22
 800fe16:	601a      	str	r2, [r3, #0]
			return lim;
 800fe18:	e9d7 342e 	ldrd	r3, r4, [r7, #184]	; 0xb8
 800fe1c:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
 800fe20:	e017      	b.n	800fe52 <__intscan+0x7a6>
		}
	}
	return (y^neg)-neg;
 800fe22:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800fe24:	4618      	mov	r0, r3
 800fe26:	ea4f 71e0 	mov.w	r1, r0, asr #31
 800fe2a:	e9d7 2322 	ldrd	r2, r3, [r7, #136]	; 0x88
 800fe2e:	ea80 0402 	eor.w	r4, r0, r2
 800fe32:	62bc      	str	r4, [r7, #40]	; 0x28
 800fe34:	404b      	eors	r3, r1
 800fe36:	62fb      	str	r3, [r7, #44]	; 0x2c
 800fe38:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800fe3a:	461a      	mov	r2, r3
 800fe3c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 800fe40:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	; 0x28
 800fe44:	4621      	mov	r1, r4
 800fe46:	1a89      	subs	r1, r1, r2
 800fe48:	65b9      	str	r1, [r7, #88]	; 0x58
 800fe4a:	4629      	mov	r1, r5
 800fe4c:	eb61 0303 	sbc.w	r3, r1, r3
 800fe50:	65fb      	str	r3, [r7, #92]	; 0x5c
 800fe52:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
}
 800fe56:	4610      	mov	r0, r2
 800fe58:	4619      	mov	r1, r3
 800fe5a:	3794      	adds	r7, #148	; 0x94
 800fe5c:	46bd      	mov	sp, r7
 800fe5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fe62:	bf00      	nop

0800fe64 <__shlim>:
 * the value of buf-rpos at the last function call (__shlim or __shgetc),
 * so that between calls the inline shcnt macro can add rpos-buf to get
 * the actual count. */

void __shlim(FILE *f, off_t lim)
{
 800fe64:	b480      	push	{r7}
 800fe66:	b083      	sub	sp, #12
 800fe68:	af00      	add	r7, sp, #0
 800fe6a:	6078      	str	r0, [r7, #4]
 800fe6c:	6039      	str	r1, [r7, #0]
	f->shlim = lim;
 800fe6e:	687b      	ldr	r3, [r7, #4]
 800fe70:	683a      	ldr	r2, [r7, #0]
 800fe72:	66da      	str	r2, [r3, #108]	; 0x6c
	f->shcnt = f->buf - f->rpos;
 800fe74:	687b      	ldr	r3, [r7, #4]
 800fe76:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800fe78:	687b      	ldr	r3, [r7, #4]
 800fe7a:	685b      	ldr	r3, [r3, #4]
 800fe7c:	1ad2      	subs	r2, r2, r3
 800fe7e:	687b      	ldr	r3, [r7, #4]
 800fe80:	671a      	str	r2, [r3, #112]	; 0x70
	/* If lim is nonzero, rend must be a valid pointer. */
	if (lim && f->rend - f->rpos > lim)
 800fe82:	683b      	ldr	r3, [r7, #0]
 800fe84:	2b00      	cmp	r3, #0
 800fe86:	d00e      	beq.n	800fea6 <__shlim+0x42>
 800fe88:	687b      	ldr	r3, [r7, #4]
 800fe8a:	689a      	ldr	r2, [r3, #8]
 800fe8c:	687b      	ldr	r3, [r7, #4]
 800fe8e:	685b      	ldr	r3, [r3, #4]
 800fe90:	1ad3      	subs	r3, r2, r3
 800fe92:	683a      	ldr	r2, [r7, #0]
 800fe94:	429a      	cmp	r2, r3
 800fe96:	da06      	bge.n	800fea6 <__shlim+0x42>
		f->shend = f->rpos + lim;
 800fe98:	687b      	ldr	r3, [r7, #4]
 800fe9a:	685a      	ldr	r2, [r3, #4]
 800fe9c:	683b      	ldr	r3, [r7, #0]
 800fe9e:	441a      	add	r2, r3
 800fea0:	687b      	ldr	r3, [r7, #4]
 800fea2:	669a      	str	r2, [r3, #104]	; 0x68
 800fea4:	e004      	b.n	800feb0 <__shlim+0x4c>
	else
		f->shend = f->rend;
 800fea6:	687b      	ldr	r3, [r7, #4]
 800fea8:	689a      	ldr	r2, [r3, #8]
 800feaa:	687b      	ldr	r3, [r7, #4]
 800feac:	669a      	str	r2, [r3, #104]	; 0x68
}
 800feae:	bf00      	nop
 800feb0:	bf00      	nop
 800feb2:	370c      	adds	r7, #12
 800feb4:	46bd      	mov	sp, r7
 800feb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800feba:	4770      	bx	lr

0800febc <__shgetc>:

int __shgetc(FILE *f)
{
 800febc:	b580      	push	{r7, lr}
 800febe:	b084      	sub	sp, #16
 800fec0:	af00      	add	r7, sp, #0
 800fec2:	6078      	str	r0, [r7, #4]
	int c;
	off_t cnt = shcnt(f);
 800fec4:	687b      	ldr	r3, [r7, #4]
 800fec6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800fec8:	687b      	ldr	r3, [r7, #4]
 800feca:	6859      	ldr	r1, [r3, #4]
 800fecc:	687b      	ldr	r3, [r7, #4]
 800fece:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fed0:	1acb      	subs	r3, r1, r3
 800fed2:	4413      	add	r3, r2
 800fed4:	60bb      	str	r3, [r7, #8]
	if ((f->shlim && cnt >= f->shlim) || (c=__uflow(f)) < 0) {
 800fed6:	687b      	ldr	r3, [r7, #4]
 800fed8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800feda:	2b00      	cmp	r3, #0
 800fedc:	d004      	beq.n	800fee8 <__shgetc+0x2c>
 800fede:	687b      	ldr	r3, [r7, #4]
 800fee0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800fee2:	68ba      	ldr	r2, [r7, #8]
 800fee4:	429a      	cmp	r2, r3
 800fee6:	da06      	bge.n	800fef6 <__shgetc+0x3a>
 800fee8:	6878      	ldr	r0, [r7, #4]
 800feea:	f000 f86b 	bl	800ffc4 <__uflow>
 800feee:	60f8      	str	r0, [r7, #12]
 800fef0:	68fb      	ldr	r3, [r7, #12]
 800fef2:	2b00      	cmp	r3, #0
 800fef4:	da13      	bge.n	800ff1e <__shgetc+0x62>
		f->shcnt = f->buf - f->rpos + cnt;
 800fef6:	687b      	ldr	r3, [r7, #4]
 800fef8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800fefa:	687b      	ldr	r3, [r7, #4]
 800fefc:	685b      	ldr	r3, [r3, #4]
 800fefe:	1ad2      	subs	r2, r2, r3
 800ff00:	68bb      	ldr	r3, [r7, #8]
 800ff02:	441a      	add	r2, r3
 800ff04:	687b      	ldr	r3, [r7, #4]
 800ff06:	671a      	str	r2, [r3, #112]	; 0x70
		f->shend = f->rpos;
 800ff08:	687b      	ldr	r3, [r7, #4]
 800ff0a:	685a      	ldr	r2, [r3, #4]
 800ff0c:	687b      	ldr	r3, [r7, #4]
 800ff0e:	669a      	str	r2, [r3, #104]	; 0x68
		f->shlim = -1;
 800ff10:	687b      	ldr	r3, [r7, #4]
 800ff12:	f04f 32ff 	mov.w	r2, #4294967295
 800ff16:	66da      	str	r2, [r3, #108]	; 0x6c
		return EOF;
 800ff18:	f04f 33ff 	mov.w	r3, #4294967295
 800ff1c:	e037      	b.n	800ff8e <__shgetc+0xd2>
	}
	cnt++;
 800ff1e:	68bb      	ldr	r3, [r7, #8]
 800ff20:	3301      	adds	r3, #1
 800ff22:	60bb      	str	r3, [r7, #8]
	if (f->shlim && f->rend - f->rpos > f->shlim - cnt)
 800ff24:	687b      	ldr	r3, [r7, #4]
 800ff26:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ff28:	2b00      	cmp	r3, #0
 800ff2a:	d014      	beq.n	800ff56 <__shgetc+0x9a>
 800ff2c:	687b      	ldr	r3, [r7, #4]
 800ff2e:	689a      	ldr	r2, [r3, #8]
 800ff30:	687b      	ldr	r3, [r7, #4]
 800ff32:	685b      	ldr	r3, [r3, #4]
 800ff34:	1ad2      	subs	r2, r2, r3
 800ff36:	687b      	ldr	r3, [r7, #4]
 800ff38:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800ff3a:	68bb      	ldr	r3, [r7, #8]
 800ff3c:	1acb      	subs	r3, r1, r3
 800ff3e:	429a      	cmp	r2, r3
 800ff40:	dd09      	ble.n	800ff56 <__shgetc+0x9a>
		f->shend = f->rpos + (f->shlim - cnt);
 800ff42:	687b      	ldr	r3, [r7, #4]
 800ff44:	685b      	ldr	r3, [r3, #4]
 800ff46:	687a      	ldr	r2, [r7, #4]
 800ff48:	6ed1      	ldr	r1, [r2, #108]	; 0x6c
 800ff4a:	68ba      	ldr	r2, [r7, #8]
 800ff4c:	1a8a      	subs	r2, r1, r2
 800ff4e:	441a      	add	r2, r3
 800ff50:	687b      	ldr	r3, [r7, #4]
 800ff52:	669a      	str	r2, [r3, #104]	; 0x68
 800ff54:	e003      	b.n	800ff5e <__shgetc+0xa2>
	else
		f->shend = f->rend;
 800ff56:	687b      	ldr	r3, [r7, #4]
 800ff58:	689a      	ldr	r2, [r3, #8]
 800ff5a:	687b      	ldr	r3, [r7, #4]
 800ff5c:	669a      	str	r2, [r3, #104]	; 0x68
	f->shcnt = f->buf - f->rpos + cnt;
 800ff5e:	687b      	ldr	r3, [r7, #4]
 800ff60:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ff62:	687b      	ldr	r3, [r7, #4]
 800ff64:	685b      	ldr	r3, [r3, #4]
 800ff66:	1ad2      	subs	r2, r2, r3
 800ff68:	68bb      	ldr	r3, [r7, #8]
 800ff6a:	441a      	add	r2, r3
 800ff6c:	687b      	ldr	r3, [r7, #4]
 800ff6e:	671a      	str	r2, [r3, #112]	; 0x70
	if (f->rpos[-1] != c) f->rpos[-1] = c;
 800ff70:	687b      	ldr	r3, [r7, #4]
 800ff72:	685b      	ldr	r3, [r3, #4]
 800ff74:	3b01      	subs	r3, #1
 800ff76:	781b      	ldrb	r3, [r3, #0]
 800ff78:	461a      	mov	r2, r3
 800ff7a:	68fb      	ldr	r3, [r7, #12]
 800ff7c:	4293      	cmp	r3, r2
 800ff7e:	d005      	beq.n	800ff8c <__shgetc+0xd0>
 800ff80:	687b      	ldr	r3, [r7, #4]
 800ff82:	685b      	ldr	r3, [r3, #4]
 800ff84:	3b01      	subs	r3, #1
 800ff86:	68fa      	ldr	r2, [r7, #12]
 800ff88:	b2d2      	uxtb	r2, r2
 800ff8a:	701a      	strb	r2, [r3, #0]
	return c;
 800ff8c:	68fb      	ldr	r3, [r7, #12]
}
 800ff8e:	4618      	mov	r0, r3
 800ff90:	3710      	adds	r7, #16
 800ff92:	46bd      	mov	sp, r7
 800ff94:	bd80      	pop	{r7, pc}
	...

0800ff98 <__errno_location>:
        return g_errnoIsr;
    }
}

int *__errno_location(void)
{
 800ff98:	b580      	push	{r7, lr}
 800ff9a:	af00      	add	r7, sp, #0
    if (OS_INT_INACTIVE) {
 800ff9c:	f7f2 fb60 	bl	8002660 <IntActive>
 800ffa0:	4603      	mov	r3, r0
 800ffa2:	2b00      	cmp	r3, #0
 800ffa4:	d106      	bne.n	800ffb4 <__errno_location+0x1c>
        return &g_errnoArray[LOS_CurTaskIDGet()];
 800ffa6:	f7f3 f927 	bl	80031f8 <LOS_CurTaskIDGet>
 800ffaa:	4603      	mov	r3, r0
 800ffac:	009b      	lsls	r3, r3, #2
 800ffae:	4a03      	ldr	r2, [pc, #12]	; (800ffbc <__errno_location+0x24>)
 800ffb0:	4413      	add	r3, r2
 800ffb2:	e000      	b.n	800ffb6 <__errno_location+0x1e>
    } else {
        return &g_errnoIsr;
 800ffb4:	4b02      	ldr	r3, [pc, #8]	; (800ffc0 <__errno_location+0x28>)
    }
}
 800ffb6:	4618      	mov	r0, r3
 800ffb8:	bd80      	pop	{r7, pc}
 800ffba:	bf00      	nop
 800ffbc:	20003720 	.word	0x20003720
 800ffc0:	20002280 	.word	0x20002280

0800ffc4 <__uflow>:

/* This function assumes it will never be called if there is already
 * data buffered for reading. */

int __uflow(FILE *f)
{
 800ffc4:	b580      	push	{r7, lr}
 800ffc6:	b084      	sub	sp, #16
 800ffc8:	af00      	add	r7, sp, #0
 800ffca:	6078      	str	r0, [r7, #4]
 800ffcc:	4b11      	ldr	r3, [pc, #68]	; (8010014 <__uflow+0x50>)
 800ffce:	681b      	ldr	r3, [r3, #0]
 800ffd0:	60fb      	str	r3, [r7, #12]
 800ffd2:	f04f 0300 	mov.w	r3, #0
	unsigned char c;
	if (!__toread(f) && f->read(f, &c, 1)==1) return c;
 800ffd6:	6878      	ldr	r0, [r7, #4]
 800ffd8:	f000 f81e 	bl	8010018 <__toread>
 800ffdc:	4603      	mov	r3, r0
 800ffde:	2b00      	cmp	r3, #0
 800ffe0:	d10b      	bne.n	800fffa <__uflow+0x36>
 800ffe2:	687b      	ldr	r3, [r7, #4]
 800ffe4:	6a1b      	ldr	r3, [r3, #32]
 800ffe6:	f107 010b 	add.w	r1, r7, #11
 800ffea:	2201      	movs	r2, #1
 800ffec:	6878      	ldr	r0, [r7, #4]
 800ffee:	4798      	blx	r3
 800fff0:	4603      	mov	r3, r0
 800fff2:	2b01      	cmp	r3, #1
 800fff4:	d101      	bne.n	800fffa <__uflow+0x36>
 800fff6:	7afb      	ldrb	r3, [r7, #11]
 800fff8:	e001      	b.n	800fffe <__uflow+0x3a>
	return EOF;
 800fffa:	f04f 33ff 	mov.w	r3, #4294967295
}
 800fffe:	4a05      	ldr	r2, [pc, #20]	; (8010014 <__uflow+0x50>)
 8010000:	6811      	ldr	r1, [r2, #0]
 8010002:	68fa      	ldr	r2, [r7, #12]
 8010004:	4051      	eors	r1, r2
 8010006:	d001      	beq.n	801000c <__uflow+0x48>
 8010008:	f7f4 fae8 	bl	80045dc <__stack_chk_fail>
 801000c:	4618      	mov	r0, r3
 801000e:	3710      	adds	r7, #16
 8010010:	46bd      	mov	sp, r7
 8010012:	bd80      	pop	{r7, pc}
 8010014:	0802174c 	.word	0x0802174c

08010018 <__toread>:
#include <stdio_impl.h>

int __toread(FILE *f)
{
 8010018:	b580      	push	{r7, lr}
 801001a:	b082      	sub	sp, #8
 801001c:	af00      	add	r7, sp, #0
 801001e:	6078      	str	r0, [r7, #4]
	f->mode |= f->mode-1;
 8010020:	687b      	ldr	r3, [r7, #4]
 8010022:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8010024:	687b      	ldr	r3, [r7, #4]
 8010026:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010028:	3b01      	subs	r3, #1
 801002a:	431a      	orrs	r2, r3
 801002c:	687b      	ldr	r3, [r7, #4]
 801002e:	64da      	str	r2, [r3, #76]	; 0x4c
	if (f->wpos != f->wbase) f->write(f, 0, 0);
 8010030:	687b      	ldr	r3, [r7, #4]
 8010032:	695a      	ldr	r2, [r3, #20]
 8010034:	687b      	ldr	r3, [r7, #4]
 8010036:	69db      	ldr	r3, [r3, #28]
 8010038:	429a      	cmp	r2, r3
 801003a:	d005      	beq.n	8010048 <__toread+0x30>
 801003c:	687b      	ldr	r3, [r7, #4]
 801003e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010040:	2200      	movs	r2, #0
 8010042:	2100      	movs	r1, #0
 8010044:	6878      	ldr	r0, [r7, #4]
 8010046:	4798      	blx	r3
	f->wpos = f->wbase = f->wend = 0;
 8010048:	687b      	ldr	r3, [r7, #4]
 801004a:	2200      	movs	r2, #0
 801004c:	611a      	str	r2, [r3, #16]
 801004e:	687b      	ldr	r3, [r7, #4]
 8010050:	691a      	ldr	r2, [r3, #16]
 8010052:	687b      	ldr	r3, [r7, #4]
 8010054:	61da      	str	r2, [r3, #28]
 8010056:	687b      	ldr	r3, [r7, #4]
 8010058:	69da      	ldr	r2, [r3, #28]
 801005a:	687b      	ldr	r3, [r7, #4]
 801005c:	615a      	str	r2, [r3, #20]
	if (f->flags & F_NORD) {
 801005e:	687b      	ldr	r3, [r7, #4]
 8010060:	681b      	ldr	r3, [r3, #0]
 8010062:	f003 0304 	and.w	r3, r3, #4
 8010066:	2b00      	cmp	r3, #0
 8010068:	d008      	beq.n	801007c <__toread+0x64>
		f->flags |= F_ERR;
 801006a:	687b      	ldr	r3, [r7, #4]
 801006c:	681b      	ldr	r3, [r3, #0]
 801006e:	f043 0220 	orr.w	r2, r3, #32
 8010072:	687b      	ldr	r3, [r7, #4]
 8010074:	601a      	str	r2, [r3, #0]
		return EOF;
 8010076:	f04f 33ff 	mov.w	r3, #4294967295
 801007a:	e01d      	b.n	80100b8 <__toread+0xa0>
	}
#ifdef __LITEOS__
	if (f->flags & F_CLS) {
 801007c:	687b      	ldr	r3, [r7, #4]
 801007e:	681b      	ldr	r3, [r3, #0]
 8010080:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8010084:	2b00      	cmp	r3, #0
 8010086:	d002      	beq.n	801008e <__toread+0x76>
		return EOF;
 8010088:	f04f 33ff 	mov.w	r3, #4294967295
 801008c:	e014      	b.n	80100b8 <__toread+0xa0>
	}
#endif
	f->rpos = f->rend = f->buf + f->buf_size;
 801008e:	687b      	ldr	r3, [r7, #4]
 8010090:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8010092:	687b      	ldr	r3, [r7, #4]
 8010094:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8010096:	441a      	add	r2, r3
 8010098:	687b      	ldr	r3, [r7, #4]
 801009a:	609a      	str	r2, [r3, #8]
 801009c:	687b      	ldr	r3, [r7, #4]
 801009e:	689a      	ldr	r2, [r3, #8]
 80100a0:	687b      	ldr	r3, [r7, #4]
 80100a2:	605a      	str	r2, [r3, #4]
	return (f->flags & F_EOF) ? EOF : 0;
 80100a4:	687b      	ldr	r3, [r7, #4]
 80100a6:	681b      	ldr	r3, [r3, #0]
 80100a8:	f003 0310 	and.w	r3, r3, #16
 80100ac:	2b00      	cmp	r3, #0
 80100ae:	d002      	beq.n	80100b6 <__toread+0x9e>
 80100b0:	f04f 33ff 	mov.w	r3, #4294967295
 80100b4:	e000      	b.n	80100b8 <__toread+0xa0>
 80100b6:	2300      	movs	r3, #0
}
 80100b8:	4618      	mov	r0, r3
 80100ba:	3708      	adds	r7, #8
 80100bc:	46bd      	mov	sp, r7
 80100be:	bd80      	pop	{r7, pc}

080100c0 <printf>:
#include <stdio.h>
#include <stdarg.h>
#include "los_printf_pri.h"

int printf(const char *restrict fmt, ...)
{
 80100c0:	b40f      	push	{r0, r1, r2, r3}
 80100c2:	b580      	push	{r7, lr}
 80100c4:	b086      	sub	sp, #24
 80100c6:	af00      	add	r7, sp, #0
 80100c8:	6a3b      	ldr	r3, [r7, #32]
 80100ca:	607b      	str	r3, [r7, #4]
 80100cc:	4b0e      	ldr	r3, [pc, #56]	; (8010108 <printf+0x48>)
 80100ce:	681b      	ldr	r3, [r3, #0]
 80100d0:	617b      	str	r3, [r7, #20]
 80100d2:	f04f 0300 	mov.w	r3, #0
	int ret = 0;
 80100d6:	2300      	movs	r3, #0
 80100d8:	613b      	str	r3, [r7, #16]
	va_list ap;
	va_start(ap, fmt);
 80100da:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80100de:	60fb      	str	r3, [r7, #12]
#if defined(LOSCFG_FS_VFS)
	ret = vfprintf(stdout, fmt, ap);
#elif defined(LOSCFG_DRIVERS_UART) || defined(LOSCFG_DRIVERS_SIMPLE_UART)
	UartVprintf(fmt, ap);
 80100e0:	68f9      	ldr	r1, [r7, #12]
 80100e2:	6878      	ldr	r0, [r7, #4]
 80100e4:	f7f4 fbde 	bl	80048a4 <UartVprintf>
#else
	ret = -1;
#endif
	va_end(ap);
	return ret;
 80100e8:	693b      	ldr	r3, [r7, #16]
}
 80100ea:	4a07      	ldr	r2, [pc, #28]	; (8010108 <printf+0x48>)
 80100ec:	6811      	ldr	r1, [r2, #0]
 80100ee:	697a      	ldr	r2, [r7, #20]
 80100f0:	4051      	eors	r1, r2
 80100f2:	d001      	beq.n	80100f8 <printf+0x38>
 80100f4:	f7f4 fa72 	bl	80045dc <__stack_chk_fail>
 80100f8:	4618      	mov	r0, r3
 80100fa:	3718      	adds	r7, #24
 80100fc:	46bd      	mov	sp, r7
 80100fe:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8010102:	b004      	add	sp, #16
 8010104:	4770      	bx	lr
 8010106:	bf00      	nop
 8010108:	08021750 	.word	0x08021750

0801010c <__NVIC_SetPriorityGrouping>:
{
 801010c:	b480      	push	{r7}
 801010e:	b085      	sub	sp, #20
 8010110:	af00      	add	r7, sp, #0
 8010112:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8010114:	687b      	ldr	r3, [r7, #4]
 8010116:	f003 0307 	and.w	r3, r3, #7
 801011a:	60bb      	str	r3, [r7, #8]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 801011c:	4b0b      	ldr	r3, [pc, #44]	; (801014c <__NVIC_SetPriorityGrouping+0x40>)
 801011e:	68db      	ldr	r3, [r3, #12]
 8010120:	60fb      	str	r3, [r7, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8010122:	68fa      	ldr	r2, [r7, #12]
 8010124:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8010128:	4013      	ands	r3, r2
 801012a:	60fb      	str	r3, [r7, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 801012c:	68bb      	ldr	r3, [r7, #8]
 801012e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8010130:	68fb      	ldr	r3, [r7, #12]
 8010132:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
 8010134:	4b06      	ldr	r3, [pc, #24]	; (8010150 <__NVIC_SetPriorityGrouping+0x44>)
 8010136:	4313      	orrs	r3, r2
 8010138:	60fb      	str	r3, [r7, #12]
  SCB->AIRCR =  reg_value;
 801013a:	4a04      	ldr	r2, [pc, #16]	; (801014c <__NVIC_SetPriorityGrouping+0x40>)
 801013c:	68fb      	ldr	r3, [r7, #12]
 801013e:	60d3      	str	r3, [r2, #12]
}
 8010140:	bf00      	nop
 8010142:	3714      	adds	r7, #20
 8010144:	46bd      	mov	sp, r7
 8010146:	f85d 7b04 	ldr.w	r7, [sp], #4
 801014a:	4770      	bx	lr
 801014c:	e000ed00 	.word	0xe000ed00
 8010150:	05fa0000 	.word	0x05fa0000

08010154 <__NVIC_EnableIRQ>:
{
 8010154:	b480      	push	{r7}
 8010156:	b083      	sub	sp, #12
 8010158:	af00      	add	r7, sp, #0
 801015a:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 801015c:	687b      	ldr	r3, [r7, #4]
 801015e:	2b00      	cmp	r3, #0
 8010160:	db0a      	blt.n	8010178 <__NVIC_EnableIRQ+0x24>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8010162:	687b      	ldr	r3, [r7, #4]
 8010164:	f003 021f 	and.w	r2, r3, #31
 8010168:	4906      	ldr	r1, [pc, #24]	; (8010184 <__NVIC_EnableIRQ+0x30>)
 801016a:	687b      	ldr	r3, [r7, #4]
 801016c:	095b      	lsrs	r3, r3, #5
 801016e:	2001      	movs	r0, #1
 8010170:	fa00 f202 	lsl.w	r2, r0, r2
 8010174:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8010178:	bf00      	nop
 801017a:	370c      	adds	r7, #12
 801017c:	46bd      	mov	sp, r7
 801017e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010182:	4770      	bx	lr
 8010184:	e000e100 	.word	0xe000e100

08010188 <__NVIC_DisableIRQ>:
{
 8010188:	b480      	push	{r7}
 801018a:	b083      	sub	sp, #12
 801018c:	af00      	add	r7, sp, #0
 801018e:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 8010190:	687b      	ldr	r3, [r7, #4]
 8010192:	2b00      	cmp	r3, #0
 8010194:	db11      	blt.n	80101ba <__NVIC_DisableIRQ+0x32>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8010196:	687b      	ldr	r3, [r7, #4]
 8010198:	f003 021f 	and.w	r2, r3, #31
 801019c:	490a      	ldr	r1, [pc, #40]	; (80101c8 <__NVIC_DisableIRQ+0x40>)
 801019e:	687b      	ldr	r3, [r7, #4]
 80101a0:	095b      	lsrs	r3, r3, #5
 80101a2:	2001      	movs	r0, #1
 80101a4:	fa00 f202 	lsl.w	r2, r0, r2
 80101a8:	3320      	adds	r3, #32
 80101aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 80101ae:	f3bf 8f4f 	dsb	sy
}
 80101b2:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 80101b4:	f3bf 8f6f 	isb	sy
}
 80101b8:	bf00      	nop
}
 80101ba:	bf00      	nop
 80101bc:	370c      	adds	r7, #12
 80101be:	46bd      	mov	sp, r7
 80101c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80101c4:	4770      	bx	lr
 80101c6:	bf00      	nop
 80101c8:	e000e100 	.word	0xe000e100

080101cc <__NVIC_SetPendingIRQ>:
{
 80101cc:	b480      	push	{r7}
 80101ce:	b083      	sub	sp, #12
 80101d0:	af00      	add	r7, sp, #0
 80101d2:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 80101d4:	687b      	ldr	r3, [r7, #4]
 80101d6:	2b00      	cmp	r3, #0
 80101d8:	db0b      	blt.n	80101f2 <__NVIC_SetPendingIRQ+0x26>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80101da:	687b      	ldr	r3, [r7, #4]
 80101dc:	f003 021f 	and.w	r2, r3, #31
 80101e0:	4907      	ldr	r1, [pc, #28]	; (8010200 <__NVIC_SetPendingIRQ+0x34>)
 80101e2:	687b      	ldr	r3, [r7, #4]
 80101e4:	095b      	lsrs	r3, r3, #5
 80101e6:	2001      	movs	r0, #1
 80101e8:	fa00 f202 	lsl.w	r2, r0, r2
 80101ec:	3340      	adds	r3, #64	; 0x40
 80101ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80101f2:	bf00      	nop
 80101f4:	370c      	adds	r7, #12
 80101f6:	46bd      	mov	sp, r7
 80101f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80101fc:	4770      	bx	lr
 80101fe:	bf00      	nop
 8010200:	e000e100 	.word	0xe000e100

08010204 <__NVIC_ClearPendingIRQ>:
{
 8010204:	b480      	push	{r7}
 8010206:	b083      	sub	sp, #12
 8010208:	af00      	add	r7, sp, #0
 801020a:	6078      	str	r0, [r7, #4]
  if ((int32_t)(IRQn) >= 0)
 801020c:	687b      	ldr	r3, [r7, #4]
 801020e:	2b00      	cmp	r3, #0
 8010210:	db0b      	blt.n	801022a <__NVIC_ClearPendingIRQ+0x26>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8010212:	687b      	ldr	r3, [r7, #4]
 8010214:	f003 021f 	and.w	r2, r3, #31
 8010218:	4907      	ldr	r1, [pc, #28]	; (8010238 <__NVIC_ClearPendingIRQ+0x34>)
 801021a:	687b      	ldr	r3, [r7, #4]
 801021c:	095b      	lsrs	r3, r3, #5
 801021e:	2001      	movs	r0, #1
 8010220:	fa00 f202 	lsl.w	r2, r0, r2
 8010224:	3360      	adds	r3, #96	; 0x60
 8010226:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 801022a:	bf00      	nop
 801022c:	370c      	adds	r7, #12
 801022e:	46bd      	mov	sp, r7
 8010230:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010234:	4770      	bx	lr
 8010236:	bf00      	nop
 8010238:	e000e100 	.word	0xe000e100

0801023c <__NVIC_SetPriority>:
{
 801023c:	b480      	push	{r7}
 801023e:	b083      	sub	sp, #12
 8010240:	af00      	add	r7, sp, #0
 8010242:	6078      	str	r0, [r7, #4]
 8010244:	6039      	str	r1, [r7, #0]
  if ((int32_t)(IRQn) >= 0)
 8010246:	687b      	ldr	r3, [r7, #4]
 8010248:	2b00      	cmp	r3, #0
 801024a:	db09      	blt.n	8010260 <__NVIC_SetPriority+0x24>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 801024c:	683b      	ldr	r3, [r7, #0]
 801024e:	b2da      	uxtb	r2, r3
 8010250:	490c      	ldr	r1, [pc, #48]	; (8010284 <__NVIC_SetPriority+0x48>)
 8010252:	687b      	ldr	r3, [r7, #4]
 8010254:	0112      	lsls	r2, r2, #4
 8010256:	b2d2      	uxtb	r2, r2
 8010258:	440b      	add	r3, r1
 801025a:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 801025e:	e00a      	b.n	8010276 <__NVIC_SetPriority+0x3a>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8010260:	683b      	ldr	r3, [r7, #0]
 8010262:	b2da      	uxtb	r2, r3
 8010264:	4908      	ldr	r1, [pc, #32]	; (8010288 <__NVIC_SetPriority+0x4c>)
 8010266:	687b      	ldr	r3, [r7, #4]
 8010268:	f003 030f 	and.w	r3, r3, #15
 801026c:	3b04      	subs	r3, #4
 801026e:	0112      	lsls	r2, r2, #4
 8010270:	b2d2      	uxtb	r2, r2
 8010272:	440b      	add	r3, r1
 8010274:	761a      	strb	r2, [r3, #24]
}
 8010276:	bf00      	nop
 8010278:	370c      	adds	r7, #12
 801027a:	46bd      	mov	sp, r7
 801027c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010280:	4770      	bx	lr
 8010282:	bf00      	nop
 8010284:	e000e100 	.word	0xe000e100
 8010288:	e000ed00 	.word	0xe000ed00

0801028c <LOS_IntLock>:
{
 801028c:	b580      	push	{r7, lr}
 801028e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8010290:	f7f0 fd1a 	bl	8000cc8 <ArchIntLock>
 8010294:	4603      	mov	r3, r0
}
 8010296:	4618      	mov	r0, r3
 8010298:	bd80      	pop	{r7, pc}

0801029a <LOS_IntRestore>:
{
 801029a:	b580      	push	{r7, lr}
 801029c:	b082      	sub	sp, #8
 801029e:	af00      	add	r7, sp, #0
 80102a0:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80102a2:	6878      	ldr	r0, [r7, #4]
 80102a4:	f7f0 fd18 	bl	8000cd8 <ArchIntRestore>
}
 80102a8:	bf00      	nop
 80102aa:	3708      	adds	r7, #8
 80102ac:	46bd      	mov	sp, r7
 80102ae:	bd80      	pop	{r7, pc}

080102b0 <OsHwiControllerReg>:
 * registered;Because the function pointer is not judged in the abstraction layer, all function members defined in
 * HwiControllerOps need to be registered. If this function is not supported, you can call the LOS_Panic interface in
 * the implementation of the stub function to report an error in time.
 */
STATIC INLINE VOID OsHwiControllerReg(const HwiControllerOps *ops)
{
 80102b0:	b480      	push	{r7}
 80102b2:	b083      	sub	sp, #12
 80102b4:	af00      	add	r7, sp, #0
 80102b6:	6078      	str	r0, [r7, #4]
    g_hwiOps = ops;
 80102b8:	4a04      	ldr	r2, [pc, #16]	; (80102cc <OsHwiControllerReg+0x1c>)
 80102ba:	687b      	ldr	r3, [r7, #4]
 80102bc:	6013      	str	r3, [r2, #0]
}
 80102be:	bf00      	nop
 80102c0:	370c      	adds	r7, #12
 80102c2:	46bd      	mov	sp, r7
 80102c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80102c8:	4770      	bx	lr
 80102ca:	bf00      	nop
 80102cc:	20000764 	.word	0x20000764

080102d0 <IrqEntryV7M>:
    (HWI_PROC_FUNC)osPendSV,      /* [14] PendSV Handler */
    (HWI_PROC_FUNC)IrqEntryV7M,   /* [15] SysTick Handler */
};
#endif
LITE_OS_SEC_TEXT_MINOR VOID IrqEntryV7M(VOID)
{
 80102d0:	b580      	push	{r7, lr}
 80102d2:	b082      	sub	sp, #8
 80102d4:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80102d6:	f3ef 8305 	mrs	r3, IPSR
 80102da:	607b      	str	r3, [r7, #4]
  return(result);
 80102dc:	687b      	ldr	r3, [r7, #4]
#ifdef LOSCFG_PLATFORM_STM32F767_FIRE
        // Fire_LED_BLUE_ON(1);
    // Fire_DEBUG_GPIOB6(1);
    // DEBUG_INT_PC
#endif    
    g_curIrqNum = __get_IPSR();
 80102de:	4a0c      	ldr	r2, [pc, #48]	; (8010310 <IrqEntryV7M+0x40>)
 80102e0:	6013      	str	r3, [r2, #0]
    OsIntHandle(g_curIrqNum, &g_hwiForm[g_curIrqNum]);
 80102e2:	4b0b      	ldr	r3, [pc, #44]	; (8010310 <IrqEntryV7M+0x40>)
 80102e4:	681a      	ldr	r2, [r3, #0]
 80102e6:	4b0a      	ldr	r3, [pc, #40]	; (8010310 <IrqEntryV7M+0x40>)
 80102e8:	681b      	ldr	r3, [r3, #0]
 80102ea:	011b      	lsls	r3, r3, #4
 80102ec:	4909      	ldr	r1, [pc, #36]	; (8010314 <IrqEntryV7M+0x44>)
 80102ee:	440b      	add	r3, r1
 80102f0:	4619      	mov	r1, r3
 80102f2:	4610      	mov	r0, r2
 80102f4:	f7f1 ff8a 	bl	800220c <OsIntHandle>

    if (OsTaskProcSignal() != 0) {
 80102f8:	f7f3 ff18 	bl	800412c <OsTaskProcSignal>
 80102fc:	4603      	mov	r3, r0
 80102fe:	2b00      	cmp	r3, #0
 8010300:	d001      	beq.n	8010306 <IrqEntryV7M+0x36>
        OsSchedPreempt();
 8010302:	f7f8 fd17 	bl	8008d34 <OsSchedPreempt>
    }
#ifdef LOSCFG_PLATFORM_STM32F767_FIRE    
   // Fire_DEBUG_GPIOB6(0);
    // Fire_LED_BLUE_ON(0);
#endif  
}
 8010306:	bf00      	nop
 8010308:	3708      	adds	r7, #8
 801030a:	46bd      	mov	sp, r7
 801030c:	bd80      	pop	{r7, pc}
 801030e:	bf00      	nop
 8010310:	20002284 	.word	0x20002284
 8010314:	20002288 	.word	0x20002288

08010318 <ArchIrqUnmask>:

UINT32 ArchIrqUnmask(UINT32 hwiNum)
{
 8010318:	b580      	push	{r7, lr}
 801031a:	b084      	sub	sp, #16
 801031c:	af00      	add	r7, sp, #0
 801031e:	6078      	str	r0, [r7, #4]
    UINT32 intSave;

    if (!HWI_NUM_VALID(hwiNum)) {
 8010320:	687b      	ldr	r3, [r7, #4]
 8010322:	2b0e      	cmp	r3, #14
 8010324:	d902      	bls.n	801032c <ArchIrqUnmask+0x14>
 8010326:	687b      	ldr	r3, [r7, #4]
 8010328:	2bff      	cmp	r3, #255	; 0xff
 801032a:	d901      	bls.n	8010330 <ArchIrqUnmask+0x18>
        return LOS_ERRNO_HWI_NUM_INVALID;
 801032c:	4b09      	ldr	r3, [pc, #36]	; (8010354 <ArchIrqUnmask+0x3c>)
 801032e:	e00d      	b.n	801034c <ArchIrqUnmask+0x34>
    }

    hwiNum -= OS_SYS_VECTOR_CNT;
 8010330:	687b      	ldr	r3, [r7, #4]
 8010332:	3b10      	subs	r3, #16
 8010334:	607b      	str	r3, [r7, #4]
    intSave = LOS_IntLock();
 8010336:	f7ff ffa9 	bl	801028c <LOS_IntLock>
 801033a:	60f8      	str	r0, [r7, #12]
    NVIC_EnableIRQ((IRQn_Type)hwiNum);
 801033c:	687b      	ldr	r3, [r7, #4]
 801033e:	4618      	mov	r0, r3
 8010340:	f7ff ff08 	bl	8010154 <__NVIC_EnableIRQ>
    LOS_IntRestore(intSave);
 8010344:	68f8      	ldr	r0, [r7, #12]
 8010346:	f7ff ffa8 	bl	801029a <LOS_IntRestore>
    return LOS_OK;
 801034a:	2300      	movs	r3, #0
}
 801034c:	4618      	mov	r0, r3
 801034e:	3710      	adds	r7, #16
 8010350:	46bd      	mov	sp, r7
 8010352:	bd80      	pop	{r7, pc}
 8010354:	02000900 	.word	0x02000900

08010358 <HalIrqSetPriority>:

UINT32 HalIrqSetPriority(UINT32 hwiNum, UINT8 priority)
{
 8010358:	b580      	push	{r7, lr}
 801035a:	b084      	sub	sp, #16
 801035c:	af00      	add	r7, sp, #0
 801035e:	6078      	str	r0, [r7, #4]
 8010360:	460b      	mov	r3, r1
 8010362:	70fb      	strb	r3, [r7, #3]
    UINT32 intSave;

    if (!HWI_NUM_VALID(hwiNum)) {
 8010364:	687b      	ldr	r3, [r7, #4]
 8010366:	2b0e      	cmp	r3, #14
 8010368:	d902      	bls.n	8010370 <HalIrqSetPriority+0x18>
 801036a:	687b      	ldr	r3, [r7, #4]
 801036c:	2bff      	cmp	r3, #255	; 0xff
 801036e:	d901      	bls.n	8010374 <HalIrqSetPriority+0x1c>
        return LOS_ERRNO_HWI_NUM_INVALID;
 8010370:	4b0d      	ldr	r3, [pc, #52]	; (80103a8 <HalIrqSetPriority+0x50>)
 8010372:	e014      	b.n	801039e <HalIrqSetPriority+0x46>
    }

    if (!HWI_PRI_VALID(priority)) {
 8010374:	78fb      	ldrb	r3, [r7, #3]
 8010376:	2b1f      	cmp	r3, #31
 8010378:	d901      	bls.n	801037e <HalIrqSetPriority+0x26>
        return OS_ERRNO_HWI_PRIO_INVALID;
 801037a:	4b0c      	ldr	r3, [pc, #48]	; (80103ac <HalIrqSetPriority+0x54>)
 801037c:	e00f      	b.n	801039e <HalIrqSetPriority+0x46>
    }

    hwiNum -= OS_SYS_VECTOR_CNT;
 801037e:	687b      	ldr	r3, [r7, #4]
 8010380:	3b10      	subs	r3, #16
 8010382:	607b      	str	r3, [r7, #4]
    intSave = LOS_IntLock();
 8010384:	f7ff ff82 	bl	801028c <LOS_IntLock>
 8010388:	60f8      	str	r0, [r7, #12]
    NVIC_SetPriority((IRQn_Type)hwiNum, priority);
 801038a:	687b      	ldr	r3, [r7, #4]
 801038c:	78fa      	ldrb	r2, [r7, #3]
 801038e:	4611      	mov	r1, r2
 8010390:	4618      	mov	r0, r3
 8010392:	f7ff ff53 	bl	801023c <__NVIC_SetPriority>
    LOS_IntRestore(intSave);
 8010396:	68f8      	ldr	r0, [r7, #12]
 8010398:	f7ff ff7f 	bl	801029a <LOS_IntRestore>

    return LOS_OK;
 801039c:	2300      	movs	r3, #0
}
 801039e:	4618      	mov	r0, r3
 80103a0:	3710      	adds	r7, #16
 80103a2:	46bd      	mov	sp, r7
 80103a4:	bd80      	pop	{r7, pc}
 80103a6:	bf00      	nop
 80103a8:	02000900 	.word	0x02000900
 80103ac:	02000905 	.word	0x02000905

080103b0 <ArchIrqMask>:

UINT32 ArchIrqMask(HWI_HANDLE_T hwiNum)
{
 80103b0:	b580      	push	{r7, lr}
 80103b2:	b084      	sub	sp, #16
 80103b4:	af00      	add	r7, sp, #0
 80103b6:	6078      	str	r0, [r7, #4]
    UINT32 intSave;

    if (!HWI_NUM_VALID(hwiNum)) {
 80103b8:	687b      	ldr	r3, [r7, #4]
 80103ba:	2b0e      	cmp	r3, #14
 80103bc:	d902      	bls.n	80103c4 <ArchIrqMask+0x14>
 80103be:	687b      	ldr	r3, [r7, #4]
 80103c0:	2bff      	cmp	r3, #255	; 0xff
 80103c2:	d901      	bls.n	80103c8 <ArchIrqMask+0x18>
        return LOS_ERRNO_HWI_NUM_INVALID;
 80103c4:	4b09      	ldr	r3, [pc, #36]	; (80103ec <ArchIrqMask+0x3c>)
 80103c6:	e00d      	b.n	80103e4 <ArchIrqMask+0x34>
    }

    hwiNum -= OS_SYS_VECTOR_CNT;
 80103c8:	687b      	ldr	r3, [r7, #4]
 80103ca:	3b10      	subs	r3, #16
 80103cc:	607b      	str	r3, [r7, #4]
    intSave = LOS_IntLock();
 80103ce:	f7ff ff5d 	bl	801028c <LOS_IntLock>
 80103d2:	60f8      	str	r0, [r7, #12]
    NVIC_DisableIRQ((IRQn_Type)hwiNum);
 80103d4:	687b      	ldr	r3, [r7, #4]
 80103d6:	4618      	mov	r0, r3
 80103d8:	f7ff fed6 	bl	8010188 <__NVIC_DisableIRQ>
    LOS_IntRestore(intSave);
 80103dc:	68f8      	ldr	r0, [r7, #12]
 80103de:	f7ff ff5c 	bl	801029a <LOS_IntRestore>
    return LOS_OK;
 80103e2:	2300      	movs	r3, #0
}
 80103e4:	4618      	mov	r0, r3
 80103e6:	3710      	adds	r7, #16
 80103e8:	46bd      	mov	sp, r7
 80103ea:	bd80      	pop	{r7, pc}
 80103ec:	02000900 	.word	0x02000900

080103f0 <ArchIrqPending>:

UINT32 ArchIrqPending(UINT32 hwiNum)
{
 80103f0:	b580      	push	{r7, lr}
 80103f2:	b084      	sub	sp, #16
 80103f4:	af00      	add	r7, sp, #0
 80103f6:	6078      	str	r0, [r7, #4]
    UINT32 intSave;

    if (!HWI_NUM_VALID(hwiNum)) {
 80103f8:	687b      	ldr	r3, [r7, #4]
 80103fa:	2b0e      	cmp	r3, #14
 80103fc:	d902      	bls.n	8010404 <ArchIrqPending+0x14>
 80103fe:	687b      	ldr	r3, [r7, #4]
 8010400:	2bff      	cmp	r3, #255	; 0xff
 8010402:	d901      	bls.n	8010408 <ArchIrqPending+0x18>
        return LOS_ERRNO_HWI_NUM_INVALID;
 8010404:	4b09      	ldr	r3, [pc, #36]	; (801042c <ArchIrqPending+0x3c>)
 8010406:	e00d      	b.n	8010424 <ArchIrqPending+0x34>
    }

    hwiNum -= OS_SYS_VECTOR_CNT;
 8010408:	687b      	ldr	r3, [r7, #4]
 801040a:	3b10      	subs	r3, #16
 801040c:	607b      	str	r3, [r7, #4]
    intSave = LOS_IntLock();
 801040e:	f7ff ff3d 	bl	801028c <LOS_IntLock>
 8010412:	60f8      	str	r0, [r7, #12]
    NVIC_SetPendingIRQ((IRQn_Type)hwiNum);
 8010414:	687b      	ldr	r3, [r7, #4]
 8010416:	4618      	mov	r0, r3
 8010418:	f7ff fed8 	bl	80101cc <__NVIC_SetPendingIRQ>
    LOS_IntRestore(intSave);
 801041c:	68f8      	ldr	r0, [r7, #12]
 801041e:	f7ff ff3c 	bl	801029a <LOS_IntRestore>
    return LOS_OK;
 8010422:	2300      	movs	r3, #0
}
 8010424:	4618      	mov	r0, r3
 8010426:	3710      	adds	r7, #16
 8010428:	46bd      	mov	sp, r7
 801042a:	bd80      	pop	{r7, pc}
 801042c:	02000900 	.word	0x02000900

08010430 <ArchIrqClear>:

UINT32 ArchIrqClear(UINT32 hwiNum)
{
 8010430:	b580      	push	{r7, lr}
 8010432:	b082      	sub	sp, #8
 8010434:	af00      	add	r7, sp, #0
 8010436:	6078      	str	r0, [r7, #4]
    if (!HWI_NUM_VALID(hwiNum)) {
 8010438:	687b      	ldr	r3, [r7, #4]
 801043a:	2b0e      	cmp	r3, #14
 801043c:	d902      	bls.n	8010444 <ArchIrqClear+0x14>
 801043e:	687b      	ldr	r3, [r7, #4]
 8010440:	2bff      	cmp	r3, #255	; 0xff
 8010442:	d901      	bls.n	8010448 <ArchIrqClear+0x18>
        return LOS_ERRNO_HWI_NUM_INVALID;
 8010444:	4b06      	ldr	r3, [pc, #24]	; (8010460 <ArchIrqClear+0x30>)
 8010446:	e007      	b.n	8010458 <ArchIrqClear+0x28>
    }

    hwiNum -= OS_SYS_VECTOR_CNT;
 8010448:	687b      	ldr	r3, [r7, #4]
 801044a:	3b10      	subs	r3, #16
 801044c:	607b      	str	r3, [r7, #4]
    NVIC_ClearPendingIRQ((IRQn_Type)hwiNum);
 801044e:	687b      	ldr	r3, [r7, #4]
 8010450:	4618      	mov	r0, r3
 8010452:	f7ff fed7 	bl	8010204 <__NVIC_ClearPendingIRQ>
    return LOS_OK;
 8010456:	2300      	movs	r3, #0
}
 8010458:	4618      	mov	r0, r3
 801045a:	3708      	adds	r7, #8
 801045c:	46bd      	mov	sp, r7
 801045e:	bd80      	pop	{r7, pc}
 8010460:	02000900 	.word	0x02000900

08010464 <HalCurIrqGet>:

UINT32 HalCurIrqGet(VOID)
{
 8010464:	b480      	push	{r7}
 8010466:	b083      	sub	sp, #12
 8010468:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801046a:	f3ef 8305 	mrs	r3, IPSR
 801046e:	607b      	str	r3, [r7, #4]
  return(result);
 8010470:	687b      	ldr	r3, [r7, #4]
    g_curIrqNum = __get_IPSR();
 8010472:	4a05      	ldr	r2, [pc, #20]	; (8010488 <HalCurIrqGet+0x24>)
 8010474:	6013      	str	r3, [r2, #0]
    return g_curIrqNum;
 8010476:	4b04      	ldr	r3, [pc, #16]	; (8010488 <HalCurIrqGet+0x24>)
 8010478:	681b      	ldr	r3, [r3, #0]
}
 801047a:	4618      	mov	r0, r3
 801047c:	370c      	adds	r7, #12
 801047e:	46bd      	mov	sp, r7
 8010480:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010484:	4770      	bx	lr
 8010486:	bf00      	nop
 8010488:	20002284 	.word	0x20002284

0801048c <HalIrqVersion>:

CHAR *HalIrqVersion(VOID)
{
 801048c:	b480      	push	{r7}
 801048e:	af00      	add	r7, sp, #0
    return "NVIC";
 8010490:	4b02      	ldr	r3, [pc, #8]	; (801049c <HalIrqVersion+0x10>)
}
 8010492:	4618      	mov	r0, r3
 8010494:	46bd      	mov	sp, r7
 8010496:	f85d 7b04 	ldr.w	r7, [sp], #4
 801049a:	4770      	bx	lr
 801049c:	08021754 	.word	0x08021754

080104a0 <ArchIrqGetHandleForm>:

HwiHandleInfo *ArchIrqGetHandleForm(HWI_HANDLE_T hwiNum)
{
 80104a0:	b480      	push	{r7}
 80104a2:	b083      	sub	sp, #12
 80104a4:	af00      	add	r7, sp, #0
 80104a6:	6078      	str	r0, [r7, #4]
    if (!HWI_NUM_VALID(hwiNum)) {
 80104a8:	687b      	ldr	r3, [r7, #4]
 80104aa:	2b0e      	cmp	r3, #14
 80104ac:	d902      	bls.n	80104b4 <ArchIrqGetHandleForm+0x14>
 80104ae:	687b      	ldr	r3, [r7, #4]
 80104b0:	2bff      	cmp	r3, #255	; 0xff
 80104b2:	d901      	bls.n	80104b8 <ArchIrqGetHandleForm+0x18>
        return NULL;
 80104b4:	2300      	movs	r3, #0
 80104b6:	e003      	b.n	80104c0 <ArchIrqGetHandleForm+0x20>
    }

    return &g_hwiForm[hwiNum];
 80104b8:	687b      	ldr	r3, [r7, #4]
 80104ba:	011b      	lsls	r3, r3, #4
 80104bc:	4a03      	ldr	r2, [pc, #12]	; (80104cc <ArchIrqGetHandleForm+0x2c>)
 80104be:	4413      	add	r3, r2
}
 80104c0:	4618      	mov	r0, r3
 80104c2:	370c      	adds	r7, #12
 80104c4:	46bd      	mov	sp, r7
 80104c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80104ca:	4770      	bx	lr
 80104cc:	20002288 	.word	0x20002288

080104d0 <ArchIrqInit>:
    .getHandleForm  = ArchIrqGetHandleForm,
    .clearIrq       = ArchIrqClear,
};

VOID ArchIrqInit(VOID)
{
 80104d0:	b580      	push	{r7, lr}
 80104d2:	b082      	sub	sp, #8
 80104d4:	af00      	add	r7, sp, #0
    UINT32 i;

    for (i = OS_SYS_VECTOR_CNT; i < LOSCFG_PLATFORM_HWI_LIMIT; i++) {
 80104d6:	2310      	movs	r3, #16
 80104d8:	607b      	str	r3, [r7, #4]
 80104da:	e007      	b.n	80104ec <ArchIrqInit+0x1c>
        g_hwiVec[i] = (HWI_PROC_FUNC)IrqEntryV7M;
 80104dc:	4a0b      	ldr	r2, [pc, #44]	; (801050c <ArchIrqInit+0x3c>)
 80104de:	687b      	ldr	r3, [r7, #4]
 80104e0:	490b      	ldr	r1, [pc, #44]	; (8010510 <ArchIrqInit+0x40>)
 80104e2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for (i = OS_SYS_VECTOR_CNT; i < LOSCFG_PLATFORM_HWI_LIMIT; i++) {
 80104e6:	687b      	ldr	r3, [r7, #4]
 80104e8:	3301      	adds	r3, #1
 80104ea:	607b      	str	r3, [r7, #4]
 80104ec:	687b      	ldr	r3, [r7, #4]
 80104ee:	2bff      	cmp	r3, #255	; 0xff
 80104f0:	d9f4      	bls.n	80104dc <ArchIrqInit+0xc>
    __HAL_RCC_SYSCFG_CLK_ENABLE();
    /* Remap SRAM at 0x00000000 */
    __HAL_SYSCFG_REMAPMEMORY_SRAM();
#else
    /* Interrupt vector table location */
    SCB->VTOR = (UINT32)g_hwiVec;
 80104f2:	4b08      	ldr	r3, [pc, #32]	; (8010514 <ArchIrqInit+0x44>)
 80104f4:	4a05      	ldr	r2, [pc, #20]	; (801050c <ArchIrqInit+0x3c>)
 80104f6:	609a      	str	r2, [r3, #8]
#endif
#if (__CORTEX_M >= 0x03U) /* only for Cortex-M3 and above */
    NVIC_SetPriorityGrouping(OS_NVIC_AIRCR_PRIGROUP);
 80104f8:	2007      	movs	r0, #7
 80104fa:	f7ff fe07 	bl	801010c <__NVIC_SetPriorityGrouping>
#endif

    /* register interrupt controller's operations */
    OsHwiControllerReg(&g_nvicOps);
 80104fe:	4806      	ldr	r0, [pc, #24]	; (8010518 <ArchIrqInit+0x48>)
 8010500:	f7ff fed6 	bl	80102b0 <OsHwiControllerReg>
    return;
 8010504:	bf00      	nop
}
 8010506:	3708      	adds	r7, #8
 8010508:	46bd      	mov	sp, r7
 801050a:	bd80      	pop	{r7, pc}
 801050c:	20000000 	.word	0x20000000
 8010510:	080102d1 	.word	0x080102d1
 8010514:	e000ed00 	.word	0xe000ed00
 8010518:	080234ac 	.word	0x080234ac

0801051c <__NVIC_SetPriority>:
{
 801051c:	b480      	push	{r7}
 801051e:	b083      	sub	sp, #12
 8010520:	af00      	add	r7, sp, #0
 8010522:	6078      	str	r0, [r7, #4]
 8010524:	6039      	str	r1, [r7, #0]
  if ((int32_t)(IRQn) >= 0)
 8010526:	687b      	ldr	r3, [r7, #4]
 8010528:	2b00      	cmp	r3, #0
 801052a:	db09      	blt.n	8010540 <__NVIC_SetPriority+0x24>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 801052c:	683b      	ldr	r3, [r7, #0]
 801052e:	b2da      	uxtb	r2, r3
 8010530:	490c      	ldr	r1, [pc, #48]	; (8010564 <__NVIC_SetPriority+0x48>)
 8010532:	687b      	ldr	r3, [r7, #4]
 8010534:	0112      	lsls	r2, r2, #4
 8010536:	b2d2      	uxtb	r2, r2
 8010538:	440b      	add	r3, r1
 801053a:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 801053e:	e00a      	b.n	8010556 <__NVIC_SetPriority+0x3a>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8010540:	683b      	ldr	r3, [r7, #0]
 8010542:	b2da      	uxtb	r2, r3
 8010544:	4908      	ldr	r1, [pc, #32]	; (8010568 <__NVIC_SetPriority+0x4c>)
 8010546:	687b      	ldr	r3, [r7, #4]
 8010548:	f003 030f 	and.w	r3, r3, #15
 801054c:	3b04      	subs	r3, #4
 801054e:	0112      	lsls	r2, r2, #4
 8010550:	b2d2      	uxtb	r2, r2
 8010552:	440b      	add	r3, r1
 8010554:	761a      	strb	r2, [r3, #24]
}
 8010556:	bf00      	nop
 8010558:	370c      	adds	r7, #12
 801055a:	46bd      	mov	sp, r7
 801055c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010560:	4770      	bx	lr
 8010562:	bf00      	nop
 8010564:	e000e100 	.word	0xe000e100
 8010568:	e000ed00 	.word	0xe000ed00

0801056c <SysTick_Config>:
{
 801056c:	b580      	push	{r7, lr}
 801056e:	b082      	sub	sp, #8
 8010570:	af00      	add	r7, sp, #0
 8010572:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8010574:	687b      	ldr	r3, [r7, #4]
 8010576:	3b01      	subs	r3, #1
 8010578:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 801057c:	d301      	bcc.n	8010582 <SysTick_Config+0x16>
    return (1UL);                                                   /* Reload value impossible */
 801057e:	2301      	movs	r3, #1
 8010580:	e00f      	b.n	80105a2 <SysTick_Config+0x36>
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8010582:	4a0a      	ldr	r2, [pc, #40]	; (80105ac <SysTick_Config+0x40>)
 8010584:	687b      	ldr	r3, [r7, #4]
 8010586:	3b01      	subs	r3, #1
 8010588:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 801058a:	210f      	movs	r1, #15
 801058c:	f04f 30ff 	mov.w	r0, #4294967295
 8010590:	f7ff ffc4 	bl	801051c <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8010594:	4b05      	ldr	r3, [pc, #20]	; (80105ac <SysTick_Config+0x40>)
 8010596:	2200      	movs	r2, #0
 8010598:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 801059a:	4b04      	ldr	r3, [pc, #16]	; (80105ac <SysTick_Config+0x40>)
 801059c:	2207      	movs	r2, #7
 801059e:	601a      	str	r2, [r3, #0]
  return (0UL);                                                     /* Function successful */
 80105a0:	2300      	movs	r3, #0
}
 80105a2:	4618      	mov	r0, r3
 80105a4:	3708      	adds	r7, #8
 80105a6:	46bd      	mov	sp, r7
 80105a8:	bd80      	pop	{r7, pc}
 80105aa:	bf00      	nop
 80105ac:	e000e010 	.word	0xe000e010

080105b0 <LOS_IntLock>:
{
 80105b0:	b580      	push	{r7, lr}
 80105b2:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80105b4:	f7f0 fb88 	bl	8000cc8 <ArchIntLock>
 80105b8:	4603      	mov	r3, r0
}
 80105ba:	4618      	mov	r0, r3
 80105bc:	bd80      	pop	{r7, pc}

080105be <LOS_IntRestore>:
{
 80105be:	b580      	push	{r7, lr}
 80105c0:	b082      	sub	sp, #8
 80105c2:	af00      	add	r7, sp, #0
 80105c4:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80105c6:	6878      	ldr	r0, [r7, #4]
 80105c8:	f7f0 fb86 	bl	8000cd8 <ArchIntRestore>
}
 80105cc:	bf00      	nop
 80105ce:	3708      	adds	r7, #8
 80105d0:	46bd      	mov	sp, r7
 80105d2:	bd80      	pop	{r7, pc}

080105d4 <HalClockInit>:
LITE_OS_SEC_BSS UINT32     g_cyclesPerTick;

#define M_INT_NUM  15 /* SysTick_IRQn + OS_SYS_VECOTRE */

VOID HalClockInit(VOID)
{
 80105d4:	b580      	push	{r7, lr}
 80105d6:	b084      	sub	sp, #16
 80105d8:	af02      	add	r7, sp, #8
    UINT32 ret = LOS_HwiCreate(M_INT_NUM, 0, 0, OsTickHandler, 0);
 80105da:	2300      	movs	r3, #0
 80105dc:	9300      	str	r3, [sp, #0]
 80105de:	4b0c      	ldr	r3, [pc, #48]	; (8010610 <HalClockInit+0x3c>)
 80105e0:	2200      	movs	r2, #0
 80105e2:	2100      	movs	r1, #0
 80105e4:	200f      	movs	r0, #15
 80105e6:	f7f2 f853 	bl	8002690 <LOS_HwiCreate>
 80105ea:	6078      	str	r0, [r7, #4]
    if (ret != 0) {
 80105ec:	687b      	ldr	r3, [r7, #4]
 80105ee:	2b00      	cmp	r3, #0
 80105f0:	d003      	beq.n	80105fa <HalClockInit+0x26>
        PRINTK("ret of LOS_HwiCreate = %#x\n", ret);
 80105f2:	6879      	ldr	r1, [r7, #4]
 80105f4:	4807      	ldr	r0, [pc, #28]	; (8010614 <HalClockInit+0x40>)
 80105f6:	f7f4 f963 	bl	80048c0 <dprintf>
    }
#ifdef LOSCFG_KERNEL_CPUP
    if (g_cpupTimerOps.timHwiCreate != NULL) {
 80105fa:	4b07      	ldr	r3, [pc, #28]	; (8010618 <HalClockInit+0x44>)
 80105fc:	685b      	ldr	r3, [r3, #4]
 80105fe:	2b00      	cmp	r3, #0
 8010600:	d002      	beq.n	8010608 <HalClockInit+0x34>
        g_cpupTimerOps.timHwiCreate();
 8010602:	4b05      	ldr	r3, [pc, #20]	; (8010618 <HalClockInit+0x44>)
 8010604:	685b      	ldr	r3, [r3, #4]
 8010606:	4798      	blx	r3
    }
#endif
}
 8010608:	bf00      	nop
 801060a:	3708      	adds	r7, #8
 801060c:	46bd      	mov	sp, r7
 801060e:	bd80      	pop	{r7, pc}
 8010610:	080042a5 	.word	0x080042a5
 8010614:	0802175c 	.word	0x0802175c
 8010618:	20000408 	.word	0x20000408

0801061c <HalClockStart>:

VOID HalClockStart(VOID)
{
 801061c:	b580      	push	{r7, lr}
 801061e:	b082      	sub	sp, #8
 8010620:	af00      	add	r7, sp, #0
    if ((OS_SYS_CLOCK == 0) ||
 8010622:	4b15      	ldr	r3, [pc, #84]	; (8010678 <HalClockStart+0x5c>)
 8010624:	681b      	ldr	r3, [r3, #0]
 8010626:	2b00      	cmp	r3, #0
 8010628:	d021      	beq.n	801066e <HalClockStart+0x52>
        (LOSCFG_BASE_CORE_TICK_PER_SECOND == 0) ||
        (LOSCFG_BASE_CORE_TICK_PER_SECOND > OS_SYS_CLOCK)) {
 801062a:	4b13      	ldr	r3, [pc, #76]	; (8010678 <HalClockStart+0x5c>)
 801062c:	681b      	ldr	r3, [r3, #0]
        (LOSCFG_BASE_CORE_TICK_PER_SECOND == 0) ||
 801062e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8010632:	d31c      	bcc.n	801066e <HalClockStart+0x52>
        return;
    }

    g_cyclesPerTick = OS_CYCLE_PER_TICK;
 8010634:	4b10      	ldr	r3, [pc, #64]	; (8010678 <HalClockStart+0x5c>)
 8010636:	681b      	ldr	r3, [r3, #0]
 8010638:	4a10      	ldr	r2, [pc, #64]	; (801067c <HalClockStart+0x60>)
 801063a:	fba2 2303 	umull	r2, r3, r2, r3
 801063e:	099b      	lsrs	r3, r3, #6
 8010640:	4a0f      	ldr	r2, [pc, #60]	; (8010680 <HalClockStart+0x64>)
 8010642:	6013      	str	r3, [r2, #0]

    (VOID)SysTick_Config(OS_CYCLE_PER_TICK);
 8010644:	4b0c      	ldr	r3, [pc, #48]	; (8010678 <HalClockStart+0x5c>)
 8010646:	681b      	ldr	r3, [r3, #0]
 8010648:	4a0c      	ldr	r2, [pc, #48]	; (801067c <HalClockStart+0x60>)
 801064a:	fba2 2303 	umull	r2, r3, r2, r3
 801064e:	099b      	lsrs	r3, r3, #6
 8010650:	4618      	mov	r0, r3
 8010652:	f7ff ff8b 	bl	801056c <SysTick_Config>

    UINT32 ret = LOS_HwiEnable(M_INT_NUM);
 8010656:	200f      	movs	r0, #15
 8010658:	f7f2 f8cc 	bl	80027f4 <LOS_HwiEnable>
 801065c:	6078      	str	r0, [r7, #4]
    if (ret != 0) {
 801065e:	687b      	ldr	r3, [r7, #4]
 8010660:	2b00      	cmp	r3, #0
 8010662:	d005      	beq.n	8010670 <HalClockStart+0x54>
        PRINTK("LOS_HwiEnable failed. ret = %#x\n", ret);
 8010664:	6879      	ldr	r1, [r7, #4]
 8010666:	4807      	ldr	r0, [pc, #28]	; (8010684 <HalClockStart+0x68>)
 8010668:	f7f4 f92a 	bl	80048c0 <dprintf>
 801066c:	e000      	b.n	8010670 <HalClockStart+0x54>
        return;
 801066e:	bf00      	nop
    }
}
 8010670:	3708      	adds	r7, #8
 8010672:	46bd      	mov	sp, r7
 8010674:	bd80      	pop	{r7, pc}
 8010676:	bf00      	nop
 8010678:	20000404 	.word	0x20000404
 801067c:	10624dd3 	.word	0x10624dd3
 8010680:	20003768 	.word	0x20003768
 8010684:	08021778 	.word	0x08021778

08010688 <HalClockGetCycles>:

UINT64 HalClockGetCycles(VOID)
{
 8010688:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801068c:	b086      	sub	sp, #24
 801068e:	af00      	add	r7, sp, #0
    UINT32 hwCycle;
    UINT32 intSave;


#ifdef LOSCFG_PLATFORM_STM32F767_FIRE
    if (g_cpupTimerOps.timGetTimerCycles != NULL) {
 8010690:	4b35      	ldr	r3, [pc, #212]	; (8010768 <HalClockGetCycles+0xe0>)
 8010692:	689b      	ldr	r3, [r3, #8]
 8010694:	2b00      	cmp	r3, #0
 8010696:	d007      	beq.n	80106a8 <HalClockGetCycles+0x20>
        cycle = g_cpupTimerOps.timGetTimerCycles();
 8010698:	4b33      	ldr	r3, [pc, #204]	; (8010768 <HalClockGetCycles+0xe0>)
 801069a:	689b      	ldr	r3, [r3, #8]
 801069c:	4798      	blx	r3
 801069e:	e9c7 0104 	strd	r0, r1, [r7, #16]
        return cycle;
 80106a2:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80106a6:	e059      	b.n	801075c <HalClockGetCycles+0xd4>
    }
#endif
    intSave = LOS_IntLock();
 80106a8:	f7ff ff82 	bl	80105b0 <LOS_IntLock>
 80106ac:	6078      	str	r0, [r7, #4]

    swTick = LOS_TickCountGet();
 80106ae:	f7f3 fe5d 	bl	800436c <LOS_TickCountGet>
 80106b2:	e9c7 0102 	strd	r0, r1, [r7, #8]
    hwCycle = SysTick->VAL;
 80106b6:	4b2d      	ldr	r3, [pc, #180]	; (801076c <HalClockGetCycles+0xe4>)
 80106b8:	689b      	ldr	r3, [r3, #8]
 80106ba:	603b      	str	r3, [r7, #0]

    /* tick has come, but may interrupt environment, not counting the Tick interrupt response */
    // 2022-03-31 tanzhongqiang 检查中断控制状态寄存器。是否有systick 被悬起。因为此时已经关闭中断了。
    if ((SCB->ICSR & TICK_INTR_CHECK) != 0) {
 80106bc:	4b2c      	ldr	r3, [pc, #176]	; (8010770 <HalClockGetCycles+0xe8>)
 80106be:	685b      	ldr	r3, [r3, #4]
 80106c0:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80106c4:	2b00      	cmp	r3, #0
 80106c6:	d00a      	beq.n	80106de <HalClockGetCycles+0x56>
        hwCycle = SysTick->VAL;
 80106c8:	4b28      	ldr	r3, [pc, #160]	; (801076c <HalClockGetCycles+0xe4>)
 80106ca:	689b      	ldr	r3, [r3, #8]
 80106cc:	603b      	str	r3, [r7, #0]
        swTick++;
 80106ce:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80106d2:	f112 0801 	adds.w	r8, r2, #1
 80106d6:	f143 0900 	adc.w	r9, r3, #0
 80106da:	e9c7 8902 	strd	r8, r9, [r7, #8]
    }

    cycle = (swTick * g_cyclesPerTick) + (g_cyclesPerTick - hwCycle);
 80106de:	4b25      	ldr	r3, [pc, #148]	; (8010774 <HalClockGetCycles+0xec>)
 80106e0:	681b      	ldr	r3, [r3, #0]
 80106e2:	461a      	mov	r2, r3
 80106e4:	f04f 0300 	mov.w	r3, #0
 80106e8:	68b9      	ldr	r1, [r7, #8]
 80106ea:	fb03 f001 	mul.w	r0, r3, r1
 80106ee:	68f9      	ldr	r1, [r7, #12]
 80106f0:	fb02 f101 	mul.w	r1, r2, r1
 80106f4:	4401      	add	r1, r0
 80106f6:	68b8      	ldr	r0, [r7, #8]
 80106f8:	fba0 2302 	umull	r2, r3, r0, r2
 80106fc:	4419      	add	r1, r3
 80106fe:	460b      	mov	r3, r1
 8010700:	491c      	ldr	r1, [pc, #112]	; (8010774 <HalClockGetCycles+0xec>)
 8010702:	6808      	ldr	r0, [r1, #0]
 8010704:	6839      	ldr	r1, [r7, #0]
 8010706:	1a41      	subs	r1, r0, r1
 8010708:	4608      	mov	r0, r1
 801070a:	f04f 0100 	mov.w	r1, #0
 801070e:	1814      	adds	r4, r2, r0
 8010710:	eb43 0501 	adc.w	r5, r3, r1
 8010714:	e9c7 4504 	strd	r4, r5, [r7, #16]
    LOS_IntRestore(intSave);
 8010718:	6878      	ldr	r0, [r7, #4]
 801071a:	f7ff ff50 	bl	80105be <LOS_IntRestore>

#ifdef LOSCFG_KERNEL_CPUP
    if (g_cpupTimerOps.timGetTimerCycles != NULL) {
 801071e:	4b12      	ldr	r3, [pc, #72]	; (8010768 <HalClockGetCycles+0xe0>)
 8010720:	689b      	ldr	r3, [r3, #8]
 8010722:	2b00      	cmp	r3, #0
 8010724:	d018      	beq.n	8010758 <HalClockGetCycles+0xd0>
        cycle = g_cpupTimerOps.timGetTimerCycles() * TIMER_CYCLE_SWITCH;
 8010726:	4b10      	ldr	r3, [pc, #64]	; (8010768 <HalClockGetCycles+0xe0>)
 8010728:	689b      	ldr	r3, [r3, #8]
 801072a:	4798      	blx	r3
 801072c:	4b12      	ldr	r3, [pc, #72]	; (8010778 <HalClockGetCycles+0xf0>)
 801072e:	681b      	ldr	r3, [r3, #0]
 8010730:	4a12      	ldr	r2, [pc, #72]	; (801077c <HalClockGetCycles+0xf4>)
 8010732:	fba2 2303 	umull	r2, r3, r2, r3
 8010736:	0b5b      	lsrs	r3, r3, #13
 8010738:	461a      	mov	r2, r3
 801073a:	f04f 0300 	mov.w	r3, #0
 801073e:	fb02 f501 	mul.w	r5, r2, r1
 8010742:	fb00 f403 	mul.w	r4, r0, r3
 8010746:	442c      	add	r4, r5
 8010748:	fba0 2302 	umull	r2, r3, r0, r2
 801074c:	18e1      	adds	r1, r4, r3
 801074e:	460b      	mov	r3, r1
 8010750:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8010754:	e9c7 2304 	strd	r2, r3, [r7, #16]
    }
#endif

    return cycle;
 8010758:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
}
 801075c:	4610      	mov	r0, r2
 801075e:	4619      	mov	r1, r3
 8010760:	3718      	adds	r7, #24
 8010762:	46bd      	mov	sp, r7
 8010764:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 8010768:	20000408 	.word	0x20000408
 801076c:	e000e010 	.word	0xe000e010
 8010770:	e000ed00 	.word	0xe000ed00
 8010774:	20003768 	.word	0x20003768
 8010778:	20000404 	.word	0x20000404
 801077c:	d1b71759 	.word	0xd1b71759

08010780 <HalClockGetTickTimerCycles>:
    return LOS_CurrNanosec();
}

/* just stub api for tickless */
UINT32 HalClockGetTickTimerCycles(VOID)
{
 8010780:	b480      	push	{r7}
 8010782:	af00      	add	r7, sp, #0
    return SysTick->VAL;
 8010784:	4b03      	ldr	r3, [pc, #12]	; (8010794 <HalClockGetTickTimerCycles+0x14>)
 8010786:	689b      	ldr	r3, [r3, #8]
}
 8010788:	4618      	mov	r0, r3
 801078a:	46bd      	mov	sp, r7
 801078c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010790:	4770      	bx	lr
 8010792:	bf00      	nop
 8010794:	e000e010 	.word	0xe000e010

08010798 <HalClockTickTimerReload>:

/* just stub api for tickless */
VOID HalClockTickTimerReload(UINT32 cycles)
{
 8010798:	b480      	push	{r7}
 801079a:	b083      	sub	sp, #12
 801079c:	af00      	add	r7, sp, #0
 801079e:	6078      	str	r0, [r7, #4]
    SysTick->VAL = (cycles == 0) ? 0 : (cycles - 1U);
 80107a0:	687b      	ldr	r3, [r7, #4]
 80107a2:	2b00      	cmp	r3, #0
 80107a4:	d002      	beq.n	80107ac <HalClockTickTimerReload+0x14>
 80107a6:	687b      	ldr	r3, [r7, #4]
 80107a8:	3b01      	subs	r3, #1
 80107aa:	e000      	b.n	80107ae <HalClockTickTimerReload+0x16>
 80107ac:	2300      	movs	r3, #0
 80107ae:	4a05      	ldr	r2, [pc, #20]	; (80107c4 <HalClockTickTimerReload+0x2c>)
 80107b0:	6093      	str	r3, [r2, #8]
    SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80107b2:	4b04      	ldr	r3, [pc, #16]	; (80107c4 <HalClockTickTimerReload+0x2c>)
 80107b4:	2207      	movs	r2, #7
 80107b6:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;        /* Enable SysTick IRQ and SysTick Timer */
}
 80107b8:	bf00      	nop
 80107ba:	370c      	adds	r7, #12
 80107bc:	46bd      	mov	sp, r7
 80107be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80107c2:	4770      	bx	lr
 80107c4:	e000e010 	.word	0xe000e010

080107c8 <OsLowpowerInit>:
#define CALL_PMOPS_FUNC_RET(func, ret, ...) CALL_FUNC_WITH_RETURN_FROM_PTR(g_pmOps, ret, func, __VA_ARGS__)

__attribute__((section(".data"))) STATIC const PowerMgrOps *g_pmOps = NULL;

VOID OsLowpowerInit(const PowerMgrOps *pmOps)
{
 80107c8:	b580      	push	{r7, lr}
 80107ca:	b082      	sub	sp, #8
 80107cc:	af00      	add	r7, sp, #0
 80107ce:	6078      	str	r0, [r7, #4]
    if (pmOps == NULL) {
 80107d0:	687b      	ldr	r3, [r7, #4]
 80107d2:	2b00      	cmp	r3, #0
 80107d4:	d00b      	beq.n	80107ee <OsLowpowerInit+0x26>
#ifdef LOSCFG_KERNEL_POWER_MGR
        PRINT_ERR("\r\n [PM] PowerMgrOps must be non-null.\n");
        return;
#endif
    } else if (pmOps->process == NULL) {
 80107d6:	687b      	ldr	r3, [r7, #4]
 80107d8:	681b      	ldr	r3, [r3, #0]
 80107da:	2b00      	cmp	r3, #0
 80107dc:	d107      	bne.n	80107ee <OsLowpowerInit+0x26>
        PRINT_ERR("\r\n [PM] %s must be non-null.\n", __FUNCTION__);
 80107de:	480f      	ldr	r0, [pc, #60]	; (801081c <OsLowpowerInit+0x54>)
 80107e0:	f7f4 f86e 	bl	80048c0 <dprintf>
 80107e4:	490e      	ldr	r1, [pc, #56]	; (8010820 <OsLowpowerInit+0x58>)
 80107e6:	480f      	ldr	r0, [pc, #60]	; (8010824 <OsLowpowerInit+0x5c>)
 80107e8:	f7f4 f86a 	bl	80048c0 <dprintf>
        return;
 80107ec:	e013      	b.n	8010816 <OsLowpowerInit+0x4e>
    }

    if (g_pmOps != NULL) {
 80107ee:	4b0e      	ldr	r3, [pc, #56]	; (8010828 <OsLowpowerInit+0x60>)
 80107f0:	681b      	ldr	r3, [r3, #0]
 80107f2:	2b00      	cmp	r3, #0
 80107f4:	d006      	beq.n	8010804 <OsLowpowerInit+0x3c>
        PRINT_ERR("\r\n [PM] Reassignment of PowerMgrOps is forbidden.\n");
 80107f6:	4809      	ldr	r0, [pc, #36]	; (801081c <OsLowpowerInit+0x54>)
 80107f8:	f7f4 f862 	bl	80048c0 <dprintf>
 80107fc:	480b      	ldr	r0, [pc, #44]	; (801082c <OsLowpowerInit+0x64>)
 80107fe:	f7f4 f85f 	bl	80048c0 <dprintf>
        return;
 8010802:	e008      	b.n	8010816 <OsLowpowerInit+0x4e>
    }
    g_pmOps = pmOps;
 8010804:	4a08      	ldr	r2, [pc, #32]	; (8010828 <OsLowpowerInit+0x60>)
 8010806:	687b      	ldr	r3, [r7, #4]
 8010808:	6013      	str	r3, [r2, #0]

    LOS_LowpowerHookReg(OsPowerMgrProcess);
 801080a:	4809      	ldr	r0, [pc, #36]	; (8010830 <OsLowpowerInit+0x68>)
 801080c:	f7f2 fd6a 	bl	80032e4 <LOS_LowpowerHookReg>

    LOS_IntWakeupHookReg(OsPowerMgrWakeUpFromInterrupt);
 8010810:	4808      	ldr	r0, [pc, #32]	; (8010834 <OsLowpowerInit+0x6c>)
 8010812:	f7f2 f83b 	bl	800288c <LOS_IntWakeupHookReg>
}
 8010816:	3708      	adds	r7, #8
 8010818:	46bd      	mov	sp, r7
 801081a:	bd80      	pop	{r7, pc}
 801081c:	0802179c 	.word	0x0802179c
 8010820:	080234d0 	.word	0x080234d0
 8010824:	080217a4 	.word	0x080217a4
 8010828:	20000400 	.word	0x20000400
 801082c:	080217c4 	.word	0x080217c4
 8010830:	08010839 	.word	0x08010839
 8010834:	0801087d 	.word	0x0801087d

08010838 <OsPowerMgrProcess>:
#ifdef LOSCFG_PLATFORM_STM32F767_FIRE
extern void Fire_DEBUG_GPIOB6(int on);
#endif
VOID OsPowerMgrProcess(VOID)
{
 8010838:	b580      	push	{r7, lr}
 801083a:	af00      	add	r7, sp, #0
#ifdef LOSCFG_KERNEL_POWER_MGR
    CALL_PMOPS_FUNC_VOID(process);
#else
    if (g_pmOps == NULL) {
 801083c:	4b0e      	ldr	r3, [pc, #56]	; (8010878 <OsPowerMgrProcess+0x40>)
 801083e:	681b      	ldr	r3, [r3, #0]
 8010840:	2b00      	cmp	r3, #0
 8010842:	d10a      	bne.n	801085a <OsPowerMgrProcess+0x22>
#ifdef LOSCFG_KERNEL_TICKLESS
        OsTicklessOpen();
 8010844:	f003 fdf2 	bl	801442c <OsTicklessOpen>
#ifdef LOSCFG_PLATFORM_STM32F767_FIRE
    // 2022-03-31 tanzhongqiang 测试进入休眠期的间隔
    Fire_DEBUG_GPIOB6(1);
 8010848:	2001      	movs	r0, #1
 801084a:	f7f1 fa6b 	bl	8001d24 <Fire_DEBUG_GPIOB6>
    __asm__ volatile("nop" );
 801084e:	bf00      	nop
    Fire_DEBUG_GPIOB6(0);
 8010850:	2000      	movs	r0, #0
 8010852:	f7f1 fa67 	bl	8001d24 <Fire_DEBUG_GPIOB6>
#endif
        wfi();
 8010856:	bf30      	wfi
#endif
    } else {
        CALL_PMOPS_FUNC_VOID(process);
    }
#endif
}
 8010858:	e00c      	b.n	8010874 <OsPowerMgrProcess+0x3c>
        CALL_PMOPS_FUNC_VOID(process);
 801085a:	4b07      	ldr	r3, [pc, #28]	; (8010878 <OsPowerMgrProcess+0x40>)
 801085c:	681b      	ldr	r3, [r3, #0]
 801085e:	2b00      	cmp	r3, #0
 8010860:	d008      	beq.n	8010874 <OsPowerMgrProcess+0x3c>
 8010862:	4b05      	ldr	r3, [pc, #20]	; (8010878 <OsPowerMgrProcess+0x40>)
 8010864:	681b      	ldr	r3, [r3, #0]
 8010866:	681b      	ldr	r3, [r3, #0]
 8010868:	2b00      	cmp	r3, #0
 801086a:	d003      	beq.n	8010874 <OsPowerMgrProcess+0x3c>
 801086c:	4b02      	ldr	r3, [pc, #8]	; (8010878 <OsPowerMgrProcess+0x40>)
 801086e:	681b      	ldr	r3, [r3, #0]
 8010870:	681b      	ldr	r3, [r3, #0]
 8010872:	4798      	blx	r3
}
 8010874:	bf00      	nop
 8010876:	bd80      	pop	{r7, pc}
 8010878:	20000400 	.word	0x20000400

0801087c <OsPowerMgrWakeUpFromInterrupt>:

VOID OsPowerMgrWakeUpFromInterrupt(UINT32 intNum)
{
 801087c:	b580      	push	{r7, lr}
 801087e:	b082      	sub	sp, #8
 8010880:	af00      	add	r7, sp, #0
 8010882:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_KERNEL_POWER_MGR
    CALL_PMOPS_FUNC_VOID(resumeFromInterrupt, intNum);
#else
    if (g_pmOps == NULL) {
 8010884:	4b0c      	ldr	r3, [pc, #48]	; (80108b8 <OsPowerMgrWakeUpFromInterrupt+0x3c>)
 8010886:	681b      	ldr	r3, [r3, #0]
 8010888:	2b00      	cmp	r3, #0
 801088a:	d103      	bne.n	8010894 <OsPowerMgrWakeUpFromInterrupt+0x18>
#ifdef LOSCFG_KERNEL_TICKLESS
        OsTicklessUpdate(intNum);
 801088c:	6878      	ldr	r0, [r7, #4]
 801088e:	f003 fd19 	bl	80142c4 <OsTicklessUpdate>
#endif
    } else {
        CALL_PMOPS_FUNC_VOID(resumeFromInterrupt, intNum);
    }
#endif
}
 8010892:	e00d      	b.n	80108b0 <OsPowerMgrWakeUpFromInterrupt+0x34>
        CALL_PMOPS_FUNC_VOID(resumeFromInterrupt, intNum);
 8010894:	4b08      	ldr	r3, [pc, #32]	; (80108b8 <OsPowerMgrWakeUpFromInterrupt+0x3c>)
 8010896:	681b      	ldr	r3, [r3, #0]
 8010898:	2b00      	cmp	r3, #0
 801089a:	d009      	beq.n	80108b0 <OsPowerMgrWakeUpFromInterrupt+0x34>
 801089c:	4b06      	ldr	r3, [pc, #24]	; (80108b8 <OsPowerMgrWakeUpFromInterrupt+0x3c>)
 801089e:	681b      	ldr	r3, [r3, #0]
 80108a0:	689b      	ldr	r3, [r3, #8]
 80108a2:	2b00      	cmp	r3, #0
 80108a4:	d004      	beq.n	80108b0 <OsPowerMgrWakeUpFromInterrupt+0x34>
 80108a6:	4b04      	ldr	r3, [pc, #16]	; (80108b8 <OsPowerMgrWakeUpFromInterrupt+0x3c>)
 80108a8:	681b      	ldr	r3, [r3, #0]
 80108aa:	689b      	ldr	r3, [r3, #8]
 80108ac:	6878      	ldr	r0, [r7, #4]
 80108ae:	4798      	blx	r3
}
 80108b0:	bf00      	nop
 80108b2:	3708      	adds	r7, #8
 80108b4:	46bd      	mov	sp, r7
 80108b6:	bd80      	pop	{r7, pc}
 80108b8:	20000400 	.word	0x20000400

080108bc <uart_putc>:
#define UART_QUEUE_REC_DELAY   5

STATIC UINT32 g_uartQueue;

INT32 uart_putc(CHAR c)
{
 80108bc:	b580      	push	{r7, lr}
 80108be:	b082      	sub	sp, #8
 80108c0:	af00      	add	r7, sp, #0
 80108c2:	4603      	mov	r3, r0
 80108c4:	71fb      	strb	r3, [r7, #7]
    return uart_write(&c, 1, 0);
 80108c6:	1dfb      	adds	r3, r7, #7
 80108c8:	2200      	movs	r2, #0
 80108ca:	2101      	movs	r1, #1
 80108cc:	4618      	mov	r0, r3
 80108ce:	f000 f881 	bl	80109d4 <uart_write>
 80108d2:	4603      	mov	r3, r0
}
 80108d4:	4618      	mov	r0, r3
 80108d6:	3708      	adds	r7, #8
 80108d8:	46bd      	mov	sp, r7
 80108da:	bd80      	pop	{r7, pc}

080108dc <uart_getc>:

UINT8 uart_getc(VOID)
{
 80108dc:	b580      	push	{r7, lr}
 80108de:	b082      	sub	sp, #8
 80108e0:	af00      	add	r7, sp, #0
 80108e2:	4b11      	ldr	r3, [pc, #68]	; (8010928 <uart_getc+0x4c>)
 80108e4:	681b      	ldr	r3, [r3, #0]
 80108e6:	607b      	str	r3, [r7, #4]
 80108e8:	f04f 0300 	mov.w	r3, #0
    UINT8 ch = 0;
 80108ec:	2300      	movs	r3, #0
 80108ee:	70fb      	strb	r3, [r7, #3]
    if (g_genericUart.uartReadChar != NULL) {
 80108f0:	4b0e      	ldr	r3, [pc, #56]	; (801092c <uart_getc+0x50>)
 80108f2:	689b      	ldr	r3, [r3, #8]
 80108f4:	2b00      	cmp	r3, #0
 80108f6:	d004      	beq.n	8010902 <uart_getc+0x26>
        ch = g_genericUart.uartReadChar();
 80108f8:	4b0c      	ldr	r3, [pc, #48]	; (801092c <uart_getc+0x50>)
 80108fa:	689b      	ldr	r3, [r3, #8]
 80108fc:	4798      	blx	r3
 80108fe:	4603      	mov	r3, r0
 8010900:	70fb      	strb	r3, [r7, #3]
    }
    (VOID)LOS_QueueWriteCopy(g_uartQueue, &ch, sizeof(UINT8), 0);
 8010902:	4b0b      	ldr	r3, [pc, #44]	; (8010930 <uart_getc+0x54>)
 8010904:	6818      	ldr	r0, [r3, #0]
 8010906:	1cf9      	adds	r1, r7, #3
 8010908:	2300      	movs	r3, #0
 801090a:	2201      	movs	r2, #1
 801090c:	f7fa fbc4 	bl	800b098 <LOS_QueueWriteCopy>
    return ch;
 8010910:	78fb      	ldrb	r3, [r7, #3]
}
 8010912:	4a05      	ldr	r2, [pc, #20]	; (8010928 <uart_getc+0x4c>)
 8010914:	6811      	ldr	r1, [r2, #0]
 8010916:	687a      	ldr	r2, [r7, #4]
 8010918:	4051      	eors	r1, r2
 801091a:	d001      	beq.n	8010920 <uart_getc+0x44>
 801091c:	f7f3 fe5e 	bl	80045dc <__stack_chk_fail>
 8010920:	4618      	mov	r0, r3
 8010922:	3708      	adds	r7, #8
 8010924:	46bd      	mov	sp, r7
 8010926:	bd80      	pop	{r7, pc}
 8010928:	080217f8 	.word	0x080217f8
 801092c:	20000414 	.word	0x20000414
 8010930:	20003288 	.word	0x20003288

08010934 <ShellQueueCreat>:
        g_genericUart.uartInit();
    }
}

INT32 ShellQueueCreat(VOID)
{
 8010934:	b580      	push	{r7, lr}
 8010936:	b082      	sub	sp, #8
 8010938:	af02      	add	r7, sp, #8
    return (INT32)LOS_QueueCreate("uartQueue", UART_QUEUE_SIZE, &g_uartQueue, 0, UART_QUEUE_BUF_MAX_LEN);
 801093a:	2301      	movs	r3, #1
 801093c:	9300      	str	r3, [sp, #0]
 801093e:	2300      	movs	r3, #0
 8010940:	4a04      	ldr	r2, [pc, #16]	; (8010954 <ShellQueueCreat+0x20>)
 8010942:	2140      	movs	r1, #64	; 0x40
 8010944:	4804      	ldr	r0, [pc, #16]	; (8010958 <ShellQueueCreat+0x24>)
 8010946:	f7fa f867 	bl	800aa18 <LOS_QueueCreate>
 801094a:	4603      	mov	r3, r0
}
 801094c:	4618      	mov	r0, r3
 801094e:	46bd      	mov	sp, r7
 8010950:	bd80      	pop	{r7, pc}
 8010952:	bf00      	nop
 8010954:	20003288 	.word	0x20003288
 8010958:	080217fc 	.word	0x080217fc

0801095c <uart_hwiCreate>:

INT32 uart_hwiCreate(VOID)
{
 801095c:	b580      	push	{r7, lr}
 801095e:	af00      	add	r7, sp, #0
    if (g_genericUart.uartHwiCreate != NULL) {
 8010960:	4b04      	ldr	r3, [pc, #16]	; (8010974 <uart_hwiCreate+0x18>)
 8010962:	68db      	ldr	r3, [r3, #12]
 8010964:	2b00      	cmp	r3, #0
 8010966:	d002      	beq.n	801096e <uart_hwiCreate+0x12>
        g_genericUart.uartHwiCreate();
 8010968:	4b02      	ldr	r3, [pc, #8]	; (8010974 <uart_hwiCreate+0x18>)
 801096a:	68db      	ldr	r3, [r3, #12]
 801096c:	4798      	blx	r3
    }
    return LOS_OK;
 801096e:	2300      	movs	r3, #0
}
 8010970:	4618      	mov	r0, r3
 8010972:	bd80      	pop	{r7, pc}
 8010974:	20000414 	.word	0x20000414

08010978 <uart_read>:

UINT8 uart_read(VOID)
{
 8010978:	b580      	push	{r7, lr}
 801097a:	b084      	sub	sp, #16
 801097c:	af00      	add	r7, sp, #0
 801097e:	4b13      	ldr	r3, [pc, #76]	; (80109cc <uart_read+0x54>)
 8010980:	681b      	ldr	r3, [r3, #0]
 8010982:	60fb      	str	r3, [r7, #12]
 8010984:	f04f 0300 	mov.w	r3, #0
    UINT8 rec = 0;
 8010988:	2300      	movs	r3, #0
 801098a:	70fb      	strb	r3, [r7, #3]
    UINT32 ret;
    UINT32 len;
    len = UART_QUEUE_BUF_MAX_LEN;
 801098c:	2301      	movs	r3, #1
 801098e:	607b      	str	r3, [r7, #4]
    ret = LOS_QueueReadCopy(g_uartQueue, &rec, &len, LOS_WAIT_FOREVER);
 8010990:	4b0f      	ldr	r3, [pc, #60]	; (80109d0 <uart_read+0x58>)
 8010992:	6818      	ldr	r0, [r3, #0]
 8010994:	1d3a      	adds	r2, r7, #4
 8010996:	1cf9      	adds	r1, r7, #3
 8010998:	f04f 33ff 	mov.w	r3, #4294967295
 801099c:	f7fa fb5a 	bl	800b054 <LOS_QueueReadCopy>
 80109a0:	60b8      	str	r0, [r7, #8]
    if (ret == LOS_OK) {
 80109a2:	68bb      	ldr	r3, [r7, #8]
 80109a4:	2b00      	cmp	r3, #0
 80109a6:	d104      	bne.n	80109b2 <uart_read+0x3a>
        (VOID)LOS_TaskDelay(UART_QUEUE_REC_DELAY);
 80109a8:	2005      	movs	r0, #5
 80109aa:	f7f3 fa7b 	bl	8003ea4 <LOS_TaskDelay>
        return rec;
 80109ae:	78fb      	ldrb	r3, [r7, #3]
 80109b0:	e000      	b.n	80109b4 <uart_read+0x3c>
    }
    return rec;
 80109b2:	78fb      	ldrb	r3, [r7, #3]
}
 80109b4:	4a05      	ldr	r2, [pc, #20]	; (80109cc <uart_read+0x54>)
 80109b6:	6811      	ldr	r1, [r2, #0]
 80109b8:	68fa      	ldr	r2, [r7, #12]
 80109ba:	4051      	eors	r1, r2
 80109bc:	d001      	beq.n	80109c2 <uart_read+0x4a>
 80109be:	f7f3 fe0d 	bl	80045dc <__stack_chk_fail>
 80109c2:	4618      	mov	r0, r3
 80109c4:	3710      	adds	r7, #16
 80109c6:	46bd      	mov	sp, r7
 80109c8:	bd80      	pop	{r7, pc}
 80109ca:	bf00      	nop
 80109cc:	08021808 	.word	0x08021808
 80109d0:	20003288 	.word	0x20003288

080109d4 <uart_write>:

INT32 uart_write(const CHAR *buf, INT32 len, INT32 timeout)
{
 80109d4:	b580      	push	{r7, lr}
 80109d6:	b086      	sub	sp, #24
 80109d8:	af00      	add	r7, sp, #0
 80109da:	60f8      	str	r0, [r7, #12]
 80109dc:	60b9      	str	r1, [r7, #8]
 80109de:	607a      	str	r2, [r7, #4]
    (VOID)timeout;
    UINT32 i;
    for (i = 0; i < len; i++) {  
 80109e0:	2300      	movs	r3, #0
 80109e2:	617b      	str	r3, [r7, #20]
 80109e4:	e00e      	b.n	8010a04 <uart_write+0x30>
        if (g_genericUart.uartWriteChar != NULL) {
 80109e6:	4b0c      	ldr	r3, [pc, #48]	; (8010a18 <uart_write+0x44>)
 80109e8:	685b      	ldr	r3, [r3, #4]
 80109ea:	2b00      	cmp	r3, #0
 80109ec:	d007      	beq.n	80109fe <uart_write+0x2a>
            g_genericUart.uartWriteChar(buf[i]);
 80109ee:	4b0a      	ldr	r3, [pc, #40]	; (8010a18 <uart_write+0x44>)
 80109f0:	685b      	ldr	r3, [r3, #4]
 80109f2:	68f9      	ldr	r1, [r7, #12]
 80109f4:	697a      	ldr	r2, [r7, #20]
 80109f6:	440a      	add	r2, r1
 80109f8:	7812      	ldrb	r2, [r2, #0]
 80109fa:	4610      	mov	r0, r2
 80109fc:	4798      	blx	r3
    for (i = 0; i < len; i++) {  
 80109fe:	697b      	ldr	r3, [r7, #20]
 8010a00:	3301      	adds	r3, #1
 8010a02:	617b      	str	r3, [r7, #20]
 8010a04:	68bb      	ldr	r3, [r7, #8]
 8010a06:	697a      	ldr	r2, [r7, #20]
 8010a08:	429a      	cmp	r2, r3
 8010a0a:	d3ec      	bcc.n	80109e6 <uart_write+0x12>
        }
    }
    return len;
 8010a0c:	68bb      	ldr	r3, [r7, #8]
}
 8010a0e:	4618      	mov	r0, r3
 8010a10:	3718      	adds	r7, #24
 8010a12:	46bd      	mov	sp, r7
 8010a14:	bd80      	pop	{r7, pc}
 8010a16:	bf00      	nop
 8010a18:	20000414 	.word	0x20000414

08010a1c <UartPuts>:

VOID UartPuts(const CHAR *s, UINT32 len, BOOL isLock)
{
 8010a1c:	b580      	push	{r7, lr}
 8010a1e:	b086      	sub	sp, #24
 8010a20:	af00      	add	r7, sp, #0
 8010a22:	60f8      	str	r0, [r7, #12]
 8010a24:	60b9      	str	r1, [r7, #8]
 8010a26:	607a      	str	r2, [r7, #4]
    UINT32 i;
    (VOID)isLock;
    if (s == NULL) {
 8010a28:	68fb      	ldr	r3, [r7, #12]
 8010a2a:	2b00      	cmp	r3, #0
 8010a2c:	d01a      	beq.n	8010a64 <UartPuts+0x48>
        return;
    }
    for (i = 0; i < len; i++) {
 8010a2e:	2300      	movs	r3, #0
 8010a30:	617b      	str	r3, [r7, #20]
 8010a32:	e012      	b.n	8010a5a <UartPuts+0x3e>
        /*
         * Only system uart output needs to add extra '\r' to improve
         * the compatibility.
         */
        if (*(s + i) == '\n') {
 8010a34:	68fa      	ldr	r2, [r7, #12]
 8010a36:	697b      	ldr	r3, [r7, #20]
 8010a38:	4413      	add	r3, r2
 8010a3a:	781b      	ldrb	r3, [r3, #0]
 8010a3c:	2b0a      	cmp	r3, #10
 8010a3e:	d102      	bne.n	8010a46 <UartPuts+0x2a>
            (VOID)uart_putc('\r');
 8010a40:	200d      	movs	r0, #13
 8010a42:	f7ff ff3b 	bl	80108bc <uart_putc>
        }
        (VOID)uart_putc(*(s + i));
 8010a46:	68fa      	ldr	r2, [r7, #12]
 8010a48:	697b      	ldr	r3, [r7, #20]
 8010a4a:	4413      	add	r3, r2
 8010a4c:	781b      	ldrb	r3, [r3, #0]
 8010a4e:	4618      	mov	r0, r3
 8010a50:	f7ff ff34 	bl	80108bc <uart_putc>
    for (i = 0; i < len; i++) {
 8010a54:	697b      	ldr	r3, [r7, #20]
 8010a56:	3301      	adds	r3, #1
 8010a58:	617b      	str	r3, [r7, #20]
 8010a5a:	697a      	ldr	r2, [r7, #20]
 8010a5c:	68bb      	ldr	r3, [r7, #8]
 8010a5e:	429a      	cmp	r2, r3
 8010a60:	d3e8      	bcc.n	8010a34 <UartPuts+0x18>
 8010a62:	e000      	b.n	8010a66 <UartPuts+0x4a>
        return;
 8010a64:	bf00      	nop
    }
}
 8010a66:	3718      	adds	r7, #24
 8010a68:	46bd      	mov	sp, r7
 8010a6a:	bd80      	pop	{r7, pc}

08010a6c <uart_init>:

VOID uart_init(VOID) 
{
 8010a6c:	b480      	push	{r7}
 8010a6e:	af00      	add	r7, sp, #0
}
 8010a70:	bf00      	nop
 8010a72:	46bd      	mov	sp, r7
 8010a74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010a78:	4770      	bx	lr

08010a7a <LOS_IntLock>:
{
 8010a7a:	b580      	push	{r7, lr}
 8010a7c:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8010a7e:	f7f0 f923 	bl	8000cc8 <ArchIntLock>
 8010a82:	4603      	mov	r3, r0
}
 8010a84:	4618      	mov	r0, r3
 8010a86:	bd80      	pop	{r7, pc}

08010a88 <LOS_IntRestore>:
{
 8010a88:	b580      	push	{r7, lr}
 8010a8a:	b082      	sub	sp, #8
 8010a8c:	af00      	add	r7, sp, #0
 8010a8e:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8010a90:	6878      	ldr	r0, [r7, #4]
 8010a92:	f7f0 f921 	bl	8000cd8 <ArchIntRestore>
}
 8010a96:	bf00      	nop
 8010a98:	3708      	adds	r7, #8
 8010a9a:	46bd      	mov	sp, r7
 8010a9c:	bd80      	pop	{r7, pc}

08010a9e <LOS_SpinLockSave>:
{
 8010a9e:	b580      	push	{r7, lr}
 8010aa0:	b082      	sub	sp, #8
 8010aa2:	af00      	add	r7, sp, #0
 8010aa4:	6078      	str	r0, [r7, #4]
 8010aa6:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8010aa8:	f7ff ffe7 	bl	8010a7a <LOS_IntLock>
 8010aac:	4602      	mov	r2, r0
 8010aae:	683b      	ldr	r3, [r7, #0]
 8010ab0:	601a      	str	r2, [r3, #0]
}
 8010ab2:	bf00      	nop
 8010ab4:	3708      	adds	r7, #8
 8010ab6:	46bd      	mov	sp, r7
 8010ab8:	bd80      	pop	{r7, pc}

08010aba <LOS_SpinUnlockRestore>:
{
 8010aba:	b580      	push	{r7, lr}
 8010abc:	b082      	sub	sp, #8
 8010abe:	af00      	add	r7, sp, #0
 8010ac0:	6078      	str	r0, [r7, #4]
 8010ac2:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8010ac4:	6838      	ldr	r0, [r7, #0]
 8010ac6:	f7ff ffdf 	bl	8010a88 <LOS_IntRestore>
}
 8010aca:	bf00      	nop
 8010acc:	3708      	adds	r7, #8
 8010ace:	46bd      	mov	sp, r7
 8010ad0:	bd80      	pop	{r7, pc}
	...

08010ad4 <OsLockConsole>:
    "INFO",
    "DEBUG"
};

STATIC VOID OsLockConsole(VOID)
{
 8010ad4:	b480      	push	{r7}
 8010ad6:	af00      	add	r7, sp, #0
    g_consoleLock = 1;
 8010ad8:	4b03      	ldr	r3, [pc, #12]	; (8010ae8 <OsLockConsole+0x14>)
 8010ada:	2201      	movs	r2, #1
 8010adc:	601a      	str	r2, [r3, #0]
}
 8010ade:	bf00      	nop
 8010ae0:	46bd      	mov	sp, r7
 8010ae2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ae6:	4770      	bx	lr
 8010ae8:	2000329c 	.word	0x2000329c

08010aec <OsUnlockConsole>:

STATIC VOID OsUnlockConsole(VOID)
{
 8010aec:	b480      	push	{r7}
 8010aee:	af00      	add	r7, sp, #0
    g_consoleLock = 0;
 8010af0:	4b03      	ldr	r3, [pc, #12]	; (8010b00 <OsUnlockConsole+0x14>)
 8010af2:	2200      	movs	r2, #0
 8010af4:	601a      	str	r2, [r3, #0]
}
 8010af6:	bf00      	nop
 8010af8:	46bd      	mov	sp, r7
 8010afa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010afe:	4770      	bx	lr
 8010b00:	2000329c 	.word	0x2000329c

08010b04 <OsLockUart>:

STATIC VOID OsLockUart(VOID)
{
 8010b04:	b480      	push	{r7}
 8010b06:	af00      	add	r7, sp, #0
    g_uartLock = 1;
 8010b08:	4b03      	ldr	r3, [pc, #12]	; (8010b18 <OsLockUart+0x14>)
 8010b0a:	2201      	movs	r2, #1
 8010b0c:	601a      	str	r2, [r3, #0]
}
 8010b0e:	bf00      	nop
 8010b10:	46bd      	mov	sp, r7
 8010b12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010b16:	4770      	bx	lr
 8010b18:	200032a0 	.word	0x200032a0

08010b1c <OsUnlockUart>:

STATIC VOID OsUnlockUart(VOID)
{
 8010b1c:	b480      	push	{r7}
 8010b1e:	af00      	add	r7, sp, #0
    g_uartLock = 0;
 8010b20:	4b03      	ldr	r3, [pc, #12]	; (8010b30 <OsUnlockUart+0x14>)
 8010b22:	2200      	movs	r2, #0
 8010b24:	601a      	str	r2, [r3, #0]
}
 8010b26:	bf00      	nop
 8010b28:	46bd      	mov	sp, r7
 8010b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010b2e:	4770      	bx	lr
 8010b30:	200032a0 	.word	0x200032a0

08010b34 <OsCheckError>:

STATIC UINT32 OsCheckError(VOID)
{
 8010b34:	b480      	push	{r7}
 8010b36:	af00      	add	r7, sp, #0
    if (g_dmesgInfo == NULL) {
 8010b38:	4b15      	ldr	r3, [pc, #84]	; (8010b90 <OsCheckError+0x5c>)
 8010b3a:	681b      	ldr	r3, [r3, #0]
 8010b3c:	2b00      	cmp	r3, #0
 8010b3e:	d101      	bne.n	8010b44 <OsCheckError+0x10>
        return LOS_NOK;
 8010b40:	2301      	movs	r3, #1
 8010b42:	e01f      	b.n	8010b84 <OsCheckError+0x50>
    }

    if (g_dmesgInfo->logSize > g_logBufSize) {
 8010b44:	4b12      	ldr	r3, [pc, #72]	; (8010b90 <OsCheckError+0x5c>)
 8010b46:	681b      	ldr	r3, [r3, #0]
 8010b48:	681a      	ldr	r2, [r3, #0]
 8010b4a:	4b12      	ldr	r3, [pc, #72]	; (8010b94 <OsCheckError+0x60>)
 8010b4c:	681b      	ldr	r3, [r3, #0]
 8010b4e:	429a      	cmp	r2, r3
 8010b50:	d901      	bls.n	8010b56 <OsCheckError+0x22>
        return LOS_NOK;
 8010b52:	2301      	movs	r3, #1
 8010b54:	e016      	b.n	8010b84 <OsCheckError+0x50>
    }

    if (((g_dmesgInfo->logSize == g_logBufSize) || (g_dmesgInfo->logSize == 0)) &&
 8010b56:	4b0e      	ldr	r3, [pc, #56]	; (8010b90 <OsCheckError+0x5c>)
 8010b58:	681b      	ldr	r3, [r3, #0]
 8010b5a:	681a      	ldr	r2, [r3, #0]
 8010b5c:	4b0d      	ldr	r3, [pc, #52]	; (8010b94 <OsCheckError+0x60>)
 8010b5e:	681b      	ldr	r3, [r3, #0]
 8010b60:	429a      	cmp	r2, r3
 8010b62:	d004      	beq.n	8010b6e <OsCheckError+0x3a>
 8010b64:	4b0a      	ldr	r3, [pc, #40]	; (8010b90 <OsCheckError+0x5c>)
 8010b66:	681b      	ldr	r3, [r3, #0]
 8010b68:	681b      	ldr	r3, [r3, #0]
 8010b6a:	2b00      	cmp	r3, #0
 8010b6c:	d109      	bne.n	8010b82 <OsCheckError+0x4e>
        (g_dmesgInfo->logTail != g_dmesgInfo->logHead)) {
 8010b6e:	4b08      	ldr	r3, [pc, #32]	; (8010b90 <OsCheckError+0x5c>)
 8010b70:	681b      	ldr	r3, [r3, #0]
 8010b72:	689a      	ldr	r2, [r3, #8]
 8010b74:	4b06      	ldr	r3, [pc, #24]	; (8010b90 <OsCheckError+0x5c>)
 8010b76:	681b      	ldr	r3, [r3, #0]
 8010b78:	685b      	ldr	r3, [r3, #4]
    if (((g_dmesgInfo->logSize == g_logBufSize) || (g_dmesgInfo->logSize == 0)) &&
 8010b7a:	429a      	cmp	r2, r3
 8010b7c:	d001      	beq.n	8010b82 <OsCheckError+0x4e>
        return LOS_NOK;
 8010b7e:	2301      	movs	r3, #1
 8010b80:	e000      	b.n	8010b84 <OsCheckError+0x50>
    }

    return LOS_OK;
 8010b82:	2300      	movs	r3, #0
}
 8010b84:	4618      	mov	r0, r3
 8010b86:	46bd      	mov	sp, r7
 8010b88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010b8c:	4770      	bx	lr
 8010b8e:	bf00      	nop
 8010b90:	20003290 	.word	0x20003290
 8010b94:	20003294 	.word	0x20003294

08010b98 <OsDmesgRead>:

STATIC INT32 OsDmesgRead(CHAR *buf, UINT32 len)
{
 8010b98:	b580      	push	{r7, lr}
 8010b9a:	b088      	sub	sp, #32
 8010b9c:	af00      	add	r7, sp, #0
 8010b9e:	6078      	str	r0, [r7, #4]
 8010ba0:	6039      	str	r1, [r7, #0]
    UINT32 readLen;
    UINT32 logSize = g_dmesgInfo->logSize;
 8010ba2:	4b59      	ldr	r3, [pc, #356]	; (8010d08 <OsDmesgRead+0x170>)
 8010ba4:	681b      	ldr	r3, [r3, #0]
 8010ba6:	681b      	ldr	r3, [r3, #0]
 8010ba8:	60bb      	str	r3, [r7, #8]
    UINT32 head = g_dmesgInfo->logHead;
 8010baa:	4b57      	ldr	r3, [pc, #348]	; (8010d08 <OsDmesgRead+0x170>)
 8010bac:	681b      	ldr	r3, [r3, #0]
 8010bae:	685b      	ldr	r3, [r3, #4]
 8010bb0:	60fb      	str	r3, [r7, #12]
    UINT32 tail = g_dmesgInfo->logTail;
 8010bb2:	4b55      	ldr	r3, [pc, #340]	; (8010d08 <OsDmesgRead+0x170>)
 8010bb4:	681b      	ldr	r3, [r3, #0]
 8010bb6:	689b      	ldr	r3, [r3, #8]
 8010bb8:	613b      	str	r3, [r7, #16]
    CHAR *logBuf = g_dmesgInfo->logBuf;
 8010bba:	4b53      	ldr	r3, [pc, #332]	; (8010d08 <OsDmesgRead+0x170>)
 8010bbc:	681b      	ldr	r3, [r3, #0]
 8010bbe:	68db      	ldr	r3, [r3, #12]
 8010bc0:	617b      	str	r3, [r7, #20]
    errno_t ret;

    if (OsCheckError()) {
 8010bc2:	f7ff ffb7 	bl	8010b34 <OsCheckError>
 8010bc6:	4603      	mov	r3, r0
 8010bc8:	2b00      	cmp	r3, #0
 8010bca:	d002      	beq.n	8010bd2 <OsDmesgRead+0x3a>
        return -1;
 8010bcc:	f04f 33ff 	mov.w	r3, #4294967295
 8010bd0:	e096      	b.n	8010d00 <OsDmesgRead+0x168>
    }
    if (logSize == 0) {
 8010bd2:	68bb      	ldr	r3, [r7, #8]
 8010bd4:	2b00      	cmp	r3, #0
 8010bd6:	d101      	bne.n	8010bdc <OsDmesgRead+0x44>
        return 0;
 8010bd8:	2300      	movs	r3, #0
 8010bda:	e091      	b.n	8010d00 <OsDmesgRead+0x168>
    }

    readLen = len < logSize ? len : logSize;
 8010bdc:	68ba      	ldr	r2, [r7, #8]
 8010bde:	683b      	ldr	r3, [r7, #0]
 8010be0:	4293      	cmp	r3, r2
 8010be2:	bf28      	it	cs
 8010be4:	4613      	movcs	r3, r2
 8010be6:	61bb      	str	r3, [r7, #24]

    if (head < tail) { /* Case A */
 8010be8:	68fa      	ldr	r2, [r7, #12]
 8010bea:	693b      	ldr	r3, [r7, #16]
 8010bec:	429a      	cmp	r2, r3
 8010bee:	d21f      	bcs.n	8010c30 <OsDmesgRead+0x98>
        ret = memcpy_s(buf, len, logBuf + head, readLen);
 8010bf0:	697a      	ldr	r2, [r7, #20]
 8010bf2:	68fb      	ldr	r3, [r7, #12]
 8010bf4:	441a      	add	r2, r3
 8010bf6:	69bb      	ldr	r3, [r7, #24]
 8010bf8:	6839      	ldr	r1, [r7, #0]
 8010bfa:	6878      	ldr	r0, [r7, #4]
 8010bfc:	f006 fa4c 	bl	8017098 <memcpy_s>
 8010c00:	61f8      	str	r0, [r7, #28]
        if (ret != EOK) {
 8010c02:	69fb      	ldr	r3, [r7, #28]
 8010c04:	2b00      	cmp	r3, #0
 8010c06:	d002      	beq.n	8010c0e <OsDmesgRead+0x76>
            return -1;
 8010c08:	f04f 33ff 	mov.w	r3, #4294967295
 8010c0c:	e078      	b.n	8010d00 <OsDmesgRead+0x168>
        }
        g_dmesgInfo->logHead += readLen;
 8010c0e:	4b3e      	ldr	r3, [pc, #248]	; (8010d08 <OsDmesgRead+0x170>)
 8010c10:	681b      	ldr	r3, [r3, #0]
 8010c12:	6859      	ldr	r1, [r3, #4]
 8010c14:	4b3c      	ldr	r3, [pc, #240]	; (8010d08 <OsDmesgRead+0x170>)
 8010c16:	681b      	ldr	r3, [r3, #0]
 8010c18:	69ba      	ldr	r2, [r7, #24]
 8010c1a:	440a      	add	r2, r1
 8010c1c:	605a      	str	r2, [r3, #4]
        g_dmesgInfo->logSize -= readLen;
 8010c1e:	4b3a      	ldr	r3, [pc, #232]	; (8010d08 <OsDmesgRead+0x170>)
 8010c20:	681b      	ldr	r3, [r3, #0]
 8010c22:	6819      	ldr	r1, [r3, #0]
 8010c24:	4b38      	ldr	r3, [pc, #224]	; (8010d08 <OsDmesgRead+0x170>)
 8010c26:	681b      	ldr	r3, [r3, #0]
 8010c28:	69ba      	ldr	r2, [r7, #24]
 8010c2a:	1a8a      	subs	r2, r1, r2
 8010c2c:	601a      	str	r2, [r3, #0]
 8010c2e:	e066      	b.n	8010cfe <OsDmesgRead+0x166>
    } else { /* Case B */
        if (readLen <= (g_logBufSize - head)) {
 8010c30:	4b36      	ldr	r3, [pc, #216]	; (8010d0c <OsDmesgRead+0x174>)
 8010c32:	681a      	ldr	r2, [r3, #0]
 8010c34:	68fb      	ldr	r3, [r7, #12]
 8010c36:	1ad3      	subs	r3, r2, r3
 8010c38:	69ba      	ldr	r2, [r7, #24]
 8010c3a:	429a      	cmp	r2, r3
 8010c3c:	d81f      	bhi.n	8010c7e <OsDmesgRead+0xe6>
            ret = memcpy_s(buf, len, logBuf + head, readLen);
 8010c3e:	697a      	ldr	r2, [r7, #20]
 8010c40:	68fb      	ldr	r3, [r7, #12]
 8010c42:	441a      	add	r2, r3
 8010c44:	69bb      	ldr	r3, [r7, #24]
 8010c46:	6839      	ldr	r1, [r7, #0]
 8010c48:	6878      	ldr	r0, [r7, #4]
 8010c4a:	f006 fa25 	bl	8017098 <memcpy_s>
 8010c4e:	61f8      	str	r0, [r7, #28]
            if (ret != EOK) {
 8010c50:	69fb      	ldr	r3, [r7, #28]
 8010c52:	2b00      	cmp	r3, #0
 8010c54:	d002      	beq.n	8010c5c <OsDmesgRead+0xc4>
                return -1;
 8010c56:	f04f 33ff 	mov.w	r3, #4294967295
 8010c5a:	e051      	b.n	8010d00 <OsDmesgRead+0x168>
            }
            g_dmesgInfo->logHead += readLen;
 8010c5c:	4b2a      	ldr	r3, [pc, #168]	; (8010d08 <OsDmesgRead+0x170>)
 8010c5e:	681b      	ldr	r3, [r3, #0]
 8010c60:	6859      	ldr	r1, [r3, #4]
 8010c62:	4b29      	ldr	r3, [pc, #164]	; (8010d08 <OsDmesgRead+0x170>)
 8010c64:	681b      	ldr	r3, [r3, #0]
 8010c66:	69ba      	ldr	r2, [r7, #24]
 8010c68:	440a      	add	r2, r1
 8010c6a:	605a      	str	r2, [r3, #4]
            g_dmesgInfo->logSize -= readLen;
 8010c6c:	4b26      	ldr	r3, [pc, #152]	; (8010d08 <OsDmesgRead+0x170>)
 8010c6e:	681b      	ldr	r3, [r3, #0]
 8010c70:	6819      	ldr	r1, [r3, #0]
 8010c72:	4b25      	ldr	r3, [pc, #148]	; (8010d08 <OsDmesgRead+0x170>)
 8010c74:	681b      	ldr	r3, [r3, #0]
 8010c76:	69ba      	ldr	r2, [r7, #24]
 8010c78:	1a8a      	subs	r2, r1, r2
 8010c7a:	601a      	str	r2, [r3, #0]
 8010c7c:	e03f      	b.n	8010cfe <OsDmesgRead+0x166>
        } else {
            ret = memcpy_s(buf, len, logBuf + head, g_logBufSize - head);
 8010c7e:	697a      	ldr	r2, [r7, #20]
 8010c80:	68fb      	ldr	r3, [r7, #12]
 8010c82:	18d1      	adds	r1, r2, r3
 8010c84:	4b21      	ldr	r3, [pc, #132]	; (8010d0c <OsDmesgRead+0x174>)
 8010c86:	681a      	ldr	r2, [r3, #0]
 8010c88:	68fb      	ldr	r3, [r7, #12]
 8010c8a:	1ad3      	subs	r3, r2, r3
 8010c8c:	460a      	mov	r2, r1
 8010c8e:	6839      	ldr	r1, [r7, #0]
 8010c90:	6878      	ldr	r0, [r7, #4]
 8010c92:	f006 fa01 	bl	8017098 <memcpy_s>
 8010c96:	61f8      	str	r0, [r7, #28]
            if (ret != EOK) {
 8010c98:	69fb      	ldr	r3, [r7, #28]
 8010c9a:	2b00      	cmp	r3, #0
 8010c9c:	d002      	beq.n	8010ca4 <OsDmesgRead+0x10c>
                return -1;
 8010c9e:	f04f 33ff 	mov.w	r3, #4294967295
 8010ca2:	e02d      	b.n	8010d00 <OsDmesgRead+0x168>
            }

            ret = memcpy_s(buf + g_logBufSize - head, len - (g_logBufSize - head),
 8010ca4:	4b19      	ldr	r3, [pc, #100]	; (8010d0c <OsDmesgRead+0x174>)
 8010ca6:	681a      	ldr	r2, [r3, #0]
 8010ca8:	68fb      	ldr	r3, [r7, #12]
 8010caa:	1ad3      	subs	r3, r2, r3
 8010cac:	687a      	ldr	r2, [r7, #4]
 8010cae:	18d0      	adds	r0, r2, r3
 8010cb0:	4b16      	ldr	r3, [pc, #88]	; (8010d0c <OsDmesgRead+0x174>)
 8010cb2:	681b      	ldr	r3, [r3, #0]
 8010cb4:	68fa      	ldr	r2, [r7, #12]
 8010cb6:	1ad2      	subs	r2, r2, r3
 8010cb8:	683b      	ldr	r3, [r7, #0]
 8010cba:	18d1      	adds	r1, r2, r3
                           logBuf, readLen - (g_logBufSize - head));
 8010cbc:	4b13      	ldr	r3, [pc, #76]	; (8010d0c <OsDmesgRead+0x174>)
 8010cbe:	681b      	ldr	r3, [r3, #0]
 8010cc0:	68fa      	ldr	r2, [r7, #12]
 8010cc2:	1ad2      	subs	r2, r2, r3
            ret = memcpy_s(buf + g_logBufSize - head, len - (g_logBufSize - head),
 8010cc4:	69bb      	ldr	r3, [r7, #24]
 8010cc6:	4413      	add	r3, r2
 8010cc8:	697a      	ldr	r2, [r7, #20]
 8010cca:	f006 f9e5 	bl	8017098 <memcpy_s>
 8010cce:	61f8      	str	r0, [r7, #28]
            if (ret != EOK) {
 8010cd0:	69fb      	ldr	r3, [r7, #28]
 8010cd2:	2b00      	cmp	r3, #0
 8010cd4:	d002      	beq.n	8010cdc <OsDmesgRead+0x144>
                return -1;
 8010cd6:	f04f 33ff 	mov.w	r3, #4294967295
 8010cda:	e011      	b.n	8010d00 <OsDmesgRead+0x168>
            }
            g_dmesgInfo->logHead = readLen - (g_logBufSize - head);
 8010cdc:	4b0b      	ldr	r3, [pc, #44]	; (8010d0c <OsDmesgRead+0x174>)
 8010cde:	681b      	ldr	r3, [r3, #0]
 8010ce0:	68fa      	ldr	r2, [r7, #12]
 8010ce2:	1ad1      	subs	r1, r2, r3
 8010ce4:	4b08      	ldr	r3, [pc, #32]	; (8010d08 <OsDmesgRead+0x170>)
 8010ce6:	681b      	ldr	r3, [r3, #0]
 8010ce8:	69ba      	ldr	r2, [r7, #24]
 8010cea:	440a      	add	r2, r1
 8010cec:	605a      	str	r2, [r3, #4]
            g_dmesgInfo->logSize -= readLen;
 8010cee:	4b06      	ldr	r3, [pc, #24]	; (8010d08 <OsDmesgRead+0x170>)
 8010cf0:	681b      	ldr	r3, [r3, #0]
 8010cf2:	6819      	ldr	r1, [r3, #0]
 8010cf4:	4b04      	ldr	r3, [pc, #16]	; (8010d08 <OsDmesgRead+0x170>)
 8010cf6:	681b      	ldr	r3, [r3, #0]
 8010cf8:	69ba      	ldr	r2, [r7, #24]
 8010cfa:	1a8a      	subs	r2, r1, r2
 8010cfc:	601a      	str	r2, [r3, #0]
        }
    }
    return (INT32)readLen;
 8010cfe:	69bb      	ldr	r3, [r7, #24]
}
 8010d00:	4618      	mov	r0, r3
 8010d02:	3720      	adds	r7, #32
 8010d04:	46bd      	mov	sp, r7
 8010d06:	bd80      	pop	{r7, pc}
 8010d08:	20003290 	.word	0x20003290
 8010d0c:	20003294 	.word	0x20003294

08010d10 <OsCopyToNew>:

STATIC INT32 OsCopyToNew(VOID *addr, UINT32 size)
{
 8010d10:	b580      	push	{r7, lr}
 8010d12:	b088      	sub	sp, #32
 8010d14:	af00      	add	r7, sp, #0
 8010d16:	6078      	str	r0, [r7, #4]
 8010d18:	6039      	str	r1, [r7, #0]
    UINT32 copyStart = 0;
 8010d1a:	2300      	movs	r3, #0
 8010d1c:	60bb      	str	r3, [r7, #8]
    UINT32 copyLen;
    CHAR *temp = NULL;
 8010d1e:	2300      	movs	r3, #0
 8010d20:	60fb      	str	r3, [r7, #12]
    CHAR *newBuf = (CHAR *)addr + sizeof(DmesgInfo);
 8010d22:	687b      	ldr	r3, [r7, #4]
 8010d24:	3310      	adds	r3, #16
 8010d26:	613b      	str	r3, [r7, #16]
    UINT32 bufSize = size - sizeof(DmesgInfo);
 8010d28:	683b      	ldr	r3, [r7, #0]
 8010d2a:	3b10      	subs	r3, #16
 8010d2c:	617b      	str	r3, [r7, #20]
    INT32 ret;

    if (g_dmesgInfo->logSize == 0) {
 8010d2e:	4b37      	ldr	r3, [pc, #220]	; (8010e0c <OsCopyToNew+0xfc>)
 8010d30:	681b      	ldr	r3, [r3, #0]
 8010d32:	681b      	ldr	r3, [r3, #0]
 8010d34:	2b00      	cmp	r3, #0
 8010d36:	d101      	bne.n	8010d3c <OsCopyToNew+0x2c>
        return 0;
 8010d38:	2300      	movs	r3, #0
 8010d3a:	e063      	b.n	8010e04 <OsCopyToNew+0xf4>
    }

    temp = (CHAR *)malloc(g_dmesgInfo->logSize);
 8010d3c:	4b33      	ldr	r3, [pc, #204]	; (8010e0c <OsCopyToNew+0xfc>)
 8010d3e:	681b      	ldr	r3, [r3, #0]
 8010d40:	681b      	ldr	r3, [r3, #0]
 8010d42:	4618      	mov	r0, r3
 8010d44:	f009 fe70 	bl	801aa28 <malloc>
 8010d48:	60f8      	str	r0, [r7, #12]
    if (temp == NULL) {
 8010d4a:	68fb      	ldr	r3, [r7, #12]
 8010d4c:	2b00      	cmp	r3, #0
 8010d4e:	d102      	bne.n	8010d56 <OsCopyToNew+0x46>
        return -1;
 8010d50:	f04f 33ff 	mov.w	r3, #4294967295
 8010d54:	e056      	b.n	8010e04 <OsCopyToNew+0xf4>
    }

    (VOID)memset_s(temp, g_dmesgInfo->logSize, 0, g_dmesgInfo->logSize);
 8010d56:	4b2d      	ldr	r3, [pc, #180]	; (8010e0c <OsCopyToNew+0xfc>)
 8010d58:	681b      	ldr	r3, [r3, #0]
 8010d5a:	6819      	ldr	r1, [r3, #0]
 8010d5c:	4b2b      	ldr	r3, [pc, #172]	; (8010e0c <OsCopyToNew+0xfc>)
 8010d5e:	681b      	ldr	r3, [r3, #0]
 8010d60:	681b      	ldr	r3, [r3, #0]
 8010d62:	2200      	movs	r2, #0
 8010d64:	68f8      	ldr	r0, [r7, #12]
 8010d66:	f7f1 f99d 	bl	80020a4 <memset_s>
    copyLen = ((bufSize < g_dmesgInfo->logSize) ? bufSize : g_dmesgInfo->logSize);
 8010d6a:	4b28      	ldr	r3, [pc, #160]	; (8010e0c <OsCopyToNew+0xfc>)
 8010d6c:	681b      	ldr	r3, [r3, #0]
 8010d6e:	681b      	ldr	r3, [r3, #0]
 8010d70:	697a      	ldr	r2, [r7, #20]
 8010d72:	4293      	cmp	r3, r2
 8010d74:	bf28      	it	cs
 8010d76:	4613      	movcs	r3, r2
 8010d78:	61bb      	str	r3, [r7, #24]
    if (bufSize < g_dmesgInfo->logSize) {
 8010d7a:	4b24      	ldr	r3, [pc, #144]	; (8010e0c <OsCopyToNew+0xfc>)
 8010d7c:	681b      	ldr	r3, [r3, #0]
 8010d7e:	681b      	ldr	r3, [r3, #0]
 8010d80:	697a      	ldr	r2, [r7, #20]
 8010d82:	429a      	cmp	r2, r3
 8010d84:	d205      	bcs.n	8010d92 <OsCopyToNew+0x82>
        copyStart = g_dmesgInfo->logSize - bufSize;
 8010d86:	4b21      	ldr	r3, [pc, #132]	; (8010e0c <OsCopyToNew+0xfc>)
 8010d88:	681b      	ldr	r3, [r3, #0]
 8010d8a:	681a      	ldr	r2, [r3, #0]
 8010d8c:	697b      	ldr	r3, [r7, #20]
 8010d8e:	1ad3      	subs	r3, r2, r3
 8010d90:	60bb      	str	r3, [r7, #8]
    }

    ret = OsDmesgRead(temp, g_dmesgInfo->logSize);
 8010d92:	4b1e      	ldr	r3, [pc, #120]	; (8010e0c <OsCopyToNew+0xfc>)
 8010d94:	681b      	ldr	r3, [r3, #0]
 8010d96:	681b      	ldr	r3, [r3, #0]
 8010d98:	4619      	mov	r1, r3
 8010d9a:	68f8      	ldr	r0, [r7, #12]
 8010d9c:	f7ff fefc 	bl	8010b98 <OsDmesgRead>
 8010da0:	61f8      	str	r0, [r7, #28]
    if (ret <= 0) {
 8010da2:	69fb      	ldr	r3, [r7, #28]
 8010da4:	2b00      	cmp	r3, #0
 8010da6:	dc0e      	bgt.n	8010dc6 <OsCopyToNew+0xb6>
        PRINT_ERR("%s,%d failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8010da8:	4819      	ldr	r0, [pc, #100]	; (8010e10 <OsCopyToNew+0x100>)
 8010daa:	f7f3 fd89 	bl	80048c0 <dprintf>
 8010dae:	69fb      	ldr	r3, [r7, #28]
 8010db0:	22cd      	movs	r2, #205	; 0xcd
 8010db2:	4918      	ldr	r1, [pc, #96]	; (8010e14 <OsCopyToNew+0x104>)
 8010db4:	4818      	ldr	r0, [pc, #96]	; (8010e18 <OsCopyToNew+0x108>)
 8010db6:	f7f3 fd83 	bl	80048c0 <dprintf>
        free(temp);
 8010dba:	68f8      	ldr	r0, [r7, #12]
 8010dbc:	f009 fe20 	bl	801aa00 <free>
        return -1;
 8010dc0:	f04f 33ff 	mov.w	r3, #4294967295
 8010dc4:	e01e      	b.n	8010e04 <OsCopyToNew+0xf4>
    }

    /* if new buf size smaller than logSize */
    ret = memcpy_s(newBuf, bufSize, temp + copyStart, copyLen);
 8010dc6:	68fa      	ldr	r2, [r7, #12]
 8010dc8:	68bb      	ldr	r3, [r7, #8]
 8010dca:	441a      	add	r2, r3
 8010dcc:	69bb      	ldr	r3, [r7, #24]
 8010dce:	6979      	ldr	r1, [r7, #20]
 8010dd0:	6938      	ldr	r0, [r7, #16]
 8010dd2:	f006 f961 	bl	8017098 <memcpy_s>
 8010dd6:	61f8      	str	r0, [r7, #28]
    if (ret != EOK) {
 8010dd8:	69fb      	ldr	r3, [r7, #28]
 8010dda:	2b00      	cmp	r3, #0
 8010ddc:	d00e      	beq.n	8010dfc <OsCopyToNew+0xec>
        PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8010dde:	480c      	ldr	r0, [pc, #48]	; (8010e10 <OsCopyToNew+0x100>)
 8010de0:	f7f3 fd6e 	bl	80048c0 <dprintf>
 8010de4:	69fb      	ldr	r3, [r7, #28]
 8010de6:	22d5      	movs	r2, #213	; 0xd5
 8010de8:	490a      	ldr	r1, [pc, #40]	; (8010e14 <OsCopyToNew+0x104>)
 8010dea:	480c      	ldr	r0, [pc, #48]	; (8010e1c <OsCopyToNew+0x10c>)
 8010dec:	f7f3 fd68 	bl	80048c0 <dprintf>
        free(temp);
 8010df0:	68f8      	ldr	r0, [r7, #12]
 8010df2:	f009 fe05 	bl	801aa00 <free>
        return -1;
 8010df6:	f04f 33ff 	mov.w	r3, #4294967295
 8010dfa:	e003      	b.n	8010e04 <OsCopyToNew+0xf4>
    }
    free(temp);
 8010dfc:	68f8      	ldr	r0, [r7, #12]
 8010dfe:	f009 fdff 	bl	801aa00 <free>

    return (INT32)copyLen;
 8010e02:	69bb      	ldr	r3, [r7, #24]
}
 8010e04:	4618      	mov	r0, r3
 8010e06:	3720      	adds	r7, #32
 8010e08:	46bd      	mov	sp, r7
 8010e0a:	bd80      	pop	{r7, pc}
 8010e0c:	20003290 	.word	0x20003290
 8010e10:	08021834 	.word	0x08021834
 8010e14:	080234e0 	.word	0x080234e0
 8010e18:	0802183c 	.word	0x0802183c
 8010e1c:	08021854 	.word	0x08021854

08010e20 <OsDmesgResetMem>:

STATIC UINT32 OsDmesgResetMem(VOID *addr, UINT32 size)
{
 8010e20:	b580      	push	{r7, lr}
 8010e22:	b086      	sub	sp, #24
 8010e24:	af00      	add	r7, sp, #0
 8010e26:	6078      	str	r0, [r7, #4]
 8010e28:	6039      	str	r1, [r7, #0]
 8010e2a:	4b2f      	ldr	r3, [pc, #188]	; (8010ee8 <OsDmesgResetMem+0xc8>)
 8010e2c:	681b      	ldr	r3, [r3, #0]
 8010e2e:	617b      	str	r3, [r7, #20]
 8010e30:	f04f 0300 	mov.w	r3, #0
    VOID *temp = NULL;
 8010e34:	2300      	movs	r3, #0
 8010e36:	60fb      	str	r3, [r7, #12]
    INT32 copyLen;
    UINT32 intSave;

    if (size <= sizeof(DmesgInfo)) {
 8010e38:	683b      	ldr	r3, [r7, #0]
 8010e3a:	2b10      	cmp	r3, #16
 8010e3c:	d801      	bhi.n	8010e42 <OsDmesgResetMem+0x22>
        return LOS_NOK;
 8010e3e:	2301      	movs	r3, #1
 8010e40:	e047      	b.n	8010ed2 <OsDmesgResetMem+0xb2>
    }

    LOS_SpinLockSave(&g_dmesgSpin, &intSave);
 8010e42:	f107 0308 	add.w	r3, r7, #8
 8010e46:	4619      	mov	r1, r3
 8010e48:	4828      	ldr	r0, [pc, #160]	; (8010eec <OsDmesgResetMem+0xcc>)
 8010e4a:	f7ff fe28 	bl	8010a9e <LOS_SpinLockSave>
    temp = g_dmesgInfo;
 8010e4e:	4b28      	ldr	r3, [pc, #160]	; (8010ef0 <OsDmesgResetMem+0xd0>)
 8010e50:	681b      	ldr	r3, [r3, #0]
 8010e52:	60fb      	str	r3, [r7, #12]
    copyLen = OsCopyToNew(addr, size);
 8010e54:	6839      	ldr	r1, [r7, #0]
 8010e56:	6878      	ldr	r0, [r7, #4]
 8010e58:	f7ff ff5a 	bl	8010d10 <OsCopyToNew>
 8010e5c:	6138      	str	r0, [r7, #16]
    if (copyLen < 0) {
 8010e5e:	693b      	ldr	r3, [r7, #16]
 8010e60:	2b00      	cmp	r3, #0
 8010e62:	da06      	bge.n	8010e72 <OsDmesgResetMem+0x52>
        LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8010e64:	68bb      	ldr	r3, [r7, #8]
 8010e66:	4619      	mov	r1, r3
 8010e68:	4820      	ldr	r0, [pc, #128]	; (8010eec <OsDmesgResetMem+0xcc>)
 8010e6a:	f7ff fe26 	bl	8010aba <LOS_SpinUnlockRestore>
        return LOS_NOK;
 8010e6e:	2301      	movs	r3, #1
 8010e70:	e02f      	b.n	8010ed2 <OsDmesgResetMem+0xb2>
    }

    g_logBufSize = size - sizeof(DmesgInfo);
 8010e72:	683b      	ldr	r3, [r7, #0]
 8010e74:	3b10      	subs	r3, #16
 8010e76:	4a1f      	ldr	r2, [pc, #124]	; (8010ef4 <OsDmesgResetMem+0xd4>)
 8010e78:	6013      	str	r3, [r2, #0]
    g_dmesgInfo = (DmesgInfo *)addr;
 8010e7a:	4a1d      	ldr	r2, [pc, #116]	; (8010ef0 <OsDmesgResetMem+0xd0>)
 8010e7c:	687b      	ldr	r3, [r7, #4]
 8010e7e:	6013      	str	r3, [r2, #0]
    g_dmesgInfo->logBuf = (CHAR *)addr + sizeof(DmesgInfo);
 8010e80:	4b1b      	ldr	r3, [pc, #108]	; (8010ef0 <OsDmesgResetMem+0xd0>)
 8010e82:	681b      	ldr	r3, [r3, #0]
 8010e84:	687a      	ldr	r2, [r7, #4]
 8010e86:	3210      	adds	r2, #16
 8010e88:	60da      	str	r2, [r3, #12]
    g_dmesgInfo->logSize = copyLen;
 8010e8a:	4b19      	ldr	r3, [pc, #100]	; (8010ef0 <OsDmesgResetMem+0xd0>)
 8010e8c:	681b      	ldr	r3, [r3, #0]
 8010e8e:	693a      	ldr	r2, [r7, #16]
 8010e90:	601a      	str	r2, [r3, #0]
    g_dmesgInfo->logTail = ((copyLen == g_logBufSize) ? 0 : copyLen);
 8010e92:	693a      	ldr	r2, [r7, #16]
 8010e94:	4b17      	ldr	r3, [pc, #92]	; (8010ef4 <OsDmesgResetMem+0xd4>)
 8010e96:	681b      	ldr	r3, [r3, #0]
 8010e98:	429a      	cmp	r2, r3
 8010e9a:	d001      	beq.n	8010ea0 <OsDmesgResetMem+0x80>
 8010e9c:	693b      	ldr	r3, [r7, #16]
 8010e9e:	e000      	b.n	8010ea2 <OsDmesgResetMem+0x82>
 8010ea0:	2300      	movs	r3, #0
 8010ea2:	4a13      	ldr	r2, [pc, #76]	; (8010ef0 <OsDmesgResetMem+0xd0>)
 8010ea4:	6812      	ldr	r2, [r2, #0]
 8010ea6:	6093      	str	r3, [r2, #8]
    g_dmesgInfo->logHead = 0;
 8010ea8:	4b11      	ldr	r3, [pc, #68]	; (8010ef0 <OsDmesgResetMem+0xd0>)
 8010eaa:	681b      	ldr	r3, [r3, #0]
 8010eac:	2200      	movs	r2, #0
 8010eae:	605a      	str	r2, [r3, #4]

    /* if old mem came from malloc */
    if (temp == g_mallocAddr) {
 8010eb0:	4b11      	ldr	r3, [pc, #68]	; (8010ef8 <OsDmesgResetMem+0xd8>)
 8010eb2:	681b      	ldr	r3, [r3, #0]
 8010eb4:	68fa      	ldr	r2, [r7, #12]
 8010eb6:	429a      	cmp	r2, r3
 8010eb8:	d105      	bne.n	8010ec6 <OsDmesgResetMem+0xa6>
        free(temp);
 8010eba:	68f8      	ldr	r0, [r7, #12]
 8010ebc:	f009 fda0 	bl	801aa00 <free>
        g_mallocAddr = NULL;
 8010ec0:	4b0d      	ldr	r3, [pc, #52]	; (8010ef8 <OsDmesgResetMem+0xd8>)
 8010ec2:	2200      	movs	r2, #0
 8010ec4:	601a      	str	r2, [r3, #0]
    }
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8010ec6:	68bb      	ldr	r3, [r7, #8]
 8010ec8:	4619      	mov	r1, r3
 8010eca:	4808      	ldr	r0, [pc, #32]	; (8010eec <OsDmesgResetMem+0xcc>)
 8010ecc:	f7ff fdf5 	bl	8010aba <LOS_SpinUnlockRestore>

    return LOS_OK;
 8010ed0:	2300      	movs	r3, #0
}
 8010ed2:	4a05      	ldr	r2, [pc, #20]	; (8010ee8 <OsDmesgResetMem+0xc8>)
 8010ed4:	6811      	ldr	r1, [r2, #0]
 8010ed6:	697a      	ldr	r2, [r7, #20]
 8010ed8:	4051      	eors	r1, r2
 8010eda:	d001      	beq.n	8010ee0 <OsDmesgResetMem+0xc0>
 8010edc:	f7f3 fb7e 	bl	80045dc <__stack_chk_fail>
 8010ee0:	4618      	mov	r0, r3
 8010ee2:	3718      	adds	r7, #24
 8010ee4:	46bd      	mov	sp, r7
 8010ee6:	bd80      	pop	{r7, pc}
 8010ee8:	08021874 	.word	0x08021874
 8010eec:	2000328c 	.word	0x2000328c
 8010ef0:	20003290 	.word	0x20003290
 8010ef4:	20003294 	.word	0x20003294
 8010ef8:	20003298 	.word	0x20003298

08010efc <OsDmesgChangeSize>:

STATIC UINT32 OsDmesgChangeSize(UINT32 size)
{
 8010efc:	b580      	push	{r7, lr}
 8010efe:	b088      	sub	sp, #32
 8010f00:	af00      	add	r7, sp, #0
 8010f02:	6078      	str	r0, [r7, #4]
 8010f04:	4b37      	ldr	r3, [pc, #220]	; (8010fe4 <OsDmesgChangeSize+0xe8>)
 8010f06:	681b      	ldr	r3, [r3, #0]
 8010f08:	61fb      	str	r3, [r7, #28]
 8010f0a:	f04f 0300 	mov.w	r3, #0
    VOID *temp = NULL;
 8010f0e:	2300      	movs	r3, #0
 8010f10:	613b      	str	r3, [r7, #16]
    INT32 copyLen;
    CHAR *newString = NULL;
 8010f12:	2300      	movs	r3, #0
 8010f14:	617b      	str	r3, [r7, #20]
    UINT32 intSave;

    if (size == 0) {
 8010f16:	687b      	ldr	r3, [r7, #4]
 8010f18:	2b00      	cmp	r3, #0
 8010f1a:	d101      	bne.n	8010f20 <OsDmesgChangeSize+0x24>
        return LOS_NOK;
 8010f1c:	2301      	movs	r3, #1
 8010f1e:	e056      	b.n	8010fce <OsDmesgChangeSize+0xd2>
    }

    newString = (CHAR *)malloc(size + sizeof(DmesgInfo));
 8010f20:	687b      	ldr	r3, [r7, #4]
 8010f22:	3310      	adds	r3, #16
 8010f24:	4618      	mov	r0, r3
 8010f26:	f009 fd7f 	bl	801aa28 <malloc>
 8010f2a:	6178      	str	r0, [r7, #20]
    if (newString == NULL) {
 8010f2c:	697b      	ldr	r3, [r7, #20]
 8010f2e:	2b00      	cmp	r3, #0
 8010f30:	d101      	bne.n	8010f36 <OsDmesgChangeSize+0x3a>
        return LOS_NOK;
 8010f32:	2301      	movs	r3, #1
 8010f34:	e04b      	b.n	8010fce <OsDmesgChangeSize+0xd2>
    }

    LOS_SpinLockSave(&g_dmesgSpin, &intSave);
 8010f36:	f107 030c 	add.w	r3, r7, #12
 8010f3a:	4619      	mov	r1, r3
 8010f3c:	482a      	ldr	r0, [pc, #168]	; (8010fe8 <OsDmesgChangeSize+0xec>)
 8010f3e:	f7ff fdae 	bl	8010a9e <LOS_SpinLockSave>
    temp = g_dmesgInfo;
 8010f42:	4b2a      	ldr	r3, [pc, #168]	; (8010fec <OsDmesgChangeSize+0xf0>)
 8010f44:	681b      	ldr	r3, [r3, #0]
 8010f46:	613b      	str	r3, [r7, #16]

    copyLen = OsCopyToNew(newString, size + sizeof(DmesgInfo));
 8010f48:	687b      	ldr	r3, [r7, #4]
 8010f4a:	3310      	adds	r3, #16
 8010f4c:	4619      	mov	r1, r3
 8010f4e:	6978      	ldr	r0, [r7, #20]
 8010f50:	f7ff fede 	bl	8010d10 <OsCopyToNew>
 8010f54:	61b8      	str	r0, [r7, #24]
    if (copyLen < 0) {
 8010f56:	69bb      	ldr	r3, [r7, #24]
 8010f58:	2b00      	cmp	r3, #0
 8010f5a:	da09      	bge.n	8010f70 <OsDmesgChangeSize+0x74>
        LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8010f5c:	68fb      	ldr	r3, [r7, #12]
 8010f5e:	4619      	mov	r1, r3
 8010f60:	4821      	ldr	r0, [pc, #132]	; (8010fe8 <OsDmesgChangeSize+0xec>)
 8010f62:	f7ff fdaa 	bl	8010aba <LOS_SpinUnlockRestore>
        free(newString);
 8010f66:	6978      	ldr	r0, [r7, #20]
 8010f68:	f009 fd4a 	bl	801aa00 <free>
        return LOS_NOK;
 8010f6c:	2301      	movs	r3, #1
 8010f6e:	e02e      	b.n	8010fce <OsDmesgChangeSize+0xd2>
    }

    g_logBufSize = size;
 8010f70:	4a1f      	ldr	r2, [pc, #124]	; (8010ff0 <OsDmesgChangeSize+0xf4>)
 8010f72:	687b      	ldr	r3, [r7, #4]
 8010f74:	6013      	str	r3, [r2, #0]
    g_dmesgInfo = (DmesgInfo *)newString;
 8010f76:	4a1d      	ldr	r2, [pc, #116]	; (8010fec <OsDmesgChangeSize+0xf0>)
 8010f78:	697b      	ldr	r3, [r7, #20]
 8010f7a:	6013      	str	r3, [r2, #0]
    g_dmesgInfo->logBuf = (CHAR *)newString + sizeof(DmesgInfo);
 8010f7c:	4b1b      	ldr	r3, [pc, #108]	; (8010fec <OsDmesgChangeSize+0xf0>)
 8010f7e:	681b      	ldr	r3, [r3, #0]
 8010f80:	697a      	ldr	r2, [r7, #20]
 8010f82:	3210      	adds	r2, #16
 8010f84:	60da      	str	r2, [r3, #12]
    g_dmesgInfo->logSize = copyLen;
 8010f86:	4b19      	ldr	r3, [pc, #100]	; (8010fec <OsDmesgChangeSize+0xf0>)
 8010f88:	681b      	ldr	r3, [r3, #0]
 8010f8a:	69ba      	ldr	r2, [r7, #24]
 8010f8c:	601a      	str	r2, [r3, #0]
    g_dmesgInfo->logTail = ((copyLen == g_logBufSize) ? 0 : copyLen);
 8010f8e:	69ba      	ldr	r2, [r7, #24]
 8010f90:	4b17      	ldr	r3, [pc, #92]	; (8010ff0 <OsDmesgChangeSize+0xf4>)
 8010f92:	681b      	ldr	r3, [r3, #0]
 8010f94:	429a      	cmp	r2, r3
 8010f96:	d001      	beq.n	8010f9c <OsDmesgChangeSize+0xa0>
 8010f98:	69bb      	ldr	r3, [r7, #24]
 8010f9a:	e000      	b.n	8010f9e <OsDmesgChangeSize+0xa2>
 8010f9c:	2300      	movs	r3, #0
 8010f9e:	4a13      	ldr	r2, [pc, #76]	; (8010fec <OsDmesgChangeSize+0xf0>)
 8010fa0:	6812      	ldr	r2, [r2, #0]
 8010fa2:	6093      	str	r3, [r2, #8]
    g_dmesgInfo->logHead = 0;
 8010fa4:	4b11      	ldr	r3, [pc, #68]	; (8010fec <OsDmesgChangeSize+0xf0>)
 8010fa6:	681b      	ldr	r3, [r3, #0]
 8010fa8:	2200      	movs	r2, #0
 8010faa:	605a      	str	r2, [r3, #4]

    if (temp == g_mallocAddr) {
 8010fac:	4b11      	ldr	r3, [pc, #68]	; (8010ff4 <OsDmesgChangeSize+0xf8>)
 8010fae:	681b      	ldr	r3, [r3, #0]
 8010fb0:	693a      	ldr	r2, [r7, #16]
 8010fb2:	429a      	cmp	r2, r3
 8010fb4:	d102      	bne.n	8010fbc <OsDmesgChangeSize+0xc0>
        free(temp);
 8010fb6:	6938      	ldr	r0, [r7, #16]
 8010fb8:	f009 fd22 	bl	801aa00 <free>
    }
    g_mallocAddr = newString;
 8010fbc:	4a0d      	ldr	r2, [pc, #52]	; (8010ff4 <OsDmesgChangeSize+0xf8>)
 8010fbe:	697b      	ldr	r3, [r7, #20]
 8010fc0:	6013      	str	r3, [r2, #0]
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8010fc2:	68fb      	ldr	r3, [r7, #12]
 8010fc4:	4619      	mov	r1, r3
 8010fc6:	4808      	ldr	r0, [pc, #32]	; (8010fe8 <OsDmesgChangeSize+0xec>)
 8010fc8:	f7ff fd77 	bl	8010aba <LOS_SpinUnlockRestore>

    return LOS_OK;
 8010fcc:	2300      	movs	r3, #0
}
 8010fce:	4a05      	ldr	r2, [pc, #20]	; (8010fe4 <OsDmesgChangeSize+0xe8>)
 8010fd0:	6811      	ldr	r1, [r2, #0]
 8010fd2:	69fa      	ldr	r2, [r7, #28]
 8010fd4:	4051      	eors	r1, r2
 8010fd6:	d001      	beq.n	8010fdc <OsDmesgChangeSize+0xe0>
 8010fd8:	f7f3 fb00 	bl	80045dc <__stack_chk_fail>
 8010fdc:	4618      	mov	r0, r3
 8010fde:	3720      	adds	r7, #32
 8010fe0:	46bd      	mov	sp, r7
 8010fe2:	bd80      	pop	{r7, pc}
 8010fe4:	08021878 	.word	0x08021878
 8010fe8:	2000328c 	.word	0x2000328c
 8010fec:	20003290 	.word	0x20003290
 8010ff0:	20003294 	.word	0x20003294
 8010ff4:	20003298 	.word	0x20003298

08010ff8 <OsCheckUartLock>:
{
    return g_consoleLock;
}

UINT32 OsCheckUartLock(VOID)
{
 8010ff8:	b480      	push	{r7}
 8010ffa:	af00      	add	r7, sp, #0
    return g_uartLock;
 8010ffc:	4b03      	ldr	r3, [pc, #12]	; (801100c <OsCheckUartLock+0x14>)
 8010ffe:	681b      	ldr	r3, [r3, #0]
}
 8011000:	4618      	mov	r0, r3
 8011002:	46bd      	mov	sp, r7
 8011004:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011008:	4770      	bx	lr
 801100a:	bf00      	nop
 801100c:	200032a0 	.word	0x200032a0

08011010 <OsDmesgInit>:

UINT32 OsDmesgInit(VOID)
{
 8011010:	b580      	push	{r7, lr}
 8011012:	b082      	sub	sp, #8
 8011014:	af00      	add	r7, sp, #0
    CHAR* buffer = NULL;
 8011016:	2300      	movs	r3, #0
 8011018:	607b      	str	r3, [r7, #4]

    buffer = (CHAR *)malloc(KERNEL_LOG_BUF_SIZE + sizeof(DmesgInfo));
 801101a:	f242 0010 	movw	r0, #8208	; 0x2010
 801101e:	f009 fd03 	bl	801aa28 <malloc>
 8011022:	6078      	str	r0, [r7, #4]
    if (buffer == NULL) {
 8011024:	687b      	ldr	r3, [r7, #4]
 8011026:	2b00      	cmp	r3, #0
 8011028:	d101      	bne.n	801102e <OsDmesgInit+0x1e>
        return LOS_NOK;
 801102a:	2301      	movs	r3, #1
 801102c:	e01b      	b.n	8011066 <OsDmesgInit+0x56>
    }
    g_mallocAddr = buffer;
 801102e:	4a10      	ldr	r2, [pc, #64]	; (8011070 <OsDmesgInit+0x60>)
 8011030:	687b      	ldr	r3, [r7, #4]
 8011032:	6013      	str	r3, [r2, #0]
    g_dmesgInfo = (DmesgInfo *)buffer;
 8011034:	4a0f      	ldr	r2, [pc, #60]	; (8011074 <OsDmesgInit+0x64>)
 8011036:	687b      	ldr	r3, [r7, #4]
 8011038:	6013      	str	r3, [r2, #0]
    g_dmesgInfo->logHead = 0;
 801103a:	4b0e      	ldr	r3, [pc, #56]	; (8011074 <OsDmesgInit+0x64>)
 801103c:	681b      	ldr	r3, [r3, #0]
 801103e:	2200      	movs	r2, #0
 8011040:	605a      	str	r2, [r3, #4]
    g_dmesgInfo->logTail = 0;
 8011042:	4b0c      	ldr	r3, [pc, #48]	; (8011074 <OsDmesgInit+0x64>)
 8011044:	681b      	ldr	r3, [r3, #0]
 8011046:	2200      	movs	r2, #0
 8011048:	609a      	str	r2, [r3, #8]
    g_dmesgInfo->logSize = 0;
 801104a:	4b0a      	ldr	r3, [pc, #40]	; (8011074 <OsDmesgInit+0x64>)
 801104c:	681b      	ldr	r3, [r3, #0]
 801104e:	2200      	movs	r2, #0
 8011050:	601a      	str	r2, [r3, #0]
    g_dmesgInfo->logBuf = buffer + sizeof(DmesgInfo);
 8011052:	4b08      	ldr	r3, [pc, #32]	; (8011074 <OsDmesgInit+0x64>)
 8011054:	681b      	ldr	r3, [r3, #0]
 8011056:	687a      	ldr	r2, [r7, #4]
 8011058:	3210      	adds	r2, #16
 801105a:	60da      	str	r2, [r3, #12]
    g_logBufSize = KERNEL_LOG_BUF_SIZE;
 801105c:	4b06      	ldr	r3, [pc, #24]	; (8011078 <OsDmesgInit+0x68>)
 801105e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8011062:	601a      	str	r2, [r3, #0]

    return LOS_OK;
 8011064:	2300      	movs	r3, #0
}
 8011066:	4618      	mov	r0, r3
 8011068:	3708      	adds	r7, #8
 801106a:	46bd      	mov	sp, r7
 801106c:	bd80      	pop	{r7, pc}
 801106e:	bf00      	nop
 8011070:	20003298 	.word	0x20003298
 8011074:	20003290 	.word	0x20003290
 8011078:	20003294 	.word	0x20003294

0801107c <OsBufFullWrite>:
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
    return i;
}

STATIC VOID OsBufFullWrite(const CHAR *dst, UINT32 logLen)
{
 801107c:	b580      	push	{r7, lr}
 801107e:	b086      	sub	sp, #24
 8011080:	af00      	add	r7, sp, #0
 8011082:	6078      	str	r0, [r7, #4]
 8011084:	6039      	str	r1, [r7, #0]
    UINT32 bufSize = g_logBufSize;
 8011086:	4b6d      	ldr	r3, [pc, #436]	; (801123c <OsBufFullWrite+0x1c0>)
 8011088:	681b      	ldr	r3, [r3, #0]
 801108a:	60bb      	str	r3, [r7, #8]
    UINT32 tail = g_dmesgInfo->logTail;
 801108c:	4b6c      	ldr	r3, [pc, #432]	; (8011240 <OsBufFullWrite+0x1c4>)
 801108e:	681b      	ldr	r3, [r3, #0]
 8011090:	689b      	ldr	r3, [r3, #8]
 8011092:	60fb      	str	r3, [r7, #12]
    CHAR *buf = g_dmesgInfo->logBuf;
 8011094:	4b6a      	ldr	r3, [pc, #424]	; (8011240 <OsBufFullWrite+0x1c4>)
 8011096:	681b      	ldr	r3, [r3, #0]
 8011098:	68db      	ldr	r3, [r3, #12]
 801109a:	613b      	str	r3, [r7, #16]
    errno_t ret;

    if ((logLen == 0) || (dst == NULL)) {
 801109c:	683b      	ldr	r3, [r7, #0]
 801109e:	2b00      	cmp	r3, #0
 80110a0:	f000 80c8 	beq.w	8011234 <OsBufFullWrite+0x1b8>
 80110a4:	687b      	ldr	r3, [r7, #4]
 80110a6:	2b00      	cmp	r3, #0
 80110a8:	f000 80c4 	beq.w	8011234 <OsBufFullWrite+0x1b8>
        return;
    }
    if (logLen > bufSize) { /* full re-write */
 80110ac:	683a      	ldr	r2, [r7, #0]
 80110ae:	68bb      	ldr	r3, [r7, #8]
 80110b0:	429a      	cmp	r2, r3
 80110b2:	d93d      	bls.n	8011130 <OsBufFullWrite+0xb4>
        ret = memcpy_s(buf + tail, bufSize - tail, dst, bufSize - tail);
 80110b4:	693a      	ldr	r2, [r7, #16]
 80110b6:	68fb      	ldr	r3, [r7, #12]
 80110b8:	18d0      	adds	r0, r2, r3
 80110ba:	68ba      	ldr	r2, [r7, #8]
 80110bc:	68fb      	ldr	r3, [r7, #12]
 80110be:	1ad1      	subs	r1, r2, r3
 80110c0:	68ba      	ldr	r2, [r7, #8]
 80110c2:	68fb      	ldr	r3, [r7, #12]
 80110c4:	1ad3      	subs	r3, r2, r3
 80110c6:	687a      	ldr	r2, [r7, #4]
 80110c8:	f005 ffe6 	bl	8017098 <memcpy_s>
 80110cc:	6178      	str	r0, [r7, #20]
        if (ret != EOK) {
 80110ce:	697b      	ldr	r3, [r7, #20]
 80110d0:	2b00      	cmp	r3, #0
 80110d2:	d00a      	beq.n	80110ea <OsBufFullWrite+0x6e>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 80110d4:	485b      	ldr	r0, [pc, #364]	; (8011244 <OsBufFullWrite+0x1c8>)
 80110d6:	f7f3 fbf3 	bl	80048c0 <dprintf>
 80110da:	697b      	ldr	r3, [r7, #20]
 80110dc:	f240 1273 	movw	r2, #371	; 0x173
 80110e0:	4959      	ldr	r1, [pc, #356]	; (8011248 <OsBufFullWrite+0x1cc>)
 80110e2:	485a      	ldr	r0, [pc, #360]	; (801124c <OsBufFullWrite+0x1d0>)
 80110e4:	f7f3 fbec 	bl	80048c0 <dprintf>
            return;
 80110e8:	e0a5      	b.n	8011236 <OsBufFullWrite+0x1ba>
        }
        ret = memcpy_s(buf, bufSize, dst + bufSize - tail, tail);
 80110ea:	68ba      	ldr	r2, [r7, #8]
 80110ec:	68fb      	ldr	r3, [r7, #12]
 80110ee:	1ad3      	subs	r3, r2, r3
 80110f0:	687a      	ldr	r2, [r7, #4]
 80110f2:	441a      	add	r2, r3
 80110f4:	68fb      	ldr	r3, [r7, #12]
 80110f6:	68b9      	ldr	r1, [r7, #8]
 80110f8:	6938      	ldr	r0, [r7, #16]
 80110fa:	f005 ffcd 	bl	8017098 <memcpy_s>
 80110fe:	6178      	str	r0, [r7, #20]
        if (ret != EOK) {
 8011100:	697b      	ldr	r3, [r7, #20]
 8011102:	2b00      	cmp	r3, #0
 8011104:	d00a      	beq.n	801111c <OsBufFullWrite+0xa0>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8011106:	484f      	ldr	r0, [pc, #316]	; (8011244 <OsBufFullWrite+0x1c8>)
 8011108:	f7f3 fbda 	bl	80048c0 <dprintf>
 801110c:	697b      	ldr	r3, [r7, #20]
 801110e:	f44f 72bc 	mov.w	r2, #376	; 0x178
 8011112:	494d      	ldr	r1, [pc, #308]	; (8011248 <OsBufFullWrite+0x1cc>)
 8011114:	484d      	ldr	r0, [pc, #308]	; (801124c <OsBufFullWrite+0x1d0>)
 8011116:	f7f3 fbd3 	bl	80048c0 <dprintf>
            return;
 801111a:	e08c      	b.n	8011236 <OsBufFullWrite+0x1ba>
        }

        OsBufFullWrite(dst + bufSize, logLen - bufSize);
 801111c:	687a      	ldr	r2, [r7, #4]
 801111e:	68bb      	ldr	r3, [r7, #8]
 8011120:	18d0      	adds	r0, r2, r3
 8011122:	683a      	ldr	r2, [r7, #0]
 8011124:	68bb      	ldr	r3, [r7, #8]
 8011126:	1ad3      	subs	r3, r2, r3
 8011128:	4619      	mov	r1, r3
 801112a:	f7ff ffa7 	bl	801107c <OsBufFullWrite>
 801112e:	e082      	b.n	8011236 <OsBufFullWrite+0x1ba>
    } else {
        if (logLen > (bufSize - tail)) { /* need cycle back to start */
 8011130:	68ba      	ldr	r2, [r7, #8]
 8011132:	68fb      	ldr	r3, [r7, #12]
 8011134:	1ad3      	subs	r3, r2, r3
 8011136:	683a      	ldr	r2, [r7, #0]
 8011138:	429a      	cmp	r2, r3
 801113a:	d947      	bls.n	80111cc <OsBufFullWrite+0x150>
            ret = memcpy_s(buf + tail, bufSize - tail, dst, bufSize - tail);
 801113c:	693a      	ldr	r2, [r7, #16]
 801113e:	68fb      	ldr	r3, [r7, #12]
 8011140:	18d0      	adds	r0, r2, r3
 8011142:	68ba      	ldr	r2, [r7, #8]
 8011144:	68fb      	ldr	r3, [r7, #12]
 8011146:	1ad1      	subs	r1, r2, r3
 8011148:	68ba      	ldr	r2, [r7, #8]
 801114a:	68fb      	ldr	r3, [r7, #12]
 801114c:	1ad3      	subs	r3, r2, r3
 801114e:	687a      	ldr	r2, [r7, #4]
 8011150:	f005 ffa2 	bl	8017098 <memcpy_s>
 8011154:	6178      	str	r0, [r7, #20]
            if (ret != EOK) {
 8011156:	697b      	ldr	r3, [r7, #20]
 8011158:	2b00      	cmp	r3, #0
 801115a:	d00a      	beq.n	8011172 <OsBufFullWrite+0xf6>
                PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 801115c:	4839      	ldr	r0, [pc, #228]	; (8011244 <OsBufFullWrite+0x1c8>)
 801115e:	f7f3 fbaf 	bl	80048c0 <dprintf>
 8011162:	697b      	ldr	r3, [r7, #20]
 8011164:	f240 1281 	movw	r2, #385	; 0x181
 8011168:	4937      	ldr	r1, [pc, #220]	; (8011248 <OsBufFullWrite+0x1cc>)
 801116a:	4838      	ldr	r0, [pc, #224]	; (801124c <OsBufFullWrite+0x1d0>)
 801116c:	f7f3 fba8 	bl	80048c0 <dprintf>
                return;
 8011170:	e061      	b.n	8011236 <OsBufFullWrite+0x1ba>
            }
            ret = memcpy_s(buf, bufSize, dst + bufSize - tail, logLen - (bufSize - tail));
 8011172:	68ba      	ldr	r2, [r7, #8]
 8011174:	68fb      	ldr	r3, [r7, #12]
 8011176:	1ad3      	subs	r3, r2, r3
 8011178:	687a      	ldr	r2, [r7, #4]
 801117a:	18d1      	adds	r1, r2, r3
 801117c:	68fa      	ldr	r2, [r7, #12]
 801117e:	68bb      	ldr	r3, [r7, #8]
 8011180:	1ad2      	subs	r2, r2, r3
 8011182:	683b      	ldr	r3, [r7, #0]
 8011184:	4413      	add	r3, r2
 8011186:	460a      	mov	r2, r1
 8011188:	68b9      	ldr	r1, [r7, #8]
 801118a:	6938      	ldr	r0, [r7, #16]
 801118c:	f005 ff84 	bl	8017098 <memcpy_s>
 8011190:	6178      	str	r0, [r7, #20]
            if (ret != EOK) {
 8011192:	697b      	ldr	r3, [r7, #20]
 8011194:	2b00      	cmp	r3, #0
 8011196:	d00a      	beq.n	80111ae <OsBufFullWrite+0x132>
                PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8011198:	482a      	ldr	r0, [pc, #168]	; (8011244 <OsBufFullWrite+0x1c8>)
 801119a:	f7f3 fb91 	bl	80048c0 <dprintf>
 801119e:	697b      	ldr	r3, [r7, #20]
 80111a0:	f44f 72c3 	mov.w	r2, #390	; 0x186
 80111a4:	4928      	ldr	r1, [pc, #160]	; (8011248 <OsBufFullWrite+0x1cc>)
 80111a6:	4829      	ldr	r0, [pc, #164]	; (801124c <OsBufFullWrite+0x1d0>)
 80111a8:	f7f3 fb8a 	bl	80048c0 <dprintf>
                return;
 80111ac:	e043      	b.n	8011236 <OsBufFullWrite+0x1ba>
            }

            g_dmesgInfo->logTail = logLen - (bufSize - tail);
 80111ae:	68fa      	ldr	r2, [r7, #12]
 80111b0:	68bb      	ldr	r3, [r7, #8]
 80111b2:	1ad1      	subs	r1, r2, r3
 80111b4:	4b22      	ldr	r3, [pc, #136]	; (8011240 <OsBufFullWrite+0x1c4>)
 80111b6:	681b      	ldr	r3, [r3, #0]
 80111b8:	683a      	ldr	r2, [r7, #0]
 80111ba:	440a      	add	r2, r1
 80111bc:	609a      	str	r2, [r3, #8]
            g_dmesgInfo->logHead = g_dmesgInfo->logTail;
 80111be:	4b20      	ldr	r3, [pc, #128]	; (8011240 <OsBufFullWrite+0x1c4>)
 80111c0:	681a      	ldr	r2, [r3, #0]
 80111c2:	4b1f      	ldr	r3, [pc, #124]	; (8011240 <OsBufFullWrite+0x1c4>)
 80111c4:	681b      	ldr	r3, [r3, #0]
 80111c6:	6892      	ldr	r2, [r2, #8]
 80111c8:	605a      	str	r2, [r3, #4]
 80111ca:	e034      	b.n	8011236 <OsBufFullWrite+0x1ba>
        } else { /* no need cycle back to start */
            ret = memcpy_s(buf + tail, bufSize - tail, dst, logLen);
 80111cc:	693a      	ldr	r2, [r7, #16]
 80111ce:	68fb      	ldr	r3, [r7, #12]
 80111d0:	18d0      	adds	r0, r2, r3
 80111d2:	68ba      	ldr	r2, [r7, #8]
 80111d4:	68fb      	ldr	r3, [r7, #12]
 80111d6:	1ad1      	subs	r1, r2, r3
 80111d8:	683b      	ldr	r3, [r7, #0]
 80111da:	687a      	ldr	r2, [r7, #4]
 80111dc:	f005 ff5c 	bl	8017098 <memcpy_s>
 80111e0:	6178      	str	r0, [r7, #20]
            if (ret != EOK) {
 80111e2:	697b      	ldr	r3, [r7, #20]
 80111e4:	2b00      	cmp	r3, #0
 80111e6:	d00a      	beq.n	80111fe <OsBufFullWrite+0x182>
                PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 80111e8:	4816      	ldr	r0, [pc, #88]	; (8011244 <OsBufFullWrite+0x1c8>)
 80111ea:	f7f3 fb69 	bl	80048c0 <dprintf>
 80111ee:	697b      	ldr	r3, [r7, #20]
 80111f0:	f240 128f 	movw	r2, #399	; 0x18f
 80111f4:	4914      	ldr	r1, [pc, #80]	; (8011248 <OsBufFullWrite+0x1cc>)
 80111f6:	4815      	ldr	r0, [pc, #84]	; (801124c <OsBufFullWrite+0x1d0>)
 80111f8:	f7f3 fb62 	bl	80048c0 <dprintf>
                return;
 80111fc:	e01b      	b.n	8011236 <OsBufFullWrite+0x1ba>
            }
            g_dmesgInfo->logTail += logLen;
 80111fe:	4b10      	ldr	r3, [pc, #64]	; (8011240 <OsBufFullWrite+0x1c4>)
 8011200:	681b      	ldr	r3, [r3, #0]
 8011202:	6899      	ldr	r1, [r3, #8]
 8011204:	4b0e      	ldr	r3, [pc, #56]	; (8011240 <OsBufFullWrite+0x1c4>)
 8011206:	681b      	ldr	r3, [r3, #0]
 8011208:	683a      	ldr	r2, [r7, #0]
 801120a:	440a      	add	r2, r1
 801120c:	609a      	str	r2, [r3, #8]
            if (g_dmesgInfo->logTail > BUF_MAX_INDEX) {
 801120e:	4b0c      	ldr	r3, [pc, #48]	; (8011240 <OsBufFullWrite+0x1c4>)
 8011210:	681b      	ldr	r3, [r3, #0]
 8011212:	689a      	ldr	r2, [r3, #8]
 8011214:	4b09      	ldr	r3, [pc, #36]	; (801123c <OsBufFullWrite+0x1c0>)
 8011216:	681b      	ldr	r3, [r3, #0]
 8011218:	3b01      	subs	r3, #1
 801121a:	429a      	cmp	r2, r3
 801121c:	d903      	bls.n	8011226 <OsBufFullWrite+0x1aa>
                g_dmesgInfo->logTail = 0;
 801121e:	4b08      	ldr	r3, [pc, #32]	; (8011240 <OsBufFullWrite+0x1c4>)
 8011220:	681b      	ldr	r3, [r3, #0]
 8011222:	2200      	movs	r2, #0
 8011224:	609a      	str	r2, [r3, #8]
            }
            g_dmesgInfo->logHead = g_dmesgInfo->logTail;
 8011226:	4b06      	ldr	r3, [pc, #24]	; (8011240 <OsBufFullWrite+0x1c4>)
 8011228:	681a      	ldr	r2, [r3, #0]
 801122a:	4b05      	ldr	r3, [pc, #20]	; (8011240 <OsBufFullWrite+0x1c4>)
 801122c:	681b      	ldr	r3, [r3, #0]
 801122e:	6892      	ldr	r2, [r2, #8]
 8011230:	605a      	str	r2, [r3, #4]
 8011232:	e000      	b.n	8011236 <OsBufFullWrite+0x1ba>
        return;
 8011234:	bf00      	nop
        }
    }
}
 8011236:	3718      	adds	r7, #24
 8011238:	46bd      	mov	sp, r7
 801123a:	bd80      	pop	{r7, pc}
 801123c:	20003294 	.word	0x20003294
 8011240:	20003290 	.word	0x20003290
 8011244:	08021834 	.word	0x08021834
 8011248:	080234ec 	.word	0x080234ec
 801124c:	08021854 	.word	0x08021854

08011250 <OsWriteTailToHead>:

STATIC VOID OsWriteTailToHead(const CHAR *dst, UINT32 logLen)
{
 8011250:	b580      	push	{r7, lr}
 8011252:	b088      	sub	sp, #32
 8011254:	af00      	add	r7, sp, #0
 8011256:	6078      	str	r0, [r7, #4]
 8011258:	6039      	str	r1, [r7, #0]
    UINT32 writeLen;
    UINT32 bufSize = g_logBufSize;
 801125a:	4b3d      	ldr	r3, [pc, #244]	; (8011350 <OsWriteTailToHead+0x100>)
 801125c:	681b      	ldr	r3, [r3, #0]
 801125e:	60bb      	str	r3, [r7, #8]
    UINT32 logSize = g_dmesgInfo->logSize;
 8011260:	4b3c      	ldr	r3, [pc, #240]	; (8011354 <OsWriteTailToHead+0x104>)
 8011262:	681b      	ldr	r3, [r3, #0]
 8011264:	681b      	ldr	r3, [r3, #0]
 8011266:	60fb      	str	r3, [r7, #12]
    UINT32 tail = g_dmesgInfo->logTail;
 8011268:	4b3a      	ldr	r3, [pc, #232]	; (8011354 <OsWriteTailToHead+0x104>)
 801126a:	681b      	ldr	r3, [r3, #0]
 801126c:	689b      	ldr	r3, [r3, #8]
 801126e:	613b      	str	r3, [r7, #16]
    CHAR *buf = g_dmesgInfo->logBuf;
 8011270:	4b38      	ldr	r3, [pc, #224]	; (8011354 <OsWriteTailToHead+0x104>)
 8011272:	681b      	ldr	r3, [r3, #0]
 8011274:	68db      	ldr	r3, [r3, #12]
 8011276:	617b      	str	r3, [r7, #20]
    errno_t ret;

    if ((logLen == 0) || (dst == NULL)) {
 8011278:	683b      	ldr	r3, [r7, #0]
 801127a:	2b00      	cmp	r3, #0
 801127c:	d064      	beq.n	8011348 <OsWriteTailToHead+0xf8>
 801127e:	687b      	ldr	r3, [r7, #4]
 8011280:	2b00      	cmp	r3, #0
 8011282:	d061      	beq.n	8011348 <OsWriteTailToHead+0xf8>
        return;
    }
    if (logLen > (bufSize - logSize)) { /* space-need > space-remain */
 8011284:	68ba      	ldr	r2, [r7, #8]
 8011286:	68fb      	ldr	r3, [r7, #12]
 8011288:	1ad3      	subs	r3, r2, r3
 801128a:	683a      	ldr	r2, [r7, #0]
 801128c:	429a      	cmp	r2, r3
 801128e:	d931      	bls.n	80112f4 <OsWriteTailToHead+0xa4>
        writeLen = bufSize - logSize;
 8011290:	68ba      	ldr	r2, [r7, #8]
 8011292:	68fb      	ldr	r3, [r7, #12]
 8011294:	1ad3      	subs	r3, r2, r3
 8011296:	61fb      	str	r3, [r7, #28]
        ret = memcpy_s(buf + tail, bufSize - tail, dst, writeLen);
 8011298:	697a      	ldr	r2, [r7, #20]
 801129a:	693b      	ldr	r3, [r7, #16]
 801129c:	18d0      	adds	r0, r2, r3
 801129e:	68ba      	ldr	r2, [r7, #8]
 80112a0:	693b      	ldr	r3, [r7, #16]
 80112a2:	1ad1      	subs	r1, r2, r3
 80112a4:	69fb      	ldr	r3, [r7, #28]
 80112a6:	687a      	ldr	r2, [r7, #4]
 80112a8:	f005 fef6 	bl	8017098 <memcpy_s>
 80112ac:	61b8      	str	r0, [r7, #24]
        if (ret != EOK) {
 80112ae:	69bb      	ldr	r3, [r7, #24]
 80112b0:	2b00      	cmp	r3, #0
 80112b2:	d00a      	beq.n	80112ca <OsWriteTailToHead+0x7a>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 80112b4:	4828      	ldr	r0, [pc, #160]	; (8011358 <OsWriteTailToHead+0x108>)
 80112b6:	f7f3 fb03 	bl	80048c0 <dprintf>
 80112ba:	69bb      	ldr	r3, [r7, #24]
 80112bc:	f240 12ab 	movw	r2, #427	; 0x1ab
 80112c0:	4926      	ldr	r1, [pc, #152]	; (801135c <OsWriteTailToHead+0x10c>)
 80112c2:	4827      	ldr	r0, [pc, #156]	; (8011360 <OsWriteTailToHead+0x110>)
 80112c4:	f7f3 fafc 	bl	80048c0 <dprintf>
            return;
 80112c8:	e03f      	b.n	801134a <OsWriteTailToHead+0xfa>
        }

        g_dmesgInfo->logTail = g_dmesgInfo->logHead;
 80112ca:	4b22      	ldr	r3, [pc, #136]	; (8011354 <OsWriteTailToHead+0x104>)
 80112cc:	681a      	ldr	r2, [r3, #0]
 80112ce:	4b21      	ldr	r3, [pc, #132]	; (8011354 <OsWriteTailToHead+0x104>)
 80112d0:	681b      	ldr	r3, [r3, #0]
 80112d2:	6852      	ldr	r2, [r2, #4]
 80112d4:	609a      	str	r2, [r3, #8]
        g_dmesgInfo->logSize = g_logBufSize;
 80112d6:	4b1f      	ldr	r3, [pc, #124]	; (8011354 <OsWriteTailToHead+0x104>)
 80112d8:	681b      	ldr	r3, [r3, #0]
 80112da:	4a1d      	ldr	r2, [pc, #116]	; (8011350 <OsWriteTailToHead+0x100>)
 80112dc:	6812      	ldr	r2, [r2, #0]
 80112de:	601a      	str	r2, [r3, #0]
        OsBufFullWrite(dst + writeLen, logLen - writeLen);
 80112e0:	687a      	ldr	r2, [r7, #4]
 80112e2:	69fb      	ldr	r3, [r7, #28]
 80112e4:	18d0      	adds	r0, r2, r3
 80112e6:	683a      	ldr	r2, [r7, #0]
 80112e8:	69fb      	ldr	r3, [r7, #28]
 80112ea:	1ad3      	subs	r3, r2, r3
 80112ec:	4619      	mov	r1, r3
 80112ee:	f7ff fec5 	bl	801107c <OsBufFullWrite>
 80112f2:	e02a      	b.n	801134a <OsWriteTailToHead+0xfa>
    } else {
        ret = memcpy_s(buf + tail, bufSize - tail, dst, logLen);
 80112f4:	697a      	ldr	r2, [r7, #20]
 80112f6:	693b      	ldr	r3, [r7, #16]
 80112f8:	18d0      	adds	r0, r2, r3
 80112fa:	68ba      	ldr	r2, [r7, #8]
 80112fc:	693b      	ldr	r3, [r7, #16]
 80112fe:	1ad1      	subs	r1, r2, r3
 8011300:	683b      	ldr	r3, [r7, #0]
 8011302:	687a      	ldr	r2, [r7, #4]
 8011304:	f005 fec8 	bl	8017098 <memcpy_s>
 8011308:	61b8      	str	r0, [r7, #24]
        if (ret != EOK) {
 801130a:	69bb      	ldr	r3, [r7, #24]
 801130c:	2b00      	cmp	r3, #0
 801130e:	d00a      	beq.n	8011326 <OsWriteTailToHead+0xd6>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8011310:	4811      	ldr	r0, [pc, #68]	; (8011358 <OsWriteTailToHead+0x108>)
 8011312:	f7f3 fad5 	bl	80048c0 <dprintf>
 8011316:	69bb      	ldr	r3, [r7, #24]
 8011318:	f240 12b5 	movw	r2, #437	; 0x1b5
 801131c:	490f      	ldr	r1, [pc, #60]	; (801135c <OsWriteTailToHead+0x10c>)
 801131e:	4810      	ldr	r0, [pc, #64]	; (8011360 <OsWriteTailToHead+0x110>)
 8011320:	f7f3 face 	bl	80048c0 <dprintf>
            return;
 8011324:	e011      	b.n	801134a <OsWriteTailToHead+0xfa>
        }

        g_dmesgInfo->logTail += logLen;
 8011326:	4b0b      	ldr	r3, [pc, #44]	; (8011354 <OsWriteTailToHead+0x104>)
 8011328:	681b      	ldr	r3, [r3, #0]
 801132a:	6899      	ldr	r1, [r3, #8]
 801132c:	4b09      	ldr	r3, [pc, #36]	; (8011354 <OsWriteTailToHead+0x104>)
 801132e:	681b      	ldr	r3, [r3, #0]
 8011330:	683a      	ldr	r2, [r7, #0]
 8011332:	440a      	add	r2, r1
 8011334:	609a      	str	r2, [r3, #8]
        g_dmesgInfo->logSize += logLen;
 8011336:	4b07      	ldr	r3, [pc, #28]	; (8011354 <OsWriteTailToHead+0x104>)
 8011338:	681b      	ldr	r3, [r3, #0]
 801133a:	6819      	ldr	r1, [r3, #0]
 801133c:	4b05      	ldr	r3, [pc, #20]	; (8011354 <OsWriteTailToHead+0x104>)
 801133e:	681b      	ldr	r3, [r3, #0]
 8011340:	683a      	ldr	r2, [r7, #0]
 8011342:	440a      	add	r2, r1
 8011344:	601a      	str	r2, [r3, #0]
 8011346:	e000      	b.n	801134a <OsWriteTailToHead+0xfa>
        return;
 8011348:	bf00      	nop
    }
}
 801134a:	3720      	adds	r7, #32
 801134c:	46bd      	mov	sp, r7
 801134e:	bd80      	pop	{r7, pc}
 8011350:	20003294 	.word	0x20003294
 8011354:	20003290 	.word	0x20003290
 8011358:	08021834 	.word	0x08021834
 801135c:	080234fc 	.word	0x080234fc
 8011360:	08021854 	.word	0x08021854

08011364 <OsWriteTailToEnd>:

STATIC VOID OsWriteTailToEnd(const CHAR *dst, UINT32 logLen)
{
 8011364:	b580      	push	{r7, lr}
 8011366:	b088      	sub	sp, #32
 8011368:	af00      	add	r7, sp, #0
 801136a:	6078      	str	r0, [r7, #4]
 801136c:	6039      	str	r1, [r7, #0]
    UINT32 writeLen;
    UINT32 bufSize = g_logBufSize;
 801136e:	4b43      	ldr	r3, [pc, #268]	; (801147c <OsWriteTailToEnd+0x118>)
 8011370:	681b      	ldr	r3, [r3, #0]
 8011372:	60fb      	str	r3, [r7, #12]
    UINT32 tail = g_dmesgInfo->logTail;
 8011374:	4b42      	ldr	r3, [pc, #264]	; (8011480 <OsWriteTailToEnd+0x11c>)
 8011376:	681b      	ldr	r3, [r3, #0]
 8011378:	689b      	ldr	r3, [r3, #8]
 801137a:	613b      	str	r3, [r7, #16]
    CHAR *buf = g_dmesgInfo->logBuf;
 801137c:	4b40      	ldr	r3, [pc, #256]	; (8011480 <OsWriteTailToEnd+0x11c>)
 801137e:	681b      	ldr	r3, [r3, #0]
 8011380:	68db      	ldr	r3, [r3, #12]
 8011382:	617b      	str	r3, [r7, #20]
    errno_t ret;

    if ((logLen == 0) || (dst == NULL)) {
 8011384:	683b      	ldr	r3, [r7, #0]
 8011386:	2b00      	cmp	r3, #0
 8011388:	d074      	beq.n	8011474 <OsWriteTailToEnd+0x110>
 801138a:	687b      	ldr	r3, [r7, #4]
 801138c:	2b00      	cmp	r3, #0
 801138e:	d071      	beq.n	8011474 <OsWriteTailToEnd+0x110>
        return;
    }
    if (logLen >= (bufSize - tail)) { /* need cycle to start ,then became B */
 8011390:	68fa      	ldr	r2, [r7, #12]
 8011392:	693b      	ldr	r3, [r7, #16]
 8011394:	1ad3      	subs	r3, r2, r3
 8011396:	683a      	ldr	r2, [r7, #0]
 8011398:	429a      	cmp	r2, r3
 801139a:	d341      	bcc.n	8011420 <OsWriteTailToEnd+0xbc>
        writeLen = bufSize - tail;
 801139c:	68fa      	ldr	r2, [r7, #12]
 801139e:	693b      	ldr	r3, [r7, #16]
 80113a0:	1ad3      	subs	r3, r2, r3
 80113a2:	61fb      	str	r3, [r7, #28]
        ret = memcpy_s(buf + tail, writeLen, dst, writeLen);
 80113a4:	697a      	ldr	r2, [r7, #20]
 80113a6:	693b      	ldr	r3, [r7, #16]
 80113a8:	18d0      	adds	r0, r2, r3
 80113aa:	69fb      	ldr	r3, [r7, #28]
 80113ac:	687a      	ldr	r2, [r7, #4]
 80113ae:	69f9      	ldr	r1, [r7, #28]
 80113b0:	f005 fe72 	bl	8017098 <memcpy_s>
 80113b4:	61b8      	str	r0, [r7, #24]
        if (ret != EOK) {
 80113b6:	69bb      	ldr	r3, [r7, #24]
 80113b8:	2b00      	cmp	r3, #0
 80113ba:	d00a      	beq.n	80113d2 <OsWriteTailToEnd+0x6e>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 80113bc:	4831      	ldr	r0, [pc, #196]	; (8011484 <OsWriteTailToEnd+0x120>)
 80113be:	f7f3 fa7f 	bl	80048c0 <dprintf>
 80113c2:	69bb      	ldr	r3, [r7, #24]
 80113c4:	f240 12cd 	movw	r2, #461	; 0x1cd
 80113c8:	492f      	ldr	r1, [pc, #188]	; (8011488 <OsWriteTailToEnd+0x124>)
 80113ca:	4830      	ldr	r0, [pc, #192]	; (801148c <OsWriteTailToEnd+0x128>)
 80113cc:	f7f3 fa78 	bl	80048c0 <dprintf>
            return;
 80113d0:	e051      	b.n	8011476 <OsWriteTailToEnd+0x112>
        }

        g_dmesgInfo->logSize += writeLen;
 80113d2:	4b2b      	ldr	r3, [pc, #172]	; (8011480 <OsWriteTailToEnd+0x11c>)
 80113d4:	681b      	ldr	r3, [r3, #0]
 80113d6:	6819      	ldr	r1, [r3, #0]
 80113d8:	4b29      	ldr	r3, [pc, #164]	; (8011480 <OsWriteTailToEnd+0x11c>)
 80113da:	681b      	ldr	r3, [r3, #0]
 80113dc:	69fa      	ldr	r2, [r7, #28]
 80113de:	440a      	add	r2, r1
 80113e0:	601a      	str	r2, [r3, #0]
        g_dmesgInfo->logTail = 0;
 80113e2:	4b27      	ldr	r3, [pc, #156]	; (8011480 <OsWriteTailToEnd+0x11c>)
 80113e4:	681b      	ldr	r3, [r3, #0]
 80113e6:	2200      	movs	r2, #0
 80113e8:	609a      	str	r2, [r3, #8]
        if (g_dmesgInfo->logSize == g_logBufSize) { /* Tail = Head is 0 */
 80113ea:	4b25      	ldr	r3, [pc, #148]	; (8011480 <OsWriteTailToEnd+0x11c>)
 80113ec:	681b      	ldr	r3, [r3, #0]
 80113ee:	681a      	ldr	r2, [r3, #0]
 80113f0:	4b22      	ldr	r3, [pc, #136]	; (801147c <OsWriteTailToEnd+0x118>)
 80113f2:	681b      	ldr	r3, [r3, #0]
 80113f4:	429a      	cmp	r2, r3
 80113f6:	d109      	bne.n	801140c <OsWriteTailToEnd+0xa8>
            OsBufFullWrite(dst + writeLen, logLen - writeLen);
 80113f8:	687a      	ldr	r2, [r7, #4]
 80113fa:	69fb      	ldr	r3, [r7, #28]
 80113fc:	18d0      	adds	r0, r2, r3
 80113fe:	683a      	ldr	r2, [r7, #0]
 8011400:	69fb      	ldr	r3, [r7, #28]
 8011402:	1ad3      	subs	r3, r2, r3
 8011404:	4619      	mov	r1, r3
 8011406:	f7ff fe39 	bl	801107c <OsBufFullWrite>
 801140a:	e034      	b.n	8011476 <OsWriteTailToEnd+0x112>
        } else {
            OsWriteTailToHead(dst + writeLen, logLen - writeLen);
 801140c:	687a      	ldr	r2, [r7, #4]
 801140e:	69fb      	ldr	r3, [r7, #28]
 8011410:	18d0      	adds	r0, r2, r3
 8011412:	683a      	ldr	r2, [r7, #0]
 8011414:	69fb      	ldr	r3, [r7, #28]
 8011416:	1ad3      	subs	r3, r2, r3
 8011418:	4619      	mov	r1, r3
 801141a:	f7ff ff19 	bl	8011250 <OsWriteTailToHead>
 801141e:	e02a      	b.n	8011476 <OsWriteTailToEnd+0x112>
        }
    } else { /* just do serial copy */
        ret = memcpy_s(buf + tail, bufSize - tail, dst, logLen);
 8011420:	697a      	ldr	r2, [r7, #20]
 8011422:	693b      	ldr	r3, [r7, #16]
 8011424:	18d0      	adds	r0, r2, r3
 8011426:	68fa      	ldr	r2, [r7, #12]
 8011428:	693b      	ldr	r3, [r7, #16]
 801142a:	1ad1      	subs	r1, r2, r3
 801142c:	683b      	ldr	r3, [r7, #0]
 801142e:	687a      	ldr	r2, [r7, #4]
 8011430:	f005 fe32 	bl	8017098 <memcpy_s>
 8011434:	61b8      	str	r0, [r7, #24]
        if (ret != EOK) {
 8011436:	69bb      	ldr	r3, [r7, #24]
 8011438:	2b00      	cmp	r3, #0
 801143a:	d00a      	beq.n	8011452 <OsWriteTailToEnd+0xee>
            PRINT_ERR("%s,%d memcpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 801143c:	4811      	ldr	r0, [pc, #68]	; (8011484 <OsWriteTailToEnd+0x120>)
 801143e:	f7f3 fa3f 	bl	80048c0 <dprintf>
 8011442:	69bb      	ldr	r3, [r7, #24]
 8011444:	f240 12db 	movw	r2, #475	; 0x1db
 8011448:	490f      	ldr	r1, [pc, #60]	; (8011488 <OsWriteTailToEnd+0x124>)
 801144a:	4810      	ldr	r0, [pc, #64]	; (801148c <OsWriteTailToEnd+0x128>)
 801144c:	f7f3 fa38 	bl	80048c0 <dprintf>
            return;
 8011450:	e011      	b.n	8011476 <OsWriteTailToEnd+0x112>
        }

        g_dmesgInfo->logTail += logLen;
 8011452:	4b0b      	ldr	r3, [pc, #44]	; (8011480 <OsWriteTailToEnd+0x11c>)
 8011454:	681b      	ldr	r3, [r3, #0]
 8011456:	6899      	ldr	r1, [r3, #8]
 8011458:	4b09      	ldr	r3, [pc, #36]	; (8011480 <OsWriteTailToEnd+0x11c>)
 801145a:	681b      	ldr	r3, [r3, #0]
 801145c:	683a      	ldr	r2, [r7, #0]
 801145e:	440a      	add	r2, r1
 8011460:	609a      	str	r2, [r3, #8]
        g_dmesgInfo->logSize += logLen;
 8011462:	4b07      	ldr	r3, [pc, #28]	; (8011480 <OsWriteTailToEnd+0x11c>)
 8011464:	681b      	ldr	r3, [r3, #0]
 8011466:	6819      	ldr	r1, [r3, #0]
 8011468:	4b05      	ldr	r3, [pc, #20]	; (8011480 <OsWriteTailToEnd+0x11c>)
 801146a:	681b      	ldr	r3, [r3, #0]
 801146c:	683a      	ldr	r2, [r7, #0]
 801146e:	440a      	add	r2, r1
 8011470:	601a      	str	r2, [r3, #0]
 8011472:	e000      	b.n	8011476 <OsWriteTailToEnd+0x112>
        return;
 8011474:	bf00      	nop
    }
}
 8011476:	3720      	adds	r7, #32
 8011478:	46bd      	mov	sp, r7
 801147a:	bd80      	pop	{r7, pc}
 801147c:	20003294 	.word	0x20003294
 8011480:	20003290 	.word	0x20003290
 8011484:	08021834 	.word	0x08021834
 8011488:	08023510 	.word	0x08023510
 801148c:	08021854 	.word	0x08021854

08011490 <OsLogMemcpyRecord>:

INT32 OsLogMemcpyRecord(const CHAR *buf, UINT32 logLen)
{
 8011490:	b580      	push	{r7, lr}
 8011492:	b084      	sub	sp, #16
 8011494:	af00      	add	r7, sp, #0
 8011496:	6078      	str	r0, [r7, #4]
 8011498:	6039      	str	r1, [r7, #0]
 801149a:	4b23      	ldr	r3, [pc, #140]	; (8011528 <OsLogMemcpyRecord+0x98>)
 801149c:	681b      	ldr	r3, [r3, #0]
 801149e:	60fb      	str	r3, [r7, #12]
 80114a0:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    LOS_SpinLockSave(&g_dmesgSpin, &intSave);
 80114a4:	f107 0308 	add.w	r3, r7, #8
 80114a8:	4619      	mov	r1, r3
 80114aa:	4820      	ldr	r0, [pc, #128]	; (801152c <OsLogMemcpyRecord+0x9c>)
 80114ac:	f7ff faf7 	bl	8010a9e <LOS_SpinLockSave>
    if (OsCheckError()) {
 80114b0:	f7ff fb40 	bl	8010b34 <OsCheckError>
 80114b4:	4603      	mov	r3, r0
 80114b6:	2b00      	cmp	r3, #0
 80114b8:	d007      	beq.n	80114ca <OsLogMemcpyRecord+0x3a>
        LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 80114ba:	68bb      	ldr	r3, [r7, #8]
 80114bc:	4619      	mov	r1, r3
 80114be:	481b      	ldr	r0, [pc, #108]	; (801152c <OsLogMemcpyRecord+0x9c>)
 80114c0:	f7ff fafb 	bl	8010aba <LOS_SpinUnlockRestore>
        return -1;
 80114c4:	f04f 33ff 	mov.w	r3, #4294967295
 80114c8:	e022      	b.n	8011510 <OsLogMemcpyRecord+0x80>
    }
    if (g_dmesgInfo->logSize < g_logBufSize) {
 80114ca:	4b19      	ldr	r3, [pc, #100]	; (8011530 <OsLogMemcpyRecord+0xa0>)
 80114cc:	681b      	ldr	r3, [r3, #0]
 80114ce:	681a      	ldr	r2, [r3, #0]
 80114d0:	4b18      	ldr	r3, [pc, #96]	; (8011534 <OsLogMemcpyRecord+0xa4>)
 80114d2:	681b      	ldr	r3, [r3, #0]
 80114d4:	429a      	cmp	r2, r3
 80114d6:	d211      	bcs.n	80114fc <OsLogMemcpyRecord+0x6c>
        if (g_dmesgInfo->logHead <= g_dmesgInfo->logTail) {
 80114d8:	4b15      	ldr	r3, [pc, #84]	; (8011530 <OsLogMemcpyRecord+0xa0>)
 80114da:	681b      	ldr	r3, [r3, #0]
 80114dc:	685a      	ldr	r2, [r3, #4]
 80114de:	4b14      	ldr	r3, [pc, #80]	; (8011530 <OsLogMemcpyRecord+0xa0>)
 80114e0:	681b      	ldr	r3, [r3, #0]
 80114e2:	689b      	ldr	r3, [r3, #8]
 80114e4:	429a      	cmp	r2, r3
 80114e6:	d804      	bhi.n	80114f2 <OsLogMemcpyRecord+0x62>
            OsWriteTailToEnd(buf, logLen);
 80114e8:	6839      	ldr	r1, [r7, #0]
 80114ea:	6878      	ldr	r0, [r7, #4]
 80114ec:	f7ff ff3a 	bl	8011364 <OsWriteTailToEnd>
 80114f0:	e008      	b.n	8011504 <OsLogMemcpyRecord+0x74>
        } else {
            OsWriteTailToHead(buf, logLen);
 80114f2:	6839      	ldr	r1, [r7, #0]
 80114f4:	6878      	ldr	r0, [r7, #4]
 80114f6:	f7ff feab 	bl	8011250 <OsWriteTailToHead>
 80114fa:	e003      	b.n	8011504 <OsLogMemcpyRecord+0x74>
        }
    } else {
        OsBufFullWrite(buf, logLen);
 80114fc:	6839      	ldr	r1, [r7, #0]
 80114fe:	6878      	ldr	r0, [r7, #4]
 8011500:	f7ff fdbc 	bl	801107c <OsBufFullWrite>
    }
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8011504:	68bb      	ldr	r3, [r7, #8]
 8011506:	4619      	mov	r1, r3
 8011508:	4808      	ldr	r0, [pc, #32]	; (801152c <OsLogMemcpyRecord+0x9c>)
 801150a:	f7ff fad6 	bl	8010aba <LOS_SpinUnlockRestore>

    return LOS_OK;
 801150e:	2300      	movs	r3, #0
}
 8011510:	4a05      	ldr	r2, [pc, #20]	; (8011528 <OsLogMemcpyRecord+0x98>)
 8011512:	6811      	ldr	r1, [r2, #0]
 8011514:	68fa      	ldr	r2, [r7, #12]
 8011516:	4051      	eors	r1, r2
 8011518:	d001      	beq.n	801151e <OsLogMemcpyRecord+0x8e>
 801151a:	f7f3 f85f 	bl	80045dc <__stack_chk_fail>
 801151e:	4618      	mov	r0, r3
 8011520:	3710      	adds	r7, #16
 8011522:	46bd      	mov	sp, r7
 8011524:	bd80      	pop	{r7, pc}
 8011526:	bf00      	nop
 8011528:	08021880 	.word	0x08021880
 801152c:	2000328c 	.word	0x2000328c
 8011530:	20003290 	.word	0x20003290
 8011534:	20003294 	.word	0x20003294

08011538 <OsLogShow>:

VOID OsLogShow(VOID)
{
 8011538:	b580      	push	{r7, lr}
 801153a:	b086      	sub	sp, #24
 801153c:	af00      	add	r7, sp, #0
 801153e:	4b36      	ldr	r3, [pc, #216]	; (8011618 <OsLogShow+0xe0>)
 8011540:	681b      	ldr	r3, [r3, #0]
 8011542:	617b      	str	r3, [r7, #20]
 8011544:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 index;
    UINT32 i = 0;
 8011548:	2300      	movs	r3, #0
 801154a:	60fb      	str	r3, [r7, #12]
    CHAR *p = NULL;
 801154c:	2300      	movs	r3, #0
 801154e:	613b      	str	r3, [r7, #16]

    LOS_SpinLockSave(&g_dmesgSpin, &intSave);
 8011550:	1d3b      	adds	r3, r7, #4
 8011552:	4619      	mov	r1, r3
 8011554:	4831      	ldr	r0, [pc, #196]	; (801161c <OsLogShow+0xe4>)
 8011556:	f7ff faa2 	bl	8010a9e <LOS_SpinLockSave>
    index = g_dmesgInfo->logHead;
 801155a:	4b31      	ldr	r3, [pc, #196]	; (8011620 <OsLogShow+0xe8>)
 801155c:	681b      	ldr	r3, [r3, #0]
 801155e:	685b      	ldr	r3, [r3, #4]
 8011560:	60bb      	str	r3, [r7, #8]
    p = (CHAR *)malloc(g_dmesgInfo->logSize + 1);
 8011562:	4b2f      	ldr	r3, [pc, #188]	; (8011620 <OsLogShow+0xe8>)
 8011564:	681b      	ldr	r3, [r3, #0]
 8011566:	681b      	ldr	r3, [r3, #0]
 8011568:	3301      	adds	r3, #1
 801156a:	4618      	mov	r0, r3
 801156c:	f009 fa5c 	bl	801aa28 <malloc>
 8011570:	6138      	str	r0, [r7, #16]
    if (p == NULL) {
 8011572:	693b      	ldr	r3, [r7, #16]
 8011574:	2b00      	cmp	r3, #0
 8011576:	d105      	bne.n	8011584 <OsLogShow+0x4c>
        LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 8011578:	687b      	ldr	r3, [r7, #4]
 801157a:	4619      	mov	r1, r3
 801157c:	4827      	ldr	r0, [pc, #156]	; (801161c <OsLogShow+0xe4>)
 801157e:	f7ff fa9c 	bl	8010aba <LOS_SpinUnlockRestore>
 8011582:	e03e      	b.n	8011602 <OsLogShow+0xca>
        return;
    }
    (VOID)memset_s(p, g_dmesgInfo->logSize + 1, 0, g_dmesgInfo->logSize + 1);
 8011584:	4b26      	ldr	r3, [pc, #152]	; (8011620 <OsLogShow+0xe8>)
 8011586:	681b      	ldr	r3, [r3, #0]
 8011588:	681b      	ldr	r3, [r3, #0]
 801158a:	1c59      	adds	r1, r3, #1
 801158c:	4b24      	ldr	r3, [pc, #144]	; (8011620 <OsLogShow+0xe8>)
 801158e:	681b      	ldr	r3, [r3, #0]
 8011590:	681b      	ldr	r3, [r3, #0]
 8011592:	3301      	adds	r3, #1
 8011594:	2200      	movs	r2, #0
 8011596:	6938      	ldr	r0, [r7, #16]
 8011598:	f7f0 fd84 	bl	80020a4 <memset_s>

    while (i < g_dmesgInfo->logSize) {
 801159c:	e01c      	b.n	80115d8 <OsLogShow+0xa0>
        *(p + i) = *(g_dmesgInfo->logBuf + index++);
 801159e:	4b20      	ldr	r3, [pc, #128]	; (8011620 <OsLogShow+0xe8>)
 80115a0:	681b      	ldr	r3, [r3, #0]
 80115a2:	68da      	ldr	r2, [r3, #12]
 80115a4:	68bb      	ldr	r3, [r7, #8]
 80115a6:	1c59      	adds	r1, r3, #1
 80115a8:	60b9      	str	r1, [r7, #8]
 80115aa:	441a      	add	r2, r3
 80115ac:	6939      	ldr	r1, [r7, #16]
 80115ae:	68fb      	ldr	r3, [r7, #12]
 80115b0:	440b      	add	r3, r1
 80115b2:	7812      	ldrb	r2, [r2, #0]
 80115b4:	701a      	strb	r2, [r3, #0]
        if (index > BUF_MAX_INDEX) {
 80115b6:	4b1b      	ldr	r3, [pc, #108]	; (8011624 <OsLogShow+0xec>)
 80115b8:	681b      	ldr	r3, [r3, #0]
 80115ba:	3b01      	subs	r3, #1
 80115bc:	68ba      	ldr	r2, [r7, #8]
 80115be:	429a      	cmp	r2, r3
 80115c0:	d901      	bls.n	80115c6 <OsLogShow+0x8e>
            index = 0;
 80115c2:	2300      	movs	r3, #0
 80115c4:	60bb      	str	r3, [r7, #8]
        }
        i++;
 80115c6:	68fb      	ldr	r3, [r7, #12]
 80115c8:	3301      	adds	r3, #1
 80115ca:	60fb      	str	r3, [r7, #12]
        if (index == g_dmesgInfo->logTail) {
 80115cc:	4b14      	ldr	r3, [pc, #80]	; (8011620 <OsLogShow+0xe8>)
 80115ce:	681b      	ldr	r3, [r3, #0]
 80115d0:	689b      	ldr	r3, [r3, #8]
 80115d2:	68ba      	ldr	r2, [r7, #8]
 80115d4:	429a      	cmp	r2, r3
 80115d6:	d006      	beq.n	80115e6 <OsLogShow+0xae>
    while (i < g_dmesgInfo->logSize) {
 80115d8:	4b11      	ldr	r3, [pc, #68]	; (8011620 <OsLogShow+0xe8>)
 80115da:	681b      	ldr	r3, [r3, #0]
 80115dc:	681b      	ldr	r3, [r3, #0]
 80115de:	68fa      	ldr	r2, [r7, #12]
 80115e0:	429a      	cmp	r2, r3
 80115e2:	d3dc      	bcc.n	801159e <OsLogShow+0x66>
 80115e4:	e000      	b.n	80115e8 <OsLogShow+0xb0>
            break;
 80115e6:	bf00      	nop
        }
    }
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 80115e8:	687b      	ldr	r3, [r7, #4]
 80115ea:	4619      	mov	r1, r3
 80115ec:	480b      	ldr	r0, [pc, #44]	; (801161c <OsLogShow+0xe4>)
 80115ee:	f7ff fa64 	bl	8010aba <LOS_SpinUnlockRestore>
    UartPuts(p, i, UART_WITH_LOCK);
 80115f2:	2201      	movs	r2, #1
 80115f4:	68f9      	ldr	r1, [r7, #12]
 80115f6:	6938      	ldr	r0, [r7, #16]
 80115f8:	f7ff fa10 	bl	8010a1c <UartPuts>
    free(p);
 80115fc:	6938      	ldr	r0, [r7, #16]
 80115fe:	f009 f9ff 	bl	801aa00 <free>
}
 8011602:	4b05      	ldr	r3, [pc, #20]	; (8011618 <OsLogShow+0xe0>)
 8011604:	681a      	ldr	r2, [r3, #0]
 8011606:	697b      	ldr	r3, [r7, #20]
 8011608:	405a      	eors	r2, r3
 801160a:	d001      	beq.n	8011610 <OsLogShow+0xd8>
 801160c:	f7f2 ffe6 	bl	80045dc <__stack_chk_fail>
 8011610:	3718      	adds	r7, #24
 8011612:	46bd      	mov	sp, r7
 8011614:	bd80      	pop	{r7, pc}
 8011616:	bf00      	nop
 8011618:	08021884 	.word	0x08021884
 801161c:	2000328c 	.word	0x2000328c
 8011620:	20003290 	.word	0x20003290
 8011624:	20003294 	.word	0x20003294

08011628 <OsDmesgLvSet>:

STATIC INT32 OsDmesgLvSet(const CHAR *level)
{
 8011628:	b580      	push	{r7, lr}
 801162a:	b086      	sub	sp, #24
 801162c:	af00      	add	r7, sp, #0
 801162e:	6078      	str	r0, [r7, #4]
 8011630:	4b21      	ldr	r3, [pc, #132]	; (80116b8 <OsDmesgLvSet+0x90>)
 8011632:	681b      	ldr	r3, [r3, #0]
 8011634:	617b      	str	r3, [r7, #20]
 8011636:	f04f 0300 	mov.w	r3, #0
    UINT32 levelNum, ret;
    CHAR *p = NULL;
 801163a:	2300      	movs	r3, #0
 801163c:	60bb      	str	r3, [r7, #8]

    levelNum = strtoul(level, &p, 0);
 801163e:	f107 0308 	add.w	r3, r7, #8
 8011642:	2200      	movs	r2, #0
 8011644:	4619      	mov	r1, r3
 8011646:	6878      	ldr	r0, [r7, #4]
 8011648:	f7fe f804 	bl	800f654 <strtoul>
 801164c:	60f8      	str	r0, [r7, #12]
    if (*p != 0) {
 801164e:	68bb      	ldr	r3, [r7, #8]
 8011650:	781b      	ldrb	r3, [r3, #0]
 8011652:	2b00      	cmp	r3, #0
 8011654:	d005      	beq.n	8011662 <OsDmesgLvSet+0x3a>
        PRINTK("dmesg: invalid option or parameter.\n");
 8011656:	4819      	ldr	r0, [pc, #100]	; (80116bc <OsDmesgLvSet+0x94>)
 8011658:	f7f3 f932 	bl	80048c0 <dprintf>
        return -1;
 801165c:	f04f 33ff 	mov.w	r3, #4294967295
 8011660:	e01f      	b.n	80116a2 <OsDmesgLvSet+0x7a>
    }

    ret = LOS_DmesgLvSet(levelNum);
 8011662:	68f8      	ldr	r0, [r7, #12]
 8011664:	f000 f86c 	bl	8011740 <LOS_DmesgLvSet>
 8011668:	6138      	str	r0, [r7, #16]
    if (ret == LOS_OK) {
 801166a:	693b      	ldr	r3, [r7, #16]
 801166c:	2b00      	cmp	r3, #0
 801166e:	d10a      	bne.n	8011686 <OsDmesgLvSet+0x5e>
        PRINTK("Set current dmesg log level %s\n", g_levelString[g_dmesgLogLevel]);
 8011670:	4b13      	ldr	r3, [pc, #76]	; (80116c0 <OsDmesgLvSet+0x98>)
 8011672:	681b      	ldr	r3, [r3, #0]
 8011674:	4a13      	ldr	r2, [pc, #76]	; (80116c4 <OsDmesgLvSet+0x9c>)
 8011676:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801167a:	4619      	mov	r1, r3
 801167c:	4812      	ldr	r0, [pc, #72]	; (80116c8 <OsDmesgLvSet+0xa0>)
 801167e:	f7f3 f91f 	bl	80048c0 <dprintf>
        return LOS_OK;
 8011682:	2300      	movs	r3, #0
 8011684:	e00d      	b.n	80116a2 <OsDmesgLvSet+0x7a>
    } else {
        PRINTK("current dmesg log level %s\n", g_levelString[g_dmesgLogLevel]);
 8011686:	4b0e      	ldr	r3, [pc, #56]	; (80116c0 <OsDmesgLvSet+0x98>)
 8011688:	681b      	ldr	r3, [r3, #0]
 801168a:	4a0e      	ldr	r2, [pc, #56]	; (80116c4 <OsDmesgLvSet+0x9c>)
 801168c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8011690:	4619      	mov	r1, r3
 8011692:	480e      	ldr	r0, [pc, #56]	; (80116cc <OsDmesgLvSet+0xa4>)
 8011694:	f7f3 f914 	bl	80048c0 <dprintf>
        PRINTK("dmesg -l [num] can access as 0:EMG 1:COMMOM 2:ERROR 3:WARN 4:INFO 5:DEBUG\n");
 8011698:	480d      	ldr	r0, [pc, #52]	; (80116d0 <OsDmesgLvSet+0xa8>)
 801169a:	f7f3 f911 	bl	80048c0 <dprintf>
        return -1;
 801169e:	f04f 33ff 	mov.w	r3, #4294967295
    }
}
 80116a2:	4a05      	ldr	r2, [pc, #20]	; (80116b8 <OsDmesgLvSet+0x90>)
 80116a4:	6811      	ldr	r1, [r2, #0]
 80116a6:	697a      	ldr	r2, [r7, #20]
 80116a8:	4051      	eors	r1, r2
 80116aa:	d001      	beq.n	80116b0 <OsDmesgLvSet+0x88>
 80116ac:	f7f2 ff96 	bl	80045dc <__stack_chk_fail>
 80116b0:	4618      	mov	r0, r3
 80116b2:	3718      	adds	r7, #24
 80116b4:	46bd      	mov	sp, r7
 80116b6:	bd80      	pop	{r7, pc}
 80116b8:	08021938 	.word	0x08021938
 80116bc:	08021888 	.word	0x08021888
 80116c0:	20000484 	.word	0x20000484
 80116c4:	20000488 	.word	0x20000488
 80116c8:	080218b0 	.word	0x080218b0
 80116cc:	080218d0 	.word	0x080218d0
 80116d0:	080218ec 	.word	0x080218ec

080116d4 <OsDmesgMemSizeSet>:

STATIC INT32 OsDmesgMemSizeSet(const CHAR *size)
{
 80116d4:	b580      	push	{r7, lr}
 80116d6:	b086      	sub	sp, #24
 80116d8:	af00      	add	r7, sp, #0
 80116da:	6078      	str	r0, [r7, #4]
 80116dc:	4b15      	ldr	r3, [pc, #84]	; (8011734 <OsDmesgMemSizeSet+0x60>)
 80116de:	681b      	ldr	r3, [r3, #0]
 80116e0:	617b      	str	r3, [r7, #20]
 80116e2:	f04f 0300 	mov.w	r3, #0
    UINT32 sizeVal;
    CHAR *p = NULL;
 80116e6:	2300      	movs	r3, #0
 80116e8:	60fb      	str	r3, [r7, #12]

    sizeVal = strtoul(size, &p, 0);
 80116ea:	f107 030c 	add.w	r3, r7, #12
 80116ee:	2200      	movs	r2, #0
 80116f0:	4619      	mov	r1, r3
 80116f2:	6878      	ldr	r0, [r7, #4]
 80116f4:	f7fd ffae 	bl	800f654 <strtoul>
 80116f8:	6138      	str	r0, [r7, #16]
    if (!(LOS_DmesgMemSet(NULL, sizeVal))) {
 80116fa:	6939      	ldr	r1, [r7, #16]
 80116fc:	2000      	movs	r0, #0
 80116fe:	f000 f871 	bl	80117e4 <LOS_DmesgMemSet>
 8011702:	4603      	mov	r3, r0
 8011704:	2b00      	cmp	r3, #0
 8011706:	d105      	bne.n	8011714 <OsDmesgMemSizeSet+0x40>
        PRINTK("Set dmesg buf size %u success\n", sizeVal);
 8011708:	6939      	ldr	r1, [r7, #16]
 801170a:	480b      	ldr	r0, [pc, #44]	; (8011738 <OsDmesgMemSizeSet+0x64>)
 801170c:	f7f3 f8d8 	bl	80048c0 <dprintf>
        return LOS_OK;
 8011710:	2300      	movs	r3, #0
 8011712:	e004      	b.n	801171e <OsDmesgMemSizeSet+0x4a>
    } else {
        PRINTK("Set dmesg buf size %u fail\n", sizeVal);
 8011714:	6939      	ldr	r1, [r7, #16]
 8011716:	4809      	ldr	r0, [pc, #36]	; (801173c <OsDmesgMemSizeSet+0x68>)
 8011718:	f7f3 f8d2 	bl	80048c0 <dprintf>
        return LOS_NOK;
 801171c:	2301      	movs	r3, #1
    }
}
 801171e:	4a05      	ldr	r2, [pc, #20]	; (8011734 <OsDmesgMemSizeSet+0x60>)
 8011720:	6811      	ldr	r1, [r2, #0]
 8011722:	697a      	ldr	r2, [r7, #20]
 8011724:	4051      	eors	r1, r2
 8011726:	d001      	beq.n	801172c <OsDmesgMemSizeSet+0x58>
 8011728:	f7f2 ff58 	bl	80045dc <__stack_chk_fail>
 801172c:	4618      	mov	r0, r3
 801172e:	3718      	adds	r7, #24
 8011730:	46bd      	mov	sp, r7
 8011732:	bd80      	pop	{r7, pc}
 8011734:	08021978 	.word	0x08021978
 8011738:	0802193c 	.word	0x0802193c
 801173c:	0802195c 	.word	0x0802195c

08011740 <LOS_DmesgLvSet>:
{
    return g_dmesgLogLevel;
}

UINT32 LOS_DmesgLvSet(UINT32 level)
{
 8011740:	b480      	push	{r7}
 8011742:	b083      	sub	sp, #12
 8011744:	af00      	add	r7, sp, #0
 8011746:	6078      	str	r0, [r7, #4]
    if (level > 5) { /* 5: count of level */
 8011748:	687b      	ldr	r3, [r7, #4]
 801174a:	2b05      	cmp	r3, #5
 801174c:	d901      	bls.n	8011752 <LOS_DmesgLvSet+0x12>
        return LOS_NOK;
 801174e:	2301      	movs	r3, #1
 8011750:	e003      	b.n	801175a <LOS_DmesgLvSet+0x1a>
    }

    g_dmesgLogLevel = level;
 8011752:	4a05      	ldr	r2, [pc, #20]	; (8011768 <LOS_DmesgLvSet+0x28>)
 8011754:	687b      	ldr	r3, [r7, #4]
 8011756:	6013      	str	r3, [r2, #0]
    return LOS_OK;
 8011758:	2300      	movs	r3, #0
}
 801175a:	4618      	mov	r0, r3
 801175c:	370c      	adds	r7, #12
 801175e:	46bd      	mov	sp, r7
 8011760:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011764:	4770      	bx	lr
 8011766:	bf00      	nop
 8011768:	20000484 	.word	0x20000484

0801176c <LOS_DmesgClear>:

VOID LOS_DmesgClear(VOID)
{
 801176c:	b580      	push	{r7, lr}
 801176e:	b082      	sub	sp, #8
 8011770:	af00      	add	r7, sp, #0
 8011772:	4b18      	ldr	r3, [pc, #96]	; (80117d4 <LOS_DmesgClear+0x68>)
 8011774:	681b      	ldr	r3, [r3, #0]
 8011776:	607b      	str	r3, [r7, #4]
 8011778:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    LOS_SpinLockSave(&g_dmesgSpin, &intSave);
 801177c:	463b      	mov	r3, r7
 801177e:	4619      	mov	r1, r3
 8011780:	4815      	ldr	r0, [pc, #84]	; (80117d8 <LOS_DmesgClear+0x6c>)
 8011782:	f7ff f98c 	bl	8010a9e <LOS_SpinLockSave>
    (VOID)memset_s(g_dmesgInfo->logBuf, g_logBufSize, 0, g_logBufSize);
 8011786:	4b15      	ldr	r3, [pc, #84]	; (80117dc <LOS_DmesgClear+0x70>)
 8011788:	681b      	ldr	r3, [r3, #0]
 801178a:	68d8      	ldr	r0, [r3, #12]
 801178c:	4b14      	ldr	r3, [pc, #80]	; (80117e0 <LOS_DmesgClear+0x74>)
 801178e:	6819      	ldr	r1, [r3, #0]
 8011790:	4b13      	ldr	r3, [pc, #76]	; (80117e0 <LOS_DmesgClear+0x74>)
 8011792:	681b      	ldr	r3, [r3, #0]
 8011794:	2200      	movs	r2, #0
 8011796:	f7f0 fc85 	bl	80020a4 <memset_s>
    g_dmesgInfo->logHead = 0;
 801179a:	4b10      	ldr	r3, [pc, #64]	; (80117dc <LOS_DmesgClear+0x70>)
 801179c:	681b      	ldr	r3, [r3, #0]
 801179e:	2200      	movs	r2, #0
 80117a0:	605a      	str	r2, [r3, #4]
    g_dmesgInfo->logTail = 0;
 80117a2:	4b0e      	ldr	r3, [pc, #56]	; (80117dc <LOS_DmesgClear+0x70>)
 80117a4:	681b      	ldr	r3, [r3, #0]
 80117a6:	2200      	movs	r2, #0
 80117a8:	609a      	str	r2, [r3, #8]
    g_dmesgInfo->logSize = 0;
 80117aa:	4b0c      	ldr	r3, [pc, #48]	; (80117dc <LOS_DmesgClear+0x70>)
 80117ac:	681b      	ldr	r3, [r3, #0]
 80117ae:	2200      	movs	r2, #0
 80117b0:	601a      	str	r2, [r3, #0]
    LOS_SpinUnlockRestore(&g_dmesgSpin, intSave);
 80117b2:	683b      	ldr	r3, [r7, #0]
 80117b4:	4619      	mov	r1, r3
 80117b6:	4808      	ldr	r0, [pc, #32]	; (80117d8 <LOS_DmesgClear+0x6c>)
 80117b8:	f7ff f97f 	bl	8010aba <LOS_SpinUnlockRestore>
}
 80117bc:	bf00      	nop
 80117be:	4b05      	ldr	r3, [pc, #20]	; (80117d4 <LOS_DmesgClear+0x68>)
 80117c0:	681a      	ldr	r2, [r3, #0]
 80117c2:	687b      	ldr	r3, [r7, #4]
 80117c4:	405a      	eors	r2, r3
 80117c6:	d001      	beq.n	80117cc <LOS_DmesgClear+0x60>
 80117c8:	f7f2 ff08 	bl	80045dc <__stack_chk_fail>
 80117cc:	3708      	adds	r7, #8
 80117ce:	46bd      	mov	sp, r7
 80117d0:	bd80      	pop	{r7, pc}
 80117d2:	bf00      	nop
 80117d4:	0802197c 	.word	0x0802197c
 80117d8:	2000328c 	.word	0x2000328c
 80117dc:	20003290 	.word	0x20003290
 80117e0:	20003294 	.word	0x20003294

080117e4 <LOS_DmesgMemSet>:

UINT32 LOS_DmesgMemSet(VOID *addr, UINT32 size)
{
 80117e4:	b580      	push	{r7, lr}
 80117e6:	b084      	sub	sp, #16
 80117e8:	af00      	add	r7, sp, #0
 80117ea:	6078      	str	r0, [r7, #4]
 80117ec:	6039      	str	r1, [r7, #0]
    UINT32 ret;

    if (addr == NULL) {
 80117ee:	687b      	ldr	r3, [r7, #4]
 80117f0:	2b00      	cmp	r3, #0
 80117f2:	d104      	bne.n	80117fe <LOS_DmesgMemSet+0x1a>
        ret = OsDmesgChangeSize(size);
 80117f4:	6838      	ldr	r0, [r7, #0]
 80117f6:	f7ff fb81 	bl	8010efc <OsDmesgChangeSize>
 80117fa:	60f8      	str	r0, [r7, #12]
 80117fc:	e004      	b.n	8011808 <LOS_DmesgMemSet+0x24>
    } else {
        ret = OsDmesgResetMem(addr, size);
 80117fe:	6839      	ldr	r1, [r7, #0]
 8011800:	6878      	ldr	r0, [r7, #4]
 8011802:	f7ff fb0d 	bl	8010e20 <OsDmesgResetMem>
 8011806:	60f8      	str	r0, [r7, #12]
    }
    return ret;
 8011808:	68fb      	ldr	r3, [r7, #12]
}
 801180a:	4618      	mov	r0, r3
 801180c:	3710      	adds	r7, #16
 801180e:	46bd      	mov	sp, r7
 8011810:	bd80      	pop	{r7, pc}
	...

08011814 <LOS_DmesgToFile>:
    free(fullpath);
    return ret;
}
#else
INT32 LOS_DmesgToFile(CHAR *filename)
{
 8011814:	b580      	push	{r7, lr}
 8011816:	b082      	sub	sp, #8
 8011818:	af00      	add	r7, sp, #0
 801181a:	6078      	str	r0, [r7, #4]
    (VOID)filename;
    PRINTK("File operation need VFS\n");
 801181c:	4804      	ldr	r0, [pc, #16]	; (8011830 <LOS_DmesgToFile+0x1c>)
 801181e:	f7f3 f84f 	bl	80048c0 <dprintf>
    return -1;
 8011822:	f04f 33ff 	mov.w	r3, #4294967295
}
 8011826:	4618      	mov	r0, r3
 8011828:	3708      	adds	r7, #8
 801182a:	46bd      	mov	sp, r7
 801182c:	bd80      	pop	{r7, pc}
 801182e:	bf00      	nop
 8011830:	08021984 	.word	0x08021984

08011834 <OsShellCmdDmesg>:
#endif

INT32 OsShellCmdDmesg(INT32 argc, const CHAR **argv)
{
 8011834:	b580      	push	{r7, lr}
 8011836:	b082      	sub	sp, #8
 8011838:	af00      	add	r7, sp, #0
 801183a:	6078      	str	r0, [r7, #4]
 801183c:	6039      	str	r1, [r7, #0]
    if (argc == 1) {
 801183e:	687b      	ldr	r3, [r7, #4]
 8011840:	2b01      	cmp	r3, #1
 8011842:	d106      	bne.n	8011852 <OsShellCmdDmesg+0x1e>
        PRINTK("\n");
 8011844:	485c      	ldr	r0, [pc, #368]	; (80119b8 <OsShellCmdDmesg+0x184>)
 8011846:	f7f3 f83b 	bl	80048c0 <dprintf>
        OsLogShow();
 801184a:	f7ff fe75 	bl	8011538 <OsLogShow>
        return LOS_OK;
 801184e:	2300      	movs	r3, #0
 8011850:	e0ad      	b.n	80119ae <OsShellCmdDmesg+0x17a>
    } else if (argc == 2) { /* 2: count of parameters */
 8011852:	687b      	ldr	r3, [r7, #4]
 8011854:	2b02      	cmp	r3, #2
 8011856:	d158      	bne.n	801190a <OsShellCmdDmesg+0xd6>
        if (!strcmp(argv[1], "-c")) {
 8011858:	683b      	ldr	r3, [r7, #0]
 801185a:	3304      	adds	r3, #4
 801185c:	681b      	ldr	r3, [r3, #0]
 801185e:	4957      	ldr	r1, [pc, #348]	; (80119bc <OsShellCmdDmesg+0x188>)
 8011860:	4618      	mov	r0, r3
 8011862:	f7fd fe52 	bl	800f50a <strcmp>
 8011866:	4603      	mov	r3, r0
 8011868:	2b00      	cmp	r3, #0
 801186a:	d108      	bne.n	801187e <OsShellCmdDmesg+0x4a>
            PRINTK("\n");
 801186c:	4852      	ldr	r0, [pc, #328]	; (80119b8 <OsShellCmdDmesg+0x184>)
 801186e:	f7f3 f827 	bl	80048c0 <dprintf>
            OsLogShow();
 8011872:	f7ff fe61 	bl	8011538 <OsLogShow>
            LOS_DmesgClear();
 8011876:	f7ff ff79 	bl	801176c <LOS_DmesgClear>
            return LOS_OK;
 801187a:	2300      	movs	r3, #0
 801187c:	e097      	b.n	80119ae <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-C")) {
 801187e:	683b      	ldr	r3, [r7, #0]
 8011880:	3304      	adds	r3, #4
 8011882:	681b      	ldr	r3, [r3, #0]
 8011884:	494e      	ldr	r1, [pc, #312]	; (80119c0 <OsShellCmdDmesg+0x18c>)
 8011886:	4618      	mov	r0, r3
 8011888:	f7fd fe3f 	bl	800f50a <strcmp>
 801188c:	4603      	mov	r3, r0
 801188e:	2b00      	cmp	r3, #0
 8011890:	d103      	bne.n	801189a <OsShellCmdDmesg+0x66>
            LOS_DmesgClear();
 8011892:	f7ff ff6b 	bl	801176c <LOS_DmesgClear>
            return LOS_OK;
 8011896:	2300      	movs	r3, #0
 8011898:	e089      	b.n	80119ae <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-D")) {
 801189a:	683b      	ldr	r3, [r7, #0]
 801189c:	3304      	adds	r3, #4
 801189e:	681b      	ldr	r3, [r3, #0]
 80118a0:	4948      	ldr	r1, [pc, #288]	; (80119c4 <OsShellCmdDmesg+0x190>)
 80118a2:	4618      	mov	r0, r3
 80118a4:	f7fd fe31 	bl	800f50a <strcmp>
 80118a8:	4603      	mov	r3, r0
 80118aa:	2b00      	cmp	r3, #0
 80118ac:	d103      	bne.n	80118b6 <OsShellCmdDmesg+0x82>
            OsLockConsole();
 80118ae:	f7ff f911 	bl	8010ad4 <OsLockConsole>
            return LOS_OK;
 80118b2:	2300      	movs	r3, #0
 80118b4:	e07b      	b.n	80119ae <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-E")) {
 80118b6:	683b      	ldr	r3, [r7, #0]
 80118b8:	3304      	adds	r3, #4
 80118ba:	681b      	ldr	r3, [r3, #0]
 80118bc:	4942      	ldr	r1, [pc, #264]	; (80119c8 <OsShellCmdDmesg+0x194>)
 80118be:	4618      	mov	r0, r3
 80118c0:	f7fd fe23 	bl	800f50a <strcmp>
 80118c4:	4603      	mov	r3, r0
 80118c6:	2b00      	cmp	r3, #0
 80118c8:	d103      	bne.n	80118d2 <OsShellCmdDmesg+0x9e>
            OsUnlockConsole();
 80118ca:	f7ff f90f 	bl	8010aec <OsUnlockConsole>
            return LOS_OK;
 80118ce:	2300      	movs	r3, #0
 80118d0:	e06d      	b.n	80119ae <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-L")) {
 80118d2:	683b      	ldr	r3, [r7, #0]
 80118d4:	3304      	adds	r3, #4
 80118d6:	681b      	ldr	r3, [r3, #0]
 80118d8:	493c      	ldr	r1, [pc, #240]	; (80119cc <OsShellCmdDmesg+0x198>)
 80118da:	4618      	mov	r0, r3
 80118dc:	f7fd fe15 	bl	800f50a <strcmp>
 80118e0:	4603      	mov	r3, r0
 80118e2:	2b00      	cmp	r3, #0
 80118e4:	d103      	bne.n	80118ee <OsShellCmdDmesg+0xba>
            OsLockUart();
 80118e6:	f7ff f90d 	bl	8010b04 <OsLockUart>
            return LOS_OK;
 80118ea:	2300      	movs	r3, #0
 80118ec:	e05f      	b.n	80119ae <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-U")) {
 80118ee:	683b      	ldr	r3, [r7, #0]
 80118f0:	3304      	adds	r3, #4
 80118f2:	681b      	ldr	r3, [r3, #0]
 80118f4:	4936      	ldr	r1, [pc, #216]	; (80119d0 <OsShellCmdDmesg+0x19c>)
 80118f6:	4618      	mov	r0, r3
 80118f8:	f7fd fe07 	bl	800f50a <strcmp>
 80118fc:	4603      	mov	r3, r0
 80118fe:	2b00      	cmp	r3, #0
 8011900:	d150      	bne.n	80119a4 <OsShellCmdDmesg+0x170>
            OsUnlockUart();
 8011902:	f7ff f90b 	bl	8010b1c <OsUnlockUart>
            return LOS_OK;
 8011906:	2300      	movs	r3, #0
 8011908:	e051      	b.n	80119ae <OsShellCmdDmesg+0x17a>
        }
    } else if (argc == 3) { /* 3: count of parameters */
 801190a:	687b      	ldr	r3, [r7, #4]
 801190c:	2b03      	cmp	r3, #3
 801190e:	d149      	bne.n	80119a4 <OsShellCmdDmesg+0x170>
        if (!strcmp(argv[1], ">")) {
 8011910:	683b      	ldr	r3, [r7, #0]
 8011912:	3304      	adds	r3, #4
 8011914:	681b      	ldr	r3, [r3, #0]
 8011916:	492f      	ldr	r1, [pc, #188]	; (80119d4 <OsShellCmdDmesg+0x1a0>)
 8011918:	4618      	mov	r0, r3
 801191a:	f7fd fdf6 	bl	800f50a <strcmp>
 801191e:	4603      	mov	r3, r0
 8011920:	2b00      	cmp	r3, #0
 8011922:	d11b      	bne.n	801195c <OsShellCmdDmesg+0x128>
            if (LOS_DmesgToFile((CHAR *)argv[2]) < 0) { /* 2:index of parameters */
 8011924:	683b      	ldr	r3, [r7, #0]
 8011926:	3308      	adds	r3, #8
 8011928:	681b      	ldr	r3, [r3, #0]
 801192a:	4618      	mov	r0, r3
 801192c:	f7ff ff72 	bl	8011814 <LOS_DmesgToFile>
 8011930:	4603      	mov	r3, r0
 8011932:	2b00      	cmp	r3, #0
 8011934:	da09      	bge.n	801194a <OsShellCmdDmesg+0x116>
                PRINTK("Dmesg write log to %s fail \n", argv[2]); /* 2:index of parameters */
 8011936:	683b      	ldr	r3, [r7, #0]
 8011938:	3308      	adds	r3, #8
 801193a:	681b      	ldr	r3, [r3, #0]
 801193c:	4619      	mov	r1, r3
 801193e:	4826      	ldr	r0, [pc, #152]	; (80119d8 <OsShellCmdDmesg+0x1a4>)
 8011940:	f7f2 ffbe 	bl	80048c0 <dprintf>
                return -1;
 8011944:	f04f 33ff 	mov.w	r3, #4294967295
 8011948:	e031      	b.n	80119ae <OsShellCmdDmesg+0x17a>
            } else {
                PRINTK("Dmesg write log to %s success \n", argv[2]); /* 2:index of parameters */
 801194a:	683b      	ldr	r3, [r7, #0]
 801194c:	3308      	adds	r3, #8
 801194e:	681b      	ldr	r3, [r3, #0]
 8011950:	4619      	mov	r1, r3
 8011952:	4822      	ldr	r0, [pc, #136]	; (80119dc <OsShellCmdDmesg+0x1a8>)
 8011954:	f7f2 ffb4 	bl	80048c0 <dprintf>
                return LOS_OK;
 8011958:	2300      	movs	r3, #0
 801195a:	e028      	b.n	80119ae <OsShellCmdDmesg+0x17a>
            }
        } else if (!strcmp(argv[1], "-l")) {
 801195c:	683b      	ldr	r3, [r7, #0]
 801195e:	3304      	adds	r3, #4
 8011960:	681b      	ldr	r3, [r3, #0]
 8011962:	491f      	ldr	r1, [pc, #124]	; (80119e0 <OsShellCmdDmesg+0x1ac>)
 8011964:	4618      	mov	r0, r3
 8011966:	f7fd fdd0 	bl	800f50a <strcmp>
 801196a:	4603      	mov	r3, r0
 801196c:	2b00      	cmp	r3, #0
 801196e:	d107      	bne.n	8011980 <OsShellCmdDmesg+0x14c>
            return OsDmesgLvSet(argv[2]); /* 2:index of parameters */
 8011970:	683b      	ldr	r3, [r7, #0]
 8011972:	3308      	adds	r3, #8
 8011974:	681b      	ldr	r3, [r3, #0]
 8011976:	4618      	mov	r0, r3
 8011978:	f7ff fe56 	bl	8011628 <OsDmesgLvSet>
 801197c:	4603      	mov	r3, r0
 801197e:	e016      	b.n	80119ae <OsShellCmdDmesg+0x17a>
        } else if (!strcmp(argv[1], "-s")) {
 8011980:	683b      	ldr	r3, [r7, #0]
 8011982:	3304      	adds	r3, #4
 8011984:	681b      	ldr	r3, [r3, #0]
 8011986:	4917      	ldr	r1, [pc, #92]	; (80119e4 <OsShellCmdDmesg+0x1b0>)
 8011988:	4618      	mov	r0, r3
 801198a:	f7fd fdbe 	bl	800f50a <strcmp>
 801198e:	4603      	mov	r3, r0
 8011990:	2b00      	cmp	r3, #0
 8011992:	d107      	bne.n	80119a4 <OsShellCmdDmesg+0x170>
            return OsDmesgMemSizeSet(argv[2]); /* 2:index of parameters */
 8011994:	683b      	ldr	r3, [r7, #0]
 8011996:	3308      	adds	r3, #8
 8011998:	681b      	ldr	r3, [r3, #0]
 801199a:	4618      	mov	r0, r3
 801199c:	f7ff fe9a 	bl	80116d4 <OsDmesgMemSizeSet>
 80119a0:	4603      	mov	r3, r0
 80119a2:	e004      	b.n	80119ae <OsShellCmdDmesg+0x17a>
        }
    }

    PRINTK("dmesg: invalid option or parameter.\n");
 80119a4:	4810      	ldr	r0, [pc, #64]	; (80119e8 <OsShellCmdDmesg+0x1b4>)
 80119a6:	f7f2 ff8b 	bl	80048c0 <dprintf>
    return -1;
 80119aa:	f04f 33ff 	mov.w	r3, #4294967295
}
 80119ae:	4618      	mov	r0, r3
 80119b0:	3708      	adds	r7, #8
 80119b2:	46bd      	mov	sp, r7
 80119b4:	bd80      	pop	{r7, pc}
 80119b6:	bf00      	nop
 80119b8:	080219a0 	.word	0x080219a0
 80119bc:	080219a4 	.word	0x080219a4
 80119c0:	080219a8 	.word	0x080219a8
 80119c4:	080219ac 	.word	0x080219ac
 80119c8:	080219b0 	.word	0x080219b0
 80119cc:	080219b4 	.word	0x080219b4
 80119d0:	080219b8 	.word	0x080219b8
 80119d4:	080219bc 	.word	0x080219bc
 80119d8:	080219c0 	.word	0x080219c0
 80119dc:	080219e0 	.word	0x080219e0
 80119e0:	08021a00 	.word	0x08021a00
 80119e4:	08021a04 	.word	0x08021a04
 80119e8:	08021888 	.word	0x08021888

080119ec <OsShellCmdHelp>:

#include "shcmd.h"
#include "shell_pri.h"

UINT32 OsShellCmdHelp(UINT32 argc, const CHAR **argv)
{
 80119ec:	b580      	push	{r7, lr}
 80119ee:	b086      	sub	sp, #24
 80119f0:	af00      	add	r7, sp, #0
 80119f2:	6078      	str	r0, [r7, #4]
 80119f4:	6039      	str	r1, [r7, #0]
    UINT32 loop = 0;
 80119f6:	2300      	movs	r3, #0
 80119f8:	60fb      	str	r3, [r7, #12]
    CmdItemNode *curCmdItem = NULL;
 80119fa:	2300      	movs	r3, #0
 80119fc:	613b      	str	r3, [r7, #16]
    CmdModInfo *cmdInfo = OsCmdInfoGet();
 80119fe:	f000 f997 	bl	8011d30 <OsCmdInfoGet>
 8011a02:	6178      	str	r0, [r7, #20]

    (VOID)argv;
    if (argc > 0) {
 8011a04:	687b      	ldr	r3, [r7, #4]
 8011a06:	2b00      	cmp	r3, #0
 8011a08:	d005      	beq.n	8011a16 <OsShellCmdHelp+0x2a>
        PRINTK("\nUsage: help\n");
 8011a0a:	4817      	ldr	r0, [pc, #92]	; (8011a68 <OsShellCmdHelp+0x7c>)
 8011a0c:	f7f2 ff58 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8011a10:	f04f 33ff 	mov.w	r3, #4294967295
 8011a14:	e023      	b.n	8011a5e <OsShellCmdHelp+0x72>
    }

    PRINTK("*******************shell commands:*************************\n");
 8011a16:	4815      	ldr	r0, [pc, #84]	; (8011a6c <OsShellCmdHelp+0x80>)
 8011a18:	f7f2 ff52 	bl	80048c0 <dprintf>
    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &cmdInfo->cmdList.list, CmdItemNode, list) {
 8011a1c:	697b      	ldr	r3, [r7, #20]
 8011a1e:	685b      	ldr	r3, [r3, #4]
 8011a20:	613b      	str	r3, [r7, #16]
 8011a22:	e014      	b.n	8011a4e <OsShellCmdHelp+0x62>
        if ((loop & (8 - 1)) == 0) { /* 8 - 1:just align print */
 8011a24:	68fb      	ldr	r3, [r7, #12]
 8011a26:	f003 0307 	and.w	r3, r3, #7
 8011a2a:	2b00      	cmp	r3, #0
 8011a2c:	d102      	bne.n	8011a34 <OsShellCmdHelp+0x48>
            PRINTK("\n");
 8011a2e:	4810      	ldr	r0, [pc, #64]	; (8011a70 <OsShellCmdHelp+0x84>)
 8011a30:	f7f2 ff46 	bl	80048c0 <dprintf>
        }
        PRINTK("%-12s  ", curCmdItem->cmd->cmdKey);
 8011a34:	693b      	ldr	r3, [r7, #16]
 8011a36:	689b      	ldr	r3, [r3, #8]
 8011a38:	685b      	ldr	r3, [r3, #4]
 8011a3a:	4619      	mov	r1, r3
 8011a3c:	480d      	ldr	r0, [pc, #52]	; (8011a74 <OsShellCmdHelp+0x88>)
 8011a3e:	f7f2 ff3f 	bl	80048c0 <dprintf>

        loop++;
 8011a42:	68fb      	ldr	r3, [r7, #12]
 8011a44:	3301      	adds	r3, #1
 8011a46:	60fb      	str	r3, [r7, #12]
    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &cmdInfo->cmdList.list, CmdItemNode, list) {
 8011a48:	693b      	ldr	r3, [r7, #16]
 8011a4a:	685b      	ldr	r3, [r3, #4]
 8011a4c:	613b      	str	r3, [r7, #16]
 8011a4e:	693a      	ldr	r2, [r7, #16]
 8011a50:	697b      	ldr	r3, [r7, #20]
 8011a52:	429a      	cmp	r2, r3
 8011a54:	d1e6      	bne.n	8011a24 <OsShellCmdHelp+0x38>
    }

    PRINTK("\n");
 8011a56:	4806      	ldr	r0, [pc, #24]	; (8011a70 <OsShellCmdHelp+0x84>)
 8011a58:	f7f2 ff32 	bl	80048c0 <dprintf>
    return 0;
 8011a5c:	2300      	movs	r3, #0
}
 8011a5e:	4618      	mov	r0, r3
 8011a60:	3718      	adds	r7, #24
 8011a62:	46bd      	mov	sp, r7
 8011a64:	bd80      	pop	{r7, pc}
 8011a66:	bf00      	nop
 8011a68:	08021a10 	.word	0x08021a10
 8011a6c:	08021a20 	.word	0x08021a20
 8011a70:	08021a60 	.word	0x08021a60
 8011a74:	08021a64 	.word	0x08021a64

08011a78 <OsShellSourceInit>:
/* If not using console, then allocated shell struct will store in this global variable */
STATIC ShellCB *g_shellCB = NULL;
#endif

STATIC UINT32 OsShellSourceInit(VOID)
{
 8011a78:	b580      	push	{r7, lr}
 8011a7a:	b082      	sub	sp, #8
 8011a7c:	af00      	add	r7, sp, #0
    UINT32 ret;

    if (g_shellSourceFlag) {
 8011a7e:	4b10      	ldr	r3, [pc, #64]	; (8011ac0 <OsShellSourceInit+0x48>)
 8011a80:	681b      	ldr	r3, [r3, #0]
 8011a82:	2b00      	cmp	r3, #0
 8011a84:	d001      	beq.n	8011a8a <OsShellSourceInit+0x12>
        return LOS_OK;
 8011a86:	2300      	movs	r3, #0
 8011a88:	e015      	b.n	8011ab6 <OsShellSourceInit+0x3e>
    }

    ret = OsCmdInit();
 8011a8a:	f000 fe3d 	bl	8012708 <OsCmdInit>
 8011a8e:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 8011a90:	687b      	ldr	r3, [r7, #4]
 8011a92:	2b00      	cmp	r3, #0
 8011a94:	d001      	beq.n	8011a9a <OsShellSourceInit+0x22>
        return ret;
 8011a96:	687b      	ldr	r3, [r7, #4]
 8011a98:	e00d      	b.n	8011ab6 <OsShellSourceInit+0x3e>
    }

    ret = OsShellSysCmdRegister();
 8011a9a:	f000 fc47 	bl	801232c <OsShellSysCmdRegister>
 8011a9e:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 8011aa0:	687b      	ldr	r3, [r7, #4]
 8011aa2:	2b00      	cmp	r3, #0
 8011aa4:	d003      	beq.n	8011aae <OsShellSourceInit+0x36>
        OsCmdDeInit();
 8011aa6:	f000 fe5d 	bl	8012764 <OsCmdDeInit>
        return ret;
 8011aaa:	687b      	ldr	r3, [r7, #4]
 8011aac:	e003      	b.n	8011ab6 <OsShellSourceInit+0x3e>
    }
    g_shellSourceFlag = TRUE;
 8011aae:	4b04      	ldr	r3, [pc, #16]	; (8011ac0 <OsShellSourceInit+0x48>)
 8011ab0:	2201      	movs	r2, #1
 8011ab2:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 8011ab4:	2300      	movs	r3, #0
}
 8011ab6:	4618      	mov	r0, r3
 8011ab8:	3708      	adds	r7, #8
 8011aba:	46bd      	mov	sp, r7
 8011abc:	bd80      	pop	{r7, pc}
 8011abe:	bf00      	nop
 8011ac0:	200032a4 	.word	0x200032a4

08011ac4 <OsShellSourceDeInit>:

STATIC VOID OsShellSourceDeInit(VOID)
{
 8011ac4:	b580      	push	{r7, lr}
 8011ac6:	af00      	add	r7, sp, #0
    OsCmdDeInit();
 8011ac8:	f000 fe4c 	bl	8012764 <OsCmdDeInit>
    OsShellSysCmdUnregister();
 8011acc:	f000 fc8a 	bl	80123e4 <OsShellSysCmdUnregister>
    g_shellSourceFlag = FALSE;
 8011ad0:	4b02      	ldr	r3, [pc, #8]	; (8011adc <OsShellSourceDeInit+0x18>)
 8011ad2:	2200      	movs	r2, #0
 8011ad4:	601a      	str	r2, [r3, #0]
}
 8011ad6:	bf00      	nop
 8011ad8:	bd80      	pop	{r7, pc}
 8011ada:	bf00      	nop
 8011adc:	200032a4 	.word	0x200032a4

08011ae0 <OsShellCreateTask>:

STATIC UINT32 OsShellCreateTask(ShellCB *shellCB)
{
 8011ae0:	b580      	push	{r7, lr}
 8011ae2:	b084      	sub	sp, #16
 8011ae4:	af00      	add	r7, sp, #0
 8011ae6:	6078      	str	r0, [r7, #4]
    UINT32 ret = ShellTaskInit(shellCB);
 8011ae8:	6878      	ldr	r0, [r7, #4]
 8011aea:	f002 f92f 	bl	8013d4c <ShellTaskInit>
 8011aee:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 8011af0:	68fb      	ldr	r3, [r7, #12]
 8011af2:	2b00      	cmp	r3, #0
 8011af4:	d001      	beq.n	8011afa <OsShellCreateTask+0x1a>
        return ret;
 8011af6:	68fb      	ldr	r3, [r7, #12]
 8011af8:	e00c      	b.n	8011b14 <OsShellCreateTask+0x34>
    }

    ret = ShellEntryInit(shellCB);
 8011afa:	6878      	ldr	r0, [r7, #4]
 8011afc:	f002 f96c 	bl	8013dd8 <ShellEntryInit>
 8011b00:	60f8      	str	r0, [r7, #12]
    if (ret != LOS_OK) {
 8011b02:	68fb      	ldr	r3, [r7, #12]
 8011b04:	2b00      	cmp	r3, #0
 8011b06:	d004      	beq.n	8011b12 <OsShellCreateTask+0x32>
        (VOID)LOS_TaskDelete(shellCB->shellTaskHandle);
 8011b08:	687b      	ldr	r3, [r7, #4]
 8011b0a:	685b      	ldr	r3, [r3, #4]
 8011b0c:	4618      	mov	r0, r3
 8011b0e:	f7f2 f825 	bl	8003b5c <LOS_TaskDelete>
    }
    return ret;
 8011b12:	68fb      	ldr	r3, [r7, #12]
}
 8011b14:	4618      	mov	r0, r3
 8011b16:	3710      	adds	r7, #16
 8011b18:	46bd      	mov	sp, r7
 8011b1a:	bd80      	pop	{r7, pc}

08011b1c <OsShellConsoleInit>:

STATIC INLINE UINT32 OsShellConsoleInit(INT32 consoleId, ShellCB *shellCB)
{
 8011b1c:	b480      	push	{r7}
 8011b1e:	b083      	sub	sp, #12
 8011b20:	af00      	add	r7, sp, #0
 8011b22:	6078      	str	r0, [r7, #4]
 8011b24:	6039      	str	r1, [r7, #0]
    g_shellCB = shellCB;
 8011b26:	4a05      	ldr	r2, [pc, #20]	; (8011b3c <OsShellConsoleInit+0x20>)
 8011b28:	683b      	ldr	r3, [r7, #0]
 8011b2a:	6013      	str	r3, [r2, #0]
    return LOS_OK;
 8011b2c:	2300      	movs	r3, #0
}
 8011b2e:	4618      	mov	r0, r3
 8011b30:	370c      	adds	r7, #12
 8011b32:	46bd      	mov	sp, r7
 8011b34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b38:	4770      	bx	lr
 8011b3a:	bf00      	nop
 8011b3c:	200032a8 	.word	0x200032a8

08011b40 <OsShellConsoleDeinit>:

STATIC INLINE VOID OsShellConsoleDeinit(INT32 consoleId)
{
 8011b40:	b480      	push	{r7}
 8011b42:	b083      	sub	sp, #12
 8011b44:	af00      	add	r7, sp, #0
 8011b46:	6078      	str	r0, [r7, #4]
    g_shellCB = NULL;
 8011b48:	4b04      	ldr	r3, [pc, #16]	; (8011b5c <OsShellConsoleDeinit+0x1c>)
 8011b4a:	2200      	movs	r2, #0
 8011b4c:	601a      	str	r2, [r3, #0]
}
 8011b4e:	bf00      	nop
 8011b50:	370c      	adds	r7, #12
 8011b52:	46bd      	mov	sp, r7
 8011b54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b58:	4770      	bx	lr
 8011b5a:	bf00      	nop
 8011b5c:	200032a8 	.word	0x200032a8

08011b60 <OsShellInit>:

UINT32 OsShellInit(INT32 consoleId)
{
 8011b60:	b580      	push	{r7, lr}
 8011b62:	b084      	sub	sp, #16
 8011b64:	af00      	add	r7, sp, #0
 8011b66:	6078      	str	r0, [r7, #4]
    UINT32 ret = LOS_NOK;
 8011b68:	2301      	movs	r3, #1
 8011b6a:	60bb      	str	r3, [r7, #8]
    ShellCB *shellCB = NULL;
 8011b6c:	2300      	movs	r3, #0
 8011b6e:	60fb      	str	r3, [r7, #12]

    if (OsShellSourceInit() != LOS_OK) {
 8011b70:	f7ff ff82 	bl	8011a78 <OsShellSourceInit>
 8011b74:	4603      	mov	r3, r0
 8011b76:	2b00      	cmp	r3, #0
 8011b78:	d001      	beq.n	8011b7e <OsShellInit+0x1e>
        return ret;
 8011b7a:	68bb      	ldr	r3, [r7, #8]
 8011b7c:	e06b      	b.n	8011c56 <OsShellInit+0xf6>
    }

    shellCB = LOS_MemAlloc(m_aucSysMem0, sizeof(ShellCB));
 8011b7e:	4b38      	ldr	r3, [pc, #224]	; (8011c60 <OsShellInit+0x100>)
 8011b80:	681b      	ldr	r3, [r3, #0]
 8011b82:	f44f 7112 	mov.w	r1, #584	; 0x248
 8011b86:	4618      	mov	r0, r3
 8011b88:	f7f7 fc44 	bl	8009414 <LOS_MemAlloc>
 8011b8c:	60f8      	str	r0, [r7, #12]
    if (shellCB == NULL) {
 8011b8e:	68fb      	ldr	r3, [r7, #12]
 8011b90:	2b00      	cmp	r3, #0
 8011b92:	d05c      	beq.n	8011c4e <OsShellInit+0xee>
        goto ERR_OUT_SOURCE_DEINIT;
    }
    (VOID)memset_s(shellCB, sizeof(ShellCB), 0, sizeof(ShellCB));
 8011b94:	f44f 7312 	mov.w	r3, #584	; 0x248
 8011b98:	2200      	movs	r2, #0
 8011b9a:	f44f 7112 	mov.w	r1, #584	; 0x248
 8011b9e:	68f8      	ldr	r0, [r7, #12]
 8011ba0:	f7f0 fa80 	bl	80020a4 <memset_s>

    if (OsShellConsoleInit(consoleId, shellCB) != LOS_OK) {
 8011ba4:	68f9      	ldr	r1, [r7, #12]
 8011ba6:	6878      	ldr	r0, [r7, #4]
 8011ba8:	f7ff ffb8 	bl	8011b1c <OsShellConsoleInit>
 8011bac:	4603      	mov	r3, r0
 8011bae:	2b00      	cmp	r3, #0
 8011bb0:	d145      	bne.n	8011c3e <OsShellInit+0xde>
        goto ERR_OUT_FREE_MEM;
    }

    if (LOS_MuxCreate(&shellCB->keyMutex) != LOS_OK) {
 8011bb2:	68fb      	ldr	r3, [r7, #12]
 8011bb4:	332c      	adds	r3, #44	; 0x2c
 8011bb6:	4618      	mov	r0, r3
 8011bb8:	f7f9 fc0e 	bl	800b3d8 <LOS_MuxCreate>
 8011bbc:	4603      	mov	r3, r0
 8011bbe:	2b00      	cmp	r3, #0
 8011bc0:	d138      	bne.n	8011c34 <OsShellInit+0xd4>
        goto ERR_OUT_DEINIT_CONSOLE;
    }

    if (LOS_MuxCreate(&shellCB->historyMutex) != LOS_OK) {
 8011bc2:	68fb      	ldr	r3, [r7, #12]
 8011bc4:	3330      	adds	r3, #48	; 0x30
 8011bc6:	4618      	mov	r0, r3
 8011bc8:	f7f9 fc06 	bl	800b3d8 <LOS_MuxCreate>
 8011bcc:	4603      	mov	r3, r0
 8011bce:	2b00      	cmp	r3, #0
 8011bd0:	d129      	bne.n	8011c26 <OsShellInit+0xc6>
        goto ERR_OUT_DELETE_KEY_MUX;
    }

    if (strncpy_s(shellCB->shellWorkingDirectory, PATH_MAX, "/", 1) != EOK) {
 8011bd2:	68fb      	ldr	r3, [r7, #12]
 8011bd4:	f503 70a2 	add.w	r0, r3, #324	; 0x144
 8011bd8:	2301      	movs	r3, #1
 8011bda:	4a22      	ldr	r2, [pc, #136]	; (8011c64 <OsShellInit+0x104>)
 8011bdc:	f44f 7182 	mov.w	r1, #260	; 0x104
 8011be0:	f005 f8c0 	bl	8016d64 <strncpy_s>
 8011be4:	4603      	mov	r3, r0
 8011be6:	2b00      	cmp	r3, #0
 8011be8:	d114      	bne.n	8011c14 <OsShellInit+0xb4>
        goto ERR_OUT_DELETE_HISTORY_MUX;
    }

    ret = OsShellKeyInit(shellCB);
 8011bea:	68f8      	ldr	r0, [r7, #12]
 8011bec:	f000 fb04 	bl	80121f8 <OsShellKeyInit>
 8011bf0:	60b8      	str	r0, [r7, #8]
    if (ret != LOS_OK) {
 8011bf2:	68bb      	ldr	r3, [r7, #8]
 8011bf4:	2b00      	cmp	r3, #0
 8011bf6:	d10f      	bne.n	8011c18 <OsShellInit+0xb8>
        goto ERR_OUT_DELETE_HISTORY_MUX;
    }

    ret = OsShellCreateTask(shellCB);
 8011bf8:	68f8      	ldr	r0, [r7, #12]
 8011bfa:	f7ff ff71 	bl	8011ae0 <OsShellCreateTask>
 8011bfe:	60b8      	str	r0, [r7, #8]
    if (ret != LOS_OK) {
 8011c00:	68bb      	ldr	r3, [r7, #8]
 8011c02:	2b00      	cmp	r3, #0
 8011c04:	d101      	bne.n	8011c0a <OsShellInit+0xaa>
        goto ERR_OUT_DEINIT_KEY;
    }

    return LOS_OK;
 8011c06:	2300      	movs	r3, #0
 8011c08:	e025      	b.n	8011c56 <OsShellInit+0xf6>
        goto ERR_OUT_DEINIT_KEY;
 8011c0a:	bf00      	nop

ERR_OUT_DEINIT_KEY:
    OsShellKeyDeInit(shellCB);
 8011c0c:	68f8      	ldr	r0, [r7, #12]
 8011c0e:	f000 fb7b 	bl	8012308 <OsShellKeyDeInit>
 8011c12:	e002      	b.n	8011c1a <OsShellInit+0xba>
        goto ERR_OUT_DELETE_HISTORY_MUX;
 8011c14:	bf00      	nop
 8011c16:	e000      	b.n	8011c1a <OsShellInit+0xba>
        goto ERR_OUT_DELETE_HISTORY_MUX;
 8011c18:	bf00      	nop
ERR_OUT_DELETE_HISTORY_MUX:
    (VOID)LOS_MuxDelete(shellCB->historyMutex);
 8011c1a:	68fb      	ldr	r3, [r7, #12]
 8011c1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011c1e:	4618      	mov	r0, r3
 8011c20:	f7f9 fc74 	bl	800b50c <LOS_MuxDelete>
 8011c24:	e000      	b.n	8011c28 <OsShellInit+0xc8>
        goto ERR_OUT_DELETE_KEY_MUX;
 8011c26:	bf00      	nop
ERR_OUT_DELETE_KEY_MUX:
    (VOID)LOS_MuxDelete(shellCB->keyMutex);
 8011c28:	68fb      	ldr	r3, [r7, #12]
 8011c2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011c2c:	4618      	mov	r0, r3
 8011c2e:	f7f9 fc6d 	bl	800b50c <LOS_MuxDelete>
 8011c32:	e000      	b.n	8011c36 <OsShellInit+0xd6>
        goto ERR_OUT_DEINIT_CONSOLE;
 8011c34:	bf00      	nop
ERR_OUT_DEINIT_CONSOLE:
    OsShellConsoleDeinit(consoleId);
 8011c36:	6878      	ldr	r0, [r7, #4]
 8011c38:	f7ff ff82 	bl	8011b40 <OsShellConsoleDeinit>
 8011c3c:	e000      	b.n	8011c40 <OsShellInit+0xe0>
        goto ERR_OUT_FREE_MEM;
 8011c3e:	bf00      	nop
ERR_OUT_FREE_MEM:
    (VOID)LOS_MemFree((VOID *)m_aucSysMem0, shellCB);
 8011c40:	4b07      	ldr	r3, [pc, #28]	; (8011c60 <OsShellInit+0x100>)
 8011c42:	681b      	ldr	r3, [r3, #0]
 8011c44:	68f9      	ldr	r1, [r7, #12]
 8011c46:	4618      	mov	r0, r3
 8011c48:	f7f7 fc9c 	bl	8009584 <LOS_MemFree>
 8011c4c:	e000      	b.n	8011c50 <OsShellInit+0xf0>
        goto ERR_OUT_SOURCE_DEINIT;
 8011c4e:	bf00      	nop
ERR_OUT_SOURCE_DEINIT:
    OsShellSourceDeInit();
 8011c50:	f7ff ff38 	bl	8011ac4 <OsShellSourceDeInit>

    return ret;
 8011c54:	68bb      	ldr	r3, [r7, #8]
}
 8011c56:	4618      	mov	r0, r3
 8011c58:	3710      	adds	r7, #16
 8011c5a:	46bd      	mov	sp, r7
 8011c5c:	bd80      	pop	{r7, pc}
 8011c5e:	bf00      	nop
 8011c60:	200021bc 	.word	0x200021bc
 8011c64:	08021a74 	.word	0x08021a74

08011c68 <LOS_ListInit>:
{
 8011c68:	b480      	push	{r7}
 8011c6a:	b083      	sub	sp, #12
 8011c6c:	af00      	add	r7, sp, #0
 8011c6e:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 8011c70:	687b      	ldr	r3, [r7, #4]
 8011c72:	687a      	ldr	r2, [r7, #4]
 8011c74:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 8011c76:	687b      	ldr	r3, [r7, #4]
 8011c78:	687a      	ldr	r2, [r7, #4]
 8011c7a:	601a      	str	r2, [r3, #0]
}
 8011c7c:	bf00      	nop
 8011c7e:	370c      	adds	r7, #12
 8011c80:	46bd      	mov	sp, r7
 8011c82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011c86:	4770      	bx	lr

08011c88 <LOS_ListAdd>:
{
 8011c88:	b480      	push	{r7}
 8011c8a:	b083      	sub	sp, #12
 8011c8c:	af00      	add	r7, sp, #0
 8011c8e:	6078      	str	r0, [r7, #4]
 8011c90:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 8011c92:	687b      	ldr	r3, [r7, #4]
 8011c94:	685a      	ldr	r2, [r3, #4]
 8011c96:	683b      	ldr	r3, [r7, #0]
 8011c98:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 8011c9a:	683b      	ldr	r3, [r7, #0]
 8011c9c:	687a      	ldr	r2, [r7, #4]
 8011c9e:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 8011ca0:	687b      	ldr	r3, [r7, #4]
 8011ca2:	685b      	ldr	r3, [r3, #4]
 8011ca4:	683a      	ldr	r2, [r7, #0]
 8011ca6:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 8011ca8:	687b      	ldr	r3, [r7, #4]
 8011caa:	683a      	ldr	r2, [r7, #0]
 8011cac:	605a      	str	r2, [r3, #4]
}
 8011cae:	bf00      	nop
 8011cb0:	370c      	adds	r7, #12
 8011cb2:	46bd      	mov	sp, r7
 8011cb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011cb8:	4770      	bx	lr

08011cba <LOS_ListTailInsert>:
{
 8011cba:	b580      	push	{r7, lr}
 8011cbc:	b082      	sub	sp, #8
 8011cbe:	af00      	add	r7, sp, #0
 8011cc0:	6078      	str	r0, [r7, #4]
 8011cc2:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 8011cc4:	687b      	ldr	r3, [r7, #4]
 8011cc6:	681b      	ldr	r3, [r3, #0]
 8011cc8:	6839      	ldr	r1, [r7, #0]
 8011cca:	4618      	mov	r0, r3
 8011ccc:	f7ff ffdc 	bl	8011c88 <LOS_ListAdd>
}
 8011cd0:	bf00      	nop
 8011cd2:	3708      	adds	r7, #8
 8011cd4:	46bd      	mov	sp, r7
 8011cd6:	bd80      	pop	{r7, pc}

08011cd8 <LOS_ListDelete>:
{
 8011cd8:	b480      	push	{r7}
 8011cda:	b083      	sub	sp, #12
 8011cdc:	af00      	add	r7, sp, #0
 8011cde:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8011ce0:	687b      	ldr	r3, [r7, #4]
 8011ce2:	685b      	ldr	r3, [r3, #4]
 8011ce4:	687a      	ldr	r2, [r7, #4]
 8011ce6:	6812      	ldr	r2, [r2, #0]
 8011ce8:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 8011cea:	687b      	ldr	r3, [r7, #4]
 8011cec:	681b      	ldr	r3, [r3, #0]
 8011cee:	687a      	ldr	r2, [r7, #4]
 8011cf0:	6852      	ldr	r2, [r2, #4]
 8011cf2:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 8011cf4:	687b      	ldr	r3, [r7, #4]
 8011cf6:	2200      	movs	r2, #0
 8011cf8:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 8011cfa:	687b      	ldr	r3, [r7, #4]
 8011cfc:	2200      	movs	r2, #0
 8011cfe:	601a      	str	r2, [r3, #0]
}
 8011d00:	bf00      	nop
 8011d02:	370c      	adds	r7, #12
 8011d04:	46bd      	mov	sp, r7
 8011d06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011d0a:	4770      	bx	lr

08011d0c <LOS_ListEmpty>:
{
 8011d0c:	b480      	push	{r7}
 8011d0e:	b083      	sub	sp, #12
 8011d10:	af00      	add	r7, sp, #0
 8011d12:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 8011d14:	687b      	ldr	r3, [r7, #4]
 8011d16:	685b      	ldr	r3, [r3, #4]
 8011d18:	687a      	ldr	r2, [r7, #4]
 8011d1a:	429a      	cmp	r2, r3
 8011d1c:	bf0c      	ite	eq
 8011d1e:	2301      	moveq	r3, #1
 8011d20:	2300      	movne	r3, #0
 8011d22:	b2db      	uxtb	r3, r3
}
 8011d24:	4618      	mov	r0, r3
 8011d26:	370c      	adds	r7, #12
 8011d28:	46bd      	mov	sp, r7
 8011d2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011d2e:	4770      	bx	lr

08011d30 <OsCmdInfoGet>:

LOS_HAL_TABLE_BEGIN(g_shellcmd, shellcmd);
LOS_HAL_TABLE_END(g_shellcmdEnd, shellcmd);

CmdModInfo *OsCmdInfoGet(VOID)
{
 8011d30:	b480      	push	{r7}
 8011d32:	af00      	add	r7, sp, #0
    return &g_cmdInfo;
 8011d34:	4b02      	ldr	r3, [pc, #8]	; (8011d40 <OsCmdInfoGet+0x10>)
}
 8011d36:	4618      	mov	r0, r3
 8011d38:	46bd      	mov	sp, r7
 8011d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011d3e:	4770      	bx	lr
 8011d40:	200032ac 	.word	0x200032ac

08011d44 <OsFreeCmdPara>:

STATIC VOID OsFreeCmdPara(CmdParsed *cmdParsed)
{
 8011d44:	b580      	push	{r7, lr}
 8011d46:	b084      	sub	sp, #16
 8011d48:	af00      	add	r7, sp, #0
 8011d4a:	6078      	str	r0, [r7, #4]
    UINT32 i;
    for (i = 0; i < cmdParsed->paramCnt; i++) {
 8011d4c:	2300      	movs	r3, #0
 8011d4e:	60fb      	str	r3, [r7, #12]
 8011d50:	e019      	b.n	8011d86 <OsFreeCmdPara+0x42>
        if (cmdParsed->paramArray[i] != NULL) {
 8011d52:	687b      	ldr	r3, [r7, #4]
 8011d54:	68fa      	ldr	r2, [r7, #12]
 8011d56:	3206      	adds	r2, #6
 8011d58:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011d5c:	2b00      	cmp	r3, #0
 8011d5e:	d00f      	beq.n	8011d80 <OsFreeCmdPara+0x3c>
            (VOID)LOS_MemFree(m_aucSysMem0, cmdParsed->paramArray[i]);
 8011d60:	4b0e      	ldr	r3, [pc, #56]	; (8011d9c <OsFreeCmdPara+0x58>)
 8011d62:	6818      	ldr	r0, [r3, #0]
 8011d64:	687b      	ldr	r3, [r7, #4]
 8011d66:	68fa      	ldr	r2, [r7, #12]
 8011d68:	3206      	adds	r2, #6
 8011d6a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011d6e:	4619      	mov	r1, r3
 8011d70:	f7f7 fc08 	bl	8009584 <LOS_MemFree>
            cmdParsed->paramArray[i] = NULL;
 8011d74:	687b      	ldr	r3, [r7, #4]
 8011d76:	68fa      	ldr	r2, [r7, #12]
 8011d78:	3206      	adds	r2, #6
 8011d7a:	2100      	movs	r1, #0
 8011d7c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (i = 0; i < cmdParsed->paramCnt; i++) {
 8011d80:	68fb      	ldr	r3, [r7, #12]
 8011d82:	3301      	adds	r3, #1
 8011d84:	60fb      	str	r3, [r7, #12]
 8011d86:	687b      	ldr	r3, [r7, #4]
 8011d88:	681b      	ldr	r3, [r3, #0]
 8011d8a:	68fa      	ldr	r2, [r7, #12]
 8011d8c:	429a      	cmp	r2, r3
 8011d8e:	d3e0      	bcc.n	8011d52 <OsFreeCmdPara+0xe>
        }
    }
}
 8011d90:	bf00      	nop
 8011d92:	bf00      	nop
 8011d94:	3710      	adds	r7, #16
 8011d96:	46bd      	mov	sp, r7
 8011d98:	bd80      	pop	{r7, pc}
 8011d9a:	bf00      	nop
 8011d9c:	200021bc 	.word	0x200021bc

08011da0 <OsCompleteStr>:

STATIC VOID OsCompleteStr(CHAR *result, const CHAR *target, CHAR *cmdKey, UINT32 *len)
{
 8011da0:	b590      	push	{r4, r7, lr}
 8011da2:	b089      	sub	sp, #36	; 0x24
 8011da4:	af00      	add	r7, sp, #0
 8011da6:	60f8      	str	r0, [r7, #12]
 8011da8:	60b9      	str	r1, [r7, #8]
 8011daa:	607a      	str	r2, [r7, #4]
 8011dac:	603b      	str	r3, [r7, #0]
    UINT32 size = strlen(result) - strlen(target);
 8011dae:	68f8      	ldr	r0, [r7, #12]
 8011db0:	f7fd fbcd 	bl	800f54e <strlen>
 8011db4:	4604      	mov	r4, r0
 8011db6:	68b8      	ldr	r0, [r7, #8]
 8011db8:	f7fd fbc9 	bl	800f54e <strlen>
 8011dbc:	4603      	mov	r3, r0
 8011dbe:	1ae3      	subs	r3, r4, r3
 8011dc0:	617b      	str	r3, [r7, #20]
    CHAR *des = cmdKey + *len;
 8011dc2:	683b      	ldr	r3, [r7, #0]
 8011dc4:	681b      	ldr	r3, [r3, #0]
 8011dc6:	687a      	ldr	r2, [r7, #4]
 8011dc8:	4413      	add	r3, r2
 8011dca:	61bb      	str	r3, [r7, #24]
    CHAR *src = result + strlen(target);
 8011dcc:	68b8      	ldr	r0, [r7, #8]
 8011dce:	f7fd fbbe 	bl	800f54e <strlen>
 8011dd2:	4602      	mov	r2, r0
 8011dd4:	68fb      	ldr	r3, [r7, #12]
 8011dd6:	4413      	add	r3, r2
 8011dd8:	61fb      	str	r3, [r7, #28]

    while (size-- > 0) {
 8011dda:	e01c      	b.n	8011e16 <OsCompleteStr+0x76>
        PRINTK("%c", *src);
 8011ddc:	69fb      	ldr	r3, [r7, #28]
 8011dde:	781b      	ldrb	r3, [r3, #0]
 8011de0:	4619      	mov	r1, r3
 8011de2:	4812      	ldr	r0, [pc, #72]	; (8011e2c <OsCompleteStr+0x8c>)
 8011de4:	f7f2 fd6c 	bl	80048c0 <dprintf>
        if (*len == (SHOW_MAX_LEN - 1)) {
 8011de8:	683b      	ldr	r3, [r7, #0]
 8011dea:	681b      	ldr	r3, [r3, #0]
 8011dec:	f240 120f 	movw	r2, #271	; 0x10f
 8011df0:	4293      	cmp	r3, r2
 8011df2:	d103      	bne.n	8011dfc <OsCompleteStr+0x5c>
            *des = '\0';
 8011df4:	69bb      	ldr	r3, [r7, #24]
 8011df6:	2200      	movs	r2, #0
 8011df8:	701a      	strb	r2, [r3, #0]
            break;
 8011dfa:	e012      	b.n	8011e22 <OsCompleteStr+0x82>
        }
        *des++ = *src++;
 8011dfc:	69fa      	ldr	r2, [r7, #28]
 8011dfe:	1c53      	adds	r3, r2, #1
 8011e00:	61fb      	str	r3, [r7, #28]
 8011e02:	69bb      	ldr	r3, [r7, #24]
 8011e04:	1c59      	adds	r1, r3, #1
 8011e06:	61b9      	str	r1, [r7, #24]
 8011e08:	7812      	ldrb	r2, [r2, #0]
 8011e0a:	701a      	strb	r2, [r3, #0]
        (*len)++;
 8011e0c:	683b      	ldr	r3, [r7, #0]
 8011e0e:	681b      	ldr	r3, [r3, #0]
 8011e10:	1c5a      	adds	r2, r3, #1
 8011e12:	683b      	ldr	r3, [r7, #0]
 8011e14:	601a      	str	r2, [r3, #0]
    while (size-- > 0) {
 8011e16:	697b      	ldr	r3, [r7, #20]
 8011e18:	1e5a      	subs	r2, r3, #1
 8011e1a:	617a      	str	r2, [r7, #20]
 8011e1c:	2b00      	cmp	r3, #0
 8011e1e:	d1dd      	bne.n	8011ddc <OsCompleteStr+0x3c>
    }
}
 8011e20:	bf00      	nop
 8011e22:	bf00      	nop
 8011e24:	3724      	adds	r7, #36	; 0x24
 8011e26:	46bd      	mov	sp, r7
 8011e28:	bd90      	pop	{r4, r7, pc}
 8011e2a:	bf00      	nop
 8011e2c:	08021a78 	.word	0x08021a78

08011e30 <OsTabMatchFile>:
    (VOID)LOS_MemFree(m_aucSysMem0, dirOpen);
    return count;
}
#else
STATIC INT32 OsTabMatchFile(CHAR *cmdKey, UINT32 *len)
{
 8011e30:	b480      	push	{r7}
 8011e32:	b083      	sub	sp, #12
 8011e34:	af00      	add	r7, sp, #0
 8011e36:	6078      	str	r0, [r7, #4]
 8011e38:	6039      	str	r1, [r7, #0]
    return 0;
 8011e3a:	2300      	movs	r3, #0
}
 8011e3c:	4618      	mov	r0, r3
 8011e3e:	370c      	adds	r7, #12
 8011e40:	46bd      	mov	sp, r7
 8011e42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e46:	4770      	bx	lr

08011e48 <OsTabMatchCmd>:
#endif

STATIC INT32 OsTabMatchCmd(CHAR *cmdKey, UINT32 *len)
{
 8011e48:	b590      	push	{r4, r7, lr}
 8011e4a:	b089      	sub	sp, #36	; 0x24
 8011e4c:	af00      	add	r7, sp, #0
 8011e4e:	6078      	str	r0, [r7, #4]
 8011e50:	6039      	str	r1, [r7, #0]
    INT32 count = 0;
 8011e52:	2300      	movs	r3, #0
 8011e54:	60fb      	str	r3, [r7, #12]
    INT32 ret;
    CmdItemNode *cmdItemGuard = NULL;
 8011e56:	2300      	movs	r3, #0
 8011e58:	613b      	str	r3, [r7, #16]
    CmdItemNode *curCmdItem = NULL;
 8011e5a:	2300      	movs	r3, #0
 8011e5c:	617b      	str	r3, [r7, #20]
    CHAR *cmdMajor = cmdKey;
 8011e5e:	687b      	ldr	r3, [r7, #4]
 8011e60:	61bb      	str	r3, [r7, #24]

    while (*cmdMajor == SPACE) { /* cut left space */
 8011e62:	e002      	b.n	8011e6a <OsTabMatchCmd+0x22>
        cmdMajor++;
 8011e64:	69bb      	ldr	r3, [r7, #24]
 8011e66:	3301      	adds	r3, #1
 8011e68:	61bb      	str	r3, [r7, #24]
    while (*cmdMajor == SPACE) { /* cut left space */
 8011e6a:	69bb      	ldr	r3, [r7, #24]
 8011e6c:	781b      	ldrb	r3, [r3, #0]
 8011e6e:	2b20      	cmp	r3, #32
 8011e70:	d0f8      	beq.n	8011e64 <OsTabMatchCmd+0x1c>
    }

    if (LOS_ListEmpty(&g_cmdInfo.cmdList.list)) {
 8011e72:	4831      	ldr	r0, [pc, #196]	; (8011f38 <OsTabMatchCmd+0xf0>)
 8011e74:	f7ff ff4a 	bl	8011d0c <LOS_ListEmpty>
 8011e78:	4603      	mov	r3, r0
 8011e7a:	2b00      	cmp	r3, #0
 8011e7c:	d002      	beq.n	8011e84 <OsTabMatchCmd+0x3c>
        return (INT32)OS_ERROR;
 8011e7e:	f04f 33ff 	mov.w	r3, #4294967295
 8011e82:	e055      	b.n	8011f30 <OsTabMatchCmd+0xe8>
    }

    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &g_cmdInfo.cmdList.list, CmdItemNode, list) {
 8011e84:	4b2c      	ldr	r3, [pc, #176]	; (8011f38 <OsTabMatchCmd+0xf0>)
 8011e86:	685b      	ldr	r3, [r3, #4]
 8011e88:	617b      	str	r3, [r7, #20]
 8011e8a:	e01f      	b.n	8011ecc <OsTabMatchCmd+0x84>
        ret = strncmp(cmdMajor, curCmdItem->cmd->cmdKey, strlen(cmdMajor));
 8011e8c:	697b      	ldr	r3, [r7, #20]
 8011e8e:	689b      	ldr	r3, [r3, #8]
 8011e90:	685c      	ldr	r4, [r3, #4]
 8011e92:	69b8      	ldr	r0, [r7, #24]
 8011e94:	f7fd fb5b 	bl	800f54e <strlen>
 8011e98:	4603      	mov	r3, r0
 8011e9a:	461a      	mov	r2, r3
 8011e9c:	4621      	mov	r1, r4
 8011e9e:	69b8      	ldr	r0, [r7, #24]
 8011ea0:	f007 fbd8 	bl	8019654 <strncmp>
 8011ea4:	61f8      	str	r0, [r7, #28]
        if (ret > 0) {
 8011ea6:	69fb      	ldr	r3, [r7, #28]
 8011ea8:	2b00      	cmp	r3, #0
 8011eaa:	dc0b      	bgt.n	8011ec4 <OsTabMatchCmd+0x7c>
            continue;
        } else if (ret != 0) {
 8011eac:	69fb      	ldr	r3, [r7, #28]
 8011eae:	2b00      	cmp	r3, #0
 8011eb0:	d111      	bne.n	8011ed6 <OsTabMatchCmd+0x8e>
            break;
        }

        if (count == 0) {
 8011eb2:	68fb      	ldr	r3, [r7, #12]
 8011eb4:	2b00      	cmp	r3, #0
 8011eb6:	d101      	bne.n	8011ebc <OsTabMatchCmd+0x74>
            cmdItemGuard = curCmdItem;
 8011eb8:	697b      	ldr	r3, [r7, #20]
 8011eba:	613b      	str	r3, [r7, #16]
        }
        ++count;
 8011ebc:	68fb      	ldr	r3, [r7, #12]
 8011ebe:	3301      	adds	r3, #1
 8011ec0:	60fb      	str	r3, [r7, #12]
 8011ec2:	e000      	b.n	8011ec6 <OsTabMatchCmd+0x7e>
            continue;
 8011ec4:	bf00      	nop
    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &g_cmdInfo.cmdList.list, CmdItemNode, list) {
 8011ec6:	697b      	ldr	r3, [r7, #20]
 8011ec8:	685b      	ldr	r3, [r3, #4]
 8011eca:	617b      	str	r3, [r7, #20]
 8011ecc:	697b      	ldr	r3, [r7, #20]
 8011ece:	4a1a      	ldr	r2, [pc, #104]	; (8011f38 <OsTabMatchCmd+0xf0>)
 8011ed0:	4293      	cmp	r3, r2
 8011ed2:	d1db      	bne.n	8011e8c <OsTabMatchCmd+0x44>
 8011ed4:	e000      	b.n	8011ed8 <OsTabMatchCmd+0x90>
            break;
 8011ed6:	bf00      	nop
    }

    if (cmdItemGuard == NULL) {
 8011ed8:	693b      	ldr	r3, [r7, #16]
 8011eda:	2b00      	cmp	r3, #0
 8011edc:	d101      	bne.n	8011ee2 <OsTabMatchCmd+0x9a>
        return 0;
 8011ede:	2300      	movs	r3, #0
 8011ee0:	e026      	b.n	8011f30 <OsTabMatchCmd+0xe8>
    }

    if (count == 1) {
 8011ee2:	68fb      	ldr	r3, [r7, #12]
 8011ee4:	2b01      	cmp	r3, #1
 8011ee6:	d107      	bne.n	8011ef8 <OsTabMatchCmd+0xb0>
        OsCompleteStr(cmdItemGuard->cmd->cmdKey, cmdMajor, cmdKey, len);
 8011ee8:	693b      	ldr	r3, [r7, #16]
 8011eea:	689b      	ldr	r3, [r3, #8]
 8011eec:	6858      	ldr	r0, [r3, #4]
 8011eee:	683b      	ldr	r3, [r7, #0]
 8011ef0:	687a      	ldr	r2, [r7, #4]
 8011ef2:	69b9      	ldr	r1, [r7, #24]
 8011ef4:	f7ff ff54 	bl	8011da0 <OsCompleteStr>
    }

    ret = count;
 8011ef8:	68fb      	ldr	r3, [r7, #12]
 8011efa:	61fb      	str	r3, [r7, #28]
    if (count > 1) {
 8011efc:	68fb      	ldr	r3, [r7, #12]
 8011efe:	2b01      	cmp	r3, #1
 8011f00:	dd15      	ble.n	8011f2e <OsTabMatchCmd+0xe6>
        PRINTK("\n");
 8011f02:	480e      	ldr	r0, [pc, #56]	; (8011f3c <OsTabMatchCmd+0xf4>)
 8011f04:	f7f2 fcdc 	bl	80048c0 <dprintf>
        while (count--) {
 8011f08:	e009      	b.n	8011f1e <OsTabMatchCmd+0xd6>
            PRINTK("%s  ", cmdItemGuard->cmd->cmdKey);
 8011f0a:	693b      	ldr	r3, [r7, #16]
 8011f0c:	689b      	ldr	r3, [r3, #8]
 8011f0e:	685b      	ldr	r3, [r3, #4]
 8011f10:	4619      	mov	r1, r3
 8011f12:	480b      	ldr	r0, [pc, #44]	; (8011f40 <OsTabMatchCmd+0xf8>)
 8011f14:	f7f2 fcd4 	bl	80048c0 <dprintf>
            cmdItemGuard = LOS_DL_LIST_ENTRY(cmdItemGuard->list.pstNext, CmdItemNode, list);
 8011f18:	693b      	ldr	r3, [r7, #16]
 8011f1a:	685b      	ldr	r3, [r3, #4]
 8011f1c:	613b      	str	r3, [r7, #16]
        while (count--) {
 8011f1e:	68fb      	ldr	r3, [r7, #12]
 8011f20:	1e5a      	subs	r2, r3, #1
 8011f22:	60fa      	str	r2, [r7, #12]
 8011f24:	2b00      	cmp	r3, #0
 8011f26:	d1f0      	bne.n	8011f0a <OsTabMatchCmd+0xc2>
        }
        PRINTK("\n");
 8011f28:	4804      	ldr	r0, [pc, #16]	; (8011f3c <OsTabMatchCmd+0xf4>)
 8011f2a:	f7f2 fcc9 	bl	80048c0 <dprintf>
    }

    return ret;
 8011f2e:	69fb      	ldr	r3, [r7, #28]
}
 8011f30:	4618      	mov	r0, r3
 8011f32:	3724      	adds	r7, #36	; 0x24
 8011f34:	46bd      	mov	sp, r7
 8011f36:	bd90      	pop	{r4, r7, pc}
 8011f38:	200032ac 	.word	0x200032ac
 8011f3c:	08021a7c 	.word	0x08021a7c
 8011f40:	08021a80 	.word	0x08021a80

08011f44 <OsCmdKeyShift>:
 * Input:       cmdKey : Pass in the buff string, which is ready to be operated
 *              cmdOut : Pass out the buffer string, which has already been operated
 *              size : cmdKey length
 */
LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdKeyShift(const CHAR *cmdKey, CHAR *cmdOut, UINT32 size)
{
 8011f44:	b580      	push	{r7, lr}
 8011f46:	b08a      	sub	sp, #40	; 0x28
 8011f48:	af00      	add	r7, sp, #0
 8011f4a:	60f8      	str	r0, [r7, #12]
 8011f4c:	60b9      	str	r1, [r7, #8]
 8011f4e:	607a      	str	r2, [r7, #4]
    CHAR *output = NULL;
 8011f50:	2300      	movs	r3, #0
 8011f52:	617b      	str	r3, [r7, #20]
    CHAR *outputBak = NULL;
 8011f54:	2300      	movs	r3, #0
 8011f56:	623b      	str	r3, [r7, #32]
    UINT32 len;
    INT32 ret;
    BOOL quotes = FALSE;
 8011f58:	2300      	movs	r3, #0
 8011f5a:	61fb      	str	r3, [r7, #28]

    if ((cmdKey == NULL) || (cmdOut == NULL)) {
 8011f5c:	68fb      	ldr	r3, [r7, #12]
 8011f5e:	2b00      	cmp	r3, #0
 8011f60:	d002      	beq.n	8011f68 <OsCmdKeyShift+0x24>
 8011f62:	68bb      	ldr	r3, [r7, #8]
 8011f64:	2b00      	cmp	r3, #0
 8011f66:	d102      	bne.n	8011f6e <OsCmdKeyShift+0x2a>
        return OS_ERROR;
 8011f68:	f04f 33ff 	mov.w	r3, #4294967295
 8011f6c:	e08c      	b.n	8012088 <OsCmdKeyShift+0x144>
    }

    len = strlen(cmdKey);
 8011f6e:	68f8      	ldr	r0, [r7, #12]
 8011f70:	f7fd faed 	bl	800f54e <strlen>
 8011f74:	61b8      	str	r0, [r7, #24]
    if (len >= size) {
 8011f76:	69ba      	ldr	r2, [r7, #24]
 8011f78:	687b      	ldr	r3, [r7, #4]
 8011f7a:	429a      	cmp	r2, r3
 8011f7c:	d302      	bcc.n	8011f84 <OsCmdKeyShift+0x40>
        return OS_ERROR;
 8011f7e:	f04f 33ff 	mov.w	r3, #4294967295
 8011f82:	e081      	b.n	8012088 <OsCmdKeyShift+0x144>
    }
    output = (CHAR*)LOS_MemAlloc(m_aucSysMem0, len + 1);
 8011f84:	4b42      	ldr	r3, [pc, #264]	; (8012090 <OsCmdKeyShift+0x14c>)
 8011f86:	681a      	ldr	r2, [r3, #0]
 8011f88:	69bb      	ldr	r3, [r7, #24]
 8011f8a:	3301      	adds	r3, #1
 8011f8c:	4619      	mov	r1, r3
 8011f8e:	4610      	mov	r0, r2
 8011f90:	f7f7 fa40 	bl	8009414 <LOS_MemAlloc>
 8011f94:	6178      	str	r0, [r7, #20]
    if (output == NULL) {
 8011f96:	697b      	ldr	r3, [r7, #20]
 8011f98:	2b00      	cmp	r3, #0
 8011f9a:	d108      	bne.n	8011fae <OsCmdKeyShift+0x6a>
        PRINTK("malloc failure in %s[%d]", __FUNCTION__, __LINE__);
 8011f9c:	f44f 72e5 	mov.w	r2, #458	; 0x1ca
 8011fa0:	493c      	ldr	r1, [pc, #240]	; (8012094 <OsCmdKeyShift+0x150>)
 8011fa2:	483d      	ldr	r0, [pc, #244]	; (8012098 <OsCmdKeyShift+0x154>)
 8011fa4:	f7f2 fc8c 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8011fa8:	f04f 33ff 	mov.w	r3, #4294967295
 8011fac:	e06c      	b.n	8012088 <OsCmdKeyShift+0x144>
    }
    /* backup the 'output' start address */
    outputBak = output;
 8011fae:	697b      	ldr	r3, [r7, #20]
 8011fb0:	623b      	str	r3, [r7, #32]
    /* scan each character in 'cmdKey',and squeeze the overmuch space and ignore Invalid character */
    for (; *cmdKey != '\0'; cmdKey++) {
 8011fb2:	e02e      	b.n	8012012 <OsCmdKeyShift+0xce>
        /* detected a Double Quotes, switch the matching status */
        if (*cmdKey == '\"') {
 8011fb4:	68fb      	ldr	r3, [r7, #12]
 8011fb6:	781b      	ldrb	r3, [r3, #0]
 8011fb8:	2b22      	cmp	r3, #34	; 0x22
 8011fba:	d107      	bne.n	8011fcc <OsCmdKeyShift+0x88>
            SWITCH_QUOTES_STATUS(quotes);
 8011fbc:	69fb      	ldr	r3, [r7, #28]
 8011fbe:	2b01      	cmp	r3, #1
 8011fc0:	d102      	bne.n	8011fc8 <OsCmdKeyShift+0x84>
 8011fc2:	2300      	movs	r3, #0
 8011fc4:	61fb      	str	r3, [r7, #28]
 8011fc6:	e001      	b.n	8011fcc <OsCmdKeyShift+0x88>
 8011fc8:	2301      	movs	r3, #1
 8011fca:	61fb      	str	r3, [r7, #28]
        /* Ignore the current character in following situation */
        /* 1) Quotes matching status is FALSE (which said that the space is not been marked by double quotes) */
        /* 2) Current character is a space */
        /* 3) Next character is a space too, or the string is been seeked to the end already(\0) */
        /* 4) Invalid character, such as single quotes */
        if ((*cmdKey == ' ') && ((*(cmdKey + 1) == ' ') || (*(cmdKey + 1) == '\0')) && QUOTES_STATUS_CLOSE(quotes)) {
 8011fcc:	68fb      	ldr	r3, [r7, #12]
 8011fce:	781b      	ldrb	r3, [r3, #0]
 8011fd0:	2b20      	cmp	r3, #32
 8011fd2:	d10c      	bne.n	8011fee <OsCmdKeyShift+0xaa>
 8011fd4:	68fb      	ldr	r3, [r7, #12]
 8011fd6:	3301      	adds	r3, #1
 8011fd8:	781b      	ldrb	r3, [r3, #0]
 8011fda:	2b20      	cmp	r3, #32
 8011fdc:	d004      	beq.n	8011fe8 <OsCmdKeyShift+0xa4>
 8011fde:	68fb      	ldr	r3, [r7, #12]
 8011fe0:	3301      	adds	r3, #1
 8011fe2:	781b      	ldrb	r3, [r3, #0]
 8011fe4:	2b00      	cmp	r3, #0
 8011fe6:	d102      	bne.n	8011fee <OsCmdKeyShift+0xaa>
 8011fe8:	69fb      	ldr	r3, [r7, #28]
 8011fea:	2b00      	cmp	r3, #0
 8011fec:	d00b      	beq.n	8012006 <OsCmdKeyShift+0xc2>
            continue;
        }
        if (*cmdKey == '\'') {
 8011fee:	68fb      	ldr	r3, [r7, #12]
 8011ff0:	781b      	ldrb	r3, [r3, #0]
 8011ff2:	2b27      	cmp	r3, #39	; 0x27
 8011ff4:	d009      	beq.n	801200a <OsCmdKeyShift+0xc6>
            continue;
        }
        *output = *cmdKey;
 8011ff6:	68fb      	ldr	r3, [r7, #12]
 8011ff8:	781a      	ldrb	r2, [r3, #0]
 8011ffa:	697b      	ldr	r3, [r7, #20]
 8011ffc:	701a      	strb	r2, [r3, #0]
        output++;
 8011ffe:	697b      	ldr	r3, [r7, #20]
 8012000:	3301      	adds	r3, #1
 8012002:	617b      	str	r3, [r7, #20]
 8012004:	e002      	b.n	801200c <OsCmdKeyShift+0xc8>
            continue;
 8012006:	bf00      	nop
 8012008:	e000      	b.n	801200c <OsCmdKeyShift+0xc8>
            continue;
 801200a:	bf00      	nop
    for (; *cmdKey != '\0'; cmdKey++) {
 801200c:	68fb      	ldr	r3, [r7, #12]
 801200e:	3301      	adds	r3, #1
 8012010:	60fb      	str	r3, [r7, #12]
 8012012:	68fb      	ldr	r3, [r7, #12]
 8012014:	781b      	ldrb	r3, [r3, #0]
 8012016:	2b00      	cmp	r3, #0
 8012018:	d1cc      	bne.n	8011fb4 <OsCmdKeyShift+0x70>
    }
    *output = '\0';
 801201a:	697b      	ldr	r3, [r7, #20]
 801201c:	2200      	movs	r2, #0
 801201e:	701a      	strb	r2, [r3, #0]
    /* restore the 'output' start address */
    output = outputBak;
 8012020:	6a3b      	ldr	r3, [r7, #32]
 8012022:	617b      	str	r3, [r7, #20]
    len = strlen(output);
 8012024:	6978      	ldr	r0, [r7, #20]
 8012026:	f7fd fa92 	bl	800f54e <strlen>
 801202a:	61b8      	str	r0, [r7, #24]
    /* clear the space which is located at the first character in buffer */
    if (*output == ' ') {
 801202c:	697b      	ldr	r3, [r7, #20]
 801202e:	781b      	ldrb	r3, [r3, #0]
 8012030:	2b20      	cmp	r3, #32
 8012032:	d105      	bne.n	8012040 <OsCmdKeyShift+0xfc>
        output++;
 8012034:	697b      	ldr	r3, [r7, #20]
 8012036:	3301      	adds	r3, #1
 8012038:	617b      	str	r3, [r7, #20]
        len--;
 801203a:	69bb      	ldr	r3, [r7, #24]
 801203c:	3b01      	subs	r3, #1
 801203e:	61bb      	str	r3, [r7, #24]
    }
    /* copy out the buffer which is been operated already */
    ret = strncpy_s(cmdOut, size, output, len);
 8012040:	69bb      	ldr	r3, [r7, #24]
 8012042:	697a      	ldr	r2, [r7, #20]
 8012044:	6879      	ldr	r1, [r7, #4]
 8012046:	68b8      	ldr	r0, [r7, #8]
 8012048:	f004 fe8c 	bl	8016d64 <strncpy_s>
 801204c:	6278      	str	r0, [r7, #36]	; 0x24
    if (ret != EOK) {
 801204e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012050:	2b00      	cmp	r3, #0
 8012052:	d012      	beq.n	801207a <OsCmdKeyShift+0x136>
        PRINT_ERR("%s,%d strncpy_s failed, err:%d!\n", __FUNCTION__, __LINE__, ret);
 8012054:	4811      	ldr	r0, [pc, #68]	; (801209c <OsCmdKeyShift+0x158>)
 8012056:	f7f2 fc33 	bl	80048c0 <dprintf>
 801205a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801205c:	f240 12ef 	movw	r2, #495	; 0x1ef
 8012060:	490c      	ldr	r1, [pc, #48]	; (8012094 <OsCmdKeyShift+0x150>)
 8012062:	480f      	ldr	r0, [pc, #60]	; (80120a0 <OsCmdKeyShift+0x15c>)
 8012064:	f7f2 fc2c 	bl	80048c0 <dprintf>
        (VOID)LOS_MemFree(m_aucSysMem0, outputBak);
 8012068:	4b09      	ldr	r3, [pc, #36]	; (8012090 <OsCmdKeyShift+0x14c>)
 801206a:	681b      	ldr	r3, [r3, #0]
 801206c:	6a39      	ldr	r1, [r7, #32]
 801206e:	4618      	mov	r0, r3
 8012070:	f7f7 fa88 	bl	8009584 <LOS_MemFree>
        return OS_ERROR;
 8012074:	f04f 33ff 	mov.w	r3, #4294967295
 8012078:	e006      	b.n	8012088 <OsCmdKeyShift+0x144>
    }

    (VOID)LOS_MemFree(m_aucSysMem0, outputBak);
 801207a:	4b05      	ldr	r3, [pc, #20]	; (8012090 <OsCmdKeyShift+0x14c>)
 801207c:	681b      	ldr	r3, [r3, #0]
 801207e:	6a39      	ldr	r1, [r7, #32]
 8012080:	4618      	mov	r0, r3
 8012082:	f7f7 fa7f 	bl	8009584 <LOS_MemFree>

    return LOS_OK;
 8012086:	2300      	movs	r3, #0
}
 8012088:	4618      	mov	r0, r3
 801208a:	3728      	adds	r7, #40	; 0x28
 801208c:	46bd      	mov	sp, r7
 801208e:	bd80      	pop	{r7, pc}
 8012090:	200021bc 	.word	0x200021bc
 8012094:	08023524 	.word	0x08023524
 8012098:	08021a88 	.word	0x08021a88
 801209c:	08021aa4 	.word	0x08021aa4
 80120a0:	08021aac 	.word	0x08021aac

080120a4 <OsTabCompletion>:

    return TRUE;
}

LITE_OS_SEC_TEXT_MINOR INT32 OsTabCompletion(CHAR *cmdKey, UINT32 *len)
{
 80120a4:	b580      	push	{r7, lr}
 80120a6:	b086      	sub	sp, #24
 80120a8:	af00      	add	r7, sp, #0
 80120aa:	6078      	str	r0, [r7, #4]
 80120ac:	6039      	str	r1, [r7, #0]
    INT32 count = 0;
 80120ae:	2300      	movs	r3, #0
 80120b0:	60fb      	str	r3, [r7, #12]
    CHAR *space = NULL;
 80120b2:	2300      	movs	r3, #0
 80120b4:	617b      	str	r3, [r7, #20]
    CHAR *cmdMainStr = cmdKey;
 80120b6:	687b      	ldr	r3, [r7, #4]
 80120b8:	613b      	str	r3, [r7, #16]

    if ((cmdKey == NULL) || (len == NULL)) {
 80120ba:	687b      	ldr	r3, [r7, #4]
 80120bc:	2b00      	cmp	r3, #0
 80120be:	d002      	beq.n	80120c6 <OsTabCompletion+0x22>
 80120c0:	683b      	ldr	r3, [r7, #0]
 80120c2:	2b00      	cmp	r3, #0
 80120c4:	d105      	bne.n	80120d2 <OsTabCompletion+0x2e>
        return (INT32)OS_ERROR;
 80120c6:	f04f 33ff 	mov.w	r3, #4294967295
 80120ca:	e020      	b.n	801210e <OsTabCompletion+0x6a>
    }

    /* cut left space */
    while (*cmdMainStr == SPACE) {
        cmdMainStr++;
 80120cc:	693b      	ldr	r3, [r7, #16]
 80120ce:	3301      	adds	r3, #1
 80120d0:	613b      	str	r3, [r7, #16]
    while (*cmdMainStr == SPACE) {
 80120d2:	693b      	ldr	r3, [r7, #16]
 80120d4:	781b      	ldrb	r3, [r3, #0]
 80120d6:	2b20      	cmp	r3, #32
 80120d8:	d0f8      	beq.n	80120cc <OsTabCompletion+0x28>
    }

    /* try to find space in remain */
    space = strrchr(cmdMainStr, SPACE);
 80120da:	2120      	movs	r1, #32
 80120dc:	6938      	ldr	r0, [r7, #16]
 80120de:	f007 faf0 	bl	80196c2 <strrchr>
 80120e2:	6178      	str	r0, [r7, #20]
    if ((space == NULL) && (*cmdMainStr != '\0')) {
 80120e4:	697b      	ldr	r3, [r7, #20]
 80120e6:	2b00      	cmp	r3, #0
 80120e8:	d108      	bne.n	80120fc <OsTabCompletion+0x58>
 80120ea:	693b      	ldr	r3, [r7, #16]
 80120ec:	781b      	ldrb	r3, [r3, #0]
 80120ee:	2b00      	cmp	r3, #0
 80120f0:	d004      	beq.n	80120fc <OsTabCompletion+0x58>
        count = OsTabMatchCmd(cmdKey, len);
 80120f2:	6839      	ldr	r1, [r7, #0]
 80120f4:	6878      	ldr	r0, [r7, #4]
 80120f6:	f7ff fea7 	bl	8011e48 <OsTabMatchCmd>
 80120fa:	60f8      	str	r0, [r7, #12]
    }

    if (count == 0) {
 80120fc:	68fb      	ldr	r3, [r7, #12]
 80120fe:	2b00      	cmp	r3, #0
 8012100:	d104      	bne.n	801210c <OsTabCompletion+0x68>
        count = OsTabMatchFile(cmdKey, len);
 8012102:	6839      	ldr	r1, [r7, #0]
 8012104:	6878      	ldr	r0, [r7, #4]
 8012106:	f7ff fe93 	bl	8011e30 <OsTabMatchFile>
 801210a:	60f8      	str	r0, [r7, #12]
    }

    return count;
 801210c:	68fb      	ldr	r3, [r7, #12]
}
 801210e:	4618      	mov	r0, r3
 8012110:	3718      	adds	r7, #24
 8012112:	46bd      	mov	sp, r7
 8012114:	bd80      	pop	{r7, pc}
	...

08012118 <OsCmdAscendingInsert>:

LITE_OS_SEC_TEXT_MINOR VOID OsCmdAscendingInsert(CmdItemNode *cmd)
{
 8012118:	b5b0      	push	{r4, r5, r7, lr}
 801211a:	b084      	sub	sp, #16
 801211c:	af00      	add	r7, sp, #0
 801211e:	6078      	str	r0, [r7, #4]
    CmdItemNode *cmdItem = NULL;
 8012120:	2300      	movs	r3, #0
 8012122:	60bb      	str	r3, [r7, #8]
    CmdItemNode *cmdNext = NULL;
 8012124:	2300      	movs	r3, #0
 8012126:	60fb      	str	r3, [r7, #12]

    for (cmdItem = LOS_DL_LIST_ENTRY((&g_cmdInfo.cmdList.list)->pstPrev, CmdItemNode, list);
 8012128:	4b32      	ldr	r3, [pc, #200]	; (80121f4 <OsCmdAscendingInsert+0xdc>)
 801212a:	681b      	ldr	r3, [r3, #0]
 801212c:	60bb      	str	r3, [r7, #8]
 801212e:	e052      	b.n	80121d6 <OsCmdAscendingInsert+0xbe>
         &cmdItem->list != &g_cmdInfo.cmdList.list;) {
        cmdNext = LOS_DL_LIST_ENTRY(cmdItem->list.pstPrev, CmdItemNode, list);
 8012130:	68bb      	ldr	r3, [r7, #8]
 8012132:	681b      	ldr	r3, [r3, #0]
 8012134:	60fb      	str	r3, [r7, #12]
        if (&cmdNext->list != &g_cmdInfo.cmdList.list) {
 8012136:	68fb      	ldr	r3, [r7, #12]
 8012138:	4a2e      	ldr	r2, [pc, #184]	; (80121f4 <OsCmdAscendingInsert+0xdc>)
 801213a:	4293      	cmp	r3, r2
 801213c:	d033      	beq.n	80121a6 <OsCmdAscendingInsert+0x8e>
            if ((strncmp(cmdItem->cmd->cmdKey, cmd->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) >= 0) &&
 801213e:	68bb      	ldr	r3, [r7, #8]
 8012140:	689b      	ldr	r3, [r3, #8]
 8012142:	685c      	ldr	r4, [r3, #4]
 8012144:	687b      	ldr	r3, [r7, #4]
 8012146:	689b      	ldr	r3, [r3, #8]
 8012148:	685d      	ldr	r5, [r3, #4]
 801214a:	687b      	ldr	r3, [r7, #4]
 801214c:	689b      	ldr	r3, [r3, #8]
 801214e:	685b      	ldr	r3, [r3, #4]
 8012150:	4618      	mov	r0, r3
 8012152:	f7fd f9fc 	bl	800f54e <strlen>
 8012156:	4603      	mov	r3, r0
 8012158:	461a      	mov	r2, r3
 801215a:	4629      	mov	r1, r5
 801215c:	4620      	mov	r0, r4
 801215e:	f007 fa79 	bl	8019654 <strncmp>
 8012162:	4603      	mov	r3, r0
 8012164:	2b00      	cmp	r3, #0
 8012166:	db1b      	blt.n	80121a0 <OsCmdAscendingInsert+0x88>
                (strncmp(cmdNext->cmd->cmdKey, cmd->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) < 0)) {
 8012168:	68fb      	ldr	r3, [r7, #12]
 801216a:	689b      	ldr	r3, [r3, #8]
 801216c:	685c      	ldr	r4, [r3, #4]
 801216e:	687b      	ldr	r3, [r7, #4]
 8012170:	689b      	ldr	r3, [r3, #8]
 8012172:	685d      	ldr	r5, [r3, #4]
 8012174:	687b      	ldr	r3, [r7, #4]
 8012176:	689b      	ldr	r3, [r3, #8]
 8012178:	685b      	ldr	r3, [r3, #4]
 801217a:	4618      	mov	r0, r3
 801217c:	f7fd f9e7 	bl	800f54e <strlen>
 8012180:	4603      	mov	r3, r0
 8012182:	461a      	mov	r2, r3
 8012184:	4629      	mov	r1, r5
 8012186:	4620      	mov	r0, r4
 8012188:	f007 fa64 	bl	8019654 <strncmp>
 801218c:	4603      	mov	r3, r0
            if ((strncmp(cmdItem->cmd->cmdKey, cmd->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) >= 0) &&
 801218e:	2b00      	cmp	r3, #0
 8012190:	da06      	bge.n	80121a0 <OsCmdAscendingInsert+0x88>
                LOS_ListTailInsert(&cmdItem->list, &cmd->list);
 8012192:	68bb      	ldr	r3, [r7, #8]
 8012194:	687a      	ldr	r2, [r7, #4]
 8012196:	4611      	mov	r1, r2
 8012198:	4618      	mov	r0, r3
 801219a:	f7ff fd8e 	bl	8011cba <LOS_ListTailInsert>
                return;
 801219e:	e026      	b.n	80121ee <OsCmdAscendingInsert+0xd6>
            }
            cmdItem = cmdNext;
 80121a0:	68fb      	ldr	r3, [r7, #12]
 80121a2:	60bb      	str	r3, [r7, #8]
 80121a4:	e017      	b.n	80121d6 <OsCmdAscendingInsert+0xbe>
        } else {
            if (strncmp(cmd->cmd->cmdKey, cmdItem->cmd->cmdKey, strlen(cmd->cmd->cmdKey)) > 0) {
 80121a6:	687b      	ldr	r3, [r7, #4]
 80121a8:	689b      	ldr	r3, [r3, #8]
 80121aa:	685c      	ldr	r4, [r3, #4]
 80121ac:	68bb      	ldr	r3, [r7, #8]
 80121ae:	689b      	ldr	r3, [r3, #8]
 80121b0:	685d      	ldr	r5, [r3, #4]
 80121b2:	687b      	ldr	r3, [r7, #4]
 80121b4:	689b      	ldr	r3, [r3, #8]
 80121b6:	685b      	ldr	r3, [r3, #4]
 80121b8:	4618      	mov	r0, r3
 80121ba:	f7fd f9c8 	bl	800f54e <strlen>
 80121be:	4603      	mov	r3, r0
 80121c0:	461a      	mov	r2, r3
 80121c2:	4629      	mov	r1, r5
 80121c4:	4620      	mov	r0, r4
 80121c6:	f007 fa45 	bl	8019654 <strncmp>
 80121ca:	4603      	mov	r3, r0
 80121cc:	2b00      	cmp	r3, #0
 80121ce:	dd07      	ble.n	80121e0 <OsCmdAscendingInsert+0xc8>
                cmdItem = cmdNext;
 80121d0:	68fb      	ldr	r3, [r7, #12]
 80121d2:	60bb      	str	r3, [r7, #8]
            }
            break;
 80121d4:	e004      	b.n	80121e0 <OsCmdAscendingInsert+0xc8>
    for (cmdItem = LOS_DL_LIST_ENTRY((&g_cmdInfo.cmdList.list)->pstPrev, CmdItemNode, list);
 80121d6:	68bb      	ldr	r3, [r7, #8]
 80121d8:	4a06      	ldr	r2, [pc, #24]	; (80121f4 <OsCmdAscendingInsert+0xdc>)
 80121da:	4293      	cmp	r3, r2
 80121dc:	d1a8      	bne.n	8012130 <OsCmdAscendingInsert+0x18>
 80121de:	e000      	b.n	80121e2 <OsCmdAscendingInsert+0xca>
            break;
 80121e0:	bf00      	nop
        }
    }

    LOS_ListTailInsert(&cmdItem->list, &cmd->list);
 80121e2:	68bb      	ldr	r3, [r7, #8]
 80121e4:	687a      	ldr	r2, [r7, #4]
 80121e6:	4611      	mov	r1, r2
 80121e8:	4618      	mov	r0, r3
 80121ea:	f7ff fd66 	bl	8011cba <LOS_ListTailInsert>
}
 80121ee:	3710      	adds	r7, #16
 80121f0:	46bd      	mov	sp, r7
 80121f2:	bdb0      	pop	{r4, r5, r7, pc}
 80121f4:	200032ac 	.word	0x200032ac

080121f8 <OsShellKeyInit>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellKeyInit(ShellCB *shellCB)
{
 80121f8:	b580      	push	{r7, lr}
 80121fa:	b084      	sub	sp, #16
 80121fc:	af00      	add	r7, sp, #0
 80121fe:	6078      	str	r0, [r7, #4]
    CmdKeyLink *cmdKeyLink = NULL;
 8012200:	2300      	movs	r3, #0
 8012202:	60bb      	str	r3, [r7, #8]
    CmdKeyLink *cmdHistoryLink = NULL;
 8012204:	2300      	movs	r3, #0
 8012206:	60fb      	str	r3, [r7, #12]

    cmdKeyLink = (CmdKeyLink *)LOS_MemAlloc(m_aucSysMem0, sizeof(CmdKeyLink));
 8012208:	4b24      	ldr	r3, [pc, #144]	; (801229c <OsShellKeyInit+0xa4>)
 801220a:	681b      	ldr	r3, [r3, #0]
 801220c:	210c      	movs	r1, #12
 801220e:	4618      	mov	r0, r3
 8012210:	f7f7 f900 	bl	8009414 <LOS_MemAlloc>
 8012214:	60b8      	str	r0, [r7, #8]
    if (cmdKeyLink == NULL) {
 8012216:	68bb      	ldr	r3, [r7, #8]
 8012218:	2b00      	cmp	r3, #0
 801221a:	d108      	bne.n	801222e <OsShellKeyInit+0x36>
        PRINT_ERR("Shell CmdKeyLink memory alloc error!\n");
 801221c:	4820      	ldr	r0, [pc, #128]	; (80122a0 <OsShellKeyInit+0xa8>)
 801221e:	f7f2 fb4f 	bl	80048c0 <dprintf>
 8012222:	4820      	ldr	r0, [pc, #128]	; (80122a4 <OsShellKeyInit+0xac>)
 8012224:	f7f2 fb4c 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8012228:	f04f 33ff 	mov.w	r3, #4294967295
 801222c:	e032      	b.n	8012294 <OsShellKeyInit+0x9c>
    }
    cmdHistoryLink = (CmdKeyLink *)LOS_MemAlloc(m_aucSysMem0, sizeof(CmdKeyLink));
 801222e:	4b1b      	ldr	r3, [pc, #108]	; (801229c <OsShellKeyInit+0xa4>)
 8012230:	681b      	ldr	r3, [r3, #0]
 8012232:	210c      	movs	r1, #12
 8012234:	4618      	mov	r0, r3
 8012236:	f7f7 f8ed 	bl	8009414 <LOS_MemAlloc>
 801223a:	60f8      	str	r0, [r7, #12]
    if (cmdHistoryLink == NULL) {
 801223c:	68fb      	ldr	r3, [r7, #12]
 801223e:	2b00      	cmp	r3, #0
 8012240:	d10e      	bne.n	8012260 <OsShellKeyInit+0x68>
        (VOID)LOS_MemFree(m_aucSysMem0, cmdKeyLink);
 8012242:	4b16      	ldr	r3, [pc, #88]	; (801229c <OsShellKeyInit+0xa4>)
 8012244:	681b      	ldr	r3, [r3, #0]
 8012246:	68b9      	ldr	r1, [r7, #8]
 8012248:	4618      	mov	r0, r3
 801224a:	f7f7 f99b 	bl	8009584 <LOS_MemFree>
        PRINT_ERR("Shell CmdHistoryLink memory alloc error!\n");
 801224e:	4814      	ldr	r0, [pc, #80]	; (80122a0 <OsShellKeyInit+0xa8>)
 8012250:	f7f2 fb36 	bl	80048c0 <dprintf>
 8012254:	4814      	ldr	r0, [pc, #80]	; (80122a8 <OsShellKeyInit+0xb0>)
 8012256:	f7f2 fb33 	bl	80048c0 <dprintf>
        return OS_ERROR;
 801225a:	f04f 33ff 	mov.w	r3, #4294967295
 801225e:	e019      	b.n	8012294 <OsShellKeyInit+0x9c>
    }

    cmdKeyLink->count = 0;
 8012260:	68bb      	ldr	r3, [r7, #8]
 8012262:	2200      	movs	r2, #0
 8012264:	601a      	str	r2, [r3, #0]
    LOS_ListInit(&cmdKeyLink->list);
 8012266:	68bb      	ldr	r3, [r7, #8]
 8012268:	3304      	adds	r3, #4
 801226a:	4618      	mov	r0, r3
 801226c:	f7ff fcfc 	bl	8011c68 <LOS_ListInit>
    shellCB->cmdKeyLink = (VOID *)cmdKeyLink;
 8012270:	687b      	ldr	r3, [r7, #4]
 8012272:	68ba      	ldr	r2, [r7, #8]
 8012274:	60da      	str	r2, [r3, #12]

    cmdHistoryLink->count = 0;
 8012276:	68fb      	ldr	r3, [r7, #12]
 8012278:	2200      	movs	r2, #0
 801227a:	601a      	str	r2, [r3, #0]
    LOS_ListInit(&cmdHistoryLink->list);
 801227c:	68fb      	ldr	r3, [r7, #12]
 801227e:	3304      	adds	r3, #4
 8012280:	4618      	mov	r0, r3
 8012282:	f7ff fcf1 	bl	8011c68 <LOS_ListInit>
    shellCB->cmdHistoryKeyLink = (VOID *)cmdHistoryLink;
 8012286:	687b      	ldr	r3, [r7, #4]
 8012288:	68fa      	ldr	r2, [r7, #12]
 801228a:	611a      	str	r2, [r3, #16]
    shellCB->cmdMaskKeyLink = (VOID *)cmdHistoryLink;
 801228c:	687b      	ldr	r3, [r7, #4]
 801228e:	68fa      	ldr	r2, [r7, #12]
 8012290:	615a      	str	r2, [r3, #20]
    return LOS_OK;
 8012292:	2300      	movs	r3, #0
}
 8012294:	4618      	mov	r0, r3
 8012296:	3710      	adds	r7, #16
 8012298:	46bd      	mov	sp, r7
 801229a:	bd80      	pop	{r7, pc}
 801229c:	200021bc 	.word	0x200021bc
 80122a0:	08021aa4 	.word	0x08021aa4
 80122a4:	08021ad0 	.word	0x08021ad0
 80122a8:	08021af8 	.word	0x08021af8

080122ac <OsShellKeyLinkDeInit>:

LITE_OS_SEC_TEXT_MINOR VOID OsShellKeyLinkDeInit(CmdKeyLink *cmdKeyLink)
{
 80122ac:	b580      	push	{r7, lr}
 80122ae:	b084      	sub	sp, #16
 80122b0:	af00      	add	r7, sp, #0
 80122b2:	6078      	str	r0, [r7, #4]
    CmdKeyLink *cmd = NULL;
 80122b4:	2300      	movs	r3, #0
 80122b6:	60fb      	str	r3, [r7, #12]

    while (!LOS_ListEmpty(&cmdKeyLink->list)) {
 80122b8:	e00e      	b.n	80122d8 <OsShellKeyLinkDeInit+0x2c>
        cmd = LOS_DL_LIST_ENTRY(cmdKeyLink->list.pstNext, CmdKeyLink, list);
 80122ba:	687b      	ldr	r3, [r7, #4]
 80122bc:	689b      	ldr	r3, [r3, #8]
 80122be:	3b04      	subs	r3, #4
 80122c0:	60fb      	str	r3, [r7, #12]
        LOS_ListDelete(&cmd->list);
 80122c2:	68fb      	ldr	r3, [r7, #12]
 80122c4:	3304      	adds	r3, #4
 80122c6:	4618      	mov	r0, r3
 80122c8:	f7ff fd06 	bl	8011cd8 <LOS_ListDelete>
        (VOID)LOS_MemFree(m_aucSysMem0, cmd);
 80122cc:	4b0d      	ldr	r3, [pc, #52]	; (8012304 <OsShellKeyLinkDeInit+0x58>)
 80122ce:	681b      	ldr	r3, [r3, #0]
 80122d0:	68f9      	ldr	r1, [r7, #12]
 80122d2:	4618      	mov	r0, r3
 80122d4:	f7f7 f956 	bl	8009584 <LOS_MemFree>
    while (!LOS_ListEmpty(&cmdKeyLink->list)) {
 80122d8:	687b      	ldr	r3, [r7, #4]
 80122da:	3304      	adds	r3, #4
 80122dc:	4618      	mov	r0, r3
 80122de:	f7ff fd15 	bl	8011d0c <LOS_ListEmpty>
 80122e2:	4603      	mov	r3, r0
 80122e4:	2b00      	cmp	r3, #0
 80122e6:	d0e8      	beq.n	80122ba <OsShellKeyLinkDeInit+0xe>
    }

    cmdKeyLink->count = 0;
 80122e8:	687b      	ldr	r3, [r7, #4]
 80122ea:	2200      	movs	r2, #0
 80122ec:	601a      	str	r2, [r3, #0]
    (VOID)LOS_MemFree(m_aucSysMem0, cmdKeyLink);
 80122ee:	4b05      	ldr	r3, [pc, #20]	; (8012304 <OsShellKeyLinkDeInit+0x58>)
 80122f0:	681b      	ldr	r3, [r3, #0]
 80122f2:	6879      	ldr	r1, [r7, #4]
 80122f4:	4618      	mov	r0, r3
 80122f6:	f7f7 f945 	bl	8009584 <LOS_MemFree>
}
 80122fa:	bf00      	nop
 80122fc:	3710      	adds	r7, #16
 80122fe:	46bd      	mov	sp, r7
 8012300:	bd80      	pop	{r7, pc}
 8012302:	bf00      	nop
 8012304:	200021bc 	.word	0x200021bc

08012308 <OsShellKeyDeInit>:

LITE_OS_SEC_TEXT_MINOR VOID OsShellKeyDeInit(const ShellCB *shellCB)
{
 8012308:	b580      	push	{r7, lr}
 801230a:	b082      	sub	sp, #8
 801230c:	af00      	add	r7, sp, #0
 801230e:	6078      	str	r0, [r7, #4]
    OsShellKeyLinkDeInit(shellCB->cmdKeyLink);
 8012310:	687b      	ldr	r3, [r7, #4]
 8012312:	68db      	ldr	r3, [r3, #12]
 8012314:	4618      	mov	r0, r3
 8012316:	f7ff ffc9 	bl	80122ac <OsShellKeyLinkDeInit>
    OsShellKeyLinkDeInit(shellCB->cmdHistoryKeyLink);
 801231a:	687b      	ldr	r3, [r7, #4]
 801231c:	691b      	ldr	r3, [r3, #16]
 801231e:	4618      	mov	r0, r3
 8012320:	f7ff ffc4 	bl	80122ac <OsShellKeyLinkDeInit>
}
 8012324:	bf00      	nop
 8012326:	3708      	adds	r7, #8
 8012328:	46bd      	mov	sp, r7
 801232a:	bd80      	pop	{r7, pc}

0801232c <OsShellSysCmdRegister>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellSysCmdRegister(VOID)
{
 801232c:	b580      	push	{r7, lr}
 801232e:	b084      	sub	sp, #16
 8012330:	af00      	add	r7, sp, #0
    UINT32 i;
    UINT32 index = ((UINTPTR)(&g_shellcmdEnd) - (UINTPTR)(&g_shellcmd[0])) / sizeof(CmdItem);
 8012332:	4a24      	ldr	r2, [pc, #144]	; (80123c4 <OsShellSysCmdRegister+0x98>)
 8012334:	4b24      	ldr	r3, [pc, #144]	; (80123c8 <OsShellSysCmdRegister+0x9c>)
 8012336:	1ad3      	subs	r3, r2, r3
 8012338:	091b      	lsrs	r3, r3, #4
 801233a:	60bb      	str	r3, [r7, #8]
    CmdItemNode *cmdItem = NULL;
 801233c:	2300      	movs	r3, #0
 801233e:	60fb      	str	r3, [r7, #12]

    g_cmdItemGroup = (UINT8 *)LOS_MemAlloc(m_aucSysMem0, index * sizeof(CmdItemNode));
 8012340:	4b22      	ldr	r3, [pc, #136]	; (80123cc <OsShellSysCmdRegister+0xa0>)
 8012342:	6818      	ldr	r0, [r3, #0]
 8012344:	68ba      	ldr	r2, [r7, #8]
 8012346:	4613      	mov	r3, r2
 8012348:	005b      	lsls	r3, r3, #1
 801234a:	4413      	add	r3, r2
 801234c:	009b      	lsls	r3, r3, #2
 801234e:	4619      	mov	r1, r3
 8012350:	f7f7 f860 	bl	8009414 <LOS_MemAlloc>
 8012354:	4603      	mov	r3, r0
 8012356:	4a1e      	ldr	r2, [pc, #120]	; (80123d0 <OsShellSysCmdRegister+0xa4>)
 8012358:	6013      	str	r3, [r2, #0]
    if (g_cmdItemGroup == NULL) {
 801235a:	4b1d      	ldr	r3, [pc, #116]	; (80123d0 <OsShellSysCmdRegister+0xa4>)
 801235c:	681b      	ldr	r3, [r3, #0]
 801235e:	2b00      	cmp	r3, #0
 8012360:	d109      	bne.n	8012376 <OsShellSysCmdRegister+0x4a>
        PRINT_ERR("[%s]System memory allocation failure!\n", __FUNCTION__);
 8012362:	481c      	ldr	r0, [pc, #112]	; (80123d4 <OsShellSysCmdRegister+0xa8>)
 8012364:	f7f2 faac 	bl	80048c0 <dprintf>
 8012368:	491b      	ldr	r1, [pc, #108]	; (80123d8 <OsShellSysCmdRegister+0xac>)
 801236a:	481c      	ldr	r0, [pc, #112]	; (80123dc <OsShellSysCmdRegister+0xb0>)
 801236c:	f7f2 faa8 	bl	80048c0 <dprintf>
        return (UINT32)OS_ERROR;
 8012370:	f04f 33ff 	mov.w	r3, #4294967295
 8012374:	e022      	b.n	80123bc <OsShellSysCmdRegister+0x90>
    }

    for (i = 0; i < index; ++i) {
 8012376:	2300      	movs	r3, #0
 8012378:	607b      	str	r3, [r7, #4]
 801237a:	e014      	b.n	80123a6 <OsShellSysCmdRegister+0x7a>
        cmdItem = (CmdItemNode *)(g_cmdItemGroup + i * sizeof(CmdItemNode));
 801237c:	4b14      	ldr	r3, [pc, #80]	; (80123d0 <OsShellSysCmdRegister+0xa4>)
 801237e:	6819      	ldr	r1, [r3, #0]
 8012380:	687a      	ldr	r2, [r7, #4]
 8012382:	4613      	mov	r3, r2
 8012384:	005b      	lsls	r3, r3, #1
 8012386:	4413      	add	r3, r2
 8012388:	009b      	lsls	r3, r3, #2
 801238a:	440b      	add	r3, r1
 801238c:	60fb      	str	r3, [r7, #12]
        cmdItem->cmd = &g_shellcmd[i];
 801238e:	687b      	ldr	r3, [r7, #4]
 8012390:	011b      	lsls	r3, r3, #4
 8012392:	4a0d      	ldr	r2, [pc, #52]	; (80123c8 <OsShellSysCmdRegister+0x9c>)
 8012394:	441a      	add	r2, r3
 8012396:	68fb      	ldr	r3, [r7, #12]
 8012398:	609a      	str	r2, [r3, #8]
        OsCmdAscendingInsert(cmdItem);
 801239a:	68f8      	ldr	r0, [r7, #12]
 801239c:	f7ff febc 	bl	8012118 <OsCmdAscendingInsert>
    for (i = 0; i < index; ++i) {
 80123a0:	687b      	ldr	r3, [r7, #4]
 80123a2:	3301      	adds	r3, #1
 80123a4:	607b      	str	r3, [r7, #4]
 80123a6:	687a      	ldr	r2, [r7, #4]
 80123a8:	68bb      	ldr	r3, [r7, #8]
 80123aa:	429a      	cmp	r2, r3
 80123ac:	d3e6      	bcc.n	801237c <OsShellSysCmdRegister+0x50>
    }
    g_cmdInfo.listNum += index;
 80123ae:	4b0c      	ldr	r3, [pc, #48]	; (80123e0 <OsShellSysCmdRegister+0xb4>)
 80123b0:	68da      	ldr	r2, [r3, #12]
 80123b2:	68bb      	ldr	r3, [r7, #8]
 80123b4:	4413      	add	r3, r2
 80123b6:	4a0a      	ldr	r2, [pc, #40]	; (80123e0 <OsShellSysCmdRegister+0xb4>)
 80123b8:	60d3      	str	r3, [r2, #12]
    return LOS_OK;
 80123ba:	2300      	movs	r3, #0
}
 80123bc:	4618      	mov	r0, r3
 80123be:	3710      	adds	r7, #16
 80123c0:	46bd      	mov	sp, r7
 80123c2:	bd80      	pop	{r7, pc}
 80123c4:	20000724 	.word	0x20000724
 80123c8:	200005d4 	.word	0x200005d4
 80123cc:	200021bc 	.word	0x200021bc
 80123d0:	200032c8 	.word	0x200032c8
 80123d4:	08021aa4 	.word	0x08021aa4
 80123d8:	08023534 	.word	0x08023534
 80123dc:	08021b24 	.word	0x08021b24
 80123e0:	200032ac 	.word	0x200032ac

080123e4 <OsShellSysCmdUnregister>:

LITE_OS_SEC_TEXT_MINOR VOID OsShellSysCmdUnregister(VOID)
{
 80123e4:	b580      	push	{r7, lr}
 80123e6:	b082      	sub	sp, #8
 80123e8:	af00      	add	r7, sp, #0
    CmdItemNode *cmdItem = NULL;
 80123ea:	2300      	movs	r3, #0
 80123ec:	607b      	str	r3, [r7, #4]
    while (!LOS_ListEmpty(&(g_cmdInfo.cmdList.list))) {
 80123ee:	e006      	b.n	80123fe <OsShellSysCmdUnregister+0x1a>
        cmdItem = LOS_DL_LIST_ENTRY(g_cmdInfo.cmdList.list.pstNext, CmdItemNode, list);
 80123f0:	4b0c      	ldr	r3, [pc, #48]	; (8012424 <OsShellSysCmdUnregister+0x40>)
 80123f2:	685b      	ldr	r3, [r3, #4]
 80123f4:	607b      	str	r3, [r7, #4]
        LOS_ListDelete(&cmdItem->list);
 80123f6:	687b      	ldr	r3, [r7, #4]
 80123f8:	4618      	mov	r0, r3
 80123fa:	f7ff fc6d 	bl	8011cd8 <LOS_ListDelete>
    while (!LOS_ListEmpty(&(g_cmdInfo.cmdList.list))) {
 80123fe:	4809      	ldr	r0, [pc, #36]	; (8012424 <OsShellSysCmdUnregister+0x40>)
 8012400:	f7ff fc84 	bl	8011d0c <LOS_ListEmpty>
 8012404:	4603      	mov	r3, r0
 8012406:	2b00      	cmp	r3, #0
 8012408:	d0f2      	beq.n	80123f0 <OsShellSysCmdUnregister+0xc>
    }
    (VOID)LOS_MemFree(m_aucSysMem0, g_cmdItemGroup);
 801240a:	4b07      	ldr	r3, [pc, #28]	; (8012428 <OsShellSysCmdUnregister+0x44>)
 801240c:	681b      	ldr	r3, [r3, #0]
 801240e:	4a07      	ldr	r2, [pc, #28]	; (801242c <OsShellSysCmdUnregister+0x48>)
 8012410:	6812      	ldr	r2, [r2, #0]
 8012412:	4611      	mov	r1, r2
 8012414:	4618      	mov	r0, r3
 8012416:	f7f7 f8b5 	bl	8009584 <LOS_MemFree>
}
 801241a:	bf00      	nop
 801241c:	3708      	adds	r7, #8
 801241e:	46bd      	mov	sp, r7
 8012420:	bd80      	pop	{r7, pc}
 8012422:	bf00      	nop
 8012424:	200032ac 	.word	0x200032ac
 8012428:	200021bc 	.word	0x200021bc
 801242c:	200032c8 	.word	0x200032c8

08012430 <OsShellCmdPush>:

LITE_OS_SEC_TEXT_MINOR VOID OsShellCmdPush(const CHAR *string, CmdKeyLink *cmdKeyLink)
{
 8012430:	b580      	push	{r7, lr}
 8012432:	b084      	sub	sp, #16
 8012434:	af00      	add	r7, sp, #0
 8012436:	6078      	str	r0, [r7, #4]
 8012438:	6039      	str	r1, [r7, #0]
    CmdKeyLink *cmdNewNode = NULL;
 801243a:	2300      	movs	r3, #0
 801243c:	60bb      	str	r3, [r7, #8]
    UINT32 len;

    if ((string == NULL) || (strlen(string) == 0)) {
 801243e:	687b      	ldr	r3, [r7, #4]
 8012440:	2b00      	cmp	r3, #0
 8012442:	d03a      	beq.n	80124ba <OsShellCmdPush+0x8a>
 8012444:	6878      	ldr	r0, [r7, #4]
 8012446:	f7fd f882 	bl	800f54e <strlen>
 801244a:	4603      	mov	r3, r0
 801244c:	2b00      	cmp	r3, #0
 801244e:	d034      	beq.n	80124ba <OsShellCmdPush+0x8a>
        return;
    }

    len = strlen(string);
 8012450:	6878      	ldr	r0, [r7, #4]
 8012452:	f7fd f87c 	bl	800f54e <strlen>
 8012456:	60f8      	str	r0, [r7, #12]
    cmdNewNode = (CmdKeyLink *)LOS_MemAlloc(m_aucSysMem0, sizeof(CmdKeyLink) + len + 1);
 8012458:	4b1b      	ldr	r3, [pc, #108]	; (80124c8 <OsShellCmdPush+0x98>)
 801245a:	681a      	ldr	r2, [r3, #0]
 801245c:	68fb      	ldr	r3, [r7, #12]
 801245e:	330d      	adds	r3, #13
 8012460:	4619      	mov	r1, r3
 8012462:	4610      	mov	r0, r2
 8012464:	f7f6 ffd6 	bl	8009414 <LOS_MemAlloc>
 8012468:	60b8      	str	r0, [r7, #8]
    if (cmdNewNode == NULL) {
 801246a:	68bb      	ldr	r3, [r7, #8]
 801246c:	2b00      	cmp	r3, #0
 801246e:	d026      	beq.n	80124be <OsShellCmdPush+0x8e>
        return;
    }

    (VOID)memset_s(cmdNewNode, sizeof(CmdKeyLink) + len + 1, 0, sizeof(CmdKeyLink) + len + 1);
 8012470:	68fb      	ldr	r3, [r7, #12]
 8012472:	f103 010d 	add.w	r1, r3, #13
 8012476:	68fb      	ldr	r3, [r7, #12]
 8012478:	330d      	adds	r3, #13
 801247a:	2200      	movs	r2, #0
 801247c:	68b8      	ldr	r0, [r7, #8]
 801247e:	f7ef fe11 	bl	80020a4 <memset_s>
    if (strncpy_s(cmdNewNode->cmdString, len + 1, string, len) != EOK) {
 8012482:	68bb      	ldr	r3, [r7, #8]
 8012484:	f103 000c 	add.w	r0, r3, #12
 8012488:	68fb      	ldr	r3, [r7, #12]
 801248a:	1c59      	adds	r1, r3, #1
 801248c:	68fb      	ldr	r3, [r7, #12]
 801248e:	687a      	ldr	r2, [r7, #4]
 8012490:	f004 fc68 	bl	8016d64 <strncpy_s>
 8012494:	4603      	mov	r3, r0
 8012496:	2b00      	cmp	r3, #0
 8012498:	d006      	beq.n	80124a8 <OsShellCmdPush+0x78>
        (VOID)LOS_MemFree(m_aucSysMem0, cmdNewNode);
 801249a:	4b0b      	ldr	r3, [pc, #44]	; (80124c8 <OsShellCmdPush+0x98>)
 801249c:	681b      	ldr	r3, [r3, #0]
 801249e:	68b9      	ldr	r1, [r7, #8]
 80124a0:	4618      	mov	r0, r3
 80124a2:	f7f7 f86f 	bl	8009584 <LOS_MemFree>
        return;
 80124a6:	e00b      	b.n	80124c0 <OsShellCmdPush+0x90>
    }

    LOS_ListTailInsert(&cmdKeyLink->list, &cmdNewNode->list);
 80124a8:	683b      	ldr	r3, [r7, #0]
 80124aa:	1d1a      	adds	r2, r3, #4
 80124ac:	68bb      	ldr	r3, [r7, #8]
 80124ae:	3304      	adds	r3, #4
 80124b0:	4619      	mov	r1, r3
 80124b2:	4610      	mov	r0, r2
 80124b4:	f7ff fc01 	bl	8011cba <LOS_ListTailInsert>

    return;
 80124b8:	e002      	b.n	80124c0 <OsShellCmdPush+0x90>
        return;
 80124ba:	bf00      	nop
 80124bc:	e000      	b.n	80124c0 <OsShellCmdPush+0x90>
        return;
 80124be:	bf00      	nop
}
 80124c0:	3710      	adds	r7, #16
 80124c2:	46bd      	mov	sp, r7
 80124c4:	bd80      	pop	{r7, pc}
 80124c6:	bf00      	nop
 80124c8:	200021bc 	.word	0x200021bc

080124cc <OsShellHistoryShow>:

LITE_OS_SEC_TEXT_MINOR VOID OsShellHistoryShow(UINT32 value, ShellCB *shellCB)
{
 80124cc:	b580      	push	{r7, lr}
 80124ce:	b088      	sub	sp, #32
 80124d0:	af00      	add	r7, sp, #0
 80124d2:	6078      	str	r0, [r7, #4]
 80124d4:	6039      	str	r1, [r7, #0]
    CmdKeyLink *cmd = NULL;
 80124d6:	2300      	movs	r3, #0
 80124d8:	60fb      	str	r3, [r7, #12]
    CmdKeyLink *cmdNode = shellCB->cmdHistoryKeyLink;
 80124da:	683b      	ldr	r3, [r7, #0]
 80124dc:	691b      	ldr	r3, [r3, #16]
 80124de:	613b      	str	r3, [r7, #16]
    CmdKeyLink *cmdMask = shellCB->cmdMaskKeyLink;
 80124e0:	683b      	ldr	r3, [r7, #0]
 80124e2:	695b      	ldr	r3, [r3, #20]
 80124e4:	60bb      	str	r3, [r7, #8]
    errno_t ret;

    HISTORY_LOCK(shellCB);
 80124e6:	683b      	ldr	r3, [r7, #0]
 80124e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80124ea:	f04f 31ff 	mov.w	r1, #4294967295
 80124ee:	4618      	mov	r0, r3
 80124f0:	f7f9 fa1c 	bl	800b92c <LOS_MuxPend>
 80124f4:	6178      	str	r0, [r7, #20]
 80124f6:	697b      	ldr	r3, [r7, #20]
 80124f8:	2b00      	cmp	r3, #0
 80124fa:	d009      	beq.n	8012510 <OsShellHistoryShow+0x44>
 80124fc:	4843      	ldr	r0, [pc, #268]	; (801260c <OsShellHistoryShow+0x140>)
 80124fe:	f7f2 f9df 	bl	80048c0 <dprintf>
 8012502:	697b      	ldr	r3, [r7, #20]
 8012504:	f240 22c6 	movw	r2, #710	; 0x2c6
 8012508:	4941      	ldr	r1, [pc, #260]	; (8012610 <OsShellHistoryShow+0x144>)
 801250a:	4842      	ldr	r0, [pc, #264]	; (8012614 <OsShellHistoryShow+0x148>)
 801250c:	f7f2 f9d8 	bl	80048c0 <dprintf>
    if (value == CMD_KEY_DOWN) {
 8012510:	687b      	ldr	r3, [r7, #4]
 8012512:	2b01      	cmp	r3, #1
 8012514:	d10e      	bne.n	8012534 <OsShellHistoryShow+0x68>
        if (cmdMask == cmdNode) {
 8012516:	68ba      	ldr	r2, [r7, #8]
 8012518:	693b      	ldr	r3, [r7, #16]
 801251a:	429a      	cmp	r2, r3
 801251c:	d058      	beq.n	80125d0 <OsShellHistoryShow+0x104>
            goto END;
        }

        cmd = LOS_DL_LIST_ENTRY(cmdMask->list.pstNext, CmdKeyLink, list);
 801251e:	68bb      	ldr	r3, [r7, #8]
 8012520:	689b      	ldr	r3, [r3, #8]
 8012522:	3b04      	subs	r3, #4
 8012524:	60fb      	str	r3, [r7, #12]
        if (cmd != cmdNode) {
 8012526:	68fa      	ldr	r2, [r7, #12]
 8012528:	693b      	ldr	r3, [r7, #16]
 801252a:	429a      	cmp	r2, r3
 801252c:	d052      	beq.n	80125d4 <OsShellHistoryShow+0x108>
            cmdMask = cmd;
 801252e:	68fb      	ldr	r3, [r7, #12]
 8012530:	60bb      	str	r3, [r7, #8]
 8012532:	e010      	b.n	8012556 <OsShellHistoryShow+0x8a>
        } else {
            goto END;
        }
    } else if (value == CMD_KEY_UP) {
 8012534:	687b      	ldr	r3, [r7, #4]
 8012536:	2b00      	cmp	r3, #0
 8012538:	d10d      	bne.n	8012556 <OsShellHistoryShow+0x8a>
        cmd = LOS_DL_LIST_ENTRY(cmdMask->list.pstPrev, CmdKeyLink, list);
 801253a:	68bb      	ldr	r3, [r7, #8]
 801253c:	685b      	ldr	r3, [r3, #4]
 801253e:	3b04      	subs	r3, #4
 8012540:	60fb      	str	r3, [r7, #12]
        if (cmd != cmdNode) {
 8012542:	68fa      	ldr	r2, [r7, #12]
 8012544:	693b      	ldr	r3, [r7, #16]
 8012546:	429a      	cmp	r2, r3
 8012548:	d046      	beq.n	80125d8 <OsShellHistoryShow+0x10c>
            cmdMask = cmd;
 801254a:	68fb      	ldr	r3, [r7, #12]
 801254c:	60bb      	str	r3, [r7, #8]
        } else {
            goto END;
        }
    }

    while (shellCB->shellBufOffset--) {
 801254e:	e002      	b.n	8012556 <OsShellHistoryShow+0x8a>
        PRINTK("\b \b");
 8012550:	4831      	ldr	r0, [pc, #196]	; (8012618 <OsShellHistoryShow+0x14c>)
 8012552:	f7f2 f9b5 	bl	80048c0 <dprintf>
    while (shellCB->shellBufOffset--) {
 8012556:	683b      	ldr	r3, [r7, #0]
 8012558:	699b      	ldr	r3, [r3, #24]
 801255a:	1e59      	subs	r1, r3, #1
 801255c:	683a      	ldr	r2, [r7, #0]
 801255e:	6191      	str	r1, [r2, #24]
 8012560:	2b00      	cmp	r3, #0
 8012562:	d1f5      	bne.n	8012550 <OsShellHistoryShow+0x84>
    }
    PRINTK("%s", cmdMask->cmdString);
 8012564:	68bb      	ldr	r3, [r7, #8]
 8012566:	330c      	adds	r3, #12
 8012568:	4619      	mov	r1, r3
 801256a:	482c      	ldr	r0, [pc, #176]	; (801261c <OsShellHistoryShow+0x150>)
 801256c:	f7f2 f9a8 	bl	80048c0 <dprintf>
    shellCB->shellBufOffset = strlen(cmdMask->cmdString);
 8012570:	68bb      	ldr	r3, [r7, #8]
 8012572:	330c      	adds	r3, #12
 8012574:	4618      	mov	r0, r3
 8012576:	f7fc ffea 	bl	800f54e <strlen>
 801257a:	4602      	mov	r2, r0
 801257c:	683b      	ldr	r3, [r7, #0]
 801257e:	619a      	str	r2, [r3, #24]
    (VOID)memset_s(shellCB->shellBuf, SHOW_MAX_LEN, 0, SHOW_MAX_LEN);
 8012580:	683b      	ldr	r3, [r7, #0]
 8012582:	f103 0034 	add.w	r0, r3, #52	; 0x34
 8012586:	f44f 7388 	mov.w	r3, #272	; 0x110
 801258a:	2200      	movs	r2, #0
 801258c:	f44f 7188 	mov.w	r1, #272	; 0x110
 8012590:	f7ef fd88 	bl	80020a4 <memset_s>
    ret = memcpy_s(shellCB->shellBuf, SHOW_MAX_LEN, cmdMask->cmdString, shellCB->shellBufOffset);
 8012594:	683b      	ldr	r3, [r7, #0]
 8012596:	f103 0034 	add.w	r0, r3, #52	; 0x34
 801259a:	68bb      	ldr	r3, [r7, #8]
 801259c:	f103 020c 	add.w	r2, r3, #12
 80125a0:	683b      	ldr	r3, [r7, #0]
 80125a2:	699b      	ldr	r3, [r3, #24]
 80125a4:	f44f 7188 	mov.w	r1, #272	; 0x110
 80125a8:	f004 fd76 	bl	8017098 <memcpy_s>
 80125ac:	61b8      	str	r0, [r7, #24]
    if (ret != EOK) {
 80125ae:	69bb      	ldr	r3, [r7, #24]
 80125b0:	2b00      	cmp	r3, #0
 80125b2:	d009      	beq.n	80125c8 <OsShellHistoryShow+0xfc>
        PRINT_ERR("%s, %d memcpy failed!\n", __FUNCTION__, __LINE__);
 80125b4:	4815      	ldr	r0, [pc, #84]	; (801260c <OsShellHistoryShow+0x140>)
 80125b6:	f7f2 f983 	bl	80048c0 <dprintf>
 80125ba:	f240 22e3 	movw	r2, #739	; 0x2e3
 80125be:	4914      	ldr	r1, [pc, #80]	; (8012610 <OsShellHistoryShow+0x144>)
 80125c0:	4817      	ldr	r0, [pc, #92]	; (8012620 <OsShellHistoryShow+0x154>)
 80125c2:	f7f2 f97d 	bl	80048c0 <dprintf>
        goto END;
 80125c6:	e008      	b.n	80125da <OsShellHistoryShow+0x10e>
    }
    shellCB->cmdMaskKeyLink = (VOID *)cmdMask;
 80125c8:	683b      	ldr	r3, [r7, #0]
 80125ca:	68ba      	ldr	r2, [r7, #8]
 80125cc:	615a      	str	r2, [r3, #20]
 80125ce:	e004      	b.n	80125da <OsShellHistoryShow+0x10e>
            goto END;
 80125d0:	bf00      	nop
 80125d2:	e002      	b.n	80125da <OsShellHistoryShow+0x10e>
            goto END;
 80125d4:	bf00      	nop
 80125d6:	e000      	b.n	80125da <OsShellHistoryShow+0x10e>
            goto END;
 80125d8:	bf00      	nop

END:
    HISTORY_UNLOCK(shellCB);
 80125da:	683b      	ldr	r3, [r7, #0]
 80125dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80125de:	4618      	mov	r0, r3
 80125e0:	f7f9 fb24 	bl	800bc2c <LOS_MuxPost>
 80125e4:	61f8      	str	r0, [r7, #28]
 80125e6:	69fb      	ldr	r3, [r7, #28]
 80125e8:	2b00      	cmp	r3, #0
 80125ea:	d00a      	beq.n	8012602 <OsShellHistoryShow+0x136>
 80125ec:	4807      	ldr	r0, [pc, #28]	; (801260c <OsShellHistoryShow+0x140>)
 80125ee:	f7f2 f967 	bl	80048c0 <dprintf>
 80125f2:	69fb      	ldr	r3, [r7, #28]
 80125f4:	f240 22e9 	movw	r2, #745	; 0x2e9
 80125f8:	4905      	ldr	r1, [pc, #20]	; (8012610 <OsShellHistoryShow+0x144>)
 80125fa:	480a      	ldr	r0, [pc, #40]	; (8012624 <OsShellHistoryShow+0x158>)
 80125fc:	f7f2 f960 	bl	80048c0 <dprintf>
    return;
 8012600:	bf00      	nop
 8012602:	bf00      	nop
}
 8012604:	3720      	adds	r7, #32
 8012606:	46bd      	mov	sp, r7
 8012608:	bd80      	pop	{r7, pc}
 801260a:	bf00      	nop
 801260c:	08021aa4 	.word	0x08021aa4
 8012610:	0802354c 	.word	0x0802354c
 8012614:	08021b4c 	.word	0x08021b4c
 8012618:	08021b70 	.word	0x08021b70
 801261c:	08021b74 	.word	0x08021b74
 8012620:	08021b78 	.word	0x08021b78
 8012624:	08021b90 	.word	0x08021b90

08012628 <OsCmdExec>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdExec(CmdParsed *cmdParsed, CHAR *cmdStr)
{
 8012628:	b590      	push	{r4, r7, lr}
 801262a:	b087      	sub	sp, #28
 801262c:	af00      	add	r7, sp, #0
 801262e:	6078      	str	r0, [r7, #4]
 8012630:	6039      	str	r1, [r7, #0]
    UINT32 ret;
    CmdCallBackFunc cmdHook = NULL;
 8012632:	2300      	movs	r3, #0
 8012634:	60fb      	str	r3, [r7, #12]
    CmdItemNode *curCmdItem = NULL;
 8012636:	2300      	movs	r3, #0
 8012638:	613b      	str	r3, [r7, #16]
    CHAR *cmdKey = NULL;
 801263a:	2300      	movs	r3, #0
 801263c:	617b      	str	r3, [r7, #20]

    if ((cmdStr == NULL) || (strlen(cmdStr) == 0)) {
 801263e:	683b      	ldr	r3, [r7, #0]
 8012640:	2b00      	cmp	r3, #0
 8012642:	d005      	beq.n	8012650 <OsCmdExec+0x28>
 8012644:	6838      	ldr	r0, [r7, #0]
 8012646:	f7fc ff82 	bl	800f54e <strlen>
 801264a:	4603      	mov	r3, r0
 801264c:	2b00      	cmp	r3, #0
 801264e:	d102      	bne.n	8012656 <OsCmdExec+0x2e>
        return (UINT32)OS_ERROR;
 8012650:	f04f 33ff 	mov.w	r3, #4294967295
 8012654:	e052      	b.n	80126fc <OsCmdExec+0xd4>
    }

    ret = OsCmdParse(cmdStr, cmdParsed);
 8012656:	6879      	ldr	r1, [r7, #4]
 8012658:	6838      	ldr	r0, [r7, #0]
 801265a:	f001 fd01 	bl	8014060 <OsCmdParse>
 801265e:	60b8      	str	r0, [r7, #8]
    if (ret != LOS_OK) {
 8012660:	68bb      	ldr	r3, [r7, #8]
 8012662:	2b00      	cmp	r3, #0
 8012664:	d001      	beq.n	801266a <OsCmdExec+0x42>
        return ret;
 8012666:	68bb      	ldr	r3, [r7, #8]
 8012668:	e048      	b.n	80126fc <OsCmdExec+0xd4>
    }

    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &g_cmdInfo.cmdList.list, CmdItemNode, list) {
 801266a:	4b26      	ldr	r3, [pc, #152]	; (8012704 <OsCmdExec+0xdc>)
 801266c:	685b      	ldr	r3, [r3, #4]
 801266e:	613b      	str	r3, [r7, #16]
 8012670:	e02d      	b.n	80126ce <OsCmdExec+0xa6>
        cmdKey = curCmdItem->cmd->cmdKey;
 8012672:	693b      	ldr	r3, [r7, #16]
 8012674:	689b      	ldr	r3, [r3, #8]
 8012676:	685b      	ldr	r3, [r3, #4]
 8012678:	617b      	str	r3, [r7, #20]
        if ((cmdParsed->cmdType == curCmdItem->cmd->cmdType) &&
 801267a:	687b      	ldr	r3, [r7, #4]
 801267c:	685a      	ldr	r2, [r3, #4]
 801267e:	693b      	ldr	r3, [r7, #16]
 8012680:	689b      	ldr	r3, [r3, #8]
 8012682:	681b      	ldr	r3, [r3, #0]
 8012684:	429a      	cmp	r2, r3
 8012686:	d11f      	bne.n	80126c8 <OsCmdExec+0xa0>
            (strlen(cmdKey) == strlen(cmdParsed->cmdKeyword)) &&
 8012688:	6978      	ldr	r0, [r7, #20]
 801268a:	f7fc ff60 	bl	800f54e <strlen>
 801268e:	4604      	mov	r4, r0
 8012690:	687b      	ldr	r3, [r7, #4]
 8012692:	3308      	adds	r3, #8
 8012694:	4618      	mov	r0, r3
 8012696:	f7fc ff5a 	bl	800f54e <strlen>
 801269a:	4603      	mov	r3, r0
        if ((cmdParsed->cmdType == curCmdItem->cmd->cmdType) &&
 801269c:	429c      	cmp	r4, r3
 801269e:	d113      	bne.n	80126c8 <OsCmdExec+0xa0>
            (strncmp(cmdKey, (CHAR *)(cmdParsed->cmdKeyword), strlen(cmdKey)) == 0)) {
 80126a0:	687b      	ldr	r3, [r7, #4]
 80126a2:	f103 0408 	add.w	r4, r3, #8
 80126a6:	6978      	ldr	r0, [r7, #20]
 80126a8:	f7fc ff51 	bl	800f54e <strlen>
 80126ac:	4603      	mov	r3, r0
 80126ae:	461a      	mov	r2, r3
 80126b0:	4621      	mov	r1, r4
 80126b2:	6978      	ldr	r0, [r7, #20]
 80126b4:	f006 ffce 	bl	8019654 <strncmp>
 80126b8:	4603      	mov	r3, r0
            (strlen(cmdKey) == strlen(cmdParsed->cmdKeyword)) &&
 80126ba:	2b00      	cmp	r3, #0
 80126bc:	d104      	bne.n	80126c8 <OsCmdExec+0xa0>
            cmdHook = curCmdItem->cmd->cmdHook;
 80126be:	693b      	ldr	r3, [r7, #16]
 80126c0:	689b      	ldr	r3, [r3, #8]
 80126c2:	68db      	ldr	r3, [r3, #12]
 80126c4:	60fb      	str	r3, [r7, #12]
            break;
 80126c6:	e006      	b.n	80126d6 <OsCmdExec+0xae>
    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &g_cmdInfo.cmdList.list, CmdItemNode, list) {
 80126c8:	693b      	ldr	r3, [r7, #16]
 80126ca:	685b      	ldr	r3, [r3, #4]
 80126cc:	613b      	str	r3, [r7, #16]
 80126ce:	693b      	ldr	r3, [r7, #16]
 80126d0:	4a0c      	ldr	r2, [pc, #48]	; (8012704 <OsCmdExec+0xdc>)
 80126d2:	4293      	cmp	r3, r2
 80126d4:	d1cd      	bne.n	8012672 <OsCmdExec+0x4a>
        }
    }

    ret = OS_ERROR;
 80126d6:	f04f 33ff 	mov.w	r3, #4294967295
 80126da:	60bb      	str	r3, [r7, #8]
    if (cmdHook != NULL) {
 80126dc:	68fb      	ldr	r3, [r7, #12]
 80126de:	2b00      	cmp	r3, #0
 80126e0:	d008      	beq.n	80126f4 <OsCmdExec+0xcc>
        ret = (cmdHook)(cmdParsed->paramCnt, (const CHAR **)cmdParsed->paramArray);
 80126e2:	687b      	ldr	r3, [r7, #4]
 80126e4:	681a      	ldr	r2, [r3, #0]
 80126e6:	687b      	ldr	r3, [r7, #4]
 80126e8:	f103 0118 	add.w	r1, r3, #24
 80126ec:	68fb      	ldr	r3, [r7, #12]
 80126ee:	4610      	mov	r0, r2
 80126f0:	4798      	blx	r3
 80126f2:	60b8      	str	r0, [r7, #8]
    }
    OsFreeCmdPara(cmdParsed);
 80126f4:	6878      	ldr	r0, [r7, #4]
 80126f6:	f7ff fb25 	bl	8011d44 <OsFreeCmdPara>

    return (UINT32)ret;
 80126fa:	68bb      	ldr	r3, [r7, #8]
}
 80126fc:	4618      	mov	r0, r3
 80126fe:	371c      	adds	r7, #28
 8012700:	46bd      	mov	sp, r7
 8012702:	bd90      	pop	{r4, r7, pc}
 8012704:	200032ac 	.word	0x200032ac

08012708 <OsCmdInit>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdInit(VOID)
{
 8012708:	b580      	push	{r7, lr}
 801270a:	b082      	sub	sp, #8
 801270c:	af00      	add	r7, sp, #0
    UINT32 ret;
    LOS_ListInit(&(g_cmdInfo.cmdList.list));
 801270e:	4811      	ldr	r0, [pc, #68]	; (8012754 <OsCmdInit+0x4c>)
 8012710:	f7ff faaa 	bl	8011c68 <LOS_ListInit>
    g_cmdInfo.listNum = 0;
 8012714:	4b0f      	ldr	r3, [pc, #60]	; (8012754 <OsCmdInit+0x4c>)
 8012716:	2200      	movs	r2, #0
 8012718:	60da      	str	r2, [r3, #12]
    g_cmdInfo.muxLock = 0;
 801271a:	4b0e      	ldr	r3, [pc, #56]	; (8012754 <OsCmdInit+0x4c>)
 801271c:	2200      	movs	r2, #0
 801271e:	615a      	str	r2, [r3, #20]
    g_cmdInfo.initMagicFlag = SHELL_INIT_MAGIC_FLAG;
 8012720:	4b0c      	ldr	r3, [pc, #48]	; (8012754 <OsCmdInit+0x4c>)
 8012722:	f04f 32ab 	mov.w	r2, #2880154539	; 0xabababab
 8012726:	611a      	str	r2, [r3, #16]
    ret = LOS_MuxCreate(&g_cmdInfo.muxLock);
 8012728:	480b      	ldr	r0, [pc, #44]	; (8012758 <OsCmdInit+0x50>)
 801272a:	f7f8 fe55 	bl	800b3d8 <LOS_MuxCreate>
 801272e:	6078      	str	r0, [r7, #4]
    if (ret != LOS_OK) {
 8012730:	687b      	ldr	r3, [r7, #4]
 8012732:	2b00      	cmp	r3, #0
 8012734:	d008      	beq.n	8012748 <OsCmdInit+0x40>
        PRINT_ERR("Create mutex for shell cmd info failed\n");
 8012736:	4809      	ldr	r0, [pc, #36]	; (801275c <OsCmdInit+0x54>)
 8012738:	f7f2 f8c2 	bl	80048c0 <dprintf>
 801273c:	4808      	ldr	r0, [pc, #32]	; (8012760 <OsCmdInit+0x58>)
 801273e:	f7f2 f8bf 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8012742:	f04f 33ff 	mov.w	r3, #4294967295
 8012746:	e000      	b.n	801274a <OsCmdInit+0x42>
    }
    return LOS_OK;
 8012748:	2300      	movs	r3, #0
}
 801274a:	4618      	mov	r0, r3
 801274c:	3708      	adds	r7, #8
 801274e:	46bd      	mov	sp, r7
 8012750:	bd80      	pop	{r7, pc}
 8012752:	bf00      	nop
 8012754:	200032ac 	.word	0x200032ac
 8012758:	200032c0 	.word	0x200032c0
 801275c:	08021aa4 	.word	0x08021aa4
 8012760:	08021bb4 	.word	0x08021bb4

08012764 <OsCmdDeInit>:

LITE_OS_SEC_TEXT_MINOR VOID OsCmdDeInit(VOID)
{
 8012764:	b580      	push	{r7, lr}
 8012766:	af00      	add	r7, sp, #0
    g_cmdInfo.initMagicFlag = 0;
 8012768:	4b04      	ldr	r3, [pc, #16]	; (801277c <OsCmdDeInit+0x18>)
 801276a:	2200      	movs	r2, #0
 801276c:	611a      	str	r2, [r3, #16]
    (VOID)LOS_MuxDelete(g_cmdInfo.muxLock);
 801276e:	4b03      	ldr	r3, [pc, #12]	; (801277c <OsCmdDeInit+0x18>)
 8012770:	695b      	ldr	r3, [r3, #20]
 8012772:	4618      	mov	r0, r3
 8012774:	f7f8 feca 	bl	800b50c <LOS_MuxDelete>
}
 8012778:	bf00      	nop
 801277a:	bd80      	pop	{r7, pc}
 801277c:	200032ac 	.word	0x200032ac

08012780 <OsCopyTm>:
    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
    {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

STATIC VOID OsCopyTm(struct tm *destTm, const struct tm *srcTm)
{
 8012780:	b580      	push	{r7, lr}
 8012782:	b082      	sub	sp, #8
 8012784:	af00      	add	r7, sp, #0
 8012786:	6078      	str	r0, [r7, #4]
 8012788:	6039      	str	r1, [r7, #0]
    if (srcTm == NULL) {
 801278a:	683b      	ldr	r3, [r7, #0]
 801278c:	2b00      	cmp	r3, #0
 801278e:	d106      	bne.n	801279e <OsCopyTm+0x1e>
        (VOID)memset_s(destTm, sizeof(struct tm), 0, sizeof(struct tm));
 8012790:	232c      	movs	r3, #44	; 0x2c
 8012792:	2200      	movs	r2, #0
 8012794:	212c      	movs	r1, #44	; 0x2c
 8012796:	6878      	ldr	r0, [r7, #4]
 8012798:	f7ef fc84 	bl	80020a4 <memset_s>
        destTm->tm_yday = srcTm->tm_yday;
        destTm->tm_isdst = srcTm->tm_isdst;
        destTm->tm_gmtoff = srcTm->tm_gmtoff;
        destTm->tm_zone = srcTm->tm_zone;
    }
}
 801279c:	e02b      	b.n	80127f6 <OsCopyTm+0x76>
        destTm->tm_sec = srcTm->tm_sec;
 801279e:	683b      	ldr	r3, [r7, #0]
 80127a0:	681a      	ldr	r2, [r3, #0]
 80127a2:	687b      	ldr	r3, [r7, #4]
 80127a4:	601a      	str	r2, [r3, #0]
        destTm->tm_min = srcTm->tm_min;
 80127a6:	683b      	ldr	r3, [r7, #0]
 80127a8:	685a      	ldr	r2, [r3, #4]
 80127aa:	687b      	ldr	r3, [r7, #4]
 80127ac:	605a      	str	r2, [r3, #4]
        destTm->tm_hour = srcTm->tm_hour;
 80127ae:	683b      	ldr	r3, [r7, #0]
 80127b0:	689a      	ldr	r2, [r3, #8]
 80127b2:	687b      	ldr	r3, [r7, #4]
 80127b4:	609a      	str	r2, [r3, #8]
        destTm->tm_mday = srcTm->tm_mday;
 80127b6:	683b      	ldr	r3, [r7, #0]
 80127b8:	68da      	ldr	r2, [r3, #12]
 80127ba:	687b      	ldr	r3, [r7, #4]
 80127bc:	60da      	str	r2, [r3, #12]
        destTm->tm_mon = srcTm->tm_mon;
 80127be:	683b      	ldr	r3, [r7, #0]
 80127c0:	691a      	ldr	r2, [r3, #16]
 80127c2:	687b      	ldr	r3, [r7, #4]
 80127c4:	611a      	str	r2, [r3, #16]
        destTm->tm_year = srcTm->tm_year;
 80127c6:	683b      	ldr	r3, [r7, #0]
 80127c8:	695a      	ldr	r2, [r3, #20]
 80127ca:	687b      	ldr	r3, [r7, #4]
 80127cc:	615a      	str	r2, [r3, #20]
        destTm->tm_wday = srcTm->tm_wday;
 80127ce:	683b      	ldr	r3, [r7, #0]
 80127d0:	699a      	ldr	r2, [r3, #24]
 80127d2:	687b      	ldr	r3, [r7, #4]
 80127d4:	619a      	str	r2, [r3, #24]
        destTm->tm_yday = srcTm->tm_yday;
 80127d6:	683b      	ldr	r3, [r7, #0]
 80127d8:	69da      	ldr	r2, [r3, #28]
 80127da:	687b      	ldr	r3, [r7, #4]
 80127dc:	61da      	str	r2, [r3, #28]
        destTm->tm_isdst = srcTm->tm_isdst;
 80127de:	683b      	ldr	r3, [r7, #0]
 80127e0:	6a1a      	ldr	r2, [r3, #32]
 80127e2:	687b      	ldr	r3, [r7, #4]
 80127e4:	621a      	str	r2, [r3, #32]
        destTm->tm_gmtoff = srcTm->tm_gmtoff;
 80127e6:	683b      	ldr	r3, [r7, #0]
 80127e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80127ea:	687b      	ldr	r3, [r7, #4]
 80127ec:	625a      	str	r2, [r3, #36]	; 0x24
        destTm->tm_zone = srcTm->tm_zone;
 80127ee:	683b      	ldr	r3, [r7, #0]
 80127f0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80127f2:	687b      	ldr	r3, [r7, #4]
 80127f4:	629a      	str	r2, [r3, #40]	; 0x28
}
 80127f6:	bf00      	nop
 80127f8:	3708      	adds	r7, #8
 80127fa:	46bd      	mov	sp, r7
 80127fc:	bd80      	pop	{r7, pc}
	...

08012800 <OsCmdUsageDate>:

STATIC VOID OsCmdUsageDate(INT32 order)
{
 8012800:	b580      	push	{r7, lr}
 8012802:	b082      	sub	sp, #8
 8012804:	af00      	add	r7, sp, #0
 8012806:	6078      	str	r0, [r7, #4]
    if (order) {
 8012808:	687b      	ldr	r3, [r7, #4]
 801280a:	2b00      	cmp	r3, #0
 801280c:	d006      	beq.n	801281c <OsCmdUsageDate+0x1c>
        PRINTK("date: invalid option or parameter.\n");
 801280e:	4842      	ldr	r0, [pc, #264]	; (8012918 <OsCmdUsageDate+0x118>)
 8012810:	f7f2 f856 	bl	80048c0 <dprintf>
        PRINTK("Try 'date --help' for more information.\n");
 8012814:	4841      	ldr	r0, [pc, #260]	; (801291c <OsCmdUsageDate+0x11c>)
 8012816:	f7f2 f853 	bl	80048c0 <dprintf>
        return;
 801281a:	e07a      	b.n	8012912 <OsCmdUsageDate+0x112>
    }
    PRINTK("\nUsage: date [+FORMAT]\n");
 801281c:	4840      	ldr	r0, [pc, #256]	; (8012920 <OsCmdUsageDate+0x120>)
 801281e:	f7f2 f84f 	bl	80048c0 <dprintf>
    PRINTK("   or: date [-s] [YY/MM/DD] [hh:mm:ss]\n");
 8012822:	4840      	ldr	r0, [pc, #256]	; (8012924 <OsCmdUsageDate+0x124>)
 8012824:	f7f2 f84c 	bl	80048c0 <dprintf>
    PRINTK("Display the current time in the given FORMAT, or set the system date.\n");
 8012828:	483f      	ldr	r0, [pc, #252]	; (8012928 <OsCmdUsageDate+0x128>)
 801282a:	f7f2 f849 	bl	80048c0 <dprintf>
    PRINTK("FORMAT controls the output.  Interpreted sequences are:\n");
 801282e:	483f      	ldr	r0, [pc, #252]	; (801292c <OsCmdUsageDate+0x12c>)
 8012830:	f7f2 f846 	bl	80048c0 <dprintf>
    PRINTK("  %%b     The abbreviated month name according to the current locale.\n");
 8012834:	483e      	ldr	r0, [pc, #248]	; (8012930 <OsCmdUsageDate+0x130>)
 8012836:	f7f2 f843 	bl	80048c0 <dprintf>
    PRINTK("  %%B     The full month name according to the current locale.\n");
 801283a:	483e      	ldr	r0, [pc, #248]	; (8012934 <OsCmdUsageDate+0x134>)
 801283c:	f7f2 f840 	bl	80048c0 <dprintf>
    PRINTK("  %%C     The century number (year/100) as a 2-digit integer. (SU)\n");
 8012840:	483d      	ldr	r0, [pc, #244]	; (8012938 <OsCmdUsageDate+0x138>)
 8012842:	f7f2 f83d 	bl	80048c0 <dprintf>
    PRINTK("  %%d     The day of the month as a decimal number (range 01 to 31).\n");
 8012846:	483d      	ldr	r0, [pc, #244]	; (801293c <OsCmdUsageDate+0x13c>)
 8012848:	f7f2 f83a 	bl	80048c0 <dprintf>
    PRINTK("  %%e     Like %%d, the day of the month as a decimal number, \n");
 801284c:	483c      	ldr	r0, [pc, #240]	; (8012940 <OsCmdUsageDate+0x140>)
 801284e:	f7f2 f837 	bl	80048c0 <dprintf>
    PRINTK("         but a leading zero is replaced by a space.\n");
 8012852:	483c      	ldr	r0, [pc, #240]	; (8012944 <OsCmdUsageDate+0x144>)
 8012854:	f7f2 f834 	bl	80048c0 <dprintf>
    PRINTK("  %%h     Equivalent to %%b.  (SU)\n");
 8012858:	483b      	ldr	r0, [pc, #236]	; (8012948 <OsCmdUsageDate+0x148>)
 801285a:	f7f2 f831 	bl	80048c0 <dprintf>
    PRINTK("  %%H     The hour as a decimal number using a 24-hour clock (range 00 to 23).\n");
 801285e:	483b      	ldr	r0, [pc, #236]	; (801294c <OsCmdUsageDate+0x14c>)
 8012860:	f7f2 f82e 	bl	80048c0 <dprintf>
    PRINTK("  %%I     The hour as a decimal number using a 12-hour clock (range 01 to 12).\n");
 8012864:	483a      	ldr	r0, [pc, #232]	; (8012950 <OsCmdUsageDate+0x150>)
 8012866:	f7f2 f82b 	bl	80048c0 <dprintf>
    PRINTK("  %%j     The day of the year as a decimal number (range 001 to 366).\n");
 801286a:	483a      	ldr	r0, [pc, #232]	; (8012954 <OsCmdUsageDate+0x154>)
 801286c:	f7f2 f828 	bl	80048c0 <dprintf>
    PRINTK("  %%k     The hour (24-hour clock) as a decimal number (range  0  to  23); \n");
 8012870:	4839      	ldr	r0, [pc, #228]	; (8012958 <OsCmdUsageDate+0x158>)
 8012872:	f7f2 f825 	bl	80048c0 <dprintf>
    PRINTK("         single digits are preceded by a blank.  (See also %%H.)  (TZ)\n");
 8012876:	4839      	ldr	r0, [pc, #228]	; (801295c <OsCmdUsageDate+0x15c>)
 8012878:	f7f2 f822 	bl	80048c0 <dprintf>
    PRINTK("  %%l     The hour (12-hour  clock) as a decimal number (range 1 to 12); \n");
 801287c:	4838      	ldr	r0, [pc, #224]	; (8012960 <OsCmdUsageDate+0x160>)
 801287e:	f7f2 f81f 	bl	80048c0 <dprintf>
    PRINTK("         single digits are preceded by a blank.  (See also %%I.)  (TZ)\n");
 8012882:	4838      	ldr	r0, [pc, #224]	; (8012964 <OsCmdUsageDate+0x164>)
 8012884:	f7f2 f81c 	bl	80048c0 <dprintf>
    PRINTK("  %%m     The month as a decimal number (range 01 to 12).\n");
 8012888:	4837      	ldr	r0, [pc, #220]	; (8012968 <OsCmdUsageDate+0x168>)
 801288a:	f7f2 f819 	bl	80048c0 <dprintf>
    PRINTK("  %%M     The minute as a decimal number (range 00 to 59).\n");
 801288e:	4837      	ldr	r0, [pc, #220]	; (801296c <OsCmdUsageDate+0x16c>)
 8012890:	f7f2 f816 	bl	80048c0 <dprintf>
    PRINTK("  %%n     A newline character. (SU)\n");
 8012894:	4836      	ldr	r0, [pc, #216]	; (8012970 <OsCmdUsageDate+0x170>)
 8012896:	f7f2 f813 	bl	80048c0 <dprintf>
    PRINTK("  %%p     Either \"AM\" or \"PM\" according to the given time value, \n");
 801289a:	4836      	ldr	r0, [pc, #216]	; (8012974 <OsCmdUsageDate+0x174>)
 801289c:	f7f2 f810 	bl	80048c0 <dprintf>
    PRINTK("         or the corresponding strings for the current locale.\n");
 80128a0:	4835      	ldr	r0, [pc, #212]	; (8012978 <OsCmdUsageDate+0x178>)
 80128a2:	f7f2 f80d 	bl	80048c0 <dprintf>
    PRINTK("         Noon is treated as \"PM\" and midnight as \"AM\".\n");
 80128a6:	4835      	ldr	r0, [pc, #212]	; (801297c <OsCmdUsageDate+0x17c>)
 80128a8:	f7f2 f80a 	bl	80048c0 <dprintf>
    PRINTK("  %%P     Like %%p but in lowercase: \"am\" or \"pm\" \n");
 80128ac:	4834      	ldr	r0, [pc, #208]	; (8012980 <OsCmdUsageDate+0x180>)
 80128ae:	f7f2 f807 	bl	80048c0 <dprintf>
    PRINTK("         or a corresponding string for the current locale. (GNU)\n");
 80128b2:	4834      	ldr	r0, [pc, #208]	; (8012984 <OsCmdUsageDate+0x184>)
 80128b4:	f7f2 f804 	bl	80048c0 <dprintf>
    PRINTK("  %%s     The number of seconds since the Epoch, that is,\n");
 80128b8:	4833      	ldr	r0, [pc, #204]	; (8012988 <OsCmdUsageDate+0x188>)
 80128ba:	f7f2 f801 	bl	80048c0 <dprintf>
    PRINTK("         since 1970-01-01 00:00:00 UTC. (TZ)\n");
 80128be:	4833      	ldr	r0, [pc, #204]	; (801298c <OsCmdUsageDate+0x18c>)
 80128c0:	f7f1 fffe 	bl	80048c0 <dprintf>
    PRINTK("  %%S     The second as a decimal number (range 00 to 60).\n");
 80128c4:	4832      	ldr	r0, [pc, #200]	; (8012990 <OsCmdUsageDate+0x190>)
 80128c6:	f7f1 fffb 	bl	80048c0 <dprintf>
    PRINTK("         (The range is up to 60 to allow for occasional leap seconds.)\n");
 80128ca:	4832      	ldr	r0, [pc, #200]	; (8012994 <OsCmdUsageDate+0x194>)
 80128cc:	f7f1 fff8 	bl	80048c0 <dprintf>
    PRINTK("  %%t     A tab character. (SU)\n");
 80128d0:	4831      	ldr	r0, [pc, #196]	; (8012998 <OsCmdUsageDate+0x198>)
 80128d2:	f7f1 fff5 	bl	80048c0 <dprintf>
    PRINTK("  %%y     The year as a decimal number without a century (range 00 to 99).\n");
 80128d6:	4831      	ldr	r0, [pc, #196]	; (801299c <OsCmdUsageDate+0x19c>)
 80128d8:	f7f1 fff2 	bl	80048c0 <dprintf>
    PRINTK("  %%Y     The year as a decimal number including the century.\n");
 80128dc:	4830      	ldr	r0, [pc, #192]	; (80129a0 <OsCmdUsageDate+0x1a0>)
 80128de:	f7f1 ffef 	bl	80048c0 <dprintf>
    PRINTK("  %%%%     A literal '%%' character.\n");
 80128e2:	4830      	ldr	r0, [pc, #192]	; (80129a4 <OsCmdUsageDate+0x1a4>)
 80128e4:	f7f1 ffec 	bl	80048c0 <dprintf>
    PRINTK("\nExamples:\n");
 80128e8:	482f      	ldr	r0, [pc, #188]	; (80129a8 <OsCmdUsageDate+0x1a8>)
 80128ea:	f7f1 ffe9 	bl	80048c0 <dprintf>
    PRINTK("Set system date (2017-01-01)\n");
 80128ee:	482f      	ldr	r0, [pc, #188]	; (80129ac <OsCmdUsageDate+0x1ac>)
 80128f0:	f7f1 ffe6 	bl	80048c0 <dprintf>
    PRINTK("$ date -s 20170101\n");
 80128f4:	482e      	ldr	r0, [pc, #184]	; (80129b0 <OsCmdUsageDate+0x1b0>)
 80128f6:	f7f1 ffe3 	bl	80048c0 <dprintf>
    PRINTK("Set system time (12:00:00)\n");
 80128fa:	482e      	ldr	r0, [pc, #184]	; (80129b4 <OsCmdUsageDate+0x1b4>)
 80128fc:	f7f1 ffe0 	bl	80048c0 <dprintf>
    PRINTK("$ date -s 12:00:00\n");
 8012900:	482d      	ldr	r0, [pc, #180]	; (80129b8 <OsCmdUsageDate+0x1b8>)
 8012902:	f7f1 ffdd 	bl	80048c0 <dprintf>
    PRINTK("Show the time with format Year-Month-Day\n");
 8012906:	482d      	ldr	r0, [pc, #180]	; (80129bc <OsCmdUsageDate+0x1bc>)
 8012908:	f7f1 ffda 	bl	80048c0 <dprintf>
    PRINTK("$ date +%%Y-%%m-%%d\n");
 801290c:	482c      	ldr	r0, [pc, #176]	; (80129c0 <OsCmdUsageDate+0x1c0>)
 801290e:	f7f1 ffd7 	bl	80048c0 <dprintf>
}
 8012912:	3708      	adds	r7, #8
 8012914:	46bd      	mov	sp, r7
 8012916:	bd80      	pop	{r7, pc}
 8012918:	08021c00 	.word	0x08021c00
 801291c:	08021c24 	.word	0x08021c24
 8012920:	08021c50 	.word	0x08021c50
 8012924:	08021c68 	.word	0x08021c68
 8012928:	08021c90 	.word	0x08021c90
 801292c:	08021cd8 	.word	0x08021cd8
 8012930:	08021d14 	.word	0x08021d14
 8012934:	08021d5c 	.word	0x08021d5c
 8012938:	08021d9c 	.word	0x08021d9c
 801293c:	08021de0 	.word	0x08021de0
 8012940:	08021e28 	.word	0x08021e28
 8012944:	08021e68 	.word	0x08021e68
 8012948:	08021ea0 	.word	0x08021ea0
 801294c:	08021ec4 	.word	0x08021ec4
 8012950:	08021f14 	.word	0x08021f14
 8012954:	08021f64 	.word	0x08021f64
 8012958:	08021fac 	.word	0x08021fac
 801295c:	08021ffc 	.word	0x08021ffc
 8012960:	08022044 	.word	0x08022044
 8012964:	08022090 	.word	0x08022090
 8012968:	080220d8 	.word	0x080220d8
 801296c:	08022114 	.word	0x08022114
 8012970:	08022150 	.word	0x08022150
 8012974:	08022178 	.word	0x08022178
 8012978:	080221bc 	.word	0x080221bc
 801297c:	080221fc 	.word	0x080221fc
 8012980:	08022234 	.word	0x08022234
 8012984:	08022268 	.word	0x08022268
 8012988:	080222ac 	.word	0x080222ac
 801298c:	080222e8 	.word	0x080222e8
 8012990:	08022318 	.word	0x08022318
 8012994:	08022354 	.word	0x08022354
 8012998:	0802239c 	.word	0x0802239c
 801299c:	080223c0 	.word	0x080223c0
 80129a0:	0802240c 	.word	0x0802240c
 80129a4:	0802244c 	.word	0x0802244c
 80129a8:	08022474 	.word	0x08022474
 80129ac:	08022480 	.word	0x08022480
 80129b0:	080224a0 	.word	0x080224a0
 80129b4:	080224b4 	.word	0x080224b4
 80129b8:	080224d0 	.word	0x080224d0
 80129bc:	080224e4 	.word	0x080224e4
 80129c0:	08022510 	.word	0x08022510

080129c4 <OsStrToTm>:

STATIC INT32 OsStrToTm(const CHAR *str, struct tm *tm)
{
 80129c4:	b590      	push	{r4, r7, lr}
 80129c6:	b085      	sub	sp, #20
 80129c8:	af00      	add	r7, sp, #0
 80129ca:	6078      	str	r0, [r7, #4]
 80129cc:	6039      	str	r1, [r7, #0]
    CHAR *ret = NULL;
 80129ce:	2300      	movs	r3, #0
 80129d0:	60bb      	str	r3, [r7, #8]
    UINT32 strLen = strlen(str);
 80129d2:	6878      	ldr	r0, [r7, #4]
 80129d4:	f7fc fdbb 	bl	800f54e <strlen>
 80129d8:	60f8      	str	r0, [r7, #12]
    if (strLen == 8) { /* 8:Time format string length, such as hh:mm:ss or yyyymmdd */
 80129da:	68fb      	ldr	r3, [r7, #12]
 80129dc:	2b08      	cmp	r3, #8
 80129de:	d112      	bne.n	8012a06 <OsStrToTm+0x42>
        if (str[2] == ':') { /* 2:Index of Eigenvalues */
 80129e0:	687b      	ldr	r3, [r7, #4]
 80129e2:	3302      	adds	r3, #2
 80129e4:	781b      	ldrb	r3, [r3, #0]
 80129e6:	2b3a      	cmp	r3, #58	; 0x3a
 80129e8:	d106      	bne.n	80129f8 <OsStrToTm+0x34>
            ret = strptime(str, "%H:%M:%S", tm);
 80129ea:	683a      	ldr	r2, [r7, #0]
 80129ec:	494e      	ldr	r1, [pc, #312]	; (8012b28 <OsStrToTm+0x164>)
 80129ee:	6878      	ldr	r0, [r7, #4]
 80129f0:	f007 fc28 	bl	801a244 <strptime>
 80129f4:	60b8      	str	r0, [r7, #8]
 80129f6:	e039      	b.n	8012a6c <OsStrToTm+0xa8>
        } else {
            ret = strptime(str, "%Y%m%d", tm);
 80129f8:	683a      	ldr	r2, [r7, #0]
 80129fa:	494c      	ldr	r1, [pc, #304]	; (8012b2c <OsStrToTm+0x168>)
 80129fc:	6878      	ldr	r0, [r7, #4]
 80129fe:	f007 fc21 	bl	801a244 <strptime>
 8012a02:	60b8      	str	r0, [r7, #8]
 8012a04:	e032      	b.n	8012a6c <OsStrToTm+0xa8>
        }
    } else if (strLen == 10) { /* 10:Time format string length,such as yyyy/mm/dd  */
 8012a06:	68fb      	ldr	r3, [r7, #12]
 8012a08:	2b0a      	cmp	r3, #10
 8012a0a:	d106      	bne.n	8012a1a <OsStrToTm+0x56>
        ret = strptime(str, "%Y/%m/%d", tm);
 8012a0c:	683a      	ldr	r2, [r7, #0]
 8012a0e:	4948      	ldr	r1, [pc, #288]	; (8012b30 <OsStrToTm+0x16c>)
 8012a10:	6878      	ldr	r0, [r7, #4]
 8012a12:	f007 fc17 	bl	801a244 <strptime>
 8012a16:	60b8      	str	r0, [r7, #8]
 8012a18:	e028      	b.n	8012a6c <OsStrToTm+0xa8>
    } else if (strLen == 5) { /* 5:Time format string length,such as hh:mm or mm/dd */
 8012a1a:	68fb      	ldr	r3, [r7, #12]
 8012a1c:	2b05      	cmp	r3, #5
 8012a1e:	d117      	bne.n	8012a50 <OsStrToTm+0x8c>
        if (str[2] == ':') { /* 2:Index of Eigenvalues */
 8012a20:	687b      	ldr	r3, [r7, #4]
 8012a22:	3302      	adds	r3, #2
 8012a24:	781b      	ldrb	r3, [r3, #0]
 8012a26:	2b3a      	cmp	r3, #58	; 0x3a
 8012a28:	d106      	bne.n	8012a38 <OsStrToTm+0x74>
            ret = strptime(str, "%H:%M", tm);
 8012a2a:	683a      	ldr	r2, [r7, #0]
 8012a2c:	4941      	ldr	r1, [pc, #260]	; (8012b34 <OsStrToTm+0x170>)
 8012a2e:	6878      	ldr	r0, [r7, #4]
 8012a30:	f007 fc08 	bl	801a244 <strptime>
 8012a34:	60b8      	str	r0, [r7, #8]
 8012a36:	e019      	b.n	8012a6c <OsStrToTm+0xa8>
        } else if (str[2] == '/') { /* 2:Index of Eigenvalues */
 8012a38:	687b      	ldr	r3, [r7, #4]
 8012a3a:	3302      	adds	r3, #2
 8012a3c:	781b      	ldrb	r3, [r3, #0]
 8012a3e:	2b2f      	cmp	r3, #47	; 0x2f
 8012a40:	d114      	bne.n	8012a6c <OsStrToTm+0xa8>
            ret = strptime(str, "%m/%d", tm);
 8012a42:	683a      	ldr	r2, [r7, #0]
 8012a44:	493c      	ldr	r1, [pc, #240]	; (8012b38 <OsStrToTm+0x174>)
 8012a46:	6878      	ldr	r0, [r7, #4]
 8012a48:	f007 fbfc 	bl	801a244 <strptime>
 8012a4c:	60b8      	str	r0, [r7, #8]
 8012a4e:	e00d      	b.n	8012a6c <OsStrToTm+0xa8>
        }
    } else if (strLen == 7) { /* 7:Time format string length,such as yyyy/mm */
 8012a50:	68fb      	ldr	r3, [r7, #12]
 8012a52:	2b07      	cmp	r3, #7
 8012a54:	d10a      	bne.n	8012a6c <OsStrToTm+0xa8>
        if (str[4] == '/') { /* 4:Index of Eigenvalues */
 8012a56:	687b      	ldr	r3, [r7, #4]
 8012a58:	3304      	adds	r3, #4
 8012a5a:	781b      	ldrb	r3, [r3, #0]
 8012a5c:	2b2f      	cmp	r3, #47	; 0x2f
 8012a5e:	d105      	bne.n	8012a6c <OsStrToTm+0xa8>
            ret = strptime(str, "%Y/%m", tm);
 8012a60:	683a      	ldr	r2, [r7, #0]
 8012a62:	4936      	ldr	r1, [pc, #216]	; (8012b3c <OsStrToTm+0x178>)
 8012a64:	6878      	ldr	r0, [r7, #4]
 8012a66:	f007 fbed 	bl	801a244 <strptime>
 8012a6a:	60b8      	str	r0, [r7, #8]
        }
    }

    if (tm->tm_year < 70) { /* 70:the year is starting in 1970,tm_year must be greater than 70 */
 8012a6c:	683b      	ldr	r3, [r7, #0]
 8012a6e:	695b      	ldr	r3, [r3, #20]
 8012a70:	2b45      	cmp	r3, #69	; 0x45
 8012a72:	dc05      	bgt.n	8012a80 <OsStrToTm+0xbc>
        PRINTK("\nUsage: date -s set system time range from 1970.\n");
 8012a74:	4832      	ldr	r0, [pc, #200]	; (8012b40 <OsStrToTm+0x17c>)
 8012a76:	f7f1 ff23 	bl	80048c0 <dprintf>
        return DATE_ERR;
 8012a7a:	f04f 33ff 	mov.w	r3, #4294967295
 8012a7e:	e04e      	b.n	8012b1e <OsStrToTm+0x15a>
    }

    if (tm->tm_mday > g_monLengths[(INT32)LEAPYEAR(tm->tm_year + DATE_BASE_YEAR)][tm->tm_mon]) {
 8012a80:	683b      	ldr	r3, [r7, #0]
 8012a82:	68d9      	ldr	r1, [r3, #12]
 8012a84:	683b      	ldr	r3, [r7, #0]
 8012a86:	695b      	ldr	r3, [r3, #20]
 8012a88:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 8012a8c:	f003 0303 	and.w	r3, r3, #3
 8012a90:	2b00      	cmp	r3, #0
 8012a92:	d122      	bne.n	8012ada <OsStrToTm+0x116>
 8012a94:	683b      	ldr	r3, [r7, #0]
 8012a96:	695b      	ldr	r3, [r3, #20]
 8012a98:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 8012a9c:	4b29      	ldr	r3, [pc, #164]	; (8012b44 <OsStrToTm+0x180>)
 8012a9e:	fb83 0302 	smull	r0, r3, r3, r2
 8012aa2:	1158      	asrs	r0, r3, #5
 8012aa4:	17d3      	asrs	r3, r2, #31
 8012aa6:	1ac3      	subs	r3, r0, r3
 8012aa8:	2064      	movs	r0, #100	; 0x64
 8012aaa:	fb00 f303 	mul.w	r3, r0, r3
 8012aae:	1ad3      	subs	r3, r2, r3
 8012ab0:	2b00      	cmp	r3, #0
 8012ab2:	d110      	bne.n	8012ad6 <OsStrToTm+0x112>
 8012ab4:	683b      	ldr	r3, [r7, #0]
 8012ab6:	695b      	ldr	r3, [r3, #20]
 8012ab8:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 8012abc:	4b21      	ldr	r3, [pc, #132]	; (8012b44 <OsStrToTm+0x180>)
 8012abe:	fb83 0302 	smull	r0, r3, r3, r2
 8012ac2:	11d8      	asrs	r0, r3, #7
 8012ac4:	17d3      	asrs	r3, r2, #31
 8012ac6:	1ac3      	subs	r3, r0, r3
 8012ac8:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8012acc:	fb00 f303 	mul.w	r3, r0, r3
 8012ad0:	1ad3      	subs	r3, r2, r3
 8012ad2:	2b00      	cmp	r3, #0
 8012ad4:	d101      	bne.n	8012ada <OsStrToTm+0x116>
 8012ad6:	2201      	movs	r2, #1
 8012ad8:	e000      	b.n	8012adc <OsStrToTm+0x118>
 8012ada:	2200      	movs	r2, #0
 8012adc:	683b      	ldr	r3, [r7, #0]
 8012ade:	6918      	ldr	r0, [r3, #16]
 8012ae0:	4c19      	ldr	r4, [pc, #100]	; (8012b48 <OsStrToTm+0x184>)
 8012ae2:	4613      	mov	r3, r2
 8012ae4:	005b      	lsls	r3, r3, #1
 8012ae6:	4413      	add	r3, r2
 8012ae8:	009b      	lsls	r3, r3, #2
 8012aea:	4403      	add	r3, r0
 8012aec:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8012af0:	4299      	cmp	r1, r3
 8012af2:	dd02      	ble.n	8012afa <OsStrToTm+0x136>
        return DATE_ERR;
 8012af4:	f04f 33ff 	mov.w	r3, #4294967295
 8012af8:	e011      	b.n	8012b1e <OsStrToTm+0x15a>
    }

    if ((tm->tm_sec < 0) || (tm->tm_sec > 59)) { /* Seconds (0-59), leap seconds shall not be used when set time. */
 8012afa:	683b      	ldr	r3, [r7, #0]
 8012afc:	681b      	ldr	r3, [r3, #0]
 8012afe:	2b00      	cmp	r3, #0
 8012b00:	db03      	blt.n	8012b0a <OsStrToTm+0x146>
 8012b02:	683b      	ldr	r3, [r7, #0]
 8012b04:	681b      	ldr	r3, [r3, #0]
 8012b06:	2b3b      	cmp	r3, #59	; 0x3b
 8012b08:	dd02      	ble.n	8012b10 <OsStrToTm+0x14c>
        return DATE_ERR;
 8012b0a:	f04f 33ff 	mov.w	r3, #4294967295
 8012b0e:	e006      	b.n	8012b1e <OsStrToTm+0x15a>
    }
    return (ret == NULL) ? DATE_ERR : DATE_OK;
 8012b10:	68bb      	ldr	r3, [r7, #8]
 8012b12:	2b00      	cmp	r3, #0
 8012b14:	d102      	bne.n	8012b1c <OsStrToTm+0x158>
 8012b16:	f04f 33ff 	mov.w	r3, #4294967295
 8012b1a:	e000      	b.n	8012b1e <OsStrToTm+0x15a>
 8012b1c:	2300      	movs	r3, #0
}
 8012b1e:	4618      	mov	r0, r3
 8012b20:	3714      	adds	r7, #20
 8012b22:	46bd      	mov	sp, r7
 8012b24:	bd90      	pop	{r4, r7, pc}
 8012b26:	bf00      	nop
 8012b28:	08022528 	.word	0x08022528
 8012b2c:	08022534 	.word	0x08022534
 8012b30:	0802253c 	.word	0x0802253c
 8012b34:	08022548 	.word	0x08022548
 8012b38:	08022550 	.word	0x08022550
 8012b3c:	08022558 	.word	0x08022558
 8012b40:	08022560 	.word	0x08022560
 8012b44:	51eb851f 	.word	0x51eb851f
 8012b48:	08023560 	.word	0x08023560

08012b4c <OsFormatPrintTime>:

STATIC INT32 OsFormatPrintTime(const CHAR *formatStr)
{
 8012b4c:	b590      	push	{r4, r7, lr}
 8012b4e:	b0cf      	sub	sp, #316	; 0x13c
 8012b50:	af00      	add	r7, sp, #0
 8012b52:	1d3b      	adds	r3, r7, #4
 8012b54:	6018      	str	r0, [r3, #0]
 8012b56:	4b37      	ldr	r3, [pc, #220]	; (8012c34 <OsFormatPrintTime+0xe8>)
 8012b58:	681b      	ldr	r3, [r3, #0]
 8012b5a:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
 8012b5e:	f04f 0300 	mov.w	r3, #0
    CHAR timebuf[SHOW_MAX_LEN] = {0};
 8012b62:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8012b66:	2200      	movs	r2, #0
 8012b68:	601a      	str	r2, [r3, #0]
 8012b6a:	3304      	adds	r3, #4
 8012b6c:	f44f 7286 	mov.w	r2, #268	; 0x10c
 8012b70:	2100      	movs	r1, #0
 8012b72:	4618      	mov	r0, r3
 8012b74:	f7fc fbc8 	bl	800f308 <memset>
    struct tm *tm = NULL;
 8012b78:	f107 030c 	add.w	r3, r7, #12
 8012b7c:	2200      	movs	r2, #0
 8012b7e:	601a      	str	r2, [r3, #0]
    struct timeval64 nowTime = {0};
 8012b80:	f107 0310 	add.w	r3, r7, #16
 8012b84:	461a      	mov	r2, r3
 8012b86:	2300      	movs	r3, #0
 8012b88:	6013      	str	r3, [r2, #0]
 8012b8a:	6053      	str	r3, [r2, #4]
 8012b8c:	6093      	str	r3, [r2, #8]
 8012b8e:	60d3      	str	r3, [r2, #12]

    if (strlen(formatStr) < 2) { /* 2:check format string length */
 8012b90:	1d3b      	adds	r3, r7, #4
 8012b92:	6818      	ldr	r0, [r3, #0]
 8012b94:	f7fc fcdb 	bl	800f54e <strlen>
 8012b98:	4603      	mov	r3, r0
 8012b9a:	2b01      	cmp	r3, #1
 8012b9c:	d805      	bhi.n	8012baa <OsFormatPrintTime+0x5e>
        OsCmdUsageDate(DATE_ERR_INFO);
 8012b9e:	2001      	movs	r0, #1
 8012ba0:	f7ff fe2e 	bl	8012800 <OsCmdUsageDate>
        return DATE_ERR;
 8012ba4:	f04f 33ff 	mov.w	r3, #4294967295
 8012ba8:	e037      	b.n	8012c1a <OsFormatPrintTime+0xce>
    }

    if (gettimeofday64(&nowTime, NULL)) {
 8012baa:	f107 0310 	add.w	r3, r7, #16
 8012bae:	2100      	movs	r1, #0
 8012bb0:	4618      	mov	r0, r3
 8012bb2:	f00a ff77 	bl	801daa4 <gettimeofday64>
 8012bb6:	4603      	mov	r3, r0
 8012bb8:	2b00      	cmp	r3, #0
 8012bba:	d002      	beq.n	8012bc2 <OsFormatPrintTime+0x76>
        return DATE_ERR;
 8012bbc:	f04f 33ff 	mov.w	r3, #4294967295
 8012bc0:	e02b      	b.n	8012c1a <OsFormatPrintTime+0xce>
    }
    tm = localtime64(&nowTime.tv_sec);
 8012bc2:	f107 040c 	add.w	r4, r7, #12
 8012bc6:	f107 0310 	add.w	r3, r7, #16
 8012bca:	4618      	mov	r0, r3
 8012bcc:	f00b f81e 	bl	801dc0c <localtime64>
 8012bd0:	6020      	str	r0, [r4, #0]
    if (tm == NULL) {
 8012bd2:	f107 030c 	add.w	r3, r7, #12
 8012bd6:	681b      	ldr	r3, [r3, #0]
 8012bd8:	2b00      	cmp	r3, #0
 8012bda:	d102      	bne.n	8012be2 <OsFormatPrintTime+0x96>
        return DATE_ERR;
 8012bdc:	f04f 33ff 	mov.w	r3, #4294967295
 8012be0:	e01b      	b.n	8012c1a <OsFormatPrintTime+0xce>
    }

    if (strftime(timebuf, SHOW_MAX_LEN - 1, formatStr + 1, tm)) {
 8012be2:	1d3b      	adds	r3, r7, #4
 8012be4:	681b      	ldr	r3, [r3, #0]
 8012be6:	1c5a      	adds	r2, r3, #1
 8012be8:	f107 030c 	add.w	r3, r7, #12
 8012bec:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8012bf0:	681b      	ldr	r3, [r3, #0]
 8012bf2:	f240 110f 	movw	r1, #271	; 0x10f
 8012bf6:	f007 fafd 	bl	801a1f4 <strftime>
 8012bfa:	4603      	mov	r3, r0
 8012bfc:	2b00      	cmp	r3, #0
 8012bfe:	d007      	beq.n	8012c10 <OsFormatPrintTime+0xc4>
        PRINTK("%s\n", timebuf);
 8012c00:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8012c04:	4619      	mov	r1, r3
 8012c06:	480c      	ldr	r0, [pc, #48]	; (8012c38 <OsFormatPrintTime+0xec>)
 8012c08:	f7f1 fe5a 	bl	80048c0 <dprintf>
    } else {
        OsCmdUsageDate(DATE_ERR_INFO);
        return DATE_ERR;
    }
    return DATE_OK;
 8012c0c:	2300      	movs	r3, #0
 8012c0e:	e004      	b.n	8012c1a <OsFormatPrintTime+0xce>
        OsCmdUsageDate(DATE_ERR_INFO);
 8012c10:	2001      	movs	r0, #1
 8012c12:	f7ff fdf5 	bl	8012800 <OsCmdUsageDate>
        return DATE_ERR;
 8012c16:	f04f 33ff 	mov.w	r3, #4294967295
}
 8012c1a:	4a06      	ldr	r2, [pc, #24]	; (8012c34 <OsFormatPrintTime+0xe8>)
 8012c1c:	6811      	ldr	r1, [r2, #0]
 8012c1e:	f8d7 2134 	ldr.w	r2, [r7, #308]	; 0x134
 8012c22:	4051      	eors	r1, r2
 8012c24:	d001      	beq.n	8012c2a <OsFormatPrintTime+0xde>
 8012c26:	f7f1 fcd9 	bl	80045dc <__stack_chk_fail>
 8012c2a:	4618      	mov	r0, r3
 8012c2c:	f507 779e 	add.w	r7, r7, #316	; 0x13c
 8012c30:	46bd      	mov	sp, r7
 8012c32:	bd90      	pop	{r4, r7, pc}
 8012c34:	08022598 	.word	0x08022598
 8012c38:	08022594 	.word	0x08022594

08012c3c <OsDateSetTime>:

STATIC INT32 OsDateSetTime(const CHAR *timeStr)
{
 8012c3c:	b580      	push	{r7, lr}
 8012c3e:	b096      	sub	sp, #88	; 0x58
 8012c40:	af00      	add	r7, sp, #0
 8012c42:	6078      	str	r0, [r7, #4]
 8012c44:	4b3c      	ldr	r3, [pc, #240]	; (8012d38 <OsDateSetTime+0xfc>)
 8012c46:	681b      	ldr	r3, [r3, #0]
 8012c48:	657b      	str	r3, [r7, #84]	; 0x54
 8012c4a:	f04f 0300 	mov.w	r3, #0
    struct tm tm = {0};
 8012c4e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8012c52:	222c      	movs	r2, #44	; 0x2c
 8012c54:	2100      	movs	r1, #0
 8012c56:	4618      	mov	r0, r3
 8012c58:	f7fc fb56 	bl	800f308 <memset>
    struct timeval64 nowTime = {0};
 8012c5c:	f107 0308 	add.w	r3, r7, #8
 8012c60:	2200      	movs	r2, #0
 8012c62:	601a      	str	r2, [r3, #0]
 8012c64:	605a      	str	r2, [r3, #4]
 8012c66:	609a      	str	r2, [r3, #8]
 8012c68:	60da      	str	r2, [r3, #12]
    struct timeval64 setTime = {0};
 8012c6a:	f107 0318 	add.w	r3, r7, #24
 8012c6e:	2200      	movs	r2, #0
 8012c70:	601a      	str	r2, [r3, #0]
 8012c72:	605a      	str	r2, [r3, #4]
 8012c74:	609a      	str	r2, [r3, #8]
 8012c76:	60da      	str	r2, [r3, #12]

    if (gettimeofday64(&nowTime, NULL)) {
 8012c78:	f107 0308 	add.w	r3, r7, #8
 8012c7c:	2100      	movs	r1, #0
 8012c7e:	4618      	mov	r0, r3
 8012c80:	f00a ff10 	bl	801daa4 <gettimeofday64>
 8012c84:	4603      	mov	r3, r0
 8012c86:	2b00      	cmp	r3, #0
 8012c88:	d005      	beq.n	8012c96 <OsDateSetTime+0x5a>
        PRINTK("settime failed...\n");
 8012c8a:	482c      	ldr	r0, [pc, #176]	; (8012d3c <OsDateSetTime+0x100>)
 8012c8c:	f7f1 fe18 	bl	80048c0 <dprintf>
        return DATE_ERR;
 8012c90:	f04f 33ff 	mov.w	r3, #4294967295
 8012c94:	e045      	b.n	8012d22 <OsDateSetTime+0xe6>
    }

    setTime.tv_usec = nowTime.tv_usec;
 8012c96:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8012c9a:	e9c7 2308 	strd	r2, r3, [r7, #32]
    OsCopyTm(&tm, localtime64(&nowTime.tv_sec));
 8012c9e:	f107 0308 	add.w	r3, r7, #8
 8012ca2:	4618      	mov	r0, r3
 8012ca4:	f00a ffb2 	bl	801dc0c <localtime64>
 8012ca8:	4602      	mov	r2, r0
 8012caa:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8012cae:	4611      	mov	r1, r2
 8012cb0:	4618      	mov	r0, r3
 8012cb2:	f7ff fd65 	bl	8012780 <OsCopyTm>

    if (OsStrToTm(timeStr, &tm)) {
 8012cb6:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8012cba:	4619      	mov	r1, r3
 8012cbc:	6878      	ldr	r0, [r7, #4]
 8012cbe:	f7ff fe81 	bl	80129c4 <OsStrToTm>
 8012cc2:	4603      	mov	r3, r0
 8012cc4:	2b00      	cmp	r3, #0
 8012cc6:	d005      	beq.n	8012cd4 <OsDateSetTime+0x98>
        OsCmdUsageDate(DATE_ERR_INFO);
 8012cc8:	2001      	movs	r0, #1
 8012cca:	f7ff fd99 	bl	8012800 <OsCmdUsageDate>
        return DATE_ERR;
 8012cce:	f04f 33ff 	mov.w	r3, #4294967295
 8012cd2:	e026      	b.n	8012d22 <OsDateSetTime+0xe6>
    }

    setTime.tv_sec = mktime64(&tm);
 8012cd4:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8012cd8:	4618      	mov	r0, r3
 8012cda:	f00a fff1 	bl	801dcc0 <mktime64>
 8012cde:	4602      	mov	r2, r0
 8012ce0:	460b      	mov	r3, r1
 8012ce2:	e9c7 2306 	strd	r2, r3, [r7, #24]
    if (setTime.tv_sec == -1) {
 8012ce6:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8012cea:	f1b3 3fff 	cmp.w	r3, #4294967295
 8012cee:	bf08      	it	eq
 8012cf0:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 8012cf4:	d105      	bne.n	8012d02 <OsDateSetTime+0xc6>
        PRINTK("mktime failed...\n");
 8012cf6:	4812      	ldr	r0, [pc, #72]	; (8012d40 <OsDateSetTime+0x104>)
 8012cf8:	f7f1 fde2 	bl	80048c0 <dprintf>
        return DATE_ERR;
 8012cfc:	f04f 33ff 	mov.w	r3, #4294967295
 8012d00:	e00f      	b.n	8012d22 <OsDateSetTime+0xe6>
    }

    if (settimeofday64(&setTime, NULL)) {
 8012d02:	f107 0318 	add.w	r3, r7, #24
 8012d06:	2100      	movs	r1, #0
 8012d08:	4618      	mov	r0, r3
 8012d0a:	f00a fdf1 	bl	801d8f0 <settimeofday64>
 8012d0e:	4603      	mov	r3, r0
 8012d10:	2b00      	cmp	r3, #0
 8012d12:	d005      	beq.n	8012d20 <OsDateSetTime+0xe4>
        PRINTK("settime failed...\n");
 8012d14:	4809      	ldr	r0, [pc, #36]	; (8012d3c <OsDateSetTime+0x100>)
 8012d16:	f7f1 fdd3 	bl	80048c0 <dprintf>
        return DATE_ERR;
 8012d1a:	f04f 33ff 	mov.w	r3, #4294967295
 8012d1e:	e000      	b.n	8012d22 <OsDateSetTime+0xe6>
    }

    return DATE_OK;
 8012d20:	2300      	movs	r3, #0
}
 8012d22:	4a05      	ldr	r2, [pc, #20]	; (8012d38 <OsDateSetTime+0xfc>)
 8012d24:	6811      	ldr	r1, [r2, #0]
 8012d26:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8012d28:	4051      	eors	r1, r2
 8012d2a:	d001      	beq.n	8012d30 <OsDateSetTime+0xf4>
 8012d2c:	f7f1 fc56 	bl	80045dc <__stack_chk_fail>
 8012d30:	4618      	mov	r0, r3
 8012d32:	3758      	adds	r7, #88	; 0x58
 8012d34:	46bd      	mov	sp, r7
 8012d36:	bd80      	pop	{r7, pc}
 8012d38:	080225c4 	.word	0x080225c4
 8012d3c:	0802259c 	.word	0x0802259c
 8012d40:	080225b0 	.word	0x080225b0

08012d44 <OsShellCmdDate>:
    return DATE_OK;
}
#endif

INT32 OsShellCmdDate(INT32 argc, const CHAR **argv)
{
 8012d44:	b580      	push	{r7, lr}
 8012d46:	b088      	sub	sp, #32
 8012d48:	af00      	add	r7, sp, #0
 8012d4a:	6078      	str	r0, [r7, #4]
 8012d4c:	6039      	str	r1, [r7, #0]
 8012d4e:	4b38      	ldr	r3, [pc, #224]	; (8012e30 <OsShellCmdDate+0xec>)
 8012d50:	681b      	ldr	r3, [r3, #0]
 8012d52:	61fb      	str	r3, [r7, #28]
 8012d54:	f04f 0300 	mov.w	r3, #0
    struct timeval64 nowTime = {0};
 8012d58:	f107 0308 	add.w	r3, r7, #8
 8012d5c:	2200      	movs	r2, #0
 8012d5e:	601a      	str	r2, [r3, #0]
 8012d60:	605a      	str	r2, [r3, #4]
 8012d62:	609a      	str	r2, [r3, #8]
 8012d64:	60da      	str	r2, [r3, #12]

    if (argc == 1) { /* 1:count of parameters */
 8012d66:	687b      	ldr	r3, [r7, #4]
 8012d68:	2b01      	cmp	r3, #1
 8012d6a:	d117      	bne.n	8012d9c <OsShellCmdDate+0x58>
        if (gettimeofday64(&nowTime, NULL)) {
 8012d6c:	f107 0308 	add.w	r3, r7, #8
 8012d70:	2100      	movs	r1, #0
 8012d72:	4618      	mov	r0, r3
 8012d74:	f00a fe96 	bl	801daa4 <gettimeofday64>
 8012d78:	4603      	mov	r3, r0
 8012d7a:	2b00      	cmp	r3, #0
 8012d7c:	d002      	beq.n	8012d84 <OsShellCmdDate+0x40>
            return DATE_ERR;
 8012d7e:	f04f 33ff 	mov.w	r3, #4294967295
 8012d82:	e049      	b.n	8012e18 <OsShellCmdDate+0xd4>
        }
        PRINTK("%s\n", ctime64(&nowTime.tv_sec));
 8012d84:	f107 0308 	add.w	r3, r7, #8
 8012d88:	4618      	mov	r0, r3
 8012d8a:	f00a ff83 	bl	801dc94 <ctime64>
 8012d8e:	4603      	mov	r3, r0
 8012d90:	4619      	mov	r1, r3
 8012d92:	4828      	ldr	r0, [pc, #160]	; (8012e34 <OsShellCmdDate+0xf0>)
 8012d94:	f7f1 fd94 	bl	80048c0 <dprintf>
        return DATE_OK;
 8012d98:	2300      	movs	r3, #0
 8012d9a:	e03d      	b.n	8012e18 <OsShellCmdDate+0xd4>
    }

    if (argc == 2) { /* 2:count of parameters */
 8012d9c:	687b      	ldr	r3, [r7, #4]
 8012d9e:	2b02      	cmp	r3, #2
 8012da0:	d121      	bne.n	8012de6 <OsShellCmdDate+0xa2>
        if (!(strcmp(argv[1], "--help"))) {
 8012da2:	683b      	ldr	r3, [r7, #0]
 8012da4:	3304      	adds	r3, #4
 8012da6:	681b      	ldr	r3, [r3, #0]
 8012da8:	4923      	ldr	r1, [pc, #140]	; (8012e38 <OsShellCmdDate+0xf4>)
 8012daa:	4618      	mov	r0, r3
 8012dac:	f7fc fbad 	bl	800f50a <strcmp>
 8012db0:	4603      	mov	r3, r0
 8012db2:	2b00      	cmp	r3, #0
 8012db4:	d104      	bne.n	8012dc0 <OsShellCmdDate+0x7c>
            OsCmdUsageDate(DATE_HELP_INFO);
 8012db6:	2000      	movs	r0, #0
 8012db8:	f7ff fd22 	bl	8012800 <OsCmdUsageDate>
            return DATE_OK;
 8012dbc:	2300      	movs	r3, #0
 8012dbe:	e02b      	b.n	8012e18 <OsShellCmdDate+0xd4>
        }
        if (!(strncmp(argv[1], "+", 1))) {
 8012dc0:	683b      	ldr	r3, [r7, #0]
 8012dc2:	3304      	adds	r3, #4
 8012dc4:	681b      	ldr	r3, [r3, #0]
 8012dc6:	2201      	movs	r2, #1
 8012dc8:	491c      	ldr	r1, [pc, #112]	; (8012e3c <OsShellCmdDate+0xf8>)
 8012dca:	4618      	mov	r0, r3
 8012dcc:	f006 fc42 	bl	8019654 <strncmp>
 8012dd0:	4603      	mov	r3, r0
 8012dd2:	2b00      	cmp	r3, #0
 8012dd4:	d107      	bne.n	8012de6 <OsShellCmdDate+0xa2>
            return OsFormatPrintTime(argv[1]);
 8012dd6:	683b      	ldr	r3, [r7, #0]
 8012dd8:	3304      	adds	r3, #4
 8012dda:	681b      	ldr	r3, [r3, #0]
 8012ddc:	4618      	mov	r0, r3
 8012dde:	f7ff feb5 	bl	8012b4c <OsFormatPrintTime>
 8012de2:	4603      	mov	r3, r0
 8012de4:	e018      	b.n	8012e18 <OsShellCmdDate+0xd4>
        }
    }

    if (argc > 2) { /* 2:count of parameters */
 8012de6:	687b      	ldr	r3, [r7, #4]
 8012de8:	2b02      	cmp	r3, #2
 8012dea:	dd11      	ble.n	8012e10 <OsShellCmdDate+0xcc>
        if (!(strcmp(argv[1], "-s"))) {
 8012dec:	683b      	ldr	r3, [r7, #0]
 8012dee:	3304      	adds	r3, #4
 8012df0:	681b      	ldr	r3, [r3, #0]
 8012df2:	4913      	ldr	r1, [pc, #76]	; (8012e40 <OsShellCmdDate+0xfc>)
 8012df4:	4618      	mov	r0, r3
 8012df6:	f7fc fb88 	bl	800f50a <strcmp>
 8012dfa:	4603      	mov	r3, r0
 8012dfc:	2b00      	cmp	r3, #0
 8012dfe:	d107      	bne.n	8012e10 <OsShellCmdDate+0xcc>
            return OsDateSetTime(argv[2]); /* 2:index of parameters */
 8012e00:	683b      	ldr	r3, [r7, #0]
 8012e02:	3308      	adds	r3, #8
 8012e04:	681b      	ldr	r3, [r3, #0]
 8012e06:	4618      	mov	r0, r3
 8012e08:	f7ff ff18 	bl	8012c3c <OsDateSetTime>
 8012e0c:	4603      	mov	r3, r0
 8012e0e:	e003      	b.n	8012e18 <OsShellCmdDate+0xd4>
            return OsViewFileTime(argv[2]); /* 2:index of parameters */
        }
#endif
    }

    OsCmdUsageDate(DATE_ERR_INFO);
 8012e10:	2001      	movs	r0, #1
 8012e12:	f7ff fcf5 	bl	8012800 <OsCmdUsageDate>
    return DATE_OK;
 8012e16:	2300      	movs	r3, #0
}
 8012e18:	4a05      	ldr	r2, [pc, #20]	; (8012e30 <OsShellCmdDate+0xec>)
 8012e1a:	6811      	ldr	r1, [r2, #0]
 8012e1c:	69fa      	ldr	r2, [r7, #28]
 8012e1e:	4051      	eors	r1, r2
 8012e20:	d001      	beq.n	8012e26 <OsShellCmdDate+0xe2>
 8012e22:	f7f1 fbdb 	bl	80045dc <__stack_chk_fail>
 8012e26:	4618      	mov	r0, r3
 8012e28:	3720      	adds	r7, #32
 8012e2a:	46bd      	mov	sp, r7
 8012e2c:	bd80      	pop	{r7, pc}
 8012e2e:	bf00      	nop
 8012e30:	080225d8 	.word	0x080225d8
 8012e34:	08022594 	.word	0x08022594
 8012e38:	080225c8 	.word	0x080225c8
 8012e3c:	080225d0 	.word	0x080225d0
 8012e40:	080225d4 	.word	0x080225d4

08012e44 <PrintTime>:
#define WATCH_COUNT_MAX 0xFFFFFF
#define WATCH_INTETVAL_MAX 0xFFFFFF
#define WATCH_EVENT_MASK 0x01U

STATIC VOID PrintTime(VOID)
{
 8012e44:	b580      	push	{r7, lr}
 8012e46:	b086      	sub	sp, #24
 8012e48:	af00      	add	r7, sp, #0
 8012e4a:	4b13      	ldr	r3, [pc, #76]	; (8012e98 <PrintTime+0x54>)
 8012e4c:	681b      	ldr	r3, [r3, #0]
 8012e4e:	617b      	str	r3, [r7, #20]
 8012e50:	f04f 0300 	mov.w	r3, #0
    struct timeval64 nowTime = {0};
 8012e54:	463b      	mov	r3, r7
 8012e56:	2200      	movs	r2, #0
 8012e58:	601a      	str	r2, [r3, #0]
 8012e5a:	605a      	str	r2, [r3, #4]
 8012e5c:	609a      	str	r2, [r3, #8]
 8012e5e:	60da      	str	r2, [r3, #12]

    if (gettimeofday64(&nowTime, NULL) == 0) {
 8012e60:	463b      	mov	r3, r7
 8012e62:	2100      	movs	r1, #0
 8012e64:	4618      	mov	r0, r3
 8012e66:	f00a fe1d 	bl	801daa4 <gettimeofday64>
 8012e6a:	4603      	mov	r3, r0
 8012e6c:	2b00      	cmp	r3, #0
 8012e6e:	d108      	bne.n	8012e82 <PrintTime+0x3e>
        PRINTK("%s", ctime64(&nowTime.tv_sec));
 8012e70:	463b      	mov	r3, r7
 8012e72:	4618      	mov	r0, r3
 8012e74:	f00a ff0e 	bl	801dc94 <ctime64>
 8012e78:	4603      	mov	r3, r0
 8012e7a:	4619      	mov	r1, r3
 8012e7c:	4807      	ldr	r0, [pc, #28]	; (8012e9c <PrintTime+0x58>)
 8012e7e:	f7f1 fd1f 	bl	80048c0 <dprintf>
    }
}
 8012e82:	bf00      	nop
 8012e84:	4b04      	ldr	r3, [pc, #16]	; (8012e98 <PrintTime+0x54>)
 8012e86:	681a      	ldr	r2, [r3, #0]
 8012e88:	697b      	ldr	r3, [r7, #20]
 8012e8a:	405a      	eors	r2, r3
 8012e8c:	d001      	beq.n	8012e92 <PrintTime+0x4e>
 8012e8e:	f7f1 fba5 	bl	80045dc <__stack_chk_fail>
 8012e92:	3718      	adds	r7, #24
 8012e94:	46bd      	mov	sp, r7
 8012e96:	bd80      	pop	{r7, pc}
 8012e98:	080225e8 	.word	0x080225e8
 8012e9c:	080225e4 	.word	0x080225e4

08012ea0 <OsShellCmdDoWatch>:

STATIC VOID OsShellCmdDoWatch(VOID *arg1)
{
 8012ea0:	b580      	push	{r7, lr}
 8012ea2:	b084      	sub	sp, #16
 8012ea4:	af00      	add	r7, sp, #0
 8012ea6:	6078      	str	r0, [r7, #4]
    WatchCB *watchItem = (WatchCB *)arg1;
 8012ea8:	687b      	ldr	r3, [r7, #4]
 8012eaa:	60bb      	str	r3, [r7, #8]
    UINT32 ret;
    g_watchCmd = watchItem;
 8012eac:	4a1d      	ldr	r2, [pc, #116]	; (8012f24 <OsShellCmdDoWatch+0x84>)
 8012eae:	68bb      	ldr	r3, [r7, #8]
 8012eb0:	6013      	str	r3, [r2, #0]

    while (watchItem->count--) {
 8012eb2:	e01a      	b.n	8012eea <OsShellCmdDoWatch+0x4a>
        PRINTK("\033[2J\n");
 8012eb4:	481c      	ldr	r0, [pc, #112]	; (8012f28 <OsShellCmdDoWatch+0x88>)
 8012eb6:	f7f1 fd03 	bl	80048c0 <dprintf>
        if (watchItem->title) {
 8012eba:	68bb      	ldr	r3, [r7, #8]
 8012ebc:	681b      	ldr	r3, [r3, #0]
 8012ebe:	2b00      	cmp	r3, #0
 8012ec0:	d001      	beq.n	8012ec6 <OsShellCmdDoWatch+0x26>
            PrintTime();
 8012ec2:	f7ff ffbf 	bl	8012e44 <PrintTime>
        }
        (VOID)ShellMsgParse(watchItem->cmdBuf);
 8012ec6:	68bb      	ldr	r3, [r7, #8]
 8012ec8:	3318      	adds	r3, #24
 8012eca:	4618      	mov	r0, r3
 8012ecc:	f000 fe5a 	bl	8013b84 <ShellMsgParse>
        ret = LOS_EventRead(&watchItem->watchEvent, WATCH_EVENT_MASK,
 8012ed0:	68bb      	ldr	r3, [r7, #8]
 8012ed2:	f103 000c 	add.w	r0, r3, #12
 8012ed6:	68bb      	ldr	r3, [r7, #8]
 8012ed8:	689b      	ldr	r3, [r3, #8]
 8012eda:	2203      	movs	r2, #3
 8012edc:	2101      	movs	r1, #1
 8012ede:	f7f2 f893 	bl	8005008 <LOS_EventRead>
 8012ee2:	60f8      	str	r0, [r7, #12]
                            LOS_WAITMODE_OR | LOS_WAITMODE_CLR, watchItem->interval);
        if (ret == WATCH_EVENT_MASK) {
 8012ee4:	68fb      	ldr	r3, [r7, #12]
 8012ee6:	2b01      	cmp	r3, #1
 8012ee8:	d007      	beq.n	8012efa <OsShellCmdDoWatch+0x5a>
    while (watchItem->count--) {
 8012eea:	68bb      	ldr	r3, [r7, #8]
 8012eec:	685b      	ldr	r3, [r3, #4]
 8012eee:	1e59      	subs	r1, r3, #1
 8012ef0:	68ba      	ldr	r2, [r7, #8]
 8012ef2:	6051      	str	r1, [r2, #4]
 8012ef4:	2b00      	cmp	r3, #0
 8012ef6:	d1dd      	bne.n	8012eb4 <OsShellCmdDoWatch+0x14>
 8012ef8:	e000      	b.n	8012efc <OsShellCmdDoWatch+0x5c>
            break;
 8012efa:	bf00      	nop
        }
    }

    (VOID)LOS_EventDestroy(&watchItem->watchEvent);
 8012efc:	68bb      	ldr	r3, [r7, #8]
 8012efe:	330c      	adds	r3, #12
 8012f00:	4618      	mov	r0, r3
 8012f02:	f7f2 f8a5 	bl	8005050 <LOS_EventDestroy>
    free(g_watchCmd);
 8012f06:	4b07      	ldr	r3, [pc, #28]	; (8012f24 <OsShellCmdDoWatch+0x84>)
 8012f08:	681b      	ldr	r3, [r3, #0]
 8012f0a:	4618      	mov	r0, r3
 8012f0c:	f007 fd78 	bl	801aa00 <free>
    g_watchCmd = NULL;
 8012f10:	4b04      	ldr	r3, [pc, #16]	; (8012f24 <OsShellCmdDoWatch+0x84>)
 8012f12:	2200      	movs	r2, #0
 8012f14:	601a      	str	r2, [r3, #0]
    PRINTK("\nHuawei LiteOS # ");
 8012f16:	4805      	ldr	r0, [pc, #20]	; (8012f2c <OsShellCmdDoWatch+0x8c>)
 8012f18:	f7f1 fcd2 	bl	80048c0 <dprintf>
}
 8012f1c:	bf00      	nop
 8012f1e:	3710      	adds	r7, #16
 8012f20:	46bd      	mov	sp, r7
 8012f22:	bd80      	pop	{r7, pc}
 8012f24:	200032cc 	.word	0x200032cc
 8012f28:	080225ec 	.word	0x080225ec
 8012f2c:	080225f4 	.word	0x080225f4

08012f30 <OsWatchCmdUsage>:

STATIC INLINE VOID OsWatchCmdUsage(VOID)
{
 8012f30:	b580      	push	{r7, lr}
 8012f32:	af00      	add	r7, sp, #0
    PRINTK("\nUsage: watch\n");
 8012f34:	4803      	ldr	r0, [pc, #12]	; (8012f44 <OsWatchCmdUsage+0x14>)
 8012f36:	f7f1 fcc3 	bl	80048c0 <dprintf>
    PRINTK("watch [options] command\n");
 8012f3a:	4803      	ldr	r0, [pc, #12]	; (8012f48 <OsWatchCmdUsage+0x18>)
 8012f3c:	f7f1 fcc0 	bl	80048c0 <dprintf>
}
 8012f40:	bf00      	nop
 8012f42:	bd80      	pop	{r7, pc}
 8012f44:	08022608 	.word	0x08022608
 8012f48:	08022618 	.word	0x08022618

08012f4c <OsWatchOverFunc>:

STATIC UINT32 OsWatchOverFunc(VOID)
{
 8012f4c:	b580      	push	{r7, lr}
 8012f4e:	b082      	sub	sp, #8
 8012f50:	af00      	add	r7, sp, #0
    UINT32 ret;
    if (g_watchCmd != NULL) {
 8012f52:	4b12      	ldr	r3, [pc, #72]	; (8012f9c <OsWatchOverFunc+0x50>)
 8012f54:	681b      	ldr	r3, [r3, #0]
 8012f56:	2b00      	cmp	r3, #0
 8012f58:	d017      	beq.n	8012f8a <OsWatchOverFunc+0x3e>
        ret = LOS_EventWrite(&g_watchCmd->watchEvent, WATCH_EVENT_MASK);
 8012f5a:	4b10      	ldr	r3, [pc, #64]	; (8012f9c <OsWatchOverFunc+0x50>)
 8012f5c:	681b      	ldr	r3, [r3, #0]
 8012f5e:	330c      	adds	r3, #12
 8012f60:	2101      	movs	r1, #1
 8012f62:	4618      	mov	r0, r3
 8012f64:	f7f2 f864 	bl	8005030 <LOS_EventWrite>
 8012f68:	6078      	str	r0, [r7, #4]
        if (ret != LOS_OK) {
 8012f6a:	687b      	ldr	r3, [r7, #4]
 8012f6c:	2b00      	cmp	r3, #0
 8012f6e:	d00a      	beq.n	8012f86 <OsWatchOverFunc+0x3a>
            PRINT_ERR("Write event failed in %s,%d\n", __FUNCTION__, __LINE__);
 8012f70:	480b      	ldr	r0, [pc, #44]	; (8012fa0 <OsWatchOverFunc+0x54>)
 8012f72:	f7f1 fca5 	bl	80048c0 <dprintf>
 8012f76:	2268      	movs	r2, #104	; 0x68
 8012f78:	490a      	ldr	r1, [pc, #40]	; (8012fa4 <OsWatchOverFunc+0x58>)
 8012f7a:	480b      	ldr	r0, [pc, #44]	; (8012fa8 <OsWatchOverFunc+0x5c>)
 8012f7c:	f7f1 fca0 	bl	80048c0 <dprintf>
            return OS_ERROR;
 8012f80:	f04f 33ff 	mov.w	r3, #4294967295
 8012f84:	e006      	b.n	8012f94 <OsWatchOverFunc+0x48>
        }
        return LOS_OK;
 8012f86:	2300      	movs	r3, #0
 8012f88:	e004      	b.n	8012f94 <OsWatchOverFunc+0x48>
    } else {
        PRINTK("No watch task to turn off.\n");
 8012f8a:	4808      	ldr	r0, [pc, #32]	; (8012fac <OsWatchOverFunc+0x60>)
 8012f8c:	f7f1 fc98 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8012f90:	f04f 33ff 	mov.w	r3, #4294967295
    }
}
 8012f94:	4618      	mov	r0, r3
 8012f96:	3708      	adds	r7, #8
 8012f98:	46bd      	mov	sp, r7
 8012f9a:	bd80      	pop	{r7, pc}
 8012f9c:	200032cc 	.word	0x200032cc
 8012fa0:	08022634 	.word	0x08022634
 8012fa4:	080235c0 	.word	0x080235c0
 8012fa8:	0802263c 	.word	0x0802263c
 8012fac:	0802265c 	.word	0x0802265c

08012fb0 <OsWatchOptionParsed>:

STATIC INT32 OsWatchOptionParsed(UINT32 argc, UINT32 *argoff, const CHAR **argv, WatchCB *watchItem)
{
 8012fb0:	b5b0      	push	{r4, r5, r7, lr}
 8012fb2:	b088      	sub	sp, #32
 8012fb4:	af00      	add	r7, sp, #0
 8012fb6:	60f8      	str	r0, [r7, #12]
 8012fb8:	60b9      	str	r1, [r7, #8]
 8012fba:	607a      	str	r2, [r7, #4]
 8012fbc:	603b      	str	r3, [r7, #0]
 8012fbe:	4b86      	ldr	r3, [pc, #536]	; (80131d8 <OsWatchOptionParsed+0x228>)
 8012fc0:	681b      	ldr	r3, [r3, #0]
 8012fc2:	61fb      	str	r3, [r7, #28]
 8012fc4:	f04f 0300 	mov.w	r3, #0
    size_t tmpVal;
    CHAR *strPtr = NULL;
 8012fc8:	2300      	movs	r3, #0
 8012fca:	613b      	str	r3, [r7, #16]
    UINT32 argCount = argc;
 8012fcc:	68fb      	ldr	r3, [r7, #12]
 8012fce:	617b      	str	r3, [r7, #20]

    while (argv[*argoff][0] == '-') {
 8012fd0:	e0eb      	b.n	80131aa <OsWatchOptionParsed+0x1fa>
        if (argCount <= 1) {
 8012fd2:	697b      	ldr	r3, [r7, #20]
 8012fd4:	2b01      	cmp	r3, #1
 8012fd6:	d804      	bhi.n	8012fe2 <OsWatchOptionParsed+0x32>
            OsWatchCmdUsage();
 8012fd8:	f7ff ffaa 	bl	8012f30 <OsWatchCmdUsage>
            return -1;
 8012fdc:	f04f 33ff 	mov.w	r3, #4294967295
 8012fe0:	e0ee      	b.n	80131c0 <OsWatchOptionParsed+0x210>
        }

        if ((strcmp(argv[*argoff], "-n") == 0) || (strcmp(argv[*argoff], "--interval") == 0)) {
 8012fe2:	68bb      	ldr	r3, [r7, #8]
 8012fe4:	681b      	ldr	r3, [r3, #0]
 8012fe6:	009b      	lsls	r3, r3, #2
 8012fe8:	687a      	ldr	r2, [r7, #4]
 8012fea:	4413      	add	r3, r2
 8012fec:	681b      	ldr	r3, [r3, #0]
 8012fee:	497b      	ldr	r1, [pc, #492]	; (80131dc <OsWatchOptionParsed+0x22c>)
 8012ff0:	4618      	mov	r0, r3
 8012ff2:	f7fc fa8a 	bl	800f50a <strcmp>
 8012ff6:	4603      	mov	r3, r0
 8012ff8:	2b00      	cmp	r3, #0
 8012ffa:	d00c      	beq.n	8013016 <OsWatchOptionParsed+0x66>
 8012ffc:	68bb      	ldr	r3, [r7, #8]
 8012ffe:	681b      	ldr	r3, [r3, #0]
 8013000:	009b      	lsls	r3, r3, #2
 8013002:	687a      	ldr	r2, [r7, #4]
 8013004:	4413      	add	r3, r2
 8013006:	681b      	ldr	r3, [r3, #0]
 8013008:	4975      	ldr	r1, [pc, #468]	; (80131e0 <OsWatchOptionParsed+0x230>)
 801300a:	4618      	mov	r0, r3
 801300c:	f7fc fa7d 	bl	800f50a <strcmp>
 8013010:	4603      	mov	r3, r0
 8013012:	2b00      	cmp	r3, #0
 8013014:	d14e      	bne.n	80130b4 <OsWatchOptionParsed+0x104>
            if (argCount <= 2) { /* 2:count of parameter */
 8013016:	697b      	ldr	r3, [r7, #20]
 8013018:	2b02      	cmp	r3, #2
 801301a:	d804      	bhi.n	8013026 <OsWatchOptionParsed+0x76>
                OsWatchCmdUsage();
 801301c:	f7ff ff88 	bl	8012f30 <OsWatchCmdUsage>
                return -1;
 8013020:	f04f 33ff 	mov.w	r3, #4294967295
 8013024:	e0cc      	b.n	80131c0 <OsWatchOptionParsed+0x210>
            }
            tmpVal = strtoul(argv[*argoff + 1], &strPtr, 0);
 8013026:	68bb      	ldr	r3, [r7, #8]
 8013028:	681b      	ldr	r3, [r3, #0]
 801302a:	3301      	adds	r3, #1
 801302c:	009b      	lsls	r3, r3, #2
 801302e:	687a      	ldr	r2, [r7, #4]
 8013030:	4413      	add	r3, r2
 8013032:	681b      	ldr	r3, [r3, #0]
 8013034:	f107 0110 	add.w	r1, r7, #16
 8013038:	2200      	movs	r2, #0
 801303a:	4618      	mov	r0, r3
 801303c:	f7fc fb0a 	bl	800f654 <strtoul>
 8013040:	61b8      	str	r0, [r7, #24]
            if ((*strPtr != 0) || (tmpVal == 0) || (tmpVal > WATCH_INTETVAL_MAX) ||
 8013042:	693b      	ldr	r3, [r7, #16]
 8013044:	781b      	ldrb	r3, [r3, #0]
 8013046:	2b00      	cmp	r3, #0
 8013048:	d11c      	bne.n	8013084 <OsWatchOptionParsed+0xd4>
 801304a:	69bb      	ldr	r3, [r7, #24]
 801304c:	2b00      	cmp	r3, #0
 801304e:	d019      	beq.n	8013084 <OsWatchOptionParsed+0xd4>
 8013050:	69bb      	ldr	r3, [r7, #24]
 8013052:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8013056:	d215      	bcs.n	8013084 <OsWatchOptionParsed+0xd4>
                ((UINT64)g_tickPerSecond * tmpVal > UINT32_MAX)) {
 8013058:	4b62      	ldr	r3, [pc, #392]	; (80131e4 <OsWatchOptionParsed+0x234>)
 801305a:	681b      	ldr	r3, [r3, #0]
 801305c:	4618      	mov	r0, r3
 801305e:	f04f 0100 	mov.w	r1, #0
 8013062:	69bb      	ldr	r3, [r7, #24]
 8013064:	461a      	mov	r2, r3
 8013066:	f04f 0300 	mov.w	r3, #0
 801306a:	fb02 f501 	mul.w	r5, r2, r1
 801306e:	fb00 f403 	mul.w	r4, r0, r3
 8013072:	442c      	add	r4, r5
 8013074:	fba0 2302 	umull	r2, r3, r0, r2
 8013078:	18e1      	adds	r1, r4, r3
 801307a:	460b      	mov	r3, r1
            if ((*strPtr != 0) || (tmpVal == 0) || (tmpVal > WATCH_INTETVAL_MAX) ||
 801307c:	2b01      	cmp	r3, #1
 801307e:	bf08      	it	eq
 8013080:	2a00      	cmpeq	r2, #0
 8013082:	d307      	bcc.n	8013094 <OsWatchOptionParsed+0xe4>
                PRINTK("\ninterval time is invalid\n");
 8013084:	4858      	ldr	r0, [pc, #352]	; (80131e8 <OsWatchOptionParsed+0x238>)
 8013086:	f7f1 fc1b 	bl	80048c0 <dprintf>
                OsWatchCmdUsage();
 801308a:	f7ff ff51 	bl	8012f30 <OsWatchCmdUsage>
                return -1;
 801308e:	f04f 33ff 	mov.w	r3, #4294967295
 8013092:	e095      	b.n	80131c0 <OsWatchOptionParsed+0x210>
            }

            watchItem->interval = g_tickPerSecond * (UINT32)tmpVal;
 8013094:	4b53      	ldr	r3, [pc, #332]	; (80131e4 <OsWatchOptionParsed+0x234>)
 8013096:	681b      	ldr	r3, [r3, #0]
 8013098:	69ba      	ldr	r2, [r7, #24]
 801309a:	fb02 f203 	mul.w	r2, r2, r3
 801309e:	683b      	ldr	r3, [r7, #0]
 80130a0:	609a      	str	r2, [r3, #8]
            argCount -= 2; /* 2:offset of argv */
 80130a2:	697b      	ldr	r3, [r7, #20]
 80130a4:	3b02      	subs	r3, #2
 80130a6:	617b      	str	r3, [r7, #20]
            (*argoff) += 2; /* 2:offset of argv */
 80130a8:	68bb      	ldr	r3, [r7, #8]
 80130aa:	681b      	ldr	r3, [r3, #0]
 80130ac:	1c9a      	adds	r2, r3, #2
 80130ae:	68bb      	ldr	r3, [r7, #8]
 80130b0:	601a      	str	r2, [r3, #0]
 80130b2:	e07a      	b.n	80131aa <OsWatchOptionParsed+0x1fa>
        } else if ((strcmp(argv[*argoff], "-t") == 0) || (strcmp(argv[*argoff], "-no-title") == 0)) {
 80130b4:	68bb      	ldr	r3, [r7, #8]
 80130b6:	681b      	ldr	r3, [r3, #0]
 80130b8:	009b      	lsls	r3, r3, #2
 80130ba:	687a      	ldr	r2, [r7, #4]
 80130bc:	4413      	add	r3, r2
 80130be:	681b      	ldr	r3, [r3, #0]
 80130c0:	494a      	ldr	r1, [pc, #296]	; (80131ec <OsWatchOptionParsed+0x23c>)
 80130c2:	4618      	mov	r0, r3
 80130c4:	f7fc fa21 	bl	800f50a <strcmp>
 80130c8:	4603      	mov	r3, r0
 80130ca:	2b00      	cmp	r3, #0
 80130cc:	d00c      	beq.n	80130e8 <OsWatchOptionParsed+0x138>
 80130ce:	68bb      	ldr	r3, [r7, #8]
 80130d0:	681b      	ldr	r3, [r3, #0]
 80130d2:	009b      	lsls	r3, r3, #2
 80130d4:	687a      	ldr	r2, [r7, #4]
 80130d6:	4413      	add	r3, r2
 80130d8:	681b      	ldr	r3, [r3, #0]
 80130da:	4945      	ldr	r1, [pc, #276]	; (80131f0 <OsWatchOptionParsed+0x240>)
 80130dc:	4618      	mov	r0, r3
 80130de:	f7fc fa14 	bl	800f50a <strcmp>
 80130e2:	4603      	mov	r3, r0
 80130e4:	2b00      	cmp	r3, #0
 80130e6:	d10b      	bne.n	8013100 <OsWatchOptionParsed+0x150>
            watchItem->title = FALSE;
 80130e8:	683b      	ldr	r3, [r7, #0]
 80130ea:	2200      	movs	r2, #0
 80130ec:	601a      	str	r2, [r3, #0]
            argCount--;
 80130ee:	697b      	ldr	r3, [r7, #20]
 80130f0:	3b01      	subs	r3, #1
 80130f2:	617b      	str	r3, [r7, #20]
            (*argoff)++;
 80130f4:	68bb      	ldr	r3, [r7, #8]
 80130f6:	681b      	ldr	r3, [r3, #0]
 80130f8:	1c5a      	adds	r2, r3, #1
 80130fa:	68bb      	ldr	r3, [r7, #8]
 80130fc:	601a      	str	r2, [r3, #0]
 80130fe:	e054      	b.n	80131aa <OsWatchOptionParsed+0x1fa>
        } else if ((strcmp(argv[*argoff], "-c") == 0) || (strcmp(argv[*argoff], "--count") == 0)) {
 8013100:	68bb      	ldr	r3, [r7, #8]
 8013102:	681b      	ldr	r3, [r3, #0]
 8013104:	009b      	lsls	r3, r3, #2
 8013106:	687a      	ldr	r2, [r7, #4]
 8013108:	4413      	add	r3, r2
 801310a:	681b      	ldr	r3, [r3, #0]
 801310c:	4939      	ldr	r1, [pc, #228]	; (80131f4 <OsWatchOptionParsed+0x244>)
 801310e:	4618      	mov	r0, r3
 8013110:	f7fc f9fb 	bl	800f50a <strcmp>
 8013114:	4603      	mov	r3, r0
 8013116:	2b00      	cmp	r3, #0
 8013118:	d00c      	beq.n	8013134 <OsWatchOptionParsed+0x184>
 801311a:	68bb      	ldr	r3, [r7, #8]
 801311c:	681b      	ldr	r3, [r3, #0]
 801311e:	009b      	lsls	r3, r3, #2
 8013120:	687a      	ldr	r2, [r7, #4]
 8013122:	4413      	add	r3, r2
 8013124:	681b      	ldr	r3, [r3, #0]
 8013126:	4934      	ldr	r1, [pc, #208]	; (80131f8 <OsWatchOptionParsed+0x248>)
 8013128:	4618      	mov	r0, r3
 801312a:	f7fc f9ee 	bl	800f50a <strcmp>
 801312e:	4603      	mov	r3, r0
 8013130:	2b00      	cmp	r3, #0
 8013132:	d134      	bne.n	801319e <OsWatchOptionParsed+0x1ee>
            if (argCount <= 2) { /* 2:count of parameter */
 8013134:	697b      	ldr	r3, [r7, #20]
 8013136:	2b02      	cmp	r3, #2
 8013138:	d804      	bhi.n	8013144 <OsWatchOptionParsed+0x194>
                OsWatchCmdUsage();
 801313a:	f7ff fef9 	bl	8012f30 <OsWatchCmdUsage>
                return -1;
 801313e:	f04f 33ff 	mov.w	r3, #4294967295
 8013142:	e03d      	b.n	80131c0 <OsWatchOptionParsed+0x210>
            }
            tmpVal = strtoul(argv[*argoff + 1], &strPtr, 0);
 8013144:	68bb      	ldr	r3, [r7, #8]
 8013146:	681b      	ldr	r3, [r3, #0]
 8013148:	3301      	adds	r3, #1
 801314a:	009b      	lsls	r3, r3, #2
 801314c:	687a      	ldr	r2, [r7, #4]
 801314e:	4413      	add	r3, r2
 8013150:	681b      	ldr	r3, [r3, #0]
 8013152:	f107 0110 	add.w	r1, r7, #16
 8013156:	2200      	movs	r2, #0
 8013158:	4618      	mov	r0, r3
 801315a:	f7fc fa7b 	bl	800f654 <strtoul>
 801315e:	61b8      	str	r0, [r7, #24]
            if ((*strPtr != 0) || (tmpVal == 0) || (tmpVal > WATCH_COUNT_MAX)) {
 8013160:	693b      	ldr	r3, [r7, #16]
 8013162:	781b      	ldrb	r3, [r3, #0]
 8013164:	2b00      	cmp	r3, #0
 8013166:	d106      	bne.n	8013176 <OsWatchOptionParsed+0x1c6>
 8013168:	69bb      	ldr	r3, [r7, #24]
 801316a:	2b00      	cmp	r3, #0
 801316c:	d003      	beq.n	8013176 <OsWatchOptionParsed+0x1c6>
 801316e:	69bb      	ldr	r3, [r7, #24]
 8013170:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8013174:	d307      	bcc.n	8013186 <OsWatchOptionParsed+0x1d6>
                PRINTK("\ncount is invalid\n");
 8013176:	4821      	ldr	r0, [pc, #132]	; (80131fc <OsWatchOptionParsed+0x24c>)
 8013178:	f7f1 fba2 	bl	80048c0 <dprintf>
                OsWatchCmdUsage();
 801317c:	f7ff fed8 	bl	8012f30 <OsWatchCmdUsage>
                return -1;
 8013180:	f04f 33ff 	mov.w	r3, #4294967295
 8013184:	e01c      	b.n	80131c0 <OsWatchOptionParsed+0x210>
            }
            watchItem->count = (UINT32)tmpVal;
 8013186:	683b      	ldr	r3, [r7, #0]
 8013188:	69ba      	ldr	r2, [r7, #24]
 801318a:	605a      	str	r2, [r3, #4]
            argCount -= 2; /* 2:offset of argv */
 801318c:	697b      	ldr	r3, [r7, #20]
 801318e:	3b02      	subs	r3, #2
 8013190:	617b      	str	r3, [r7, #20]
            (*argoff) += 2; /* 2:offset of argv */
 8013192:	68bb      	ldr	r3, [r7, #8]
 8013194:	681b      	ldr	r3, [r3, #0]
 8013196:	1c9a      	adds	r2, r3, #2
 8013198:	68bb      	ldr	r3, [r7, #8]
 801319a:	601a      	str	r2, [r3, #0]
 801319c:	e005      	b.n	80131aa <OsWatchOptionParsed+0x1fa>
        } else {
            PRINTK("Unknown option.\n");
 801319e:	4818      	ldr	r0, [pc, #96]	; (8013200 <OsWatchOptionParsed+0x250>)
 80131a0:	f7f1 fb8e 	bl	80048c0 <dprintf>
            return -1;
 80131a4:	f04f 33ff 	mov.w	r3, #4294967295
 80131a8:	e00a      	b.n	80131c0 <OsWatchOptionParsed+0x210>
    while (argv[*argoff][0] == '-') {
 80131aa:	68bb      	ldr	r3, [r7, #8]
 80131ac:	681b      	ldr	r3, [r3, #0]
 80131ae:	009b      	lsls	r3, r3, #2
 80131b0:	687a      	ldr	r2, [r7, #4]
 80131b2:	4413      	add	r3, r2
 80131b4:	681b      	ldr	r3, [r3, #0]
 80131b6:	781b      	ldrb	r3, [r3, #0]
 80131b8:	2b2d      	cmp	r3, #45	; 0x2d
 80131ba:	f43f af0a 	beq.w	8012fd2 <OsWatchOptionParsed+0x22>
        }
    }
    return 0;
 80131be:	2300      	movs	r3, #0
}
 80131c0:	4a05      	ldr	r2, [pc, #20]	; (80131d8 <OsWatchOptionParsed+0x228>)
 80131c2:	6811      	ldr	r1, [r2, #0]
 80131c4:	69fa      	ldr	r2, [r7, #28]
 80131c6:	4051      	eors	r1, r2
 80131c8:	d001      	beq.n	80131ce <OsWatchOptionParsed+0x21e>
 80131ca:	f7f1 fa07 	bl	80045dc <__stack_chk_fail>
 80131ce:	4618      	mov	r0, r3
 80131d0:	3720      	adds	r7, #32
 80131d2:	46bd      	mov	sp, r7
 80131d4:	bdb0      	pop	{r4, r5, r7, pc}
 80131d6:	bf00      	nop
 80131d8:	080226e8 	.word	0x080226e8
 80131dc:	08022678 	.word	0x08022678
 80131e0:	0802267c 	.word	0x0802267c
 80131e4:	200036e4 	.word	0x200036e4
 80131e8:	08022688 	.word	0x08022688
 80131ec:	080226a4 	.word	0x080226a4
 80131f0:	080226a8 	.word	0x080226a8
 80131f4:	080226b4 	.word	0x080226b4
 80131f8:	080226b8 	.word	0x080226b8
 80131fc:	080226c0 	.word	0x080226c0
 8013200:	080226d4 	.word	0x080226d4

08013204 <OsWatchCmdSplice>:

STATIC INT32 OsWatchCmdSplice(UINT32 argc, UINT32 argoff, const CHAR **argv, WatchCB *watchItem)
{
 8013204:	b580      	push	{r7, lr}
 8013206:	b086      	sub	sp, #24
 8013208:	af00      	add	r7, sp, #0
 801320a:	60f8      	str	r0, [r7, #12]
 801320c:	60b9      	str	r1, [r7, #8]
 801320e:	607a      	str	r2, [r7, #4]
 8013210:	603b      	str	r3, [r7, #0]
    INT32 err = 0;
 8013212:	2300      	movs	r3, #0
 8013214:	617b      	str	r3, [r7, #20]
    if ((argc - argoff) == 0) {
 8013216:	68fa      	ldr	r2, [r7, #12]
 8013218:	68bb      	ldr	r3, [r7, #8]
 801321a:	429a      	cmp	r2, r3
 801321c:	d13e      	bne.n	801329c <OsWatchCmdSplice+0x98>
        PRINT_ERR("no watch command!\n");
 801321e:	4824      	ldr	r0, [pc, #144]	; (80132b0 <OsWatchCmdSplice+0xac>)
 8013220:	f7f1 fb4e 	bl	80048c0 <dprintf>
 8013224:	4823      	ldr	r0, [pc, #140]	; (80132b4 <OsWatchCmdSplice+0xb0>)
 8013226:	f7f1 fb4b 	bl	80048c0 <dprintf>
        return -1;
 801322a:	f04f 33ff 	mov.w	r3, #4294967295
 801322e:	e03a      	b.n	80132a6 <OsWatchCmdSplice+0xa2>
    }
    while (argc - argoff) {
        err = strcat_s(watchItem->cmdBuf, sizeof(watchItem->cmdBuf), argv[argoff]);
 8013230:	683b      	ldr	r3, [r7, #0]
 8013232:	f103 0018 	add.w	r0, r3, #24
 8013236:	68bb      	ldr	r3, [r7, #8]
 8013238:	009b      	lsls	r3, r3, #2
 801323a:	687a      	ldr	r2, [r7, #4]
 801323c:	4413      	add	r3, r2
 801323e:	681b      	ldr	r3, [r3, #0]
 8013240:	461a      	mov	r2, r3
 8013242:	f44f 7188 	mov.w	r1, #272	; 0x110
 8013246:	f003 feb3 	bl	8016fb0 <strcat_s>
 801324a:	6178      	str	r0, [r7, #20]
        if (err != EOK) {
 801324c:	697b      	ldr	r3, [r7, #20]
 801324e:	2b00      	cmp	r3, #0
 8013250:	d00a      	beq.n	8013268 <OsWatchCmdSplice+0x64>
            PRINT_ERR("%s, %d strcat_s failed!\n", __FUNCTION__, __LINE__);
 8013252:	4817      	ldr	r0, [pc, #92]	; (80132b0 <OsWatchCmdSplice+0xac>)
 8013254:	f7f1 fb34 	bl	80048c0 <dprintf>
 8013258:	22b2      	movs	r2, #178	; 0xb2
 801325a:	4917      	ldr	r1, [pc, #92]	; (80132b8 <OsWatchCmdSplice+0xb4>)
 801325c:	4817      	ldr	r0, [pc, #92]	; (80132bc <OsWatchCmdSplice+0xb8>)
 801325e:	f7f1 fb2f 	bl	80048c0 <dprintf>
            return -1;
 8013262:	f04f 33ff 	mov.w	r3, #4294967295
 8013266:	e01e      	b.n	80132a6 <OsWatchCmdSplice+0xa2>
        }
        err = strcat_s(watchItem->cmdBuf, sizeof(watchItem->cmdBuf), " ");
 8013268:	683b      	ldr	r3, [r7, #0]
 801326a:	3318      	adds	r3, #24
 801326c:	4a14      	ldr	r2, [pc, #80]	; (80132c0 <OsWatchCmdSplice+0xbc>)
 801326e:	f44f 7188 	mov.w	r1, #272	; 0x110
 8013272:	4618      	mov	r0, r3
 8013274:	f003 fe9c 	bl	8016fb0 <strcat_s>
 8013278:	6178      	str	r0, [r7, #20]
        if (err != EOK) {
 801327a:	697b      	ldr	r3, [r7, #20]
 801327c:	2b00      	cmp	r3, #0
 801327e:	d00a      	beq.n	8013296 <OsWatchCmdSplice+0x92>
            PRINT_ERR("%s, %d strcat_s failed!\n", __FUNCTION__, __LINE__);
 8013280:	480b      	ldr	r0, [pc, #44]	; (80132b0 <OsWatchCmdSplice+0xac>)
 8013282:	f7f1 fb1d 	bl	80048c0 <dprintf>
 8013286:	22b7      	movs	r2, #183	; 0xb7
 8013288:	490b      	ldr	r1, [pc, #44]	; (80132b8 <OsWatchCmdSplice+0xb4>)
 801328a:	480c      	ldr	r0, [pc, #48]	; (80132bc <OsWatchCmdSplice+0xb8>)
 801328c:	f7f1 fb18 	bl	80048c0 <dprintf>
            return -1;
 8013290:	f04f 33ff 	mov.w	r3, #4294967295
 8013294:	e007      	b.n	80132a6 <OsWatchCmdSplice+0xa2>
        }
        argoff++;
 8013296:	68bb      	ldr	r3, [r7, #8]
 8013298:	3301      	adds	r3, #1
 801329a:	60bb      	str	r3, [r7, #8]
    while (argc - argoff) {
 801329c:	68fa      	ldr	r2, [r7, #12]
 801329e:	68bb      	ldr	r3, [r7, #8]
 80132a0:	429a      	cmp	r2, r3
 80132a2:	d1c5      	bne.n	8013230 <OsWatchCmdSplice+0x2c>
    }
    return err;
 80132a4:	697b      	ldr	r3, [r7, #20]
}
 80132a6:	4618      	mov	r0, r3
 80132a8:	3718      	adds	r7, #24
 80132aa:	46bd      	mov	sp, r7
 80132ac:	bd80      	pop	{r7, pc}
 80132ae:	bf00      	nop
 80132b0:	08022634 	.word	0x08022634
 80132b4:	080226ec 	.word	0x080226ec
 80132b8:	080235d0 	.word	0x080235d0
 80132bc:	08022700 	.word	0x08022700
 80132c0:	0802271c 	.word	0x0802271c

080132c4 <OsWatchTaskCreate>:

STATIC UINT32 OsWatchTaskCreate(WatchCB *watchItem)
{
 80132c4:	b580      	push	{r7, lr}
 80132c6:	b08e      	sub	sp, #56	; 0x38
 80132c8:	af00      	add	r7, sp, #0
 80132ca:	6078      	str	r0, [r7, #4]
 80132cc:	4b28      	ldr	r3, [pc, #160]	; (8013370 <OsWatchTaskCreate+0xac>)
 80132ce:	681b      	ldr	r3, [r3, #0]
 80132d0:	637b      	str	r3, [r7, #52]	; 0x34
 80132d2:	f04f 0300 	mov.w	r3, #0
    TSK_INIT_PARAM_S initParam = {0};
 80132d6:	f107 0310 	add.w	r3, r7, #16
 80132da:	2224      	movs	r2, #36	; 0x24
 80132dc:	2100      	movs	r1, #0
 80132de:	4618      	mov	r0, r3
 80132e0:	f7fc f812 	bl	800f308 <memset>
    UINT32 watchTaskId = 0;
 80132e4:	2300      	movs	r3, #0
 80132e6:	60bb      	str	r3, [r7, #8]
    UINT32 ret;

    ret = LOS_EventInit(&watchItem->watchEvent);
 80132e8:	687b      	ldr	r3, [r7, #4]
 80132ea:	330c      	adds	r3, #12
 80132ec:	4618      	mov	r0, r3
 80132ee:	f7f1 fbf7 	bl	8004ae0 <LOS_EventInit>
 80132f2:	60f8      	str	r0, [r7, #12]
    if (ret != 0) {
 80132f4:	68fb      	ldr	r3, [r7, #12]
 80132f6:	2b00      	cmp	r3, #0
 80132f8:	d009      	beq.n	801330e <OsWatchTaskCreate+0x4a>
        PRINT_ERR("Watch event init failed in %s, %d\n", __FUNCTION__, __LINE__);
 80132fa:	481e      	ldr	r0, [pc, #120]	; (8013374 <OsWatchTaskCreate+0xb0>)
 80132fc:	f7f1 fae0 	bl	80048c0 <dprintf>
 8013300:	22c7      	movs	r2, #199	; 0xc7
 8013302:	491d      	ldr	r1, [pc, #116]	; (8013378 <OsWatchTaskCreate+0xb4>)
 8013304:	481d      	ldr	r0, [pc, #116]	; (801337c <OsWatchTaskCreate+0xb8>)
 8013306:	f7f1 fadb 	bl	80048c0 <dprintf>
        return ret;
 801330a:	68fb      	ldr	r3, [r7, #12]
 801330c:	e024      	b.n	8013358 <OsWatchTaskCreate+0x94>
    }

    initParam.pfnTaskEntry = (TSK_ENTRY_FUNC)OsShellCmdDoWatch;
 801330e:	4b1c      	ldr	r3, [pc, #112]	; (8013380 <OsWatchTaskCreate+0xbc>)
 8013310:	613b      	str	r3, [r7, #16]
    initParam.usTaskPrio   = 10; /* 10:shellcmd_watch task priority */
 8013312:	230a      	movs	r3, #10
 8013314:	82bb      	strh	r3, [r7, #20]
    initParam.uwStackSize  = 0x3000; /* 0x3000:stack size of shellcmd_watch task */
 8013316:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 801331a:	62bb      	str	r3, [r7, #40]	; 0x28
    initParam.pcName       = "shellcmd_watch";
 801331c:	4b19      	ldr	r3, [pc, #100]	; (8013384 <OsWatchTaskCreate+0xc0>)
 801331e:	62fb      	str	r3, [r7, #44]	; 0x2c
    initParam.uwResved     = LOS_TASK_STATUS_DETACHED;
 8013320:	f44f 7380 	mov.w	r3, #256	; 0x100
 8013324:	633b      	str	r3, [r7, #48]	; 0x30
    LOS_TASK_PARAM_INIT_ARG(initParam, watchItem);
 8013326:	687b      	ldr	r3, [r7, #4]
 8013328:	61bb      	str	r3, [r7, #24]

    ret = LOS_TaskCreate(&watchTaskId, &initParam);
 801332a:	f107 0210 	add.w	r2, r7, #16
 801332e:	f107 0308 	add.w	r3, r7, #8
 8013332:	4611      	mov	r1, r2
 8013334:	4618      	mov	r0, r3
 8013336:	f7f0 fbf9 	bl	8003b2c <LOS_TaskCreate>
 801333a:	60f8      	str	r0, [r7, #12]
    if (ret != 0) {
 801333c:	68fb      	ldr	r3, [r7, #12]
 801333e:	2b00      	cmp	r3, #0
 8013340:	d009      	beq.n	8013356 <OsWatchTaskCreate+0x92>
        PRINT_ERR("Watch task init failed in %s, %d\n", __FUNCTION__, __LINE__);
 8013342:	480c      	ldr	r0, [pc, #48]	; (8013374 <OsWatchTaskCreate+0xb0>)
 8013344:	f7f1 fabc 	bl	80048c0 <dprintf>
 8013348:	22d4      	movs	r2, #212	; 0xd4
 801334a:	490b      	ldr	r1, [pc, #44]	; (8013378 <OsWatchTaskCreate+0xb4>)
 801334c:	480e      	ldr	r0, [pc, #56]	; (8013388 <OsWatchTaskCreate+0xc4>)
 801334e:	f7f1 fab7 	bl	80048c0 <dprintf>
        return ret;
 8013352:	68fb      	ldr	r3, [r7, #12]
 8013354:	e000      	b.n	8013358 <OsWatchTaskCreate+0x94>
    }
    return ret;
 8013356:	68fb      	ldr	r3, [r7, #12]
}
 8013358:	4a05      	ldr	r2, [pc, #20]	; (8013370 <OsWatchTaskCreate+0xac>)
 801335a:	6811      	ldr	r1, [r2, #0]
 801335c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801335e:	4051      	eors	r1, r2
 8013360:	d001      	beq.n	8013366 <OsWatchTaskCreate+0xa2>
 8013362:	f7f1 f93b 	bl	80045dc <__stack_chk_fail>
 8013366:	4618      	mov	r0, r3
 8013368:	3738      	adds	r7, #56	; 0x38
 801336a:	46bd      	mov	sp, r7
 801336c:	bd80      	pop	{r7, pc}
 801336e:	bf00      	nop
 8013370:	08022778 	.word	0x08022778
 8013374:	08022634 	.word	0x08022634
 8013378:	080235e4 	.word	0x080235e4
 801337c:	08022720 	.word	0x08022720
 8013380:	08012ea1 	.word	0x08012ea1
 8013384:	08022744 	.word	0x08022744
 8013388:	08022754 	.word	0x08022754

0801338c <OsShellCmdWatch>:

UINT32 OsShellCmdWatch(UINT32 argc, const CHAR **argv)
{
 801338c:	b580      	push	{r7, lr}
 801338e:	b088      	sub	sp, #32
 8013390:	af00      	add	r7, sp, #0
 8013392:	6078      	str	r0, [r7, #4]
 8013394:	6039      	str	r1, [r7, #0]
 8013396:	4b40      	ldr	r3, [pc, #256]	; (8013498 <OsShellCmdWatch+0x10c>)
 8013398:	681b      	ldr	r3, [r3, #0]
 801339a:	61fb      	str	r3, [r7, #28]
 801339c:	f04f 0300 	mov.w	r3, #0
    WatchCB *watchItem = NULL;
 80133a0:	2300      	movs	r3, #0
 80133a2:	613b      	str	r3, [r7, #16]
    UINT32 argoff = 0;
 80133a4:	2300      	movs	r3, #0
 80133a6:	60fb      	str	r3, [r7, #12]
    UINT32 ret;
    INT32 err;

    if (argc == 0) {
 80133a8:	687b      	ldr	r3, [r7, #4]
 80133aa:	2b00      	cmp	r3, #0
 80133ac:	d104      	bne.n	80133b8 <OsShellCmdWatch+0x2c>
        OsWatchCmdUsage();
 80133ae:	f7ff fdbf 	bl	8012f30 <OsWatchCmdUsage>
        return OS_ERROR;
 80133b2:	f04f 33ff 	mov.w	r3, #4294967295
 80133b6:	e063      	b.n	8013480 <OsShellCmdWatch+0xf4>
    }

    if ((argc == 1) && (strcmp(argv[0], "--over") == 0)) {
 80133b8:	687b      	ldr	r3, [r7, #4]
 80133ba:	2b01      	cmp	r3, #1
 80133bc:	d10d      	bne.n	80133da <OsShellCmdWatch+0x4e>
 80133be:	683b      	ldr	r3, [r7, #0]
 80133c0:	681b      	ldr	r3, [r3, #0]
 80133c2:	4936      	ldr	r1, [pc, #216]	; (801349c <OsShellCmdWatch+0x110>)
 80133c4:	4618      	mov	r0, r3
 80133c6:	f7fc f8a0 	bl	800f50a <strcmp>
 80133ca:	4603      	mov	r3, r0
 80133cc:	2b00      	cmp	r3, #0
 80133ce:	d104      	bne.n	80133da <OsShellCmdWatch+0x4e>
        ret = OsWatchOverFunc();
 80133d0:	f7ff fdbc 	bl	8012f4c <OsWatchOverFunc>
 80133d4:	6178      	str	r0, [r7, #20]
        return ret;
 80133d6:	697b      	ldr	r3, [r7, #20]
 80133d8:	e052      	b.n	8013480 <OsShellCmdWatch+0xf4>
    }

    if (g_watchCmd != NULL) {
 80133da:	4b31      	ldr	r3, [pc, #196]	; (80134a0 <OsShellCmdWatch+0x114>)
 80133dc:	681b      	ldr	r3, [r3, #0]
 80133de:	2b00      	cmp	r3, #0
 80133e0:	d005      	beq.n	80133ee <OsShellCmdWatch+0x62>
        PRINTK("Please turn off previous watch before to start a new watch.\n");
 80133e2:	4830      	ldr	r0, [pc, #192]	; (80134a4 <OsShellCmdWatch+0x118>)
 80133e4:	f7f1 fa6c 	bl	80048c0 <dprintf>
        return OS_ERROR;
 80133e8:	f04f 33ff 	mov.w	r3, #4294967295
 80133ec:	e048      	b.n	8013480 <OsShellCmdWatch+0xf4>
    }

    watchItem = (WatchCB *)malloc(sizeof(WatchCB));
 80133ee:	f44f 7094 	mov.w	r0, #296	; 0x128
 80133f2:	f007 fb19 	bl	801aa28 <malloc>
 80133f6:	6138      	str	r0, [r7, #16]
    if (watchItem == NULL) {
 80133f8:	693b      	ldr	r3, [r7, #16]
 80133fa:	2b00      	cmp	r3, #0
 80133fc:	d105      	bne.n	801340a <OsShellCmdWatch+0x7e>
        PRINTK("Malloc error!\n");
 80133fe:	482a      	ldr	r0, [pc, #168]	; (80134a8 <OsShellCmdWatch+0x11c>)
 8013400:	f7f1 fa5e 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8013404:	f04f 33ff 	mov.w	r3, #4294967295
 8013408:	e03a      	b.n	8013480 <OsShellCmdWatch+0xf4>
    }
    (VOID)memset_s(watchItem, sizeof(WatchCB), 0, sizeof(WatchCB));
 801340a:	f44f 7394 	mov.w	r3, #296	; 0x128
 801340e:	2200      	movs	r2, #0
 8013410:	f44f 7194 	mov.w	r1, #296	; 0x128
 8013414:	6938      	ldr	r0, [r7, #16]
 8013416:	f7ee fe45 	bl	80020a4 <memset_s>
    watchItem->title = TRUE;
 801341a:	693b      	ldr	r3, [r7, #16]
 801341c:	2201      	movs	r2, #1
 801341e:	601a      	str	r2, [r3, #0]
    watchItem->count = WATCH_COUNT_MAX;
 8013420:	693b      	ldr	r3, [r7, #16]
 8013422:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8013426:	605a      	str	r2, [r3, #4]
    watchItem->interval = g_tickPerSecond;
 8013428:	4b20      	ldr	r3, [pc, #128]	; (80134ac <OsShellCmdWatch+0x120>)
 801342a:	681a      	ldr	r2, [r3, #0]
 801342c:	693b      	ldr	r3, [r7, #16]
 801342e:	609a      	str	r2, [r3, #8]

    err = OsWatchOptionParsed(argc, &argoff, argv, watchItem);
 8013430:	f107 010c 	add.w	r1, r7, #12
 8013434:	693b      	ldr	r3, [r7, #16]
 8013436:	683a      	ldr	r2, [r7, #0]
 8013438:	6878      	ldr	r0, [r7, #4]
 801343a:	f7ff fdb9 	bl	8012fb0 <OsWatchOptionParsed>
 801343e:	61b8      	str	r0, [r7, #24]
    if (err != 0) {
 8013440:	69bb      	ldr	r3, [r7, #24]
 8013442:	2b00      	cmp	r3, #0
 8013444:	d112      	bne.n	801346c <OsShellCmdWatch+0xe0>
        goto WATCH_ERROR;
    }

    err = OsWatchCmdSplice(argc, argoff, argv, watchItem);
 8013446:	68f9      	ldr	r1, [r7, #12]
 8013448:	693b      	ldr	r3, [r7, #16]
 801344a:	683a      	ldr	r2, [r7, #0]
 801344c:	6878      	ldr	r0, [r7, #4]
 801344e:	f7ff fed9 	bl	8013204 <OsWatchCmdSplice>
 8013452:	61b8      	str	r0, [r7, #24]
    if (err != 0) {
 8013454:	69bb      	ldr	r3, [r7, #24]
 8013456:	2b00      	cmp	r3, #0
 8013458:	d10a      	bne.n	8013470 <OsShellCmdWatch+0xe4>
        goto WATCH_ERROR;
    }

    ret = OsWatchTaskCreate(watchItem);
 801345a:	6938      	ldr	r0, [r7, #16]
 801345c:	f7ff ff32 	bl	80132c4 <OsWatchTaskCreate>
 8013460:	6178      	str	r0, [r7, #20]
    if (ret != 0) {
 8013462:	697b      	ldr	r3, [r7, #20]
 8013464:	2b00      	cmp	r3, #0
 8013466:	d105      	bne.n	8013474 <OsShellCmdWatch+0xe8>
        goto WATCH_ERROR;
    }

    return LOS_OK;
 8013468:	2300      	movs	r3, #0
 801346a:	e009      	b.n	8013480 <OsShellCmdWatch+0xf4>
        goto WATCH_ERROR;
 801346c:	bf00      	nop
 801346e:	e002      	b.n	8013476 <OsShellCmdWatch+0xea>
        goto WATCH_ERROR;
 8013470:	bf00      	nop
 8013472:	e000      	b.n	8013476 <OsShellCmdWatch+0xea>
        goto WATCH_ERROR;
 8013474:	bf00      	nop

WATCH_ERROR:
    free(watchItem);
 8013476:	6938      	ldr	r0, [r7, #16]
 8013478:	f007 fac2 	bl	801aa00 <free>
    return OS_ERROR;
 801347c:	f04f 33ff 	mov.w	r3, #4294967295
}
 8013480:	4a05      	ldr	r2, [pc, #20]	; (8013498 <OsShellCmdWatch+0x10c>)
 8013482:	6811      	ldr	r1, [r2, #0]
 8013484:	69fa      	ldr	r2, [r7, #28]
 8013486:	4051      	eors	r1, r2
 8013488:	d001      	beq.n	801348e <OsShellCmdWatch+0x102>
 801348a:	f7f1 f8a7 	bl	80045dc <__stack_chk_fail>
 801348e:	4618      	mov	r0, r3
 8013490:	3720      	adds	r7, #32
 8013492:	46bd      	mov	sp, r7
 8013494:	bd80      	pop	{r7, pc}
 8013496:	bf00      	nop
 8013498:	080227d4 	.word	0x080227d4
 801349c:	0802277c 	.word	0x0802277c
 80134a0:	200032cc 	.word	0x200032cc
 80134a4:	08022784 	.word	0x08022784
 80134a8:	080227c4 	.word	0x080227c4
 80134ac:	200036e4 	.word	0x200036e4

080134b0 <LOS_ListAdd>:
{
 80134b0:	b480      	push	{r7}
 80134b2:	b083      	sub	sp, #12
 80134b4:	af00      	add	r7, sp, #0
 80134b6:	6078      	str	r0, [r7, #4]
 80134b8:	6039      	str	r1, [r7, #0]
    node->pstNext = list->pstNext;
 80134ba:	687b      	ldr	r3, [r7, #4]
 80134bc:	685a      	ldr	r2, [r3, #4]
 80134be:	683b      	ldr	r3, [r7, #0]
 80134c0:	605a      	str	r2, [r3, #4]
    node->pstPrev = list;
 80134c2:	683b      	ldr	r3, [r7, #0]
 80134c4:	687a      	ldr	r2, [r7, #4]
 80134c6:	601a      	str	r2, [r3, #0]
    list->pstNext->pstPrev = node;
 80134c8:	687b      	ldr	r3, [r7, #4]
 80134ca:	685b      	ldr	r3, [r3, #4]
 80134cc:	683a      	ldr	r2, [r7, #0]
 80134ce:	601a      	str	r2, [r3, #0]
    list->pstNext = node;
 80134d0:	687b      	ldr	r3, [r7, #4]
 80134d2:	683a      	ldr	r2, [r7, #0]
 80134d4:	605a      	str	r2, [r3, #4]
}
 80134d6:	bf00      	nop
 80134d8:	370c      	adds	r7, #12
 80134da:	46bd      	mov	sp, r7
 80134dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80134e0:	4770      	bx	lr

080134e2 <LOS_ListTailInsert>:
{
 80134e2:	b580      	push	{r7, lr}
 80134e4:	b082      	sub	sp, #8
 80134e6:	af00      	add	r7, sp, #0
 80134e8:	6078      	str	r0, [r7, #4]
 80134ea:	6039      	str	r1, [r7, #0]
    LOS_ListAdd(list->pstPrev, node);
 80134ec:	687b      	ldr	r3, [r7, #4]
 80134ee:	681b      	ldr	r3, [r3, #0]
 80134f0:	6839      	ldr	r1, [r7, #0]
 80134f2:	4618      	mov	r0, r3
 80134f4:	f7ff ffdc 	bl	80134b0 <LOS_ListAdd>
}
 80134f8:	bf00      	nop
 80134fa:	3708      	adds	r7, #8
 80134fc:	46bd      	mov	sp, r7
 80134fe:	bd80      	pop	{r7, pc}

08013500 <LOS_ListDelete>:
{
 8013500:	b480      	push	{r7}
 8013502:	b083      	sub	sp, #12
 8013504:	af00      	add	r7, sp, #0
 8013506:	6078      	str	r0, [r7, #4]
    node->pstNext->pstPrev = node->pstPrev;
 8013508:	687b      	ldr	r3, [r7, #4]
 801350a:	685b      	ldr	r3, [r3, #4]
 801350c:	687a      	ldr	r2, [r7, #4]
 801350e:	6812      	ldr	r2, [r2, #0]
 8013510:	601a      	str	r2, [r3, #0]
    node->pstPrev->pstNext = node->pstNext;
 8013512:	687b      	ldr	r3, [r7, #4]
 8013514:	681b      	ldr	r3, [r3, #0]
 8013516:	687a      	ldr	r2, [r7, #4]
 8013518:	6852      	ldr	r2, [r2, #4]
 801351a:	605a      	str	r2, [r3, #4]
    node->pstNext = NULL;
 801351c:	687b      	ldr	r3, [r7, #4]
 801351e:	2200      	movs	r2, #0
 8013520:	605a      	str	r2, [r3, #4]
    node->pstPrev = NULL;
 8013522:	687b      	ldr	r3, [r7, #4]
 8013524:	2200      	movs	r2, #0
 8013526:	601a      	str	r2, [r3, #0]
}
 8013528:	bf00      	nop
 801352a:	370c      	adds	r7, #12
 801352c:	46bd      	mov	sp, r7
 801352e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013532:	4770      	bx	lr

08013534 <LOS_ListEmpty>:
{
 8013534:	b480      	push	{r7}
 8013536:	b083      	sub	sp, #12
 8013538:	af00      	add	r7, sp, #0
 801353a:	6078      	str	r0, [r7, #4]
    return (BOOL)(list->pstNext == list);
 801353c:	687b      	ldr	r3, [r7, #4]
 801353e:	685b      	ldr	r3, [r3, #4]
 8013540:	687a      	ldr	r2, [r7, #4]
 8013542:	429a      	cmp	r2, r3
 8013544:	bf0c      	ite	eq
 8013546:	2301      	moveq	r3, #1
 8013548:	2300      	movne	r3, #0
 801354a:	b2db      	uxtb	r3, r3
}
 801354c:	4618      	mov	r0, r3
 801354e:	370c      	adds	r7, #12
 8013550:	46bd      	mov	sp, r7
 8013552:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013556:	4770      	bx	lr

08013558 <ShellGetInputBuf>:

#define SHELL_TASK_PRIORITY     9
#define SHELL_ENTRY_PRIORITY    9

CHAR *ShellGetInputBuf(ShellCB *shellCB)
{
 8013558:	b580      	push	{r7, lr}
 801355a:	b088      	sub	sp, #32
 801355c:	af00      	add	r7, sp, #0
 801355e:	6078      	str	r0, [r7, #4]
    CmdKeyLink *cmdKey = shellCB->cmdKeyLink;
 8013560:	687b      	ldr	r3, [r7, #4]
 8013562:	68db      	ldr	r3, [r3, #12]
 8013564:	60fb      	str	r3, [r7, #12]
    CmdKeyLink *cmdNode = NULL;
 8013566:	2300      	movs	r3, #0
 8013568:	613b      	str	r3, [r7, #16]

    KEY_LOCK(shellCB);
 801356a:	687b      	ldr	r3, [r7, #4]
 801356c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801356e:	f04f 31ff 	mov.w	r1, #4294967295
 8013572:	4618      	mov	r0, r3
 8013574:	f7f8 f9da 	bl	800b92c <LOS_MuxPend>
 8013578:	6178      	str	r0, [r7, #20]
 801357a:	697b      	ldr	r3, [r7, #20]
 801357c:	2b00      	cmp	r3, #0
 801357e:	d008      	beq.n	8013592 <ShellGetInputBuf+0x3a>
 8013580:	4824      	ldr	r0, [pc, #144]	; (8013614 <ShellGetInputBuf+0xbc>)
 8013582:	f7f1 f99d 	bl	80048c0 <dprintf>
 8013586:	697b      	ldr	r3, [r7, #20]
 8013588:	2248      	movs	r2, #72	; 0x48
 801358a:	4923      	ldr	r1, [pc, #140]	; (8013618 <ShellGetInputBuf+0xc0>)
 801358c:	4823      	ldr	r0, [pc, #140]	; (801361c <ShellGetInputBuf+0xc4>)
 801358e:	f7f1 f997 	bl	80048c0 <dprintf>
    if ((cmdKey == NULL) || LOS_ListEmpty(&cmdKey->list)) {
 8013592:	68fb      	ldr	r3, [r7, #12]
 8013594:	2b00      	cmp	r3, #0
 8013596:	d007      	beq.n	80135a8 <ShellGetInputBuf+0x50>
 8013598:	68fb      	ldr	r3, [r7, #12]
 801359a:	3304      	adds	r3, #4
 801359c:	4618      	mov	r0, r3
 801359e:	f7ff ffc9 	bl	8013534 <LOS_ListEmpty>
 80135a2:	4603      	mov	r3, r0
 80135a4:	2b00      	cmp	r3, #0
 80135a6:	d013      	beq.n	80135d0 <ShellGetInputBuf+0x78>
        KEY_UNLOCK(shellCB);
 80135a8:	687b      	ldr	r3, [r7, #4]
 80135aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80135ac:	4618      	mov	r0, r3
 80135ae:	f7f8 fb3d 	bl	800bc2c <LOS_MuxPost>
 80135b2:	61f8      	str	r0, [r7, #28]
 80135b4:	69fb      	ldr	r3, [r7, #28]
 80135b6:	2b00      	cmp	r3, #0
 80135b8:	d008      	beq.n	80135cc <ShellGetInputBuf+0x74>
 80135ba:	4816      	ldr	r0, [pc, #88]	; (8013614 <ShellGetInputBuf+0xbc>)
 80135bc:	f7f1 f980 	bl	80048c0 <dprintf>
 80135c0:	69fb      	ldr	r3, [r7, #28]
 80135c2:	224a      	movs	r2, #74	; 0x4a
 80135c4:	4914      	ldr	r1, [pc, #80]	; (8013618 <ShellGetInputBuf+0xc0>)
 80135c6:	4816      	ldr	r0, [pc, #88]	; (8013620 <ShellGetInputBuf+0xc8>)
 80135c8:	f7f1 f97a 	bl	80048c0 <dprintf>
        return NULL;
 80135cc:	2300      	movs	r3, #0
 80135ce:	e01c      	b.n	801360a <ShellGetInputBuf+0xb2>
    }

    cmdNode = LOS_DL_LIST_ENTRY(cmdKey->list.pstNext, CmdKeyLink, list);
 80135d0:	68fb      	ldr	r3, [r7, #12]
 80135d2:	689b      	ldr	r3, [r3, #8]
 80135d4:	3b04      	subs	r3, #4
 80135d6:	613b      	str	r3, [r7, #16]
    LOS_ListDelete(&(cmdNode->list));
 80135d8:	693b      	ldr	r3, [r7, #16]
 80135da:	3304      	adds	r3, #4
 80135dc:	4618      	mov	r0, r3
 80135de:	f7ff ff8f 	bl	8013500 <LOS_ListDelete>
    KEY_UNLOCK(shellCB);
 80135e2:	687b      	ldr	r3, [r7, #4]
 80135e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80135e6:	4618      	mov	r0, r3
 80135e8:	f7f8 fb20 	bl	800bc2c <LOS_MuxPost>
 80135ec:	61b8      	str	r0, [r7, #24]
 80135ee:	69bb      	ldr	r3, [r7, #24]
 80135f0:	2b00      	cmp	r3, #0
 80135f2:	d008      	beq.n	8013606 <ShellGetInputBuf+0xae>
 80135f4:	4807      	ldr	r0, [pc, #28]	; (8013614 <ShellGetInputBuf+0xbc>)
 80135f6:	f7f1 f963 	bl	80048c0 <dprintf>
 80135fa:	69bb      	ldr	r3, [r7, #24]
 80135fc:	2250      	movs	r2, #80	; 0x50
 80135fe:	4906      	ldr	r1, [pc, #24]	; (8013618 <ShellGetInputBuf+0xc0>)
 8013600:	4807      	ldr	r0, [pc, #28]	; (8013620 <ShellGetInputBuf+0xc8>)
 8013602:	f7f1 f95d 	bl	80048c0 <dprintf>

    return cmdNode->cmdString;
 8013606:	693b      	ldr	r3, [r7, #16]
 8013608:	330c      	adds	r3, #12
}
 801360a:	4618      	mov	r0, r3
 801360c:	3720      	adds	r7, #32
 801360e:	46bd      	mov	sp, r7
 8013610:	bd80      	pop	{r7, pc}
 8013612:	bf00      	nop
 8013614:	080227e0 	.word	0x080227e0
 8013618:	080235f8 	.word	0x080235f8
 801361c:	080227e8 	.word	0x080227e8
 8013620:	0802280c 	.word	0x0802280c

08013624 <ShellSaveHistoryCmd>:

STATIC VOID ShellSaveHistoryCmd(CHAR *string, ShellCB *shellCB)
{
 8013624:	b580      	push	{r7, lr}
 8013626:	b088      	sub	sp, #32
 8013628:	af00      	add	r7, sp, #0
 801362a:	6078      	str	r0, [r7, #4]
 801362c:	6039      	str	r1, [r7, #0]
    CmdKeyLink *cmdHistory = shellCB->cmdHistoryKeyLink;
 801362e:	683b      	ldr	r3, [r7, #0]
 8013630:	691b      	ldr	r3, [r3, #16]
 8013632:	60fb      	str	r3, [r7, #12]
    CmdKeyLink *cmdKey = LOS_DL_LIST_ENTRY(string, CmdKeyLink, cmdString);
 8013634:	687b      	ldr	r3, [r7, #4]
 8013636:	3b0c      	subs	r3, #12
 8013638:	613b      	str	r3, [r7, #16]
    CmdKeyLink *cmdNxt = NULL;
 801363a:	2300      	movs	r3, #0
 801363c:	617b      	str	r3, [r7, #20]

    if ((string == NULL) || (strlen(string) == 0)) {
 801363e:	687b      	ldr	r3, [r7, #4]
 8013640:	2b00      	cmp	r3, #0
 8013642:	d06d      	beq.n	8013720 <ShellSaveHistoryCmd+0xfc>
 8013644:	6878      	ldr	r0, [r7, #4]
 8013646:	f7fb ff82 	bl	800f54e <strlen>
 801364a:	4603      	mov	r3, r0
 801364c:	2b00      	cmp	r3, #0
 801364e:	d067      	beq.n	8013720 <ShellSaveHistoryCmd+0xfc>
        return;
    }

    HISTORY_LOCK(shellCB);
 8013650:	683b      	ldr	r3, [r7, #0]
 8013652:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013654:	f04f 31ff 	mov.w	r1, #4294967295
 8013658:	4618      	mov	r0, r3
 801365a:	f7f8 f967 	bl	800b92c <LOS_MuxPend>
 801365e:	61b8      	str	r0, [r7, #24]
 8013660:	69bb      	ldr	r3, [r7, #24]
 8013662:	2b00      	cmp	r3, #0
 8013664:	d008      	beq.n	8013678 <ShellSaveHistoryCmd+0x54>
 8013666:	4831      	ldr	r0, [pc, #196]	; (801372c <ShellSaveHistoryCmd+0x108>)
 8013668:	f7f1 f92a 	bl	80048c0 <dprintf>
 801366c:	69bb      	ldr	r3, [r7, #24]
 801366e:	225f      	movs	r2, #95	; 0x5f
 8013670:	492f      	ldr	r1, [pc, #188]	; (8013730 <ShellSaveHistoryCmd+0x10c>)
 8013672:	4830      	ldr	r0, [pc, #192]	; (8013734 <ShellSaveHistoryCmd+0x110>)
 8013674:	f7f1 f924 	bl	80048c0 <dprintf>

    if (cmdHistory->count != 0) {
 8013678:	68fb      	ldr	r3, [r7, #12]
 801367a:	681b      	ldr	r3, [r3, #0]
 801367c:	2b00      	cmp	r3, #0
 801367e:	d013      	beq.n	80136a8 <ShellSaveHistoryCmd+0x84>
        cmdNxt = LOS_DL_LIST_ENTRY(cmdHistory->list.pstPrev, CmdKeyLink, list);
 8013680:	68fb      	ldr	r3, [r7, #12]
 8013682:	685b      	ldr	r3, [r3, #4]
 8013684:	3b04      	subs	r3, #4
 8013686:	617b      	str	r3, [r7, #20]
        if (strcmp(string, cmdNxt->cmdString) == 0) {
 8013688:	697b      	ldr	r3, [r7, #20]
 801368a:	330c      	adds	r3, #12
 801368c:	4619      	mov	r1, r3
 801368e:	6878      	ldr	r0, [r7, #4]
 8013690:	f7fb ff3b 	bl	800f50a <strcmp>
 8013694:	4603      	mov	r3, r0
 8013696:	2b00      	cmp	r3, #0
 8013698:	d106      	bne.n	80136a8 <ShellSaveHistoryCmd+0x84>
            (VOID)LOS_MemFree(m_aucSysMem0, (VOID *)cmdKey);
 801369a:	4b27      	ldr	r3, [pc, #156]	; (8013738 <ShellSaveHistoryCmd+0x114>)
 801369c:	681b      	ldr	r3, [r3, #0]
 801369e:	6939      	ldr	r1, [r7, #16]
 80136a0:	4618      	mov	r0, r3
 80136a2:	f7f5 ff6f 	bl	8009584 <LOS_MemFree>
            goto END;
 80136a6:	e028      	b.n	80136fa <ShellSaveHistoryCmd+0xd6>
        }
    }

    if (cmdHistory->count == CMD_HISTORY_LEN) {
 80136a8:	68fb      	ldr	r3, [r7, #12]
 80136aa:	681b      	ldr	r3, [r3, #0]
 80136ac:	2b0a      	cmp	r3, #10
 80136ae:	d117      	bne.n	80136e0 <ShellSaveHistoryCmd+0xbc>
        cmdNxt = LOS_DL_LIST_ENTRY(cmdHistory->list.pstNext, CmdKeyLink, list);
 80136b0:	68fb      	ldr	r3, [r7, #12]
 80136b2:	689b      	ldr	r3, [r3, #8]
 80136b4:	3b04      	subs	r3, #4
 80136b6:	617b      	str	r3, [r7, #20]
        LOS_ListDelete(&cmdNxt->list);
 80136b8:	697b      	ldr	r3, [r7, #20]
 80136ba:	3304      	adds	r3, #4
 80136bc:	4618      	mov	r0, r3
 80136be:	f7ff ff1f 	bl	8013500 <LOS_ListDelete>
        LOS_ListTailInsert(&cmdHistory->list, &cmdKey->list);
 80136c2:	68fb      	ldr	r3, [r7, #12]
 80136c4:	1d1a      	adds	r2, r3, #4
 80136c6:	693b      	ldr	r3, [r7, #16]
 80136c8:	3304      	adds	r3, #4
 80136ca:	4619      	mov	r1, r3
 80136cc:	4610      	mov	r0, r2
 80136ce:	f7ff ff08 	bl	80134e2 <LOS_ListTailInsert>
        (VOID)LOS_MemFree(m_aucSysMem0, (VOID *)cmdNxt);
 80136d2:	4b19      	ldr	r3, [pc, #100]	; (8013738 <ShellSaveHistoryCmd+0x114>)
 80136d4:	681b      	ldr	r3, [r3, #0]
 80136d6:	6979      	ldr	r1, [r7, #20]
 80136d8:	4618      	mov	r0, r3
 80136da:	f7f5 ff53 	bl	8009584 <LOS_MemFree>
        goto END;
 80136de:	e00c      	b.n	80136fa <ShellSaveHistoryCmd+0xd6>
    }

    LOS_ListTailInsert(&cmdHistory->list, &cmdKey->list);
 80136e0:	68fb      	ldr	r3, [r7, #12]
 80136e2:	1d1a      	adds	r2, r3, #4
 80136e4:	693b      	ldr	r3, [r7, #16]
 80136e6:	3304      	adds	r3, #4
 80136e8:	4619      	mov	r1, r3
 80136ea:	4610      	mov	r0, r2
 80136ec:	f7ff fef9 	bl	80134e2 <LOS_ListTailInsert>
    cmdHistory->count++;
 80136f0:	68fb      	ldr	r3, [r7, #12]
 80136f2:	681b      	ldr	r3, [r3, #0]
 80136f4:	1c5a      	adds	r2, r3, #1
 80136f6:	68fb      	ldr	r3, [r7, #12]
 80136f8:	601a      	str	r2, [r3, #0]

END:
    HISTORY_UNLOCK(shellCB);
 80136fa:	683b      	ldr	r3, [r7, #0]
 80136fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80136fe:	4618      	mov	r0, r3
 8013700:	f7f8 fa94 	bl	800bc2c <LOS_MuxPost>
 8013704:	61f8      	str	r0, [r7, #28]
 8013706:	69fb      	ldr	r3, [r7, #28]
 8013708:	2b00      	cmp	r3, #0
 801370a:	d00b      	beq.n	8013724 <ShellSaveHistoryCmd+0x100>
 801370c:	4807      	ldr	r0, [pc, #28]	; (801372c <ShellSaveHistoryCmd+0x108>)
 801370e:	f7f1 f8d7 	bl	80048c0 <dprintf>
 8013712:	69fb      	ldr	r3, [r7, #28]
 8013714:	2275      	movs	r2, #117	; 0x75
 8013716:	4906      	ldr	r1, [pc, #24]	; (8013730 <ShellSaveHistoryCmd+0x10c>)
 8013718:	4808      	ldr	r0, [pc, #32]	; (801373c <ShellSaveHistoryCmd+0x118>)
 801371a:	f7f1 f8d1 	bl	80048c0 <dprintf>
    return;
 801371e:	e001      	b.n	8013724 <ShellSaveHistoryCmd+0x100>
        return;
 8013720:	bf00      	nop
 8013722:	e000      	b.n	8013726 <ShellSaveHistoryCmd+0x102>
    return;
 8013724:	bf00      	nop
}
 8013726:	3720      	adds	r7, #32
 8013728:	46bd      	mov	sp, r7
 801372a:	bd80      	pop	{r7, pc}
 801372c:	080227e0 	.word	0x080227e0
 8013730:	0802360c 	.word	0x0802360c
 8013734:	080227e8 	.word	0x080227e8
 8013738:	200021bc 	.word	0x200021bc
 801373c:	0802280c 	.word	0x0802280c

08013740 <ShellNotify>:

STATIC VOID ShellNotify(ShellCB *shellCB)
{
 8013740:	b580      	push	{r7, lr}
 8013742:	b082      	sub	sp, #8
 8013744:	af00      	add	r7, sp, #0
 8013746:	6078      	str	r0, [r7, #4]
    (VOID)LOS_EventWrite(&shellCB->shellEvent, SHELL_CMD_PARSE_EVENT);
 8013748:	687b      	ldr	r3, [r7, #4]
 801374a:	3320      	adds	r3, #32
 801374c:	f240 1111 	movw	r1, #273	; 0x111
 8013750:	4618      	mov	r0, r3
 8013752:	f7f1 fc6d 	bl	8005030 <LOS_EventWrite>
}
 8013756:	bf00      	nop
 8013758:	3708      	adds	r7, #8
 801375a:	46bd      	mov	sp, r7
 801375c:	bd80      	pop	{r7, pc}

0801375e <ShellCmdLineCheckUDRL>:
    CMD_KEY_LEFT_VALUE  = 0x44,
    CMD_KEY_COMBINATION_VALUE = 0x5b
};

STATIC INT32 ShellCmdLineCheckUDRL(const CHAR ch, ShellCB *shellCB)
{
 801375e:	b580      	push	{r7, lr}
 8013760:	b084      	sub	sp, #16
 8013762:	af00      	add	r7, sp, #0
 8013764:	4603      	mov	r3, r0
 8013766:	6039      	str	r1, [r7, #0]
 8013768:	71fb      	strb	r3, [r7, #7]
    INT32 ret = LOS_OK;
 801376a:	2300      	movs	r3, #0
 801376c:	60fb      	str	r3, [r7, #12]
    if (ch == CMD_KEY_ESC_VALUE) {
 801376e:	79fb      	ldrb	r3, [r7, #7]
 8013770:	2b1b      	cmp	r3, #27
 8013772:	d104      	bne.n	801377e <ShellCmdLineCheckUDRL+0x20>
        shellCB->shellKeyType = STAT_ESC_KEY;
 8013774:	683b      	ldr	r3, [r7, #0]
 8013776:	2201      	movs	r2, #1
 8013778:	61da      	str	r2, [r3, #28]
        return ret;
 801377a:	68fb      	ldr	r3, [r7, #12]
 801377c:	e044      	b.n	8013808 <ShellCmdLineCheckUDRL+0xaa>
    } else if (ch == CMD_KEY_COMBINATION_VALUE) {
 801377e:	79fb      	ldrb	r3, [r7, #7]
 8013780:	2b5b      	cmp	r3, #91	; 0x5b
 8013782:	d108      	bne.n	8013796 <ShellCmdLineCheckUDRL+0x38>
        if (shellCB->shellKeyType == STAT_ESC_KEY) {
 8013784:	683b      	ldr	r3, [r7, #0]
 8013786:	69db      	ldr	r3, [r3, #28]
 8013788:	2b01      	cmp	r3, #1
 801378a:	d13c      	bne.n	8013806 <ShellCmdLineCheckUDRL+0xa8>
            shellCB->shellKeyType = STAT_MULTI_KEY;
 801378c:	683b      	ldr	r3, [r7, #0]
 801378e:	2202      	movs	r2, #2
 8013790:	61da      	str	r2, [r3, #28]
            return ret;
 8013792:	68fb      	ldr	r3, [r7, #12]
 8013794:	e038      	b.n	8013808 <ShellCmdLineCheckUDRL+0xaa>
        }
    } else if (ch == CMD_KEY_UP_VALUE) {
 8013796:	79fb      	ldrb	r3, [r7, #7]
 8013798:	2b41      	cmp	r3, #65	; 0x41
 801379a:	d10c      	bne.n	80137b6 <ShellCmdLineCheckUDRL+0x58>
        if (shellCB->shellKeyType == STAT_MULTI_KEY) {
 801379c:	683b      	ldr	r3, [r7, #0]
 801379e:	69db      	ldr	r3, [r3, #28]
 80137a0:	2b02      	cmp	r3, #2
 80137a2:	d130      	bne.n	8013806 <ShellCmdLineCheckUDRL+0xa8>
            OsShellHistoryShow(CMD_KEY_UP, shellCB);
 80137a4:	6839      	ldr	r1, [r7, #0]
 80137a6:	2000      	movs	r0, #0
 80137a8:	f7fe fe90 	bl	80124cc <OsShellHistoryShow>
            shellCB->shellKeyType = STAT_NOMAL_KEY;
 80137ac:	683b      	ldr	r3, [r7, #0]
 80137ae:	2200      	movs	r2, #0
 80137b0:	61da      	str	r2, [r3, #28]
            return ret;
 80137b2:	68fb      	ldr	r3, [r7, #12]
 80137b4:	e028      	b.n	8013808 <ShellCmdLineCheckUDRL+0xaa>
        }
    } else if (ch == CMD_KEY_DOWN_VALUE) {
 80137b6:	79fb      	ldrb	r3, [r7, #7]
 80137b8:	2b42      	cmp	r3, #66	; 0x42
 80137ba:	d10c      	bne.n	80137d6 <ShellCmdLineCheckUDRL+0x78>
        if (shellCB->shellKeyType == STAT_MULTI_KEY) {
 80137bc:	683b      	ldr	r3, [r7, #0]
 80137be:	69db      	ldr	r3, [r3, #28]
 80137c0:	2b02      	cmp	r3, #2
 80137c2:	d120      	bne.n	8013806 <ShellCmdLineCheckUDRL+0xa8>
            shellCB->shellKeyType = STAT_NOMAL_KEY;
 80137c4:	683b      	ldr	r3, [r7, #0]
 80137c6:	2200      	movs	r2, #0
 80137c8:	61da      	str	r2, [r3, #28]
            OsShellHistoryShow(CMD_KEY_DOWN, shellCB);
 80137ca:	6839      	ldr	r1, [r7, #0]
 80137cc:	2001      	movs	r0, #1
 80137ce:	f7fe fe7d 	bl	80124cc <OsShellHistoryShow>
            return ret;
 80137d2:	68fb      	ldr	r3, [r7, #12]
 80137d4:	e018      	b.n	8013808 <ShellCmdLineCheckUDRL+0xaa>
        }
    } else if (ch == CMD_KEY_RIGHT_VALUE) {
 80137d6:	79fb      	ldrb	r3, [r7, #7]
 80137d8:	2b43      	cmp	r3, #67	; 0x43
 80137da:	d108      	bne.n	80137ee <ShellCmdLineCheckUDRL+0x90>
        if (shellCB->shellKeyType == STAT_MULTI_KEY) {
 80137dc:	683b      	ldr	r3, [r7, #0]
 80137de:	69db      	ldr	r3, [r3, #28]
 80137e0:	2b02      	cmp	r3, #2
 80137e2:	d110      	bne.n	8013806 <ShellCmdLineCheckUDRL+0xa8>
            shellCB->shellKeyType = STAT_NOMAL_KEY;
 80137e4:	683b      	ldr	r3, [r7, #0]
 80137e6:	2200      	movs	r2, #0
 80137e8:	61da      	str	r2, [r3, #28]
            return ret;
 80137ea:	68fb      	ldr	r3, [r7, #12]
 80137ec:	e00c      	b.n	8013808 <ShellCmdLineCheckUDRL+0xaa>
        }
    } else if (ch == CMD_KEY_LEFT_VALUE) {
 80137ee:	79fb      	ldrb	r3, [r7, #7]
 80137f0:	2b44      	cmp	r3, #68	; 0x44
 80137f2:	d108      	bne.n	8013806 <ShellCmdLineCheckUDRL+0xa8>
        if (shellCB->shellKeyType == STAT_MULTI_KEY) {
 80137f4:	683b      	ldr	r3, [r7, #0]
 80137f6:	69db      	ldr	r3, [r3, #28]
 80137f8:	2b02      	cmp	r3, #2
 80137fa:	d104      	bne.n	8013806 <ShellCmdLineCheckUDRL+0xa8>
            shellCB->shellKeyType = STAT_NOMAL_KEY;
 80137fc:	683b      	ldr	r3, [r7, #0]
 80137fe:	2200      	movs	r2, #0
 8013800:	61da      	str	r2, [r3, #28]
            return ret;
 8013802:	68fb      	ldr	r3, [r7, #12]
 8013804:	e000      	b.n	8013808 <ShellCmdLineCheckUDRL+0xaa>
        }
    }
    return LOS_NOK;
 8013806:	2301      	movs	r3, #1
}
 8013808:	4618      	mov	r0, r3
 801380a:	3710      	adds	r7, #16
 801380c:	46bd      	mov	sp, r7
 801380e:	bd80      	pop	{r7, pc}

08013810 <ShellCmdLineParse>:

LITE_OS_SEC_TEXT_MINOR VOID ShellCmdLineParse(CHAR c, pf_OUTPUT outputFunc, ShellCB *shellCB)
{
 8013810:	b580      	push	{r7, lr}
 8013812:	b088      	sub	sp, #32
 8013814:	af00      	add	r7, sp, #0
 8013816:	4603      	mov	r3, r0
 8013818:	60b9      	str	r1, [r7, #8]
 801381a:	607a      	str	r2, [r7, #4]
 801381c:	73fb      	strb	r3, [r7, #15]
    const CHAR ch = c;
 801381e:	7bfb      	ldrb	r3, [r7, #15]
 8013820:	74fb      	strb	r3, [r7, #19]
    INT32 ret;

    if ((shellCB->shellBufOffset == 0) && (ch != '\n') && (ch != '\0')) {
 8013822:	687b      	ldr	r3, [r7, #4]
 8013824:	699b      	ldr	r3, [r3, #24]
 8013826:	2b00      	cmp	r3, #0
 8013828:	d10f      	bne.n	801384a <ShellCmdLineParse+0x3a>
 801382a:	7cfb      	ldrb	r3, [r7, #19]
 801382c:	2b0a      	cmp	r3, #10
 801382e:	d00c      	beq.n	801384a <ShellCmdLineParse+0x3a>
 8013830:	7cfb      	ldrb	r3, [r7, #19]
 8013832:	2b00      	cmp	r3, #0
 8013834:	d009      	beq.n	801384a <ShellCmdLineParse+0x3a>
        (VOID)memset_s(shellCB->shellBuf, SHOW_MAX_LEN, 0, SHOW_MAX_LEN);
 8013836:	687b      	ldr	r3, [r7, #4]
 8013838:	f103 0034 	add.w	r0, r3, #52	; 0x34
 801383c:	f44f 7388 	mov.w	r3, #272	; 0x110
 8013840:	2200      	movs	r2, #0
 8013842:	f44f 7188 	mov.w	r1, #272	; 0x110
 8013846:	f7ee fc2d 	bl	80020a4 <memset_s>
    }

    if (ch == '\r') {
 801384a:	7cfb      	ldrb	r3, [r7, #19]
 801384c:	2b0d      	cmp	r3, #13
 801384e:	d141      	bne.n	80138d4 <ShellCmdLineParse+0xc4>
        if (shellCB->shellBufOffset < (SHOW_MAX_LEN - 1)) {
 8013850:	687b      	ldr	r3, [r7, #4]
 8013852:	699b      	ldr	r3, [r3, #24]
 8013854:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 8013858:	d806      	bhi.n	8013868 <ShellCmdLineParse+0x58>
            shellCB->shellBuf[shellCB->shellBufOffset] = '\0';
 801385a:	687b      	ldr	r3, [r7, #4]
 801385c:	699b      	ldr	r3, [r3, #24]
 801385e:	687a      	ldr	r2, [r7, #4]
 8013860:	4413      	add	r3, r2
 8013862:	2200      	movs	r2, #0
 8013864:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        }
        shellCB->shellBufOffset = 0;
 8013868:	687b      	ldr	r3, [r7, #4]
 801386a:	2200      	movs	r2, #0
 801386c:	619a      	str	r2, [r3, #24]
        KEY_LOCK(shellCB);
 801386e:	687b      	ldr	r3, [r7, #4]
 8013870:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013872:	f04f 31ff 	mov.w	r1, #4294967295
 8013876:	4618      	mov	r0, r3
 8013878:	f7f8 f858 	bl	800b92c <LOS_MuxPend>
 801387c:	61b8      	str	r0, [r7, #24]
 801387e:	69bb      	ldr	r3, [r7, #24]
 8013880:	2b00      	cmp	r3, #0
 8013882:	d008      	beq.n	8013896 <ShellCmdLineParse+0x86>
 8013884:	484f      	ldr	r0, [pc, #316]	; (80139c4 <ShellCmdLineParse+0x1b4>)
 8013886:	f7f1 f81b 	bl	80048c0 <dprintf>
 801388a:	69bb      	ldr	r3, [r7, #24]
 801388c:	22c0      	movs	r2, #192	; 0xc0
 801388e:	494e      	ldr	r1, [pc, #312]	; (80139c8 <ShellCmdLineParse+0x1b8>)
 8013890:	484e      	ldr	r0, [pc, #312]	; (80139cc <ShellCmdLineParse+0x1bc>)
 8013892:	f7f1 f815 	bl	80048c0 <dprintf>
        OsShellCmdPush(shellCB->shellBuf, shellCB->cmdKeyLink);
 8013896:	687b      	ldr	r3, [r7, #4]
 8013898:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801389c:	687b      	ldr	r3, [r7, #4]
 801389e:	68db      	ldr	r3, [r3, #12]
 80138a0:	4619      	mov	r1, r3
 80138a2:	4610      	mov	r0, r2
 80138a4:	f7fe fdc4 	bl	8012430 <OsShellCmdPush>
        KEY_UNLOCK(shellCB);
 80138a8:	687b      	ldr	r3, [r7, #4]
 80138aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80138ac:	4618      	mov	r0, r3
 80138ae:	f7f8 f9bd 	bl	800bc2c <LOS_MuxPost>
 80138b2:	61f8      	str	r0, [r7, #28]
 80138b4:	69fb      	ldr	r3, [r7, #28]
 80138b6:	2b00      	cmp	r3, #0
 80138b8:	d008      	beq.n	80138cc <ShellCmdLineParse+0xbc>
 80138ba:	4842      	ldr	r0, [pc, #264]	; (80139c4 <ShellCmdLineParse+0x1b4>)
 80138bc:	f7f1 f800 	bl	80048c0 <dprintf>
 80138c0:	69fb      	ldr	r3, [r7, #28]
 80138c2:	22c2      	movs	r2, #194	; 0xc2
 80138c4:	4940      	ldr	r1, [pc, #256]	; (80139c8 <ShellCmdLineParse+0x1b8>)
 80138c6:	4842      	ldr	r0, [pc, #264]	; (80139d0 <ShellCmdLineParse+0x1c0>)
 80138c8:	f7f0 fffa 	bl	80048c0 <dprintf>
        ShellNotify(shellCB);
 80138cc:	6878      	ldr	r0, [r7, #4]
 80138ce:	f7ff ff37 	bl	8013740 <ShellNotify>
        return;
 80138d2:	e073      	b.n	80139bc <ShellCmdLineParse+0x1ac>
    } else if ((ch == '\b') || (ch == 0x7F)) { /* backspace or delete(0x7F) */
 80138d4:	7cfb      	ldrb	r3, [r7, #19]
 80138d6:	2b08      	cmp	r3, #8
 80138d8:	d002      	beq.n	80138e0 <ShellCmdLineParse+0xd0>
 80138da:	7cfb      	ldrb	r3, [r7, #19]
 80138dc:	2b7f      	cmp	r3, #127	; 0x7f
 80138de:	d119      	bne.n	8013914 <ShellCmdLineParse+0x104>
        if ((shellCB->shellBufOffset > 0) && (shellCB->shellBufOffset < (SHOW_MAX_LEN - 1))) {
 80138e0:	687b      	ldr	r3, [r7, #4]
 80138e2:	699b      	ldr	r3, [r3, #24]
 80138e4:	2b00      	cmp	r3, #0
 80138e6:	d064      	beq.n	80139b2 <ShellCmdLineParse+0x1a2>
 80138e8:	687b      	ldr	r3, [r7, #4]
 80138ea:	699b      	ldr	r3, [r3, #24]
 80138ec:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 80138f0:	d85f      	bhi.n	80139b2 <ShellCmdLineParse+0x1a2>
            shellCB->shellBuf[shellCB->shellBufOffset - 1] = '\0';
 80138f2:	687b      	ldr	r3, [r7, #4]
 80138f4:	699b      	ldr	r3, [r3, #24]
 80138f6:	3b01      	subs	r3, #1
 80138f8:	687a      	ldr	r2, [r7, #4]
 80138fa:	4413      	add	r3, r2
 80138fc:	2200      	movs	r2, #0
 80138fe:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            shellCB->shellBufOffset--;
 8013902:	687b      	ldr	r3, [r7, #4]
 8013904:	699b      	ldr	r3, [r3, #24]
 8013906:	1e5a      	subs	r2, r3, #1
 8013908:	687b      	ldr	r3, [r7, #4]
 801390a:	619a      	str	r2, [r3, #24]
            outputFunc("\b \b");
 801390c:	68bb      	ldr	r3, [r7, #8]
 801390e:	4831      	ldr	r0, [pc, #196]	; (80139d4 <ShellCmdLineParse+0x1c4>)
 8013910:	4798      	blx	r3
        }
        return;
 8013912:	e04e      	b.n	80139b2 <ShellCmdLineParse+0x1a2>
    } else if (ch == 0x09) { /* 0x09: tab */
 8013914:	7cfb      	ldrb	r3, [r7, #19]
 8013916:	2b09      	cmp	r3, #9
 8013918:	d11d      	bne.n	8013956 <ShellCmdLineParse+0x146>
        if ((shellCB->shellBufOffset > 0) && (shellCB->shellBufOffset < (SHOW_MAX_LEN - 1))) {
 801391a:	687b      	ldr	r3, [r7, #4]
 801391c:	699b      	ldr	r3, [r3, #24]
 801391e:	2b00      	cmp	r3, #0
 8013920:	d049      	beq.n	80139b6 <ShellCmdLineParse+0x1a6>
 8013922:	687b      	ldr	r3, [r7, #4]
 8013924:	699b      	ldr	r3, [r3, #24]
 8013926:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 801392a:	d844      	bhi.n	80139b6 <ShellCmdLineParse+0x1a6>
            ret = OsTabCompletion(shellCB->shellBuf, &shellCB->shellBufOffset);
 801392c:	687b      	ldr	r3, [r7, #4]
 801392e:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8013932:	687b      	ldr	r3, [r7, #4]
 8013934:	3318      	adds	r3, #24
 8013936:	4619      	mov	r1, r3
 8013938:	4610      	mov	r0, r2
 801393a:	f7fe fbb3 	bl	80120a4 <OsTabCompletion>
 801393e:	6178      	str	r0, [r7, #20]
            if (ret > 1) {
 8013940:	697b      	ldr	r3, [r7, #20]
 8013942:	2b01      	cmp	r3, #1
 8013944:	dd37      	ble.n	80139b6 <ShellCmdLineParse+0x1a6>
                outputFunc("Huawei LiteOS # %s", shellCB->shellBuf);
 8013946:	687b      	ldr	r3, [r7, #4]
 8013948:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801394c:	68bb      	ldr	r3, [r7, #8]
 801394e:	4611      	mov	r1, r2
 8013950:	4821      	ldr	r0, [pc, #132]	; (80139d8 <ShellCmdLineParse+0x1c8>)
 8013952:	4798      	blx	r3
            }
        }
        return;
 8013954:	e02f      	b.n	80139b6 <ShellCmdLineParse+0x1a6>
    }
    /* parse the up/down/right/left key */
    ret = ShellCmdLineCheckUDRL(ch, shellCB);
 8013956:	7cfb      	ldrb	r3, [r7, #19]
 8013958:	6879      	ldr	r1, [r7, #4]
 801395a:	4618      	mov	r0, r3
 801395c:	f7ff feff 	bl	801375e <ShellCmdLineCheckUDRL>
 8013960:	6178      	str	r0, [r7, #20]
    if (ret == LOS_OK) {
 8013962:	697b      	ldr	r3, [r7, #20]
 8013964:	2b00      	cmp	r3, #0
 8013966:	d028      	beq.n	80139ba <ShellCmdLineParse+0x1aa>
        return;
    }

    if ((ch != '\n') && (ch != '\0')) {
 8013968:	7cfb      	ldrb	r3, [r7, #19]
 801396a:	2b0a      	cmp	r3, #10
 801396c:	d01d      	beq.n	80139aa <ShellCmdLineParse+0x19a>
 801396e:	7cfb      	ldrb	r3, [r7, #19]
 8013970:	2b00      	cmp	r3, #0
 8013972:	d01a      	beq.n	80139aa <ShellCmdLineParse+0x19a>
        if (shellCB->shellBufOffset < (SHOW_MAX_LEN - 1)) {
 8013974:	687b      	ldr	r3, [r7, #4]
 8013976:	699b      	ldr	r3, [r3, #24]
 8013978:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 801397c:	d807      	bhi.n	801398e <ShellCmdLineParse+0x17e>
            shellCB->shellBuf[shellCB->shellBufOffset] = ch;
 801397e:	687b      	ldr	r3, [r7, #4]
 8013980:	699b      	ldr	r3, [r3, #24]
 8013982:	687a      	ldr	r2, [r7, #4]
 8013984:	4413      	add	r3, r2
 8013986:	7cfa      	ldrb	r2, [r7, #19]
 8013988:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 801398c:	e003      	b.n	8013996 <ShellCmdLineParse+0x186>
        } else {
            shellCB->shellBuf[SHOW_MAX_LEN - 1] = '\0';
 801398e:	687b      	ldr	r3, [r7, #4]
 8013990:	2200      	movs	r2, #0
 8013992:	f883 2143 	strb.w	r2, [r3, #323]	; 0x143
        }
        shellCB->shellBufOffset++;
 8013996:	687b      	ldr	r3, [r7, #4]
 8013998:	699b      	ldr	r3, [r3, #24]
 801399a:	1c5a      	adds	r2, r3, #1
 801399c:	687b      	ldr	r3, [r7, #4]
 801399e:	619a      	str	r2, [r3, #24]
        outputFunc("%c", ch);
 80139a0:	7cfa      	ldrb	r2, [r7, #19]
 80139a2:	68bb      	ldr	r3, [r7, #8]
 80139a4:	4611      	mov	r1, r2
 80139a6:	480d      	ldr	r0, [pc, #52]	; (80139dc <ShellCmdLineParse+0x1cc>)
 80139a8:	4798      	blx	r3
    }

    shellCB->shellKeyType = STAT_NOMAL_KEY;
 80139aa:	687b      	ldr	r3, [r7, #4]
 80139ac:	2200      	movs	r2, #0
 80139ae:	61da      	str	r2, [r3, #28]
 80139b0:	e004      	b.n	80139bc <ShellCmdLineParse+0x1ac>
        return;
 80139b2:	bf00      	nop
 80139b4:	e002      	b.n	80139bc <ShellCmdLineParse+0x1ac>
        return;
 80139b6:	bf00      	nop
 80139b8:	e000      	b.n	80139bc <ShellCmdLineParse+0x1ac>
        return;
 80139ba:	bf00      	nop
}
 80139bc:	3720      	adds	r7, #32
 80139be:	46bd      	mov	sp, r7
 80139c0:	bd80      	pop	{r7, pc}
 80139c2:	bf00      	nop
 80139c4:	080227e0 	.word	0x080227e0
 80139c8:	08023620 	.word	0x08023620
 80139cc:	080227e8 	.word	0x080227e8
 80139d0:	0802280c 	.word	0x0802280c
 80139d4:	08022830 	.word	0x08022830
 80139d8:	08022834 	.word	0x08022834
 80139dc:	08022848 	.word	0x08022848

080139e0 <ShellMsgTypeGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 ShellMsgTypeGet(CmdParsed *cmdParsed, const CHAR *cmdType)
{
 80139e0:	b580      	push	{r7, lr}
 80139e2:	b086      	sub	sp, #24
 80139e4:	af00      	add	r7, sp, #0
 80139e6:	6078      	str	r0, [r7, #4]
 80139e8:	6039      	str	r1, [r7, #0]
    UINT32 minLen;
    CmdItemNode *curCmdItem = (CmdItemNode *)NULL;
 80139ea:	2300      	movs	r3, #0
 80139ec:	60bb      	str	r3, [r7, #8]
    UINT32 len = strlen(cmdType);
 80139ee:	6838      	ldr	r0, [r7, #0]
 80139f0:	f7fb fdad 	bl	800f54e <strlen>
 80139f4:	60f8      	str	r0, [r7, #12]
    CmdModInfo *cmdInfo = OsCmdInfoGet();
 80139f6:	f7fe f99b 	bl	8011d30 <OsCmdInfoGet>
 80139fa:	6138      	str	r0, [r7, #16]

    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &cmdInfo->cmdList.list, CmdItemNode, list) {
 80139fc:	693b      	ldr	r3, [r7, #16]
 80139fe:	685b      	ldr	r3, [r3, #4]
 8013a00:	60bb      	str	r3, [r7, #8]
 8013a02:	e032      	b.n	8013a6a <ShellMsgTypeGet+0x8a>
        if ((len == strlen(curCmdItem->cmd->cmdKey)) &&
 8013a04:	68bb      	ldr	r3, [r7, #8]
 8013a06:	689b      	ldr	r3, [r3, #8]
 8013a08:	685b      	ldr	r3, [r3, #4]
 8013a0a:	4618      	mov	r0, r3
 8013a0c:	f7fb fd9f 	bl	800f54e <strlen>
 8013a10:	4602      	mov	r2, r0
 8013a12:	68fb      	ldr	r3, [r7, #12]
 8013a14:	4293      	cmp	r3, r2
 8013a16:	d125      	bne.n	8013a64 <ShellMsgTypeGet+0x84>
            (strncmp((CHAR *)(curCmdItem->cmd->cmdKey), cmdType, len) == 0)) {
 8013a18:	68bb      	ldr	r3, [r7, #8]
 8013a1a:	689b      	ldr	r3, [r3, #8]
 8013a1c:	685b      	ldr	r3, [r3, #4]
 8013a1e:	68fa      	ldr	r2, [r7, #12]
 8013a20:	6839      	ldr	r1, [r7, #0]
 8013a22:	4618      	mov	r0, r3
 8013a24:	f005 fe16 	bl	8019654 <strncmp>
 8013a28:	4603      	mov	r3, r0
        if ((len == strlen(curCmdItem->cmd->cmdKey)) &&
 8013a2a:	2b00      	cmp	r3, #0
 8013a2c:	d11a      	bne.n	8013a64 <ShellMsgTypeGet+0x84>
            minLen = (len < CMD_KEY_LEN) ? len : (CMD_KEY_LEN - 1);
 8013a2e:	68fb      	ldr	r3, [r7, #12]
 8013a30:	2b0f      	cmp	r3, #15
 8013a32:	bf28      	it	cs
 8013a34:	230f      	movcs	r3, #15
 8013a36:	617b      	str	r3, [r7, #20]
            if (strncpy_s((CHAR *)(cmdParsed->cmdKeyword), CMD_KEY_LEN, cmdType, minLen) != EOK) {
 8013a38:	687b      	ldr	r3, [r7, #4]
 8013a3a:	f103 0008 	add.w	r0, r3, #8
 8013a3e:	697b      	ldr	r3, [r7, #20]
 8013a40:	683a      	ldr	r2, [r7, #0]
 8013a42:	2110      	movs	r1, #16
 8013a44:	f003 f98e 	bl	8016d64 <strncpy_s>
 8013a48:	4603      	mov	r3, r0
 8013a4a:	2b00      	cmp	r3, #0
 8013a4c:	d003      	beq.n	8013a56 <ShellMsgTypeGet+0x76>
                PRINTK("strncpy_s failure in %s\n", __FUNCTION__);
 8013a4e:	490c      	ldr	r1, [pc, #48]	; (8013a80 <ShellMsgTypeGet+0xa0>)
 8013a50:	480c      	ldr	r0, [pc, #48]	; (8013a84 <ShellMsgTypeGet+0xa4>)
 8013a52:	f7f0 ff35 	bl	80048c0 <dprintf>
            }
            cmdParsed->cmdType = curCmdItem->cmd->cmdType;
 8013a56:	68bb      	ldr	r3, [r7, #8]
 8013a58:	689b      	ldr	r3, [r3, #8]
 8013a5a:	681a      	ldr	r2, [r3, #0]
 8013a5c:	687b      	ldr	r3, [r7, #4]
 8013a5e:	605a      	str	r2, [r3, #4]
            return LOS_OK;
 8013a60:	2300      	movs	r3, #0
 8013a62:	e008      	b.n	8013a76 <ShellMsgTypeGet+0x96>
    LOS_DL_LIST_FOR_EACH_ENTRY(curCmdItem, &cmdInfo->cmdList.list, CmdItemNode, list) {
 8013a64:	68bb      	ldr	r3, [r7, #8]
 8013a66:	685b      	ldr	r3, [r3, #4]
 8013a68:	60bb      	str	r3, [r7, #8]
 8013a6a:	68ba      	ldr	r2, [r7, #8]
 8013a6c:	693b      	ldr	r3, [r7, #16]
 8013a6e:	429a      	cmp	r2, r3
 8013a70:	d1c8      	bne.n	8013a04 <ShellMsgTypeGet+0x24>
        }
    }

    return OS_INVALID;
 8013a72:	f04f 33ff 	mov.w	r3, #4294967295
}
 8013a76:	4618      	mov	r0, r3
 8013a78:	3718      	adds	r7, #24
 8013a7a:	46bd      	mov	sp, r7
 8013a7c:	bd80      	pop	{r7, pc}
 8013a7e:	bf00      	nop
 8013a80:	08023634 	.word	0x08023634
 8013a84:	0802284c 	.word	0x0802284c

08013a88 <ShellMsgNameGetAndExec>:

STATIC UINT32 ShellMsgNameGetAndExec(CmdParsed *cmdParsed, const CHAR *output, UINT32 len)
{
 8013a88:	b580      	push	{r7, lr}
 8013a8a:	b08a      	sub	sp, #40	; 0x28
 8013a8c:	af00      	add	r7, sp, #0
 8013a8e:	60f8      	str	r0, [r7, #12]
 8013a90:	60b9      	str	r1, [r7, #8]
 8013a92:	607a      	str	r2, [r7, #4]
    UINT32 loop;
    UINT32 ret;
    const CHAR *tmpStr = NULL;
 8013a94:	2300      	movs	r3, #0
 8013a96:	61bb      	str	r3, [r7, #24]
    BOOL quotes = FALSE;
 8013a98:	2300      	movs	r3, #0
 8013a9a:	61fb      	str	r3, [r7, #28]
    CHAR *msgName = (CHAR *)LOS_MemAlloc(m_aucSysMem0, len + 1);
 8013a9c:	4b34      	ldr	r3, [pc, #208]	; (8013b70 <ShellMsgNameGetAndExec+0xe8>)
 8013a9e:	681a      	ldr	r2, [r3, #0]
 8013aa0:	687b      	ldr	r3, [r7, #4]
 8013aa2:	3301      	adds	r3, #1
 8013aa4:	4619      	mov	r1, r3
 8013aa6:	4610      	mov	r0, r2
 8013aa8:	f7f5 fcb4 	bl	8009414 <LOS_MemAlloc>
 8013aac:	6238      	str	r0, [r7, #32]
    if (msgName == NULL) {
 8013aae:	6a3b      	ldr	r3, [r7, #32]
 8013ab0:	2b00      	cmp	r3, #0
 8013ab2:	d108      	bne.n	8013ac6 <ShellMsgNameGetAndExec+0x3e>
        PRINTK("malloc failure in %s[%d]\n", __FUNCTION__, __LINE__);
 8013ab4:	f44f 7283 	mov.w	r2, #262	; 0x106
 8013ab8:	492e      	ldr	r1, [pc, #184]	; (8013b74 <ShellMsgNameGetAndExec+0xec>)
 8013aba:	482f      	ldr	r0, [pc, #188]	; (8013b78 <ShellMsgNameGetAndExec+0xf0>)
 8013abc:	f7f0 ff00 	bl	80048c0 <dprintf>
        return OS_INVALID;
 8013ac0:	f04f 33ff 	mov.w	r3, #4294967295
 8013ac4:	e050      	b.n	8013b68 <ShellMsgNameGetAndExec+0xe0>
    }
    /* Scan the 'output' string for command */
    /* Notice: Command string must not have any special name */
    for (tmpStr = output, loop = 0; (*tmpStr != '\0') && (loop < len);) {
 8013ac6:	68bb      	ldr	r3, [r7, #8]
 8013ac8:	61bb      	str	r3, [r7, #24]
 8013aca:	2300      	movs	r3, #0
 8013acc:	617b      	str	r3, [r7, #20]
 8013ace:	e021      	b.n	8013b14 <ShellMsgNameGetAndExec+0x8c>
        /* If reach a double quotes, switch the quotes matching status */
        if (*tmpStr == '\"') {
 8013ad0:	69bb      	ldr	r3, [r7, #24]
 8013ad2:	781b      	ldrb	r3, [r3, #0]
 8013ad4:	2b22      	cmp	r3, #34	; 0x22
 8013ad6:	d10b      	bne.n	8013af0 <ShellMsgNameGetAndExec+0x68>
            SWITCH_QUOTES_STATUS(quotes);
 8013ad8:	69fb      	ldr	r3, [r7, #28]
 8013ada:	2b01      	cmp	r3, #1
 8013adc:	d102      	bne.n	8013ae4 <ShellMsgNameGetAndExec+0x5c>
 8013ade:	2300      	movs	r3, #0
 8013ae0:	61fb      	str	r3, [r7, #28]
 8013ae2:	e001      	b.n	8013ae8 <ShellMsgNameGetAndExec+0x60>
 8013ae4:	2301      	movs	r3, #1
 8013ae6:	61fb      	str	r3, [r7, #28]
            /* Ignore the double quote CHARactor itself */
            tmpStr++;
 8013ae8:	69bb      	ldr	r3, [r7, #24]
 8013aea:	3301      	adds	r3, #1
 8013aec:	61bb      	str	r3, [r7, #24]
            continue;
 8013aee:	e011      	b.n	8013b14 <ShellMsgNameGetAndExec+0x8c>
        }
        /* If detected a space which the quotes matching status is false */
        /* which said has detected the first space for separator, finish this scan operation */
        if ((*tmpStr == ' ') && (QUOTES_STATUS_CLOSE(quotes))) {
 8013af0:	69bb      	ldr	r3, [r7, #24]
 8013af2:	781b      	ldrb	r3, [r3, #0]
 8013af4:	2b20      	cmp	r3, #32
 8013af6:	d102      	bne.n	8013afe <ShellMsgNameGetAndExec+0x76>
 8013af8:	69fb      	ldr	r3, [r7, #28]
 8013afa:	2b00      	cmp	r3, #0
 8013afc:	d013      	beq.n	8013b26 <ShellMsgNameGetAndExec+0x9e>
            break;
        }
        msgName[loop] = *tmpStr++;
 8013afe:	69bb      	ldr	r3, [r7, #24]
 8013b00:	1c5a      	adds	r2, r3, #1
 8013b02:	61ba      	str	r2, [r7, #24]
 8013b04:	6a39      	ldr	r1, [r7, #32]
 8013b06:	697a      	ldr	r2, [r7, #20]
 8013b08:	440a      	add	r2, r1
 8013b0a:	781b      	ldrb	r3, [r3, #0]
 8013b0c:	7013      	strb	r3, [r2, #0]
        loop++;
 8013b0e:	697b      	ldr	r3, [r7, #20]
 8013b10:	3301      	adds	r3, #1
 8013b12:	617b      	str	r3, [r7, #20]
    for (tmpStr = output, loop = 0; (*tmpStr != '\0') && (loop < len);) {
 8013b14:	69bb      	ldr	r3, [r7, #24]
 8013b16:	781b      	ldrb	r3, [r3, #0]
 8013b18:	2b00      	cmp	r3, #0
 8013b1a:	d005      	beq.n	8013b28 <ShellMsgNameGetAndExec+0xa0>
 8013b1c:	697a      	ldr	r2, [r7, #20]
 8013b1e:	687b      	ldr	r3, [r7, #4]
 8013b20:	429a      	cmp	r2, r3
 8013b22:	d3d5      	bcc.n	8013ad0 <ShellMsgNameGetAndExec+0x48>
 8013b24:	e000      	b.n	8013b28 <ShellMsgNameGetAndExec+0xa0>
            break;
 8013b26:	bf00      	nop
    }
    msgName[loop] = '\0';
 8013b28:	6a3a      	ldr	r2, [r7, #32]
 8013b2a:	697b      	ldr	r3, [r7, #20]
 8013b2c:	4413      	add	r3, r2
 8013b2e:	2200      	movs	r2, #0
 8013b30:	701a      	strb	r2, [r3, #0]
    /* Scan the command list to check whether the command can be found */
    ret = ShellMsgTypeGet(cmdParsed, msgName);
 8013b32:	6a39      	ldr	r1, [r7, #32]
 8013b34:	68f8      	ldr	r0, [r7, #12]
 8013b36:	f7ff ff53 	bl	80139e0 <ShellMsgTypeGet>
 8013b3a:	6278      	str	r0, [r7, #36]	; 0x24
    PRINTK("\n");
 8013b3c:	480f      	ldr	r0, [pc, #60]	; (8013b7c <ShellMsgNameGetAndExec+0xf4>)
 8013b3e:	f7f0 febf 	bl	80048c0 <dprintf>
    if (ret != LOS_OK) {
 8013b42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013b44:	2b00      	cmp	r3, #0
 8013b46:	d004      	beq.n	8013b52 <ShellMsgNameGetAndExec+0xca>
        PRINTK("%s:command not found", msgName);
 8013b48:	6a39      	ldr	r1, [r7, #32]
 8013b4a:	480d      	ldr	r0, [pc, #52]	; (8013b80 <ShellMsgNameGetAndExec+0xf8>)
 8013b4c:	f7f0 feb8 	bl	80048c0 <dprintf>
 8013b50:	e003      	b.n	8013b5a <ShellMsgNameGetAndExec+0xd2>
    } else {
        (VOID)OsCmdExec(cmdParsed, (CHAR *)output);
 8013b52:	68b9      	ldr	r1, [r7, #8]
 8013b54:	68f8      	ldr	r0, [r7, #12]
 8013b56:	f7fe fd67 	bl	8012628 <OsCmdExec>
    }
    (VOID)LOS_MemFree(m_aucSysMem0, msgName);
 8013b5a:	4b05      	ldr	r3, [pc, #20]	; (8013b70 <ShellMsgNameGetAndExec+0xe8>)
 8013b5c:	681b      	ldr	r3, [r3, #0]
 8013b5e:	6a39      	ldr	r1, [r7, #32]
 8013b60:	4618      	mov	r0, r3
 8013b62:	f7f5 fd0f 	bl	8009584 <LOS_MemFree>
    return ret;
 8013b66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8013b68:	4618      	mov	r0, r3
 8013b6a:	3728      	adds	r7, #40	; 0x28
 8013b6c:	46bd      	mov	sp, r7
 8013b6e:	bd80      	pop	{r7, pc}
 8013b70:	200021bc 	.word	0x200021bc
 8013b74:	08023644 	.word	0x08023644
 8013b78:	08022868 	.word	0x08022868
 8013b7c:	08022884 	.word	0x08022884
 8013b80:	08022888 	.word	0x08022888

08013b84 <ShellMsgParse>:

LITE_OS_SEC_TEXT_MINOR UINT32 ShellMsgParse(const VOID *msg)
{
 8013b84:	b580      	push	{r7, lr}
 8013b86:	b0ac      	sub	sp, #176	; 0xb0
 8013b88:	af00      	add	r7, sp, #0
 8013b8a:	6078      	str	r0, [r7, #4]
 8013b8c:	4b2e      	ldr	r3, [pc, #184]	; (8013c48 <ShellMsgParse+0xc4>)
 8013b8e:	681b      	ldr	r3, [r3, #0]
 8013b90:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8013b94:	f04f 0300 	mov.w	r3, #0
    CHAR *output = NULL;
 8013b98:	2300      	movs	r3, #0
 8013b9a:	60fb      	str	r3, [r7, #12]
    UINT32 len;
    CmdParsed cmdParsed;
    UINT32 ret = OS_INVALID;
 8013b9c:	f04f 33ff 	mov.w	r3, #4294967295
 8013ba0:	60bb      	str	r3, [r7, #8]

    if (msg == NULL) {
 8013ba2:	687b      	ldr	r3, [r7, #4]
 8013ba4:	2b00      	cmp	r3, #0
 8013ba6:	d041      	beq.n	8013c2c <ShellMsgParse+0xa8>
        goto END;
    }

    len = strlen(msg);
 8013ba8:	6878      	ldr	r0, [r7, #4]
 8013baa:	f7fb fcd0 	bl	800f54e <strlen>
 8013bae:	6138      	str	r0, [r7, #16]
    output = (CHAR *)LOS_MemAlloc(m_aucSysMem0, len + 1);
 8013bb0:	4b26      	ldr	r3, [pc, #152]	; (8013c4c <ShellMsgParse+0xc8>)
 8013bb2:	681a      	ldr	r2, [r3, #0]
 8013bb4:	693b      	ldr	r3, [r7, #16]
 8013bb6:	3301      	adds	r3, #1
 8013bb8:	4619      	mov	r1, r3
 8013bba:	4610      	mov	r0, r2
 8013bbc:	f7f5 fc2a 	bl	8009414 <LOS_MemAlloc>
 8013bc0:	60f8      	str	r0, [r7, #12]
    if (output == NULL) {
 8013bc2:	68fb      	ldr	r3, [r7, #12]
 8013bc4:	2b00      	cmp	r3, #0
 8013bc6:	d106      	bne.n	8013bd6 <ShellMsgParse+0x52>
        PRINTK("malloc failure in %s[%d]\n", __FUNCTION__, __LINE__);
 8013bc8:	f44f 729b 	mov.w	r2, #310	; 0x136
 8013bcc:	4920      	ldr	r1, [pc, #128]	; (8013c50 <ShellMsgParse+0xcc>)
 8013bce:	4821      	ldr	r0, [pc, #132]	; (8013c54 <ShellMsgParse+0xd0>)
 8013bd0:	f7f0 fe76 	bl	80048c0 <dprintf>
        goto END;
 8013bd4:	e02b      	b.n	8013c2e <ShellMsgParse+0xaa>
    }
    /* Call function 'OsCmdKeyShift' to squeeze and clear useless or overmuch space if string buffer */
    ret = OsCmdKeyShift((CHAR *)msg, output, len + 1);
 8013bd6:	693b      	ldr	r3, [r7, #16]
 8013bd8:	3301      	adds	r3, #1
 8013bda:	461a      	mov	r2, r3
 8013bdc:	68f9      	ldr	r1, [r7, #12]
 8013bde:	6878      	ldr	r0, [r7, #4]
 8013be0:	f7fe f9b0 	bl	8011f44 <OsCmdKeyShift>
 8013be4:	60b8      	str	r0, [r7, #8]
    if ((ret != LOS_OK) || (strlen(output) == 0)) {
 8013be6:	68bb      	ldr	r3, [r7, #8]
 8013be8:	2b00      	cmp	r3, #0
 8013bea:	d105      	bne.n	8013bf8 <ShellMsgParse+0x74>
 8013bec:	68f8      	ldr	r0, [r7, #12]
 8013bee:	f7fb fcae 	bl	800f54e <strlen>
 8013bf2:	4603      	mov	r3, r0
 8013bf4:	2b00      	cmp	r3, #0
 8013bf6:	d103      	bne.n	8013c00 <ShellMsgParse+0x7c>
        ret = OS_INVALID;
 8013bf8:	f04f 33ff 	mov.w	r3, #4294967295
 8013bfc:	60bb      	str	r3, [r7, #8]
        goto END_FREE_OUTPUT;
 8013bfe:	e00e      	b.n	8013c1e <ShellMsgParse+0x9a>
    }

    (VOID)memset_s(&cmdParsed, sizeof(CmdParsed), 0, sizeof(CmdParsed));
 8013c00:	f107 0014 	add.w	r0, r7, #20
 8013c04:	2398      	movs	r3, #152	; 0x98
 8013c06:	2200      	movs	r2, #0
 8013c08:	2198      	movs	r1, #152	; 0x98
 8013c0a:	f7ee fa4b 	bl	80020a4 <memset_s>

    ret = ShellMsgNameGetAndExec(&cmdParsed, output, len);
 8013c0e:	f107 0314 	add.w	r3, r7, #20
 8013c12:	693a      	ldr	r2, [r7, #16]
 8013c14:	68f9      	ldr	r1, [r7, #12]
 8013c16:	4618      	mov	r0, r3
 8013c18:	f7ff ff36 	bl	8013a88 <ShellMsgNameGetAndExec>
 8013c1c:	60b8      	str	r0, [r7, #8]

END_FREE_OUTPUT:
    (VOID)LOS_MemFree(m_aucSysMem0, output);
 8013c1e:	4b0b      	ldr	r3, [pc, #44]	; (8013c4c <ShellMsgParse+0xc8>)
 8013c20:	681b      	ldr	r3, [r3, #0]
 8013c22:	68f9      	ldr	r1, [r7, #12]
 8013c24:	4618      	mov	r0, r3
 8013c26:	f7f5 fcad 	bl	8009584 <LOS_MemFree>
 8013c2a:	e000      	b.n	8013c2e <ShellMsgParse+0xaa>
        goto END;
 8013c2c:	bf00      	nop
END:
    return ret;
 8013c2e:	68bb      	ldr	r3, [r7, #8]
}
 8013c30:	4a05      	ldr	r2, [pc, #20]	; (8013c48 <ShellMsgParse+0xc4>)
 8013c32:	6811      	ldr	r1, [r2, #0]
 8013c34:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8013c38:	4051      	eors	r1, r2
 8013c3a:	d001      	beq.n	8013c40 <ShellMsgParse+0xbc>
 8013c3c:	f7f0 fcce 	bl	80045dc <__stack_chk_fail>
 8013c40:	4618      	mov	r0, r3
 8013c42:	37b0      	adds	r7, #176	; 0xb0
 8013c44:	46bd      	mov	sp, r7
 8013c46:	bd80      	pop	{r7, pc}
 8013c48:	080228a0 	.word	0x080228a0
 8013c4c:	200021bc 	.word	0x200021bc
 8013c50:	0802365c 	.word	0x0802365c
 8013c54:	08022868 	.word	0x08022868

08013c58 <ShellEntry>:

LITE_OS_SEC_TEXT_MINOR UINT32 ShellEntry(VOID *param)
{
 8013c58:	b580      	push	{r7, lr}
 8013c5a:	b084      	sub	sp, #16
 8013c5c:	af00      	add	r7, sp, #0
 8013c5e:	6078      	str	r0, [r7, #4]
    ShellCB *shellCB = (ShellCB *)param;
 8013c60:	687b      	ldr	r3, [r7, #4]
 8013c62:	60fb      	str	r3, [r7, #12]

    (VOID)memset_s(shellCB->shellBuf, SHOW_MAX_LEN, 0, SHOW_MAX_LEN);
 8013c64:	68fb      	ldr	r3, [r7, #12]
 8013c66:	f103 0034 	add.w	r0, r3, #52	; 0x34
 8013c6a:	f44f 7388 	mov.w	r3, #272	; 0x110
 8013c6e:	2200      	movs	r2, #0
 8013c70:	f44f 7188 	mov.w	r1, #272	; 0x110
 8013c74:	f7ee fa16 	bl	80020a4 <memset_s>
    return ShellStdinLoop(shellCB);
 8013c78:	68f8      	ldr	r0, [r7, #12]
 8013c7a:	f000 fa0f 	bl	801409c <ShellStdinLoop>
 8013c7e:	4603      	mov	r3, r0
}
 8013c80:	4618      	mov	r0, r3
 8013c82:	3710      	adds	r7, #16
 8013c84:	46bd      	mov	sp, r7
 8013c86:	bd80      	pop	{r7, pc}

08013c88 <ShellCmdProcess>:

STATIC VOID ShellCmdProcess(ShellCB *shellCB)
{
 8013c88:	b580      	push	{r7, lr}
 8013c8a:	b084      	sub	sp, #16
 8013c8c:	af00      	add	r7, sp, #0
 8013c8e:	6078      	str	r0, [r7, #4]
    CHAR *buf = NULL;
 8013c90:	2300      	movs	r3, #0
 8013c92:	60fb      	str	r3, [r7, #12]
    while (1) {
        buf = ShellGetInputBuf(shellCB);
 8013c94:	6878      	ldr	r0, [r7, #4]
 8013c96:	f7ff fc5f 	bl	8013558 <ShellGetInputBuf>
 8013c9a:	60f8      	str	r0, [r7, #12]
        if (buf == NULL) {
 8013c9c:	68fb      	ldr	r3, [r7, #12]
 8013c9e:	2b00      	cmp	r3, #0
 8013ca0:	d00b      	beq.n	8013cba <ShellCmdProcess+0x32>
            break;
        }
        (VOID)ShellMsgParse(buf);
 8013ca2:	68f8      	ldr	r0, [r7, #12]
 8013ca4:	f7ff ff6e 	bl	8013b84 <ShellMsgParse>
        ShellSaveHistoryCmd(buf, shellCB);
 8013ca8:	6879      	ldr	r1, [r7, #4]
 8013caa:	68f8      	ldr	r0, [r7, #12]
 8013cac:	f7ff fcba 	bl	8013624 <ShellSaveHistoryCmd>
        shellCB->cmdMaskKeyLink = shellCB->cmdHistoryKeyLink;
 8013cb0:	687b      	ldr	r3, [r7, #4]
 8013cb2:	691a      	ldr	r2, [r3, #16]
 8013cb4:	687b      	ldr	r3, [r7, #4]
 8013cb6:	615a      	str	r2, [r3, #20]
        buf = ShellGetInputBuf(shellCB);
 8013cb8:	e7ec      	b.n	8013c94 <ShellCmdProcess+0xc>
            break;
 8013cba:	bf00      	nop
    }
}
 8013cbc:	bf00      	nop
 8013cbe:	3710      	adds	r7, #16
 8013cc0:	46bd      	mov	sp, r7
 8013cc2:	bd80      	pop	{r7, pc}

08013cc4 <ShellTask>:

LITE_OS_SEC_TEXT_MINOR UINT32 ShellTask(VOID *param)
{
 8013cc4:	b580      	push	{r7, lr}
 8013cc6:	b084      	sub	sp, #16
 8013cc8:	af00      	add	r7, sp, #0
 8013cca:	6078      	str	r0, [r7, #4]
    UINT32 ret;
    ShellCB *shellCB = (ShellCB *)param;
 8013ccc:	687b      	ldr	r3, [r7, #4]
 8013cce:	60bb      	str	r3, [r7, #8]

    while (1) {
        PRINTK("\nHuawei LiteOS # ");
 8013cd0:	481c      	ldr	r0, [pc, #112]	; (8013d44 <ShellTask+0x80>)
 8013cd2:	f7f0 fdf5 	bl	80048c0 <dprintf>
        ret = LOS_EventRead(&shellCB->shellEvent, SHELL_CMD_EVENT_MASK,
 8013cd6:	68bb      	ldr	r3, [r7, #8]
 8013cd8:	f103 0020 	add.w	r0, r3, #32
 8013cdc:	f04f 33ff 	mov.w	r3, #4294967295
 8013ce0:	2203      	movs	r2, #3
 8013ce2:	f640 71ff 	movw	r1, #4095	; 0xfff
 8013ce6:	f7f1 f98f 	bl	8005008 <LOS_EventRead>
 8013cea:	60f8      	str	r0, [r7, #12]
                            LOS_WAITMODE_OR | LOS_WAITMODE_CLR, LOS_WAIT_FOREVER);
        if (ret == SHELL_CMD_PARSE_EVENT) {
 8013cec:	68fb      	ldr	r3, [r7, #12]
 8013cee:	f240 1211 	movw	r2, #273	; 0x111
 8013cf2:	4293      	cmp	r3, r2
 8013cf4:	d103      	bne.n	8013cfe <ShellTask+0x3a>
            ShellCmdProcess(shellCB);
 8013cf6:	68b8      	ldr	r0, [r7, #8]
 8013cf8:	f7ff ffc6 	bl	8013c88 <ShellCmdProcess>
 8013cfc:	e7e8      	b.n	8013cd0 <ShellTask+0xc>
        } else if (ret == SHELL_CMD_EXIT_EVENT) {
 8013cfe:	68fb      	ldr	r3, [r7, #12]
 8013d00:	f5b3 7f89 	cmp.w	r3, #274	; 0x112
 8013d04:	d000      	beq.n	8013d08 <ShellTask+0x44>
        PRINTK("\nHuawei LiteOS # ");
 8013d06:	e7e3      	b.n	8013cd0 <ShellTask+0xc>
            break;
 8013d08:	bf00      	nop
        }
    }
    OsShellKeyDeInit(shellCB);
 8013d0a:	68b8      	ldr	r0, [r7, #8]
 8013d0c:	f7fe fafc 	bl	8012308 <OsShellKeyDeInit>
    (VOID)LOS_EventDestroy(&shellCB->shellEvent);
 8013d10:	68bb      	ldr	r3, [r7, #8]
 8013d12:	3320      	adds	r3, #32
 8013d14:	4618      	mov	r0, r3
 8013d16:	f7f1 f99b 	bl	8005050 <LOS_EventDestroy>
    (VOID)LOS_MuxDelete(shellCB->historyMutex);
 8013d1a:	68bb      	ldr	r3, [r7, #8]
 8013d1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013d1e:	4618      	mov	r0, r3
 8013d20:	f7f7 fbf4 	bl	800b50c <LOS_MuxDelete>
    (VOID)LOS_MuxDelete(shellCB->keyMutex);
 8013d24:	68bb      	ldr	r3, [r7, #8]
 8013d26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013d28:	4618      	mov	r0, r3
 8013d2a:	f7f7 fbef 	bl	800b50c <LOS_MuxDelete>
    (VOID)LOS_MemFree((VOID *)m_aucSysMem0, shellCB);
 8013d2e:	4b06      	ldr	r3, [pc, #24]	; (8013d48 <ShellTask+0x84>)
 8013d30:	681b      	ldr	r3, [r3, #0]
 8013d32:	68b9      	ldr	r1, [r7, #8]
 8013d34:	4618      	mov	r0, r3
 8013d36:	f7f5 fc25 	bl	8009584 <LOS_MemFree>
    return 0;
 8013d3a:	2300      	movs	r3, #0
}
 8013d3c:	4618      	mov	r0, r3
 8013d3e:	3710      	adds	r7, #16
 8013d40:	46bd      	mov	sp, r7
 8013d42:	bd80      	pop	{r7, pc}
 8013d44:	080228a4 	.word	0x080228a4
 8013d48:	200021bc 	.word	0x200021bc

08013d4c <ShellTaskInit>:
#define SERIAL_ENTRY_TASK_NAME "SerialEntryTask"
#define TELNET_SHELL_TASK_NAME "TelnetShellTask"
#define TELNET_ENTRY_TASK_NAME "TelnetEntryTask"

LITE_OS_SEC_TEXT_MINOR UINT32 ShellTaskInit(ShellCB *shellCB)
{
 8013d4c:	b580      	push	{r7, lr}
 8013d4e:	b08e      	sub	sp, #56	; 0x38
 8013d50:	af00      	add	r7, sp, #0
 8013d52:	6078      	str	r0, [r7, #4]
 8013d54:	4b1d      	ldr	r3, [pc, #116]	; (8013dcc <ShellTaskInit+0x80>)
 8013d56:	681b      	ldr	r3, [r3, #0]
 8013d58:	637b      	str	r3, [r7, #52]	; 0x34
 8013d5a:	f04f 0300 	mov.w	r3, #0
    CHAR *name = NULL;
 8013d5e:	2300      	movs	r3, #0
 8013d60:	60fb      	str	r3, [r7, #12]
    TSK_INIT_PARAM_S initParam = {0};
 8013d62:	f107 0310 	add.w	r3, r7, #16
 8013d66:	2224      	movs	r2, #36	; 0x24
 8013d68:	2100      	movs	r1, #0
 8013d6a:	4618      	mov	r0, r3
 8013d6c:	f7fb facc 	bl	800f308 <memset>

    if (shellCB == NULL) {
 8013d70:	687b      	ldr	r3, [r7, #4]
 8013d72:	2b00      	cmp	r3, #0
 8013d74:	d101      	bne.n	8013d7a <ShellTaskInit+0x2e>
        return LOS_NOK;
 8013d76:	2301      	movs	r3, #1
 8013d78:	e01d      	b.n	8013db6 <ShellTaskInit+0x6a>
    } else {
        return LOS_NOK;
    }
#else
    /* in non-console mode, shell only support one input */
    name = SERIAL_SHELL_TASK_NAME;
 8013d7a:	4b15      	ldr	r3, [pc, #84]	; (8013dd0 <ShellTaskInit+0x84>)
 8013d7c:	60fb      	str	r3, [r7, #12]
#endif

    initParam.pfnTaskEntry = (TSK_ENTRY_FUNC)ShellTask;
 8013d7e:	4b15      	ldr	r3, [pc, #84]	; (8013dd4 <ShellTaskInit+0x88>)
 8013d80:	613b      	str	r3, [r7, #16]
    initParam.usTaskPrio   = SHELL_TASK_PRIORITY;
 8013d82:	2309      	movs	r3, #9
 8013d84:	82bb      	strh	r3, [r7, #20]
    initParam.uwStackSize  = SHELL_TASK_STACK_SIZE;
 8013d86:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8013d8a:	62bb      	str	r3, [r7, #40]	; 0x28
    initParam.pcName       = name;
 8013d8c:	68fb      	ldr	r3, [r7, #12]
 8013d8e:	62fb      	str	r3, [r7, #44]	; 0x2c
    initParam.uwResved     = LOS_TASK_STATUS_DETACHED;
 8013d90:	f44f 7380 	mov.w	r3, #256	; 0x100
 8013d94:	633b      	str	r3, [r7, #48]	; 0x30
    LOS_TASK_PARAM_INIT_ARG(initParam, shellCB);
 8013d96:	687b      	ldr	r3, [r7, #4]
 8013d98:	61bb      	str	r3, [r7, #24]

    (VOID)LOS_EventInit(&shellCB->shellEvent);
 8013d9a:	687b      	ldr	r3, [r7, #4]
 8013d9c:	3320      	adds	r3, #32
 8013d9e:	4618      	mov	r0, r3
 8013da0:	f7f0 fe9e 	bl	8004ae0 <LOS_EventInit>

    return LOS_TaskCreate(&shellCB->shellTaskHandle, &initParam);
 8013da4:	687b      	ldr	r3, [r7, #4]
 8013da6:	3304      	adds	r3, #4
 8013da8:	f107 0210 	add.w	r2, r7, #16
 8013dac:	4611      	mov	r1, r2
 8013dae:	4618      	mov	r0, r3
 8013db0:	f7ef febc 	bl	8003b2c <LOS_TaskCreate>
 8013db4:	4603      	mov	r3, r0
}
 8013db6:	4a05      	ldr	r2, [pc, #20]	; (8013dcc <ShellTaskInit+0x80>)
 8013db8:	6811      	ldr	r1, [r2, #0]
 8013dba:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013dbc:	4051      	eors	r1, r2
 8013dbe:	d001      	beq.n	8013dc4 <ShellTaskInit+0x78>
 8013dc0:	f7f0 fc0c 	bl	80045dc <__stack_chk_fail>
 8013dc4:	4618      	mov	r0, r3
 8013dc6:	3738      	adds	r7, #56	; 0x38
 8013dc8:	46bd      	mov	sp, r7
 8013dca:	bd80      	pop	{r7, pc}
 8013dcc:	080228c8 	.word	0x080228c8
 8013dd0:	080228b8 	.word	0x080228b8
 8013dd4:	08013cc5 	.word	0x08013cc5

08013dd8 <ShellEntryInit>:
    return FALSE;
}
#endif

LITE_OS_SEC_TEXT_MINOR UINT32 ShellEntryInit(ShellCB *shellCB)
{
 8013dd8:	b580      	push	{r7, lr}
 8013dda:	b08e      	sub	sp, #56	; 0x38
 8013ddc:	af00      	add	r7, sp, #0
 8013dde:	6078      	str	r0, [r7, #4]
 8013de0:	4b1b      	ldr	r3, [pc, #108]	; (8013e50 <ShellEntryInit+0x78>)
 8013de2:	681b      	ldr	r3, [r3, #0]
 8013de4:	637b      	str	r3, [r7, #52]	; 0x34
 8013de6:	f04f 0300 	mov.w	r3, #0
    UINT32 ret;
    CHAR *name = NULL;
 8013dea:	2300      	movs	r3, #0
 8013dec:	60bb      	str	r3, [r7, #8]
    TSK_INIT_PARAM_S initParam = {0};
 8013dee:	f107 0310 	add.w	r3, r7, #16
 8013df2:	2224      	movs	r2, #36	; 0x24
 8013df4:	2100      	movs	r1, #0
 8013df6:	4618      	mov	r0, r3
 8013df8:	f7fb fa86 	bl	800f308 <memset>

    if (shellCB == NULL) {
 8013dfc:	687b      	ldr	r3, [r7, #4]
 8013dfe:	2b00      	cmp	r3, #0
 8013e00:	d101      	bne.n	8013e06 <ShellEntryInit+0x2e>
        return LOS_NOK;
 8013e02:	2301      	movs	r3, #1
 8013e04:	e019      	b.n	8013e3a <ShellEntryInit+0x62>
    } else {
        return LOS_NOK;
    }
#else
    /* in non-console mode, shell only support one input */
    name = SERIAL_ENTRY_TASK_NAME;
 8013e06:	4b13      	ldr	r3, [pc, #76]	; (8013e54 <ShellEntryInit+0x7c>)
 8013e08:	60bb      	str	r3, [r7, #8]
#endif

    initParam.pfnTaskEntry = (TSK_ENTRY_FUNC)ShellEntry;
 8013e0a:	4b13      	ldr	r3, [pc, #76]	; (8013e58 <ShellEntryInit+0x80>)
 8013e0c:	613b      	str	r3, [r7, #16]
    initParam.usTaskPrio   = SHELL_ENTRY_PRIORITY;
 8013e0e:	2309      	movs	r3, #9
 8013e10:	82bb      	strh	r3, [r7, #20]
    initParam.uwStackSize  = SHELL_ENTRY_STACK_SIZE;
 8013e12:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8013e16:	62bb      	str	r3, [r7, #40]	; 0x28
    initParam.pcName       = name;
 8013e18:	68bb      	ldr	r3, [r7, #8]
 8013e1a:	62fb      	str	r3, [r7, #44]	; 0x2c
    initParam.uwResved     = LOS_TASK_STATUS_DETACHED;
 8013e1c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8013e20:	633b      	str	r3, [r7, #48]	; 0x30
    LOS_TASK_PARAM_INIT_ARG(initParam, shellCB);
 8013e22:	687b      	ldr	r3, [r7, #4]
 8013e24:	61bb      	str	r3, [r7, #24]

    ret = LOS_TaskCreate(&shellCB->shellEntryHandle, &initParam);
 8013e26:	687b      	ldr	r3, [r7, #4]
 8013e28:	3308      	adds	r3, #8
 8013e2a:	f107 0210 	add.w	r2, r7, #16
 8013e2e:	4611      	mov	r1, r2
 8013e30:	4618      	mov	r0, r3
 8013e32:	f7ef fe7b 	bl	8003b2c <LOS_TaskCreate>
 8013e36:	60f8      	str	r0, [r7, #12]

#ifdef LOSCFG_SHELL_CONSOLE
    ret = ConsoleTaskReg((INT32)shellCB->consoleID, shellCB->shellEntryHandle);
#endif

    return ret;
 8013e38:	68fb      	ldr	r3, [r7, #12]
}
 8013e3a:	4a05      	ldr	r2, [pc, #20]	; (8013e50 <ShellEntryInit+0x78>)
 8013e3c:	6811      	ldr	r1, [r2, #0]
 8013e3e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013e40:	4051      	eors	r1, r2
 8013e42:	d001      	beq.n	8013e48 <ShellEntryInit+0x70>
 8013e44:	f7f0 fbca 	bl	80045dc <__stack_chk_fail>
 8013e48:	4618      	mov	r0, r3
 8013e4a:	3738      	adds	r7, #56	; 0x38
 8013e4c:	46bd      	mov	sp, r7
 8013e4e:	bd80      	pop	{r7, pc}
 8013e50:	080228dc 	.word	0x080228dc
 8013e54:	080228cc 	.word	0x080228cc
 8013e58:	08013c59 	.word	0x08013c59

08013e5c <OsCmdParseStrdup>:

/*
 * Filter out double quote or single-quoted strings at both ends
 */
LITE_OS_SEC_TEXT_MINOR CHAR *OsCmdParseStrdup(const CHAR *str)
{
 8013e5c:	b590      	push	{r4, r7, lr}
 8013e5e:	b085      	sub	sp, #20
 8013e60:	af00      	add	r7, sp, #0
 8013e62:	6078      	str	r0, [r7, #4]
    CHAR *tempStr = NULL;
 8013e64:	2300      	movs	r3, #0
 8013e66:	60fb      	str	r3, [r7, #12]
    CHAR *newStr = NULL;
 8013e68:	2300      	movs	r3, #0
 8013e6a:	60bb      	str	r3, [r7, #8]

    newStr = (CHAR *)LOS_MemAlloc(m_aucSysMem0, strlen(str) + 1);
 8013e6c:	4b19      	ldr	r3, [pc, #100]	; (8013ed4 <OsCmdParseStrdup+0x78>)
 8013e6e:	681c      	ldr	r4, [r3, #0]
 8013e70:	6878      	ldr	r0, [r7, #4]
 8013e72:	f7fb fb6c 	bl	800f54e <strlen>
 8013e76:	4603      	mov	r3, r0
 8013e78:	3301      	adds	r3, #1
 8013e7a:	4619      	mov	r1, r3
 8013e7c:	4620      	mov	r0, r4
 8013e7e:	f7f5 fac9 	bl	8009414 <LOS_MemAlloc>
 8013e82:	60b8      	str	r0, [r7, #8]
    if (newStr == NULL) {
 8013e84:	68bb      	ldr	r3, [r7, #8]
 8013e86:	2b00      	cmp	r3, #0
 8013e88:	d101      	bne.n	8013e8e <OsCmdParseStrdup+0x32>
        return NULL;
 8013e8a:	2300      	movs	r3, #0
 8013e8c:	e01e      	b.n	8013ecc <OsCmdParseStrdup+0x70>
    }

    tempStr = newStr;
 8013e8e:	68bb      	ldr	r3, [r7, #8]
 8013e90:	60fb      	str	r3, [r7, #12]
    for (; *str != '\0'; str++) {
 8013e92:	e013      	b.n	8013ebc <OsCmdParseStrdup+0x60>
        if ((*str == '\"') || (*str == '\'')) {
 8013e94:	687b      	ldr	r3, [r7, #4]
 8013e96:	781b      	ldrb	r3, [r3, #0]
 8013e98:	2b22      	cmp	r3, #34	; 0x22
 8013e9a:	d00b      	beq.n	8013eb4 <OsCmdParseStrdup+0x58>
 8013e9c:	687b      	ldr	r3, [r7, #4]
 8013e9e:	781b      	ldrb	r3, [r3, #0]
 8013ea0:	2b27      	cmp	r3, #39	; 0x27
 8013ea2:	d007      	beq.n	8013eb4 <OsCmdParseStrdup+0x58>
            continue;
        }
        *newStr = *str;
 8013ea4:	687b      	ldr	r3, [r7, #4]
 8013ea6:	781a      	ldrb	r2, [r3, #0]
 8013ea8:	68bb      	ldr	r3, [r7, #8]
 8013eaa:	701a      	strb	r2, [r3, #0]
        newStr++;
 8013eac:	68bb      	ldr	r3, [r7, #8]
 8013eae:	3301      	adds	r3, #1
 8013eb0:	60bb      	str	r3, [r7, #8]
 8013eb2:	e000      	b.n	8013eb6 <OsCmdParseStrdup+0x5a>
            continue;
 8013eb4:	bf00      	nop
    for (; *str != '\0'; str++) {
 8013eb6:	687b      	ldr	r3, [r7, #4]
 8013eb8:	3301      	adds	r3, #1
 8013eba:	607b      	str	r3, [r7, #4]
 8013ebc:	687b      	ldr	r3, [r7, #4]
 8013ebe:	781b      	ldrb	r3, [r3, #0]
 8013ec0:	2b00      	cmp	r3, #0
 8013ec2:	d1e7      	bne.n	8013e94 <OsCmdParseStrdup+0x38>
    }
    *newStr = '\0';
 8013ec4:	68bb      	ldr	r3, [r7, #8]
 8013ec6:	2200      	movs	r2, #0
 8013ec8:	701a      	strb	r2, [r3, #0]
    return tempStr;
 8013eca:	68fb      	ldr	r3, [r7, #12]
}
 8013ecc:	4618      	mov	r0, r3
 8013ece:	3714      	adds	r7, #20
 8013ed0:	46bd      	mov	sp, r7
 8013ed2:	bd90      	pop	{r4, r7, pc}
 8013ed4:	200021bc 	.word	0x200021bc

08013ed8 <OsCmdParseParaGet>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdParseParaGet(CHAR **value, const CHAR *paraTokenStr)
{
 8013ed8:	b580      	push	{r7, lr}
 8013eda:	b082      	sub	sp, #8
 8013edc:	af00      	add	r7, sp, #0
 8013ede:	6078      	str	r0, [r7, #4]
 8013ee0:	6039      	str	r1, [r7, #0]
    if ((paraTokenStr == NULL) || (value == NULL)) {
 8013ee2:	683b      	ldr	r3, [r7, #0]
 8013ee4:	2b00      	cmp	r3, #0
 8013ee6:	d002      	beq.n	8013eee <OsCmdParseParaGet+0x16>
 8013ee8:	687b      	ldr	r3, [r7, #4]
 8013eea:	2b00      	cmp	r3, #0
 8013eec:	d102      	bne.n	8013ef4 <OsCmdParseParaGet+0x1c>
        return (UINT32)OS_ERROR;
 8013eee:	f04f 33ff 	mov.w	r3, #4294967295
 8013ef2:	e006      	b.n	8013f02 <OsCmdParseParaGet+0x2a>
    }
    *value = OsCmdParseStrdup(paraTokenStr);
 8013ef4:	6838      	ldr	r0, [r7, #0]
 8013ef6:	f7ff ffb1 	bl	8013e5c <OsCmdParseStrdup>
 8013efa:	4602      	mov	r2, r0
 8013efc:	687b      	ldr	r3, [r7, #4]
 8013efe:	601a      	str	r2, [r3, #0]
    return LOS_OK;
 8013f00:	2300      	movs	r3, #0
}
 8013f02:	4618      	mov	r0, r3
 8013f04:	3708      	adds	r7, #8
 8013f06:	46bd      	mov	sp, r7
 8013f08:	bd80      	pop	{r7, pc}

08013f0a <OsCmdParseOneToken>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdParseOneToken(CmdParsed *cmdParsed, UINT32 index, const CHAR *token)
{
 8013f0a:	b580      	push	{r7, lr}
 8013f0c:	b086      	sub	sp, #24
 8013f0e:	af00      	add	r7, sp, #0
 8013f10:	60f8      	str	r0, [r7, #12]
 8013f12:	60b9      	str	r1, [r7, #8]
 8013f14:	607a      	str	r2, [r7, #4]
    UINT32 ret = LOS_OK;
 8013f16:	2300      	movs	r3, #0
 8013f18:	613b      	str	r3, [r7, #16]
    UINT32 tempLen;

    if (cmdParsed == NULL) {
 8013f1a:	68fb      	ldr	r3, [r7, #12]
 8013f1c:	2b00      	cmp	r3, #0
 8013f1e:	d102      	bne.n	8013f26 <OsCmdParseOneToken+0x1c>
        return (UINT32)OS_ERROR;
 8013f20:	f04f 33ff 	mov.w	r3, #4294967295
 8013f24:	e027      	b.n	8013f76 <OsCmdParseOneToken+0x6c>
    }

    if (index == 0) {
 8013f26:	68bb      	ldr	r3, [r7, #8]
 8013f28:	2b00      	cmp	r3, #0
 8013f2a:	d105      	bne.n	8013f38 <OsCmdParseOneToken+0x2e>
        if (cmdParsed->cmdType != CMD_TYPE_STD) {
 8013f2c:	68fb      	ldr	r3, [r7, #12]
 8013f2e:	685b      	ldr	r3, [r3, #4]
 8013f30:	2b01      	cmp	r3, #1
 8013f32:	d001      	beq.n	8013f38 <OsCmdParseOneToken+0x2e>
            return ret;
 8013f34:	693b      	ldr	r3, [r7, #16]
 8013f36:	e01e      	b.n	8013f76 <OsCmdParseOneToken+0x6c>
        }
    }

    if ((token != NULL) && (cmdParsed->paramCnt < CMD_MAX_PARAS)) {
 8013f38:	687b      	ldr	r3, [r7, #4]
 8013f3a:	2b00      	cmp	r3, #0
 8013f3c:	d01a      	beq.n	8013f74 <OsCmdParseOneToken+0x6a>
 8013f3e:	68fb      	ldr	r3, [r7, #12]
 8013f40:	681b      	ldr	r3, [r3, #0]
 8013f42:	2b1f      	cmp	r3, #31
 8013f44:	d816      	bhi.n	8013f74 <OsCmdParseOneToken+0x6a>
        tempLen = cmdParsed->paramCnt;
 8013f46:	68fb      	ldr	r3, [r7, #12]
 8013f48:	681b      	ldr	r3, [r3, #0]
 8013f4a:	617b      	str	r3, [r7, #20]
        ret = OsCmdParseParaGet(&(cmdParsed->paramArray[tempLen]), token);
 8013f4c:	697b      	ldr	r3, [r7, #20]
 8013f4e:	3306      	adds	r3, #6
 8013f50:	009b      	lsls	r3, r3, #2
 8013f52:	68fa      	ldr	r2, [r7, #12]
 8013f54:	4413      	add	r3, r2
 8013f56:	6879      	ldr	r1, [r7, #4]
 8013f58:	4618      	mov	r0, r3
 8013f5a:	f7ff ffbd 	bl	8013ed8 <OsCmdParseParaGet>
 8013f5e:	6138      	str	r0, [r7, #16]
        if (ret != LOS_OK) {
 8013f60:	693b      	ldr	r3, [r7, #16]
 8013f62:	2b00      	cmp	r3, #0
 8013f64:	d001      	beq.n	8013f6a <OsCmdParseOneToken+0x60>
            return ret;
 8013f66:	693b      	ldr	r3, [r7, #16]
 8013f68:	e005      	b.n	8013f76 <OsCmdParseOneToken+0x6c>
        }
        cmdParsed->paramCnt++;
 8013f6a:	68fb      	ldr	r3, [r7, #12]
 8013f6c:	681b      	ldr	r3, [r3, #0]
 8013f6e:	1c5a      	adds	r2, r3, #1
 8013f70:	68fb      	ldr	r3, [r7, #12]
 8013f72:	601a      	str	r2, [r3, #0]
    }
    return ret;
 8013f74:	693b      	ldr	r3, [r7, #16]
}
 8013f76:	4618      	mov	r0, r3
 8013f78:	3718      	adds	r7, #24
 8013f7a:	46bd      	mov	sp, r7
 8013f7c:	bd80      	pop	{r7, pc}

08013f7e <OsCmdTokenSplit>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdTokenSplit(CHAR *cmdStr, CHAR split, CmdParsed *cmdParsed)
{
 8013f7e:	b580      	push	{r7, lr}
 8013f80:	b08a      	sub	sp, #40	; 0x28
 8013f82:	af00      	add	r7, sp, #0
 8013f84:	60f8      	str	r0, [r7, #12]
 8013f86:	460b      	mov	r3, r1
 8013f88:	607a      	str	r2, [r7, #4]
 8013f8a:	72fb      	strb	r3, [r7, #11]
    enum {
        STAT_INIT,
        STAT_TOKEN_IN,
        STAT_TOKEN_OUT
    } state = STAT_INIT;
 8013f8c:	2300      	movs	r3, #0
 8013f8e:	613b      	str	r3, [r7, #16]
    UINT32 count = 0;
 8013f90:	2300      	movs	r3, #0
 8013f92:	617b      	str	r3, [r7, #20]
    CHAR *p = NULL;
 8013f94:	2300      	movs	r3, #0
 8013f96:	61bb      	str	r3, [r7, #24]
    CHAR *token = cmdStr;
 8013f98:	68fb      	ldr	r3, [r7, #12]
 8013f9a:	61fb      	str	r3, [r7, #28]
    UINT32 ret = LOS_OK;
 8013f9c:	2300      	movs	r3, #0
 8013f9e:	623b      	str	r3, [r7, #32]
    BOOL quotes = FALSE;
 8013fa0:	2300      	movs	r3, #0
 8013fa2:	627b      	str	r3, [r7, #36]	; 0x24

    if (cmdStr == NULL) {
 8013fa4:	68fb      	ldr	r3, [r7, #12]
 8013fa6:	2b00      	cmp	r3, #0
 8013fa8:	d102      	bne.n	8013fb0 <OsCmdTokenSplit+0x32>
        return (UINT32)OS_ERROR;
 8013faa:	f04f 33ff 	mov.w	r3, #4294967295
 8013fae:	e053      	b.n	8014058 <OsCmdTokenSplit+0xda>
    }

    for (p = cmdStr; (*p != '\0') && (ret == LOS_OK); p++) {
 8013fb0:	68fb      	ldr	r3, [r7, #12]
 8013fb2:	61bb      	str	r3, [r7, #24]
 8013fb4:	e039      	b.n	801402a <OsCmdTokenSplit+0xac>
        if (*p == '\"') {
 8013fb6:	69bb      	ldr	r3, [r7, #24]
 8013fb8:	781b      	ldrb	r3, [r3, #0]
 8013fba:	2b22      	cmp	r3, #34	; 0x22
 8013fbc:	d107      	bne.n	8013fce <OsCmdTokenSplit+0x50>
            SWITCH_QUOTES_STATUS(quotes);
 8013fbe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013fc0:	2b01      	cmp	r3, #1
 8013fc2:	d102      	bne.n	8013fca <OsCmdTokenSplit+0x4c>
 8013fc4:	2300      	movs	r3, #0
 8013fc6:	627b      	str	r3, [r7, #36]	; 0x24
 8013fc8:	e001      	b.n	8013fce <OsCmdTokenSplit+0x50>
 8013fca:	2301      	movs	r3, #1
 8013fcc:	627b      	str	r3, [r7, #36]	; 0x24
        }
        switch (state) {
 8013fce:	693b      	ldr	r3, [r7, #16]
 8013fd0:	2b01      	cmp	r3, #1
 8013fd2:	d903      	bls.n	8013fdc <OsCmdTokenSplit+0x5e>
 8013fd4:	693b      	ldr	r3, [r7, #16]
 8013fd6:	2b02      	cmp	r3, #2
 8013fd8:	d017      	beq.n	801400a <OsCmdTokenSplit+0x8c>
                    token = p;
                    state = STAT_TOKEN_IN;
                }
                break;
            default:
                break;
 8013fda:	e023      	b.n	8014024 <OsCmdTokenSplit+0xa6>
                if ((*p == split) && QUOTES_STATUS_CLOSE(quotes)) {
 8013fdc:	69bb      	ldr	r3, [r7, #24]
 8013fde:	781b      	ldrb	r3, [r3, #0]
 8013fe0:	7afa      	ldrb	r2, [r7, #11]
 8013fe2:	429a      	cmp	r2, r3
 8013fe4:	d11b      	bne.n	801401e <OsCmdTokenSplit+0xa0>
 8013fe6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013fe8:	2b00      	cmp	r3, #0
 8013fea:	d118      	bne.n	801401e <OsCmdTokenSplit+0xa0>
                    *p = '\0';
 8013fec:	69bb      	ldr	r3, [r7, #24]
 8013fee:	2200      	movs	r2, #0
 8013ff0:	701a      	strb	r2, [r3, #0]
                    ret = OsCmdParseOneToken(cmdParsed, count++, token);
 8013ff2:	697b      	ldr	r3, [r7, #20]
 8013ff4:	1c5a      	adds	r2, r3, #1
 8013ff6:	617a      	str	r2, [r7, #20]
 8013ff8:	69fa      	ldr	r2, [r7, #28]
 8013ffa:	4619      	mov	r1, r3
 8013ffc:	6878      	ldr	r0, [r7, #4]
 8013ffe:	f7ff ff84 	bl	8013f0a <OsCmdParseOneToken>
 8014002:	6238      	str	r0, [r7, #32]
                    state = STAT_TOKEN_OUT;
 8014004:	2302      	movs	r3, #2
 8014006:	613b      	str	r3, [r7, #16]
                break;
 8014008:	e009      	b.n	801401e <OsCmdTokenSplit+0xa0>
                if (*p != split) {
 801400a:	69bb      	ldr	r3, [r7, #24]
 801400c:	781b      	ldrb	r3, [r3, #0]
 801400e:	7afa      	ldrb	r2, [r7, #11]
 8014010:	429a      	cmp	r2, r3
 8014012:	d006      	beq.n	8014022 <OsCmdTokenSplit+0xa4>
                    token = p;
 8014014:	69bb      	ldr	r3, [r7, #24]
 8014016:	61fb      	str	r3, [r7, #28]
                    state = STAT_TOKEN_IN;
 8014018:	2301      	movs	r3, #1
 801401a:	613b      	str	r3, [r7, #16]
                break;
 801401c:	e001      	b.n	8014022 <OsCmdTokenSplit+0xa4>
                break;
 801401e:	bf00      	nop
 8014020:	e000      	b.n	8014024 <OsCmdTokenSplit+0xa6>
                break;
 8014022:	bf00      	nop
    for (p = cmdStr; (*p != '\0') && (ret == LOS_OK); p++) {
 8014024:	69bb      	ldr	r3, [r7, #24]
 8014026:	3301      	adds	r3, #1
 8014028:	61bb      	str	r3, [r7, #24]
 801402a:	69bb      	ldr	r3, [r7, #24]
 801402c:	781b      	ldrb	r3, [r3, #0]
 801402e:	2b00      	cmp	r3, #0
 8014030:	d002      	beq.n	8014038 <OsCmdTokenSplit+0xba>
 8014032:	6a3b      	ldr	r3, [r7, #32]
 8014034:	2b00      	cmp	r3, #0
 8014036:	d0be      	beq.n	8013fb6 <OsCmdTokenSplit+0x38>
        }
    }

    if (((ret == LOS_OK) && (state == STAT_TOKEN_IN)) || (state == STAT_INIT)) {
 8014038:	6a3b      	ldr	r3, [r7, #32]
 801403a:	2b00      	cmp	r3, #0
 801403c:	d102      	bne.n	8014044 <OsCmdTokenSplit+0xc6>
 801403e:	693b      	ldr	r3, [r7, #16]
 8014040:	2b01      	cmp	r3, #1
 8014042:	d002      	beq.n	801404a <OsCmdTokenSplit+0xcc>
 8014044:	693b      	ldr	r3, [r7, #16]
 8014046:	2b00      	cmp	r3, #0
 8014048:	d105      	bne.n	8014056 <OsCmdTokenSplit+0xd8>
        ret = OsCmdParseOneToken(cmdParsed, count, token);
 801404a:	69fa      	ldr	r2, [r7, #28]
 801404c:	6979      	ldr	r1, [r7, #20]
 801404e:	6878      	ldr	r0, [r7, #4]
 8014050:	f7ff ff5b 	bl	8013f0a <OsCmdParseOneToken>
 8014054:	6238      	str	r0, [r7, #32]
    }

    return ret;
 8014056:	6a3b      	ldr	r3, [r7, #32]
}
 8014058:	4618      	mov	r0, r3
 801405a:	3728      	adds	r7, #40	; 0x28
 801405c:	46bd      	mov	sp, r7
 801405e:	bd80      	pop	{r7, pc}

08014060 <OsCmdParse>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsCmdParse(CHAR *cmdStr, CmdParsed *cmdParsed)
{
 8014060:	b580      	push	{r7, lr}
 8014062:	b082      	sub	sp, #8
 8014064:	af00      	add	r7, sp, #0
 8014066:	6078      	str	r0, [r7, #4]
 8014068:	6039      	str	r1, [r7, #0]
    if ((cmdStr == NULL) || (cmdParsed == NULL) || (strlen(cmdStr) == 0)) {
 801406a:	687b      	ldr	r3, [r7, #4]
 801406c:	2b00      	cmp	r3, #0
 801406e:	d008      	beq.n	8014082 <OsCmdParse+0x22>
 8014070:	683b      	ldr	r3, [r7, #0]
 8014072:	2b00      	cmp	r3, #0
 8014074:	d005      	beq.n	8014082 <OsCmdParse+0x22>
 8014076:	6878      	ldr	r0, [r7, #4]
 8014078:	f7fb fa69 	bl	800f54e <strlen>
 801407c:	4603      	mov	r3, r0
 801407e:	2b00      	cmp	r3, #0
 8014080:	d102      	bne.n	8014088 <OsCmdParse+0x28>
        return (UINT32)OS_ERROR;
 8014082:	f04f 33ff 	mov.w	r3, #4294967295
 8014086:	e005      	b.n	8014094 <OsCmdParse+0x34>
    }
    return OsCmdTokenSplit(cmdStr, ' ', cmdParsed);
 8014088:	683a      	ldr	r2, [r7, #0]
 801408a:	2120      	movs	r1, #32
 801408c:	6878      	ldr	r0, [r7, #4]
 801408e:	f7ff ff76 	bl	8013f7e <OsCmdTokenSplit>
 8014092:	4603      	mov	r3, r0
}
 8014094:	4618      	mov	r0, r3
 8014096:	3708      	adds	r7, #8
 8014098:	46bd      	mov	sp, r7
 801409a:	bd80      	pop	{r7, pc}

0801409c <ShellStdinLoop>:
#include "shmsg.h"
#include "console.h"
#include "uart.h"

UINT32 ShellStdinLoop(ShellCB *shellCB)
{
 801409c:	b580      	push	{r7, lr}
 801409e:	b084      	sub	sp, #16
 80140a0:	af00      	add	r7, sp, #0
 80140a2:	6078      	str	r0, [r7, #4]
    UINT8 ch;
    while (1) {
        ch = uart_read();
 80140a4:	f7fc fc68 	bl	8010978 <uart_read>
 80140a8:	4603      	mov	r3, r0
 80140aa:	73fb      	strb	r3, [r7, #15]
        ShellCmdLineParse(ch, (pf_OUTPUT)dprintf, shellCB);
 80140ac:	7bfb      	ldrb	r3, [r7, #15]
 80140ae:	687a      	ldr	r2, [r7, #4]
 80140b0:	4902      	ldr	r1, [pc, #8]	; (80140bc <ShellStdinLoop+0x20>)
 80140b2:	4618      	mov	r0, r3
 80140b4:	f7ff fbac 	bl	8013810 <ShellCmdLineParse>
        ch = uart_read();
 80140b8:	e7f4      	b.n	80140a4 <ShellStdinLoop+0x8>
 80140ba:	bf00      	nop
 80140bc:	080048c1 	.word	0x080048c1

080140c0 <ArchCurrCpuid>:
{
 80140c0:	b480      	push	{r7}
 80140c2:	af00      	add	r7, sp, #0
    return 0;
 80140c4:	2300      	movs	r3, #0
}
 80140c6:	4618      	mov	r0, r3
 80140c8:	46bd      	mov	sp, r7
 80140ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80140ce:	4770      	bx	lr

080140d0 <LOS_IntLock>:
{
 80140d0:	b580      	push	{r7, lr}
 80140d2:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80140d4:	f7ec fdf8 	bl	8000cc8 <ArchIntLock>
 80140d8:	4603      	mov	r3, r0
}
 80140da:	4618      	mov	r0, r3
 80140dc:	bd80      	pop	{r7, pc}

080140de <LOS_IntRestore>:
{
 80140de:	b580      	push	{r7, lr}
 80140e0:	b082      	sub	sp, #8
 80140e2:	af00      	add	r7, sp, #0
 80140e4:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80140e6:	6878      	ldr	r0, [r7, #4]
 80140e8:	f7ec fdf6 	bl	8000cd8 <ArchIntRestore>
}
 80140ec:	bf00      	nop
 80140ee:	3708      	adds	r7, #8
 80140f0:	46bd      	mov	sp, r7
 80140f2:	bd80      	pop	{r7, pc}

080140f4 <LOS_SpinLock>:
{
 80140f4:	b480      	push	{r7}
 80140f6:	b083      	sub	sp, #12
 80140f8:	af00      	add	r7, sp, #0
 80140fa:	6078      	str	r0, [r7, #4]
}
 80140fc:	bf00      	nop
 80140fe:	370c      	adds	r7, #12
 8014100:	46bd      	mov	sp, r7
 8014102:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014106:	4770      	bx	lr

08014108 <LOS_SpinUnlock>:
{
 8014108:	b480      	push	{r7}
 801410a:	b083      	sub	sp, #12
 801410c:	af00      	add	r7, sp, #0
 801410e:	6078      	str	r0, [r7, #4]
}
 8014110:	bf00      	nop
 8014112:	370c      	adds	r7, #12
 8014114:	46bd      	mov	sp, r7
 8014116:	f85d 7b04 	ldr.w	r7, [sp], #4
 801411a:	4770      	bx	lr

0801411c <OsPercpuGet>:
{
 801411c:	b580      	push	{r7, lr}
 801411e:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 8014120:	f7ff ffce 	bl	80140c0 <ArchCurrCpuid>
 8014124:	4602      	mov	r2, r0
 8014126:	4613      	mov	r3, r2
 8014128:	00db      	lsls	r3, r3, #3
 801412a:	4413      	add	r3, r2
 801412c:	009b      	lsls	r3, r3, #2
 801412e:	4a02      	ldr	r2, [pc, #8]	; (8014138 <OsPercpuGet+0x1c>)
 8014130:	4413      	add	r3, r2
}
 8014132:	4618      	mov	r0, r3
 8014134:	bd80      	pop	{r7, pc}
 8014136:	bf00      	nop
 8014138:	200036fc 	.word	0x200036fc

0801413c <LOS_TicklessEnable>:
#define OS_GET_CYCLECOMPENSATE(cyclesPre, cyclesCur) (((cyclesPre) > (cyclesCur)) ? \
    (((GET_SYS_CLOCK()) / (g_tickPerSecond)) - (cyclesCur)) : \
    ((((GET_SYS_CLOCK()) / (g_tickPerSecond)) << 1) - (cyclesCur)))

LITE_OS_SEC_TEXT VOID LOS_TicklessEnable(VOID)
{
 801413c:	b480      	push	{r7}
 801413e:	af00      	add	r7, sp, #0
    g_ticklessFlag = TRUE;
 8014140:	4b03      	ldr	r3, [pc, #12]	; (8014150 <LOS_TicklessEnable+0x14>)
 8014142:	2201      	movs	r2, #1
 8014144:	601a      	str	r2, [r3, #0]
}
 8014146:	bf00      	nop
 8014148:	46bd      	mov	sp, r7
 801414a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801414e:	4770      	bx	lr
 8014150:	200032d0 	.word	0x200032d0

08014154 <OsTickIrqFlagGet>:
{
    return g_ticklessFlag;
}

LITE_OS_SEC_TEXT BOOL OsTickIrqFlagGet(VOID)
{
 8014154:	b580      	push	{r7, lr}
 8014156:	af00      	add	r7, sp, #0
    return g_tickIrqFlag[ArchCurrCpuid()];
 8014158:	f7ff ffb2 	bl	80140c0 <ArchCurrCpuid>
 801415c:	4603      	mov	r3, r0
 801415e:	4a02      	ldr	r2, [pc, #8]	; (8014168 <OsTickIrqFlagGet+0x14>)
 8014160:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 8014164:	4618      	mov	r0, r3
 8014166:	bd80      	pop	{r7, pc}
 8014168:	200032d4 	.word	0x200032d4

0801416c <OsTickIrqFlagSet>:

LITE_OS_SEC_TEXT VOID OsTickIrqFlagSet(BOOL tickIrqFlag)
{
 801416c:	b580      	push	{r7, lr}
 801416e:	b082      	sub	sp, #8
 8014170:	af00      	add	r7, sp, #0
 8014172:	6078      	str	r0, [r7, #4]
    g_tickIrqFlag[ArchCurrCpuid()] = tickIrqFlag;
 8014174:	f7ff ffa4 	bl	80140c0 <ArchCurrCpuid>
 8014178:	4602      	mov	r2, r0
 801417a:	4904      	ldr	r1, [pc, #16]	; (801418c <OsTickIrqFlagSet+0x20>)
 801417c:	687b      	ldr	r3, [r7, #4]
 801417e:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
 8014182:	bf00      	nop
 8014184:	3708      	adds	r7, #8
 8014186:	46bd      	mov	sp, r7
 8014188:	bd80      	pop	{r7, pc}
 801418a:	bf00      	nop
 801418c:	200032d4 	.word	0x200032d4

08014190 <OsTicklessSleepTickGet>:

LITE_OS_SEC_TEXT UINT32 OsTicklessSleepTickGet(VOID)
{
 8014190:	b580      	push	{r7, lr}
 8014192:	af00      	add	r7, sp, #0
    return g_sleepTicks[ArchCurrCpuid()];
 8014194:	f7ff ff94 	bl	80140c0 <ArchCurrCpuid>
 8014198:	4603      	mov	r3, r0
 801419a:	4a02      	ldr	r2, [pc, #8]	; (80141a4 <OsTicklessSleepTickGet+0x14>)
 801419c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 80141a0:	4618      	mov	r0, r3
 80141a2:	bd80      	pop	{r7, pc}
 80141a4:	200032d8 	.word	0x200032d8

080141a8 <OsTicklessSleepTickSet>:

LITE_OS_SEC_TEXT VOID OsTicklessSleepTickSet(UINT32 sleeptick)
{
 80141a8:	b580      	push	{r7, lr}
 80141aa:	b082      	sub	sp, #8
 80141ac:	af00      	add	r7, sp, #0
 80141ae:	6078      	str	r0, [r7, #4]
    g_sleepTicks[ArchCurrCpuid()] = sleeptick;
 80141b0:	f7ff ff86 	bl	80140c0 <ArchCurrCpuid>
 80141b4:	4602      	mov	r2, r0
 80141b6:	4904      	ldr	r1, [pc, #16]	; (80141c8 <OsTicklessSleepTickSet+0x20>)
 80141b8:	687b      	ldr	r3, [r7, #4]
 80141ba:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
 80141be:	bf00      	nop
 80141c0:	3708      	adds	r7, #8
 80141c2:	46bd      	mov	sp, r7
 80141c4:	bd80      	pop	{r7, pc}
 80141c6:	bf00      	nop
 80141c8:	200032d8 	.word	0x200032d8

080141cc <OsSleepTicksGet>:

LITE_OS_SEC_TEXT UINT32 OsSleepTicksGet(VOID)
{
 80141cc:	b580      	push	{r7, lr}
 80141ce:	b084      	sub	sp, #16
 80141d0:	af00      	add	r7, sp, #0
    UINT32 tskSortLinkTicks, sleepTicks;

    UINT32 intSave = LOS_IntLock();
 80141d2:	f7ff ff7d 	bl	80140d0 <LOS_IntLock>
 80141d6:	6038      	str	r0, [r7, #0]
    LOS_SpinLock(&g_taskSpin);
 80141d8:	4814      	ldr	r0, [pc, #80]	; (801422c <OsSleepTicksGet+0x60>)
 80141da:	f7ff ff8b 	bl	80140f4 <LOS_SpinLock>
    tskSortLinkTicks = OsSortLinkGetNextExpireTime(&OsPercpuGet()->taskSortLink);
 80141de:	f7ff ff9d 	bl	801411c <OsPercpuGet>
 80141e2:	4603      	mov	r3, r0
 80141e4:	4618      	mov	r0, r3
 80141e6:	f7f6 f8cb 	bl	800a380 <OsSortLinkGetNextExpireTime>
 80141ea:	6078      	str	r0, [r7, #4]
    LOS_SpinUnlock(&g_taskSpin);
 80141ec:	480f      	ldr	r0, [pc, #60]	; (801422c <OsSleepTicksGet+0x60>)
 80141ee:	f7ff ff8b 	bl	8014108 <LOS_SpinUnlock>

#ifdef LOSCFG_BASE_CORE_SWTMR
    UINT32 swtmrSortLinkTicks;
    LOS_SpinLock(&g_swtmrSpin);
 80141f2:	480f      	ldr	r0, [pc, #60]	; (8014230 <OsSleepTicksGet+0x64>)
 80141f4:	f7ff ff7e 	bl	80140f4 <LOS_SpinLock>
    swtmrSortLinkTicks = OsSortLinkGetNextExpireTime(&OsPercpuGet()->swtmrSortLink);
 80141f8:	f7ff ff90 	bl	801411c <OsPercpuGet>
 80141fc:	4603      	mov	r3, r0
 80141fe:	3308      	adds	r3, #8
 8014200:	4618      	mov	r0, r3
 8014202:	f7f6 f8bd 	bl	800a380 <OsSortLinkGetNextExpireTime>
 8014206:	60b8      	str	r0, [r7, #8]
    LOS_SpinUnlock(&g_swtmrSpin);
 8014208:	4809      	ldr	r0, [pc, #36]	; (8014230 <OsSleepTicksGet+0x64>)
 801420a:	f7ff ff7d 	bl	8014108 <LOS_SpinUnlock>
    sleepTicks = (tskSortLinkTicks < swtmrSortLinkTicks) ? tskSortLinkTicks : swtmrSortLinkTicks;
 801420e:	68ba      	ldr	r2, [r7, #8]
 8014210:	687b      	ldr	r3, [r7, #4]
 8014212:	4293      	cmp	r3, r2
 8014214:	bf28      	it	cs
 8014216:	4613      	movcs	r3, r2
 8014218:	60fb      	str	r3, [r7, #12]
#else
    sleepTicks = tskSortLinkTicks;
#endif

    LOS_IntRestore(intSave);
 801421a:	6838      	ldr	r0, [r7, #0]
 801421c:	f7ff ff5f 	bl	80140de <LOS_IntRestore>
    return sleepTicks;
 8014220:	68fb      	ldr	r3, [r7, #12]
}
 8014222:	4618      	mov	r0, r3
 8014224:	3710      	adds	r7, #16
 8014226:	46bd      	mov	sp, r7
 8014228:	bd80      	pop	{r7, pc}
 801422a:	bf00      	nop
 801422c:	20000770 	.word	0x20000770
 8014230:	200007a0 	.word	0x200007a0

08014234 <OsSysTimeUpdate>:

LITE_OS_SEC_TEXT VOID OsSysTimeUpdate(UINT32 sleepTicks)
{
 8014234:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014236:	b085      	sub	sp, #20
 8014238:	af00      	add	r7, sp, #0
 801423a:	6078      	str	r0, [r7, #4]
    UINT32 intSave;

    if (sleepTicks == 0) {
 801423c:	687b      	ldr	r3, [r7, #4]
 801423e:	2b00      	cmp	r3, #0
 8014240:	d036      	beq.n	80142b0 <OsSysTimeUpdate+0x7c>
        return;
    }

    intSave = LOS_IntLock();
 8014242:	f7ff ff45 	bl	80140d0 <LOS_IntLock>
 8014246:	60f8      	str	r0, [r7, #12]
    g_tickCount[ArchCurrCpuid()] += (sleepTicks - 1);
 8014248:	f7ff ff3a 	bl	80140c0 <ArchCurrCpuid>
 801424c:	4606      	mov	r6, r0
 801424e:	4a1a      	ldr	r2, [pc, #104]	; (80142b8 <OsSysTimeUpdate+0x84>)
 8014250:	00f3      	lsls	r3, r6, #3
 8014252:	4413      	add	r3, r2
 8014254:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014258:	687b      	ldr	r3, [r7, #4]
 801425a:	3b01      	subs	r3, #1
 801425c:	461a      	mov	r2, r3
 801425e:	f04f 0300 	mov.w	r3, #0
 8014262:	1884      	adds	r4, r0, r2
 8014264:	eb41 0503 	adc.w	r5, r1, r3
 8014268:	4a13      	ldr	r2, [pc, #76]	; (80142b8 <OsSysTimeUpdate+0x84>)
 801426a:	00f3      	lsls	r3, r6, #3
 801426c:	4413      	add	r3, r2
 801426e:	e9c3 4500 	strd	r4, r5, [r3]
    LOS_SpinLock(&g_taskSpin);
 8014272:	4812      	ldr	r0, [pc, #72]	; (80142bc <OsSysTimeUpdate+0x88>)
 8014274:	f7ff ff3e 	bl	80140f4 <LOS_SpinLock>
    OsSortLinkUpdateExpireTime(sleepTicks, &OsPercpuGet()->taskSortLink);
 8014278:	f7ff ff50 	bl	801411c <OsPercpuGet>
 801427c:	4603      	mov	r3, r0
 801427e:	4619      	mov	r1, r3
 8014280:	6878      	ldr	r0, [r7, #4]
 8014282:	f7f6 f8d5 	bl	800a430 <OsSortLinkUpdateExpireTime>
    LOS_SpinUnlock(&g_taskSpin);
 8014286:	480d      	ldr	r0, [pc, #52]	; (80142bc <OsSysTimeUpdate+0x88>)
 8014288:	f7ff ff3e 	bl	8014108 <LOS_SpinUnlock>

#ifdef LOSCFG_BASE_CORE_SWTMR
    LOS_SpinLock(&g_swtmrSpin);
 801428c:	480c      	ldr	r0, [pc, #48]	; (80142c0 <OsSysTimeUpdate+0x8c>)
 801428e:	f7ff ff31 	bl	80140f4 <LOS_SpinLock>
    OsSortLinkUpdateExpireTime(sleepTicks, &OsPercpuGet()->swtmrSortLink);
 8014292:	f7ff ff43 	bl	801411c <OsPercpuGet>
 8014296:	4603      	mov	r3, r0
 8014298:	3308      	adds	r3, #8
 801429a:	4619      	mov	r1, r3
 801429c:	6878      	ldr	r0, [r7, #4]
 801429e:	f7f6 f8c7 	bl	800a430 <OsSortLinkUpdateExpireTime>
    LOS_SpinUnlock(&g_swtmrSpin);
 80142a2:	4807      	ldr	r0, [pc, #28]	; (80142c0 <OsSysTimeUpdate+0x8c>)
 80142a4:	f7ff ff30 	bl	8014108 <LOS_SpinUnlock>
#endif

    LOS_IntRestore(intSave);
 80142a8:	68f8      	ldr	r0, [r7, #12]
 80142aa:	f7ff ff18 	bl	80140de <LOS_IntRestore>
 80142ae:	e000      	b.n	80142b2 <OsSysTimeUpdate+0x7e>
        return;
 80142b0:	bf00      	nop
}
 80142b2:	3714      	adds	r7, #20
 80142b4:	46bd      	mov	sp, r7
 80142b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80142b8:	20000780 	.word	0x20000780
 80142bc:	20000770 	.word	0x20000770
 80142c0:	200007a0 	.word	0x200007a0

080142c4 <OsTicklessUpdate>:

VOID OsTicklessUpdate(UINT32 irqnum)
{
 80142c4:	b580      	push	{r7, lr}
 80142c6:	b088      	sub	sp, #32
 80142c8:	af00      	add	r7, sp, #0
 80142ca:	6078      	str	r0, [r7, #4]
    UINT32 cycles, ticks;
    UINT32 cyclesPertick;
    UINT32 sleepTicks;
    UINT32 intSave = LOS_IntLock();
 80142cc:	f7ff ff00 	bl	80140d0 <LOS_IntLock>
 80142d0:	60f8      	str	r0, [r7, #12]

    sleepTicks = OsTicklessSleepTickGet();
 80142d2:	f7ff ff5d 	bl	8014190 <OsTicklessSleepTickGet>
 80142d6:	6138      	str	r0, [r7, #16]
    if (sleepTicks == 0) {
 80142d8:	693b      	ldr	r3, [r7, #16]
 80142da:	2b00      	cmp	r3, #0
 80142dc:	d103      	bne.n	80142e6 <OsTicklessUpdate+0x22>
        LOS_IntRestore(intSave);
 80142de:	68f8      	ldr	r0, [r7, #12]
 80142e0:	f7ff fefd 	bl	80140de <LOS_IntRestore>
        return;
 80142e4:	e03e      	b.n	8014364 <OsTicklessUpdate+0xa0>
    }

    cyclesPertick = GET_SYS_CLOCK() / LOSCFG_BASE_CORE_TICK_PER_SECOND;
 80142e6:	4b21      	ldr	r3, [pc, #132]	; (801436c <OsTicklessUpdate+0xa8>)
 80142e8:	681b      	ldr	r3, [r3, #0]
 80142ea:	4a21      	ldr	r2, [pc, #132]	; (8014370 <OsTicklessUpdate+0xac>)
 80142ec:	fba2 2303 	umull	r2, r3, r2, r3
 80142f0:	099b      	lsrs	r3, r3, #6
 80142f2:	617b      	str	r3, [r7, #20]
    if (irqnum == OS_TICK_INT_NUM) {
 80142f4:	687b      	ldr	r3, [r7, #4]
 80142f6:	2b0f      	cmp	r3, #15
 80142f8:	d103      	bne.n	8014302 <OsTicklessUpdate+0x3e>
        OsSysTimeUpdate(sleepTicks);
 80142fa:	6938      	ldr	r0, [r7, #16]
 80142fc:	f7ff ff9a 	bl	8014234 <OsSysTimeUpdate>
 8014300:	e02a      	b.n	8014358 <OsTicklessUpdate+0x94>
    } else {
        cycles = HalClockGetTickTimerCycles();
 8014302:	f7fc fa3d 	bl	8010780 <HalClockGetTickTimerCycles>
 8014306:	61b8      	str	r0, [r7, #24]
        cycles = (sleepTicks * cyclesPertick) - cycles;
 8014308:	693b      	ldr	r3, [r7, #16]
 801430a:	697a      	ldr	r2, [r7, #20]
 801430c:	fb02 f203 	mul.w	r2, r2, r3
 8014310:	69bb      	ldr	r3, [r7, #24]
 8014312:	1ad3      	subs	r3, r2, r3
 8014314:	61bb      	str	r3, [r7, #24]
        ticks = cycles / cyclesPertick;
 8014316:	69ba      	ldr	r2, [r7, #24]
 8014318:	697b      	ldr	r3, [r7, #20]
 801431a:	fbb2 f3f3 	udiv	r3, r2, r3
 801431e:	61fb      	str	r3, [r7, #28]
        if (ticks < sleepTicks) {
 8014320:	69fa      	ldr	r2, [r7, #28]
 8014322:	693b      	ldr	r3, [r7, #16]
 8014324:	429a      	cmp	r2, r3
 8014326:	d214      	bcs.n	8014352 <OsTicklessUpdate+0x8e>
            cycles = cycles % cyclesPertick;
 8014328:	69bb      	ldr	r3, [r7, #24]
 801432a:	697a      	ldr	r2, [r7, #20]
 801432c:	fbb3 f2f2 	udiv	r2, r3, r2
 8014330:	6979      	ldr	r1, [r7, #20]
 8014332:	fb01 f202 	mul.w	r2, r1, r2
 8014336:	1a9b      	subs	r3, r3, r2
 8014338:	61bb      	str	r3, [r7, #24]
            OsSysTimeUpdate(ticks + 1);
 801433a:	69fb      	ldr	r3, [r7, #28]
 801433c:	3301      	adds	r3, #1
 801433e:	4618      	mov	r0, r3
 8014340:	f7ff ff78 	bl	8014234 <OsSysTimeUpdate>
            HalClockTickTimerReload(cyclesPertick - cycles);
 8014344:	697a      	ldr	r2, [r7, #20]
 8014346:	69bb      	ldr	r3, [r7, #24]
 8014348:	1ad3      	subs	r3, r2, r3
 801434a:	4618      	mov	r0, r3
 801434c:	f7fc fa24 	bl	8010798 <HalClockTickTimerReload>
 8014350:	e002      	b.n	8014358 <OsTicklessUpdate+0x94>
            /*
             * If ticks is greater or equal to sleepTicks, it means the tick has already
             * arrived, it should compensate with the sleepTicks just as that will be done
             * in tick handler.
             */
            OsSysTimeUpdate(sleepTicks);
 8014352:	6938      	ldr	r0, [r7, #16]
 8014354:	f7ff ff6e 	bl	8014234 <OsSysTimeUpdate>
        }
    }
    OsTicklessSleepTickSet(0);
 8014358:	2000      	movs	r0, #0
 801435a:	f7ff ff25 	bl	80141a8 <OsTicklessSleepTickSet>

    LOS_IntRestore(intSave);
 801435e:	68f8      	ldr	r0, [r7, #12]
 8014360:	f7ff febd 	bl	80140de <LOS_IntRestore>
}
 8014364:	3720      	adds	r7, #32
 8014366:	46bd      	mov	sp, r7
 8014368:	bd80      	pop	{r7, pc}
 801436a:	bf00      	nop
 801436c:	200036e0 	.word	0x200036e0
 8014370:	10624dd3 	.word	0x10624dd3

08014374 <OsTicklessStart>:

VOID OsTicklessStart(VOID)
{
 8014374:	b580      	push	{r7, lr}
 8014376:	b088      	sub	sp, #32
 8014378:	af00      	add	r7, sp, #0
    UINT32 intSave;
    /*
     * The system has already started, GET_SYS_CLOCK() muse get a non-zero value and greater or equal to
     * LOSCFG_BASE_CORE_TICK_PER_SECOND (see OsTickInit). So the cyclesPerTick won't be zero.
     */
    UINT32 cyclesPerTick = GET_SYS_CLOCK() / LOSCFG_BASE_CORE_TICK_PER_SECOND;
 801437a:	4b29      	ldr	r3, [pc, #164]	; (8014420 <OsTicklessStart+0xac>)
 801437c:	681b      	ldr	r3, [r3, #0]
 801437e:	4a29      	ldr	r2, [pc, #164]	; (8014424 <OsTicklessStart+0xb0>)
 8014380:	fba2 2303 	umull	r2, r3, r2, r3
 8014384:	099b      	lsrs	r3, r3, #6
 8014386:	607b      	str	r3, [r7, #4]
    UINT32 maxTicks = OS_NULL_INT / cyclesPerTick;
 8014388:	f04f 32ff 	mov.w	r2, #4294967295
 801438c:	687b      	ldr	r3, [r7, #4]
 801438e:	fbb2 f3f3 	udiv	r3, r2, r3
 8014392:	60bb      	str	r3, [r7, #8]
    UINT32 sleepTicks;
    UINT32 cycles, cyclesPre, cyclesCur, cycleCompensate;

    intSave = LOS_IntLock();
 8014394:	f7ff fe9c 	bl	80140d0 <LOS_IntLock>
 8014398:	60f8      	str	r0, [r7, #12]
    /*
     * The sleep tick may be changed afterwards, cause interrupt has been disabled, the sleep tick
     * may increase but cannot decrease. Thus there's no need to spin here.
     */
    sleepTicks = OsSleepTicksGet();
 801439a:	f7ff ff17 	bl	80141cc <OsSleepTicksGet>
 801439e:	6038      	str	r0, [r7, #0]
    cyclesPre = HalClockGetTickTimerCycles();
 80143a0:	f7fc f9ee 	bl	8010780 <HalClockGetTickTimerCycles>
 80143a4:	6138      	str	r0, [r7, #16]

    if (sleepTicks > 1) {
 80143a6:	683b      	ldr	r3, [r7, #0]
 80143a8:	2b01      	cmp	r3, #1
 80143aa:	d931      	bls.n	8014410 <OsTicklessStart+0x9c>
        if (sleepTicks >= maxTicks) {
 80143ac:	683a      	ldr	r2, [r7, #0]
 80143ae:	68bb      	ldr	r3, [r7, #8]
 80143b0:	429a      	cmp	r2, r3
 80143b2:	d301      	bcc.n	80143b8 <OsTicklessStart+0x44>
            sleepTicks = maxTicks;
 80143b4:	68bb      	ldr	r3, [r7, #8]
 80143b6:	603b      	str	r3, [r7, #0]
        }
        cycles = sleepTicks * cyclesPerTick;
 80143b8:	683b      	ldr	r3, [r7, #0]
 80143ba:	687a      	ldr	r2, [r7, #4]
 80143bc:	fb02 f303 	mul.w	r3, r2, r3
 80143c0:	617b      	str	r3, [r7, #20]
        cyclesCur = HalClockGetTickTimerCycles();
 80143c2:	f7fc f9dd 	bl	8010780 <HalClockGetTickTimerCycles>
 80143c6:	61b8      	str	r0, [r7, #24]
        cycleCompensate = OS_GET_CYCLECOMPENSATE(cyclesPre, cyclesCur);
 80143c8:	693a      	ldr	r2, [r7, #16]
 80143ca:	69bb      	ldr	r3, [r7, #24]
 80143cc:	429a      	cmp	r2, r3
 80143ce:	d908      	bls.n	80143e2 <OsTicklessStart+0x6e>
 80143d0:	4b13      	ldr	r3, [pc, #76]	; (8014420 <OsTicklessStart+0xac>)
 80143d2:	681a      	ldr	r2, [r3, #0]
 80143d4:	4b14      	ldr	r3, [pc, #80]	; (8014428 <OsTicklessStart+0xb4>)
 80143d6:	681b      	ldr	r3, [r3, #0]
 80143d8:	fbb2 f2f3 	udiv	r2, r2, r3
 80143dc:	69bb      	ldr	r3, [r7, #24]
 80143de:	1ad3      	subs	r3, r2, r3
 80143e0:	e008      	b.n	80143f4 <OsTicklessStart+0x80>
 80143e2:	4b0f      	ldr	r3, [pc, #60]	; (8014420 <OsTicklessStart+0xac>)
 80143e4:	681a      	ldr	r2, [r3, #0]
 80143e6:	4b10      	ldr	r3, [pc, #64]	; (8014428 <OsTicklessStart+0xb4>)
 80143e8:	681b      	ldr	r3, [r3, #0]
 80143ea:	fbb2 f3f3 	udiv	r3, r2, r3
 80143ee:	005a      	lsls	r2, r3, #1
 80143f0:	69bb      	ldr	r3, [r7, #24]
 80143f2:	1ad3      	subs	r3, r2, r3
 80143f4:	61fb      	str	r3, [r7, #28]
        HalClockTickTimerReload(cycles - cycleCompensate);
 80143f6:	697a      	ldr	r2, [r7, #20]
 80143f8:	69fb      	ldr	r3, [r7, #28]
 80143fa:	1ad3      	subs	r3, r2, r3
 80143fc:	4618      	mov	r0, r3
 80143fe:	f7fc f9cb 	bl	8010798 <HalClockTickTimerReload>
        OsTicklessSleepTickSet(sleepTicks);
 8014402:	6838      	ldr	r0, [r7, #0]
 8014404:	f7ff fed0 	bl	80141a8 <OsTicklessSleepTickSet>
        LOS_IntRestore(intSave);
 8014408:	68f8      	ldr	r0, [r7, #12]
 801440a:	f7ff fe68 	bl	80140de <LOS_IntRestore>

        return;
 801440e:	e003      	b.n	8014418 <OsTicklessStart+0xa4>
    }
    LOS_IntRestore(intSave);
 8014410:	68f8      	ldr	r0, [r7, #12]
 8014412:	f7ff fe64 	bl	80140de <LOS_IntRestore>
    return;
 8014416:	bf00      	nop
}
 8014418:	3720      	adds	r7, #32
 801441a:	46bd      	mov	sp, r7
 801441c:	bd80      	pop	{r7, pc}
 801441e:	bf00      	nop
 8014420:	200036e0 	.word	0x200036e0
 8014424:	10624dd3 	.word	0x10624dd3
 8014428:	200036e4 	.word	0x200036e4

0801442c <OsTicklessOpen>:

VOID OsTicklessOpen(VOID)
{
 801442c:	b580      	push	{r7, lr}
 801442e:	af00      	add	r7, sp, #0
    if (OsTickIrqFlagGet()) {
 8014430:	f7ff fe90 	bl	8014154 <OsTickIrqFlagGet>
 8014434:	4603      	mov	r3, r0
 8014436:	2b00      	cmp	r3, #0
 8014438:	d004      	beq.n	8014444 <OsTicklessOpen+0x18>
        OsTickIrqFlagSet(0);
 801443a:	2000      	movs	r0, #0
 801443c:	f7ff fe96 	bl	801416c <OsTickIrqFlagSet>
        OsTicklessStart();
 8014440:	f7ff ff98 	bl	8014374 <OsTicklessStart>
    }
}
 8014444:	bf00      	nop
 8014446:	bd80      	pop	{r7, pc}

08014448 <ArchCurrCpuid>:
{
 8014448:	b480      	push	{r7}
 801444a:	af00      	add	r7, sp, #0
    return 0;
 801444c:	2300      	movs	r3, #0
}
 801444e:	4618      	mov	r0, r3
 8014450:	46bd      	mov	sp, r7
 8014452:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014456:	4770      	bx	lr

08014458 <LOS_IntLock>:
{
 8014458:	b580      	push	{r7, lr}
 801445a:	af00      	add	r7, sp, #0
    return ArchIntLock();
 801445c:	f7ec fc34 	bl	8000cc8 <ArchIntLock>
 8014460:	4603      	mov	r3, r0
}
 8014462:	4618      	mov	r0, r3
 8014464:	bd80      	pop	{r7, pc}

08014466 <LOS_IntRestore>:
{
 8014466:	b580      	push	{r7, lr}
 8014468:	b082      	sub	sp, #8
 801446a:	af00      	add	r7, sp, #0
 801446c:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 801446e:	6878      	ldr	r0, [r7, #4]
 8014470:	f7ec fc32 	bl	8000cd8 <ArchIntRestore>
}
 8014474:	bf00      	nop
 8014476:	3708      	adds	r7, #8
 8014478:	46bd      	mov	sp, r7
 801447a:	bd80      	pop	{r7, pc}

0801447c <ArchCurrTaskGet>:
{
 801447c:	b480      	push	{r7}
 801447e:	af00      	add	r7, sp, #0
    return g_runTask;
 8014480:	4b03      	ldr	r3, [pc, #12]	; (8014490 <ArchCurrTaskGet+0x14>)
 8014482:	681b      	ldr	r3, [r3, #0]
}
 8014484:	4618      	mov	r0, r3
 8014486:	46bd      	mov	sp, r7
 8014488:	f85d 7b04 	ldr.w	r7, [sp], #4
 801448c:	4770      	bx	lr
 801448e:	bf00      	nop
 8014490:	200033cc 	.word	0x200033cc

08014494 <OsCurrTaskGet>:
{
 8014494:	b580      	push	{r7, lr}
 8014496:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 8014498:	f7ff fff0 	bl	801447c <ArchCurrTaskGet>
 801449c:	4603      	mov	r3, r0
}
 801449e:	4618      	mov	r0, r3
 80144a0:	bd80      	pop	{r7, pc}
	...

080144a4 <OsCpupCBGet>:

#define CPUP_PRE_POS(pos) (((pos) == 0) ? (OS_CPUP_HISTORY_RECORD_NUM - 1) : ((pos) - 1))
#define CPUP_POST_POS(pos) (((pos) == (OS_CPUP_HISTORY_RECORD_NUM - 1)) ? 0 : ((pos) + 1))

LITE_OS_SEC_TEXT_INIT OsCpupCB *OsCpupCBGet(UINT32 index)
{
 80144a4:	b480      	push	{r7}
 80144a6:	b083      	sub	sp, #12
 80144a8:	af00      	add	r7, sp, #0
 80144aa:	6078      	str	r0, [r7, #4]
    return &g_cpup[index];
 80144ac:	4b06      	ldr	r3, [pc, #24]	; (80144c8 <OsCpupCBGet+0x24>)
 80144ae:	6819      	ldr	r1, [r3, #0]
 80144b0:	687a      	ldr	r2, [r7, #4]
 80144b2:	4613      	mov	r3, r2
 80144b4:	011b      	lsls	r3, r3, #4
 80144b6:	1a9b      	subs	r3, r3, r2
 80144b8:	00db      	lsls	r3, r3, #3
 80144ba:	440b      	add	r3, r1
}
 80144bc:	4618      	mov	r0, r3
 80144be:	370c      	adds	r7, #12
 80144c0:	46bd      	mov	sp, r7
 80144c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80144c6:	4770      	bx	lr
 80144c8:	200032e0 	.word	0x200032e0

080144cc <OsCpupGuard>:

LITE_OS_SEC_TEXT_INIT VOID OsCpupGuard(VOID)
{
 80144cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80144d0:	b089      	sub	sp, #36	; 0x24
 80144d2:	af00      	add	r7, sp, #0
    UINT16 prevPos = g_hisPos;
 80144d4:	4b5d      	ldr	r3, [pc, #372]	; (801464c <OsCpupGuard+0x180>)
 80144d6:	881b      	ldrh	r3, [r3, #0]
 80144d8:	823b      	strh	r3, [r7, #16]
    UINT16 loop;
    UINT16 runTaskId;
    UINT64 curCycle;
    UINT32 intSave;

    if (g_cpupInitFlg == 0) {
 80144da:	4b5d      	ldr	r3, [pc, #372]	; (8014650 <OsCpupGuard+0x184>)
 80144dc:	881b      	ldrh	r3, [r3, #0]
 80144de:	2b00      	cmp	r3, #0
 80144e0:	f000 80ae 	beq.w	8014640 <OsCpupGuard+0x174>
        return;
    }
    intSave = LOS_IntLock();
 80144e4:	f7ff ffb8 	bl	8014458 <LOS_IntLock>
 80144e8:	6178      	str	r0, [r7, #20]
    curCycle = OsCpupGetCycle();
 80144ea:	f000 f957 	bl	801479c <OsCpupGetCycle>
 80144ee:	e9c7 0106 	strd	r0, r1, [r7, #24]

    g_hisPos = CPUP_POST_POS(g_hisPos);
 80144f2:	4b56      	ldr	r3, [pc, #344]	; (801464c <OsCpupGuard+0x180>)
 80144f4:	881b      	ldrh	r3, [r3, #0]
 80144f6:	2b0a      	cmp	r3, #10
 80144f8:	d004      	beq.n	8014504 <OsCpupGuard+0x38>
 80144fa:	4b54      	ldr	r3, [pc, #336]	; (801464c <OsCpupGuard+0x180>)
 80144fc:	881b      	ldrh	r3, [r3, #0]
 80144fe:	3301      	adds	r3, #1
 8014500:	b29b      	uxth	r3, r3
 8014502:	e000      	b.n	8014506 <OsCpupGuard+0x3a>
 8014504:	2300      	movs	r3, #0
 8014506:	4a51      	ldr	r2, [pc, #324]	; (801464c <OsCpupGuard+0x180>)
 8014508:	8013      	strh	r3, [r2, #0]
    cpuHistoryTime[prevPos] = curCycle;
 801450a:	8a3b      	ldrh	r3, [r7, #16]
 801450c:	4a51      	ldr	r2, [pc, #324]	; (8014654 <OsCpupGuard+0x188>)
 801450e:	00db      	lsls	r3, r3, #3
 8014510:	18d1      	adds	r1, r2, r3
 8014512:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8014516:	e9c1 2300 	strd	r2, r3, [r1]

    for (loop = 0; loop < g_cpupMaxNum; loop++) {
 801451a:	2300      	movs	r3, #0
 801451c:	81fb      	strh	r3, [r7, #14]
 801451e:	e01a      	b.n	8014556 <OsCpupGuard+0x8a>
        g_cpup[loop].historyTime[prevPos] = g_cpup[loop].allTime;
 8014520:	4b4d      	ldr	r3, [pc, #308]	; (8014658 <OsCpupGuard+0x18c>)
 8014522:	6819      	ldr	r1, [r3, #0]
 8014524:	89fa      	ldrh	r2, [r7, #14]
 8014526:	4613      	mov	r3, r2
 8014528:	011b      	lsls	r3, r3, #4
 801452a:	1a9b      	subs	r3, r3, r2
 801452c:	00db      	lsls	r3, r3, #3
 801452e:	18ce      	adds	r6, r1, r3
 8014530:	4b49      	ldr	r3, [pc, #292]	; (8014658 <OsCpupGuard+0x18c>)
 8014532:	6819      	ldr	r1, [r3, #0]
 8014534:	89fa      	ldrh	r2, [r7, #14]
 8014536:	4613      	mov	r3, r2
 8014538:	011b      	lsls	r3, r3, #4
 801453a:	1a9b      	subs	r3, r3, r2
 801453c:	00db      	lsls	r3, r3, #3
 801453e:	18c8      	adds	r0, r1, r3
 8014540:	8a39      	ldrh	r1, [r7, #16]
 8014542:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8014546:	3103      	adds	r1, #3
 8014548:	00c9      	lsls	r1, r1, #3
 801454a:	4401      	add	r1, r0
 801454c:	e9c1 2300 	strd	r2, r3, [r1]
    for (loop = 0; loop < g_cpupMaxNum; loop++) {
 8014550:	89fb      	ldrh	r3, [r7, #14]
 8014552:	3301      	adds	r3, #1
 8014554:	81fb      	strh	r3, [r7, #14]
 8014556:	4b41      	ldr	r3, [pc, #260]	; (801465c <OsCpupGuard+0x190>)
 8014558:	881b      	ldrh	r3, [r3, #0]
 801455a:	89fa      	ldrh	r2, [r7, #14]
 801455c:	429a      	cmp	r2, r3
 801455e:	d3df      	bcc.n	8014520 <OsCpupGuard+0x54>
    }

    for (loop = 0; loop < LOSCFG_KERNEL_CORE_NUM; loop++) {
 8014560:	2300      	movs	r3, #0
 8014562:	81fb      	strh	r3, [r7, #14]
 8014564:	e065      	b.n	8014632 <OsCpupGuard+0x166>
        runTaskId = runningTasks[loop];
 8014566:	89fb      	ldrh	r3, [r7, #14]
 8014568:	4a3d      	ldr	r2, [pc, #244]	; (8014660 <OsCpupGuard+0x194>)
 801456a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801456e:	827b      	strh	r3, [r7, #18]
        /* reacquire the cycle to prevent flip */
        curCycle = OsCpupGetCycle();
 8014570:	f000 f914 	bl	801479c <OsCpupGetCycle>
 8014574:	e9c7 0106 	strd	r0, r1, [r7, #24]
        g_cpup[runTaskId].historyTime[prevPos] += curCycle - g_cpup[runTaskId].startTime;
 8014578:	4b37      	ldr	r3, [pc, #220]	; (8014658 <OsCpupGuard+0x18c>)
 801457a:	6819      	ldr	r1, [r3, #0]
 801457c:	8a7a      	ldrh	r2, [r7, #18]
 801457e:	4613      	mov	r3, r2
 8014580:	011b      	lsls	r3, r3, #4
 8014582:	1a9b      	subs	r3, r3, r2
 8014584:	00db      	lsls	r3, r3, #3
 8014586:	18ca      	adds	r2, r1, r3
 8014588:	8a3b      	ldrh	r3, [r7, #16]
 801458a:	3303      	adds	r3, #3
 801458c:	00db      	lsls	r3, r3, #3
 801458e:	4413      	add	r3, r2
 8014590:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014594:	4b30      	ldr	r3, [pc, #192]	; (8014658 <OsCpupGuard+0x18c>)
 8014596:	681e      	ldr	r6, [r3, #0]
 8014598:	8a7a      	ldrh	r2, [r7, #18]
 801459a:	4613      	mov	r3, r2
 801459c:	011b      	lsls	r3, r3, #4
 801459e:	1a9b      	subs	r3, r3, r2
 80145a0:	00db      	lsls	r3, r3, #3
 80145a2:	4433      	add	r3, r6
 80145a4:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80145a8:	e9d7 8906 	ldrd	r8, r9, [r7, #24]
 80145ac:	ebb8 0402 	subs.w	r4, r8, r2
 80145b0:	eb69 0503 	sbc.w	r5, r9, r3
 80145b4:	4b28      	ldr	r3, [pc, #160]	; (8014658 <OsCpupGuard+0x18c>)
 80145b6:	681e      	ldr	r6, [r3, #0]
 80145b8:	8a7a      	ldrh	r2, [r7, #18]
 80145ba:	4613      	mov	r3, r2
 80145bc:	011b      	lsls	r3, r3, #4
 80145be:	1a9b      	subs	r3, r3, r2
 80145c0:	00db      	lsls	r3, r3, #3
 80145c2:	18f2      	adds	r2, r6, r3
 80145c4:	8a3b      	ldrh	r3, [r7, #16]
 80145c6:	eb10 0a04 	adds.w	sl, r0, r4
 80145ca:	eb41 0b05 	adc.w	fp, r1, r5
 80145ce:	3303      	adds	r3, #3
 80145d0:	00db      	lsls	r3, r3, #3
 80145d2:	4413      	add	r3, r2
 80145d4:	e9c3 ab00 	strd	sl, fp, [r3]
#ifdef LOSCFG_CPUP_INCLUDE_IRQ
        g_cpup[runTaskId].historyTime[prevPos] -= g_timeInIrqPerTskSwitch[loop];
 80145d8:	4b1f      	ldr	r3, [pc, #124]	; (8014658 <OsCpupGuard+0x18c>)
 80145da:	6819      	ldr	r1, [r3, #0]
 80145dc:	8a7a      	ldrh	r2, [r7, #18]
 80145de:	4613      	mov	r3, r2
 80145e0:	011b      	lsls	r3, r3, #4
 80145e2:	1a9b      	subs	r3, r3, r2
 80145e4:	00db      	lsls	r3, r3, #3
 80145e6:	18ca      	adds	r2, r1, r3
 80145e8:	8a3b      	ldrh	r3, [r7, #16]
 80145ea:	3303      	adds	r3, #3
 80145ec:	00db      	lsls	r3, r3, #3
 80145ee:	4413      	add	r3, r2
 80145f0:	e9d3 8900 	ldrd	r8, r9, [r3]
 80145f4:	89fb      	ldrh	r3, [r7, #14]
 80145f6:	4a1b      	ldr	r2, [pc, #108]	; (8014664 <OsCpupGuard+0x198>)
 80145f8:	00db      	lsls	r3, r3, #3
 80145fa:	4413      	add	r3, r2
 80145fc:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014600:	4b15      	ldr	r3, [pc, #84]	; (8014658 <OsCpupGuard+0x18c>)
 8014602:	681e      	ldr	r6, [r3, #0]
 8014604:	8a7a      	ldrh	r2, [r7, #18]
 8014606:	4613      	mov	r3, r2
 8014608:	011b      	lsls	r3, r3, #4
 801460a:	1a9b      	subs	r3, r3, r2
 801460c:	00db      	lsls	r3, r3, #3
 801460e:	18f2      	adds	r2, r6, r3
 8014610:	8a3b      	ldrh	r3, [r7, #16]
 8014612:	ebb8 0600 	subs.w	r6, r8, r0
 8014616:	603e      	str	r6, [r7, #0]
 8014618:	eb69 0101 	sbc.w	r1, r9, r1
 801461c:	6079      	str	r1, [r7, #4]
 801461e:	3303      	adds	r3, #3
 8014620:	00db      	lsls	r3, r3, #3
 8014622:	4413      	add	r3, r2
 8014624:	e9d7 1200 	ldrd	r1, r2, [r7]
 8014628:	e9c3 1200 	strd	r1, r2, [r3]
    for (loop = 0; loop < LOSCFG_KERNEL_CORE_NUM; loop++) {
 801462c:	89fb      	ldrh	r3, [r7, #14]
 801462e:	3301      	adds	r3, #1
 8014630:	81fb      	strh	r3, [r7, #14]
 8014632:	89fb      	ldrh	r3, [r7, #14]
 8014634:	2b00      	cmp	r3, #0
 8014636:	d096      	beq.n	8014566 <OsCpupGuard+0x9a>
#endif
    }

    LOS_IntRestore(intSave);
 8014638:	6978      	ldr	r0, [r7, #20]
 801463a:	f7ff ff14 	bl	8014466 <LOS_IntRestore>
 801463e:	e000      	b.n	8014642 <OsCpupGuard+0x176>
        return;
 8014640:	bf00      	nop
}
 8014642:	3724      	adds	r7, #36	; 0x24
 8014644:	46bd      	mov	sp, r7
 8014646:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801464a:	bf00      	nop
 801464c:	200032e8 	.word	0x200032e8
 8014650:	200032de 	.word	0x200032de
 8014654:	200032f0 	.word	0x200032f0
 8014658:	200032e0 	.word	0x200032e0
 801465c:	200032e4 	.word	0x200032e4
 8014660:	200004a0 	.word	0x200004a0
 8014664:	20003770 	.word	0x20003770

08014668 <OsCpupGuardCreator>:

LITE_OS_SEC_TEXT_INIT VOID OsCpupGuardCreator(VOID)
{
 8014668:	b580      	push	{r7, lr}
 801466a:	b082      	sub	sp, #8
 801466c:	af02      	add	r7, sp, #8
    (VOID)LOS_SwtmrCreate(LOSCFG_BASE_CORE_TICK_PER_SECOND, LOS_SWTMR_MODE_PERIOD,
 801466e:	2300      	movs	r3, #0
 8014670:	9300      	str	r3, [sp, #0]
 8014672:	4b07      	ldr	r3, [pc, #28]	; (8014690 <OsCpupGuardCreator+0x28>)
 8014674:	4a07      	ldr	r2, [pc, #28]	; (8014694 <OsCpupGuardCreator+0x2c>)
 8014676:	2101      	movs	r1, #1
 8014678:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801467c:	f7f1 faa4 	bl	8005bc8 <LOS_SwtmrCreate>
                          (SWTMR_PROC_FUNC)OsCpupGuard, &g_cpupSwtmrId, 0);

    (VOID)LOS_SwtmrStart(g_cpupSwtmrId);
 8014680:	4b03      	ldr	r3, [pc, #12]	; (8014690 <OsCpupGuardCreator+0x28>)
 8014682:	881b      	ldrh	r3, [r3, #0]
 8014684:	4618      	mov	r0, r3
 8014686:	f7f1 fb47 	bl	8005d18 <LOS_SwtmrStart>
}
 801468a:	bf00      	nop
 801468c:	46bd      	mov	sp, r7
 801468e:	bd80      	pop	{r7, pc}
 8014690:	200032dc 	.word	0x200032dc
 8014694:	080144cd 	.word	0x080144cd

08014698 <OsCpupGuardInit>:

LITE_OS_SEC_TEXT_INIT VOID OsCpupGuardInit(VOID)
{
 8014698:	b580      	push	{r7, lr}
 801469a:	b08c      	sub	sp, #48	; 0x30
 801469c:	af00      	add	r7, sp, #0
 801469e:	4b17      	ldr	r3, [pc, #92]	; (80146fc <OsCpupGuardInit+0x64>)
 80146a0:	681b      	ldr	r3, [r3, #0]
 80146a2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80146a4:	f04f 0300 	mov.w	r3, #0
    TSK_INIT_PARAM_S taskInitParam;
    UINT32 tempId;

    (VOID)memset_s((void *)(&taskInitParam), sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));
 80146a8:	f107 0008 	add.w	r0, r7, #8
 80146ac:	2324      	movs	r3, #36	; 0x24
 80146ae:	2200      	movs	r2, #0
 80146b0:	2124      	movs	r1, #36	; 0x24
 80146b2:	f7ed fcf7 	bl	80020a4 <memset_s>
    taskInitParam.pfnTaskEntry  = (TSK_ENTRY_FUNC)OsCpupGuardCreator;
 80146b6:	4b12      	ldr	r3, [pc, #72]	; (8014700 <OsCpupGuardInit+0x68>)
 80146b8:	60bb      	str	r3, [r7, #8]
    taskInitParam.uwStackSize   = LOS_TASK_MIN_STACK_SIZE;
 80146ba:	2108      	movs	r1, #8
 80146bc:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80146c0:	f7ee f8fa 	bl	80028b8 <LOS_Align>
 80146c4:	4603      	mov	r3, r0
 80146c6:	623b      	str	r3, [r7, #32]
    taskInitParam.pcName        = "CpupGuardCreator";
 80146c8:	4b0e      	ldr	r3, [pc, #56]	; (8014704 <OsCpupGuardInit+0x6c>)
 80146ca:	627b      	str	r3, [r7, #36]	; 0x24
    taskInitParam.usTaskPrio    = OS_TASK_PRIORITY_HIGHEST;
 80146cc:	2300      	movs	r3, #0
 80146ce:	81bb      	strh	r3, [r7, #12]
    taskInitParam.uwResved      = LOS_TASK_STATUS_DETACHED;
 80146d0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80146d4:	62bb      	str	r3, [r7, #40]	; 0x28
#ifdef LOSCFG_KERNEL_SMP
    taskInitParam.usCpuAffiMask = CPUID_TO_AFFI_MASK(ArchCurrCpuid());
#endif
    (VOID)LOS_TaskCreate(&tempId, &taskInitParam);
 80146d6:	f107 0208 	add.w	r2, r7, #8
 80146da:	1d3b      	adds	r3, r7, #4
 80146dc:	4611      	mov	r1, r2
 80146de:	4618      	mov	r0, r3
 80146e0:	f7ef fa24 	bl	8003b2c <LOS_TaskCreate>
}
 80146e4:	bf00      	nop
 80146e6:	4b05      	ldr	r3, [pc, #20]	; (80146fc <OsCpupGuardInit+0x64>)
 80146e8:	681a      	ldr	r2, [r3, #0]
 80146ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80146ec:	405a      	eors	r2, r3
 80146ee:	d001      	beq.n	80146f4 <OsCpupGuardInit+0x5c>
 80146f0:	f7ef ff74 	bl	80045dc <__stack_chk_fail>
 80146f4:	3730      	adds	r7, #48	; 0x30
 80146f6:	46bd      	mov	sp, r7
 80146f8:	bd80      	pop	{r7, pc}
 80146fa:	bf00      	nop
 80146fc:	080228f4 	.word	0x080228f4
 8014700:	08014669 	.word	0x08014669
 8014704:	080228e0 	.word	0x080228e0

08014708 <OsCpupInit>:
/*
 * Description: initialization of CPUP
 * Return     : LOS_OK or Error Information
 */
LITE_OS_SEC_TEXT_INIT UINT32 OsCpupInit(VOID)
{
 8014708:	b580      	push	{r7, lr}
 801470a:	b082      	sub	sp, #8
 801470c:	af00      	add	r7, sp, #0
    UINT32 size;

    g_cpupTaskMaxNum = g_taskMaxNum;
 801470e:	4b1c      	ldr	r3, [pc, #112]	; (8014780 <OsCpupInit+0x78>)
 8014710:	681b      	ldr	r3, [r3, #0]
 8014712:	b29a      	uxth	r2, r3
 8014714:	4b1b      	ldr	r3, [pc, #108]	; (8014784 <OsCpupInit+0x7c>)
 8014716:	801a      	strh	r2, [r3, #0]
    g_cpupMaxNum = g_cpupTaskMaxNum;
 8014718:	4b1a      	ldr	r3, [pc, #104]	; (8014784 <OsCpupInit+0x7c>)
 801471a:	881a      	ldrh	r2, [r3, #0]
 801471c:	4b1a      	ldr	r3, [pc, #104]	; (8014788 <OsCpupInit+0x80>)
 801471e:	801a      	strh	r2, [r3, #0]
#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    g_cpupMaxNum += LOSCFG_PLATFORM_HWI_LIMIT;
 8014720:	4b19      	ldr	r3, [pc, #100]	; (8014788 <OsCpupInit+0x80>)
 8014722:	881b      	ldrh	r3, [r3, #0]
 8014724:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8014728:	b29a      	uxth	r2, r3
 801472a:	4b17      	ldr	r3, [pc, #92]	; (8014788 <OsCpupInit+0x80>)
 801472c:	801a      	strh	r2, [r3, #0]
#endif

    /* every task has only one record, and it won't operated at the same time */
    size = g_cpupMaxNum * sizeof(OsCpupCB);
 801472e:	4b16      	ldr	r3, [pc, #88]	; (8014788 <OsCpupInit+0x80>)
 8014730:	881b      	ldrh	r3, [r3, #0]
 8014732:	461a      	mov	r2, r3
 8014734:	4613      	mov	r3, r2
 8014736:	011b      	lsls	r3, r3, #4
 8014738:	1a9b      	subs	r3, r3, r2
 801473a:	00db      	lsls	r3, r3, #3
 801473c:	607b      	str	r3, [r7, #4]
    g_cpup = (OsCpupCB *)LOS_MemAlloc(m_aucSysMem0, size);
 801473e:	4b13      	ldr	r3, [pc, #76]	; (801478c <OsCpupInit+0x84>)
 8014740:	681b      	ldr	r3, [r3, #0]
 8014742:	6879      	ldr	r1, [r7, #4]
 8014744:	4618      	mov	r0, r3
 8014746:	f7f4 fe65 	bl	8009414 <LOS_MemAlloc>
 801474a:	4603      	mov	r3, r0
 801474c:	4a10      	ldr	r2, [pc, #64]	; (8014790 <OsCpupInit+0x88>)
 801474e:	6013      	str	r3, [r2, #0]
    if (g_cpup == NULL) {
 8014750:	4b0f      	ldr	r3, [pc, #60]	; (8014790 <OsCpupInit+0x88>)
 8014752:	681b      	ldr	r3, [r3, #0]
 8014754:	2b00      	cmp	r3, #0
 8014756:	d101      	bne.n	801475c <OsCpupInit+0x54>
        return LOS_ERRNO_CPUP_NO_MEMORY;
 8014758:	4b0e      	ldr	r3, [pc, #56]	; (8014794 <OsCpupInit+0x8c>)
 801475a:	e00c      	b.n	8014776 <OsCpupInit+0x6e>
    }

    OsCpupGuardInit();
 801475c:	f7ff ff9c 	bl	8014698 <OsCpupGuardInit>

    (VOID)memset_s(g_cpup, size, 0, size);
 8014760:	4b0b      	ldr	r3, [pc, #44]	; (8014790 <OsCpupInit+0x88>)
 8014762:	6818      	ldr	r0, [r3, #0]
 8014764:	687b      	ldr	r3, [r7, #4]
 8014766:	2200      	movs	r2, #0
 8014768:	6879      	ldr	r1, [r7, #4]
 801476a:	f7ed fc9b 	bl	80020a4 <memset_s>
    g_cpupInitFlg = 1;
 801476e:	4b0a      	ldr	r3, [pc, #40]	; (8014798 <OsCpupInit+0x90>)
 8014770:	2201      	movs	r2, #1
 8014772:	801a      	strh	r2, [r3, #0]

    return LOS_OK;
 8014774:	2300      	movs	r3, #0
}
 8014776:	4618      	mov	r0, r3
 8014778:	3708      	adds	r7, #8
 801477a:	46bd      	mov	sp, r7
 801477c:	bd80      	pop	{r7, pc}
 801477e:	bf00      	nop
 8014780:	200036d8 	.word	0x200036d8
 8014784:	200032e6 	.word	0x200032e6
 8014788:	200032e4 	.word	0x200032e4
 801478c:	200021bc 	.word	0x200021bc
 8014790:	200032e0 	.word	0x200032e0
 8014794:	02001e00 	.word	0x02001e00
 8014798:	200032de 	.word	0x200032de

0801479c <OsCpupGetCycle>:
/*
 * Description: get current cycles count
 * Return     : current cycles count
 */
LITE_OS_SEC_TEXT_MINOR UINT64 OsCpupGetCycle(VOID)
{
 801479c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 80147a0:	b086      	sub	sp, #24
 80147a2:	af00      	add	r7, sp, #0
 80147a4:	4b2a      	ldr	r3, [pc, #168]	; (8014850 <OsCpupGetCycle+0xb4>)
 80147a6:	681b      	ldr	r3, [r3, #0]
 80147a8:	617b      	str	r3, [r7, #20]
 80147aa:	f04f 0300 	mov.w	r3, #0
    UINT32 high;
    UINT32 low;
    UINT64 cycles;

    LOS_GetCpuCycle(&high, &low);
 80147ae:	1d3a      	adds	r2, r7, #4
 80147b0:	463b      	mov	r3, r7
 80147b2:	4611      	mov	r1, r2
 80147b4:	4618      	mov	r0, r3
 80147b6:	f7ef fe05 	bl	80043c4 <LOS_GetCpuCycle>
    cycles = ((UINT64)high << HIGH_BITS) + low;
 80147ba:	683b      	ldr	r3, [r7, #0]
 80147bc:	4618      	mov	r0, r3
 80147be:	f04f 0100 	mov.w	r1, #0
 80147c2:	f04f 0200 	mov.w	r2, #0
 80147c6:	f04f 0300 	mov.w	r3, #0
 80147ca:	0003      	movs	r3, r0
 80147cc:	2200      	movs	r2, #0
 80147ce:	6879      	ldr	r1, [r7, #4]
 80147d0:	4608      	mov	r0, r1
 80147d2:	f04f 0100 	mov.w	r1, #0
 80147d6:	1814      	adds	r4, r2, r0
 80147d8:	eb43 0501 	adc.w	r5, r3, r1
 80147dc:	e9c7 4502 	strd	r4, r5, [r7, #8]
    if (g_startCycles == 0) {
 80147e0:	4b1c      	ldr	r3, [pc, #112]	; (8014854 <OsCpupGetCycle+0xb8>)
 80147e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80147e6:	4313      	orrs	r3, r2
 80147e8:	d104      	bne.n	80147f4 <OsCpupGetCycle+0x58>
        g_startCycles = cycles;
 80147ea:	491a      	ldr	r1, [pc, #104]	; (8014854 <OsCpupGetCycle+0xb8>)
 80147ec:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80147f0:	e9c1 2300 	strd	r2, r3, [r1]

    /*
     * The cycles should keep growing, if the checking failed,
     * it mean LOS_GetCpuCycle has the problem which should be fixed.
     */
    LOS_ASSERT(cycles >= g_startCycles);
 80147f4:	4b17      	ldr	r3, [pc, #92]	; (8014854 <OsCpupGetCycle+0xb8>)
 80147f6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80147fa:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 80147fe:	4299      	cmp	r1, r3
 8014800:	bf08      	it	eq
 8014802:	4290      	cmpeq	r0, r2
 8014804:	d20b      	bcs.n	801481e <OsCpupGetCycle+0x82>
 8014806:	f7ff fe27 	bl	8014458 <LOS_IntLock>
 801480a:	4813      	ldr	r0, [pc, #76]	; (8014858 <OsCpupGetCycle+0xbc>)
 801480c:	f7f0 f858 	bl	80048c0 <dprintf>
 8014810:	4b12      	ldr	r3, [pc, #72]	; (801485c <OsCpupGetCycle+0xc0>)
 8014812:	22e1      	movs	r2, #225	; 0xe1
 8014814:	4912      	ldr	r1, [pc, #72]	; (8014860 <OsCpupGetCycle+0xc4>)
 8014816:	4813      	ldr	r0, [pc, #76]	; (8014864 <OsCpupGetCycle+0xc8>)
 8014818:	f7f0 f852 	bl	80048c0 <dprintf>
 801481c:	e7fe      	b.n	801481c <OsCpupGetCycle+0x80>

    return (cycles - g_startCycles);
 801481e:	4b0d      	ldr	r3, [pc, #52]	; (8014854 <OsCpupGetCycle+0xb8>)
 8014820:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014824:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8014828:	ebb0 0802 	subs.w	r8, r0, r2
 801482c:	eb61 0903 	sbc.w	r9, r1, r3
 8014830:	4642      	mov	r2, r8
 8014832:	464b      	mov	r3, r9
}
 8014834:	4906      	ldr	r1, [pc, #24]	; (8014850 <OsCpupGetCycle+0xb4>)
 8014836:	6808      	ldr	r0, [r1, #0]
 8014838:	6979      	ldr	r1, [r7, #20]
 801483a:	4048      	eors	r0, r1
 801483c:	d001      	beq.n	8014842 <OsCpupGetCycle+0xa6>
 801483e:	f7ef fecd 	bl	80045dc <__stack_chk_fail>
 8014842:	4610      	mov	r0, r2
 8014844:	4619      	mov	r1, r3
 8014846:	3718      	adds	r7, #24
 8014848:	46bd      	mov	sp, r7
 801484a:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 801484e:	bf00      	nop
 8014850:	08022928 	.word	0x08022928
 8014854:	20003350 	.word	0x20003350
 8014858:	080228f8 	.word	0x080228f8
 801485c:	0802366c 	.word	0x0802366c
 8014860:	08022900 	.word	0x08022900
 8014864:	0802290c 	.word	0x0802290c

08014868 <OsTaskCycleStart>:

/*
 * Description: start task to get cycles count in current task beginning
 */
LITE_OS_SEC_TEXT_MINOR VOID OsTaskCycleStart(VOID)
{
 8014868:	b590      	push	{r4, r7, lr}
 801486a:	b083      	sub	sp, #12
 801486c:	af00      	add	r7, sp, #0
    UINT32 taskId;
    LosTaskCB *runTask = NULL;
 801486e:	2300      	movs	r3, #0
 8014870:	603b      	str	r3, [r7, #0]

    if (g_cpupInitFlg == 0) {
 8014872:	4b13      	ldr	r3, [pc, #76]	; (80148c0 <OsTaskCycleStart+0x58>)
 8014874:	881b      	ldrh	r3, [r3, #0]
 8014876:	2b00      	cmp	r3, #0
 8014878:	d01e      	beq.n	80148b8 <OsTaskCycleStart+0x50>
        return;
    }

    runTask = OsCurrTaskGet();
 801487a:	f7ff fe0b 	bl	8014494 <OsCurrTaskGet>
 801487e:	6038      	str	r0, [r7, #0]
    taskId = runTask->taskId;
 8014880:	683b      	ldr	r3, [r7, #0]
 8014882:	695b      	ldr	r3, [r3, #20]
 8014884:	607b      	str	r3, [r7, #4]

    g_cpup[taskId].id = taskId;
 8014886:	4b0f      	ldr	r3, [pc, #60]	; (80148c4 <OsTaskCycleStart+0x5c>)
 8014888:	6819      	ldr	r1, [r3, #0]
 801488a:	687a      	ldr	r2, [r7, #4]
 801488c:	4613      	mov	r3, r2
 801488e:	011b      	lsls	r3, r3, #4
 8014890:	1a9b      	subs	r3, r3, r2
 8014892:	00db      	lsls	r3, r3, #3
 8014894:	440b      	add	r3, r1
 8014896:	687a      	ldr	r2, [r7, #4]
 8014898:	601a      	str	r2, [r3, #0]
    g_cpup[taskId].startTime = OsCpupGetCycle();
 801489a:	4b0a      	ldr	r3, [pc, #40]	; (80148c4 <OsTaskCycleStart+0x5c>)
 801489c:	6819      	ldr	r1, [r3, #0]
 801489e:	687a      	ldr	r2, [r7, #4]
 80148a0:	4613      	mov	r3, r2
 80148a2:	011b      	lsls	r3, r3, #4
 80148a4:	1a9b      	subs	r3, r3, r2
 80148a6:	00db      	lsls	r3, r3, #3
 80148a8:	18cc      	adds	r4, r1, r3
 80148aa:	f7ff ff77 	bl	801479c <OsCpupGetCycle>
 80148ae:	4602      	mov	r2, r0
 80148b0:	460b      	mov	r3, r1
 80148b2:	e9c4 2304 	strd	r2, r3, [r4, #16]

    return;
 80148b6:	e000      	b.n	80148ba <OsTaskCycleStart+0x52>
        return;
 80148b8:	bf00      	nop
}
 80148ba:	370c      	adds	r7, #12
 80148bc:	46bd      	mov	sp, r7
 80148be:	bd90      	pop	{r4, r7, pc}
 80148c0:	200032de 	.word	0x200032de
 80148c4:	200032e0 	.word	0x200032e0

080148c8 <OsTaskCycleEnd>:

/*
 * Description: quit task and get cycle count
 */
LITE_OS_SEC_TEXT_MINOR VOID OsTaskCycleEnd(VOID)
{
 80148c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80148cc:	b089      	sub	sp, #36	; 0x24
 80148ce:	af00      	add	r7, sp, #0
    UINT32 taskId;
    UINT64 cpuCycle;
    LosTaskCB *runTask = NULL;
 80148d0:	2300      	movs	r3, #0
 80148d2:	60fb      	str	r3, [r7, #12]

    if (g_cpupInitFlg == 0) {
 80148d4:	4b42      	ldr	r3, [pc, #264]	; (80149e0 <OsTaskCycleEnd+0x118>)
 80148d6:	881b      	ldrh	r3, [r3, #0]
 80148d8:	2b00      	cmp	r3, #0
 80148da:	d07a      	beq.n	80149d2 <OsTaskCycleEnd+0x10a>
        return;
    }

    runTask = OsCurrTaskGet();
 80148dc:	f7ff fdda 	bl	8014494 <OsCurrTaskGet>
 80148e0:	60f8      	str	r0, [r7, #12]
    taskId = runTask->taskId;
 80148e2:	68fb      	ldr	r3, [r7, #12]
 80148e4:	695b      	ldr	r3, [r3, #20]
 80148e6:	613b      	str	r3, [r7, #16]

    if (g_cpup[taskId].startTime == 0) {
 80148e8:	4b3e      	ldr	r3, [pc, #248]	; (80149e4 <OsTaskCycleEnd+0x11c>)
 80148ea:	6819      	ldr	r1, [r3, #0]
 80148ec:	693a      	ldr	r2, [r7, #16]
 80148ee:	4613      	mov	r3, r2
 80148f0:	011b      	lsls	r3, r3, #4
 80148f2:	1a9b      	subs	r3, r3, r2
 80148f4:	00db      	lsls	r3, r3, #3
 80148f6:	440b      	add	r3, r1
 80148f8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80148fc:	4313      	orrs	r3, r2
 80148fe:	d06a      	beq.n	80149d6 <OsTaskCycleEnd+0x10e>
        return;
    }

    cpuCycle = OsCpupGetCycle();
 8014900:	f7ff ff4c 	bl	801479c <OsCpupGetCycle>
 8014904:	e9c7 0106 	strd	r0, r1, [r7, #24]
    g_cpup[taskId].allTime += cpuCycle - g_cpup[taskId].startTime;
 8014908:	4b36      	ldr	r3, [pc, #216]	; (80149e4 <OsTaskCycleEnd+0x11c>)
 801490a:	6819      	ldr	r1, [r3, #0]
 801490c:	693a      	ldr	r2, [r7, #16]
 801490e:	4613      	mov	r3, r2
 8014910:	011b      	lsls	r3, r3, #4
 8014912:	1a9b      	subs	r3, r3, r2
 8014914:	00db      	lsls	r3, r3, #3
 8014916:	440b      	add	r3, r1
 8014918:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 801491c:	4b31      	ldr	r3, [pc, #196]	; (80149e4 <OsTaskCycleEnd+0x11c>)
 801491e:	681e      	ldr	r6, [r3, #0]
 8014920:	693a      	ldr	r2, [r7, #16]
 8014922:	4613      	mov	r3, r2
 8014924:	011b      	lsls	r3, r3, #4
 8014926:	1a9b      	subs	r3, r3, r2
 8014928:	00db      	lsls	r3, r3, #3
 801492a:	4433      	add	r3, r6
 801492c:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8014930:	e9d7 8906 	ldrd	r8, r9, [r7, #24]
 8014934:	ebb8 0402 	subs.w	r4, r8, r2
 8014938:	eb69 0503 	sbc.w	r5, r9, r3
 801493c:	4b29      	ldr	r3, [pc, #164]	; (80149e4 <OsTaskCycleEnd+0x11c>)
 801493e:	681e      	ldr	r6, [r3, #0]
 8014940:	693a      	ldr	r2, [r7, #16]
 8014942:	4613      	mov	r3, r2
 8014944:	011b      	lsls	r3, r3, #4
 8014946:	1a9b      	subs	r3, r3, r2
 8014948:	00db      	lsls	r3, r3, #3
 801494a:	4433      	add	r3, r6
 801494c:	1902      	adds	r2, r0, r4
 801494e:	603a      	str	r2, [r7, #0]
 8014950:	eb41 0205 	adc.w	r2, r1, r5
 8014954:	607a      	str	r2, [r7, #4]
 8014956:	e9d7 1200 	ldrd	r1, r2, [r7]
 801495a:	e9c3 1202 	strd	r1, r2, [r3, #8]

#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    UINT32 cpuId = ArchCurrCpuid();
 801495e:	f7ff fd73 	bl	8014448 <ArchCurrCpuid>
 8014962:	6178      	str	r0, [r7, #20]
    g_cpup[taskId].allTime -= g_timeInIrqPerTskSwitch[cpuId];
 8014964:	4b1f      	ldr	r3, [pc, #124]	; (80149e4 <OsTaskCycleEnd+0x11c>)
 8014966:	6819      	ldr	r1, [r3, #0]
 8014968:	693a      	ldr	r2, [r7, #16]
 801496a:	4613      	mov	r3, r2
 801496c:	011b      	lsls	r3, r3, #4
 801496e:	1a9b      	subs	r3, r3, r2
 8014970:	00db      	lsls	r3, r3, #3
 8014972:	440b      	add	r3, r1
 8014974:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 8014978:	4a1b      	ldr	r2, [pc, #108]	; (80149e8 <OsTaskCycleEnd+0x120>)
 801497a:	697b      	ldr	r3, [r7, #20]
 801497c:	00db      	lsls	r3, r3, #3
 801497e:	4413      	add	r3, r2
 8014980:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014984:	4b17      	ldr	r3, [pc, #92]	; (80149e4 <OsTaskCycleEnd+0x11c>)
 8014986:	681e      	ldr	r6, [r3, #0]
 8014988:	693a      	ldr	r2, [r7, #16]
 801498a:	4613      	mov	r3, r2
 801498c:	011b      	lsls	r3, r3, #4
 801498e:	1a9b      	subs	r3, r3, r2
 8014990:	00db      	lsls	r3, r3, #3
 8014992:	4433      	add	r3, r6
 8014994:	ebb4 0a00 	subs.w	sl, r4, r0
 8014998:	eb65 0b01 	sbc.w	fp, r5, r1
 801499c:	e9c3 ab02 	strd	sl, fp, [r3, #8]
    g_timeInIrqPerTskSwitch[cpuId] = 0;
 80149a0:	4a11      	ldr	r2, [pc, #68]	; (80149e8 <OsTaskCycleEnd+0x120>)
 80149a2:	697b      	ldr	r3, [r7, #20]
 80149a4:	00db      	lsls	r3, r3, #3
 80149a6:	18d1      	adds	r1, r2, r3
 80149a8:	f04f 0200 	mov.w	r2, #0
 80149ac:	f04f 0300 	mov.w	r3, #0
 80149b0:	e9c1 2300 	strd	r2, r3, [r1]
#endif
    g_cpup[taskId].startTime = 0;
 80149b4:	4b0b      	ldr	r3, [pc, #44]	; (80149e4 <OsTaskCycleEnd+0x11c>)
 80149b6:	6819      	ldr	r1, [r3, #0]
 80149b8:	693a      	ldr	r2, [r7, #16]
 80149ba:	4613      	mov	r3, r2
 80149bc:	011b      	lsls	r3, r3, #4
 80149be:	1a9b      	subs	r3, r3, r2
 80149c0:	00db      	lsls	r3, r3, #3
 80149c2:	4419      	add	r1, r3
 80149c4:	f04f 0200 	mov.w	r2, #0
 80149c8:	f04f 0300 	mov.w	r3, #0
 80149cc:	e9c1 2304 	strd	r2, r3, [r1, #16]

    return;
 80149d0:	e002      	b.n	80149d8 <OsTaskCycleEnd+0x110>
        return;
 80149d2:	bf00      	nop
 80149d4:	e000      	b.n	80149d8 <OsTaskCycleEnd+0x110>
        return;
 80149d6:	bf00      	nop
}
 80149d8:	3724      	adds	r7, #36	; 0x24
 80149da:	46bd      	mov	sp, r7
 80149dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80149e0:	200032de 	.word	0x200032de
 80149e4:	200032e0 	.word	0x200032e0
 80149e8:	20003770 	.word	0x20003770

080149ec <OsTaskCycleEndStart>:

/*
 * Description: start task to get cycles count in current task ending
 */
LITE_OS_SEC_TEXT_MINOR VOID OsTaskCycleEndStart(const LosTaskCB *newTask)
{
 80149ec:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80149f0:	b08a      	sub	sp, #40	; 0x28
 80149f2:	af00      	add	r7, sp, #0
 80149f4:	60f8      	str	r0, [r7, #12]
    UINT64 cpuCycle;
    LosTaskCB *runTask = NULL;
 80149f6:	2300      	movs	r3, #0
 80149f8:	617b      	str	r3, [r7, #20]
    OsCpupCB *cpup = NULL;
 80149fa:	2300      	movs	r3, #0
 80149fc:	61bb      	str	r3, [r7, #24]
    UINT32 cpuId = ArchCurrCpuid();
 80149fe:	f7ff fd23 	bl	8014448 <ArchCurrCpuid>
 8014a02:	61f8      	str	r0, [r7, #28]

    if ((g_cpupInitFlg == 0) || (newTask == NULL)) {
 8014a04:	4b35      	ldr	r3, [pc, #212]	; (8014adc <OsTaskCycleEndStart+0xf0>)
 8014a06:	881b      	ldrh	r3, [r3, #0]
 8014a08:	2b00      	cmp	r3, #0
 8014a0a:	d061      	beq.n	8014ad0 <OsTaskCycleEndStart+0xe4>
 8014a0c:	68fb      	ldr	r3, [r7, #12]
 8014a0e:	2b00      	cmp	r3, #0
 8014a10:	d05e      	beq.n	8014ad0 <OsTaskCycleEndStart+0xe4>
        return;
    }

    runTask = OsCurrTaskGet();
 8014a12:	f7ff fd3f 	bl	8014494 <OsCurrTaskGet>
 8014a16:	6178      	str	r0, [r7, #20]
    cpuCycle = OsCpupGetCycle();
 8014a18:	f7ff fec0 	bl	801479c <OsCpupGetCycle>
 8014a1c:	e9c7 0108 	strd	r0, r1, [r7, #32]

    cpup = &g_cpup[runTask->taskId];
 8014a20:	4b2f      	ldr	r3, [pc, #188]	; (8014ae0 <OsTaskCycleEndStart+0xf4>)
 8014a22:	6819      	ldr	r1, [r3, #0]
 8014a24:	697b      	ldr	r3, [r7, #20]
 8014a26:	695a      	ldr	r2, [r3, #20]
 8014a28:	4613      	mov	r3, r2
 8014a2a:	011b      	lsls	r3, r3, #4
 8014a2c:	1a9b      	subs	r3, r3, r2
 8014a2e:	00db      	lsls	r3, r3, #3
 8014a30:	440b      	add	r3, r1
 8014a32:	61bb      	str	r3, [r7, #24]
    if (cpup->startTime != 0) {
 8014a34:	69bb      	ldr	r3, [r7, #24]
 8014a36:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8014a3a:	4313      	orrs	r3, r2
 8014a3c:	d02e      	beq.n	8014a9c <OsTaskCycleEndStart+0xb0>
        cpup->allTime += cpuCycle - cpup->startTime;
 8014a3e:	69bb      	ldr	r3, [r7, #24]
 8014a40:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8014a44:	69b9      	ldr	r1, [r7, #24]
 8014a46:	e9d1 0104 	ldrd	r0, r1, [r1, #16]
 8014a4a:	e9d7 8908 	ldrd	r8, r9, [r7, #32]
 8014a4e:	ebb8 0400 	subs.w	r4, r8, r0
 8014a52:	eb69 0501 	sbc.w	r5, r9, r1
 8014a56:	1911      	adds	r1, r2, r4
 8014a58:	6039      	str	r1, [r7, #0]
 8014a5a:	416b      	adcs	r3, r5
 8014a5c:	607b      	str	r3, [r7, #4]
 8014a5e:	69bb      	ldr	r3, [r7, #24]
 8014a60:	e9d7 1200 	ldrd	r1, r2, [r7]
 8014a64:	e9c3 1202 	strd	r1, r2, [r3, #8]
#ifdef LOSCFG_CPUP_INCLUDE_IRQ
        cpup->allTime -= g_timeInIrqPerTskSwitch[cpuId];
 8014a68:	69bb      	ldr	r3, [r7, #24]
 8014a6a:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8014a6e:	4a1d      	ldr	r2, [pc, #116]	; (8014ae4 <OsTaskCycleEndStart+0xf8>)
 8014a70:	69fb      	ldr	r3, [r7, #28]
 8014a72:	00db      	lsls	r3, r3, #3
 8014a74:	4413      	add	r3, r2
 8014a76:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014a7a:	ebb0 0a02 	subs.w	sl, r0, r2
 8014a7e:	eb61 0b03 	sbc.w	fp, r1, r3
 8014a82:	69bb      	ldr	r3, [r7, #24]
 8014a84:	e9c3 ab02 	strd	sl, fp, [r3, #8]
        g_timeInIrqPerTskSwitch[cpuId] = 0;
 8014a88:	4a16      	ldr	r2, [pc, #88]	; (8014ae4 <OsTaskCycleEndStart+0xf8>)
 8014a8a:	69fb      	ldr	r3, [r7, #28]
 8014a8c:	00db      	lsls	r3, r3, #3
 8014a8e:	18d1      	adds	r1, r2, r3
 8014a90:	f04f 0200 	mov.w	r2, #0
 8014a94:	f04f 0300 	mov.w	r3, #0
 8014a98:	e9c1 2300 	strd	r2, r3, [r1]
#endif
    }

    cpup = &g_cpup[newTask->taskId];
 8014a9c:	4b10      	ldr	r3, [pc, #64]	; (8014ae0 <OsTaskCycleEndStart+0xf4>)
 8014a9e:	6819      	ldr	r1, [r3, #0]
 8014aa0:	68fb      	ldr	r3, [r7, #12]
 8014aa2:	695a      	ldr	r2, [r3, #20]
 8014aa4:	4613      	mov	r3, r2
 8014aa6:	011b      	lsls	r3, r3, #4
 8014aa8:	1a9b      	subs	r3, r3, r2
 8014aaa:	00db      	lsls	r3, r3, #3
 8014aac:	440b      	add	r3, r1
 8014aae:	61bb      	str	r3, [r7, #24]
    cpup->id = newTask->taskId;
 8014ab0:	68fb      	ldr	r3, [r7, #12]
 8014ab2:	695a      	ldr	r2, [r3, #20]
 8014ab4:	69bb      	ldr	r3, [r7, #24]
 8014ab6:	601a      	str	r2, [r3, #0]
    cpup->startTime = cpuCycle;
 8014ab8:	69b9      	ldr	r1, [r7, #24]
 8014aba:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8014abe:	e9c1 2304 	strd	r2, r3, [r1, #16]
    runningTasks[cpuId] = newTask->taskId;
 8014ac2:	68fb      	ldr	r3, [r7, #12]
 8014ac4:	695a      	ldr	r2, [r3, #20]
 8014ac6:	4908      	ldr	r1, [pc, #32]	; (8014ae8 <OsTaskCycleEndStart+0xfc>)
 8014ac8:	69fb      	ldr	r3, [r7, #28]
 8014aca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

    return;
 8014ace:	e000      	b.n	8014ad2 <OsTaskCycleEndStart+0xe6>
        return;
 8014ad0:	bf00      	nop
}
 8014ad2:	3728      	adds	r7, #40	; 0x28
 8014ad4:	46bd      	mov	sp, r7
 8014ad6:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8014ada:	bf00      	nop
 8014adc:	200032de 	.word	0x200032de
 8014ae0:	200032e0 	.word	0x200032e0
 8014ae4:	20003770 	.word	0x20003770
 8014ae8:	200004a0 	.word	0x200004a0

08014aec <OsCpupGetPos>:

LITE_OS_SEC_TEXT_MINOR STATIC VOID OsCpupGetPos(UINT32 mode, UINT16 *curPosPointer, UINT16 *prePosPointer)
{
 8014aec:	b480      	push	{r7}
 8014aee:	b087      	sub	sp, #28
 8014af0:	af00      	add	r7, sp, #0
 8014af2:	60f8      	str	r0, [r7, #12]
 8014af4:	60b9      	str	r1, [r7, #8]
 8014af6:	607a      	str	r2, [r7, #4]
    UINT16 curPos;
    UINT16 tmpPos;
    UINT16 prePos;

    tmpPos = g_hisPos;
 8014af8:	4b16      	ldr	r3, [pc, #88]	; (8014b54 <OsCpupGetPos+0x68>)
 8014afa:	881b      	ldrh	r3, [r3, #0]
 8014afc:	82bb      	strh	r3, [r7, #20]
    curPos = CPUP_PRE_POS(tmpPos);
 8014afe:	8abb      	ldrh	r3, [r7, #20]
 8014b00:	2b00      	cmp	r3, #0
 8014b02:	d003      	beq.n	8014b0c <OsCpupGetPos+0x20>
 8014b04:	8abb      	ldrh	r3, [r7, #20]
 8014b06:	3b01      	subs	r3, #1
 8014b08:	b29b      	uxth	r3, r3
 8014b0a:	e000      	b.n	8014b0e <OsCpupGetPos+0x22>
 8014b0c:	230a      	movs	r3, #10
 8014b0e:	82fb      	strh	r3, [r7, #22]

    /*
     * The current position has nothing to do with the CPUP modes,
     * however, the previous position differs.
     */
    switch (mode) {
 8014b10:	68fb      	ldr	r3, [r7, #12]
 8014b12:	2b00      	cmp	r3, #0
 8014b14:	d00c      	beq.n	8014b30 <OsCpupGetPos+0x44>
 8014b16:	68fb      	ldr	r3, [r7, #12]
 8014b18:	2b01      	cmp	r3, #1
 8014b1a:	d10c      	bne.n	8014b36 <OsCpupGetPos+0x4a>
        case CPUP_LAST_ONE_SECONDS:
            prePos = CPUP_PRE_POS(curPos);
 8014b1c:	8afb      	ldrh	r3, [r7, #22]
 8014b1e:	2b00      	cmp	r3, #0
 8014b20:	d003      	beq.n	8014b2a <OsCpupGetPos+0x3e>
 8014b22:	8afb      	ldrh	r3, [r7, #22]
 8014b24:	3b01      	subs	r3, #1
 8014b26:	b29b      	uxth	r3, r3
 8014b28:	e000      	b.n	8014b2c <OsCpupGetPos+0x40>
 8014b2a:	230a      	movs	r3, #10
 8014b2c:	827b      	strh	r3, [r7, #18]
            break;
 8014b2e:	e005      	b.n	8014b3c <OsCpupGetPos+0x50>
        case CPUP_LAST_TEN_SECONDS:
            prePos = tmpPos;
 8014b30:	8abb      	ldrh	r3, [r7, #20]
 8014b32:	827b      	strh	r3, [r7, #18]
            break;
 8014b34:	e002      	b.n	8014b3c <OsCpupGetPos+0x50>
        case CPUP_ALL_TIME:
            /* fall-through */
        default:
            prePos = OS_CPUP_HISTORY_RECORD_NUM;
 8014b36:	230b      	movs	r3, #11
 8014b38:	827b      	strh	r3, [r7, #18]
            break;
 8014b3a:	bf00      	nop
    }

    *curPosPointer = curPos;
 8014b3c:	68bb      	ldr	r3, [r7, #8]
 8014b3e:	8afa      	ldrh	r2, [r7, #22]
 8014b40:	801a      	strh	r2, [r3, #0]
    *prePosPointer = prePos;
 8014b42:	687b      	ldr	r3, [r7, #4]
 8014b44:	8a7a      	ldrh	r2, [r7, #18]
 8014b46:	801a      	strh	r2, [r3, #0]

    return;
 8014b48:	bf00      	nop
}
 8014b4a:	371c      	adds	r7, #28
 8014b4c:	46bd      	mov	sp, r7
 8014b4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014b52:	4770      	bx	lr
 8014b54:	200032e8 	.word	0x200032e8

08014b58 <OsCpuUsageParaCheck>:

LITE_OS_SEC_TEXT_MINOR STATIC INLINE UINT32 OsCpuUsageParaCheck(UINT32 taskId)
{
 8014b58:	b480      	push	{r7}
 8014b5a:	b083      	sub	sp, #12
 8014b5c:	af00      	add	r7, sp, #0
 8014b5e:	6078      	str	r0, [r7, #4]
    if (g_cpupInitFlg == 0) {
 8014b60:	4b1d      	ldr	r3, [pc, #116]	; (8014bd8 <OsCpuUsageParaCheck+0x80>)
 8014b62:	881b      	ldrh	r3, [r3, #0]
 8014b64:	2b00      	cmp	r3, #0
 8014b66:	d101      	bne.n	8014b6c <OsCpuUsageParaCheck+0x14>
        return LOS_ERRNO_CPUP_NO_INIT;
 8014b68:	4b1c      	ldr	r3, [pc, #112]	; (8014bdc <OsCpuUsageParaCheck+0x84>)
 8014b6a:	e02f      	b.n	8014bcc <OsCpuUsageParaCheck+0x74>
    }

    if (OS_TSK_GET_INDEX(taskId) >= g_taskMaxNum) {
 8014b6c:	4b1c      	ldr	r3, [pc, #112]	; (8014be0 <OsCpuUsageParaCheck+0x88>)
 8014b6e:	681b      	ldr	r3, [r3, #0]
 8014b70:	687a      	ldr	r2, [r7, #4]
 8014b72:	429a      	cmp	r2, r3
 8014b74:	d301      	bcc.n	8014b7a <OsCpuUsageParaCheck+0x22>
        return LOS_ERRNO_CPUP_TSK_ID_INVALID;
 8014b76:	4b1b      	ldr	r3, [pc, #108]	; (8014be4 <OsCpuUsageParaCheck+0x8c>)
 8014b78:	e028      	b.n	8014bcc <OsCpuUsageParaCheck+0x74>
    }

    /* weather the task is created */
    if (g_cpup[taskId].id != taskId) {
 8014b7a:	4b1b      	ldr	r3, [pc, #108]	; (8014be8 <OsCpuUsageParaCheck+0x90>)
 8014b7c:	6819      	ldr	r1, [r3, #0]
 8014b7e:	687a      	ldr	r2, [r7, #4]
 8014b80:	4613      	mov	r3, r2
 8014b82:	011b      	lsls	r3, r3, #4
 8014b84:	1a9b      	subs	r3, r3, r2
 8014b86:	00db      	lsls	r3, r3, #3
 8014b88:	440b      	add	r3, r1
 8014b8a:	681b      	ldr	r3, [r3, #0]
 8014b8c:	687a      	ldr	r2, [r7, #4]
 8014b8e:	429a      	cmp	r2, r3
 8014b90:	d001      	beq.n	8014b96 <OsCpuUsageParaCheck+0x3e>
        return LOS_ERRNO_CPUP_THREAD_NO_CREATED;
 8014b92:	4b16      	ldr	r3, [pc, #88]	; (8014bec <OsCpuUsageParaCheck+0x94>)
 8014b94:	e01a      	b.n	8014bcc <OsCpuUsageParaCheck+0x74>
    }

    if ((g_cpup[taskId].status & OS_TASK_STATUS_UNUSED) || (g_cpup[taskId].status == 0)) {
 8014b96:	4b14      	ldr	r3, [pc, #80]	; (8014be8 <OsCpuUsageParaCheck+0x90>)
 8014b98:	6819      	ldr	r1, [r3, #0]
 8014b9a:	687a      	ldr	r2, [r7, #4]
 8014b9c:	4613      	mov	r3, r2
 8014b9e:	011b      	lsls	r3, r3, #4
 8014ba0:	1a9b      	subs	r3, r3, r2
 8014ba2:	00db      	lsls	r3, r3, #3
 8014ba4:	440b      	add	r3, r1
 8014ba6:	889b      	ldrh	r3, [r3, #4]
 8014ba8:	f003 0301 	and.w	r3, r3, #1
 8014bac:	2b00      	cmp	r3, #0
 8014bae:	d10a      	bne.n	8014bc6 <OsCpuUsageParaCheck+0x6e>
 8014bb0:	4b0d      	ldr	r3, [pc, #52]	; (8014be8 <OsCpuUsageParaCheck+0x90>)
 8014bb2:	6819      	ldr	r1, [r3, #0]
 8014bb4:	687a      	ldr	r2, [r7, #4]
 8014bb6:	4613      	mov	r3, r2
 8014bb8:	011b      	lsls	r3, r3, #4
 8014bba:	1a9b      	subs	r3, r3, r2
 8014bbc:	00db      	lsls	r3, r3, #3
 8014bbe:	440b      	add	r3, r1
 8014bc0:	889b      	ldrh	r3, [r3, #4]
 8014bc2:	2b00      	cmp	r3, #0
 8014bc4:	d101      	bne.n	8014bca <OsCpuUsageParaCheck+0x72>
        return LOS_ERRNO_CPUP_THREAD_NO_CREATED;
 8014bc6:	4b09      	ldr	r3, [pc, #36]	; (8014bec <OsCpuUsageParaCheck+0x94>)
 8014bc8:	e000      	b.n	8014bcc <OsCpuUsageParaCheck+0x74>
    }

    return LOS_OK;
 8014bca:	2300      	movs	r3, #0
}
 8014bcc:	4618      	mov	r0, r3
 8014bce:	370c      	adds	r7, #12
 8014bd0:	46bd      	mov	sp, r7
 8014bd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014bd6:	4770      	bx	lr
 8014bd8:	200032de 	.word	0x200032de
 8014bdc:	02001e02 	.word	0x02001e02
 8014be0:	200036d8 	.word	0x200036d8
 8014be4:	02001e05 	.word	0x02001e05
 8014be8:	200032e0 	.word	0x200032e0
 8014bec:	02001e04 	.word	0x02001e04

08014bf0 <LOS_HistorySysCpuUsage>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_HistorySysCpuUsage(UINT32 mode)
{
 8014bf0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8014bf4:	b08d      	sub	sp, #52	; 0x34
 8014bf6:	af00      	add	r7, sp, #0
 8014bf8:	6078      	str	r0, [r7, #4]
 8014bfa:	4b50      	ldr	r3, [pc, #320]	; (8014d3c <LOS_HistorySysCpuUsage+0x14c>)
 8014bfc:	681b      	ldr	r3, [r3, #0]
 8014bfe:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014c00:	f04f 0300 	mov.w	r3, #0
    UINT64 cpuCycleAll;
    UINT64 idleCycleAll = 0;
 8014c04:	f04f 0200 	mov.w	r2, #0
 8014c08:	f04f 0300 	mov.w	r3, #0
 8014c0c:	e9c7 2306 	strd	r2, r3, [r7, #24]
    UINT32 cpup = 0;
 8014c10:	2300      	movs	r3, #0
 8014c12:	60fb      	str	r3, [r7, #12]
    UINT32 idleTaskId;
#ifdef LOSCFG_KERNEL_SMP
    UINT32 cpuId = 0;
#endif

    if (g_cpupInitFlg == 0) {
 8014c14:	4b4a      	ldr	r3, [pc, #296]	; (8014d40 <LOS_HistorySysCpuUsage+0x150>)
 8014c16:	881b      	ldrh	r3, [r3, #0]
 8014c18:	2b00      	cmp	r3, #0
 8014c1a:	d101      	bne.n	8014c20 <LOS_HistorySysCpuUsage+0x30>
        return LOS_ERRNO_CPUP_NO_INIT;
 8014c1c:	4b49      	ldr	r3, [pc, #292]	; (8014d44 <LOS_HistorySysCpuUsage+0x154>)
 8014c1e:	e080      	b.n	8014d22 <LOS_HistorySysCpuUsage+0x132>
    }

    /* get end time of current task */
    intSave = LOS_IntLock();
 8014c20:	f7ff fc1a 	bl	8014458 <LOS_IntLock>
 8014c24:	6138      	str	r0, [r7, #16]
    OsTaskCycleEnd();
 8014c26:	f7ff fe4f 	bl	80148c8 <OsTaskCycleEnd>

    OsCpupGetPos(mode, &pos, &prePos);
 8014c2a:	f107 020a 	add.w	r2, r7, #10
 8014c2e:	f107 0308 	add.w	r3, r7, #8
 8014c32:	4619      	mov	r1, r3
 8014c34:	6878      	ldr	r0, [r7, #4]
 8014c36:	f7ff ff59 	bl	8014aec <OsCpupGetPos>
    cpuCycleAll = cpuHistoryTime[pos] - cpuHistoryTime[prePos];
 8014c3a:	893b      	ldrh	r3, [r7, #8]
 8014c3c:	4a42      	ldr	r2, [pc, #264]	; (8014d48 <LOS_HistorySysCpuUsage+0x158>)
 8014c3e:	00db      	lsls	r3, r3, #3
 8014c40:	4413      	add	r3, r2
 8014c42:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014c46:	897b      	ldrh	r3, [r7, #10]
 8014c48:	4a3f      	ldr	r2, [pc, #252]	; (8014d48 <LOS_HistorySysCpuUsage+0x158>)
 8014c4a:	00db      	lsls	r3, r3, #3
 8014c4c:	4413      	add	r3, r2
 8014c4e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014c52:	ebb0 0802 	subs.w	r8, r0, r2
 8014c56:	eb61 0903 	sbc.w	r9, r1, r3
 8014c5a:	e9c7 8908 	strd	r8, r9, [r7, #32]
        idleCycleAll += g_cpup[idleTaskId].historyTime[pos] - g_cpup[idleTaskId].historyTime[prePos];
        cpuId++;
    }
    cpuCycleAll *= LOSCFG_KERNEL_CORE_NUM;
#else
    idleTaskId = OsGetIdleTaskId();
 8014c5e:	f7ee fa67 	bl	8003130 <OsGetIdleTaskId>
 8014c62:	6178      	str	r0, [r7, #20]
    idleCycleAll = g_cpup[idleTaskId].historyTime[pos] - g_cpup[idleTaskId].historyTime[prePos];
 8014c64:	4b39      	ldr	r3, [pc, #228]	; (8014d4c <LOS_HistorySysCpuUsage+0x15c>)
 8014c66:	6819      	ldr	r1, [r3, #0]
 8014c68:	697a      	ldr	r2, [r7, #20]
 8014c6a:	4613      	mov	r3, r2
 8014c6c:	011b      	lsls	r3, r3, #4
 8014c6e:	1a9b      	subs	r3, r3, r2
 8014c70:	00db      	lsls	r3, r3, #3
 8014c72:	18ca      	adds	r2, r1, r3
 8014c74:	893b      	ldrh	r3, [r7, #8]
 8014c76:	3303      	adds	r3, #3
 8014c78:	00db      	lsls	r3, r3, #3
 8014c7a:	4413      	add	r3, r2
 8014c7c:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014c80:	4b32      	ldr	r3, [pc, #200]	; (8014d4c <LOS_HistorySysCpuUsage+0x15c>)
 8014c82:	681e      	ldr	r6, [r3, #0]
 8014c84:	697a      	ldr	r2, [r7, #20]
 8014c86:	4613      	mov	r3, r2
 8014c88:	011b      	lsls	r3, r3, #4
 8014c8a:	1a9b      	subs	r3, r3, r2
 8014c8c:	00db      	lsls	r3, r3, #3
 8014c8e:	18f2      	adds	r2, r6, r3
 8014c90:	897b      	ldrh	r3, [r7, #10]
 8014c92:	3303      	adds	r3, #3
 8014c94:	00db      	lsls	r3, r3, #3
 8014c96:	4413      	add	r3, r2
 8014c98:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014c9c:	1a84      	subs	r4, r0, r2
 8014c9e:	eb61 0503 	sbc.w	r5, r1, r3
 8014ca2:	e9c7 4506 	strd	r4, r5, [r7, #24]
#endif

    if (cpuCycleAll) {
 8014ca6:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8014caa:	4313      	orrs	r3, r2
 8014cac:	d033      	beq.n	8014d16 <LOS_HistorySysCpuUsage+0x126>
        cpup = (LOS_CPUP_PRECISION - (UINT32)((LOS_CPUP_PRECISION * idleCycleAll) / cpuCycleAll));
 8014cae:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8014cb2:	4602      	mov	r2, r0
 8014cb4:	460b      	mov	r3, r1
 8014cb6:	f04f 0400 	mov.w	r4, #0
 8014cba:	f04f 0500 	mov.w	r5, #0
 8014cbe:	015d      	lsls	r5, r3, #5
 8014cc0:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 8014cc4:	0154      	lsls	r4, r2, #5
 8014cc6:	4622      	mov	r2, r4
 8014cc8:	462b      	mov	r3, r5
 8014cca:	1a12      	subs	r2, r2, r0
 8014ccc:	eb63 0301 	sbc.w	r3, r3, r1
 8014cd0:	f04f 0400 	mov.w	r4, #0
 8014cd4:	f04f 0500 	mov.w	r5, #0
 8014cd8:	009d      	lsls	r5, r3, #2
 8014cda:	ea45 7592 	orr.w	r5, r5, r2, lsr #30
 8014cde:	0094      	lsls	r4, r2, #2
 8014ce0:	4622      	mov	r2, r4
 8014ce2:	462b      	mov	r3, r5
 8014ce4:	1812      	adds	r2, r2, r0
 8014ce6:	eb41 0303 	adc.w	r3, r1, r3
 8014cea:	f04f 0000 	mov.w	r0, #0
 8014cee:	f04f 0100 	mov.w	r1, #0
 8014cf2:	00d9      	lsls	r1, r3, #3
 8014cf4:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8014cf8:	00d0      	lsls	r0, r2, #3
 8014cfa:	4602      	mov	r2, r0
 8014cfc:	460b      	mov	r3, r1
 8014cfe:	4610      	mov	r0, r2
 8014d00:	4619      	mov	r1, r3
 8014d02:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8014d06:	f7eb fe45 	bl	8000994 <__aeabi_uldivmod>
 8014d0a:	4602      	mov	r2, r0
 8014d0c:	460b      	mov	r3, r1
 8014d0e:	4613      	mov	r3, r2
 8014d10:	f5c3 737a 	rsb	r3, r3, #1000	; 0x3e8
 8014d14:	60fb      	str	r3, [r7, #12]
    }

    OsTaskCycleStart();
 8014d16:	f7ff fda7 	bl	8014868 <OsTaskCycleStart>
    LOS_IntRestore(intSave);
 8014d1a:	6938      	ldr	r0, [r7, #16]
 8014d1c:	f7ff fba3 	bl	8014466 <LOS_IntRestore>

    return cpup;
 8014d20:	68fb      	ldr	r3, [r7, #12]
}
 8014d22:	4a06      	ldr	r2, [pc, #24]	; (8014d3c <LOS_HistorySysCpuUsage+0x14c>)
 8014d24:	6811      	ldr	r1, [r2, #0]
 8014d26:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014d28:	4051      	eors	r1, r2
 8014d2a:	d001      	beq.n	8014d30 <LOS_HistorySysCpuUsage+0x140>
 8014d2c:	f7ef fc56 	bl	80045dc <__stack_chk_fail>
 8014d30:	4618      	mov	r0, r3
 8014d32:	3734      	adds	r7, #52	; 0x34
 8014d34:	46bd      	mov	sp, r7
 8014d36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8014d3a:	bf00      	nop
 8014d3c:	0802292c 	.word	0x0802292c
 8014d40:	200032de 	.word	0x200032de
 8014d44:	02001e02 	.word	0x02001e02
 8014d48:	200032f0 	.word	0x200032f0
 8014d4c:	200032e0 	.word	0x200032e0

08014d50 <LOS_HistoryTaskCpuUsage>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_HistoryTaskCpuUsage(UINT32 taskId, UINT32 mode)
{
 8014d50:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8014d54:	b08e      	sub	sp, #56	; 0x38
 8014d56:	af00      	add	r7, sp, #0
 8014d58:	6078      	str	r0, [r7, #4]
 8014d5a:	6039      	str	r1, [r7, #0]
 8014d5c:	4b4c      	ldr	r3, [pc, #304]	; (8014e90 <LOS_HistoryTaskCpuUsage+0x140>)
 8014d5e:	681b      	ldr	r3, [r3, #0]
 8014d60:	637b      	str	r3, [r7, #52]	; 0x34
 8014d62:	f04f 0300 	mov.w	r3, #0
    UINT64 cpuCycleAll;
    UINT64 cpuCycleCurTask;
    UINT16 pos;
    UINT16 prePos;
    UINT32 intSave;
    UINT32 cpup = 0;
 8014d66:	2300      	movs	r3, #0
 8014d68:	613b      	str	r3, [r7, #16]
    UINT32 ret;

    if (g_cpupInitFlg == 0) {
 8014d6a:	4b4a      	ldr	r3, [pc, #296]	; (8014e94 <LOS_HistoryTaskCpuUsage+0x144>)
 8014d6c:	881b      	ldrh	r3, [r3, #0]
 8014d6e:	2b00      	cmp	r3, #0
 8014d70:	d101      	bne.n	8014d76 <LOS_HistoryTaskCpuUsage+0x26>
        return LOS_ERRNO_CPUP_NO_INIT;
 8014d72:	4b49      	ldr	r3, [pc, #292]	; (8014e98 <LOS_HistoryTaskCpuUsage+0x148>)
 8014d74:	e07f      	b.n	8014e76 <LOS_HistoryTaskCpuUsage+0x126>
    }

    ret = OsCpuUsageParaCheck(taskId);
 8014d76:	6878      	ldr	r0, [r7, #4]
 8014d78:	f7ff feee 	bl	8014b58 <OsCpuUsageParaCheck>
 8014d7c:	6178      	str	r0, [r7, #20]
    if (ret != LOS_OK) {
 8014d7e:	697b      	ldr	r3, [r7, #20]
 8014d80:	2b00      	cmp	r3, #0
 8014d82:	d001      	beq.n	8014d88 <LOS_HistoryTaskCpuUsage+0x38>
        return ret;
 8014d84:	697b      	ldr	r3, [r7, #20]
 8014d86:	e076      	b.n	8014e76 <LOS_HistoryTaskCpuUsage+0x126>
    }
    OsCpupCB *taskCpup = &g_cpup[taskId];
 8014d88:	4b44      	ldr	r3, [pc, #272]	; (8014e9c <LOS_HistoryTaskCpuUsage+0x14c>)
 8014d8a:	6819      	ldr	r1, [r3, #0]
 8014d8c:	687a      	ldr	r2, [r7, #4]
 8014d8e:	4613      	mov	r3, r2
 8014d90:	011b      	lsls	r3, r3, #4
 8014d92:	1a9b      	subs	r3, r3, r2
 8014d94:	00db      	lsls	r3, r3, #3
 8014d96:	440b      	add	r3, r1
 8014d98:	61bb      	str	r3, [r7, #24]

    intSave = LOS_IntLock();
 8014d9a:	f7ff fb5d 	bl	8014458 <LOS_IntLock>
 8014d9e:	61f8      	str	r0, [r7, #28]
    OsTaskCycleEnd();
 8014da0:	f7ff fd92 	bl	80148c8 <OsTaskCycleEnd>

    OsCpupGetPos(mode, &pos, &prePos);
 8014da4:	f107 020e 	add.w	r2, r7, #14
 8014da8:	f107 030c 	add.w	r3, r7, #12
 8014dac:	4619      	mov	r1, r3
 8014dae:	6838      	ldr	r0, [r7, #0]
 8014db0:	f7ff fe9c 	bl	8014aec <OsCpupGetPos>
    cpuCycleAll = cpuHistoryTime[pos] - cpuHistoryTime[prePos];
 8014db4:	89bb      	ldrh	r3, [r7, #12]
 8014db6:	4a3a      	ldr	r2, [pc, #232]	; (8014ea0 <LOS_HistoryTaskCpuUsage+0x150>)
 8014db8:	00db      	lsls	r3, r3, #3
 8014dba:	4413      	add	r3, r2
 8014dbc:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014dc0:	89fb      	ldrh	r3, [r7, #14]
 8014dc2:	4a37      	ldr	r2, [pc, #220]	; (8014ea0 <LOS_HistoryTaskCpuUsage+0x150>)
 8014dc4:	00db      	lsls	r3, r3, #3
 8014dc6:	4413      	add	r3, r2
 8014dc8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014dcc:	ebb0 0802 	subs.w	r8, r0, r2
 8014dd0:	eb61 0903 	sbc.w	r9, r1, r3
 8014dd4:	e9c7 8908 	strd	r8, r9, [r7, #32]
    cpuCycleCurTask = taskCpup->historyTime[pos] - taskCpup->historyTime[prePos];
 8014dd8:	89bb      	ldrh	r3, [r7, #12]
 8014dda:	69ba      	ldr	r2, [r7, #24]
 8014ddc:	3303      	adds	r3, #3
 8014dde:	00db      	lsls	r3, r3, #3
 8014de0:	4413      	add	r3, r2
 8014de2:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014de6:	89fb      	ldrh	r3, [r7, #14]
 8014de8:	69ba      	ldr	r2, [r7, #24]
 8014dea:	3303      	adds	r3, #3
 8014dec:	00db      	lsls	r3, r3, #3
 8014dee:	4413      	add	r3, r2
 8014df0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014df4:	1a84      	subs	r4, r0, r2
 8014df6:	eb61 0503 	sbc.w	r5, r1, r3
 8014dfa:	e9c7 450a 	strd	r4, r5, [r7, #40]	; 0x28
    if (cpuCycleAll) {
 8014dfe:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8014e02:	4313      	orrs	r3, r2
 8014e04:	d031      	beq.n	8014e6a <LOS_HistoryTaskCpuUsage+0x11a>
        cpup = (UINT32)((LOS_CPUP_PRECISION * cpuCycleCurTask) / cpuCycleAll);
 8014e06:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8014e0a:	4602      	mov	r2, r0
 8014e0c:	460b      	mov	r3, r1
 8014e0e:	f04f 0400 	mov.w	r4, #0
 8014e12:	f04f 0500 	mov.w	r5, #0
 8014e16:	015d      	lsls	r5, r3, #5
 8014e18:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 8014e1c:	0154      	lsls	r4, r2, #5
 8014e1e:	4622      	mov	r2, r4
 8014e20:	462b      	mov	r3, r5
 8014e22:	1a12      	subs	r2, r2, r0
 8014e24:	eb63 0301 	sbc.w	r3, r3, r1
 8014e28:	f04f 0400 	mov.w	r4, #0
 8014e2c:	f04f 0500 	mov.w	r5, #0
 8014e30:	009d      	lsls	r5, r3, #2
 8014e32:	ea45 7592 	orr.w	r5, r5, r2, lsr #30
 8014e36:	0094      	lsls	r4, r2, #2
 8014e38:	4622      	mov	r2, r4
 8014e3a:	462b      	mov	r3, r5
 8014e3c:	1812      	adds	r2, r2, r0
 8014e3e:	eb41 0303 	adc.w	r3, r1, r3
 8014e42:	f04f 0000 	mov.w	r0, #0
 8014e46:	f04f 0100 	mov.w	r1, #0
 8014e4a:	00d9      	lsls	r1, r3, #3
 8014e4c:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8014e50:	00d0      	lsls	r0, r2, #3
 8014e52:	4602      	mov	r2, r0
 8014e54:	460b      	mov	r3, r1
 8014e56:	4610      	mov	r0, r2
 8014e58:	4619      	mov	r1, r3
 8014e5a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8014e5e:	f7eb fd99 	bl	8000994 <__aeabi_uldivmod>
 8014e62:	4602      	mov	r2, r0
 8014e64:	460b      	mov	r3, r1
 8014e66:	4613      	mov	r3, r2
 8014e68:	613b      	str	r3, [r7, #16]
    }

    OsTaskCycleStart();
 8014e6a:	f7ff fcfd 	bl	8014868 <OsTaskCycleStart>
    LOS_IntRestore(intSave);
 8014e6e:	69f8      	ldr	r0, [r7, #28]
 8014e70:	f7ff faf9 	bl	8014466 <LOS_IntRestore>

    return cpup;
 8014e74:	693b      	ldr	r3, [r7, #16]
}
 8014e76:	4a06      	ldr	r2, [pc, #24]	; (8014e90 <LOS_HistoryTaskCpuUsage+0x140>)
 8014e78:	6811      	ldr	r1, [r2, #0]
 8014e7a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014e7c:	4051      	eors	r1, r2
 8014e7e:	d001      	beq.n	8014e84 <LOS_HistoryTaskCpuUsage+0x134>
 8014e80:	f7ef fbac 	bl	80045dc <__stack_chk_fail>
 8014e84:	4618      	mov	r0, r3
 8014e86:	3738      	adds	r7, #56	; 0x38
 8014e88:	46bd      	mov	sp, r7
 8014e8a:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 8014e8e:	bf00      	nop
 8014e90:	08022930 	.word	0x08022930
 8014e94:	200032de 	.word	0x200032de
 8014e98:	02001e02 	.word	0x02001e02
 8014e9c:	200032e0 	.word	0x200032e0
 8014ea0:	200032f0 	.word	0x200032f0

08014ea4 <LOS_AllCpuUsage>:

LITE_OS_SEC_TEXT_MINOR UINT32 LOS_AllCpuUsage(UINT16 maxNum, CPUP_INFO_S *cpupInfo, UINT32 mode, UINT16 flag)
{
 8014ea4:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8014ea8:	b08e      	sub	sp, #56	; 0x38
 8014eaa:	af00      	add	r7, sp, #0
 8014eac:	60b9      	str	r1, [r7, #8]
 8014eae:	607a      	str	r2, [r7, #4]
 8014eb0:	461a      	mov	r2, r3
 8014eb2:	4603      	mov	r3, r0
 8014eb4:	81fb      	strh	r3, [r7, #14]
 8014eb6:	4613      	mov	r3, r2
 8014eb8:	81bb      	strh	r3, [r7, #12]
 8014eba:	4b7b      	ldr	r3, [pc, #492]	; (80150a8 <LOS_AllCpuUsage+0x204>)
 8014ebc:	681b      	ldr	r3, [r3, #0]
 8014ebe:	637b      	str	r3, [r7, #52]	; 0x34
 8014ec0:	f04f 0300 	mov.w	r3, #0
    UINT16 pos;
    UINT16 prePos;
    UINT32 intSave;
    UINT64 cpuCycleAll;
    UINT64 cpuCycleCurTask;
    UINT16 numTmpMax = maxNum;
 8014ec4:	89fb      	ldrh	r3, [r7, #14]
 8014ec6:	82fb      	strh	r3, [r7, #22]
    UINT16 numTmpMin = 0;
 8014ec8:	2300      	movs	r3, #0
 8014eca:	833b      	strh	r3, [r7, #24]
    UINT16 numMax = g_cpupTaskMaxNum;
 8014ecc:	4b77      	ldr	r3, [pc, #476]	; (80150ac <LOS_AllCpuUsage+0x208>)
 8014ece:	881b      	ldrh	r3, [r3, #0]
 8014ed0:	837b      	strh	r3, [r7, #26]

    if (g_cpupInitFlg == 0) {
 8014ed2:	4b77      	ldr	r3, [pc, #476]	; (80150b0 <LOS_AllCpuUsage+0x20c>)
 8014ed4:	881b      	ldrh	r3, [r3, #0]
 8014ed6:	2b00      	cmp	r3, #0
 8014ed8:	d101      	bne.n	8014ede <LOS_AllCpuUsage+0x3a>
        return  LOS_ERRNO_CPUP_NO_INIT;
 8014eda:	4b76      	ldr	r3, [pc, #472]	; (80150b4 <LOS_AllCpuUsage+0x210>)
 8014edc:	e0d8      	b.n	8015090 <LOS_AllCpuUsage+0x1ec>
    }

    if (cpupInfo == NULL) {
 8014ede:	68bb      	ldr	r3, [r7, #8]
 8014ee0:	2b00      	cmp	r3, #0
 8014ee2:	d101      	bne.n	8014ee8 <LOS_AllCpuUsage+0x44>
        return LOS_ERRNO_CPUP_TASK_PTR_NULL;
 8014ee4:	4b74      	ldr	r3, [pc, #464]	; (80150b8 <LOS_AllCpuUsage+0x214>)
 8014ee6:	e0d3      	b.n	8015090 <LOS_AllCpuUsage+0x1ec>
    }

    if (maxNum == 0) {
 8014ee8:	89fb      	ldrh	r3, [r7, #14]
 8014eea:	2b00      	cmp	r3, #0
 8014eec:	d101      	bne.n	8014ef2 <LOS_AllCpuUsage+0x4e>
        return  LOS_ERRNO_CPUP_MAXNUM_INVALID;
 8014eee:	4b73      	ldr	r3, [pc, #460]	; (80150bc <LOS_AllCpuUsage+0x218>)
 8014ef0:	e0ce      	b.n	8015090 <LOS_AllCpuUsage+0x1ec>
    }

#ifdef LOSCFG_CPUP_INCLUDE_IRQ
    if (flag == 0) {
 8014ef2:	89bb      	ldrh	r3, [r7, #12]
 8014ef4:	2b00      	cmp	r3, #0
 8014ef6:	d10c      	bne.n	8014f12 <LOS_AllCpuUsage+0x6e>
        numTmpMax += g_cpupTaskMaxNum;
 8014ef8:	4b6c      	ldr	r3, [pc, #432]	; (80150ac <LOS_AllCpuUsage+0x208>)
 8014efa:	881a      	ldrh	r2, [r3, #0]
 8014efc:	8afb      	ldrh	r3, [r7, #22]
 8014efe:	4413      	add	r3, r2
 8014f00:	82fb      	strh	r3, [r7, #22]
        numTmpMin += g_cpupTaskMaxNum;
 8014f02:	4b6a      	ldr	r3, [pc, #424]	; (80150ac <LOS_AllCpuUsage+0x208>)
 8014f04:	881a      	ldrh	r2, [r3, #0]
 8014f06:	8b3b      	ldrh	r3, [r7, #24]
 8014f08:	4413      	add	r3, r2
 8014f0a:	833b      	strh	r3, [r7, #24]
        numMax = g_cpupMaxNum;
 8014f0c:	4b6c      	ldr	r3, [pc, #432]	; (80150c0 <LOS_AllCpuUsage+0x21c>)
 8014f0e:	881b      	ldrh	r3, [r3, #0]
 8014f10:	837b      	strh	r3, [r7, #26]
    }
#endif

    if (numTmpMax > numMax) {
 8014f12:	8afa      	ldrh	r2, [r7, #22]
 8014f14:	8b7b      	ldrh	r3, [r7, #26]
 8014f16:	429a      	cmp	r2, r3
 8014f18:	d901      	bls.n	8014f1e <LOS_AllCpuUsage+0x7a>
        numTmpMax = numMax;
 8014f1a:	8b7b      	ldrh	r3, [r7, #26]
 8014f1c:	82fb      	strh	r3, [r7, #22]
    }

    intSave = LOS_IntLock();
 8014f1e:	f7ff fa9b 	bl	8014458 <LOS_IntLock>
 8014f22:	61f8      	str	r0, [r7, #28]
    OsTaskCycleEnd();
 8014f24:	f7ff fcd0 	bl	80148c8 <OsTaskCycleEnd>

    OsCpupGetPos(mode, &pos, &prePos);
 8014f28:	f107 0212 	add.w	r2, r7, #18
 8014f2c:	f107 0310 	add.w	r3, r7, #16
 8014f30:	4619      	mov	r1, r3
 8014f32:	6878      	ldr	r0, [r7, #4]
 8014f34:	f7ff fdda 	bl	8014aec <OsCpupGetPos>
    cpuCycleAll = cpuHistoryTime[pos] - cpuHistoryTime[prePos];
 8014f38:	8a3b      	ldrh	r3, [r7, #16]
 8014f3a:	4a62      	ldr	r2, [pc, #392]	; (80150c4 <LOS_AllCpuUsage+0x220>)
 8014f3c:	00db      	lsls	r3, r3, #3
 8014f3e:	4413      	add	r3, r2
 8014f40:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014f44:	8a7b      	ldrh	r3, [r7, #18]
 8014f46:	4a5f      	ldr	r2, [pc, #380]	; (80150c4 <LOS_AllCpuUsage+0x220>)
 8014f48:	00db      	lsls	r3, r3, #3
 8014f4a:	4413      	add	r3, r2
 8014f4c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014f50:	1a84      	subs	r4, r0, r2
 8014f52:	eb61 0503 	sbc.w	r5, r1, r3
 8014f56:	e9c7 4508 	strd	r4, r5, [r7, #32]

    for (loop = numTmpMin; loop < numTmpMax; loop++) {
 8014f5a:	8b3b      	ldrh	r3, [r7, #24]
 8014f5c:	82bb      	strh	r3, [r7, #20]
 8014f5e:	e08c      	b.n	801507a <LOS_AllCpuUsage+0x1d6>
        if ((g_cpup[loop].status & OS_TASK_STATUS_UNUSED) || (g_cpup[loop].status == 0)) {
 8014f60:	4b59      	ldr	r3, [pc, #356]	; (80150c8 <LOS_AllCpuUsage+0x224>)
 8014f62:	6819      	ldr	r1, [r3, #0]
 8014f64:	8aba      	ldrh	r2, [r7, #20]
 8014f66:	4613      	mov	r3, r2
 8014f68:	011b      	lsls	r3, r3, #4
 8014f6a:	1a9b      	subs	r3, r3, r2
 8014f6c:	00db      	lsls	r3, r3, #3
 8014f6e:	440b      	add	r3, r1
 8014f70:	889b      	ldrh	r3, [r3, #4]
 8014f72:	f003 0301 	and.w	r3, r3, #1
 8014f76:	2b00      	cmp	r3, #0
 8014f78:	d17b      	bne.n	8015072 <LOS_AllCpuUsage+0x1ce>
 8014f7a:	4b53      	ldr	r3, [pc, #332]	; (80150c8 <LOS_AllCpuUsage+0x224>)
 8014f7c:	6819      	ldr	r1, [r3, #0]
 8014f7e:	8aba      	ldrh	r2, [r7, #20]
 8014f80:	4613      	mov	r3, r2
 8014f82:	011b      	lsls	r3, r3, #4
 8014f84:	1a9b      	subs	r3, r3, r2
 8014f86:	00db      	lsls	r3, r3, #3
 8014f88:	440b      	add	r3, r1
 8014f8a:	889b      	ldrh	r3, [r3, #4]
 8014f8c:	2b00      	cmp	r3, #0
 8014f8e:	d070      	beq.n	8015072 <LOS_AllCpuUsage+0x1ce>
            continue;
        }

        cpuCycleCurTask = g_cpup[loop].historyTime[pos] - g_cpup[loop].historyTime[prePos];
 8014f90:	4b4d      	ldr	r3, [pc, #308]	; (80150c8 <LOS_AllCpuUsage+0x224>)
 8014f92:	6819      	ldr	r1, [r3, #0]
 8014f94:	8aba      	ldrh	r2, [r7, #20]
 8014f96:	4613      	mov	r3, r2
 8014f98:	011b      	lsls	r3, r3, #4
 8014f9a:	1a9b      	subs	r3, r3, r2
 8014f9c:	00db      	lsls	r3, r3, #3
 8014f9e:	18ca      	adds	r2, r1, r3
 8014fa0:	8a3b      	ldrh	r3, [r7, #16]
 8014fa2:	3303      	adds	r3, #3
 8014fa4:	00db      	lsls	r3, r3, #3
 8014fa6:	4413      	add	r3, r2
 8014fa8:	e9d3 0100 	ldrd	r0, r1, [r3]
 8014fac:	4b46      	ldr	r3, [pc, #280]	; (80150c8 <LOS_AllCpuUsage+0x224>)
 8014fae:	681c      	ldr	r4, [r3, #0]
 8014fb0:	8aba      	ldrh	r2, [r7, #20]
 8014fb2:	4613      	mov	r3, r2
 8014fb4:	011b      	lsls	r3, r3, #4
 8014fb6:	1a9b      	subs	r3, r3, r2
 8014fb8:	00db      	lsls	r3, r3, #3
 8014fba:	18e2      	adds	r2, r4, r3
 8014fbc:	8a7b      	ldrh	r3, [r7, #18]
 8014fbe:	3303      	adds	r3, #3
 8014fc0:	00db      	lsls	r3, r3, #3
 8014fc2:	4413      	add	r3, r2
 8014fc4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014fc8:	ebb0 0802 	subs.w	r8, r0, r2
 8014fcc:	eb61 0903 	sbc.w	r9, r1, r3
 8014fd0:	e9c7 890a 	strd	r8, r9, [r7, #40]	; 0x28
        cpupInfo[loop - numTmpMin].usStatus = g_cpup[loop].status;
 8014fd4:	4b3c      	ldr	r3, [pc, #240]	; (80150c8 <LOS_AllCpuUsage+0x224>)
 8014fd6:	6819      	ldr	r1, [r3, #0]
 8014fd8:	8aba      	ldrh	r2, [r7, #20]
 8014fda:	4613      	mov	r3, r2
 8014fdc:	011b      	lsls	r3, r3, #4
 8014fde:	1a9b      	subs	r3, r3, r2
 8014fe0:	00db      	lsls	r3, r3, #3
 8014fe2:	18ca      	adds	r2, r1, r3
 8014fe4:	8ab9      	ldrh	r1, [r7, #20]
 8014fe6:	8b3b      	ldrh	r3, [r7, #24]
 8014fe8:	1acb      	subs	r3, r1, r3
 8014fea:	00db      	lsls	r3, r3, #3
 8014fec:	68b9      	ldr	r1, [r7, #8]
 8014fee:	440b      	add	r3, r1
 8014ff0:	8892      	ldrh	r2, [r2, #4]
 8014ff2:	801a      	strh	r2, [r3, #0]

        if (cpuCycleAll) {
 8014ff4:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8014ff8:	4313      	orrs	r3, r2
 8014ffa:	d03b      	beq.n	8015074 <LOS_AllCpuUsage+0x1d0>
            cpupInfo[loop - numTmpMin].uwUsage = (UINT32)((LOS_CPUP_PRECISION * cpuCycleCurTask) / cpuCycleAll);
 8014ffc:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8015000:	4602      	mov	r2, r0
 8015002:	460b      	mov	r3, r1
 8015004:	f04f 0400 	mov.w	r4, #0
 8015008:	f04f 0500 	mov.w	r5, #0
 801500c:	015d      	lsls	r5, r3, #5
 801500e:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 8015012:	0154      	lsls	r4, r2, #5
 8015014:	4622      	mov	r2, r4
 8015016:	462b      	mov	r3, r5
 8015018:	1a12      	subs	r2, r2, r0
 801501a:	eb63 0301 	sbc.w	r3, r3, r1
 801501e:	f04f 0400 	mov.w	r4, #0
 8015022:	f04f 0500 	mov.w	r5, #0
 8015026:	009d      	lsls	r5, r3, #2
 8015028:	ea45 7592 	orr.w	r5, r5, r2, lsr #30
 801502c:	0094      	lsls	r4, r2, #2
 801502e:	4622      	mov	r2, r4
 8015030:	462b      	mov	r3, r5
 8015032:	1812      	adds	r2, r2, r0
 8015034:	eb41 0303 	adc.w	r3, r1, r3
 8015038:	f04f 0000 	mov.w	r0, #0
 801503c:	f04f 0100 	mov.w	r1, #0
 8015040:	00d9      	lsls	r1, r3, #3
 8015042:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 8015046:	00d0      	lsls	r0, r2, #3
 8015048:	4602      	mov	r2, r0
 801504a:	460b      	mov	r3, r1
 801504c:	4610      	mov	r0, r2
 801504e:	4619      	mov	r1, r3
 8015050:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8015054:	f7eb fc9e 	bl	8000994 <__aeabi_uldivmod>
 8015058:	4602      	mov	r2, r0
 801505a:	460b      	mov	r3, r1
 801505c:	4610      	mov	r0, r2
 801505e:	4619      	mov	r1, r3
 8015060:	8aba      	ldrh	r2, [r7, #20]
 8015062:	8b3b      	ldrh	r3, [r7, #24]
 8015064:	1ad3      	subs	r3, r2, r3
 8015066:	00db      	lsls	r3, r3, #3
 8015068:	68ba      	ldr	r2, [r7, #8]
 801506a:	4413      	add	r3, r2
 801506c:	4602      	mov	r2, r0
 801506e:	605a      	str	r2, [r3, #4]
 8015070:	e000      	b.n	8015074 <LOS_AllCpuUsage+0x1d0>
            continue;
 8015072:	bf00      	nop
    for (loop = numTmpMin; loop < numTmpMax; loop++) {
 8015074:	8abb      	ldrh	r3, [r7, #20]
 8015076:	3301      	adds	r3, #1
 8015078:	82bb      	strh	r3, [r7, #20]
 801507a:	8aba      	ldrh	r2, [r7, #20]
 801507c:	8afb      	ldrh	r3, [r7, #22]
 801507e:	429a      	cmp	r2, r3
 8015080:	f4ff af6e 	bcc.w	8014f60 <LOS_AllCpuUsage+0xbc>
        }
    }

    OsTaskCycleStart();
 8015084:	f7ff fbf0 	bl	8014868 <OsTaskCycleStart>
    LOS_IntRestore(intSave);
 8015088:	69f8      	ldr	r0, [r7, #28]
 801508a:	f7ff f9ec 	bl	8014466 <LOS_IntRestore>

    return LOS_OK;
 801508e:	2300      	movs	r3, #0
}
 8015090:	4a05      	ldr	r2, [pc, #20]	; (80150a8 <LOS_AllCpuUsage+0x204>)
 8015092:	6811      	ldr	r1, [r2, #0]
 8015094:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8015096:	4051      	eors	r1, r2
 8015098:	d001      	beq.n	801509e <LOS_AllCpuUsage+0x1fa>
 801509a:	f7ef fa9f 	bl	80045dc <__stack_chk_fail>
 801509e:	4618      	mov	r0, r3
 80150a0:	3738      	adds	r7, #56	; 0x38
 80150a2:	46bd      	mov	sp, r7
 80150a4:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 80150a8:	08022934 	.word	0x08022934
 80150ac:	200032e6 	.word	0x200032e6
 80150b0:	200032de 	.word	0x200032de
 80150b4:	02001e02 	.word	0x02001e02
 80150b8:	02001e01 	.word	0x02001e01
 80150bc:	02001e03 	.word	0x02001e03
 80150c0:	200032e4 	.word	0x200032e4
 80150c4:	200032f0 	.word	0x200032f0
 80150c8:	200032e0 	.word	0x200032e0

080150cc <OsCpupIrqStart>:

#ifdef LOSCFG_CPUP_INCLUDE_IRQ
LITE_OS_SEC_TEXT_MINOR VOID OsCpupIrqStart(VOID)
{
 80150cc:	b598      	push	{r3, r4, r7, lr}
 80150ce:	af00      	add	r7, sp, #0
    g_intTimeStart[ArchCurrCpuid()] = OsCpupGetCycle();
 80150d0:	f7ff f9ba 	bl	8014448 <ArchCurrCpuid>
 80150d4:	4604      	mov	r4, r0
 80150d6:	f7ff fb61 	bl	801479c <OsCpupGetCycle>
 80150da:	4602      	mov	r2, r0
 80150dc:	460b      	mov	r3, r1
 80150de:	4803      	ldr	r0, [pc, #12]	; (80150ec <OsCpupIrqStart+0x20>)
 80150e0:	00e1      	lsls	r1, r4, #3
 80150e2:	4401      	add	r1, r0
 80150e4:	e9c1 2300 	strd	r2, r3, [r1]
    return;
 80150e8:	bf00      	nop
}
 80150ea:	bd98      	pop	{r3, r4, r7, pc}
 80150ec:	20003358 	.word	0x20003358

080150f0 <OsCpupIrqEnd>:

LITE_OS_SEC_TEXT_MINOR VOID OsCpupIrqEnd(UINT32 intNum)
{
 80150f0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80150f4:	b08a      	sub	sp, #40	; 0x28
 80150f6:	af00      	add	r7, sp, #0
 80150f8:	6178      	str	r0, [r7, #20]
    UINT64 intTimeEnd = OsCpupGetCycle();
 80150fa:	f7ff fb4f 	bl	801479c <OsCpupGetCycle>
 80150fe:	e9c7 0108 	strd	r0, r1, [r7, #32]
    UINT32 cpuId = ArchCurrCpuid();
 8015102:	f7ff f9a1 	bl	8014448 <ArchCurrCpuid>
 8015106:	61f8      	str	r0, [r7, #28]

    if (g_cpupInitFlg == 0) {
 8015108:	4b37      	ldr	r3, [pc, #220]	; (80151e8 <OsCpupIrqEnd+0xf8>)
 801510a:	881b      	ldrh	r3, [r3, #0]
 801510c:	2b00      	cmp	r3, #0
 801510e:	d066      	beq.n	80151de <OsCpupIrqEnd+0xee>
        return;
    }

    g_cpup[g_taskMaxNum + intNum].id = intNum;
 8015110:	4b36      	ldr	r3, [pc, #216]	; (80151ec <OsCpupIrqEnd+0xfc>)
 8015112:	6819      	ldr	r1, [r3, #0]
 8015114:	4b36      	ldr	r3, [pc, #216]	; (80151f0 <OsCpupIrqEnd+0x100>)
 8015116:	681a      	ldr	r2, [r3, #0]
 8015118:	697b      	ldr	r3, [r7, #20]
 801511a:	441a      	add	r2, r3
 801511c:	4613      	mov	r3, r2
 801511e:	011b      	lsls	r3, r3, #4
 8015120:	1a9b      	subs	r3, r3, r2
 8015122:	00db      	lsls	r3, r3, #3
 8015124:	440b      	add	r3, r1
 8015126:	697a      	ldr	r2, [r7, #20]
 8015128:	601a      	str	r2, [r3, #0]
    g_cpup[g_taskMaxNum + intNum].status = OS_TASK_STATUS_RUNNING;
 801512a:	4b30      	ldr	r3, [pc, #192]	; (80151ec <OsCpupIrqEnd+0xfc>)
 801512c:	6819      	ldr	r1, [r3, #0]
 801512e:	4b30      	ldr	r3, [pc, #192]	; (80151f0 <OsCpupIrqEnd+0x100>)
 8015130:	681a      	ldr	r2, [r3, #0]
 8015132:	697b      	ldr	r3, [r7, #20]
 8015134:	441a      	add	r2, r3
 8015136:	4613      	mov	r3, r2
 8015138:	011b      	lsls	r3, r3, #4
 801513a:	1a9b      	subs	r3, r3, r2
 801513c:	00db      	lsls	r3, r3, #3
 801513e:	440b      	add	r3, r1
 8015140:	2210      	movs	r2, #16
 8015142:	809a      	strh	r2, [r3, #4]
    g_timeInIrqPerTskSwitch[cpuId] += (intTimeEnd - g_intTimeStart[cpuId]);
 8015144:	4a2b      	ldr	r2, [pc, #172]	; (80151f4 <OsCpupIrqEnd+0x104>)
 8015146:	69fb      	ldr	r3, [r7, #28]
 8015148:	00db      	lsls	r3, r3, #3
 801514a:	4413      	add	r3, r2
 801514c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8015150:	4829      	ldr	r0, [pc, #164]	; (80151f8 <OsCpupIrqEnd+0x108>)
 8015152:	69f9      	ldr	r1, [r7, #28]
 8015154:	00c9      	lsls	r1, r1, #3
 8015156:	4401      	add	r1, r0
 8015158:	e9d1 0100 	ldrd	r0, r1, [r1]
 801515c:	e9d7 ab08 	ldrd	sl, fp, [r7, #32]
 8015160:	ebba 0400 	subs.w	r4, sl, r0
 8015164:	eb6b 0501 	sbc.w	r5, fp, r1
 8015168:	1911      	adds	r1, r2, r4
 801516a:	60b9      	str	r1, [r7, #8]
 801516c:	416b      	adcs	r3, r5
 801516e:	60fb      	str	r3, [r7, #12]
 8015170:	4a20      	ldr	r2, [pc, #128]	; (80151f4 <OsCpupIrqEnd+0x104>)
 8015172:	69fb      	ldr	r3, [r7, #28]
 8015174:	00db      	lsls	r3, r3, #3
 8015176:	4413      	add	r3, r2
 8015178:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 801517c:	e9c3 1200 	strd	r1, r2, [r3]
    g_cpup[g_taskMaxNum + intNum].allTime += (intTimeEnd - g_intTimeStart[cpuId]);
 8015180:	4b1a      	ldr	r3, [pc, #104]	; (80151ec <OsCpupIrqEnd+0xfc>)
 8015182:	6819      	ldr	r1, [r3, #0]
 8015184:	4b1a      	ldr	r3, [pc, #104]	; (80151f0 <OsCpupIrqEnd+0x100>)
 8015186:	681a      	ldr	r2, [r3, #0]
 8015188:	697b      	ldr	r3, [r7, #20]
 801518a:	441a      	add	r2, r3
 801518c:	4613      	mov	r3, r2
 801518e:	011b      	lsls	r3, r3, #4
 8015190:	1a9b      	subs	r3, r3, r2
 8015192:	00db      	lsls	r3, r3, #3
 8015194:	440b      	add	r3, r1
 8015196:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 801519a:	4a17      	ldr	r2, [pc, #92]	; (80151f8 <OsCpupIrqEnd+0x108>)
 801519c:	69fb      	ldr	r3, [r7, #28]
 801519e:	00db      	lsls	r3, r3, #3
 80151a0:	4413      	add	r3, r2
 80151a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80151a6:	e9d7 4508 	ldrd	r4, r5, [r7, #32]
 80151aa:	ebb4 0802 	subs.w	r8, r4, r2
 80151ae:	eb65 0903 	sbc.w	r9, r5, r3
 80151b2:	4b0e      	ldr	r3, [pc, #56]	; (80151ec <OsCpupIrqEnd+0xfc>)
 80151b4:	681c      	ldr	r4, [r3, #0]
 80151b6:	4b0e      	ldr	r3, [pc, #56]	; (80151f0 <OsCpupIrqEnd+0x100>)
 80151b8:	681a      	ldr	r2, [r3, #0]
 80151ba:	697b      	ldr	r3, [r7, #20]
 80151bc:	441a      	add	r2, r3
 80151be:	4613      	mov	r3, r2
 80151c0:	011b      	lsls	r3, r3, #4
 80151c2:	1a9b      	subs	r3, r3, r2
 80151c4:	00db      	lsls	r3, r3, #3
 80151c6:	4423      	add	r3, r4
 80151c8:	eb10 0208 	adds.w	r2, r0, r8
 80151cc:	603a      	str	r2, [r7, #0]
 80151ce:	eb41 0209 	adc.w	r2, r1, r9
 80151d2:	607a      	str	r2, [r7, #4]
 80151d4:	e9d7 1200 	ldrd	r1, r2, [r7]
 80151d8:	e9c3 1202 	strd	r1, r2, [r3, #8]

    return;
 80151dc:	e000      	b.n	80151e0 <OsCpupIrqEnd+0xf0>
        return;
 80151de:	bf00      	nop
}
 80151e0:	3728      	adds	r7, #40	; 0x28
 80151e2:	46bd      	mov	sp, r7
 80151e4:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80151e8:	200032de 	.word	0x200032de
 80151ec:	200032e0 	.word	0x200032e0
 80151f0:	200036d8 	.word	0x200036d8
 80151f4:	20003770 	.word	0x20003770
 80151f8:	20003358 	.word	0x20003358

080151fc <OsCmdCpupOperateOneParam>:
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

VOID OsCmdCpupOperateOneParam(UINT32 mode)
{
 80151fc:	b580      	push	{r7, lr}
 80151fe:	b084      	sub	sp, #16
 8015200:	af00      	add	r7, sp, #0
 8015202:	6078      	str	r0, [r7, #4]
    UINT32 ret;

    if (mode == CPUP_LAST_TEN_SECONDS) {
 8015204:	687b      	ldr	r3, [r7, #4]
 8015206:	2b00      	cmp	r3, #0
 8015208:	d103      	bne.n	8015212 <OsCmdCpupOperateOneParam+0x16>
        PRINTK("\nSysCpuUsage in 10s: ");
 801520a:	4814      	ldr	r0, [pc, #80]	; (801525c <OsCmdCpupOperateOneParam+0x60>)
 801520c:	f7ef fb58 	bl	80048c0 <dprintf>
 8015210:	e009      	b.n	8015226 <OsCmdCpupOperateOneParam+0x2a>
    } else if (mode == CPUP_LAST_ONE_SECONDS) {
 8015212:	687b      	ldr	r3, [r7, #4]
 8015214:	2b01      	cmp	r3, #1
 8015216:	d103      	bne.n	8015220 <OsCmdCpupOperateOneParam+0x24>
        PRINTK("\nSysCpuUsage in 1s: ");
 8015218:	4811      	ldr	r0, [pc, #68]	; (8015260 <OsCmdCpupOperateOneParam+0x64>)
 801521a:	f7ef fb51 	bl	80048c0 <dprintf>
 801521e:	e002      	b.n	8015226 <OsCmdCpupOperateOneParam+0x2a>
    } else {
        PRINTK("\nSysCpuUsage in all time: ");
 8015220:	4810      	ldr	r0, [pc, #64]	; (8015264 <OsCmdCpupOperateOneParam+0x68>)
 8015222:	f7ef fb4d 	bl	80048c0 <dprintf>
    }
    ret = LOS_HistorySysCpuUsage(mode);
 8015226:	6878      	ldr	r0, [r7, #4]
 8015228:	f7ff fce2 	bl	8014bf0 <LOS_HistorySysCpuUsage>
 801522c:	60f8      	str	r0, [r7, #12]
    PRINTK("%u.%u", ret / LOS_CPUP_PRECISION_MULT, ret % LOS_CPUP_PRECISION_MULT);
 801522e:	68fb      	ldr	r3, [r7, #12]
 8015230:	4a0d      	ldr	r2, [pc, #52]	; (8015268 <OsCmdCpupOperateOneParam+0x6c>)
 8015232:	fba2 2303 	umull	r2, r3, r2, r3
 8015236:	08d8      	lsrs	r0, r3, #3
 8015238:	68f9      	ldr	r1, [r7, #12]
 801523a:	4b0b      	ldr	r3, [pc, #44]	; (8015268 <OsCmdCpupOperateOneParam+0x6c>)
 801523c:	fba3 2301 	umull	r2, r3, r3, r1
 8015240:	08da      	lsrs	r2, r3, #3
 8015242:	4613      	mov	r3, r2
 8015244:	009b      	lsls	r3, r3, #2
 8015246:	4413      	add	r3, r2
 8015248:	005b      	lsls	r3, r3, #1
 801524a:	1aca      	subs	r2, r1, r3
 801524c:	4601      	mov	r1, r0
 801524e:	4807      	ldr	r0, [pc, #28]	; (801526c <OsCmdCpupOperateOneParam+0x70>)
 8015250:	f7ef fb36 	bl	80048c0 <dprintf>
}
 8015254:	bf00      	nop
 8015256:	3710      	adds	r7, #16
 8015258:	46bd      	mov	sp, r7
 801525a:	bd80      	pop	{r7, pc}
 801525c:	08022938 	.word	0x08022938
 8015260:	08022950 	.word	0x08022950
 8015264:	08022968 	.word	0x08022968
 8015268:	cccccccd 	.word	0xcccccccd
 801526c:	08022984 	.word	0x08022984

08015270 <OsCmdCpupOperateTwoParam>:

VOID OsCmdCpupOperateTwoParam(UINT32 mode, UINT32 taskId)
{
 8015270:	b580      	push	{r7, lr}
 8015272:	b084      	sub	sp, #16
 8015274:	af00      	add	r7, sp, #0
 8015276:	6078      	str	r0, [r7, #4]
 8015278:	6039      	str	r1, [r7, #0]
    UINT32 ret;

    if (mode == CPUP_LAST_TEN_SECONDS) {
 801527a:	687b      	ldr	r3, [r7, #4]
 801527c:	2b00      	cmp	r3, #0
 801527e:	d104      	bne.n	801528a <OsCmdCpupOperateTwoParam+0x1a>
        PRINTK("\nTaskId %u CpuUsage in 10s: ", taskId);
 8015280:	6839      	ldr	r1, [r7, #0]
 8015282:	4816      	ldr	r0, [pc, #88]	; (80152dc <OsCmdCpupOperateTwoParam+0x6c>)
 8015284:	f7ef fb1c 	bl	80048c0 <dprintf>
 8015288:	e00b      	b.n	80152a2 <OsCmdCpupOperateTwoParam+0x32>
    } else if (mode == CPUP_LAST_ONE_SECONDS) {
 801528a:	687b      	ldr	r3, [r7, #4]
 801528c:	2b01      	cmp	r3, #1
 801528e:	d104      	bne.n	801529a <OsCmdCpupOperateTwoParam+0x2a>
        PRINTK("\nTaskId %u CpuUsage in 1s: ", taskId);
 8015290:	6839      	ldr	r1, [r7, #0]
 8015292:	4813      	ldr	r0, [pc, #76]	; (80152e0 <OsCmdCpupOperateTwoParam+0x70>)
 8015294:	f7ef fb14 	bl	80048c0 <dprintf>
 8015298:	e003      	b.n	80152a2 <OsCmdCpupOperateTwoParam+0x32>
    } else {
        PRINTK("\nTaskId %u CpuUsage in all time: ", taskId);
 801529a:	6839      	ldr	r1, [r7, #0]
 801529c:	4811      	ldr	r0, [pc, #68]	; (80152e4 <OsCmdCpupOperateTwoParam+0x74>)
 801529e:	f7ef fb0f 	bl	80048c0 <dprintf>
    }
    ret = LOS_HistoryTaskCpuUsage(taskId, mode);
 80152a2:	6879      	ldr	r1, [r7, #4]
 80152a4:	6838      	ldr	r0, [r7, #0]
 80152a6:	f7ff fd53 	bl	8014d50 <LOS_HistoryTaskCpuUsage>
 80152aa:	60f8      	str	r0, [r7, #12]
    PRINTK("%u.%u", ret / LOS_CPUP_PRECISION_MULT, ret % LOS_CPUP_PRECISION_MULT);
 80152ac:	68fb      	ldr	r3, [r7, #12]
 80152ae:	4a0e      	ldr	r2, [pc, #56]	; (80152e8 <OsCmdCpupOperateTwoParam+0x78>)
 80152b0:	fba2 2303 	umull	r2, r3, r2, r3
 80152b4:	08d8      	lsrs	r0, r3, #3
 80152b6:	68f9      	ldr	r1, [r7, #12]
 80152b8:	4b0b      	ldr	r3, [pc, #44]	; (80152e8 <OsCmdCpupOperateTwoParam+0x78>)
 80152ba:	fba3 2301 	umull	r2, r3, r3, r1
 80152be:	08da      	lsrs	r2, r3, #3
 80152c0:	4613      	mov	r3, r2
 80152c2:	009b      	lsls	r3, r3, #2
 80152c4:	4413      	add	r3, r2
 80152c6:	005b      	lsls	r3, r3, #1
 80152c8:	1aca      	subs	r2, r1, r3
 80152ca:	4601      	mov	r1, r0
 80152cc:	4807      	ldr	r0, [pc, #28]	; (80152ec <OsCmdCpupOperateTwoParam+0x7c>)
 80152ce:	f7ef faf7 	bl	80048c0 <dprintf>
}
 80152d2:	bf00      	nop
 80152d4:	3710      	adds	r7, #16
 80152d6:	46bd      	mov	sp, r7
 80152d8:	bd80      	pop	{r7, pc}
 80152da:	bf00      	nop
 80152dc:	0802298c 	.word	0x0802298c
 80152e0:	080229ac 	.word	0x080229ac
 80152e4:	080229c8 	.word	0x080229c8
 80152e8:	cccccccd 	.word	0xcccccccd
 80152ec:	08022984 	.word	0x08022984

080152f0 <OsShellCmdCpup>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdCpup(INT32 argc, const CHAR **argv)
{
 80152f0:	b580      	push	{r7, lr}
 80152f2:	b08a      	sub	sp, #40	; 0x28
 80152f4:	af00      	add	r7, sp, #0
 80152f6:	6078      	str	r0, [r7, #4]
 80152f8:	6039      	str	r1, [r7, #0]
 80152fa:	4b47      	ldr	r3, [pc, #284]	; (8015418 <OsShellCmdCpup+0x128>)
 80152fc:	681b      	ldr	r3, [r3, #0]
 80152fe:	627b      	str	r3, [r7, #36]	; 0x24
 8015300:	f04f 0300 	mov.w	r3, #0
    size_t mode, taskId;
    CHAR *bufMode = NULL;
 8015304:	2300      	movs	r3, #0
 8015306:	60fb      	str	r3, [r7, #12]
    CHAR *bufId = NULL;
 8015308:	2300      	movs	r3, #0
 801530a:	613b      	str	r3, [r7, #16]
    LosTaskCB *taskCB = NULL;
 801530c:	2300      	movs	r3, #0
 801530e:	61bb      	str	r3, [r7, #24]
    UINT32 ret;

    if (argc <= 0) {
 8015310:	687b      	ldr	r3, [r7, #4]
 8015312:	2b00      	cmp	r3, #0
 8015314:	dc18      	bgt.n	8015348 <OsShellCmdCpup+0x58>
        ret = LOS_HistorySysCpuUsage(CPUP_LAST_TEN_SECONDS);
 8015316:	2000      	movs	r0, #0
 8015318:	f7ff fc6a 	bl	8014bf0 <LOS_HistorySysCpuUsage>
 801531c:	6238      	str	r0, [r7, #32]
        PRINTK("\nSysCpuUsage in 10s: %u.%u", ret / LOS_CPUP_PRECISION_MULT, ret % LOS_CPUP_PRECISION_MULT);
 801531e:	6a3b      	ldr	r3, [r7, #32]
 8015320:	4a3e      	ldr	r2, [pc, #248]	; (801541c <OsShellCmdCpup+0x12c>)
 8015322:	fba2 2303 	umull	r2, r3, r2, r3
 8015326:	08d8      	lsrs	r0, r3, #3
 8015328:	6a39      	ldr	r1, [r7, #32]
 801532a:	4b3c      	ldr	r3, [pc, #240]	; (801541c <OsShellCmdCpup+0x12c>)
 801532c:	fba3 2301 	umull	r2, r3, r3, r1
 8015330:	08da      	lsrs	r2, r3, #3
 8015332:	4613      	mov	r3, r2
 8015334:	009b      	lsls	r3, r3, #2
 8015336:	4413      	add	r3, r2
 8015338:	005b      	lsls	r3, r3, #1
 801533a:	1aca      	subs	r2, r1, r3
 801533c:	4601      	mov	r1, r0
 801533e:	4838      	ldr	r0, [pc, #224]	; (8015420 <OsShellCmdCpup+0x130>)
 8015340:	f7ef fabe 	bl	80048c0 <dprintf>
        return 0;
 8015344:	2300      	movs	r3, #0
 8015346:	e05c      	b.n	8015402 <OsShellCmdCpup+0x112>
    }

    mode = strtoul(argv[0], &bufMode, 0);
 8015348:	683b      	ldr	r3, [r7, #0]
 801534a:	681b      	ldr	r3, [r3, #0]
 801534c:	f107 010c 	add.w	r1, r7, #12
 8015350:	2200      	movs	r2, #0
 8015352:	4618      	mov	r0, r3
 8015354:	f7fa f97e 	bl	800f654 <strtoul>
 8015358:	6178      	str	r0, [r7, #20]
    if ((bufMode == NULL) || (*bufMode != 0)) {
 801535a:	68fb      	ldr	r3, [r7, #12]
 801535c:	2b00      	cmp	r3, #0
 801535e:	d003      	beq.n	8015368 <OsShellCmdCpup+0x78>
 8015360:	68fb      	ldr	r3, [r7, #12]
 8015362:	781b      	ldrb	r3, [r3, #0]
 8015364:	2b00      	cmp	r3, #0
 8015366:	d004      	beq.n	8015372 <OsShellCmdCpup+0x82>
        PRINTK("\nThe input mode is invalid. Please try again.\n");
 8015368:	482e      	ldr	r0, [pc, #184]	; (8015424 <OsShellCmdCpup+0x134>)
 801536a:	f7ef faa9 	bl	80048c0 <dprintf>
        return 0;
 801536e:	2300      	movs	r3, #0
 8015370:	e047      	b.n	8015402 <OsShellCmdCpup+0x112>
    }

    if (mode > CPUP_ALL_TIME) {
 8015372:	697b      	ldr	r3, [r7, #20]
 8015374:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8015378:	d302      	bcc.n	8015380 <OsShellCmdCpup+0x90>
        mode = CPUP_ALL_TIME;
 801537a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801537e:	617b      	str	r3, [r7, #20]
    }

    if (argc == 1) {
 8015380:	687b      	ldr	r3, [r7, #4]
 8015382:	2b01      	cmp	r3, #1
 8015384:	d104      	bne.n	8015390 <OsShellCmdCpup+0xa0>
        OsCmdCpupOperateOneParam((UINT32)mode);
 8015386:	6978      	ldr	r0, [r7, #20]
 8015388:	f7ff ff38 	bl	80151fc <OsCmdCpupOperateOneParam>
        return 0;
 801538c:	2300      	movs	r3, #0
 801538e:	e038      	b.n	8015402 <OsShellCmdCpup+0x112>
    }

    taskId = strtoul(argv[1], &bufId, 0);
 8015390:	683b      	ldr	r3, [r7, #0]
 8015392:	3304      	adds	r3, #4
 8015394:	681b      	ldr	r3, [r3, #0]
 8015396:	f107 0110 	add.w	r1, r7, #16
 801539a:	2200      	movs	r2, #0
 801539c:	4618      	mov	r0, r3
 801539e:	f7fa f959 	bl	800f654 <strtoul>
 80153a2:	61f8      	str	r0, [r7, #28]
    if ((taskId >= g_taskMaxNum) || (*bufId != 0)) {
 80153a4:	4b20      	ldr	r3, [pc, #128]	; (8015428 <OsShellCmdCpup+0x138>)
 80153a6:	681b      	ldr	r3, [r3, #0]
 80153a8:	69fa      	ldr	r2, [r7, #28]
 80153aa:	429a      	cmp	r2, r3
 80153ac:	d203      	bcs.n	80153b6 <OsShellCmdCpup+0xc6>
 80153ae:	693b      	ldr	r3, [r7, #16]
 80153b0:	781b      	ldrb	r3, [r3, #0]
 80153b2:	2b00      	cmp	r3, #0
 80153b4:	d004      	beq.n	80153c0 <OsShellCmdCpup+0xd0>
        PRINTK("\nThe input taskId is invalid. Please try again.\n");
 80153b6:	481d      	ldr	r0, [pc, #116]	; (801542c <OsShellCmdCpup+0x13c>)
 80153b8:	f7ef fa82 	bl	80048c0 <dprintf>
        return 0;
 80153bc:	2300      	movs	r3, #0
 80153be:	e020      	b.n	8015402 <OsShellCmdCpup+0x112>
    }
    taskCB = OS_TCB_FROM_TID(taskId);
 80153c0:	4b1b      	ldr	r3, [pc, #108]	; (8015430 <OsShellCmdCpup+0x140>)
 80153c2:	6819      	ldr	r1, [r3, #0]
 80153c4:	69fa      	ldr	r2, [r7, #28]
 80153c6:	4613      	mov	r3, r2
 80153c8:	009b      	lsls	r3, r3, #2
 80153ca:	4413      	add	r3, r2
 80153cc:	015b      	lsls	r3, r3, #5
 80153ce:	440b      	add	r3, r1
 80153d0:	61bb      	str	r3, [r7, #24]
    if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 80153d2:	69bb      	ldr	r3, [r7, #24]
 80153d4:	889b      	ldrh	r3, [r3, #4]
 80153d6:	f003 0301 	and.w	r3, r3, #1
 80153da:	2b00      	cmp	r3, #0
 80153dc:	d004      	beq.n	80153e8 <OsShellCmdCpup+0xf8>
        PRINTK("\nThe task is unused. Please try again.\n");
 80153de:	4815      	ldr	r0, [pc, #84]	; (8015434 <OsShellCmdCpup+0x144>)
 80153e0:	f7ef fa6e 	bl	80048c0 <dprintf>
        return 0;
 80153e4:	2300      	movs	r3, #0
 80153e6:	e00c      	b.n	8015402 <OsShellCmdCpup+0x112>
    }

    if (argc == 2) {
 80153e8:	687b      	ldr	r3, [r7, #4]
 80153ea:	2b02      	cmp	r3, #2
 80153ec:	d105      	bne.n	80153fa <OsShellCmdCpup+0x10a>
        OsCmdCpupOperateTwoParam((UINT32)mode, (UINT32)taskId);
 80153ee:	69f9      	ldr	r1, [r7, #28]
 80153f0:	6978      	ldr	r0, [r7, #20]
 80153f2:	f7ff ff3d 	bl	8015270 <OsCmdCpupOperateTwoParam>
        return 0;
 80153f6:	2300      	movs	r3, #0
 80153f8:	e003      	b.n	8015402 <OsShellCmdCpup+0x112>
    }

    PRINTK("cpup [MODE] \ncpup [MODE] [TASKID] \n");
 80153fa:	480f      	ldr	r0, [pc, #60]	; (8015438 <OsShellCmdCpup+0x148>)
 80153fc:	f7ef fa60 	bl	80048c0 <dprintf>
    return 0;
 8015400:	2300      	movs	r3, #0
}
 8015402:	4a05      	ldr	r2, [pc, #20]	; (8015418 <OsShellCmdCpup+0x128>)
 8015404:	6811      	ldr	r1, [r2, #0]
 8015406:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015408:	4051      	eors	r1, r2
 801540a:	d001      	beq.n	8015410 <OsShellCmdCpup+0x120>
 801540c:	f7ef f8e6 	bl	80045dc <__stack_chk_fail>
 8015410:	4618      	mov	r0, r3
 8015412:	3728      	adds	r7, #40	; 0x28
 8015414:	46bd      	mov	sp, r7
 8015416:	bd80      	pop	{r7, pc}
 8015418:	08022ab8 	.word	0x08022ab8
 801541c:	cccccccd 	.word	0xcccccccd
 8015420:	080229ec 	.word	0x080229ec
 8015424:	08022a08 	.word	0x08022a08
 8015428:	200036d8 	.word	0x200036d8
 801542c:	08022a38 	.word	0x08022a38
 8015430:	200036c4 	.word	0x200036c4
 8015434:	08022a6c 	.word	0x08022a6c
 8015438:	08022a94 	.word	0x08022a94

0801543c <ArchCurrCpuid>:
{
 801543c:	b480      	push	{r7}
 801543e:	af00      	add	r7, sp, #0
    return 0;
 8015440:	2300      	movs	r3, #0
}
 8015442:	4618      	mov	r0, r3
 8015444:	46bd      	mov	sp, r7
 8015446:	f85d 7b04 	ldr.w	r7, [sp], #4
 801544a:	4770      	bx	lr

0801544c <LOS_IntLock>:
{
 801544c:	b580      	push	{r7, lr}
 801544e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8015450:	f7eb fc3a 	bl	8000cc8 <ArchIntLock>
 8015454:	4603      	mov	r3, r0
}
 8015456:	4618      	mov	r0, r3
 8015458:	bd80      	pop	{r7, pc}

0801545a <LOS_IntRestore>:
{
 801545a:	b580      	push	{r7, lr}
 801545c:	b082      	sub	sp, #8
 801545e:	af00      	add	r7, sp, #0
 8015460:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8015462:	6878      	ldr	r0, [r7, #4]
 8015464:	f7eb fc38 	bl	8000cd8 <ArchIntRestore>
}
 8015468:	bf00      	nop
 801546a:	3708      	adds	r7, #8
 801546c:	46bd      	mov	sp, r7
 801546e:	bd80      	pop	{r7, pc}

08015470 <ArchCurrTaskGet>:
{
 8015470:	b480      	push	{r7}
 8015472:	af00      	add	r7, sp, #0
    return g_runTask;
 8015474:	4b03      	ldr	r3, [pc, #12]	; (8015484 <ArchCurrTaskGet+0x14>)
 8015476:	681b      	ldr	r3, [r3, #0]
}
 8015478:	4618      	mov	r0, r3
 801547a:	46bd      	mov	sp, r7
 801547c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015480:	4770      	bx	lr
 8015482:	bf00      	nop
 8015484:	200033cc 	.word	0x200033cc

08015488 <OsPercpuGet>:
{
 8015488:	b580      	push	{r7, lr}
 801548a:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 801548c:	f7ff ffd6 	bl	801543c <ArchCurrCpuid>
 8015490:	4602      	mov	r2, r0
 8015492:	4613      	mov	r3, r2
 8015494:	00db      	lsls	r3, r3, #3
 8015496:	4413      	add	r3, r2
 8015498:	009b      	lsls	r3, r3, #2
 801549a:	4a02      	ldr	r2, [pc, #8]	; (80154a4 <OsPercpuGet+0x1c>)
 801549c:	4413      	add	r3, r2
}
 801549e:	4618      	mov	r0, r3
 80154a0:	bd80      	pop	{r7, pc}
 80154a2:	bf00      	nop
 80154a4:	200036fc 	.word	0x200036fc

080154a8 <LOS_SpinLockSave>:
{
 80154a8:	b580      	push	{r7, lr}
 80154aa:	b082      	sub	sp, #8
 80154ac:	af00      	add	r7, sp, #0
 80154ae:	6078      	str	r0, [r7, #4]
 80154b0:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 80154b2:	f7ff ffcb 	bl	801544c <LOS_IntLock>
 80154b6:	4602      	mov	r2, r0
 80154b8:	683b      	ldr	r3, [r7, #0]
 80154ba:	601a      	str	r2, [r3, #0]
}
 80154bc:	bf00      	nop
 80154be:	3708      	adds	r7, #8
 80154c0:	46bd      	mov	sp, r7
 80154c2:	bd80      	pop	{r7, pc}

080154c4 <LOS_SpinUnlockRestore>:
{
 80154c4:	b580      	push	{r7, lr}
 80154c6:	b082      	sub	sp, #8
 80154c8:	af00      	add	r7, sp, #0
 80154ca:	6078      	str	r0, [r7, #4]
 80154cc:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 80154ce:	6838      	ldr	r0, [r7, #0]
 80154d0:	f7ff ffc3 	bl	801545a <LOS_IntRestore>
}
 80154d4:	bf00      	nop
 80154d6:	3708      	adds	r7, #8
 80154d8:	46bd      	mov	sp, r7
 80154da:	bd80      	pop	{r7, pc}

080154dc <OsCurrTaskGet>:
{
 80154dc:	b580      	push	{r7, lr}
 80154de:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 80154e0:	f7ff ffc6 	bl	8015470 <ArchCurrTaskGet>
 80154e4:	4603      	mov	r3, r0
}
 80154e6:	4618      	mov	r0, r3
 80154e8:	bd80      	pop	{r7, pc}
	...

080154ec <OsTraceHwiFilter>:
LITE_OS_SEC_BSS STATIC TRACE_HWI_FILTER_HOOK g_traceHwiFliterHook = NULL;

LITE_OS_SEC_BSS SPIN_LOCK_INIT(g_traceSpin);

STATIC_INLINE BOOL OsTraceHwiFilter(UINT32 hwiNum)
{
 80154ec:	b580      	push	{r7, lr}
 80154ee:	b084      	sub	sp, #16
 80154f0:	af00      	add	r7, sp, #0
 80154f2:	6078      	str	r0, [r7, #4]
    BOOL ret = ((hwiNum == NUM_HAL_INTERRUPT_UART) || (hwiNum == OS_TICK_INT_NUM));
 80154f4:	687b      	ldr	r3, [r7, #4]
 80154f6:	2b35      	cmp	r3, #53	; 0x35
 80154f8:	d002      	beq.n	8015500 <OsTraceHwiFilter+0x14>
 80154fa:	687b      	ldr	r3, [r7, #4]
 80154fc:	2b0f      	cmp	r3, #15
 80154fe:	d101      	bne.n	8015504 <OsTraceHwiFilter+0x18>
 8015500:	2301      	movs	r3, #1
 8015502:	e000      	b.n	8015506 <OsTraceHwiFilter+0x1a>
 8015504:	2300      	movs	r3, #0
 8015506:	60fb      	str	r3, [r7, #12]
#ifdef LOSCFG_KERNEL_SMP
    ret |= (hwiNum == LOS_MP_IPI_SCHEDULE);
#endif
    if (g_traceHwiFliterHook != NULL) {
 8015508:	4b08      	ldr	r3, [pc, #32]	; (801552c <OsTraceHwiFilter+0x40>)
 801550a:	681b      	ldr	r3, [r3, #0]
 801550c:	2b00      	cmp	r3, #0
 801550e:	d007      	beq.n	8015520 <OsTraceHwiFilter+0x34>
        ret |= g_traceHwiFliterHook(hwiNum);
 8015510:	4b06      	ldr	r3, [pc, #24]	; (801552c <OsTraceHwiFilter+0x40>)
 8015512:	681b      	ldr	r3, [r3, #0]
 8015514:	6878      	ldr	r0, [r7, #4]
 8015516:	4798      	blx	r3
 8015518:	4602      	mov	r2, r0
 801551a:	68fb      	ldr	r3, [r7, #12]
 801551c:	4313      	orrs	r3, r2
 801551e:	60fb      	str	r3, [r7, #12]
    }
    return ret;
 8015520:	68fb      	ldr	r3, [r7, #12]
}
 8015522:	4618      	mov	r0, r3
 8015524:	3710      	adds	r7, #16
 8015526:	46bd      	mov	sp, r7
 8015528:	bd80      	pop	{r7, pc}
 801552a:	bf00      	nop
 801552c:	2000336c 	.word	0x2000336c

08015530 <OsTraceSetFrame>:

STATIC VOID OsTraceSetFrame(TraceEventFrame *frame, UINT32 eventType, UINTPTR identity, const UINTPTR *params,
    UINT16 paramCount)
{
 8015530:	b580      	push	{r7, lr}
 8015532:	b088      	sub	sp, #32
 8015534:	af00      	add	r7, sp, #0
 8015536:	60f8      	str	r0, [r7, #12]
 8015538:	60b9      	str	r1, [r7, #8]
 801553a:	607a      	str	r2, [r7, #4]
 801553c:	603b      	str	r3, [r7, #0]
 801553e:	4b45      	ldr	r3, [pc, #276]	; (8015654 <OsTraceSetFrame+0x124>)
 8015540:	681b      	ldr	r3, [r3, #0]
 8015542:	61fb      	str	r3, [r7, #28]
 8015544:	f04f 0300 	mov.w	r3, #0
    INT32 i;
    UINT32 intSave;

    (VOID)memset_s(frame, sizeof(TraceEventFrame), 0, sizeof(TraceEventFrame));
 8015548:	2328      	movs	r3, #40	; 0x28
 801554a:	2200      	movs	r2, #0
 801554c:	2128      	movs	r1, #40	; 0x28
 801554e:	68f8      	ldr	r0, [r7, #12]
 8015550:	f7ec fda8 	bl	80020a4 <memset_s>

    if (paramCount > LOSCFG_TRACE_FRAME_MAX_PARAMS) {
 8015554:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8015556:	2b03      	cmp	r3, #3
 8015558:	d901      	bls.n	801555e <OsTraceSetFrame+0x2e>
        paramCount = LOSCFG_TRACE_FRAME_MAX_PARAMS;
 801555a:	2303      	movs	r3, #3
 801555c:	853b      	strh	r3, [r7, #40]	; 0x28
    }

    TRACE_LOCK(intSave);
 801555e:	f107 0314 	add.w	r3, r7, #20
 8015562:	4619      	mov	r1, r3
 8015564:	483c      	ldr	r0, [pc, #240]	; (8015658 <OsTraceSetFrame+0x128>)
 8015566:	f7ff ff9f 	bl	80154a8 <LOS_SpinLockSave>
    frame->curTask   = OsTraceGetMaskTid(OsCurrTaskGet()->taskId);
 801556a:	f7ff ffb7 	bl	80154dc <OsCurrTaskGet>
 801556e:	4603      	mov	r3, r0
 8015570:	695b      	ldr	r3, [r3, #20]
 8015572:	4618      	mov	r0, r3
 8015574:	f000 fb02 	bl	8015b7c <OsTraceGetMaskTid>
 8015578:	4602      	mov	r2, r0
 801557a:	68fb      	ldr	r3, [r7, #12]
 801557c:	605a      	str	r2, [r3, #4]
    frame->identity  = identity;
 801557e:	68fb      	ldr	r3, [r7, #12]
 8015580:	687a      	ldr	r2, [r7, #4]
 8015582:	611a      	str	r2, [r3, #16]
    frame->curTime   = HalClockGetCycles();
 8015584:	f7fb f880 	bl	8010688 <HalClockGetCycles>
 8015588:	4602      	mov	r2, r0
 801558a:	460b      	mov	r3, r1
 801558c:	68f9      	ldr	r1, [r7, #12]
 801558e:	e9c1 2302 	strd	r2, r3, [r1, #8]
    frame->eventType = eventType;
 8015592:	68fb      	ldr	r3, [r7, #12]
 8015594:	68ba      	ldr	r2, [r7, #8]
 8015596:	601a      	str	r2, [r3, #0]

#ifdef LOSCFG_TRACE_FRAME_CORE_MSG
    frame->core.cpuId      = ArchCurrCpuid();
 8015598:	f7ff ff50 	bl	801543c <ArchCurrCpuid>
 801559c:	4603      	mov	r3, r0
 801559e:	b2da      	uxtb	r2, r3
 80155a0:	68fb      	ldr	r3, [r7, #12]
 80155a2:	751a      	strb	r2, [r3, #20]
    frame->core.hwiActive  = OS_INT_ACTIVE ? TRUE : FALSE;
 80155a4:	f7ed f85c 	bl	8002660 <IntActive>
 80155a8:	4603      	mov	r3, r0
 80155aa:	2b00      	cmp	r3, #0
 80155ac:	d001      	beq.n	80155b2 <OsTraceSetFrame+0x82>
 80155ae:	2101      	movs	r1, #1
 80155b0:	e000      	b.n	80155b4 <OsTraceSetFrame+0x84>
 80155b2:	2100      	movs	r1, #0
 80155b4:	68fa      	ldr	r2, [r7, #12]
 80155b6:	7d53      	ldrb	r3, [r2, #21]
 80155b8:	f361 0303 	bfi	r3, r1, #0, #4
 80155bc:	7553      	strb	r3, [r2, #21]
    frame->core.taskLockCnt = MIN(OsPercpuGet()->taskLockCnt, 0xF); /* taskLockCnt is 4 bits, max vaule = 0xF */
 80155be:	f7ff ff63 	bl	8015488 <OsPercpuGet>
 80155c2:	4603      	mov	r3, r0
 80155c4:	695b      	ldr	r3, [r3, #20]
 80155c6:	2b0e      	cmp	r3, #14
 80155c8:	d807      	bhi.n	80155da <OsTraceSetFrame+0xaa>
 80155ca:	f7ff ff5d 	bl	8015488 <OsPercpuGet>
 80155ce:	4603      	mov	r3, r0
 80155d0:	695b      	ldr	r3, [r3, #20]
 80155d2:	f003 030f 	and.w	r3, r3, #15
 80155d6:	b2d9      	uxtb	r1, r3
 80155d8:	e000      	b.n	80155dc <OsTraceSetFrame+0xac>
 80155da:	210f      	movs	r1, #15
 80155dc:	68fa      	ldr	r2, [r7, #12]
 80155de:	7d53      	ldrb	r3, [r2, #21]
 80155e0:	f361 1307 	bfi	r3, r1, #4, #4
 80155e4:	7553      	strb	r3, [r2, #21]
    frame->core.paramCount = paramCount;
 80155e6:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80155e8:	f003 030f 	and.w	r3, r3, #15
 80155ec:	b2d9      	uxtb	r1, r3
 80155ee:	68fa      	ldr	r2, [r7, #12]
 80155f0:	7d93      	ldrb	r3, [r2, #22]
 80155f2:	f361 0303 	bfi	r3, r1, #0, #4
 80155f6:	7593      	strb	r3, [r2, #22]
#endif

#ifdef LOSCFG_TRACE_FRAME_EVENT_COUNT
    frame->eventCount = g_traceEventCount;
 80155f8:	4b18      	ldr	r3, [pc, #96]	; (801565c <OsTraceSetFrame+0x12c>)
 80155fa:	681a      	ldr	r2, [r3, #0]
 80155fc:	68fb      	ldr	r3, [r7, #12]
 80155fe:	619a      	str	r2, [r3, #24]
    g_traceEventCount++;
 8015600:	4b16      	ldr	r3, [pc, #88]	; (801565c <OsTraceSetFrame+0x12c>)
 8015602:	681b      	ldr	r3, [r3, #0]
 8015604:	3301      	adds	r3, #1
 8015606:	4a15      	ldr	r2, [pc, #84]	; (801565c <OsTraceSetFrame+0x12c>)
 8015608:	6013      	str	r3, [r2, #0]
#endif
    TRACE_UNLOCK(intSave);
 801560a:	697b      	ldr	r3, [r7, #20]
 801560c:	4619      	mov	r1, r3
 801560e:	4812      	ldr	r0, [pc, #72]	; (8015658 <OsTraceSetFrame+0x128>)
 8015610:	f7ff ff58 	bl	80154c4 <LOS_SpinUnlockRestore>

    for (i = 0; i < paramCount; i++) {
 8015614:	2300      	movs	r3, #0
 8015616:	61bb      	str	r3, [r7, #24]
 8015618:	e00d      	b.n	8015636 <OsTraceSetFrame+0x106>
        frame->params[i] = params[i];
 801561a:	69bb      	ldr	r3, [r7, #24]
 801561c:	009b      	lsls	r3, r3, #2
 801561e:	683a      	ldr	r2, [r7, #0]
 8015620:	4413      	add	r3, r2
 8015622:	681a      	ldr	r2, [r3, #0]
 8015624:	68f9      	ldr	r1, [r7, #12]
 8015626:	69bb      	ldr	r3, [r7, #24]
 8015628:	3306      	adds	r3, #6
 801562a:	009b      	lsls	r3, r3, #2
 801562c:	440b      	add	r3, r1
 801562e:	605a      	str	r2, [r3, #4]
    for (i = 0; i < paramCount; i++) {
 8015630:	69bb      	ldr	r3, [r7, #24]
 8015632:	3301      	adds	r3, #1
 8015634:	61bb      	str	r3, [r7, #24]
 8015636:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8015638:	69ba      	ldr	r2, [r7, #24]
 801563a:	429a      	cmp	r2, r3
 801563c:	dbed      	blt.n	801561a <OsTraceSetFrame+0xea>
    }
}
 801563e:	bf00      	nop
 8015640:	4b04      	ldr	r3, [pc, #16]	; (8015654 <OsTraceSetFrame+0x124>)
 8015642:	681a      	ldr	r2, [r3, #0]
 8015644:	69fb      	ldr	r3, [r7, #28]
 8015646:	405a      	eors	r2, r3
 8015648:	d001      	beq.n	801564e <OsTraceSetFrame+0x11e>
 801564a:	f7ee ffc7 	bl	80045dc <__stack_chk_fail>
 801564e:	3720      	adds	r7, #32
 8015650:	46bd      	mov	sp, r7
 8015652:	bd80      	pop	{r7, pc}
 8015654:	08022ac4 	.word	0x08022ac4
 8015658:	20003370 	.word	0x20003370
 801565c:	20003360 	.word	0x20003360

08015660 <OsTraceHook>:
        TRACE_ERROR("Task name copy failed!\n");
    }
}

VOID OsTraceHook(UINT32 eventType, UINTPTR identity, const UINTPTR *params, UINT16 paramCount)
{
 8015660:	b590      	push	{r4, r7, lr}
 8015662:	b09b      	sub	sp, #108	; 0x6c
 8015664:	af02      	add	r7, sp, #8
 8015666:	60f8      	str	r0, [r7, #12]
 8015668:	60b9      	str	r1, [r7, #8]
 801566a:	607a      	str	r2, [r7, #4]
 801566c:	807b      	strh	r3, [r7, #2]
 801566e:	4b3c      	ldr	r3, [pc, #240]	; (8015760 <OsTraceHook+0x100>)
 8015670:	681b      	ldr	r3, [r3, #0]
 8015672:	65fb      	str	r3, [r7, #92]	; 0x5c
 8015674:	f04f 0300 	mov.w	r3, #0
    if ((eventType == TASK_CREATE) || (eventType == TASK_PRIOSET)) {
 8015678:	68fb      	ldr	r3, [r7, #12]
 801567a:	2b40      	cmp	r3, #64	; 0x40
 801567c:	d002      	beq.n	8015684 <OsTraceHook+0x24>
 801567e:	68fb      	ldr	r3, [r7, #12]
 8015680:	2b41      	cmp	r3, #65	; 0x41
 8015682:	d103      	bne.n	801568c <OsTraceHook+0x2c>
        OsTraceObjAdd(eventType, identity); /* handle important obj info, these can not be filtered */
 8015684:	68b9      	ldr	r1, [r7, #8]
 8015686:	68f8      	ldr	r0, [r7, #12]
 8015688:	f000 fb1c 	bl	8015cc4 <OsTraceObjAdd>
    }

    if ((g_enableTrace == TRUE) && (eventType & g_traceMask)) {
 801568c:	4b35      	ldr	r3, [pc, #212]	; (8015764 <OsTraceHook+0x104>)
 801568e:	681b      	ldr	r3, [r3, #0]
 8015690:	2b01      	cmp	r3, #1
 8015692:	d15b      	bne.n	801574c <OsTraceHook+0xec>
 8015694:	4b34      	ldr	r3, [pc, #208]	; (8015768 <OsTraceHook+0x108>)
 8015696:	681a      	ldr	r2, [r3, #0]
 8015698:	68fb      	ldr	r3, [r7, #12]
 801569a:	4013      	ands	r3, r2
 801569c:	2b00      	cmp	r3, #0
 801569e:	d055      	beq.n	801574c <OsTraceHook+0xec>
        UINTPTR id = identity;
 80156a0:	68bb      	ldr	r3, [r7, #8]
 80156a2:	613b      	str	r3, [r7, #16]
        if (TRACE_GET_MODE_FLAG(eventType) == TRACE_HWI_FLAG) {
 80156a4:	68fb      	ldr	r3, [r7, #12]
 80156a6:	f023 030f 	bic.w	r3, r3, #15
 80156aa:	2b20      	cmp	r3, #32
 80156ac:	d106      	bne.n	80156bc <OsTraceHook+0x5c>
            if (OsTraceHwiFilter(identity)) {
 80156ae:	68b8      	ldr	r0, [r7, #8]
 80156b0:	f7ff ff1c 	bl	80154ec <OsTraceHwiFilter>
 80156b4:	4603      	mov	r3, r0
 80156b6:	2b00      	cmp	r3, #0
 80156b8:	d03a      	beq.n	8015730 <OsTraceHook+0xd0>
                return;
 80156ba:	e047      	b.n	801574c <OsTraceHook+0xec>
            }
        } else if (TRACE_GET_MODE_FLAG(eventType) == TRACE_TASK_FLAG) {
 80156bc:	68fb      	ldr	r3, [r7, #12]
 80156be:	f023 030f 	bic.w	r3, r3, #15
 80156c2:	2b40      	cmp	r3, #64	; 0x40
 80156c4:	d104      	bne.n	80156d0 <OsTraceHook+0x70>
            id = OsTraceGetMaskTid(identity);
 80156c6:	68b8      	ldr	r0, [r7, #8]
 80156c8:	f000 fa58 	bl	8015b7c <OsTraceGetMaskTid>
 80156cc:	6138      	str	r0, [r7, #16]
 80156ce:	e02f      	b.n	8015730 <OsTraceHook+0xd0>
        } else if (eventType == MEM_INFO_REQ) {
 80156d0:	68fb      	ldr	r3, [r7, #12]
 80156d2:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80156d6:	d12b      	bne.n	8015730 <OsTraceHook+0xd0>
            LOS_MEM_POOL_STATUS status;
            LOS_MemInfoGet((VOID *)identity, &status);
 80156d8:	68bb      	ldr	r3, [r7, #8]
 80156da:	f107 0218 	add.w	r2, r7, #24
 80156de:	4611      	mov	r1, r2
 80156e0:	4618      	mov	r0, r3
 80156e2:	f7f3 ffb5 	bl	8009650 <LOS_MemInfoGet>
            LOS_TRACE(MEM_INFO, identity, status.uwTotalUsedSize, status.uwTotalFreeSize);
 80156e6:	2300      	movs	r3, #0
 80156e8:	633b      	str	r3, [r7, #48]	; 0x30
 80156ea:	68bb      	ldr	r3, [r7, #8]
 80156ec:	637b      	str	r3, [r7, #52]	; 0x34
 80156ee:	69bb      	ldr	r3, [r7, #24]
 80156f0:	63bb      	str	r3, [r7, #56]	; 0x38
 80156f2:	69fb      	ldr	r3, [r7, #28]
 80156f4:	63fb      	str	r3, [r7, #60]	; 0x3c
 80156f6:	2304      	movs	r3, #4
 80156f8:	617b      	str	r3, [r7, #20]
 80156fa:	697b      	ldr	r3, [r7, #20]
 80156fc:	2b01      	cmp	r3, #1
 80156fe:	d925      	bls.n	801574c <OsTraceHook+0xec>
 8015700:	4b1a      	ldr	r3, [pc, #104]	; (801576c <OsTraceHook+0x10c>)
 8015702:	681b      	ldr	r3, [r3, #0]
 8015704:	2b00      	cmp	r3, #0
 8015706:	d021      	beq.n	801574c <OsTraceHook+0xec>
 8015708:	4b18      	ldr	r3, [pc, #96]	; (801576c <OsTraceHook+0x10c>)
 801570a:	681c      	ldr	r4, [r3, #0]
 801570c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801570e:	697b      	ldr	r3, [r7, #20]
 8015710:	2b02      	cmp	r3, #2
 8015712:	d904      	bls.n	801571e <OsTraceHook+0xbe>
 8015714:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8015718:	f103 0208 	add.w	r2, r3, #8
 801571c:	e000      	b.n	8015720 <OsTraceHook+0xc0>
 801571e:	2200      	movs	r2, #0
 8015720:	697b      	ldr	r3, [r7, #20]
 8015722:	b29b      	uxth	r3, r3
 8015724:	3b02      	subs	r3, #2
 8015726:	b29b      	uxth	r3, r3
 8015728:	f240 1005 	movw	r0, #261	; 0x105
 801572c:	47a0      	blx	r4
 801572e:	e00d      	b.n	801574c <OsTraceHook+0xec>
            return;
        }

        TraceEventFrame frame;
        OsTraceSetFrame(&frame, eventType, id, params, paramCount);
 8015730:	f107 0030 	add.w	r0, r7, #48	; 0x30
 8015734:	887b      	ldrh	r3, [r7, #2]
 8015736:	9300      	str	r3, [sp, #0]
 8015738:	687b      	ldr	r3, [r7, #4]
 801573a:	693a      	ldr	r2, [r7, #16]
 801573c:	68f9      	ldr	r1, [r7, #12]
 801573e:	f7ff fef7 	bl	8015530 <OsTraceSetFrame>

        OsTraceWriteOrSendEvent(&frame);
 8015742:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8015746:	4618      	mov	r0, r3
 8015748:	f000 fae6 	bl	8015d18 <OsTraceWriteOrSendEvent>
    }
}
 801574c:	4b04      	ldr	r3, [pc, #16]	; (8015760 <OsTraceHook+0x100>)
 801574e:	681a      	ldr	r2, [r3, #0]
 8015750:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015752:	405a      	eors	r2, r3
 8015754:	d001      	beq.n	801575a <OsTraceHook+0xfa>
 8015756:	f7ee ff41 	bl	80045dc <__stack_chk_fail>
 801575a:	3764      	adds	r7, #100	; 0x64
 801575c:	46bd      	mov	sp, r7
 801575e:	bd90      	pop	{r4, r7, pc}
 8015760:	08022ae8 	.word	0x08022ae8
 8015764:	20003368 	.word	0x20003368
 8015768:	200004a4 	.word	0x200004a4
 801576c:	20000768 	.word	0x20000768

08015770 <OsTraceHookInstall>:
{
    return g_enableTrace == TRUE;
}

STATIC VOID OsTraceHookInstall(VOID)
{
 8015770:	b480      	push	{r7}
 8015772:	af00      	add	r7, sp, #0
    g_traceEventHook = OsTraceHook;
 8015774:	4b05      	ldr	r3, [pc, #20]	; (801578c <OsTraceHookInstall+0x1c>)
 8015776:	4a06      	ldr	r2, [pc, #24]	; (8015790 <OsTraceHookInstall+0x20>)
 8015778:	601a      	str	r2, [r3, #0]
#ifdef LOSCFG_RECORDER_MODE_OFFLINE
    g_traceDumpHook = OsTraceRecordDump;
 801577a:	4b06      	ldr	r3, [pc, #24]	; (8015794 <OsTraceHookInstall+0x24>)
 801577c:	4a06      	ldr	r2, [pc, #24]	; (8015798 <OsTraceHookInstall+0x28>)
 801577e:	601a      	str	r2, [r3, #0]
#endif
}
 8015780:	bf00      	nop
 8015782:	46bd      	mov	sp, r7
 8015784:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015788:	4770      	bx	lr
 801578a:	bf00      	nop
 801578c:	20000768 	.word	0x20000768
 8015790:	08015661 	.word	0x08015661
 8015794:	2000076c 	.word	0x2000076c
 8015798:	0801608d 	.word	0x0801608d

0801579c <LOS_TraceInit>:
    return ret;
}
#endif

UINT32 LOS_TraceInit(VOID *buf, UINT32 size)
{
 801579c:	b580      	push	{r7, lr}
 801579e:	b086      	sub	sp, #24
 80157a0:	af00      	add	r7, sp, #0
 80157a2:	6078      	str	r0, [r7, #4]
 80157a4:	6039      	str	r1, [r7, #0]
 80157a6:	4b27      	ldr	r3, [pc, #156]	; (8015844 <LOS_TraceInit+0xa8>)
 80157a8:	681b      	ldr	r3, [r3, #0]
 80157aa:	617b      	str	r3, [r7, #20]
 80157ac:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 ret;

    TRACE_LOCK(intSave);
 80157b0:	f107 030c 	add.w	r3, r7, #12
 80157b4:	4619      	mov	r1, r3
 80157b6:	4824      	ldr	r0, [pc, #144]	; (8015848 <LOS_TraceInit+0xac>)
 80157b8:	f7ff fe76 	bl	80154a8 <LOS_SpinLockSave>
    if (g_traceState != TRACE_UNINIT) {
 80157bc:	4b23      	ldr	r3, [pc, #140]	; (801584c <LOS_TraceInit+0xb0>)
 80157be:	681b      	ldr	r3, [r3, #0]
 80157c0:	2b00      	cmp	r3, #0
 80157c2:	d00b      	beq.n	80157dc <LOS_TraceInit+0x40>
        TRACE_ERROR("trace has been initialized already, the current state is :%d\n", g_traceState);
 80157c4:	4822      	ldr	r0, [pc, #136]	; (8015850 <LOS_TraceInit+0xb4>)
 80157c6:	f7ef f87b 	bl	80048c0 <dprintf>
 80157ca:	4b20      	ldr	r3, [pc, #128]	; (801584c <LOS_TraceInit+0xb0>)
 80157cc:	681b      	ldr	r3, [r3, #0]
 80157ce:	4619      	mov	r1, r3
 80157d0:	4820      	ldr	r0, [pc, #128]	; (8015854 <LOS_TraceInit+0xb8>)
 80157d2:	f7ef f875 	bl	80048c0 <dprintf>
        ret = LOS_ERRNO_TRACE_ERROR_STATUS;
 80157d6:	4b20      	ldr	r3, [pc, #128]	; (8015858 <LOS_TraceInit+0xbc>)
 80157d8:	613b      	str	r3, [r7, #16]
        goto LOS_ERREND;
 80157da:	e022      	b.n	8015822 <LOS_TraceInit+0x86>
    }

#ifdef LOSCFG_TRACE_CLIENT_INTERACT
    ret = OsTracePipelineInit();
 80157dc:	f000 fd56 	bl	801628c <OsTracePipelineInit>
 80157e0:	6138      	str	r0, [r7, #16]
    if (ret != LOS_OK) {
 80157e2:	693b      	ldr	r3, [r7, #16]
 80157e4:	2b00      	cmp	r3, #0
 80157e6:	d119      	bne.n	801581c <LOS_TraceInit+0x80>
        TRACE_ERROR("trace init create agentTask error :0x%x\n", ret);
        goto LOS_ERREND;
    }
#endif

    ret = OsTraceBufInit(buf, size);
 80157e8:	6839      	ldr	r1, [r7, #0]
 80157ea:	6878      	ldr	r0, [r7, #4]
 80157ec:	f000 f9de 	bl	8015bac <OsTraceBufInit>
 80157f0:	6138      	str	r0, [r7, #16]
    if (ret != LOS_OK) {
 80157f2:	693b      	ldr	r3, [r7, #16]
 80157f4:	2b00      	cmp	r3, #0
 80157f6:	d113      	bne.n	8015820 <LOS_TraceInit+0x84>
        goto LOS_RELEASE;
    }

    OsTraceHookInstall();
 80157f8:	f7ff ffba 	bl	8015770 <OsTraceHookInstall>

    g_traceEventCount = 0;
 80157fc:	4b17      	ldr	r3, [pc, #92]	; (801585c <LOS_TraceInit+0xc0>)
 80157fe:	2200      	movs	r2, #0
 8015800:	601a      	str	r2, [r3, #0]

#ifdef LOSCFG_RECORDER_MODE_ONLINE  /* Wait trace client to start trace */
    g_enableTrace = FALSE;
    g_traceState = TRACE_INITED;
#else
    g_enableTrace = TRUE;
 8015802:	4b17      	ldr	r3, [pc, #92]	; (8015860 <LOS_TraceInit+0xc4>)
 8015804:	2201      	movs	r2, #1
 8015806:	601a      	str	r2, [r3, #0]
    g_traceState = TRACE_STARTED;
 8015808:	4b10      	ldr	r3, [pc, #64]	; (801584c <LOS_TraceInit+0xb0>)
 801580a:	2202      	movs	r2, #2
 801580c:	601a      	str	r2, [r3, #0]
#endif
    TRACE_UNLOCK(intSave);
 801580e:	68fb      	ldr	r3, [r7, #12]
 8015810:	4619      	mov	r1, r3
 8015812:	480d      	ldr	r0, [pc, #52]	; (8015848 <LOS_TraceInit+0xac>)
 8015814:	f7ff fe56 	bl	80154c4 <LOS_SpinUnlockRestore>
    return LOS_OK;
 8015818:	2300      	movs	r3, #0
 801581a:	e008      	b.n	801582e <LOS_TraceInit+0x92>
        goto LOS_ERREND;
 801581c:	bf00      	nop
 801581e:	e000      	b.n	8015822 <LOS_TraceInit+0x86>
        goto LOS_RELEASE;
 8015820:	bf00      	nop
LOS_RELEASE:
#ifdef LOSCFG_TRACE_CONTROL_AGENT
    LOS_TaskDelete(g_traceTaskId);
#endif
LOS_ERREND:
    TRACE_UNLOCK(intSave);
 8015822:	68fb      	ldr	r3, [r7, #12]
 8015824:	4619      	mov	r1, r3
 8015826:	4808      	ldr	r0, [pc, #32]	; (8015848 <LOS_TraceInit+0xac>)
 8015828:	f7ff fe4c 	bl	80154c4 <LOS_SpinUnlockRestore>
    return ret;
 801582c:	693b      	ldr	r3, [r7, #16]
}
 801582e:	4a05      	ldr	r2, [pc, #20]	; (8015844 <LOS_TraceInit+0xa8>)
 8015830:	6811      	ldr	r1, [r2, #0]
 8015832:	697a      	ldr	r2, [r7, #20]
 8015834:	4051      	eors	r1, r2
 8015836:	d001      	beq.n	801583c <LOS_TraceInit+0xa0>
 8015838:	f7ee fed0 	bl	80045dc <__stack_chk_fail>
 801583c:	4618      	mov	r0, r3
 801583e:	3718      	adds	r7, #24
 8015840:	46bd      	mov	sp, r7
 8015842:	bd80      	pop	{r7, pc}
 8015844:	08022b2c 	.word	0x08022b2c
 8015848:	20003370 	.word	0x20003370
 801584c:	20003364 	.word	0x20003364
 8015850:	08022ac8 	.word	0x08022ac8
 8015854:	08022aec 	.word	0x08022aec
 8015858:	02001400 	.word	0x02001400
 801585c:	20003360 	.word	0x20003360
 8015860:	20003368 	.word	0x20003368

08015864 <LOS_TraceStart>:

UINT32 LOS_TraceStart(VOID)
{
 8015864:	b590      	push	{r4, r7, lr}
 8015866:	b087      	sub	sp, #28
 8015868:	af00      	add	r7, sp, #0
 801586a:	4b2e      	ldr	r3, [pc, #184]	; (8015924 <LOS_TraceStart+0xc0>)
 801586c:	681b      	ldr	r3, [r3, #0]
 801586e:	617b      	str	r3, [r7, #20]
 8015870:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 ret = LOS_OK;
 8015874:	2300      	movs	r3, #0
 8015876:	607b      	str	r3, [r7, #4]

    TRACE_LOCK(intSave);
 8015878:	463b      	mov	r3, r7
 801587a:	4619      	mov	r1, r3
 801587c:	482a      	ldr	r0, [pc, #168]	; (8015928 <LOS_TraceStart+0xc4>)
 801587e:	f7ff fe13 	bl	80154a8 <LOS_SpinLockSave>
    if (g_traceState == TRACE_STARTED) {
 8015882:	4b2a      	ldr	r3, [pc, #168]	; (801592c <LOS_TraceStart+0xc8>)
 8015884:	681b      	ldr	r3, [r3, #0]
 8015886:	2b02      	cmp	r3, #2
 8015888:	d03a      	beq.n	8015900 <LOS_TraceStart+0x9c>
        goto START_END;
    }

    if (g_traceState == TRACE_UNINIT) {
 801588a:	4b28      	ldr	r3, [pc, #160]	; (801592c <LOS_TraceStart+0xc8>)
 801588c:	681b      	ldr	r3, [r3, #0]
 801588e:	2b00      	cmp	r3, #0
 8015890:	d108      	bne.n	80158a4 <LOS_TraceStart+0x40>
        TRACE_ERROR("trace not inited, be sure LOS_TraceInit excute success\n");
 8015892:	4827      	ldr	r0, [pc, #156]	; (8015930 <LOS_TraceStart+0xcc>)
 8015894:	f7ef f814 	bl	80048c0 <dprintf>
 8015898:	4826      	ldr	r0, [pc, #152]	; (8015934 <LOS_TraceStart+0xd0>)
 801589a:	f7ef f811 	bl	80048c0 <dprintf>
        ret = LOS_ERRNO_TRACE_ERROR_STATUS;
 801589e:	4b26      	ldr	r3, [pc, #152]	; (8015938 <LOS_TraceStart+0xd4>)
 80158a0:	607b      	str	r3, [r7, #4]
        goto START_END;
 80158a2:	e02e      	b.n	8015902 <LOS_TraceStart+0x9e>
    }

    OsTraceNotifyStart();

    g_enableTrace = TRUE;
 80158a4:	4b25      	ldr	r3, [pc, #148]	; (801593c <LOS_TraceStart+0xd8>)
 80158a6:	2201      	movs	r2, #1
 80158a8:	601a      	str	r2, [r3, #0]
    g_traceState = TRACE_STARTED;
 80158aa:	4b20      	ldr	r3, [pc, #128]	; (801592c <LOS_TraceStart+0xc8>)
 80158ac:	2202      	movs	r2, #2
 80158ae:	601a      	str	r2, [r3, #0]

    TRACE_UNLOCK(intSave);
 80158b0:	683b      	ldr	r3, [r7, #0]
 80158b2:	4619      	mov	r1, r3
 80158b4:	481c      	ldr	r0, [pc, #112]	; (8015928 <LOS_TraceStart+0xc4>)
 80158b6:	f7ff fe05 	bl	80154c4 <LOS_SpinUnlockRestore>
    LOS_TRACE(MEM_INFO_REQ, m_aucSysMem0);
 80158ba:	2300      	movs	r3, #0
 80158bc:	60fb      	str	r3, [r7, #12]
 80158be:	4b20      	ldr	r3, [pc, #128]	; (8015940 <LOS_TraceStart+0xdc>)
 80158c0:	681b      	ldr	r3, [r3, #0]
 80158c2:	613b      	str	r3, [r7, #16]
 80158c4:	2302      	movs	r3, #2
 80158c6:	60bb      	str	r3, [r7, #8]
 80158c8:	68bb      	ldr	r3, [r7, #8]
 80158ca:	2b01      	cmp	r3, #1
 80158cc:	d916      	bls.n	80158fc <LOS_TraceStart+0x98>
 80158ce:	4b1d      	ldr	r3, [pc, #116]	; (8015944 <LOS_TraceStart+0xe0>)
 80158d0:	681b      	ldr	r3, [r3, #0]
 80158d2:	2b00      	cmp	r3, #0
 80158d4:	d012      	beq.n	80158fc <LOS_TraceStart+0x98>
 80158d6:	4b1b      	ldr	r3, [pc, #108]	; (8015944 <LOS_TraceStart+0xe0>)
 80158d8:	681c      	ldr	r4, [r3, #0]
 80158da:	6939      	ldr	r1, [r7, #16]
 80158dc:	68bb      	ldr	r3, [r7, #8]
 80158de:	2b02      	cmp	r3, #2
 80158e0:	d904      	bls.n	80158ec <LOS_TraceStart+0x88>
 80158e2:	f107 030c 	add.w	r3, r7, #12
 80158e6:	f103 0208 	add.w	r2, r3, #8
 80158ea:	e000      	b.n	80158ee <LOS_TraceStart+0x8a>
 80158ec:	2200      	movs	r2, #0
 80158ee:	68bb      	ldr	r3, [r7, #8]
 80158f0:	b29b      	uxth	r3, r3
 80158f2:	3b02      	subs	r3, #2
 80158f4:	b29b      	uxth	r3, r3
 80158f6:	f44f 7082 	mov.w	r0, #260	; 0x104
 80158fa:	47a0      	blx	r4
    return ret;
 80158fc:	687b      	ldr	r3, [r7, #4]
 80158fe:	e006      	b.n	801590e <LOS_TraceStart+0xaa>
        goto START_END;
 8015900:	bf00      	nop
START_END:
    TRACE_UNLOCK(intSave);
 8015902:	683b      	ldr	r3, [r7, #0]
 8015904:	4619      	mov	r1, r3
 8015906:	4808      	ldr	r0, [pc, #32]	; (8015928 <LOS_TraceStart+0xc4>)
 8015908:	f7ff fddc 	bl	80154c4 <LOS_SpinUnlockRestore>
    return ret;
 801590c:	687b      	ldr	r3, [r7, #4]
}
 801590e:	4a05      	ldr	r2, [pc, #20]	; (8015924 <LOS_TraceStart+0xc0>)
 8015910:	6811      	ldr	r1, [r2, #0]
 8015912:	697a      	ldr	r2, [r7, #20]
 8015914:	4051      	eors	r1, r2
 8015916:	d001      	beq.n	801591c <LOS_TraceStart+0xb8>
 8015918:	f7ee fe60 	bl	80045dc <__stack_chk_fail>
 801591c:	4618      	mov	r0, r3
 801591e:	371c      	adds	r7, #28
 8015920:	46bd      	mov	sp, r7
 8015922:	bd90      	pop	{r4, r7, pc}
 8015924:	08022b68 	.word	0x08022b68
 8015928:	20003370 	.word	0x20003370
 801592c:	20003364 	.word	0x20003364
 8015930:	08022ac8 	.word	0x08022ac8
 8015934:	08022b30 	.word	0x08022b30
 8015938:	02001400 	.word	0x02001400
 801593c:	20003368 	.word	0x20003368
 8015940:	200021bc 	.word	0x200021bc
 8015944:	20000768 	.word	0x20000768

08015948 <LOS_TraceStop>:

VOID LOS_TraceStop(VOID)
{
 8015948:	b580      	push	{r7, lr}
 801594a:	b082      	sub	sp, #8
 801594c:	af00      	add	r7, sp, #0
 801594e:	4b13      	ldr	r3, [pc, #76]	; (801599c <LOS_TraceStop+0x54>)
 8015950:	681b      	ldr	r3, [r3, #0]
 8015952:	607b      	str	r3, [r7, #4]
 8015954:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;

    TRACE_LOCK(intSave);
 8015958:	463b      	mov	r3, r7
 801595a:	4619      	mov	r1, r3
 801595c:	4810      	ldr	r0, [pc, #64]	; (80159a0 <LOS_TraceStop+0x58>)
 801595e:	f7ff fda3 	bl	80154a8 <LOS_SpinLockSave>
    if (g_traceState != TRACE_STARTED) {
 8015962:	4b10      	ldr	r3, [pc, #64]	; (80159a4 <LOS_TraceStop+0x5c>)
 8015964:	681b      	ldr	r3, [r3, #0]
 8015966:	2b02      	cmp	r3, #2
 8015968:	d106      	bne.n	8015978 <LOS_TraceStop+0x30>
        goto STOP_END;
    }

    g_enableTrace = FALSE;
 801596a:	4b0f      	ldr	r3, [pc, #60]	; (80159a8 <LOS_TraceStop+0x60>)
 801596c:	2200      	movs	r2, #0
 801596e:	601a      	str	r2, [r3, #0]
    g_traceState = TRACE_STOPED;
 8015970:	4b0c      	ldr	r3, [pc, #48]	; (80159a4 <LOS_TraceStop+0x5c>)
 8015972:	2203      	movs	r2, #3
 8015974:	601a      	str	r2, [r3, #0]
 8015976:	e000      	b.n	801597a <LOS_TraceStop+0x32>
        goto STOP_END;
 8015978:	bf00      	nop
    OsTraceNotifyStop();
STOP_END:
    TRACE_UNLOCK(intSave);
 801597a:	683b      	ldr	r3, [r7, #0]
 801597c:	4619      	mov	r1, r3
 801597e:	4808      	ldr	r0, [pc, #32]	; (80159a0 <LOS_TraceStop+0x58>)
 8015980:	f7ff fda0 	bl	80154c4 <LOS_SpinUnlockRestore>
}
 8015984:	bf00      	nop
 8015986:	4b05      	ldr	r3, [pc, #20]	; (801599c <LOS_TraceStop+0x54>)
 8015988:	681a      	ldr	r2, [r3, #0]
 801598a:	687b      	ldr	r3, [r7, #4]
 801598c:	405a      	eors	r2, r3
 801598e:	d001      	beq.n	8015994 <LOS_TraceStop+0x4c>
 8015990:	f7ee fe24 	bl	80045dc <__stack_chk_fail>
 8015994:	3708      	adds	r7, #8
 8015996:	46bd      	mov	sp, r7
 8015998:	bd80      	pop	{r7, pc}
 801599a:	bf00      	nop
 801599c:	08022b6c 	.word	0x08022b6c
 80159a0:	20003370 	.word	0x20003370
 80159a4:	20003364 	.word	0x20003364
 80159a8:	20003368 	.word	0x20003368

080159ac <LOS_TraceEventMaskSet>:

VOID LOS_TraceEventMaskSet(UINT32 mask)
{
 80159ac:	b480      	push	{r7}
 80159ae:	b083      	sub	sp, #12
 80159b0:	af00      	add	r7, sp, #0
 80159b2:	6078      	str	r0, [r7, #4]
    g_traceMask = mask & EVENT_MASK;
 80159b4:	687b      	ldr	r3, [r7, #4]
 80159b6:	f023 030f 	bic.w	r3, r3, #15
 80159ba:	4a04      	ldr	r2, [pc, #16]	; (80159cc <LOS_TraceEventMaskSet+0x20>)
 80159bc:	6013      	str	r3, [r2, #0]
}
 80159be:	bf00      	nop
 80159c0:	370c      	adds	r7, #12
 80159c2:	46bd      	mov	sp, r7
 80159c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80159c8:	4770      	bx	lr
 80159ca:	bf00      	nop
 80159cc:	200004a4 	.word	0x200004a4

080159d0 <LOS_TraceRecordDump>:

VOID LOS_TraceRecordDump(BOOL toClient)
{
 80159d0:	b580      	push	{r7, lr}
 80159d2:	b082      	sub	sp, #8
 80159d4:	af00      	add	r7, sp, #0
 80159d6:	6078      	str	r0, [r7, #4]
    if (g_traceState != TRACE_STOPED) {
 80159d8:	4b09      	ldr	r3, [pc, #36]	; (8015a00 <LOS_TraceRecordDump+0x30>)
 80159da:	681b      	ldr	r3, [r3, #0]
 80159dc:	2b03      	cmp	r3, #3
 80159de:	d009      	beq.n	80159f4 <LOS_TraceRecordDump+0x24>
        TRACE_ERROR("trace dump must after trace stopped , the current state is : %d\n", g_traceState);
 80159e0:	4808      	ldr	r0, [pc, #32]	; (8015a04 <LOS_TraceRecordDump+0x34>)
 80159e2:	f7ee ff6d 	bl	80048c0 <dprintf>
 80159e6:	4b06      	ldr	r3, [pc, #24]	; (8015a00 <LOS_TraceRecordDump+0x30>)
 80159e8:	681b      	ldr	r3, [r3, #0]
 80159ea:	4619      	mov	r1, r3
 80159ec:	4806      	ldr	r0, [pc, #24]	; (8015a08 <LOS_TraceRecordDump+0x38>)
 80159ee:	f7ee ff67 	bl	80048c0 <dprintf>
        return;
 80159f2:	e002      	b.n	80159fa <LOS_TraceRecordDump+0x2a>
    }
    OsTraceRecordDump(toClient);
 80159f4:	6878      	ldr	r0, [r7, #4]
 80159f6:	f000 fb49 	bl	801608c <OsTraceRecordDump>
}
 80159fa:	3708      	adds	r7, #8
 80159fc:	46bd      	mov	sp, r7
 80159fe:	bd80      	pop	{r7, pc}
 8015a00:	20003364 	.word	0x20003364
 8015a04:	08022ac8 	.word	0x08022ac8
 8015a08:	08022b70 	.word	0x08022b70

08015a0c <LOS_TraceReset>:
{
    return OsTraceRecordGet();
}

VOID LOS_TraceReset(VOID)
{
 8015a0c:	b580      	push	{r7, lr}
 8015a0e:	af00      	add	r7, sp, #0
    if (g_traceState == TRACE_UNINIT) {
 8015a10:	4b06      	ldr	r3, [pc, #24]	; (8015a2c <LOS_TraceReset+0x20>)
 8015a12:	681b      	ldr	r3, [r3, #0]
 8015a14:	2b00      	cmp	r3, #0
 8015a16:	d106      	bne.n	8015a26 <LOS_TraceReset+0x1a>
        TRACE_ERROR("trace not inited, be sure LOS_TraceInit excute success\n");
 8015a18:	4805      	ldr	r0, [pc, #20]	; (8015a30 <LOS_TraceReset+0x24>)
 8015a1a:	f7ee ff51 	bl	80048c0 <dprintf>
 8015a1e:	4805      	ldr	r0, [pc, #20]	; (8015a34 <LOS_TraceReset+0x28>)
 8015a20:	f7ee ff4e 	bl	80048c0 <dprintf>
        return;
 8015a24:	e001      	b.n	8015a2a <LOS_TraceReset+0x1e>
    }

    OsTraceReset();
 8015a26:	f000 f9bb 	bl	8015da0 <OsTraceReset>
}
 8015a2a:	bd80      	pop	{r7, pc}
 8015a2c:	20003364 	.word	0x20003364
 8015a30:	08022ac8 	.word	0x08022ac8
 8015a34:	08022b30 	.word	0x08022b30

08015a38 <OsShellCmdTraceSetMask>:
    TRACE_UNLOCK(intSave);
}

#ifdef LOSCFG_SHELL
LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdTraceSetMask(INT32 argc, const CHAR **argv)
{
 8015a38:	b580      	push	{r7, lr}
 8015a3a:	b086      	sub	sp, #24
 8015a3c:	af00      	add	r7, sp, #0
 8015a3e:	6078      	str	r0, [r7, #4]
 8015a40:	6039      	str	r1, [r7, #0]
 8015a42:	4b17      	ldr	r3, [pc, #92]	; (8015aa0 <OsShellCmdTraceSetMask+0x68>)
 8015a44:	681b      	ldr	r3, [r3, #0]
 8015a46:	617b      	str	r3, [r7, #20]
 8015a48:	f04f 0300 	mov.w	r3, #0
    size_t mask;
    CHAR *endPtr = NULL;
 8015a4c:	2300      	movs	r3, #0
 8015a4e:	60fb      	str	r3, [r7, #12]

    if (argc >= 2) { /* 2:Just as number of parameters */
 8015a50:	687b      	ldr	r3, [r7, #4]
 8015a52:	2b01      	cmp	r3, #1
 8015a54:	dd05      	ble.n	8015a62 <OsShellCmdTraceSetMask+0x2a>
        PRINTK("\nUsage: trace_mask or trace_mask ID\n");
 8015a56:	4813      	ldr	r0, [pc, #76]	; (8015aa4 <OsShellCmdTraceSetMask+0x6c>)
 8015a58:	f7ee ff32 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8015a5c:	f04f 33ff 	mov.w	r3, #4294967295
 8015a60:	e012      	b.n	8015a88 <OsShellCmdTraceSetMask+0x50>
    }

    if (argc == 0) {
 8015a62:	687b      	ldr	r3, [r7, #4]
 8015a64:	2b00      	cmp	r3, #0
 8015a66:	d102      	bne.n	8015a6e <OsShellCmdTraceSetMask+0x36>
        mask = TRACE_DEFAULT_MASK;
 8015a68:	2360      	movs	r3, #96	; 0x60
 8015a6a:	613b      	str	r3, [r7, #16]
 8015a6c:	e008      	b.n	8015a80 <OsShellCmdTraceSetMask+0x48>
    } else {
        mask = strtoul(argv[0], &endPtr, 0);
 8015a6e:	683b      	ldr	r3, [r7, #0]
 8015a70:	681b      	ldr	r3, [r3, #0]
 8015a72:	f107 010c 	add.w	r1, r7, #12
 8015a76:	2200      	movs	r2, #0
 8015a78:	4618      	mov	r0, r3
 8015a7a:	f7f9 fdeb 	bl	800f654 <strtoul>
 8015a7e:	6138      	str	r0, [r7, #16]
    }
    LOS_TraceEventMaskSet((UINT32)mask);
 8015a80:	6938      	ldr	r0, [r7, #16]
 8015a82:	f7ff ff93 	bl	80159ac <LOS_TraceEventMaskSet>
    return LOS_OK;
 8015a86:	2300      	movs	r3, #0
}
 8015a88:	4a05      	ldr	r2, [pc, #20]	; (8015aa0 <OsShellCmdTraceSetMask+0x68>)
 8015a8a:	6811      	ldr	r1, [r2, #0]
 8015a8c:	697a      	ldr	r2, [r7, #20]
 8015a8e:	4051      	eors	r1, r2
 8015a90:	d001      	beq.n	8015a96 <OsShellCmdTraceSetMask+0x5e>
 8015a92:	f7ee fda3 	bl	80045dc <__stack_chk_fail>
 8015a96:	4618      	mov	r0, r3
 8015a98:	3718      	adds	r7, #24
 8015a9a:	46bd      	mov	sp, r7
 8015a9c:	bd80      	pop	{r7, pc}
 8015a9e:	bf00      	nop
 8015aa0:	08022be0 	.word	0x08022be0
 8015aa4:	08022bb8 	.word	0x08022bb8

08015aa8 <OsShellCmdTraceDump>:

LITE_OS_SEC_TEXT_MINOR UINT32 OsShellCmdTraceDump(INT32 argc, const CHAR **argv)
{
 8015aa8:	b580      	push	{r7, lr}
 8015aaa:	b086      	sub	sp, #24
 8015aac:	af00      	add	r7, sp, #0
 8015aae:	6078      	str	r0, [r7, #4]
 8015ab0:	6039      	str	r1, [r7, #0]
 8015ab2:	4b1a      	ldr	r3, [pc, #104]	; (8015b1c <OsShellCmdTraceDump+0x74>)
 8015ab4:	681b      	ldr	r3, [r3, #0]
 8015ab6:	617b      	str	r3, [r7, #20]
 8015ab8:	f04f 0300 	mov.w	r3, #0
    BOOL toClient;
    CHAR *endPtr = NULL;
 8015abc:	2300      	movs	r3, #0
 8015abe:	60fb      	str	r3, [r7, #12]

    if (argc >= 2) { /* 2:Just as number of parameters */
 8015ac0:	687b      	ldr	r3, [r7, #4]
 8015ac2:	2b01      	cmp	r3, #1
 8015ac4:	dd05      	ble.n	8015ad2 <OsShellCmdTraceDump+0x2a>
        PRINTK("\nUsage: trace_dump or trace_dump [1/0]\n");
 8015ac6:	4816      	ldr	r0, [pc, #88]	; (8015b20 <OsShellCmdTraceDump+0x78>)
 8015ac8:	f7ee fefa 	bl	80048c0 <dprintf>
        return OS_ERROR;
 8015acc:	f04f 33ff 	mov.w	r3, #4294967295
 8015ad0:	e018      	b.n	8015b04 <OsShellCmdTraceDump+0x5c>
    }

    if (argc == 0) {
 8015ad2:	687b      	ldr	r3, [r7, #4]
 8015ad4:	2b00      	cmp	r3, #0
 8015ad6:	d102      	bne.n	8015ade <OsShellCmdTraceDump+0x36>
        toClient = FALSE;
 8015ad8:	2300      	movs	r3, #0
 8015ada:	613b      	str	r3, [r7, #16]
 8015adc:	e00e      	b.n	8015afc <OsShellCmdTraceDump+0x54>
    } else {
        toClient = strtoul(argv[0], &endPtr, 0) != 0 ? TRUE : FALSE;
 8015ade:	683b      	ldr	r3, [r7, #0]
 8015ae0:	681b      	ldr	r3, [r3, #0]
 8015ae2:	f107 010c 	add.w	r1, r7, #12
 8015ae6:	2200      	movs	r2, #0
 8015ae8:	4618      	mov	r0, r3
 8015aea:	f7f9 fdb3 	bl	800f654 <strtoul>
 8015aee:	4603      	mov	r3, r0
 8015af0:	2b00      	cmp	r3, #0
 8015af2:	d001      	beq.n	8015af8 <OsShellCmdTraceDump+0x50>
 8015af4:	2301      	movs	r3, #1
 8015af6:	e000      	b.n	8015afa <OsShellCmdTraceDump+0x52>
 8015af8:	2300      	movs	r3, #0
 8015afa:	613b      	str	r3, [r7, #16]
    }
    LOS_TraceRecordDump(toClient);
 8015afc:	6938      	ldr	r0, [r7, #16]
 8015afe:	f7ff ff67 	bl	80159d0 <LOS_TraceRecordDump>
    return LOS_OK;
 8015b02:	2300      	movs	r3, #0
}
 8015b04:	4a05      	ldr	r2, [pc, #20]	; (8015b1c <OsShellCmdTraceDump+0x74>)
 8015b06:	6811      	ldr	r1, [r2, #0]
 8015b08:	697a      	ldr	r2, [r7, #20]
 8015b0a:	4051      	eors	r1, r2
 8015b0c:	d001      	beq.n	8015b12 <OsShellCmdTraceDump+0x6a>
 8015b0e:	f7ee fd65 	bl	80045dc <__stack_chk_fail>
 8015b12:	4618      	mov	r0, r3
 8015b14:	3718      	adds	r7, #24
 8015b16:	46bd      	mov	sp, r7
 8015b18:	bd80      	pop	{r7, pc}
 8015b1a:	bf00      	nop
 8015b1c:	08022c0c 	.word	0x08022c0c
 8015b20:	08022be4 	.word	0x08022be4

08015b24 <LOS_IntLock>:
{
 8015b24:	b580      	push	{r7, lr}
 8015b26:	af00      	add	r7, sp, #0
    return ArchIntLock();
 8015b28:	f7eb f8ce 	bl	8000cc8 <ArchIntLock>
 8015b2c:	4603      	mov	r3, r0
}
 8015b2e:	4618      	mov	r0, r3
 8015b30:	bd80      	pop	{r7, pc}

08015b32 <LOS_IntRestore>:
{
 8015b32:	b580      	push	{r7, lr}
 8015b34:	b082      	sub	sp, #8
 8015b36:	af00      	add	r7, sp, #0
 8015b38:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 8015b3a:	6878      	ldr	r0, [r7, #4]
 8015b3c:	f7eb f8cc 	bl	8000cd8 <ArchIntRestore>
}
 8015b40:	bf00      	nop
 8015b42:	3708      	adds	r7, #8
 8015b44:	46bd      	mov	sp, r7
 8015b46:	bd80      	pop	{r7, pc}

08015b48 <LOS_SpinLockSave>:
{
 8015b48:	b580      	push	{r7, lr}
 8015b4a:	b082      	sub	sp, #8
 8015b4c:	af00      	add	r7, sp, #0
 8015b4e:	6078      	str	r0, [r7, #4]
 8015b50:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 8015b52:	f7ff ffe7 	bl	8015b24 <LOS_IntLock>
 8015b56:	4602      	mov	r2, r0
 8015b58:	683b      	ldr	r3, [r7, #0]
 8015b5a:	601a      	str	r2, [r3, #0]
}
 8015b5c:	bf00      	nop
 8015b5e:	3708      	adds	r7, #8
 8015b60:	46bd      	mov	sp, r7
 8015b62:	bd80      	pop	{r7, pc}

08015b64 <LOS_SpinUnlockRestore>:
{
 8015b64:	b580      	push	{r7, lr}
 8015b66:	b082      	sub	sp, #8
 8015b68:	af00      	add	r7, sp, #0
 8015b6a:	6078      	str	r0, [r7, #4]
 8015b6c:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 8015b6e:	6838      	ldr	r0, [r7, #0]
 8015b70:	f7ff ffdf 	bl	8015b32 <LOS_IntRestore>
}
 8015b74:	bf00      	nop
 8015b76:	3708      	adds	r7, #8
 8015b78:	46bd      	mov	sp, r7
 8015b7a:	bd80      	pop	{r7, pc}

08015b7c <OsTraceGetMaskTid>:

LITE_OS_SEC_BSS STATIC TraceOfflineHeaderInfo g_traceRecoder;
LITE_OS_SEC_BSS STATIC UINT32 g_tidMask[LOSCFG_BASE_CORE_TSK_LIMIT] = {0};

UINT32 OsTraceGetMaskTid(UINT32 tid)
{
 8015b7c:	b480      	push	{r7}
 8015b7e:	b083      	sub	sp, #12
 8015b80:	af00      	add	r7, sp, #0
 8015b82:	6078      	str	r0, [r7, #4]
    return tid | ((tid < LOSCFG_BASE_CORE_TSK_LIMIT) ? g_tidMask[tid] << BITS_NUM_FOR_TASK_ID : 0); /* tid < 65535 */
 8015b84:	687b      	ldr	r3, [r7, #4]
 8015b86:	2b0f      	cmp	r3, #15
 8015b88:	d805      	bhi.n	8015b96 <OsTraceGetMaskTid+0x1a>
 8015b8a:	4a07      	ldr	r2, [pc, #28]	; (8015ba8 <OsTraceGetMaskTid+0x2c>)
 8015b8c:	687b      	ldr	r3, [r7, #4]
 8015b8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8015b92:	041b      	lsls	r3, r3, #16
 8015b94:	e000      	b.n	8015b98 <OsTraceGetMaskTid+0x1c>
 8015b96:	2300      	movs	r3, #0
 8015b98:	687a      	ldr	r2, [r7, #4]
 8015b9a:	4313      	orrs	r3, r2
}
 8015b9c:	4618      	mov	r0, r3
 8015b9e:	370c      	adds	r7, #12
 8015ba0:	46bd      	mov	sp, r7
 8015ba2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015ba6:	4770      	bx	lr
 8015ba8:	20003388 	.word	0x20003388

08015bac <OsTraceBufInit>:

UINT32 OsTraceBufInit(VOID *buf, UINT32 size)
{
 8015bac:	b580      	push	{r7, lr}
 8015bae:	b084      	sub	sp, #16
 8015bb0:	af00      	add	r7, sp, #0
 8015bb2:	6078      	str	r0, [r7, #4]
 8015bb4:	6039      	str	r1, [r7, #0]
    UINT32 headSize;

    headSize = sizeof(OfflineHead) + sizeof(ObjData) * LOSCFG_TRACE_OBJ_MAX_NUM;
 8015bb6:	2318      	movs	r3, #24
 8015bb8:	60fb      	str	r3, [r7, #12]
    if (size <= headSize) {
 8015bba:	683a      	ldr	r2, [r7, #0]
 8015bbc:	68fb      	ldr	r3, [r7, #12]
 8015bbe:	429a      	cmp	r2, r3
 8015bc0:	d808      	bhi.n	8015bd4 <OsTraceBufInit+0x28>
        TRACE_ERROR("trace buf size not enough than 0x%x\n", headSize);
 8015bc2:	4837      	ldr	r0, [pc, #220]	; (8015ca0 <OsTraceBufInit+0xf4>)
 8015bc4:	f7ee fe7c 	bl	80048c0 <dprintf>
 8015bc8:	68f9      	ldr	r1, [r7, #12]
 8015bca:	4836      	ldr	r0, [pc, #216]	; (8015ca4 <OsTraceBufInit+0xf8>)
 8015bcc:	f7ee fe78 	bl	80048c0 <dprintf>
        return LOS_ERRNO_TRACE_BUF_TOO_SMALL;
 8015bd0:	4b35      	ldr	r3, [pc, #212]	; (8015ca8 <OsTraceBufInit+0xfc>)
 8015bd2:	e060      	b.n	8015c96 <OsTraceBufInit+0xea>
    }

    if (buf == NULL) {
 8015bd4:	687b      	ldr	r3, [r7, #4]
 8015bd6:	2b00      	cmp	r3, #0
 8015bd8:	d10b      	bne.n	8015bf2 <OsTraceBufInit+0x46>
        buf = LOS_MemAlloc(m_aucSysMem1, size);
 8015bda:	4b34      	ldr	r3, [pc, #208]	; (8015cac <OsTraceBufInit+0x100>)
 8015bdc:	681b      	ldr	r3, [r3, #0]
 8015bde:	6839      	ldr	r1, [r7, #0]
 8015be0:	4618      	mov	r0, r3
 8015be2:	f7f3 fc17 	bl	8009414 <LOS_MemAlloc>
 8015be6:	6078      	str	r0, [r7, #4]
        if (buf == NULL) {
 8015be8:	687b      	ldr	r3, [r7, #4]
 8015bea:	2b00      	cmp	r3, #0
 8015bec:	d101      	bne.n	8015bf2 <OsTraceBufInit+0x46>
            return LOS_ERRNO_TRACE_NO_MEMORY;
 8015bee:	4b30      	ldr	r3, [pc, #192]	; (8015cb0 <OsTraceBufInit+0x104>)
 8015bf0:	e051      	b.n	8015c96 <OsTraceBufInit+0xea>
        }
    }

    (VOID)memset_s(buf, size, 0, size);
 8015bf2:	683b      	ldr	r3, [r7, #0]
 8015bf4:	2200      	movs	r2, #0
 8015bf6:	6839      	ldr	r1, [r7, #0]
 8015bf8:	6878      	ldr	r0, [r7, #4]
 8015bfa:	f7ec fa53 	bl	80020a4 <memset_s>
    g_traceRecoder.head = (OfflineHead *)buf;
 8015bfe:	4a2d      	ldr	r2, [pc, #180]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c00:	687b      	ldr	r3, [r7, #4]
 8015c02:	6113      	str	r3, [r2, #16]
    g_traceRecoder.head->baseInfo.bigLittleEndian = TRACE_BIGLITTLE_WORD;
 8015c04:	4b2b      	ldr	r3, [pc, #172]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c06:	691b      	ldr	r3, [r3, #16]
 8015c08:	4a2b      	ldr	r2, [pc, #172]	; (8015cb8 <OsTraceBufInit+0x10c>)
 8015c0a:	601a      	str	r2, [r3, #0]
    g_traceRecoder.head->baseInfo.version         = TRACE_VERSION(TRACE_MODE_OFFLINE);
 8015c0c:	4b29      	ldr	r3, [pc, #164]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c0e:	691b      	ldr	r3, [r3, #16]
 8015c10:	2200      	movs	r2, #0
 8015c12:	609a      	str	r2, [r3, #8]
    g_traceRecoder.head->baseInfo.clockFreq       = GET_SYS_CLOCK();
 8015c14:	4b27      	ldr	r3, [pc, #156]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c16:	691b      	ldr	r3, [r3, #16]
 8015c18:	4a28      	ldr	r2, [pc, #160]	; (8015cbc <OsTraceBufInit+0x110>)
 8015c1a:	6812      	ldr	r2, [r2, #0]
 8015c1c:	605a      	str	r2, [r3, #4]
    g_traceRecoder.head->objSize                  = sizeof(ObjData);
 8015c1e:	4b25      	ldr	r3, [pc, #148]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c20:	691b      	ldr	r3, [r3, #16]
 8015c22:	2228      	movs	r2, #40	; 0x28
 8015c24:	81da      	strh	r2, [r3, #14]
    g_traceRecoder.head->frameSize                = sizeof(TraceEventFrame);
 8015c26:	4b23      	ldr	r3, [pc, #140]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c28:	691b      	ldr	r3, [r3, #16]
 8015c2a:	2228      	movs	r2, #40	; 0x28
 8015c2c:	821a      	strh	r2, [r3, #16]
    g_traceRecoder.head->objOffset                = sizeof(OfflineHead);
 8015c2e:	4b21      	ldr	r3, [pc, #132]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c30:	691b      	ldr	r3, [r3, #16]
 8015c32:	2218      	movs	r2, #24
 8015c34:	825a      	strh	r2, [r3, #18]
    g_traceRecoder.head->frameOffset              = headSize;
 8015c36:	4b1f      	ldr	r3, [pc, #124]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c38:	691b      	ldr	r3, [r3, #16]
 8015c3a:	68fa      	ldr	r2, [r7, #12]
 8015c3c:	b292      	uxth	r2, r2
 8015c3e:	829a      	strh	r2, [r3, #20]
    g_traceRecoder.head->totalLen                 = size;
 8015c40:	4b1c      	ldr	r3, [pc, #112]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c42:	691b      	ldr	r3, [r3, #16]
 8015c44:	683a      	ldr	r2, [r7, #0]
 8015c46:	b292      	uxth	r2, r2
 8015c48:	819a      	strh	r2, [r3, #12]

    g_traceRecoder.ctrl.curIndex       = 0;
 8015c4a:	4b1a      	ldr	r3, [pc, #104]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c4c:	2200      	movs	r2, #0
 8015c4e:	801a      	strh	r2, [r3, #0]
    g_traceRecoder.ctrl.curObjIndex    = 0;
 8015c50:	4b18      	ldr	r3, [pc, #96]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c52:	2200      	movs	r2, #0
 8015c54:	809a      	strh	r2, [r3, #4]
    g_traceRecoder.ctrl.maxObjCount    = LOSCFG_TRACE_OBJ_MAX_NUM;
 8015c56:	4b17      	ldr	r3, [pc, #92]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c58:	2200      	movs	r2, #0
 8015c5a:	80da      	strh	r2, [r3, #6]
    g_traceRecoder.ctrl.maxRecordCount = (size - headSize) / sizeof(TraceEventFrame);
 8015c5c:	683a      	ldr	r2, [r7, #0]
 8015c5e:	68fb      	ldr	r3, [r7, #12]
 8015c60:	1ad3      	subs	r3, r2, r3
 8015c62:	4a17      	ldr	r2, [pc, #92]	; (8015cc0 <OsTraceBufInit+0x114>)
 8015c64:	fba2 2303 	umull	r2, r3, r2, r3
 8015c68:	095b      	lsrs	r3, r3, #5
 8015c6a:	b29a      	uxth	r2, r3
 8015c6c:	4b11      	ldr	r3, [pc, #68]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c6e:	805a      	strh	r2, [r3, #2]
    g_traceRecoder.ctrl.objBuf         = (ObjData *)((UINTPTR)buf + g_traceRecoder.head->objOffset);
 8015c70:	4b10      	ldr	r3, [pc, #64]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c72:	691b      	ldr	r3, [r3, #16]
 8015c74:	8a5b      	ldrh	r3, [r3, #18]
 8015c76:	461a      	mov	r2, r3
 8015c78:	687b      	ldr	r3, [r7, #4]
 8015c7a:	4413      	add	r3, r2
 8015c7c:	461a      	mov	r2, r3
 8015c7e:	4b0d      	ldr	r3, [pc, #52]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c80:	609a      	str	r2, [r3, #8]
    g_traceRecoder.ctrl.frameBuf       = (TraceEventFrame *)((UINTPTR)buf + g_traceRecoder.head->frameOffset);
 8015c82:	4b0c      	ldr	r3, [pc, #48]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c84:	691b      	ldr	r3, [r3, #16]
 8015c86:	8a9b      	ldrh	r3, [r3, #20]
 8015c88:	461a      	mov	r2, r3
 8015c8a:	687b      	ldr	r3, [r7, #4]
 8015c8c:	4413      	add	r3, r2
 8015c8e:	461a      	mov	r2, r3
 8015c90:	4b08      	ldr	r3, [pc, #32]	; (8015cb4 <OsTraceBufInit+0x108>)
 8015c92:	60da      	str	r2, [r3, #12]

    return LOS_OK;
 8015c94:	2300      	movs	r3, #0
}
 8015c96:	4618      	mov	r0, r3
 8015c98:	3710      	adds	r7, #16
 8015c9a:	46bd      	mov	sp, r7
 8015c9c:	bd80      	pop	{r7, pc}
 8015c9e:	bf00      	nop
 8015ca0:	08022c4c 	.word	0x08022c4c
 8015ca4:	08022c54 	.word	0x08022c54
 8015ca8:	02001402 	.word	0x02001402
 8015cac:	200021c0 	.word	0x200021c0
 8015cb0:	02001401 	.word	0x02001401
 8015cb4:	20003374 	.word	0x20003374
 8015cb8:	12345678 	.word	0x12345678
 8015cbc:	200036e0 	.word	0x200036e0
 8015cc0:	cccccccd 	.word	0xcccccccd

08015cc4 <OsTraceObjAdd>:

VOID OsTraceObjAdd(UINT32 eventType, UINT32 taskId)
{
 8015cc4:	b580      	push	{r7, lr}
 8015cc6:	b086      	sub	sp, #24
 8015cc8:	af00      	add	r7, sp, #0
 8015cca:	6078      	str	r0, [r7, #4]
 8015ccc:	6039      	str	r1, [r7, #0]
 8015cce:	4b0f      	ldr	r3, [pc, #60]	; (8015d0c <OsTraceObjAdd+0x48>)
 8015cd0:	681b      	ldr	r3, [r3, #0]
 8015cd2:	617b      	str	r3, [r7, #20]
 8015cd4:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 index;
    ObjData *obj = NULL;
 8015cd8:	2300      	movs	r3, #0
 8015cda:	613b      	str	r3, [r7, #16]

    TRACE_LOCK(intSave);
 8015cdc:	f107 0308 	add.w	r3, r7, #8
 8015ce0:	4619      	mov	r1, r3
 8015ce2:	480b      	ldr	r0, [pc, #44]	; (8015d10 <OsTraceObjAdd+0x4c>)
 8015ce4:	f7ff ff30 	bl	8015b48 <LOS_SpinLockSave>
    /* add obj begin */
    index = g_traceRecoder.ctrl.curObjIndex;
 8015ce8:	4b0a      	ldr	r3, [pc, #40]	; (8015d14 <OsTraceObjAdd+0x50>)
 8015cea:	889b      	ldrh	r3, [r3, #4]
 8015cec:	60fb      	str	r3, [r7, #12]
    if (index >= LOSCFG_TRACE_OBJ_MAX_NUM) { /* do nothing when config LOSCFG_TRACE_OBJ_MAX_NUM = 0 */
        TRACE_UNLOCK(intSave);
 8015cee:	68bb      	ldr	r3, [r7, #8]
 8015cf0:	4619      	mov	r1, r3
 8015cf2:	4807      	ldr	r0, [pc, #28]	; (8015d10 <OsTraceObjAdd+0x4c>)
 8015cf4:	f7ff ff36 	bl	8015b64 <LOS_SpinUnlockRestore>
    if (g_traceRecoder.ctrl.curObjIndex >= g_traceRecoder.ctrl.maxObjCount) {
        g_traceRecoder.ctrl.curObjIndex = 0; /* turn around */
    }
    /* add obj end */
    TRACE_UNLOCK(intSave);
}
 8015cf8:	4b04      	ldr	r3, [pc, #16]	; (8015d0c <OsTraceObjAdd+0x48>)
 8015cfa:	681a      	ldr	r2, [r3, #0]
 8015cfc:	697b      	ldr	r3, [r7, #20]
 8015cfe:	405a      	eors	r2, r3
 8015d00:	d001      	beq.n	8015d06 <OsTraceObjAdd+0x42>
 8015d02:	f7ee fc6b 	bl	80045dc <__stack_chk_fail>
 8015d06:	3718      	adds	r7, #24
 8015d08:	46bd      	mov	sp, r7
 8015d0a:	bd80      	pop	{r7, pc}
 8015d0c:	08022c7c 	.word	0x08022c7c
 8015d10:	20003370 	.word	0x20003370
 8015d14:	20003374 	.word	0x20003374

08015d18 <OsTraceWriteOrSendEvent>:

VOID OsTraceWriteOrSendEvent(const TraceEventFrame *frame)
{
 8015d18:	b580      	push	{r7, lr}
 8015d1a:	b086      	sub	sp, #24
 8015d1c:	af00      	add	r7, sp, #0
 8015d1e:	6078      	str	r0, [r7, #4]
 8015d20:	4b1c      	ldr	r3, [pc, #112]	; (8015d94 <OsTraceWriteOrSendEvent+0x7c>)
 8015d22:	681b      	ldr	r3, [r3, #0]
 8015d24:	617b      	str	r3, [r7, #20]
 8015d26:	f04f 0300 	mov.w	r3, #0
    UINT16 index;
    UINT32 intSave;

    TRACE_LOCK(intSave);
 8015d2a:	f107 0310 	add.w	r3, r7, #16
 8015d2e:	4619      	mov	r1, r3
 8015d30:	4819      	ldr	r0, [pc, #100]	; (8015d98 <OsTraceWriteOrSendEvent+0x80>)
 8015d32:	f7ff ff09 	bl	8015b48 <LOS_SpinLockSave>
    index = g_traceRecoder.ctrl.curIndex;
 8015d36:	4b19      	ldr	r3, [pc, #100]	; (8015d9c <OsTraceWriteOrSendEvent+0x84>)
 8015d38:	881b      	ldrh	r3, [r3, #0]
 8015d3a:	81fb      	strh	r3, [r7, #14]
    (VOID)memcpy_s(&g_traceRecoder.ctrl.frameBuf[index], sizeof(TraceEventFrame), frame, sizeof(TraceEventFrame));
 8015d3c:	4b17      	ldr	r3, [pc, #92]	; (8015d9c <OsTraceWriteOrSendEvent+0x84>)
 8015d3e:	68d9      	ldr	r1, [r3, #12]
 8015d40:	89fa      	ldrh	r2, [r7, #14]
 8015d42:	4613      	mov	r3, r2
 8015d44:	009b      	lsls	r3, r3, #2
 8015d46:	4413      	add	r3, r2
 8015d48:	00db      	lsls	r3, r3, #3
 8015d4a:	18c8      	adds	r0, r1, r3
 8015d4c:	2328      	movs	r3, #40	; 0x28
 8015d4e:	687a      	ldr	r2, [r7, #4]
 8015d50:	2128      	movs	r1, #40	; 0x28
 8015d52:	f001 f9a1 	bl	8017098 <memcpy_s>

    g_traceRecoder.ctrl.curIndex++;
 8015d56:	4b11      	ldr	r3, [pc, #68]	; (8015d9c <OsTraceWriteOrSendEvent+0x84>)
 8015d58:	881b      	ldrh	r3, [r3, #0]
 8015d5a:	3301      	adds	r3, #1
 8015d5c:	b29a      	uxth	r2, r3
 8015d5e:	4b0f      	ldr	r3, [pc, #60]	; (8015d9c <OsTraceWriteOrSendEvent+0x84>)
 8015d60:	801a      	strh	r2, [r3, #0]
    if (g_traceRecoder.ctrl.curIndex >= g_traceRecoder.ctrl.maxRecordCount) {
 8015d62:	4b0e      	ldr	r3, [pc, #56]	; (8015d9c <OsTraceWriteOrSendEvent+0x84>)
 8015d64:	881a      	ldrh	r2, [r3, #0]
 8015d66:	4b0d      	ldr	r3, [pc, #52]	; (8015d9c <OsTraceWriteOrSendEvent+0x84>)
 8015d68:	885b      	ldrh	r3, [r3, #2]
 8015d6a:	429a      	cmp	r2, r3
 8015d6c:	d302      	bcc.n	8015d74 <OsTraceWriteOrSendEvent+0x5c>
        g_traceRecoder.ctrl.curIndex = 0;
 8015d6e:	4b0b      	ldr	r3, [pc, #44]	; (8015d9c <OsTraceWriteOrSendEvent+0x84>)
 8015d70:	2200      	movs	r2, #0
 8015d72:	801a      	strh	r2, [r3, #0]
    }
    TRACE_UNLOCK(intSave);
 8015d74:	693b      	ldr	r3, [r7, #16]
 8015d76:	4619      	mov	r1, r3
 8015d78:	4807      	ldr	r0, [pc, #28]	; (8015d98 <OsTraceWriteOrSendEvent+0x80>)
 8015d7a:	f7ff fef3 	bl	8015b64 <LOS_SpinUnlockRestore>
}
 8015d7e:	bf00      	nop
 8015d80:	4b04      	ldr	r3, [pc, #16]	; (8015d94 <OsTraceWriteOrSendEvent+0x7c>)
 8015d82:	681a      	ldr	r2, [r3, #0]
 8015d84:	697b      	ldr	r3, [r7, #20]
 8015d86:	405a      	eors	r2, r3
 8015d88:	d001      	beq.n	8015d8e <OsTraceWriteOrSendEvent+0x76>
 8015d8a:	f7ee fc27 	bl	80045dc <__stack_chk_fail>
 8015d8e:	3718      	adds	r7, #24
 8015d90:	46bd      	mov	sp, r7
 8015d92:	bd80      	pop	{r7, pc}
 8015d94:	08022c80 	.word	0x08022c80
 8015d98:	20003370 	.word	0x20003370
 8015d9c:	20003374 	.word	0x20003374

08015da0 <OsTraceReset>:

VOID OsTraceReset(VOID)
{
 8015da0:	b580      	push	{r7, lr}
 8015da2:	b084      	sub	sp, #16
 8015da4:	af00      	add	r7, sp, #0
 8015da6:	4b16      	ldr	r3, [pc, #88]	; (8015e00 <OsTraceReset+0x60>)
 8015da8:	681b      	ldr	r3, [r3, #0]
 8015daa:	60fb      	str	r3, [r7, #12]
 8015dac:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 bufLen;

    TRACE_LOCK(intSave);
 8015db0:	1d3b      	adds	r3, r7, #4
 8015db2:	4619      	mov	r1, r3
 8015db4:	4813      	ldr	r0, [pc, #76]	; (8015e04 <OsTraceReset+0x64>)
 8015db6:	f7ff fec7 	bl	8015b48 <LOS_SpinLockSave>
    bufLen = sizeof(TraceEventFrame) * g_traceRecoder.ctrl.maxRecordCount;
 8015dba:	4b13      	ldr	r3, [pc, #76]	; (8015e08 <OsTraceReset+0x68>)
 8015dbc:	885b      	ldrh	r3, [r3, #2]
 8015dbe:	461a      	mov	r2, r3
 8015dc0:	4613      	mov	r3, r2
 8015dc2:	009b      	lsls	r3, r3, #2
 8015dc4:	4413      	add	r3, r2
 8015dc6:	00db      	lsls	r3, r3, #3
 8015dc8:	60bb      	str	r3, [r7, #8]
    (VOID)memset_s(g_traceRecoder.ctrl.frameBuf, bufLen, 0, bufLen);
 8015dca:	4b0f      	ldr	r3, [pc, #60]	; (8015e08 <OsTraceReset+0x68>)
 8015dcc:	68d8      	ldr	r0, [r3, #12]
 8015dce:	68bb      	ldr	r3, [r7, #8]
 8015dd0:	2200      	movs	r2, #0
 8015dd2:	68b9      	ldr	r1, [r7, #8]
 8015dd4:	f7ec f966 	bl	80020a4 <memset_s>
    g_traceRecoder.ctrl.curIndex = 0;
 8015dd8:	4b0b      	ldr	r3, [pc, #44]	; (8015e08 <OsTraceReset+0x68>)
 8015dda:	2200      	movs	r2, #0
 8015ddc:	801a      	strh	r2, [r3, #0]
    TRACE_UNLOCK(intSave);
 8015dde:	687b      	ldr	r3, [r7, #4]
 8015de0:	4619      	mov	r1, r3
 8015de2:	4808      	ldr	r0, [pc, #32]	; (8015e04 <OsTraceReset+0x64>)
 8015de4:	f7ff febe 	bl	8015b64 <LOS_SpinUnlockRestore>
}
 8015de8:	bf00      	nop
 8015dea:	4b05      	ldr	r3, [pc, #20]	; (8015e00 <OsTraceReset+0x60>)
 8015dec:	681a      	ldr	r2, [r3, #0]
 8015dee:	68fb      	ldr	r3, [r7, #12]
 8015df0:	405a      	eors	r2, r3
 8015df2:	d001      	beq.n	8015df8 <OsTraceReset+0x58>
 8015df4:	f7ee fbf2 	bl	80045dc <__stack_chk_fail>
 8015df8:	3710      	adds	r7, #16
 8015dfa:	46bd      	mov	sp, r7
 8015dfc:	bd80      	pop	{r7, pc}
 8015dfe:	bf00      	nop
 8015e00:	08022c84 	.word	0x08022c84
 8015e04:	20003370 	.word	0x20003370
 8015e08:	20003374 	.word	0x20003374

08015e0c <OsTraceInfoObj>:

STATIC VOID OsTraceInfoObj(VOID)
{
 8015e0c:	b580      	push	{r7, lr}
 8015e0e:	b084      	sub	sp, #16
 8015e10:	af02      	add	r7, sp, #8
    UINT32 i;
    ObjData *obj = &g_traceRecoder.ctrl.objBuf[0];
 8015e12:	4b19      	ldr	r3, [pc, #100]	; (8015e78 <OsTraceInfoObj+0x6c>)
 8015e14:	689b      	ldr	r3, [r3, #8]
 8015e16:	607b      	str	r3, [r7, #4]

    if (g_traceRecoder.ctrl.maxObjCount > 0) {
 8015e18:	4b17      	ldr	r3, [pc, #92]	; (8015e78 <OsTraceInfoObj+0x6c>)
 8015e1a:	88db      	ldrh	r3, [r3, #6]
 8015e1c:	2b00      	cmp	r3, #0
 8015e1e:	d026      	beq.n	8015e6e <OsTraceInfoObj+0x62>
        PRINTK("CurObjIndex = %u\n", g_traceRecoder.ctrl.curObjIndex);
 8015e20:	4b15      	ldr	r3, [pc, #84]	; (8015e78 <OsTraceInfoObj+0x6c>)
 8015e22:	889b      	ldrh	r3, [r3, #4]
 8015e24:	4619      	mov	r1, r3
 8015e26:	4815      	ldr	r0, [pc, #84]	; (8015e7c <OsTraceInfoObj+0x70>)
 8015e28:	f7ee fd4a 	bl	80048c0 <dprintf>
        PRINTK("Index   TaskID   TaskPrio   TaskName \n");
 8015e2c:	4814      	ldr	r0, [pc, #80]	; (8015e80 <OsTraceInfoObj+0x74>)
 8015e2e:	f7ee fd47 	bl	80048c0 <dprintf>
        for (i = 0; i < g_traceRecoder.ctrl.maxObjCount; i++, obj++) {
 8015e32:	2300      	movs	r3, #0
 8015e34:	603b      	str	r3, [r7, #0]
 8015e36:	e011      	b.n	8015e5c <OsTraceInfoObj+0x50>
            PRINTK("%-7u 0x%-6x %-10u %s\n", i, obj->id, obj->prio, obj->name);
 8015e38:	687b      	ldr	r3, [r7, #4]
 8015e3a:	681a      	ldr	r2, [r3, #0]
 8015e3c:	687b      	ldr	r3, [r7, #4]
 8015e3e:	6859      	ldr	r1, [r3, #4]
 8015e40:	687b      	ldr	r3, [r7, #4]
 8015e42:	3308      	adds	r3, #8
 8015e44:	9300      	str	r3, [sp, #0]
 8015e46:	460b      	mov	r3, r1
 8015e48:	6839      	ldr	r1, [r7, #0]
 8015e4a:	480e      	ldr	r0, [pc, #56]	; (8015e84 <OsTraceInfoObj+0x78>)
 8015e4c:	f7ee fd38 	bl	80048c0 <dprintf>
        for (i = 0; i < g_traceRecoder.ctrl.maxObjCount; i++, obj++) {
 8015e50:	683b      	ldr	r3, [r7, #0]
 8015e52:	3301      	adds	r3, #1
 8015e54:	603b      	str	r3, [r7, #0]
 8015e56:	687b      	ldr	r3, [r7, #4]
 8015e58:	3328      	adds	r3, #40	; 0x28
 8015e5a:	607b      	str	r3, [r7, #4]
 8015e5c:	4b06      	ldr	r3, [pc, #24]	; (8015e78 <OsTraceInfoObj+0x6c>)
 8015e5e:	88db      	ldrh	r3, [r3, #6]
 8015e60:	461a      	mov	r2, r3
 8015e62:	683b      	ldr	r3, [r7, #0]
 8015e64:	4293      	cmp	r3, r2
 8015e66:	d3e7      	bcc.n	8015e38 <OsTraceInfoObj+0x2c>
        }
        PRINTK("\n");
 8015e68:	4807      	ldr	r0, [pc, #28]	; (8015e88 <OsTraceInfoObj+0x7c>)
 8015e6a:	f7ee fd29 	bl	80048c0 <dprintf>
    }
}
 8015e6e:	bf00      	nop
 8015e70:	3708      	adds	r7, #8
 8015e72:	46bd      	mov	sp, r7
 8015e74:	bd80      	pop	{r7, pc}
 8015e76:	bf00      	nop
 8015e78:	20003374 	.word	0x20003374
 8015e7c:	08022c88 	.word	0x08022c88
 8015e80:	08022c9c 	.word	0x08022c9c
 8015e84:	08022cc4 	.word	0x08022cc4
 8015e88:	08022cdc 	.word	0x08022cdc

08015e8c <OsTraceInfoEventTitle>:

STATIC VOID OsTraceInfoEventTitle(VOID)
{
 8015e8c:	b580      	push	{r7, lr}
 8015e8e:	af00      	add	r7, sp, #0
    PRINTK("CurEvtIndex = %u\n", g_traceRecoder.ctrl.curIndex);
 8015e90:	4b0b      	ldr	r3, [pc, #44]	; (8015ec0 <OsTraceInfoEventTitle+0x34>)
 8015e92:	881b      	ldrh	r3, [r3, #0]
 8015e94:	4619      	mov	r1, r3
 8015e96:	480b      	ldr	r0, [pc, #44]	; (8015ec4 <OsTraceInfoEventTitle+0x38>)
 8015e98:	f7ee fd12 	bl	80048c0 <dprintf>

    PRINTK("Index   Time(cycles)      EventType      CurTask   Identity      ");
 8015e9c:	480a      	ldr	r0, [pc, #40]	; (8015ec8 <OsTraceInfoEventTitle+0x3c>)
 8015e9e:	f7ee fd0f 	bl	80048c0 <dprintf>
#ifdef LOSCFG_TRACE_FRAME_CORE_MSG
    PRINTK("cpuId    hwiActive    taskLockCnt    ");
 8015ea2:	480a      	ldr	r0, [pc, #40]	; (8015ecc <OsTraceInfoEventTitle+0x40>)
 8015ea4:	f7ee fd0c 	bl	80048c0 <dprintf>
#endif
#ifdef LOSCFG_TRACE_FRAME_EVENT_COUNT
    PRINTK("eventCount    ");
 8015ea8:	4809      	ldr	r0, [pc, #36]	; (8015ed0 <OsTraceInfoEventTitle+0x44>)
 8015eaa:	f7ee fd09 	bl	80048c0 <dprintf>
#endif
    if (LOSCFG_TRACE_FRAME_MAX_PARAMS > 0) {
        PRINTK("params    ");
 8015eae:	4809      	ldr	r0, [pc, #36]	; (8015ed4 <OsTraceInfoEventTitle+0x48>)
 8015eb0:	f7ee fd06 	bl	80048c0 <dprintf>
    }
    PRINTK("\n");
 8015eb4:	4808      	ldr	r0, [pc, #32]	; (8015ed8 <OsTraceInfoEventTitle+0x4c>)
 8015eb6:	f7ee fd03 	bl	80048c0 <dprintf>
}
 8015eba:	bf00      	nop
 8015ebc:	bd80      	pop	{r7, pc}
 8015ebe:	bf00      	nop
 8015ec0:	20003374 	.word	0x20003374
 8015ec4:	08022ce0 	.word	0x08022ce0
 8015ec8:	08022cf4 	.word	0x08022cf4
 8015ecc:	08022d38 	.word	0x08022d38
 8015ed0:	08022d60 	.word	0x08022d60
 8015ed4:	08022d70 	.word	0x08022d70
 8015ed8:	08022cdc 	.word	0x08022cdc

08015edc <OsTraceInfoEventData>:

STATIC VOID OsTraceInfoEventData(VOID)
{
 8015edc:	b590      	push	{r4, r7, lr}
 8015ede:	b089      	sub	sp, #36	; 0x24
 8015ee0:	af04      	add	r7, sp, #16
    UINT32 i, j;
    TraceEventFrame *frame = &g_traceRecoder.ctrl.frameBuf[0];
 8015ee2:	4b2b      	ldr	r3, [pc, #172]	; (8015f90 <OsTraceInfoEventData+0xb4>)
 8015ee4:	68db      	ldr	r3, [r3, #12]
 8015ee6:	60bb      	str	r3, [r7, #8]

    for (i = 0; i < g_traceRecoder.ctrl.maxRecordCount; i++, frame++) {
 8015ee8:	2300      	movs	r3, #0
 8015eea:	603b      	str	r3, [r7, #0]
 8015eec:	e044      	b.n	8015f78 <OsTraceInfoEventData+0x9c>
        PRINTK("%-7u 0x%-15llx 0x%-12x 0x%-7x 0x%-11x ", i, frame->curTime, frame->eventType,
 8015eee:	68bb      	ldr	r3, [r7, #8]
 8015ef0:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8015ef4:	68b9      	ldr	r1, [r7, #8]
 8015ef6:	6809      	ldr	r1, [r1, #0]
 8015ef8:	68b8      	ldr	r0, [r7, #8]
 8015efa:	6840      	ldr	r0, [r0, #4]
 8015efc:	68bc      	ldr	r4, [r7, #8]
 8015efe:	6924      	ldr	r4, [r4, #16]
 8015f00:	9402      	str	r4, [sp, #8]
 8015f02:	9001      	str	r0, [sp, #4]
 8015f04:	9100      	str	r1, [sp, #0]
 8015f06:	6839      	ldr	r1, [r7, #0]
 8015f08:	4822      	ldr	r0, [pc, #136]	; (8015f94 <OsTraceInfoEventData+0xb8>)
 8015f0a:	f7ee fcd9 	bl	80048c0 <dprintf>
            frame->curTask, frame->identity);
#ifdef LOSCFG_TRACE_FRAME_CORE_MSG
        UINT32 taskLockCnt = frame->core.taskLockCnt;
 8015f0e:	68bb      	ldr	r3, [r7, #8]
 8015f10:	7d5b      	ldrb	r3, [r3, #21]
 8015f12:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8015f16:	b2db      	uxtb	r3, r3
 8015f18:	60fb      	str	r3, [r7, #12]
         * For smp systems, TRACE_LOCK will requst taskLock, and this counter
         * will increase by 1 in that case.
         */
        taskLockCnt -= 1;
#endif
        PRINTK("%-11u %-11u %-11u", frame->core.cpuId, frame->core.hwiActive, taskLockCnt);
 8015f1a:	68bb      	ldr	r3, [r7, #8]
 8015f1c:	7d1b      	ldrb	r3, [r3, #20]
 8015f1e:	4619      	mov	r1, r3
 8015f20:	68bb      	ldr	r3, [r7, #8]
 8015f22:	7d5b      	ldrb	r3, [r3, #21]
 8015f24:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8015f28:	b2db      	uxtb	r3, r3
 8015f2a:	461a      	mov	r2, r3
 8015f2c:	68fb      	ldr	r3, [r7, #12]
 8015f2e:	481a      	ldr	r0, [pc, #104]	; (8015f98 <OsTraceInfoEventData+0xbc>)
 8015f30:	f7ee fcc6 	bl	80048c0 <dprintf>
#endif
#ifdef LOSCFG_TRACE_FRAME_EVENT_COUNT
        PRINTK("%-11u", frame->eventCount);
 8015f34:	68bb      	ldr	r3, [r7, #8]
 8015f36:	699b      	ldr	r3, [r3, #24]
 8015f38:	4619      	mov	r1, r3
 8015f3a:	4818      	ldr	r0, [pc, #96]	; (8015f9c <OsTraceInfoEventData+0xc0>)
 8015f3c:	f7ee fcc0 	bl	80048c0 <dprintf>
#endif
        for (j = 0; j < LOSCFG_TRACE_FRAME_MAX_PARAMS; j++) {
 8015f40:	2300      	movs	r3, #0
 8015f42:	607b      	str	r3, [r7, #4]
 8015f44:	e00c      	b.n	8015f60 <OsTraceInfoEventData+0x84>
            PRINTK("0x%-11x", frame->params[j]);
 8015f46:	68ba      	ldr	r2, [r7, #8]
 8015f48:	687b      	ldr	r3, [r7, #4]
 8015f4a:	3306      	adds	r3, #6
 8015f4c:	009b      	lsls	r3, r3, #2
 8015f4e:	4413      	add	r3, r2
 8015f50:	685b      	ldr	r3, [r3, #4]
 8015f52:	4619      	mov	r1, r3
 8015f54:	4812      	ldr	r0, [pc, #72]	; (8015fa0 <OsTraceInfoEventData+0xc4>)
 8015f56:	f7ee fcb3 	bl	80048c0 <dprintf>
        for (j = 0; j < LOSCFG_TRACE_FRAME_MAX_PARAMS; j++) {
 8015f5a:	687b      	ldr	r3, [r7, #4]
 8015f5c:	3301      	adds	r3, #1
 8015f5e:	607b      	str	r3, [r7, #4]
 8015f60:	687b      	ldr	r3, [r7, #4]
 8015f62:	2b02      	cmp	r3, #2
 8015f64:	d9ef      	bls.n	8015f46 <OsTraceInfoEventData+0x6a>
        }
        PRINTK("\n");
 8015f66:	480f      	ldr	r0, [pc, #60]	; (8015fa4 <OsTraceInfoEventData+0xc8>)
 8015f68:	f7ee fcaa 	bl	80048c0 <dprintf>
    for (i = 0; i < g_traceRecoder.ctrl.maxRecordCount; i++, frame++) {
 8015f6c:	683b      	ldr	r3, [r7, #0]
 8015f6e:	3301      	adds	r3, #1
 8015f70:	603b      	str	r3, [r7, #0]
 8015f72:	68bb      	ldr	r3, [r7, #8]
 8015f74:	3328      	adds	r3, #40	; 0x28
 8015f76:	60bb      	str	r3, [r7, #8]
 8015f78:	4b05      	ldr	r3, [pc, #20]	; (8015f90 <OsTraceInfoEventData+0xb4>)
 8015f7a:	885b      	ldrh	r3, [r3, #2]
 8015f7c:	461a      	mov	r2, r3
 8015f7e:	683b      	ldr	r3, [r7, #0]
 8015f80:	4293      	cmp	r3, r2
 8015f82:	d3b4      	bcc.n	8015eee <OsTraceInfoEventData+0x12>
    }
}
 8015f84:	bf00      	nop
 8015f86:	bf00      	nop
 8015f88:	3714      	adds	r7, #20
 8015f8a:	46bd      	mov	sp, r7
 8015f8c:	bd90      	pop	{r4, r7, pc}
 8015f8e:	bf00      	nop
 8015f90:	20003374 	.word	0x20003374
 8015f94:	08022d7c 	.word	0x08022d7c
 8015f98:	08022da4 	.word	0x08022da4
 8015f9c:	08022db8 	.word	0x08022db8
 8015fa0:	08022dc0 	.word	0x08022dc0
 8015fa4:	08022cdc 	.word	0x08022cdc

08015fa8 <OsTraceInfoDisplay>:

STATIC VOID OsTraceInfoDisplay(VOID)
{
 8015fa8:	b580      	push	{r7, lr}
 8015faa:	b082      	sub	sp, #8
 8015fac:	af00      	add	r7, sp, #0
    OfflineHead *head = g_traceRecoder.head;
 8015fae:	4b0c      	ldr	r3, [pc, #48]	; (8015fe0 <OsTraceInfoDisplay+0x38>)
 8015fb0:	691b      	ldr	r3, [r3, #16]
 8015fb2:	607b      	str	r3, [r7, #4]

    PRINTK("*******TraceInfo begin*******\n");
 8015fb4:	480b      	ldr	r0, [pc, #44]	; (8015fe4 <OsTraceInfoDisplay+0x3c>)
 8015fb6:	f7ee fc83 	bl	80048c0 <dprintf>
    PRINTK("clockFreq = %u\n", head->baseInfo.clockFreq);
 8015fba:	687b      	ldr	r3, [r7, #4]
 8015fbc:	685b      	ldr	r3, [r3, #4]
 8015fbe:	4619      	mov	r1, r3
 8015fc0:	4809      	ldr	r0, [pc, #36]	; (8015fe8 <OsTraceInfoDisplay+0x40>)
 8015fc2:	f7ee fc7d 	bl	80048c0 <dprintf>

    OsTraceInfoObj();
 8015fc6:	f7ff ff21 	bl	8015e0c <OsTraceInfoObj>

    OsTraceInfoEventTitle();
 8015fca:	f7ff ff5f 	bl	8015e8c <OsTraceInfoEventTitle>
    OsTraceInfoEventData();
 8015fce:	f7ff ff85 	bl	8015edc <OsTraceInfoEventData>

    PRINTK("*******TraceInfo end*******\n");
 8015fd2:	4806      	ldr	r0, [pc, #24]	; (8015fec <OsTraceInfoDisplay+0x44>)
 8015fd4:	f7ee fc74 	bl	80048c0 <dprintf>
}
 8015fd8:	bf00      	nop
 8015fda:	3708      	adds	r7, #8
 8015fdc:	46bd      	mov	sp, r7
 8015fde:	bd80      	pop	{r7, pc}
 8015fe0:	20003374 	.word	0x20003374
 8015fe4:	08022dc8 	.word	0x08022dc8
 8015fe8:	08022de8 	.word	0x08022de8
 8015fec:	08022df8 	.word	0x08022df8

08015ff0 <OsTraceSendInfo>:

#ifdef LOSCFG_TRACE_CLIENT_INTERACT
STATIC VOID OsTraceSendInfo(VOID)
{
 8015ff0:	b580      	push	{r7, lr}
 8015ff2:	b084      	sub	sp, #16
 8015ff4:	af00      	add	r7, sp, #0
    UINT32 i;
    ObjData *obj = NULL;
 8015ff6:	2300      	movs	r3, #0
 8015ff8:	60bb      	str	r3, [r7, #8]
    TraceEventFrame *frame = NULL;
 8015ffa:	2300      	movs	r3, #0
 8015ffc:	60fb      	str	r3, [r7, #12]

    OsTraceDataSend(HEAD, sizeof(OfflineHead), (UINT8 *)g_traceRecoder.head);
 8015ffe:	4b22      	ldr	r3, [pc, #136]	; (8016088 <OsTraceSendInfo+0x98>)
 8016000:	691b      	ldr	r3, [r3, #16]
 8016002:	461a      	mov	r2, r3
 8016004:	2118      	movs	r1, #24
 8016006:	2001      	movs	r0, #1
 8016008:	f000 f8b4 	bl	8016174 <OsTraceDataSend>

    obj = &g_traceRecoder.ctrl.objBuf[0];
 801600c:	4b1e      	ldr	r3, [pc, #120]	; (8016088 <OsTraceSendInfo+0x98>)
 801600e:	689b      	ldr	r3, [r3, #8]
 8016010:	60bb      	str	r3, [r7, #8]
    for (i = 0; i < g_traceRecoder.ctrl.maxObjCount; i++) {
 8016012:	2300      	movs	r3, #0
 8016014:	607b      	str	r3, [r7, #4]
 8016016:	e00f      	b.n	8016038 <OsTraceSendInfo+0x48>
        OsTraceDataSend(OBJ, sizeof(ObjData), (UINT8 *)(obj + i));
 8016018:	687a      	ldr	r2, [r7, #4]
 801601a:	4613      	mov	r3, r2
 801601c:	009b      	lsls	r3, r3, #2
 801601e:	4413      	add	r3, r2
 8016020:	00db      	lsls	r3, r3, #3
 8016022:	461a      	mov	r2, r3
 8016024:	68bb      	ldr	r3, [r7, #8]
 8016026:	4413      	add	r3, r2
 8016028:	461a      	mov	r2, r3
 801602a:	2128      	movs	r1, #40	; 0x28
 801602c:	2002      	movs	r0, #2
 801602e:	f000 f8a1 	bl	8016174 <OsTraceDataSend>
    for (i = 0; i < g_traceRecoder.ctrl.maxObjCount; i++) {
 8016032:	687b      	ldr	r3, [r7, #4]
 8016034:	3301      	adds	r3, #1
 8016036:	607b      	str	r3, [r7, #4]
 8016038:	4b13      	ldr	r3, [pc, #76]	; (8016088 <OsTraceSendInfo+0x98>)
 801603a:	88db      	ldrh	r3, [r3, #6]
 801603c:	461a      	mov	r2, r3
 801603e:	687b      	ldr	r3, [r7, #4]
 8016040:	4293      	cmp	r3, r2
 8016042:	d3e9      	bcc.n	8016018 <OsTraceSendInfo+0x28>
    }

    frame = &g_traceRecoder.ctrl.frameBuf[0];
 8016044:	4b10      	ldr	r3, [pc, #64]	; (8016088 <OsTraceSendInfo+0x98>)
 8016046:	68db      	ldr	r3, [r3, #12]
 8016048:	60fb      	str	r3, [r7, #12]
    for (i = 0; i < g_traceRecoder.ctrl.maxRecordCount; i++) {
 801604a:	2300      	movs	r3, #0
 801604c:	607b      	str	r3, [r7, #4]
 801604e:	e00f      	b.n	8016070 <OsTraceSendInfo+0x80>
        OsTraceDataSend(EVENT, sizeof(TraceEventFrame), (UINT8 *)(frame + i));
 8016050:	687a      	ldr	r2, [r7, #4]
 8016052:	4613      	mov	r3, r2
 8016054:	009b      	lsls	r3, r3, #2
 8016056:	4413      	add	r3, r2
 8016058:	00db      	lsls	r3, r3, #3
 801605a:	461a      	mov	r2, r3
 801605c:	68fb      	ldr	r3, [r7, #12]
 801605e:	4413      	add	r3, r2
 8016060:	461a      	mov	r2, r3
 8016062:	2128      	movs	r1, #40	; 0x28
 8016064:	2003      	movs	r0, #3
 8016066:	f000 f885 	bl	8016174 <OsTraceDataSend>
    for (i = 0; i < g_traceRecoder.ctrl.maxRecordCount; i++) {
 801606a:	687b      	ldr	r3, [r7, #4]
 801606c:	3301      	adds	r3, #1
 801606e:	607b      	str	r3, [r7, #4]
 8016070:	4b05      	ldr	r3, [pc, #20]	; (8016088 <OsTraceSendInfo+0x98>)
 8016072:	885b      	ldrh	r3, [r3, #2]
 8016074:	461a      	mov	r2, r3
 8016076:	687b      	ldr	r3, [r7, #4]
 8016078:	4293      	cmp	r3, r2
 801607a:	d3e9      	bcc.n	8016050 <OsTraceSendInfo+0x60>
    }
}
 801607c:	bf00      	nop
 801607e:	bf00      	nop
 8016080:	3710      	adds	r7, #16
 8016082:	46bd      	mov	sp, r7
 8016084:	bd80      	pop	{r7, pc}
 8016086:	bf00      	nop
 8016088:	20003374 	.word	0x20003374

0801608c <OsTraceRecordDump>:
#endif

VOID OsTraceRecordDump(BOOL toClient)
{
 801608c:	b580      	push	{r7, lr}
 801608e:	b082      	sub	sp, #8
 8016090:	af00      	add	r7, sp, #0
 8016092:	6078      	str	r0, [r7, #4]
    if (!toClient) {
 8016094:	687b      	ldr	r3, [r7, #4]
 8016096:	2b00      	cmp	r3, #0
 8016098:	d102      	bne.n	80160a0 <OsTraceRecordDump+0x14>
        OsTraceInfoDisplay();
 801609a:	f7ff ff85 	bl	8015fa8 <OsTraceInfoDisplay>
        return;
 801609e:	e001      	b.n	80160a4 <OsTraceRecordDump+0x18>
    }

#ifdef LOSCFG_TRACE_CLIENT_INTERACT
    OsTraceSendInfo();
 80160a0:	f7ff ffa6 	bl	8015ff0 <OsTraceSendInfo>
#endif
}
 80160a4:	3708      	adds	r7, #8
 80160a6:	46bd      	mov	sp, r7
 80160a8:	bd80      	pop	{r7, pc}

080160aa <LOS_IntLock>:
{
 80160aa:	b580      	push	{r7, lr}
 80160ac:	af00      	add	r7, sp, #0
    return ArchIntLock();
 80160ae:	f7ea fe0b 	bl	8000cc8 <ArchIntLock>
 80160b2:	4603      	mov	r3, r0
}
 80160b4:	4618      	mov	r0, r3
 80160b6:	bd80      	pop	{r7, pc}

080160b8 <LOS_IntRestore>:
{
 80160b8:	b580      	push	{r7, lr}
 80160ba:	b082      	sub	sp, #8
 80160bc:	af00      	add	r7, sp, #0
 80160be:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 80160c0:	6878      	ldr	r0, [r7, #4]
 80160c2:	f7ea fe09 	bl	8000cd8 <ArchIntRestore>
}
 80160c6:	bf00      	nop
 80160c8:	3708      	adds	r7, #8
 80160ca:	46bd      	mov	sp, r7
 80160cc:	bd80      	pop	{r7, pc}

080160ce <LOS_SpinLockSave>:
{
 80160ce:	b580      	push	{r7, lr}
 80160d0:	b082      	sub	sp, #8
 80160d2:	af00      	add	r7, sp, #0
 80160d4:	6078      	str	r0, [r7, #4]
 80160d6:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 80160d8:	f7ff ffe7 	bl	80160aa <LOS_IntLock>
 80160dc:	4602      	mov	r2, r0
 80160de:	683b      	ldr	r3, [r7, #0]
 80160e0:	601a      	str	r2, [r3, #0]
}
 80160e2:	bf00      	nop
 80160e4:	3708      	adds	r7, #8
 80160e6:	46bd      	mov	sp, r7
 80160e8:	bd80      	pop	{r7, pc}

080160ea <LOS_SpinUnlockRestore>:
{
 80160ea:	b580      	push	{r7, lr}
 80160ec:	b082      	sub	sp, #8
 80160ee:	af00      	add	r7, sp, #0
 80160f0:	6078      	str	r0, [r7, #4]
 80160f2:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 80160f4:	6838      	ldr	r0, [r7, #0]
 80160f6:	f7ff ffdf 	bl	80160b8 <LOS_IntRestore>
}
 80160fa:	bf00      	nop
 80160fc:	3708      	adds	r7, #8
 80160fe:	46bd      	mov	sp, r7
 8016100:	bd80      	pop	{r7, pc}

08016102 <DefaultPipelineInit>:
    g_traceTlvTblObj,
    g_traceTlvTblEvent
};

STATIC UINT32 DefaultPipelineInit(VOID)
{
 8016102:	b480      	push	{r7}
 8016104:	af00      	add	r7, sp, #0
    return LOS_OK;
 8016106:	2300      	movs	r3, #0
}
 8016108:	4618      	mov	r0, r3
 801610a:	46bd      	mov	sp, r7
 801610c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016110:	4770      	bx	lr

08016112 <DefaultDataSend>:

STATIC VOID DefaultDataSend(UINT16 len, UINT8 *data)
{
 8016112:	b480      	push	{r7}
 8016114:	b083      	sub	sp, #12
 8016116:	af00      	add	r7, sp, #0
 8016118:	4603      	mov	r3, r0
 801611a:	6039      	str	r1, [r7, #0]
 801611c:	80fb      	strh	r3, [r7, #6]
    (VOID)len;
    (VOID)data;
}
 801611e:	bf00      	nop
 8016120:	370c      	adds	r7, #12
 8016122:	46bd      	mov	sp, r7
 8016124:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016128:	4770      	bx	lr

0801612a <DefaultDataReceive>:

STATIC UINT32 DefaultDataReceive(UINT8 *data, UINT32 size, UINT32 timeout)
{
 801612a:	b480      	push	{r7}
 801612c:	b085      	sub	sp, #20
 801612e:	af00      	add	r7, sp, #0
 8016130:	60f8      	str	r0, [r7, #12]
 8016132:	60b9      	str	r1, [r7, #8]
 8016134:	607a      	str	r2, [r7, #4]
    (VOID)data;
    (VOID)size;
    (VOID)timeout;
    return LOS_OK;
 8016136:	2300      	movs	r3, #0
}
 8016138:	4618      	mov	r0, r3
 801613a:	3714      	adds	r7, #20
 801613c:	46bd      	mov	sp, r7
 801613e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016142:	4770      	bx	lr

08016144 <DefaultWait>:

STATIC UINT32 DefaultWait(VOID)
{
 8016144:	b480      	push	{r7}
 8016146:	af00      	add	r7, sp, #0
    return LOS_OK;
 8016148:	2300      	movs	r3, #0
}
 801614a:	4618      	mov	r0, r3
 801614c:	46bd      	mov	sp, r7
 801614e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016152:	4770      	bx	lr

08016154 <OsTracePipelineReg>:
};

STATIC const TracePipelineOps *g_tracePipelineOps = &g_defaultOps;

VOID OsTracePipelineReg(const TracePipelineOps *ops)
{
 8016154:	b480      	push	{r7}
 8016156:	b083      	sub	sp, #12
 8016158:	af00      	add	r7, sp, #0
 801615a:	6078      	str	r0, [r7, #4]
    g_tracePipelineOps = ops;
 801615c:	4a04      	ldr	r2, [pc, #16]	; (8016170 <OsTracePipelineReg+0x1c>)
 801615e:	687b      	ldr	r3, [r7, #4]
 8016160:	6013      	str	r3, [r2, #0]
}
 8016162:	bf00      	nop
 8016164:	370c      	adds	r7, #12
 8016166:	46bd      	mov	sp, r7
 8016168:	f85d 7b04 	ldr.w	r7, [sp], #4
 801616c:	4770      	bx	lr
 801616e:	bf00      	nop
 8016170:	20000504 	.word	0x20000504

08016174 <OsTraceDataSend>:

VOID OsTraceDataSend(UINT8 type, UINT16 len, UINT8 *data)
{
 8016174:	b580      	push	{r7, lr}
 8016176:	b0a0      	sub	sp, #128	; 0x80
 8016178:	af02      	add	r7, sp, #8
 801617a:	4603      	mov	r3, r0
 801617c:	603a      	str	r2, [r7, #0]
 801617e:	71fb      	strb	r3, [r7, #7]
 8016180:	460b      	mov	r3, r1
 8016182:	80bb      	strh	r3, [r7, #4]
 8016184:	4b20      	ldr	r3, [pc, #128]	; (8016208 <OsTraceDataSend+0x94>)
 8016186:	681b      	ldr	r3, [r3, #0]
 8016188:	677b      	str	r3, [r7, #116]	; 0x74
 801618a:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT8 outBuf[LOSCFG_TRACE_TLV_BUF_SIZE] = {0};
 801618e:	2300      	movs	r3, #0
 8016190:	613b      	str	r3, [r7, #16]
 8016192:	f107 0314 	add.w	r3, r7, #20
 8016196:	2260      	movs	r2, #96	; 0x60
 8016198:	2100      	movs	r1, #0
 801619a:	4618      	mov	r0, r3
 801619c:	f7f9 f8b4 	bl	800f308 <memset>

    if ((type > TRACE_MSG_MAX) || (len > LOSCFG_TRACE_TLV_BUF_SIZE)) {
 80161a0:	79fb      	ldrb	r3, [r7, #7]
 80161a2:	2b04      	cmp	r3, #4
 80161a4:	d824      	bhi.n	80161f0 <OsTraceDataSend+0x7c>
 80161a6:	88bb      	ldrh	r3, [r7, #4]
 80161a8:	2b64      	cmp	r3, #100	; 0x64
 80161aa:	d821      	bhi.n	80161f0 <OsTraceDataSend+0x7c>
        return;
    }

    len = OsTraceDataEncode(type, g_traceTlvTbl[type], data, &outBuf[0], sizeof(outBuf));
 80161ac:	79fb      	ldrb	r3, [r7, #7]
 80161ae:	4a17      	ldr	r2, [pc, #92]	; (801620c <OsTraceDataSend+0x98>)
 80161b0:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 80161b4:	f107 0310 	add.w	r3, r7, #16
 80161b8:	79f8      	ldrb	r0, [r7, #7]
 80161ba:	2264      	movs	r2, #100	; 0x64
 80161bc:	9200      	str	r2, [sp, #0]
 80161be:	683a      	ldr	r2, [r7, #0]
 80161c0:	f000 f903 	bl	80163ca <OsTraceDataEncode>
 80161c4:	4603      	mov	r3, r0
 80161c6:	80bb      	strh	r3, [r7, #4]

    PIPE_LOCK(intSave);
 80161c8:	f107 030c 	add.w	r3, r7, #12
 80161cc:	4619      	mov	r1, r3
 80161ce:	4810      	ldr	r0, [pc, #64]	; (8016210 <OsTraceDataSend+0x9c>)
 80161d0:	f7ff ff7d 	bl	80160ce <LOS_SpinLockSave>
    g_tracePipelineOps->dataSend(len, &outBuf[0]);
 80161d4:	4b0f      	ldr	r3, [pc, #60]	; (8016214 <OsTraceDataSend+0xa0>)
 80161d6:	681b      	ldr	r3, [r3, #0]
 80161d8:	685b      	ldr	r3, [r3, #4]
 80161da:	f107 0110 	add.w	r1, r7, #16
 80161de:	88ba      	ldrh	r2, [r7, #4]
 80161e0:	4610      	mov	r0, r2
 80161e2:	4798      	blx	r3
    PIPE_UNLOCK(intSave);
 80161e4:	68fb      	ldr	r3, [r7, #12]
 80161e6:	4619      	mov	r1, r3
 80161e8:	4809      	ldr	r0, [pc, #36]	; (8016210 <OsTraceDataSend+0x9c>)
 80161ea:	f7ff ff7e 	bl	80160ea <LOS_SpinUnlockRestore>
 80161ee:	e000      	b.n	80161f2 <OsTraceDataSend+0x7e>
        return;
 80161f0:	bf00      	nop
}
 80161f2:	4b05      	ldr	r3, [pc, #20]	; (8016208 <OsTraceDataSend+0x94>)
 80161f4:	681a      	ldr	r2, [r3, #0]
 80161f6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80161f8:	405a      	eors	r2, r3
 80161fa:	d001      	beq.n	8016200 <OsTraceDataSend+0x8c>
 80161fc:	f7ee f9ee 	bl	80045dc <__stack_chk_fail>
 8016200:	3778      	adds	r7, #120	; 0x78
 8016202:	46bd      	mov	sp, r7
 8016204:	bd80      	pop	{r7, pc}
 8016206:	bf00      	nop
 8016208:	08022e18 	.word	0x08022e18
 801620c:	200004e4 	.word	0x200004e4
 8016210:	200033c8 	.word	0x200033c8
 8016214:	20000504 	.word	0x20000504

08016218 <SerialPipelineInit>:
}

#else

UINT32 SerialPipelineInit(VOID)
{
 8016218:	b480      	push	{r7}
 801621a:	af00      	add	r7, sp, #0
    return LOS_OK;
 801621c:	2300      	movs	r3, #0
}
 801621e:	4618      	mov	r0, r3
 8016220:	46bd      	mov	sp, r7
 8016222:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016226:	4770      	bx	lr

08016228 <SerialDataReceive>:

UINT32 SerialDataReceive(UINT8 *data, UINT32 size, UINT32 timeout)
{
 8016228:	b480      	push	{r7}
 801622a:	b085      	sub	sp, #20
 801622c:	af00      	add	r7, sp, #0
 801622e:	60f8      	str	r0, [r7, #12]
 8016230:	60b9      	str	r1, [r7, #8]
 8016232:	607a      	str	r2, [r7, #4]
    return LOS_OK;
 8016234:	2300      	movs	r3, #0
}
 8016236:	4618      	mov	r0, r3
 8016238:	3714      	adds	r7, #20
 801623a:	46bd      	mov	sp, r7
 801623c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016240:	4770      	bx	lr

08016242 <SerialWait>:

UINT32 SerialWait(VOID)
{
 8016242:	b480      	push	{r7}
 8016244:	af00      	add	r7, sp, #0
    return LOS_OK;
 8016246:	2300      	movs	r3, #0
}
 8016248:	4618      	mov	r0, r3
 801624a:	46bd      	mov	sp, r7
 801624c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016250:	4770      	bx	lr

08016252 <SerialDataSend>:
#endif

VOID SerialDataSend(UINT16 len, UINT8 *data)
{
 8016252:	b580      	push	{r7, lr}
 8016254:	b084      	sub	sp, #16
 8016256:	af00      	add	r7, sp, #0
 8016258:	4603      	mov	r3, r0
 801625a:	6039      	str	r1, [r7, #0]
 801625c:	80fb      	strh	r3, [r7, #6]
    UINT32 i;

    for (i = 0; i < len; i++) {
 801625e:	2300      	movs	r3, #0
 8016260:	60fb      	str	r3, [r7, #12]
 8016262:	e009      	b.n	8016278 <SerialDataSend+0x26>
        UART_PUTC(data[i]);
 8016264:	683a      	ldr	r2, [r7, #0]
 8016266:	68fb      	ldr	r3, [r7, #12]
 8016268:	4413      	add	r3, r2
 801626a:	781b      	ldrb	r3, [r3, #0]
 801626c:	4618      	mov	r0, r3
 801626e:	f7fa fb25 	bl	80108bc <uart_putc>
    for (i = 0; i < len; i++) {
 8016272:	68fb      	ldr	r3, [r7, #12]
 8016274:	3301      	adds	r3, #1
 8016276:	60fb      	str	r3, [r7, #12]
 8016278:	88fb      	ldrh	r3, [r7, #6]
 801627a:	68fa      	ldr	r2, [r7, #12]
 801627c:	429a      	cmp	r2, r3
 801627e:	d3f1      	bcc.n	8016264 <SerialDataSend+0x12>
    }
}
 8016280:	bf00      	nop
 8016282:	bf00      	nop
 8016284:	3710      	adds	r7, #16
 8016286:	46bd      	mov	sp, r7
 8016288:	bd80      	pop	{r7, pc}
	...

0801628c <OsTracePipelineInit>:
    .dataRecv = SerialDataReceive,
    .wait = SerialWait,
};

UINT32 OsTracePipelineInit(VOID)
{
 801628c:	b580      	push	{r7, lr}
 801628e:	af00      	add	r7, sp, #0
    OsTracePipelineReg(&g_serialOps);
 8016290:	4803      	ldr	r0, [pc, #12]	; (80162a0 <OsTracePipelineInit+0x14>)
 8016292:	f7ff ff5f 	bl	8016154 <OsTracePipelineReg>
    return g_serialOps.init();
 8016296:	4b03      	ldr	r3, [pc, #12]	; (80162a4 <OsTracePipelineInit+0x18>)
 8016298:	4798      	blx	r3
 801629a:	4603      	mov	r3, r0
}
 801629c:	4618      	mov	r0, r3
 801629e:	bd80      	pop	{r7, pc}
 80162a0:	0802367c 	.word	0x0802367c
 80162a4:	08016219 	.word	0x08016219

080162a8 <CalcCrc16>:
#define CRC_WIDTH  8
#define CRC_POLY   0x1021
#define CRC_TOPBIT 0x8000

STATIC UINT16 CalcCrc16(const UINT8 *buf, UINT32 len)
{
 80162a8:	b480      	push	{r7}
 80162aa:	b085      	sub	sp, #20
 80162ac:	af00      	add	r7, sp, #0
 80162ae:	6078      	str	r0, [r7, #4]
 80162b0:	6039      	str	r1, [r7, #0]
    UINT32 i;
    UINT16 crc = 0;
 80162b2:	2300      	movs	r3, #0
 80162b4:	817b      	strh	r3, [r7, #10]

    for (; len > 0; len--) {
 80162b6:	e026      	b.n	8016306 <CalcCrc16+0x5e>
        crc = crc ^ (*buf++ << CRC_WIDTH);
 80162b8:	687b      	ldr	r3, [r7, #4]
 80162ba:	1c5a      	adds	r2, r3, #1
 80162bc:	607a      	str	r2, [r7, #4]
 80162be:	781b      	ldrb	r3, [r3, #0]
 80162c0:	021b      	lsls	r3, r3, #8
 80162c2:	b21a      	sxth	r2, r3
 80162c4:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80162c8:	4053      	eors	r3, r2
 80162ca:	b21b      	sxth	r3, r3
 80162cc:	817b      	strh	r3, [r7, #10]
        for (i = 0; i < CRC_WIDTH; i++) {
 80162ce:	2300      	movs	r3, #0
 80162d0:	60fb      	str	r3, [r7, #12]
 80162d2:	e012      	b.n	80162fa <CalcCrc16+0x52>
            if (crc & CRC_TOPBIT) {
 80162d4:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80162d8:	2b00      	cmp	r3, #0
 80162da:	da08      	bge.n	80162ee <CalcCrc16+0x46>
                crc = (crc << 1) ^ CRC_POLY;
 80162dc:	897b      	ldrh	r3, [r7, #10]
 80162de:	005b      	lsls	r3, r3, #1
 80162e0:	b21a      	sxth	r2, r3
 80162e2:	f241 0321 	movw	r3, #4129	; 0x1021
 80162e6:	4053      	eors	r3, r2
 80162e8:	b21b      	sxth	r3, r3
 80162ea:	817b      	strh	r3, [r7, #10]
 80162ec:	e002      	b.n	80162f4 <CalcCrc16+0x4c>
            } else {
                crc <<= 1;
 80162ee:	897b      	ldrh	r3, [r7, #10]
 80162f0:	005b      	lsls	r3, r3, #1
 80162f2:	817b      	strh	r3, [r7, #10]
        for (i = 0; i < CRC_WIDTH; i++) {
 80162f4:	68fb      	ldr	r3, [r7, #12]
 80162f6:	3301      	adds	r3, #1
 80162f8:	60fb      	str	r3, [r7, #12]
 80162fa:	68fb      	ldr	r3, [r7, #12]
 80162fc:	2b07      	cmp	r3, #7
 80162fe:	d9e9      	bls.n	80162d4 <CalcCrc16+0x2c>
    for (; len > 0; len--) {
 8016300:	683b      	ldr	r3, [r7, #0]
 8016302:	3b01      	subs	r3, #1
 8016304:	603b      	str	r3, [r7, #0]
 8016306:	683b      	ldr	r3, [r7, #0]
 8016308:	2b00      	cmp	r3, #0
 801630a:	d1d5      	bne.n	80162b8 <CalcCrc16+0x10>
            }
        }
    }
    return crc;
 801630c:	897b      	ldrh	r3, [r7, #10]
}
 801630e:	4618      	mov	r0, r3
 8016310:	3714      	adds	r7, #20
 8016312:	46bd      	mov	sp, r7
 8016314:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016318:	4770      	bx	lr

0801631a <OsWriteTlv>:

STATIC UINT32 OsWriteTlv(UINT8 *tlvBuf, UINT8 type, UINT8 len, UINT8 *value)
{
 801631a:	b580      	push	{r7, lr}
 801631c:	b086      	sub	sp, #24
 801631e:	af00      	add	r7, sp, #0
 8016320:	60f8      	str	r0, [r7, #12]
 8016322:	607b      	str	r3, [r7, #4]
 8016324:	460b      	mov	r3, r1
 8016326:	72fb      	strb	r3, [r7, #11]
 8016328:	4613      	mov	r3, r2
 801632a:	72bb      	strb	r3, [r7, #10]
    TraceMsgTlvBody *body = (TraceMsgTlvBody *)tlvBuf;
 801632c:	68fb      	ldr	r3, [r7, #12]
 801632e:	617b      	str	r3, [r7, #20]

    if (len == 0) {
 8016330:	7abb      	ldrb	r3, [r7, #10]
 8016332:	2b00      	cmp	r3, #0
 8016334:	d101      	bne.n	801633a <OsWriteTlv+0x20>
        return 0;
 8016336:	2300      	movs	r3, #0
 8016338:	e00e      	b.n	8016358 <OsWriteTlv+0x3e>
    }

    body->type = type;
 801633a:	697b      	ldr	r3, [r7, #20]
 801633c:	7afa      	ldrb	r2, [r7, #11]
 801633e:	701a      	strb	r2, [r3, #0]
    body->len = len;
 8016340:	697b      	ldr	r3, [r7, #20]
 8016342:	7aba      	ldrb	r2, [r7, #10]
 8016344:	705a      	strb	r2, [r3, #1]
    /* Do not check return value for performance, if copy failed, only this package will be discarded */
    (VOID)memcpy_s(body->value, len, value, len);
 8016346:	697b      	ldr	r3, [r7, #20]
 8016348:	1c98      	adds	r0, r3, #2
 801634a:	7ab9      	ldrb	r1, [r7, #10]
 801634c:	7abb      	ldrb	r3, [r7, #10]
 801634e:	687a      	ldr	r2, [r7, #4]
 8016350:	f000 fea2 	bl	8017098 <memcpy_s>
    return len + sizeof(body->type) + sizeof(body->len);
 8016354:	7abb      	ldrb	r3, [r7, #10]
 8016356:	3302      	adds	r3, #2
}
 8016358:	4618      	mov	r0, r3
 801635a:	3718      	adds	r7, #24
 801635c:	46bd      	mov	sp, r7
 801635e:	bd80      	pop	{r7, pc}

08016360 <OsTlvEncode>:

STATIC UINT32 OsTlvEncode(const TlvTable *table, UINT8 *srcBuf, UINT8 *tlvBuf, INT32 tlvBufLen)
{
 8016360:	b590      	push	{r4, r7, lr}
 8016362:	b087      	sub	sp, #28
 8016364:	af00      	add	r7, sp, #0
 8016366:	60f8      	str	r0, [r7, #12]
 8016368:	60b9      	str	r1, [r7, #8]
 801636a:	607a      	str	r2, [r7, #4]
 801636c:	603b      	str	r3, [r7, #0]
    UINT32 len = 0;
 801636e:	2300      	movs	r3, #0
 8016370:	613b      	str	r3, [r7, #16]
    const TlvTable *tlvTableItem = table;
 8016372:	68fb      	ldr	r3, [r7, #12]
 8016374:	617b      	str	r3, [r7, #20]

    while (tlvTableItem->tag != TRACE_TLV_TYPE_NULL) {
 8016376:	e01d      	b.n	80163b4 <OsTlvEncode+0x54>
        if ((len + tlvTableItem->elemSize + sizeof(UINT8) + sizeof(UINT8)) > tlvBufLen) {
 8016378:	697b      	ldr	r3, [r7, #20]
 801637a:	789b      	ldrb	r3, [r3, #2]
 801637c:	461a      	mov	r2, r3
 801637e:	693b      	ldr	r3, [r7, #16]
 8016380:	4413      	add	r3, r2
 8016382:	1c9a      	adds	r2, r3, #2
 8016384:	683b      	ldr	r3, [r7, #0]
 8016386:	429a      	cmp	r2, r3
 8016388:	d819      	bhi.n	80163be <OsTlvEncode+0x5e>
            break;
        }
        len += OsWriteTlv(tlvBuf + len, tlvTableItem->tag, tlvTableItem->elemSize, srcBuf + tlvTableItem->elemOffset);
 801638a:	687a      	ldr	r2, [r7, #4]
 801638c:	693b      	ldr	r3, [r7, #16]
 801638e:	18d0      	adds	r0, r2, r3
 8016390:	697b      	ldr	r3, [r7, #20]
 8016392:	7819      	ldrb	r1, [r3, #0]
 8016394:	697b      	ldr	r3, [r7, #20]
 8016396:	789a      	ldrb	r2, [r3, #2]
 8016398:	697b      	ldr	r3, [r7, #20]
 801639a:	785b      	ldrb	r3, [r3, #1]
 801639c:	461c      	mov	r4, r3
 801639e:	68bb      	ldr	r3, [r7, #8]
 80163a0:	4423      	add	r3, r4
 80163a2:	f7ff ffba 	bl	801631a <OsWriteTlv>
 80163a6:	4602      	mov	r2, r0
 80163a8:	693b      	ldr	r3, [r7, #16]
 80163aa:	4413      	add	r3, r2
 80163ac:	613b      	str	r3, [r7, #16]
        tlvTableItem++;
 80163ae:	697b      	ldr	r3, [r7, #20]
 80163b0:	3303      	adds	r3, #3
 80163b2:	617b      	str	r3, [r7, #20]
    while (tlvTableItem->tag != TRACE_TLV_TYPE_NULL) {
 80163b4:	697b      	ldr	r3, [r7, #20]
 80163b6:	781b      	ldrb	r3, [r3, #0]
 80163b8:	2bff      	cmp	r3, #255	; 0xff
 80163ba:	d1dd      	bne.n	8016378 <OsTlvEncode+0x18>
 80163bc:	e000      	b.n	80163c0 <OsTlvEncode+0x60>
            break;
 80163be:	bf00      	nop
    }
    return len;
 80163c0:	693b      	ldr	r3, [r7, #16]
}
 80163c2:	4618      	mov	r0, r3
 80163c4:	371c      	adds	r7, #28
 80163c6:	46bd      	mov	sp, r7
 80163c8:	bd90      	pop	{r4, r7, pc}

080163ca <OsTraceDataEncode>:

UINT32 OsTraceDataEncode(UINT8 type, const TlvTable *table, UINT8 *src, UINT8 *dest, INT32 destLen)
{
 80163ca:	b580      	push	{r7, lr}
 80163cc:	b08a      	sub	sp, #40	; 0x28
 80163ce:	af00      	add	r7, sp, #0
 80163d0:	60b9      	str	r1, [r7, #8]
 80163d2:	607a      	str	r2, [r7, #4]
 80163d4:	603b      	str	r3, [r7, #0]
 80163d6:	4603      	mov	r3, r0
 80163d8:	73fb      	strb	r3, [r7, #15]
    UINT16 crc;
    INT32 len;
    INT32 tlvBufLen;
    UINT8 *tlvBuf = NULL;
 80163da:	2300      	movs	r3, #0
 80163dc:	61bb      	str	r3, [r7, #24]

    TraceMsgTlvHead *head = (TraceMsgTlvHead *)dest;
 80163de:	683b      	ldr	r3, [r7, #0]
 80163e0:	61fb      	str	r3, [r7, #28]
    tlvBufLen = destLen - sizeof(TraceMsgTlvHead);
 80163e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80163e4:	3b06      	subs	r3, #6
 80163e6:	623b      	str	r3, [r7, #32]

    if ((tlvBufLen <= 0) || (table == NULL)) {
 80163e8:	6a3b      	ldr	r3, [r7, #32]
 80163ea:	2b00      	cmp	r3, #0
 80163ec:	dd02      	ble.n	80163f4 <OsTraceDataEncode+0x2a>
 80163ee:	68bb      	ldr	r3, [r7, #8]
 80163f0:	2b00      	cmp	r3, #0
 80163f2:	d101      	bne.n	80163f8 <OsTraceDataEncode+0x2e>
        return 0;
 80163f4:	2300      	movs	r3, #0
 80163f6:	e020      	b.n	801643a <OsTraceDataEncode+0x70>
    }

    tlvBuf = dest + sizeof(TraceMsgTlvHead);
 80163f8:	683b      	ldr	r3, [r7, #0]
 80163fa:	3306      	adds	r3, #6
 80163fc:	61bb      	str	r3, [r7, #24]
    len = OsTlvEncode(table, src, tlvBuf, tlvBufLen);
 80163fe:	6a3b      	ldr	r3, [r7, #32]
 8016400:	69ba      	ldr	r2, [r7, #24]
 8016402:	6879      	ldr	r1, [r7, #4]
 8016404:	68b8      	ldr	r0, [r7, #8]
 8016406:	f7ff ffab 	bl	8016360 <OsTlvEncode>
 801640a:	4603      	mov	r3, r0
 801640c:	627b      	str	r3, [r7, #36]	; 0x24
    crc = CalcCrc16(tlvBuf, len);
 801640e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016410:	4619      	mov	r1, r3
 8016412:	69b8      	ldr	r0, [r7, #24]
 8016414:	f7ff ff48 	bl	80162a8 <CalcCrc16>
 8016418:	4603      	mov	r3, r0
 801641a:	82fb      	strh	r3, [r7, #22]

    head->magicNum = TRACE_TLV_MSG_HEAD;
 801641c:	69fb      	ldr	r3, [r7, #28]
 801641e:	22ff      	movs	r2, #255	; 0xff
 8016420:	701a      	strb	r2, [r3, #0]
    head->msgType  = type;
 8016422:	69fb      	ldr	r3, [r7, #28]
 8016424:	7bfa      	ldrb	r2, [r7, #15]
 8016426:	705a      	strb	r2, [r3, #1]
    head->len      = len;
 8016428:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801642a:	b29a      	uxth	r2, r3
 801642c:	69fb      	ldr	r3, [r7, #28]
 801642e:	805a      	strh	r2, [r3, #2]
    head->crc      = crc;
 8016430:	69fb      	ldr	r3, [r7, #28]
 8016432:	8afa      	ldrh	r2, [r7, #22]
 8016434:	809a      	strh	r2, [r3, #4]
    return len + sizeof(TraceMsgTlvHead);
 8016436:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016438:	3306      	adds	r3, #6
}
 801643a:	4618      	mov	r0, r3
 801643c:	3728      	adds	r7, #40	; 0x28
 801643e:	46bd      	mov	sp, r7
 8016440:	bd80      	pop	{r7, pc}
	...

08016444 <LOS_CppSystemInit>:
#endif /* __cplusplus */

typedef VOID (*InitFunc)(VOID);

LITE_OS_SEC_TEXT_MINOR INT32 LOS_CppSystemInit(UINTPTR initArrayStart, UINTPTR initArrayEnd, INT32 flag)
{
 8016444:	b580      	push	{r7, lr}
 8016446:	b088      	sub	sp, #32
 8016448:	af00      	add	r7, sp, #0
 801644a:	60f8      	str	r0, [r7, #12]
 801644c:	60b9      	str	r1, [r7, #8]
 801644e:	607a      	str	r2, [r7, #4]
    UINTPTR fastEnd    = (UINTPTR)&__fast_end;
 8016450:	4b15      	ldr	r3, [pc, #84]	; (80164a8 <LOS_CppSystemInit+0x64>)
 8016452:	61bb      	str	r3, [r7, #24]
    UINTPTR *start     = (UINTPTR *)initArrayStart;
 8016454:	68fb      	ldr	r3, [r7, #12]
 8016456:	617b      	str	r3, [r7, #20]
    InitFunc initFunc   = NULL;
 8016458:	2300      	movs	r3, #0
 801645a:	61fb      	str	r3, [r7, #28]

#ifdef LOSCFG_AARCH64
    __register_frame(__EH_FRAME_BEGIN__);
#endif

    for (; start != (UINTPTR *)initArrayEnd; ++start) {
 801645c:	e01b      	b.n	8016496 <LOS_CppSystemInit+0x52>
        if ((flag == BEFORE_SCATTER) && ((UINTPTR)*start > fastEnd)) {
 801645e:	687b      	ldr	r3, [r7, #4]
 8016460:	2b00      	cmp	r3, #0
 8016462:	d104      	bne.n	801646e <LOS_CppSystemInit+0x2a>
 8016464:	697b      	ldr	r3, [r7, #20]
 8016466:	681b      	ldr	r3, [r3, #0]
 8016468:	69ba      	ldr	r2, [r7, #24]
 801646a:	429a      	cmp	r2, r3
 801646c:	d30d      	bcc.n	801648a <LOS_CppSystemInit+0x46>
            continue;
        } else if ((flag == AFTER_SCATTER) && ((UINTPTR)*start <= fastEnd)) {
 801646e:	687b      	ldr	r3, [r7, #4]
 8016470:	2b01      	cmp	r3, #1
 8016472:	d104      	bne.n	801647e <LOS_CppSystemInit+0x3a>
 8016474:	697b      	ldr	r3, [r7, #20]
 8016476:	681b      	ldr	r3, [r3, #0]
 8016478:	69ba      	ldr	r2, [r7, #24]
 801647a:	429a      	cmp	r2, r3
 801647c:	d207      	bcs.n	801648e <LOS_CppSystemInit+0x4a>
            continue;
        }

        initFunc = (InitFunc)(*start);
 801647e:	697b      	ldr	r3, [r7, #20]
 8016480:	681b      	ldr	r3, [r3, #0]
 8016482:	61fb      	str	r3, [r7, #28]
        initFunc();
 8016484:	69fb      	ldr	r3, [r7, #28]
 8016486:	4798      	blx	r3
 8016488:	e002      	b.n	8016490 <LOS_CppSystemInit+0x4c>
            continue;
 801648a:	bf00      	nop
 801648c:	e000      	b.n	8016490 <LOS_CppSystemInit+0x4c>
            continue;
 801648e:	bf00      	nop
    for (; start != (UINTPTR *)initArrayEnd; ++start) {
 8016490:	697b      	ldr	r3, [r7, #20]
 8016492:	3304      	adds	r3, #4
 8016494:	617b      	str	r3, [r7, #20]
 8016496:	68bb      	ldr	r3, [r7, #8]
 8016498:	697a      	ldr	r2, [r7, #20]
 801649a:	429a      	cmp	r2, r3
 801649c:	d1df      	bne.n	801645e <LOS_CppSystemInit+0x1a>
    }

    return 0;
 801649e:	2300      	movs	r3, #0
}
 80164a0:	4618      	mov	r0, r3
 80164a2:	3720      	adds	r7, #32
 80164a4:	46bd      	mov	sp, r7
 80164a6:	bd80      	pop	{r7, pc}
 80164a8:	20003de0 	.word	0x20003de0

080164ac <OsTaskExit>:
                 "\tpop {fp, pc}\n");
}
#endif

LITE_OS_SEC_TEXT_MINOR VOID OsTaskExit(VOID)
{
 80164ac:	b480      	push	{r7}
 80164ae:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 80164b0:	b672      	cpsid	i
}
 80164b2:	bf00      	nop
    __disable_irq();
    while (1) { }
 80164b4:	e7fe      	b.n	80164b4 <OsTaskExit+0x8>
	...

080164b8 <OsTaskStackInit>:
}

LITE_OS_SEC_TEXT_INIT VOID *OsTaskStackInit(UINT32 taskId, UINT32 stackSize, VOID *topStack)
{
 80164b8:	b580      	push	{r7, lr}
 80164ba:	b086      	sub	sp, #24
 80164bc:	af00      	add	r7, sp, #0
 80164be:	60f8      	str	r0, [r7, #12]
 80164c0:	60b9      	str	r1, [r7, #8]
 80164c2:	607a      	str	r2, [r7, #4]
    TaskContext *taskContext = NULL;
 80164c4:	2300      	movs	r3, #0
 80164c6:	617b      	str	r3, [r7, #20]

    OsStackInit(topStack, stackSize);
 80164c8:	68b9      	ldr	r1, [r7, #8]
 80164ca:	6878      	ldr	r0, [r7, #4]
 80164cc:	f7f4 f850 	bl	800a570 <OsStackInit>
    taskContext = (TaskContext *)(((UINTPTR)topStack + stackSize) - sizeof(TaskContext));
 80164d0:	687a      	ldr	r2, [r7, #4]
 80164d2:	68bb      	ldr	r3, [r7, #8]
 80164d4:	4413      	add	r3, r2
 80164d6:	3b48      	subs	r3, #72	; 0x48
 80164d8:	617b      	str	r3, [r7, #20]

#ifdef LOSCFG_ARCH_FPU_ENABLE
    taskContext->excReturn = 0xFFFFFFFD;
 80164da:	697b      	ldr	r3, [r7, #20]
 80164dc:	f06f 0202 	mvn.w	r2, #2
 80164e0:	625a      	str	r2, [r3, #36]	; 0x24
#endif

    taskContext->R4  = 0x04040404L;
 80164e2:	697b      	ldr	r3, [r7, #20]
 80164e4:	f04f 3204 	mov.w	r2, #67372036	; 0x4040404
 80164e8:	601a      	str	r2, [r3, #0]
    taskContext->R5  = 0x05050505L;
 80164ea:	697b      	ldr	r3, [r7, #20]
 80164ec:	f04f 3205 	mov.w	r2, #84215045	; 0x5050505
 80164f0:	605a      	str	r2, [r3, #4]
    taskContext->R6  = 0x06060606L;
 80164f2:	697b      	ldr	r3, [r7, #20]
 80164f4:	f04f 3206 	mov.w	r2, #101058054	; 0x6060606
 80164f8:	609a      	str	r2, [r3, #8]
    taskContext->R7  = 0x07070707L;
 80164fa:	697b      	ldr	r3, [r7, #20]
 80164fc:	f04f 3207 	mov.w	r2, #117901063	; 0x7070707
 8016500:	60da      	str	r2, [r3, #12]
    taskContext->R8  = 0x08080808L;
 8016502:	697b      	ldr	r3, [r7, #20]
 8016504:	f04f 3208 	mov.w	r2, #134744072	; 0x8080808
 8016508:	611a      	str	r2, [r3, #16]
    taskContext->R9  = 0x09090909L;
 801650a:	697b      	ldr	r3, [r7, #20]
 801650c:	f04f 3209 	mov.w	r2, #151587081	; 0x9090909
 8016510:	615a      	str	r2, [r3, #20]
    taskContext->R10 = 0x10101010L;
 8016512:	697b      	ldr	r3, [r7, #20]
 8016514:	f04f 3210 	mov.w	r2, #269488144	; 0x10101010
 8016518:	619a      	str	r2, [r3, #24]
    taskContext->R11 = 0x11111111L;
 801651a:	697b      	ldr	r3, [r7, #20]
 801651c:	f04f 3211 	mov.w	r2, #286331153	; 0x11111111
 8016520:	61da      	str	r2, [r3, #28]
    taskContext->PriMask = 0;
 8016522:	697b      	ldr	r3, [r7, #20]
 8016524:	2200      	movs	r2, #0
 8016526:	621a      	str	r2, [r3, #32]
    taskContext->R0  = taskId;
 8016528:	697b      	ldr	r3, [r7, #20]
 801652a:	68fa      	ldr	r2, [r7, #12]
 801652c:	629a      	str	r2, [r3, #40]	; 0x28
    taskContext->R1  = 0x01010101L;
 801652e:	697b      	ldr	r3, [r7, #20]
 8016530:	f04f 3201 	mov.w	r2, #16843009	; 0x1010101
 8016534:	62da      	str	r2, [r3, #44]	; 0x2c
    taskContext->R2  = 0x02020202L;
 8016536:	697b      	ldr	r3, [r7, #20]
 8016538:	f04f 3202 	mov.w	r2, #33686018	; 0x2020202
 801653c:	631a      	str	r2, [r3, #48]	; 0x30
    taskContext->R3  = 0x03030303L;
 801653e:	697b      	ldr	r3, [r7, #20]
 8016540:	f04f 3203 	mov.w	r2, #50529027	; 0x3030303
 8016544:	635a      	str	r2, [r3, #52]	; 0x34
    taskContext->R12 = 0x12121212L;
 8016546:	697b      	ldr	r3, [r7, #20]
 8016548:	f04f 3212 	mov.w	r2, #303174162	; 0x12121212
 801654c:	639a      	str	r2, [r3, #56]	; 0x38
    taskContext->LR  = (UINT32)OsTaskExit;
 801654e:	4a07      	ldr	r2, [pc, #28]	; (801656c <OsTaskStackInit+0xb4>)
 8016550:	697b      	ldr	r3, [r7, #20]
 8016552:	63da      	str	r2, [r3, #60]	; 0x3c
    taskContext->PC  = (UINT32)OsTaskEntry;
 8016554:	4a06      	ldr	r2, [pc, #24]	; (8016570 <OsTaskStackInit+0xb8>)
 8016556:	697b      	ldr	r3, [r7, #20]
 8016558:	641a      	str	r2, [r3, #64]	; 0x40
    taskContext->xPSR = 0x01000000L;
 801655a:	697b      	ldr	r3, [r7, #20]
 801655c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8016560:	645a      	str	r2, [r3, #68]	; 0x44

    return (VOID *)taskContext;
 8016562:	697b      	ldr	r3, [r7, #20]
}
 8016564:	4618      	mov	r0, r3
 8016566:	3718      	adds	r7, #24
 8016568:	46bd      	mov	sp, r7
 801656a:	bd80      	pop	{r7, pc}
 801656c:	080164ad 	.word	0x080164ad
 8016570:	080033e1 	.word	0x080033e1

08016574 <ArchStackGuardInit>:
 * value to replace the function implementation template shown as below.
 */
#pragma GCC push_options
#pragma GCC optimize ("-fno-stack-protector")
LITE_OS_SEC_TEXT_INIT WEAK VOID ArchStackGuardInit(VOID)
{
 8016574:	b480      	push	{r7}
 8016576:	af00      	add	r7, sp, #0
}
 8016578:	bf00      	nop
 801657a:	46bd      	mov	sp, r7
 801657c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016580:	4770      	bx	lr

08016582 <ArchGetSp>:
{
 8016582:	b480      	push	{r7}
 8016584:	b083      	sub	sp, #12
 8016586:	af00      	add	r7, sp, #0
    __asm__ __volatile__("mov %0, sp\n" : "=r"(regSp));
 8016588:	466b      	mov	r3, sp
 801658a:	607b      	str	r3, [r7, #4]
    return regSp;
 801658c:	687b      	ldr	r3, [r7, #4]
}
 801658e:	4618      	mov	r0, r3
 8016590:	370c      	adds	r7, #12
 8016592:	46bd      	mov	sp, r7
 8016594:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016598:	4770      	bx	lr

0801659a <ArchGetPsp>:
{
 801659a:	b480      	push	{r7}
 801659c:	b083      	sub	sp, #12
 801659e:	af00      	add	r7, sp, #0
    __asm__ __volatile__("MRS %0, psp\n" : "=r"(regPsp));
 80165a0:	f3ef 8309 	mrs	r3, PSP
 80165a4:	607b      	str	r3, [r7, #4]
    return regPsp;
 80165a6:	687b      	ldr	r3, [r7, #4]
}
 80165a8:	4618      	mov	r0, r3
 80165aa:	370c      	adds	r7, #12
 80165ac:	46bd      	mov	sp, r7
 80165ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80165b2:	4770      	bx	lr

080165b4 <ArchCurrTaskGet>:
{
 80165b4:	b480      	push	{r7}
 80165b6:	af00      	add	r7, sp, #0
    return g_runTask;
 80165b8:	4b03      	ldr	r3, [pc, #12]	; (80165c8 <ArchCurrTaskGet+0x14>)
 80165ba:	681b      	ldr	r3, [r3, #0]
}
 80165bc:	4618      	mov	r0, r3
 80165be:	46bd      	mov	sp, r7
 80165c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80165c4:	4770      	bx	lr
 80165c6:	bf00      	nop
 80165c8:	200033cc 	.word	0x200033cc

080165cc <OsCurrTaskGet>:
{
 80165cc:	b580      	push	{r7, lr}
 80165ce:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 80165d0:	f7ff fff0 	bl	80165b4 <ArchCurrTaskGet>
 80165d4:	4603      	mov	r3, r0
}
 80165d6:	4618      	mov	r0, r3
 80165d8:	bd80      	pop	{r7, pc}
	...

080165dc <OsExcSysInfo>:
    "fault in task",
    "fault in interrupt",
};

STATIC VOID OsExcSysInfo(VOID)
{
 80165dc:	b580      	push	{r7, lr}
 80165de:	b084      	sub	sp, #16
 80165e0:	af02      	add	r7, sp, #8
    LosTaskCB *runTask = OsCurrTaskGet();
 80165e2:	f7ff fff3 	bl	80165cc <OsCurrTaskGet>
 80165e6:	6078      	str	r0, [r7, #4]

    if (runTask != NULL) {
 80165e8:	687b      	ldr	r3, [r7, #4]
 80165ea:	2b00      	cmp	r3, #0
 80165ec:	d00c      	beq.n	8016608 <OsExcSysInfo+0x2c>
        PrintExcInfo("TaskName = %s\n"
 80165ee:	687b      	ldr	r3, [r7, #4]
 80165f0:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80165f2:	687b      	ldr	r3, [r7, #4]
 80165f4:	695a      	ldr	r2, [r3, #20]
 80165f6:	687b      	ldr	r3, [r7, #4]
 80165f8:	68d8      	ldr	r0, [r3, #12]
 80165fa:	4b05      	ldr	r3, [pc, #20]	; (8016610 <OsExcSysInfo+0x34>)
 80165fc:	681b      	ldr	r3, [r3, #0]
 80165fe:	9300      	str	r3, [sp, #0]
 8016600:	4603      	mov	r3, r0
 8016602:	4804      	ldr	r0, [pc, #16]	; (8016614 <OsExcSysInfo+0x38>)
 8016604:	f7ee f980 	bl	8004908 <PrintExcInfo>
                     runTask->taskName,
                     runTask->taskId,
                     runTask->stackSize,
                     m_aucSysMem0);
    }
}
 8016608:	bf00      	nop
 801660a:	3708      	adds	r7, #8
 801660c:	46bd      	mov	sp, r7
 801660e:	bd80      	pop	{r7, pc}
 8016610:	200021bc 	.word	0x200021bc
 8016614:	08022e50 	.word	0x08022e50

08016618 <OsExcInfoDisplay>:

LITE_OS_SEC_TEXT_INIT VOID OsExcInfoDisplay(const ExcInfo *exc, const ExcContext *excBufAddr)
{
 8016618:	b5f0      	push	{r4, r5, r6, r7, lr}
 801661a:	b0a5      	sub	sp, #148	; 0x94
 801661c:	af14      	add	r7, sp, #80	; 0x50
 801661e:	63f8      	str	r0, [r7, #60]	; 0x3c
 8016620:	63b9      	str	r1, [r7, #56]	; 0x38
                 "PriMask    = 0x%x\n"
                 "SP         = 0x%x\n"
                 "LR         = 0x%x\n"
                 "PC         = 0x%x\n"
                 "xPSR       = 0x%x\n",
                 g_phaseName[exc->phase], exc->type, exc->faultAddr, exc->intNumOrTaskId, excBufAddr->R0,
 8016622:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016624:	881b      	ldrh	r3, [r3, #0]
 8016626:	461a      	mov	r2, r3
    PrintExcInfo("Phase      = %s\n"
 8016628:	4b33      	ldr	r3, [pc, #204]	; (80166f8 <OsExcInfoDisplay+0xe0>)
 801662a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801662e:	637b      	str	r3, [r7, #52]	; 0x34
                 g_phaseName[exc->phase], exc->type, exc->faultAddr, exc->intNumOrTaskId, excBufAddr->R0,
 8016630:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016632:	885b      	ldrh	r3, [r3, #2]
    PrintExcInfo("Phase      = %s\n"
 8016634:	469c      	mov	ip, r3
 8016636:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016638:	685a      	ldr	r2, [r3, #4]
 801663a:	633a      	str	r2, [r7, #48]	; 0x30
 801663c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801663e:	6898      	ldr	r0, [r3, #8]
 8016640:	62f8      	str	r0, [r7, #44]	; 0x2c
 8016642:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016644:	6e9c      	ldr	r4, [r3, #104]	; 0x68
 8016646:	62bc      	str	r4, [r7, #40]	; 0x28
 8016648:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801664a:	6edd      	ldr	r5, [r3, #108]	; 0x6c
 801664c:	627d      	str	r5, [r7, #36]	; 0x24
 801664e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016650:	6f1e      	ldr	r6, [r3, #112]	; 0x70
 8016652:	623e      	str	r6, [r7, #32]
 8016654:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016656:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8016658:	61fa      	str	r2, [r7, #28]
 801665a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801665c:	6c19      	ldr	r1, [r3, #64]	; 0x40
 801665e:	61b9      	str	r1, [r7, #24]
 8016660:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016662:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016664:	617b      	str	r3, [r7, #20]
 8016666:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016668:	6c98      	ldr	r0, [r3, #72]	; 0x48
 801666a:	6138      	str	r0, [r7, #16]
 801666c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801666e:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
 8016670:	60fc      	str	r4, [r7, #12]
 8016672:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016674:	6d1d      	ldr	r5, [r3, #80]	; 0x50
 8016676:	60bd      	str	r5, [r7, #8]
 8016678:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801667a:	6d5e      	ldr	r6, [r3, #84]	; 0x54
 801667c:	607e      	str	r6, [r7, #4]
 801667e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016680:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8016682:	603a      	str	r2, [r7, #0]
 8016684:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016686:	6dde      	ldr	r6, [r3, #92]	; 0x5c
 8016688:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801668a:	6f9d      	ldr	r5, [r3, #120]	; 0x78
 801668c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801668e:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 8016690:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016692:	6e58      	ldr	r0, [r3, #100]	; 0x64
 8016694:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016696:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 8016698:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801669a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 801669e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80166a0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80166a4:	9312      	str	r3, [sp, #72]	; 0x48
 80166a6:	9211      	str	r2, [sp, #68]	; 0x44
 80166a8:	9110      	str	r1, [sp, #64]	; 0x40
 80166aa:	900f      	str	r0, [sp, #60]	; 0x3c
 80166ac:	940e      	str	r4, [sp, #56]	; 0x38
 80166ae:	950d      	str	r5, [sp, #52]	; 0x34
 80166b0:	960c      	str	r6, [sp, #48]	; 0x30
 80166b2:	683a      	ldr	r2, [r7, #0]
 80166b4:	920b      	str	r2, [sp, #44]	; 0x2c
 80166b6:	687e      	ldr	r6, [r7, #4]
 80166b8:	960a      	str	r6, [sp, #40]	; 0x28
 80166ba:	68bd      	ldr	r5, [r7, #8]
 80166bc:	9509      	str	r5, [sp, #36]	; 0x24
 80166be:	68fc      	ldr	r4, [r7, #12]
 80166c0:	9408      	str	r4, [sp, #32]
 80166c2:	6938      	ldr	r0, [r7, #16]
 80166c4:	9007      	str	r0, [sp, #28]
 80166c6:	697b      	ldr	r3, [r7, #20]
 80166c8:	9306      	str	r3, [sp, #24]
 80166ca:	69b9      	ldr	r1, [r7, #24]
 80166cc:	9105      	str	r1, [sp, #20]
 80166ce:	69fa      	ldr	r2, [r7, #28]
 80166d0:	9204      	str	r2, [sp, #16]
 80166d2:	6a3e      	ldr	r6, [r7, #32]
 80166d4:	9603      	str	r6, [sp, #12]
 80166d6:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 80166d8:	9502      	str	r5, [sp, #8]
 80166da:	6abc      	ldr	r4, [r7, #40]	; 0x28
 80166dc:	9401      	str	r4, [sp, #4]
 80166de:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80166e0:	9000      	str	r0, [sp, #0]
 80166e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80166e4:	4662      	mov	r2, ip
 80166e6:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80166e8:	4804      	ldr	r0, [pc, #16]	; (80166fc <OsExcInfoDisplay+0xe4>)
 80166ea:	f7ee f90d 	bl	8004908 <PrintExcInfo>
                 excBufAddr->R1, excBufAddr->R2, excBufAddr->R3, excBufAddr->R4, excBufAddr->R5,
                 excBufAddr->R6, excBufAddr->R7, excBufAddr->R8, excBufAddr->R9,
                 excBufAddr->R10, excBufAddr->R11, excBufAddr->R12, excBufAddr->PriMask,
                 excBufAddr->SP, excBufAddr->LR, excBufAddr->PC, excBufAddr->xPSR);
}
 80166ee:	bf00      	nop
 80166f0:	3744      	adds	r7, #68	; 0x44
 80166f2:	46bd      	mov	sp, r7
 80166f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80166f6:	bf00      	nop
 80166f8:	2000052c 	.word	0x2000052c
 80166fc:	08022e98 	.word	0x08022e98

08016700 <OsExcHandleEntry>:

LITE_OS_SEC_TEXT_INIT VOID OsExcHandleEntry(UINT32 excType, UINT32 faultAddr, UINT32 pid,
                                            const ExcContext *excBufAddr)
{
 8016700:	b580      	push	{r7, lr}
 8016702:	b086      	sub	sp, #24
 8016704:	af00      	add	r7, sp, #0
 8016706:	60f8      	str	r0, [r7, #12]
 8016708:	60b9      	str	r1, [r7, #8]
 801670a:	607a      	str	r2, [r7, #4]
 801670c:	603b      	str	r3, [r7, #0]
    ExcContext *BufAddr = NULL;
 801670e:	2300      	movs	r3, #0
 8016710:	617b      	str	r3, [r7, #20]
    UINT16 tmpFlag = (excType >> MASK_16_BIT) & OS_NULL_SHORT; /* 2:in intrrupt,1:faul addr valid */
 8016712:	68fb      	ldr	r3, [r7, #12]
 8016714:	0c1b      	lsrs	r3, r3, #16
 8016716:	827b      	strh	r3, [r7, #18]
    g_curNestCount++;
 8016718:	4b31      	ldr	r3, [pc, #196]	; (80167e0 <OsExcHandleEntry+0xe0>)
 801671a:	681b      	ldr	r3, [r3, #0]
 801671c:	3301      	adds	r3, #1
 801671e:	4a30      	ldr	r2, [pc, #192]	; (80167e0 <OsExcHandleEntry+0xe0>)
 8016720:	6013      	str	r3, [r2, #0]
    g_excInfo.nestCnt = (UINT16)g_curNestCount;
 8016722:	4b2f      	ldr	r3, [pc, #188]	; (80167e0 <OsExcHandleEntry+0xe0>)
 8016724:	681b      	ldr	r3, [r3, #0]
 8016726:	b29a      	uxth	r2, r3
 8016728:	4b2e      	ldr	r3, [pc, #184]	; (80167e4 <OsExcHandleEntry+0xe4>)
 801672a:	819a      	strh	r2, [r3, #12]

    g_excInfo.type = excType & OS_NULL_SHORT;
 801672c:	68fb      	ldr	r3, [r7, #12]
 801672e:	b29a      	uxth	r2, r3
 8016730:	4b2c      	ldr	r3, [pc, #176]	; (80167e4 <OsExcHandleEntry+0xe4>)
 8016732:	805a      	strh	r2, [r3, #2]

    if (tmpFlag & OS_EXC_FLAG_FAULTADDR_VALID) {
 8016734:	8a7b      	ldrh	r3, [r7, #18]
 8016736:	f003 0301 	and.w	r3, r3, #1
 801673a:	2b00      	cmp	r3, #0
 801673c:	d003      	beq.n	8016746 <OsExcHandleEntry+0x46>
        g_excInfo.faultAddr = faultAddr;
 801673e:	4a29      	ldr	r2, [pc, #164]	; (80167e4 <OsExcHandleEntry+0xe4>)
 8016740:	68bb      	ldr	r3, [r7, #8]
 8016742:	6053      	str	r3, [r2, #4]
 8016744:	e003      	b.n	801674e <OsExcHandleEntry+0x4e>
    } else {
        g_excInfo.faultAddr = OS_EXC_IMPRECISE_ACCESS_ADDR;
 8016746:	4b27      	ldr	r3, [pc, #156]	; (80167e4 <OsExcHandleEntry+0xe4>)
 8016748:	f04f 32ab 	mov.w	r2, #2880154539	; 0xabababab
 801674c:	605a      	str	r2, [r3, #4]
    }

    if (ArchCurrTaskGet() != NULL) {
 801674e:	f7ff ff31 	bl	80165b4 <ArchCurrTaskGet>
 8016752:	4603      	mov	r3, r0
 8016754:	2b00      	cmp	r3, #0
 8016756:	d017      	beq.n	8016788 <OsExcHandleEntry+0x88>
        if (tmpFlag & OS_EXC_FLAG_IN_HWI) {
 8016758:	8a7b      	ldrh	r3, [r7, #18]
 801675a:	f003 0302 	and.w	r3, r3, #2
 801675e:	2b00      	cmp	r3, #0
 8016760:	d006      	beq.n	8016770 <OsExcHandleEntry+0x70>
            g_excInfo.phase = OS_EXC_IN_HWI;
 8016762:	4b20      	ldr	r3, [pc, #128]	; (80167e4 <OsExcHandleEntry+0xe4>)
 8016764:	2202      	movs	r2, #2
 8016766:	801a      	strh	r2, [r3, #0]
            g_excInfo.intNumOrTaskId = pid;
 8016768:	4a1e      	ldr	r2, [pc, #120]	; (80167e4 <OsExcHandleEntry+0xe4>)
 801676a:	687b      	ldr	r3, [r7, #4]
 801676c:	6093      	str	r3, [r2, #8]
 801676e:	e012      	b.n	8016796 <OsExcHandleEntry+0x96>
        } else {
            g_excInfo.phase = OS_EXC_IN_TASK;
 8016770:	4b1c      	ldr	r3, [pc, #112]	; (80167e4 <OsExcHandleEntry+0xe4>)
 8016772:	2201      	movs	r2, #1
 8016774:	801a      	strh	r2, [r3, #0]
            g_excInfo.intNumOrTaskId = ((LosTaskCB *)ArchCurrTaskGet())->taskId;
 8016776:	f7ff ff1d 	bl	80165b4 <ArchCurrTaskGet>
 801677a:	4603      	mov	r3, r0
 801677c:	695b      	ldr	r3, [r3, #20]
 801677e:	4a19      	ldr	r2, [pc, #100]	; (80167e4 <OsExcHandleEntry+0xe4>)
 8016780:	6093      	str	r3, [r2, #8]
            OsExcSysInfo();
 8016782:	f7ff ff2b 	bl	80165dc <OsExcSysInfo>
 8016786:	e006      	b.n	8016796 <OsExcHandleEntry+0x96>
        }
    } else {
        g_excInfo.phase = OS_EXC_IN_INIT;
 8016788:	4b16      	ldr	r3, [pc, #88]	; (80167e4 <OsExcHandleEntry+0xe4>)
 801678a:	2200      	movs	r2, #0
 801678c:	801a      	strh	r2, [r3, #0]
        g_excInfo.intNumOrTaskId = OS_NULL_INT;
 801678e:	4b15      	ldr	r3, [pc, #84]	; (80167e4 <OsExcHandleEntry+0xe4>)
 8016790:	f04f 32ff 	mov.w	r2, #4294967295
 8016794:	609a      	str	r2, [r3, #8]
    }

    if (excType & OS_EXC_FLAG_NO_FLOAT) {
 8016796:	68fb      	ldr	r3, [r7, #12]
 8016798:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 801679c:	2b00      	cmp	r3, #0
 801679e:	d004      	beq.n	80167aa <OsExcHandleEntry+0xaa>
        g_excInfo.context = (ExcContext *)((CHAR *)excBufAddr - LOS_OFF_SET_OF(ExcContext, R4));
 80167a0:	683b      	ldr	r3, [r7, #0]
 80167a2:	3b40      	subs	r3, #64	; 0x40
 80167a4:	4a0f      	ldr	r2, [pc, #60]	; (80167e4 <OsExcHandleEntry+0xe4>)
 80167a6:	6113      	str	r3, [r2, #16]
 80167a8:	e002      	b.n	80167b0 <OsExcHandleEntry+0xb0>
    } else {
        g_excInfo.context = (ExcContext *)excBufAddr;
 80167aa:	4a0e      	ldr	r2, [pc, #56]	; (80167e4 <OsExcHandleEntry+0xe4>)
 80167ac:	683b      	ldr	r3, [r7, #0]
 80167ae:	6113      	str	r3, [r2, #16]
    }

    if (g_excInfo.phase == OS_EXC_IN_TASK) {
 80167b0:	4b0c      	ldr	r3, [pc, #48]	; (80167e4 <OsExcHandleEntry+0xe4>)
 80167b2:	881b      	ldrh	r3, [r3, #0]
 80167b4:	2b01      	cmp	r3, #1
 80167b6:	d105      	bne.n	80167c4 <OsExcHandleEntry+0xc4>
        BufAddr =  (ExcContext *)(ArchGetPsp() - OFFSET_OF_PSP);
 80167b8:	f7ff feef 	bl	801659a <ArchGetPsp>
 80167bc:	4603      	mov	r3, r0
 80167be:	3b28      	subs	r3, #40	; 0x28
 80167c0:	617b      	str	r3, [r7, #20]
 80167c2:	e002      	b.n	80167ca <OsExcHandleEntry+0xca>
    } else {
        BufAddr = g_excInfo.context;
 80167c4:	4b07      	ldr	r3, [pc, #28]	; (80167e4 <OsExcHandleEntry+0xe4>)
 80167c6:	691b      	ldr	r3, [r3, #16]
 80167c8:	617b      	str	r3, [r7, #20]
    }

    OsExcInfoDisplay((const ExcInfo *)&g_excInfo, BufAddr);
 80167ca:	6979      	ldr	r1, [r7, #20]
 80167cc:	4805      	ldr	r0, [pc, #20]	; (80167e4 <OsExcHandleEntry+0xe4>)
 80167ce:	f7ff ff23 	bl	8016618 <OsExcInfoDisplay>

#ifdef LOSCFG_BACKTRACE
    ArchBackTraceWithSp(BufAddr);
 80167d2:	6978      	ldr	r0, [r7, #20]
 80167d4:	f000 f9c8 	bl	8016b68 <ArchBackTraceWithSp>
#endif

#ifdef LOSCFG_KERNEL_TRACE
    OsTraceRecordDump(FALSE);
 80167d8:	2000      	movs	r0, #0
 80167da:	f7ff fc57 	bl	801608c <OsTraceRecordDump>
#endif
    while (1) { }
 80167de:	e7fe      	b.n	80167de <OsExcHandleEntry+0xde>
 80167e0:	200033d4 	.word	0x200033d4
 80167e4:	20003778 	.word	0x20003778

080167e8 <IsValidSP>:
}

#ifdef LOSCFG_BACKTRACE
/* this function is used to validate sp or validate the checking range start and end. */
STATIC INLINE BOOL IsValidSP(UINTPTR regSP, UINTPTR start, UINTPTR end)
{
 80167e8:	b480      	push	{r7}
 80167ea:	b085      	sub	sp, #20
 80167ec:	af00      	add	r7, sp, #0
 80167ee:	60f8      	str	r0, [r7, #12]
 80167f0:	60b9      	str	r1, [r7, #8]
 80167f2:	607a      	str	r2, [r7, #4]
    return (regSP >= start) && (regSP < end);
 80167f4:	68fa      	ldr	r2, [r7, #12]
 80167f6:	68bb      	ldr	r3, [r7, #8]
 80167f8:	429a      	cmp	r2, r3
 80167fa:	d305      	bcc.n	8016808 <IsValidSP+0x20>
 80167fc:	68fa      	ldr	r2, [r7, #12]
 80167fe:	687b      	ldr	r3, [r7, #4]
 8016800:	429a      	cmp	r2, r3
 8016802:	d201      	bcs.n	8016808 <IsValidSP+0x20>
 8016804:	2301      	movs	r3, #1
 8016806:	e000      	b.n	801680a <IsValidSP+0x22>
 8016808:	2300      	movs	r3, #0
}
 801680a:	4618      	mov	r0, r3
 801680c:	3714      	adds	r7, #20
 801680e:	46bd      	mov	sp, r7
 8016810:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016814:	4770      	bx	lr
	...

08016818 <FindSuitableStack>:

STATIC INLINE BOOL FindSuitableStack(UINTPTR *regSP, UINTPTR *start, UINTPTR *end)
{
 8016818:	b580      	push	{r7, lr}
 801681a:	b08a      	sub	sp, #40	; 0x28
 801681c:	af00      	add	r7, sp, #0
 801681e:	60f8      	str	r0, [r7, #12]
 8016820:	60b9      	str	r1, [r7, #8]
 8016822:	607a      	str	r2, [r7, #4]
    UINT32 index, topOfStack, stackBottom;
    BOOL found = FALSE;
 8016824:	2300      	movs	r3, #0
 8016826:	623b      	str	r3, [r7, #32]
    LosTaskCB *taskCB = NULL;
 8016828:	2300      	movs	r3, #0
 801682a:	627b      	str	r3, [r7, #36]	; 0x24

    /* Search in the task stacks */
    for (index = 0; index < g_taskMaxNum; index++) {
 801682c:	2300      	movs	r3, #0
 801682e:	617b      	str	r3, [r7, #20]
 8016830:	e028      	b.n	8016884 <FindSuitableStack+0x6c>
        taskCB = OS_TCB_FROM_TID(index);
 8016832:	4b27      	ldr	r3, [pc, #156]	; (80168d0 <FindSuitableStack+0xb8>)
 8016834:	6819      	ldr	r1, [r3, #0]
 8016836:	697a      	ldr	r2, [r7, #20]
 8016838:	4613      	mov	r3, r2
 801683a:	009b      	lsls	r3, r3, #2
 801683c:	4413      	add	r3, r2
 801683e:	015b      	lsls	r3, r3, #5
 8016840:	440b      	add	r3, r1
 8016842:	627b      	str	r3, [r7, #36]	; 0x24
        if (taskCB->taskStatus & OS_TASK_STATUS_UNUSED) {
 8016844:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016846:	889b      	ldrh	r3, [r3, #4]
 8016848:	f003 0301 	and.w	r3, r3, #1
 801684c:	2b00      	cmp	r3, #0
 801684e:	d115      	bne.n	801687c <FindSuitableStack+0x64>
            continue;
        }
        topOfStack = taskCB->topOfStack;
 8016850:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016852:	691b      	ldr	r3, [r3, #16]
 8016854:	61bb      	str	r3, [r7, #24]
        stackBottom = taskCB->topOfStack + taskCB->stackSize;
 8016856:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016858:	691a      	ldr	r2, [r3, #16]
 801685a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801685c:	68db      	ldr	r3, [r3, #12]
 801685e:	4413      	add	r3, r2
 8016860:	61fb      	str	r3, [r7, #28]

        if (IsValidSP(*regSP, topOfStack, stackBottom)) {
 8016862:	68fb      	ldr	r3, [r7, #12]
 8016864:	681b      	ldr	r3, [r3, #0]
 8016866:	69fa      	ldr	r2, [r7, #28]
 8016868:	69b9      	ldr	r1, [r7, #24]
 801686a:	4618      	mov	r0, r3
 801686c:	f7ff ffbc 	bl	80167e8 <IsValidSP>
 8016870:	4603      	mov	r3, r0
 8016872:	2b00      	cmp	r3, #0
 8016874:	d003      	beq.n	801687e <FindSuitableStack+0x66>
            found = TRUE;
 8016876:	2301      	movs	r3, #1
 8016878:	623b      	str	r3, [r7, #32]
            goto FOUND;
 801687a:	e009      	b.n	8016890 <FindSuitableStack+0x78>
            continue;
 801687c:	bf00      	nop
    for (index = 0; index < g_taskMaxNum; index++) {
 801687e:	697b      	ldr	r3, [r7, #20]
 8016880:	3301      	adds	r3, #1
 8016882:	617b      	str	r3, [r7, #20]
 8016884:	4b13      	ldr	r3, [pc, #76]	; (80168d4 <FindSuitableStack+0xbc>)
 8016886:	681b      	ldr	r3, [r3, #0]
 8016888:	697a      	ldr	r2, [r7, #20]
 801688a:	429a      	cmp	r2, r3
 801688c:	d3d1      	bcc.n	8016832 <FindSuitableStack+0x1a>
        }
    }

FOUND:
 801688e:	bf00      	nop
    if (found == TRUE) {
 8016890:	6a3b      	ldr	r3, [r7, #32]
 8016892:	2b01      	cmp	r3, #1
 8016894:	d106      	bne.n	80168a4 <FindSuitableStack+0x8c>
        *start = topOfStack;
 8016896:	68bb      	ldr	r3, [r7, #8]
 8016898:	69ba      	ldr	r2, [r7, #24]
 801689a:	601a      	str	r2, [r3, #0]
        *end = stackBottom;
 801689c:	687b      	ldr	r3, [r7, #4]
 801689e:	69fa      	ldr	r2, [r7, #28]
 80168a0:	601a      	str	r2, [r3, #0]
 80168a2:	e010      	b.n	80168c6 <FindSuitableStack+0xae>
    } else if (*regSP < g_estack) {
 80168a4:	68fb      	ldr	r3, [r7, #12]
 80168a6:	681b      	ldr	r3, [r3, #0]
 80168a8:	4a0b      	ldr	r2, [pc, #44]	; (80168d8 <FindSuitableStack+0xc0>)
 80168aa:	6812      	ldr	r2, [r2, #0]
 80168ac:	4293      	cmp	r3, r2
 80168ae:	d20a      	bcs.n	80168c6 <FindSuitableStack+0xae>
        *start = *regSP;
 80168b0:	68fb      	ldr	r3, [r7, #12]
 80168b2:	681a      	ldr	r2, [r3, #0]
 80168b4:	68bb      	ldr	r3, [r7, #8]
 80168b6:	601a      	str	r2, [r3, #0]
        *end = g_estack;
 80168b8:	4b07      	ldr	r3, [pc, #28]	; (80168d8 <FindSuitableStack+0xc0>)
 80168ba:	681b      	ldr	r3, [r3, #0]
 80168bc:	461a      	mov	r2, r3
 80168be:	687b      	ldr	r3, [r7, #4]
 80168c0:	601a      	str	r2, [r3, #0]
        found = TRUE;
 80168c2:	2301      	movs	r3, #1
 80168c4:	623b      	str	r3, [r7, #32]
    }

    return found;
 80168c6:	6a3b      	ldr	r3, [r7, #32]
}
 80168c8:	4618      	mov	r0, r3
 80168ca:	3728      	adds	r7, #40	; 0x28
 80168cc:	46bd      	mov	sp, r7
 80168ce:	bd80      	pop	{r7, pc}
 80168d0:	200036c4 	.word	0x200036c4
 80168d4:	200036d8 	.word	0x200036d8
 80168d8:	08023694 	.word	0x08023694

080168dc <LoopUntilEntry>:

UINTPTR LoopUntilEntry(UINTPTR addr)
{
 80168dc:	b480      	push	{r7}
 80168de:	b083      	sub	sp, #12
 80168e0:	af00      	add	r7, sp, #0
 80168e2:	6078      	str	r0, [r7, #4]
    while (addr > (UINTPTR)g_textStart) {
 80168e4:	e00e      	b.n	8016904 <LoopUntilEntry+0x28>
        if (((*((UINT16 *)addr) >> HIGH_8_OFFSET) == PUSH_MASK_WITH_LR) ||
 80168e6:	687b      	ldr	r3, [r7, #4]
 80168e8:	881b      	ldrh	r3, [r3, #0]
 80168ea:	0a1b      	lsrs	r3, r3, #8
 80168ec:	b29b      	uxth	r3, r3
 80168ee:	2bb5      	cmp	r3, #181	; 0xb5
 80168f0:	d00e      	beq.n	8016910 <LoopUntilEntry+0x34>
            ((*((UINT16 *)addr) >> HIGH_8_OFFSET) == PUSH_MASK)) {
 80168f2:	687b      	ldr	r3, [r7, #4]
 80168f4:	881b      	ldrh	r3, [r3, #0]
 80168f6:	0a1b      	lsrs	r3, r3, #8
 80168f8:	b29b      	uxth	r3, r3
        if (((*((UINT16 *)addr) >> HIGH_8_OFFSET) == PUSH_MASK_WITH_LR) ||
 80168fa:	2bb4      	cmp	r3, #180	; 0xb4
 80168fc:	d008      	beq.n	8016910 <LoopUntilEntry+0x34>
            break;
        }
        addr -= THUM_OFFSET;
 80168fe:	687b      	ldr	r3, [r7, #4]
 8016900:	3b02      	subs	r3, #2
 8016902:	607b      	str	r3, [r7, #4]
    while (addr > (UINTPTR)g_textStart) {
 8016904:	4b06      	ldr	r3, [pc, #24]	; (8016920 <LoopUntilEntry+0x44>)
 8016906:	681b      	ldr	r3, [r3, #0]
 8016908:	461a      	mov	r2, r3
 801690a:	687b      	ldr	r3, [r7, #4]
 801690c:	4293      	cmp	r3, r2
 801690e:	d8ea      	bhi.n	80168e6 <LoopUntilEntry+0xa>
    }

    return addr;
 8016910:	687b      	ldr	r3, [r7, #4]
}
 8016912:	4618      	mov	r0, r3
 8016914:	370c      	adds	r7, #12
 8016916:	46bd      	mov	sp, r7
 8016918:	f85d 7b04 	ldr.w	r7, [sp], #4
 801691c:	4770      	bx	lr
 801691e:	bf00      	nop
 8016920:	0802368c 	.word	0x0802368c

08016924 <CalculateBLTargetAddress>:

UINTPTR CalculateBLTargetAddress(UINTPTR bl)
{
 8016924:	b480      	push	{r7}
 8016926:	b087      	sub	sp, #28
 8016928:	af00      	add	r7, sp, #0
 801692a:	6078      	str	r0, [r7, #4]
    UINTPTR target;
    UINT32 off0, off1, off;

    if (*(UINT16 *)bl & SIGN_BIT_MASK) {
 801692c:	687b      	ldr	r3, [r7, #4]
 801692e:	881b      	ldrh	r3, [r3, #0]
 8016930:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8016934:	2b00      	cmp	r3, #0
 8016936:	d00b      	beq.n	8016950 <CalculateBLTargetAddress+0x2c>
        off1 = *(UINT16 *)bl & LOW_11_BITS_MASK;
 8016938:	687b      	ldr	r3, [r7, #4]
 801693a:	881b      	ldrh	r3, [r3, #0]
 801693c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8016940:	613b      	str	r3, [r7, #16]
        off0 = *(UINT16 *)(bl + MASK_OFFSET) & LOW_11_BITS_MASK;
 8016942:	687b      	ldr	r3, [r7, #4]
 8016944:	3302      	adds	r3, #2
 8016946:	881b      	ldrh	r3, [r3, #0]
 8016948:	f3c3 030a 	ubfx	r3, r3, #0, #11
 801694c:	60fb      	str	r3, [r7, #12]
 801694e:	e00a      	b.n	8016966 <CalculateBLTargetAddress+0x42>
    } else {
        off0 = *(UINT16 *)bl & LOW_11_BITS_MASK;
 8016950:	687b      	ldr	r3, [r7, #4]
 8016952:	881b      	ldrh	r3, [r3, #0]
 8016954:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8016958:	60fb      	str	r3, [r7, #12]
        off1 = *(UINT16 *)(bl + MASK_OFFSET) & LOW_11_BITS_MASK;
 801695a:	687b      	ldr	r3, [r7, #4]
 801695c:	3302      	adds	r3, #2
 801695e:	881b      	ldrh	r3, [r3, #0]
 8016960:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8016964:	613b      	str	r3, [r7, #16]
    }
    off = (off0 << HIGH_OFFSET_NUMBER) + (off1 << LOW_OFFSET_NUMBER);
 8016966:	68fb      	ldr	r3, [r7, #12]
 8016968:	031a      	lsls	r2, r3, #12
 801696a:	693b      	ldr	r3, [r7, #16]
 801696c:	005b      	lsls	r3, r3, #1
 801696e:	4413      	add	r3, r2
 8016970:	617b      	str	r3, [r7, #20]
    if (off & SIGN_BIT_MASK) {
 8016972:	697b      	ldr	r3, [r7, #20]
 8016974:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8016978:	2b00      	cmp	r3, #0
 801697a:	d008      	beq.n	801698e <CalculateBLTargetAddress+0x6a>
        target = bl + BL_CMD_OFFSET - ((~(off - 1)) & 0x7FFFFF); // 0x7FFFFF : offset mask
 801697c:	697b      	ldr	r3, [r7, #20]
 801697e:	425b      	negs	r3, r3
 8016980:	f3c3 0316 	ubfx	r3, r3, #0, #23
 8016984:	687a      	ldr	r2, [r7, #4]
 8016986:	1ad3      	subs	r3, r2, r3
 8016988:	3304      	adds	r3, #4
 801698a:	60bb      	str	r3, [r7, #8]
 801698c:	e004      	b.n	8016998 <CalculateBLTargetAddress+0x74>
    } else {
        target = bl + BL_CMD_OFFSET + off;
 801698e:	687a      	ldr	r2, [r7, #4]
 8016990:	697b      	ldr	r3, [r7, #20]
 8016992:	4413      	add	r3, r2
 8016994:	3304      	adds	r3, #4
 8016996:	60bb      	str	r3, [r7, #8]
    }

    return target;
 8016998:	68bb      	ldr	r3, [r7, #8]
}
 801699a:	4618      	mov	r0, r3
 801699c:	371c      	adds	r7, #28
 801699e:	46bd      	mov	sp, r7
 80169a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80169a4:	4770      	bx	lr
	...

080169a8 <CalculateTargetAddress>:

UINTPTR CalculateTargetAddress(UINTPTR bl)
{
 80169a8:	b580      	push	{r7, lr}
 80169aa:	b084      	sub	sp, #16
 80169ac:	af00      	add	r7, sp, #0
 80169ae:	6078      	str	r0, [r7, #4]
    UINTPTR target;
    STATIC UINTPTR tmpBL = 0;

    if ((((*(UINT16 *)(bl - BLX_CMD_OFFSET)) & HIGH_8_BITS_MASK) == BLX_INX)) {
 80169b0:	687b      	ldr	r3, [r7, #4]
 80169b2:	3b02      	subs	r3, #2
 80169b4:	881b      	ldrh	r3, [r3, #0]
 80169b6:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80169ba:	f5b3 4f8e 	cmp.w	r3, #18176	; 0x4700
 80169be:	d11a      	bne.n	80169f6 <CalculateTargetAddress+0x4e>
        if (tmpBL != 0) {
 80169c0:	4b19      	ldr	r3, [pc, #100]	; (8016a28 <CalculateTargetAddress+0x80>)
 80169c2:	681b      	ldr	r3, [r3, #0]
 80169c4:	2b00      	cmp	r3, #0
 80169c6:	d00b      	beq.n	80169e0 <CalculateTargetAddress+0x38>
            target = LoopUntilEntry(tmpBL);
 80169c8:	4b17      	ldr	r3, [pc, #92]	; (8016a28 <CalculateTargetAddress+0x80>)
 80169ca:	681b      	ldr	r3, [r3, #0]
 80169cc:	4618      	mov	r0, r3
 80169ce:	f7ff ff85 	bl	80168dc <LoopUntilEntry>
 80169d2:	60f8      	str	r0, [r7, #12]
            tmpBL = bl - BLX_CMD_OFFSET;
 80169d4:	687b      	ldr	r3, [r7, #4]
 80169d6:	3b02      	subs	r3, #2
 80169d8:	4a13      	ldr	r2, [pc, #76]	; (8016a28 <CalculateTargetAddress+0x80>)
 80169da:	6013      	str	r3, [r2, #0]
            return target;
 80169dc:	68fb      	ldr	r3, [r7, #12]
 80169de:	e01e      	b.n	8016a1e <CalculateTargetAddress+0x76>
        }
        tmpBL = bl - BLX_CMD_OFFSET;
 80169e0:	687b      	ldr	r3, [r7, #4]
 80169e2:	3b02      	subs	r3, #2
 80169e4:	4a10      	ldr	r2, [pc, #64]	; (8016a28 <CalculateTargetAddress+0x80>)
 80169e6:	6013      	str	r3, [r2, #0]
        return LoopUntilEntry(tmpBL);
 80169e8:	4b0f      	ldr	r3, [pc, #60]	; (8016a28 <CalculateTargetAddress+0x80>)
 80169ea:	681b      	ldr	r3, [r3, #0]
 80169ec:	4618      	mov	r0, r3
 80169ee:	f7ff ff75 	bl	80168dc <LoopUntilEntry>
 80169f2:	4603      	mov	r3, r0
 80169f4:	e013      	b.n	8016a1e <CalculateTargetAddress+0x76>
    } else if ((*(UINT32 *)(bl - BL_CMD_OFFSET) & BL_INS) == BL_INS) {
 80169f6:	687b      	ldr	r3, [r7, #4]
 80169f8:	3b04      	subs	r3, #4
 80169fa:	681b      	ldr	r3, [r3, #0]
 80169fc:	f003 23f0 	and.w	r3, r3, #4026593280	; 0xf000f000
 8016a00:	f1b3 2ff0 	cmp.w	r3, #4026593280	; 0xf000f000
 8016a04:	d10a      	bne.n	8016a1c <CalculateTargetAddress+0x74>
        tmpBL = bl - BL_CMD_OFFSET;
 8016a06:	687b      	ldr	r3, [r7, #4]
 8016a08:	3b04      	subs	r3, #4
 8016a0a:	4a07      	ldr	r2, [pc, #28]	; (8016a28 <CalculateTargetAddress+0x80>)
 8016a0c:	6013      	str	r3, [r2, #0]
        return CalculateBLTargetAddress(tmpBL);
 8016a0e:	4b06      	ldr	r3, [pc, #24]	; (8016a28 <CalculateTargetAddress+0x80>)
 8016a10:	681b      	ldr	r3, [r3, #0]
 8016a12:	4618      	mov	r0, r3
 8016a14:	f7ff ff86 	bl	8016924 <CalculateBLTargetAddress>
 8016a18:	4603      	mov	r3, r0
 8016a1a:	e000      	b.n	8016a1e <CalculateTargetAddress+0x76>
    }

    return 0;
 8016a1c:	2300      	movs	r3, #0
}
 8016a1e:	4618      	mov	r0, r3
 8016a20:	3710      	adds	r7, #16
 8016a22:	46bd      	mov	sp, r7
 8016a24:	bd80      	pop	{r7, pc}
 8016a26:	bf00      	nop
 8016a28:	200033d8 	.word	0x200033d8

08016a2c <BackTraceSub>:

VOID BackTraceSub(UINTPTR sp)
{
 8016a2c:	b580      	push	{r7, lr}
 8016a2e:	b088      	sub	sp, #32
 8016a30:	af00      	add	r7, sp, #0
 8016a32:	6078      	str	r0, [r7, #4]
 8016a34:	4b32      	ldr	r3, [pc, #200]	; (8016b00 <BackTraceSub+0xd4>)
 8016a36:	681b      	ldr	r3, [r3, #0]
 8016a38:	61fb      	str	r3, [r7, #28]
 8016a3a:	f04f 0300 	mov.w	r3, #0
    UINTPTR stackPointer = sp;
 8016a3e:	687b      	ldr	r3, [r7, #4]
 8016a40:	60bb      	str	r3, [r7, #8]
    UINT32 count = 0;
 8016a42:	2300      	movs	r3, #0
 8016a44:	617b      	str	r3, [r7, #20]
    UINTPTR topOfStack = 0;
 8016a46:	2300      	movs	r3, #0
 8016a48:	60fb      	str	r3, [r7, #12]
    UINTPTR stackBottom = 0;
 8016a4a:	2300      	movs	r3, #0
 8016a4c:	613b      	str	r3, [r7, #16]
    STATIC UINTPTR tmpJump = 0;

    if (FindSuitableStack(&stackPointer, &topOfStack, &stackBottom) == FALSE) {
 8016a4e:	f107 0210 	add.w	r2, r7, #16
 8016a52:	f107 010c 	add.w	r1, r7, #12
 8016a56:	f107 0308 	add.w	r3, r7, #8
 8016a5a:	4618      	mov	r0, r3
 8016a5c:	f7ff fedc 	bl	8016818 <FindSuitableStack>
 8016a60:	4603      	mov	r3, r0
 8016a62:	2b00      	cmp	r3, #0
 8016a64:	d040      	beq.n	8016ae8 <BackTraceSub+0xbc>
        return;
    }

    while ((stackPointer < stackBottom) && (count < OS_MAX_BACKTRACE)) {
 8016a66:	e037      	b.n	8016ad8 <BackTraceSub+0xac>
        if ((*(UINT32 *)stackPointer >= (UINT32)g_textStart) &&
 8016a68:	68bb      	ldr	r3, [r7, #8]
 8016a6a:	681b      	ldr	r3, [r3, #0]
 8016a6c:	4a25      	ldr	r2, [pc, #148]	; (8016b04 <BackTraceSub+0xd8>)
 8016a6e:	6812      	ldr	r2, [r2, #0]
 8016a70:	4293      	cmp	r3, r2
 8016a72:	d32e      	bcc.n	8016ad2 <BackTraceSub+0xa6>
            (*(UINT32 *)stackPointer <= (UINT32)g_textEnd) &&
 8016a74:	68bb      	ldr	r3, [r7, #8]
 8016a76:	681b      	ldr	r3, [r3, #0]
 8016a78:	4a23      	ldr	r2, [pc, #140]	; (8016b08 <BackTraceSub+0xdc>)
 8016a7a:	6812      	ldr	r2, [r2, #0]
        if ((*(UINT32 *)stackPointer >= (UINT32)g_textStart) &&
 8016a7c:	4293      	cmp	r3, r2
 8016a7e:	d828      	bhi.n	8016ad2 <BackTraceSub+0xa6>
            /**
             * 2022-04-11 tanzhongqiang 堆栈中保存的LR 值，一定是奇数。应该是thumb 指令都是16bit 。
             * 如何判断堆栈中保存是LR 还是函数地址？ 通过判断LR 值 对应上一条指令是否BL,BX 。
             * */
            IS_ALIGNED(*(UINT32 *)stackPointer - 1, THUM_OFFSET)) {
 8016a80:	68bb      	ldr	r3, [r7, #8]
 8016a82:	681b      	ldr	r3, [r3, #0]
 8016a84:	3b01      	subs	r3, #1
 8016a86:	f003 0301 	and.w	r3, r3, #1
            (*(UINT32 *)stackPointer <= (UINT32)g_textEnd) &&
 8016a8a:	2b00      	cmp	r3, #0
 8016a8c:	d121      	bne.n	8016ad2 <BackTraceSub+0xa6>
            /* Get the entry address of current function. */
            UINTPTR checkBL = CalculateTargetAddress(*(UINT32 *)stackPointer - 1);
 8016a8e:	68bb      	ldr	r3, [r7, #8]
 8016a90:	681b      	ldr	r3, [r3, #0]
 8016a92:	3b01      	subs	r3, #1
 8016a94:	4618      	mov	r0, r3
 8016a96:	f7ff ff87 	bl	80169a8 <CalculateTargetAddress>
 8016a9a:	61b8      	str	r0, [r7, #24]
            if ((checkBL == 0) || (checkBL == tmpJump)) {
 8016a9c:	69bb      	ldr	r3, [r7, #24]
 8016a9e:	2b00      	cmp	r3, #0
 8016aa0:	d004      	beq.n	8016aac <BackTraceSub+0x80>
 8016aa2:	4b1a      	ldr	r3, [pc, #104]	; (8016b0c <BackTraceSub+0xe0>)
 8016aa4:	681b      	ldr	r3, [r3, #0]
 8016aa6:	69ba      	ldr	r2, [r7, #24]
 8016aa8:	429a      	cmp	r2, r3
 8016aaa:	d103      	bne.n	8016ab4 <BackTraceSub+0x88>
                stackPointer += STACK_OFFSET;
 8016aac:	68bb      	ldr	r3, [r7, #8]
 8016aae:	3304      	adds	r3, #4
 8016ab0:	60bb      	str	r3, [r7, #8]
                continue;
 8016ab2:	e011      	b.n	8016ad8 <BackTraceSub+0xac>
            }
            tmpJump = checkBL;
 8016ab4:	4a15      	ldr	r2, [pc, #84]	; (8016b0c <BackTraceSub+0xe0>)
 8016ab6:	69bb      	ldr	r3, [r7, #24]
 8016ab8:	6013      	str	r3, [r2, #0]
            count++;
 8016aba:	697b      	ldr	r3, [r7, #20]
 8016abc:	3301      	adds	r3, #1
 8016abe:	617b      	str	r3, [r7, #20]
            PrintExcInfo("traceback %u -- lr = 0x%08x -- fp = 0x%08x\n", count, *(UINT32 *)stackPointer - 1, tmpJump);
 8016ac0:	68bb      	ldr	r3, [r7, #8]
 8016ac2:	681b      	ldr	r3, [r3, #0]
 8016ac4:	1e5a      	subs	r2, r3, #1
 8016ac6:	4b11      	ldr	r3, [pc, #68]	; (8016b0c <BackTraceSub+0xe0>)
 8016ac8:	681b      	ldr	r3, [r3, #0]
 8016aca:	6979      	ldr	r1, [r7, #20]
 8016acc:	4810      	ldr	r0, [pc, #64]	; (8016b10 <BackTraceSub+0xe4>)
 8016ace:	f7ed ff1b 	bl	8004908 <PrintExcInfo>
        }
        stackPointer += STACK_OFFSET;
 8016ad2:	68bb      	ldr	r3, [r7, #8]
 8016ad4:	3304      	adds	r3, #4
 8016ad6:	60bb      	str	r3, [r7, #8]
    while ((stackPointer < stackBottom) && (count < OS_MAX_BACKTRACE)) {
 8016ad8:	68ba      	ldr	r2, [r7, #8]
 8016ada:	693b      	ldr	r3, [r7, #16]
 8016adc:	429a      	cmp	r2, r3
 8016ade:	d204      	bcs.n	8016aea <BackTraceSub+0xbe>
 8016ae0:	697b      	ldr	r3, [r7, #20]
 8016ae2:	2b0e      	cmp	r3, #14
 8016ae4:	d9c0      	bls.n	8016a68 <BackTraceSub+0x3c>
 8016ae6:	e000      	b.n	8016aea <BackTraceSub+0xbe>
        return;
 8016ae8:	bf00      	nop
    }
}
 8016aea:	4b05      	ldr	r3, [pc, #20]	; (8016b00 <BackTraceSub+0xd4>)
 8016aec:	681a      	ldr	r2, [r3, #0]
 8016aee:	69fb      	ldr	r3, [r7, #28]
 8016af0:	405a      	eors	r2, r3
 8016af2:	d001      	beq.n	8016af8 <BackTraceSub+0xcc>
 8016af4:	f7ed fd72 	bl	80045dc <__stack_chk_fail>
 8016af8:	3720      	adds	r7, #32
 8016afa:	46bd      	mov	sp, r7
 8016afc:	bd80      	pop	{r7, pc}
 8016afe:	bf00      	nop
 8016b00:	08023058 	.word	0x08023058
 8016b04:	0802368c 	.word	0x0802368c
 8016b08:	08023690 	.word	0x08023690
 8016b0c:	200033dc 	.word	0x200033dc
 8016b10:	0802302c 	.word	0x0802302c

08016b14 <BackTraceWithSp>:

STATIC VOID BackTraceWithSp(UINTPTR sp)
{
 8016b14:	b580      	push	{r7, lr}
 8016b16:	b082      	sub	sp, #8
 8016b18:	af00      	add	r7, sp, #0
 8016b1a:	6078      	str	r0, [r7, #4]
    PrintExcInfo("*******backtrace begin*******\n");
 8016b1c:	4806      	ldr	r0, [pc, #24]	; (8016b38 <BackTraceWithSp+0x24>)
 8016b1e:	f7ed fef3 	bl	8004908 <PrintExcInfo>
    BackTraceSub(sp);
 8016b22:	6878      	ldr	r0, [r7, #4]
 8016b24:	f7ff ff82 	bl	8016a2c <BackTraceSub>
    PrintExcInfo("*******backtrace end*******\n");
 8016b28:	4804      	ldr	r0, [pc, #16]	; (8016b3c <BackTraceWithSp+0x28>)
 8016b2a:	f7ed feed 	bl	8004908 <PrintExcInfo>
}
 8016b2e:	bf00      	nop
 8016b30:	3708      	adds	r7, #8
 8016b32:	46bd      	mov	sp, r7
 8016b34:	bd80      	pop	{r7, pc}
 8016b36:	bf00      	nop
 8016b38:	0802305c 	.word	0x0802305c
 8016b3c:	0802307c 	.word	0x0802307c

08016b40 <ArchBackTrace>:
#endif

VOID ArchBackTrace(VOID)
{
 8016b40:	b580      	push	{r7, lr}
 8016b42:	b082      	sub	sp, #8
 8016b44:	af00      	add	r7, sp, #0
#ifdef LOSCFG_BACKTRACE
    UINTPTR sp = ArchGetSp();
 8016b46:	f7ff fd1c 	bl	8016582 <ArchGetSp>
 8016b4a:	6078      	str	r0, [r7, #4]
    PrintExcInfo("sp:0x%08x\n", sp);
 8016b4c:	6879      	ldr	r1, [r7, #4]
 8016b4e:	4805      	ldr	r0, [pc, #20]	; (8016b64 <ArchBackTrace+0x24>)
 8016b50:	f7ed feda 	bl	8004908 <PrintExcInfo>
    BackTraceWithSp(sp);
 8016b54:	6878      	ldr	r0, [r7, #4]
 8016b56:	f7ff ffdd 	bl	8016b14 <BackTraceWithSp>
#endif
}
 8016b5a:	bf00      	nop
 8016b5c:	3708      	adds	r7, #8
 8016b5e:	46bd      	mov	sp, r7
 8016b60:	bd80      	pop	{r7, pc}
 8016b62:	bf00      	nop
 8016b64:	0802309c 	.word	0x0802309c

08016b68 <ArchBackTraceWithSp>:

VOID ArchBackTraceWithSp(const VOID *stackPointer)
{
 8016b68:	b580      	push	{r7, lr}
 8016b6a:	b082      	sub	sp, #8
 8016b6c:	af00      	add	r7, sp, #0
 8016b6e:	6078      	str	r0, [r7, #4]
#ifdef LOSCFG_BACKTRACE
    BackTraceWithSp((UINTPTR)stackPointer);
 8016b70:	687b      	ldr	r3, [r7, #4]
 8016b72:	4618      	mov	r0, r3
 8016b74:	f7ff ffce 	bl	8016b14 <BackTraceWithSp>
#else
    (VOID)stackPointer;
#endif
}
 8016b78:	bf00      	nop
 8016b7a:	3708      	adds	r7, #8
 8016b7c:	46bd      	mov	sp, r7
 8016b7e:	bd80      	pop	{r7, pc}

08016b80 <ArchExcInit>:

LITE_OS_SEC_TEXT_INIT VOID ArchExcInit(VOID)
{
 8016b80:	b480      	push	{r7}
 8016b82:	af00      	add	r7, sp, #0
#ifndef LOSCFG_ARCH_CORTEX_M0
#ifndef LOSCFG_ARCH_CORTEX_M0_PLUS
    g_hwiVec[HARD_FAULT_IRQN + OS_SYS_VECTOR_CNT] = OsExcHardFault;
 8016b84:	4b11      	ldr	r3, [pc, #68]	; (8016bcc <ArchExcInit+0x4c>)
 8016b86:	4a12      	ldr	r2, [pc, #72]	; (8016bd0 <ArchExcInit+0x50>)
 8016b88:	60da      	str	r2, [r3, #12]
    g_hwiVec[NonMaskableInt_IRQn + OS_SYS_VECTOR_CNT] = OsExcNMI;
 8016b8a:	4b10      	ldr	r3, [pc, #64]	; (8016bcc <ArchExcInit+0x4c>)
 8016b8c:	4a11      	ldr	r2, [pc, #68]	; (8016bd4 <ArchExcInit+0x54>)
 8016b8e:	609a      	str	r2, [r3, #8]
    g_hwiVec[MemoryManagement_IRQn + OS_SYS_VECTOR_CNT] = OsExcMemFault;
 8016b90:	4b0e      	ldr	r3, [pc, #56]	; (8016bcc <ArchExcInit+0x4c>)
 8016b92:	4a11      	ldr	r2, [pc, #68]	; (8016bd8 <ArchExcInit+0x58>)
 8016b94:	611a      	str	r2, [r3, #16]
    g_hwiVec[BusFault_IRQn + OS_SYS_VECTOR_CNT] = OsExcBusFault;
 8016b96:	4b0d      	ldr	r3, [pc, #52]	; (8016bcc <ArchExcInit+0x4c>)
 8016b98:	4a10      	ldr	r2, [pc, #64]	; (8016bdc <ArchExcInit+0x5c>)
 8016b9a:	615a      	str	r2, [r3, #20]
    g_hwiVec[UsageFault_IRQn + OS_SYS_VECTOR_CNT] = OsExcUsageFault;
 8016b9c:	4b0b      	ldr	r3, [pc, #44]	; (8016bcc <ArchExcInit+0x4c>)
 8016b9e:	4a10      	ldr	r2, [pc, #64]	; (8016be0 <ArchExcInit+0x60>)
 8016ba0:	619a      	str	r2, [r3, #24]
    g_hwiVec[SVCall_IRQn + OS_SYS_VECTOR_CNT] = OsExcSvcCall;
 8016ba2:	4b0a      	ldr	r3, [pc, #40]	; (8016bcc <ArchExcInit+0x4c>)
 8016ba4:	4a0f      	ldr	r2, [pc, #60]	; (8016be4 <ArchExcInit+0x64>)
 8016ba6:	62da      	str	r2, [r3, #44]	; 0x2c
    g_hwiVec[SVC_IRQn + OS_SYS_VECTOR_CNT] = OsExcSvcCall;
    g_hwiVec[NonMaskableInt_IRQn + OS_SYS_VECTOR_CNT] = OsExcNMI;
#endif
#endif
    /* Enable USGFAULT, BUSFAULT, MEMFAULT */
    *(volatile UINT32 *)OS_NVIC_SHCSR |= (USGFAULT | BUSFAULT | MEMFAULT);
 8016ba8:	4b0f      	ldr	r3, [pc, #60]	; (8016be8 <ArchExcInit+0x68>)
 8016baa:	681b      	ldr	r3, [r3, #0]
 8016bac:	4a0e      	ldr	r2, [pc, #56]	; (8016be8 <ArchExcInit+0x68>)
 8016bae:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
 8016bb2:	6013      	str	r3, [r2, #0]
    /* Enable DIV 0 and unaligned exception */
    *(volatile UINT32 *)OS_NVIC_CCR |= DIV0FAULT;
 8016bb4:	4b0d      	ldr	r3, [pc, #52]	; (8016bec <ArchExcInit+0x6c>)
 8016bb6:	681b      	ldr	r3, [r3, #0]
 8016bb8:	4a0c      	ldr	r2, [pc, #48]	; (8016bec <ArchExcInit+0x6c>)
 8016bba:	f043 0310 	orr.w	r3, r3, #16
 8016bbe:	6013      	str	r3, [r2, #0]
}
 8016bc0:	bf00      	nop
 8016bc2:	46bd      	mov	sp, r7
 8016bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016bc8:	4770      	bx	lr
 8016bca:	bf00      	nop
 8016bcc:	20000000 	.word	0x20000000
 8016bd0:	08000d4f 	.word	0x08000d4f
 8016bd4:	08000d45 	.word	0x08000d45
 8016bd8:	08000df9 	.word	0x08000df9
 8016bdc:	08000ddb 	.word	0x08000ddb
 8016be0:	08000e17 	.word	0x08000e17
 8016be4:	08000dc1 	.word	0x08000dc1
 8016be8:	e000ed24 	.word	0xe000ed24
 8016bec:	e000ed14 	.word	0xe000ed14

08016bf0 <vsnprintf_s>:
 *    return -1 if count < destMax and the output string  has been truncated
 *
 * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
 */
int vsnprintf_s(char *strDest, size_t destMax, size_t count, const char *format, va_list argList)
{
 8016bf0:	b580      	push	{r7, lr}
 8016bf2:	b086      	sub	sp, #24
 8016bf4:	af00      	add	r7, sp, #0
 8016bf6:	60f8      	str	r0, [r7, #12]
 8016bf8:	60b9      	str	r1, [r7, #8]
 8016bfa:	607a      	str	r2, [r7, #4]
 8016bfc:	603b      	str	r3, [r7, #0]
    int retVal;

    if (SECUREC_VSNPRINTF_PARAM_ERROR(format, strDest, destMax, count, SECUREC_STRING_MAX_LEN)) {
 8016bfe:	683b      	ldr	r3, [r7, #0]
 8016c00:	2b00      	cmp	r3, #0
 8016c02:	d00d      	beq.n	8016c20 <vsnprintf_s+0x30>
 8016c04:	68fb      	ldr	r3, [r7, #12]
 8016c06:	2b00      	cmp	r3, #0
 8016c08:	d00a      	beq.n	8016c20 <vsnprintf_s+0x30>
 8016c0a:	68bb      	ldr	r3, [r7, #8]
 8016c0c:	2b00      	cmp	r3, #0
 8016c0e:	d007      	beq.n	8016c20 <vsnprintf_s+0x30>
 8016c10:	68bb      	ldr	r3, [r7, #8]
 8016c12:	2b00      	cmp	r3, #0
 8016c14:	db04      	blt.n	8016c20 <vsnprintf_s+0x30>
 8016c16:	687b      	ldr	r3, [r7, #4]
 8016c18:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 8016c1c:	4293      	cmp	r3, r2
 8016c1e:	d30e      	bcc.n	8016c3e <vsnprintf_s+0x4e>
        SECUREC_VSPRINTF_CLEAR_DEST(strDest, destMax, SECUREC_STRING_MAX_LEN);
 8016c20:	68fb      	ldr	r3, [r7, #12]
 8016c22:	2b00      	cmp	r3, #0
 8016c24:	d008      	beq.n	8016c38 <vsnprintf_s+0x48>
 8016c26:	68bb      	ldr	r3, [r7, #8]
 8016c28:	2b00      	cmp	r3, #0
 8016c2a:	d005      	beq.n	8016c38 <vsnprintf_s+0x48>
 8016c2c:	68bb      	ldr	r3, [r7, #8]
 8016c2e:	2b00      	cmp	r3, #0
 8016c30:	db02      	blt.n	8016c38 <vsnprintf_s+0x48>
 8016c32:	68fb      	ldr	r3, [r7, #12]
 8016c34:	2200      	movs	r2, #0
 8016c36:	701a      	strb	r2, [r3, #0]
        SECUREC_ERROR_INVALID_PARAMTER("vsnprintf_s");
        return -1;
 8016c38:	f04f 33ff 	mov.w	r3, #4294967295
 8016c3c:	e023      	b.n	8016c86 <vsnprintf_s+0x96>
    }

    if (destMax > count) {
 8016c3e:	68ba      	ldr	r2, [r7, #8]
 8016c40:	687b      	ldr	r3, [r7, #4]
 8016c42:	429a      	cmp	r2, r3
 8016c44:	d90e      	bls.n	8016c64 <vsnprintf_s+0x74>
        retVal = SecVsnprintfImpl(strDest, count + 1, format, argList);
 8016c46:	687b      	ldr	r3, [r7, #4]
 8016c48:	1c59      	adds	r1, r3, #1
 8016c4a:	6a3b      	ldr	r3, [r7, #32]
 8016c4c:	683a      	ldr	r2, [r7, #0]
 8016c4e:	68f8      	ldr	r0, [r7, #12]
 8016c50:	f002 fa10 	bl	8019074 <SecVsnprintfImpl>
 8016c54:	6178      	str	r0, [r7, #20]
        if (retVal == SECUREC_PRINTF_TRUNCATE) {  /* To keep dest buffer not destroyed 2014.2.18 */
 8016c56:	697b      	ldr	r3, [r7, #20]
 8016c58:	f113 0f02 	cmn.w	r3, #2
 8016c5c:	d109      	bne.n	8016c72 <vsnprintf_s+0x82>
            /* The string has been truncated, return  -1 */
            return -1;          /* To skip error handler,  return strlen(strDest) or -1 */
 8016c5e:	f04f 33ff 	mov.w	r3, #4294967295
 8016c62:	e010      	b.n	8016c86 <vsnprintf_s+0x96>
        }
    } else {
        retVal = SecVsnprintfImpl(strDest, destMax, format, argList);
 8016c64:	6a3b      	ldr	r3, [r7, #32]
 8016c66:	683a      	ldr	r2, [r7, #0]
 8016c68:	68b9      	ldr	r1, [r7, #8]
 8016c6a:	68f8      	ldr	r0, [r7, #12]
 8016c6c:	f002 fa02 	bl	8019074 <SecVsnprintfImpl>
 8016c70:	6178      	str	r0, [r7, #20]
            return -1;
        }
#endif
    }

    if (retVal < 0) {
 8016c72:	697b      	ldr	r3, [r7, #20]
 8016c74:	2b00      	cmp	r3, #0
 8016c76:	da05      	bge.n	8016c84 <vsnprintf_s+0x94>
        strDest[0] = '\0';      /* Empty the dest strDest */
 8016c78:	68fb      	ldr	r3, [r7, #12]
 8016c7a:	2200      	movs	r2, #0
 8016c7c:	701a      	strb	r2, [r3, #0]
        if (retVal == SECUREC_PRINTF_TRUNCATE) {
            /* Buffer too small */
            SECUREC_ERROR_INVALID_RANGE("vsnprintf_s");
        }
        SECUREC_ERROR_INVALID_PARAMTER("vsnprintf_s");
        return -1;
 8016c7e:	f04f 33ff 	mov.w	r3, #4294967295
 8016c82:	e000      	b.n	8016c86 <vsnprintf_s+0x96>
    }

    return retVal;
 8016c84:	697b      	ldr	r3, [r7, #20]
}
 8016c86:	4618      	mov	r0, r3
 8016c88:	3718      	adds	r7, #24
 8016c8a:	46bd      	mov	sp, r7
 8016c8c:	bd80      	pop	{r7, pc}

08016c8e <CheckSrcCountRange>:

/*
 * Check Src Count Range
 */
SECUREC_INLINE errno_t CheckSrcCountRange(char *strDest, size_t destMax, const char *strSrc, size_t count)
{
 8016c8e:	b480      	push	{r7}
 8016c90:	b089      	sub	sp, #36	; 0x24
 8016c92:	af00      	add	r7, sp, #0
 8016c94:	60f8      	str	r0, [r7, #12]
 8016c96:	60b9      	str	r1, [r7, #8]
 8016c98:	607a      	str	r2, [r7, #4]
 8016c9a:	603b      	str	r3, [r7, #0]
    size_t tmpDestMax = destMax;
 8016c9c:	68bb      	ldr	r3, [r7, #8]
 8016c9e:	617b      	str	r3, [r7, #20]
    size_t tmpCount = count;
 8016ca0:	683b      	ldr	r3, [r7, #0]
 8016ca2:	61bb      	str	r3, [r7, #24]
    const char *endPos = strSrc;
 8016ca4:	687b      	ldr	r3, [r7, #4]
 8016ca6:	61fb      	str	r3, [r7, #28]

    /* Use destMax and  count as boundary checker and destMax must be greater than zero */
    while (*(endPos) != '\0' && tmpDestMax > 0 && tmpCount > 0) {
 8016ca8:	e008      	b.n	8016cbc <CheckSrcCountRange+0x2e>
        ++endPos;
 8016caa:	69fb      	ldr	r3, [r7, #28]
 8016cac:	3301      	adds	r3, #1
 8016cae:	61fb      	str	r3, [r7, #28]
        --tmpCount;
 8016cb0:	69bb      	ldr	r3, [r7, #24]
 8016cb2:	3b01      	subs	r3, #1
 8016cb4:	61bb      	str	r3, [r7, #24]
        --tmpDestMax;
 8016cb6:	697b      	ldr	r3, [r7, #20]
 8016cb8:	3b01      	subs	r3, #1
 8016cba:	617b      	str	r3, [r7, #20]
    while (*(endPos) != '\0' && tmpDestMax > 0 && tmpCount > 0) {
 8016cbc:	69fb      	ldr	r3, [r7, #28]
 8016cbe:	781b      	ldrb	r3, [r3, #0]
 8016cc0:	2b00      	cmp	r3, #0
 8016cc2:	d005      	beq.n	8016cd0 <CheckSrcCountRange+0x42>
 8016cc4:	697b      	ldr	r3, [r7, #20]
 8016cc6:	2b00      	cmp	r3, #0
 8016cc8:	d002      	beq.n	8016cd0 <CheckSrcCountRange+0x42>
 8016cca:	69bb      	ldr	r3, [r7, #24]
 8016ccc:	2b00      	cmp	r3, #0
 8016cce:	d1ec      	bne.n	8016caa <CheckSrcCountRange+0x1c>
    }
    if (tmpDestMax == 0) {
 8016cd0:	697b      	ldr	r3, [r7, #20]
 8016cd2:	2b00      	cmp	r3, #0
 8016cd4:	d104      	bne.n	8016ce0 <CheckSrcCountRange+0x52>
        strDest[0] = '\0';
 8016cd6:	68fb      	ldr	r3, [r7, #12]
 8016cd8:	2200      	movs	r2, #0
 8016cda:	701a      	strb	r2, [r3, #0]
        SECUREC_ERROR_INVALID_RANGE("strncpy_s");
        return ERANGE_AND_RESET;
 8016cdc:	23a2      	movs	r3, #162	; 0xa2
 8016cde:	e000      	b.n	8016ce2 <CheckSrcCountRange+0x54>
    }
    return EOK;
 8016ce0:	2300      	movs	r3, #0
}
 8016ce2:	4618      	mov	r0, r3
 8016ce4:	3724      	adds	r7, #36	; 0x24
 8016ce6:	46bd      	mov	sp, r7
 8016ce8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016cec:	4770      	bx	lr

08016cee <strncpy_error>:

/*
 * Handling errors, when dest equal src return EOK
 */
errno_t strncpy_error(char *strDest, size_t destMax, const char *strSrc, size_t count)
{
 8016cee:	b580      	push	{r7, lr}
 8016cf0:	b084      	sub	sp, #16
 8016cf2:	af00      	add	r7, sp, #0
 8016cf4:	60f8      	str	r0, [r7, #12]
 8016cf6:	60b9      	str	r1, [r7, #8]
 8016cf8:	607a      	str	r2, [r7, #4]
 8016cfa:	603b      	str	r3, [r7, #0]
    if (destMax == 0 || destMax > SECUREC_STRING_MAX_LEN) {
 8016cfc:	68bb      	ldr	r3, [r7, #8]
 8016cfe:	2b00      	cmp	r3, #0
 8016d00:	d002      	beq.n	8016d08 <strncpy_error+0x1a>
 8016d02:	68bb      	ldr	r3, [r7, #8]
 8016d04:	2b00      	cmp	r3, #0
 8016d06:	da01      	bge.n	8016d0c <strncpy_error+0x1e>
        SECUREC_ERROR_INVALID_RANGE("strncpy_s");
        return ERANGE;
 8016d08:	2322      	movs	r3, #34	; 0x22
 8016d0a:	e026      	b.n	8016d5a <strncpy_error+0x6c>
    }
    if (strDest == NULL || strSrc == NULL) {
 8016d0c:	68fb      	ldr	r3, [r7, #12]
 8016d0e:	2b00      	cmp	r3, #0
 8016d10:	d002      	beq.n	8016d18 <strncpy_error+0x2a>
 8016d12:	687b      	ldr	r3, [r7, #4]
 8016d14:	2b00      	cmp	r3, #0
 8016d16:	d109      	bne.n	8016d2c <strncpy_error+0x3e>
        SECUREC_ERROR_INVALID_PARAMTER("strncpy_s");
        if (strDest != NULL) {
 8016d18:	68fb      	ldr	r3, [r7, #12]
 8016d1a:	2b00      	cmp	r3, #0
 8016d1c:	d004      	beq.n	8016d28 <strncpy_error+0x3a>
            strDest[0] = '\0';
 8016d1e:	68fb      	ldr	r3, [r7, #12]
 8016d20:	2200      	movs	r2, #0
 8016d22:	701a      	strb	r2, [r3, #0]
            return EINVAL_AND_RESET;
 8016d24:	2396      	movs	r3, #150	; 0x96
 8016d26:	e018      	b.n	8016d5a <strncpy_error+0x6c>
        }
        return EINVAL;
 8016d28:	2316      	movs	r3, #22
 8016d2a:	e016      	b.n	8016d5a <strncpy_error+0x6c>
    }
    if (count > SECUREC_STRING_MAX_LEN) {
 8016d2c:	683b      	ldr	r3, [r7, #0]
 8016d2e:	2b00      	cmp	r3, #0
 8016d30:	da04      	bge.n	8016d3c <strncpy_error+0x4e>
        strDest[0] = '\0';      /* Clear dest string */
 8016d32:	68fb      	ldr	r3, [r7, #12]
 8016d34:	2200      	movs	r2, #0
 8016d36:	701a      	strb	r2, [r3, #0]
        SECUREC_ERROR_INVALID_RANGE("strncpy_s");
        return ERANGE_AND_RESET;
 8016d38:	23a2      	movs	r3, #162	; 0xa2
 8016d3a:	e00e      	b.n	8016d5a <strncpy_error+0x6c>
    }
    if (count == 0) {
 8016d3c:	683b      	ldr	r3, [r7, #0]
 8016d3e:	2b00      	cmp	r3, #0
 8016d40:	d104      	bne.n	8016d4c <strncpy_error+0x5e>
        strDest[0] = '\0';
 8016d42:	68fb      	ldr	r3, [r7, #12]
 8016d44:	2200      	movs	r2, #0
 8016d46:	701a      	strb	r2, [r3, #0]
        return EOK;
 8016d48:	2300      	movs	r3, #0
 8016d4a:	e006      	b.n	8016d5a <strncpy_error+0x6c>
    }
    return CheckSrcCountRange(strDest, destMax, strSrc, count);
 8016d4c:	683b      	ldr	r3, [r7, #0]
 8016d4e:	687a      	ldr	r2, [r7, #4]
 8016d50:	68b9      	ldr	r1, [r7, #8]
 8016d52:	68f8      	ldr	r0, [r7, #12]
 8016d54:	f7ff ff9b 	bl	8016c8e <CheckSrcCountRange>
 8016d58:	4603      	mov	r3, r0
}
 8016d5a:	4618      	mov	r0, r3
 8016d5c:	3710      	adds	r7, #16
 8016d5e:	46bd      	mov	sp, r7
 8016d60:	bd80      	pop	{r7, pc}
	...

08016d64 <strncpy_s>:
 *    EOVERLAP_AND_RESET   dest buffer and source buffer are overlapped and all  parameters are valid
 *
 *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
 */
errno_t strncpy_s(char *strDest, size_t destMax, const char *strSrc, size_t count)
{
 8016d64:	b580      	push	{r7, lr}
 8016d66:	b08c      	sub	sp, #48	; 0x30
 8016d68:	af00      	add	r7, sp, #0
 8016d6a:	60f8      	str	r0, [r7, #12]
 8016d6c:	60b9      	str	r1, [r7, #8]
 8016d6e:	607a      	str	r2, [r7, #4]
 8016d70:	603b      	str	r3, [r7, #0]
 8016d72:	4b47      	ldr	r3, [pc, #284]	; (8016e90 <strncpy_s+0x12c>)
 8016d74:	681b      	ldr	r3, [r3, #0]
 8016d76:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016d78:	f04f 0300 	mov.w	r3, #0
    if (SECUREC_STRNCPY_PARAM_OK(strDest, destMax, strSrc, count)) {
 8016d7c:	68bb      	ldr	r3, [r7, #8]
 8016d7e:	2b00      	cmp	r3, #0
 8016d80:	d074      	beq.n	8016e6c <strncpy_s+0x108>
 8016d82:	68bb      	ldr	r3, [r7, #8]
 8016d84:	2b00      	cmp	r3, #0
 8016d86:	db71      	blt.n	8016e6c <strncpy_s+0x108>
 8016d88:	68fb      	ldr	r3, [r7, #12]
 8016d8a:	2b00      	cmp	r3, #0
 8016d8c:	d06e      	beq.n	8016e6c <strncpy_s+0x108>
 8016d8e:	687b      	ldr	r3, [r7, #4]
 8016d90:	2b00      	cmp	r3, #0
 8016d92:	d06b      	beq.n	8016e6c <strncpy_s+0x108>
 8016d94:	683b      	ldr	r3, [r7, #0]
 8016d96:	2b00      	cmp	r3, #0
 8016d98:	db68      	blt.n	8016e6c <strncpy_s+0x108>
 8016d9a:	683b      	ldr	r3, [r7, #0]
 8016d9c:	2b00      	cmp	r3, #0
 8016d9e:	d065      	beq.n	8016e6c <strncpy_s+0x108>
        size_t minCpLen;        /* Use it to store the maxi length limit */
        if (count < destMax) {
 8016da0:	683a      	ldr	r2, [r7, #0]
 8016da2:	68bb      	ldr	r3, [r7, #8]
 8016da4:	429a      	cmp	r2, r3
 8016da6:	d216      	bcs.n	8016dd6 <strncpy_s+0x72>
            SECUREC_CALC_STR_LEN(strSrc, count, &minCpLen); /* No ending terminator */
 8016da8:	687b      	ldr	r3, [r7, #4]
 8016daa:	61bb      	str	r3, [r7, #24]
 8016dac:	683b      	ldr	r3, [r7, #0]
 8016dae:	61fb      	str	r3, [r7, #28]
 8016db0:	e005      	b.n	8016dbe <strncpy_s+0x5a>
 8016db2:	69fb      	ldr	r3, [r7, #28]
 8016db4:	3b01      	subs	r3, #1
 8016db6:	61fb      	str	r3, [r7, #28]
 8016db8:	69bb      	ldr	r3, [r7, #24]
 8016dba:	3301      	adds	r3, #1
 8016dbc:	61bb      	str	r3, [r7, #24]
 8016dbe:	69fb      	ldr	r3, [r7, #28]
 8016dc0:	2b00      	cmp	r3, #0
 8016dc2:	d003      	beq.n	8016dcc <strncpy_s+0x68>
 8016dc4:	69bb      	ldr	r3, [r7, #24]
 8016dc6:	781b      	ldrb	r3, [r3, #0]
 8016dc8:	2b00      	cmp	r3, #0
 8016dca:	d1f2      	bne.n	8016db2 <strncpy_s+0x4e>
 8016dcc:	69ba      	ldr	r2, [r7, #24]
 8016dce:	687b      	ldr	r3, [r7, #4]
 8016dd0:	1ad3      	subs	r3, r2, r3
 8016dd2:	617b      	str	r3, [r7, #20]
 8016dd4:	e020      	b.n	8016e18 <strncpy_s+0xb4>
        } else {
            size_t tmpCount = destMax;
 8016dd6:	68bb      	ldr	r3, [r7, #8]
 8016dd8:	62bb      	str	r3, [r7, #40]	; 0x28
#ifdef  SECUREC_COMPATIBLE_WIN_FORMAT
            if (count == ((size_t)(-1))) {
                tmpCount = destMax - 1;
            }
#endif
            SECUREC_CALC_STR_LEN(strSrc, tmpCount, &minCpLen); /* No ending terminator */
 8016dda:	687b      	ldr	r3, [r7, #4]
 8016ddc:	623b      	str	r3, [r7, #32]
 8016dde:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016de0:	627b      	str	r3, [r7, #36]	; 0x24
 8016de2:	e005      	b.n	8016df0 <strncpy_s+0x8c>
 8016de4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016de6:	3b01      	subs	r3, #1
 8016de8:	627b      	str	r3, [r7, #36]	; 0x24
 8016dea:	6a3b      	ldr	r3, [r7, #32]
 8016dec:	3301      	adds	r3, #1
 8016dee:	623b      	str	r3, [r7, #32]
 8016df0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016df2:	2b00      	cmp	r3, #0
 8016df4:	d003      	beq.n	8016dfe <strncpy_s+0x9a>
 8016df6:	6a3b      	ldr	r3, [r7, #32]
 8016df8:	781b      	ldrb	r3, [r3, #0]
 8016dfa:	2b00      	cmp	r3, #0
 8016dfc:	d1f2      	bne.n	8016de4 <strncpy_s+0x80>
 8016dfe:	6a3a      	ldr	r2, [r7, #32]
 8016e00:	687b      	ldr	r3, [r7, #4]
 8016e02:	1ad3      	subs	r3, r2, r3
 8016e04:	617b      	str	r3, [r7, #20]
            if (minCpLen == destMax) {
 8016e06:	697b      	ldr	r3, [r7, #20]
 8016e08:	68ba      	ldr	r2, [r7, #8]
 8016e0a:	429a      	cmp	r2, r3
 8016e0c:	d104      	bne.n	8016e18 <strncpy_s+0xb4>
                strDest[0] = '\0';
 8016e0e:	68fb      	ldr	r3, [r7, #12]
 8016e10:	2200      	movs	r2, #0
 8016e12:	701a      	strb	r2, [r3, #0]
                SECUREC_ERROR_INVALID_RANGE("strncpy_s");
                return ERANGE_AND_RESET;
 8016e14:	23a2      	movs	r3, #162	; 0xa2
 8016e16:	e030      	b.n	8016e7a <strncpy_s+0x116>
            }
        }
        if (SECUREC_STRING_NO_OVERLAP(strDest, strSrc, minCpLen) || strDest == strSrc) {
 8016e18:	687a      	ldr	r2, [r7, #4]
 8016e1a:	68fb      	ldr	r3, [r7, #12]
 8016e1c:	429a      	cmp	r2, r3
 8016e1e:	d205      	bcs.n	8016e2c <strncpy_s+0xc8>
 8016e20:	697b      	ldr	r3, [r7, #20]
 8016e22:	687a      	ldr	r2, [r7, #4]
 8016e24:	4413      	add	r3, r2
 8016e26:	68fa      	ldr	r2, [r7, #12]
 8016e28:	429a      	cmp	r2, r3
 8016e2a:	d80d      	bhi.n	8016e48 <strncpy_s+0xe4>
 8016e2c:	68fa      	ldr	r2, [r7, #12]
 8016e2e:	687b      	ldr	r3, [r7, #4]
 8016e30:	429a      	cmp	r2, r3
 8016e32:	d205      	bcs.n	8016e40 <strncpy_s+0xdc>
 8016e34:	697b      	ldr	r3, [r7, #20]
 8016e36:	68fa      	ldr	r2, [r7, #12]
 8016e38:	4413      	add	r3, r2
 8016e3a:	687a      	ldr	r2, [r7, #4]
 8016e3c:	429a      	cmp	r2, r3
 8016e3e:	d803      	bhi.n	8016e48 <strncpy_s+0xe4>
 8016e40:	68fa      	ldr	r2, [r7, #12]
 8016e42:	687b      	ldr	r3, [r7, #4]
 8016e44:	429a      	cmp	r2, r3
 8016e46:	d10c      	bne.n	8016e62 <strncpy_s+0xfe>
            /* Not overlap */
            SECUREC_MEMCPY_WARP_OPT(strDest, strSrc, minCpLen);    /* Copy string without terminator */
 8016e48:	697b      	ldr	r3, [r7, #20]
 8016e4a:	461a      	mov	r2, r3
 8016e4c:	6879      	ldr	r1, [r7, #4]
 8016e4e:	68f8      	ldr	r0, [r7, #12]
 8016e50:	f002 f954 	bl	80190fc <memcpy>
            strDest[minCpLen] = '\0';
 8016e54:	697b      	ldr	r3, [r7, #20]
 8016e56:	68fa      	ldr	r2, [r7, #12]
 8016e58:	4413      	add	r3, r2
 8016e5a:	2200      	movs	r2, #0
 8016e5c:	701a      	strb	r2, [r3, #0]
            return EOK;
 8016e5e:	2300      	movs	r3, #0
 8016e60:	e00b      	b.n	8016e7a <strncpy_s+0x116>
        } else {
            strDest[0] = '\0';
 8016e62:	68fb      	ldr	r3, [r7, #12]
 8016e64:	2200      	movs	r2, #0
 8016e66:	701a      	strb	r2, [r3, #0]
            SECUREC_ERROR_BUFFER_OVERLAP("strncpy_s");
            return EOVERLAP_AND_RESET;
 8016e68:	23b6      	movs	r3, #182	; 0xb6
 8016e6a:	e006      	b.n	8016e7a <strncpy_s+0x116>
        }
    }
    return strncpy_error(strDest, destMax, strSrc, count);
 8016e6c:	683b      	ldr	r3, [r7, #0]
 8016e6e:	687a      	ldr	r2, [r7, #4]
 8016e70:	68b9      	ldr	r1, [r7, #8]
 8016e72:	68f8      	ldr	r0, [r7, #12]
 8016e74:	f7ff ff3b 	bl	8016cee <strncpy_error>
 8016e78:	4603      	mov	r3, r0
}
 8016e7a:	4a05      	ldr	r2, [pc, #20]	; (8016e90 <strncpy_s+0x12c>)
 8016e7c:	6811      	ldr	r1, [r2, #0]
 8016e7e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016e80:	4051      	eors	r1, r2
 8016e82:	d001      	beq.n	8016e88 <strncpy_s+0x124>
 8016e84:	f7ed fbaa 	bl	80045dc <__stack_chk_fail>
 8016e88:	4618      	mov	r0, r3
 8016e8a:	3730      	adds	r7, #48	; 0x30
 8016e8c:	46bd      	mov	sp, r7
 8016e8e:	bd80      	pop	{r7, pc}
 8016e90:	080230a8 	.word	0x080230a8

08016e94 <SecDoCat>:

/*
 * Befor this function, the basic parameter checking has been done
 */
SECUREC_INLINE errno_t SecDoCat(char *strDest, size_t destMax, const char *strSrc)
{
 8016e94:	b580      	push	{r7, lr}
 8016e96:	b08c      	sub	sp, #48	; 0x30
 8016e98:	af00      	add	r7, sp, #0
 8016e9a:	60f8      	str	r0, [r7, #12]
 8016e9c:	60b9      	str	r1, [r7, #8]
 8016e9e:	607a      	str	r2, [r7, #4]
 8016ea0:	4b42      	ldr	r3, [pc, #264]	; (8016fac <SecDoCat+0x118>)
 8016ea2:	681b      	ldr	r3, [r3, #0]
 8016ea4:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016ea6:	f04f 0300 	mov.w	r3, #0
    size_t destLen;
    size_t srcLen;
    size_t maxSrcLen;
    SECUREC_CALC_STR_LEN(strDest, destMax, &destLen);
 8016eaa:	68fb      	ldr	r3, [r7, #12]
 8016eac:	61bb      	str	r3, [r7, #24]
 8016eae:	68bb      	ldr	r3, [r7, #8]
 8016eb0:	61fb      	str	r3, [r7, #28]
 8016eb2:	e005      	b.n	8016ec0 <SecDoCat+0x2c>
 8016eb4:	69fb      	ldr	r3, [r7, #28]
 8016eb6:	3b01      	subs	r3, #1
 8016eb8:	61fb      	str	r3, [r7, #28]
 8016eba:	69bb      	ldr	r3, [r7, #24]
 8016ebc:	3301      	adds	r3, #1
 8016ebe:	61bb      	str	r3, [r7, #24]
 8016ec0:	69fb      	ldr	r3, [r7, #28]
 8016ec2:	2b00      	cmp	r3, #0
 8016ec4:	d003      	beq.n	8016ece <SecDoCat+0x3a>
 8016ec6:	69bb      	ldr	r3, [r7, #24]
 8016ec8:	781b      	ldrb	r3, [r3, #0]
 8016eca:	2b00      	cmp	r3, #0
 8016ecc:	d1f2      	bne.n	8016eb4 <SecDoCat+0x20>
 8016ece:	69ba      	ldr	r2, [r7, #24]
 8016ed0:	68fb      	ldr	r3, [r7, #12]
 8016ed2:	1ad3      	subs	r3, r2, r3
 8016ed4:	613b      	str	r3, [r7, #16]
    /* Only optimize strSrc, do not apply this function to strDest */
    maxSrcLen = destMax - destLen;
 8016ed6:	693b      	ldr	r3, [r7, #16]
 8016ed8:	68ba      	ldr	r2, [r7, #8]
 8016eda:	1ad3      	subs	r3, r2, r3
 8016edc:	62bb      	str	r3, [r7, #40]	; 0x28
    SECUREC_CALC_STR_LEN_OPT(strSrc, maxSrcLen, &srcLen);
 8016ede:	687b      	ldr	r3, [r7, #4]
 8016ee0:	623b      	str	r3, [r7, #32]
 8016ee2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ee4:	627b      	str	r3, [r7, #36]	; 0x24
 8016ee6:	e005      	b.n	8016ef4 <SecDoCat+0x60>
 8016ee8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016eea:	3b01      	subs	r3, #1
 8016eec:	627b      	str	r3, [r7, #36]	; 0x24
 8016eee:	6a3b      	ldr	r3, [r7, #32]
 8016ef0:	3301      	adds	r3, #1
 8016ef2:	623b      	str	r3, [r7, #32]
 8016ef4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016ef6:	2b00      	cmp	r3, #0
 8016ef8:	d003      	beq.n	8016f02 <SecDoCat+0x6e>
 8016efa:	6a3b      	ldr	r3, [r7, #32]
 8016efc:	781b      	ldrb	r3, [r3, #0]
 8016efe:	2b00      	cmp	r3, #0
 8016f00:	d1f2      	bne.n	8016ee8 <SecDoCat+0x54>
 8016f02:	6a3a      	ldr	r2, [r7, #32]
 8016f04:	687b      	ldr	r3, [r7, #4]
 8016f06:	1ad3      	subs	r3, r2, r3
 8016f08:	617b      	str	r3, [r7, #20]

    if (SECUREC_CAT_STRING_IS_OVERLAP(strDest, destLen, strSrc, srcLen)) {
 8016f0a:	68fa      	ldr	r2, [r7, #12]
 8016f0c:	687b      	ldr	r3, [r7, #4]
 8016f0e:	429a      	cmp	r2, r3
 8016f10:	d207      	bcs.n	8016f22 <SecDoCat+0x8e>
 8016f12:	693a      	ldr	r2, [r7, #16]
 8016f14:	697b      	ldr	r3, [r7, #20]
 8016f16:	4413      	add	r3, r2
 8016f18:	68fa      	ldr	r2, [r7, #12]
 8016f1a:	4413      	add	r3, r2
 8016f1c:	687a      	ldr	r2, [r7, #4]
 8016f1e:	429a      	cmp	r2, r3
 8016f20:	d909      	bls.n	8016f36 <SecDoCat+0xa2>
 8016f22:	687a      	ldr	r2, [r7, #4]
 8016f24:	68fb      	ldr	r3, [r7, #12]
 8016f26:	429a      	cmp	r2, r3
 8016f28:	d216      	bcs.n	8016f58 <SecDoCat+0xc4>
 8016f2a:	697b      	ldr	r3, [r7, #20]
 8016f2c:	687a      	ldr	r2, [r7, #4]
 8016f2e:	4413      	add	r3, r2
 8016f30:	68fa      	ldr	r2, [r7, #12]
 8016f32:	429a      	cmp	r2, r3
 8016f34:	d810      	bhi.n	8016f58 <SecDoCat+0xc4>
        strDest[0] = '\0';
 8016f36:	68fb      	ldr	r3, [r7, #12]
 8016f38:	2200      	movs	r2, #0
 8016f3a:	701a      	strb	r2, [r3, #0]
        if (strDest + destLen <= strSrc && destLen == destMax) {
 8016f3c:	693b      	ldr	r3, [r7, #16]
 8016f3e:	68fa      	ldr	r2, [r7, #12]
 8016f40:	4413      	add	r3, r2
 8016f42:	687a      	ldr	r2, [r7, #4]
 8016f44:	429a      	cmp	r2, r3
 8016f46:	d305      	bcc.n	8016f54 <SecDoCat+0xc0>
 8016f48:	693b      	ldr	r3, [r7, #16]
 8016f4a:	68ba      	ldr	r2, [r7, #8]
 8016f4c:	429a      	cmp	r2, r3
 8016f4e:	d101      	bne.n	8016f54 <SecDoCat+0xc0>
            SECUREC_ERROR_INVALID_PARAMTER("strcat_s");
            return EINVAL_AND_RESET;
 8016f50:	2396      	movs	r3, #150	; 0x96
 8016f52:	e020      	b.n	8016f96 <SecDoCat+0x102>
        }
        SECUREC_ERROR_BUFFER_OVERLAP("strcat_s");
        return EOVERLAP_AND_RESET;
 8016f54:	23b6      	movs	r3, #182	; 0xb6
 8016f56:	e01e      	b.n	8016f96 <SecDoCat+0x102>
    }
    if (srcLen + destLen >= destMax || strDest == strSrc) {
 8016f58:	697a      	ldr	r2, [r7, #20]
 8016f5a:	693b      	ldr	r3, [r7, #16]
 8016f5c:	4413      	add	r3, r2
 8016f5e:	68ba      	ldr	r2, [r7, #8]
 8016f60:	429a      	cmp	r2, r3
 8016f62:	d903      	bls.n	8016f6c <SecDoCat+0xd8>
 8016f64:	68fa      	ldr	r2, [r7, #12]
 8016f66:	687b      	ldr	r3, [r7, #4]
 8016f68:	429a      	cmp	r2, r3
 8016f6a:	d10a      	bne.n	8016f82 <SecDoCat+0xee>
        strDest[0] = '\0';
 8016f6c:	68fb      	ldr	r3, [r7, #12]
 8016f6e:	2200      	movs	r2, #0
 8016f70:	701a      	strb	r2, [r3, #0]
        if (destLen == destMax) {
 8016f72:	693b      	ldr	r3, [r7, #16]
 8016f74:	68ba      	ldr	r2, [r7, #8]
 8016f76:	429a      	cmp	r2, r3
 8016f78:	d101      	bne.n	8016f7e <SecDoCat+0xea>
            SECUREC_ERROR_INVALID_PARAMTER("strcat_s");
            return EINVAL_AND_RESET;
 8016f7a:	2396      	movs	r3, #150	; 0x96
 8016f7c:	e00b      	b.n	8016f96 <SecDoCat+0x102>
        }
        SECUREC_ERROR_INVALID_RANGE("strcat_s");
        return ERANGE_AND_RESET;
 8016f7e:	23a2      	movs	r3, #162	; 0xa2
 8016f80:	e009      	b.n	8016f96 <SecDoCat+0x102>
    }
    SECUREC_MEMCPY_WARP_OPT(strDest + destLen, strSrc, srcLen + 1); /* Single character length  include \0 */
 8016f82:	693b      	ldr	r3, [r7, #16]
 8016f84:	68fa      	ldr	r2, [r7, #12]
 8016f86:	18d0      	adds	r0, r2, r3
 8016f88:	697b      	ldr	r3, [r7, #20]
 8016f8a:	3301      	adds	r3, #1
 8016f8c:	461a      	mov	r2, r3
 8016f8e:	6879      	ldr	r1, [r7, #4]
 8016f90:	f002 f8b4 	bl	80190fc <memcpy>
    return EOK;
 8016f94:	2300      	movs	r3, #0
}
 8016f96:	4a05      	ldr	r2, [pc, #20]	; (8016fac <SecDoCat+0x118>)
 8016f98:	6811      	ldr	r1, [r2, #0]
 8016f9a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016f9c:	4051      	eors	r1, r2
 8016f9e:	d001      	beq.n	8016fa4 <SecDoCat+0x110>
 8016fa0:	f7ed fb1c 	bl	80045dc <__stack_chk_fail>
 8016fa4:	4618      	mov	r0, r3
 8016fa6:	3730      	adds	r7, #48	; 0x30
 8016fa8:	46bd      	mov	sp, r7
 8016faa:	bd80      	pop	{r7, pc}
 8016fac:	080230ac 	.word	0x080230ac

08016fb0 <strcat_s>:
 *    EOVERLAP_AND_RESET   dest buffer and source buffer are overlapped and all  parameters are valid
 *
 *    If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
 */
errno_t strcat_s(char *strDest, size_t destMax, const char *strSrc)
{
 8016fb0:	b580      	push	{r7, lr}
 8016fb2:	b084      	sub	sp, #16
 8016fb4:	af00      	add	r7, sp, #0
 8016fb6:	60f8      	str	r0, [r7, #12]
 8016fb8:	60b9      	str	r1, [r7, #8]
 8016fba:	607a      	str	r2, [r7, #4]
    if (destMax == 0 || destMax > SECUREC_STRING_MAX_LEN) {
 8016fbc:	68bb      	ldr	r3, [r7, #8]
 8016fbe:	2b00      	cmp	r3, #0
 8016fc0:	d002      	beq.n	8016fc8 <strcat_s+0x18>
 8016fc2:	68bb      	ldr	r3, [r7, #8]
 8016fc4:	2b00      	cmp	r3, #0
 8016fc6:	da01      	bge.n	8016fcc <strcat_s+0x1c>
        SECUREC_ERROR_INVALID_RANGE("strcat_s");
        return ERANGE;
 8016fc8:	2322      	movs	r3, #34	; 0x22
 8016fca:	e015      	b.n	8016ff8 <strcat_s+0x48>
    }
    if (strDest == NULL || strSrc == NULL) {
 8016fcc:	68fb      	ldr	r3, [r7, #12]
 8016fce:	2b00      	cmp	r3, #0
 8016fd0:	d002      	beq.n	8016fd8 <strcat_s+0x28>
 8016fd2:	687b      	ldr	r3, [r7, #4]
 8016fd4:	2b00      	cmp	r3, #0
 8016fd6:	d109      	bne.n	8016fec <strcat_s+0x3c>
        SECUREC_ERROR_INVALID_PARAMTER("strcat_s");
        if (strDest != NULL) {
 8016fd8:	68fb      	ldr	r3, [r7, #12]
 8016fda:	2b00      	cmp	r3, #0
 8016fdc:	d004      	beq.n	8016fe8 <strcat_s+0x38>
            strDest[0] = '\0';
 8016fde:	68fb      	ldr	r3, [r7, #12]
 8016fe0:	2200      	movs	r2, #0
 8016fe2:	701a      	strb	r2, [r3, #0]
            return EINVAL_AND_RESET;
 8016fe4:	2396      	movs	r3, #150	; 0x96
 8016fe6:	e007      	b.n	8016ff8 <strcat_s+0x48>
        }
        return EINVAL;
 8016fe8:	2316      	movs	r3, #22
 8016fea:	e005      	b.n	8016ff8 <strcat_s+0x48>
    }
    return SecDoCat(strDest, destMax, strSrc);
 8016fec:	687a      	ldr	r2, [r7, #4]
 8016fee:	68b9      	ldr	r1, [r7, #8]
 8016ff0:	68f8      	ldr	r0, [r7, #12]
 8016ff2:	f7ff ff4f 	bl	8016e94 <SecDoCat>
 8016ff6:	4603      	mov	r3, r0
}
 8016ff8:	4618      	mov	r0, r3
 8016ffa:	3710      	adds	r7, #16
 8016ffc:	46bd      	mov	sp, r7
 8016ffe:	bd80      	pop	{r7, pc}

08017000 <SecMemcpyError>:

/*
 * Handling errors
 */
SECUREC_INLINE errno_t SecMemcpyError(void *dest, size_t destMax, const void *src, size_t count)
{
 8017000:	b580      	push	{r7, lr}
 8017002:	b084      	sub	sp, #16
 8017004:	af00      	add	r7, sp, #0
 8017006:	60f8      	str	r0, [r7, #12]
 8017008:	60b9      	str	r1, [r7, #8]
 801700a:	607a      	str	r2, [r7, #4]
 801700c:	603b      	str	r3, [r7, #0]
    if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN) {
 801700e:	68bb      	ldr	r3, [r7, #8]
 8017010:	2b00      	cmp	r3, #0
 8017012:	d002      	beq.n	801701a <SecMemcpyError+0x1a>
 8017014:	68bb      	ldr	r3, [r7, #8]
 8017016:	2b00      	cmp	r3, #0
 8017018:	da01      	bge.n	801701e <SecMemcpyError+0x1e>
        SECUREC_ERROR_INVALID_RANGE("memcpy_s");
        return ERANGE;
 801701a:	2322      	movs	r3, #34	; 0x22
 801701c:	e038      	b.n	8017090 <SecMemcpyError+0x90>
    }
    if (dest == NULL || src == NULL) {
 801701e:	68fb      	ldr	r3, [r7, #12]
 8017020:	2b00      	cmp	r3, #0
 8017022:	d002      	beq.n	801702a <SecMemcpyError+0x2a>
 8017024:	687b      	ldr	r3, [r7, #4]
 8017026:	2b00      	cmp	r3, #0
 8017028:	d10b      	bne.n	8017042 <SecMemcpyError+0x42>
        SECUREC_ERROR_INVALID_PARAMTER("memcpy_s");
        if (dest != NULL) {
 801702a:	68fb      	ldr	r3, [r7, #12]
 801702c:	2b00      	cmp	r3, #0
 801702e:	d006      	beq.n	801703e <SecMemcpyError+0x3e>
            (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
 8017030:	68ba      	ldr	r2, [r7, #8]
 8017032:	2100      	movs	r1, #0
 8017034:	68f8      	ldr	r0, [r7, #12]
 8017036:	f7f8 f967 	bl	800f308 <memset>
            return EINVAL_AND_RESET;
 801703a:	2396      	movs	r3, #150	; 0x96
 801703c:	e028      	b.n	8017090 <SecMemcpyError+0x90>
        }
        return EINVAL;
 801703e:	2316      	movs	r3, #22
 8017040:	e026      	b.n	8017090 <SecMemcpyError+0x90>
    }
    if (count > destMax) {
 8017042:	683a      	ldr	r2, [r7, #0]
 8017044:	68bb      	ldr	r3, [r7, #8]
 8017046:	429a      	cmp	r2, r3
 8017048:	d906      	bls.n	8017058 <SecMemcpyError+0x58>
        (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
 801704a:	68ba      	ldr	r2, [r7, #8]
 801704c:	2100      	movs	r1, #0
 801704e:	68f8      	ldr	r0, [r7, #12]
 8017050:	f7f8 f95a 	bl	800f308 <memset>
        SECUREC_ERROR_INVALID_RANGE("memcpy_s");
        return ERANGE_AND_RESET;
 8017054:	23a2      	movs	r3, #162	; 0xa2
 8017056:	e01b      	b.n	8017090 <SecMemcpyError+0x90>
    }
    if (SECUREC_MEMORY_IS_OVERLAP(dest, src, count)) {
 8017058:	687a      	ldr	r2, [r7, #4]
 801705a:	68fb      	ldr	r3, [r7, #12]
 801705c:	429a      	cmp	r2, r3
 801705e:	d205      	bcs.n	801706c <SecMemcpyError+0x6c>
 8017060:	687a      	ldr	r2, [r7, #4]
 8017062:	683b      	ldr	r3, [r7, #0]
 8017064:	4413      	add	r3, r2
 8017066:	68fa      	ldr	r2, [r7, #12]
 8017068:	429a      	cmp	r2, r3
 801706a:	d309      	bcc.n	8017080 <SecMemcpyError+0x80>
 801706c:	68fa      	ldr	r2, [r7, #12]
 801706e:	687b      	ldr	r3, [r7, #4]
 8017070:	429a      	cmp	r2, r3
 8017072:	d20c      	bcs.n	801708e <SecMemcpyError+0x8e>
 8017074:	68fa      	ldr	r2, [r7, #12]
 8017076:	683b      	ldr	r3, [r7, #0]
 8017078:	4413      	add	r3, r2
 801707a:	687a      	ldr	r2, [r7, #4]
 801707c:	429a      	cmp	r2, r3
 801707e:	d206      	bcs.n	801708e <SecMemcpyError+0x8e>
        (void)SECUREC_MEMSET_FUNC_OPT(dest, 0, destMax);
 8017080:	68ba      	ldr	r2, [r7, #8]
 8017082:	2100      	movs	r1, #0
 8017084:	68f8      	ldr	r0, [r7, #12]
 8017086:	f7f8 f93f 	bl	800f308 <memset>
        SECUREC_ERROR_BUFFER_OVERLAP("memcpy_s");
        return EOVERLAP_AND_RESET;
 801708a:	23b6      	movs	r3, #182	; 0xb6
 801708c:	e000      	b.n	8017090 <SecMemcpyError+0x90>
    }
    /* Count is 0 or dest equal src also ret EOK */
    return EOK;
 801708e:	2300      	movs	r3, #0
}
 8017090:	4618      	mov	r0, r3
 8017092:	3710      	adds	r7, #16
 8017094:	46bd      	mov	sp, r7
 8017096:	bd80      	pop	{r7, pc}

08017098 <memcpy_s>:
 *    if an error occurred, dest will be filled with 0.
 *    If the source and destination overlap, the behavior of memcpy_s is undefined.
 *    Use memmove_s to handle overlapping regions.
 */
errno_t memcpy_s(void *dest, size_t destMax, const void *src, size_t count)
{
 8017098:	b580      	push	{r7, lr}
 801709a:	b084      	sub	sp, #16
 801709c:	af00      	add	r7, sp, #0
 801709e:	60f8      	str	r0, [r7, #12]
 80170a0:	60b9      	str	r1, [r7, #8]
 80170a2:	607a      	str	r2, [r7, #4]
 80170a4:	603b      	str	r3, [r7, #0]
    if (SECUREC_MEMCPY_PARAM_OK(dest, destMax, src, count)) {
 80170a6:	683a      	ldr	r2, [r7, #0]
 80170a8:	68bb      	ldr	r3, [r7, #8]
 80170aa:	429a      	cmp	r2, r3
 80170ac:	bf94      	ite	ls
 80170ae:	2301      	movls	r3, #1
 80170b0:	2300      	movhi	r3, #0
 80170b2:	b2db      	uxtb	r3, r3
 80170b4:	2b00      	cmp	r3, #0
 80170b6:	d009      	beq.n	80170cc <memcpy_s+0x34>
 80170b8:	68fb      	ldr	r3, [r7, #12]
 80170ba:	2b00      	cmp	r3, #0
 80170bc:	bf14      	ite	ne
 80170be:	2301      	movne	r3, #1
 80170c0:	2300      	moveq	r3, #0
 80170c2:	b2db      	uxtb	r3, r3
 80170c4:	2b00      	cmp	r3, #0
 80170c6:	d001      	beq.n	80170cc <memcpy_s+0x34>
 80170c8:	2301      	movs	r3, #1
 80170ca:	e000      	b.n	80170ce <memcpy_s+0x36>
 80170cc:	2300      	movs	r3, #0
 80170ce:	2b00      	cmp	r3, #0
 80170d0:	d009      	beq.n	80170e6 <memcpy_s+0x4e>
 80170d2:	687b      	ldr	r3, [r7, #4]
 80170d4:	2b00      	cmp	r3, #0
 80170d6:	bf14      	ite	ne
 80170d8:	2301      	movne	r3, #1
 80170da:	2300      	moveq	r3, #0
 80170dc:	b2db      	uxtb	r3, r3
 80170de:	2b00      	cmp	r3, #0
 80170e0:	d001      	beq.n	80170e6 <memcpy_s+0x4e>
 80170e2:	2301      	movs	r3, #1
 80170e4:	e000      	b.n	80170e8 <memcpy_s+0x50>
 80170e6:	2300      	movs	r3, #0
 80170e8:	2b00      	cmp	r3, #0
 80170ea:	d007      	beq.n	80170fc <memcpy_s+0x64>
 80170ec:	68bb      	ldr	r3, [r7, #8]
 80170ee:	43db      	mvns	r3, r3
 80170f0:	0fdb      	lsrs	r3, r3, #31
 80170f2:	b2db      	uxtb	r3, r3
 80170f4:	2b00      	cmp	r3, #0
 80170f6:	d001      	beq.n	80170fc <memcpy_s+0x64>
 80170f8:	2301      	movs	r3, #1
 80170fa:	e000      	b.n	80170fe <memcpy_s+0x66>
 80170fc:	2300      	movs	r3, #0
 80170fe:	2b00      	cmp	r3, #0
 8017100:	d009      	beq.n	8017116 <memcpy_s+0x7e>
 8017102:	683b      	ldr	r3, [r7, #0]
 8017104:	2b00      	cmp	r3, #0
 8017106:	bf14      	ite	ne
 8017108:	2301      	movne	r3, #1
 801710a:	2300      	moveq	r3, #0
 801710c:	b2db      	uxtb	r3, r3
 801710e:	2b00      	cmp	r3, #0
 8017110:	d001      	beq.n	8017116 <memcpy_s+0x7e>
 8017112:	2301      	movs	r3, #1
 8017114:	e000      	b.n	8017118 <memcpy_s+0x80>
 8017116:	2300      	movs	r3, #0
 8017118:	2b00      	cmp	r3, #0
 801711a:	d03d      	beq.n	8017198 <memcpy_s+0x100>
 801711c:	687a      	ldr	r2, [r7, #4]
 801711e:	68fb      	ldr	r3, [r7, #12]
 8017120:	429a      	cmp	r2, r3
 8017122:	bf34      	ite	cc
 8017124:	2301      	movcc	r3, #1
 8017126:	2300      	movcs	r3, #0
 8017128:	b2db      	uxtb	r3, r3
 801712a:	2b00      	cmp	r3, #0
 801712c:	d00c      	beq.n	8017148 <memcpy_s+0xb0>
 801712e:	687a      	ldr	r2, [r7, #4]
 8017130:	683b      	ldr	r3, [r7, #0]
 8017132:	4413      	add	r3, r2
 8017134:	68fa      	ldr	r2, [r7, #12]
 8017136:	429a      	cmp	r2, r3
 8017138:	bf2c      	ite	cs
 801713a:	2301      	movcs	r3, #1
 801713c:	2300      	movcc	r3, #0
 801713e:	b2db      	uxtb	r3, r3
 8017140:	2b00      	cmp	r3, #0
 8017142:	d001      	beq.n	8017148 <memcpy_s+0xb0>
 8017144:	2301      	movs	r3, #1
 8017146:	e000      	b.n	801714a <memcpy_s+0xb2>
 8017148:	2300      	movs	r3, #0
 801714a:	2b00      	cmp	r3, #0
 801714c:	d118      	bne.n	8017180 <memcpy_s+0xe8>
 801714e:	68fa      	ldr	r2, [r7, #12]
 8017150:	687b      	ldr	r3, [r7, #4]
 8017152:	429a      	cmp	r2, r3
 8017154:	bf34      	ite	cc
 8017156:	2301      	movcc	r3, #1
 8017158:	2300      	movcs	r3, #0
 801715a:	b2db      	uxtb	r3, r3
 801715c:	2b00      	cmp	r3, #0
 801715e:	d00c      	beq.n	801717a <memcpy_s+0xe2>
 8017160:	68fa      	ldr	r2, [r7, #12]
 8017162:	683b      	ldr	r3, [r7, #0]
 8017164:	4413      	add	r3, r2
 8017166:	687a      	ldr	r2, [r7, #4]
 8017168:	429a      	cmp	r2, r3
 801716a:	bf2c      	ite	cs
 801716c:	2301      	movcs	r3, #1
 801716e:	2300      	movcc	r3, #0
 8017170:	b2db      	uxtb	r3, r3
 8017172:	2b00      	cmp	r3, #0
 8017174:	d001      	beq.n	801717a <memcpy_s+0xe2>
 8017176:	2301      	movs	r3, #1
 8017178:	e000      	b.n	801717c <memcpy_s+0xe4>
 801717a:	2300      	movs	r3, #0
 801717c:	2b00      	cmp	r3, #0
 801717e:	d001      	beq.n	8017184 <memcpy_s+0xec>
 8017180:	2301      	movs	r3, #1
 8017182:	e000      	b.n	8017186 <memcpy_s+0xee>
 8017184:	2300      	movs	r3, #0
 8017186:	2b00      	cmp	r3, #0
 8017188:	d006      	beq.n	8017198 <memcpy_s+0x100>
        SECUREC_MEMCPY_WARP_OPT(dest, src, count);
 801718a:	683a      	ldr	r2, [r7, #0]
 801718c:	6879      	ldr	r1, [r7, #4]
 801718e:	68f8      	ldr	r0, [r7, #12]
 8017190:	f001 ffb4 	bl	80190fc <memcpy>
        return EOK;
 8017194:	2300      	movs	r3, #0
 8017196:	e006      	b.n	80171a6 <memcpy_s+0x10e>
    }
    /* Meet some runtime violation, return error code */
    return SecMemcpyError(dest, destMax, src, count);
 8017198:	683b      	ldr	r3, [r7, #0]
 801719a:	687a      	ldr	r2, [r7, #4]
 801719c:	68b9      	ldr	r1, [r7, #8]
 801719e:	68f8      	ldr	r0, [r7, #12]
 80171a0:	f7ff ff2e 	bl	8017000 <SecMemcpyError>
 80171a4:	4603      	mov	r3, r0
}
 80171a6:	4618      	mov	r0, r3
 80171a8:	3710      	adds	r7, #16
 80171aa:	46bd      	mov	sp, r7
 80171ac:	bd80      	pop	{r7, pc}
	...

080171b0 <SecFormatFloat>:
static const char g_itoaLowerDigits[SECUREC_DIGITS_BUF_SIZE] = "0123456789abcdefx";

#if SECUREC_ENABLE_SPRINTF_FLOAT
/* Call system sprintf to format float value */
SECUREC_INLINE int SecFormatFloat(char *strDest, const char *format, ...)
{
 80171b0:	b40e      	push	{r1, r2, r3}
 80171b2:	b580      	push	{r7, lr}
 80171b4:	b087      	sub	sp, #28
 80171b6:	af00      	add	r7, sp, #0
 80171b8:	6078      	str	r0, [r7, #4]
 80171ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80171bc:	603b      	str	r3, [r7, #0]
 80171be:	4b0e      	ldr	r3, [pc, #56]	; (80171f8 <SecFormatFloat+0x48>)
 80171c0:	681b      	ldr	r3, [r3, #0]
 80171c2:	617b      	str	r3, [r7, #20]
 80171c4:	f04f 0300 	mov.w	r3, #0
    int ret;                    /* If initialization causes  e838 */
    va_list argList;

    va_start(argList, format);
 80171c8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80171cc:	60fb      	str	r3, [r7, #12]
    SECUREC_MASK_VSPRINTF_WARNING
    ret = vsprintf(strDest, format, argList);
 80171ce:	68fa      	ldr	r2, [r7, #12]
 80171d0:	6839      	ldr	r1, [r7, #0]
 80171d2:	6878      	ldr	r0, [r7, #4]
 80171d4:	f003 fc66 	bl	801aaa4 <vsprintf>
 80171d8:	6138      	str	r0, [r7, #16]
    SECUREC_END_MASK_VSPRINTF_WARNING
    va_end(argList);
    (void)argList; /* To clear e438 last value assigned not used , the compiler will optimize this code */

    return ret;
 80171da:	693b      	ldr	r3, [r7, #16]
}
 80171dc:	4a06      	ldr	r2, [pc, #24]	; (80171f8 <SecFormatFloat+0x48>)
 80171de:	6811      	ldr	r1, [r2, #0]
 80171e0:	697a      	ldr	r2, [r7, #20]
 80171e2:	4051      	eors	r1, r2
 80171e4:	d001      	beq.n	80171ea <SecFormatFloat+0x3a>
 80171e6:	f7ed f9f9 	bl	80045dc <__stack_chk_fail>
 80171ea:	4618      	mov	r0, r3
 80171ec:	371c      	adds	r7, #28
 80171ee:	46bd      	mov	sp, r7
 80171f0:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 80171f4:	b003      	add	sp, #12
 80171f6:	4770      	bx	lr
 80171f8:	080230b0 	.word	0x080230b0

080171fc <SecFormatLongDouble>:

#if defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && SECUREC_ENABLE_SPRINTF_LONG_DOUBLE
/* Out put long double value to dest */
SECUREC_INLINE void SecFormatLongDouble(SecFormatAttr *attr, const SecFloatAdapt *floatAdapt, long double ldValue)
{
 80171fc:	b590      	push	{r4, r7, lr}
 80171fe:	b089      	sub	sp, #36	; 0x24
 8017200:	af02      	add	r7, sp, #8
 8017202:	60f8      	str	r0, [r7, #12]
 8017204:	60b9      	str	r1, [r7, #8]
 8017206:	e9c7 2300 	strd	r2, r3, [r7]
    int fldWidth = (((attr->flags & SECUREC_FLAG_LEFT) != 0) ? (-attr->fldWidth) : attr->fldWidth);
 801720a:	68fb      	ldr	r3, [r7, #12]
 801720c:	695b      	ldr	r3, [r3, #20]
 801720e:	f003 0304 	and.w	r3, r3, #4
 8017212:	2b00      	cmp	r3, #0
 8017214:	d003      	beq.n	801721e <SecFormatLongDouble+0x22>
 8017216:	68fb      	ldr	r3, [r7, #12]
 8017218:	699b      	ldr	r3, [r3, #24]
 801721a:	425b      	negs	r3, r3
 801721c:	e001      	b.n	8017222 <SecFormatLongDouble+0x26>
 801721e:	68fb      	ldr	r3, [r7, #12]
 8017220:	699b      	ldr	r3, [r3, #24]
 8017222:	617b      	str	r3, [r7, #20]
    if (attr->dynWidth != 0 && attr->dynPrecision != 0) {
 8017224:	68fb      	ldr	r3, [r7, #12]
 8017226:	6a1b      	ldr	r3, [r3, #32]
 8017228:	2b00      	cmp	r3, #0
 801722a:	d015      	beq.n	8017258 <SecFormatLongDouble+0x5c>
 801722c:	68fb      	ldr	r3, [r7, #12]
 801722e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017230:	2b00      	cmp	r3, #0
 8017232:	d011      	beq.n	8017258 <SecFormatLongDouble+0x5c>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, attr->precision, ldValue);
 8017234:	68fb      	ldr	r3, [r7, #12]
 8017236:	6858      	ldr	r0, [r3, #4]
 8017238:	68bb      	ldr	r3, [r7, #8]
 801723a:	6919      	ldr	r1, [r3, #16]
 801723c:	68fb      	ldr	r3, [r7, #12]
 801723e:	69dc      	ldr	r4, [r3, #28]
 8017240:	e9d7 2300 	ldrd	r2, r3, [r7]
 8017244:	e9cd 2300 	strd	r2, r3, [sp]
 8017248:	4623      	mov	r3, r4
 801724a:	697a      	ldr	r2, [r7, #20]
 801724c:	f7ff ffb0 	bl	80171b0 <SecFormatFloat>
 8017250:	4602      	mov	r2, r0
 8017252:	68fb      	ldr	r3, [r7, #12]
 8017254:	609a      	str	r2, [r3, #8]
 8017256:	e032      	b.n	80172be <SecFormatLongDouble+0xc2>
    } else if (attr->dynWidth != 0) {
 8017258:	68fb      	ldr	r3, [r7, #12]
 801725a:	6a1b      	ldr	r3, [r3, #32]
 801725c:	2b00      	cmp	r3, #0
 801725e:	d00e      	beq.n	801727e <SecFormatLongDouble+0x82>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, ldValue);
 8017260:	68fb      	ldr	r3, [r7, #12]
 8017262:	6858      	ldr	r0, [r3, #4]
 8017264:	68bb      	ldr	r3, [r7, #8]
 8017266:	6919      	ldr	r1, [r3, #16]
 8017268:	e9d7 2300 	ldrd	r2, r3, [r7]
 801726c:	e9cd 2300 	strd	r2, r3, [sp]
 8017270:	697a      	ldr	r2, [r7, #20]
 8017272:	f7ff ff9d 	bl	80171b0 <SecFormatFloat>
 8017276:	4602      	mov	r2, r0
 8017278:	68fb      	ldr	r3, [r7, #12]
 801727a:	609a      	str	r2, [r3, #8]
 801727c:	e01f      	b.n	80172be <SecFormatLongDouble+0xc2>
    } else if (attr->dynPrecision != 0) {
 801727e:	68fb      	ldr	r3, [r7, #12]
 8017280:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017282:	2b00      	cmp	r3, #0
 8017284:	d010      	beq.n	80172a8 <SecFormatLongDouble+0xac>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, attr->precision, ldValue);
 8017286:	68fb      	ldr	r3, [r7, #12]
 8017288:	6858      	ldr	r0, [r3, #4]
 801728a:	68bb      	ldr	r3, [r7, #8]
 801728c:	6919      	ldr	r1, [r3, #16]
 801728e:	68fb      	ldr	r3, [r7, #12]
 8017290:	69dc      	ldr	r4, [r3, #28]
 8017292:	e9d7 2300 	ldrd	r2, r3, [r7]
 8017296:	e9cd 2300 	strd	r2, r3, [sp]
 801729a:	4622      	mov	r2, r4
 801729c:	f7ff ff88 	bl	80171b0 <SecFormatFloat>
 80172a0:	4602      	mov	r2, r0
 80172a2:	68fb      	ldr	r3, [r7, #12]
 80172a4:	609a      	str	r2, [r3, #8]
 80172a6:	e00a      	b.n	80172be <SecFormatLongDouble+0xc2>
    } else {
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, ldValue);
 80172a8:	68fb      	ldr	r3, [r7, #12]
 80172aa:	6858      	ldr	r0, [r3, #4]
 80172ac:	68bb      	ldr	r3, [r7, #8]
 80172ae:	6919      	ldr	r1, [r3, #16]
 80172b0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80172b4:	f7ff ff7c 	bl	80171b0 <SecFormatFloat>
 80172b8:	4602      	mov	r2, r0
 80172ba:	68fb      	ldr	r3, [r7, #12]
 80172bc:	609a      	str	r2, [r3, #8]
    }
    if (attr->textLen < 0 || attr->textLen >= floatAdapt->bufferSize) {
 80172be:	68fb      	ldr	r3, [r7, #12]
 80172c0:	689b      	ldr	r3, [r3, #8]
 80172c2:	2b00      	cmp	r3, #0
 80172c4:	db05      	blt.n	80172d2 <SecFormatLongDouble+0xd6>
 80172c6:	68fb      	ldr	r3, [r7, #12]
 80172c8:	689a      	ldr	r2, [r3, #8]
 80172ca:	68bb      	ldr	r3, [r7, #8]
 80172cc:	69db      	ldr	r3, [r3, #28]
 80172ce:	429a      	cmp	r2, r3
 80172d0:	db02      	blt.n	80172d8 <SecFormatLongDouble+0xdc>
        attr->textLen = 0;
 80172d2:	68fb      	ldr	r3, [r7, #12]
 80172d4:	2200      	movs	r2, #0
 80172d6:	609a      	str	r2, [r3, #8]
    }
}
 80172d8:	bf00      	nop
 80172da:	371c      	adds	r7, #28
 80172dc:	46bd      	mov	sp, r7
 80172de:	bd90      	pop	{r4, r7, pc}

080172e0 <SecFormatDouble>:
#endif

/* Out put double value to dest */
SECUREC_INLINE void SecFormatDouble(SecFormatAttr *attr, const SecFloatAdapt *floatAdapt, double dValue)
{
 80172e0:	b590      	push	{r4, r7, lr}
 80172e2:	b089      	sub	sp, #36	; 0x24
 80172e4:	af02      	add	r7, sp, #8
 80172e6:	60f8      	str	r0, [r7, #12]
 80172e8:	60b9      	str	r1, [r7, #8]
 80172ea:	e9c7 2300 	strd	r2, r3, [r7]
    int fldWidth = (((attr->flags & SECUREC_FLAG_LEFT) != 0) ? (-attr->fldWidth) : attr->fldWidth);
 80172ee:	68fb      	ldr	r3, [r7, #12]
 80172f0:	695b      	ldr	r3, [r3, #20]
 80172f2:	f003 0304 	and.w	r3, r3, #4
 80172f6:	2b00      	cmp	r3, #0
 80172f8:	d003      	beq.n	8017302 <SecFormatDouble+0x22>
 80172fa:	68fb      	ldr	r3, [r7, #12]
 80172fc:	699b      	ldr	r3, [r3, #24]
 80172fe:	425b      	negs	r3, r3
 8017300:	e001      	b.n	8017306 <SecFormatDouble+0x26>
 8017302:	68fb      	ldr	r3, [r7, #12]
 8017304:	699b      	ldr	r3, [r3, #24]
 8017306:	617b      	str	r3, [r7, #20]
    if (attr->dynWidth != 0 && attr->dynPrecision != 0) {
 8017308:	68fb      	ldr	r3, [r7, #12]
 801730a:	6a1b      	ldr	r3, [r3, #32]
 801730c:	2b00      	cmp	r3, #0
 801730e:	d015      	beq.n	801733c <SecFormatDouble+0x5c>
 8017310:	68fb      	ldr	r3, [r7, #12]
 8017312:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017314:	2b00      	cmp	r3, #0
 8017316:	d011      	beq.n	801733c <SecFormatDouble+0x5c>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, attr->precision, dValue);
 8017318:	68fb      	ldr	r3, [r7, #12]
 801731a:	6858      	ldr	r0, [r3, #4]
 801731c:	68bb      	ldr	r3, [r7, #8]
 801731e:	6919      	ldr	r1, [r3, #16]
 8017320:	68fb      	ldr	r3, [r7, #12]
 8017322:	69dc      	ldr	r4, [r3, #28]
 8017324:	e9d7 2300 	ldrd	r2, r3, [r7]
 8017328:	e9cd 2300 	strd	r2, r3, [sp]
 801732c:	4623      	mov	r3, r4
 801732e:	697a      	ldr	r2, [r7, #20]
 8017330:	f7ff ff3e 	bl	80171b0 <SecFormatFloat>
 8017334:	4602      	mov	r2, r0
 8017336:	68fb      	ldr	r3, [r7, #12]
 8017338:	609a      	str	r2, [r3, #8]
 801733a:	e032      	b.n	80173a2 <SecFormatDouble+0xc2>
    } else if (attr->dynWidth != 0) {
 801733c:	68fb      	ldr	r3, [r7, #12]
 801733e:	6a1b      	ldr	r3, [r3, #32]
 8017340:	2b00      	cmp	r3, #0
 8017342:	d00e      	beq.n	8017362 <SecFormatDouble+0x82>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, fldWidth, dValue);
 8017344:	68fb      	ldr	r3, [r7, #12]
 8017346:	6858      	ldr	r0, [r3, #4]
 8017348:	68bb      	ldr	r3, [r7, #8]
 801734a:	6919      	ldr	r1, [r3, #16]
 801734c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8017350:	e9cd 2300 	strd	r2, r3, [sp]
 8017354:	697a      	ldr	r2, [r7, #20]
 8017356:	f7ff ff2b 	bl	80171b0 <SecFormatFloat>
 801735a:	4602      	mov	r2, r0
 801735c:	68fb      	ldr	r3, [r7, #12]
 801735e:	609a      	str	r2, [r3, #8]
 8017360:	e01f      	b.n	80173a2 <SecFormatDouble+0xc2>
    } else if (attr->dynPrecision != 0) {
 8017362:	68fb      	ldr	r3, [r7, #12]
 8017364:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8017366:	2b00      	cmp	r3, #0
 8017368:	d010      	beq.n	801738c <SecFormatDouble+0xac>
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, attr->precision, dValue);
 801736a:	68fb      	ldr	r3, [r7, #12]
 801736c:	6858      	ldr	r0, [r3, #4]
 801736e:	68bb      	ldr	r3, [r7, #8]
 8017370:	6919      	ldr	r1, [r3, #16]
 8017372:	68fb      	ldr	r3, [r7, #12]
 8017374:	69dc      	ldr	r4, [r3, #28]
 8017376:	e9d7 2300 	ldrd	r2, r3, [r7]
 801737a:	e9cd 2300 	strd	r2, r3, [sp]
 801737e:	4622      	mov	r2, r4
 8017380:	f7ff ff16 	bl	80171b0 <SecFormatFloat>
 8017384:	4602      	mov	r2, r0
 8017386:	68fb      	ldr	r3, [r7, #12]
 8017388:	609a      	str	r2, [r3, #8]
 801738a:	e00a      	b.n	80173a2 <SecFormatDouble+0xc2>
    } else {
        attr->textLen = SecFormatFloat(attr->text.str, floatAdapt->fmtStr, dValue);
 801738c:	68fb      	ldr	r3, [r7, #12]
 801738e:	6858      	ldr	r0, [r3, #4]
 8017390:	68bb      	ldr	r3, [r7, #8]
 8017392:	6919      	ldr	r1, [r3, #16]
 8017394:	e9d7 2300 	ldrd	r2, r3, [r7]
 8017398:	f7ff ff0a 	bl	80171b0 <SecFormatFloat>
 801739c:	4602      	mov	r2, r0
 801739e:	68fb      	ldr	r3, [r7, #12]
 80173a0:	609a      	str	r2, [r3, #8]
    }
    if (attr->textLen < 0 || attr->textLen >= floatAdapt->bufferSize) {
 80173a2:	68fb      	ldr	r3, [r7, #12]
 80173a4:	689b      	ldr	r3, [r3, #8]
 80173a6:	2b00      	cmp	r3, #0
 80173a8:	db05      	blt.n	80173b6 <SecFormatDouble+0xd6>
 80173aa:	68fb      	ldr	r3, [r7, #12]
 80173ac:	689a      	ldr	r2, [r3, #8]
 80173ae:	68bb      	ldr	r3, [r7, #8]
 80173b0:	69db      	ldr	r3, [r3, #28]
 80173b2:	429a      	cmp	r2, r3
 80173b4:	db02      	blt.n	80173bc <SecFormatDouble+0xdc>
        attr->textLen = 0;
 80173b6:	68fb      	ldr	r3, [r7, #12]
 80173b8:	2200      	movs	r2, #0
 80173ba:	609a      	str	r2, [r3, #8]
    }
}
 80173bc:	bf00      	nop
 80173be:	371c      	adds	r7, #28
 80173c0:	46bd      	mov	sp, r7
 80173c2:	bd90      	pop	{r4, r7, pc}

080173c4 <SecIsSameSize>:
#endif

#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
/* To clear e506 warning */
SECUREC_INLINE int SecIsSameSize(size_t sizeA, size_t sizeB)
{
 80173c4:	b480      	push	{r7}
 80173c6:	b083      	sub	sp, #12
 80173c8:	af00      	add	r7, sp, #0
 80173ca:	6078      	str	r0, [r7, #4]
 80173cc:	6039      	str	r1, [r7, #0]
    return (int)(sizeA == sizeB);
 80173ce:	687a      	ldr	r2, [r7, #4]
 80173d0:	683b      	ldr	r3, [r7, #0]
 80173d2:	429a      	cmp	r2, r3
 80173d4:	bf0c      	ite	eq
 80173d6:	2301      	moveq	r3, #1
 80173d8:	2300      	movne	r3, #0
 80173da:	b2db      	uxtb	r3, r3
}
 80173dc:	4618      	mov	r0, r3
 80173de:	370c      	adds	r7, #12
 80173e0:	46bd      	mov	sp, r7
 80173e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80173e6:	4770      	bx	lr

080173e8 <SecNumber32ToOctalString>:
/*
 * Compiler Optimized Division 8.
 * The text.str point to buffer end, must be Large enough
 */
SECUREC_INLINE void SecNumber32ToOctalString(SecUnsignedInt32 number, SecFormatAttr *attr)
{
 80173e8:	b480      	push	{r7}
 80173ea:	b085      	sub	sp, #20
 80173ec:	af00      	add	r7, sp, #0
 80173ee:	6078      	str	r0, [r7, #4]
 80173f0:	6039      	str	r1, [r7, #0]
    SecUnsignedInt32 val32 = number;
 80173f2:	687b      	ldr	r3, [r7, #4]
 80173f4:	60fb      	str	r3, [r7, #12]
    do {
        --attr->text.str;
 80173f6:	683b      	ldr	r3, [r7, #0]
 80173f8:	685b      	ldr	r3, [r3, #4]
 80173fa:	1e5a      	subs	r2, r3, #1
 80173fc:	683b      	ldr	r3, [r7, #0]
 80173fe:	605a      	str	r2, [r3, #4]
        /* Just use lowerDigits for 0 - 9 */
        *(attr->text.str) = g_itoaLowerDigits[val32 % SECUREC_RADIX_OCTAL];
 8017400:	68fb      	ldr	r3, [r7, #12]
 8017402:	f003 0207 	and.w	r2, r3, #7
 8017406:	683b      	ldr	r3, [r7, #0]
 8017408:	685b      	ldr	r3, [r3, #4]
 801740a:	4908      	ldr	r1, [pc, #32]	; (801742c <SecNumber32ToOctalString+0x44>)
 801740c:	5c8a      	ldrb	r2, [r1, r2]
 801740e:	701a      	strb	r2, [r3, #0]
        val32 /= SECUREC_RADIX_OCTAL;
 8017410:	68fb      	ldr	r3, [r7, #12]
 8017412:	08db      	lsrs	r3, r3, #3
 8017414:	60fb      	str	r3, [r7, #12]
    } while (val32 != 0);
 8017416:	68fb      	ldr	r3, [r7, #12]
 8017418:	2b00      	cmp	r3, #0
 801741a:	d1ec      	bne.n	80173f6 <SecNumber32ToOctalString+0xe>
}
 801741c:	bf00      	nop
 801741e:	bf00      	nop
 8017420:	3714      	adds	r7, #20
 8017422:	46bd      	mov	sp, r7
 8017424:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017428:	4770      	bx	lr
 801742a:	bf00      	nop
 801742c:	080236ac 	.word	0x080236ac

08017430 <SecNumber32ToHexString>:
/*
 * Compiler Optimized Division 16.
 * The text.str point to buffer end, must be Large enough
 */
SECUREC_INLINE void SecNumber32ToHexString(SecUnsignedInt32 number, SecFormatAttr *attr)
{
 8017430:	b480      	push	{r7}
 8017432:	b085      	sub	sp, #20
 8017434:	af00      	add	r7, sp, #0
 8017436:	6078      	str	r0, [r7, #4]
 8017438:	6039      	str	r1, [r7, #0]
    SecUnsignedInt32 val32 = number;
 801743a:	687b      	ldr	r3, [r7, #4]
 801743c:	60fb      	str	r3, [r7, #12]
    do {
        --attr->text.str;
 801743e:	683b      	ldr	r3, [r7, #0]
 8017440:	685b      	ldr	r3, [r3, #4]
 8017442:	1e5a      	subs	r2, r3, #1
 8017444:	683b      	ldr	r3, [r7, #0]
 8017446:	605a      	str	r2, [r3, #4]
        *(attr->text.str) = attr->digits[val32 % SECUREC_RADIX_HEX];
 8017448:	683b      	ldr	r3, [r7, #0]
 801744a:	681a      	ldr	r2, [r3, #0]
 801744c:	68fb      	ldr	r3, [r7, #12]
 801744e:	f003 030f 	and.w	r3, r3, #15
 8017452:	441a      	add	r2, r3
 8017454:	683b      	ldr	r3, [r7, #0]
 8017456:	685b      	ldr	r3, [r3, #4]
 8017458:	7812      	ldrb	r2, [r2, #0]
 801745a:	701a      	strb	r2, [r3, #0]
        val32 /= SECUREC_RADIX_HEX;
 801745c:	68fb      	ldr	r3, [r7, #12]
 801745e:	091b      	lsrs	r3, r3, #4
 8017460:	60fb      	str	r3, [r7, #12]
    } while (val32 != 0);
 8017462:	68fb      	ldr	r3, [r7, #12]
 8017464:	2b00      	cmp	r3, #0
 8017466:	d1ea      	bne.n	801743e <SecNumber32ToHexString+0xe>
}
 8017468:	bf00      	nop
 801746a:	bf00      	nop
 801746c:	3714      	adds	r7, #20
 801746e:	46bd      	mov	sp, r7
 8017470:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017474:	4770      	bx	lr
	...

08017478 <SecNumber32ToDecStringFast>:

#ifndef _AIX
/* Use fast div 10 */
SECUREC_INLINE void SecNumber32ToDecStringFast(SecUnsignedInt32 number, SecFormatAttr *attr)
{
 8017478:	b480      	push	{r7}
 801747a:	b087      	sub	sp, #28
 801747c:	af00      	add	r7, sp, #0
 801747e:	6078      	str	r0, [r7, #4]
 8017480:	6039      	str	r1, [r7, #0]
    SecUnsignedInt32 val32 = number;
 8017482:	687b      	ldr	r3, [r7, #4]
 8017484:	60fb      	str	r3, [r7, #12]
    do {
        SecUnsignedInt32 quotient;
        SecUnsignedInt32 remain;
        --attr->text.str;
 8017486:	683b      	ldr	r3, [r7, #0]
 8017488:	685b      	ldr	r3, [r3, #4]
 801748a:	1e5a      	subs	r2, r3, #1
 801748c:	683b      	ldr	r3, [r7, #0]
 801748e:	605a      	str	r2, [r3, #4]
        *(attr->text.str) = g_itoaLowerDigits[val32 % SECUREC_RADIX_DECIMAL];
 8017490:	68f9      	ldr	r1, [r7, #12]
 8017492:	4b20      	ldr	r3, [pc, #128]	; (8017514 <SecNumber32ToDecStringFast+0x9c>)
 8017494:	fba3 2301 	umull	r2, r3, r3, r1
 8017498:	08da      	lsrs	r2, r3, #3
 801749a:	4613      	mov	r3, r2
 801749c:	009b      	lsls	r3, r3, #2
 801749e:	4413      	add	r3, r2
 80174a0:	005b      	lsls	r3, r3, #1
 80174a2:	1aca      	subs	r2, r1, r3
 80174a4:	683b      	ldr	r3, [r7, #0]
 80174a6:	685b      	ldr	r3, [r3, #4]
 80174a8:	491b      	ldr	r1, [pc, #108]	; (8017518 <SecNumber32ToDecStringFast+0xa0>)
 80174aa:	5c8a      	ldrb	r2, [r1, r2]
 80174ac:	701a      	strb	r2, [r3, #0]
        quotient = (val32 >> 1U) + (val32 >> 2U); /* Fast div  magic 2 */
 80174ae:	68fb      	ldr	r3, [r7, #12]
 80174b0:	085a      	lsrs	r2, r3, #1
 80174b2:	68fb      	ldr	r3, [r7, #12]
 80174b4:	089b      	lsrs	r3, r3, #2
 80174b6:	4413      	add	r3, r2
 80174b8:	613b      	str	r3, [r7, #16]
        quotient = quotient + (quotient >> 4U); /* Fast div  magic 4 */
 80174ba:	693b      	ldr	r3, [r7, #16]
 80174bc:	091b      	lsrs	r3, r3, #4
 80174be:	693a      	ldr	r2, [r7, #16]
 80174c0:	4413      	add	r3, r2
 80174c2:	613b      	str	r3, [r7, #16]
        quotient = quotient + (quotient >> 8U); /* Fast div  magic 8 */
 80174c4:	693b      	ldr	r3, [r7, #16]
 80174c6:	0a1b      	lsrs	r3, r3, #8
 80174c8:	693a      	ldr	r2, [r7, #16]
 80174ca:	4413      	add	r3, r2
 80174cc:	613b      	str	r3, [r7, #16]
        quotient = quotient + (quotient >> 16U); /* Fast div  magic 16 */
 80174ce:	693b      	ldr	r3, [r7, #16]
 80174d0:	0c1b      	lsrs	r3, r3, #16
 80174d2:	693a      	ldr	r2, [r7, #16]
 80174d4:	4413      	add	r3, r2
 80174d6:	613b      	str	r3, [r7, #16]
        quotient = quotient >> 3U; /* Fast div  magic 3 */
 80174d8:	693b      	ldr	r3, [r7, #16]
 80174da:	08db      	lsrs	r3, r3, #3
 80174dc:	613b      	str	r3, [r7, #16]
        remain = val32 - SECUREC_MUL_TEN(quotient);
 80174de:	693b      	ldr	r3, [r7, #16]
 80174e0:	009a      	lsls	r2, r3, #2
 80174e2:	693b      	ldr	r3, [r7, #16]
 80174e4:	4413      	add	r3, r2
 80174e6:	005b      	lsls	r3, r3, #1
 80174e8:	68fa      	ldr	r2, [r7, #12]
 80174ea:	1ad3      	subs	r3, r2, r3
 80174ec:	617b      	str	r3, [r7, #20]
        val32 = (remain > 9U) ? (quotient + 1U) : quotient; /* Fast div  magic 9 */
 80174ee:	697b      	ldr	r3, [r7, #20]
 80174f0:	2b09      	cmp	r3, #9
 80174f2:	d902      	bls.n	80174fa <SecNumber32ToDecStringFast+0x82>
 80174f4:	693b      	ldr	r3, [r7, #16]
 80174f6:	3301      	adds	r3, #1
 80174f8:	e000      	b.n	80174fc <SecNumber32ToDecStringFast+0x84>
 80174fa:	693b      	ldr	r3, [r7, #16]
 80174fc:	60fb      	str	r3, [r7, #12]
    } while (val32 != 0);
 80174fe:	68fb      	ldr	r3, [r7, #12]
 8017500:	2b00      	cmp	r3, #0
 8017502:	d1c0      	bne.n	8017486 <SecNumber32ToDecStringFast+0xe>
}
 8017504:	bf00      	nop
 8017506:	bf00      	nop
 8017508:	371c      	adds	r7, #28
 801750a:	46bd      	mov	sp, r7
 801750c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017510:	4770      	bx	lr
 8017512:	bf00      	nop
 8017514:	cccccccd 	.word	0xcccccccd
 8017518:	080236ac 	.word	0x080236ac

0801751c <SecNumber32ToString>:
#endif

SECUREC_INLINE void SecNumber32ToString(SecUnsignedInt32 number, SecFormatAttr *attr)
{
 801751c:	b580      	push	{r7, lr}
 801751e:	b082      	sub	sp, #8
 8017520:	af00      	add	r7, sp, #0
 8017522:	6078      	str	r0, [r7, #4]
 8017524:	6039      	str	r1, [r7, #0]
    switch (attr->radix) {
 8017526:	683b      	ldr	r3, [r7, #0]
 8017528:	691b      	ldr	r3, [r3, #16]
 801752a:	2b10      	cmp	r3, #16
 801752c:	d006      	beq.n	801753c <SecNumber32ToString+0x20>
 801752e:	2b10      	cmp	r3, #16
 8017530:	d813      	bhi.n	801755a <SecNumber32ToString+0x3e>
 8017532:	2b08      	cmp	r3, #8
 8017534:	d007      	beq.n	8017546 <SecNumber32ToString+0x2a>
 8017536:	2b0a      	cmp	r3, #10
 8017538:	d00a      	beq.n	8017550 <SecNumber32ToString+0x34>
            SecNumber32ToDecStringFast(number, attr);
#endif
            break;
        default:
            /* Do nothing */
            break;
 801753a:	e00e      	b.n	801755a <SecNumber32ToString+0x3e>
            SecNumber32ToHexString(number, attr);
 801753c:	6839      	ldr	r1, [r7, #0]
 801753e:	6878      	ldr	r0, [r7, #4]
 8017540:	f7ff ff76 	bl	8017430 <SecNumber32ToHexString>
            break;
 8017544:	e00a      	b.n	801755c <SecNumber32ToString+0x40>
            SecNumber32ToOctalString(number, attr);
 8017546:	6839      	ldr	r1, [r7, #0]
 8017548:	6878      	ldr	r0, [r7, #4]
 801754a:	f7ff ff4d 	bl	80173e8 <SecNumber32ToOctalString>
            break;
 801754e:	e005      	b.n	801755c <SecNumber32ToString+0x40>
            SecNumber32ToDecStringFast(number, attr);
 8017550:	6839      	ldr	r1, [r7, #0]
 8017552:	6878      	ldr	r0, [r7, #4]
 8017554:	f7ff ff90 	bl	8017478 <SecNumber32ToDecStringFast>
            break;
 8017558:	e000      	b.n	801755c <SecNumber32ToString+0x40>
            break;
 801755a:	bf00      	nop
    }
}
 801755c:	bf00      	nop
 801755e:	3708      	adds	r7, #8
 8017560:	46bd      	mov	sp, r7
 8017562:	bd80      	pop	{r7, pc}

08017564 <SecNumber64ToDecString>:
/*
 * Compiler Optimized Division 10.
 * The text.str point to buffer end, must be Large enough
 */
SECUREC_INLINE void SecNumber64ToDecString(SecUnsignedInt64 number, SecFormatAttr *attr)
{
 8017564:	b580      	push	{r7, lr}
 8017566:	b086      	sub	sp, #24
 8017568:	af00      	add	r7, sp, #0
 801756a:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801756e:	607a      	str	r2, [r7, #4]
    SecUnsignedInt64 val64 = number;
 8017570:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8017574:	e9c7 2304 	strd	r2, r3, [r7, #16]
    do {
        --attr->text.str;
 8017578:	687b      	ldr	r3, [r7, #4]
 801757a:	685b      	ldr	r3, [r3, #4]
 801757c:	1e5a      	subs	r2, r3, #1
 801757e:	687b      	ldr	r3, [r7, #4]
 8017580:	605a      	str	r2, [r3, #4]
        /* Just use lowerDigits for 0 - 9 */
        *(attr->text.str) = g_itoaLowerDigits[val64 % SECUREC_RADIX_DECIMAL];
 8017582:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8017586:	f04f 020a 	mov.w	r2, #10
 801758a:	f04f 0300 	mov.w	r3, #0
 801758e:	f7e9 fa01 	bl	8000994 <__aeabi_uldivmod>
 8017592:	6879      	ldr	r1, [r7, #4]
 8017594:	6849      	ldr	r1, [r1, #4]
 8017596:	480c      	ldr	r0, [pc, #48]	; (80175c8 <SecNumber64ToDecString+0x64>)
 8017598:	1883      	adds	r3, r0, r2
 801759a:	781b      	ldrb	r3, [r3, #0]
 801759c:	700b      	strb	r3, [r1, #0]
        val64 /= SECUREC_RADIX_DECIMAL;
 801759e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80175a2:	f04f 020a 	mov.w	r2, #10
 80175a6:	f04f 0300 	mov.w	r3, #0
 80175aa:	f7e9 f9f3 	bl	8000994 <__aeabi_uldivmod>
 80175ae:	4602      	mov	r2, r0
 80175b0:	460b      	mov	r3, r1
 80175b2:	e9c7 2304 	strd	r2, r3, [r7, #16]
    } while (val64 != 0);
 80175b6:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80175ba:	4313      	orrs	r3, r2
 80175bc:	d1dc      	bne.n	8017578 <SecNumber64ToDecString+0x14>
}
 80175be:	bf00      	nop
 80175c0:	bf00      	nop
 80175c2:	3718      	adds	r7, #24
 80175c4:	46bd      	mov	sp, r7
 80175c6:	bd80      	pop	{r7, pc}
 80175c8:	080236ac 	.word	0x080236ac

080175cc <SecNumber64ToOctalString>:
/*
 * Compiler Optimized Division 8.
 * The text.str point to buffer end, must be Large enough
 */
SECUREC_INLINE void SecNumber64ToOctalString(SecUnsignedInt64 number, SecFormatAttr *attr)
{
 80175cc:	b4b0      	push	{r4, r5, r7}
 80175ce:	b087      	sub	sp, #28
 80175d0:	af00      	add	r7, sp, #0
 80175d2:	e9c7 0102 	strd	r0, r1, [r7, #8]
 80175d6:	607a      	str	r2, [r7, #4]
    SecUnsignedInt64 val64 = number;
 80175d8:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80175dc:	e9c7 2304 	strd	r2, r3, [r7, #16]
    do {
        --attr->text.str;
 80175e0:	687b      	ldr	r3, [r7, #4]
 80175e2:	685b      	ldr	r3, [r3, #4]
 80175e4:	1e5a      	subs	r2, r3, #1
 80175e6:	687b      	ldr	r3, [r7, #4]
 80175e8:	605a      	str	r2, [r3, #4]
        /* Just use lowerDigits for 0 - 9 */
        *(attr->text.str) = g_itoaLowerDigits[val64 % SECUREC_RADIX_OCTAL];
 80175ea:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80175ee:	f04f 0007 	mov.w	r0, #7
 80175f2:	f04f 0100 	mov.w	r1, #0
 80175f6:	ea02 0400 	and.w	r4, r2, r0
 80175fa:	ea03 0501 	and.w	r5, r3, r1
 80175fe:	687b      	ldr	r3, [r7, #4]
 8017600:	685b      	ldr	r3, [r3, #4]
 8017602:	4a0d      	ldr	r2, [pc, #52]	; (8017638 <SecNumber64ToOctalString+0x6c>)
 8017604:	4422      	add	r2, r4
 8017606:	7812      	ldrb	r2, [r2, #0]
 8017608:	701a      	strb	r2, [r3, #0]
        val64 /= SECUREC_RADIX_OCTAL;
 801760a:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801760e:	f04f 0200 	mov.w	r2, #0
 8017612:	f04f 0300 	mov.w	r3, #0
 8017616:	08c2      	lsrs	r2, r0, #3
 8017618:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
 801761c:	08cb      	lsrs	r3, r1, #3
 801761e:	e9c7 2304 	strd	r2, r3, [r7, #16]
    } while (val64 != 0);
 8017622:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8017626:	4313      	orrs	r3, r2
 8017628:	d1da      	bne.n	80175e0 <SecNumber64ToOctalString+0x14>
}
 801762a:	bf00      	nop
 801762c:	bf00      	nop
 801762e:	371c      	adds	r7, #28
 8017630:	46bd      	mov	sp, r7
 8017632:	bcb0      	pop	{r4, r5, r7}
 8017634:	4770      	bx	lr
 8017636:	bf00      	nop
 8017638:	080236ac 	.word	0x080236ac

0801763c <SecNumber64ToHexString>:
/*
 * Compiler Optimized Division 16.
 * The text.str point to buffer end, must be Large enough
 */
SECUREC_INLINE void SecNumber64ToHexString(SecUnsignedInt64 number, SecFormatAttr *attr)
{
 801763c:	b480      	push	{r7}
 801763e:	b087      	sub	sp, #28
 8017640:	af00      	add	r7, sp, #0
 8017642:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8017646:	607a      	str	r2, [r7, #4]
    SecUnsignedInt64 val64 = number;
 8017648:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801764c:	e9c7 2304 	strd	r2, r3, [r7, #16]
    do {
        --attr->text.str;
 8017650:	687b      	ldr	r3, [r7, #4]
 8017652:	685b      	ldr	r3, [r3, #4]
 8017654:	1e5a      	subs	r2, r3, #1
 8017656:	687b      	ldr	r3, [r7, #4]
 8017658:	605a      	str	r2, [r3, #4]
        *(attr->text.str) = attr->digits[val64 % SECUREC_RADIX_HEX];
 801765a:	687b      	ldr	r3, [r7, #4]
 801765c:	681a      	ldr	r2, [r3, #0]
 801765e:	693b      	ldr	r3, [r7, #16]
 8017660:	f003 030f 	and.w	r3, r3, #15
 8017664:	441a      	add	r2, r3
 8017666:	687b      	ldr	r3, [r7, #4]
 8017668:	685b      	ldr	r3, [r3, #4]
 801766a:	7812      	ldrb	r2, [r2, #0]
 801766c:	701a      	strb	r2, [r3, #0]
        val64 /= SECUREC_RADIX_HEX;
 801766e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8017672:	f04f 0200 	mov.w	r2, #0
 8017676:	f04f 0300 	mov.w	r3, #0
 801767a:	0902      	lsrs	r2, r0, #4
 801767c:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 8017680:	090b      	lsrs	r3, r1, #4
 8017682:	e9c7 2304 	strd	r2, r3, [r7, #16]
    } while (val64 != 0);
 8017686:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801768a:	4313      	orrs	r3, r2
 801768c:	d1e0      	bne.n	8017650 <SecNumber64ToHexString+0x14>
}
 801768e:	bf00      	nop
 8017690:	bf00      	nop
 8017692:	371c      	adds	r7, #28
 8017694:	46bd      	mov	sp, r7
 8017696:	f85d 7b04 	ldr.w	r7, [sp], #4
 801769a:	4770      	bx	lr

0801769c <SecNumber64ToString>:

SECUREC_INLINE void SecNumber64ToString(SecUnsignedInt64 number, SecFormatAttr *attr)
{
 801769c:	b580      	push	{r7, lr}
 801769e:	b084      	sub	sp, #16
 80176a0:	af00      	add	r7, sp, #0
 80176a2:	e9c7 0102 	strd	r0, r1, [r7, #8]
 80176a6:	607a      	str	r2, [r7, #4]
    switch (attr->radix) {
 80176a8:	687b      	ldr	r3, [r7, #4]
 80176aa:	691b      	ldr	r3, [r3, #16]
 80176ac:	2b10      	cmp	r3, #16
 80176ae:	d011      	beq.n	80176d4 <SecNumber64ToString+0x38>
 80176b0:	2b10      	cmp	r3, #16
 80176b2:	d815      	bhi.n	80176e0 <SecNumber64ToString+0x44>
 80176b4:	2b08      	cmp	r3, #8
 80176b6:	d007      	beq.n	80176c8 <SecNumber64ToString+0x2c>
 80176b8:	2b0a      	cmp	r3, #10
 80176ba:	d111      	bne.n	80176e0 <SecNumber64ToString+0x44>
        /* The compiler will optimize div 10 */
        case SECUREC_RADIX_DECIMAL:
            SecNumber64ToDecString(number, attr);
 80176bc:	687a      	ldr	r2, [r7, #4]
 80176be:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 80176c2:	f7ff ff4f 	bl	8017564 <SecNumber64ToDecString>
            break;
 80176c6:	e00c      	b.n	80176e2 <SecNumber64ToString+0x46>
        case SECUREC_RADIX_OCTAL:
            SecNumber64ToOctalString(number, attr);
 80176c8:	687a      	ldr	r2, [r7, #4]
 80176ca:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 80176ce:	f7ff ff7d 	bl	80175cc <SecNumber64ToOctalString>
            break;
 80176d2:	e006      	b.n	80176e2 <SecNumber64ToString+0x46>
        case SECUREC_RADIX_HEX:
            SecNumber64ToHexString(number, attr);
 80176d4:	687a      	ldr	r2, [r7, #4]
 80176d6:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 80176da:	f7ff ffaf 	bl	801763c <SecNumber64ToHexString>
            break;
 80176de:	e000      	b.n	80176e2 <SecNumber64ToString+0x46>
        default:
            /* Do nothing */
            break;
 80176e0:	bf00      	nop
    }
}
 80176e2:	bf00      	nop
 80176e4:	3710      	adds	r7, #16
 80176e6:	46bd      	mov	sp, r7
 80176e8:	bd80      	pop	{r7, pc}

080176ea <SecNumberToString>:

/*
 * Converting integers to string
 */
SECUREC_INLINE void SecNumberToString(SecUnsignedInt64 number, SecFormatAttr *attr)
{
 80176ea:	b580      	push	{r7, lr}
 80176ec:	b086      	sub	sp, #24
 80176ee:	af00      	add	r7, sp, #0
 80176f0:	e9c7 0102 	strd	r0, r1, [r7, #8]
 80176f4:	607a      	str	r2, [r7, #4]
#ifdef SECUREC_ON_64BITS
    SecNumber64ToString(number, attr);
#else /* For 32 bits system */
    if (number <= 0xffffffffUL) { /* Use 0xffffffffUL to check if the value is in the 32-bit range */
 80176f6:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80176fa:	2b01      	cmp	r3, #1
 80176fc:	bf08      	it	eq
 80176fe:	2a00      	cmpeq	r2, #0
 8017700:	d206      	bcs.n	8017710 <SecNumberToString+0x26>
        /* In most case, the value to be converted is small value */
        SecUnsignedInt32 n32Tmp = (SecUnsignedInt32)number;
 8017702:	68bb      	ldr	r3, [r7, #8]
 8017704:	617b      	str	r3, [r7, #20]
        SecNumber32ToString(n32Tmp, attr);
 8017706:	6879      	ldr	r1, [r7, #4]
 8017708:	6978      	ldr	r0, [r7, #20]
 801770a:	f7ff ff07 	bl	801751c <SecNumber32ToString>
#else
        SecNumber64ToString(number, attr);
#endif
    }
#endif
}
 801770e:	e004      	b.n	801771a <SecNumberToString+0x30>
        SecNumber64ToString(number, attr);
 8017710:	687a      	ldr	r2, [r7, #4]
 8017712:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8017716:	f7ff ffc1 	bl	801769c <SecNumber64ToString>
}
 801771a:	bf00      	nop
 801771c:	3718      	adds	r7, #24
 801771e:	46bd      	mov	sp, r7
 8017720:	bd80      	pop	{r7, pc}

08017722 <SecIsNumberNeedTo32Bit>:

SECUREC_INLINE int SecIsNumberNeedTo32Bit(const SecFormatAttr *attr)
{
 8017722:	b480      	push	{r7}
 8017724:	b083      	sub	sp, #12
 8017726:	af00      	add	r7, sp, #0
 8017728:	6078      	str	r0, [r7, #4]
    return (int)(((attr->flags & SECUREC_FLAG_I64) == 0) &&
 801772a:	687b      	ldr	r3, [r7, #4]
 801772c:	695b      	ldr	r3, [r3, #20]
 801772e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8017732:	2b00      	cmp	r3, #0
 8017734:	d10d      	bne.n	8017752 <SecIsNumberNeedTo32Bit+0x30>
#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
            ((attr->flags & SECUREC_FLAG_INTMAX) == 0) &&
 8017736:	687b      	ldr	r3, [r7, #4]
 8017738:	695b      	ldr	r3, [r3, #20]
 801773a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
    return (int)(((attr->flags & SECUREC_FLAG_I64) == 0) &&
 801773e:	2b00      	cmp	r3, #0
 8017740:	d107      	bne.n	8017752 <SecIsNumberNeedTo32Bit+0x30>
            ((attr->flags & SECUREC_FLAG_SIZE) == 0) &&
#if !defined(SECUREC_COMPATIBLE_WIN_FORMAT)  /* on window 64 system sizeof long is 32bit */
            ((attr->flags & SECUREC_FLAG_LONG) == 0) &&
#endif
#endif
            ((attr->flags & SECUREC_FLAG_LONGLONG) == 0));
 8017742:	687b      	ldr	r3, [r7, #4]
 8017744:	695b      	ldr	r3, [r3, #20]
 8017746:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    return (int)(((attr->flags & SECUREC_FLAG_I64) == 0) &&
 801774a:	2b00      	cmp	r3, #0
 801774c:	d101      	bne.n	8017752 <SecIsNumberNeedTo32Bit+0x30>
 801774e:	2301      	movs	r3, #1
 8017750:	e000      	b.n	8017754 <SecIsNumberNeedTo32Bit+0x32>
 8017752:	2300      	movs	r3, #0
}
 8017754:	4618      	mov	r0, r3
 8017756:	370c      	adds	r7, #12
 8017758:	46bd      	mov	sp, r7
 801775a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801775e:	4770      	bx	lr

08017760 <SecNumberToBuffer>:

SECUREC_INLINE void SecNumberToBuffer(SecFormatAttr *attr, SecInt64 num64)
{
 8017760:	b5b0      	push	{r4, r5, r7, lr}
 8017762:	b086      	sub	sp, #24
 8017764:	af00      	add	r7, sp, #0
 8017766:	60f8      	str	r0, [r7, #12]
 8017768:	e9c7 2300 	strd	r2, r3, [r7]
    SecUnsignedInt64 number;
    /* Check for negative; copy into number */
    if ((attr->flags & SECUREC_FLAG_SIGNED) != 0 && num64 < 0) {
 801776c:	68fb      	ldr	r3, [r7, #12]
 801776e:	695b      	ldr	r3, [r3, #20]
 8017770:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8017774:	2b00      	cmp	r3, #0
 8017776:	d013      	beq.n	80177a0 <SecNumberToBuffer+0x40>
 8017778:	e9d7 2300 	ldrd	r2, r3, [r7]
 801777c:	2a00      	cmp	r2, #0
 801777e:	f173 0300 	sbcs.w	r3, r3, #0
 8017782:	da0d      	bge.n	80177a0 <SecNumberToBuffer+0x40>
        number = (SecUnsignedInt64)(0 - (SecUnsignedInt64)num64); /* Wrap with unsigned int64 numbers */
 8017784:	e9d7 2300 	ldrd	r2, r3, [r7]
 8017788:	4252      	negs	r2, r2
 801778a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 801778e:	e9c7 2304 	strd	r2, r3, [r7, #16]
        attr->flags |= SECUREC_FLAG_NEGATIVE;
 8017792:	68fb      	ldr	r3, [r7, #12]
 8017794:	695b      	ldr	r3, [r3, #20]
 8017796:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 801779a:	68fb      	ldr	r3, [r7, #12]
 801779c:	615a      	str	r2, [r3, #20]
 801779e:	e003      	b.n	80177a8 <SecNumberToBuffer+0x48>
    } else {
        number = (SecUnsignedInt64)num64;
 80177a0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80177a4:	e9c7 2304 	strd	r2, r3, [r7, #16]
    }
    if (SecIsNumberNeedTo32Bit(attr) != 0) {
 80177a8:	68f8      	ldr	r0, [r7, #12]
 80177aa:	f7ff ffba 	bl	8017722 <SecIsNumberNeedTo32Bit>
 80177ae:	4603      	mov	r3, r0
 80177b0:	2b00      	cmp	r3, #0
 80177b2:	d00b      	beq.n	80177cc <SecNumberToBuffer+0x6c>
        number = (number & (SecUnsignedInt64)0xffffffffUL);  /* Use 0xffffffff as 32 bit mask */
 80177b4:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80177b8:	f04f 30ff 	mov.w	r0, #4294967295
 80177bc:	f04f 0100 	mov.w	r1, #0
 80177c0:	ea02 0400 	and.w	r4, r2, r0
 80177c4:	ea03 0501 	and.w	r5, r3, r1
 80177c8:	e9c7 4504 	strd	r4, r5, [r7, #16]
    }

    /* The text.str must be point to buffer.str, this pointer is used outside the function */
    attr->text.str = &attr->buffer.str[SECUREC_BUFFER_SIZE];
 80177cc:	68fb      	ldr	r3, [r7, #12]
 80177ce:	f503 720d 	add.w	r2, r3, #564	; 0x234
 80177d2:	68fb      	ldr	r3, [r7, #12]
 80177d4:	605a      	str	r2, [r3, #4]

    if (number == 0) {
 80177d6:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 80177da:	4313      	orrs	r3, r2
 80177dc:	d106      	bne.n	80177ec <SecNumberToBuffer+0x8c>
        /* Turn off hex prefix default, and textLen is zero */
        attr->prefixLen = 0;
 80177de:	68fb      	ldr	r3, [r7, #12]
 80177e0:	2200      	movs	r2, #0
 80177e2:	62da      	str	r2, [r3, #44]	; 0x2c
        attr->textLen = 0;
 80177e4:	68fb      	ldr	r3, [r7, #12]
 80177e6:	2200      	movs	r2, #0
 80177e8:	609a      	str	r2, [r3, #8]
        return;
 80177ea:	e00c      	b.n	8017806 <SecNumberToBuffer+0xa6>
    }

    /* Convert integer to string. It must be invoked when number > 0, otherwise the following logic is incorrect */
    SecNumberToString(number, attr);
 80177ec:	68fa      	ldr	r2, [r7, #12]
 80177ee:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 80177f2:	f7ff ff7a 	bl	80176ea <SecNumberToString>
    /* Compute length of number,  text.str must be in buffer.str */
    attr->textLen = (int)(size_t)((char *)&attr->buffer.str[SECUREC_BUFFER_SIZE] - attr->text.str);
 80177f6:	68fb      	ldr	r3, [r7, #12]
 80177f8:	f503 720d 	add.w	r2, r3, #564	; 0x234
 80177fc:	68fb      	ldr	r3, [r7, #12]
 80177fe:	685b      	ldr	r3, [r3, #4]
 8017800:	1ad2      	subs	r2, r2, r3
 8017802:	68fb      	ldr	r3, [r7, #12]
 8017804:	609a      	str	r2, [r3, #8]
}
 8017806:	3718      	adds	r7, #24
 8017808:	46bd      	mov	sp, r7
 801780a:	bdb0      	pop	{r4, r5, r7, pc}

0801780c <SecWriteChar>:

/*
 * Write one character to dest buffer
 */
SECUREC_INLINE void SecWriteChar(SecPrintfStream *stream, SecChar ch, int *charsOut)
{
 801780c:	b480      	push	{r7}
 801780e:	b085      	sub	sp, #20
 8017810:	af00      	add	r7, sp, #0
 8017812:	60f8      	str	r0, [r7, #12]
 8017814:	460b      	mov	r3, r1
 8017816:	607a      	str	r2, [r7, #4]
 8017818:	72fb      	strb	r3, [r7, #11]
    /* Count must be reduced first, In order to identify insufficient length */
    --stream->count;
 801781a:	68fb      	ldr	r3, [r7, #12]
 801781c:	681b      	ldr	r3, [r3, #0]
 801781e:	1e5a      	subs	r2, r3, #1
 8017820:	68fb      	ldr	r3, [r7, #12]
 8017822:	601a      	str	r2, [r3, #0]
    if (stream->count >= 0) {
 8017824:	68fb      	ldr	r3, [r7, #12]
 8017826:	681b      	ldr	r3, [r3, #0]
 8017828:	2b00      	cmp	r3, #0
 801782a:	db0e      	blt.n	801784a <SecWriteChar+0x3e>
        *(stream->cur) = ch;
 801782c:	68fb      	ldr	r3, [r7, #12]
 801782e:	685b      	ldr	r3, [r3, #4]
 8017830:	7afa      	ldrb	r2, [r7, #11]
 8017832:	701a      	strb	r2, [r3, #0]
        ++stream->cur;
 8017834:	68fb      	ldr	r3, [r7, #12]
 8017836:	685b      	ldr	r3, [r3, #4]
 8017838:	1c5a      	adds	r2, r3, #1
 801783a:	68fb      	ldr	r3, [r7, #12]
 801783c:	605a      	str	r2, [r3, #4]
        *charsOut = *charsOut + 1;
 801783e:	687b      	ldr	r3, [r7, #4]
 8017840:	681b      	ldr	r3, [r3, #0]
 8017842:	1c5a      	adds	r2, r3, #1
 8017844:	687b      	ldr	r3, [r7, #4]
 8017846:	601a      	str	r2, [r3, #0]
        return;
 8017848:	e003      	b.n	8017852 <SecWriteChar+0x46>
    }
    /* No enough length */
    *charsOut = -1;
 801784a:	687b      	ldr	r3, [r7, #4]
 801784c:	f04f 32ff 	mov.w	r2, #4294967295
 8017850:	601a      	str	r2, [r3, #0]
}
 8017852:	3714      	adds	r7, #20
 8017854:	46bd      	mov	sp, r7
 8017856:	f85d 7b04 	ldr.w	r7, [sp], #4
 801785a:	4770      	bx	lr

0801785c <SecWriteMultiChar>:

/*
* Write multiple identical characters.
*/
SECUREC_INLINE void SecWriteMultiChar(SecPrintfStream *stream, SecChar ch, int num, int *charsOut)
{
 801785c:	b480      	push	{r7}
 801785e:	b087      	sub	sp, #28
 8017860:	af00      	add	r7, sp, #0
 8017862:	60f8      	str	r0, [r7, #12]
 8017864:	607a      	str	r2, [r7, #4]
 8017866:	603b      	str	r3, [r7, #0]
 8017868:	460b      	mov	r3, r1
 801786a:	72fb      	strb	r3, [r7, #11]
    int count;
    for (count = num; count > 0; --count) {
 801786c:	687b      	ldr	r3, [r7, #4]
 801786e:	617b      	str	r3, [r7, #20]
 8017870:	e019      	b.n	80178a6 <SecWriteMultiChar+0x4a>
        --stream->count; /* count may be negative,indicating insufficient space */
 8017872:	68fb      	ldr	r3, [r7, #12]
 8017874:	681b      	ldr	r3, [r3, #0]
 8017876:	1e5a      	subs	r2, r3, #1
 8017878:	68fb      	ldr	r3, [r7, #12]
 801787a:	601a      	str	r2, [r3, #0]
        if (stream->count < 0) {
 801787c:	68fb      	ldr	r3, [r7, #12]
 801787e:	681b      	ldr	r3, [r3, #0]
 8017880:	2b00      	cmp	r3, #0
 8017882:	da04      	bge.n	801788e <SecWriteMultiChar+0x32>
            *charsOut = -1;
 8017884:	683b      	ldr	r3, [r7, #0]
 8017886:	f04f 32ff 	mov.w	r2, #4294967295
 801788a:	601a      	str	r2, [r3, #0]
            return;
 801788c:	e014      	b.n	80178b8 <SecWriteMultiChar+0x5c>
        }
        *(stream->cur) = ch;
 801788e:	68fb      	ldr	r3, [r7, #12]
 8017890:	685b      	ldr	r3, [r3, #4]
 8017892:	7afa      	ldrb	r2, [r7, #11]
 8017894:	701a      	strb	r2, [r3, #0]
        ++stream->cur;
 8017896:	68fb      	ldr	r3, [r7, #12]
 8017898:	685b      	ldr	r3, [r3, #4]
 801789a:	1c5a      	adds	r2, r3, #1
 801789c:	68fb      	ldr	r3, [r7, #12]
 801789e:	605a      	str	r2, [r3, #4]
    for (count = num; count > 0; --count) {
 80178a0:	697b      	ldr	r3, [r7, #20]
 80178a2:	3b01      	subs	r3, #1
 80178a4:	617b      	str	r3, [r7, #20]
 80178a6:	697b      	ldr	r3, [r7, #20]
 80178a8:	2b00      	cmp	r3, #0
 80178aa:	dce2      	bgt.n	8017872 <SecWriteMultiChar+0x16>
    }
    *charsOut = *charsOut + num;
 80178ac:	683b      	ldr	r3, [r7, #0]
 80178ae:	681a      	ldr	r2, [r3, #0]
 80178b0:	687b      	ldr	r3, [r7, #4]
 80178b2:	441a      	add	r2, r3
 80178b4:	683b      	ldr	r3, [r7, #0]
 80178b6:	601a      	str	r2, [r3, #0]
}
 80178b8:	371c      	adds	r7, #28
 80178ba:	46bd      	mov	sp, r7
 80178bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80178c0:	4770      	bx	lr

080178c2 <SecWriteString>:

/*
* Write string function, where this function is called, make sure that len is greater than 0
*/
SECUREC_INLINE void SecWriteString(SecPrintfStream *stream, const SecChar *str, int len, int *charsOut)
{
 80178c2:	b480      	push	{r7}
 80178c4:	b087      	sub	sp, #28
 80178c6:	af00      	add	r7, sp, #0
 80178c8:	60f8      	str	r0, [r7, #12]
 80178ca:	60b9      	str	r1, [r7, #8]
 80178cc:	607a      	str	r2, [r7, #4]
 80178ce:	603b      	str	r3, [r7, #0]
    const SecChar *tmp = str;
 80178d0:	68bb      	ldr	r3, [r7, #8]
 80178d2:	613b      	str	r3, [r7, #16]
    int count;
    for (count = len; count > 0; --count) {
 80178d4:	687b      	ldr	r3, [r7, #4]
 80178d6:	617b      	str	r3, [r7, #20]
 80178d8:	e01d      	b.n	8017916 <SecWriteString+0x54>
        --stream->count; /* count may be negative,indicating insufficient space */
 80178da:	68fb      	ldr	r3, [r7, #12]
 80178dc:	681b      	ldr	r3, [r3, #0]
 80178de:	1e5a      	subs	r2, r3, #1
 80178e0:	68fb      	ldr	r3, [r7, #12]
 80178e2:	601a      	str	r2, [r3, #0]
        if (stream->count < 0) {
 80178e4:	68fb      	ldr	r3, [r7, #12]
 80178e6:	681b      	ldr	r3, [r3, #0]
 80178e8:	2b00      	cmp	r3, #0
 80178ea:	da04      	bge.n	80178f6 <SecWriteString+0x34>
            *charsOut = -1;
 80178ec:	683b      	ldr	r3, [r7, #0]
 80178ee:	f04f 32ff 	mov.w	r2, #4294967295
 80178f2:	601a      	str	r2, [r3, #0]
            return;
 80178f4:	e018      	b.n	8017928 <SecWriteString+0x66>
        }
        *(stream->cur) = *tmp;
 80178f6:	68fb      	ldr	r3, [r7, #12]
 80178f8:	685b      	ldr	r3, [r3, #4]
 80178fa:	693a      	ldr	r2, [r7, #16]
 80178fc:	7812      	ldrb	r2, [r2, #0]
 80178fe:	701a      	strb	r2, [r3, #0]
        ++stream->cur;
 8017900:	68fb      	ldr	r3, [r7, #12]
 8017902:	685b      	ldr	r3, [r3, #4]
 8017904:	1c5a      	adds	r2, r3, #1
 8017906:	68fb      	ldr	r3, [r7, #12]
 8017908:	605a      	str	r2, [r3, #4]
        ++tmp;
 801790a:	693b      	ldr	r3, [r7, #16]
 801790c:	3301      	adds	r3, #1
 801790e:	613b      	str	r3, [r7, #16]
    for (count = len; count > 0; --count) {
 8017910:	697b      	ldr	r3, [r7, #20]
 8017912:	3b01      	subs	r3, #1
 8017914:	617b      	str	r3, [r7, #20]
 8017916:	697b      	ldr	r3, [r7, #20]
 8017918:	2b00      	cmp	r3, #0
 801791a:	dcde      	bgt.n	80178da <SecWriteString+0x18>
    }
    *charsOut = *charsOut + len;
 801791c:	683b      	ldr	r3, [r7, #0]
 801791e:	681a      	ldr	r2, [r3, #0]
 8017920:	687b      	ldr	r3, [r7, #4]
 8017922:	441a      	add	r2, r3
 8017924:	683b      	ldr	r3, [r7, #0]
 8017926:	601a      	str	r2, [r3, #0]
}
 8017928:	371c      	adds	r7, #28
 801792a:	46bd      	mov	sp, r7
 801792c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017930:	4770      	bx	lr

08017932 <SecWriteStringByLoop>:

/* Use loop copy char or wchar_t string */
SECUREC_INLINE void SecWriteStringByLoop(SecPrintfStream *stream, const SecChar *str, int len)
{
 8017932:	b480      	push	{r7}
 8017934:	b087      	sub	sp, #28
 8017936:	af00      	add	r7, sp, #0
 8017938:	60f8      	str	r0, [r7, #12]
 801793a:	60b9      	str	r1, [r7, #8]
 801793c:	607a      	str	r2, [r7, #4]
    int i;
    const SecChar *tmp = str;
 801793e:	68bb      	ldr	r3, [r7, #8]
 8017940:	617b      	str	r3, [r7, #20]
    for (i = 0; i < len; ++i) {
 8017942:	2300      	movs	r3, #0
 8017944:	613b      	str	r3, [r7, #16]
 8017946:	e00f      	b.n	8017968 <SecWriteStringByLoop+0x36>
        *stream->cur = *tmp;
 8017948:	68fb      	ldr	r3, [r7, #12]
 801794a:	685b      	ldr	r3, [r3, #4]
 801794c:	697a      	ldr	r2, [r7, #20]
 801794e:	7812      	ldrb	r2, [r2, #0]
 8017950:	701a      	strb	r2, [r3, #0]
        ++stream->cur;
 8017952:	68fb      	ldr	r3, [r7, #12]
 8017954:	685b      	ldr	r3, [r3, #4]
 8017956:	1c5a      	adds	r2, r3, #1
 8017958:	68fb      	ldr	r3, [r7, #12]
 801795a:	605a      	str	r2, [r3, #4]
        ++tmp;
 801795c:	697b      	ldr	r3, [r7, #20]
 801795e:	3301      	adds	r3, #1
 8017960:	617b      	str	r3, [r7, #20]
    for (i = 0; i < len; ++i) {
 8017962:	693b      	ldr	r3, [r7, #16]
 8017964:	3301      	adds	r3, #1
 8017966:	613b      	str	r3, [r7, #16]
 8017968:	693a      	ldr	r2, [r7, #16]
 801796a:	687b      	ldr	r3, [r7, #4]
 801796c:	429a      	cmp	r2, r3
 801796e:	dbeb      	blt.n	8017948 <SecWriteStringByLoop+0x16>
    }
    stream->count -= len;
 8017970:	68fb      	ldr	r3, [r7, #12]
 8017972:	681a      	ldr	r2, [r3, #0]
 8017974:	687b      	ldr	r3, [r7, #4]
 8017976:	1ad2      	subs	r2, r2, r3
 8017978:	68fb      	ldr	r3, [r7, #12]
 801797a:	601a      	str	r2, [r3, #0]
}
 801797c:	bf00      	nop
 801797e:	371c      	adds	r7, #28
 8017980:	46bd      	mov	sp, r7
 8017982:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017986:	4770      	bx	lr

08017988 <SecWriteStringOpt>:

SECUREC_INLINE void SecWriteStringOpt(SecPrintfStream *stream, const SecChar *str, int len)
{
 8017988:	b580      	push	{r7, lr}
 801798a:	b086      	sub	sp, #24
 801798c:	af00      	add	r7, sp, #0
 801798e:	60f8      	str	r0, [r7, #12]
 8017990:	60b9      	str	r1, [r7, #8]
 8017992:	607a      	str	r2, [r7, #4]
    if (len < 12) { /* Performance optimization for mobile number length 12 */
 8017994:	687b      	ldr	r3, [r7, #4]
 8017996:	2b0b      	cmp	r3, #11
 8017998:	dc05      	bgt.n	80179a6 <SecWriteStringOpt+0x1e>
        SecWriteStringByLoop(stream, str, len);
 801799a:	687a      	ldr	r2, [r7, #4]
 801799c:	68b9      	ldr	r1, [r7, #8]
 801799e:	68f8      	ldr	r0, [r7, #12]
 80179a0:	f7ff ffc7 	bl	8017932 <SecWriteStringByLoop>
        size_t count = (size_t)(unsigned int)len * sizeof(SecChar);
        SECUREC_MEMCPY_WARP_OPT(stream->cur, str, count);
        stream->cur += len;
        stream->count -= len;
    }
}
 80179a4:	e014      	b.n	80179d0 <SecWriteStringOpt+0x48>
        size_t count = (size_t)(unsigned int)len * sizeof(SecChar);
 80179a6:	687b      	ldr	r3, [r7, #4]
 80179a8:	617b      	str	r3, [r7, #20]
        SECUREC_MEMCPY_WARP_OPT(stream->cur, str, count);
 80179aa:	68fb      	ldr	r3, [r7, #12]
 80179ac:	685b      	ldr	r3, [r3, #4]
 80179ae:	697a      	ldr	r2, [r7, #20]
 80179b0:	68b9      	ldr	r1, [r7, #8]
 80179b2:	4618      	mov	r0, r3
 80179b4:	f001 fba2 	bl	80190fc <memcpy>
        stream->cur += len;
 80179b8:	68fb      	ldr	r3, [r7, #12]
 80179ba:	685a      	ldr	r2, [r3, #4]
 80179bc:	687b      	ldr	r3, [r7, #4]
 80179be:	441a      	add	r2, r3
 80179c0:	68fb      	ldr	r3, [r7, #12]
 80179c2:	605a      	str	r2, [r3, #4]
        stream->count -= len;
 80179c4:	68fb      	ldr	r3, [r7, #12]
 80179c6:	681a      	ldr	r2, [r3, #0]
 80179c8:	687b      	ldr	r3, [r7, #4]
 80179ca:	1ad2      	subs	r2, r2, r3
 80179cc:	68fb      	ldr	r3, [r7, #12]
 80179ce:	601a      	str	r2, [r3, #0]
}
 80179d0:	bf00      	nop
 80179d2:	3718      	adds	r7, #24
 80179d4:	46bd      	mov	sp, r7
 80179d6:	bd80      	pop	{r7, pc}

080179d8 <SecIsStreamBufEnough>:
/*
 * Return if buffer length is enough
 * The count variable can be reduced to 0, and the external function complements the \0 terminator.
 */
SECUREC_INLINE int SecIsStreamBufEnough(const SecPrintfStream *stream, int needLen)
{
 80179d8:	b480      	push	{r7}
 80179da:	b083      	sub	sp, #12
 80179dc:	af00      	add	r7, sp, #0
 80179de:	6078      	str	r0, [r7, #4]
 80179e0:	6039      	str	r1, [r7, #0]
    return (int)(stream->count >= needLen);
 80179e2:	687b      	ldr	r3, [r7, #4]
 80179e4:	681b      	ldr	r3, [r3, #0]
 80179e6:	683a      	ldr	r2, [r7, #0]
 80179e8:	429a      	cmp	r2, r3
 80179ea:	bfd4      	ite	le
 80179ec:	2301      	movle	r3, #1
 80179ee:	2300      	movgt	r3, #0
 80179f0:	b2db      	uxtb	r3, r3
}
 80179f2:	4618      	mov	r0, r3
 80179f4:	370c      	adds	r7, #12
 80179f6:	46bd      	mov	sp, r7
 80179f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80179fc:	4770      	bx	lr

080179fe <SecWriteTextOpt>:

/* Write text string */
SECUREC_INLINE void SecWriteTextOpt(SecPrintfStream *stream, const SecChar *str, int len, int *charsOut)
{
 80179fe:	b580      	push	{r7, lr}
 8017a00:	b084      	sub	sp, #16
 8017a02:	af00      	add	r7, sp, #0
 8017a04:	60f8      	str	r0, [r7, #12]
 8017a06:	60b9      	str	r1, [r7, #8]
 8017a08:	607a      	str	r2, [r7, #4]
 8017a0a:	603b      	str	r3, [r7, #0]
    if (SecIsStreamBufEnough(stream, len) != 0) {
 8017a0c:	6879      	ldr	r1, [r7, #4]
 8017a0e:	68f8      	ldr	r0, [r7, #12]
 8017a10:	f7ff ffe2 	bl	80179d8 <SecIsStreamBufEnough>
 8017a14:	4603      	mov	r3, r0
 8017a16:	2b00      	cmp	r3, #0
 8017a18:	d00b      	beq.n	8017a32 <SecWriteTextOpt+0x34>
        SecWriteStringOpt(stream, str, len);
 8017a1a:	687a      	ldr	r2, [r7, #4]
 8017a1c:	68b9      	ldr	r1, [r7, #8]
 8017a1e:	68f8      	ldr	r0, [r7, #12]
 8017a20:	f7ff ffb2 	bl	8017988 <SecWriteStringOpt>
        *charsOut += len;
 8017a24:	683b      	ldr	r3, [r7, #0]
 8017a26:	681a      	ldr	r2, [r3, #0]
 8017a28:	687b      	ldr	r3, [r7, #4]
 8017a2a:	441a      	add	r2, r3
 8017a2c:	683b      	ldr	r3, [r7, #0]
 8017a2e:	601a      	str	r2, [r3, #0]
    } else {
        SecWriteString(stream, str, len, charsOut);
    }
}
 8017a30:	e005      	b.n	8017a3e <SecWriteTextOpt+0x40>
        SecWriteString(stream, str, len, charsOut);
 8017a32:	683b      	ldr	r3, [r7, #0]
 8017a34:	687a      	ldr	r2, [r7, #4]
 8017a36:	68b9      	ldr	r1, [r7, #8]
 8017a38:	68f8      	ldr	r0, [r7, #12]
 8017a3a:	f7ff ff42 	bl	80178c2 <SecWriteString>
}
 8017a3e:	bf00      	nop
 8017a40:	3710      	adds	r7, #16
 8017a42:	46bd      	mov	sp, r7
 8017a44:	bd80      	pop	{r7, pc}

08017a46 <SecWriteLeftPadding>:

/* Write left padding */
SECUREC_INLINE void SecWriteLeftPadding(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8017a46:	b580      	push	{r7, lr}
 8017a48:	b084      	sub	sp, #16
 8017a4a:	af00      	add	r7, sp, #0
 8017a4c:	60f8      	str	r0, [r7, #12]
 8017a4e:	60b9      	str	r1, [r7, #8]
 8017a50:	607a      	str	r2, [r7, #4]
    if ((attr->flags & (SECUREC_FLAG_LEFT | SECUREC_FLAG_LEADZERO)) == 0 && attr->padding > 0) {
 8017a52:	68bb      	ldr	r3, [r7, #8]
 8017a54:	695b      	ldr	r3, [r3, #20]
 8017a56:	f003 030c 	and.w	r3, r3, #12
 8017a5a:	2b00      	cmp	r3, #0
 8017a5c:	d10a      	bne.n	8017a74 <SecWriteLeftPadding+0x2e>
 8017a5e:	68bb      	ldr	r3, [r7, #8]
 8017a60:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017a62:	2b00      	cmp	r3, #0
 8017a64:	dd06      	ble.n	8017a74 <SecWriteLeftPadding+0x2e>
        /* Pad on left with blanks */
        SecWriteMultiChar(stream, SECUREC_CHAR(' '), attr->padding, charsOut);
 8017a66:	68bb      	ldr	r3, [r7, #8]
 8017a68:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8017a6a:	687b      	ldr	r3, [r7, #4]
 8017a6c:	2120      	movs	r1, #32
 8017a6e:	68f8      	ldr	r0, [r7, #12]
 8017a70:	f7ff fef4 	bl	801785c <SecWriteMultiChar>
    }
}
 8017a74:	bf00      	nop
 8017a76:	3710      	adds	r7, #16
 8017a78:	46bd      	mov	sp, r7
 8017a7a:	bd80      	pop	{r7, pc}

08017a7c <SecWritePrefix>:

/* Write prefix */
SECUREC_INLINE void SecWritePrefix(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8017a7c:	b580      	push	{r7, lr}
 8017a7e:	b084      	sub	sp, #16
 8017a80:	af00      	add	r7, sp, #0
 8017a82:	60f8      	str	r0, [r7, #12]
 8017a84:	60b9      	str	r1, [r7, #8]
 8017a86:	607a      	str	r2, [r7, #4]
    if (attr->prefixLen > 0) {
 8017a88:	68bb      	ldr	r3, [r7, #8]
 8017a8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8017a8c:	2b00      	cmp	r3, #0
 8017a8e:	dd08      	ble.n	8017aa2 <SecWritePrefix+0x26>
        SecWriteString(stream, attr->prefix, attr->prefixLen, charsOut);
 8017a90:	68bb      	ldr	r3, [r7, #8]
 8017a92:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8017a96:	68bb      	ldr	r3, [r7, #8]
 8017a98:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8017a9a:	687b      	ldr	r3, [r7, #4]
 8017a9c:	68f8      	ldr	r0, [r7, #12]
 8017a9e:	f7ff ff10 	bl	80178c2 <SecWriteString>
    }
}
 8017aa2:	bf00      	nop
 8017aa4:	3710      	adds	r7, #16
 8017aa6:	46bd      	mov	sp, r7
 8017aa8:	bd80      	pop	{r7, pc}

08017aaa <SecWriteLeadingZero>:

/* Write leading zeros */
SECUREC_INLINE void SecWriteLeadingZero(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8017aaa:	b580      	push	{r7, lr}
 8017aac:	b084      	sub	sp, #16
 8017aae:	af00      	add	r7, sp, #0
 8017ab0:	60f8      	str	r0, [r7, #12]
 8017ab2:	60b9      	str	r1, [r7, #8]
 8017ab4:	607a      	str	r2, [r7, #4]
    if ((attr->flags & SECUREC_FLAG_LEADZERO) != 0 && (attr->flags & SECUREC_FLAG_LEFT) == 0 &&
 8017ab6:	68bb      	ldr	r3, [r7, #8]
 8017ab8:	695b      	ldr	r3, [r3, #20]
 8017aba:	f003 0308 	and.w	r3, r3, #8
 8017abe:	2b00      	cmp	r3, #0
 8017ac0:	d010      	beq.n	8017ae4 <SecWriteLeadingZero+0x3a>
 8017ac2:	68bb      	ldr	r3, [r7, #8]
 8017ac4:	695b      	ldr	r3, [r3, #20]
 8017ac6:	f003 0304 	and.w	r3, r3, #4
 8017aca:	2b00      	cmp	r3, #0
 8017acc:	d10a      	bne.n	8017ae4 <SecWriteLeadingZero+0x3a>
        attr->padding > 0) {
 8017ace:	68bb      	ldr	r3, [r7, #8]
 8017ad0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    if ((attr->flags & SECUREC_FLAG_LEADZERO) != 0 && (attr->flags & SECUREC_FLAG_LEFT) == 0 &&
 8017ad2:	2b00      	cmp	r3, #0
 8017ad4:	dd06      	ble.n	8017ae4 <SecWriteLeadingZero+0x3a>
        SecWriteMultiChar(stream, SECUREC_CHAR('0'), attr->padding, charsOut);
 8017ad6:	68bb      	ldr	r3, [r7, #8]
 8017ad8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8017ada:	687b      	ldr	r3, [r7, #4]
 8017adc:	2130      	movs	r1, #48	; 0x30
 8017ade:	68f8      	ldr	r0, [r7, #12]
 8017ae0:	f7ff febc 	bl	801785c <SecWriteMultiChar>
    }
}
 8017ae4:	bf00      	nop
 8017ae6:	3710      	adds	r7, #16
 8017ae8:	46bd      	mov	sp, r7
 8017aea:	bd80      	pop	{r7, pc}

08017aec <SecWriteRightPadding>:

/* Write right padding */
SECUREC_INLINE void SecWriteRightPadding(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8017aec:	b580      	push	{r7, lr}
 8017aee:	b084      	sub	sp, #16
 8017af0:	af00      	add	r7, sp, #0
 8017af2:	60f8      	str	r0, [r7, #12]
 8017af4:	60b9      	str	r1, [r7, #8]
 8017af6:	607a      	str	r2, [r7, #4]
    if (*charsOut >= 0 && (attr->flags & SECUREC_FLAG_LEFT) != 0 && attr->padding > 0) {
 8017af8:	687b      	ldr	r3, [r7, #4]
 8017afa:	681b      	ldr	r3, [r3, #0]
 8017afc:	2b00      	cmp	r3, #0
 8017afe:	db10      	blt.n	8017b22 <SecWriteRightPadding+0x36>
 8017b00:	68bb      	ldr	r3, [r7, #8]
 8017b02:	695b      	ldr	r3, [r3, #20]
 8017b04:	f003 0304 	and.w	r3, r3, #4
 8017b08:	2b00      	cmp	r3, #0
 8017b0a:	d00a      	beq.n	8017b22 <SecWriteRightPadding+0x36>
 8017b0c:	68bb      	ldr	r3, [r7, #8]
 8017b0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017b10:	2b00      	cmp	r3, #0
 8017b12:	dd06      	ble.n	8017b22 <SecWriteRightPadding+0x36>
        /* Pad on right with blanks */
        SecWriteMultiChar(stream, SECUREC_CHAR(' '), attr->padding, charsOut);
 8017b14:	68bb      	ldr	r3, [r7, #8]
 8017b16:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8017b18:	687b      	ldr	r3, [r7, #4]
 8017b1a:	2120      	movs	r1, #32
 8017b1c:	68f8      	ldr	r0, [r7, #12]
 8017b1e:	f7ff fe9d 	bl	801785c <SecWriteMultiChar>
    }
}
 8017b22:	bf00      	nop
 8017b24:	3710      	adds	r7, #16
 8017b26:	46bd      	mov	sp, r7
 8017b28:	bd80      	pop	{r7, pc}
	...

08017b2c <SecWriteTextAfterWctomb>:
}
#endif
#else  /* Not SECUREC_FOR_WCHAR */
#if SECUREC_HAVE_WCTOMB
SECUREC_INLINE void SecWriteTextAfterWctomb(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8017b2c:	b580      	push	{r7, lr}
 8017b2e:	b08e      	sub	sp, #56	; 0x38
 8017b30:	af00      	add	r7, sp, #0
 8017b32:	60f8      	str	r0, [r7, #12]
 8017b34:	60b9      	str	r1, [r7, #8]
 8017b36:	607a      	str	r2, [r7, #4]
 8017b38:	4b20      	ldr	r3, [pc, #128]	; (8017bbc <SecWriteTextAfterWctomb+0x90>)
 8017b3a:	681b      	ldr	r3, [r3, #0]
 8017b3c:	637b      	str	r3, [r7, #52]	; 0x34
 8017b3e:	f04f 0300 	mov.w	r3, #0
    const wchar_t *p = attr->text.wStr;
 8017b42:	68bb      	ldr	r3, [r7, #8]
 8017b44:	685b      	ldr	r3, [r3, #4]
 8017b46:	617b      	str	r3, [r7, #20]
    int count = attr->textLen;
 8017b48:	68bb      	ldr	r3, [r7, #8]
 8017b4a:	689b      	ldr	r3, [r3, #8]
 8017b4c:	61bb      	str	r3, [r7, #24]
    while (count > 0) {
 8017b4e:	e026      	b.n	8017b9e <SecWriteTextAfterWctomb+0x72>
        char tmpBuf[SECUREC_MB_LEN + 1];
        SECUREC_MASK_MSVC_CRT_WARNING
        int retVal = wctomb(tmpBuf, *p);
 8017b50:	697b      	ldr	r3, [r7, #20]
 8017b52:	681a      	ldr	r2, [r3, #0]
 8017b54:	f107 0320 	add.w	r3, r7, #32
 8017b58:	4611      	mov	r1, r2
 8017b5a:	4618      	mov	r0, r3
 8017b5c:	f007 fbf2 	bl	801f344 <wctomb>
 8017b60:	61f8      	str	r0, [r7, #28]
        SECUREC_END_MASK_MSVC_CRT_WARNING
        if (retVal <= 0) {
 8017b62:	69fb      	ldr	r3, [r7, #28]
 8017b64:	2b00      	cmp	r3, #0
 8017b66:	dc05      	bgt.n	8017b74 <SecWriteTextAfterWctomb+0x48>
            *charsOut = -1;
 8017b68:	687b      	ldr	r3, [r7, #4]
 8017b6a:	f04f 32ff 	mov.w	r2, #4294967295
 8017b6e:	601a      	str	r2, [r3, #0]
            break;
 8017b70:	bf00      	nop
            break;
        }
        --count;
        ++p;
    }
}
 8017b72:	e017      	b.n	8017ba4 <SecWriteTextAfterWctomb+0x78>
        SecWriteString(stream, tmpBuf, retVal, charsOut);
 8017b74:	f107 0120 	add.w	r1, r7, #32
 8017b78:	687b      	ldr	r3, [r7, #4]
 8017b7a:	69fa      	ldr	r2, [r7, #28]
 8017b7c:	68f8      	ldr	r0, [r7, #12]
 8017b7e:	f7ff fea0 	bl	80178c2 <SecWriteString>
        if (*charsOut == -1) {
 8017b82:	687b      	ldr	r3, [r7, #4]
 8017b84:	681b      	ldr	r3, [r3, #0]
 8017b86:	f1b3 3fff 	cmp.w	r3, #4294967295
 8017b8a:	d006      	beq.n	8017b9a <SecWriteTextAfterWctomb+0x6e>
        --count;
 8017b8c:	69bb      	ldr	r3, [r7, #24]
 8017b8e:	3b01      	subs	r3, #1
 8017b90:	61bb      	str	r3, [r7, #24]
        ++p;
 8017b92:	697b      	ldr	r3, [r7, #20]
 8017b94:	3304      	adds	r3, #4
 8017b96:	617b      	str	r3, [r7, #20]
 8017b98:	e001      	b.n	8017b9e <SecWriteTextAfterWctomb+0x72>
            break;
 8017b9a:	bf00      	nop
}
 8017b9c:	e002      	b.n	8017ba4 <SecWriteTextAfterWctomb+0x78>
    while (count > 0) {
 8017b9e:	69bb      	ldr	r3, [r7, #24]
 8017ba0:	2b00      	cmp	r3, #0
 8017ba2:	dcd5      	bgt.n	8017b50 <SecWriteTextAfterWctomb+0x24>
}
 8017ba4:	bf00      	nop
 8017ba6:	4b05      	ldr	r3, [pc, #20]	; (8017bbc <SecWriteTextAfterWctomb+0x90>)
 8017ba8:	681a      	ldr	r2, [r3, #0]
 8017baa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017bac:	405a      	eors	r2, r3
 8017bae:	d001      	beq.n	8017bb4 <SecWriteTextAfterWctomb+0x88>
 8017bb0:	f7ec fd14 	bl	80045dc <__stack_chk_fail>
 8017bb4:	3738      	adds	r7, #56	; 0x38
 8017bb6:	46bd      	mov	sp, r7
 8017bb8:	bd80      	pop	{r7, pc}
 8017bba:	bf00      	nop
 8017bbc:	080230b4 	.word	0x080230b4

08017bc0 <SecWriteFloatText>:
/*
 * Write text of float
 * Using independent functions to optimize the expansion of inline functions by the compiler
 */
SECUREC_INLINE void SecWriteFloatText(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8017bc0:	b580      	push	{r7, lr}
 8017bc2:	b084      	sub	sp, #16
 8017bc4:	af00      	add	r7, sp, #0
 8017bc6:	60f8      	str	r0, [r7, #12]
 8017bc8:	60b9      	str	r1, [r7, #8]
 8017bca:	607a      	str	r2, [r7, #4]
    *charsOut = -1;
    (void)stream; /* To clear e438 last value assigned not used , the compiler will optimize this code */
    (void)attr;   /* To clear e438 last value assigned not used , the compiler will optimize this code */
#endif
#else /* Not SECUREC_FOR_WCHAR */
    SecWriteString(stream, attr->text.str, attr->textLen, charsOut);
 8017bcc:	68bb      	ldr	r3, [r7, #8]
 8017bce:	6859      	ldr	r1, [r3, #4]
 8017bd0:	68bb      	ldr	r3, [r7, #8]
 8017bd2:	689a      	ldr	r2, [r3, #8]
 8017bd4:	687b      	ldr	r3, [r7, #4]
 8017bd6:	68f8      	ldr	r0, [r7, #12]
 8017bd8:	f7ff fe73 	bl	80178c2 <SecWriteString>
#endif
}
 8017bdc:	bf00      	nop
 8017bde:	3710      	adds	r7, #16
 8017be0:	46bd      	mov	sp, r7
 8017be2:	bd80      	pop	{r7, pc}

08017be4 <SecWriteText>:
#endif

/* Write text of integer or string ... */
SECUREC_INLINE void SecWriteText(SecPrintfStream *stream, const SecFormatAttr *attr, int *charsOut)
{
 8017be4:	b580      	push	{r7, lr}
 8017be6:	b084      	sub	sp, #16
 8017be8:	af00      	add	r7, sp, #0
 8017bea:	60f8      	str	r0, [r7, #12]
 8017bec:	60b9      	str	r1, [r7, #8]
 8017bee:	607a      	str	r2, [r7, #4]
    if (SECUREC_NEED_CONVERT_TEXT(attr)) {
 8017bf0:	68bb      	ldr	r3, [r7, #8]
 8017bf2:	68db      	ldr	r3, [r3, #12]
 8017bf4:	2b00      	cmp	r3, #0
 8017bf6:	d005      	beq.n	8017c04 <SecWriteText+0x20>
        SECUREC_WRITE_TEXT_AFTER_CONVERT(stream, attr, charsOut);
 8017bf8:	687a      	ldr	r2, [r7, #4]
 8017bfa:	68b9      	ldr	r1, [r7, #8]
 8017bfc:	68f8      	ldr	r0, [r7, #12]
 8017bfe:	f7ff ff95 	bl	8017b2c <SecWriteTextAfterWctomb>
    } else {
        SecWriteTextOpt(stream, SECUREC_TEXT_CHAR_PTR(attr->text), attr->textLen, charsOut);
    }
}
 8017c02:	e007      	b.n	8017c14 <SecWriteText+0x30>
        SecWriteTextOpt(stream, SECUREC_TEXT_CHAR_PTR(attr->text), attr->textLen, charsOut);
 8017c04:	68bb      	ldr	r3, [r7, #8]
 8017c06:	6859      	ldr	r1, [r3, #4]
 8017c08:	68bb      	ldr	r3, [r7, #8]
 8017c0a:	689a      	ldr	r2, [r3, #8]
 8017c0c:	687b      	ldr	r3, [r7, #4]
 8017c0e:	68f8      	ldr	r0, [r7, #12]
 8017c10:	f7ff fef5 	bl	80179fe <SecWriteTextOpt>
}
 8017c14:	bf00      	nop
 8017c16:	3710      	adds	r7, #16
 8017c18:	46bd      	mov	sp, r7
 8017c1a:	bd80      	pop	{r7, pc}

08017c1c <SecDecodeState>:

#define SECUREC_FMT_STATE_OFFSET  256

SECUREC_INLINE SecFmtState SecDecodeState(SecChar ch, SecFmtState lastState)
{
 8017c1c:	b480      	push	{r7}
 8017c1e:	b085      	sub	sp, #20
 8017c20:	af00      	add	r7, sp, #0
 8017c22:	4603      	mov	r3, r0
 8017c24:	6039      	str	r1, [r7, #0]
 8017c26:	71fb      	strb	r3, [r7, #7]
    unsigned char fmtType = (unsigned char)((((unsigned int)(int)(ch)) <= (unsigned int)(int)(L'~')) ? \
        (stateTable[(unsigned char)(ch)]) : 0);
    return (SecFmtState)(stateTable[fmtType * ((unsigned char)STAT_INVALID + 1) +
        (unsigned char)(lastState) + SECUREC_FMT_STATE_OFFSET]);
#else
    unsigned char fmtType = stateTable[(unsigned char)(ch)];
 8017c28:	79fb      	ldrb	r3, [r7, #7]
 8017c2a:	4a0a      	ldr	r2, [pc, #40]	; (8017c54 <SecDecodeState+0x38>)
 8017c2c:	5cd3      	ldrb	r3, [r2, r3]
 8017c2e:	73fb      	strb	r3, [r7, #15]
    return (SecFmtState)(stateTable[fmtType * ((unsigned char)STAT_INVALID + 1) +
 8017c30:	7bfa      	ldrb	r2, [r7, #15]
 8017c32:	4613      	mov	r3, r2
 8017c34:	00db      	lsls	r3, r3, #3
 8017c36:	4413      	add	r3, r2
        (unsigned char)(lastState) + SECUREC_FMT_STATE_OFFSET]);
 8017c38:	683a      	ldr	r2, [r7, #0]
 8017c3a:	b2d2      	uxtb	r2, r2
    return (SecFmtState)(stateTable[fmtType * ((unsigned char)STAT_INVALID + 1) +
 8017c3c:	4413      	add	r3, r2
        (unsigned char)(lastState) + SECUREC_FMT_STATE_OFFSET]);
 8017c3e:	f503 7380 	add.w	r3, r3, #256	; 0x100
    return (SecFmtState)(stateTable[fmtType * ((unsigned char)STAT_INVALID + 1) +
 8017c42:	4a04      	ldr	r2, [pc, #16]	; (8017c54 <SecDecodeState+0x38>)
 8017c44:	5cd3      	ldrb	r3, [r2, r3]
#endif
}
 8017c46:	4618      	mov	r0, r3
 8017c48:	3714      	adds	r7, #20
 8017c4a:	46bd      	mov	sp, r7
 8017c4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017c50:	4770      	bx	lr
 8017c52:	bf00      	nop
 8017c54:	080236c0 	.word	0x080236c0

08017c58 <SecDecodeFlags>:

SECUREC_INLINE void SecDecodeFlags(SecChar ch, SecFormatAttr *attr)
{
 8017c58:	b480      	push	{r7}
 8017c5a:	b083      	sub	sp, #12
 8017c5c:	af00      	add	r7, sp, #0
 8017c5e:	4603      	mov	r3, r0
 8017c60:	6039      	str	r1, [r7, #0]
 8017c62:	71fb      	strb	r3, [r7, #7]
    switch (ch) {
 8017c64:	79fb      	ldrb	r3, [r7, #7]
 8017c66:	3b20      	subs	r3, #32
 8017c68:	2b10      	cmp	r3, #16
 8017c6a:	d848      	bhi.n	8017cfe <SecDecodeFlags+0xa6>
 8017c6c:	a201      	add	r2, pc, #4	; (adr r2, 8017c74 <SecDecodeFlags+0x1c>)
 8017c6e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017c72:	bf00      	nop
 8017c74:	08017cb9 	.word	0x08017cb9
 8017c78:	08017cff 	.word	0x08017cff
 8017c7c:	08017cff 	.word	0x08017cff
 8017c80:	08017cf1 	.word	0x08017cf1
 8017c84:	08017cff 	.word	0x08017cff
 8017c88:	08017cff 	.word	0x08017cff
 8017c8c:	08017cff 	.word	0x08017cff
 8017c90:	08017cff 	.word	0x08017cff
 8017c94:	08017cff 	.word	0x08017cff
 8017c98:	08017cff 	.word	0x08017cff
 8017c9c:	08017cff 	.word	0x08017cff
 8017ca0:	08017cc7 	.word	0x08017cc7
 8017ca4:	08017cff 	.word	0x08017cff
 8017ca8:	08017cd5 	.word	0x08017cd5
 8017cac:	08017cff 	.word	0x08017cff
 8017cb0:	08017cff 	.word	0x08017cff
 8017cb4:	08017ce3 	.word	0x08017ce3
        case SECUREC_CHAR(' '):
            attr->flags |= SECUREC_FLAG_SIGN_SPACE;
 8017cb8:	683b      	ldr	r3, [r7, #0]
 8017cba:	695b      	ldr	r3, [r3, #20]
 8017cbc:	f043 0202 	orr.w	r2, r3, #2
 8017cc0:	683b      	ldr	r3, [r7, #0]
 8017cc2:	615a      	str	r2, [r3, #20]
            break;
 8017cc4:	e01c      	b.n	8017d00 <SecDecodeFlags+0xa8>
        case SECUREC_CHAR('+'):
            attr->flags |= SECUREC_FLAG_SIGN;
 8017cc6:	683b      	ldr	r3, [r7, #0]
 8017cc8:	695b      	ldr	r3, [r3, #20]
 8017cca:	f043 0201 	orr.w	r2, r3, #1
 8017cce:	683b      	ldr	r3, [r7, #0]
 8017cd0:	615a      	str	r2, [r3, #20]
            break;
 8017cd2:	e015      	b.n	8017d00 <SecDecodeFlags+0xa8>
        case SECUREC_CHAR('-'):
            attr->flags |= SECUREC_FLAG_LEFT;
 8017cd4:	683b      	ldr	r3, [r7, #0]
 8017cd6:	695b      	ldr	r3, [r3, #20]
 8017cd8:	f043 0204 	orr.w	r2, r3, #4
 8017cdc:	683b      	ldr	r3, [r7, #0]
 8017cde:	615a      	str	r2, [r3, #20]
            break;
 8017ce0:	e00e      	b.n	8017d00 <SecDecodeFlags+0xa8>
        case SECUREC_CHAR('0'):
            attr->flags |= SECUREC_FLAG_LEADZERO;   /* Add zero th the front */
 8017ce2:	683b      	ldr	r3, [r7, #0]
 8017ce4:	695b      	ldr	r3, [r3, #20]
 8017ce6:	f043 0208 	orr.w	r2, r3, #8
 8017cea:	683b      	ldr	r3, [r7, #0]
 8017cec:	615a      	str	r2, [r3, #20]
            break;
 8017cee:	e007      	b.n	8017d00 <SecDecodeFlags+0xa8>
        case SECUREC_CHAR('#'):
            attr->flags |= SECUREC_FLAG_ALTERNATE;  /* Output %x with 0x */
 8017cf0:	683b      	ldr	r3, [r7, #0]
 8017cf2:	695b      	ldr	r3, [r3, #20]
 8017cf4:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8017cf8:	683b      	ldr	r3, [r7, #0]
 8017cfa:	615a      	str	r2, [r3, #20]
            break;
 8017cfc:	e000      	b.n	8017d00 <SecDecodeFlags+0xa8>
        default:
            /* Do nothing */
            break;
 8017cfe:	bf00      	nop
    }
    return;
 8017d00:	bf00      	nop
}
 8017d02:	370c      	adds	r7, #12
 8017d04:	46bd      	mov	sp, r7
 8017d06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017d0a:	4770      	bx	lr

08017d0c <SecDecodeSizeI>:

/*
 * Decoded size identifier in format string to Reduce the number of lines of function code
 */
SECUREC_INLINE int SecDecodeSizeI(SecFormatAttr *attr, const SecChar **format)
{
 8017d0c:	b480      	push	{r7}
 8017d0e:	b083      	sub	sp, #12
 8017d10:	af00      	add	r7, sp, #0
 8017d12:	6078      	str	r0, [r7, #4]
 8017d14:	6039      	str	r1, [r7, #0]
#ifdef SECUREC_ON_64BITS
    attr->flags |= SECUREC_FLAG_I64;    /* %I  to  INT64 */
#endif
    if ((**format == SECUREC_CHAR('6')) && (*((*format) + 1) == SECUREC_CHAR('4'))) {
 8017d16:	683b      	ldr	r3, [r7, #0]
 8017d18:	681b      	ldr	r3, [r3, #0]
 8017d1a:	781b      	ldrb	r3, [r3, #0]
 8017d1c:	2b36      	cmp	r3, #54	; 0x36
 8017d1e:	d111      	bne.n	8017d44 <SecDecodeSizeI+0x38>
 8017d20:	683b      	ldr	r3, [r7, #0]
 8017d22:	681b      	ldr	r3, [r3, #0]
 8017d24:	3301      	adds	r3, #1
 8017d26:	781b      	ldrb	r3, [r3, #0]
 8017d28:	2b34      	cmp	r3, #52	; 0x34
 8017d2a:	d10b      	bne.n	8017d44 <SecDecodeSizeI+0x38>
        (*format) += 2; /* Add 2 to skip I64 */
 8017d2c:	683b      	ldr	r3, [r7, #0]
 8017d2e:	681b      	ldr	r3, [r3, #0]
 8017d30:	1c9a      	adds	r2, r3, #2
 8017d32:	683b      	ldr	r3, [r7, #0]
 8017d34:	601a      	str	r2, [r3, #0]
        attr->flags |= SECUREC_FLAG_I64;    /* %I64  to  INT64 */
 8017d36:	687b      	ldr	r3, [r7, #4]
 8017d38:	695b      	ldr	r3, [r3, #20]
 8017d3a:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8017d3e:	687b      	ldr	r3, [r7, #4]
 8017d40:	615a      	str	r2, [r3, #20]
 8017d42:	e037      	b.n	8017db4 <SecDecodeSizeI+0xa8>
    } else if ((**format == SECUREC_CHAR('3')) && (*((*format) + 1) == SECUREC_CHAR('2'))) {
 8017d44:	683b      	ldr	r3, [r7, #0]
 8017d46:	681b      	ldr	r3, [r3, #0]
 8017d48:	781b      	ldrb	r3, [r3, #0]
 8017d4a:	2b33      	cmp	r3, #51	; 0x33
 8017d4c:	d111      	bne.n	8017d72 <SecDecodeSizeI+0x66>
 8017d4e:	683b      	ldr	r3, [r7, #0]
 8017d50:	681b      	ldr	r3, [r3, #0]
 8017d52:	3301      	adds	r3, #1
 8017d54:	781b      	ldrb	r3, [r3, #0]
 8017d56:	2b32      	cmp	r3, #50	; 0x32
 8017d58:	d10b      	bne.n	8017d72 <SecDecodeSizeI+0x66>
        (*format) += 2; /* Add 2 to skip I32 */
 8017d5a:	683b      	ldr	r3, [r7, #0]
 8017d5c:	681b      	ldr	r3, [r3, #0]
 8017d5e:	1c9a      	adds	r2, r3, #2
 8017d60:	683b      	ldr	r3, [r7, #0]
 8017d62:	601a      	str	r2, [r3, #0]
        attr->flags &= ~SECUREC_FLAG_I64;   /* %I64  to  INT32 */
 8017d64:	687b      	ldr	r3, [r7, #4]
 8017d66:	695b      	ldr	r3, [r3, #20]
 8017d68:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 8017d6c:	687b      	ldr	r3, [r7, #4]
 8017d6e:	615a      	str	r2, [r3, #20]
 8017d70:	e020      	b.n	8017db4 <SecDecodeSizeI+0xa8>
    } else if ((**format == SECUREC_CHAR('d')) || (**format == SECUREC_CHAR('i')) ||
 8017d72:	683b      	ldr	r3, [r7, #0]
 8017d74:	681b      	ldr	r3, [r3, #0]
 8017d76:	781b      	ldrb	r3, [r3, #0]
 8017d78:	2b64      	cmp	r3, #100	; 0x64
 8017d7a:	d01b      	beq.n	8017db4 <SecDecodeSizeI+0xa8>
 8017d7c:	683b      	ldr	r3, [r7, #0]
 8017d7e:	681b      	ldr	r3, [r3, #0]
 8017d80:	781b      	ldrb	r3, [r3, #0]
 8017d82:	2b69      	cmp	r3, #105	; 0x69
 8017d84:	d016      	beq.n	8017db4 <SecDecodeSizeI+0xa8>
        (**format == SECUREC_CHAR('o')) || (**format == SECUREC_CHAR('u')) ||
 8017d86:	683b      	ldr	r3, [r7, #0]
 8017d88:	681b      	ldr	r3, [r3, #0]
 8017d8a:	781b      	ldrb	r3, [r3, #0]
    } else if ((**format == SECUREC_CHAR('d')) || (**format == SECUREC_CHAR('i')) ||
 8017d8c:	2b6f      	cmp	r3, #111	; 0x6f
 8017d8e:	d011      	beq.n	8017db4 <SecDecodeSizeI+0xa8>
        (**format == SECUREC_CHAR('o')) || (**format == SECUREC_CHAR('u')) ||
 8017d90:	683b      	ldr	r3, [r7, #0]
 8017d92:	681b      	ldr	r3, [r3, #0]
 8017d94:	781b      	ldrb	r3, [r3, #0]
 8017d96:	2b75      	cmp	r3, #117	; 0x75
 8017d98:	d00c      	beq.n	8017db4 <SecDecodeSizeI+0xa8>
        (**format == SECUREC_CHAR('x')) || (**format == SECUREC_CHAR('X'))) {
 8017d9a:	683b      	ldr	r3, [r7, #0]
 8017d9c:	681b      	ldr	r3, [r3, #0]
 8017d9e:	781b      	ldrb	r3, [r3, #0]
        (**format == SECUREC_CHAR('o')) || (**format == SECUREC_CHAR('u')) ||
 8017da0:	2b78      	cmp	r3, #120	; 0x78
 8017da2:	d007      	beq.n	8017db4 <SecDecodeSizeI+0xa8>
        (**format == SECUREC_CHAR('x')) || (**format == SECUREC_CHAR('X'))) {
 8017da4:	683b      	ldr	r3, [r7, #0]
 8017da6:	681b      	ldr	r3, [r3, #0]
 8017da8:	781b      	ldrb	r3, [r3, #0]
 8017daa:	2b58      	cmp	r3, #88	; 0x58
 8017dac:	d002      	beq.n	8017db4 <SecDecodeSizeI+0xa8>
        /* Do nothing */
    } else {
        /* Compatibility  code for "%I" just print I */
        return -1;
 8017dae:	f04f 33ff 	mov.w	r3, #4294967295
 8017db2:	e000      	b.n	8017db6 <SecDecodeSizeI+0xaa>
    }
    return 0;
 8017db4:	2300      	movs	r3, #0
}
 8017db6:	4618      	mov	r0, r3
 8017db8:	370c      	adds	r7, #12
 8017dba:	46bd      	mov	sp, r7
 8017dbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017dc0:	4770      	bx	lr
	...

08017dc4 <SecDecodeSize>:

/*
 * Decoded size identifier in format string, and skip format to next charater
 */
SECUREC_INLINE int SecDecodeSize(SecChar ch, SecFormatAttr *attr, const SecChar **format)
{
 8017dc4:	b580      	push	{r7, lr}
 8017dc6:	b084      	sub	sp, #16
 8017dc8:	af00      	add	r7, sp, #0
 8017dca:	4603      	mov	r3, r0
 8017dcc:	60b9      	str	r1, [r7, #8]
 8017dce:	607a      	str	r2, [r7, #4]
 8017dd0:	73fb      	strb	r3, [r7, #15]
    switch (ch) {
 8017dd2:	7bfb      	ldrb	r3, [r7, #15]
 8017dd4:	3b49      	subs	r3, #73	; 0x49
 8017dd6:	2b31      	cmp	r3, #49	; 0x31
 8017dd8:	f200 80c5 	bhi.w	8017f66 <SecDecodeSize+0x1a2>
 8017ddc:	a201      	add	r2, pc, #4	; (adr r2, 8017de4 <SecDecodeSize+0x20>)
 8017dde:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017de2:	bf00      	nop
 8017de4:	08017f15 	.word	0x08017f15
 8017de8:	08017f67 	.word	0x08017f67
 8017dec:	08017f67 	.word	0x08017f67
 8017df0:	08017f07 	.word	0x08017f07
 8017df4:	08017f67 	.word	0x08017f67
 8017df8:	08017f67 	.word	0x08017f67
 8017dfc:	08017f67 	.word	0x08017f67
 8017e00:	08017f67 	.word	0x08017f67
 8017e04:	08017f67 	.word	0x08017f67
 8017e08:	08017f67 	.word	0x08017f67
 8017e0c:	08017f67 	.word	0x08017f67
 8017e10:	08017f67 	.word	0x08017f67
 8017e14:	08017f67 	.word	0x08017f67
 8017e18:	08017f67 	.word	0x08017f67
 8017e1c:	08017f67 	.word	0x08017f67
 8017e20:	08017f67 	.word	0x08017f67
 8017e24:	08017f67 	.word	0x08017f67
 8017e28:	08017edd 	.word	0x08017edd
 8017e2c:	08017f67 	.word	0x08017f67
 8017e30:	08017f67 	.word	0x08017f67
 8017e34:	08017f67 	.word	0x08017f67
 8017e38:	08017f67 	.word	0x08017f67
 8017e3c:	08017f67 	.word	0x08017f67
 8017e40:	08017f67 	.word	0x08017f67
 8017e44:	08017f67 	.word	0x08017f67
 8017e48:	08017f67 	.word	0x08017f67
 8017e4c:	08017f67 	.word	0x08017f67
 8017e50:	08017f67 	.word	0x08017f67
 8017e54:	08017f67 	.word	0x08017f67
 8017e58:	08017f67 	.word	0x08017f67
 8017e5c:	08017f67 	.word	0x08017f67
 8017e60:	08017f29 	.word	0x08017f29
 8017e64:	08017f67 	.word	0x08017f67
 8017e68:	08017eeb 	.word	0x08017eeb
 8017e6c:	08017f67 	.word	0x08017f67
 8017e70:	08017ead 	.word	0x08017ead
 8017e74:	08017f67 	.word	0x08017f67
 8017e78:	08017f67 	.word	0x08017f67
 8017e7c:	08017f67 	.word	0x08017f67
 8017e80:	08017f67 	.word	0x08017f67
 8017e84:	08017f07 	.word	0x08017f07
 8017e88:	08017f67 	.word	0x08017f67
 8017e8c:	08017f67 	.word	0x08017f67
 8017e90:	08017ef9 	.word	0x08017ef9
 8017e94:	08017f67 	.word	0x08017f67
 8017e98:	08017f67 	.word	0x08017f67
 8017e9c:	08017f59 	.word	0x08017f59
 8017ea0:	08017f67 	.word	0x08017f67
 8017ea4:	08017f67 	.word	0x08017f67
 8017ea8:	08017edd 	.word	0x08017edd
        case SECUREC_CHAR('l'):
            if (**format == SECUREC_CHAR('l')) {
 8017eac:	687b      	ldr	r3, [r7, #4]
 8017eae:	681b      	ldr	r3, [r3, #0]
 8017eb0:	781b      	ldrb	r3, [r3, #0]
 8017eb2:	2b6c      	cmp	r3, #108	; 0x6c
 8017eb4:	d10b      	bne.n	8017ece <SecDecodeSize+0x10a>
                *format = *format + 1;
 8017eb6:	687b      	ldr	r3, [r7, #4]
 8017eb8:	681b      	ldr	r3, [r3, #0]
 8017eba:	1c5a      	adds	r2, r3, #1
 8017ebc:	687b      	ldr	r3, [r7, #4]
 8017ebe:	601a      	str	r2, [r3, #0]
                attr->flags |= SECUREC_FLAG_LONGLONG; /* For long long */
 8017ec0:	68bb      	ldr	r3, [r7, #8]
 8017ec2:	695b      	ldr	r3, [r3, #20]
 8017ec4:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 8017ec8:	68bb      	ldr	r3, [r7, #8]
 8017eca:	615a      	str	r2, [r3, #20]
            } else {
                attr->flags |= SECUREC_FLAG_LONG;     /* For long int or wchar_t */
            }
            break;
 8017ecc:	e04e      	b.n	8017f6c <SecDecodeSize+0x1a8>
                attr->flags |= SECUREC_FLAG_LONG;     /* For long int or wchar_t */
 8017ece:	68bb      	ldr	r3, [r7, #8]
 8017ed0:	695b      	ldr	r3, [r3, #20]
 8017ed2:	f043 0210 	orr.w	r2, r3, #16
 8017ed6:	68bb      	ldr	r3, [r7, #8]
 8017ed8:	615a      	str	r2, [r3, #20]
            break;
 8017eda:	e047      	b.n	8017f6c <SecDecodeSize+0x1a8>
#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
        case SECUREC_CHAR('z'): /* fall-through */ /* FALLTHRU */
        case SECUREC_CHAR('Z'):
            attr->flags |= SECUREC_FLAG_SIZE;
 8017edc:	68bb      	ldr	r3, [r7, #8]
 8017ede:	695b      	ldr	r3, [r3, #20]
 8017ee0:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 8017ee4:	68bb      	ldr	r3, [r7, #8]
 8017ee6:	615a      	str	r2, [r3, #20]
            break;
 8017ee8:	e040      	b.n	8017f6c <SecDecodeSize+0x1a8>
        case SECUREC_CHAR('j'):
            attr->flags |= SECUREC_FLAG_INTMAX;
 8017eea:	68bb      	ldr	r3, [r7, #8]
 8017eec:	695b      	ldr	r3, [r3, #20]
 8017eee:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 8017ef2:	68bb      	ldr	r3, [r7, #8]
 8017ef4:	615a      	str	r2, [r3, #20]
            break;
 8017ef6:	e039      	b.n	8017f6c <SecDecodeSize+0x1a8>
#endif
        case SECUREC_CHAR('t'):
            attr->flags |= SECUREC_FLAG_PTRDIFF;
 8017ef8:	68bb      	ldr	r3, [r7, #8]
 8017efa:	695b      	ldr	r3, [r3, #20]
 8017efc:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8017f00:	68bb      	ldr	r3, [r7, #8]
 8017f02:	615a      	str	r2, [r3, #20]
            break;
 8017f04:	e032      	b.n	8017f6c <SecDecodeSize+0x1a8>
        case SECUREC_CHAR('q'): /* fall-through */ /* FALLTHRU */
        case SECUREC_CHAR('L'):
            attr->flags |= (SECUREC_FLAG_LONGLONG | SECUREC_FLAG_LONG_DOUBLE);
 8017f06:	68bb      	ldr	r3, [r7, #8]
 8017f08:	695b      	ldr	r3, [r3, #20]
 8017f0a:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 8017f0e:	68bb      	ldr	r3, [r7, #8]
 8017f10:	615a      	str	r2, [r3, #20]
            break;
 8017f12:	e02b      	b.n	8017f6c <SecDecodeSize+0x1a8>
        case SECUREC_CHAR('I'):
            if (SecDecodeSizeI(attr, format) != 0) {
 8017f14:	6879      	ldr	r1, [r7, #4]
 8017f16:	68b8      	ldr	r0, [r7, #8]
 8017f18:	f7ff fef8 	bl	8017d0c <SecDecodeSizeI>
 8017f1c:	4603      	mov	r3, r0
 8017f1e:	2b00      	cmp	r3, #0
 8017f20:	d023      	beq.n	8017f6a <SecDecodeSize+0x1a6>
                /* Compatibility  code for "%I" just print I */
                return -1;
 8017f22:	f04f 33ff 	mov.w	r3, #4294967295
 8017f26:	e022      	b.n	8017f6e <SecDecodeSize+0x1aa>
            }
            break;
        case SECUREC_CHAR('h'):
            if (**format == SECUREC_CHAR('h')) {
 8017f28:	687b      	ldr	r3, [r7, #4]
 8017f2a:	681b      	ldr	r3, [r3, #0]
 8017f2c:	781b      	ldrb	r3, [r3, #0]
 8017f2e:	2b68      	cmp	r3, #104	; 0x68
 8017f30:	d10b      	bne.n	8017f4a <SecDecodeSize+0x186>
                *format = *format + 1;
 8017f32:	687b      	ldr	r3, [r7, #4]
 8017f34:	681b      	ldr	r3, [r3, #0]
 8017f36:	1c5a      	adds	r2, r3, #1
 8017f38:	687b      	ldr	r3, [r7, #4]
 8017f3a:	601a      	str	r2, [r3, #0]
                attr->flags |= SECUREC_FLAG_CHAR;   /* For char */
 8017f3c:	68bb      	ldr	r3, [r7, #8]
 8017f3e:	695b      	ldr	r3, [r3, #20]
 8017f40:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 8017f44:	68bb      	ldr	r3, [r7, #8]
 8017f46:	615a      	str	r2, [r3, #20]
            } else {
                attr->flags |= SECUREC_FLAG_SHORT;  /* For short int */
            }
            break;
 8017f48:	e010      	b.n	8017f6c <SecDecodeSize+0x1a8>
                attr->flags |= SECUREC_FLAG_SHORT;  /* For short int */
 8017f4a:	68bb      	ldr	r3, [r7, #8]
 8017f4c:	695b      	ldr	r3, [r3, #20]
 8017f4e:	f043 0220 	orr.w	r2, r3, #32
 8017f52:	68bb      	ldr	r3, [r7, #8]
 8017f54:	615a      	str	r2, [r3, #20]
            break;
 8017f56:	e009      	b.n	8017f6c <SecDecodeSize+0x1a8>
        case SECUREC_CHAR('w'):
            attr->flags |= SECUREC_FLAG_WIDECHAR;   /* For wide char */
 8017f58:	68bb      	ldr	r3, [r7, #8]
 8017f5a:	695b      	ldr	r3, [r3, #20]
 8017f5c:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 8017f60:	68bb      	ldr	r3, [r7, #8]
 8017f62:	615a      	str	r2, [r3, #20]
            break;
 8017f64:	e002      	b.n	8017f6c <SecDecodeSize+0x1a8>
        default:
            /* Do nothing */
            break;
 8017f66:	bf00      	nop
 8017f68:	e000      	b.n	8017f6c <SecDecodeSize+0x1a8>
            break;
 8017f6a:	bf00      	nop
    }
    return 0;
 8017f6c:	2300      	movs	r3, #0
}
 8017f6e:	4618      	mov	r0, r3
 8017f70:	3710      	adds	r7, #16
 8017f72:	46bd      	mov	sp, r7
 8017f74:	bd80      	pop	{r7, pc}
 8017f76:	bf00      	nop

08017f78 <SecDecodeTypeC>:

/*
 * Decoded char type identifier
 */
SECUREC_INLINE void SecDecodeTypeC(SecFormatAttr *attr, unsigned int c)
{
 8017f78:	b480      	push	{r7}
 8017f7a:	b083      	sub	sp, #12
 8017f7c:	af00      	add	r7, sp, #0
 8017f7e:	6078      	str	r0, [r7, #4]
 8017f80:	6039      	str	r1, [r7, #0]
    attr->textLen = 1; /* Only 1 wide character */
 8017f82:	687b      	ldr	r3, [r7, #4]
 8017f84:	2201      	movs	r2, #1
 8017f86:	609a      	str	r2, [r3, #8]

#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT)) && !(defined(__hpux)) && !(defined(SECUREC_ON_SOLARIS))
    attr->flags &= ~SECUREC_FLAG_LEADZERO;
 8017f88:	687b      	ldr	r3, [r7, #4]
 8017f8a:	695b      	ldr	r3, [r3, #20]
 8017f8c:	f023 0208 	bic.w	r2, r3, #8
 8017f90:	687b      	ldr	r3, [r7, #4]
 8017f92:	615a      	str	r2, [r3, #20]
        attr->buffer.wStr[0] = (wchar_t)c;
        attr->text.wStr = attr->buffer.wStr;
        attr->textIsWide = 1;
    }
#else /* Not SECUREC_FOR_WCHAR */
    if ((attr->flags & (SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) != 0) {
 8017f94:	687b      	ldr	r3, [r7, #4]
 8017f96:	695b      	ldr	r3, [r3, #20]
 8017f98:	f403 6301 	and.w	r3, r3, #2064	; 0x810
 8017f9c:	2b00      	cmp	r3, #0
 8017f9e:	d00b      	beq.n	8017fb8 <SecDecodeTypeC+0x40>
#if SECUREC_HAVE_WCHART
        attr->buffer.wStr[0] = (wchar_t)c;
 8017fa0:	687b      	ldr	r3, [r7, #4]
 8017fa2:	683a      	ldr	r2, [r7, #0]
 8017fa4:	635a      	str	r2, [r3, #52]	; 0x34
        attr->text.wStr = attr->buffer.wStr;
 8017fa6:	687b      	ldr	r3, [r7, #4]
 8017fa8:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8017fac:	687b      	ldr	r3, [r7, #4]
 8017fae:	605a      	str	r2, [r3, #4]
        attr->textIsWide = 1;
 8017fb0:	687b      	ldr	r3, [r7, #4]
 8017fb2:	2201      	movs	r2, #1
 8017fb4:	60da      	str	r2, [r3, #12]
        attr->buffer.str[0] = (char)c;
        attr->text.str = attr->buffer.str;
        attr->textIsWide = 0;
    }
#endif
}
 8017fb6:	e00c      	b.n	8017fd2 <SecDecodeTypeC+0x5a>
        attr->buffer.str[0] = (char)c;
 8017fb8:	683b      	ldr	r3, [r7, #0]
 8017fba:	b2da      	uxtb	r2, r3
 8017fbc:	687b      	ldr	r3, [r7, #4]
 8017fbe:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        attr->text.str = attr->buffer.str;
 8017fc2:	687b      	ldr	r3, [r7, #4]
 8017fc4:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8017fc8:	687b      	ldr	r3, [r7, #4]
 8017fca:	605a      	str	r2, [r3, #4]
        attr->textIsWide = 0;
 8017fcc:	687b      	ldr	r3, [r7, #4]
 8017fce:	2200      	movs	r2, #0
 8017fd0:	60da      	str	r2, [r3, #12]
}
 8017fd2:	bf00      	nop
 8017fd4:	370c      	adds	r7, #12
 8017fd6:	46bd      	mov	sp, r7
 8017fd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017fdc:	4770      	bx	lr
	...

08017fe0 <SecDecodeTypeSchar>:
#else
#define SECUREC_IS_NARROW_STRING(attr) (((attr)->flags & (SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) == 0)
#endif

SECUREC_INLINE void SecDecodeTypeSchar(SecFormatAttr *attr)
{
 8017fe0:	b580      	push	{r7, lr}
 8017fe2:	b086      	sub	sp, #24
 8017fe4:	af00      	add	r7, sp, #0
 8017fe6:	6078      	str	r0, [r7, #4]
 8017fe8:	4b22      	ldr	r3, [pc, #136]	; (8018074 <SecDecodeTypeSchar+0x94>)
 8017fea:	681b      	ldr	r3, [r3, #0]
 8017fec:	617b      	str	r3, [r7, #20]
 8017fee:	f04f 0300 	mov.w	r3, #0
    size_t textLen;
    if (attr->text.str == NULL) {
 8017ff2:	687b      	ldr	r3, [r7, #4]
 8017ff4:	685b      	ldr	r3, [r3, #4]
 8017ff6:	2b00      	cmp	r3, #0
 8017ff8:	d102      	bne.n	8018000 <SecDecodeTypeSchar+0x20>
        /*
         * Literal string to print null ptr, define it as array rather than const text area
         * To avoid gcc warning with pointing const text with variable
         */
        static char strNullString[SECUREC_NULL_STRING_SIZE] = "(null)";
        attr->text.str = strNullString;
 8017ffa:	687b      	ldr	r3, [r7, #4]
 8017ffc:	4a1e      	ldr	r2, [pc, #120]	; (8018078 <SecDecodeTypeSchar+0x98>)
 8017ffe:	605a      	str	r2, [r3, #4]
    }
    if (attr->precision == -1) {
 8018000:	687b      	ldr	r3, [r7, #4]
 8018002:	69db      	ldr	r3, [r3, #28]
 8018004:	f1b3 3fff 	cmp.w	r3, #4294967295
 8018008:	d10c      	bne.n	8018024 <SecDecodeTypeSchar+0x44>
        /* Precision NOT assigned */
        /* The strlen performance is high when the string length is greater than 32 */
        textLen = strlen(attr->text.str);
 801800a:	687b      	ldr	r3, [r7, #4]
 801800c:	685b      	ldr	r3, [r3, #4]
 801800e:	4618      	mov	r0, r3
 8018010:	f7f7 fa9d 	bl	800f54e <strlen>
 8018014:	4603      	mov	r3, r0
 8018016:	60bb      	str	r3, [r7, #8]
        if (textLen > SECUREC_STRING_MAX_LEN) {
 8018018:	68bb      	ldr	r3, [r7, #8]
 801801a:	2b00      	cmp	r3, #0
 801801c:	da1b      	bge.n	8018056 <SecDecodeTypeSchar+0x76>
            textLen = 0;
 801801e:	2300      	movs	r3, #0
 8018020:	60bb      	str	r3, [r7, #8]
 8018022:	e018      	b.n	8018056 <SecDecodeTypeSchar+0x76>
        }
    } else {
        /* Precision assigned */
        SECUREC_CALC_STR_LEN(attr->text.str, (size_t)(unsigned int)attr->precision, &textLen);
 8018024:	687b      	ldr	r3, [r7, #4]
 8018026:	685b      	ldr	r3, [r3, #4]
 8018028:	60fb      	str	r3, [r7, #12]
 801802a:	687b      	ldr	r3, [r7, #4]
 801802c:	69db      	ldr	r3, [r3, #28]
 801802e:	613b      	str	r3, [r7, #16]
 8018030:	e005      	b.n	801803e <SecDecodeTypeSchar+0x5e>
 8018032:	693b      	ldr	r3, [r7, #16]
 8018034:	3b01      	subs	r3, #1
 8018036:	613b      	str	r3, [r7, #16]
 8018038:	68fb      	ldr	r3, [r7, #12]
 801803a:	3301      	adds	r3, #1
 801803c:	60fb      	str	r3, [r7, #12]
 801803e:	693b      	ldr	r3, [r7, #16]
 8018040:	2b00      	cmp	r3, #0
 8018042:	d003      	beq.n	801804c <SecDecodeTypeSchar+0x6c>
 8018044:	68fb      	ldr	r3, [r7, #12]
 8018046:	781b      	ldrb	r3, [r3, #0]
 8018048:	2b00      	cmp	r3, #0
 801804a:	d1f2      	bne.n	8018032 <SecDecodeTypeSchar+0x52>
 801804c:	687b      	ldr	r3, [r7, #4]
 801804e:	685b      	ldr	r3, [r3, #4]
 8018050:	68fa      	ldr	r2, [r7, #12]
 8018052:	1ad3      	subs	r3, r2, r3
 8018054:	60bb      	str	r3, [r7, #8]
    }
    attr->textLen = (int)textLen;
 8018056:	68bb      	ldr	r3, [r7, #8]
 8018058:	461a      	mov	r2, r3
 801805a:	687b      	ldr	r3, [r7, #4]
 801805c:	609a      	str	r2, [r3, #8]
}
 801805e:	bf00      	nop
 8018060:	4b04      	ldr	r3, [pc, #16]	; (8018074 <SecDecodeTypeSchar+0x94>)
 8018062:	681a      	ldr	r2, [r3, #0]
 8018064:	697b      	ldr	r3, [r7, #20]
 8018066:	405a      	eors	r2, r3
 8018068:	d001      	beq.n	801806e <SecDecodeTypeSchar+0x8e>
 801806a:	f7ec fab7 	bl	80045dc <__stack_chk_fail>
 801806e:	3718      	adds	r7, #24
 8018070:	46bd      	mov	sp, r7
 8018072:	bd80      	pop	{r7, pc}
 8018074:	080230b8 	.word	0x080230b8
 8018078:	20000538 	.word	0x20000538

0801807c <SecDecodeTypeSwchar>:

SECUREC_INLINE void SecDecodeTypeSwchar(SecFormatAttr *attr)
{
 801807c:	b580      	push	{r7, lr}
 801807e:	b086      	sub	sp, #24
 8018080:	af00      	add	r7, sp, #0
 8018082:	6078      	str	r0, [r7, #4]
 8018084:	4b1d      	ldr	r3, [pc, #116]	; (80180fc <SecDecodeTypeSwchar+0x80>)
 8018086:	681b      	ldr	r3, [r3, #0]
 8018088:	617b      	str	r3, [r7, #20]
 801808a:	f04f 0300 	mov.w	r3, #0
#if SECUREC_HAVE_WCHART
    size_t textLen;
    attr->textIsWide = 1;
 801808e:	687b      	ldr	r3, [r7, #4]
 8018090:	2201      	movs	r2, #1
 8018092:	60da      	str	r2, [r3, #12]
    if (attr->text.wStr == NULL) {
 8018094:	687b      	ldr	r3, [r7, #4]
 8018096:	685b      	ldr	r3, [r3, #4]
 8018098:	2b00      	cmp	r3, #0
 801809a:	d102      	bne.n	80180a2 <SecDecodeTypeSwchar+0x26>
        /*
         * Literal string to print null ptr, define it as array rather than const text area
         * To avoid gcc warning with pointing const text with variable
         */
        static wchar_t wStrNullString[SECUREC_NULL_STRING_SIZE] = { L'(', L'n', L'u', L'l', L'l', L')', L'\0', L'\0' };
        attr->text.wStr = wStrNullString;
 801809c:	687b      	ldr	r3, [r7, #4]
 801809e:	4a18      	ldr	r2, [pc, #96]	; (8018100 <SecDecodeTypeSwchar+0x84>)
 80180a0:	605a      	str	r2, [r3, #4]
    }
    /* The textLen in wchar_t,when precision is -1, it is unlimited  */
    SECUREC_CALC_WSTR_LEN(attr->text.wStr, (size_t)(unsigned int)attr->precision, &textLen);
 80180a2:	687b      	ldr	r3, [r7, #4]
 80180a4:	685b      	ldr	r3, [r3, #4]
 80180a6:	60fb      	str	r3, [r7, #12]
 80180a8:	2300      	movs	r3, #0
 80180aa:	613b      	str	r3, [r7, #16]
 80180ac:	e005      	b.n	80180ba <SecDecodeTypeSwchar+0x3e>
 80180ae:	693b      	ldr	r3, [r7, #16]
 80180b0:	3301      	adds	r3, #1
 80180b2:	613b      	str	r3, [r7, #16]
 80180b4:	68fb      	ldr	r3, [r7, #12]
 80180b6:	3304      	adds	r3, #4
 80180b8:	60fb      	str	r3, [r7, #12]
 80180ba:	687b      	ldr	r3, [r7, #4]
 80180bc:	69db      	ldr	r3, [r3, #28]
 80180be:	461a      	mov	r2, r3
 80180c0:	693b      	ldr	r3, [r7, #16]
 80180c2:	4293      	cmp	r3, r2
 80180c4:	d203      	bcs.n	80180ce <SecDecodeTypeSwchar+0x52>
 80180c6:	68fb      	ldr	r3, [r7, #12]
 80180c8:	681b      	ldr	r3, [r3, #0]
 80180ca:	2b00      	cmp	r3, #0
 80180cc:	d1ef      	bne.n	80180ae <SecDecodeTypeSwchar+0x32>
 80180ce:	693b      	ldr	r3, [r7, #16]
 80180d0:	60bb      	str	r3, [r7, #8]
    if (textLen > SECUREC_WCHAR_STRING_MAX_LEN) {
 80180d2:	68bb      	ldr	r3, [r7, #8]
 80180d4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80180d8:	d301      	bcc.n	80180de <SecDecodeTypeSwchar+0x62>
        textLen = 0;
 80180da:	2300      	movs	r3, #0
 80180dc:	60bb      	str	r3, [r7, #8]
    }
    attr->textLen = (int)textLen;
 80180de:	68bb      	ldr	r3, [r7, #8]
 80180e0:	461a      	mov	r2, r3
 80180e2:	687b      	ldr	r3, [r7, #4]
 80180e4:	609a      	str	r2, [r3, #8]
#else
    attr->textLen = 0;
#endif
}
 80180e6:	bf00      	nop
 80180e8:	4b04      	ldr	r3, [pc, #16]	; (80180fc <SecDecodeTypeSwchar+0x80>)
 80180ea:	681a      	ldr	r2, [r3, #0]
 80180ec:	697b      	ldr	r3, [r7, #20]
 80180ee:	405a      	eors	r2, r3
 80180f0:	d001      	beq.n	80180f6 <SecDecodeTypeSwchar+0x7a>
 80180f2:	f7ec fa73 	bl	80045dc <__stack_chk_fail>
 80180f6:	3718      	adds	r7, #24
 80180f8:	46bd      	mov	sp, r7
 80180fa:	bd80      	pop	{r7, pc}
 80180fc:	080230bc 	.word	0x080230bc
 8018100:	20000540 	.word	0x20000540

08018104 <SecDecodeTypeS>:

/*
 * Decoded string identifier
 */
SECUREC_INLINE void SecDecodeTypeS(SecFormatAttr *attr, char *argPtr)
{
 8018104:	b580      	push	{r7, lr}
 8018106:	b082      	sub	sp, #8
 8018108:	af00      	add	r7, sp, #0
 801810a:	6078      	str	r0, [r7, #4]
 801810c:	6039      	str	r1, [r7, #0]
#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT))
#if (!defined(SECUREC_ON_UNIX))
    attr->flags &= ~SECUREC_FLAG_LEADZERO;
 801810e:	687b      	ldr	r3, [r7, #4]
 8018110:	695b      	ldr	r3, [r3, #20]
 8018112:	f023 0208 	bic.w	r2, r3, #8
 8018116:	687b      	ldr	r3, [r7, #4]
 8018118:	615a      	str	r2, [r3, #20]
    if ((attr->flags & SECUREC_FLAG_LONG) == 0) {
        attr->flags |= SECUREC_FLAG_SHORT;
    }
#endif
#endif
    attr->text.str = argPtr;
 801811a:	687b      	ldr	r3, [r7, #4]
 801811c:	683a      	ldr	r2, [r7, #0]
 801811e:	605a      	str	r2, [r3, #4]
    if (SECUREC_IS_NARROW_STRING(attr)) {
 8018120:	687b      	ldr	r3, [r7, #4]
 8018122:	695b      	ldr	r3, [r3, #20]
 8018124:	f403 6301 	and.w	r3, r3, #2064	; 0x810
 8018128:	2b00      	cmp	r3, #0
 801812a:	d103      	bne.n	8018134 <SecDecodeTypeS+0x30>
        /* The textLen now contains length in multibyte chars */
        SecDecodeTypeSchar(attr);
 801812c:	6878      	ldr	r0, [r7, #4]
 801812e:	f7ff ff57 	bl	8017fe0 <SecDecodeTypeSchar>
    } else {
        /* The textLen now contains length in wide chars */
        SecDecodeTypeSwchar(attr);
    }
}
 8018132:	e002      	b.n	801813a <SecDecodeTypeS+0x36>
        SecDecodeTypeSwchar(attr);
 8018134:	6878      	ldr	r0, [r7, #4]
 8018136:	f7ff ffa1 	bl	801807c <SecDecodeTypeSwchar>
}
 801813a:	bf00      	nop
 801813c:	3708      	adds	r7, #8
 801813e:	46bd      	mov	sp, r7
 8018140:	bd80      	pop	{r7, pc}
	...

08018144 <SecDecodePrecision>:

/*
 * Check precision in format
 */
SECUREC_INLINE int SecDecodePrecision(SecChar ch, SecFormatAttr *attr)
{
 8018144:	b480      	push	{r7}
 8018146:	b083      	sub	sp, #12
 8018148:	af00      	add	r7, sp, #0
 801814a:	4603      	mov	r3, r0
 801814c:	6039      	str	r1, [r7, #0]
 801814e:	71fb      	strb	r3, [r7, #7]
    if (attr->dynPrecision == 0) {
 8018150:	683b      	ldr	r3, [r7, #0]
 8018152:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8018154:	2b00      	cmp	r3, #0
 8018156:	d116      	bne.n	8018186 <SecDecodePrecision+0x42>
        /* Add digit to current precision */
        if (SECUREC_MUL_TEN_ADD_BEYOND_MAX(attr->precision)) {
 8018158:	683b      	ldr	r3, [r7, #0]
 801815a:	69db      	ldr	r3, [r3, #28]
 801815c:	4a15      	ldr	r2, [pc, #84]	; (80181b4 <SecDecodePrecision+0x70>)
 801815e:	4293      	cmp	r3, r2
 8018160:	dd02      	ble.n	8018168 <SecDecodePrecision+0x24>
            return -1;
 8018162:	f04f 33ff 	mov.w	r3, #4294967295
 8018166:	e01f      	b.n	80181a8 <SecDecodePrecision+0x64>
        }
        attr->precision = (int)SECUREC_MUL_TEN((unsigned int)attr->precision) +
 8018168:	683b      	ldr	r3, [r7, #0]
 801816a:	69db      	ldr	r3, [r3, #28]
 801816c:	009b      	lsls	r3, r3, #2
 801816e:	683a      	ldr	r2, [r7, #0]
 8018170:	69d2      	ldr	r2, [r2, #28]
 8018172:	4413      	add	r3, r2
 8018174:	005b      	lsls	r3, r3, #1
 8018176:	461a      	mov	r2, r3
            (unsigned char)(ch - SECUREC_CHAR('0'));
 8018178:	79fb      	ldrb	r3, [r7, #7]
 801817a:	3b30      	subs	r3, #48	; 0x30
 801817c:	b2db      	uxtb	r3, r3
        attr->precision = (int)SECUREC_MUL_TEN((unsigned int)attr->precision) +
 801817e:	441a      	add	r2, r3
 8018180:	683b      	ldr	r3, [r7, #0]
 8018182:	61da      	str	r2, [r3, #28]
 8018184:	e00f      	b.n	80181a6 <SecDecodePrecision+0x62>
    } else {
        if (attr->precision < 0) {
 8018186:	683b      	ldr	r3, [r7, #0]
 8018188:	69db      	ldr	r3, [r3, #28]
 801818a:	2b00      	cmp	r3, #0
 801818c:	da03      	bge.n	8018196 <SecDecodePrecision+0x52>
            attr->precision = -1;
 801818e:	683b      	ldr	r3, [r7, #0]
 8018190:	f04f 32ff 	mov.w	r2, #4294967295
 8018194:	61da      	str	r2, [r3, #28]
        }
        if (attr->precision > SECUREC_MAX_WIDTH_LEN) {
 8018196:	683b      	ldr	r3, [r7, #0]
 8018198:	69db      	ldr	r3, [r3, #28]
 801819a:	4a07      	ldr	r2, [pc, #28]	; (80181b8 <SecDecodePrecision+0x74>)
 801819c:	4293      	cmp	r3, r2
 801819e:	dd02      	ble.n	80181a6 <SecDecodePrecision+0x62>
            return -1;
 80181a0:	f04f 33ff 	mov.w	r3, #4294967295
 80181a4:	e000      	b.n	80181a8 <SecDecodePrecision+0x64>
        }
    }
    return 0;
 80181a6:	2300      	movs	r3, #0
}
 80181a8:	4618      	mov	r0, r3
 80181aa:	370c      	adds	r7, #12
 80181ac:	46bd      	mov	sp, r7
 80181ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80181b2:	4770      	bx	lr
 80181b4:	0147ae14 	.word	0x0147ae14
 80181b8:	0cccccc8 	.word	0x0cccccc8

080181bc <SecDecodeWidth>:

/*
 * Check width in format
 */
SECUREC_INLINE int SecDecodeWidth(SecChar ch, SecFormatAttr *attr, SecFmtState lastState)
{
 80181bc:	b480      	push	{r7}
 80181be:	b085      	sub	sp, #20
 80181c0:	af00      	add	r7, sp, #0
 80181c2:	4603      	mov	r3, r0
 80181c4:	60b9      	str	r1, [r7, #8]
 80181c6:	607a      	str	r2, [r7, #4]
 80181c8:	73fb      	strb	r3, [r7, #15]
    if (attr->dynWidth == 0) {
 80181ca:	68bb      	ldr	r3, [r7, #8]
 80181cc:	6a1b      	ldr	r3, [r3, #32]
 80181ce:	2b00      	cmp	r3, #0
 80181d0:	d11c      	bne.n	801820c <SecDecodeWidth+0x50>
        if (lastState != STAT_WIDTH) {
 80181d2:	687b      	ldr	r3, [r7, #4]
 80181d4:	2b03      	cmp	r3, #3
 80181d6:	d002      	beq.n	80181de <SecDecodeWidth+0x22>
            attr->fldWidth = 0;
 80181d8:	68bb      	ldr	r3, [r7, #8]
 80181da:	2200      	movs	r2, #0
 80181dc:	619a      	str	r2, [r3, #24]
        }
        if (SECUREC_MUL_TEN_ADD_BEYOND_MAX(attr->fldWidth)) {
 80181de:	68bb      	ldr	r3, [r7, #8]
 80181e0:	699b      	ldr	r3, [r3, #24]
 80181e2:	4a19      	ldr	r2, [pc, #100]	; (8018248 <SecDecodeWidth+0x8c>)
 80181e4:	4293      	cmp	r3, r2
 80181e6:	dd02      	ble.n	80181ee <SecDecodeWidth+0x32>
            return -1;
 80181e8:	f04f 33ff 	mov.w	r3, #4294967295
 80181ec:	e026      	b.n	801823c <SecDecodeWidth+0x80>
        }
        attr->fldWidth = (int)SECUREC_MUL_TEN((unsigned int)attr->fldWidth) +
 80181ee:	68bb      	ldr	r3, [r7, #8]
 80181f0:	699b      	ldr	r3, [r3, #24]
 80181f2:	009b      	lsls	r3, r3, #2
 80181f4:	68ba      	ldr	r2, [r7, #8]
 80181f6:	6992      	ldr	r2, [r2, #24]
 80181f8:	4413      	add	r3, r2
 80181fa:	005b      	lsls	r3, r3, #1
 80181fc:	461a      	mov	r2, r3
            (unsigned char)(ch - SECUREC_CHAR('0'));
 80181fe:	7bfb      	ldrb	r3, [r7, #15]
 8018200:	3b30      	subs	r3, #48	; 0x30
 8018202:	b2db      	uxtb	r3, r3
        attr->fldWidth = (int)SECUREC_MUL_TEN((unsigned int)attr->fldWidth) +
 8018204:	441a      	add	r2, r3
 8018206:	68bb      	ldr	r3, [r7, #8]
 8018208:	619a      	str	r2, [r3, #24]
 801820a:	e016      	b.n	801823a <SecDecodeWidth+0x7e>
    } else {
        if (attr->fldWidth < 0) {
 801820c:	68bb      	ldr	r3, [r7, #8]
 801820e:	699b      	ldr	r3, [r3, #24]
 8018210:	2b00      	cmp	r3, #0
 8018212:	da0a      	bge.n	801822a <SecDecodeWidth+0x6e>
            attr->flags |= SECUREC_FLAG_LEFT;
 8018214:	68bb      	ldr	r3, [r7, #8]
 8018216:	695b      	ldr	r3, [r3, #20]
 8018218:	f043 0204 	orr.w	r2, r3, #4
 801821c:	68bb      	ldr	r3, [r7, #8]
 801821e:	615a      	str	r2, [r3, #20]
            attr->fldWidth = (-attr->fldWidth);
 8018220:	68bb      	ldr	r3, [r7, #8]
 8018222:	699b      	ldr	r3, [r3, #24]
 8018224:	425a      	negs	r2, r3
 8018226:	68bb      	ldr	r3, [r7, #8]
 8018228:	619a      	str	r2, [r3, #24]
        }
        if (attr->fldWidth > SECUREC_MAX_WIDTH_LEN) {
 801822a:	68bb      	ldr	r3, [r7, #8]
 801822c:	699b      	ldr	r3, [r3, #24]
 801822e:	4a07      	ldr	r2, [pc, #28]	; (801824c <SecDecodeWidth+0x90>)
 8018230:	4293      	cmp	r3, r2
 8018232:	dd02      	ble.n	801823a <SecDecodeWidth+0x7e>
            return -1;
 8018234:	f04f 33ff 	mov.w	r3, #4294967295
 8018238:	e000      	b.n	801823c <SecDecodeWidth+0x80>
        }
    }
    return 0;
 801823a:	2300      	movs	r3, #0
}
 801823c:	4618      	mov	r0, r3
 801823e:	3714      	adds	r7, #20
 8018240:	46bd      	mov	sp, r7
 8018242:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018246:	4770      	bx	lr
 8018248:	0147ae14 	.word	0x0147ae14
 801824c:	0cccccc8 	.word	0x0cccccc8

08018250 <SecUpdateWcharFlags>:
/*
 * The sprintf_s function processes the wide character as a parameter for %C
 * The swprintf_s function processes the multiple character as a parameter for %C
 */
SECUREC_INLINE void SecUpdateWcharFlags(SecFormatAttr *attr)
{
 8018250:	b480      	push	{r7}
 8018252:	b083      	sub	sp, #12
 8018254:	af00      	add	r7, sp, #0
 8018256:	6078      	str	r0, [r7, #4]
    if ((attr->flags & (SECUREC_FLAG_SHORT | SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) == 0) {
 8018258:	687b      	ldr	r3, [r7, #4]
 801825a:	695b      	ldr	r3, [r3, #20]
 801825c:	f403 6303 	and.w	r3, r3, #2096	; 0x830
 8018260:	2b00      	cmp	r3, #0
 8018262:	d105      	bne.n	8018270 <SecUpdateWcharFlags+0x20>
#ifdef SECUREC_FOR_WCHAR
        attr->flags |= SECUREC_FLAG_SHORT;
#else
        attr->flags |= SECUREC_FLAG_WIDECHAR;
 8018264:	687b      	ldr	r3, [r7, #4]
 8018266:	695b      	ldr	r3, [r3, #20]
 8018268:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 801826c:	687b      	ldr	r3, [r7, #4]
 801826e:	615a      	str	r2, [r3, #20]
#endif
    }
}
 8018270:	bf00      	nop
 8018272:	370c      	adds	r7, #12
 8018274:	46bd      	mov	sp, r7
 8018276:	f85d 7b04 	ldr.w	r7, [sp], #4
 801827a:	4770      	bx	lr

0801827c <SecUpdateWstringFlags>:
/*
 * When encountering %S, current just same as %C
 */
SECUREC_INLINE void SecUpdateWstringFlags(SecFormatAttr *attr)
{
 801827c:	b580      	push	{r7, lr}
 801827e:	b082      	sub	sp, #8
 8018280:	af00      	add	r7, sp, #0
 8018282:	6078      	str	r0, [r7, #4]
    SecUpdateWcharFlags(attr);
 8018284:	6878      	ldr	r0, [r7, #4]
 8018286:	f7ff ffe3 	bl	8018250 <SecUpdateWcharFlags>
}
 801828a:	bf00      	nop
 801828c:	3708      	adds	r7, #8
 801828e:	46bd      	mov	sp, r7
 8018290:	bd80      	pop	{r7, pc}
	...

08018294 <SecUpdatePointFlags>:
    attr->flags |= SECUREC_FLAG_LONG;  /* Converting a long */
}
#endif

SECUREC_INLINE void SecUpdatePointFlags(SecFormatAttr *attr)
{
 8018294:	b480      	push	{r7}
 8018296:	b083      	sub	sp, #12
 8018298:	af00      	add	r7, sp, #0
 801829a:	6078      	str	r0, [r7, #4]
    attr->flags |= SECUREC_FLAG_POINTER;
 801829c:	687b      	ldr	r3, [r7, #4]
 801829e:	695b      	ldr	r3, [r3, #20]
 80182a0:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
 80182a4:	687b      	ldr	r3, [r7, #4]
 80182a6:	615a      	str	r2, [r3, #20]
#else
#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) || defined(SECUREC_VXWORKS_PLATFORM)) && (!defined(SECUREC_ON_UNIX))
#if defined(SECUREC_VXWORKS_PLATFORM)
    attr->precision = 1;
#else
    attr->precision = 0;
 80182a8:	687b      	ldr	r3, [r7, #4]
 80182aa:	2200      	movs	r2, #0
 80182ac:	61da      	str	r2, [r3, #28]
#endif
    attr->flags |= SECUREC_FLAG_ALTERNATE; /* "0x" is not default prefix in UNIX */
 80182ae:	687b      	ldr	r3, [r7, #4]
 80182b0:	695b      	ldr	r3, [r3, #20]
 80182b2:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80182b6:	687b      	ldr	r3, [r7, #4]
 80182b8:	615a      	str	r2, [r3, #20]
    attr->digits = g_itoaLowerDigits;
 80182ba:	687b      	ldr	r3, [r7, #4]
 80182bc:	4a0f      	ldr	r2, [pc, #60]	; (80182fc <SecUpdatePointFlags+0x68>)
 80182be:	601a      	str	r2, [r3, #0]
#endif

#ifdef SECUREC_ON_64BITS
    attr->flags |= SECUREC_FLAG_I64;   /* Converting an int64 */
#else
    attr->flags |= SECUREC_FLAG_LONG;  /* Converting a long */
 80182c0:	687b      	ldr	r3, [r7, #4]
 80182c2:	695b      	ldr	r3, [r3, #20]
 80182c4:	f043 0210 	orr.w	r2, r3, #16
 80182c8:	687b      	ldr	r3, [r7, #4]
 80182ca:	615a      	str	r2, [r3, #20]
#endif
    /* Set up for %#p on different system */
    if ((attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
 80182cc:	687b      	ldr	r3, [r7, #4]
 80182ce:	695b      	ldr	r3, [r3, #20]
 80182d0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80182d4:	2b00      	cmp	r3, #0
 80182d6:	d00a      	beq.n	80182ee <SecUpdatePointFlags+0x5a>
        /* Alternate form means '0x' prefix */
        attr->prefix[0] = SECUREC_CHAR('0');
 80182d8:	687b      	ldr	r3, [r7, #4]
 80182da:	2230      	movs	r2, #48	; 0x30
 80182dc:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) || defined(SECUREC_VXWORKS_PLATFORM))
        attr->prefix[1] = SECUREC_CHAR('x');
 80182e0:	687b      	ldr	r3, [r7, #4]
 80182e2:	2278      	movs	r2, #120	; 0x78
 80182e4:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
        attr->prefix[1] = (SecChar)(attr->digits[SECUREC_NUMBER_OF_X]);
#endif
#if defined(_AIX) || defined(SECUREC_ON_SOLARIS)
        attr->prefixLen = 0;
#else
        attr->prefixLen = SECUREC_PREFIX_LEN;
 80182e8:	687b      	ldr	r3, [r7, #4]
 80182ea:	2202      	movs	r2, #2
 80182ec:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
    }
#endif
}
 80182ee:	bf00      	nop
 80182f0:	370c      	adds	r7, #12
 80182f2:	46bd      	mov	sp, r7
 80182f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80182f8:	4770      	bx	lr
 80182fa:	bf00      	nop
 80182fc:	080236ac 	.word	0x080236ac

08018300 <SecUpdateXpxFlags>:

SECUREC_INLINE void SecUpdateXpxFlags(SecFormatAttr *attr, SecChar ch)
{
 8018300:	b580      	push	{r7, lr}
 8018302:	b082      	sub	sp, #8
 8018304:	af00      	add	r7, sp, #0
 8018306:	6078      	str	r0, [r7, #4]
 8018308:	460b      	mov	r3, r1
 801830a:	70fb      	strb	r3, [r7, #3]
    /* Use unsigned lower hex output for 'x' */
    attr->digits = g_itoaLowerDigits;
 801830c:	687b      	ldr	r3, [r7, #4]
 801830e:	4a15      	ldr	r2, [pc, #84]	; (8018364 <SecUpdateXpxFlags+0x64>)
 8018310:	601a      	str	r2, [r3, #0]
    attr->radix = SECUREC_RADIX_HEX;
 8018312:	687b      	ldr	r3, [r7, #4]
 8018314:	2210      	movs	r2, #16
 8018316:	611a      	str	r2, [r3, #16]
    switch (ch) {
 8018318:	78fb      	ldrb	r3, [r7, #3]
 801831a:	2b58      	cmp	r3, #88	; 0x58
 801831c:	d005      	beq.n	801832a <SecUpdateXpxFlags+0x2a>
 801831e:	2b70      	cmp	r3, #112	; 0x70
 8018320:	d106      	bne.n	8018330 <SecUpdateXpxFlags+0x30>
        case SECUREC_CHAR('p'):
            /* Print a pointer */
            SecUpdatePointFlags(attr);
 8018322:	6878      	ldr	r0, [r7, #4]
 8018324:	f7ff ffb6 	bl	8018294 <SecUpdatePointFlags>
            break;
 8018328:	e017      	b.n	801835a <SecUpdateXpxFlags+0x5a>
        case SECUREC_CHAR('X'): /* fall-through */ /* FALLTHRU */
            /* Unsigned upper hex output */
            attr->digits = g_itoaUpperDigits;
 801832a:	687b      	ldr	r3, [r7, #4]
 801832c:	4a0e      	ldr	r2, [pc, #56]	; (8018368 <SecUpdateXpxFlags+0x68>)
 801832e:	601a      	str	r2, [r3, #0]
            /* fall-through */ /* FALLTHRU */
        default:
            /* For %#x or %#X */
            if ((attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
 8018330:	687b      	ldr	r3, [r7, #4]
 8018332:	695b      	ldr	r3, [r3, #20]
 8018334:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8018338:	2b00      	cmp	r3, #0
 801833a:	d00d      	beq.n	8018358 <SecUpdateXpxFlags+0x58>
                /* Alternate form means '0x' prefix */
                attr->prefix[0] = SECUREC_CHAR('0');
 801833c:	687b      	ldr	r3, [r7, #4]
 801833e:	2230      	movs	r2, #48	; 0x30
 8018340:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                attr->prefix[1] = (SecChar)(attr->digits[SECUREC_NUMBER_OF_X]);
 8018344:	687b      	ldr	r3, [r7, #4]
 8018346:	681b      	ldr	r3, [r3, #0]
 8018348:	3310      	adds	r3, #16
 801834a:	781a      	ldrb	r2, [r3, #0]
 801834c:	687b      	ldr	r3, [r7, #4]
 801834e:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
                attr->prefixLen = SECUREC_PREFIX_LEN;
 8018352:	687b      	ldr	r3, [r7, #4]
 8018354:	2202      	movs	r2, #2
 8018356:	62da      	str	r2, [r3, #44]	; 0x2c
            }
            break;
 8018358:	bf00      	nop
    }
}
 801835a:	bf00      	nop
 801835c:	3708      	adds	r7, #8
 801835e:	46bd      	mov	sp, r7
 8018360:	bd80      	pop	{r7, pc}
 8018362:	bf00      	nop
 8018364:	080236ac 	.word	0x080236ac
 8018368:	08023698 	.word	0x08023698

0801836c <SecUpdateOudiFlags>:

SECUREC_INLINE void SecUpdateOudiFlags(SecFormatAttr *attr, SecChar ch)
{
 801836c:	b480      	push	{r7}
 801836e:	b083      	sub	sp, #12
 8018370:	af00      	add	r7, sp, #0
 8018372:	6078      	str	r0, [r7, #4]
 8018374:	460b      	mov	r3, r1
 8018376:	70fb      	strb	r3, [r7, #3]
    /* Do not set digits here */
    switch (ch) {
 8018378:	78fb      	ldrb	r3, [r7, #3]
 801837a:	3b64      	subs	r3, #100	; 0x64
 801837c:	2b11      	cmp	r3, #17
 801837e:	d847      	bhi.n	8018410 <SecUpdateOudiFlags+0xa4>
 8018380:	a201      	add	r2, pc, #4	; (adr r2, 8018388 <SecUpdateOudiFlags+0x1c>)
 8018382:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018386:	bf00      	nop
 8018388:	080183d1 	.word	0x080183d1
 801838c:	08018411 	.word	0x08018411
 8018390:	08018411 	.word	0x08018411
 8018394:	08018411 	.word	0x08018411
 8018398:	08018411 	.word	0x08018411
 801839c:	080183d1 	.word	0x080183d1
 80183a0:	08018411 	.word	0x08018411
 80183a4:	08018411 	.word	0x08018411
 80183a8:	08018411 	.word	0x08018411
 80183ac:	08018411 	.word	0x08018411
 80183b0:	08018411 	.word	0x08018411
 80183b4:	080183eb 	.word	0x080183eb
 80183b8:	08018411 	.word	0x08018411
 80183bc:	08018411 	.word	0x08018411
 80183c0:	08018411 	.word	0x08018411
 80183c4:	08018411 	.word	0x08018411
 80183c8:	08018411 	.word	0x08018411
 80183cc:	080183dd 	.word	0x080183dd
        case SECUREC_CHAR('i'): /* fall-through */ /* FALLTHRU */
        case SECUREC_CHAR('d'): /* fall-through */ /* FALLTHRU */
            /* For signed decimal output */
            attr->flags |= SECUREC_FLAG_SIGNED;
 80183d0:	687b      	ldr	r3, [r7, #4]
 80183d2:	695b      	ldr	r3, [r3, #20]
 80183d4:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 80183d8:	687b      	ldr	r3, [r7, #4]
 80183da:	615a      	str	r2, [r3, #20]
            /* fall-through */ /* FALLTHRU */
        case SECUREC_CHAR('u'):
            attr->radix = SECUREC_RADIX_DECIMAL;
 80183dc:	687b      	ldr	r3, [r7, #4]
 80183de:	220a      	movs	r2, #10
 80183e0:	611a      	str	r2, [r3, #16]
            attr->digits = g_itoaLowerDigits;
 80183e2:	687b      	ldr	r3, [r7, #4]
 80183e4:	4a0f      	ldr	r2, [pc, #60]	; (8018424 <SecUpdateOudiFlags+0xb8>)
 80183e6:	601a      	str	r2, [r3, #0]
            break;
 80183e8:	e015      	b.n	8018416 <SecUpdateOudiFlags+0xaa>
        case SECUREC_CHAR('o'):
            /* For unsigned octal output */
            attr->radix = SECUREC_RADIX_OCTAL;
 80183ea:	687b      	ldr	r3, [r7, #4]
 80183ec:	2208      	movs	r2, #8
 80183ee:	611a      	str	r2, [r3, #16]
            attr->digits = g_itoaLowerDigits;
 80183f0:	687b      	ldr	r3, [r7, #4]
 80183f2:	4a0c      	ldr	r2, [pc, #48]	; (8018424 <SecUpdateOudiFlags+0xb8>)
 80183f4:	601a      	str	r2, [r3, #0]
            if ((attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
 80183f6:	687b      	ldr	r3, [r7, #4]
 80183f8:	695b      	ldr	r3, [r3, #20]
 80183fa:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80183fe:	2b00      	cmp	r3, #0
 8018400:	d008      	beq.n	8018414 <SecUpdateOudiFlags+0xa8>
                /* Alternate form means force a leading 0 */
                attr->flags |= SECUREC_FLAG_FORCE_OCTAL;
 8018402:	687b      	ldr	r3, [r7, #4]
 8018404:	695b      	ldr	r3, [r3, #20]
 8018406:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 801840a:	687b      	ldr	r3, [r7, #4]
 801840c:	615a      	str	r2, [r3, #20]
            }
            break;
 801840e:	e001      	b.n	8018414 <SecUpdateOudiFlags+0xa8>
        default:
            /* Do nothing */
            break;
 8018410:	bf00      	nop
 8018412:	e000      	b.n	8018416 <SecUpdateOudiFlags+0xaa>
            break;
 8018414:	bf00      	nop
    }
}
 8018416:	bf00      	nop
 8018418:	370c      	adds	r7, #12
 801841a:	46bd      	mov	sp, r7
 801841c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018420:	4770      	bx	lr
 8018422:	bf00      	nop
 8018424:	080236ac 	.word	0x080236ac

08018428 <SecFreeFloatBuffer>:

#if SECUREC_ENABLE_SPRINTF_FLOAT
SECUREC_INLINE void SecFreeFloatBuffer(SecFloatAdapt *floatAdapt)
{
 8018428:	b580      	push	{r7, lr}
 801842a:	b082      	sub	sp, #8
 801842c:	af00      	add	r7, sp, #0
 801842e:	6078      	str	r0, [r7, #4]
    if (floatAdapt->floatBuffer != NULL) {
 8018430:	687b      	ldr	r3, [r7, #4]
 8018432:	699b      	ldr	r3, [r3, #24]
 8018434:	2b00      	cmp	r3, #0
 8018436:	d004      	beq.n	8018442 <SecFreeFloatBuffer+0x1a>
        SECUREC_FREE(floatAdapt->floatBuffer);
 8018438:	687b      	ldr	r3, [r7, #4]
 801843a:	699b      	ldr	r3, [r3, #24]
 801843c:	4618      	mov	r0, r3
 801843e:	f002 fadf 	bl	801aa00 <free>
    }
    if (floatAdapt->allocatedFmtStr != NULL) {
 8018442:	687b      	ldr	r3, [r7, #4]
 8018444:	695b      	ldr	r3, [r3, #20]
 8018446:	2b00      	cmp	r3, #0
 8018448:	d004      	beq.n	8018454 <SecFreeFloatBuffer+0x2c>
        SECUREC_FREE(floatAdapt->allocatedFmtStr);
 801844a:	687b      	ldr	r3, [r7, #4]
 801844c:	695b      	ldr	r3, [r3, #20]
 801844e:	4618      	mov	r0, r3
 8018450:	f002 fad6 	bl	801aa00 <free>
    }
    floatAdapt->floatBuffer = NULL;
 8018454:	687b      	ldr	r3, [r7, #4]
 8018456:	2200      	movs	r2, #0
 8018458:	619a      	str	r2, [r3, #24]
    floatAdapt->allocatedFmtStr = NULL;
 801845a:	687b      	ldr	r3, [r7, #4]
 801845c:	2200      	movs	r2, #0
 801845e:	615a      	str	r2, [r3, #20]
    floatAdapt->fmtStr = NULL;
 8018460:	687b      	ldr	r3, [r7, #4]
 8018462:	2200      	movs	r2, #0
 8018464:	611a      	str	r2, [r3, #16]
    floatAdapt->bufferSize = 0;
 8018466:	687b      	ldr	r3, [r7, #4]
 8018468:	2200      	movs	r2, #0
 801846a:	61da      	str	r2, [r3, #28]
}
 801846c:	bf00      	nop
 801846e:	3708      	adds	r7, #8
 8018470:	46bd      	mov	sp, r7
 8018472:	bd80      	pop	{r7, pc}

08018474 <SecSeekToFrontPercent>:

SECUREC_INLINE void SecSeekToFrontPercent(const SecChar **format)
{
 8018474:	b480      	push	{r7}
 8018476:	b085      	sub	sp, #20
 8018478:	af00      	add	r7, sp, #0
 801847a:	6078      	str	r0, [r7, #4]
    const SecChar *fmt = *format;
 801847c:	687b      	ldr	r3, [r7, #4]
 801847e:	681b      	ldr	r3, [r3, #0]
 8018480:	60fb      	str	r3, [r7, #12]
    while (*fmt != SECUREC_CHAR('%')) { /* Must meet '%' */
 8018482:	e002      	b.n	801848a <SecSeekToFrontPercent+0x16>
        --fmt;
 8018484:	68fb      	ldr	r3, [r7, #12]
 8018486:	3b01      	subs	r3, #1
 8018488:	60fb      	str	r3, [r7, #12]
    while (*fmt != SECUREC_CHAR('%')) { /* Must meet '%' */
 801848a:	68fb      	ldr	r3, [r7, #12]
 801848c:	781b      	ldrb	r3, [r3, #0]
 801848e:	2b25      	cmp	r3, #37	; 0x25
 8018490:	d1f8      	bne.n	8018484 <SecSeekToFrontPercent+0x10>
    }
    *format = fmt;
 8018492:	687b      	ldr	r3, [r7, #4]
 8018494:	68fa      	ldr	r2, [r7, #12]
 8018496:	601a      	str	r2, [r3, #0]
}
 8018498:	bf00      	nop
 801849a:	3714      	adds	r7, #20
 801849c:	46bd      	mov	sp, r7
 801849e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80184a2:	4770      	bx	lr

080184a4 <SecInitFloatFmt>:

/* Init float format, return 0 is OK */
SECUREC_INLINE int SecInitFloatFmt(SecFloatAdapt *floatFmt, const SecChar *format)
{
 80184a4:	b580      	push	{r7, lr}
 80184a6:	b086      	sub	sp, #24
 80184a8:	af00      	add	r7, sp, #0
 80184aa:	6078      	str	r0, [r7, #4]
 80184ac:	6039      	str	r1, [r7, #0]
 80184ae:	4b2a      	ldr	r3, [pc, #168]	; (8018558 <SecInitFloatFmt+0xb4>)
 80184b0:	681b      	ldr	r3, [r3, #0]
 80184b2:	617b      	str	r3, [r7, #20]
 80184b4:	f04f 0300 	mov.w	r3, #0
    const SecChar *fmt = format - 2;  /* Sub 2 to the position before 'f' or 'g' */
 80184b8:	683b      	ldr	r3, [r7, #0]
 80184ba:	3b02      	subs	r3, #2
 80184bc:	60bb      	str	r3, [r7, #8]
    int fmtStrLen;
    int i;

    SecSeekToFrontPercent(&fmt);
 80184be:	f107 0308 	add.w	r3, r7, #8
 80184c2:	4618      	mov	r0, r3
 80184c4:	f7ff ffd6 	bl	8018474 <SecSeekToFrontPercent>
    /* Now fmt point to '%' */
    fmtStrLen = (int)(size_t)(format - fmt) + 1;   /* With ending terminator */
 80184c8:	68bb      	ldr	r3, [r7, #8]
 80184ca:	683a      	ldr	r2, [r7, #0]
 80184cc:	1ad3      	subs	r3, r2, r3
 80184ce:	3301      	adds	r3, #1
 80184d0:	613b      	str	r3, [r7, #16]
    if (fmtStrLen > (int)sizeof(floatFmt->buffer)) {
 80184d2:	693b      	ldr	r3, [r7, #16]
 80184d4:	2b10      	cmp	r3, #16
 80184d6:	dd12      	ble.n	80184fe <SecInitFloatFmt+0x5a>
        /* When buffer is NOT enough, alloc a new buffer */
        floatFmt->allocatedFmtStr = (char *)SECUREC_MALLOC((size_t)((unsigned int)fmtStrLen));
 80184d8:	693b      	ldr	r3, [r7, #16]
 80184da:	4618      	mov	r0, r3
 80184dc:	f002 faa4 	bl	801aa28 <malloc>
 80184e0:	4602      	mov	r2, r0
 80184e2:	687b      	ldr	r3, [r7, #4]
 80184e4:	615a      	str	r2, [r3, #20]
        if (floatFmt->allocatedFmtStr == NULL) {
 80184e6:	687b      	ldr	r3, [r7, #4]
 80184e8:	695b      	ldr	r3, [r3, #20]
 80184ea:	2b00      	cmp	r3, #0
 80184ec:	d102      	bne.n	80184f4 <SecInitFloatFmt+0x50>
            return -1;
 80184ee:	f04f 33ff 	mov.w	r3, #4294967295
 80184f2:	e026      	b.n	8018542 <SecInitFloatFmt+0x9e>
        }
        floatFmt->fmtStr = floatFmt->allocatedFmtStr;
 80184f4:	687b      	ldr	r3, [r7, #4]
 80184f6:	695a      	ldr	r2, [r3, #20]
 80184f8:	687b      	ldr	r3, [r7, #4]
 80184fa:	611a      	str	r2, [r3, #16]
 80184fc:	e005      	b.n	801850a <SecInitFloatFmt+0x66>
    } else {
        floatFmt->fmtStr = floatFmt->buffer;
 80184fe:	687a      	ldr	r2, [r7, #4]
 8018500:	687b      	ldr	r3, [r7, #4]
 8018502:	611a      	str	r2, [r3, #16]
        floatFmt->allocatedFmtStr = NULL; /* Must set to NULL, later code free memory based on this identity */
 8018504:	687b      	ldr	r3, [r7, #4]
 8018506:	2200      	movs	r2, #0
 8018508:	615a      	str	r2, [r3, #20]
    }

    for (i = 0; i < fmtStrLen - 1; ++i) {
 801850a:	2300      	movs	r3, #0
 801850c:	60fb      	str	r3, [r7, #12]
 801850e:	e00b      	b.n	8018528 <SecInitFloatFmt+0x84>
        /* Convert wchar to char */
        floatFmt->fmtStr[i] = (char)(fmt[i]);  /* Copy the format string */
 8018510:	68ba      	ldr	r2, [r7, #8]
 8018512:	68fb      	ldr	r3, [r7, #12]
 8018514:	441a      	add	r2, r3
 8018516:	687b      	ldr	r3, [r7, #4]
 8018518:	6919      	ldr	r1, [r3, #16]
 801851a:	68fb      	ldr	r3, [r7, #12]
 801851c:	440b      	add	r3, r1
 801851e:	7812      	ldrb	r2, [r2, #0]
 8018520:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < fmtStrLen - 1; ++i) {
 8018522:	68fb      	ldr	r3, [r7, #12]
 8018524:	3301      	adds	r3, #1
 8018526:	60fb      	str	r3, [r7, #12]
 8018528:	693b      	ldr	r3, [r7, #16]
 801852a:	3b01      	subs	r3, #1
 801852c:	68fa      	ldr	r2, [r7, #12]
 801852e:	429a      	cmp	r2, r3
 8018530:	dbee      	blt.n	8018510 <SecInitFloatFmt+0x6c>
    }
    floatFmt->fmtStr[fmtStrLen - 1] = '\0';
 8018532:	687b      	ldr	r3, [r7, #4]
 8018534:	691a      	ldr	r2, [r3, #16]
 8018536:	693b      	ldr	r3, [r7, #16]
 8018538:	3b01      	subs	r3, #1
 801853a:	4413      	add	r3, r2
 801853c:	2200      	movs	r2, #0
 801853e:	701a      	strb	r2, [r3, #0]

    return 0;
 8018540:	2300      	movs	r3, #0
}
 8018542:	4a05      	ldr	r2, [pc, #20]	; (8018558 <SecInitFloatFmt+0xb4>)
 8018544:	6811      	ldr	r1, [r2, #0]
 8018546:	697a      	ldr	r2, [r7, #20]
 8018548:	4051      	eors	r1, r2
 801854a:	d001      	beq.n	8018550 <SecInitFloatFmt+0xac>
 801854c:	f7ec f846 	bl	80045dc <__stack_chk_fail>
 8018550:	4618      	mov	r0, r3
 8018552:	3718      	adds	r7, #24
 8018554:	46bd      	mov	sp, r7
 8018556:	bd80      	pop	{r7, pc}
 8018558:	080230c0 	.word	0x080230c0

0801855c <SecInitFloatBuffer>:

/* Init float buffer and format, return 0 is OK */
SECUREC_INLINE int SecInitFloatBuffer(SecFloatAdapt *floatAdapt, const SecChar *format, SecFormatAttr *attr)
{
 801855c:	b580      	push	{r7, lr}
 801855e:	b084      	sub	sp, #16
 8018560:	af00      	add	r7, sp, #0
 8018562:	60f8      	str	r0, [r7, #12]
 8018564:	60b9      	str	r1, [r7, #8]
 8018566:	607a      	str	r2, [r7, #4]
    floatAdapt->allocatedFmtStr = NULL;
 8018568:	68fb      	ldr	r3, [r7, #12]
 801856a:	2200      	movs	r2, #0
 801856c:	615a      	str	r2, [r3, #20]
    floatAdapt->fmtStr = NULL;
 801856e:	68fb      	ldr	r3, [r7, #12]
 8018570:	2200      	movs	r2, #0
 8018572:	611a      	str	r2, [r3, #16]
    floatAdapt->floatBuffer = NULL;
 8018574:	68fb      	ldr	r3, [r7, #12]
 8018576:	2200      	movs	r2, #0
 8018578:	619a      	str	r2, [r3, #24]
    /* Compute the precision value */
    if (attr->precision < 0) {
 801857a:	687b      	ldr	r3, [r7, #4]
 801857c:	69db      	ldr	r3, [r3, #28]
 801857e:	2b00      	cmp	r3, #0
 8018580:	da02      	bge.n	8018588 <SecInitFloatBuffer+0x2c>
        attr->precision = SECUREC_FLOAT_DEFAULT_PRECISION;
 8018582:	687b      	ldr	r3, [r7, #4]
 8018584:	2206      	movs	r2, #6
 8018586:	61da      	str	r2, [r3, #28]
    }
    /*
     * Calc buffer size to store double value
     * The maximum length of SECUREC_MAX_WIDTH_LEN is enough
     */
    if ((attr->flags & SECUREC_FLAG_LONG_DOUBLE) != 0) {
 8018588:	687b      	ldr	r3, [r7, #4]
 801858a:	695b      	ldr	r3, [r3, #20]
 801858c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8018590:	2b00      	cmp	r3, #0
 8018592:	d00f      	beq.n	80185b4 <SecInitFloatBuffer+0x58>
        if (attr->precision > (SECUREC_MAX_WIDTH_LEN - SECUREC_FLOAT_BUFSIZE_LB)) {
 8018594:	687b      	ldr	r3, [r7, #4]
 8018596:	69db      	ldr	r3, [r3, #28]
 8018598:	4a2f      	ldr	r2, [pc, #188]	; (8018658 <SecInitFloatBuffer+0xfc>)
 801859a:	4293      	cmp	r3, r2
 801859c:	dd02      	ble.n	80185a4 <SecInitFloatBuffer+0x48>
            return -1;
 801859e:	f04f 33ff 	mov.w	r3, #4294967295
 80185a2:	e055      	b.n	8018650 <SecInitFloatBuffer+0xf4>
        }
        /* Long double needs to meet the basic print length */
        floatAdapt->bufferSize = SECUREC_FLOAT_BUFSIZE_LB + attr->precision + SECUREC_FLOAT_BUF_EXT;
 80185a4:	687b      	ldr	r3, [r7, #4]
 80185a6:	69da      	ldr	r2, [r3, #28]
 80185a8:	f241 336e 	movw	r3, #4974	; 0x136e
 80185ac:	4413      	add	r3, r2
 80185ae:	68fa      	ldr	r2, [r7, #12]
 80185b0:	61d3      	str	r3, [r2, #28]
 80185b2:	e00d      	b.n	80185d0 <SecInitFloatBuffer+0x74>
    } else {
        if (attr->precision > (SECUREC_MAX_WIDTH_LEN - SECUREC_FLOAT_BUFSIZE)) {
 80185b4:	687b      	ldr	r3, [r7, #4]
 80185b6:	69db      	ldr	r3, [r3, #28]
 80185b8:	4a28      	ldr	r2, [pc, #160]	; (801865c <SecInitFloatBuffer+0x100>)
 80185ba:	4293      	cmp	r3, r2
 80185bc:	dd02      	ble.n	80185c4 <SecInitFloatBuffer+0x68>
            return -1;
 80185be:	f04f 33ff 	mov.w	r3, #4294967295
 80185c2:	e045      	b.n	8018650 <SecInitFloatBuffer+0xf4>
        }
        /* Double needs to meet the basic print length */
        floatAdapt->bufferSize = SECUREC_FLOAT_BUFSIZE + attr->precision + SECUREC_FLOAT_BUF_EXT;
 80185c4:	687b      	ldr	r3, [r7, #4]
 80185c6:	69db      	ldr	r3, [r3, #28]
 80185c8:	f203 125f 	addw	r2, r3, #351	; 0x15f
 80185cc:	68fb      	ldr	r3, [r7, #12]
 80185ce:	61da      	str	r2, [r3, #28]
    }
    if (attr->fldWidth > floatAdapt->bufferSize) {
 80185d0:	687b      	ldr	r3, [r7, #4]
 80185d2:	699a      	ldr	r2, [r3, #24]
 80185d4:	68fb      	ldr	r3, [r7, #12]
 80185d6:	69db      	ldr	r3, [r3, #28]
 80185d8:	429a      	cmp	r2, r3
 80185da:	dd04      	ble.n	80185e6 <SecInitFloatBuffer+0x8a>
        floatAdapt->bufferSize = attr->fldWidth + SECUREC_FLOAT_BUF_EXT;
 80185dc:	687b      	ldr	r3, [r7, #4]
 80185de:	699b      	ldr	r3, [r3, #24]
 80185e0:	1c9a      	adds	r2, r3, #2
 80185e2:	68fb      	ldr	r3, [r7, #12]
 80185e4:	61da      	str	r2, [r3, #28]
    }

    if (floatAdapt->bufferSize > SECUREC_BUFFER_SIZE) {
 80185e6:	68fb      	ldr	r3, [r7, #12]
 80185e8:	69db      	ldr	r3, [r3, #28]
 80185ea:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80185ee:	dd13      	ble.n	8018618 <SecInitFloatBuffer+0xbc>
        /* The current value of SECUREC_BUFFER_SIZE could not store the formatted float string */
        floatAdapt->floatBuffer = (char *)SECUREC_MALLOC(((size_t)(unsigned int)floatAdapt->bufferSize));
 80185f0:	68fb      	ldr	r3, [r7, #12]
 80185f2:	69db      	ldr	r3, [r3, #28]
 80185f4:	4618      	mov	r0, r3
 80185f6:	f002 fa17 	bl	801aa28 <malloc>
 80185fa:	4602      	mov	r2, r0
 80185fc:	68fb      	ldr	r3, [r7, #12]
 80185fe:	619a      	str	r2, [r3, #24]
        if (floatAdapt->floatBuffer == NULL) {
 8018600:	68fb      	ldr	r3, [r7, #12]
 8018602:	699b      	ldr	r3, [r3, #24]
 8018604:	2b00      	cmp	r3, #0
 8018606:	d102      	bne.n	801860e <SecInitFloatBuffer+0xb2>
            return -1;
 8018608:	f04f 33ff 	mov.w	r3, #4294967295
 801860c:	e020      	b.n	8018650 <SecInitFloatBuffer+0xf4>
        }
        attr->text.str = floatAdapt->floatBuffer;
 801860e:	68fb      	ldr	r3, [r7, #12]
 8018610:	699a      	ldr	r2, [r3, #24]
 8018612:	687b      	ldr	r3, [r7, #4]
 8018614:	605a      	str	r2, [r3, #4]
 8018616:	e004      	b.n	8018622 <SecInitFloatBuffer+0xc6>
    } else {
        attr->text.str = attr->buffer.str; /* Output buffer for float string with default size */
 8018618:	687b      	ldr	r3, [r7, #4]
 801861a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 801861e:	687b      	ldr	r3, [r7, #4]
 8018620:	605a      	str	r2, [r3, #4]
    }

    if (SecInitFloatFmt(floatAdapt, format) != 0) {
 8018622:	68b9      	ldr	r1, [r7, #8]
 8018624:	68f8      	ldr	r0, [r7, #12]
 8018626:	f7ff ff3d 	bl	80184a4 <SecInitFloatFmt>
 801862a:	4603      	mov	r3, r0
 801862c:	2b00      	cmp	r3, #0
 801862e:	d00e      	beq.n	801864e <SecInitFloatBuffer+0xf2>
        if (floatAdapt->floatBuffer != NULL) {
 8018630:	68fb      	ldr	r3, [r7, #12]
 8018632:	699b      	ldr	r3, [r3, #24]
 8018634:	2b00      	cmp	r3, #0
 8018636:	d007      	beq.n	8018648 <SecInitFloatBuffer+0xec>
            SECUREC_FREE(floatAdapt->floatBuffer);
 8018638:	68fb      	ldr	r3, [r7, #12]
 801863a:	699b      	ldr	r3, [r3, #24]
 801863c:	4618      	mov	r0, r3
 801863e:	f002 f9df 	bl	801aa00 <free>
            floatAdapt->floatBuffer = NULL;
 8018642:	68fb      	ldr	r3, [r7, #12]
 8018644:	2200      	movs	r2, #0
 8018646:	619a      	str	r2, [r3, #24]
        }
        return -1;
 8018648:	f04f 33ff 	mov.w	r3, #4294967295
 801864c:	e000      	b.n	8018650 <SecInitFloatBuffer+0xf4>
    }
    return 0;
 801864e:	2300      	movs	r3, #0
}
 8018650:	4618      	mov	r0, r3
 8018652:	3710      	adds	r7, #16
 8018654:	46bd      	mov	sp, r7
 8018656:	bd80      	pop	{r7, pc}
 8018658:	0cccb95c 	.word	0x0cccb95c
 801865c:	0ccccb6b 	.word	0x0ccccb6b

08018660 <SecUpdateNegativeChar>:
#endif

SECUREC_INLINE SecInt64 SecUpdateNegativeChar(SecFormatAttr *attr, char ch)
{
 8018660:	b480      	push	{r7}
 8018662:	b087      	sub	sp, #28
 8018664:	af00      	add	r7, sp, #0
 8018666:	6078      	str	r0, [r7, #4]
 8018668:	460b      	mov	r3, r1
 801866a:	70fb      	strb	r3, [r7, #3]
    SecInt64 num64 = ch; /* Sign extend */
 801866c:	78fa      	ldrb	r2, [r7, #3]
 801866e:	f04f 0300 	mov.w	r3, #0
 8018672:	e9c7 2304 	strd	r2, r3, [r7, #16]
    if (num64 >= 128) { /* 128 on some platform, char is always unsigned */
 8018676:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801867a:	2a80      	cmp	r2, #128	; 0x80
 801867c:	f173 0300 	sbcs.w	r3, r3, #0
 8018680:	db0f      	blt.n	80186a2 <SecUpdateNegativeChar+0x42>
        unsigned char tmp = (unsigned char)(~((unsigned char)ch));
 8018682:	78fb      	ldrb	r3, [r7, #3]
 8018684:	43db      	mvns	r3, r3
 8018686:	73fb      	strb	r3, [r7, #15]
        num64 = tmp + 1;
 8018688:	7bfb      	ldrb	r3, [r7, #15]
 801868a:	3301      	adds	r3, #1
 801868c:	461a      	mov	r2, r3
 801868e:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8018692:	e9c7 2304 	strd	r2, r3, [r7, #16]
        attr->flags |= SECUREC_FLAG_NEGATIVE;
 8018696:	687b      	ldr	r3, [r7, #4]
 8018698:	695b      	ldr	r3, [r3, #20]
 801869a:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 801869e:	687b      	ldr	r3, [r7, #4]
 80186a0:	615a      	str	r2, [r3, #20]
    }
    return num64;
 80186a2:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
}
 80186a6:	4610      	mov	r0, r2
 80186a8:	4619      	mov	r1, r3
 80186aa:	371c      	adds	r7, #28
 80186ac:	46bd      	mov	sp, r7
 80186ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80186b2:	4770      	bx	lr

080186b4 <SecNumberSatisfyPrecision>:

/*
 * If the precision is not satisfied, zero is added before the string
 */
SECUREC_INLINE void SecNumberSatisfyPrecision(SecFormatAttr *attr)
{
 80186b4:	b480      	push	{r7}
 80186b6:	b085      	sub	sp, #20
 80186b8:	af00      	add	r7, sp, #0
 80186ba:	6078      	str	r0, [r7, #4]
    int precision;
    if (attr->precision < 0) {
 80186bc:	687b      	ldr	r3, [r7, #4]
 80186be:	69db      	ldr	r3, [r3, #28]
 80186c0:	2b00      	cmp	r3, #0
 80186c2:	da02      	bge.n	80186ca <SecNumberSatisfyPrecision+0x16>
        precision = 1; /* Default precision 1 */
 80186c4:	2301      	movs	r3, #1
 80186c6:	60fb      	str	r3, [r7, #12]
 80186c8:	e026      	b.n	8018718 <SecNumberSatisfyPrecision+0x64>
    } else {
#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
        attr->flags &= ~SECUREC_FLAG_LEADZERO;
#else
        if ((attr->flags & SECUREC_FLAG_POINTER) == 0) {
 80186ca:	687b      	ldr	r3, [r7, #4]
 80186cc:	695b      	ldr	r3, [r3, #20]
 80186ce:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80186d2:	2b00      	cmp	r3, #0
 80186d4:	d105      	bne.n	80186e2 <SecNumberSatisfyPrecision+0x2e>
            attr->flags &= ~SECUREC_FLAG_LEADZERO;
 80186d6:	687b      	ldr	r3, [r7, #4]
 80186d8:	695b      	ldr	r3, [r3, #20]
 80186da:	f023 0208 	bic.w	r2, r3, #8
 80186de:	687b      	ldr	r3, [r7, #4]
 80186e0:	615a      	str	r2, [r3, #20]
        }
#endif
        if (attr->precision > SECUREC_MAX_PRECISION) {
 80186e2:	687b      	ldr	r3, [r7, #4]
 80186e4:	69db      	ldr	r3, [r3, #28]
 80186e6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80186ea:	dd03      	ble.n	80186f4 <SecNumberSatisfyPrecision+0x40>
            attr->precision = SECUREC_MAX_PRECISION;
 80186ec:	687b      	ldr	r3, [r7, #4]
 80186ee:	f44f 7200 	mov.w	r2, #512	; 0x200
 80186f2:	61da      	str	r2, [r3, #28]
        }
        precision = attr->precision;
 80186f4:	687b      	ldr	r3, [r7, #4]
 80186f6:	69db      	ldr	r3, [r3, #28]
 80186f8:	60fb      	str	r3, [r7, #12]
    }
    while (attr->textLen < precision) {
 80186fa:	e00d      	b.n	8018718 <SecNumberSatisfyPrecision+0x64>
        --attr->text.str;
 80186fc:	687b      	ldr	r3, [r7, #4]
 80186fe:	685b      	ldr	r3, [r3, #4]
 8018700:	1e5a      	subs	r2, r3, #1
 8018702:	687b      	ldr	r3, [r7, #4]
 8018704:	605a      	str	r2, [r3, #4]
        *(attr->text.str) = '0';
 8018706:	687b      	ldr	r3, [r7, #4]
 8018708:	685b      	ldr	r3, [r3, #4]
 801870a:	2230      	movs	r2, #48	; 0x30
 801870c:	701a      	strb	r2, [r3, #0]
        ++attr->textLen;
 801870e:	687b      	ldr	r3, [r7, #4]
 8018710:	689b      	ldr	r3, [r3, #8]
 8018712:	1c5a      	adds	r2, r3, #1
 8018714:	687b      	ldr	r3, [r7, #4]
 8018716:	609a      	str	r2, [r3, #8]
    while (attr->textLen < precision) {
 8018718:	687b      	ldr	r3, [r7, #4]
 801871a:	689b      	ldr	r3, [r3, #8]
 801871c:	68fa      	ldr	r2, [r7, #12]
 801871e:	429a      	cmp	r2, r3
 8018720:	dcec      	bgt.n	80186fc <SecNumberSatisfyPrecision+0x48>
    }
}
 8018722:	bf00      	nop
 8018724:	bf00      	nop
 8018726:	3714      	adds	r7, #20
 8018728:	46bd      	mov	sp, r7
 801872a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801872e:	4770      	bx	lr

08018730 <SecNumberForceOctal>:

/*
 * Add leading zero for %#o
 */
SECUREC_INLINE void SecNumberForceOctal(SecFormatAttr *attr)
{
 8018730:	b480      	push	{r7}
 8018732:	b083      	sub	sp, #12
 8018734:	af00      	add	r7, sp, #0
 8018736:	6078      	str	r0, [r7, #4]
    /* Force a leading zero if FORCEOCTAL flag set */
    if ((attr->flags & SECUREC_FLAG_FORCE_OCTAL) != 0 &&
 8018738:	687b      	ldr	r3, [r7, #4]
 801873a:	695b      	ldr	r3, [r3, #20]
 801873c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8018740:	2b00      	cmp	r3, #0
 8018742:	d016      	beq.n	8018772 <SecNumberForceOctal+0x42>
        (attr->textLen == 0 || attr->text.str[0] != '0')) {
 8018744:	687b      	ldr	r3, [r7, #4]
 8018746:	689b      	ldr	r3, [r3, #8]
    if ((attr->flags & SECUREC_FLAG_FORCE_OCTAL) != 0 &&
 8018748:	2b00      	cmp	r3, #0
 801874a:	d004      	beq.n	8018756 <SecNumberForceOctal+0x26>
        (attr->textLen == 0 || attr->text.str[0] != '0')) {
 801874c:	687b      	ldr	r3, [r7, #4]
 801874e:	685b      	ldr	r3, [r3, #4]
 8018750:	781b      	ldrb	r3, [r3, #0]
 8018752:	2b30      	cmp	r3, #48	; 0x30
 8018754:	d00d      	beq.n	8018772 <SecNumberForceOctal+0x42>
        --attr->text.str;
 8018756:	687b      	ldr	r3, [r7, #4]
 8018758:	685b      	ldr	r3, [r3, #4]
 801875a:	1e5a      	subs	r2, r3, #1
 801875c:	687b      	ldr	r3, [r7, #4]
 801875e:	605a      	str	r2, [r3, #4]
        *(attr->text.str) = '0';
 8018760:	687b      	ldr	r3, [r7, #4]
 8018762:	685b      	ldr	r3, [r3, #4]
 8018764:	2230      	movs	r2, #48	; 0x30
 8018766:	701a      	strb	r2, [r3, #0]
        ++attr->textLen;
 8018768:	687b      	ldr	r3, [r7, #4]
 801876a:	689b      	ldr	r3, [r3, #8]
 801876c:	1c5a      	adds	r2, r3, #1
 801876e:	687b      	ldr	r3, [r7, #4]
 8018770:	609a      	str	r2, [r3, #8]
    }
}
 8018772:	bf00      	nop
 8018774:	370c      	adds	r7, #12
 8018776:	46bd      	mov	sp, r7
 8018778:	f85d 7b04 	ldr.w	r7, [sp], #4
 801877c:	4770      	bx	lr

0801877e <SecUpdateSignedNumberPrefix>:

SECUREC_INLINE void SecUpdateSignedNumberPrefix(SecFormatAttr *attr)
{
 801877e:	b480      	push	{r7}
 8018780:	b083      	sub	sp, #12
 8018782:	af00      	add	r7, sp, #0
 8018784:	6078      	str	r0, [r7, #4]
    if ((attr->flags & SECUREC_FLAG_SIGNED) == 0) {
 8018786:	687b      	ldr	r3, [r7, #4]
 8018788:	695b      	ldr	r3, [r3, #20]
 801878a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801878e:	2b00      	cmp	r3, #0
 8018790:	d029      	beq.n	80187e6 <SecUpdateSignedNumberPrefix+0x68>
        return;
    }
    if ((attr->flags & SECUREC_FLAG_NEGATIVE) != 0) {
 8018792:	687b      	ldr	r3, [r7, #4]
 8018794:	695b      	ldr	r3, [r3, #20]
 8018796:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801879a:	2b00      	cmp	r3, #0
 801879c:	d007      	beq.n	80187ae <SecUpdateSignedNumberPrefix+0x30>
        /* Prefix is '-' */
        attr->prefix[0] = SECUREC_CHAR('-');
 801879e:	687b      	ldr	r3, [r7, #4]
 80187a0:	222d      	movs	r2, #45	; 0x2d
 80187a2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        attr->prefixLen = 1;
 80187a6:	687b      	ldr	r3, [r7, #4]
 80187a8:	2201      	movs	r2, #1
 80187aa:	62da      	str	r2, [r3, #44]	; 0x2c
        return;
 80187ac:	e01e      	b.n	80187ec <SecUpdateSignedNumberPrefix+0x6e>
    }
    if ((attr->flags & SECUREC_FLAG_SIGN) != 0) {
 80187ae:	687b      	ldr	r3, [r7, #4]
 80187b0:	695b      	ldr	r3, [r3, #20]
 80187b2:	f003 0301 	and.w	r3, r3, #1
 80187b6:	2b00      	cmp	r3, #0
 80187b8:	d007      	beq.n	80187ca <SecUpdateSignedNumberPrefix+0x4c>
        /* Prefix is '+' */
        attr->prefix[0] = SECUREC_CHAR('+');
 80187ba:	687b      	ldr	r3, [r7, #4]
 80187bc:	222b      	movs	r2, #43	; 0x2b
 80187be:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        attr->prefixLen = 1;
 80187c2:	687b      	ldr	r3, [r7, #4]
 80187c4:	2201      	movs	r2, #1
 80187c6:	62da      	str	r2, [r3, #44]	; 0x2c
        return;
 80187c8:	e010      	b.n	80187ec <SecUpdateSignedNumberPrefix+0x6e>
    }
    if ((attr->flags & SECUREC_FLAG_SIGN_SPACE) != 0) {
 80187ca:	687b      	ldr	r3, [r7, #4]
 80187cc:	695b      	ldr	r3, [r3, #20]
 80187ce:	f003 0302 	and.w	r3, r3, #2
 80187d2:	2b00      	cmp	r3, #0
 80187d4:	d009      	beq.n	80187ea <SecUpdateSignedNumberPrefix+0x6c>
        /* Prefix is ' ' */
        attr->prefix[0] = SECUREC_CHAR(' ');
 80187d6:	687b      	ldr	r3, [r7, #4]
 80187d8:	2220      	movs	r2, #32
 80187da:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        attr->prefixLen = 1;
 80187de:	687b      	ldr	r3, [r7, #4]
 80187e0:	2201      	movs	r2, #1
 80187e2:	62da      	str	r2, [r3, #44]	; 0x2c
        return;
 80187e4:	e002      	b.n	80187ec <SecUpdateSignedNumberPrefix+0x6e>
        return;
 80187e6:	bf00      	nop
 80187e8:	e000      	b.n	80187ec <SecUpdateSignedNumberPrefix+0x6e>
    }
    return;
 80187ea:	bf00      	nop
}
 80187ec:	370c      	adds	r7, #12
 80187ee:	46bd      	mov	sp, r7
 80187f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80187f4:	4770      	bx	lr
	...

080187f8 <SecNumberCompatZero>:

SECUREC_INLINE void SecNumberCompatZero(SecFormatAttr *attr)
{
 80187f8:	b480      	push	{r7}
 80187fa:	b083      	sub	sp, #12
 80187fc:	af00      	add	r7, sp, #0
 80187fe:	6078      	str	r0, [r7, #4]
        (attr->flags & SECUREC_FLAG_ALTERNATE) != 0) {
        /* Add 0x prefix for %x or %X, the prefix string has been set before */
        attr->prefixLen = SECUREC_PREFIX_LEN;
    }
#elif defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && (!defined(SECUREC_ON_UNIX))
    if ((attr->flags & SECUREC_FLAG_POINTER) != 0) {
 8018800:	687b      	ldr	r3, [r7, #4]
 8018802:	695b      	ldr	r3, [r3, #20]
 8018804:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8018808:	2b00      	cmp	r3, #0
 801880a:	d00b      	beq.n	8018824 <SecNumberCompatZero+0x2c>
        static char strNullPointer[SECUREC_NULL_STRING_SIZE] = "(nil)";
        attr->text.str = strNullPointer;
 801880c:	687b      	ldr	r3, [r7, #4]
 801880e:	4a08      	ldr	r2, [pc, #32]	; (8018830 <SecNumberCompatZero+0x38>)
 8018810:	605a      	str	r2, [r3, #4]
        attr->textLen = 5; /* Length of (nil) is 5 */
 8018812:	687b      	ldr	r3, [r7, #4]
 8018814:	2205      	movs	r2, #5
 8018816:	609a      	str	r2, [r3, #8]
        attr->flags &= ~SECUREC_FLAG_LEADZERO;
 8018818:	687b      	ldr	r3, [r7, #4]
 801881a:	695b      	ldr	r3, [r3, #20]
 801881c:	f023 0208 	bic.w	r2, r3, #8
 8018820:	687b      	ldr	r3, [r7, #4]
 8018822:	615a      	str	r2, [r3, #20]
        /* Add 0x prefix for %p, the prefix string has been set before */
        attr->prefixLen = SECUREC_PREFIX_LEN;
    }
#endif
    (void)attr; /* To clear e438 last value assigned not used , the compiler will optimize this code */
}
 8018824:	bf00      	nop
 8018826:	370c      	adds	r7, #12
 8018828:	46bd      	mov	sp, r7
 801882a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801882e:	4770      	bx	lr
 8018830:	20000560 	.word	0x20000560

08018834 <SecOutput>:

/*
 * Formatting output core function
 */
SECUREC_INLINE int SecOutput(SecPrintfStream *stream, const SecChar *cFormat, va_list argList)
{
 8018834:	b590      	push	{r4, r7, lr}
 8018836:	f5ad 7d2b 	sub.w	sp, sp, #684	; 0x2ac
 801883a:	af00      	add	r7, sp, #0
 801883c:	f107 030c 	add.w	r3, r7, #12
 8018840:	6018      	str	r0, [r3, #0]
 8018842:	f107 0308 	add.w	r3, r7, #8
 8018846:	6019      	str	r1, [r3, #0]
 8018848:	1d3b      	adds	r3, r7, #4
 801884a:	601a      	str	r2, [r3, #0]
 801884c:	4bd1      	ldr	r3, [pc, #836]	; (8018b94 <SecOutput+0x360>)
 801884e:	681b      	ldr	r3, [r3, #0]
 8018850:	f8c7 32a4 	str.w	r3, [r7, #676]	; 0x2a4
 8018854:	f04f 0300 	mov.w	r3, #0
    const SecChar *format = cFormat;
 8018858:	f107 0314 	add.w	r3, r7, #20
 801885c:	f107 0208 	add.w	r2, r7, #8
 8018860:	6812      	ldr	r2, [r2, #0]
 8018862:	601a      	str	r2, [r3, #0]
    int charsOut;               /* Characters written */
    int noOutput = 0; /* Must be initialized or compiler alerts */
 8018864:	f107 031c 	add.w	r3, r7, #28
 8018868:	2200      	movs	r2, #0
 801886a:	601a      	str	r2, [r3, #0]
    SecFmtState state;
    SecFormatAttr formatAttr;

    formatAttr.flags = 0;
 801886c:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018870:	2200      	movs	r2, #0
 8018872:	615a      	str	r2, [r3, #20]
    formatAttr.textIsWide = 0;    /* Flag for buffer contains wide chars */
 8018874:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018878:	2200      	movs	r2, #0
 801887a:	60da      	str	r2, [r3, #12]
    formatAttr.fldWidth = 0;
 801887c:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018880:	2200      	movs	r2, #0
 8018882:	619a      	str	r2, [r3, #24]
    formatAttr.precision = 0;
 8018884:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018888:	2200      	movs	r2, #0
 801888a:	61da      	str	r2, [r3, #28]
    formatAttr.dynWidth = 0;
 801888c:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018890:	2200      	movs	r2, #0
 8018892:	621a      	str	r2, [r3, #32]
    formatAttr.dynPrecision = 0;
 8018894:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018898:	2200      	movs	r2, #0
 801889a:	625a      	str	r2, [r3, #36]	; 0x24
    formatAttr.digits = g_itoaUpperDigits;
 801889c:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80188a0:	4abd      	ldr	r2, [pc, #756]	; (8018b98 <SecOutput+0x364>)
 80188a2:	601a      	str	r2, [r3, #0]
    formatAttr.radix = SECUREC_RADIX_DECIMAL;
 80188a4:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80188a8:	220a      	movs	r2, #10
 80188aa:	611a      	str	r2, [r3, #16]
    formatAttr.padding = 0;
 80188ac:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80188b0:	2200      	movs	r2, #0
 80188b2:	629a      	str	r2, [r3, #40]	; 0x28
    formatAttr.textLen = 0;
 80188b4:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80188b8:	2200      	movs	r2, #0
 80188ba:	609a      	str	r2, [r3, #8]
    formatAttr.text.str = NULL;
 80188bc:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80188c0:	2200      	movs	r2, #0
 80188c2:	605a      	str	r2, [r3, #4]
    formatAttr.prefixLen = 0;
 80188c4:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80188c8:	2200      	movs	r2, #0
 80188ca:	62da      	str	r2, [r3, #44]	; 0x2c
    formatAttr.prefix[0] = SECUREC_CHAR('\0');
 80188cc:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80188d0:	2200      	movs	r2, #0
 80188d2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    formatAttr.prefix[1] = SECUREC_CHAR('\0');
 80188d6:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80188da:	2200      	movs	r2, #0
 80188dc:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
    charsOut = 0;
 80188e0:	f107 0318 	add.w	r3, r7, #24
 80188e4:	2200      	movs	r2, #0
 80188e6:	601a      	str	r2, [r3, #0]
    state = STAT_NORMAL;        /* Starting state */
 80188e8:	f107 0320 	add.w	r3, r7, #32
 80188ec:	2200      	movs	r2, #0
 80188ee:	601a      	str	r2, [r3, #0]

    /* Loop each format character */
    while (*format != SECUREC_CHAR('\0') && charsOut >= 0) {
 80188f0:	e375      	b.n	8018fde <SecOutput+0x7aa>
        SecFmtState lastState = state;
 80188f2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80188f6:	f107 0220 	add.w	r2, r7, #32
 80188fa:	6812      	ldr	r2, [r2, #0]
 80188fc:	601a      	str	r2, [r3, #0]
        SecChar ch = *format; /* Currently read character */
 80188fe:	f107 0314 	add.w	r3, r7, #20
 8018902:	681a      	ldr	r2, [r3, #0]
 8018904:	f107 0313 	add.w	r3, r7, #19
 8018908:	7812      	ldrb	r2, [r2, #0]
 801890a:	701a      	strb	r2, [r3, #0]
        ++format;
 801890c:	f107 0314 	add.w	r3, r7, #20
 8018910:	681b      	ldr	r3, [r3, #0]
 8018912:	1c5a      	adds	r2, r3, #1
 8018914:	f107 0314 	add.w	r3, r7, #20
 8018918:	601a      	str	r2, [r3, #0]
        state = SecDecodeState(ch, lastState);
 801891a:	f107 0420 	add.w	r4, r7, #32
 801891e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8018922:	f107 0213 	add.w	r2, r7, #19
 8018926:	7812      	ldrb	r2, [r2, #0]
 8018928:	6819      	ldr	r1, [r3, #0]
 801892a:	4610      	mov	r0, r2
 801892c:	f7ff f976 	bl	8017c1c <SecDecodeState>
 8018930:	6020      	str	r0, [r4, #0]
 8018932:	f107 0320 	add.w	r3, r7, #32
 8018936:	681b      	ldr	r3, [r3, #0]
 8018938:	2b07      	cmp	r3, #7
 801893a:	f200 834d 	bhi.w	8018fd8 <SecOutput+0x7a4>
 801893e:	a201      	add	r2, pc, #4	; (adr r2, 8018944 <SecOutput+0x110>)
 8018940:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018944:	08018965 	.word	0x08018965
 8018948:	0801897b 	.word	0x0801897b
 801894c:	080189c7 	.word	0x080189c7
 8018950:	080189db 	.word	0x080189db
 8018954:	08018a21 	.word	0x08018a21
 8018958:	08018a2b 	.word	0x08018a2b
 801895c:	08018a6f 	.word	0x08018a6f
 8018960:	08018aa9 	.word	0x08018aa9
        switch (state) {
            case STAT_NORMAL:
                SecWriteChar(stream, ch, &charsOut);
 8018964:	f107 0218 	add.w	r2, r7, #24
 8018968:	f107 0313 	add.w	r3, r7, #19
 801896c:	7819      	ldrb	r1, [r3, #0]
 801896e:	f107 030c 	add.w	r3, r7, #12
 8018972:	6818      	ldr	r0, [r3, #0]
 8018974:	f7fe ff4a 	bl	801780c <SecWriteChar>
                continue;
 8018978:	e331      	b.n	8018fde <SecOutput+0x7aa>
            case STAT_PERCENT:
                /* Set default values */
                noOutput = 0;
 801897a:	f107 031c 	add.w	r3, r7, #28
 801897e:	2200      	movs	r2, #0
 8018980:	601a      	str	r2, [r3, #0]
                formatAttr.prefixLen = 0;
 8018982:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018986:	2200      	movs	r2, #0
 8018988:	62da      	str	r2, [r3, #44]	; 0x2c
                formatAttr.textLen = 0;
 801898a:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801898e:	2200      	movs	r2, #0
 8018990:	609a      	str	r2, [r3, #8]
                formatAttr.flags = 0;
 8018992:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018996:	2200      	movs	r2, #0
 8018998:	615a      	str	r2, [r3, #20]
                formatAttr.fldWidth = 0;
 801899a:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801899e:	2200      	movs	r2, #0
 80189a0:	619a      	str	r2, [r3, #24]
                formatAttr.precision = -1;
 80189a2:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80189a6:	f04f 32ff 	mov.w	r2, #4294967295
 80189aa:	61da      	str	r2, [r3, #28]
                formatAttr.textIsWide = 0;
 80189ac:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80189b0:	2200      	movs	r2, #0
 80189b2:	60da      	str	r2, [r3, #12]
                formatAttr.dynWidth = 0;
 80189b4:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80189b8:	2200      	movs	r2, #0
 80189ba:	621a      	str	r2, [r3, #32]
                formatAttr.dynPrecision = 0;
 80189bc:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80189c0:	2200      	movs	r2, #0
 80189c2:	625a      	str	r2, [r3, #36]	; 0x24
                break;
 80189c4:	e30b      	b.n	8018fde <SecOutput+0x7aa>
            case STAT_FLAG:
                /* Set flag based on which flag character */
                SecDecodeFlags(ch, &formatAttr);
 80189c6:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 80189ca:	f107 0313 	add.w	r3, r7, #19
 80189ce:	781b      	ldrb	r3, [r3, #0]
 80189d0:	4611      	mov	r1, r2
 80189d2:	4618      	mov	r0, r3
 80189d4:	f7ff f940 	bl	8017c58 <SecDecodeFlags>
                break;
 80189d8:	e301      	b.n	8018fde <SecOutput+0x7aa>
            case STAT_WIDTH:
                /* Update width value */
                if (ch == SECUREC_CHAR('*')) {
 80189da:	f107 0313 	add.w	r3, r7, #19
 80189de:	781b      	ldrb	r3, [r3, #0]
 80189e0:	2b2a      	cmp	r3, #42	; 0x2a
 80189e2:	d10c      	bne.n	80189fe <SecOutput+0x1ca>
                    /* get width from arg list */
                    formatAttr.fldWidth = (int)va_arg(argList, int);
 80189e4:	1d3b      	adds	r3, r7, #4
 80189e6:	681b      	ldr	r3, [r3, #0]
 80189e8:	1d19      	adds	r1, r3, #4
 80189ea:	1d3a      	adds	r2, r7, #4
 80189ec:	6011      	str	r1, [r2, #0]
 80189ee:	681a      	ldr	r2, [r3, #0]
 80189f0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80189f4:	619a      	str	r2, [r3, #24]
                    formatAttr.dynWidth = 1;
 80189f6:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 80189fa:	2201      	movs	r2, #1
 80189fc:	621a      	str	r2, [r3, #32]
                }
                if (SecDecodeWidth(ch, &formatAttr, lastState) != 0) {
 80189fe:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8018a02:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018a06:	f107 0213 	add.w	r2, r7, #19
 8018a0a:	7810      	ldrb	r0, [r2, #0]
 8018a0c:	681a      	ldr	r2, [r3, #0]
 8018a0e:	f7ff fbd5 	bl	80181bc <SecDecodeWidth>
 8018a12:	4603      	mov	r3, r0
 8018a14:	2b00      	cmp	r3, #0
 8018a16:	f000 82e2 	beq.w	8018fde <SecOutput+0x7aa>
                    return -1;
 8018a1a:	f04f 33ff 	mov.w	r3, #4294967295
 8018a1e:	e2fa      	b.n	8019016 <SecOutput+0x7e2>
                }
                break;
            case STAT_DOT:
                formatAttr.precision = 0;
 8018a20:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018a24:	2200      	movs	r2, #0
 8018a26:	61da      	str	r2, [r3, #28]
                break;
 8018a28:	e2d9      	b.n	8018fde <SecOutput+0x7aa>
            case STAT_PRECIS:
                /* Update precision value */
                if (ch == SECUREC_CHAR('*')) {
 8018a2a:	f107 0313 	add.w	r3, r7, #19
 8018a2e:	781b      	ldrb	r3, [r3, #0]
 8018a30:	2b2a      	cmp	r3, #42	; 0x2a
 8018a32:	d10c      	bne.n	8018a4e <SecOutput+0x21a>
                    /* Get precision from arg list */
                    formatAttr.precision = (int)va_arg(argList, int);
 8018a34:	1d3b      	adds	r3, r7, #4
 8018a36:	681b      	ldr	r3, [r3, #0]
 8018a38:	1d19      	adds	r1, r3, #4
 8018a3a:	1d3a      	adds	r2, r7, #4
 8018a3c:	6011      	str	r1, [r2, #0]
 8018a3e:	681a      	ldr	r2, [r3, #0]
 8018a40:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018a44:	61da      	str	r2, [r3, #28]
                    formatAttr.dynPrecision = 1;
 8018a46:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018a4a:	2201      	movs	r2, #1
 8018a4c:	625a      	str	r2, [r3, #36]	; 0x24
                }
                if (SecDecodePrecision(ch, &formatAttr) != 0) {
 8018a4e:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8018a52:	f107 0313 	add.w	r3, r7, #19
 8018a56:	781b      	ldrb	r3, [r3, #0]
 8018a58:	4611      	mov	r1, r2
 8018a5a:	4618      	mov	r0, r3
 8018a5c:	f7ff fb72 	bl	8018144 <SecDecodePrecision>
 8018a60:	4603      	mov	r3, r0
 8018a62:	2b00      	cmp	r3, #0
 8018a64:	f000 82bb 	beq.w	8018fde <SecOutput+0x7aa>
                    return -1;
 8018a68:	f04f 33ff 	mov.w	r3, #4294967295
 8018a6c:	e2d3      	b.n	8019016 <SecOutput+0x7e2>
                }
                break;
            case STAT_SIZE:
                /* Read a size specifier, set the formatAttr.flags based on it, and skip format to next character */
                if (SecDecodeSize(ch, &formatAttr, &format) != 0) {
 8018a6e:	f107 0214 	add.w	r2, r7, #20
 8018a72:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018a76:	f107 0313 	add.w	r3, r7, #19
 8018a7a:	781b      	ldrb	r3, [r3, #0]
 8018a7c:	4618      	mov	r0, r3
 8018a7e:	f7ff f9a1 	bl	8017dc4 <SecDecodeSize>
 8018a82:	4603      	mov	r3, r0
 8018a84:	2b00      	cmp	r3, #0
 8018a86:	f000 82aa 	beq.w	8018fde <SecOutput+0x7aa>
                    /* Compatibility  code for "%I" just print I */
                    SecWriteChar(stream, ch, &charsOut);
 8018a8a:	f107 0218 	add.w	r2, r7, #24
 8018a8e:	f107 0313 	add.w	r3, r7, #19
 8018a92:	7819      	ldrb	r1, [r3, #0]
 8018a94:	f107 030c 	add.w	r3, r7, #12
 8018a98:	6818      	ldr	r0, [r3, #0]
 8018a9a:	f7fe feb7 	bl	801780c <SecWriteChar>
                    state = STAT_NORMAL;
 8018a9e:	f107 0320 	add.w	r3, r7, #32
 8018aa2:	2200      	movs	r2, #0
 8018aa4:	601a      	str	r2, [r3, #0]
                    continue;
 8018aa6:	e29a      	b.n	8018fde <SecOutput+0x7aa>
                }
                break;
            case STAT_TYPE:
                switch (ch) {
 8018aa8:	f107 0313 	add.w	r3, r7, #19
 8018aac:	781b      	ldrb	r3, [r3, #0]
 8018aae:	3b43      	subs	r3, #67	; 0x43
 8018ab0:	2b35      	cmp	r3, #53	; 0x35
 8018ab2:	f200 824b 	bhi.w	8018f4c <SecOutput+0x718>
 8018ab6:	a201      	add	r2, pc, #4	; (adr r2, 8018abc <SecOutput+0x288>)
 8018ab8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018abc:	08018b9d 	.word	0x08018b9d
 8018ac0:	08018f4d 	.word	0x08018f4d
 8018ac4:	08018bf9 	.word	0x08018bf9
 8018ac8:	08018bf9 	.word	0x08018bf9
 8018acc:	08018bf9 	.word	0x08018bf9
 8018ad0:	08018f4d 	.word	0x08018f4d
 8018ad4:	08018f4d 	.word	0x08018f4d
 8018ad8:	08018f4d 	.word	0x08018f4d
 8018adc:	08018f4d 	.word	0x08018f4d
 8018ae0:	08018f4d 	.word	0x08018f4d
 8018ae4:	08018f4d 	.word	0x08018f4d
 8018ae8:	08018f4d 	.word	0x08018f4d
 8018aec:	08018f4d 	.word	0x08018f4d
 8018af0:	08018f4d 	.word	0x08018f4d
 8018af4:	08018f4d 	.word	0x08018f4d
 8018af8:	08018f4d 	.word	0x08018f4d
 8018afc:	08018bcb 	.word	0x08018bcb
 8018b00:	08018f4d 	.word	0x08018f4d
 8018b04:	08018f4d 	.word	0x08018f4d
 8018b08:	08018f4d 	.word	0x08018f4d
 8018b0c:	08018f4d 	.word	0x08018f4d
 8018b10:	08018caf 	.word	0x08018caf
 8018b14:	08018f4d 	.word	0x08018f4d
 8018b18:	08018f4d 	.word	0x08018f4d
 8018b1c:	08018f4d 	.word	0x08018f4d
 8018b20:	08018f4d 	.word	0x08018f4d
 8018b24:	08018f4d 	.word	0x08018f4d
 8018b28:	08018f4d 	.word	0x08018f4d
 8018b2c:	08018f4d 	.word	0x08018f4d
 8018b30:	08018f4d 	.word	0x08018f4d
 8018b34:	08018f4d 	.word	0x08018f4d
 8018b38:	08018f4d 	.word	0x08018f4d
 8018b3c:	08018ba7 	.word	0x08018ba7
 8018b40:	08018cc1 	.word	0x08018cc1
 8018b44:	08018bf9 	.word	0x08018bf9
 8018b48:	08018bf9 	.word	0x08018bf9
 8018b4c:	08018bf9 	.word	0x08018bf9
 8018b50:	08018f4d 	.word	0x08018f4d
 8018b54:	08018cc1 	.word	0x08018cc1
 8018b58:	08018f4d 	.word	0x08018f4d
 8018b5c:	08018f4d 	.word	0x08018f4d
 8018b60:	08018f4d 	.word	0x08018f4d
 8018b64:	08018f4d 	.word	0x08018f4d
 8018b68:	08018f4d 	.word	0x08018f4d
 8018b6c:	08018cc1 	.word	0x08018cc1
 8018b70:	08018caf 	.word	0x08018caf
 8018b74:	08018f4d 	.word	0x08018f4d
 8018b78:	08018f4d 	.word	0x08018f4d
 8018b7c:	08018bd5 	.word	0x08018bd5
 8018b80:	08018f4d 	.word	0x08018f4d
 8018b84:	08018cc1 	.word	0x08018cc1
 8018b88:	08018f4d 	.word	0x08018f4d
 8018b8c:	08018f4d 	.word	0x08018f4d
 8018b90:	08018caf 	.word	0x08018caf
 8018b94:	080230c4 	.word	0x080230c4
 8018b98:	08023698 	.word	0x08023698
                    case SECUREC_CHAR('C'): /* Wide char */
                        SecUpdateWcharFlags(&formatAttr);
 8018b9c:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018ba0:	4618      	mov	r0, r3
 8018ba2:	f7ff fb55 	bl	8018250 <SecUpdateWcharFlags>
                        /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('c'): {
                        unsigned int cValue = (unsigned int)va_arg(argList, int);
 8018ba6:	1d3b      	adds	r3, r7, #4
 8018ba8:	681b      	ldr	r3, [r3, #0]
 8018baa:	1d19      	adds	r1, r3, #4
 8018bac:	1d3a      	adds	r2, r7, #4
 8018bae:	6011      	str	r1, [r2, #0]
 8018bb0:	681a      	ldr	r2, [r3, #0]
 8018bb2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8018bb6:	601a      	str	r2, [r3, #0]
                        SecDecodeTypeC(&formatAttr, cValue);
 8018bb8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8018bbc:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8018bc0:	6819      	ldr	r1, [r3, #0]
 8018bc2:	4610      	mov	r0, r2
 8018bc4:	f7ff f9d8 	bl	8017f78 <SecDecodeTypeC>
                        break;
 8018bc8:	e1c5      	b.n	8018f56 <SecOutput+0x722>
                    }
                    case SECUREC_CHAR('S'):    /* Wide char string */
                        SecUpdateWstringFlags(&formatAttr);
 8018bca:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018bce:	4618      	mov	r0, r3
 8018bd0:	f7ff fb54 	bl	801827c <SecUpdateWstringFlags>
                        /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('s'): {
                        char *argPtr = (char *)va_arg(argList, char *);
 8018bd4:	1d3b      	adds	r3, r7, #4
 8018bd6:	681b      	ldr	r3, [r3, #0]
 8018bd8:	1d19      	adds	r1, r3, #4
 8018bda:	1d3a      	adds	r2, r7, #4
 8018bdc:	6011      	str	r1, [r2, #0]
 8018bde:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8018be2:	681b      	ldr	r3, [r3, #0]
 8018be4:	6013      	str	r3, [r2, #0]
                        SecDecodeTypeS(&formatAttr, argPtr);
 8018be6:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8018bea:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8018bee:	6819      	ldr	r1, [r3, #0]
 8018bf0:	4610      	mov	r0, r2
 8018bf2:	f7ff fa87 	bl	8018104 <SecDecodeTypeS>
                        break;
 8018bf6:	e1ae      	b.n	8018f56 <SecOutput+0x722>
                    case SECUREC_CHAR('e'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('f'): {
#if SECUREC_ENABLE_SPRINTF_FLOAT
                        /* Add following code to call system sprintf API for float number */
                        SecFloatAdapt floatAdapt;
                        noOutput = 1; /* It's no more data needs to be written */
 8018bf8:	f107 031c 	add.w	r3, r7, #28
 8018bfc:	2201      	movs	r2, #1
 8018bfe:	601a      	str	r2, [r3, #0]

                        /* Now format is pointer to the next character of 'f' */
                        if (SecInitFloatBuffer(&floatAdapt, format, &formatAttr) != 0) {
 8018c00:	f107 0314 	add.w	r3, r7, #20
 8018c04:	6819      	ldr	r1, [r3, #0]
 8018c06:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8018c0a:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8018c0e:	4618      	mov	r0, r3
 8018c10:	f7ff fca4 	bl	801855c <SecInitFloatBuffer>
 8018c14:	4603      	mov	r3, r0
 8018c16:	2b00      	cmp	r3, #0
 8018c18:	f040 819a 	bne.w	8018f50 <SecOutput+0x71c>
                            break;
                        }

                        if ((formatAttr.flags & SECUREC_FLAG_LONG_DOUBLE) != 0) {
 8018c1c:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018c20:	695b      	ldr	r3, [r3, #20]
 8018c22:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8018c26:	2b00      	cmp	r3, #0
 8018c28:	d019      	beq.n	8018c5e <SecOutput+0x42a>
#if defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && SECUREC_ENABLE_SPRINTF_LONG_DOUBLE
                            long double tmp = (long double)va_arg(argList, long double);
 8018c2a:	1d3b      	adds	r3, r7, #4
 8018c2c:	681b      	ldr	r3, [r3, #0]
 8018c2e:	3307      	adds	r3, #7
 8018c30:	f023 0307 	bic.w	r3, r3, #7
 8018c34:	f103 0108 	add.w	r1, r3, #8
 8018c38:	1d3a      	adds	r2, r7, #4
 8018c3a:	6011      	str	r1, [r2, #0]
 8018c3c:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8018c40:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018c44:	e9c1 2300 	strd	r2, r3, [r1]
                            SecFormatLongDouble(&formatAttr, &floatAdapt, tmp);
 8018c48:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8018c4c:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8018c50:	f107 006c 	add.w	r0, r7, #108	; 0x6c
 8018c54:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018c58:	f7fe fad0 	bl	80171fc <SecFormatLongDouble>
 8018c5c:	e018      	b.n	8018c90 <SecOutput+0x45c>
#else
                            double tmp = (double)va_arg(argList, double);
                            SecFormatDouble(&formatAttr, &floatAdapt, tmp);
#endif
                        } else {
                            double tmp = (double)va_arg(argList, double);
 8018c5e:	1d3b      	adds	r3, r7, #4
 8018c60:	681b      	ldr	r3, [r3, #0]
 8018c62:	3307      	adds	r3, #7
 8018c64:	f023 0307 	bic.w	r3, r3, #7
 8018c68:	f103 0108 	add.w	r1, r3, #8
 8018c6c:	1d3a      	adds	r2, r7, #4
 8018c6e:	6011      	str	r1, [r2, #0]
 8018c70:	f107 0138 	add.w	r1, r7, #56	; 0x38
 8018c74:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018c78:	e9c1 2300 	strd	r2, r3, [r1]
                            SecFormatDouble(&formatAttr, &floatAdapt, tmp);
 8018c7c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8018c80:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 8018c84:	f107 006c 	add.w	r0, r7, #108	; 0x6c
 8018c88:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018c8c:	f7fe fb28 	bl	80172e0 <SecFormatDouble>
                        }

                        /* Only need write formatted float string */
                        SecWriteFloatText(stream, &formatAttr, &charsOut);
 8018c90:	f107 0218 	add.w	r2, r7, #24
 8018c94:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018c98:	f107 030c 	add.w	r3, r7, #12
 8018c9c:	6818      	ldr	r0, [r3, #0]
 8018c9e:	f7fe ff8f 	bl	8017bc0 <SecWriteFloatText>
                        SecFreeFloatBuffer(&floatAdapt);
 8018ca2:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8018ca6:	4618      	mov	r0, r3
 8018ca8:	f7ff fbbe 	bl	8018428 <SecFreeFloatBuffer>
                        break;
 8018cac:	e153      	b.n	8018f56 <SecOutput+0x722>
#endif
                    }
                    case SECUREC_CHAR('X'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('p'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('x'): /* fall-through */ /* FALLTHRU */
                        SecUpdateXpxFlags(&formatAttr, ch);
 8018cae:	f107 0313 	add.w	r3, r7, #19
 8018cb2:	781a      	ldrb	r2, [r3, #0]
 8018cb4:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018cb8:	4611      	mov	r1, r2
 8018cba:	4618      	mov	r0, r3
 8018cbc:	f7ff fb20 	bl	8018300 <SecUpdateXpxFlags>
                    case SECUREC_CHAR('i'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('d'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('u'): /* fall-through */ /* FALLTHRU */
                    case SECUREC_CHAR('o'): {
                        SecInt64 num64;
                        SecUpdateOudiFlags(&formatAttr, ch);
 8018cc0:	f107 0313 	add.w	r3, r7, #19
 8018cc4:	781a      	ldrb	r2, [r3, #0]
 8018cc6:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018cca:	4611      	mov	r1, r2
 8018ccc:	4618      	mov	r0, r3
 8018cce:	f7ff fb4d 	bl	801836c <SecUpdateOudiFlags>
                        /* Read argument into variable num64. Be careful, depend on the order of judgment */
                        if ((formatAttr.flags & SECUREC_FLAG_I64) != 0 ||
 8018cd2:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018cd6:	695b      	ldr	r3, [r3, #20]
 8018cd8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8018cdc:	2b00      	cmp	r3, #0
 8018cde:	d106      	bne.n	8018cee <SecOutput+0x4ba>
                            (formatAttr.flags & SECUREC_FLAG_LONGLONG) != 0) {
 8018ce0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018ce4:	695b      	ldr	r3, [r3, #20]
 8018ce6:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
                        if ((formatAttr.flags & SECUREC_FLAG_I64) != 0 ||
 8018cea:	2b00      	cmp	r3, #0
 8018cec:	d00d      	beq.n	8018d0a <SecOutput+0x4d6>
                            num64 = (SecInt64)va_arg(argList, SecInt64); /* Maximum Bit Width sign bit unchanged */
 8018cee:	1d3b      	adds	r3, r7, #4
 8018cf0:	681b      	ldr	r3, [r3, #0]
 8018cf2:	3307      	adds	r3, #7
 8018cf4:	f023 0307 	bic.w	r3, r3, #7
 8018cf8:	f103 0108 	add.w	r1, r3, #8
 8018cfc:	1d3a      	adds	r2, r7, #4
 8018cfe:	6011      	str	r1, [r2, #0]
 8018d00:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018d04:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8018d08:	e100      	b.n	8018f0c <SecOutput+0x6d8>
                        } else if ((formatAttr.flags & SECUREC_FLAG_LONG) != 0) {
 8018d0a:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018d0e:	695b      	ldr	r3, [r3, #20]
 8018d10:	f003 0310 	and.w	r3, r3, #16
 8018d14:	2b00      	cmp	r3, #0
 8018d16:	d01c      	beq.n	8018d52 <SecOutput+0x51e>
                            num64 = SECUREC_GET_LONG_FROM_ARG(formatAttr);
 8018d18:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018d1c:	695b      	ldr	r3, [r3, #20]
 8018d1e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8018d22:	2b00      	cmp	r3, #0
 8018d24:	d009      	beq.n	8018d3a <SecOutput+0x506>
 8018d26:	1d3b      	adds	r3, r7, #4
 8018d28:	681b      	ldr	r3, [r3, #0]
 8018d2a:	1d19      	adds	r1, r3, #4
 8018d2c:	1d3a      	adds	r2, r7, #4
 8018d2e:	6011      	str	r1, [r2, #0]
 8018d30:	681b      	ldr	r3, [r3, #0]
 8018d32:	461a      	mov	r2, r3
 8018d34:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8018d38:	e008      	b.n	8018d4c <SecOutput+0x518>
 8018d3a:	1d3b      	adds	r3, r7, #4
 8018d3c:	681b      	ldr	r3, [r3, #0]
 8018d3e:	1d19      	adds	r1, r3, #4
 8018d40:	1d3a      	adds	r2, r7, #4
 8018d42:	6011      	str	r1, [r2, #0]
 8018d44:	681b      	ldr	r3, [r3, #0]
 8018d46:	461a      	mov	r2, r3
 8018d48:	f04f 0300 	mov.w	r3, #0
 8018d4c:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8018d50:	e0dc      	b.n	8018f0c <SecOutput+0x6d8>
                        } else if ((formatAttr.flags & SECUREC_FLAG_CHAR) != 0) {
 8018d52:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018d56:	695b      	ldr	r3, [r3, #20]
 8018d58:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8018d5c:	2b00      	cmp	r3, #0
 8018d5e:	d023      	beq.n	8018da8 <SecOutput+0x574>
                            num64 = SECUREC_GET_CHAR_FROM_ARG(formatAttr);
 8018d60:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018d64:	695b      	ldr	r3, [r3, #20]
 8018d66:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8018d6a:	2b00      	cmp	r3, #0
 8018d6c:	d00f      	beq.n	8018d8e <SecOutput+0x55a>
 8018d6e:	1d3b      	adds	r3, r7, #4
 8018d70:	681b      	ldr	r3, [r3, #0]
 8018d72:	1d19      	adds	r1, r3, #4
 8018d74:	1d3a      	adds	r2, r7, #4
 8018d76:	6011      	str	r1, [r2, #0]
 8018d78:	681b      	ldr	r3, [r3, #0]
 8018d7a:	b2da      	uxtb	r2, r3
 8018d7c:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018d80:	4611      	mov	r1, r2
 8018d82:	4618      	mov	r0, r3
 8018d84:	f7ff fc6c 	bl	8018660 <SecUpdateNegativeChar>
 8018d88:	4602      	mov	r2, r0
 8018d8a:	460b      	mov	r3, r1
 8018d8c:	e009      	b.n	8018da2 <SecOutput+0x56e>
 8018d8e:	1d3b      	adds	r3, r7, #4
 8018d90:	681b      	ldr	r3, [r3, #0]
 8018d92:	1d19      	adds	r1, r3, #4
 8018d94:	1d3a      	adds	r2, r7, #4
 8018d96:	6011      	str	r1, [r2, #0]
 8018d98:	681b      	ldr	r3, [r3, #0]
 8018d9a:	b2db      	uxtb	r3, r3
 8018d9c:	b2da      	uxtb	r2, r3
 8018d9e:	f04f 0300 	mov.w	r3, #0
 8018da2:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8018da6:	e0b1      	b.n	8018f0c <SecOutput+0x6d8>
                        } else if ((formatAttr.flags & SECUREC_FLAG_SHORT) != 0) {
 8018da8:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018dac:	695b      	ldr	r3, [r3, #20]
 8018dae:	f003 0320 	and.w	r3, r3, #32
 8018db2:	2b00      	cmp	r3, #0
 8018db4:	d01e      	beq.n	8018df4 <SecOutput+0x5c0>
                            num64 = SECUREC_GET_SHORT_FROM_ARG(formatAttr);
 8018db6:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018dba:	695b      	ldr	r3, [r3, #20]
 8018dbc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8018dc0:	2b00      	cmp	r3, #0
 8018dc2:	d00a      	beq.n	8018dda <SecOutput+0x5a6>
 8018dc4:	1d3b      	adds	r3, r7, #4
 8018dc6:	681b      	ldr	r3, [r3, #0]
 8018dc8:	1d19      	adds	r1, r3, #4
 8018dca:	1d3a      	adds	r2, r7, #4
 8018dcc:	6011      	str	r1, [r2, #0]
 8018dce:	681b      	ldr	r3, [r3, #0]
 8018dd0:	b21b      	sxth	r3, r3
 8018dd2:	b21a      	sxth	r2, r3
 8018dd4:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8018dd8:	e009      	b.n	8018dee <SecOutput+0x5ba>
 8018dda:	1d3b      	adds	r3, r7, #4
 8018ddc:	681b      	ldr	r3, [r3, #0]
 8018dde:	1d19      	adds	r1, r3, #4
 8018de0:	1d3a      	adds	r2, r7, #4
 8018de2:	6011      	str	r1, [r2, #0]
 8018de4:	681b      	ldr	r3, [r3, #0]
 8018de6:	b29b      	uxth	r3, r3
 8018de8:	b29a      	uxth	r2, r3
 8018dea:	f04f 0300 	mov.w	r3, #0
 8018dee:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8018df2:	e08b      	b.n	8018f0c <SecOutput+0x6d8>
#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
                        } else if ((formatAttr.flags & SECUREC_FLAG_PTRDIFF) != 0) {
 8018df4:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018df8:	695b      	ldr	r3, [r3, #20]
 8018dfa:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8018dfe:	2b00      	cmp	r3, #0
 8018e00:	d00b      	beq.n	8018e1a <SecOutput+0x5e6>
                            num64 = (ptrdiff_t)va_arg(argList, ptrdiff_t);  /* Sign extend */
 8018e02:	1d3b      	adds	r3, r7, #4
 8018e04:	681b      	ldr	r3, [r3, #0]
 8018e06:	1d19      	adds	r1, r3, #4
 8018e08:	1d3a      	adds	r2, r7, #4
 8018e0a:	6011      	str	r1, [r2, #0]
 8018e0c:	681b      	ldr	r3, [r3, #0]
 8018e0e:	461a      	mov	r2, r3
 8018e10:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8018e14:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8018e18:	e078      	b.n	8018f0c <SecOutput+0x6d8>
                        } else if ((formatAttr.flags & SECUREC_FLAG_SIZE) != 0) {
 8018e1a:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018e1e:	695b      	ldr	r3, [r3, #20]
 8018e20:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8018e24:	2b00      	cmp	r3, #0
 8018e26:	d040      	beq.n	8018eaa <SecOutput+0x676>
                            num64 = SECUREC_GET_SIZE_FROM_ARG(formatAttr);
 8018e28:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018e2c:	695b      	ldr	r3, [r3, #20]
 8018e2e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8018e32:	2b00      	cmp	r3, #0
 8018e34:	d02d      	beq.n	8018e92 <SecOutput+0x65e>
 8018e36:	2104      	movs	r1, #4
 8018e38:	2004      	movs	r0, #4
 8018e3a:	f7fe fac3 	bl	80173c4 <SecIsSameSize>
 8018e3e:	4603      	mov	r3, r0
 8018e40:	2b00      	cmp	r3, #0
 8018e42:	d009      	beq.n	8018e58 <SecOutput+0x624>
 8018e44:	1d3b      	adds	r3, r7, #4
 8018e46:	681b      	ldr	r3, [r3, #0]
 8018e48:	1d19      	adds	r1, r3, #4
 8018e4a:	1d3a      	adds	r2, r7, #4
 8018e4c:	6011      	str	r1, [r2, #0]
 8018e4e:	681b      	ldr	r3, [r3, #0]
 8018e50:	461a      	mov	r2, r3
 8018e52:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8018e56:	e025      	b.n	8018ea4 <SecOutput+0x670>
 8018e58:	2108      	movs	r1, #8
 8018e5a:	2004      	movs	r0, #4
 8018e5c:	f7fe fab2 	bl	80173c4 <SecIsSameSize>
 8018e60:	4603      	mov	r3, r0
 8018e62:	2b00      	cmp	r3, #0
 8018e64:	d00b      	beq.n	8018e7e <SecOutput+0x64a>
 8018e66:	1d3b      	adds	r3, r7, #4
 8018e68:	681b      	ldr	r3, [r3, #0]
 8018e6a:	3307      	adds	r3, #7
 8018e6c:	f023 0307 	bic.w	r3, r3, #7
 8018e70:	f103 0108 	add.w	r1, r3, #8
 8018e74:	1d3a      	adds	r2, r7, #4
 8018e76:	6011      	str	r1, [r2, #0]
 8018e78:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018e7c:	e012      	b.n	8018ea4 <SecOutput+0x670>
 8018e7e:	1d3b      	adds	r3, r7, #4
 8018e80:	681b      	ldr	r3, [r3, #0]
 8018e82:	1d19      	adds	r1, r3, #4
 8018e84:	1d3a      	adds	r2, r7, #4
 8018e86:	6011      	str	r1, [r2, #0]
 8018e88:	681b      	ldr	r3, [r3, #0]
 8018e8a:	461a      	mov	r2, r3
 8018e8c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8018e90:	e008      	b.n	8018ea4 <SecOutput+0x670>
 8018e92:	1d3b      	adds	r3, r7, #4
 8018e94:	681b      	ldr	r3, [r3, #0]
 8018e96:	1d19      	adds	r1, r3, #4
 8018e98:	1d3a      	adds	r2, r7, #4
 8018e9a:	6011      	str	r1, [r2, #0]
 8018e9c:	681b      	ldr	r3, [r3, #0]
 8018e9e:	461a      	mov	r2, r3
 8018ea0:	f04f 0300 	mov.w	r3, #0
 8018ea4:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8018ea8:	e030      	b.n	8018f0c <SecOutput+0x6d8>
                        } else if ((formatAttr.flags & SECUREC_FLAG_INTMAX) != 0) {
 8018eaa:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018eae:	695b      	ldr	r3, [r3, #20]
 8018eb0:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8018eb4:	2b00      	cmp	r3, #0
 8018eb6:	d00d      	beq.n	8018ed4 <SecOutput+0x6a0>
                            num64 = (SecInt64)va_arg(argList, SecInt64);
 8018eb8:	1d3b      	adds	r3, r7, #4
 8018eba:	681b      	ldr	r3, [r3, #0]
 8018ebc:	3307      	adds	r3, #7
 8018ebe:	f023 0307 	bic.w	r3, r3, #7
 8018ec2:	f103 0108 	add.w	r1, r3, #8
 8018ec6:	1d3a      	adds	r2, r7, #4
 8018ec8:	6011      	str	r1, [r2, #0]
 8018eca:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018ece:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
 8018ed2:	e01b      	b.n	8018f0c <SecOutput+0x6d8>
#endif
                        } else {
                            num64 = SECUREC_GET_INT_FROM_ARG(formatAttr);
 8018ed4:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018ed8:	695b      	ldr	r3, [r3, #20]
 8018eda:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8018ede:	2b00      	cmp	r3, #0
 8018ee0:	d009      	beq.n	8018ef6 <SecOutput+0x6c2>
 8018ee2:	1d3b      	adds	r3, r7, #4
 8018ee4:	681b      	ldr	r3, [r3, #0]
 8018ee6:	1d19      	adds	r1, r3, #4
 8018ee8:	1d3a      	adds	r2, r7, #4
 8018eea:	6011      	str	r1, [r2, #0]
 8018eec:	681b      	ldr	r3, [r3, #0]
 8018eee:	461a      	mov	r2, r3
 8018ef0:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8018ef4:	e008      	b.n	8018f08 <SecOutput+0x6d4>
 8018ef6:	1d3b      	adds	r3, r7, #4
 8018ef8:	681b      	ldr	r3, [r3, #0]
 8018efa:	1d19      	adds	r1, r3, #4
 8018efc:	1d3a      	adds	r2, r7, #4
 8018efe:	6011      	str	r1, [r2, #0]
 8018f00:	681b      	ldr	r3, [r3, #0]
 8018f02:	461a      	mov	r2, r3
 8018f04:	f04f 0300 	mov.w	r3, #0
 8018f08:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
                        }

                        /* The order of the following calls must be correct */
                        SecNumberToBuffer(&formatAttr, num64);
 8018f0c:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018f10:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 8018f14:	4608      	mov	r0, r1
 8018f16:	f7fe fc23 	bl	8017760 <SecNumberToBuffer>
                        SecNumberSatisfyPrecision(&formatAttr);
 8018f1a:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018f1e:	4618      	mov	r0, r3
 8018f20:	f7ff fbc8 	bl	80186b4 <SecNumberSatisfyPrecision>
                        SecNumberForceOctal(&formatAttr);
 8018f24:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018f28:	4618      	mov	r0, r3
 8018f2a:	f7ff fc01 	bl	8018730 <SecNumberForceOctal>
                        SecUpdateSignedNumberPrefix(&formatAttr);
 8018f2e:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018f32:	4618      	mov	r0, r3
 8018f34:	f7ff fc23 	bl	801877e <SecUpdateSignedNumberPrefix>
                        if (num64 == 0) {
 8018f38:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 8018f3c:	4313      	orrs	r3, r2
 8018f3e:	d109      	bne.n	8018f54 <SecOutput+0x720>
                            SecNumberCompatZero(&formatAttr);
 8018f40:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018f44:	4618      	mov	r0, r3
 8018f46:	f7ff fc57 	bl	80187f8 <SecNumberCompatZero>
                        }
                        break;
 8018f4a:	e003      	b.n	8018f54 <SecOutput+0x720>
                    }
                    default:
                        /* Do nothing */
                        break;
 8018f4c:	bf00      	nop
 8018f4e:	e002      	b.n	8018f56 <SecOutput+0x722>
                            break;
 8018f50:	bf00      	nop
 8018f52:	e000      	b.n	8018f56 <SecOutput+0x722>
                        break;
 8018f54:	bf00      	nop
                }

                if (noOutput == 0) {
 8018f56:	f107 031c 	add.w	r3, r7, #28
 8018f5a:	681b      	ldr	r3, [r3, #0]
 8018f5c:	2b00      	cmp	r3, #0
 8018f5e:	d13e      	bne.n	8018fde <SecOutput+0x7aa>
                    /* Calculate amount of padding */
                    formatAttr.padding = (formatAttr.fldWidth - formatAttr.textLen) - formatAttr.prefixLen;
 8018f60:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018f64:	699a      	ldr	r2, [r3, #24]
 8018f66:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018f6a:	689b      	ldr	r3, [r3, #8]
 8018f6c:	1ad2      	subs	r2, r2, r3
 8018f6e:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018f72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8018f74:	1ad2      	subs	r2, r2, r3
 8018f76:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8018f7a:	629a      	str	r2, [r3, #40]	; 0x28

                    /* Put out the padding, prefix, and text, in the correct order */
                    SecWriteLeftPadding(stream, &formatAttr, &charsOut);
 8018f7c:	f107 0218 	add.w	r2, r7, #24
 8018f80:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018f84:	f107 030c 	add.w	r3, r7, #12
 8018f88:	6818      	ldr	r0, [r3, #0]
 8018f8a:	f7fe fd5c 	bl	8017a46 <SecWriteLeftPadding>
                    SecWritePrefix(stream, &formatAttr, &charsOut);
 8018f8e:	f107 0218 	add.w	r2, r7, #24
 8018f92:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018f96:	f107 030c 	add.w	r3, r7, #12
 8018f9a:	6818      	ldr	r0, [r3, #0]
 8018f9c:	f7fe fd6e 	bl	8017a7c <SecWritePrefix>
                    SecWriteLeadingZero(stream, &formatAttr, &charsOut);
 8018fa0:	f107 0218 	add.w	r2, r7, #24
 8018fa4:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018fa8:	f107 030c 	add.w	r3, r7, #12
 8018fac:	6818      	ldr	r0, [r3, #0]
 8018fae:	f7fe fd7c 	bl	8017aaa <SecWriteLeadingZero>
                    SecWriteText(stream, &formatAttr, &charsOut);
 8018fb2:	f107 0218 	add.w	r2, r7, #24
 8018fb6:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018fba:	f107 030c 	add.w	r3, r7, #12
 8018fbe:	6818      	ldr	r0, [r3, #0]
 8018fc0:	f7fe fe10 	bl	8017be4 <SecWriteText>
                    SecWriteRightPadding(stream, &formatAttr, &charsOut);
 8018fc4:	f107 0218 	add.w	r2, r7, #24
 8018fc8:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8018fcc:	f107 030c 	add.w	r3, r7, #12
 8018fd0:	6818      	ldr	r0, [r3, #0]
 8018fd2:	f7fe fd8b 	bl	8017aec <SecWriteRightPadding>
                }
                break;
 8018fd6:	e002      	b.n	8018fde <SecOutput+0x7aa>
            case STAT_INVALID: /* fall-through */ /* FALLTHRU */
            default:
                return -1;  /* Input format is wrong(STAT_INVALID), directly return */
 8018fd8:	f04f 33ff 	mov.w	r3, #4294967295
 8018fdc:	e01b      	b.n	8019016 <SecOutput+0x7e2>
    while (*format != SECUREC_CHAR('\0') && charsOut >= 0) {
 8018fde:	f107 0314 	add.w	r3, r7, #20
 8018fe2:	681b      	ldr	r3, [r3, #0]
 8018fe4:	781b      	ldrb	r3, [r3, #0]
 8018fe6:	2b00      	cmp	r3, #0
 8018fe8:	d005      	beq.n	8018ff6 <SecOutput+0x7c2>
 8018fea:	f107 0318 	add.w	r3, r7, #24
 8018fee:	681b      	ldr	r3, [r3, #0]
 8018ff0:	2b00      	cmp	r3, #0
 8018ff2:	f6bf ac7e 	bge.w	80188f2 <SecOutput+0xbe>
        }
    }

    if (state != STAT_NORMAL && state != STAT_TYPE) {
 8018ff6:	f107 0320 	add.w	r3, r7, #32
 8018ffa:	681b      	ldr	r3, [r3, #0]
 8018ffc:	2b00      	cmp	r3, #0
 8018ffe:	d007      	beq.n	8019010 <SecOutput+0x7dc>
 8019000:	f107 0320 	add.w	r3, r7, #32
 8019004:	681b      	ldr	r3, [r3, #0]
 8019006:	2b07      	cmp	r3, #7
 8019008:	d002      	beq.n	8019010 <SecOutput+0x7dc>
        return -1;
 801900a:	f04f 33ff 	mov.w	r3, #4294967295
 801900e:	e002      	b.n	8019016 <SecOutput+0x7e2>
    }

    return charsOut;            /* The number of characters written */
 8019010:	f107 0318 	add.w	r3, r7, #24
 8019014:	681b      	ldr	r3, [r3, #0]
}
 8019016:	4a06      	ldr	r2, [pc, #24]	; (8019030 <SecOutput+0x7fc>)
 8019018:	6811      	ldr	r1, [r2, #0]
 801901a:	f8d7 22a4 	ldr.w	r2, [r7, #676]	; 0x2a4
 801901e:	4051      	eors	r1, r2
 8019020:	d001      	beq.n	8019026 <SecOutput+0x7f2>
 8019022:	f7eb fadb 	bl	80045dc <__stack_chk_fail>
 8019026:	4618      	mov	r0, r3
 8019028:	f507 772b 	add.w	r7, r7, #684	; 0x2ac
 801902c:	46bd      	mov	sp, r7
 801902e:	bd90      	pop	{r4, r7, pc}
 8019030:	080230c4 	.word	0x080230c4

08019034 <SecPutZeroChar>:
/*
 * Output one zero character zero into the SecPrintfStream structure
 * If there is not enough space, make sure f->count is less than 0
 */
SECUREC_INLINE int SecPutZeroChar(SecPrintfStream *stream)
{
 8019034:	b480      	push	{r7}
 8019036:	b083      	sub	sp, #12
 8019038:	af00      	add	r7, sp, #0
 801903a:	6078      	str	r0, [r7, #4]
    --stream->count;
 801903c:	687b      	ldr	r3, [r7, #4]
 801903e:	681b      	ldr	r3, [r3, #0]
 8019040:	1e5a      	subs	r2, r3, #1
 8019042:	687b      	ldr	r3, [r7, #4]
 8019044:	601a      	str	r2, [r3, #0]
    if (stream->count >= 0) {
 8019046:	687b      	ldr	r3, [r7, #4]
 8019048:	681b      	ldr	r3, [r3, #0]
 801904a:	2b00      	cmp	r3, #0
 801904c:	db0a      	blt.n	8019064 <SecPutZeroChar+0x30>
        *(stream->cur) = SECUREC_CHAR('\0');
 801904e:	687b      	ldr	r3, [r7, #4]
 8019050:	685b      	ldr	r3, [r3, #4]
 8019052:	2200      	movs	r2, #0
 8019054:	701a      	strb	r2, [r3, #0]
        ++stream->cur;
 8019056:	687b      	ldr	r3, [r7, #4]
 8019058:	685b      	ldr	r3, [r3, #4]
 801905a:	1c5a      	adds	r2, r3, #1
 801905c:	687b      	ldr	r3, [r7, #4]
 801905e:	605a      	str	r2, [r3, #4]
        return 0;
 8019060:	2300      	movs	r3, #0
 8019062:	e001      	b.n	8019068 <SecPutZeroChar+0x34>
    }
    return -1;
 8019064:	f04f 33ff 	mov.w	r3, #4294967295
}
 8019068:	4618      	mov	r0, r3
 801906a:	370c      	adds	r7, #12
 801906c:	46bd      	mov	sp, r7
 801906e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019072:	4770      	bx	lr

08019074 <SecVsnprintfImpl>:
#ifdef SECUREC_FOR_WCHAR
int SecVswprintfImpl(wchar_t *string, size_t count, const wchar_t *format, va_list argList)
#else
int SecVsnprintfImpl(char *string, size_t count, const char *format, va_list argList)
#endif
{
 8019074:	b580      	push	{r7, lr}
 8019076:	b088      	sub	sp, #32
 8019078:	af00      	add	r7, sp, #0
 801907a:	60f8      	str	r0, [r7, #12]
 801907c:	60b9      	str	r1, [r7, #8]
 801907e:	607a      	str	r2, [r7, #4]
 8019080:	603b      	str	r3, [r7, #0]
 8019082:	4b1d      	ldr	r3, [pc, #116]	; (80190f8 <SecVsnprintfImpl+0x84>)
 8019084:	681b      	ldr	r3, [r3, #0]
 8019086:	61fb      	str	r3, [r7, #28]
 8019088:	f04f 0300 	mov.w	r3, #0
    SecPrintfStream stream;
    int retVal;

    stream.count = (int)count; /* The count include \0 character, must be greater than zero */
 801908c:	68bb      	ldr	r3, [r7, #8]
 801908e:	617b      	str	r3, [r7, #20]
    stream.cur = string;
 8019090:	68fb      	ldr	r3, [r7, #12]
 8019092:	61bb      	str	r3, [r7, #24]

    retVal = SecOutput(&stream, format, argList);
 8019094:	f107 0314 	add.w	r3, r7, #20
 8019098:	683a      	ldr	r2, [r7, #0]
 801909a:	6879      	ldr	r1, [r7, #4]
 801909c:	4618      	mov	r0, r3
 801909e:	f7ff fbc9 	bl	8018834 <SecOutput>
 80190a2:	6138      	str	r0, [r7, #16]
    if (retVal >= 0) {
 80190a4:	693b      	ldr	r3, [r7, #16]
 80190a6:	2b00      	cmp	r3, #0
 80190a8:	db09      	blt.n	80190be <SecVsnprintfImpl+0x4a>
        if (SecPutZeroChar(&stream) == 0) {
 80190aa:	f107 0314 	add.w	r3, r7, #20
 80190ae:	4618      	mov	r0, r3
 80190b0:	f7ff ffc0 	bl	8019034 <SecPutZeroChar>
 80190b4:	4603      	mov	r3, r0
 80190b6:	2b00      	cmp	r3, #0
 80190b8:	d101      	bne.n	80190be <SecVsnprintfImpl+0x4a>
            return retVal;
 80190ba:	693b      	ldr	r3, [r7, #16]
 80190bc:	e010      	b.n	80190e0 <SecVsnprintfImpl+0x6c>
        }
    }
    if (stream.count < 0) {
 80190be:	697b      	ldr	r3, [r7, #20]
 80190c0:	2b00      	cmp	r3, #0
 80190c2:	da08      	bge.n	80190d6 <SecVsnprintfImpl+0x62>
        /* The buffer was too small, then truncate */
        string[count - 1] = SECUREC_CHAR('\0');
 80190c4:	68bb      	ldr	r3, [r7, #8]
 80190c6:	3b01      	subs	r3, #1
 80190c8:	68fa      	ldr	r2, [r7, #12]
 80190ca:	4413      	add	r3, r2
 80190cc:	2200      	movs	r2, #0
 80190ce:	701a      	strb	r2, [r3, #0]
        return SECUREC_PRINTF_TRUNCATE;
 80190d0:	f06f 0301 	mvn.w	r3, #1
 80190d4:	e004      	b.n	80190e0 <SecVsnprintfImpl+0x6c>
    }
    string[0] = SECUREC_CHAR('\0'); /* Empty the dest string */
 80190d6:	68fb      	ldr	r3, [r7, #12]
 80190d8:	2200      	movs	r2, #0
 80190da:	701a      	strb	r2, [r3, #0]
    return -1;
 80190dc:	f04f 33ff 	mov.w	r3, #4294967295
}
 80190e0:	4a05      	ldr	r2, [pc, #20]	; (80190f8 <SecVsnprintfImpl+0x84>)
 80190e2:	6811      	ldr	r1, [r2, #0]
 80190e4:	69fa      	ldr	r2, [r7, #28]
 80190e6:	4051      	eors	r1, r2
 80190e8:	d001      	beq.n	80190ee <SecVsnprintfImpl+0x7a>
 80190ea:	f7eb fa77 	bl	80045dc <__stack_chk_fail>
 80190ee:	4618      	mov	r0, r3
 80190f0:	3720      	adds	r7, #32
 80190f2:	46bd      	mov	sp, r7
 80190f4:	bd80      	pop	{r7, pc}
 80190f6:	bf00      	nop
 80190f8:	080230c8 	.word	0x080230c8

080190fc <memcpy>:
#include <string.h>
#include <stdint.h>
#include <endian.h>

void *memcpy(void *restrict dest, const void *restrict src, size_t n)
{
 80190fc:	b480      	push	{r7}
 80190fe:	b089      	sub	sp, #36	; 0x24
 8019100:	af00      	add	r7, sp, #0
 8019102:	60f8      	str	r0, [r7, #12]
 8019104:	60b9      	str	r1, [r7, #8]
 8019106:	607a      	str	r2, [r7, #4]
	unsigned char *d = dest;
 8019108:	68fb      	ldr	r3, [r7, #12]
 801910a:	613b      	str	r3, [r7, #16]
	const unsigned char *s = src;
 801910c:	68bb      	ldr	r3, [r7, #8]
 801910e:	617b      	str	r3, [r7, #20]
#endif

	typedef uint32_t __attribute__((__may_alias__)) u32;
	uint32_t w, x;

	for (; (uintptr_t)s % 4 && n; n--) *d++ = *s++;
 8019110:	e00a      	b.n	8019128 <memcpy+0x2c>
 8019112:	697a      	ldr	r2, [r7, #20]
 8019114:	1c53      	adds	r3, r2, #1
 8019116:	617b      	str	r3, [r7, #20]
 8019118:	693b      	ldr	r3, [r7, #16]
 801911a:	1c59      	adds	r1, r3, #1
 801911c:	6139      	str	r1, [r7, #16]
 801911e:	7812      	ldrb	r2, [r2, #0]
 8019120:	701a      	strb	r2, [r3, #0]
 8019122:	687b      	ldr	r3, [r7, #4]
 8019124:	3b01      	subs	r3, #1
 8019126:	607b      	str	r3, [r7, #4]
 8019128:	697b      	ldr	r3, [r7, #20]
 801912a:	f003 0303 	and.w	r3, r3, #3
 801912e:	2b00      	cmp	r3, #0
 8019130:	d002      	beq.n	8019138 <memcpy+0x3c>
 8019132:	687b      	ldr	r3, [r7, #4]
 8019134:	2b00      	cmp	r3, #0
 8019136:	d1ec      	bne.n	8019112 <memcpy+0x16>

	if ((uintptr_t)d % 4 == 0) {
 8019138:	693b      	ldr	r3, [r7, #16]
 801913a:	f003 0303 	and.w	r3, r3, #3
 801913e:	2b00      	cmp	r3, #0
 8019140:	d168      	bne.n	8019214 <memcpy+0x118>
		for (; n>=16; s+=16, d+=16, n-=16) {
 8019142:	e020      	b.n	8019186 <memcpy+0x8a>
			*(u32 *)(d+0) = *(u32 *)(s+0);
 8019144:	697b      	ldr	r3, [r7, #20]
 8019146:	681a      	ldr	r2, [r3, #0]
 8019148:	693b      	ldr	r3, [r7, #16]
 801914a:	601a      	str	r2, [r3, #0]
			*(u32 *)(d+4) = *(u32 *)(s+4);
 801914c:	697b      	ldr	r3, [r7, #20]
 801914e:	1d1a      	adds	r2, r3, #4
 8019150:	693b      	ldr	r3, [r7, #16]
 8019152:	3304      	adds	r3, #4
 8019154:	6812      	ldr	r2, [r2, #0]
 8019156:	601a      	str	r2, [r3, #0]
			*(u32 *)(d+8) = *(u32 *)(s+8);
 8019158:	697b      	ldr	r3, [r7, #20]
 801915a:	f103 0208 	add.w	r2, r3, #8
 801915e:	693b      	ldr	r3, [r7, #16]
 8019160:	3308      	adds	r3, #8
 8019162:	6812      	ldr	r2, [r2, #0]
 8019164:	601a      	str	r2, [r3, #0]
			*(u32 *)(d+12) = *(u32 *)(s+12);
 8019166:	697b      	ldr	r3, [r7, #20]
 8019168:	f103 020c 	add.w	r2, r3, #12
 801916c:	693b      	ldr	r3, [r7, #16]
 801916e:	330c      	adds	r3, #12
 8019170:	6812      	ldr	r2, [r2, #0]
 8019172:	601a      	str	r2, [r3, #0]
		for (; n>=16; s+=16, d+=16, n-=16) {
 8019174:	697b      	ldr	r3, [r7, #20]
 8019176:	3310      	adds	r3, #16
 8019178:	617b      	str	r3, [r7, #20]
 801917a:	693b      	ldr	r3, [r7, #16]
 801917c:	3310      	adds	r3, #16
 801917e:	613b      	str	r3, [r7, #16]
 8019180:	687b      	ldr	r3, [r7, #4]
 8019182:	3b10      	subs	r3, #16
 8019184:	607b      	str	r3, [r7, #4]
 8019186:	687b      	ldr	r3, [r7, #4]
 8019188:	2b0f      	cmp	r3, #15
 801918a:	d8db      	bhi.n	8019144 <memcpy+0x48>
		}
		if (n&8) {
 801918c:	687b      	ldr	r3, [r7, #4]
 801918e:	f003 0308 	and.w	r3, r3, #8
 8019192:	2b00      	cmp	r3, #0
 8019194:	d00f      	beq.n	80191b6 <memcpy+0xba>
			*(u32 *)(d+0) = *(u32 *)(s+0);
 8019196:	697b      	ldr	r3, [r7, #20]
 8019198:	681a      	ldr	r2, [r3, #0]
 801919a:	693b      	ldr	r3, [r7, #16]
 801919c:	601a      	str	r2, [r3, #0]
			*(u32 *)(d+4) = *(u32 *)(s+4);
 801919e:	697b      	ldr	r3, [r7, #20]
 80191a0:	1d1a      	adds	r2, r3, #4
 80191a2:	693b      	ldr	r3, [r7, #16]
 80191a4:	3304      	adds	r3, #4
 80191a6:	6812      	ldr	r2, [r2, #0]
 80191a8:	601a      	str	r2, [r3, #0]
			d += 8; s += 8;
 80191aa:	693b      	ldr	r3, [r7, #16]
 80191ac:	3308      	adds	r3, #8
 80191ae:	613b      	str	r3, [r7, #16]
 80191b0:	697b      	ldr	r3, [r7, #20]
 80191b2:	3308      	adds	r3, #8
 80191b4:	617b      	str	r3, [r7, #20]
		}
		if (n&4) {
 80191b6:	687b      	ldr	r3, [r7, #4]
 80191b8:	f003 0304 	and.w	r3, r3, #4
 80191bc:	2b00      	cmp	r3, #0
 80191be:	d009      	beq.n	80191d4 <memcpy+0xd8>
			*(u32 *)(d+0) = *(u32 *)(s+0);
 80191c0:	697b      	ldr	r3, [r7, #20]
 80191c2:	681a      	ldr	r2, [r3, #0]
 80191c4:	693b      	ldr	r3, [r7, #16]
 80191c6:	601a      	str	r2, [r3, #0]
			d += 4; s += 4;
 80191c8:	693b      	ldr	r3, [r7, #16]
 80191ca:	3304      	adds	r3, #4
 80191cc:	613b      	str	r3, [r7, #16]
 80191ce:	697b      	ldr	r3, [r7, #20]
 80191d0:	3304      	adds	r3, #4
 80191d2:	617b      	str	r3, [r7, #20]
		}
		if (n&2) {
 80191d4:	687b      	ldr	r3, [r7, #4]
 80191d6:	f003 0302 	and.w	r3, r3, #2
 80191da:	2b00      	cmp	r3, #0
 80191dc:	d00f      	beq.n	80191fe <memcpy+0x102>
			*d++ = *s++; *d++ = *s++;
 80191de:	697a      	ldr	r2, [r7, #20]
 80191e0:	1c53      	adds	r3, r2, #1
 80191e2:	617b      	str	r3, [r7, #20]
 80191e4:	693b      	ldr	r3, [r7, #16]
 80191e6:	1c59      	adds	r1, r3, #1
 80191e8:	6139      	str	r1, [r7, #16]
 80191ea:	7812      	ldrb	r2, [r2, #0]
 80191ec:	701a      	strb	r2, [r3, #0]
 80191ee:	697a      	ldr	r2, [r7, #20]
 80191f0:	1c53      	adds	r3, r2, #1
 80191f2:	617b      	str	r3, [r7, #20]
 80191f4:	693b      	ldr	r3, [r7, #16]
 80191f6:	1c59      	adds	r1, r3, #1
 80191f8:	6139      	str	r1, [r7, #16]
 80191fa:	7812      	ldrb	r2, [r2, #0]
 80191fc:	701a      	strb	r2, [r3, #0]
		}
		if (n&1) {
 80191fe:	687b      	ldr	r3, [r7, #4]
 8019200:	f003 0301 	and.w	r3, r3, #1
 8019204:	2b00      	cmp	r3, #0
 8019206:	d003      	beq.n	8019210 <memcpy+0x114>
			*d = *s;
 8019208:	697b      	ldr	r3, [r7, #20]
 801920a:	781a      	ldrb	r2, [r3, #0]
 801920c:	693b      	ldr	r3, [r7, #16]
 801920e:	701a      	strb	r2, [r3, #0]
		}
		return dest;
 8019210:	68fb      	ldr	r3, [r7, #12]
 8019212:	e219      	b.n	8019648 <memcpy+0x54c>
	}

	if (n >= 32) switch ((uintptr_t)d % 4) {
 8019214:	687b      	ldr	r3, [r7, #4]
 8019216:	2b1f      	cmp	r3, #31
 8019218:	f240 8107 	bls.w	801942a <memcpy+0x32e>
 801921c:	693b      	ldr	r3, [r7, #16]
 801921e:	f003 0303 	and.w	r3, r3, #3
 8019222:	2b03      	cmp	r3, #3
 8019224:	f000 80b6 	beq.w	8019394 <memcpy+0x298>
 8019228:	2b03      	cmp	r3, #3
 801922a:	f200 80ff 	bhi.w	801942c <memcpy+0x330>
 801922e:	2b01      	cmp	r3, #1
 8019230:	d002      	beq.n	8019238 <memcpy+0x13c>
 8019232:	2b02      	cmp	r3, #2
 8019234:	d05b      	beq.n	80192ee <memcpy+0x1f2>
 8019236:	e0f9      	b.n	801942c <memcpy+0x330>
	case 1:
		w = *(u32 *)s;
 8019238:	697b      	ldr	r3, [r7, #20]
 801923a:	681b      	ldr	r3, [r3, #0]
 801923c:	61bb      	str	r3, [r7, #24]
		*d++ = *s++;
 801923e:	697a      	ldr	r2, [r7, #20]
 8019240:	1c53      	adds	r3, r2, #1
 8019242:	617b      	str	r3, [r7, #20]
 8019244:	693b      	ldr	r3, [r7, #16]
 8019246:	1c59      	adds	r1, r3, #1
 8019248:	6139      	str	r1, [r7, #16]
 801924a:	7812      	ldrb	r2, [r2, #0]
 801924c:	701a      	strb	r2, [r3, #0]
		*d++ = *s++;
 801924e:	697a      	ldr	r2, [r7, #20]
 8019250:	1c53      	adds	r3, r2, #1
 8019252:	617b      	str	r3, [r7, #20]
 8019254:	693b      	ldr	r3, [r7, #16]
 8019256:	1c59      	adds	r1, r3, #1
 8019258:	6139      	str	r1, [r7, #16]
 801925a:	7812      	ldrb	r2, [r2, #0]
 801925c:	701a      	strb	r2, [r3, #0]
		*d++ = *s++;
 801925e:	697a      	ldr	r2, [r7, #20]
 8019260:	1c53      	adds	r3, r2, #1
 8019262:	617b      	str	r3, [r7, #20]
 8019264:	693b      	ldr	r3, [r7, #16]
 8019266:	1c59      	adds	r1, r3, #1
 8019268:	6139      	str	r1, [r7, #16]
 801926a:	7812      	ldrb	r2, [r2, #0]
 801926c:	701a      	strb	r2, [r3, #0]
		n -= 3;
 801926e:	687b      	ldr	r3, [r7, #4]
 8019270:	3b03      	subs	r3, #3
 8019272:	607b      	str	r3, [r7, #4]
		for (; n>=17; s+=16, d+=16, n-=16) {
 8019274:	e037      	b.n	80192e6 <memcpy+0x1ea>
			x = *(u32 *)(s+1);
 8019276:	697b      	ldr	r3, [r7, #20]
 8019278:	3301      	adds	r3, #1
 801927a:	681b      	ldr	r3, [r3, #0]
 801927c:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+0) = (w LS 24) | (x RS 8);
 801927e:	69bb      	ldr	r3, [r7, #24]
 8019280:	0e1a      	lsrs	r2, r3, #24
 8019282:	69fb      	ldr	r3, [r7, #28]
 8019284:	021b      	lsls	r3, r3, #8
 8019286:	431a      	orrs	r2, r3
 8019288:	693b      	ldr	r3, [r7, #16]
 801928a:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+5);
 801928c:	697b      	ldr	r3, [r7, #20]
 801928e:	3305      	adds	r3, #5
 8019290:	681b      	ldr	r3, [r3, #0]
 8019292:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+4) = (x LS 24) | (w RS 8);
 8019294:	69fb      	ldr	r3, [r7, #28]
 8019296:	0e19      	lsrs	r1, r3, #24
 8019298:	69bb      	ldr	r3, [r7, #24]
 801929a:	021a      	lsls	r2, r3, #8
 801929c:	693b      	ldr	r3, [r7, #16]
 801929e:	3304      	adds	r3, #4
 80192a0:	430a      	orrs	r2, r1
 80192a2:	601a      	str	r2, [r3, #0]
			x = *(u32 *)(s+9);
 80192a4:	697b      	ldr	r3, [r7, #20]
 80192a6:	3309      	adds	r3, #9
 80192a8:	681b      	ldr	r3, [r3, #0]
 80192aa:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+8) = (w LS 24) | (x RS 8);
 80192ac:	69bb      	ldr	r3, [r7, #24]
 80192ae:	0e19      	lsrs	r1, r3, #24
 80192b0:	69fb      	ldr	r3, [r7, #28]
 80192b2:	021a      	lsls	r2, r3, #8
 80192b4:	693b      	ldr	r3, [r7, #16]
 80192b6:	3308      	adds	r3, #8
 80192b8:	430a      	orrs	r2, r1
 80192ba:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+13);
 80192bc:	697b      	ldr	r3, [r7, #20]
 80192be:	330d      	adds	r3, #13
 80192c0:	681b      	ldr	r3, [r3, #0]
 80192c2:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+12) = (x LS 24) | (w RS 8);
 80192c4:	69fb      	ldr	r3, [r7, #28]
 80192c6:	0e19      	lsrs	r1, r3, #24
 80192c8:	69bb      	ldr	r3, [r7, #24]
 80192ca:	021a      	lsls	r2, r3, #8
 80192cc:	693b      	ldr	r3, [r7, #16]
 80192ce:	330c      	adds	r3, #12
 80192d0:	430a      	orrs	r2, r1
 80192d2:	601a      	str	r2, [r3, #0]
		for (; n>=17; s+=16, d+=16, n-=16) {
 80192d4:	697b      	ldr	r3, [r7, #20]
 80192d6:	3310      	adds	r3, #16
 80192d8:	617b      	str	r3, [r7, #20]
 80192da:	693b      	ldr	r3, [r7, #16]
 80192dc:	3310      	adds	r3, #16
 80192de:	613b      	str	r3, [r7, #16]
 80192e0:	687b      	ldr	r3, [r7, #4]
 80192e2:	3b10      	subs	r3, #16
 80192e4:	607b      	str	r3, [r7, #4]
 80192e6:	687b      	ldr	r3, [r7, #4]
 80192e8:	2b10      	cmp	r3, #16
 80192ea:	d8c4      	bhi.n	8019276 <memcpy+0x17a>
		}
		break;
 80192ec:	e09e      	b.n	801942c <memcpy+0x330>
	case 2:
		w = *(u32 *)s;
 80192ee:	697b      	ldr	r3, [r7, #20]
 80192f0:	681b      	ldr	r3, [r3, #0]
 80192f2:	61bb      	str	r3, [r7, #24]
		*d++ = *s++;
 80192f4:	697a      	ldr	r2, [r7, #20]
 80192f6:	1c53      	adds	r3, r2, #1
 80192f8:	617b      	str	r3, [r7, #20]
 80192fa:	693b      	ldr	r3, [r7, #16]
 80192fc:	1c59      	adds	r1, r3, #1
 80192fe:	6139      	str	r1, [r7, #16]
 8019300:	7812      	ldrb	r2, [r2, #0]
 8019302:	701a      	strb	r2, [r3, #0]
		*d++ = *s++;
 8019304:	697a      	ldr	r2, [r7, #20]
 8019306:	1c53      	adds	r3, r2, #1
 8019308:	617b      	str	r3, [r7, #20]
 801930a:	693b      	ldr	r3, [r7, #16]
 801930c:	1c59      	adds	r1, r3, #1
 801930e:	6139      	str	r1, [r7, #16]
 8019310:	7812      	ldrb	r2, [r2, #0]
 8019312:	701a      	strb	r2, [r3, #0]
		n -= 2;
 8019314:	687b      	ldr	r3, [r7, #4]
 8019316:	3b02      	subs	r3, #2
 8019318:	607b      	str	r3, [r7, #4]
		for (; n>=18; s+=16, d+=16, n-=16) {
 801931a:	e037      	b.n	801938c <memcpy+0x290>
			x = *(u32 *)(s+2);
 801931c:	697b      	ldr	r3, [r7, #20]
 801931e:	3302      	adds	r3, #2
 8019320:	681b      	ldr	r3, [r3, #0]
 8019322:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+0) = (w LS 16) | (x RS 16);
 8019324:	69bb      	ldr	r3, [r7, #24]
 8019326:	0c1a      	lsrs	r2, r3, #16
 8019328:	69fb      	ldr	r3, [r7, #28]
 801932a:	041b      	lsls	r3, r3, #16
 801932c:	431a      	orrs	r2, r3
 801932e:	693b      	ldr	r3, [r7, #16]
 8019330:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+6);
 8019332:	697b      	ldr	r3, [r7, #20]
 8019334:	3306      	adds	r3, #6
 8019336:	681b      	ldr	r3, [r3, #0]
 8019338:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+4) = (x LS 16) | (w RS 16);
 801933a:	69fb      	ldr	r3, [r7, #28]
 801933c:	0c19      	lsrs	r1, r3, #16
 801933e:	69bb      	ldr	r3, [r7, #24]
 8019340:	041a      	lsls	r2, r3, #16
 8019342:	693b      	ldr	r3, [r7, #16]
 8019344:	3304      	adds	r3, #4
 8019346:	430a      	orrs	r2, r1
 8019348:	601a      	str	r2, [r3, #0]
			x = *(u32 *)(s+10);
 801934a:	697b      	ldr	r3, [r7, #20]
 801934c:	330a      	adds	r3, #10
 801934e:	681b      	ldr	r3, [r3, #0]
 8019350:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+8) = (w LS 16) | (x RS 16);
 8019352:	69bb      	ldr	r3, [r7, #24]
 8019354:	0c19      	lsrs	r1, r3, #16
 8019356:	69fb      	ldr	r3, [r7, #28]
 8019358:	041a      	lsls	r2, r3, #16
 801935a:	693b      	ldr	r3, [r7, #16]
 801935c:	3308      	adds	r3, #8
 801935e:	430a      	orrs	r2, r1
 8019360:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+14);
 8019362:	697b      	ldr	r3, [r7, #20]
 8019364:	330e      	adds	r3, #14
 8019366:	681b      	ldr	r3, [r3, #0]
 8019368:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+12) = (x LS 16) | (w RS 16);
 801936a:	69fb      	ldr	r3, [r7, #28]
 801936c:	0c19      	lsrs	r1, r3, #16
 801936e:	69bb      	ldr	r3, [r7, #24]
 8019370:	041a      	lsls	r2, r3, #16
 8019372:	693b      	ldr	r3, [r7, #16]
 8019374:	330c      	adds	r3, #12
 8019376:	430a      	orrs	r2, r1
 8019378:	601a      	str	r2, [r3, #0]
		for (; n>=18; s+=16, d+=16, n-=16) {
 801937a:	697b      	ldr	r3, [r7, #20]
 801937c:	3310      	adds	r3, #16
 801937e:	617b      	str	r3, [r7, #20]
 8019380:	693b      	ldr	r3, [r7, #16]
 8019382:	3310      	adds	r3, #16
 8019384:	613b      	str	r3, [r7, #16]
 8019386:	687b      	ldr	r3, [r7, #4]
 8019388:	3b10      	subs	r3, #16
 801938a:	607b      	str	r3, [r7, #4]
 801938c:	687b      	ldr	r3, [r7, #4]
 801938e:	2b11      	cmp	r3, #17
 8019390:	d8c4      	bhi.n	801931c <memcpy+0x220>
		}
		break;
 8019392:	e04b      	b.n	801942c <memcpy+0x330>
	case 3:
		w = *(u32 *)s;
 8019394:	697b      	ldr	r3, [r7, #20]
 8019396:	681b      	ldr	r3, [r3, #0]
 8019398:	61bb      	str	r3, [r7, #24]
		*d++ = *s++;
 801939a:	697a      	ldr	r2, [r7, #20]
 801939c:	1c53      	adds	r3, r2, #1
 801939e:	617b      	str	r3, [r7, #20]
 80193a0:	693b      	ldr	r3, [r7, #16]
 80193a2:	1c59      	adds	r1, r3, #1
 80193a4:	6139      	str	r1, [r7, #16]
 80193a6:	7812      	ldrb	r2, [r2, #0]
 80193a8:	701a      	strb	r2, [r3, #0]
		n -= 1;
 80193aa:	687b      	ldr	r3, [r7, #4]
 80193ac:	3b01      	subs	r3, #1
 80193ae:	607b      	str	r3, [r7, #4]
		for (; n>=19; s+=16, d+=16, n-=16) {
 80193b0:	e037      	b.n	8019422 <memcpy+0x326>
			x = *(u32 *)(s+3);
 80193b2:	697b      	ldr	r3, [r7, #20]
 80193b4:	3303      	adds	r3, #3
 80193b6:	681b      	ldr	r3, [r3, #0]
 80193b8:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+0) = (w LS 8) | (x RS 24);
 80193ba:	69bb      	ldr	r3, [r7, #24]
 80193bc:	0a1a      	lsrs	r2, r3, #8
 80193be:	69fb      	ldr	r3, [r7, #28]
 80193c0:	061b      	lsls	r3, r3, #24
 80193c2:	431a      	orrs	r2, r3
 80193c4:	693b      	ldr	r3, [r7, #16]
 80193c6:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+7);
 80193c8:	697b      	ldr	r3, [r7, #20]
 80193ca:	3307      	adds	r3, #7
 80193cc:	681b      	ldr	r3, [r3, #0]
 80193ce:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+4) = (x LS 8) | (w RS 24);
 80193d0:	69fb      	ldr	r3, [r7, #28]
 80193d2:	0a19      	lsrs	r1, r3, #8
 80193d4:	69bb      	ldr	r3, [r7, #24]
 80193d6:	061a      	lsls	r2, r3, #24
 80193d8:	693b      	ldr	r3, [r7, #16]
 80193da:	3304      	adds	r3, #4
 80193dc:	430a      	orrs	r2, r1
 80193de:	601a      	str	r2, [r3, #0]
			x = *(u32 *)(s+11);
 80193e0:	697b      	ldr	r3, [r7, #20]
 80193e2:	330b      	adds	r3, #11
 80193e4:	681b      	ldr	r3, [r3, #0]
 80193e6:	61fb      	str	r3, [r7, #28]
			*(u32 *)(d+8) = (w LS 8) | (x RS 24);
 80193e8:	69bb      	ldr	r3, [r7, #24]
 80193ea:	0a19      	lsrs	r1, r3, #8
 80193ec:	69fb      	ldr	r3, [r7, #28]
 80193ee:	061a      	lsls	r2, r3, #24
 80193f0:	693b      	ldr	r3, [r7, #16]
 80193f2:	3308      	adds	r3, #8
 80193f4:	430a      	orrs	r2, r1
 80193f6:	601a      	str	r2, [r3, #0]
			w = *(u32 *)(s+15);
 80193f8:	697b      	ldr	r3, [r7, #20]
 80193fa:	330f      	adds	r3, #15
 80193fc:	681b      	ldr	r3, [r3, #0]
 80193fe:	61bb      	str	r3, [r7, #24]
			*(u32 *)(d+12) = (x LS 8) | (w RS 24);
 8019400:	69fb      	ldr	r3, [r7, #28]
 8019402:	0a19      	lsrs	r1, r3, #8
 8019404:	69bb      	ldr	r3, [r7, #24]
 8019406:	061a      	lsls	r2, r3, #24
 8019408:	693b      	ldr	r3, [r7, #16]
 801940a:	330c      	adds	r3, #12
 801940c:	430a      	orrs	r2, r1
 801940e:	601a      	str	r2, [r3, #0]
		for (; n>=19; s+=16, d+=16, n-=16) {
 8019410:	697b      	ldr	r3, [r7, #20]
 8019412:	3310      	adds	r3, #16
 8019414:	617b      	str	r3, [r7, #20]
 8019416:	693b      	ldr	r3, [r7, #16]
 8019418:	3310      	adds	r3, #16
 801941a:	613b      	str	r3, [r7, #16]
 801941c:	687b      	ldr	r3, [r7, #4]
 801941e:	3b10      	subs	r3, #16
 8019420:	607b      	str	r3, [r7, #4]
 8019422:	687b      	ldr	r3, [r7, #4]
 8019424:	2b12      	cmp	r3, #18
 8019426:	d8c4      	bhi.n	80193b2 <memcpy+0x2b6>
		}
		break;
 8019428:	e000      	b.n	801942c <memcpy+0x330>
	}
	if (n&16) {
 801942a:	bf00      	nop
 801942c:	687b      	ldr	r3, [r7, #4]
 801942e:	f003 0310 	and.w	r3, r3, #16
 8019432:	2b00      	cmp	r3, #0
 8019434:	d07f      	beq.n	8019536 <memcpy+0x43a>
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 8019436:	697a      	ldr	r2, [r7, #20]
 8019438:	1c53      	adds	r3, r2, #1
 801943a:	617b      	str	r3, [r7, #20]
 801943c:	693b      	ldr	r3, [r7, #16]
 801943e:	1c59      	adds	r1, r3, #1
 8019440:	6139      	str	r1, [r7, #16]
 8019442:	7812      	ldrb	r2, [r2, #0]
 8019444:	701a      	strb	r2, [r3, #0]
 8019446:	697a      	ldr	r2, [r7, #20]
 8019448:	1c53      	adds	r3, r2, #1
 801944a:	617b      	str	r3, [r7, #20]
 801944c:	693b      	ldr	r3, [r7, #16]
 801944e:	1c59      	adds	r1, r3, #1
 8019450:	6139      	str	r1, [r7, #16]
 8019452:	7812      	ldrb	r2, [r2, #0]
 8019454:	701a      	strb	r2, [r3, #0]
 8019456:	697a      	ldr	r2, [r7, #20]
 8019458:	1c53      	adds	r3, r2, #1
 801945a:	617b      	str	r3, [r7, #20]
 801945c:	693b      	ldr	r3, [r7, #16]
 801945e:	1c59      	adds	r1, r3, #1
 8019460:	6139      	str	r1, [r7, #16]
 8019462:	7812      	ldrb	r2, [r2, #0]
 8019464:	701a      	strb	r2, [r3, #0]
 8019466:	697a      	ldr	r2, [r7, #20]
 8019468:	1c53      	adds	r3, r2, #1
 801946a:	617b      	str	r3, [r7, #20]
 801946c:	693b      	ldr	r3, [r7, #16]
 801946e:	1c59      	adds	r1, r3, #1
 8019470:	6139      	str	r1, [r7, #16]
 8019472:	7812      	ldrb	r2, [r2, #0]
 8019474:	701a      	strb	r2, [r3, #0]
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 8019476:	697a      	ldr	r2, [r7, #20]
 8019478:	1c53      	adds	r3, r2, #1
 801947a:	617b      	str	r3, [r7, #20]
 801947c:	693b      	ldr	r3, [r7, #16]
 801947e:	1c59      	adds	r1, r3, #1
 8019480:	6139      	str	r1, [r7, #16]
 8019482:	7812      	ldrb	r2, [r2, #0]
 8019484:	701a      	strb	r2, [r3, #0]
 8019486:	697a      	ldr	r2, [r7, #20]
 8019488:	1c53      	adds	r3, r2, #1
 801948a:	617b      	str	r3, [r7, #20]
 801948c:	693b      	ldr	r3, [r7, #16]
 801948e:	1c59      	adds	r1, r3, #1
 8019490:	6139      	str	r1, [r7, #16]
 8019492:	7812      	ldrb	r2, [r2, #0]
 8019494:	701a      	strb	r2, [r3, #0]
 8019496:	697a      	ldr	r2, [r7, #20]
 8019498:	1c53      	adds	r3, r2, #1
 801949a:	617b      	str	r3, [r7, #20]
 801949c:	693b      	ldr	r3, [r7, #16]
 801949e:	1c59      	adds	r1, r3, #1
 80194a0:	6139      	str	r1, [r7, #16]
 80194a2:	7812      	ldrb	r2, [r2, #0]
 80194a4:	701a      	strb	r2, [r3, #0]
 80194a6:	697a      	ldr	r2, [r7, #20]
 80194a8:	1c53      	adds	r3, r2, #1
 80194aa:	617b      	str	r3, [r7, #20]
 80194ac:	693b      	ldr	r3, [r7, #16]
 80194ae:	1c59      	adds	r1, r3, #1
 80194b0:	6139      	str	r1, [r7, #16]
 80194b2:	7812      	ldrb	r2, [r2, #0]
 80194b4:	701a      	strb	r2, [r3, #0]
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 80194b6:	697a      	ldr	r2, [r7, #20]
 80194b8:	1c53      	adds	r3, r2, #1
 80194ba:	617b      	str	r3, [r7, #20]
 80194bc:	693b      	ldr	r3, [r7, #16]
 80194be:	1c59      	adds	r1, r3, #1
 80194c0:	6139      	str	r1, [r7, #16]
 80194c2:	7812      	ldrb	r2, [r2, #0]
 80194c4:	701a      	strb	r2, [r3, #0]
 80194c6:	697a      	ldr	r2, [r7, #20]
 80194c8:	1c53      	adds	r3, r2, #1
 80194ca:	617b      	str	r3, [r7, #20]
 80194cc:	693b      	ldr	r3, [r7, #16]
 80194ce:	1c59      	adds	r1, r3, #1
 80194d0:	6139      	str	r1, [r7, #16]
 80194d2:	7812      	ldrb	r2, [r2, #0]
 80194d4:	701a      	strb	r2, [r3, #0]
 80194d6:	697a      	ldr	r2, [r7, #20]
 80194d8:	1c53      	adds	r3, r2, #1
 80194da:	617b      	str	r3, [r7, #20]
 80194dc:	693b      	ldr	r3, [r7, #16]
 80194de:	1c59      	adds	r1, r3, #1
 80194e0:	6139      	str	r1, [r7, #16]
 80194e2:	7812      	ldrb	r2, [r2, #0]
 80194e4:	701a      	strb	r2, [r3, #0]
 80194e6:	697a      	ldr	r2, [r7, #20]
 80194e8:	1c53      	adds	r3, r2, #1
 80194ea:	617b      	str	r3, [r7, #20]
 80194ec:	693b      	ldr	r3, [r7, #16]
 80194ee:	1c59      	adds	r1, r3, #1
 80194f0:	6139      	str	r1, [r7, #16]
 80194f2:	7812      	ldrb	r2, [r2, #0]
 80194f4:	701a      	strb	r2, [r3, #0]
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 80194f6:	697a      	ldr	r2, [r7, #20]
 80194f8:	1c53      	adds	r3, r2, #1
 80194fa:	617b      	str	r3, [r7, #20]
 80194fc:	693b      	ldr	r3, [r7, #16]
 80194fe:	1c59      	adds	r1, r3, #1
 8019500:	6139      	str	r1, [r7, #16]
 8019502:	7812      	ldrb	r2, [r2, #0]
 8019504:	701a      	strb	r2, [r3, #0]
 8019506:	697a      	ldr	r2, [r7, #20]
 8019508:	1c53      	adds	r3, r2, #1
 801950a:	617b      	str	r3, [r7, #20]
 801950c:	693b      	ldr	r3, [r7, #16]
 801950e:	1c59      	adds	r1, r3, #1
 8019510:	6139      	str	r1, [r7, #16]
 8019512:	7812      	ldrb	r2, [r2, #0]
 8019514:	701a      	strb	r2, [r3, #0]
 8019516:	697a      	ldr	r2, [r7, #20]
 8019518:	1c53      	adds	r3, r2, #1
 801951a:	617b      	str	r3, [r7, #20]
 801951c:	693b      	ldr	r3, [r7, #16]
 801951e:	1c59      	adds	r1, r3, #1
 8019520:	6139      	str	r1, [r7, #16]
 8019522:	7812      	ldrb	r2, [r2, #0]
 8019524:	701a      	strb	r2, [r3, #0]
 8019526:	697a      	ldr	r2, [r7, #20]
 8019528:	1c53      	adds	r3, r2, #1
 801952a:	617b      	str	r3, [r7, #20]
 801952c:	693b      	ldr	r3, [r7, #16]
 801952e:	1c59      	adds	r1, r3, #1
 8019530:	6139      	str	r1, [r7, #16]
 8019532:	7812      	ldrb	r2, [r2, #0]
 8019534:	701a      	strb	r2, [r3, #0]
	}
	if (n&8) {
 8019536:	687b      	ldr	r3, [r7, #4]
 8019538:	f003 0308 	and.w	r3, r3, #8
 801953c:	2b00      	cmp	r3, #0
 801953e:	d03f      	beq.n	80195c0 <memcpy+0x4c4>
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 8019540:	697a      	ldr	r2, [r7, #20]
 8019542:	1c53      	adds	r3, r2, #1
 8019544:	617b      	str	r3, [r7, #20]
 8019546:	693b      	ldr	r3, [r7, #16]
 8019548:	1c59      	adds	r1, r3, #1
 801954a:	6139      	str	r1, [r7, #16]
 801954c:	7812      	ldrb	r2, [r2, #0]
 801954e:	701a      	strb	r2, [r3, #0]
 8019550:	697a      	ldr	r2, [r7, #20]
 8019552:	1c53      	adds	r3, r2, #1
 8019554:	617b      	str	r3, [r7, #20]
 8019556:	693b      	ldr	r3, [r7, #16]
 8019558:	1c59      	adds	r1, r3, #1
 801955a:	6139      	str	r1, [r7, #16]
 801955c:	7812      	ldrb	r2, [r2, #0]
 801955e:	701a      	strb	r2, [r3, #0]
 8019560:	697a      	ldr	r2, [r7, #20]
 8019562:	1c53      	adds	r3, r2, #1
 8019564:	617b      	str	r3, [r7, #20]
 8019566:	693b      	ldr	r3, [r7, #16]
 8019568:	1c59      	adds	r1, r3, #1
 801956a:	6139      	str	r1, [r7, #16]
 801956c:	7812      	ldrb	r2, [r2, #0]
 801956e:	701a      	strb	r2, [r3, #0]
 8019570:	697a      	ldr	r2, [r7, #20]
 8019572:	1c53      	adds	r3, r2, #1
 8019574:	617b      	str	r3, [r7, #20]
 8019576:	693b      	ldr	r3, [r7, #16]
 8019578:	1c59      	adds	r1, r3, #1
 801957a:	6139      	str	r1, [r7, #16]
 801957c:	7812      	ldrb	r2, [r2, #0]
 801957e:	701a      	strb	r2, [r3, #0]
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 8019580:	697a      	ldr	r2, [r7, #20]
 8019582:	1c53      	adds	r3, r2, #1
 8019584:	617b      	str	r3, [r7, #20]
 8019586:	693b      	ldr	r3, [r7, #16]
 8019588:	1c59      	adds	r1, r3, #1
 801958a:	6139      	str	r1, [r7, #16]
 801958c:	7812      	ldrb	r2, [r2, #0]
 801958e:	701a      	strb	r2, [r3, #0]
 8019590:	697a      	ldr	r2, [r7, #20]
 8019592:	1c53      	adds	r3, r2, #1
 8019594:	617b      	str	r3, [r7, #20]
 8019596:	693b      	ldr	r3, [r7, #16]
 8019598:	1c59      	adds	r1, r3, #1
 801959a:	6139      	str	r1, [r7, #16]
 801959c:	7812      	ldrb	r2, [r2, #0]
 801959e:	701a      	strb	r2, [r3, #0]
 80195a0:	697a      	ldr	r2, [r7, #20]
 80195a2:	1c53      	adds	r3, r2, #1
 80195a4:	617b      	str	r3, [r7, #20]
 80195a6:	693b      	ldr	r3, [r7, #16]
 80195a8:	1c59      	adds	r1, r3, #1
 80195aa:	6139      	str	r1, [r7, #16]
 80195ac:	7812      	ldrb	r2, [r2, #0]
 80195ae:	701a      	strb	r2, [r3, #0]
 80195b0:	697a      	ldr	r2, [r7, #20]
 80195b2:	1c53      	adds	r3, r2, #1
 80195b4:	617b      	str	r3, [r7, #20]
 80195b6:	693b      	ldr	r3, [r7, #16]
 80195b8:	1c59      	adds	r1, r3, #1
 80195ba:	6139      	str	r1, [r7, #16]
 80195bc:	7812      	ldrb	r2, [r2, #0]
 80195be:	701a      	strb	r2, [r3, #0]
	}
	if (n&4) {
 80195c0:	687b      	ldr	r3, [r7, #4]
 80195c2:	f003 0304 	and.w	r3, r3, #4
 80195c6:	2b00      	cmp	r3, #0
 80195c8:	d01f      	beq.n	801960a <memcpy+0x50e>
		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
 80195ca:	697a      	ldr	r2, [r7, #20]
 80195cc:	1c53      	adds	r3, r2, #1
 80195ce:	617b      	str	r3, [r7, #20]
 80195d0:	693b      	ldr	r3, [r7, #16]
 80195d2:	1c59      	adds	r1, r3, #1
 80195d4:	6139      	str	r1, [r7, #16]
 80195d6:	7812      	ldrb	r2, [r2, #0]
 80195d8:	701a      	strb	r2, [r3, #0]
 80195da:	697a      	ldr	r2, [r7, #20]
 80195dc:	1c53      	adds	r3, r2, #1
 80195de:	617b      	str	r3, [r7, #20]
 80195e0:	693b      	ldr	r3, [r7, #16]
 80195e2:	1c59      	adds	r1, r3, #1
 80195e4:	6139      	str	r1, [r7, #16]
 80195e6:	7812      	ldrb	r2, [r2, #0]
 80195e8:	701a      	strb	r2, [r3, #0]
 80195ea:	697a      	ldr	r2, [r7, #20]
 80195ec:	1c53      	adds	r3, r2, #1
 80195ee:	617b      	str	r3, [r7, #20]
 80195f0:	693b      	ldr	r3, [r7, #16]
 80195f2:	1c59      	adds	r1, r3, #1
 80195f4:	6139      	str	r1, [r7, #16]
 80195f6:	7812      	ldrb	r2, [r2, #0]
 80195f8:	701a      	strb	r2, [r3, #0]
 80195fa:	697a      	ldr	r2, [r7, #20]
 80195fc:	1c53      	adds	r3, r2, #1
 80195fe:	617b      	str	r3, [r7, #20]
 8019600:	693b      	ldr	r3, [r7, #16]
 8019602:	1c59      	adds	r1, r3, #1
 8019604:	6139      	str	r1, [r7, #16]
 8019606:	7812      	ldrb	r2, [r2, #0]
 8019608:	701a      	strb	r2, [r3, #0]
	}
	if (n&2) {
 801960a:	687b      	ldr	r3, [r7, #4]
 801960c:	f003 0302 	and.w	r3, r3, #2
 8019610:	2b00      	cmp	r3, #0
 8019612:	d00f      	beq.n	8019634 <memcpy+0x538>
		*d++ = *s++; *d++ = *s++;
 8019614:	697a      	ldr	r2, [r7, #20]
 8019616:	1c53      	adds	r3, r2, #1
 8019618:	617b      	str	r3, [r7, #20]
 801961a:	693b      	ldr	r3, [r7, #16]
 801961c:	1c59      	adds	r1, r3, #1
 801961e:	6139      	str	r1, [r7, #16]
 8019620:	7812      	ldrb	r2, [r2, #0]
 8019622:	701a      	strb	r2, [r3, #0]
 8019624:	697a      	ldr	r2, [r7, #20]
 8019626:	1c53      	adds	r3, r2, #1
 8019628:	617b      	str	r3, [r7, #20]
 801962a:	693b      	ldr	r3, [r7, #16]
 801962c:	1c59      	adds	r1, r3, #1
 801962e:	6139      	str	r1, [r7, #16]
 8019630:	7812      	ldrb	r2, [r2, #0]
 8019632:	701a      	strb	r2, [r3, #0]
	}
	if (n&1) {
 8019634:	687b      	ldr	r3, [r7, #4]
 8019636:	f003 0301 	and.w	r3, r3, #1
 801963a:	2b00      	cmp	r3, #0
 801963c:	d003      	beq.n	8019646 <memcpy+0x54a>
		*d = *s;
 801963e:	697b      	ldr	r3, [r7, #20]
 8019640:	781a      	ldrb	r2, [r3, #0]
 8019642:	693b      	ldr	r3, [r7, #16]
 8019644:	701a      	strb	r2, [r3, #0]
	}
	return dest;
 8019646:	68fb      	ldr	r3, [r7, #12]
#endif

	for (; n; n--) *d++ = *s++;
	return dest;
}
 8019648:	4618      	mov	r0, r3
 801964a:	3724      	adds	r7, #36	; 0x24
 801964c:	46bd      	mov	sp, r7
 801964e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019652:	4770      	bx	lr

08019654 <strncmp>:
#include <string.h>

int strncmp(const char *_l, const char *_r, size_t n)
{
 8019654:	b480      	push	{r7}
 8019656:	b087      	sub	sp, #28
 8019658:	af00      	add	r7, sp, #0
 801965a:	60f8      	str	r0, [r7, #12]
 801965c:	60b9      	str	r1, [r7, #8]
 801965e:	607a      	str	r2, [r7, #4]
	const unsigned char *l=(void *)_l, *r=(void *)_r;
 8019660:	68fb      	ldr	r3, [r7, #12]
 8019662:	613b      	str	r3, [r7, #16]
 8019664:	68bb      	ldr	r3, [r7, #8]
 8019666:	617b      	str	r3, [r7, #20]
	if (!n--) return 0;
 8019668:	687b      	ldr	r3, [r7, #4]
 801966a:	1e5a      	subs	r2, r3, #1
 801966c:	607a      	str	r2, [r7, #4]
 801966e:	2b00      	cmp	r3, #0
 8019670:	d10a      	bne.n	8019688 <strncmp+0x34>
 8019672:	2300      	movs	r3, #0
 8019674:	e01f      	b.n	80196b6 <strncmp+0x62>
	for (; *l && *r && n && *l == *r ; l++, r++, n--);
 8019676:	693b      	ldr	r3, [r7, #16]
 8019678:	3301      	adds	r3, #1
 801967a:	613b      	str	r3, [r7, #16]
 801967c:	697b      	ldr	r3, [r7, #20]
 801967e:	3301      	adds	r3, #1
 8019680:	617b      	str	r3, [r7, #20]
 8019682:	687b      	ldr	r3, [r7, #4]
 8019684:	3b01      	subs	r3, #1
 8019686:	607b      	str	r3, [r7, #4]
 8019688:	693b      	ldr	r3, [r7, #16]
 801968a:	781b      	ldrb	r3, [r3, #0]
 801968c:	2b00      	cmp	r3, #0
 801968e:	d00c      	beq.n	80196aa <strncmp+0x56>
 8019690:	697b      	ldr	r3, [r7, #20]
 8019692:	781b      	ldrb	r3, [r3, #0]
 8019694:	2b00      	cmp	r3, #0
 8019696:	d008      	beq.n	80196aa <strncmp+0x56>
 8019698:	687b      	ldr	r3, [r7, #4]
 801969a:	2b00      	cmp	r3, #0
 801969c:	d005      	beq.n	80196aa <strncmp+0x56>
 801969e:	693b      	ldr	r3, [r7, #16]
 80196a0:	781a      	ldrb	r2, [r3, #0]
 80196a2:	697b      	ldr	r3, [r7, #20]
 80196a4:	781b      	ldrb	r3, [r3, #0]
 80196a6:	429a      	cmp	r2, r3
 80196a8:	d0e5      	beq.n	8019676 <strncmp+0x22>
	return *l - *r;
 80196aa:	693b      	ldr	r3, [r7, #16]
 80196ac:	781b      	ldrb	r3, [r3, #0]
 80196ae:	461a      	mov	r2, r3
 80196b0:	697b      	ldr	r3, [r7, #20]
 80196b2:	781b      	ldrb	r3, [r3, #0]
 80196b4:	1ad3      	subs	r3, r2, r3
}
 80196b6:	4618      	mov	r0, r3
 80196b8:	371c      	adds	r7, #28
 80196ba:	46bd      	mov	sp, r7
 80196bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80196c0:	4770      	bx	lr

080196c2 <strrchr>:
#include <string.h>

char *strrchr(const char *s, int c)
{
 80196c2:	b580      	push	{r7, lr}
 80196c4:	b082      	sub	sp, #8
 80196c6:	af00      	add	r7, sp, #0
 80196c8:	6078      	str	r0, [r7, #4]
 80196ca:	6039      	str	r1, [r7, #0]
	return __memrchr(s, c, strlen(s) + 1);
 80196cc:	6878      	ldr	r0, [r7, #4]
 80196ce:	f7f5 ff3e 	bl	800f54e <strlen>
 80196d2:	4603      	mov	r3, r0
 80196d4:	3301      	adds	r3, #1
 80196d6:	461a      	mov	r2, r3
 80196d8:	6839      	ldr	r1, [r7, #0]
 80196da:	6878      	ldr	r0, [r7, #4]
 80196dc:	f004 fba1 	bl	801de22 <__memrchr>
 80196e0:	4603      	mov	r3, r0
}
 80196e2:	4618      	mov	r0, r3
 80196e4:	3708      	adds	r7, #8
 80196e6:	46bd      	mov	sp, r7
 80196e8:	bd80      	pop	{r7, pc}
	...

080196ec <is_leap>:
#ifdef __LITEOS__
#include <ctype.h>
#endif

static int is_leap(int y)
{
 80196ec:	b480      	push	{r7}
 80196ee:	b083      	sub	sp, #12
 80196f0:	af00      	add	r7, sp, #0
 80196f2:	6078      	str	r0, [r7, #4]
	/* Avoid overflow */
	if (y>INT_MAX-1900) y -= 2000;
 80196f4:	687b      	ldr	r3, [r7, #4]
 80196f6:	4a1a      	ldr	r2, [pc, #104]	; (8019760 <is_leap+0x74>)
 80196f8:	4293      	cmp	r3, r2
 80196fa:	dd03      	ble.n	8019704 <is_leap+0x18>
 80196fc:	687b      	ldr	r3, [r7, #4]
 80196fe:	f5a3 63fa 	sub.w	r3, r3, #2000	; 0x7d0
 8019702:	607b      	str	r3, [r7, #4]
	y += 1900;
 8019704:	687b      	ldr	r3, [r7, #4]
 8019706:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 801970a:	607b      	str	r3, [r7, #4]
	return !(y%4) && ((y%100) || !(y%400));
 801970c:	687b      	ldr	r3, [r7, #4]
 801970e:	f003 0303 	and.w	r3, r3, #3
 8019712:	2b00      	cmp	r3, #0
 8019714:	d11c      	bne.n	8019750 <is_leap+0x64>
 8019716:	687a      	ldr	r2, [r7, #4]
 8019718:	4b12      	ldr	r3, [pc, #72]	; (8019764 <is_leap+0x78>)
 801971a:	fb83 1302 	smull	r1, r3, r3, r2
 801971e:	1159      	asrs	r1, r3, #5
 8019720:	17d3      	asrs	r3, r2, #31
 8019722:	1acb      	subs	r3, r1, r3
 8019724:	2164      	movs	r1, #100	; 0x64
 8019726:	fb01 f303 	mul.w	r3, r1, r3
 801972a:	1ad3      	subs	r3, r2, r3
 801972c:	2b00      	cmp	r3, #0
 801972e:	d10d      	bne.n	801974c <is_leap+0x60>
 8019730:	687a      	ldr	r2, [r7, #4]
 8019732:	4b0c      	ldr	r3, [pc, #48]	; (8019764 <is_leap+0x78>)
 8019734:	fb83 1302 	smull	r1, r3, r3, r2
 8019738:	11d9      	asrs	r1, r3, #7
 801973a:	17d3      	asrs	r3, r2, #31
 801973c:	1acb      	subs	r3, r1, r3
 801973e:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8019742:	fb01 f303 	mul.w	r3, r1, r3
 8019746:	1ad3      	subs	r3, r2, r3
 8019748:	2b00      	cmp	r3, #0
 801974a:	d101      	bne.n	8019750 <is_leap+0x64>
 801974c:	2301      	movs	r3, #1
 801974e:	e000      	b.n	8019752 <is_leap+0x66>
 8019750:	2300      	movs	r3, #0
}
 8019752:	4618      	mov	r0, r3
 8019754:	370c      	adds	r7, #12
 8019756:	46bd      	mov	sp, r7
 8019758:	f85d 7b04 	ldr.w	r7, [sp], #4
 801975c:	4770      	bx	lr
 801975e:	bf00      	nop
 8019760:	7ffff893 	.word	0x7ffff893
 8019764:	51eb851f 	.word	0x51eb851f

08019768 <week_num>:

static int week_num(const struct tm *tm)
{
 8019768:	b580      	push	{r7, lr}
 801976a:	b086      	sub	sp, #24
 801976c:	af00      	add	r7, sp, #0
 801976e:	6078      	str	r0, [r7, #4]
	int val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
 8019770:	687b      	ldr	r3, [r7, #4]
 8019772:	69db      	ldr	r3, [r3, #28]
 8019774:	4618      	mov	r0, r3
 8019776:	687b      	ldr	r3, [r7, #4]
 8019778:	699b      	ldr	r3, [r3, #24]
 801977a:	1d99      	adds	r1, r3, #6
 801977c:	4b47      	ldr	r3, [pc, #284]	; (801989c <week_num+0x134>)
 801977e:	fba3 2301 	umull	r2, r3, r3, r1
 8019782:	1aca      	subs	r2, r1, r3
 8019784:	0852      	lsrs	r2, r2, #1
 8019786:	4413      	add	r3, r2
 8019788:	089a      	lsrs	r2, r3, #2
 801978a:	4613      	mov	r3, r2
 801978c:	00db      	lsls	r3, r3, #3
 801978e:	1a9b      	subs	r3, r3, r2
 8019790:	1aca      	subs	r2, r1, r3
 8019792:	1a83      	subs	r3, r0, r2
 8019794:	1dda      	adds	r2, r3, #7
 8019796:	4b41      	ldr	r3, [pc, #260]	; (801989c <week_num+0x134>)
 8019798:	fba3 1302 	umull	r1, r3, r3, r2
 801979c:	1ad2      	subs	r2, r2, r3
 801979e:	0852      	lsrs	r2, r2, #1
 80197a0:	4413      	add	r3, r2
 80197a2:	089b      	lsrs	r3, r3, #2
 80197a4:	60fb      	str	r3, [r7, #12]
	/* If 1 Jan is just 1-3 days past Monday,
	 * the previous week is also in this year. */
	if ((tm->tm_wday + 371U - tm->tm_yday - 2) % 7 <= 2)
 80197a6:	687b      	ldr	r3, [r7, #4]
 80197a8:	699b      	ldr	r3, [r3, #24]
 80197aa:	461a      	mov	r2, r3
 80197ac:	687b      	ldr	r3, [r7, #4]
 80197ae:	69db      	ldr	r3, [r3, #28]
 80197b0:	1ad3      	subs	r3, r2, r3
 80197b2:	f203 1171 	addw	r1, r3, #369	; 0x171
 80197b6:	4b39      	ldr	r3, [pc, #228]	; (801989c <week_num+0x134>)
 80197b8:	fba3 2301 	umull	r2, r3, r3, r1
 80197bc:	1aca      	subs	r2, r1, r3
 80197be:	0852      	lsrs	r2, r2, #1
 80197c0:	4413      	add	r3, r2
 80197c2:	089a      	lsrs	r2, r3, #2
 80197c4:	4613      	mov	r3, r2
 80197c6:	00db      	lsls	r3, r3, #3
 80197c8:	1a9b      	subs	r3, r3, r2
 80197ca:	1aca      	subs	r2, r1, r3
 80197cc:	2a02      	cmp	r2, #2
 80197ce:	d802      	bhi.n	80197d6 <week_num+0x6e>
		val++;
 80197d0:	68fb      	ldr	r3, [r7, #12]
 80197d2:	3301      	adds	r3, #1
 80197d4:	60fb      	str	r3, [r7, #12]
	if (!val) {
 80197d6:	68fb      	ldr	r3, [r7, #12]
 80197d8:	2b00      	cmp	r3, #0
 80197da:	d132      	bne.n	8019842 <week_num+0xda>
		val = 52;
 80197dc:	2334      	movs	r3, #52	; 0x34
 80197de:	60fb      	str	r3, [r7, #12]
		/* If 31 December of prev year a Thursday,
		 * or Friday of a leap year, then the
		 * prev year has 53 weeks. */
		int dec31 = (tm->tm_wday + 7U - tm->tm_yday - 1) % 7;
 80197e0:	687b      	ldr	r3, [r7, #4]
 80197e2:	699b      	ldr	r3, [r3, #24]
 80197e4:	461a      	mov	r2, r3
 80197e6:	687b      	ldr	r3, [r7, #4]
 80197e8:	69db      	ldr	r3, [r3, #28]
 80197ea:	1ad3      	subs	r3, r2, r3
 80197ec:	1d99      	adds	r1, r3, #6
 80197ee:	4b2b      	ldr	r3, [pc, #172]	; (801989c <week_num+0x134>)
 80197f0:	fba3 2301 	umull	r2, r3, r3, r1
 80197f4:	1aca      	subs	r2, r1, r3
 80197f6:	0852      	lsrs	r2, r2, #1
 80197f8:	4413      	add	r3, r2
 80197fa:	089a      	lsrs	r2, r3, #2
 80197fc:	4613      	mov	r3, r2
 80197fe:	00db      	lsls	r3, r3, #3
 8019800:	1a9b      	subs	r3, r3, r2
 8019802:	1aca      	subs	r2, r1, r3
 8019804:	617a      	str	r2, [r7, #20]
		if (dec31 == 4 || (dec31 == 5 && is_leap(tm->tm_year%400-1)))
 8019806:	697b      	ldr	r3, [r7, #20]
 8019808:	2b04      	cmp	r3, #4
 801980a:	d016      	beq.n	801983a <week_num+0xd2>
 801980c:	697b      	ldr	r3, [r7, #20]
 801980e:	2b05      	cmp	r3, #5
 8019810:	d13e      	bne.n	8019890 <week_num+0x128>
 8019812:	687b      	ldr	r3, [r7, #4]
 8019814:	695a      	ldr	r2, [r3, #20]
 8019816:	4b22      	ldr	r3, [pc, #136]	; (80198a0 <week_num+0x138>)
 8019818:	fb83 1302 	smull	r1, r3, r3, r2
 801981c:	11d9      	asrs	r1, r3, #7
 801981e:	17d3      	asrs	r3, r2, #31
 8019820:	1acb      	subs	r3, r1, r3
 8019822:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8019826:	fb01 f303 	mul.w	r3, r1, r3
 801982a:	1ad3      	subs	r3, r2, r3
 801982c:	3b01      	subs	r3, #1
 801982e:	4618      	mov	r0, r3
 8019830:	f7ff ff5c 	bl	80196ec <is_leap>
 8019834:	4603      	mov	r3, r0
 8019836:	2b00      	cmp	r3, #0
 8019838:	d02a      	beq.n	8019890 <week_num+0x128>
			val++;
 801983a:	68fb      	ldr	r3, [r7, #12]
 801983c:	3301      	adds	r3, #1
 801983e:	60fb      	str	r3, [r7, #12]
 8019840:	e026      	b.n	8019890 <week_num+0x128>
	} else if (val == 53) {
 8019842:	68fb      	ldr	r3, [r7, #12]
 8019844:	2b35      	cmp	r3, #53	; 0x35
 8019846:	d123      	bne.n	8019890 <week_num+0x128>
		/* If 1 January is not a Thursday, and not
		 * a Wednesday of a leap year, then this
		 * year has only 52 weeks. */
		int jan1 = (tm->tm_wday + 371U - tm->tm_yday) % 7;
 8019848:	687b      	ldr	r3, [r7, #4]
 801984a:	699b      	ldr	r3, [r3, #24]
 801984c:	461a      	mov	r2, r3
 801984e:	687b      	ldr	r3, [r7, #4]
 8019850:	69db      	ldr	r3, [r3, #28]
 8019852:	1ad3      	subs	r3, r2, r3
 8019854:	f203 1173 	addw	r1, r3, #371	; 0x173
 8019858:	4b10      	ldr	r3, [pc, #64]	; (801989c <week_num+0x134>)
 801985a:	fba3 2301 	umull	r2, r3, r3, r1
 801985e:	1aca      	subs	r2, r1, r3
 8019860:	0852      	lsrs	r2, r2, #1
 8019862:	4413      	add	r3, r2
 8019864:	089a      	lsrs	r2, r3, #2
 8019866:	4613      	mov	r3, r2
 8019868:	00db      	lsls	r3, r3, #3
 801986a:	1a9b      	subs	r3, r3, r2
 801986c:	1aca      	subs	r2, r1, r3
 801986e:	613a      	str	r2, [r7, #16]
		if (jan1 != 4 && (jan1 != 3 || !is_leap(tm->tm_year)))
 8019870:	693b      	ldr	r3, [r7, #16]
 8019872:	2b04      	cmp	r3, #4
 8019874:	d00c      	beq.n	8019890 <week_num+0x128>
 8019876:	693b      	ldr	r3, [r7, #16]
 8019878:	2b03      	cmp	r3, #3
 801987a:	d107      	bne.n	801988c <week_num+0x124>
 801987c:	687b      	ldr	r3, [r7, #4]
 801987e:	695b      	ldr	r3, [r3, #20]
 8019880:	4618      	mov	r0, r3
 8019882:	f7ff ff33 	bl	80196ec <is_leap>
 8019886:	4603      	mov	r3, r0
 8019888:	2b00      	cmp	r3, #0
 801988a:	d101      	bne.n	8019890 <week_num+0x128>
			val = 1;
 801988c:	2301      	movs	r3, #1
 801988e:	60fb      	str	r3, [r7, #12]
	}
	return val;
 8019890:	68fb      	ldr	r3, [r7, #12]
}
 8019892:	4618      	mov	r0, r3
 8019894:	3718      	adds	r7, #24
 8019896:	46bd      	mov	sp, r7
 8019898:	bd80      	pop	{r7, pc}
 801989a:	bf00      	nop
 801989c:	24924925 	.word	0x24924925
 80198a0:	51eb851f 	.word	0x51eb851f

080198a4 <__strftime_fmt_1>:

const char *__strftime_fmt_1(char (*s)[100], size_t *l, int f, const struct tm *tm, locale_t loc, int pad)
{
 80198a4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80198a8:	b096      	sub	sp, #88	; 0x58
 80198aa:	af02      	add	r7, sp, #8
 80198ac:	6378      	str	r0, [r7, #52]	; 0x34
 80198ae:	6339      	str	r1, [r7, #48]	; 0x30
 80198b0:	62fa      	str	r2, [r7, #44]	; 0x2c
 80198b2:	62bb      	str	r3, [r7, #40]	; 0x28
	nl_item item;
	long long val;
	const char *fmt = "-";
 80198b4:	4bca      	ldr	r3, [pc, #808]	; (8019be0 <__strftime_fmt_1+0x33c>)
 80198b6:	63fb      	str	r3, [r7, #60]	; 0x3c
	int width = 2, def_pad = '0';
 80198b8:	2302      	movs	r3, #2
 80198ba:	643b      	str	r3, [r7, #64]	; 0x40
 80198bc:	2330      	movs	r3, #48	; 0x30
 80198be:	647b      	str	r3, [r7, #68]	; 0x44
 80198c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80198c2:	3b25      	subs	r3, #37	; 0x25
 80198c4:	2b54      	cmp	r3, #84	; 0x54
 80198c6:	f200 829f 	bhi.w	8019e08 <__strftime_fmt_1+0x564>
 80198ca:	a201      	add	r2, pc, #4	; (adr r2, 80198d0 <__strftime_fmt_1+0x2c>)
 80198cc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80198d0:	08019dff 	.word	0x08019dff
 80198d4:	08019e09 	.word	0x08019e09
 80198d8:	08019e09 	.word	0x08019e09
 80198dc:	08019e09 	.word	0x08019e09
 80198e0:	08019e09 	.word	0x08019e09
 80198e4:	08019e09 	.word	0x08019e09
 80198e8:	08019e09 	.word	0x08019e09
 80198ec:	08019e09 	.word	0x08019e09
 80198f0:	08019e09 	.word	0x08019e09
 80198f4:	08019e09 	.word	0x08019e09
 80198f8:	08019e09 	.word	0x08019e09
 80198fc:	08019e09 	.word	0x08019e09
 8019900:	08019e09 	.word	0x08019e09
 8019904:	08019e09 	.word	0x08019e09
 8019908:	08019e09 	.word	0x08019e09
 801990c:	08019e09 	.word	0x08019e09
 8019910:	08019e09 	.word	0x08019e09
 8019914:	08019e09 	.word	0x08019e09
 8019918:	08019e09 	.word	0x08019e09
 801991c:	08019e09 	.word	0x08019e09
 8019920:	08019e09 	.word	0x08019e09
 8019924:	08019e09 	.word	0x08019e09
 8019928:	08019e09 	.word	0x08019e09
 801992c:	08019e09 	.word	0x08019e09
 8019930:	08019e09 	.word	0x08019e09
 8019934:	08019e09 	.word	0x08019e09
 8019938:	08019e09 	.word	0x08019e09
 801993c:	08019e09 	.word	0x08019e09
 8019940:	08019a3b 	.word	0x08019a3b
 8019944:	08019a67 	.word	0x08019a67
 8019948:	08019a83 	.word	0x08019a83
 801994c:	08019acb 	.word	0x08019acb
 8019950:	08019e09 	.word	0x08019e09
 8019954:	08019ad1 	.word	0x08019ad1
 8019958:	08019ad7 	.word	0x08019ad7
 801995c:	08019b75 	.word	0x08019b75
 8019960:	08019b91 	.word	0x08019b91
 8019964:	08019e09 	.word	0x08019e09
 8019968:	08019e09 	.word	0x08019e09
 801996c:	08019e09 	.word	0x08019e09
 8019970:	08019c25 	.word	0x08019c25
 8019974:	08019e09 	.word	0x08019e09
 8019978:	08019e09 	.word	0x08019e09
 801997c:	08019c3f 	.word	0x08019c3f
 8019980:	08019e09 	.word	0x08019e09
 8019984:	08019c57 	.word	0x08019c57
 8019988:	08019c7f 	.word	0x08019c7f
 801998c:	08019c99 	.word	0x08019c99
 8019990:	08019cc5 	.word	0x08019cc5
 8019994:	08019d2d 	.word	0x08019d2d
 8019998:	08019ced 	.word	0x08019ced
 801999c:	08019d5b 	.word	0x08019d5b
 80199a0:	08019dab 	.word	0x08019dab
 80199a4:	08019e09 	.word	0x08019e09
 80199a8:	08019e09 	.word	0x08019e09
 80199ac:	08019e09 	.word	0x08019e09
 80199b0:	08019e09 	.word	0x08019e09
 80199b4:	08019e09 	.word	0x08019e09
 80199b8:	08019e09 	.word	0x08019e09
 80199bc:	08019e09 	.word	0x08019e09
 80199c0:	08019a25 	.word	0x08019a25
 80199c4:	08019a51 	.word	0x08019a51
 80199c8:	08019a7d 	.word	0x08019a7d
 80199cc:	08019abb 	.word	0x08019abb
 80199d0:	08019ab7 	.word	0x08019ab7
 80199d4:	08019e09 	.word	0x08019e09
 80199d8:	08019ad7 	.word	0x08019ad7
 80199dc:	08019a51 	.word	0x08019a51
 80199e0:	08019e09 	.word	0x08019e09
 80199e4:	08019bfd 	.word	0x08019bfd
 80199e8:	08019b75 	.word	0x08019b75
 80199ec:	08019b91 	.word	0x08019b91
 80199f0:	08019c13 	.word	0x08019c13
 80199f4:	08019c35 	.word	0x08019c35
 80199f8:	08019e09 	.word	0x08019e09
 80199fc:	08019c3f 	.word	0x08019c3f
 8019a00:	08019e09 	.word	0x08019e09
 8019a04:	08019c51 	.word	0x08019c51
 8019a08:	08019c5d 	.word	0x08019c5d
 8019a0c:	08019c8f 	.word	0x08019c8f
 8019a10:	08019c9f 	.word	0x08019c9f
 8019a14:	08019e09 	.word	0x08019e09
 8019a18:	08019d41 	.word	0x08019d41
 8019a1c:	08019d55 	.word	0x08019d55
 8019a20:	08019d61 	.word	0x08019d61

	switch (f) {
	case 'a':
		if (tm->tm_wday > 6U) goto string;
 8019a24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a26:	699b      	ldr	r3, [r3, #24]
 8019a28:	2b06      	cmp	r3, #6
 8019a2a:	f200 8233 	bhi.w	8019e94 <__strftime_fmt_1+0x5f0>
		item = ABDAY_1 + tm->tm_wday;
 8019a2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a30:	699b      	ldr	r3, [r3, #24]
 8019a32:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 8019a36:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strcat;
 8019a38:	e226      	b.n	8019e88 <__strftime_fmt_1+0x5e4>
	case 'A':
		if (tm->tm_wday > 6U) goto string;
 8019a3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a3c:	699b      	ldr	r3, [r3, #24]
 8019a3e:	2b06      	cmp	r3, #6
 8019a40:	f200 822a 	bhi.w	8019e98 <__strftime_fmt_1+0x5f4>
		item = DAY_1 + tm->tm_wday;
 8019a44:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a46:	699a      	ldr	r2, [r3, #24]
 8019a48:	4b66      	ldr	r3, [pc, #408]	; (8019be4 <__strftime_fmt_1+0x340>)
 8019a4a:	4413      	add	r3, r2
 8019a4c:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strcat;
 8019a4e:	e21b      	b.n	8019e88 <__strftime_fmt_1+0x5e4>
	case 'h':
	case 'b':
		if (tm->tm_mon > 11U) goto string;
 8019a50:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a52:	691b      	ldr	r3, [r3, #16]
 8019a54:	2b0b      	cmp	r3, #11
 8019a56:	f200 8221 	bhi.w	8019e9c <__strftime_fmt_1+0x5f8>
		item = ABMON_1 + tm->tm_mon;
 8019a5a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a5c:	691a      	ldr	r2, [r3, #16]
 8019a5e:	4b62      	ldr	r3, [pc, #392]	; (8019be8 <__strftime_fmt_1+0x344>)
 8019a60:	4413      	add	r3, r2
 8019a62:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strcat;
 8019a64:	e210      	b.n	8019e88 <__strftime_fmt_1+0x5e4>
	case 'B':
		if (tm->tm_mon > 11U) goto string;
 8019a66:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a68:	691b      	ldr	r3, [r3, #16]
 8019a6a:	2b0b      	cmp	r3, #11
 8019a6c:	f200 8218 	bhi.w	8019ea0 <__strftime_fmt_1+0x5fc>
		item = MON_1 + tm->tm_mon;
 8019a70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a72:	691a      	ldr	r2, [r3, #16]
 8019a74:	4b5d      	ldr	r3, [pc, #372]	; (8019bec <__strftime_fmt_1+0x348>)
 8019a76:	4413      	add	r3, r2
 8019a78:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strcat;
 8019a7a:	e205      	b.n	8019e88 <__strftime_fmt_1+0x5e4>
	case 'c':
		item = D_T_FMT;
 8019a7c:	4b5c      	ldr	r3, [pc, #368]	; (8019bf0 <__strftime_fmt_1+0x34c>)
 8019a7e:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strftime;
 8019a80:	e254      	b.n	8019f2c <__strftime_fmt_1+0x688>
	case 'C':
		val = (1900LL+tm->tm_year) / 100;
 8019a82:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019a84:	695b      	ldr	r3, [r3, #20]
 8019a86:	461a      	mov	r2, r3
 8019a88:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019a8c:	f240 706c 	movw	r0, #1900	; 0x76c
 8019a90:	f04f 0100 	mov.w	r1, #0
 8019a94:	1814      	adds	r4, r2, r0
 8019a96:	623c      	str	r4, [r7, #32]
 8019a98:	414b      	adcs	r3, r1
 8019a9a:	627b      	str	r3, [r7, #36]	; 0x24
 8019a9c:	f04f 0264 	mov.w	r2, #100	; 0x64
 8019aa0:	f04f 0300 	mov.w	r3, #0
 8019aa4:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8019aa8:	f7e7 fb10 	bl	80010cc <__aeabi_ldivmod>
 8019aac:	4602      	mov	r2, r0
 8019aae:	460b      	mov	r3, r1
 8019ab0:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019ab4:	e1af      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'e':
		def_pad = '_';
 8019ab6:	235f      	movs	r3, #95	; 0x5f
 8019ab8:	647b      	str	r3, [r7, #68]	; 0x44
	case 'd':
		val = tm->tm_mday;
 8019aba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019abc:	68db      	ldr	r3, [r3, #12]
 8019abe:	461a      	mov	r2, r3
 8019ac0:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019ac4:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019ac8:	e1a5      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'D':
		fmt = "%m/%d/%y";
 8019aca:	4b4a      	ldr	r3, [pc, #296]	; (8019bf4 <__strftime_fmt_1+0x350>)
 8019acc:	63fb      	str	r3, [r7, #60]	; 0x3c
		goto recu_strftime;
 8019ace:	e232      	b.n	8019f36 <__strftime_fmt_1+0x692>
	case 'F':
		fmt = "%Y-%m-%d";
 8019ad0:	4b49      	ldr	r3, [pc, #292]	; (8019bf8 <__strftime_fmt_1+0x354>)
 8019ad2:	63fb      	str	r3, [r7, #60]	; 0x3c
		goto recu_strftime;
 8019ad4:	e22f      	b.n	8019f36 <__strftime_fmt_1+0x692>
	case 'g':
	case 'G':
		val = tm->tm_year + 1900LL;
 8019ad6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019ad8:	695b      	ldr	r3, [r3, #20]
 8019ada:	461a      	mov	r2, r3
 8019adc:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019ae0:	f240 706c 	movw	r0, #1900	; 0x76c
 8019ae4:	f04f 0100 	mov.w	r1, #0
 8019ae8:	1814      	adds	r4, r2, r0
 8019aea:	613c      	str	r4, [r7, #16]
 8019aec:	414b      	adcs	r3, r1
 8019aee:	617b      	str	r3, [r7, #20]
 8019af0:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 8019af4:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
		if (tm->tm_yday < 3 && week_num(tm) != 1) val--;
 8019af8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019afa:	69db      	ldr	r3, [r3, #28]
 8019afc:	2b02      	cmp	r3, #2
 8019afe:	dc12      	bgt.n	8019b26 <__strftime_fmt_1+0x282>
 8019b00:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8019b02:	f7ff fe31 	bl	8019768 <week_num>
 8019b06:	4603      	mov	r3, r0
 8019b08:	2b01      	cmp	r3, #1
 8019b0a:	d00c      	beq.n	8019b26 <__strftime_fmt_1+0x282>
 8019b0c:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019b10:	f112 31ff 	adds.w	r1, r2, #4294967295
 8019b14:	60b9      	str	r1, [r7, #8]
 8019b16:	f143 33ff 	adc.w	r3, r3, #4294967295
 8019b1a:	60fb      	str	r3, [r7, #12]
 8019b1c:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8019b20:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
 8019b24:	e015      	b.n	8019b52 <__strftime_fmt_1+0x2ae>
		else if (tm->tm_yday > 360 && week_num(tm) == 1) val++;
 8019b26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019b28:	69db      	ldr	r3, [r3, #28]
 8019b2a:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
 8019b2e:	dd10      	ble.n	8019b52 <__strftime_fmt_1+0x2ae>
 8019b30:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8019b32:	f7ff fe19 	bl	8019768 <week_num>
 8019b36:	4603      	mov	r3, r0
 8019b38:	2b01      	cmp	r3, #1
 8019b3a:	d10a      	bne.n	8019b52 <__strftime_fmt_1+0x2ae>
 8019b3c:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019b40:	1c51      	adds	r1, r2, #1
 8019b42:	6039      	str	r1, [r7, #0]
 8019b44:	f143 0300 	adc.w	r3, r3, #0
 8019b48:	607b      	str	r3, [r7, #4]
 8019b4a:	e9d7 3400 	ldrd	r3, r4, [r7]
 8019b4e:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
		if (f=='g') val %= 100;
 8019b52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019b54:	2b67      	cmp	r3, #103	; 0x67
 8019b56:	d10a      	bne.n	8019b6e <__strftime_fmt_1+0x2ca>
 8019b58:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
 8019b5c:	f04f 0264 	mov.w	r2, #100	; 0x64
 8019b60:	f04f 0300 	mov.w	r3, #0
 8019b64:	f7e7 fab2 	bl	80010cc <__aeabi_ldivmod>
 8019b68:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		else width = 4;
		goto number;
 8019b6c:	e153      	b.n	8019e16 <__strftime_fmt_1+0x572>
		else width = 4;
 8019b6e:	2304      	movs	r3, #4
 8019b70:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019b72:	e150      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'k':
	case 'H':
		val = tm->tm_hour;
 8019b74:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019b76:	689b      	ldr	r3, [r3, #8]
 8019b78:	461a      	mov	r2, r3
 8019b7a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019b7e:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		if (f=='k') pad = '_';
 8019b82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019b84:	2b6b      	cmp	r3, #107	; 0x6b
 8019b86:	f040 8141 	bne.w	8019e0c <__strftime_fmt_1+0x568>
 8019b8a:	235f      	movs	r3, #95	; 0x5f
 8019b8c:	677b      	str	r3, [r7, #116]	; 0x74
		goto number;
 8019b8e:	e13d      	b.n	8019e0c <__strftime_fmt_1+0x568>
	case 'l':
	case 'I':
		val = tm->tm_hour;
 8019b90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019b92:	689b      	ldr	r3, [r3, #8]
 8019b94:	461a      	mov	r2, r3
 8019b96:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019b9a:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		if (!val) val = 12;
 8019b9e:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019ba2:	4313      	orrs	r3, r2
 8019ba4:	d106      	bne.n	8019bb4 <__strftime_fmt_1+0x310>
 8019ba6:	f04f 020c 	mov.w	r2, #12
 8019baa:	f04f 0300 	mov.w	r3, #0
 8019bae:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
 8019bb2:	e00d      	b.n	8019bd0 <__strftime_fmt_1+0x32c>
		else if (val > 12) val -= 12;
 8019bb4:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019bb8:	2a0d      	cmp	r2, #13
 8019bba:	f173 0300 	sbcs.w	r3, r3, #0
 8019bbe:	db07      	blt.n	8019bd0 <__strftime_fmt_1+0x32c>
 8019bc0:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019bc4:	f1b2 0a0c 	subs.w	sl, r2, #12
 8019bc8:	f143 3bff 	adc.w	fp, r3, #4294967295
 8019bcc:	e9c7 ab12 	strd	sl, fp, [r7, #72]	; 0x48
		if (f=='l') pad = '_';
 8019bd0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019bd2:	2b6c      	cmp	r3, #108	; 0x6c
 8019bd4:	f040 811c 	bne.w	8019e10 <__strftime_fmt_1+0x56c>
 8019bd8:	235f      	movs	r3, #95	; 0x5f
 8019bda:	677b      	str	r3, [r7, #116]	; 0x74
		goto number;
 8019bdc:	e118      	b.n	8019e10 <__strftime_fmt_1+0x56c>
 8019bde:	bf00      	nop
 8019be0:	080230cc 	.word	0x080230cc
 8019be4:	00020007 	.word	0x00020007
 8019be8:	0002000e 	.word	0x0002000e
 8019bec:	0002001a 	.word	0x0002001a
 8019bf0:	00020028 	.word	0x00020028
 8019bf4:	080230d0 	.word	0x080230d0
 8019bf8:	080230dc 	.word	0x080230dc
	case 'j':
		val = tm->tm_yday+1;
 8019bfc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019bfe:	69db      	ldr	r3, [r3, #28]
 8019c00:	3301      	adds	r3, #1
 8019c02:	461a      	mov	r2, r3
 8019c04:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019c08:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		width = 3;
 8019c0c:	2303      	movs	r3, #3
 8019c0e:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019c10:	e101      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'm':
		val = tm->tm_mon+1;
 8019c12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019c14:	691b      	ldr	r3, [r3, #16]
 8019c16:	3301      	adds	r3, #1
 8019c18:	461a      	mov	r2, r3
 8019c1a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019c1e:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019c22:	e0f8      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'M':
		val = tm->tm_min;
 8019c24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019c26:	685b      	ldr	r3, [r3, #4]
 8019c28:	461a      	mov	r2, r3
 8019c2a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019c2e:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019c32:	e0f0      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'n':
		*l = 1;
 8019c34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019c36:	2201      	movs	r2, #1
 8019c38:	601a      	str	r2, [r3, #0]
		return "\n";
 8019c3a:	4ba9      	ldr	r3, [pc, #676]	; (8019ee0 <__strftime_fmt_1+0x63c>)
 8019c3c:	e18d      	b.n	8019f5a <__strftime_fmt_1+0x6b6>
	case 'P':
	case 'p':
		item = tm->tm_hour >= 12 ? PM_STR : AM_STR;
 8019c3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019c40:	689b      	ldr	r3, [r3, #8]
 8019c42:	2b0b      	cmp	r3, #11
 8019c44:	dd01      	ble.n	8019c4a <__strftime_fmt_1+0x3a6>
 8019c46:	4ba7      	ldr	r3, [pc, #668]	; (8019ee4 <__strftime_fmt_1+0x640>)
 8019c48:	e000      	b.n	8019c4c <__strftime_fmt_1+0x3a8>
 8019c4a:	4ba7      	ldr	r3, [pc, #668]	; (8019ee8 <__strftime_fmt_1+0x644>)
 8019c4c:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strcat;
 8019c4e:	e11b      	b.n	8019e88 <__strftime_fmt_1+0x5e4>
	case 'r':
		item = T_FMT_AMPM;
 8019c50:	4ba6      	ldr	r3, [pc, #664]	; (8019eec <__strftime_fmt_1+0x648>)
 8019c52:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strftime;
 8019c54:	e16a      	b.n	8019f2c <__strftime_fmt_1+0x688>
	case 'R':
		fmt = "%H:%M";
 8019c56:	4ba6      	ldr	r3, [pc, #664]	; (8019ef0 <__strftime_fmt_1+0x64c>)
 8019c58:	63fb      	str	r3, [r7, #60]	; 0x3c
		goto recu_strftime;
 8019c5a:	e16c      	b.n	8019f36 <__strftime_fmt_1+0x692>
	case 's':
		val = __tm_to_secs(tm) - tm->__tm_gmtoff;
 8019c5c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8019c5e:	f004 fb21 	bl	801e2a4 <__tm_to_secs>
 8019c62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019c64:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8019c66:	461a      	mov	r2, r3
 8019c68:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019c6c:	ebb0 0802 	subs.w	r8, r0, r2
 8019c70:	eb61 0903 	sbc.w	r9, r1, r3
 8019c74:	e9c7 8912 	strd	r8, r9, [r7, #72]	; 0x48
		width = 1;
 8019c78:	2301      	movs	r3, #1
 8019c7a:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019c7c:	e0cb      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'S':
		val = tm->tm_sec;
 8019c7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019c80:	681b      	ldr	r3, [r3, #0]
 8019c82:	461a      	mov	r2, r3
 8019c84:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019c88:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019c8c:	e0c3      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 't':
		*l = 1;
 8019c8e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019c90:	2201      	movs	r2, #1
 8019c92:	601a      	str	r2, [r3, #0]
		return "\t";
 8019c94:	4b97      	ldr	r3, [pc, #604]	; (8019ef4 <__strftime_fmt_1+0x650>)
 8019c96:	e160      	b.n	8019f5a <__strftime_fmt_1+0x6b6>
	case 'T':
		fmt = "%H:%M:%S";
 8019c98:	4b97      	ldr	r3, [pc, #604]	; (8019ef8 <__strftime_fmt_1+0x654>)
 8019c9a:	63fb      	str	r3, [r7, #60]	; 0x3c
		goto recu_strftime;
 8019c9c:	e14b      	b.n	8019f36 <__strftime_fmt_1+0x692>
	case 'u':
		val = tm->tm_wday ? tm->tm_wday : 7;
 8019c9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019ca0:	699b      	ldr	r3, [r3, #24]
 8019ca2:	2b00      	cmp	r3, #0
 8019ca4:	d005      	beq.n	8019cb2 <__strftime_fmt_1+0x40e>
 8019ca6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019ca8:	699b      	ldr	r3, [r3, #24]
 8019caa:	461a      	mov	r2, r3
 8019cac:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019cb0:	e003      	b.n	8019cba <__strftime_fmt_1+0x416>
 8019cb2:	f04f 0207 	mov.w	r2, #7
 8019cb6:	f04f 0300 	mov.w	r3, #0
 8019cba:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		width = 1;
 8019cbe:	2301      	movs	r3, #1
 8019cc0:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019cc2:	e0a8      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'U':
		val = (tm->tm_yday + 7U - tm->tm_wday) / 7;
 8019cc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019cc6:	69db      	ldr	r3, [r3, #28]
 8019cc8:	461a      	mov	r2, r3
 8019cca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019ccc:	699b      	ldr	r3, [r3, #24]
 8019cce:	1ad3      	subs	r3, r2, r3
 8019cd0:	1dda      	adds	r2, r3, #7
 8019cd2:	4b8a      	ldr	r3, [pc, #552]	; (8019efc <__strftime_fmt_1+0x658>)
 8019cd4:	fba3 1302 	umull	r1, r3, r3, r2
 8019cd8:	1ad2      	subs	r2, r2, r3
 8019cda:	0852      	lsrs	r2, r2, #1
 8019cdc:	4413      	add	r3, r2
 8019cde:	089b      	lsrs	r3, r3, #2
 8019ce0:	461a      	mov	r2, r3
 8019ce2:	f04f 0300 	mov.w	r3, #0
 8019ce6:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019cea:	e094      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'W':
		val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
 8019cec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019cee:	69db      	ldr	r3, [r3, #28]
 8019cf0:	4618      	mov	r0, r3
 8019cf2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019cf4:	699b      	ldr	r3, [r3, #24]
 8019cf6:	1d99      	adds	r1, r3, #6
 8019cf8:	4b80      	ldr	r3, [pc, #512]	; (8019efc <__strftime_fmt_1+0x658>)
 8019cfa:	fba3 2301 	umull	r2, r3, r3, r1
 8019cfe:	1aca      	subs	r2, r1, r3
 8019d00:	0852      	lsrs	r2, r2, #1
 8019d02:	4413      	add	r3, r2
 8019d04:	089a      	lsrs	r2, r3, #2
 8019d06:	4613      	mov	r3, r2
 8019d08:	00db      	lsls	r3, r3, #3
 8019d0a:	1a9b      	subs	r3, r3, r2
 8019d0c:	1aca      	subs	r2, r1, r3
 8019d0e:	1a83      	subs	r3, r0, r2
 8019d10:	1dda      	adds	r2, r3, #7
 8019d12:	4b7a      	ldr	r3, [pc, #488]	; (8019efc <__strftime_fmt_1+0x658>)
 8019d14:	fba3 1302 	umull	r1, r3, r3, r2
 8019d18:	1ad2      	subs	r2, r2, r3
 8019d1a:	0852      	lsrs	r2, r2, #1
 8019d1c:	4413      	add	r3, r2
 8019d1e:	089b      	lsrs	r3, r3, #2
 8019d20:	461a      	mov	r2, r3
 8019d22:	f04f 0300 	mov.w	r3, #0
 8019d26:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019d2a:	e074      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'V':
		val = week_num(tm);
 8019d2c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8019d2e:	f7ff fd1b 	bl	8019768 <week_num>
 8019d32:	4603      	mov	r3, r0
 8019d34:	461a      	mov	r2, r3
 8019d36:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019d3a:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019d3e:	e06a      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'w':
		val = tm->tm_wday;
 8019d40:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019d42:	699b      	ldr	r3, [r3, #24]
 8019d44:	461a      	mov	r2, r3
 8019d46:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019d4a:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		width = 1;
 8019d4e:	2301      	movs	r3, #1
 8019d50:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019d52:	e060      	b.n	8019e16 <__strftime_fmt_1+0x572>
	case 'x':
		item = D_FMT;
 8019d54:	4b6a      	ldr	r3, [pc, #424]	; (8019f00 <__strftime_fmt_1+0x65c>)
 8019d56:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strftime;
 8019d58:	e0e8      	b.n	8019f2c <__strftime_fmt_1+0x688>
	case 'X':
		item = T_FMT;
 8019d5a:	4b6a      	ldr	r3, [pc, #424]	; (8019f04 <__strftime_fmt_1+0x660>)
 8019d5c:	63bb      	str	r3, [r7, #56]	; 0x38
		goto nl_strftime;
 8019d5e:	e0e5      	b.n	8019f2c <__strftime_fmt_1+0x688>
	case 'y':
		val = (tm->tm_year + 1900LL) % 100;
 8019d60:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019d62:	695b      	ldr	r3, [r3, #20]
 8019d64:	461a      	mov	r2, r3
 8019d66:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019d6a:	f240 706c 	movw	r0, #1900	; 0x76c
 8019d6e:	f04f 0100 	mov.w	r1, #0
 8019d72:	1814      	adds	r4, r2, r0
 8019d74:	61bc      	str	r4, [r7, #24]
 8019d76:	414b      	adcs	r3, r1
 8019d78:	61fb      	str	r3, [r7, #28]
 8019d7a:	f04f 0264 	mov.w	r2, #100	; 0x64
 8019d7e:	f04f 0300 	mov.w	r3, #0
 8019d82:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8019d86:	f7e7 f9a1 	bl	80010cc <__aeabi_ldivmod>
 8019d8a:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		if (val < 0) val = -val;
 8019d8e:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019d92:	2a00      	cmp	r2, #0
 8019d94:	f173 0300 	sbcs.w	r3, r3, #0
 8019d98:	da3c      	bge.n	8019e14 <__strftime_fmt_1+0x570>
 8019d9a:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019d9e:	4252      	negs	r2, r2
 8019da0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8019da4:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
		goto number;
 8019da8:	e034      	b.n	8019e14 <__strftime_fmt_1+0x570>
	case 'Y':
		val = tm->tm_year + 1900LL;
 8019daa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019dac:	695b      	ldr	r3, [r3, #20]
 8019dae:	461a      	mov	r2, r3
 8019db0:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8019db4:	f240 706c 	movw	r0, #1900	; 0x76c
 8019db8:	f04f 0100 	mov.w	r1, #0
 8019dbc:	1814      	adds	r4, r2, r0
 8019dbe:	eb43 0501 	adc.w	r5, r3, r1
 8019dc2:	e9c7 4512 	strd	r4, r5, [r7, #72]	; 0x48
		if (val >= 10000) {
 8019dc6:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019dca:	f242 700f 	movw	r0, #9999	; 0x270f
 8019dce:	f04f 0100 	mov.w	r1, #0
 8019dd2:	4290      	cmp	r0, r2
 8019dd4:	eb71 0303 	sbcs.w	r3, r1, r3
 8019dd8:	da0e      	bge.n	8019df8 <__strftime_fmt_1+0x554>
			*l = snprintf(*s, sizeof *s, "+%lld", val);
 8019dda:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019dde:	e9cd 2300 	strd	r2, r3, [sp]
 8019de2:	4a49      	ldr	r2, [pc, #292]	; (8019f08 <__strftime_fmt_1+0x664>)
 8019de4:	2164      	movs	r1, #100	; 0x64
 8019de6:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8019de8:	f000 fe34 	bl	801aa54 <snprintf>
 8019dec:	4603      	mov	r3, r0
 8019dee:	461a      	mov	r2, r3
 8019df0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019df2:	601a      	str	r2, [r3, #0]
			return *s;
 8019df4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8019df6:	e0b0      	b.n	8019f5a <__strftime_fmt_1+0x6b6>
		}
		width = 4;
 8019df8:	2304      	movs	r3, #4
 8019dfa:	643b      	str	r3, [r7, #64]	; 0x40
		goto number;
 8019dfc:	e00b      	b.n	8019e16 <__strftime_fmt_1+0x572>
		}
		fmt = __tm_to_tzname(tm);
		goto string;
#endif
	case '%':
		*l = 1;
 8019dfe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019e00:	2201      	movs	r2, #1
 8019e02:	601a      	str	r2, [r3, #0]
		return "%";
 8019e04:	4b41      	ldr	r3, [pc, #260]	; (8019f0c <__strftime_fmt_1+0x668>)
 8019e06:	e0a8      	b.n	8019f5a <__strftime_fmt_1+0x6b6>
	default:
		return 0;
 8019e08:	2300      	movs	r3, #0
 8019e0a:	e0a6      	b.n	8019f5a <__strftime_fmt_1+0x6b6>
		goto number;
 8019e0c:	bf00      	nop
 8019e0e:	e002      	b.n	8019e16 <__strftime_fmt_1+0x572>
		goto number;
 8019e10:	bf00      	nop
 8019e12:	e000      	b.n	8019e16 <__strftime_fmt_1+0x572>
		goto number;
 8019e14:	bf00      	nop
	}
number:
	switch (pad ? pad : def_pad) {
 8019e16:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019e18:	2b00      	cmp	r3, #0
 8019e1a:	d001      	beq.n	8019e20 <__strftime_fmt_1+0x57c>
 8019e1c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019e1e:	e000      	b.n	8019e22 <__strftime_fmt_1+0x57e>
 8019e20:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019e22:	2b2d      	cmp	r3, #45	; 0x2d
 8019e24:	d002      	beq.n	8019e2c <__strftime_fmt_1+0x588>
 8019e26:	2b5f      	cmp	r3, #95	; 0x5f
 8019e28:	d00e      	beq.n	8019e48 <__strftime_fmt_1+0x5a4>
 8019e2a:	e01c      	b.n	8019e66 <__strftime_fmt_1+0x5c2>
	case '-': *l = snprintf(*s, sizeof *s, "%lld", val); break;
 8019e2c:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019e30:	e9cd 2300 	strd	r2, r3, [sp]
 8019e34:	4a36      	ldr	r2, [pc, #216]	; (8019f10 <__strftime_fmt_1+0x66c>)
 8019e36:	2164      	movs	r1, #100	; 0x64
 8019e38:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8019e3a:	f000 fe0b 	bl	801aa54 <snprintf>
 8019e3e:	4603      	mov	r3, r0
 8019e40:	461a      	mov	r2, r3
 8019e42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019e44:	601a      	str	r2, [r3, #0]
 8019e46:	e01d      	b.n	8019e84 <__strftime_fmt_1+0x5e0>
	case '_': *l = snprintf(*s, sizeof *s, "%*lld", width, val); break;
 8019e48:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019e4c:	e9cd 2300 	strd	r2, r3, [sp]
 8019e50:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8019e52:	4a30      	ldr	r2, [pc, #192]	; (8019f14 <__strftime_fmt_1+0x670>)
 8019e54:	2164      	movs	r1, #100	; 0x64
 8019e56:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8019e58:	f000 fdfc 	bl	801aa54 <snprintf>
 8019e5c:	4603      	mov	r3, r0
 8019e5e:	461a      	mov	r2, r3
 8019e60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019e62:	601a      	str	r2, [r3, #0]
 8019e64:	e00e      	b.n	8019e84 <__strftime_fmt_1+0x5e0>
	case '0':
	default:  *l = snprintf(*s, sizeof *s, "%0*lld", width, val); break;
 8019e66:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 8019e6a:	e9cd 2300 	strd	r2, r3, [sp]
 8019e6e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8019e70:	4a29      	ldr	r2, [pc, #164]	; (8019f18 <__strftime_fmt_1+0x674>)
 8019e72:	2164      	movs	r1, #100	; 0x64
 8019e74:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8019e76:	f000 fded 	bl	801aa54 <snprintf>
 8019e7a:	4603      	mov	r3, r0
 8019e7c:	461a      	mov	r2, r3
 8019e7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019e80:	601a      	str	r2, [r3, #0]
 8019e82:	bf00      	nop
	}
	return *s;
 8019e84:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8019e86:	e068      	b.n	8019f5a <__strftime_fmt_1+0x6b6>
nl_strcat:
	fmt = __nl_langinfo_l(item, loc);
 8019e88:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8019e8a:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8019e8c:	f000 fd4c 	bl	801a928 <__nl_langinfo_l>
 8019e90:	63f8      	str	r0, [r7, #60]	; 0x3c
 8019e92:	e006      	b.n	8019ea2 <__strftime_fmt_1+0x5fe>
		if (tm->tm_wday > 6U) goto string;
 8019e94:	bf00      	nop
 8019e96:	e004      	b.n	8019ea2 <__strftime_fmt_1+0x5fe>
		if (tm->tm_wday > 6U) goto string;
 8019e98:	bf00      	nop
 8019e9a:	e002      	b.n	8019ea2 <__strftime_fmt_1+0x5fe>
		if (tm->tm_mon > 11U) goto string;
 8019e9c:	bf00      	nop
 8019e9e:	e000      	b.n	8019ea2 <__strftime_fmt_1+0x5fe>
		if (tm->tm_mon > 11U) goto string;
 8019ea0:	bf00      	nop
string:
	*l = strlen(fmt);
 8019ea2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8019ea4:	f7f5 fb53 	bl	800f54e <strlen>
 8019ea8:	4602      	mov	r2, r0
 8019eaa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019eac:	601a      	str	r2, [r3, #0]
	if (f=='P') {
 8019eae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019eb0:	2b50      	cmp	r3, #80	; 0x50
 8019eb2:	d113      	bne.n	8019edc <__strftime_fmt_1+0x638>
		static char ampm[2][3] = {"am", "pm"};
		if (!strncmp(fmt, "AM", 2)) return ampm[0];
 8019eb4:	2202      	movs	r2, #2
 8019eb6:	4919      	ldr	r1, [pc, #100]	; (8019f1c <__strftime_fmt_1+0x678>)
 8019eb8:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8019eba:	f7ff fbcb 	bl	8019654 <strncmp>
 8019ebe:	4603      	mov	r3, r0
 8019ec0:	2b00      	cmp	r3, #0
 8019ec2:	d101      	bne.n	8019ec8 <__strftime_fmt_1+0x624>
 8019ec4:	4b16      	ldr	r3, [pc, #88]	; (8019f20 <__strftime_fmt_1+0x67c>)
 8019ec6:	e048      	b.n	8019f5a <__strftime_fmt_1+0x6b6>
		else if (!strncmp(fmt, "PM", 2)) return ampm[1];
 8019ec8:	2202      	movs	r2, #2
 8019eca:	4916      	ldr	r1, [pc, #88]	; (8019f24 <__strftime_fmt_1+0x680>)
 8019ecc:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8019ece:	f7ff fbc1 	bl	8019654 <strncmp>
 8019ed2:	4603      	mov	r3, r0
 8019ed4:	2b00      	cmp	r3, #0
 8019ed6:	d101      	bne.n	8019edc <__strftime_fmt_1+0x638>
 8019ed8:	4b13      	ldr	r3, [pc, #76]	; (8019f28 <__strftime_fmt_1+0x684>)
 8019eda:	e03e      	b.n	8019f5a <__strftime_fmt_1+0x6b6>
	}
	return fmt;
 8019edc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019ede:	e03c      	b.n	8019f5a <__strftime_fmt_1+0x6b6>
 8019ee0:	080230e8 	.word	0x080230e8
 8019ee4:	00020027 	.word	0x00020027
 8019ee8:	00020026 	.word	0x00020026
 8019eec:	0002002b 	.word	0x0002002b
 8019ef0:	080230ec 	.word	0x080230ec
 8019ef4:	080230f4 	.word	0x080230f4
 8019ef8:	080230f8 	.word	0x080230f8
 8019efc:	24924925 	.word	0x24924925
 8019f00:	00020029 	.word	0x00020029
 8019f04:	0002002a 	.word	0x0002002a
 8019f08:	08023104 	.word	0x08023104
 8019f0c:	0802310c 	.word	0x0802310c
 8019f10:	08023110 	.word	0x08023110
 8019f14:	08023118 	.word	0x08023118
 8019f18:	08023120 	.word	0x08023120
 8019f1c:	08023128 	.word	0x08023128
 8019f20:	20000568 	.word	0x20000568
 8019f24:	0802312c 	.word	0x0802312c
 8019f28:	2000056b 	.word	0x2000056b
nl_strftime:
	fmt = __nl_langinfo_l(item, loc);
 8019f2c:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8019f2e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8019f30:	f000 fcfa 	bl	801a928 <__nl_langinfo_l>
 8019f34:	63f8      	str	r0, [r7, #60]	; 0x3c
recu_strftime:
	*l = __strftime_l(*s, sizeof *s, fmt, tm, loc);
 8019f36:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8019f38:	9300      	str	r3, [sp, #0]
 8019f3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019f3c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8019f3e:	2164      	movs	r1, #100	; 0x64
 8019f40:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8019f42:	f000 f80f 	bl	8019f64 <__strftime_l>
 8019f46:	4602      	mov	r2, r0
 8019f48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019f4a:	601a      	str	r2, [r3, #0]
	if (!*l) return 0;
 8019f4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019f4e:	681b      	ldr	r3, [r3, #0]
 8019f50:	2b00      	cmp	r3, #0
 8019f52:	d101      	bne.n	8019f58 <__strftime_fmt_1+0x6b4>
 8019f54:	2300      	movs	r3, #0
 8019f56:	e000      	b.n	8019f5a <__strftime_fmt_1+0x6b6>
	return *s;
 8019f58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 8019f5a:	4618      	mov	r0, r3
 8019f5c:	3750      	adds	r7, #80	; 0x50
 8019f5e:	46bd      	mov	sp, r7
 8019f60:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08019f64 <__strftime_l>:

size_t __strftime_l(char *restrict s, size_t n, const char *restrict f, const struct tm *restrict tm, locale_t loc)
{
 8019f64:	b580      	push	{r7, lr}
 8019f66:	b0aa      	sub	sp, #168	; 0xa8
 8019f68:	af02      	add	r7, sp, #8
 8019f6a:	6178      	str	r0, [r7, #20]
 8019f6c:	6139      	str	r1, [r7, #16]
 8019f6e:	60fa      	str	r2, [r7, #12]
 8019f70:	60bb      	str	r3, [r7, #8]
 8019f72:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8019f76:	607b      	str	r3, [r7, #4]
 8019f78:	4b9c      	ldr	r3, [pc, #624]	; (801a1ec <__strftime_l+0x288>)
 8019f7a:	681b      	ldr	r3, [r3, #0]
 8019f7c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8019f80:	f04f 0300 	mov.w	r3, #0
	char buf[100];
	char *p;
	const char *t;
	int pad, plus;
	unsigned long width;
	for (l=0; l<n; f++) {
 8019f84:	2300      	movs	r3, #0
 8019f86:	623b      	str	r3, [r7, #32]
 8019f88:	e10d      	b.n	801a1a6 <__strftime_l+0x242>
		if (!*f) {
 8019f8a:	68fb      	ldr	r3, [r7, #12]
 8019f8c:	781b      	ldrb	r3, [r3, #0]
 8019f8e:	2b00      	cmp	r3, #0
 8019f90:	d106      	bne.n	8019fa0 <__strftime_l+0x3c>
			s[l] = 0;
 8019f92:	697a      	ldr	r2, [r7, #20]
 8019f94:	6a3b      	ldr	r3, [r7, #32]
 8019f96:	4413      	add	r3, r2
 8019f98:	2200      	movs	r2, #0
 8019f9a:	701a      	strb	r2, [r3, #0]
			return l;
 8019f9c:	6a3b      	ldr	r3, [r7, #32]
 8019f9e:	e119      	b.n	801a1d4 <__strftime_l+0x270>
		}
		if (*f != '%') {
 8019fa0:	68fb      	ldr	r3, [r7, #12]
 8019fa2:	781b      	ldrb	r3, [r3, #0]
 8019fa4:	2b25      	cmp	r3, #37	; 0x25
 8019fa6:	d008      	beq.n	8019fba <__strftime_l+0x56>
			s[l++] = *f;
 8019fa8:	6a3b      	ldr	r3, [r7, #32]
 8019faa:	1c5a      	adds	r2, r3, #1
 8019fac:	623a      	str	r2, [r7, #32]
 8019fae:	697a      	ldr	r2, [r7, #20]
 8019fb0:	4413      	add	r3, r2
 8019fb2:	68fa      	ldr	r2, [r7, #12]
 8019fb4:	7812      	ldrb	r2, [r2, #0]
 8019fb6:	701a      	strb	r2, [r3, #0]
			continue;
 8019fb8:	e0f2      	b.n	801a1a0 <__strftime_l+0x23c>
		}
		f++;
 8019fba:	68fb      	ldr	r3, [r7, #12]
 8019fbc:	3301      	adds	r3, #1
 8019fbe:	60fb      	str	r3, [r7, #12]
		pad = 0;
 8019fc0:	2300      	movs	r3, #0
 8019fc2:	62bb      	str	r3, [r7, #40]	; 0x28
		if (*f == '-' || *f == '_' || *f == '0') pad = *f++;
 8019fc4:	68fb      	ldr	r3, [r7, #12]
 8019fc6:	781b      	ldrb	r3, [r3, #0]
 8019fc8:	2b2d      	cmp	r3, #45	; 0x2d
 8019fca:	d007      	beq.n	8019fdc <__strftime_l+0x78>
 8019fcc:	68fb      	ldr	r3, [r7, #12]
 8019fce:	781b      	ldrb	r3, [r3, #0]
 8019fd0:	2b5f      	cmp	r3, #95	; 0x5f
 8019fd2:	d003      	beq.n	8019fdc <__strftime_l+0x78>
 8019fd4:	68fb      	ldr	r3, [r7, #12]
 8019fd6:	781b      	ldrb	r3, [r3, #0]
 8019fd8:	2b30      	cmp	r3, #48	; 0x30
 8019fda:	d104      	bne.n	8019fe6 <__strftime_l+0x82>
 8019fdc:	68fb      	ldr	r3, [r7, #12]
 8019fde:	1c5a      	adds	r2, r3, #1
 8019fe0:	60fa      	str	r2, [r7, #12]
 8019fe2:	781b      	ldrb	r3, [r3, #0]
 8019fe4:	62bb      	str	r3, [r7, #40]	; 0x28
		if ((plus = (*f == '+'))) f++;
 8019fe6:	68fb      	ldr	r3, [r7, #12]
 8019fe8:	781b      	ldrb	r3, [r3, #0]
 8019fea:	2b2b      	cmp	r3, #43	; 0x2b
 8019fec:	bf0c      	ite	eq
 8019fee:	2301      	moveq	r3, #1
 8019ff0:	2300      	movne	r3, #0
 8019ff2:	b2db      	uxtb	r3, r3
 8019ff4:	637b      	str	r3, [r7, #52]	; 0x34
 8019ff6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8019ff8:	2b00      	cmp	r3, #0
 8019ffa:	d002      	beq.n	801a002 <__strftime_l+0x9e>
 8019ffc:	68fb      	ldr	r3, [r7, #12]
 8019ffe:	3301      	adds	r3, #1
 801a000:	60fb      	str	r3, [r7, #12]
		width = strtoul(f, &p, 10);
 801a002:	f107 031c 	add.w	r3, r7, #28
 801a006:	220a      	movs	r2, #10
 801a008:	4619      	mov	r1, r3
 801a00a:	68f8      	ldr	r0, [r7, #12]
 801a00c:	f7f5 fb22 	bl	800f654 <strtoul>
 801a010:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (*p == 'C' || *p == 'F' || *p == 'G' || *p == 'Y') {
 801a012:	69fb      	ldr	r3, [r7, #28]
 801a014:	781b      	ldrb	r3, [r3, #0]
 801a016:	2b43      	cmp	r3, #67	; 0x43
 801a018:	d00b      	beq.n	801a032 <__strftime_l+0xce>
 801a01a:	69fb      	ldr	r3, [r7, #28]
 801a01c:	781b      	ldrb	r3, [r3, #0]
 801a01e:	2b46      	cmp	r3, #70	; 0x46
 801a020:	d007      	beq.n	801a032 <__strftime_l+0xce>
 801a022:	69fb      	ldr	r3, [r7, #28]
 801a024:	781b      	ldrb	r3, [r3, #0]
 801a026:	2b47      	cmp	r3, #71	; 0x47
 801a028:	d003      	beq.n	801a032 <__strftime_l+0xce>
 801a02a:	69fb      	ldr	r3, [r7, #28]
 801a02c:	781b      	ldrb	r3, [r3, #0]
 801a02e:	2b59      	cmp	r3, #89	; 0x59
 801a030:	d109      	bne.n	801a046 <__strftime_l+0xe2>
			if (!width && p!=f) width = 1;
 801a032:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a034:	2b00      	cmp	r3, #0
 801a036:	d109      	bne.n	801a04c <__strftime_l+0xe8>
 801a038:	69fb      	ldr	r3, [r7, #28]
 801a03a:	68fa      	ldr	r2, [r7, #12]
 801a03c:	429a      	cmp	r2, r3
 801a03e:	d005      	beq.n	801a04c <__strftime_l+0xe8>
 801a040:	2301      	movs	r3, #1
 801a042:	62fb      	str	r3, [r7, #44]	; 0x2c
 801a044:	e002      	b.n	801a04c <__strftime_l+0xe8>
		} else {
			width = 0;
 801a046:	2300      	movs	r3, #0
 801a048:	62fb      	str	r3, [r7, #44]	; 0x2c
 801a04a:	e000      	b.n	801a04e <__strftime_l+0xea>
			if (!width && p!=f) width = 1;
 801a04c:	bf00      	nop
		}
		f = p;
 801a04e:	69fb      	ldr	r3, [r7, #28]
 801a050:	60fb      	str	r3, [r7, #12]
		if (*f == 'E' || *f == 'O') f++;
 801a052:	68fb      	ldr	r3, [r7, #12]
 801a054:	781b      	ldrb	r3, [r3, #0]
 801a056:	2b45      	cmp	r3, #69	; 0x45
 801a058:	d003      	beq.n	801a062 <__strftime_l+0xfe>
 801a05a:	68fb      	ldr	r3, [r7, #12]
 801a05c:	781b      	ldrb	r3, [r3, #0]
 801a05e:	2b4f      	cmp	r3, #79	; 0x4f
 801a060:	d102      	bne.n	801a068 <__strftime_l+0x104>
 801a062:	68fb      	ldr	r3, [r7, #12]
 801a064:	3301      	adds	r3, #1
 801a066:	60fb      	str	r3, [r7, #12]
		t = __strftime_fmt_1(&buf, &k, *f, tm, loc, pad);
 801a068:	68fb      	ldr	r3, [r7, #12]
 801a06a:	781b      	ldrb	r3, [r3, #0]
 801a06c:	461a      	mov	r2, r3
 801a06e:	f107 0118 	add.w	r1, r7, #24
 801a072:	f107 0038 	add.w	r0, r7, #56	; 0x38
 801a076:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a078:	9301      	str	r3, [sp, #4]
 801a07a:	687b      	ldr	r3, [r7, #4]
 801a07c:	9300      	str	r3, [sp, #0]
 801a07e:	68bb      	ldr	r3, [r7, #8]
 801a080:	f7ff fc10 	bl	80198a4 <__strftime_fmt_1>
 801a084:	6278      	str	r0, [r7, #36]	; 0x24
		if (!t) break;
 801a086:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a088:	2b00      	cmp	r3, #0
 801a08a:	f000 8092 	beq.w	801a1b2 <__strftime_l+0x24e>
		if (width) {
 801a08e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a090:	2b00      	cmp	r3, #0
 801a092:	d06f      	beq.n	801a174 <__strftime_l+0x210>
			/* Trim off any sign and leading zeros, then
			 * count remaining digits to determine behavior
			 * for the + flag. */
			if (*t=='+' || *t=='-') t++, k--;
 801a094:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a096:	781b      	ldrb	r3, [r3, #0]
 801a098:	2b2b      	cmp	r3, #43	; 0x2b
 801a09a:	d003      	beq.n	801a0a4 <__strftime_l+0x140>
 801a09c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a09e:	781b      	ldrb	r3, [r3, #0]
 801a0a0:	2b2d      	cmp	r3, #45	; 0x2d
 801a0a2:	d10c      	bne.n	801a0be <__strftime_l+0x15a>
 801a0a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a0a6:	3301      	adds	r3, #1
 801a0a8:	627b      	str	r3, [r7, #36]	; 0x24
 801a0aa:	69bb      	ldr	r3, [r7, #24]
 801a0ac:	3b01      	subs	r3, #1
 801a0ae:	61bb      	str	r3, [r7, #24]
			for (; *t=='0' && t[1]-'0'<10U; t++, k--);
 801a0b0:	e005      	b.n	801a0be <__strftime_l+0x15a>
 801a0b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a0b4:	3301      	adds	r3, #1
 801a0b6:	627b      	str	r3, [r7, #36]	; 0x24
 801a0b8:	69bb      	ldr	r3, [r7, #24]
 801a0ba:	3b01      	subs	r3, #1
 801a0bc:	61bb      	str	r3, [r7, #24]
 801a0be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a0c0:	781b      	ldrb	r3, [r3, #0]
 801a0c2:	2b30      	cmp	r3, #48	; 0x30
 801a0c4:	d105      	bne.n	801a0d2 <__strftime_l+0x16e>
 801a0c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a0c8:	3301      	adds	r3, #1
 801a0ca:	781b      	ldrb	r3, [r3, #0]
 801a0cc:	3b30      	subs	r3, #48	; 0x30
 801a0ce:	2b09      	cmp	r3, #9
 801a0d0:	d9ef      	bls.n	801a0b2 <__strftime_l+0x14e>
			if (width < k) width = k;
 801a0d2:	69bb      	ldr	r3, [r7, #24]
 801a0d4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a0d6:	429a      	cmp	r2, r3
 801a0d8:	d201      	bcs.n	801a0de <__strftime_l+0x17a>
 801a0da:	69bb      	ldr	r3, [r7, #24]
 801a0dc:	62fb      	str	r3, [r7, #44]	; 0x2c
			size_t d;
			for (d=0; t[d]-'0'<10U; d++);
 801a0de:	2300      	movs	r3, #0
 801a0e0:	633b      	str	r3, [r7, #48]	; 0x30
 801a0e2:	e002      	b.n	801a0ea <__strftime_l+0x186>
 801a0e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a0e6:	3301      	adds	r3, #1
 801a0e8:	633b      	str	r3, [r7, #48]	; 0x30
 801a0ea:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a0ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a0ee:	4413      	add	r3, r2
 801a0f0:	781b      	ldrb	r3, [r3, #0]
 801a0f2:	3b30      	subs	r3, #48	; 0x30
 801a0f4:	2b09      	cmp	r3, #9
 801a0f6:	d9f5      	bls.n	801a0e4 <__strftime_l+0x180>
			if (tm->tm_year < -1900) {
 801a0f8:	68bb      	ldr	r3, [r7, #8]
 801a0fa:	695b      	ldr	r3, [r3, #20]
 801a0fc:	4a3c      	ldr	r2, [pc, #240]	; (801a1f0 <__strftime_l+0x28c>)
 801a0fe:	4293      	cmp	r3, r2
 801a100:	da0a      	bge.n	801a118 <__strftime_l+0x1b4>
				s[l++] = '-';
 801a102:	6a3b      	ldr	r3, [r7, #32]
 801a104:	1c5a      	adds	r2, r3, #1
 801a106:	623a      	str	r2, [r7, #32]
 801a108:	697a      	ldr	r2, [r7, #20]
 801a10a:	4413      	add	r3, r2
 801a10c:	222d      	movs	r2, #45	; 0x2d
 801a10e:	701a      	strb	r2, [r3, #0]
				width--;
 801a110:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a112:	3b01      	subs	r3, #1
 801a114:	62fb      	str	r3, [r7, #44]	; 0x2c
 801a116:	e025      	b.n	801a164 <__strftime_l+0x200>
			} else if (plus && d+(width-k) >= (*p=='C'?3:5)) {
 801a118:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a11a:	2b00      	cmp	r3, #0
 801a11c:	d022      	beq.n	801a164 <__strftime_l+0x200>
 801a11e:	69bb      	ldr	r3, [r7, #24]
 801a120:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a122:	1ad2      	subs	r2, r2, r3
 801a124:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a126:	4413      	add	r3, r2
 801a128:	69fa      	ldr	r2, [r7, #28]
 801a12a:	7812      	ldrb	r2, [r2, #0]
 801a12c:	2a43      	cmp	r2, #67	; 0x43
 801a12e:	d101      	bne.n	801a134 <__strftime_l+0x1d0>
 801a130:	2203      	movs	r2, #3
 801a132:	e000      	b.n	801a136 <__strftime_l+0x1d2>
 801a134:	2205      	movs	r2, #5
 801a136:	429a      	cmp	r2, r3
 801a138:	d814      	bhi.n	801a164 <__strftime_l+0x200>
				s[l++] = '+';
 801a13a:	6a3b      	ldr	r3, [r7, #32]
 801a13c:	1c5a      	adds	r2, r3, #1
 801a13e:	623a      	str	r2, [r7, #32]
 801a140:	697a      	ldr	r2, [r7, #20]
 801a142:	4413      	add	r3, r2
 801a144:	222b      	movs	r2, #43	; 0x2b
 801a146:	701a      	strb	r2, [r3, #0]
				width--;
 801a148:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a14a:	3b01      	subs	r3, #1
 801a14c:	62fb      	str	r3, [r7, #44]	; 0x2c
			}
			for (; width > k && l < n; width--)
 801a14e:	e009      	b.n	801a164 <__strftime_l+0x200>
				s[l++] = '0';
 801a150:	6a3b      	ldr	r3, [r7, #32]
 801a152:	1c5a      	adds	r2, r3, #1
 801a154:	623a      	str	r2, [r7, #32]
 801a156:	697a      	ldr	r2, [r7, #20]
 801a158:	4413      	add	r3, r2
 801a15a:	2230      	movs	r2, #48	; 0x30
 801a15c:	701a      	strb	r2, [r3, #0]
			for (; width > k && l < n; width--)
 801a15e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a160:	3b01      	subs	r3, #1
 801a162:	62fb      	str	r3, [r7, #44]	; 0x2c
 801a164:	69bb      	ldr	r3, [r7, #24]
 801a166:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a168:	429a      	cmp	r2, r3
 801a16a:	d903      	bls.n	801a174 <__strftime_l+0x210>
 801a16c:	6a3a      	ldr	r2, [r7, #32]
 801a16e:	693b      	ldr	r3, [r7, #16]
 801a170:	429a      	cmp	r2, r3
 801a172:	d3ed      	bcc.n	801a150 <__strftime_l+0x1ec>
		}
		if (k > n-l) k = n-l;
 801a174:	693a      	ldr	r2, [r7, #16]
 801a176:	6a3b      	ldr	r3, [r7, #32]
 801a178:	1ad2      	subs	r2, r2, r3
 801a17a:	69bb      	ldr	r3, [r7, #24]
 801a17c:	429a      	cmp	r2, r3
 801a17e:	d203      	bcs.n	801a188 <__strftime_l+0x224>
 801a180:	693a      	ldr	r2, [r7, #16]
 801a182:	6a3b      	ldr	r3, [r7, #32]
 801a184:	1ad3      	subs	r3, r2, r3
 801a186:	61bb      	str	r3, [r7, #24]
		memcpy(s+l, t, k);
 801a188:	697a      	ldr	r2, [r7, #20]
 801a18a:	6a3b      	ldr	r3, [r7, #32]
 801a18c:	4413      	add	r3, r2
 801a18e:	69ba      	ldr	r2, [r7, #24]
 801a190:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801a192:	4618      	mov	r0, r3
 801a194:	f7fe ffb2 	bl	80190fc <memcpy>
		l += k;
 801a198:	69bb      	ldr	r3, [r7, #24]
 801a19a:	6a3a      	ldr	r2, [r7, #32]
 801a19c:	4413      	add	r3, r2
 801a19e:	623b      	str	r3, [r7, #32]
	for (l=0; l<n; f++) {
 801a1a0:	68fb      	ldr	r3, [r7, #12]
 801a1a2:	3301      	adds	r3, #1
 801a1a4:	60fb      	str	r3, [r7, #12]
 801a1a6:	6a3a      	ldr	r2, [r7, #32]
 801a1a8:	693b      	ldr	r3, [r7, #16]
 801a1aa:	429a      	cmp	r2, r3
 801a1ac:	f4ff aeed 	bcc.w	8019f8a <__strftime_l+0x26>
 801a1b0:	e000      	b.n	801a1b4 <__strftime_l+0x250>
		if (!t) break;
 801a1b2:	bf00      	nop
	}
	if (n) {
 801a1b4:	693b      	ldr	r3, [r7, #16]
 801a1b6:	2b00      	cmp	r3, #0
 801a1b8:	d00b      	beq.n	801a1d2 <__strftime_l+0x26e>
		if (l==n) l=n-1;
 801a1ba:	6a3a      	ldr	r2, [r7, #32]
 801a1bc:	693b      	ldr	r3, [r7, #16]
 801a1be:	429a      	cmp	r2, r3
 801a1c0:	d102      	bne.n	801a1c8 <__strftime_l+0x264>
 801a1c2:	693b      	ldr	r3, [r7, #16]
 801a1c4:	3b01      	subs	r3, #1
 801a1c6:	623b      	str	r3, [r7, #32]
		s[l] = 0;
 801a1c8:	697a      	ldr	r2, [r7, #20]
 801a1ca:	6a3b      	ldr	r3, [r7, #32]
 801a1cc:	4413      	add	r3, r2
 801a1ce:	2200      	movs	r2, #0
 801a1d0:	701a      	strb	r2, [r3, #0]
	}
	return 0;
 801a1d2:	2300      	movs	r3, #0
}
 801a1d4:	4a05      	ldr	r2, [pc, #20]	; (801a1ec <__strftime_l+0x288>)
 801a1d6:	6811      	ldr	r1, [r2, #0]
 801a1d8:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 801a1dc:	4051      	eors	r1, r2
 801a1de:	d001      	beq.n	801a1e4 <__strftime_l+0x280>
 801a1e0:	f7ea f9fc 	bl	80045dc <__stack_chk_fail>
 801a1e4:	4618      	mov	r0, r3
 801a1e6:	37a0      	adds	r7, #160	; 0xa0
 801a1e8:	46bd      	mov	sp, r7
 801a1ea:	bd80      	pop	{r7, pc}
 801a1ec:	08023130 	.word	0x08023130
 801a1f0:	fffff894 	.word	0xfffff894

0801a1f4 <strftime>:

size_t strftime(char *restrict s, size_t n, const char *restrict f, const struct tm *restrict tm)
{
 801a1f4:	b580      	push	{r7, lr}
 801a1f6:	b086      	sub	sp, #24
 801a1f8:	af02      	add	r7, sp, #8
 801a1fa:	60f8      	str	r0, [r7, #12]
 801a1fc:	60b9      	str	r1, [r7, #8]
 801a1fe:	607a      	str	r2, [r7, #4]
 801a200:	603b      	str	r3, [r7, #0]
	return __strftime_l(s, n, f, tm, CURRENT_LOCALE);
 801a202:	2301      	movs	r3, #1
 801a204:	9300      	str	r3, [sp, #0]
 801a206:	683b      	ldr	r3, [r7, #0]
 801a208:	687a      	ldr	r2, [r7, #4]
 801a20a:	68b9      	ldr	r1, [r7, #8]
 801a20c:	68f8      	ldr	r0, [r7, #12]
 801a20e:	f7ff fea9 	bl	8019f64 <__strftime_l>
 801a212:	4603      	mov	r3, r0
}
 801a214:	4618      	mov	r0, r3
 801a216:	3710      	adds	r7, #16
 801a218:	46bd      	mov	sp, r7
 801a21a:	bd80      	pop	{r7, pc}

0801a21c <__isspace>:
{
 801a21c:	b480      	push	{r7}
 801a21e:	b083      	sub	sp, #12
 801a220:	af00      	add	r7, sp, #0
 801a222:	6078      	str	r0, [r7, #4]
	return _c == ' ' || (unsigned)_c-'\t' < 5;
 801a224:	687b      	ldr	r3, [r7, #4]
 801a226:	2b20      	cmp	r3, #32
 801a228:	d003      	beq.n	801a232 <__isspace+0x16>
 801a22a:	687b      	ldr	r3, [r7, #4]
 801a22c:	3b09      	subs	r3, #9
 801a22e:	2b04      	cmp	r3, #4
 801a230:	d801      	bhi.n	801a236 <__isspace+0x1a>
 801a232:	2301      	movs	r3, #1
 801a234:	e000      	b.n	801a238 <__isspace+0x1c>
 801a236:	2300      	movs	r3, #0
}
 801a238:	4618      	mov	r0, r3
 801a23a:	370c      	adds	r7, #12
 801a23c:	46bd      	mov	sp, r7
 801a23e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a242:	4770      	bx	lr

0801a244 <strptime>:
#include <stddef.h>
#include <string.h>
#include <strings.h>

char *strptime(const char *restrict s, const char *restrict f, struct tm *restrict tm)
{
 801a244:	b580      	push	{r7, lr}
 801a246:	b094      	sub	sp, #80	; 0x50
 801a248:	af00      	add	r7, sp, #0
 801a24a:	60f8      	str	r0, [r7, #12]
 801a24c:	60b9      	str	r1, [r7, #8]
 801a24e:	607a      	str	r2, [r7, #4]
 801a250:	4bbe      	ldr	r3, [pc, #760]	; (801a54c <strptime+0x308>)
 801a252:	681b      	ldr	r3, [r3, #0]
 801a254:	64fb      	str	r3, [r7, #76]	; 0x4c
 801a256:	f04f 0300 	mov.w	r3, #0
	int i, w, neg, adj, min, range, *dest, dummy;
	const char *ex;
	size_t len;
	int want_century = 0, century = 0, relyear = 0;
 801a25a:	2300      	movs	r3, #0
 801a25c:	643b      	str	r3, [r7, #64]	; 0x40
 801a25e:	2300      	movs	r3, #0
 801a260:	61bb      	str	r3, [r7, #24]
 801a262:	2300      	movs	r3, #0
 801a264:	61fb      	str	r3, [r7, #28]
	while (*f) {
 801a266:	e32a      	b.n	801a8be <strptime+0x67a>
		if (*f != '%') {
 801a268:	68bb      	ldr	r3, [r7, #8]
 801a26a:	781b      	ldrb	r3, [r3, #0]
 801a26c:	2b25      	cmp	r3, #37	; 0x25
 801a26e:	d027      	beq.n	801a2c0 <strptime+0x7c>
			if (isspace(*f)) for (; *s && isspace(*s); s++);
 801a270:	68bb      	ldr	r3, [r7, #8]
 801a272:	781b      	ldrb	r3, [r3, #0]
 801a274:	4618      	mov	r0, r3
 801a276:	f7ff ffd1 	bl	801a21c <__isspace>
 801a27a:	4603      	mov	r3, r0
 801a27c:	2b00      	cmp	r3, #0
 801a27e:	d010      	beq.n	801a2a2 <strptime+0x5e>
 801a280:	e002      	b.n	801a288 <strptime+0x44>
 801a282:	68fb      	ldr	r3, [r7, #12]
 801a284:	3301      	adds	r3, #1
 801a286:	60fb      	str	r3, [r7, #12]
 801a288:	68fb      	ldr	r3, [r7, #12]
 801a28a:	781b      	ldrb	r3, [r3, #0]
 801a28c:	2b00      	cmp	r3, #0
 801a28e:	d013      	beq.n	801a2b8 <strptime+0x74>
 801a290:	68fb      	ldr	r3, [r7, #12]
 801a292:	781b      	ldrb	r3, [r3, #0]
 801a294:	4618      	mov	r0, r3
 801a296:	f7ff ffc1 	bl	801a21c <__isspace>
 801a29a:	4603      	mov	r3, r0
 801a29c:	2b00      	cmp	r3, #0
 801a29e:	d1f0      	bne.n	801a282 <strptime+0x3e>
 801a2a0:	e00a      	b.n	801a2b8 <strptime+0x74>
			else if (*s != *f) return 0;
 801a2a2:	68fb      	ldr	r3, [r7, #12]
 801a2a4:	781a      	ldrb	r2, [r3, #0]
 801a2a6:	68bb      	ldr	r3, [r7, #8]
 801a2a8:	781b      	ldrb	r3, [r3, #0]
 801a2aa:	429a      	cmp	r2, r3
 801a2ac:	d001      	beq.n	801a2b2 <strptime+0x6e>
 801a2ae:	2300      	movs	r3, #0
 801a2b0:	e32c      	b.n	801a90c <strptime+0x6c8>
			else s++;
 801a2b2:	68fb      	ldr	r3, [r7, #12]
 801a2b4:	3301      	adds	r3, #1
 801a2b6:	60fb      	str	r3, [r7, #12]
			f++;
 801a2b8:	68bb      	ldr	r3, [r7, #8]
 801a2ba:	3301      	adds	r3, #1
 801a2bc:	60bb      	str	r3, [r7, #8]
			continue;
 801a2be:	e2fe      	b.n	801a8be <strptime+0x67a>
		}
		f++;
 801a2c0:	68bb      	ldr	r3, [r7, #8]
 801a2c2:	3301      	adds	r3, #1
 801a2c4:	60bb      	str	r3, [r7, #8]
		if (*f == '+') f++;
 801a2c6:	68bb      	ldr	r3, [r7, #8]
 801a2c8:	781b      	ldrb	r3, [r3, #0]
 801a2ca:	2b2b      	cmp	r3, #43	; 0x2b
 801a2cc:	d102      	bne.n	801a2d4 <strptime+0x90>
 801a2ce:	68bb      	ldr	r3, [r7, #8]
 801a2d0:	3301      	adds	r3, #1
 801a2d2:	60bb      	str	r3, [r7, #8]
		if (isdigit(*f)) {
 801a2d4:	68bb      	ldr	r3, [r7, #8]
 801a2d6:	781b      	ldrb	r3, [r3, #0]
 801a2d8:	3b30      	subs	r3, #48	; 0x30
 801a2da:	2b09      	cmp	r3, #9
 801a2dc:	d80b      	bhi.n	801a2f6 <strptime+0xb2>
			char *new_f;
			w=strtoul(f, &new_f, 10);
 801a2de:	f107 0320 	add.w	r3, r7, #32
 801a2e2:	220a      	movs	r2, #10
 801a2e4:	4619      	mov	r1, r3
 801a2e6:	68b8      	ldr	r0, [r7, #8]
 801a2e8:	f7f5 f9b4 	bl	800f654 <strtoul>
 801a2ec:	4603      	mov	r3, r0
 801a2ee:	62bb      	str	r3, [r7, #40]	; 0x28
			f = new_f;
 801a2f0:	6a3b      	ldr	r3, [r7, #32]
 801a2f2:	60bb      	str	r3, [r7, #8]
 801a2f4:	e002      	b.n	801a2fc <strptime+0xb8>
		} else {
			w=-1;
 801a2f6:	f04f 33ff 	mov.w	r3, #4294967295
 801a2fa:	62bb      	str	r3, [r7, #40]	; 0x28
		}
		adj=0;
 801a2fc:	2300      	movs	r3, #0
 801a2fe:	633b      	str	r3, [r7, #48]	; 0x30
		switch (*f++) {
 801a300:	68bb      	ldr	r3, [r7, #8]
 801a302:	1c5a      	adds	r2, r3, #1
 801a304:	60ba      	str	r2, [r7, #8]
 801a306:	781b      	ldrb	r3, [r3, #0]
 801a308:	3b25      	subs	r3, #37	; 0x25
 801a30a:	2b54      	cmp	r3, #84	; 0x54
 801a30c:	f200 8207 	bhi.w	801a71e <strptime+0x4da>
 801a310:	a201      	add	r2, pc, #4	; (adr r2, 801a318 <strptime+0xd4>)
 801a312:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a316:	bf00      	nop
 801a318:	0801a70d 	.word	0x0801a70d
 801a31c:	0801a71f 	.word	0x0801a71f
 801a320:	0801a71f 	.word	0x0801a71f
 801a324:	0801a71f 	.word	0x0801a71f
 801a328:	0801a71f 	.word	0x0801a71f
 801a32c:	0801a71f 	.word	0x0801a71f
 801a330:	0801a71f 	.word	0x0801a71f
 801a334:	0801a71f 	.word	0x0801a71f
 801a338:	0801a71f 	.word	0x0801a71f
 801a33c:	0801a71f 	.word	0x0801a71f
 801a340:	0801a71f 	.word	0x0801a71f
 801a344:	0801a71f 	.word	0x0801a71f
 801a348:	0801a71f 	.word	0x0801a71f
 801a34c:	0801a71f 	.word	0x0801a71f
 801a350:	0801a71f 	.word	0x0801a71f
 801a354:	0801a71f 	.word	0x0801a71f
 801a358:	0801a71f 	.word	0x0801a71f
 801a35c:	0801a71f 	.word	0x0801a71f
 801a360:	0801a71f 	.word	0x0801a71f
 801a364:	0801a71f 	.word	0x0801a71f
 801a368:	0801a71f 	.word	0x0801a71f
 801a36c:	0801a71f 	.word	0x0801a71f
 801a370:	0801a71f 	.word	0x0801a71f
 801a374:	0801a71f 	.word	0x0801a71f
 801a378:	0801a71f 	.word	0x0801a71f
 801a37c:	0801a71f 	.word	0x0801a71f
 801a380:	0801a71f 	.word	0x0801a71f
 801a384:	0801a71f 	.word	0x0801a71f
 801a388:	0801a46d 	.word	0x0801a46d
 801a38c:	0801a47f 	.word	0x0801a47f
 801a390:	0801a4af 	.word	0x0801a4af
 801a394:	0801a4d9 	.word	0x0801a4d9
 801a398:	0801a71f 	.word	0x0801a71f
 801a39c:	0801a71f 	.word	0x0801a71f
 801a3a0:	0801a71f 	.word	0x0801a71f
 801a3a4:	0801a4f1 	.word	0x0801a4f1
 801a3a8:	0801a501 	.word	0x0801a501
 801a3ac:	0801a71f 	.word	0x0801a71f
 801a3b0:	0801a71f 	.word	0x0801a71f
 801a3b4:	0801a71f 	.word	0x0801a71f
 801a3b8:	0801a53b 	.word	0x0801a53b
 801a3bc:	0801a71f 	.word	0x0801a71f
 801a3c0:	0801a71f 	.word	0x0801a71f
 801a3c4:	0801a71f 	.word	0x0801a71f
 801a3c8:	0801a71f 	.word	0x0801a71f
 801a3cc:	0801a63f 	.word	0x0801a63f
 801a3d0:	0801a657 	.word	0x0801a657
 801a3d4:	0801a665 	.word	0x0801a665
 801a3d8:	0801a67d 	.word	0x0801a67d
 801a3dc:	0801a71f 	.word	0x0801a71f
 801a3e0:	0801a67d 	.word	0x0801a67d
 801a3e4:	0801a6bd 	.word	0x0801a6bd
 801a3e8:	0801a6f1 	.word	0x0801a6f1
 801a3ec:	0801a71f 	.word	0x0801a71f
 801a3f0:	0801a71f 	.word	0x0801a71f
 801a3f4:	0801a71f 	.word	0x0801a71f
 801a3f8:	0801a71f 	.word	0x0801a71f
 801a3fc:	0801a71f 	.word	0x0801a71f
 801a400:	0801a71f 	.word	0x0801a71f
 801a404:	0801a71f 	.word	0x0801a71f
 801a408:	0801a46d 	.word	0x0801a46d
 801a40c:	0801a47f 	.word	0x0801a47f
 801a410:	0801a48f 	.word	0x0801a48f
 801a414:	0801a4c9 	.word	0x0801a4c9
 801a418:	0801a4c9 	.word	0x0801a4c9
 801a41c:	0801a71f 	.word	0x0801a71f
 801a420:	0801a71f 	.word	0x0801a71f
 801a424:	0801a47f 	.word	0x0801a47f
 801a428:	0801a71f 	.word	0x0801a71f
 801a42c:	0801a511 	.word	0x0801a511
 801a430:	0801a71f 	.word	0x0801a71f
 801a434:	0801a71f 	.word	0x0801a71f
 801a438:	0801a527 	.word	0x0801a527
 801a43c:	0801a563 	.word	0x0801a563
 801a440:	0801a71f 	.word	0x0801a71f
 801a444:	0801a57f 	.word	0x0801a57f
 801a448:	0801a71f 	.word	0x0801a71f
 801a44c:	0801a61f 	.word	0x0801a61f
 801a450:	0801a71f 	.word	0x0801a71f
 801a454:	0801a563 	.word	0x0801a563
 801a458:	0801a71f 	.word	0x0801a71f
 801a45c:	0801a71f 	.word	0x0801a71f
 801a460:	0801a68d 	.word	0x0801a68d
 801a464:	0801a69d 	.word	0x0801a69d
 801a468:	0801a6dd 	.word	0x0801a6dd
		case 'a': case 'A':
			dest = &tm->tm_wday;
 801a46c:	687b      	ldr	r3, [r7, #4]
 801a46e:	3318      	adds	r3, #24
 801a470:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = ABDAY_1;
 801a472:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 801a476:	637b      	str	r3, [r7, #52]	; 0x34
			range = 7;
 801a478:	2307      	movs	r3, #7
 801a47a:	63bb      	str	r3, [r7, #56]	; 0x38
			goto symbolic_range;
 801a47c:	e1eb      	b.n	801a856 <strptime+0x612>
		case 'b': case 'B': case 'h':
			dest = &tm->tm_mon;
 801a47e:	687b      	ldr	r3, [r7, #4]
 801a480:	3310      	adds	r3, #16
 801a482:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = ABMON_1;
 801a484:	4b32      	ldr	r3, [pc, #200]	; (801a550 <strptime+0x30c>)
 801a486:	637b      	str	r3, [r7, #52]	; 0x34
			range = 12;
 801a488:	230c      	movs	r3, #12
 801a48a:	63bb      	str	r3, [r7, #56]	; 0x38
			goto symbolic_range;
 801a48c:	e1e3      	b.n	801a856 <strptime+0x612>
		case 'c':
			s = strptime(s, nl_langinfo(D_T_FMT), tm);
 801a48e:	4831      	ldr	r0, [pc, #196]	; (801a554 <strptime+0x310>)
 801a490:	f000 faa8 	bl	801a9e4 <__nl_langinfo>
 801a494:	4603      	mov	r3, r0
 801a496:	687a      	ldr	r2, [r7, #4]
 801a498:	4619      	mov	r1, r3
 801a49a:	68f8      	ldr	r0, [r7, #12]
 801a49c:	f7ff fed2 	bl	801a244 <strptime>
 801a4a0:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a4a2:	68fb      	ldr	r3, [r7, #12]
 801a4a4:	2b00      	cmp	r3, #0
 801a4a6:	f040 820a 	bne.w	801a8be <strptime+0x67a>
 801a4aa:	2300      	movs	r3, #0
 801a4ac:	e22e      	b.n	801a90c <strptime+0x6c8>
			break;
		case 'C':
			dest = &century;
 801a4ae:	f107 0318 	add.w	r3, r7, #24
 801a4b2:	63fb      	str	r3, [r7, #60]	; 0x3c
			if (w<0) w=2;
 801a4b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a4b6:	2b00      	cmp	r3, #0
 801a4b8:	da01      	bge.n	801a4be <strptime+0x27a>
 801a4ba:	2302      	movs	r3, #2
 801a4bc:	62bb      	str	r3, [r7, #40]	; 0x28
			want_century |= 2;
 801a4be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a4c0:	f043 0302 	orr.w	r3, r3, #2
 801a4c4:	643b      	str	r3, [r7, #64]	; 0x40
			goto numeric_digits;
 801a4c6:	e16b      	b.n	801a7a0 <strptime+0x55c>
		case 'd': case 'e':
			dest = &tm->tm_mday;
 801a4c8:	687b      	ldr	r3, [r7, #4]
 801a4ca:	330c      	adds	r3, #12
 801a4cc:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 1;
 801a4ce:	2301      	movs	r3, #1
 801a4d0:	637b      	str	r3, [r7, #52]	; 0x34
			range = 31;
 801a4d2:	231f      	movs	r3, #31
 801a4d4:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a4d6:	e124      	b.n	801a722 <strptime+0x4de>
		case 'D':
			s = strptime(s, "%m/%d/%y", tm);
 801a4d8:	687a      	ldr	r2, [r7, #4]
 801a4da:	491f      	ldr	r1, [pc, #124]	; (801a558 <strptime+0x314>)
 801a4dc:	68f8      	ldr	r0, [r7, #12]
 801a4de:	f7ff feb1 	bl	801a244 <strptime>
 801a4e2:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a4e4:	68fb      	ldr	r3, [r7, #12]
 801a4e6:	2b00      	cmp	r3, #0
 801a4e8:	f040 81e9 	bne.w	801a8be <strptime+0x67a>
 801a4ec:	2300      	movs	r3, #0
 801a4ee:	e20d      	b.n	801a90c <strptime+0x6c8>
			break;
		case 'H':
			dest = &tm->tm_hour;
 801a4f0:	687b      	ldr	r3, [r7, #4]
 801a4f2:	3308      	adds	r3, #8
 801a4f4:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 0;
 801a4f6:	2300      	movs	r3, #0
 801a4f8:	637b      	str	r3, [r7, #52]	; 0x34
			range = 24;
 801a4fa:	2318      	movs	r3, #24
 801a4fc:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a4fe:	e110      	b.n	801a722 <strptime+0x4de>
		case 'I':
			dest = &tm->tm_hour;
 801a500:	687b      	ldr	r3, [r7, #4]
 801a502:	3308      	adds	r3, #8
 801a504:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 1;
 801a506:	2301      	movs	r3, #1
 801a508:	637b      	str	r3, [r7, #52]	; 0x34
			range = 12;
 801a50a:	230c      	movs	r3, #12
 801a50c:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a50e:	e108      	b.n	801a722 <strptime+0x4de>
		case 'j':
			dest = &tm->tm_yday;
 801a510:	687b      	ldr	r3, [r7, #4]
 801a512:	331c      	adds	r3, #28
 801a514:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 1;
 801a516:	2301      	movs	r3, #1
 801a518:	637b      	str	r3, [r7, #52]	; 0x34
			range = 366;
 801a51a:	f44f 73b7 	mov.w	r3, #366	; 0x16e
 801a51e:	63bb      	str	r3, [r7, #56]	; 0x38
			adj = 1;
 801a520:	2301      	movs	r3, #1
 801a522:	633b      	str	r3, [r7, #48]	; 0x30
			goto numeric_range;
 801a524:	e0fd      	b.n	801a722 <strptime+0x4de>
		case 'm':
			dest = &tm->tm_mon;
 801a526:	687b      	ldr	r3, [r7, #4]
 801a528:	3310      	adds	r3, #16
 801a52a:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 1;
 801a52c:	2301      	movs	r3, #1
 801a52e:	637b      	str	r3, [r7, #52]	; 0x34
			range = 12;
 801a530:	230c      	movs	r3, #12
 801a532:	63bb      	str	r3, [r7, #56]	; 0x38
			adj = 1;
 801a534:	2301      	movs	r3, #1
 801a536:	633b      	str	r3, [r7, #48]	; 0x30
			goto numeric_range;
 801a538:	e0f3      	b.n	801a722 <strptime+0x4de>
		case 'M':
			dest = &tm->tm_min;
 801a53a:	687b      	ldr	r3, [r7, #4]
 801a53c:	3304      	adds	r3, #4
 801a53e:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 0;
 801a540:	2300      	movs	r3, #0
 801a542:	637b      	str	r3, [r7, #52]	; 0x34
			range = 60;
 801a544:	233c      	movs	r3, #60	; 0x3c
 801a546:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a548:	e0eb      	b.n	801a722 <strptime+0x4de>
 801a54a:	bf00      	nop
 801a54c:	08023154 	.word	0x08023154
 801a550:	0002000e 	.word	0x0002000e
 801a554:	00020028 	.word	0x00020028
 801a558:	08023134 	.word	0x08023134
		case 'n': case 't':
			for (; *s && isspace(*s); s++);
 801a55c:	68fb      	ldr	r3, [r7, #12]
 801a55e:	3301      	adds	r3, #1
 801a560:	60fb      	str	r3, [r7, #12]
 801a562:	68fb      	ldr	r3, [r7, #12]
 801a564:	781b      	ldrb	r3, [r3, #0]
 801a566:	2b00      	cmp	r3, #0
 801a568:	f000 81a9 	beq.w	801a8be <strptime+0x67a>
 801a56c:	68fb      	ldr	r3, [r7, #12]
 801a56e:	781b      	ldrb	r3, [r3, #0]
 801a570:	4618      	mov	r0, r3
 801a572:	f7ff fe53 	bl	801a21c <__isspace>
 801a576:	4603      	mov	r3, r0
 801a578:	2b00      	cmp	r3, #0
 801a57a:	d1ef      	bne.n	801a55c <strptime+0x318>
			break;
 801a57c:	e19f      	b.n	801a8be <strptime+0x67a>
		case 'p':
			ex = nl_langinfo(AM_STR);
 801a57e:	4898      	ldr	r0, [pc, #608]	; (801a7e0 <strptime+0x59c>)
 801a580:	f000 fa30 	bl	801a9e4 <__nl_langinfo>
 801a584:	6478      	str	r0, [r7, #68]	; 0x44
			len = strlen(ex);
 801a586:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801a588:	f7f4 ffe1 	bl	800f54e <strlen>
 801a58c:	64b8      	str	r0, [r7, #72]	; 0x48
			if (!strncasecmp(s, ex, len)) {
 801a58e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801a590:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a592:	68f8      	ldr	r0, [r7, #12]
 801a594:	f003 fc69 	bl	801de6a <strncasecmp>
 801a598:	4603      	mov	r3, r0
 801a59a:	2b00      	cmp	r3, #0
 801a59c:	d113      	bne.n	801a5c6 <strptime+0x382>
				tm->tm_hour %= 12;
 801a59e:	687b      	ldr	r3, [r7, #4]
 801a5a0:	6899      	ldr	r1, [r3, #8]
 801a5a2:	4b90      	ldr	r3, [pc, #576]	; (801a7e4 <strptime+0x5a0>)
 801a5a4:	fb83 2301 	smull	r2, r3, r3, r1
 801a5a8:	105a      	asrs	r2, r3, #1
 801a5aa:	17cb      	asrs	r3, r1, #31
 801a5ac:	1ad2      	subs	r2, r2, r3
 801a5ae:	4613      	mov	r3, r2
 801a5b0:	005b      	lsls	r3, r3, #1
 801a5b2:	4413      	add	r3, r2
 801a5b4:	009b      	lsls	r3, r3, #2
 801a5b6:	1aca      	subs	r2, r1, r3
 801a5b8:	687b      	ldr	r3, [r7, #4]
 801a5ba:	609a      	str	r2, [r3, #8]
				s += len;
 801a5bc:	68fa      	ldr	r2, [r7, #12]
 801a5be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a5c0:	4413      	add	r3, r2
 801a5c2:	60fb      	str	r3, [r7, #12]
				break;
 801a5c4:	e17b      	b.n	801a8be <strptime+0x67a>
			}
			ex = nl_langinfo(PM_STR);
 801a5c6:	4888      	ldr	r0, [pc, #544]	; (801a7e8 <strptime+0x5a4>)
 801a5c8:	f000 fa0c 	bl	801a9e4 <__nl_langinfo>
 801a5cc:	6478      	str	r0, [r7, #68]	; 0x44
			len = strlen(ex);
 801a5ce:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801a5d0:	f7f4 ffbd 	bl	800f54e <strlen>
 801a5d4:	64b8      	str	r0, [r7, #72]	; 0x48
			if (!strncasecmp(s, ex, len)) {
 801a5d6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801a5d8:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a5da:	68f8      	ldr	r0, [r7, #12]
 801a5dc:	f003 fc45 	bl	801de6a <strncasecmp>
 801a5e0:	4603      	mov	r3, r0
 801a5e2:	2b00      	cmp	r3, #0
 801a5e4:	d119      	bne.n	801a61a <strptime+0x3d6>
				tm->tm_hour %= 12;
 801a5e6:	687b      	ldr	r3, [r7, #4]
 801a5e8:	6899      	ldr	r1, [r3, #8]
 801a5ea:	4b7e      	ldr	r3, [pc, #504]	; (801a7e4 <strptime+0x5a0>)
 801a5ec:	fb83 2301 	smull	r2, r3, r3, r1
 801a5f0:	105a      	asrs	r2, r3, #1
 801a5f2:	17cb      	asrs	r3, r1, #31
 801a5f4:	1ad2      	subs	r2, r2, r3
 801a5f6:	4613      	mov	r3, r2
 801a5f8:	005b      	lsls	r3, r3, #1
 801a5fa:	4413      	add	r3, r2
 801a5fc:	009b      	lsls	r3, r3, #2
 801a5fe:	1aca      	subs	r2, r1, r3
 801a600:	687b      	ldr	r3, [r7, #4]
 801a602:	609a      	str	r2, [r3, #8]
				tm->tm_hour += 12;
 801a604:	687b      	ldr	r3, [r7, #4]
 801a606:	689b      	ldr	r3, [r3, #8]
 801a608:	f103 020c 	add.w	r2, r3, #12
 801a60c:	687b      	ldr	r3, [r7, #4]
 801a60e:	609a      	str	r2, [r3, #8]
				s += len;
 801a610:	68fa      	ldr	r2, [r7, #12]
 801a612:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a614:	4413      	add	r3, r2
 801a616:	60fb      	str	r3, [r7, #12]
				break;
 801a618:	e151      	b.n	801a8be <strptime+0x67a>
			}
			return 0;
 801a61a:	2300      	movs	r3, #0
 801a61c:	e176      	b.n	801a90c <strptime+0x6c8>
		case 'r':
			s = strptime(s, nl_langinfo(T_FMT_AMPM), tm);
 801a61e:	4873      	ldr	r0, [pc, #460]	; (801a7ec <strptime+0x5a8>)
 801a620:	f000 f9e0 	bl	801a9e4 <__nl_langinfo>
 801a624:	4603      	mov	r3, r0
 801a626:	687a      	ldr	r2, [r7, #4]
 801a628:	4619      	mov	r1, r3
 801a62a:	68f8      	ldr	r0, [r7, #12]
 801a62c:	f7ff fe0a 	bl	801a244 <strptime>
 801a630:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a632:	68fb      	ldr	r3, [r7, #12]
 801a634:	2b00      	cmp	r3, #0
 801a636:	f040 8142 	bne.w	801a8be <strptime+0x67a>
 801a63a:	2300      	movs	r3, #0
 801a63c:	e166      	b.n	801a90c <strptime+0x6c8>
			break;
		case 'R':
			s = strptime(s, "%H:%M", tm);
 801a63e:	687a      	ldr	r2, [r7, #4]
 801a640:	496b      	ldr	r1, [pc, #428]	; (801a7f0 <strptime+0x5ac>)
 801a642:	68f8      	ldr	r0, [r7, #12]
 801a644:	f7ff fdfe 	bl	801a244 <strptime>
 801a648:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a64a:	68fb      	ldr	r3, [r7, #12]
 801a64c:	2b00      	cmp	r3, #0
 801a64e:	f040 8136 	bne.w	801a8be <strptime+0x67a>
 801a652:	2300      	movs	r3, #0
 801a654:	e15a      	b.n	801a90c <strptime+0x6c8>
			break;
		case 'S':
			dest = &tm->tm_sec;
 801a656:	687b      	ldr	r3, [r7, #4]
 801a658:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 0;
 801a65a:	2300      	movs	r3, #0
 801a65c:	637b      	str	r3, [r7, #52]	; 0x34
			range = 61;
 801a65e:	233d      	movs	r3, #61	; 0x3d
 801a660:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a662:	e05e      	b.n	801a722 <strptime+0x4de>
		case 'T':
			s = strptime(s, "%H:%M:%S", tm);
 801a664:	687a      	ldr	r2, [r7, #4]
 801a666:	4963      	ldr	r1, [pc, #396]	; (801a7f4 <strptime+0x5b0>)
 801a668:	68f8      	ldr	r0, [r7, #12]
 801a66a:	f7ff fdeb 	bl	801a244 <strptime>
 801a66e:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a670:	68fb      	ldr	r3, [r7, #12]
 801a672:	2b00      	cmp	r3, #0
 801a674:	f040 8123 	bne.w	801a8be <strptime+0x67a>
 801a678:	2300      	movs	r3, #0
 801a67a:	e147      	b.n	801a90c <strptime+0x6c8>
			break;
		case 'U':
		case 'W':
			/* Throw away result, for now. (FIXME?) */
			dest = &dummy;
 801a67c:	f107 0314 	add.w	r3, r7, #20
 801a680:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 0;
 801a682:	2300      	movs	r3, #0
 801a684:	637b      	str	r3, [r7, #52]	; 0x34
			range = 54;
 801a686:	2336      	movs	r3, #54	; 0x36
 801a688:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a68a:	e04a      	b.n	801a722 <strptime+0x4de>
		case 'w':
			dest = &tm->tm_wday;
 801a68c:	687b      	ldr	r3, [r7, #4]
 801a68e:	3318      	adds	r3, #24
 801a690:	63fb      	str	r3, [r7, #60]	; 0x3c
			min = 0;
 801a692:	2300      	movs	r3, #0
 801a694:	637b      	str	r3, [r7, #52]	; 0x34
			range = 7;
 801a696:	2307      	movs	r3, #7
 801a698:	63bb      	str	r3, [r7, #56]	; 0x38
			goto numeric_range;
 801a69a:	e042      	b.n	801a722 <strptime+0x4de>
		case 'x':
			s = strptime(s, nl_langinfo(D_FMT), tm);
 801a69c:	4856      	ldr	r0, [pc, #344]	; (801a7f8 <strptime+0x5b4>)
 801a69e:	f000 f9a1 	bl	801a9e4 <__nl_langinfo>
 801a6a2:	4603      	mov	r3, r0
 801a6a4:	687a      	ldr	r2, [r7, #4]
 801a6a6:	4619      	mov	r1, r3
 801a6a8:	68f8      	ldr	r0, [r7, #12]
 801a6aa:	f7ff fdcb 	bl	801a244 <strptime>
 801a6ae:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a6b0:	68fb      	ldr	r3, [r7, #12]
 801a6b2:	2b00      	cmp	r3, #0
 801a6b4:	f040 8103 	bne.w	801a8be <strptime+0x67a>
 801a6b8:	2300      	movs	r3, #0
 801a6ba:	e127      	b.n	801a90c <strptime+0x6c8>
			break;
		case 'X':
			s = strptime(s, nl_langinfo(T_FMT), tm);
 801a6bc:	484f      	ldr	r0, [pc, #316]	; (801a7fc <strptime+0x5b8>)
 801a6be:	f000 f991 	bl	801a9e4 <__nl_langinfo>
 801a6c2:	4603      	mov	r3, r0
 801a6c4:	687a      	ldr	r2, [r7, #4]
 801a6c6:	4619      	mov	r1, r3
 801a6c8:	68f8      	ldr	r0, [r7, #12]
 801a6ca:	f7ff fdbb 	bl	801a244 <strptime>
 801a6ce:	60f8      	str	r0, [r7, #12]
			if (!s) return 0;
 801a6d0:	68fb      	ldr	r3, [r7, #12]
 801a6d2:	2b00      	cmp	r3, #0
 801a6d4:	f040 80f3 	bne.w	801a8be <strptime+0x67a>
 801a6d8:	2300      	movs	r3, #0
 801a6da:	e117      	b.n	801a90c <strptime+0x6c8>
			break;
		case 'y':
			dest = &relyear;
 801a6dc:	f107 031c 	add.w	r3, r7, #28
 801a6e0:	63fb      	str	r3, [r7, #60]	; 0x3c
			w = 2;
 801a6e2:	2302      	movs	r3, #2
 801a6e4:	62bb      	str	r3, [r7, #40]	; 0x28
			want_century |= 1;
 801a6e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a6e8:	f043 0301 	orr.w	r3, r3, #1
 801a6ec:	643b      	str	r3, [r7, #64]	; 0x40
			goto numeric_digits;
 801a6ee:	e057      	b.n	801a7a0 <strptime+0x55c>
		case 'Y':
			dest = &tm->tm_year;
 801a6f0:	687b      	ldr	r3, [r7, #4]
 801a6f2:	3314      	adds	r3, #20
 801a6f4:	63fb      	str	r3, [r7, #60]	; 0x3c
			if (w<0) w=4;
 801a6f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a6f8:	2b00      	cmp	r3, #0
 801a6fa:	da01      	bge.n	801a700 <strptime+0x4bc>
 801a6fc:	2304      	movs	r3, #4
 801a6fe:	62bb      	str	r3, [r7, #40]	; 0x28
			adj = 1900;
 801a700:	f240 736c 	movw	r3, #1900	; 0x76c
 801a704:	633b      	str	r3, [r7, #48]	; 0x30
			want_century = 0;
 801a706:	2300      	movs	r3, #0
 801a708:	643b      	str	r3, [r7, #64]	; 0x40
			goto numeric_digits;
 801a70a:	e049      	b.n	801a7a0 <strptime+0x55c>
		case '%':
			if (*s++ != '%') return 0;
 801a70c:	68fb      	ldr	r3, [r7, #12]
 801a70e:	1c5a      	adds	r2, r3, #1
 801a710:	60fa      	str	r2, [r7, #12]
 801a712:	781b      	ldrb	r3, [r3, #0]
 801a714:	2b25      	cmp	r3, #37	; 0x25
 801a716:	f000 80d2 	beq.w	801a8be <strptime+0x67a>
 801a71a:	2300      	movs	r3, #0
 801a71c:	e0f6      	b.n	801a90c <strptime+0x6c8>
			break;
		default:
			return 0;
 801a71e:	2300      	movs	r3, #0
 801a720:	e0f4      	b.n	801a90c <strptime+0x6c8>
		numeric_range:
			if (!isdigit(*s)) return 0;
 801a722:	68fb      	ldr	r3, [r7, #12]
 801a724:	781b      	ldrb	r3, [r3, #0]
 801a726:	3b30      	subs	r3, #48	; 0x30
 801a728:	2b09      	cmp	r3, #9
 801a72a:	d901      	bls.n	801a730 <strptime+0x4ec>
 801a72c:	2300      	movs	r3, #0
 801a72e:	e0ed      	b.n	801a90c <strptime+0x6c8>
			*dest = 0;
 801a730:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a732:	2200      	movs	r2, #0
 801a734:	601a      	str	r2, [r3, #0]
			for (i=1; i<=min+range && isdigit(*s); i*=10)
 801a736:	2301      	movs	r3, #1
 801a738:	627b      	str	r3, [r7, #36]	; 0x24
 801a73a:	e015      	b.n	801a768 <strptime+0x524>
				*dest = *dest * 10 + *s++ - '0';
 801a73c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a73e:	681a      	ldr	r2, [r3, #0]
 801a740:	4613      	mov	r3, r2
 801a742:	009b      	lsls	r3, r3, #2
 801a744:	4413      	add	r3, r2
 801a746:	005b      	lsls	r3, r3, #1
 801a748:	4619      	mov	r1, r3
 801a74a:	68fb      	ldr	r3, [r7, #12]
 801a74c:	1c5a      	adds	r2, r3, #1
 801a74e:	60fa      	str	r2, [r7, #12]
 801a750:	781b      	ldrb	r3, [r3, #0]
 801a752:	440b      	add	r3, r1
 801a754:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 801a758:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a75a:	601a      	str	r2, [r3, #0]
			for (i=1; i<=min+range && isdigit(*s); i*=10)
 801a75c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a75e:	4613      	mov	r3, r2
 801a760:	009b      	lsls	r3, r3, #2
 801a762:	4413      	add	r3, r2
 801a764:	005b      	lsls	r3, r3, #1
 801a766:	627b      	str	r3, [r7, #36]	; 0x24
 801a768:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a76a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a76c:	4413      	add	r3, r2
 801a76e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a770:	429a      	cmp	r2, r3
 801a772:	dc04      	bgt.n	801a77e <strptime+0x53a>
 801a774:	68fb      	ldr	r3, [r7, #12]
 801a776:	781b      	ldrb	r3, [r3, #0]
 801a778:	3b30      	subs	r3, #48	; 0x30
 801a77a:	2b09      	cmp	r3, #9
 801a77c:	d9de      	bls.n	801a73c <strptime+0x4f8>
			if (*dest - min >= (unsigned)range) return 0;
 801a77e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a780:	681a      	ldr	r2, [r3, #0]
 801a782:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a784:	1ad3      	subs	r3, r2, r3
 801a786:	461a      	mov	r2, r3
 801a788:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a78a:	429a      	cmp	r2, r3
 801a78c:	d301      	bcc.n	801a792 <strptime+0x54e>
 801a78e:	2300      	movs	r3, #0
 801a790:	e0bc      	b.n	801a90c <strptime+0x6c8>
			*dest -= adj;
 801a792:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a794:	681a      	ldr	r2, [r3, #0]
 801a796:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a798:	1ad2      	subs	r2, r2, r3
 801a79a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a79c:	601a      	str	r2, [r3, #0]
			switch((char *)dest - (char *)tm) {
			case offsetof(struct tm, tm_yday):
				;
			}
			goto update;
 801a79e:	e08e      	b.n	801a8be <strptime+0x67a>
		numeric_digits:
			neg = 0;
 801a7a0:	2300      	movs	r3, #0
 801a7a2:	62fb      	str	r3, [r7, #44]	; 0x2c
			if (*s == '+') s++;
 801a7a4:	68fb      	ldr	r3, [r7, #12]
 801a7a6:	781b      	ldrb	r3, [r3, #0]
 801a7a8:	2b2b      	cmp	r3, #43	; 0x2b
 801a7aa:	d103      	bne.n	801a7b4 <strptime+0x570>
 801a7ac:	68fb      	ldr	r3, [r7, #12]
 801a7ae:	3301      	adds	r3, #1
 801a7b0:	60fb      	str	r3, [r7, #12]
 801a7b2:	e008      	b.n	801a7c6 <strptime+0x582>
			else if (*s == '-') neg=1, s++;
 801a7b4:	68fb      	ldr	r3, [r7, #12]
 801a7b6:	781b      	ldrb	r3, [r3, #0]
 801a7b8:	2b2d      	cmp	r3, #45	; 0x2d
 801a7ba:	d104      	bne.n	801a7c6 <strptime+0x582>
 801a7bc:	2301      	movs	r3, #1
 801a7be:	62fb      	str	r3, [r7, #44]	; 0x2c
 801a7c0:	68fb      	ldr	r3, [r7, #12]
 801a7c2:	3301      	adds	r3, #1
 801a7c4:	60fb      	str	r3, [r7, #12]
			if (!isdigit(*s)) return 0;
 801a7c6:	68fb      	ldr	r3, [r7, #12]
 801a7c8:	781b      	ldrb	r3, [r3, #0]
 801a7ca:	3b30      	subs	r3, #48	; 0x30
 801a7cc:	2b09      	cmp	r3, #9
 801a7ce:	d901      	bls.n	801a7d4 <strptime+0x590>
 801a7d0:	2300      	movs	r3, #0
 801a7d2:	e09b      	b.n	801a90c <strptime+0x6c8>
			for (*dest=i=0; i<w && isdigit(*s); i++)
 801a7d4:	2300      	movs	r3, #0
 801a7d6:	627b      	str	r3, [r7, #36]	; 0x24
 801a7d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a7da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a7dc:	601a      	str	r2, [r3, #0]
 801a7de:	e022      	b.n	801a826 <strptime+0x5e2>
 801a7e0:	00020026 	.word	0x00020026
 801a7e4:	2aaaaaab 	.word	0x2aaaaaab
 801a7e8:	00020027 	.word	0x00020027
 801a7ec:	0002002b 	.word	0x0002002b
 801a7f0:	08023140 	.word	0x08023140
 801a7f4:	08023148 	.word	0x08023148
 801a7f8:	00020029 	.word	0x00020029
 801a7fc:	0002002a 	.word	0x0002002a
				*dest = *dest * 10 + *s++ - '0';
 801a800:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a802:	681a      	ldr	r2, [r3, #0]
 801a804:	4613      	mov	r3, r2
 801a806:	009b      	lsls	r3, r3, #2
 801a808:	4413      	add	r3, r2
 801a80a:	005b      	lsls	r3, r3, #1
 801a80c:	4619      	mov	r1, r3
 801a80e:	68fb      	ldr	r3, [r7, #12]
 801a810:	1c5a      	adds	r2, r3, #1
 801a812:	60fa      	str	r2, [r7, #12]
 801a814:	781b      	ldrb	r3, [r3, #0]
 801a816:	440b      	add	r3, r1
 801a818:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 801a81c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a81e:	601a      	str	r2, [r3, #0]
			for (*dest=i=0; i<w && isdigit(*s); i++)
 801a820:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a822:	3301      	adds	r3, #1
 801a824:	627b      	str	r3, [r7, #36]	; 0x24
 801a826:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a828:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a82a:	429a      	cmp	r2, r3
 801a82c:	da04      	bge.n	801a838 <strptime+0x5f4>
 801a82e:	68fb      	ldr	r3, [r7, #12]
 801a830:	781b      	ldrb	r3, [r3, #0]
 801a832:	3b30      	subs	r3, #48	; 0x30
 801a834:	2b09      	cmp	r3, #9
 801a836:	d9e3      	bls.n	801a800 <strptime+0x5bc>
			if (neg) *dest = -*dest;
 801a838:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a83a:	2b00      	cmp	r3, #0
 801a83c:	d004      	beq.n	801a848 <strptime+0x604>
 801a83e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a840:	681b      	ldr	r3, [r3, #0]
 801a842:	425a      	negs	r2, r3
 801a844:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a846:	601a      	str	r2, [r3, #0]
			*dest -= adj;
 801a848:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a84a:	681a      	ldr	r2, [r3, #0]
 801a84c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a84e:	1ad2      	subs	r2, r2, r3
 801a850:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a852:	601a      	str	r2, [r3, #0]
			goto update;
 801a854:	e033      	b.n	801a8be <strptime+0x67a>
		symbolic_range:
			for (i=2*range-1; i>=0; i--) {
 801a856:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a858:	005b      	lsls	r3, r3, #1
 801a85a:	3b01      	subs	r3, #1
 801a85c:	627b      	str	r3, [r7, #36]	; 0x24
 801a85e:	e025      	b.n	801a8ac <strptime+0x668>
				ex = nl_langinfo(min+i);
 801a860:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a862:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a864:	4413      	add	r3, r2
 801a866:	4618      	mov	r0, r3
 801a868:	f000 f8bc 	bl	801a9e4 <__nl_langinfo>
 801a86c:	6478      	str	r0, [r7, #68]	; 0x44
				len = strlen(ex);
 801a86e:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801a870:	f7f4 fe6d 	bl	800f54e <strlen>
 801a874:	64b8      	str	r0, [r7, #72]	; 0x48
				if (strncasecmp(s, ex, len)) continue;
 801a876:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801a878:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a87a:	68f8      	ldr	r0, [r7, #12]
 801a87c:	f003 faf5 	bl	801de6a <strncasecmp>
 801a880:	4603      	mov	r3, r0
 801a882:	2b00      	cmp	r3, #0
 801a884:	d003      	beq.n	801a88e <strptime+0x64a>
			for (i=2*range-1; i>=0; i--) {
 801a886:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a888:	3b01      	subs	r3, #1
 801a88a:	627b      	str	r3, [r7, #36]	; 0x24
 801a88c:	e00e      	b.n	801a8ac <strptime+0x668>
				s += len;
 801a88e:	68fa      	ldr	r2, [r7, #12]
 801a890:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a892:	4413      	add	r3, r2
 801a894:	60fb      	str	r3, [r7, #12]
				*dest = i % range;
 801a896:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a898:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a89a:	fb93 f2f2 	sdiv	r2, r3, r2
 801a89e:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801a8a0:	fb01 f202 	mul.w	r2, r1, r2
 801a8a4:	1a9a      	subs	r2, r3, r2
 801a8a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a8a8:	601a      	str	r2, [r3, #0]
				break;
 801a8aa:	e002      	b.n	801a8b2 <strptime+0x66e>
			for (i=2*range-1; i>=0; i--) {
 801a8ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a8ae:	2b00      	cmp	r3, #0
 801a8b0:	dad6      	bge.n	801a860 <strptime+0x61c>
			}
			if (i<0) return 0;
 801a8b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a8b4:	2b00      	cmp	r3, #0
 801a8b6:	da01      	bge.n	801a8bc <strptime+0x678>
 801a8b8:	2300      	movs	r3, #0
 801a8ba:	e027      	b.n	801a90c <strptime+0x6c8>
			goto update;
 801a8bc:	bf00      	nop
	while (*f) {
 801a8be:	68bb      	ldr	r3, [r7, #8]
 801a8c0:	781b      	ldrb	r3, [r3, #0]
 801a8c2:	2b00      	cmp	r3, #0
 801a8c4:	f47f acd0 	bne.w	801a268 <strptime+0x24>
		update:
			//FIXME
			;
		}
	}
	if (want_century) {
 801a8c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a8ca:	2b00      	cmp	r3, #0
 801a8cc:	d01d      	beq.n	801a90a <strptime+0x6c6>
		tm->tm_year = relyear;
 801a8ce:	69fa      	ldr	r2, [r7, #28]
 801a8d0:	687b      	ldr	r3, [r7, #4]
 801a8d2:	615a      	str	r2, [r3, #20]
		if (want_century & 2) tm->tm_year += century * 100 - 1900;
 801a8d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a8d6:	f003 0302 	and.w	r3, r3, #2
 801a8da:	2b00      	cmp	r3, #0
 801a8dc:	d00b      	beq.n	801a8f6 <strptime+0x6b2>
 801a8de:	687b      	ldr	r3, [r7, #4]
 801a8e0:	695a      	ldr	r2, [r3, #20]
 801a8e2:	69bb      	ldr	r3, [r7, #24]
 801a8e4:	2164      	movs	r1, #100	; 0x64
 801a8e6:	fb01 f303 	mul.w	r3, r1, r3
 801a8ea:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
 801a8ee:	441a      	add	r2, r3
 801a8f0:	687b      	ldr	r3, [r7, #4]
 801a8f2:	615a      	str	r2, [r3, #20]
 801a8f4:	e009      	b.n	801a90a <strptime+0x6c6>
		else if (tm->tm_year <= 68) tm->tm_year += 100;
 801a8f6:	687b      	ldr	r3, [r7, #4]
 801a8f8:	695b      	ldr	r3, [r3, #20]
 801a8fa:	2b44      	cmp	r3, #68	; 0x44
 801a8fc:	dc05      	bgt.n	801a90a <strptime+0x6c6>
 801a8fe:	687b      	ldr	r3, [r7, #4]
 801a900:	695b      	ldr	r3, [r3, #20]
 801a902:	f103 0264 	add.w	r2, r3, #100	; 0x64
 801a906:	687b      	ldr	r3, [r7, #4]
 801a908:	615a      	str	r2, [r3, #20]
	}
	return (char *)s;
 801a90a:	68fb      	ldr	r3, [r7, #12]
}
 801a90c:	4a05      	ldr	r2, [pc, #20]	; (801a924 <strptime+0x6e0>)
 801a90e:	6811      	ldr	r1, [r2, #0]
 801a910:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801a912:	4051      	eors	r1, r2
 801a914:	d001      	beq.n	801a91a <strptime+0x6d6>
 801a916:	f7e9 fe61 	bl	80045dc <__stack_chk_fail>
 801a91a:	4618      	mov	r0, r3
 801a91c:	3750      	adds	r7, #80	; 0x50
 801a91e:	46bd      	mov	sp, r7
 801a920:	bd80      	pop	{r7, pc}
 801a922:	bf00      	nop
 801a924:	08023154 	.word	0x08023154

0801a928 <__nl_langinfo_l>:

static const char c_messages[] = "^[yY]\0" "^[nN]\0" "yes\0" "no";
static const char c_numeric[] = ".\0" "";

char *__nl_langinfo_l(nl_item item, locale_t loc)
{
 801a928:	b480      	push	{r7}
 801a92a:	b087      	sub	sp, #28
 801a92c:	af00      	add	r7, sp, #0
 801a92e:	6078      	str	r0, [r7, #4]
 801a930:	6039      	str	r1, [r7, #0]
	int cat = item >> 16;
 801a932:	687b      	ldr	r3, [r7, #4]
 801a934:	141b      	asrs	r3, r3, #16
 801a936:	617b      	str	r3, [r7, #20]
	int idx = item & 65535;
 801a938:	687b      	ldr	r3, [r7, #4]
 801a93a:	b29b      	uxth	r3, r3
 801a93c:	60fb      	str	r3, [r7, #12]
 801a93e:	697b      	ldr	r3, [r7, #20]
 801a940:	3b01      	subs	r3, #1
 801a942:	2b04      	cmp	r3, #4
 801a944:	d82c      	bhi.n	801a9a0 <__nl_langinfo_l+0x78>
 801a946:	a201      	add	r2, pc, #4	; (adr r2, 801a94c <__nl_langinfo_l+0x24>)
 801a948:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a94c:	0801a961 	.word	0x0801a961
 801a950:	0801a971 	.word	0x0801a971
 801a954:	0801a9a1 	.word	0x0801a9a1
 801a958:	0801a981 	.word	0x0801a981
 801a95c:	0801a991 	.word	0x0801a991
		return loc->cat[cat] ? (char *)loc->cat[cat]->name : "C";
#endif
	
	switch (cat) {
	case LC_NUMERIC:
		if (idx > 1) return "";
 801a960:	68fb      	ldr	r3, [r7, #12]
 801a962:	2b01      	cmp	r3, #1
 801a964:	dd01      	ble.n	801a96a <__nl_langinfo_l+0x42>
 801a966:	4b1b      	ldr	r3, [pc, #108]	; (801a9d4 <__nl_langinfo_l+0xac>)
 801a968:	e02e      	b.n	801a9c8 <__nl_langinfo_l+0xa0>
		str = c_numeric;
 801a96a:	4b1b      	ldr	r3, [pc, #108]	; (801a9d8 <__nl_langinfo_l+0xb0>)
 801a96c:	613b      	str	r3, [r7, #16]
		break;
 801a96e:	e019      	b.n	801a9a4 <__nl_langinfo_l+0x7c>
	case LC_TIME:
		if (idx > 0x31) return "";
 801a970:	68fb      	ldr	r3, [r7, #12]
 801a972:	2b31      	cmp	r3, #49	; 0x31
 801a974:	dd01      	ble.n	801a97a <__nl_langinfo_l+0x52>
 801a976:	4b17      	ldr	r3, [pc, #92]	; (801a9d4 <__nl_langinfo_l+0xac>)
 801a978:	e026      	b.n	801a9c8 <__nl_langinfo_l+0xa0>
		str = c_time;
 801a97a:	4b18      	ldr	r3, [pc, #96]	; (801a9dc <__nl_langinfo_l+0xb4>)
 801a97c:	613b      	str	r3, [r7, #16]
		break;
 801a97e:	e011      	b.n	801a9a4 <__nl_langinfo_l+0x7c>
	case LC_MONETARY:
		if (idx > 0) return "";
 801a980:	68fb      	ldr	r3, [r7, #12]
 801a982:	2b00      	cmp	r3, #0
 801a984:	dd01      	ble.n	801a98a <__nl_langinfo_l+0x62>
 801a986:	4b13      	ldr	r3, [pc, #76]	; (801a9d4 <__nl_langinfo_l+0xac>)
 801a988:	e01e      	b.n	801a9c8 <__nl_langinfo_l+0xa0>
		str = "";
 801a98a:	4b12      	ldr	r3, [pc, #72]	; (801a9d4 <__nl_langinfo_l+0xac>)
 801a98c:	613b      	str	r3, [r7, #16]
		break;
 801a98e:	e009      	b.n	801a9a4 <__nl_langinfo_l+0x7c>
	case LC_MESSAGES:
		if (idx > 3) return "";
 801a990:	68fb      	ldr	r3, [r7, #12]
 801a992:	2b03      	cmp	r3, #3
 801a994:	dd01      	ble.n	801a99a <__nl_langinfo_l+0x72>
 801a996:	4b0f      	ldr	r3, [pc, #60]	; (801a9d4 <__nl_langinfo_l+0xac>)
 801a998:	e016      	b.n	801a9c8 <__nl_langinfo_l+0xa0>
		str = c_messages;
 801a99a:	4b11      	ldr	r3, [pc, #68]	; (801a9e0 <__nl_langinfo_l+0xb8>)
 801a99c:	613b      	str	r3, [r7, #16]
		break;
 801a99e:	e001      	b.n	801a9a4 <__nl_langinfo_l+0x7c>
	default:
		return "";
 801a9a0:	4b0c      	ldr	r3, [pc, #48]	; (801a9d4 <__nl_langinfo_l+0xac>)
 801a9a2:	e011      	b.n	801a9c8 <__nl_langinfo_l+0xa0>
	}

	for (; idx; idx--, str++) for (; *str; str++);
 801a9a4:	e00c      	b.n	801a9c0 <__nl_langinfo_l+0x98>
 801a9a6:	693b      	ldr	r3, [r7, #16]
 801a9a8:	3301      	adds	r3, #1
 801a9aa:	613b      	str	r3, [r7, #16]
 801a9ac:	693b      	ldr	r3, [r7, #16]
 801a9ae:	781b      	ldrb	r3, [r3, #0]
 801a9b0:	2b00      	cmp	r3, #0
 801a9b2:	d1f8      	bne.n	801a9a6 <__nl_langinfo_l+0x7e>
 801a9b4:	68fb      	ldr	r3, [r7, #12]
 801a9b6:	3b01      	subs	r3, #1
 801a9b8:	60fb      	str	r3, [r7, #12]
 801a9ba:	693b      	ldr	r3, [r7, #16]
 801a9bc:	3301      	adds	r3, #1
 801a9be:	613b      	str	r3, [r7, #16]
 801a9c0:	68fb      	ldr	r3, [r7, #12]
 801a9c2:	2b00      	cmp	r3, #0
 801a9c4:	d1f2      	bne.n	801a9ac <__nl_langinfo_l+0x84>
#ifndef __LITEOS__
	if (cat != LC_NUMERIC && *str) str = LCTRANS(str, cat, loc);
#endif
	return (char *)str;
 801a9c6:	693b      	ldr	r3, [r7, #16]
}
 801a9c8:	4618      	mov	r0, r3
 801a9ca:	371c      	adds	r7, #28
 801a9cc:	46bd      	mov	sp, r7
 801a9ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a9d2:	4770      	bx	lr
 801a9d4:	08023158 	.word	0x08023158
 801a9d8:	08023964 	.word	0x08023964
 801a9dc:	08023814 	.word	0x08023814
 801a9e0:	08023950 	.word	0x08023950

0801a9e4 <__nl_langinfo>:

char *__nl_langinfo(nl_item item)
{
 801a9e4:	b580      	push	{r7, lr}
 801a9e6:	b082      	sub	sp, #8
 801a9e8:	af00      	add	r7, sp, #0
 801a9ea:	6078      	str	r0, [r7, #4]
	return __nl_langinfo_l(item, CURRENT_LOCALE);
 801a9ec:	2101      	movs	r1, #1
 801a9ee:	6878      	ldr	r0, [r7, #4]
 801a9f0:	f7ff ff9a 	bl	801a928 <__nl_langinfo_l>
 801a9f4:	4603      	mov	r3, r0
}
 801a9f6:	4618      	mov	r0, r3
 801a9f8:	3708      	adds	r7, #8
 801a9fa:	46bd      	mov	sp, r7
 801a9fc:	bd80      	pop	{r7, pc}
	...

0801aa00 <free>:
 * realloc. The argument ptr points to the space that was previously allocated.
 * If ptr points to a memory block that was not allocated with calloc, malloc,
 * or realloc, or is a space that has been deallocated, then the result is undefined.
 */
void free(void *ptr)
{
 801aa00:	b580      	push	{r7, lr}
 801aa02:	b082      	sub	sp, #8
 801aa04:	af00      	add	r7, sp, #0
 801aa06:	6078      	str	r0, [r7, #4]
    if (ptr == NULL) {
 801aa08:	687b      	ldr	r3, [r7, #4]
 801aa0a:	2b00      	cmp	r3, #0
 801aa0c:	d006      	beq.n	801aa1c <free+0x1c>
        return;
    }

    (void)LOS_MemFree((void *)OS_SYS_MEM_ADDR, ptr);
 801aa0e:	4b05      	ldr	r3, [pc, #20]	; (801aa24 <free+0x24>)
 801aa10:	681b      	ldr	r3, [r3, #0]
 801aa12:	6879      	ldr	r1, [r7, #4]
 801aa14:	4618      	mov	r0, r3
 801aa16:	f7ee fdb5 	bl	8009584 <LOS_MemFree>
 801aa1a:	e000      	b.n	801aa1e <free+0x1e>
        return;
 801aa1c:	bf00      	nop
}
 801aa1e:	3708      	adds	r7, #8
 801aa20:	46bd      	mov	sp, r7
 801aa22:	bd80      	pop	{r7, pc}
 801aa24:	080001f0 	.word	0x080001f0

0801aa28 <malloc>:
/*
 * Allocates the requested memory and returns a pointer to it. The requested
 * size is size bytes. The value of the space is indeterminate.
 */
void *malloc(size_t size)
{
 801aa28:	b580      	push	{r7, lr}
 801aa2a:	b082      	sub	sp, #8
 801aa2c:	af00      	add	r7, sp, #0
 801aa2e:	6078      	str	r0, [r7, #4]
    if (size == 0) {
 801aa30:	687b      	ldr	r3, [r7, #4]
 801aa32:	2b00      	cmp	r3, #0
 801aa34:	d101      	bne.n	801aa3a <malloc+0x12>
        return NULL;
 801aa36:	2300      	movs	r3, #0
 801aa38:	e006      	b.n	801aa48 <malloc+0x20>
    }

    return (void *)LOS_MemAlloc((void *)OS_SYS_MEM_ADDR, (UINT32)size);
 801aa3a:	4b05      	ldr	r3, [pc, #20]	; (801aa50 <malloc+0x28>)
 801aa3c:	681b      	ldr	r3, [r3, #0]
 801aa3e:	6879      	ldr	r1, [r7, #4]
 801aa40:	4618      	mov	r0, r3
 801aa42:	f7ee fce7 	bl	8009414 <LOS_MemAlloc>
 801aa46:	4603      	mov	r3, r0
}
 801aa48:	4618      	mov	r0, r3
 801aa4a:	3708      	adds	r7, #8
 801aa4c:	46bd      	mov	sp, r7
 801aa4e:	bd80      	pop	{r7, pc}
 801aa50:	080001f0 	.word	0x080001f0

0801aa54 <snprintf>:
#include <stdio.h>
#include <stdarg.h>

int snprintf(char *restrict s, size_t n, const char *restrict fmt, ...)
{
 801aa54:	b40c      	push	{r2, r3}
 801aa56:	b580      	push	{r7, lr}
 801aa58:	b088      	sub	sp, #32
 801aa5a:	af00      	add	r7, sp, #0
 801aa5c:	60f8      	str	r0, [r7, #12]
 801aa5e:	60b9      	str	r1, [r7, #8]
 801aa60:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801aa62:	607b      	str	r3, [r7, #4]
 801aa64:	4b0e      	ldr	r3, [pc, #56]	; (801aaa0 <snprintf+0x4c>)
 801aa66:	681b      	ldr	r3, [r3, #0]
 801aa68:	61fb      	str	r3, [r7, #28]
 801aa6a:	f04f 0300 	mov.w	r3, #0
	int ret;
	va_list ap;
	va_start(ap, fmt);
 801aa6e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801aa72:	617b      	str	r3, [r7, #20]
	ret = vsnprintf(s, n, fmt, ap);
 801aa74:	697b      	ldr	r3, [r7, #20]
 801aa76:	687a      	ldr	r2, [r7, #4]
 801aa78:	68b9      	ldr	r1, [r7, #8]
 801aa7a:	68f8      	ldr	r0, [r7, #12]
 801aa7c:	f000 f87e 	bl	801ab7c <vsnprintf>
 801aa80:	61b8      	str	r0, [r7, #24]
	va_end(ap);
	return ret;
 801aa82:	69bb      	ldr	r3, [r7, #24]
}
 801aa84:	4a06      	ldr	r2, [pc, #24]	; (801aaa0 <snprintf+0x4c>)
 801aa86:	6811      	ldr	r1, [r2, #0]
 801aa88:	69fa      	ldr	r2, [r7, #28]
 801aa8a:	4051      	eors	r1, r2
 801aa8c:	d001      	beq.n	801aa92 <snprintf+0x3e>
 801aa8e:	f7e9 fda5 	bl	80045dc <__stack_chk_fail>
 801aa92:	4618      	mov	r0, r3
 801aa94:	3720      	adds	r7, #32
 801aa96:	46bd      	mov	sp, r7
 801aa98:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 801aa9c:	b002      	add	sp, #8
 801aa9e:	4770      	bx	lr
 801aaa0:	0802315c 	.word	0x0802315c

0801aaa4 <vsprintf>:
#include <stdio.h>
#include <limits.h>

int vsprintf(char *restrict s, const char *restrict fmt, va_list ap)
{
 801aaa4:	b580      	push	{r7, lr}
 801aaa6:	b084      	sub	sp, #16
 801aaa8:	af00      	add	r7, sp, #0
 801aaaa:	60f8      	str	r0, [r7, #12]
 801aaac:	60b9      	str	r1, [r7, #8]
 801aaae:	607a      	str	r2, [r7, #4]
	return vsnprintf(s, INT_MAX, fmt, ap);
 801aab0:	687b      	ldr	r3, [r7, #4]
 801aab2:	68ba      	ldr	r2, [r7, #8]
 801aab4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 801aab8:	68f8      	ldr	r0, [r7, #12]
 801aaba:	f000 f85f 	bl	801ab7c <vsnprintf>
 801aabe:	4603      	mov	r3, r0
}
 801aac0:	4618      	mov	r0, r3
 801aac2:	3710      	adds	r7, #16
 801aac4:	46bd      	mov	sp, r7
 801aac6:	bd80      	pop	{r7, pc}

0801aac8 <sn_write>:
};

#define MIN(a, b) ((a) < (b) ? (a) : (b))

static size_t sn_write(FILE *f, const unsigned char *s, size_t l)
{
 801aac8:	b580      	push	{r7, lr}
 801aaca:	b086      	sub	sp, #24
 801aacc:	af00      	add	r7, sp, #0
 801aace:	60f8      	str	r0, [r7, #12]
 801aad0:	60b9      	str	r1, [r7, #8]
 801aad2:	607a      	str	r2, [r7, #4]
	struct cookie *c = f->cookie;
 801aad4:	68fb      	ldr	r3, [r7, #12]
 801aad6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801aad8:	613b      	str	r3, [r7, #16]
	size_t k = MIN(c->n, (size_t)(f->wpos - f->wbase));
 801aada:	68fb      	ldr	r3, [r7, #12]
 801aadc:	695a      	ldr	r2, [r3, #20]
 801aade:	68fb      	ldr	r3, [r7, #12]
 801aae0:	69db      	ldr	r3, [r3, #28]
 801aae2:	1ad3      	subs	r3, r2, r3
 801aae4:	461a      	mov	r2, r3
 801aae6:	693b      	ldr	r3, [r7, #16]
 801aae8:	685b      	ldr	r3, [r3, #4]
 801aaea:	4293      	cmp	r3, r2
 801aaec:	bf28      	it	cs
 801aaee:	4613      	movcs	r3, r2
 801aaf0:	617b      	str	r3, [r7, #20]
	if (k) {
 801aaf2:	697b      	ldr	r3, [r7, #20]
 801aaf4:	2b00      	cmp	r3, #0
 801aaf6:	d013      	beq.n	801ab20 <sn_write+0x58>
		memcpy(c->s, f->wbase, k);
 801aaf8:	693b      	ldr	r3, [r7, #16]
 801aafa:	6818      	ldr	r0, [r3, #0]
 801aafc:	68fb      	ldr	r3, [r7, #12]
 801aafe:	69db      	ldr	r3, [r3, #28]
 801ab00:	697a      	ldr	r2, [r7, #20]
 801ab02:	4619      	mov	r1, r3
 801ab04:	f7fe fafa 	bl	80190fc <memcpy>
		c->s += k;
 801ab08:	693b      	ldr	r3, [r7, #16]
 801ab0a:	681a      	ldr	r2, [r3, #0]
 801ab0c:	697b      	ldr	r3, [r7, #20]
 801ab0e:	441a      	add	r2, r3
 801ab10:	693b      	ldr	r3, [r7, #16]
 801ab12:	601a      	str	r2, [r3, #0]
		c->n -= k;
 801ab14:	693b      	ldr	r3, [r7, #16]
 801ab16:	685a      	ldr	r2, [r3, #4]
 801ab18:	697b      	ldr	r3, [r7, #20]
 801ab1a:	1ad2      	subs	r2, r2, r3
 801ab1c:	693b      	ldr	r3, [r7, #16]
 801ab1e:	605a      	str	r2, [r3, #4]
	}
	k = MIN(c->n, l);
 801ab20:	693b      	ldr	r3, [r7, #16]
 801ab22:	685b      	ldr	r3, [r3, #4]
 801ab24:	687a      	ldr	r2, [r7, #4]
 801ab26:	4293      	cmp	r3, r2
 801ab28:	bf28      	it	cs
 801ab2a:	4613      	movcs	r3, r2
 801ab2c:	617b      	str	r3, [r7, #20]
	if (k) {
 801ab2e:	697b      	ldr	r3, [r7, #20]
 801ab30:	2b00      	cmp	r3, #0
 801ab32:	d012      	beq.n	801ab5a <sn_write+0x92>
		memcpy(c->s, s, k);
 801ab34:	693b      	ldr	r3, [r7, #16]
 801ab36:	681b      	ldr	r3, [r3, #0]
 801ab38:	697a      	ldr	r2, [r7, #20]
 801ab3a:	68b9      	ldr	r1, [r7, #8]
 801ab3c:	4618      	mov	r0, r3
 801ab3e:	f7fe fadd 	bl	80190fc <memcpy>
		c->s += k;
 801ab42:	693b      	ldr	r3, [r7, #16]
 801ab44:	681a      	ldr	r2, [r3, #0]
 801ab46:	697b      	ldr	r3, [r7, #20]
 801ab48:	441a      	add	r2, r3
 801ab4a:	693b      	ldr	r3, [r7, #16]
 801ab4c:	601a      	str	r2, [r3, #0]
		c->n -= k;
 801ab4e:	693b      	ldr	r3, [r7, #16]
 801ab50:	685a      	ldr	r2, [r3, #4]
 801ab52:	697b      	ldr	r3, [r7, #20]
 801ab54:	1ad2      	subs	r2, r2, r3
 801ab56:	693b      	ldr	r3, [r7, #16]
 801ab58:	605a      	str	r2, [r3, #4]
	}
	*c->s = 0;
 801ab5a:	693b      	ldr	r3, [r7, #16]
 801ab5c:	681b      	ldr	r3, [r3, #0]
 801ab5e:	2200      	movs	r2, #0
 801ab60:	701a      	strb	r2, [r3, #0]
	f->wpos = f->wbase = f->buf;
 801ab62:	68fb      	ldr	r3, [r7, #12]
 801ab64:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801ab66:	68fb      	ldr	r3, [r7, #12]
 801ab68:	61da      	str	r2, [r3, #28]
 801ab6a:	68fb      	ldr	r3, [r7, #12]
 801ab6c:	69da      	ldr	r2, [r3, #28]
 801ab6e:	68fb      	ldr	r3, [r7, #12]
 801ab70:	615a      	str	r2, [r3, #20]
	/* pretend to succeed, even if we discarded extra data */
	return l;
 801ab72:	687b      	ldr	r3, [r7, #4]
}
 801ab74:	4618      	mov	r0, r3
 801ab76:	3718      	adds	r7, #24
 801ab78:	46bd      	mov	sp, r7
 801ab7a:	bd80      	pop	{r7, pc}

0801ab7c <vsnprintf>:

int vsnprintf(char *restrict s, size_t n, const char *restrict fmt, va_list ap)
{
 801ab7c:	b580      	push	{r7, lr}
 801ab7e:	b0ae      	sub	sp, #184	; 0xb8
 801ab80:	af00      	add	r7, sp, #0
 801ab82:	60f8      	str	r0, [r7, #12]
 801ab84:	60b9      	str	r1, [r7, #8]
 801ab86:	607a      	str	r2, [r7, #4]
 801ab88:	603b      	str	r3, [r7, #0]
 801ab8a:	4b26      	ldr	r3, [pc, #152]	; (801ac24 <vsnprintf+0xa8>)
 801ab8c:	681b      	ldr	r3, [r3, #0]
 801ab8e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 801ab92:	f04f 0300 	mov.w	r3, #0
	unsigned char buf[1];
	char dummy[1];
	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
 801ab96:	68bb      	ldr	r3, [r7, #8]
 801ab98:	2b00      	cmp	r3, #0
 801ab9a:	d102      	bne.n	801aba2 <vsnprintf+0x26>
 801ab9c:	f107 03b0 	add.w	r3, r7, #176	; 0xb0
 801aba0:	e000      	b.n	801aba4 <vsnprintf+0x28>
 801aba2:	68fb      	ldr	r3, [r7, #12]
 801aba4:	613b      	str	r3, [r7, #16]
 801aba6:	68bb      	ldr	r3, [r7, #8]
 801aba8:	2b00      	cmp	r3, #0
 801abaa:	d002      	beq.n	801abb2 <vsnprintf+0x36>
 801abac:	68bb      	ldr	r3, [r7, #8]
 801abae:	3b01      	subs	r3, #1
 801abb0:	e000      	b.n	801abb4 <vsnprintf+0x38>
 801abb2:	2300      	movs	r3, #0
 801abb4:	617b      	str	r3, [r7, #20]
	FILE f = {
 801abb6:	f107 0318 	add.w	r3, r7, #24
 801abba:	2294      	movs	r2, #148	; 0x94
 801abbc:	2100      	movs	r1, #0
 801abbe:	4618      	mov	r0, r3
 801abc0:	f7f4 fba2 	bl	800f308 <memset>
 801abc4:	4b18      	ldr	r3, [pc, #96]	; (801ac28 <vsnprintf+0xac>)
 801abc6:	63fb      	str	r3, [r7, #60]	; 0x3c
 801abc8:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 801abcc:	64bb      	str	r3, [r7, #72]	; 0x48
 801abce:	f04f 33ff 	mov.w	r3, #4294967295
 801abd2:	66bb      	str	r3, [r7, #104]	; 0x68
 801abd4:	f04f 33ff 	mov.w	r3, #4294967295
 801abd8:	66fb      	str	r3, [r7, #108]	; 0x6c
 801abda:	f107 0310 	add.w	r3, r7, #16
 801abde:	673b      	str	r3, [r7, #112]	; 0x70
		.lock = -1,
		.buf = buf,
		.cookie = &c,
	};

	if (n > INT_MAX) {
 801abe0:	68bb      	ldr	r3, [r7, #8]
 801abe2:	2b00      	cmp	r3, #0
 801abe4:	da07      	bge.n	801abf6 <vsnprintf+0x7a>
		errno = EOVERFLOW;
 801abe6:	f7f5 f9d7 	bl	800ff98 <__errno_location>
 801abea:	4603      	mov	r3, r0
 801abec:	224b      	movs	r2, #75	; 0x4b
 801abee:	601a      	str	r2, [r3, #0]
		return -1;
 801abf0:	f04f 33ff 	mov.w	r3, #4294967295
 801abf4:	e00a      	b.n	801ac0c <vsnprintf+0x90>
	}

	*c.s = 0;
 801abf6:	693b      	ldr	r3, [r7, #16]
 801abf8:	2200      	movs	r2, #0
 801abfa:	701a      	strb	r2, [r3, #0]
	return vfprintf(&f, fmt, ap);
 801abfc:	f107 0318 	add.w	r3, r7, #24
 801ac00:	683a      	ldr	r2, [r7, #0]
 801ac02:	6879      	ldr	r1, [r7, #4]
 801ac04:	4618      	mov	r0, r3
 801ac06:	f002 faaf 	bl	801d168 <vfprintf>
 801ac0a:	4603      	mov	r3, r0
}
 801ac0c:	4a05      	ldr	r2, [pc, #20]	; (801ac24 <vsnprintf+0xa8>)
 801ac0e:	6811      	ldr	r1, [r2, #0]
 801ac10:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 801ac14:	4051      	eors	r1, r2
 801ac16:	d001      	beq.n	801ac1c <vsnprintf+0xa0>
 801ac18:	f7e9 fce0 	bl	80045dc <__stack_chk_fail>
 801ac1c:	4618      	mov	r0, r3
 801ac1e:	37b8      	adds	r7, #184	; 0xb8
 801ac20:	46bd      	mov	sp, r7
 801ac22:	bd80      	pop	{r7, pc}
 801ac24:	08023160 	.word	0x08023160
 801ac28:	0801aac9 	.word	0x0801aac9

0801ac2c <__DOUBLE_BITS>:
	union {float __f; unsigned __i;} __u;
	__u.__f = __f;
	return __u.__i;
}
static __inline unsigned long long __DOUBLE_BITS(double __f)
{
 801ac2c:	b480      	push	{r7}
 801ac2e:	b085      	sub	sp, #20
 801ac30:	af00      	add	r7, sp, #0
 801ac32:	e9c7 0100 	strd	r0, r1, [r7]
	union {double __f; unsigned long long __i;} __u;
	__u.__f = __f;
 801ac36:	e9d7 2300 	ldrd	r2, r3, [r7]
 801ac3a:	e9c7 2302 	strd	r2, r3, [r7, #8]
	return __u.__i;
 801ac3e:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
}
 801ac42:	4610      	mov	r0, r2
 801ac44:	4619      	mov	r1, r3
 801ac46:	3714      	adds	r7, #20
 801ac48:	46bd      	mov	sp, r7
 801ac4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ac4e:	4770      	bx	lr

0801ac50 <pop_arg>:
	ldouble_t f;
	void *p;
};

static void pop_arg(union arg *arg, int type, va_list *ap)
{
 801ac50:	b480      	push	{r7}
 801ac52:	b085      	sub	sp, #20
 801ac54:	af00      	add	r7, sp, #0
 801ac56:	60f8      	str	r0, [r7, #12]
 801ac58:	60b9      	str	r1, [r7, #8]
 801ac5a:	607a      	str	r2, [r7, #4]
 801ac5c:	68bb      	ldr	r3, [r7, #8]
 801ac5e:	3b09      	subs	r3, #9
 801ac60:	2b11      	cmp	r3, #17
 801ac62:	f200 811d 	bhi.w	801aea0 <pop_arg+0x250>
 801ac66:	a201      	add	r2, pc, #4	; (adr r2, 801ac6c <pop_arg+0x1c>)
 801ac68:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801ac6c:	0801acb5 	.word	0x0801acb5
 801ac70:	0801acc7 	.word	0x0801acc7
 801ac74:	0801ace1 	.word	0x0801ace1
 801ac78:	0801ad2f 	.word	0x0801ad2f
 801ac7c:	0801acfb 	.word	0x0801acfb
 801ac80:	0801ad15 	.word	0x0801ad15
 801ac84:	0801ad4d 	.word	0x0801ad4d
 801ac88:	0801ad69 	.word	0x0801ad69
 801ac8c:	0801ad85 	.word	0x0801ad85
 801ac90:	0801ada1 	.word	0x0801ada1
 801ac94:	0801adbd 	.word	0x0801adbd
 801ac98:	0801addb 	.word	0x0801addb
 801ac9c:	0801adf5 	.word	0x0801adf5
 801aca0:	0801ae13 	.word	0x0801ae13
 801aca4:	0801ae31 	.word	0x0801ae31
 801aca8:	0801ae4b 	.word	0x0801ae4b
 801acac:	0801ae65 	.word	0x0801ae65
 801acb0:	0801ae83 	.word	0x0801ae83
	switch (type) {
	       case PTR:	arg->p = va_arg(*ap, void *);
 801acb4:	687b      	ldr	r3, [r7, #4]
 801acb6:	681b      	ldr	r3, [r3, #0]
 801acb8:	1d19      	adds	r1, r3, #4
 801acba:	687a      	ldr	r2, [r7, #4]
 801acbc:	6011      	str	r1, [r2, #0]
 801acbe:	681a      	ldr	r2, [r3, #0]
 801acc0:	68fb      	ldr	r3, [r7, #12]
 801acc2:	601a      	str	r2, [r3, #0]
	break; case INT:	arg->i = va_arg(*ap, int);
 801acc4:	e0ec      	b.n	801aea0 <pop_arg+0x250>
 801acc6:	687b      	ldr	r3, [r7, #4]
 801acc8:	681b      	ldr	r3, [r3, #0]
 801acca:	1d19      	adds	r1, r3, #4
 801accc:	687a      	ldr	r2, [r7, #4]
 801acce:	6011      	str	r1, [r2, #0]
 801acd0:	681b      	ldr	r3, [r3, #0]
 801acd2:	461a      	mov	r2, r3
 801acd4:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801acd8:	68f9      	ldr	r1, [r7, #12]
 801acda:	e9c1 2300 	strd	r2, r3, [r1]
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
 801acde:	e0df      	b.n	801aea0 <pop_arg+0x250>
 801ace0:	687b      	ldr	r3, [r7, #4]
 801ace2:	681b      	ldr	r3, [r3, #0]
 801ace4:	1d19      	adds	r1, r3, #4
 801ace6:	687a      	ldr	r2, [r7, #4]
 801ace8:	6011      	str	r1, [r2, #0]
 801acea:	681b      	ldr	r3, [r3, #0]
 801acec:	461a      	mov	r2, r3
 801acee:	f04f 0300 	mov.w	r3, #0
 801acf2:	68f9      	ldr	r1, [r7, #12]
 801acf4:	e9c1 2300 	strd	r2, r3, [r1]
	break; case LONG:	arg->i = va_arg(*ap, long);
 801acf8:	e0d2      	b.n	801aea0 <pop_arg+0x250>
 801acfa:	687b      	ldr	r3, [r7, #4]
 801acfc:	681b      	ldr	r3, [r3, #0]
 801acfe:	1d19      	adds	r1, r3, #4
 801ad00:	687a      	ldr	r2, [r7, #4]
 801ad02:	6011      	str	r1, [r2, #0]
 801ad04:	681b      	ldr	r3, [r3, #0]
 801ad06:	461a      	mov	r2, r3
 801ad08:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801ad0c:	68f9      	ldr	r1, [r7, #12]
 801ad0e:	e9c1 2300 	strd	r2, r3, [r1]
	break; case ULONG:	arg->i = va_arg(*ap, unsigned long);
 801ad12:	e0c5      	b.n	801aea0 <pop_arg+0x250>
 801ad14:	687b      	ldr	r3, [r7, #4]
 801ad16:	681b      	ldr	r3, [r3, #0]
 801ad18:	1d19      	adds	r1, r3, #4
 801ad1a:	687a      	ldr	r2, [r7, #4]
 801ad1c:	6011      	str	r1, [r2, #0]
 801ad1e:	681b      	ldr	r3, [r3, #0]
 801ad20:	461a      	mov	r2, r3
 801ad22:	f04f 0300 	mov.w	r3, #0
 801ad26:	68f9      	ldr	r1, [r7, #12]
 801ad28:	e9c1 2300 	strd	r2, r3, [r1]
	break; case ULLONG:	arg->i = va_arg(*ap, unsigned long long);
 801ad2c:	e0b8      	b.n	801aea0 <pop_arg+0x250>
 801ad2e:	687b      	ldr	r3, [r7, #4]
 801ad30:	681b      	ldr	r3, [r3, #0]
 801ad32:	3307      	adds	r3, #7
 801ad34:	f023 0307 	bic.w	r3, r3, #7
 801ad38:	f103 0108 	add.w	r1, r3, #8
 801ad3c:	687a      	ldr	r2, [r7, #4]
 801ad3e:	6011      	str	r1, [r2, #0]
 801ad40:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ad44:	68f9      	ldr	r1, [r7, #12]
 801ad46:	e9c1 2300 	strd	r2, r3, [r1]
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
 801ad4a:	e0a9      	b.n	801aea0 <pop_arg+0x250>
 801ad4c:	687b      	ldr	r3, [r7, #4]
 801ad4e:	681b      	ldr	r3, [r3, #0]
 801ad50:	1d19      	adds	r1, r3, #4
 801ad52:	687a      	ldr	r2, [r7, #4]
 801ad54:	6011      	str	r1, [r2, #0]
 801ad56:	681b      	ldr	r3, [r3, #0]
 801ad58:	b21b      	sxth	r3, r3
 801ad5a:	b21a      	sxth	r2, r3
 801ad5c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801ad60:	68f9      	ldr	r1, [r7, #12]
 801ad62:	e9c1 2300 	strd	r2, r3, [r1]
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
 801ad66:	e09b      	b.n	801aea0 <pop_arg+0x250>
 801ad68:	687b      	ldr	r3, [r7, #4]
 801ad6a:	681b      	ldr	r3, [r3, #0]
 801ad6c:	1d19      	adds	r1, r3, #4
 801ad6e:	687a      	ldr	r2, [r7, #4]
 801ad70:	6011      	str	r1, [r2, #0]
 801ad72:	681b      	ldr	r3, [r3, #0]
 801ad74:	b29b      	uxth	r3, r3
 801ad76:	b29a      	uxth	r2, r3
 801ad78:	f04f 0300 	mov.w	r3, #0
 801ad7c:	68f9      	ldr	r1, [r7, #12]
 801ad7e:	e9c1 2300 	strd	r2, r3, [r1]
	break; case CHAR1:	arg->i = (signed char)va_arg(*ap, int);
 801ad82:	e08d      	b.n	801aea0 <pop_arg+0x250>
 801ad84:	687b      	ldr	r3, [r7, #4]
 801ad86:	681b      	ldr	r3, [r3, #0]
 801ad88:	1d19      	adds	r1, r3, #4
 801ad8a:	687a      	ldr	r2, [r7, #4]
 801ad8c:	6011      	str	r1, [r2, #0]
 801ad8e:	681b      	ldr	r3, [r3, #0]
 801ad90:	b25b      	sxtb	r3, r3
 801ad92:	b25a      	sxtb	r2, r3
 801ad94:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801ad98:	68f9      	ldr	r1, [r7, #12]
 801ad9a:	e9c1 2300 	strd	r2, r3, [r1]
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
 801ad9e:	e07f      	b.n	801aea0 <pop_arg+0x250>
 801ada0:	687b      	ldr	r3, [r7, #4]
 801ada2:	681b      	ldr	r3, [r3, #0]
 801ada4:	1d19      	adds	r1, r3, #4
 801ada6:	687a      	ldr	r2, [r7, #4]
 801ada8:	6011      	str	r1, [r2, #0]
 801adaa:	681b      	ldr	r3, [r3, #0]
 801adac:	b2db      	uxtb	r3, r3
 801adae:	b2da      	uxtb	r2, r3
 801adb0:	f04f 0300 	mov.w	r3, #0
 801adb4:	68f9      	ldr	r1, [r7, #12]
 801adb6:	e9c1 2300 	strd	r2, r3, [r1]
	break; case LLONG:	arg->i = va_arg(*ap, long long);
 801adba:	e071      	b.n	801aea0 <pop_arg+0x250>
 801adbc:	687b      	ldr	r3, [r7, #4]
 801adbe:	681b      	ldr	r3, [r3, #0]
 801adc0:	3307      	adds	r3, #7
 801adc2:	f023 0307 	bic.w	r3, r3, #7
 801adc6:	f103 0108 	add.w	r1, r3, #8
 801adca:	687a      	ldr	r2, [r7, #4]
 801adcc:	6011      	str	r1, [r2, #0]
 801adce:	e9d3 2300 	ldrd	r2, r3, [r3]
 801add2:	68f9      	ldr	r1, [r7, #12]
 801add4:	e9c1 2300 	strd	r2, r3, [r1]
	break; case SIZET:	arg->i = va_arg(*ap, size_t);
 801add8:	e062      	b.n	801aea0 <pop_arg+0x250>
 801adda:	687b      	ldr	r3, [r7, #4]
 801addc:	681b      	ldr	r3, [r3, #0]
 801adde:	1d19      	adds	r1, r3, #4
 801ade0:	687a      	ldr	r2, [r7, #4]
 801ade2:	6011      	str	r1, [r2, #0]
 801ade4:	681b      	ldr	r3, [r3, #0]
 801ade6:	461a      	mov	r2, r3
 801ade8:	f04f 0300 	mov.w	r3, #0
 801adec:	68f9      	ldr	r1, [r7, #12]
 801adee:	e9c1 2300 	strd	r2, r3, [r1]
	break; case IMAX:	arg->i = va_arg(*ap, intmax_t);
 801adf2:	e055      	b.n	801aea0 <pop_arg+0x250>
 801adf4:	687b      	ldr	r3, [r7, #4]
 801adf6:	681b      	ldr	r3, [r3, #0]
 801adf8:	3307      	adds	r3, #7
 801adfa:	f023 0307 	bic.w	r3, r3, #7
 801adfe:	f103 0108 	add.w	r1, r3, #8
 801ae02:	687a      	ldr	r2, [r7, #4]
 801ae04:	6011      	str	r1, [r2, #0]
 801ae06:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ae0a:	68f9      	ldr	r1, [r7, #12]
 801ae0c:	e9c1 2300 	strd	r2, r3, [r1]
	break; case UMAX:	arg->i = va_arg(*ap, uintmax_t);
 801ae10:	e046      	b.n	801aea0 <pop_arg+0x250>
 801ae12:	687b      	ldr	r3, [r7, #4]
 801ae14:	681b      	ldr	r3, [r3, #0]
 801ae16:	3307      	adds	r3, #7
 801ae18:	f023 0307 	bic.w	r3, r3, #7
 801ae1c:	f103 0108 	add.w	r1, r3, #8
 801ae20:	687a      	ldr	r2, [r7, #4]
 801ae22:	6011      	str	r1, [r2, #0]
 801ae24:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ae28:	68f9      	ldr	r1, [r7, #12]
 801ae2a:	e9c1 2300 	strd	r2, r3, [r1]
	break; case PDIFF:	arg->i = va_arg(*ap, ptrdiff_t);
 801ae2e:	e037      	b.n	801aea0 <pop_arg+0x250>
 801ae30:	687b      	ldr	r3, [r7, #4]
 801ae32:	681b      	ldr	r3, [r3, #0]
 801ae34:	1d19      	adds	r1, r3, #4
 801ae36:	687a      	ldr	r2, [r7, #4]
 801ae38:	6011      	str	r1, [r2, #0]
 801ae3a:	681b      	ldr	r3, [r3, #0]
 801ae3c:	461a      	mov	r2, r3
 801ae3e:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801ae42:	68f9      	ldr	r1, [r7, #12]
 801ae44:	e9c1 2300 	strd	r2, r3, [r1]
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
 801ae48:	e02a      	b.n	801aea0 <pop_arg+0x250>
 801ae4a:	687b      	ldr	r3, [r7, #4]
 801ae4c:	681b      	ldr	r3, [r3, #0]
 801ae4e:	1d19      	adds	r1, r3, #4
 801ae50:	687a      	ldr	r2, [r7, #4]
 801ae52:	6011      	str	r1, [r2, #0]
 801ae54:	681b      	ldr	r3, [r3, #0]
 801ae56:	461a      	mov	r2, r3
 801ae58:	f04f 0300 	mov.w	r3, #0
 801ae5c:	68f9      	ldr	r1, [r7, #12]
 801ae5e:	e9c1 2300 	strd	r2, r3, [r1]
	break; case DBL:	arg->f = va_arg(*ap, double);
 801ae62:	e01d      	b.n	801aea0 <pop_arg+0x250>
 801ae64:	687b      	ldr	r3, [r7, #4]
 801ae66:	681b      	ldr	r3, [r3, #0]
 801ae68:	3307      	adds	r3, #7
 801ae6a:	f023 0307 	bic.w	r3, r3, #7
 801ae6e:	f103 0108 	add.w	r1, r3, #8
 801ae72:	687a      	ldr	r2, [r7, #4]
 801ae74:	6011      	str	r1, [r2, #0]
 801ae76:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ae7a:	68f9      	ldr	r1, [r7, #12]
 801ae7c:	e9c1 2300 	strd	r2, r3, [r1]
	break; case LDBL:	arg->f = va_arg(*ap, ldouble_t);
 801ae80:	e00e      	b.n	801aea0 <pop_arg+0x250>
 801ae82:	687b      	ldr	r3, [r7, #4]
 801ae84:	681b      	ldr	r3, [r3, #0]
 801ae86:	3307      	adds	r3, #7
 801ae88:	f023 0307 	bic.w	r3, r3, #7
 801ae8c:	f103 0108 	add.w	r1, r3, #8
 801ae90:	687a      	ldr	r2, [r7, #4]
 801ae92:	6011      	str	r1, [r2, #0]
 801ae94:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ae98:	68f9      	ldr	r1, [r7, #12]
 801ae9a:	e9c1 2300 	strd	r2, r3, [r1]
	}
}
 801ae9e:	e7ff      	b.n	801aea0 <pop_arg+0x250>
 801aea0:	bf00      	nop
 801aea2:	3714      	adds	r7, #20
 801aea4:	46bd      	mov	sp, r7
 801aea6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801aeaa:	4770      	bx	lr

0801aeac <out>:

static void out(FILE *f, const char *s, size_t l)
{
 801aeac:	b580      	push	{r7, lr}
 801aeae:	b084      	sub	sp, #16
 801aeb0:	af00      	add	r7, sp, #0
 801aeb2:	60f8      	str	r0, [r7, #12]
 801aeb4:	60b9      	str	r1, [r7, #8]
 801aeb6:	607a      	str	r2, [r7, #4]
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
 801aeb8:	68fb      	ldr	r3, [r7, #12]
 801aeba:	681b      	ldr	r3, [r3, #0]
 801aebc:	f003 0320 	and.w	r3, r3, #32
 801aec0:	2b00      	cmp	r3, #0
 801aec2:	d104      	bne.n	801aece <out+0x22>
 801aec4:	68fa      	ldr	r2, [r7, #12]
 801aec6:	6879      	ldr	r1, [r7, #4]
 801aec8:	68b8      	ldr	r0, [r7, #8]
 801aeca:	f002 fa6b 	bl	801d3a4 <__fwritex>
}
 801aece:	bf00      	nop
 801aed0:	3710      	adds	r7, #16
 801aed2:	46bd      	mov	sp, r7
 801aed4:	bd80      	pop	{r7, pc}
	...

0801aed8 <pad>:

static void pad(FILE *f, char c, int w, int l, int fl)
{
 801aed8:	b590      	push	{r4, r7, lr}
 801aeda:	b0c7      	sub	sp, #284	; 0x11c
 801aedc:	af00      	add	r7, sp, #0
 801aede:	f107 040c 	add.w	r4, r7, #12
 801aee2:	6020      	str	r0, [r4, #0]
 801aee4:	4608      	mov	r0, r1
 801aee6:	1d39      	adds	r1, r7, #4
 801aee8:	600a      	str	r2, [r1, #0]
 801aeea:	463a      	mov	r2, r7
 801aeec:	6013      	str	r3, [r2, #0]
 801aeee:	f107 030b 	add.w	r3, r7, #11
 801aef2:	4602      	mov	r2, r0
 801aef4:	701a      	strb	r2, [r3, #0]
 801aef6:	4b2a      	ldr	r3, [pc, #168]	; (801afa0 <pad+0xc8>)
 801aef8:	681b      	ldr	r3, [r3, #0]
 801aefa:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 801aefe:	f04f 0300 	mov.w	r3, #0
	char pad[256];
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
 801af02:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801af06:	f403 3390 	and.w	r3, r3, #73728	; 0x12000
 801af0a:	2b00      	cmp	r3, #0
 801af0c:	d13a      	bne.n	801af84 <pad+0xac>
 801af0e:	463a      	mov	r2, r7
 801af10:	1d3b      	adds	r3, r7, #4
 801af12:	6812      	ldr	r2, [r2, #0]
 801af14:	681b      	ldr	r3, [r3, #0]
 801af16:	429a      	cmp	r2, r3
 801af18:	da34      	bge.n	801af84 <pad+0xac>
	l = w - l;
 801af1a:	463b      	mov	r3, r7
 801af1c:	1d39      	adds	r1, r7, #4
 801af1e:	463a      	mov	r2, r7
 801af20:	6809      	ldr	r1, [r1, #0]
 801af22:	6812      	ldr	r2, [r2, #0]
 801af24:	1a8a      	subs	r2, r1, r2
 801af26:	601a      	str	r2, [r3, #0]
	memset(pad, c, (unsigned)l>sizeof pad ? sizeof pad : (unsigned)l);
 801af28:	f107 030b 	add.w	r3, r7, #11
 801af2c:	7819      	ldrb	r1, [r3, #0]
 801af2e:	463b      	mov	r3, r7
 801af30:	681b      	ldr	r3, [r3, #0]
 801af32:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801af36:	bf28      	it	cs
 801af38:	f44f 7380 	movcs.w	r3, #256	; 0x100
 801af3c:	461a      	mov	r2, r3
 801af3e:	f107 0314 	add.w	r3, r7, #20
 801af42:	4618      	mov	r0, r3
 801af44:	f7f4 f9e0 	bl	800f308 <memset>
	for (; l >= (int)(sizeof pad); l -= (int)(sizeof pad))
 801af48:	e00e      	b.n	801af68 <pad+0x90>
		out(f, pad, sizeof pad);
 801af4a:	f107 0114 	add.w	r1, r7, #20
 801af4e:	f107 030c 	add.w	r3, r7, #12
 801af52:	f44f 7280 	mov.w	r2, #256	; 0x100
 801af56:	6818      	ldr	r0, [r3, #0]
 801af58:	f7ff ffa8 	bl	801aeac <out>
	for (; l >= (int)(sizeof pad); l -= (int)(sizeof pad))
 801af5c:	463b      	mov	r3, r7
 801af5e:	463a      	mov	r2, r7
 801af60:	6812      	ldr	r2, [r2, #0]
 801af62:	f5a2 7280 	sub.w	r2, r2, #256	; 0x100
 801af66:	601a      	str	r2, [r3, #0]
 801af68:	463b      	mov	r3, r7
 801af6a:	681b      	ldr	r3, [r3, #0]
 801af6c:	2bff      	cmp	r3, #255	; 0xff
 801af6e:	dcec      	bgt.n	801af4a <pad+0x72>
	out(f, pad, l);
 801af70:	463b      	mov	r3, r7
 801af72:	681a      	ldr	r2, [r3, #0]
 801af74:	f107 0114 	add.w	r1, r7, #20
 801af78:	f107 030c 	add.w	r3, r7, #12
 801af7c:	6818      	ldr	r0, [r3, #0]
 801af7e:	f7ff ff95 	bl	801aeac <out>
 801af82:	e000      	b.n	801af86 <pad+0xae>
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
 801af84:	bf00      	nop
}
 801af86:	4b06      	ldr	r3, [pc, #24]	; (801afa0 <pad+0xc8>)
 801af88:	681a      	ldr	r2, [r3, #0]
 801af8a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 801af8e:	405a      	eors	r2, r3
 801af90:	d001      	beq.n	801af96 <pad+0xbe>
 801af92:	f7e9 fb23 	bl	80045dc <__stack_chk_fail>
 801af96:	f507 778e 	add.w	r7, r7, #284	; 0x11c
 801af9a:	46bd      	mov	sp, r7
 801af9c:	bd90      	pop	{r4, r7, pc}
 801af9e:	bf00      	nop
 801afa0:	08023164 	.word	0x08023164

0801afa4 <fmt_x>:
static const char xdigits[16] = {
	"0123456789ABCDEF"
};

static char *fmt_x(uintmax_t x, char *s, int lower)
{
 801afa4:	b4b0      	push	{r4, r5, r7}
 801afa6:	b085      	sub	sp, #20
 801afa8:	af00      	add	r7, sp, #0
 801afaa:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801afae:	607a      	str	r2, [r7, #4]
 801afb0:	603b      	str	r3, [r7, #0]
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
 801afb2:	e023      	b.n	801affc <fmt_x+0x58>
 801afb4:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801afb8:	f04f 000f 	mov.w	r0, #15
 801afbc:	f04f 0100 	mov.w	r1, #0
 801afc0:	ea02 0400 	and.w	r4, r2, r0
 801afc4:	ea03 0501 	and.w	r5, r3, r1
 801afc8:	4b11      	ldr	r3, [pc, #68]	; (801b010 <fmt_x+0x6c>)
 801afca:	4423      	add	r3, r4
 801afcc:	781b      	ldrb	r3, [r3, #0]
 801afce:	b25a      	sxtb	r2, r3
 801afd0:	683b      	ldr	r3, [r7, #0]
 801afd2:	b25b      	sxtb	r3, r3
 801afd4:	4313      	orrs	r3, r2
 801afd6:	b25a      	sxtb	r2, r3
 801afd8:	687b      	ldr	r3, [r7, #4]
 801afda:	3b01      	subs	r3, #1
 801afdc:	607b      	str	r3, [r7, #4]
 801afde:	b2d2      	uxtb	r2, r2
 801afe0:	687b      	ldr	r3, [r7, #4]
 801afe2:	701a      	strb	r2, [r3, #0]
 801afe4:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801afe8:	f04f 0200 	mov.w	r2, #0
 801afec:	f04f 0300 	mov.w	r3, #0
 801aff0:	0902      	lsrs	r2, r0, #4
 801aff2:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 801aff6:	090b      	lsrs	r3, r1, #4
 801aff8:	e9c7 2302 	strd	r2, r3, [r7, #8]
 801affc:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801b000:	4313      	orrs	r3, r2
 801b002:	d1d7      	bne.n	801afb4 <fmt_x+0x10>
	return s;
 801b004:	687b      	ldr	r3, [r7, #4]
}
 801b006:	4618      	mov	r0, r3
 801b008:	3714      	adds	r7, #20
 801b00a:	46bd      	mov	sp, r7
 801b00c:	bcb0      	pop	{r4, r5, r7}
 801b00e:	4770      	bx	lr
 801b010:	08023b38 	.word	0x08023b38

0801b014 <fmt_o>:

static char *fmt_o(uintmax_t x, char *s)
{
 801b014:	b480      	push	{r7}
 801b016:	b085      	sub	sp, #20
 801b018:	af00      	add	r7, sp, #0
 801b01a:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801b01e:	607a      	str	r2, [r7, #4]
	for (; x; x>>=3) *--s = '0' + (x&7);
 801b020:	e016      	b.n	801b050 <fmt_o+0x3c>
 801b022:	7a3b      	ldrb	r3, [r7, #8]
 801b024:	f003 0307 	and.w	r3, r3, #7
 801b028:	b2db      	uxtb	r3, r3
 801b02a:	687a      	ldr	r2, [r7, #4]
 801b02c:	3a01      	subs	r2, #1
 801b02e:	607a      	str	r2, [r7, #4]
 801b030:	3330      	adds	r3, #48	; 0x30
 801b032:	b2da      	uxtb	r2, r3
 801b034:	687b      	ldr	r3, [r7, #4]
 801b036:	701a      	strb	r2, [r3, #0]
 801b038:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801b03c:	f04f 0200 	mov.w	r2, #0
 801b040:	f04f 0300 	mov.w	r3, #0
 801b044:	08c2      	lsrs	r2, r0, #3
 801b046:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
 801b04a:	08cb      	lsrs	r3, r1, #3
 801b04c:	e9c7 2302 	strd	r2, r3, [r7, #8]
 801b050:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801b054:	4313      	orrs	r3, r2
 801b056:	d1e4      	bne.n	801b022 <fmt_o+0xe>
	return s;
 801b058:	687b      	ldr	r3, [r7, #4]
}
 801b05a:	4618      	mov	r0, r3
 801b05c:	3714      	adds	r7, #20
 801b05e:	46bd      	mov	sp, r7
 801b060:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b064:	4770      	bx	lr
	...

0801b068 <fmt_u>:

static char *fmt_u(uintmax_t x, char *s)
{
 801b068:	b580      	push	{r7, lr}
 801b06a:	b086      	sub	sp, #24
 801b06c:	af00      	add	r7, sp, #0
 801b06e:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801b072:	607a      	str	r2, [r7, #4]
	unsigned long y;
	for (   ; x>ULONG_MAX; x/=10) *--s = '0' + x%10;
 801b074:	e01b      	b.n	801b0ae <fmt_u+0x46>
 801b076:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801b07a:	f04f 020a 	mov.w	r2, #10
 801b07e:	f04f 0300 	mov.w	r3, #0
 801b082:	f7e5 fc87 	bl	8000994 <__aeabi_uldivmod>
 801b086:	b2d3      	uxtb	r3, r2
 801b088:	687a      	ldr	r2, [r7, #4]
 801b08a:	3a01      	subs	r2, #1
 801b08c:	607a      	str	r2, [r7, #4]
 801b08e:	3330      	adds	r3, #48	; 0x30
 801b090:	b2da      	uxtb	r2, r3
 801b092:	687b      	ldr	r3, [r7, #4]
 801b094:	701a      	strb	r2, [r3, #0]
 801b096:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801b09a:	f04f 020a 	mov.w	r2, #10
 801b09e:	f04f 0300 	mov.w	r3, #0
 801b0a2:	f7e5 fc77 	bl	8000994 <__aeabi_uldivmod>
 801b0a6:	4602      	mov	r2, r0
 801b0a8:	460b      	mov	r3, r1
 801b0aa:	e9c7 2302 	strd	r2, r3, [r7, #8]
 801b0ae:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801b0b2:	2b01      	cmp	r3, #1
 801b0b4:	bf08      	it	eq
 801b0b6:	2a00      	cmpeq	r2, #0
 801b0b8:	d2dd      	bcs.n	801b076 <fmt_u+0xe>
	for (y=x;           y; y/=10) *--s = '0' + y%10;
 801b0ba:	68bb      	ldr	r3, [r7, #8]
 801b0bc:	617b      	str	r3, [r7, #20]
 801b0be:	e017      	b.n	801b0f0 <fmt_u+0x88>
 801b0c0:	6979      	ldr	r1, [r7, #20]
 801b0c2:	4b0f      	ldr	r3, [pc, #60]	; (801b100 <fmt_u+0x98>)
 801b0c4:	fba3 2301 	umull	r2, r3, r3, r1
 801b0c8:	08da      	lsrs	r2, r3, #3
 801b0ca:	4613      	mov	r3, r2
 801b0cc:	009b      	lsls	r3, r3, #2
 801b0ce:	4413      	add	r3, r2
 801b0d0:	005b      	lsls	r3, r3, #1
 801b0d2:	1aca      	subs	r2, r1, r3
 801b0d4:	b2d3      	uxtb	r3, r2
 801b0d6:	687a      	ldr	r2, [r7, #4]
 801b0d8:	3a01      	subs	r2, #1
 801b0da:	607a      	str	r2, [r7, #4]
 801b0dc:	3330      	adds	r3, #48	; 0x30
 801b0de:	b2da      	uxtb	r2, r3
 801b0e0:	687b      	ldr	r3, [r7, #4]
 801b0e2:	701a      	strb	r2, [r3, #0]
 801b0e4:	697b      	ldr	r3, [r7, #20]
 801b0e6:	4a06      	ldr	r2, [pc, #24]	; (801b100 <fmt_u+0x98>)
 801b0e8:	fba2 2303 	umull	r2, r3, r2, r3
 801b0ec:	08db      	lsrs	r3, r3, #3
 801b0ee:	617b      	str	r3, [r7, #20]
 801b0f0:	697b      	ldr	r3, [r7, #20]
 801b0f2:	2b00      	cmp	r3, #0
 801b0f4:	d1e4      	bne.n	801b0c0 <fmt_u+0x58>
	return s;
 801b0f6:	687b      	ldr	r3, [r7, #4]
}
 801b0f8:	4618      	mov	r0, r3
 801b0fa:	3718      	adds	r7, #24
 801b0fc:	46bd      	mov	sp, r7
 801b0fe:	bd80      	pop	{r7, pc}
 801b100:	cccccccd 	.word	0xcccccccd
 801b104:	00000000 	.word	0x00000000

0801b108 <fmt_fp>:
typedef char compiler_defines_long_double_incorrectly[9-(int)sizeof(ldouble_t)];
#endif
#endif

static int fmt_fp(FILE *f, ldouble_t y, int w, int p, int fl, int t)
{
 801b108:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b10c:	f5ad 7d33 	sub.w	sp, sp, #716	; 0x2cc
 801b110:	af02      	add	r7, sp, #8
 801b112:	f107 010c 	add.w	r1, r7, #12
 801b116:	6008      	str	r0, [r1, #0]
 801b118:	4639      	mov	r1, r7
 801b11a:	e9c1 2300 	strd	r2, r3, [r1]
 801b11e:	4ba5      	ldr	r3, [pc, #660]	; (801b3b4 <fmt_fp+0x2ac>)
 801b120:	681b      	ldr	r3, [r3, #0]
 801b122:	f8c7 32bc 	str.w	r3, [r7, #700]	; 0x2bc
 801b126:	f04f 0300 	mov.w	r3, #0
	uint32_t big[(LDBL_MANT_DIG+28)/29 + 1          // mantissa expansion
		+ (LDBL_MAX_EXP+LDBL_MANT_DIG+28+8)/9]; // exponent expansion
	uint32_t *a, *d, *r, *z;
	int e2=0, e, i, j, l;
 801b12a:	f107 0310 	add.w	r3, r7, #16
 801b12e:	2200      	movs	r2, #0
 801b130:	601a      	str	r2, [r3, #0]
	char buf[9+LDBL_MANT_DIG/4], *s;
	const char *prefix="-0X+0X 0X-0x+0x 0x";
 801b132:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801b136:	4aa0      	ldr	r2, [pc, #640]	; (801b3b8 <fmt_fp+0x2b0>)
 801b138:	601a      	str	r2, [r3, #0]
	int pl;
	char ebuf0[3*sizeof(int)], *ebuf=&ebuf0[3*sizeof(int)], *estr=NULL;
 801b13a:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801b13e:	f507 7226 	add.w	r2, r7, #664	; 0x298
 801b142:	320c      	adds	r2, #12
 801b144:	601a      	str	r2, [r3, #0]
 801b146:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b14a:	2200      	movs	r2, #0
 801b14c:	601a      	str	r2, [r3, #0]

	pl=1;
 801b14e:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b152:	2201      	movs	r2, #1
 801b154:	601a      	str	r2, [r3, #0]
	if (signbit(y)) {
 801b156:	463b      	mov	r3, r7
 801b158:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b15c:	f7ff fd66 	bl	801ac2c <__DOUBLE_BITS>
 801b160:	f04f 0200 	mov.w	r2, #0
 801b164:	f04f 0300 	mov.w	r3, #0
 801b168:	0fca      	lsrs	r2, r1, #31
 801b16a:	2300      	movs	r3, #0
 801b16c:	4613      	mov	r3, r2
 801b16e:	2b00      	cmp	r3, #0
 801b170:	d008      	beq.n	801b184 <fmt_fp+0x7c>
		y=-y;
 801b172:	463b      	mov	r3, r7
 801b174:	463a      	mov	r2, r7
 801b176:	6811      	ldr	r1, [r2, #0]
 801b178:	6019      	str	r1, [r3, #0]
 801b17a:	6852      	ldr	r2, [r2, #4]
 801b17c:	f082 4200 	eor.w	r2, r2, #2147483648	; 0x80000000
 801b180:	605a      	str	r2, [r3, #4]
 801b182:	e026      	b.n	801b1d2 <fmt_fp+0xca>
	} else if (fl & MARK_POS) {
 801b184:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b188:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801b18c:	2b00      	cmp	r3, #0
 801b18e:	d007      	beq.n	801b1a0 <fmt_fp+0x98>
		prefix+=3;
 801b190:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801b194:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801b198:	6812      	ldr	r2, [r2, #0]
 801b19a:	3203      	adds	r2, #3
 801b19c:	601a      	str	r2, [r3, #0]
 801b19e:	e018      	b.n	801b1d2 <fmt_fp+0xca>
	} else if (fl & PAD_POS) {
 801b1a0:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b1a4:	f003 0301 	and.w	r3, r3, #1
 801b1a8:	2b00      	cmp	r3, #0
 801b1aa:	d007      	beq.n	801b1bc <fmt_fp+0xb4>
		prefix+=6;
 801b1ac:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801b1b0:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801b1b4:	6812      	ldr	r2, [r2, #0]
 801b1b6:	3206      	adds	r2, #6
 801b1b8:	601a      	str	r2, [r3, #0]
 801b1ba:	e00a      	b.n	801b1d2 <fmt_fp+0xca>
	} else prefix++, pl=0;
 801b1bc:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801b1c0:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801b1c4:	6812      	ldr	r2, [r2, #0]
 801b1c6:	3201      	adds	r2, #1
 801b1c8:	601a      	str	r2, [r3, #0]
 801b1ca:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b1ce:	2200      	movs	r2, #0
 801b1d0:	601a      	str	r2, [r3, #0]

	if (!isfinite(y)) {
 801b1d2:	463b      	mov	r3, r7
 801b1d4:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b1d8:	f7ff fd28 	bl	801ac2c <__DOUBLE_BITS>
 801b1dc:	4602      	mov	r2, r0
 801b1de:	460b      	mov	r3, r1
 801b1e0:	f04f 30ff 	mov.w	r0, #4294967295
 801b1e4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 801b1e8:	ea02 0a00 	and.w	sl, r2, r0
 801b1ec:	ea03 0b01 	and.w	fp, r3, r1
 801b1f0:	f04f 32ff 	mov.w	r2, #4294967295
 801b1f4:	4b71      	ldr	r3, [pc, #452]	; (801b3bc <fmt_fp+0x2b4>)
 801b1f6:	455b      	cmp	r3, fp
 801b1f8:	bf08      	it	eq
 801b1fa:	4552      	cmpeq	r2, sl
 801b1fc:	d265      	bcs.n	801b2ca <fmt_fp+0x1c2>
		char *s = (t&32)?"inf":"INF";
 801b1fe:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b202:	f003 0320 	and.w	r3, r3, #32
 801b206:	2b00      	cmp	r3, #0
 801b208:	d001      	beq.n	801b20e <fmt_fp+0x106>
 801b20a:	4a6d      	ldr	r2, [pc, #436]	; (801b3c0 <fmt_fp+0x2b8>)
 801b20c:	e000      	b.n	801b210 <fmt_fp+0x108>
 801b20e:	4a6d      	ldr	r2, [pc, #436]	; (801b3c4 <fmt_fp+0x2bc>)
 801b210:	f107 0344 	add.w	r3, r7, #68	; 0x44
 801b214:	601a      	str	r2, [r3, #0]
		if (y!=y) s=(t&32)?"nan":"NAN";
 801b216:	4639      	mov	r1, r7
 801b218:	463b      	mov	r3, r7
 801b21a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b21e:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b222:	f7e5 fed9 	bl	8000fd8 <__aeabi_dcmpeq>
 801b226:	4603      	mov	r3, r0
 801b228:	2b00      	cmp	r3, #0
 801b22a:	d10b      	bne.n	801b244 <fmt_fp+0x13c>
 801b22c:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b230:	f003 0320 	and.w	r3, r3, #32
 801b234:	2b00      	cmp	r3, #0
 801b236:	d001      	beq.n	801b23c <fmt_fp+0x134>
 801b238:	4a63      	ldr	r2, [pc, #396]	; (801b3c8 <fmt_fp+0x2c0>)
 801b23a:	e000      	b.n	801b23e <fmt_fp+0x136>
 801b23c:	4a63      	ldr	r2, [pc, #396]	; (801b3cc <fmt_fp+0x2c4>)
 801b23e:	f107 0344 	add.w	r3, r7, #68	; 0x44
 801b242:	601a      	str	r2, [r3, #0]
		pad(f, ' ', w, 3+pl, fl&~ZERO_PAD);
 801b244:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b248:	681b      	ldr	r3, [r3, #0]
 801b24a:	1cda      	adds	r2, r3, #3
 801b24c:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b250:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801b254:	f107 000c 	add.w	r0, r7, #12
 801b258:	9300      	str	r3, [sp, #0]
 801b25a:	4613      	mov	r3, r2
 801b25c:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801b260:	2120      	movs	r1, #32
 801b262:	6800      	ldr	r0, [r0, #0]
 801b264:	f7ff fe38 	bl	801aed8 <pad>
		out(f, prefix, pl);
 801b268:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b26c:	681a      	ldr	r2, [r3, #0]
 801b26e:	f107 0138 	add.w	r1, r7, #56	; 0x38
 801b272:	f107 030c 	add.w	r3, r7, #12
 801b276:	6809      	ldr	r1, [r1, #0]
 801b278:	6818      	ldr	r0, [r3, #0]
 801b27a:	f7ff fe17 	bl	801aeac <out>
		out(f, s, 3);
 801b27e:	f107 0144 	add.w	r1, r7, #68	; 0x44
 801b282:	f107 030c 	add.w	r3, r7, #12
 801b286:	2203      	movs	r2, #3
 801b288:	6809      	ldr	r1, [r1, #0]
 801b28a:	6818      	ldr	r0, [r3, #0]
 801b28c:	f7ff fe0e 	bl	801aeac <out>
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
 801b290:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b294:	681b      	ldr	r3, [r3, #0]
 801b296:	1cda      	adds	r2, r3, #3
 801b298:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b29c:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 801b2a0:	f107 000c 	add.w	r0, r7, #12
 801b2a4:	9300      	str	r3, [sp, #0]
 801b2a6:	4613      	mov	r3, r2
 801b2a8:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801b2ac:	2120      	movs	r1, #32
 801b2ae:	6800      	ldr	r0, [r0, #0]
 801b2b0:	f7ff fe12 	bl	801aed8 <pad>
		return MAX(w, 3+pl);
 801b2b4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b2b8:	681b      	ldr	r3, [r3, #0]
 801b2ba:	1cda      	adds	r2, r3, #3
 801b2bc:	f8d7 32e8 	ldr.w	r3, [r7, #744]	; 0x2e8
 801b2c0:	4293      	cmp	r3, r2
 801b2c2:	bfb8      	it	lt
 801b2c4:	4613      	movlt	r3, r2
 801b2c6:	f001 ba31 	b.w	801c72c <fmt_fp+0x1624>
	}

	y = frexpl(y, &e2);
 801b2ca:	463e      	mov	r6, r7
 801b2cc:	f107 0210 	add.w	r2, r7, #16
 801b2d0:	463b      	mov	r3, r7
 801b2d2:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b2d6:	f003 ffaf 	bl	801f238 <frexpl>
 801b2da:	e9c6 0100 	strd	r0, r1, [r6]
	y *= 2;
 801b2de:	463e      	mov	r6, r7
 801b2e0:	463b      	mov	r3, r7
 801b2e2:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b2e6:	4602      	mov	r2, r0
 801b2e8:	460b      	mov	r3, r1
 801b2ea:	f7e4 ff8b 	bl	8000204 <__adddf3>
 801b2ee:	4602      	mov	r2, r0
 801b2f0:	460b      	mov	r3, r1
 801b2f2:	e9c6 2300 	strd	r2, r3, [r6]
	if (y) e2--;
 801b2f6:	4639      	mov	r1, r7
 801b2f8:	f04f 0200 	mov.w	r2, #0
 801b2fc:	f04f 0300 	mov.w	r3, #0
 801b300:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b304:	f7e5 fe68 	bl	8000fd8 <__aeabi_dcmpeq>
 801b308:	4603      	mov	r3, r0
 801b30a:	2b00      	cmp	r3, #0
 801b30c:	d106      	bne.n	801b31c <fmt_fp+0x214>
 801b30e:	f107 0310 	add.w	r3, r7, #16
 801b312:	681b      	ldr	r3, [r3, #0]
 801b314:	1e5a      	subs	r2, r3, #1
 801b316:	f107 0310 	add.w	r3, r7, #16
 801b31a:	601a      	str	r2, [r3, #0]

	if ((t|32)=='a') {
 801b31c:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b320:	f043 0320 	orr.w	r3, r3, #32
 801b324:	2b61      	cmp	r3, #97	; 0x61
 801b326:	f040 8251 	bne.w	801b7cc <fmt_fp+0x6c4>
		ldouble_t round = 8.0;
 801b32a:	f107 0180 	add.w	r1, r7, #128	; 0x80
 801b32e:	f04f 0200 	mov.w	r2, #0
 801b332:	4b27      	ldr	r3, [pc, #156]	; (801b3d0 <fmt_fp+0x2c8>)
 801b334:	e9c1 2300 	strd	r2, r3, [r1]
		int re;

		if (t&32) prefix += 9;
 801b338:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b33c:	f003 0320 	and.w	r3, r3, #32
 801b340:	2b00      	cmp	r3, #0
 801b342:	d006      	beq.n	801b352 <fmt_fp+0x24a>
 801b344:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801b348:	f107 0238 	add.w	r2, r7, #56	; 0x38
 801b34c:	6812      	ldr	r2, [r2, #0]
 801b34e:	3209      	adds	r2, #9
 801b350:	601a      	str	r2, [r3, #0]
		pl += 2;
 801b352:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b356:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b35a:	6812      	ldr	r2, [r2, #0]
 801b35c:	3202      	adds	r2, #2
 801b35e:	601a      	str	r2, [r3, #0]

		if (p<0 || p>=LDBL_MANT_DIG/4-1) re=0;
 801b360:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b364:	2b00      	cmp	r3, #0
 801b366:	db03      	blt.n	801b370 <fmt_fp+0x268>
 801b368:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b36c:	2b0b      	cmp	r3, #11
 801b36e:	dd04      	ble.n	801b37a <fmt_fp+0x272>
 801b370:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801b374:	2200      	movs	r2, #0
 801b376:	601a      	str	r2, [r3, #0]
 801b378:	e006      	b.n	801b388 <fmt_fp+0x280>
		else re=LDBL_MANT_DIG/4-1-p;
 801b37a:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801b37e:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801b382:	f1c2 020c 	rsb	r2, r2, #12
 801b386:	601a      	str	r2, [r3, #0]

		if (re) {
 801b388:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801b38c:	681b      	ldr	r3, [r3, #0]
 801b38e:	2b00      	cmp	r3, #0
 801b390:	f000 8087 	beq.w	801b4a2 <fmt_fp+0x39a>
			round *= 1<<(LDBL_MANT_DIG%4);
 801b394:	f107 0480 	add.w	r4, r7, #128	; 0x80
 801b398:	f107 0380 	add.w	r3, r7, #128	; 0x80
 801b39c:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b3a0:	4602      	mov	r2, r0
 801b3a2:	460b      	mov	r3, r1
 801b3a4:	f7e4 ff2e 	bl	8000204 <__adddf3>
 801b3a8:	4602      	mov	r2, r0
 801b3aa:	460b      	mov	r3, r1
 801b3ac:	e9c4 2300 	strd	r2, r3, [r4]
			while (re--) round*=16;
 801b3b0:	e01f      	b.n	801b3f2 <fmt_fp+0x2ea>
 801b3b2:	bf00      	nop
 801b3b4:	08023190 	.word	0x08023190
 801b3b8:	08023168 	.word	0x08023168
 801b3bc:	7fefffff 	.word	0x7fefffff
 801b3c0:	0802317c 	.word	0x0802317c
 801b3c4:	08023180 	.word	0x08023180
 801b3c8:	08023184 	.word	0x08023184
 801b3cc:	08023188 	.word	0x08023188
 801b3d0:	40200000 	.word	0x40200000
 801b3d4:	f107 0480 	add.w	r4, r7, #128	; 0x80
 801b3d8:	f107 0180 	add.w	r1, r7, #128	; 0x80
 801b3dc:	f04f 0200 	mov.w	r2, #0
 801b3e0:	4ba7      	ldr	r3, [pc, #668]	; (801b680 <fmt_fp+0x578>)
 801b3e2:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b3e6:	f7e5 f8c3 	bl	8000570 <__aeabi_dmul>
 801b3ea:	4602      	mov	r2, r0
 801b3ec:	460b      	mov	r3, r1
 801b3ee:	e9c4 2300 	strd	r2, r3, [r4]
 801b3f2:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801b3f6:	681b      	ldr	r3, [r3, #0]
 801b3f8:	f107 0248 	add.w	r2, r7, #72	; 0x48
 801b3fc:	1e59      	subs	r1, r3, #1
 801b3fe:	6011      	str	r1, [r2, #0]
 801b400:	2b00      	cmp	r3, #0
 801b402:	d1e7      	bne.n	801b3d4 <fmt_fp+0x2cc>
			if (*prefix=='-') {
 801b404:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801b408:	681b      	ldr	r3, [r3, #0]
 801b40a:	781b      	ldrb	r3, [r3, #0]
 801b40c:	2b2d      	cmp	r3, #45	; 0x2d
 801b40e:	d12c      	bne.n	801b46a <fmt_fp+0x362>
				y=-y;
 801b410:	463b      	mov	r3, r7
 801b412:	463a      	mov	r2, r7
 801b414:	6811      	ldr	r1, [r2, #0]
 801b416:	6019      	str	r1, [r3, #0]
 801b418:	6852      	ldr	r2, [r2, #4]
 801b41a:	f082 4200 	eor.w	r2, r2, #2147483648	; 0x80000000
 801b41e:	605a      	str	r2, [r3, #4]
				y-=round;
 801b420:	463c      	mov	r4, r7
 801b422:	4639      	mov	r1, r7
 801b424:	f107 0380 	add.w	r3, r7, #128	; 0x80
 801b428:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b42c:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b430:	f7e4 fee6 	bl	8000200 <__aeabi_dsub>
 801b434:	4602      	mov	r2, r0
 801b436:	460b      	mov	r3, r1
 801b438:	e9c4 2300 	strd	r2, r3, [r4]
				y+=round;
 801b43c:	463c      	mov	r4, r7
 801b43e:	4639      	mov	r1, r7
 801b440:	f107 0380 	add.w	r3, r7, #128	; 0x80
 801b444:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b448:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b44c:	f7e4 feda 	bl	8000204 <__adddf3>
 801b450:	4602      	mov	r2, r0
 801b452:	460b      	mov	r3, r1
 801b454:	e9c4 2300 	strd	r2, r3, [r4]
				y=-y;
 801b458:	463b      	mov	r3, r7
 801b45a:	463a      	mov	r2, r7
 801b45c:	6811      	ldr	r1, [r2, #0]
 801b45e:	6019      	str	r1, [r3, #0]
 801b460:	6852      	ldr	r2, [r2, #4]
 801b462:	f082 4200 	eor.w	r2, r2, #2147483648	; 0x80000000
 801b466:	605a      	str	r2, [r3, #4]
 801b468:	e01b      	b.n	801b4a2 <fmt_fp+0x39a>
			} else {
				y+=round;
 801b46a:	463c      	mov	r4, r7
 801b46c:	4639      	mov	r1, r7
 801b46e:	f107 0380 	add.w	r3, r7, #128	; 0x80
 801b472:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b476:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b47a:	f7e4 fec3 	bl	8000204 <__adddf3>
 801b47e:	4602      	mov	r2, r0
 801b480:	460b      	mov	r3, r1
 801b482:	e9c4 2300 	strd	r2, r3, [r4]
				y-=round;
 801b486:	463c      	mov	r4, r7
 801b488:	4639      	mov	r1, r7
 801b48a:	f107 0380 	add.w	r3, r7, #128	; 0x80
 801b48e:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b492:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b496:	f7e4 feb3 	bl	8000200 <__aeabi_dsub>
 801b49a:	4602      	mov	r2, r0
 801b49c:	460b      	mov	r3, r1
 801b49e:	e9c4 2300 	strd	r2, r3, [r4]
			}
		}

		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
 801b4a2:	f107 0310 	add.w	r3, r7, #16
 801b4a6:	681b      	ldr	r3, [r3, #0]
 801b4a8:	2b00      	cmp	r3, #0
 801b4aa:	bfb8      	it	lt
 801b4ac:	425b      	neglt	r3, r3
 801b4ae:	4618      	mov	r0, r3
 801b4b0:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801b4b4:	f107 0440 	add.w	r4, r7, #64	; 0x40
 801b4b8:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801b4bc:	681a      	ldr	r2, [r3, #0]
 801b4be:	f7ff fdd3 	bl	801b068 <fmt_u>
 801b4c2:	6020      	str	r0, [r4, #0]
		if (estr==ebuf) *--estr='0';
 801b4c4:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801b4c8:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801b4cc:	6812      	ldr	r2, [r2, #0]
 801b4ce:	681b      	ldr	r3, [r3, #0]
 801b4d0:	429a      	cmp	r2, r3
 801b4d2:	d10b      	bne.n	801b4ec <fmt_fp+0x3e4>
 801b4d4:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b4d8:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801b4dc:	6812      	ldr	r2, [r2, #0]
 801b4de:	3a01      	subs	r2, #1
 801b4e0:	601a      	str	r2, [r3, #0]
 801b4e2:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b4e6:	681b      	ldr	r3, [r3, #0]
 801b4e8:	2230      	movs	r2, #48	; 0x30
 801b4ea:	701a      	strb	r2, [r3, #0]
		*--estr = (e2<0 ? '-' : '+');
 801b4ec:	f107 0310 	add.w	r3, r7, #16
 801b4f0:	681b      	ldr	r3, [r3, #0]
 801b4f2:	2b00      	cmp	r3, #0
 801b4f4:	da01      	bge.n	801b4fa <fmt_fp+0x3f2>
 801b4f6:	212d      	movs	r1, #45	; 0x2d
 801b4f8:	e000      	b.n	801b4fc <fmt_fp+0x3f4>
 801b4fa:	212b      	movs	r1, #43	; 0x2b
 801b4fc:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b500:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801b504:	6812      	ldr	r2, [r2, #0]
 801b506:	3a01      	subs	r2, #1
 801b508:	601a      	str	r2, [r3, #0]
 801b50a:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b50e:	681b      	ldr	r3, [r3, #0]
 801b510:	460a      	mov	r2, r1
 801b512:	701a      	strb	r2, [r3, #0]
		*--estr = t+('p'-'a');
 801b514:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b518:	b2db      	uxtb	r3, r3
 801b51a:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801b51e:	f107 0140 	add.w	r1, r7, #64	; 0x40
 801b522:	6809      	ldr	r1, [r1, #0]
 801b524:	3901      	subs	r1, #1
 801b526:	6011      	str	r1, [r2, #0]
 801b528:	330f      	adds	r3, #15
 801b52a:	b2da      	uxtb	r2, r3
 801b52c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b530:	681b      	ldr	r3, [r3, #0]
 801b532:	701a      	strb	r2, [r3, #0]

		s=buf;
 801b534:	f107 0334 	add.w	r3, r7, #52	; 0x34
 801b538:	f507 7229 	add.w	r2, r7, #676	; 0x2a4
 801b53c:	601a      	str	r2, [r3, #0]
		do {
			int x=y;
 801b53e:	f107 047c 	add.w	r4, r7, #124	; 0x7c
 801b542:	463b      	mov	r3, r7
 801b544:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b548:	f7e5 fd78 	bl	800103c <__aeabi_d2iz>
 801b54c:	4603      	mov	r3, r0
 801b54e:	6023      	str	r3, [r4, #0]
			*s++=xdigits[x]|(t&32);
 801b550:	4a4c      	ldr	r2, [pc, #304]	; (801b684 <fmt_fp+0x57c>)
 801b552:	f107 037c 	add.w	r3, r7, #124	; 0x7c
 801b556:	681b      	ldr	r3, [r3, #0]
 801b558:	4413      	add	r3, r2
 801b55a:	781b      	ldrb	r3, [r3, #0]
 801b55c:	b25a      	sxtb	r2, r3
 801b55e:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801b562:	b25b      	sxtb	r3, r3
 801b564:	f003 0320 	and.w	r3, r3, #32
 801b568:	b25b      	sxtb	r3, r3
 801b56a:	4313      	orrs	r3, r2
 801b56c:	b258      	sxtb	r0, r3
 801b56e:	f107 0334 	add.w	r3, r7, #52	; 0x34
 801b572:	681b      	ldr	r3, [r3, #0]
 801b574:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b578:	1c59      	adds	r1, r3, #1
 801b57a:	6011      	str	r1, [r2, #0]
 801b57c:	b2c2      	uxtb	r2, r0
 801b57e:	701a      	strb	r2, [r3, #0]
			y=16*(y-x);
 801b580:	f107 037c 	add.w	r3, r7, #124	; 0x7c
 801b584:	6818      	ldr	r0, [r3, #0]
 801b586:	f7e4 ff89 	bl	800049c <__aeabi_i2d>
 801b58a:	4602      	mov	r2, r0
 801b58c:	460b      	mov	r3, r1
 801b58e:	4639      	mov	r1, r7
 801b590:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b594:	f7e4 fe34 	bl	8000200 <__aeabi_dsub>
 801b598:	4602      	mov	r2, r0
 801b59a:	460b      	mov	r3, r1
 801b59c:	4610      	mov	r0, r2
 801b59e:	4619      	mov	r1, r3
 801b5a0:	463c      	mov	r4, r7
 801b5a2:	f04f 0200 	mov.w	r2, #0
 801b5a6:	4b36      	ldr	r3, [pc, #216]	; (801b680 <fmt_fp+0x578>)
 801b5a8:	f7e4 ffe2 	bl	8000570 <__aeabi_dmul>
 801b5ac:	4602      	mov	r2, r0
 801b5ae:	460b      	mov	r3, r1
 801b5b0:	e9c4 2300 	strd	r2, r3, [r4]
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
 801b5b4:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b5b8:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801b5bc:	6812      	ldr	r2, [r2, #0]
 801b5be:	1ad3      	subs	r3, r2, r3
 801b5c0:	2b01      	cmp	r3, #1
 801b5c2:	d11e      	bne.n	801b602 <fmt_fp+0x4fa>
 801b5c4:	4639      	mov	r1, r7
 801b5c6:	f04f 0200 	mov.w	r2, #0
 801b5ca:	f04f 0300 	mov.w	r3, #0
 801b5ce:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b5d2:	f7e5 fd01 	bl	8000fd8 <__aeabi_dcmpeq>
 801b5d6:	4603      	mov	r3, r0
 801b5d8:	2b00      	cmp	r3, #0
 801b5da:	d009      	beq.n	801b5f0 <fmt_fp+0x4e8>
 801b5dc:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b5e0:	2b00      	cmp	r3, #0
 801b5e2:	dc05      	bgt.n	801b5f0 <fmt_fp+0x4e8>
 801b5e4:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b5e8:	f003 0308 	and.w	r3, r3, #8
 801b5ec:	2b00      	cmp	r3, #0
 801b5ee:	d008      	beq.n	801b602 <fmt_fp+0x4fa>
 801b5f0:	f107 0334 	add.w	r3, r7, #52	; 0x34
 801b5f4:	681b      	ldr	r3, [r3, #0]
 801b5f6:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b5fa:	1c59      	adds	r1, r3, #1
 801b5fc:	6011      	str	r1, [r2, #0]
 801b5fe:	222e      	movs	r2, #46	; 0x2e
 801b600:	701a      	strb	r2, [r3, #0]
		} while (y);
 801b602:	4639      	mov	r1, r7
 801b604:	f04f 0200 	mov.w	r2, #0
 801b608:	f04f 0300 	mov.w	r3, #0
 801b60c:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b610:	f7e5 fce2 	bl	8000fd8 <__aeabi_dcmpeq>
 801b614:	4603      	mov	r3, r0
 801b616:	2b00      	cmp	r3, #0
 801b618:	d091      	beq.n	801b53e <fmt_fp+0x436>

		if (p > INT_MAX-2-(ebuf-estr)-pl)
 801b61a:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b61e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b622:	6812      	ldr	r2, [r2, #0]
 801b624:	681b      	ldr	r3, [r3, #0]
 801b626:	1ad2      	subs	r2, r2, r3
 801b628:	4b17      	ldr	r3, [pc, #92]	; (801b688 <fmt_fp+0x580>)
 801b62a:	1a9b      	subs	r3, r3, r2
 801b62c:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b630:	6812      	ldr	r2, [r2, #0]
 801b632:	1a9b      	subs	r3, r3, r2
 801b634:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801b638:	429a      	cmp	r2, r3
 801b63a:	dd03      	ble.n	801b644 <fmt_fp+0x53c>
			return -1;
 801b63c:	f04f 33ff 	mov.w	r3, #4294967295
 801b640:	f001 b874 	b.w	801c72c <fmt_fp+0x1624>
		if (p && s-buf-2 < p)
 801b644:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b648:	2b00      	cmp	r3, #0
 801b64a:	d01f      	beq.n	801b68c <fmt_fp+0x584>
 801b64c:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b650:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801b654:	6812      	ldr	r2, [r2, #0]
 801b656:	1ad3      	subs	r3, r2, r3
 801b658:	3b01      	subs	r3, #1
 801b65a:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801b65e:	429a      	cmp	r2, r3
 801b660:	db14      	blt.n	801b68c <fmt_fp+0x584>
			l = (p+2) + (ebuf-estr);
 801b662:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b666:	1c99      	adds	r1, r3, #2
 801b668:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b66c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b670:	6812      	ldr	r2, [r2, #0]
 801b672:	681b      	ldr	r3, [r3, #0]
 801b674:	1ad2      	subs	r2, r2, r3
 801b676:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b67a:	440a      	add	r2, r1
 801b67c:	601a      	str	r2, [r3, #0]
 801b67e:	e016      	b.n	801b6ae <fmt_fp+0x5a6>
 801b680:	40300000 	.word	0x40300000
 801b684:	08023b38 	.word	0x08023b38
 801b688:	7ffffffd 	.word	0x7ffffffd
		else
			l = (s-buf) + (ebuf-estr);
 801b68c:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b690:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801b694:	6812      	ldr	r2, [r2, #0]
 801b696:	1ad1      	subs	r1, r2, r3
 801b698:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b69c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b6a0:	6812      	ldr	r2, [r2, #0]
 801b6a2:	681b      	ldr	r3, [r3, #0]
 801b6a4:	1ad2      	subs	r2, r2, r3
 801b6a6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b6aa:	440a      	add	r2, r1
 801b6ac:	601a      	str	r2, [r3, #0]

		pad(f, ' ', w, pl+l, fl);
 801b6ae:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b6b2:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b6b6:	6812      	ldr	r2, [r2, #0]
 801b6b8:	681b      	ldr	r3, [r3, #0]
 801b6ba:	441a      	add	r2, r3
 801b6bc:	f107 000c 	add.w	r0, r7, #12
 801b6c0:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b6c4:	9300      	str	r3, [sp, #0]
 801b6c6:	4613      	mov	r3, r2
 801b6c8:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801b6cc:	2120      	movs	r1, #32
 801b6ce:	6800      	ldr	r0, [r0, #0]
 801b6d0:	f7ff fc02 	bl	801aed8 <pad>
		out(f, prefix, pl);
 801b6d4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801b6d8:	681a      	ldr	r2, [r3, #0]
 801b6da:	f107 0138 	add.w	r1, r7, #56	; 0x38
 801b6de:	f107 030c 	add.w	r3, r7, #12
 801b6e2:	6809      	ldr	r1, [r1, #0]
 801b6e4:	6818      	ldr	r0, [r3, #0]
 801b6e6:	f7ff fbe1 	bl	801aeac <out>
		pad(f, '0', w, pl+l, fl^ZERO_PAD);
 801b6ea:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b6ee:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b6f2:	6812      	ldr	r2, [r2, #0]
 801b6f4:	681b      	ldr	r3, [r3, #0]
 801b6f6:	441a      	add	r2, r3
 801b6f8:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b6fc:	f483 3380 	eor.w	r3, r3, #65536	; 0x10000
 801b700:	f107 000c 	add.w	r0, r7, #12
 801b704:	9300      	str	r3, [sp, #0]
 801b706:	4613      	mov	r3, r2
 801b708:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801b70c:	2130      	movs	r1, #48	; 0x30
 801b70e:	6800      	ldr	r0, [r0, #0]
 801b710:	f7ff fbe2 	bl	801aed8 <pad>
		out(f, buf, s-buf);
 801b714:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801b718:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801b71c:	6812      	ldr	r2, [r2, #0]
 801b71e:	1ad3      	subs	r3, r2, r3
 801b720:	461a      	mov	r2, r3
 801b722:	f507 7129 	add.w	r1, r7, #676	; 0x2a4
 801b726:	f107 030c 	add.w	r3, r7, #12
 801b72a:	6818      	ldr	r0, [r3, #0]
 801b72c:	f7ff fbbe 	bl	801aeac <out>
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
 801b730:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b734:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b738:	6812      	ldr	r2, [r2, #0]
 801b73a:	681b      	ldr	r3, [r3, #0]
 801b73c:	1ad3      	subs	r3, r2, r3
 801b73e:	f107 0230 	add.w	r2, r7, #48	; 0x30
 801b742:	6812      	ldr	r2, [r2, #0]
 801b744:	1ad2      	subs	r2, r2, r3
 801b746:	f107 0134 	add.w	r1, r7, #52	; 0x34
 801b74a:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801b74e:	6809      	ldr	r1, [r1, #0]
 801b750:	1acb      	subs	r3, r1, r3
 801b752:	1ad2      	subs	r2, r2, r3
 801b754:	f107 000c 	add.w	r0, r7, #12
 801b758:	2300      	movs	r3, #0
 801b75a:	9300      	str	r3, [sp, #0]
 801b75c:	2300      	movs	r3, #0
 801b75e:	2130      	movs	r1, #48	; 0x30
 801b760:	6800      	ldr	r0, [r0, #0]
 801b762:	f7ff fbb9 	bl	801aed8 <pad>
		out(f, estr, ebuf-estr);
 801b766:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b76a:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b76e:	6812      	ldr	r2, [r2, #0]
 801b770:	681b      	ldr	r3, [r3, #0]
 801b772:	1ad3      	subs	r3, r2, r3
 801b774:	461a      	mov	r2, r3
 801b776:	f107 0140 	add.w	r1, r7, #64	; 0x40
 801b77a:	f107 030c 	add.w	r3, r7, #12
 801b77e:	6809      	ldr	r1, [r1, #0]
 801b780:	6818      	ldr	r0, [r3, #0]
 801b782:	f7ff fb93 	bl	801aeac <out>
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
 801b786:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b78a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b78e:	6812      	ldr	r2, [r2, #0]
 801b790:	681b      	ldr	r3, [r3, #0]
 801b792:	441a      	add	r2, r3
 801b794:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801b798:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 801b79c:	f107 000c 	add.w	r0, r7, #12
 801b7a0:	9300      	str	r3, [sp, #0]
 801b7a2:	4613      	mov	r3, r2
 801b7a4:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801b7a8:	2120      	movs	r1, #32
 801b7aa:	6800      	ldr	r0, [r0, #0]
 801b7ac:	f7ff fb94 	bl	801aed8 <pad>
		return MAX(w, pl+l);
 801b7b0:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801b7b4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b7b8:	6812      	ldr	r2, [r2, #0]
 801b7ba:	681b      	ldr	r3, [r3, #0]
 801b7bc:	441a      	add	r2, r3
 801b7be:	f8d7 32e8 	ldr.w	r3, [r7, #744]	; 0x2e8
 801b7c2:	4293      	cmp	r3, r2
 801b7c4:	bfb8      	it	lt
 801b7c6:	4613      	movlt	r3, r2
 801b7c8:	f000 bfb0 	b.w	801c72c <fmt_fp+0x1624>
	}
	if (p<0) p=6;
 801b7cc:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801b7d0:	2b00      	cmp	r3, #0
 801b7d2:	da02      	bge.n	801b7da <fmt_fp+0x6d2>
 801b7d4:	2306      	movs	r3, #6
 801b7d6:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec

	if (y) y *= 0x1p28, e2-=28;
 801b7da:	4639      	mov	r1, r7
 801b7dc:	f04f 0200 	mov.w	r2, #0
 801b7e0:	f04f 0300 	mov.w	r3, #0
 801b7e4:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b7e8:	f7e5 fbf6 	bl	8000fd8 <__aeabi_dcmpeq>
 801b7ec:	4603      	mov	r3, r0
 801b7ee:	2b00      	cmp	r3, #0
 801b7f0:	d114      	bne.n	801b81c <fmt_fp+0x714>
 801b7f2:	463e      	mov	r6, r7
 801b7f4:	4639      	mov	r1, r7
 801b7f6:	f04f 0200 	mov.w	r2, #0
 801b7fa:	4ba5      	ldr	r3, [pc, #660]	; (801ba90 <fmt_fp+0x988>)
 801b7fc:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b800:	f7e4 feb6 	bl	8000570 <__aeabi_dmul>
 801b804:	4602      	mov	r2, r0
 801b806:	460b      	mov	r3, r1
 801b808:	e9c6 2300 	strd	r2, r3, [r6]
 801b80c:	f107 0310 	add.w	r3, r7, #16
 801b810:	681b      	ldr	r3, [r3, #0]
 801b812:	f1a3 021c 	sub.w	r2, r3, #28
 801b816:	f107 0310 	add.w	r3, r7, #16
 801b81a:	601a      	str	r2, [r3, #0]

	if (e2<0) a=r=z=big;
 801b81c:	f107 0310 	add.w	r3, r7, #16
 801b820:	681b      	ldr	r3, [r3, #0]
 801b822:	2b00      	cmp	r3, #0
 801b824:	da11      	bge.n	801b84a <fmt_fp+0x742>
 801b826:	f107 0320 	add.w	r3, r7, #32
 801b82a:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 801b82e:	601a      	str	r2, [r3, #0]
 801b830:	f107 031c 	add.w	r3, r7, #28
 801b834:	f107 0220 	add.w	r2, r7, #32
 801b838:	6812      	ldr	r2, [r2, #0]
 801b83a:	601a      	str	r2, [r3, #0]
 801b83c:	f107 0314 	add.w	r3, r7, #20
 801b840:	f107 021c 	add.w	r2, r7, #28
 801b844:	6812      	ldr	r2, [r2, #0]
 801b846:	601a      	str	r2, [r3, #0]
 801b848:	e012      	b.n	801b870 <fmt_fp+0x768>
	else a=r=z=big+sizeof(big)/sizeof(*big) - LDBL_MANT_DIG - 1;
 801b84a:	f107 0320 	add.w	r3, r7, #32
 801b84e:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 801b852:	f502 7290 	add.w	r2, r2, #288	; 0x120
 801b856:	601a      	str	r2, [r3, #0]
 801b858:	f107 031c 	add.w	r3, r7, #28
 801b85c:	f107 0220 	add.w	r2, r7, #32
 801b860:	6812      	ldr	r2, [r2, #0]
 801b862:	601a      	str	r2, [r3, #0]
 801b864:	f107 0314 	add.w	r3, r7, #20
 801b868:	f107 021c 	add.w	r2, r7, #28
 801b86c:	6812      	ldr	r2, [r2, #0]
 801b86e:	601a      	str	r2, [r3, #0]

	do {
		*z = y;
 801b870:	463b      	mov	r3, r7
 801b872:	e9d3 0100 	ldrd	r0, r1, [r3]
 801b876:	f7e5 fc09 	bl	800108c <__aeabi_d2uiz>
 801b87a:	4602      	mov	r2, r0
 801b87c:	f107 0320 	add.w	r3, r7, #32
 801b880:	681b      	ldr	r3, [r3, #0]
 801b882:	601a      	str	r2, [r3, #0]
		y = 1000000000*(y-*z++);
 801b884:	f107 0320 	add.w	r3, r7, #32
 801b888:	681b      	ldr	r3, [r3, #0]
 801b88a:	f107 0220 	add.w	r2, r7, #32
 801b88e:	1d19      	adds	r1, r3, #4
 801b890:	6011      	str	r1, [r2, #0]
 801b892:	681b      	ldr	r3, [r3, #0]
 801b894:	4618      	mov	r0, r3
 801b896:	f7e4 fdf1 	bl	800047c <__aeabi_ui2d>
 801b89a:	4602      	mov	r2, r0
 801b89c:	460b      	mov	r3, r1
 801b89e:	4639      	mov	r1, r7
 801b8a0:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b8a4:	f7e4 fcac 	bl	8000200 <__aeabi_dsub>
 801b8a8:	4602      	mov	r2, r0
 801b8aa:	460b      	mov	r3, r1
 801b8ac:	4610      	mov	r0, r2
 801b8ae:	4619      	mov	r1, r3
 801b8b0:	463e      	mov	r6, r7
 801b8b2:	a373      	add	r3, pc, #460	; (adr r3, 801ba80 <fmt_fp+0x978>)
 801b8b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b8b8:	f7e4 fe5a 	bl	8000570 <__aeabi_dmul>
 801b8bc:	4602      	mov	r2, r0
 801b8be:	460b      	mov	r3, r1
 801b8c0:	e9c6 2300 	strd	r2, r3, [r6]
 801b8c4:	f107 0314 	add.w	r3, r7, #20
 801b8c8:	f107 0214 	add.w	r2, r7, #20
 801b8cc:	6812      	ldr	r2, [r2, #0]
 801b8ce:	601a      	str	r2, [r3, #0]
 801b8d0:	f107 031c 	add.w	r3, r7, #28
 801b8d4:	f107 021c 	add.w	r2, r7, #28
 801b8d8:	6812      	ldr	r2, [r2, #0]
 801b8da:	601a      	str	r2, [r3, #0]
	} while (y);
 801b8dc:	4639      	mov	r1, r7
 801b8de:	f04f 0200 	mov.w	r2, #0
 801b8e2:	f04f 0300 	mov.w	r3, #0
 801b8e6:	e9d1 0100 	ldrd	r0, r1, [r1]
 801b8ea:	f7e5 fb75 	bl	8000fd8 <__aeabi_dcmpeq>
 801b8ee:	4603      	mov	r3, r0
 801b8f0:	2b00      	cmp	r3, #0
 801b8f2:	d0bd      	beq.n	801b870 <fmt_fp+0x768>

	while (e2>0) {
 801b8f4:	e095      	b.n	801ba22 <fmt_fp+0x91a>
		uint32_t carry=0;
 801b8f6:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 801b8fa:	2200      	movs	r2, #0
 801b8fc:	601a      	str	r2, [r3, #0]
		int sh=MIN(29,e2);
 801b8fe:	f107 0310 	add.w	r3, r7, #16
 801b902:	681a      	ldr	r2, [r3, #0]
 801b904:	f107 0378 	add.w	r3, r7, #120	; 0x78
 801b908:	2a1d      	cmp	r2, #29
 801b90a:	bfa8      	it	ge
 801b90c:	221d      	movge	r2, #29
 801b90e:	601a      	str	r2, [r3, #0]
		for (d=z-1; d>=a; d--) {
 801b910:	f107 0318 	add.w	r3, r7, #24
 801b914:	f107 0220 	add.w	r2, r7, #32
 801b918:	6812      	ldr	r2, [r2, #0]
 801b91a:	3a04      	subs	r2, #4
 801b91c:	601a      	str	r2, [r3, #0]
 801b91e:	e044      	b.n	801b9aa <fmt_fp+0x8a2>
			uint64_t x = ((uint64_t)*d<<sh)+carry;
 801b920:	f107 0318 	add.w	r3, r7, #24
 801b924:	681b      	ldr	r3, [r3, #0]
 801b926:	681b      	ldr	r3, [r3, #0]
 801b928:	461a      	mov	r2, r3
 801b92a:	f04f 0300 	mov.w	r3, #0
 801b92e:	f107 0178 	add.w	r1, r7, #120	; 0x78
 801b932:	6809      	ldr	r1, [r1, #0]
 801b934:	f1a1 0620 	sub.w	r6, r1, #32
 801b938:	f1c1 0020 	rsb	r0, r1, #32
 801b93c:	fa03 f501 	lsl.w	r5, r3, r1
 801b940:	fa02 f606 	lsl.w	r6, r2, r6
 801b944:	4335      	orrs	r5, r6
 801b946:	fa22 f000 	lsr.w	r0, r2, r0
 801b94a:	4305      	orrs	r5, r0
 801b94c:	fa02 f401 	lsl.w	r4, r2, r1
 801b950:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 801b954:	681b      	ldr	r3, [r3, #0]
 801b956:	461a      	mov	r2, r3
 801b958:	f04f 0300 	mov.w	r3, #0
 801b95c:	eb14 0802 	adds.w	r8, r4, r2
 801b960:	eb45 0903 	adc.w	r9, r5, r3
 801b964:	e9c7 8926 	strd	r8, r9, [r7, #152]	; 0x98
			*d = x % 1000000000;
 801b968:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	; 0x98
 801b96c:	a346      	add	r3, pc, #280	; (adr r3, 801ba88 <fmt_fp+0x980>)
 801b96e:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b972:	f7e5 f80f 	bl	8000994 <__aeabi_uldivmod>
 801b976:	f107 0318 	add.w	r3, r7, #24
 801b97a:	681b      	ldr	r3, [r3, #0]
 801b97c:	601a      	str	r2, [r3, #0]
			carry = x / 1000000000;
 801b97e:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	; 0x98
 801b982:	a341      	add	r3, pc, #260	; (adr r3, 801ba88 <fmt_fp+0x980>)
 801b984:	e9d3 2300 	ldrd	r2, r3, [r3]
 801b988:	f7e5 f804 	bl	8000994 <__aeabi_uldivmod>
 801b98c:	4602      	mov	r2, r0
 801b98e:	460b      	mov	r3, r1
 801b990:	4610      	mov	r0, r2
 801b992:	4619      	mov	r1, r3
 801b994:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 801b998:	4602      	mov	r2, r0
 801b99a:	601a      	str	r2, [r3, #0]
		for (d=z-1; d>=a; d--) {
 801b99c:	f107 0318 	add.w	r3, r7, #24
 801b9a0:	f107 0218 	add.w	r2, r7, #24
 801b9a4:	6812      	ldr	r2, [r2, #0]
 801b9a6:	3a04      	subs	r2, #4
 801b9a8:	601a      	str	r2, [r3, #0]
 801b9aa:	f107 0218 	add.w	r2, r7, #24
 801b9ae:	f107 0314 	add.w	r3, r7, #20
 801b9b2:	6812      	ldr	r2, [r2, #0]
 801b9b4:	681b      	ldr	r3, [r3, #0]
 801b9b6:	429a      	cmp	r2, r3
 801b9b8:	d2b2      	bcs.n	801b920 <fmt_fp+0x818>
		}
		if (carry) *--a = carry;
 801b9ba:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 801b9be:	681b      	ldr	r3, [r3, #0]
 801b9c0:	2b00      	cmp	r3, #0
 801b9c2:	d015      	beq.n	801b9f0 <fmt_fp+0x8e8>
 801b9c4:	f107 0314 	add.w	r3, r7, #20
 801b9c8:	f107 0214 	add.w	r2, r7, #20
 801b9cc:	6812      	ldr	r2, [r2, #0]
 801b9ce:	3a04      	subs	r2, #4
 801b9d0:	601a      	str	r2, [r3, #0]
 801b9d2:	f107 0314 	add.w	r3, r7, #20
 801b9d6:	681b      	ldr	r3, [r3, #0]
 801b9d8:	f107 024c 	add.w	r2, r7, #76	; 0x4c
 801b9dc:	6812      	ldr	r2, [r2, #0]
 801b9de:	601a      	str	r2, [r3, #0]
		while (z>a && !z[-1]) z--;
 801b9e0:	e006      	b.n	801b9f0 <fmt_fp+0x8e8>
 801b9e2:	f107 0320 	add.w	r3, r7, #32
 801b9e6:	f107 0220 	add.w	r2, r7, #32
 801b9ea:	6812      	ldr	r2, [r2, #0]
 801b9ec:	3a04      	subs	r2, #4
 801b9ee:	601a      	str	r2, [r3, #0]
 801b9f0:	f107 0220 	add.w	r2, r7, #32
 801b9f4:	f107 0314 	add.w	r3, r7, #20
 801b9f8:	6812      	ldr	r2, [r2, #0]
 801b9fa:	681b      	ldr	r3, [r3, #0]
 801b9fc:	429a      	cmp	r2, r3
 801b9fe:	d906      	bls.n	801ba0e <fmt_fp+0x906>
 801ba00:	f107 0320 	add.w	r3, r7, #32
 801ba04:	681b      	ldr	r3, [r3, #0]
 801ba06:	3b04      	subs	r3, #4
 801ba08:	681b      	ldr	r3, [r3, #0]
 801ba0a:	2b00      	cmp	r3, #0
 801ba0c:	d0e9      	beq.n	801b9e2 <fmt_fp+0x8da>
		e2-=sh;
 801ba0e:	f107 0310 	add.w	r3, r7, #16
 801ba12:	681a      	ldr	r2, [r3, #0]
 801ba14:	f107 0378 	add.w	r3, r7, #120	; 0x78
 801ba18:	681b      	ldr	r3, [r3, #0]
 801ba1a:	1ad2      	subs	r2, r2, r3
 801ba1c:	f107 0310 	add.w	r3, r7, #16
 801ba20:	601a      	str	r2, [r3, #0]
	while (e2>0) {
 801ba22:	f107 0310 	add.w	r3, r7, #16
 801ba26:	681b      	ldr	r3, [r3, #0]
 801ba28:	2b00      	cmp	r3, #0
 801ba2a:	f73f af64 	bgt.w	801b8f6 <fmt_fp+0x7ee>
	}
	while (e2<0) {
 801ba2e:	e0c1      	b.n	801bbb4 <fmt_fp+0xaac>
		uint32_t carry=0, *b;
 801ba30:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801ba34:	2200      	movs	r2, #0
 801ba36:	601a      	str	r2, [r3, #0]
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
 801ba38:	f107 0310 	add.w	r3, r7, #16
 801ba3c:	681b      	ldr	r3, [r3, #0]
 801ba3e:	f113 0f09 	cmn.w	r3, #9
 801ba42:	db04      	blt.n	801ba4e <fmt_fp+0x946>
 801ba44:	f107 0310 	add.w	r3, r7, #16
 801ba48:	681b      	ldr	r3, [r3, #0]
 801ba4a:	425b      	negs	r3, r3
 801ba4c:	e000      	b.n	801ba50 <fmt_fp+0x948>
 801ba4e:	2309      	movs	r3, #9
 801ba50:	f107 0268 	add.w	r2, r7, #104	; 0x68
 801ba54:	6013      	str	r3, [r2, #0]
 801ba56:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801ba5a:	3319      	adds	r3, #25
 801ba5c:	4a0d      	ldr	r2, [pc, #52]	; (801ba94 <fmt_fp+0x98c>)
 801ba5e:	fba2 2303 	umull	r2, r3, r2, r3
 801ba62:	085b      	lsrs	r3, r3, #1
 801ba64:	1c5a      	adds	r2, r3, #1
 801ba66:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801ba6a:	601a      	str	r2, [r3, #0]
		for (d=a; d<z; d++) {
 801ba6c:	f107 0318 	add.w	r3, r7, #24
 801ba70:	f107 0214 	add.w	r2, r7, #20
 801ba74:	6812      	ldr	r2, [r2, #0]
 801ba76:	601a      	str	r2, [r3, #0]
 801ba78:	e044      	b.n	801bb04 <fmt_fp+0x9fc>
 801ba7a:	bf00      	nop
 801ba7c:	f3af 8000 	nop.w
 801ba80:	00000000 	.word	0x00000000
 801ba84:	41cdcd65 	.word	0x41cdcd65
 801ba88:	3b9aca00 	.word	0x3b9aca00
 801ba8c:	00000000 	.word	0x00000000
 801ba90:	41b00000 	.word	0x41b00000
 801ba94:	38e38e39 	.word	0x38e38e39
			uint32_t rm = *d & ((1<<sh)-1);
 801ba98:	f107 0318 	add.w	r3, r7, #24
 801ba9c:	681b      	ldr	r3, [r3, #0]
 801ba9e:	681a      	ldr	r2, [r3, #0]
 801baa0:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801baa4:	2101      	movs	r1, #1
 801baa6:	681b      	ldr	r3, [r3, #0]
 801baa8:	fa01 f303 	lsl.w	r3, r1, r3
 801baac:	3b01      	subs	r3, #1
 801baae:	4619      	mov	r1, r3
 801bab0:	f107 0374 	add.w	r3, r7, #116	; 0x74
 801bab4:	400a      	ands	r2, r1
 801bab6:	601a      	str	r2, [r3, #0]
			*d = (*d>>sh) + carry;
 801bab8:	f107 0318 	add.w	r3, r7, #24
 801babc:	681b      	ldr	r3, [r3, #0]
 801babe:	681a      	ldr	r2, [r3, #0]
 801bac0:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801bac4:	681b      	ldr	r3, [r3, #0]
 801bac6:	40da      	lsrs	r2, r3
 801bac8:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801bacc:	681b      	ldr	r3, [r3, #0]
 801bace:	441a      	add	r2, r3
 801bad0:	f107 0318 	add.w	r3, r7, #24
 801bad4:	681b      	ldr	r3, [r3, #0]
 801bad6:	601a      	str	r2, [r3, #0]
			carry = (1000000000>>sh) * rm;
 801bad8:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801badc:	4a8d      	ldr	r2, [pc, #564]	; (801bd14 <fmt_fp+0xc0c>)
 801bade:	681b      	ldr	r3, [r3, #0]
 801bae0:	fa42 f303 	asr.w	r3, r2, r3
 801bae4:	4619      	mov	r1, r3
 801bae6:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801baea:	f107 0274 	add.w	r2, r7, #116	; 0x74
 801baee:	6812      	ldr	r2, [r2, #0]
 801baf0:	fb01 f202 	mul.w	r2, r1, r2
 801baf4:	601a      	str	r2, [r3, #0]
		for (d=a; d<z; d++) {
 801baf6:	f107 0318 	add.w	r3, r7, #24
 801bafa:	f107 0218 	add.w	r2, r7, #24
 801bafe:	6812      	ldr	r2, [r2, #0]
 801bb00:	3204      	adds	r2, #4
 801bb02:	601a      	str	r2, [r3, #0]
 801bb04:	f107 0218 	add.w	r2, r7, #24
 801bb08:	f107 0320 	add.w	r3, r7, #32
 801bb0c:	6812      	ldr	r2, [r2, #0]
 801bb0e:	681b      	ldr	r3, [r3, #0]
 801bb10:	429a      	cmp	r2, r3
 801bb12:	d3c1      	bcc.n	801ba98 <fmt_fp+0x990>
		}
		if (!*a) a++;
 801bb14:	f107 0314 	add.w	r3, r7, #20
 801bb18:	681b      	ldr	r3, [r3, #0]
 801bb1a:	681b      	ldr	r3, [r3, #0]
 801bb1c:	2b00      	cmp	r3, #0
 801bb1e:	d106      	bne.n	801bb2e <fmt_fp+0xa26>
 801bb20:	f107 0314 	add.w	r3, r7, #20
 801bb24:	f107 0214 	add.w	r2, r7, #20
 801bb28:	6812      	ldr	r2, [r2, #0]
 801bb2a:	3204      	adds	r2, #4
 801bb2c:	601a      	str	r2, [r3, #0]
		if (carry) *z++ = carry;
 801bb2e:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801bb32:	681b      	ldr	r3, [r3, #0]
 801bb34:	2b00      	cmp	r3, #0
 801bb36:	d00a      	beq.n	801bb4e <fmt_fp+0xa46>
 801bb38:	f107 0320 	add.w	r3, r7, #32
 801bb3c:	681b      	ldr	r3, [r3, #0]
 801bb3e:	f107 0220 	add.w	r2, r7, #32
 801bb42:	1d19      	adds	r1, r3, #4
 801bb44:	6011      	str	r1, [r2, #0]
 801bb46:	f107 0250 	add.w	r2, r7, #80	; 0x50
 801bb4a:	6812      	ldr	r2, [r2, #0]
 801bb4c:	601a      	str	r2, [r3, #0]
		/* Avoid (slow!) computation past requested precision */
		b = (t|32)=='f' ? r : a;
 801bb4e:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801bb52:	f043 0320 	orr.w	r3, r3, #32
 801bb56:	2b66      	cmp	r3, #102	; 0x66
 801bb58:	d103      	bne.n	801bb62 <fmt_fp+0xa5a>
 801bb5a:	f107 031c 	add.w	r3, r7, #28
 801bb5e:	681b      	ldr	r3, [r3, #0]
 801bb60:	e002      	b.n	801bb68 <fmt_fp+0xa60>
 801bb62:	f107 0314 	add.w	r3, r7, #20
 801bb66:	681b      	ldr	r3, [r3, #0]
 801bb68:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801bb6c:	6013      	str	r3, [r2, #0]
		if (z-b > need) z = b+need;
 801bb6e:	f107 0220 	add.w	r2, r7, #32
 801bb72:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801bb76:	6812      	ldr	r2, [r2, #0]
 801bb78:	681b      	ldr	r3, [r3, #0]
 801bb7a:	1ad3      	subs	r3, r2, r3
 801bb7c:	109b      	asrs	r3, r3, #2
 801bb7e:	461a      	mov	r2, r3
 801bb80:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801bb84:	681b      	ldr	r3, [r3, #0]
 801bb86:	4293      	cmp	r3, r2
 801bb88:	da0a      	bge.n	801bba0 <fmt_fp+0xa98>
 801bb8a:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 801bb8e:	681b      	ldr	r3, [r3, #0]
 801bb90:	009a      	lsls	r2, r3, #2
 801bb92:	f107 0320 	add.w	r3, r7, #32
 801bb96:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801bb9a:	6809      	ldr	r1, [r1, #0]
 801bb9c:	440a      	add	r2, r1
 801bb9e:	601a      	str	r2, [r3, #0]
		e2+=sh;
 801bba0:	f107 0310 	add.w	r3, r7, #16
 801bba4:	681a      	ldr	r2, [r3, #0]
 801bba6:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801bbaa:	681b      	ldr	r3, [r3, #0]
 801bbac:	441a      	add	r2, r3
 801bbae:	f107 0310 	add.w	r3, r7, #16
 801bbb2:	601a      	str	r2, [r3, #0]
	while (e2<0) {
 801bbb4:	f107 0310 	add.w	r3, r7, #16
 801bbb8:	681b      	ldr	r3, [r3, #0]
 801bbba:	2b00      	cmp	r3, #0
 801bbbc:	f6ff af38 	blt.w	801ba30 <fmt_fp+0x928>
	}

	if (a<z) for (i=10, e=9*(r-a); *a>=(uint32_t)i; i*=10, e++);
 801bbc0:	f107 0214 	add.w	r2, r7, #20
 801bbc4:	f107 0320 	add.w	r3, r7, #32
 801bbc8:	6812      	ldr	r2, [r2, #0]
 801bbca:	681b      	ldr	r3, [r3, #0]
 801bbcc:	429a      	cmp	r2, r3
 801bbce:	d22e      	bcs.n	801bc2e <fmt_fp+0xb26>
 801bbd0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bbd4:	220a      	movs	r2, #10
 801bbd6:	601a      	str	r2, [r3, #0]
 801bbd8:	f107 021c 	add.w	r2, r7, #28
 801bbdc:	f107 0314 	add.w	r3, r7, #20
 801bbe0:	6812      	ldr	r2, [r2, #0]
 801bbe2:	681b      	ldr	r3, [r3, #0]
 801bbe4:	1ad3      	subs	r3, r2, r3
 801bbe6:	109b      	asrs	r3, r3, #2
 801bbe8:	4619      	mov	r1, r3
 801bbea:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801bbee:	460b      	mov	r3, r1
 801bbf0:	00db      	lsls	r3, r3, #3
 801bbf2:	440b      	add	r3, r1
 801bbf4:	6013      	str	r3, [r2, #0]
 801bbf6:	e010      	b.n	801bc1a <fmt_fp+0xb12>
 801bbf8:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801bbfc:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bc00:	681a      	ldr	r2, [r3, #0]
 801bc02:	4613      	mov	r3, r2
 801bc04:	009b      	lsls	r3, r3, #2
 801bc06:	4413      	add	r3, r2
 801bc08:	005b      	lsls	r3, r3, #1
 801bc0a:	600b      	str	r3, [r1, #0]
 801bc0c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801bc10:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801bc14:	6812      	ldr	r2, [r2, #0]
 801bc16:	3201      	adds	r2, #1
 801bc18:	601a      	str	r2, [r3, #0]
 801bc1a:	f107 0314 	add.w	r3, r7, #20
 801bc1e:	681b      	ldr	r3, [r3, #0]
 801bc20:	681a      	ldr	r2, [r3, #0]
 801bc22:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bc26:	681b      	ldr	r3, [r3, #0]
 801bc28:	429a      	cmp	r2, r3
 801bc2a:	d2e5      	bcs.n	801bbf8 <fmt_fp+0xaf0>
 801bc2c:	e003      	b.n	801bc36 <fmt_fp+0xb2e>
	else e=0;
 801bc2e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801bc32:	2200      	movs	r2, #0
 801bc34:	601a      	str	r2, [r3, #0]

	/* Perform rounding: j is precision after the radix (possibly neg) */
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
 801bc36:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801bc3a:	f043 0320 	orr.w	r3, r3, #32
 801bc3e:	2b66      	cmp	r3, #102	; 0x66
 801bc40:	bf14      	ite	ne
 801bc42:	2301      	movne	r3, #1
 801bc44:	2300      	moveq	r3, #0
 801bc46:	b2db      	uxtb	r3, r3
 801bc48:	461a      	mov	r2, r3
 801bc4a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801bc4e:	681b      	ldr	r3, [r3, #0]
 801bc50:	fb03 f302 	mul.w	r3, r3, r2
 801bc54:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801bc58:	1ad1      	subs	r1, r2, r3
 801bc5a:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801bc5e:	f043 0320 	orr.w	r3, r3, #32
 801bc62:	2b67      	cmp	r3, #103	; 0x67
 801bc64:	d105      	bne.n	801bc72 <fmt_fp+0xb6a>
 801bc66:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801bc6a:	2b00      	cmp	r3, #0
 801bc6c:	d001      	beq.n	801bc72 <fmt_fp+0xb6a>
 801bc6e:	2201      	movs	r2, #1
 801bc70:	e000      	b.n	801bc74 <fmt_fp+0xb6c>
 801bc72:	2200      	movs	r2, #0
 801bc74:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bc78:	1a8a      	subs	r2, r1, r2
 801bc7a:	601a      	str	r2, [r3, #0]
	if (j < 9*(z-r-1)) {
 801bc7c:	f107 0220 	add.w	r2, r7, #32
 801bc80:	f107 031c 	add.w	r3, r7, #28
 801bc84:	6812      	ldr	r2, [r2, #0]
 801bc86:	681b      	ldr	r3, [r3, #0]
 801bc88:	1ad3      	subs	r3, r2, r3
 801bc8a:	109b      	asrs	r3, r3, #2
 801bc8c:	1e5a      	subs	r2, r3, #1
 801bc8e:	4613      	mov	r3, r2
 801bc90:	00db      	lsls	r3, r3, #3
 801bc92:	4413      	add	r3, r2
 801bc94:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 801bc98:	6812      	ldr	r2, [r2, #0]
 801bc9a:	429a      	cmp	r2, r3
 801bc9c:	f280 81a9 	bge.w	801bff2 <fmt_fp+0xeea>
		uint32_t x;
		/* We avoid C's broken division of negative numbers */
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
 801bca0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bca4:	681b      	ldr	r3, [r3, #0]
 801bca6:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
 801bcaa:	4a1b      	ldr	r2, [pc, #108]	; (801bd18 <fmt_fp+0xc10>)
 801bcac:	fb82 1203 	smull	r1, r2, r2, r3
 801bcb0:	1052      	asrs	r2, r2, #1
 801bcb2:	17db      	asrs	r3, r3, #31
 801bcb4:	1ad3      	subs	r3, r2, r3
 801bcb6:	461a      	mov	r2, r3
 801bcb8:	4b18      	ldr	r3, [pc, #96]	; (801bd1c <fmt_fp+0xc14>)
 801bcba:	4413      	add	r3, r2
 801bcbc:	009a      	lsls	r2, r3, #2
 801bcbe:	f107 0318 	add.w	r3, r7, #24
 801bcc2:	f107 011c 	add.w	r1, r7, #28
 801bcc6:	6809      	ldr	r1, [r1, #0]
 801bcc8:	440a      	add	r2, r1
 801bcca:	601a      	str	r2, [r3, #0]
		j += 9*LDBL_MAX_EXP;
 801bccc:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bcd0:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 801bcd4:	6812      	ldr	r2, [r2, #0]
 801bcd6:	f502 5210 	add.w	r2, r2, #9216	; 0x2400
 801bcda:	601a      	str	r2, [r3, #0]
		j %= 9;
 801bcdc:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 801bce0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bce4:	681a      	ldr	r2, [r3, #0]
 801bce6:	4b0c      	ldr	r3, [pc, #48]	; (801bd18 <fmt_fp+0xc10>)
 801bce8:	fb83 1302 	smull	r1, r3, r3, r2
 801bcec:	1059      	asrs	r1, r3, #1
 801bcee:	17d3      	asrs	r3, r2, #31
 801bcf0:	1ac9      	subs	r1, r1, r3
 801bcf2:	460b      	mov	r3, r1
 801bcf4:	00db      	lsls	r3, r3, #3
 801bcf6:	440b      	add	r3, r1
 801bcf8:	1ad3      	subs	r3, r2, r3
 801bcfa:	6003      	str	r3, [r0, #0]
		for (i=10, j++; j<9; i*=10, j++);
 801bcfc:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bd00:	220a      	movs	r2, #10
 801bd02:	601a      	str	r2, [r3, #0]
 801bd04:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bd08:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 801bd0c:	6812      	ldr	r2, [r2, #0]
 801bd0e:	3201      	adds	r2, #1
 801bd10:	601a      	str	r2, [r3, #0]
 801bd12:	e016      	b.n	801bd42 <fmt_fp+0xc3a>
 801bd14:	3b9aca00 	.word	0x3b9aca00
 801bd18:	38e38e39 	.word	0x38e38e39
 801bd1c:	3ffffc01 	.word	0x3ffffc01
 801bd20:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801bd24:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bd28:	681a      	ldr	r2, [r3, #0]
 801bd2a:	4613      	mov	r3, r2
 801bd2c:	009b      	lsls	r3, r3, #2
 801bd2e:	4413      	add	r3, r2
 801bd30:	005b      	lsls	r3, r3, #1
 801bd32:	600b      	str	r3, [r1, #0]
 801bd34:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bd38:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 801bd3c:	6812      	ldr	r2, [r2, #0]
 801bd3e:	3201      	adds	r2, #1
 801bd40:	601a      	str	r2, [r3, #0]
 801bd42:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801bd46:	681b      	ldr	r3, [r3, #0]
 801bd48:	2b08      	cmp	r3, #8
 801bd4a:	dde9      	ble.n	801bd20 <fmt_fp+0xc18>
		x = *d % i;
 801bd4c:	f107 0318 	add.w	r3, r7, #24
 801bd50:	681b      	ldr	r3, [r3, #0]
 801bd52:	681b      	ldr	r3, [r3, #0]
 801bd54:	f107 0228 	add.w	r2, r7, #40	; 0x28
 801bd58:	6812      	ldr	r2, [r2, #0]
 801bd5a:	f107 0164 	add.w	r1, r7, #100	; 0x64
 801bd5e:	fbb3 f0f2 	udiv	r0, r3, r2
 801bd62:	fb02 f200 	mul.w	r2, r2, r0
 801bd66:	1a9b      	subs	r3, r3, r2
 801bd68:	600b      	str	r3, [r1, #0]
		/* Are there any significant digits past j? */
		if (x || d+1!=z) {
 801bd6a:	f107 0364 	add.w	r3, r7, #100	; 0x64
 801bd6e:	681b      	ldr	r3, [r3, #0]
 801bd70:	2b00      	cmp	r3, #0
 801bd72:	d109      	bne.n	801bd88 <fmt_fp+0xc80>
 801bd74:	f107 0318 	add.w	r3, r7, #24
 801bd78:	681b      	ldr	r3, [r3, #0]
 801bd7a:	3304      	adds	r3, #4
 801bd7c:	f107 0220 	add.w	r2, r7, #32
 801bd80:	6812      	ldr	r2, [r2, #0]
 801bd82:	429a      	cmp	r2, r3
 801bd84:	f000 811d 	beq.w	801bfc2 <fmt_fp+0xeba>
			ldouble_t round = 2/LDBL_EPSILON;
 801bd88:	f107 0188 	add.w	r1, r7, #136	; 0x88
 801bd8c:	f04f 0200 	mov.w	r2, #0
 801bd90:	4bb5      	ldr	r3, [pc, #724]	; (801c068 <fmt_fp+0xf60>)
 801bd92:	e9c1 2300 	strd	r2, r3, [r1]
			ldouble_t small;
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
 801bd96:	f107 0318 	add.w	r3, r7, #24
 801bd9a:	681b      	ldr	r3, [r3, #0]
 801bd9c:	681a      	ldr	r2, [r3, #0]
 801bd9e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bda2:	681b      	ldr	r3, [r3, #0]
 801bda4:	fbb2 f3f3 	udiv	r3, r2, r3
 801bda8:	f003 0301 	and.w	r3, r3, #1
 801bdac:	2b00      	cmp	r3, #0
 801bdae:	d116      	bne.n	801bdde <fmt_fp+0xcd6>
 801bdb0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bdb4:	681b      	ldr	r3, [r3, #0]
 801bdb6:	4aad      	ldr	r2, [pc, #692]	; (801c06c <fmt_fp+0xf64>)
 801bdb8:	4293      	cmp	r3, r2
 801bdba:	d120      	bne.n	801bdfe <fmt_fp+0xcf6>
 801bdbc:	f107 0218 	add.w	r2, r7, #24
 801bdc0:	f107 0314 	add.w	r3, r7, #20
 801bdc4:	6812      	ldr	r2, [r2, #0]
 801bdc6:	681b      	ldr	r3, [r3, #0]
 801bdc8:	429a      	cmp	r2, r3
 801bdca:	d918      	bls.n	801bdfe <fmt_fp+0xcf6>
 801bdcc:	f107 0318 	add.w	r3, r7, #24
 801bdd0:	681b      	ldr	r3, [r3, #0]
 801bdd2:	3b04      	subs	r3, #4
 801bdd4:	681b      	ldr	r3, [r3, #0]
 801bdd6:	f003 0301 	and.w	r3, r3, #1
 801bdda:	2b00      	cmp	r3, #0
 801bddc:	d00f      	beq.n	801bdfe <fmt_fp+0xcf6>
				round += 2;
 801bdde:	f107 0488 	add.w	r4, r7, #136	; 0x88
 801bde2:	f107 0188 	add.w	r1, r7, #136	; 0x88
 801bde6:	f04f 0200 	mov.w	r2, #0
 801bdea:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 801bdee:	e9d1 0100 	ldrd	r0, r1, [r1]
 801bdf2:	f7e4 fa07 	bl	8000204 <__adddf3>
 801bdf6:	4602      	mov	r2, r0
 801bdf8:	460b      	mov	r3, r1
 801bdfa:	e9c4 2300 	strd	r2, r3, [r4]
			if (x<(uint32_t)(i/2)) small=0x0.8p0;
 801bdfe:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801be02:	681b      	ldr	r3, [r3, #0]
 801be04:	2b00      	cmp	r3, #0
 801be06:	da00      	bge.n	801be0a <fmt_fp+0xd02>
 801be08:	3301      	adds	r3, #1
 801be0a:	105b      	asrs	r3, r3, #1
 801be0c:	461a      	mov	r2, r3
 801be0e:	f107 0364 	add.w	r3, r7, #100	; 0x64
 801be12:	681b      	ldr	r3, [r3, #0]
 801be14:	4293      	cmp	r3, r2
 801be16:	d207      	bcs.n	801be28 <fmt_fp+0xd20>
 801be18:	f107 0190 	add.w	r1, r7, #144	; 0x90
 801be1c:	f04f 0200 	mov.w	r2, #0
 801be20:	4b93      	ldr	r3, [pc, #588]	; (801c070 <fmt_fp+0xf68>)
 801be22:	e9c1 2300 	strd	r2, r3, [r1]
 801be26:	e024      	b.n	801be72 <fmt_fp+0xd6a>
			else if ((int)x==i/2 && d+1==z) small=0x1.0p0;
 801be28:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801be2c:	681b      	ldr	r3, [r3, #0]
 801be2e:	2b00      	cmp	r3, #0
 801be30:	da00      	bge.n	801be34 <fmt_fp+0xd2c>
 801be32:	3301      	adds	r3, #1
 801be34:	105b      	asrs	r3, r3, #1
 801be36:	461a      	mov	r2, r3
 801be38:	f107 0364 	add.w	r3, r7, #100	; 0x64
 801be3c:	681b      	ldr	r3, [r3, #0]
 801be3e:	429a      	cmp	r2, r3
 801be40:	d110      	bne.n	801be64 <fmt_fp+0xd5c>
 801be42:	f107 0318 	add.w	r3, r7, #24
 801be46:	681b      	ldr	r3, [r3, #0]
 801be48:	3304      	adds	r3, #4
 801be4a:	f107 0220 	add.w	r2, r7, #32
 801be4e:	6812      	ldr	r2, [r2, #0]
 801be50:	429a      	cmp	r2, r3
 801be52:	d107      	bne.n	801be64 <fmt_fp+0xd5c>
 801be54:	f107 0190 	add.w	r1, r7, #144	; 0x90
 801be58:	f04f 0200 	mov.w	r2, #0
 801be5c:	4b85      	ldr	r3, [pc, #532]	; (801c074 <fmt_fp+0xf6c>)
 801be5e:	e9c1 2300 	strd	r2, r3, [r1]
 801be62:	e006      	b.n	801be72 <fmt_fp+0xd6a>
			else small=0x1.8p0;
 801be64:	f107 0190 	add.w	r1, r7, #144	; 0x90
 801be68:	f04f 0200 	mov.w	r2, #0
 801be6c:	4b82      	ldr	r3, [pc, #520]	; (801c078 <fmt_fp+0xf70>)
 801be6e:	e9c1 2300 	strd	r2, r3, [r1]
			if (pl && *prefix=='-') round*=-1, small*=-1;
 801be72:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801be76:	681b      	ldr	r3, [r3, #0]
 801be78:	2b00      	cmp	r3, #0
 801be7a:	d019      	beq.n	801beb0 <fmt_fp+0xda8>
 801be7c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801be80:	681b      	ldr	r3, [r3, #0]
 801be82:	781b      	ldrb	r3, [r3, #0]
 801be84:	2b2d      	cmp	r3, #45	; 0x2d
 801be86:	d113      	bne.n	801beb0 <fmt_fp+0xda8>
 801be88:	f107 0388 	add.w	r3, r7, #136	; 0x88
 801be8c:	f107 0288 	add.w	r2, r7, #136	; 0x88
 801be90:	6811      	ldr	r1, [r2, #0]
 801be92:	6019      	str	r1, [r3, #0]
 801be94:	6852      	ldr	r2, [r2, #4]
 801be96:	f082 4200 	eor.w	r2, r2, #2147483648	; 0x80000000
 801be9a:	605a      	str	r2, [r3, #4]
 801be9c:	f107 0390 	add.w	r3, r7, #144	; 0x90
 801bea0:	f107 0290 	add.w	r2, r7, #144	; 0x90
 801bea4:	6811      	ldr	r1, [r2, #0]
 801bea6:	6019      	str	r1, [r3, #0]
 801bea8:	6852      	ldr	r2, [r2, #4]
 801beaa:	f082 4200 	eor.w	r2, r2, #2147483648	; 0x80000000
 801beae:	605a      	str	r2, [r3, #4]
			*d -= x;
 801beb0:	f107 0318 	add.w	r3, r7, #24
 801beb4:	681b      	ldr	r3, [r3, #0]
 801beb6:	681a      	ldr	r2, [r3, #0]
 801beb8:	f107 0364 	add.w	r3, r7, #100	; 0x64
 801bebc:	681b      	ldr	r3, [r3, #0]
 801bebe:	1ad2      	subs	r2, r2, r3
 801bec0:	f107 0318 	add.w	r3, r7, #24
 801bec4:	681b      	ldr	r3, [r3, #0]
 801bec6:	601a      	str	r2, [r3, #0]
			/* Decide whether to round by probing round+small */
			if (round+small != round) {
 801bec8:	f107 0188 	add.w	r1, r7, #136	; 0x88
 801becc:	f107 0390 	add.w	r3, r7, #144	; 0x90
 801bed0:	e9d3 2300 	ldrd	r2, r3, [r3]
 801bed4:	e9d1 0100 	ldrd	r0, r1, [r1]
 801bed8:	f7e4 f994 	bl	8000204 <__adddf3>
 801bedc:	4602      	mov	r2, r0
 801bede:	460b      	mov	r3, r1
 801bee0:	f107 0188 	add.w	r1, r7, #136	; 0x88
 801bee4:	e9d1 0100 	ldrd	r0, r1, [r1]
 801bee8:	f7e5 f876 	bl	8000fd8 <__aeabi_dcmpeq>
 801beec:	4603      	mov	r3, r0
 801beee:	2b00      	cmp	r3, #0
 801bef0:	d167      	bne.n	801bfc2 <fmt_fp+0xeba>
				*d = *d + i;
 801bef2:	f107 0318 	add.w	r3, r7, #24
 801bef6:	681b      	ldr	r3, [r3, #0]
 801bef8:	681a      	ldr	r2, [r3, #0]
 801befa:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801befe:	681b      	ldr	r3, [r3, #0]
 801bf00:	441a      	add	r2, r3
 801bf02:	f107 0318 	add.w	r3, r7, #24
 801bf06:	681b      	ldr	r3, [r3, #0]
 801bf08:	601a      	str	r2, [r3, #0]
				while (*d > 999999999) {
 801bf0a:	e025      	b.n	801bf58 <fmt_fp+0xe50>
					*d--=0;
 801bf0c:	f107 0318 	add.w	r3, r7, #24
 801bf10:	681b      	ldr	r3, [r3, #0]
 801bf12:	f107 0218 	add.w	r2, r7, #24
 801bf16:	1f19      	subs	r1, r3, #4
 801bf18:	6011      	str	r1, [r2, #0]
 801bf1a:	2200      	movs	r2, #0
 801bf1c:	601a      	str	r2, [r3, #0]
					if (d<a) *--a=0;
 801bf1e:	f107 0218 	add.w	r2, r7, #24
 801bf22:	f107 0314 	add.w	r3, r7, #20
 801bf26:	6812      	ldr	r2, [r2, #0]
 801bf28:	681b      	ldr	r3, [r3, #0]
 801bf2a:	429a      	cmp	r2, r3
 801bf2c:	d20b      	bcs.n	801bf46 <fmt_fp+0xe3e>
 801bf2e:	f107 0314 	add.w	r3, r7, #20
 801bf32:	f107 0214 	add.w	r2, r7, #20
 801bf36:	6812      	ldr	r2, [r2, #0]
 801bf38:	3a04      	subs	r2, #4
 801bf3a:	601a      	str	r2, [r3, #0]
 801bf3c:	f107 0314 	add.w	r3, r7, #20
 801bf40:	681b      	ldr	r3, [r3, #0]
 801bf42:	2200      	movs	r2, #0
 801bf44:	601a      	str	r2, [r3, #0]
					(*d)++;
 801bf46:	f107 0318 	add.w	r3, r7, #24
 801bf4a:	681b      	ldr	r3, [r3, #0]
 801bf4c:	681b      	ldr	r3, [r3, #0]
 801bf4e:	1c5a      	adds	r2, r3, #1
 801bf50:	f107 0318 	add.w	r3, r7, #24
 801bf54:	681b      	ldr	r3, [r3, #0]
 801bf56:	601a      	str	r2, [r3, #0]
				while (*d > 999999999) {
 801bf58:	f107 0318 	add.w	r3, r7, #24
 801bf5c:	681b      	ldr	r3, [r3, #0]
 801bf5e:	681b      	ldr	r3, [r3, #0]
 801bf60:	4a46      	ldr	r2, [pc, #280]	; (801c07c <fmt_fp+0xf74>)
 801bf62:	4293      	cmp	r3, r2
 801bf64:	d8d2      	bhi.n	801bf0c <fmt_fp+0xe04>
				}
				for (i=10, e=9*(r-a); *a>=(uint32_t)i; i*=10, e++);
 801bf66:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bf6a:	220a      	movs	r2, #10
 801bf6c:	601a      	str	r2, [r3, #0]
 801bf6e:	f107 021c 	add.w	r2, r7, #28
 801bf72:	f107 0314 	add.w	r3, r7, #20
 801bf76:	6812      	ldr	r2, [r2, #0]
 801bf78:	681b      	ldr	r3, [r3, #0]
 801bf7a:	1ad3      	subs	r3, r2, r3
 801bf7c:	109b      	asrs	r3, r3, #2
 801bf7e:	4619      	mov	r1, r3
 801bf80:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801bf84:	460b      	mov	r3, r1
 801bf86:	00db      	lsls	r3, r3, #3
 801bf88:	440b      	add	r3, r1
 801bf8a:	6013      	str	r3, [r2, #0]
 801bf8c:	e010      	b.n	801bfb0 <fmt_fp+0xea8>
 801bf8e:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801bf92:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bf96:	681a      	ldr	r2, [r3, #0]
 801bf98:	4613      	mov	r3, r2
 801bf9a:	009b      	lsls	r3, r3, #2
 801bf9c:	4413      	add	r3, r2
 801bf9e:	005b      	lsls	r3, r3, #1
 801bfa0:	600b      	str	r3, [r1, #0]
 801bfa2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801bfa6:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801bfaa:	6812      	ldr	r2, [r2, #0]
 801bfac:	3201      	adds	r2, #1
 801bfae:	601a      	str	r2, [r3, #0]
 801bfb0:	f107 0314 	add.w	r3, r7, #20
 801bfb4:	681b      	ldr	r3, [r3, #0]
 801bfb6:	681a      	ldr	r2, [r3, #0]
 801bfb8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801bfbc:	681b      	ldr	r3, [r3, #0]
 801bfbe:	429a      	cmp	r2, r3
 801bfc0:	d2e5      	bcs.n	801bf8e <fmt_fp+0xe86>
			}
		}
		if (z>d+1) z=d+1;
 801bfc2:	f107 0318 	add.w	r3, r7, #24
 801bfc6:	681b      	ldr	r3, [r3, #0]
 801bfc8:	3304      	adds	r3, #4
 801bfca:	f107 0220 	add.w	r2, r7, #32
 801bfce:	6812      	ldr	r2, [r2, #0]
 801bfd0:	429a      	cmp	r2, r3
 801bfd2:	d90e      	bls.n	801bff2 <fmt_fp+0xeea>
 801bfd4:	f107 0320 	add.w	r3, r7, #32
 801bfd8:	f107 0218 	add.w	r2, r7, #24
 801bfdc:	6812      	ldr	r2, [r2, #0]
 801bfde:	3204      	adds	r2, #4
 801bfe0:	601a      	str	r2, [r3, #0]
	}
	for (; z>a && !z[-1]; z--);
 801bfe2:	e006      	b.n	801bff2 <fmt_fp+0xeea>
 801bfe4:	f107 0320 	add.w	r3, r7, #32
 801bfe8:	f107 0220 	add.w	r2, r7, #32
 801bfec:	6812      	ldr	r2, [r2, #0]
 801bfee:	3a04      	subs	r2, #4
 801bff0:	601a      	str	r2, [r3, #0]
 801bff2:	f107 0220 	add.w	r2, r7, #32
 801bff6:	f107 0314 	add.w	r3, r7, #20
 801bffa:	6812      	ldr	r2, [r2, #0]
 801bffc:	681b      	ldr	r3, [r3, #0]
 801bffe:	429a      	cmp	r2, r3
 801c000:	d906      	bls.n	801c010 <fmt_fp+0xf08>
 801c002:	f107 0320 	add.w	r3, r7, #32
 801c006:	681b      	ldr	r3, [r3, #0]
 801c008:	3b04      	subs	r3, #4
 801c00a:	681b      	ldr	r3, [r3, #0]
 801c00c:	2b00      	cmp	r3, #0
 801c00e:	d0e9      	beq.n	801bfe4 <fmt_fp+0xedc>
	
	if ((t|32)=='g') {
 801c010:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801c014:	f043 0320 	orr.w	r3, r3, #32
 801c018:	2b67      	cmp	r3, #103	; 0x67
 801c01a:	f040 80bb 	bne.w	801c194 <fmt_fp+0x108c>
		if (!p) p++;
 801c01e:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c022:	2b00      	cmp	r3, #0
 801c024:	d104      	bne.n	801c030 <fmt_fp+0xf28>
 801c026:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c02a:	3301      	adds	r3, #1
 801c02c:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
		if (p>e && e>=-4) {
 801c030:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801c034:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801c038:	681b      	ldr	r3, [r3, #0]
 801c03a:	429a      	cmp	r2, r3
 801c03c:	dd20      	ble.n	801c080 <fmt_fp+0xf78>
 801c03e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801c042:	681b      	ldr	r3, [r3, #0]
 801c044:	f113 0f04 	cmn.w	r3, #4
 801c048:	db1a      	blt.n	801c080 <fmt_fp+0xf78>
			t--;
 801c04a:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801c04e:	3b01      	subs	r3, #1
 801c050:	f8c7 32f4 	str.w	r3, [r7, #756]	; 0x2f4
			p-=e+1;
 801c054:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801c058:	681b      	ldr	r3, [r3, #0]
 801c05a:	3301      	adds	r3, #1
 801c05c:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801c060:	1ad3      	subs	r3, r2, r3
 801c062:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
 801c066:	e015      	b.n	801c094 <fmt_fp+0xf8c>
 801c068:	43400000 	.word	0x43400000
 801c06c:	3b9aca00 	.word	0x3b9aca00
 801c070:	3fe00000 	.word	0x3fe00000
 801c074:	3ff00000 	.word	0x3ff00000
 801c078:	3ff80000 	.word	0x3ff80000
 801c07c:	3b9ac9ff 	.word	0x3b9ac9ff
		} else {
			t-=2;
 801c080:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801c084:	3b02      	subs	r3, #2
 801c086:	f8c7 32f4 	str.w	r3, [r7, #756]	; 0x2f4
			p--;
 801c08a:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c08e:	3b01      	subs	r3, #1
 801c090:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
		}
		if (!(fl&ALT_FORM)) {
 801c094:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c098:	f003 0308 	and.w	r3, r3, #8
 801c09c:	2b00      	cmp	r3, #0
 801c09e:	d179      	bne.n	801c194 <fmt_fp+0x108c>
			/* Count trailing zeros in last place */
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
 801c0a0:	f107 0220 	add.w	r2, r7, #32
 801c0a4:	f107 0314 	add.w	r3, r7, #20
 801c0a8:	6812      	ldr	r2, [r2, #0]
 801c0aa:	681b      	ldr	r3, [r3, #0]
 801c0ac:	429a      	cmp	r2, r3
 801c0ae:	d930      	bls.n	801c112 <fmt_fp+0x100a>
 801c0b0:	f107 0320 	add.w	r3, r7, #32
 801c0b4:	681b      	ldr	r3, [r3, #0]
 801c0b6:	3b04      	subs	r3, #4
 801c0b8:	681b      	ldr	r3, [r3, #0]
 801c0ba:	2b00      	cmp	r3, #0
 801c0bc:	d029      	beq.n	801c112 <fmt_fp+0x100a>
 801c0be:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801c0c2:	220a      	movs	r2, #10
 801c0c4:	601a      	str	r2, [r3, #0]
 801c0c6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801c0ca:	2200      	movs	r2, #0
 801c0cc:	601a      	str	r2, [r3, #0]
 801c0ce:	e010      	b.n	801c0f2 <fmt_fp+0xfea>
 801c0d0:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801c0d4:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801c0d8:	681a      	ldr	r2, [r3, #0]
 801c0da:	4613      	mov	r3, r2
 801c0dc:	009b      	lsls	r3, r3, #2
 801c0de:	4413      	add	r3, r2
 801c0e0:	005b      	lsls	r3, r3, #1
 801c0e2:	600b      	str	r3, [r1, #0]
 801c0e4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801c0e8:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 801c0ec:	6812      	ldr	r2, [r2, #0]
 801c0ee:	3201      	adds	r2, #1
 801c0f0:	601a      	str	r2, [r3, #0]
 801c0f2:	f107 0320 	add.w	r3, r7, #32
 801c0f6:	681b      	ldr	r3, [r3, #0]
 801c0f8:	3b04      	subs	r3, #4
 801c0fa:	681b      	ldr	r3, [r3, #0]
 801c0fc:	f107 0228 	add.w	r2, r7, #40	; 0x28
 801c100:	6812      	ldr	r2, [r2, #0]
 801c102:	fbb3 f1f2 	udiv	r1, r3, r2
 801c106:	fb02 f201 	mul.w	r2, r2, r1
 801c10a:	1a9b      	subs	r3, r3, r2
 801c10c:	2b00      	cmp	r3, #0
 801c10e:	d0df      	beq.n	801c0d0 <fmt_fp+0xfc8>
 801c110:	e003      	b.n	801c11a <fmt_fp+0x1012>
			else j=9;
 801c112:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801c116:	2209      	movs	r2, #9
 801c118:	601a      	str	r2, [r3, #0]
			if ((t|32)=='f')
 801c11a:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801c11e:	f043 0320 	orr.w	r3, r3, #32
 801c122:	2b66      	cmp	r3, #102	; 0x66
 801c124:	d119      	bne.n	801c15a <fmt_fp+0x1052>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
 801c126:	f107 0220 	add.w	r2, r7, #32
 801c12a:	f107 031c 	add.w	r3, r7, #28
 801c12e:	6812      	ldr	r2, [r2, #0]
 801c130:	681b      	ldr	r3, [r3, #0]
 801c132:	1ad3      	subs	r3, r2, r3
 801c134:	109b      	asrs	r3, r3, #2
 801c136:	1e5a      	subs	r2, r3, #1
 801c138:	4613      	mov	r3, r2
 801c13a:	00db      	lsls	r3, r3, #3
 801c13c:	441a      	add	r2, r3
 801c13e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801c142:	681b      	ldr	r3, [r3, #0]
 801c144:	1ad3      	subs	r3, r2, r3
 801c146:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 801c14a:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801c14e:	4293      	cmp	r3, r2
 801c150:	bfa8      	it	ge
 801c152:	4613      	movge	r3, r2
 801c154:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
 801c158:	e01c      	b.n	801c194 <fmt_fp+0x108c>
			else
				p = MIN(p,MAX(0,9*(z-r-1)+e-j));
 801c15a:	f107 0220 	add.w	r2, r7, #32
 801c15e:	f107 031c 	add.w	r3, r7, #28
 801c162:	6812      	ldr	r2, [r2, #0]
 801c164:	681b      	ldr	r3, [r3, #0]
 801c166:	1ad3      	subs	r3, r2, r3
 801c168:	109b      	asrs	r3, r3, #2
 801c16a:	1e5a      	subs	r2, r3, #1
 801c16c:	4613      	mov	r3, r2
 801c16e:	00db      	lsls	r3, r3, #3
 801c170:	441a      	add	r2, r3
 801c172:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801c176:	681b      	ldr	r3, [r3, #0]
 801c178:	441a      	add	r2, r3
 801c17a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801c17e:	681b      	ldr	r3, [r3, #0]
 801c180:	1ad3      	subs	r3, r2, r3
 801c182:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 801c186:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801c18a:	4293      	cmp	r3, r2
 801c18c:	bfa8      	it	ge
 801c18e:	4613      	movge	r3, r2
 801c190:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
		}
	}
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
 801c194:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c198:	2b00      	cmp	r3, #0
 801c19a:	d105      	bne.n	801c1a8 <fmt_fp+0x10a0>
 801c19c:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c1a0:	f003 0308 	and.w	r3, r3, #8
 801c1a4:	2b00      	cmp	r3, #0
 801c1a6:	d001      	beq.n	801c1ac <fmt_fp+0x10a4>
 801c1a8:	2201      	movs	r2, #1
 801c1aa:	e000      	b.n	801c1ae <fmt_fp+0x10a6>
 801c1ac:	2200      	movs	r2, #0
 801c1ae:	4bc5      	ldr	r3, [pc, #788]	; (801c4c4 <fmt_fp+0x13bc>)
 801c1b0:	1a9b      	subs	r3, r3, r2
 801c1b2:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801c1b6:	429a      	cmp	r2, r3
 801c1b8:	dd02      	ble.n	801c1c0 <fmt_fp+0x10b8>
		return -1;
 801c1ba:	f04f 33ff 	mov.w	r3, #4294967295
 801c1be:	e2b5      	b.n	801c72c <fmt_fp+0x1624>
	l = 1 + p + (p || (fl&ALT_FORM));
 801c1c0:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c1c4:	1c5a      	adds	r2, r3, #1
 801c1c6:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c1ca:	2b00      	cmp	r3, #0
 801c1cc:	d105      	bne.n	801c1da <fmt_fp+0x10d2>
 801c1ce:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c1d2:	f003 0308 	and.w	r3, r3, #8
 801c1d6:	2b00      	cmp	r3, #0
 801c1d8:	d001      	beq.n	801c1de <fmt_fp+0x10d6>
 801c1da:	2101      	movs	r1, #1
 801c1dc:	e000      	b.n	801c1e0 <fmt_fp+0x10d8>
 801c1de:	2100      	movs	r1, #0
 801c1e0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c1e4:	440a      	add	r2, r1
 801c1e6:	601a      	str	r2, [r3, #0]
	if ((t|32)=='f') {
 801c1e8:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801c1ec:	f043 0320 	orr.w	r3, r3, #32
 801c1f0:	2b66      	cmp	r3, #102	; 0x66
 801c1f2:	d11d      	bne.n	801c230 <fmt_fp+0x1128>
		if (e > INT_MAX-l) return -1;
 801c1f4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c1f8:	681a      	ldr	r2, [r3, #0]
 801c1fa:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c1fe:	1a9b      	subs	r3, r3, r2
 801c200:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801c204:	6812      	ldr	r2, [r2, #0]
 801c206:	429a      	cmp	r2, r3
 801c208:	dd02      	ble.n	801c210 <fmt_fp+0x1108>
 801c20a:	f04f 33ff 	mov.w	r3, #4294967295
 801c20e:	e28d      	b.n	801c72c <fmt_fp+0x1624>
		if (e>0) l+=e;
 801c210:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801c214:	681b      	ldr	r3, [r3, #0]
 801c216:	2b00      	cmp	r3, #0
 801c218:	dd73      	ble.n	801c302 <fmt_fp+0x11fa>
 801c21a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c21e:	f107 0130 	add.w	r1, r7, #48	; 0x30
 801c222:	f107 0224 	add.w	r2, r7, #36	; 0x24
 801c226:	6809      	ldr	r1, [r1, #0]
 801c228:	6812      	ldr	r2, [r2, #0]
 801c22a:	440a      	add	r2, r1
 801c22c:	601a      	str	r2, [r3, #0]
 801c22e:	e068      	b.n	801c302 <fmt_fp+0x11fa>
	} else {
		estr=fmt_u(e<0 ? -e : e, ebuf);
 801c230:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801c234:	681b      	ldr	r3, [r3, #0]
 801c236:	2b00      	cmp	r3, #0
 801c238:	bfb8      	it	lt
 801c23a:	425b      	neglt	r3, r3
 801c23c:	4618      	mov	r0, r3
 801c23e:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801c242:	f107 0440 	add.w	r4, r7, #64	; 0x40
 801c246:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801c24a:	681a      	ldr	r2, [r3, #0]
 801c24c:	f7fe ff0c 	bl	801b068 <fmt_u>
 801c250:	6020      	str	r0, [r4, #0]
		while(ebuf-estr<2) *--estr='0';
 801c252:	e00b      	b.n	801c26c <fmt_fp+0x1164>
 801c254:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c258:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801c25c:	6812      	ldr	r2, [r2, #0]
 801c25e:	3a01      	subs	r2, #1
 801c260:	601a      	str	r2, [r3, #0]
 801c262:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c266:	681b      	ldr	r3, [r3, #0]
 801c268:	2230      	movs	r2, #48	; 0x30
 801c26a:	701a      	strb	r2, [r3, #0]
 801c26c:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801c270:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c274:	6812      	ldr	r2, [r2, #0]
 801c276:	681b      	ldr	r3, [r3, #0]
 801c278:	1ad3      	subs	r3, r2, r3
 801c27a:	2b01      	cmp	r3, #1
 801c27c:	ddea      	ble.n	801c254 <fmt_fp+0x114c>
		*--estr = (e<0 ? '-' : '+');
 801c27e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801c282:	681b      	ldr	r3, [r3, #0]
 801c284:	2b00      	cmp	r3, #0
 801c286:	da01      	bge.n	801c28c <fmt_fp+0x1184>
 801c288:	212d      	movs	r1, #45	; 0x2d
 801c28a:	e000      	b.n	801c28e <fmt_fp+0x1186>
 801c28c:	212b      	movs	r1, #43	; 0x2b
 801c28e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c292:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801c296:	6812      	ldr	r2, [r2, #0]
 801c298:	3a01      	subs	r2, #1
 801c29a:	601a      	str	r2, [r3, #0]
 801c29c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c2a0:	681b      	ldr	r3, [r3, #0]
 801c2a2:	460a      	mov	r2, r1
 801c2a4:	701a      	strb	r2, [r3, #0]
		*--estr = t;
 801c2a6:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c2aa:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801c2ae:	6812      	ldr	r2, [r2, #0]
 801c2b0:	3a01      	subs	r2, #1
 801c2b2:	601a      	str	r2, [r3, #0]
 801c2b4:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801c2b8:	b2da      	uxtb	r2, r3
 801c2ba:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c2be:	681b      	ldr	r3, [r3, #0]
 801c2c0:	701a      	strb	r2, [r3, #0]
		if (ebuf-estr > INT_MAX-l) return -1;
 801c2c2:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801c2c6:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c2ca:	6812      	ldr	r2, [r2, #0]
 801c2cc:	681b      	ldr	r3, [r3, #0]
 801c2ce:	1ad2      	subs	r2, r2, r3
 801c2d0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c2d4:	6819      	ldr	r1, [r3, #0]
 801c2d6:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c2da:	1a5b      	subs	r3, r3, r1
 801c2dc:	429a      	cmp	r2, r3
 801c2de:	dd02      	ble.n	801c2e6 <fmt_fp+0x11de>
 801c2e0:	f04f 33ff 	mov.w	r3, #4294967295
 801c2e4:	e222      	b.n	801c72c <fmt_fp+0x1624>
		l += ebuf-estr;
 801c2e6:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801c2ea:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c2ee:	6812      	ldr	r2, [r2, #0]
 801c2f0:	681b      	ldr	r3, [r3, #0]
 801c2f2:	1ad2      	subs	r2, r2, r3
 801c2f4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c2f8:	f107 0130 	add.w	r1, r7, #48	; 0x30
 801c2fc:	6809      	ldr	r1, [r1, #0]
 801c2fe:	440a      	add	r2, r1
 801c300:	601a      	str	r2, [r3, #0]
	}

	if (l > INT_MAX-pl) return -1;
 801c302:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801c306:	681a      	ldr	r2, [r3, #0]
 801c308:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c30c:	1a9b      	subs	r3, r3, r2
 801c30e:	f107 0230 	add.w	r2, r7, #48	; 0x30
 801c312:	6812      	ldr	r2, [r2, #0]
 801c314:	429a      	cmp	r2, r3
 801c316:	dd02      	ble.n	801c31e <fmt_fp+0x1216>
 801c318:	f04f 33ff 	mov.w	r3, #4294967295
 801c31c:	e206      	b.n	801c72c <fmt_fp+0x1624>
	pad(f, ' ', w, pl+l, fl);
 801c31e:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801c322:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c326:	6812      	ldr	r2, [r2, #0]
 801c328:	681b      	ldr	r3, [r3, #0]
 801c32a:	441a      	add	r2, r3
 801c32c:	f107 000c 	add.w	r0, r7, #12
 801c330:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c334:	9300      	str	r3, [sp, #0]
 801c336:	4613      	mov	r3, r2
 801c338:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801c33c:	2120      	movs	r1, #32
 801c33e:	6800      	ldr	r0, [r0, #0]
 801c340:	f7fe fdca 	bl	801aed8 <pad>
	out(f, prefix, pl);
 801c344:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801c348:	681a      	ldr	r2, [r3, #0]
 801c34a:	f107 0138 	add.w	r1, r7, #56	; 0x38
 801c34e:	f107 030c 	add.w	r3, r7, #12
 801c352:	6809      	ldr	r1, [r1, #0]
 801c354:	6818      	ldr	r0, [r3, #0]
 801c356:	f7fe fda9 	bl	801aeac <out>
	pad(f, '0', w, pl+l, fl^ZERO_PAD);
 801c35a:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801c35e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c362:	6812      	ldr	r2, [r2, #0]
 801c364:	681b      	ldr	r3, [r3, #0]
 801c366:	441a      	add	r2, r3
 801c368:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c36c:	f483 3380 	eor.w	r3, r3, #65536	; 0x10000
 801c370:	f107 000c 	add.w	r0, r7, #12
 801c374:	9300      	str	r3, [sp, #0]
 801c376:	4613      	mov	r3, r2
 801c378:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801c37c:	2130      	movs	r1, #48	; 0x30
 801c37e:	6800      	ldr	r0, [r0, #0]
 801c380:	f7fe fdaa 	bl	801aed8 <pad>

	if ((t|32)=='f') {
 801c384:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 801c388:	f043 0320 	orr.w	r3, r3, #32
 801c38c:	2b66      	cmp	r3, #102	; 0x66
 801c38e:	f040 80e4 	bne.w	801c55a <fmt_fp+0x1452>
		if (a>r) a=r;
 801c392:	f107 0214 	add.w	r2, r7, #20
 801c396:	f107 031c 	add.w	r3, r7, #28
 801c39a:	6812      	ldr	r2, [r2, #0]
 801c39c:	681b      	ldr	r3, [r3, #0]
 801c39e:	429a      	cmp	r2, r3
 801c3a0:	d905      	bls.n	801c3ae <fmt_fp+0x12a6>
 801c3a2:	f107 0314 	add.w	r3, r7, #20
 801c3a6:	f107 021c 	add.w	r2, r7, #28
 801c3aa:	6812      	ldr	r2, [r2, #0]
 801c3ac:	601a      	str	r2, [r3, #0]
		for (d=a; d<=r; d++) {
 801c3ae:	f107 0318 	add.w	r3, r7, #24
 801c3b2:	f107 0214 	add.w	r2, r7, #20
 801c3b6:	6812      	ldr	r2, [r2, #0]
 801c3b8:	601a      	str	r2, [r3, #0]
 801c3ba:	e057      	b.n	801c46c <fmt_fp+0x1364>
			char *s = fmt_u(*d, buf+9);
 801c3bc:	f107 0318 	add.w	r3, r7, #24
 801c3c0:	681b      	ldr	r3, [r3, #0]
 801c3c2:	681b      	ldr	r3, [r3, #0]
 801c3c4:	4618      	mov	r0, r3
 801c3c6:	f04f 0100 	mov.w	r1, #0
 801c3ca:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c3ce:	3309      	adds	r3, #9
 801c3d0:	f107 0454 	add.w	r4, r7, #84	; 0x54
 801c3d4:	461a      	mov	r2, r3
 801c3d6:	f7fe fe47 	bl	801b068 <fmt_u>
 801c3da:	6020      	str	r0, [r4, #0]
			if (d!=a) while (s>buf) *--s='0';
 801c3dc:	f107 0218 	add.w	r2, r7, #24
 801c3e0:	f107 0314 	add.w	r3, r7, #20
 801c3e4:	6812      	ldr	r2, [r2, #0]
 801c3e6:	681b      	ldr	r3, [r3, #0]
 801c3e8:	429a      	cmp	r2, r3
 801c3ea:	d014      	beq.n	801c416 <fmt_fp+0x130e>
 801c3ec:	e00b      	b.n	801c406 <fmt_fp+0x12fe>
 801c3ee:	f107 0354 	add.w	r3, r7, #84	; 0x54
 801c3f2:	f107 0254 	add.w	r2, r7, #84	; 0x54
 801c3f6:	6812      	ldr	r2, [r2, #0]
 801c3f8:	3a01      	subs	r2, #1
 801c3fa:	601a      	str	r2, [r3, #0]
 801c3fc:	f107 0354 	add.w	r3, r7, #84	; 0x54
 801c400:	681b      	ldr	r3, [r3, #0]
 801c402:	2230      	movs	r2, #48	; 0x30
 801c404:	701a      	strb	r2, [r3, #0]
 801c406:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c40a:	f107 0254 	add.w	r2, r7, #84	; 0x54
 801c40e:	6812      	ldr	r2, [r2, #0]
 801c410:	429a      	cmp	r2, r3
 801c412:	d8ec      	bhi.n	801c3ee <fmt_fp+0x12e6>
 801c414:	e013      	b.n	801c43e <fmt_fp+0x1336>
			else if (s==buf+9) *--s='0';
 801c416:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c41a:	3309      	adds	r3, #9
 801c41c:	f107 0254 	add.w	r2, r7, #84	; 0x54
 801c420:	6812      	ldr	r2, [r2, #0]
 801c422:	429a      	cmp	r2, r3
 801c424:	d10b      	bne.n	801c43e <fmt_fp+0x1336>
 801c426:	f107 0354 	add.w	r3, r7, #84	; 0x54
 801c42a:	f107 0254 	add.w	r2, r7, #84	; 0x54
 801c42e:	6812      	ldr	r2, [r2, #0]
 801c430:	3a01      	subs	r2, #1
 801c432:	601a      	str	r2, [r3, #0]
 801c434:	f107 0354 	add.w	r3, r7, #84	; 0x54
 801c438:	681b      	ldr	r3, [r3, #0]
 801c43a:	2230      	movs	r2, #48	; 0x30
 801c43c:	701a      	strb	r2, [r3, #0]
			out(f, s, buf+9-s);
 801c43e:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c442:	3309      	adds	r3, #9
 801c444:	f107 0254 	add.w	r2, r7, #84	; 0x54
 801c448:	6812      	ldr	r2, [r2, #0]
 801c44a:	1a9b      	subs	r3, r3, r2
 801c44c:	461a      	mov	r2, r3
 801c44e:	f107 0154 	add.w	r1, r7, #84	; 0x54
 801c452:	f107 030c 	add.w	r3, r7, #12
 801c456:	6809      	ldr	r1, [r1, #0]
 801c458:	6818      	ldr	r0, [r3, #0]
 801c45a:	f7fe fd27 	bl	801aeac <out>
		for (d=a; d<=r; d++) {
 801c45e:	f107 0318 	add.w	r3, r7, #24
 801c462:	f107 0218 	add.w	r2, r7, #24
 801c466:	6812      	ldr	r2, [r2, #0]
 801c468:	3204      	adds	r2, #4
 801c46a:	601a      	str	r2, [r3, #0]
 801c46c:	f107 0218 	add.w	r2, r7, #24
 801c470:	f107 031c 	add.w	r3, r7, #28
 801c474:	6812      	ldr	r2, [r2, #0]
 801c476:	681b      	ldr	r3, [r3, #0]
 801c478:	429a      	cmp	r2, r3
 801c47a:	d99f      	bls.n	801c3bc <fmt_fp+0x12b4>
		}
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
 801c47c:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c480:	2b00      	cmp	r3, #0
 801c482:	d105      	bne.n	801c490 <fmt_fp+0x1388>
 801c484:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c488:	f003 0308 	and.w	r3, r3, #8
 801c48c:	2b00      	cmp	r3, #0
 801c48e:	d04a      	beq.n	801c526 <fmt_fp+0x141e>
 801c490:	f107 030c 	add.w	r3, r7, #12
 801c494:	2201      	movs	r2, #1
 801c496:	490c      	ldr	r1, [pc, #48]	; (801c4c8 <fmt_fp+0x13c0>)
 801c498:	6818      	ldr	r0, [r3, #0]
 801c49a:	f7fe fd07 	bl	801aeac <out>
		for (; d<z && p>0; d++, p-=9) {
 801c49e:	e042      	b.n	801c526 <fmt_fp+0x141e>
			char *s = fmt_u(*d, buf+9);
 801c4a0:	f107 0318 	add.w	r3, r7, #24
 801c4a4:	681b      	ldr	r3, [r3, #0]
 801c4a6:	681b      	ldr	r3, [r3, #0]
 801c4a8:	4618      	mov	r0, r3
 801c4aa:	f04f 0100 	mov.w	r1, #0
 801c4ae:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c4b2:	3309      	adds	r3, #9
 801c4b4:	f107 0458 	add.w	r4, r7, #88	; 0x58
 801c4b8:	461a      	mov	r2, r3
 801c4ba:	f7fe fdd5 	bl	801b068 <fmt_u>
 801c4be:	6020      	str	r0, [r4, #0]
			while (s>buf) *--s='0';
 801c4c0:	e010      	b.n	801c4e4 <fmt_fp+0x13dc>
 801c4c2:	bf00      	nop
 801c4c4:	7ffffffe 	.word	0x7ffffffe
 801c4c8:	0802318c 	.word	0x0802318c
 801c4cc:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801c4d0:	f107 0258 	add.w	r2, r7, #88	; 0x58
 801c4d4:	6812      	ldr	r2, [r2, #0]
 801c4d6:	3a01      	subs	r2, #1
 801c4d8:	601a      	str	r2, [r3, #0]
 801c4da:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801c4de:	681b      	ldr	r3, [r3, #0]
 801c4e0:	2230      	movs	r2, #48	; 0x30
 801c4e2:	701a      	strb	r2, [r3, #0]
 801c4e4:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c4e8:	f107 0258 	add.w	r2, r7, #88	; 0x58
 801c4ec:	6812      	ldr	r2, [r2, #0]
 801c4ee:	429a      	cmp	r2, r3
 801c4f0:	d8ec      	bhi.n	801c4cc <fmt_fp+0x13c4>
			out(f, s, MIN(9,p));
 801c4f2:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c4f6:	2b09      	cmp	r3, #9
 801c4f8:	bfa8      	it	ge
 801c4fa:	2309      	movge	r3, #9
 801c4fc:	461a      	mov	r2, r3
 801c4fe:	f107 0158 	add.w	r1, r7, #88	; 0x58
 801c502:	f107 030c 	add.w	r3, r7, #12
 801c506:	6809      	ldr	r1, [r1, #0]
 801c508:	6818      	ldr	r0, [r3, #0]
 801c50a:	f7fe fccf 	bl	801aeac <out>
		for (; d<z && p>0; d++, p-=9) {
 801c50e:	f107 0318 	add.w	r3, r7, #24
 801c512:	f107 0218 	add.w	r2, r7, #24
 801c516:	6812      	ldr	r2, [r2, #0]
 801c518:	3204      	adds	r2, #4
 801c51a:	601a      	str	r2, [r3, #0]
 801c51c:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c520:	3b09      	subs	r3, #9
 801c522:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
 801c526:	f107 0218 	add.w	r2, r7, #24
 801c52a:	f107 0320 	add.w	r3, r7, #32
 801c52e:	6812      	ldr	r2, [r2, #0]
 801c530:	681b      	ldr	r3, [r3, #0]
 801c532:	429a      	cmp	r2, r3
 801c534:	d203      	bcs.n	801c53e <fmt_fp+0x1436>
 801c536:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c53a:	2b00      	cmp	r3, #0
 801c53c:	dcb0      	bgt.n	801c4a0 <fmt_fp+0x1398>
		}
		pad(f, '0', p+9, 9, 0);
 801c53e:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c542:	f103 0209 	add.w	r2, r3, #9
 801c546:	f107 000c 	add.w	r0, r7, #12
 801c54a:	2300      	movs	r3, #0
 801c54c:	9300      	str	r3, [sp, #0]
 801c54e:	2309      	movs	r3, #9
 801c550:	2130      	movs	r1, #48	; 0x30
 801c552:	6800      	ldr	r0, [r0, #0]
 801c554:	f7fe fcc0 	bl	801aed8 <pad>
 801c558:	e0c7      	b.n	801c6ea <fmt_fp+0x15e2>
	} else {
		if (z<=a) z=a+1;
 801c55a:	f107 0220 	add.w	r2, r7, #32
 801c55e:	f107 0314 	add.w	r3, r7, #20
 801c562:	6812      	ldr	r2, [r2, #0]
 801c564:	681b      	ldr	r3, [r3, #0]
 801c566:	429a      	cmp	r2, r3
 801c568:	d806      	bhi.n	801c578 <fmt_fp+0x1470>
 801c56a:	f107 0320 	add.w	r3, r7, #32
 801c56e:	f107 0214 	add.w	r2, r7, #20
 801c572:	6812      	ldr	r2, [r2, #0]
 801c574:	3204      	adds	r2, #4
 801c576:	601a      	str	r2, [r3, #0]
		for (d=a; d<z && p>=0; d++) {
 801c578:	f107 0318 	add.w	r3, r7, #24
 801c57c:	f107 0214 	add.w	r2, r7, #20
 801c580:	6812      	ldr	r2, [r2, #0]
 801c582:	601a      	str	r2, [r3, #0]
 801c584:	e087      	b.n	801c696 <fmt_fp+0x158e>
			char *s = fmt_u(*d, buf+9);
 801c586:	f107 0318 	add.w	r3, r7, #24
 801c58a:	681b      	ldr	r3, [r3, #0]
 801c58c:	681b      	ldr	r3, [r3, #0]
 801c58e:	4618      	mov	r0, r3
 801c590:	f04f 0100 	mov.w	r1, #0
 801c594:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c598:	3309      	adds	r3, #9
 801c59a:	f107 045c 	add.w	r4, r7, #92	; 0x5c
 801c59e:	461a      	mov	r2, r3
 801c5a0:	f7fe fd62 	bl	801b068 <fmt_u>
 801c5a4:	6020      	str	r0, [r4, #0]
			if (s==buf+9) *--s='0';
 801c5a6:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c5aa:	3309      	adds	r3, #9
 801c5ac:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c5b0:	6812      	ldr	r2, [r2, #0]
 801c5b2:	429a      	cmp	r2, r3
 801c5b4:	d10b      	bne.n	801c5ce <fmt_fp+0x14c6>
 801c5b6:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801c5ba:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c5be:	6812      	ldr	r2, [r2, #0]
 801c5c0:	3a01      	subs	r2, #1
 801c5c2:	601a      	str	r2, [r3, #0]
 801c5c4:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801c5c8:	681b      	ldr	r3, [r3, #0]
 801c5ca:	2230      	movs	r2, #48	; 0x30
 801c5cc:	701a      	strb	r2, [r3, #0]
			if (d!=a) while (s>buf) *--s='0';
 801c5ce:	f107 0218 	add.w	r2, r7, #24
 801c5d2:	f107 0314 	add.w	r3, r7, #20
 801c5d6:	6812      	ldr	r2, [r2, #0]
 801c5d8:	681b      	ldr	r3, [r3, #0]
 801c5da:	429a      	cmp	r2, r3
 801c5dc:	d014      	beq.n	801c608 <fmt_fp+0x1500>
 801c5de:	e00b      	b.n	801c5f8 <fmt_fp+0x14f0>
 801c5e0:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801c5e4:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c5e8:	6812      	ldr	r2, [r2, #0]
 801c5ea:	3a01      	subs	r2, #1
 801c5ec:	601a      	str	r2, [r3, #0]
 801c5ee:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801c5f2:	681b      	ldr	r3, [r3, #0]
 801c5f4:	2230      	movs	r2, #48	; 0x30
 801c5f6:	701a      	strb	r2, [r3, #0]
 801c5f8:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c5fc:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c600:	6812      	ldr	r2, [r2, #0]
 801c602:	429a      	cmp	r2, r3
 801c604:	d8ec      	bhi.n	801c5e0 <fmt_fp+0x14d8>
 801c606:	e01e      	b.n	801c646 <fmt_fp+0x153e>
			else {
				out(f, s++, 1);
 801c608:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801c60c:	681b      	ldr	r3, [r3, #0]
 801c60e:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c612:	1c59      	adds	r1, r3, #1
 801c614:	6011      	str	r1, [r2, #0]
 801c616:	f107 000c 	add.w	r0, r7, #12
 801c61a:	2201      	movs	r2, #1
 801c61c:	4619      	mov	r1, r3
 801c61e:	6800      	ldr	r0, [r0, #0]
 801c620:	f7fe fc44 	bl	801aeac <out>
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
 801c624:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c628:	2b00      	cmp	r3, #0
 801c62a:	dc05      	bgt.n	801c638 <fmt_fp+0x1530>
 801c62c:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c630:	f003 0308 	and.w	r3, r3, #8
 801c634:	2b00      	cmp	r3, #0
 801c636:	d006      	beq.n	801c646 <fmt_fp+0x153e>
 801c638:	f107 030c 	add.w	r3, r7, #12
 801c63c:	2201      	movs	r2, #1
 801c63e:	4942      	ldr	r1, [pc, #264]	; (801c748 <fmt_fp+0x1640>)
 801c640:	6818      	ldr	r0, [r3, #0]
 801c642:	f7fe fc33 	bl	801aeac <out>
			}
			out(f, s, MIN(buf+9-s, p));
 801c646:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c64a:	3309      	adds	r3, #9
 801c64c:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c650:	6812      	ldr	r2, [r2, #0]
 801c652:	1a9a      	subs	r2, r3, r2
 801c654:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c658:	4293      	cmp	r3, r2
 801c65a:	bfa8      	it	ge
 801c65c:	4613      	movge	r3, r2
 801c65e:	461a      	mov	r2, r3
 801c660:	f107 015c 	add.w	r1, r7, #92	; 0x5c
 801c664:	f107 030c 	add.w	r3, r7, #12
 801c668:	6809      	ldr	r1, [r1, #0]
 801c66a:	6818      	ldr	r0, [r3, #0]
 801c66c:	f7fe fc1e 	bl	801aeac <out>
			p -= buf+9-s;
 801c670:	f507 7329 	add.w	r3, r7, #676	; 0x2a4
 801c674:	3309      	adds	r3, #9
 801c676:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801c67a:	6812      	ldr	r2, [r2, #0]
 801c67c:	1a9b      	subs	r3, r3, r2
 801c67e:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 801c682:	1ad3      	subs	r3, r2, r3
 801c684:	f8c7 32ec 	str.w	r3, [r7, #748]	; 0x2ec
		for (d=a; d<z && p>=0; d++) {
 801c688:	f107 0318 	add.w	r3, r7, #24
 801c68c:	f107 0218 	add.w	r2, r7, #24
 801c690:	6812      	ldr	r2, [r2, #0]
 801c692:	3204      	adds	r2, #4
 801c694:	601a      	str	r2, [r3, #0]
 801c696:	f107 0218 	add.w	r2, r7, #24
 801c69a:	f107 0320 	add.w	r3, r7, #32
 801c69e:	6812      	ldr	r2, [r2, #0]
 801c6a0:	681b      	ldr	r3, [r3, #0]
 801c6a2:	429a      	cmp	r2, r3
 801c6a4:	d204      	bcs.n	801c6b0 <fmt_fp+0x15a8>
 801c6a6:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c6aa:	2b00      	cmp	r3, #0
 801c6ac:	f6bf af6b 	bge.w	801c586 <fmt_fp+0x147e>
		}
		pad(f, '0', p+18, 18, 0);
 801c6b0:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 801c6b4:	f103 0212 	add.w	r2, r3, #18
 801c6b8:	f107 000c 	add.w	r0, r7, #12
 801c6bc:	2300      	movs	r3, #0
 801c6be:	9300      	str	r3, [sp, #0]
 801c6c0:	2312      	movs	r3, #18
 801c6c2:	2130      	movs	r1, #48	; 0x30
 801c6c4:	6800      	ldr	r0, [r0, #0]
 801c6c6:	f7fe fc07 	bl	801aed8 <pad>
		out(f, estr, ebuf-estr);
 801c6ca:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801c6ce:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801c6d2:	6812      	ldr	r2, [r2, #0]
 801c6d4:	681b      	ldr	r3, [r3, #0]
 801c6d6:	1ad3      	subs	r3, r2, r3
 801c6d8:	461a      	mov	r2, r3
 801c6da:	f107 0140 	add.w	r1, r7, #64	; 0x40
 801c6de:	f107 030c 	add.w	r3, r7, #12
 801c6e2:	6809      	ldr	r1, [r1, #0]
 801c6e4:	6818      	ldr	r0, [r3, #0]
 801c6e6:	f7fe fbe1 	bl	801aeac <out>
	}

	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
 801c6ea:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801c6ee:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c6f2:	6812      	ldr	r2, [r2, #0]
 801c6f4:	681b      	ldr	r3, [r3, #0]
 801c6f6:	441a      	add	r2, r3
 801c6f8:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 801c6fc:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 801c700:	f107 000c 	add.w	r0, r7, #12
 801c704:	9300      	str	r3, [sp, #0]
 801c706:	4613      	mov	r3, r2
 801c708:	f8d7 22e8 	ldr.w	r2, [r7, #744]	; 0x2e8
 801c70c:	2120      	movs	r1, #32
 801c70e:	6800      	ldr	r0, [r0, #0]
 801c710:	f7fe fbe2 	bl	801aed8 <pad>

	return MAX(w, pl+l);
 801c714:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 801c718:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801c71c:	6812      	ldr	r2, [r2, #0]
 801c71e:	681b      	ldr	r3, [r3, #0]
 801c720:	441a      	add	r2, r3
 801c722:	f8d7 32e8 	ldr.w	r3, [r7, #744]	; 0x2e8
 801c726:	4293      	cmp	r3, r2
 801c728:	bfb8      	it	lt
 801c72a:	4613      	movlt	r3, r2
}
 801c72c:	4a07      	ldr	r2, [pc, #28]	; (801c74c <fmt_fp+0x1644>)
 801c72e:	6811      	ldr	r1, [r2, #0]
 801c730:	f8d7 22bc 	ldr.w	r2, [r7, #700]	; 0x2bc
 801c734:	4051      	eors	r1, r2
 801c736:	d001      	beq.n	801c73c <fmt_fp+0x1634>
 801c738:	f7e7 ff50 	bl	80045dc <__stack_chk_fail>
 801c73c:	4618      	mov	r0, r3
 801c73e:	f507 7731 	add.w	r7, r7, #708	; 0x2c4
 801c742:	46bd      	mov	sp, r7
 801c744:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801c748:	0802318c 	.word	0x0802318c
 801c74c:	08023190 	.word	0x08023190

0801c750 <getint>:

static int getint(char **s) {
 801c750:	b480      	push	{r7}
 801c752:	b085      	sub	sp, #20
 801c754:	af00      	add	r7, sp, #0
 801c756:	6078      	str	r0, [r7, #4]
	int i;
	for (i=0; isdigit(**s); (*s)++) {
 801c758:	2300      	movs	r3, #0
 801c75a:	60fb      	str	r3, [r7, #12]
 801c75c:	e027      	b.n	801c7ae <getint+0x5e>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
 801c75e:	68fb      	ldr	r3, [r7, #12]
 801c760:	4a19      	ldr	r2, [pc, #100]	; (801c7c8 <getint+0x78>)
 801c762:	4293      	cmp	r3, r2
 801c764:	d80e      	bhi.n	801c784 <getint+0x34>
 801c766:	687b      	ldr	r3, [r7, #4]
 801c768:	681b      	ldr	r3, [r3, #0]
 801c76a:	781b      	ldrb	r3, [r3, #0]
 801c76c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 801c770:	68fb      	ldr	r3, [r7, #12]
 801c772:	f06f 0109 	mvn.w	r1, #9
 801c776:	fb01 f103 	mul.w	r1, r1, r3
 801c77a:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c77e:	440b      	add	r3, r1
 801c780:	429a      	cmp	r2, r3
 801c782:	dd03      	ble.n	801c78c <getint+0x3c>
 801c784:	f04f 33ff 	mov.w	r3, #4294967295
 801c788:	60fb      	str	r3, [r7, #12]
 801c78a:	e00b      	b.n	801c7a4 <getint+0x54>
		else i = 10*i + (**s-'0');
 801c78c:	68fa      	ldr	r2, [r7, #12]
 801c78e:	4613      	mov	r3, r2
 801c790:	009b      	lsls	r3, r3, #2
 801c792:	4413      	add	r3, r2
 801c794:	005b      	lsls	r3, r3, #1
 801c796:	461a      	mov	r2, r3
 801c798:	687b      	ldr	r3, [r7, #4]
 801c79a:	681b      	ldr	r3, [r3, #0]
 801c79c:	781b      	ldrb	r3, [r3, #0]
 801c79e:	3b30      	subs	r3, #48	; 0x30
 801c7a0:	4413      	add	r3, r2
 801c7a2:	60fb      	str	r3, [r7, #12]
	for (i=0; isdigit(**s); (*s)++) {
 801c7a4:	687b      	ldr	r3, [r7, #4]
 801c7a6:	681b      	ldr	r3, [r3, #0]
 801c7a8:	1c5a      	adds	r2, r3, #1
 801c7aa:	687b      	ldr	r3, [r7, #4]
 801c7ac:	601a      	str	r2, [r3, #0]
 801c7ae:	687b      	ldr	r3, [r7, #4]
 801c7b0:	681b      	ldr	r3, [r3, #0]
 801c7b2:	781b      	ldrb	r3, [r3, #0]
 801c7b4:	3b30      	subs	r3, #48	; 0x30
 801c7b6:	2b09      	cmp	r3, #9
 801c7b8:	d9d1      	bls.n	801c75e <getint+0xe>
	}
	return i;
 801c7ba:	68fb      	ldr	r3, [r7, #12]
}
 801c7bc:	4618      	mov	r0, r3
 801c7be:	3714      	adds	r7, #20
 801c7c0:	46bd      	mov	sp, r7
 801c7c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c7c6:	4770      	bx	lr
 801c7c8:	0ccccccc 	.word	0x0ccccccc

0801c7cc <printf_core>:

static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg, int *nl_type)
{
 801c7cc:	b580      	push	{r7, lr}
 801c7ce:	b0ac      	sub	sp, #176	; 0xb0
 801c7d0:	af04      	add	r7, sp, #16
 801c7d2:	6178      	str	r0, [r7, #20]
 801c7d4:	6139      	str	r1, [r7, #16]
 801c7d6:	60fa      	str	r2, [r7, #12]
 801c7d8:	60bb      	str	r3, [r7, #8]
 801c7da:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801c7de:	607b      	str	r3, [r7, #4]
 801c7e0:	4ba0      	ldr	r3, [pc, #640]	; (801ca64 <printf_core+0x298>)
 801c7e2:	681b      	ldr	r3, [r3, #0]
 801c7e4:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 801c7e8:	f04f 0300 	mov.w	r3, #0
	char *a, *z, *s=(char *)fmt;
 801c7ec:	693b      	ldr	r3, [r7, #16]
 801c7ee:	61bb      	str	r3, [r7, #24]
	unsigned l10n=0, fl;
 801c7f0:	2300      	movs	r3, #0
 801c7f2:	627b      	str	r3, [r7, #36]	; 0x24
	int w, p, xp;
	union arg arg;
	int argpos;
	unsigned st, ps;
	int cnt=0, l=0;
 801c7f4:	2300      	movs	r3, #0
 801c7f6:	643b      	str	r3, [r7, #64]	; 0x40
 801c7f8:	2300      	movs	r3, #0
 801c7fa:	647b      	str	r3, [r7, #68]	; 0x44

	for (;;) {
		/* This error is only specified for snprintf, but since it's
		 * unspecified for other forms, do the same. Stop immediately
		 * on overflow; otherwise %n could produce wrong results. */
		if (l > INT_MAX - cnt) goto overflow;
 801c7fc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801c7fe:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c802:	1a9b      	subs	r3, r3, r2
 801c804:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801c806:	429a      	cmp	r2, r3
 801c808:	f300 8488 	bgt.w	801d11c <printf_core+0x950>

		/* Update output count, end loop when fmt is exhausted */
		cnt += l;
 801c80c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801c80e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c810:	4413      	add	r3, r2
 801c812:	643b      	str	r3, [r7, #64]	; 0x40
		if (!*s) break;
 801c814:	69bb      	ldr	r3, [r7, #24]
 801c816:	781b      	ldrb	r3, [r3, #0]
 801c818:	2b00      	cmp	r3, #0
 801c81a:	f000 8431 	beq.w	801d080 <printf_core+0x8b4>

		/* Handle literal text and %% format specifiers */
		for (a=s; *s && *s!='%'; s++);
 801c81e:	69bb      	ldr	r3, [r7, #24]
 801c820:	61fb      	str	r3, [r7, #28]
 801c822:	e002      	b.n	801c82a <printf_core+0x5e>
 801c824:	69bb      	ldr	r3, [r7, #24]
 801c826:	3301      	adds	r3, #1
 801c828:	61bb      	str	r3, [r7, #24]
 801c82a:	69bb      	ldr	r3, [r7, #24]
 801c82c:	781b      	ldrb	r3, [r3, #0]
 801c82e:	2b00      	cmp	r3, #0
 801c830:	d003      	beq.n	801c83a <printf_core+0x6e>
 801c832:	69bb      	ldr	r3, [r7, #24]
 801c834:	781b      	ldrb	r3, [r3, #0]
 801c836:	2b25      	cmp	r3, #37	; 0x25
 801c838:	d1f4      	bne.n	801c824 <printf_core+0x58>
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
 801c83a:	69bb      	ldr	r3, [r7, #24]
 801c83c:	623b      	str	r3, [r7, #32]
 801c83e:	e005      	b.n	801c84c <printf_core+0x80>
 801c840:	6a3b      	ldr	r3, [r7, #32]
 801c842:	3301      	adds	r3, #1
 801c844:	623b      	str	r3, [r7, #32]
 801c846:	69bb      	ldr	r3, [r7, #24]
 801c848:	3302      	adds	r3, #2
 801c84a:	61bb      	str	r3, [r7, #24]
 801c84c:	69bb      	ldr	r3, [r7, #24]
 801c84e:	781b      	ldrb	r3, [r3, #0]
 801c850:	2b25      	cmp	r3, #37	; 0x25
 801c852:	d104      	bne.n	801c85e <printf_core+0x92>
 801c854:	69bb      	ldr	r3, [r7, #24]
 801c856:	3301      	adds	r3, #1
 801c858:	781b      	ldrb	r3, [r3, #0]
 801c85a:	2b25      	cmp	r3, #37	; 0x25
 801c85c:	d0f0      	beq.n	801c840 <printf_core+0x74>
		if (z-a > INT_MAX-cnt) goto overflow;
 801c85e:	6a3a      	ldr	r2, [r7, #32]
 801c860:	69fb      	ldr	r3, [r7, #28]
 801c862:	1ad2      	subs	r2, r2, r3
 801c864:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801c866:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801c86a:	1a5b      	subs	r3, r3, r1
 801c86c:	429a      	cmp	r2, r3
 801c86e:	f300 8457 	bgt.w	801d120 <printf_core+0x954>
		l = z-a;
 801c872:	6a3a      	ldr	r2, [r7, #32]
 801c874:	69fb      	ldr	r3, [r7, #28]
 801c876:	1ad3      	subs	r3, r2, r3
 801c878:	647b      	str	r3, [r7, #68]	; 0x44
		if (f) out(f, a, l);
 801c87a:	697b      	ldr	r3, [r7, #20]
 801c87c:	2b00      	cmp	r3, #0
 801c87e:	d005      	beq.n	801c88c <printf_core+0xc0>
 801c880:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c882:	461a      	mov	r2, r3
 801c884:	69f9      	ldr	r1, [r7, #28]
 801c886:	6978      	ldr	r0, [r7, #20]
 801c888:	f7fe fb10 	bl	801aeac <out>
		if (l) continue;
 801c88c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c88e:	2b00      	cmp	r3, #0
 801c890:	f040 83ea 	bne.w	801d068 <printf_core+0x89c>

		if (isdigit(s[1]) && s[2]=='$') {
 801c894:	69bb      	ldr	r3, [r7, #24]
 801c896:	3301      	adds	r3, #1
 801c898:	781b      	ldrb	r3, [r3, #0]
 801c89a:	3b30      	subs	r3, #48	; 0x30
 801c89c:	2b09      	cmp	r3, #9
 801c89e:	d80f      	bhi.n	801c8c0 <printf_core+0xf4>
 801c8a0:	69bb      	ldr	r3, [r7, #24]
 801c8a2:	3302      	adds	r3, #2
 801c8a4:	781b      	ldrb	r3, [r3, #0]
 801c8a6:	2b24      	cmp	r3, #36	; 0x24
 801c8a8:	d10a      	bne.n	801c8c0 <printf_core+0xf4>
			l10n=1;
 801c8aa:	2301      	movs	r3, #1
 801c8ac:	627b      	str	r3, [r7, #36]	; 0x24
			argpos = s[1]-'0';
 801c8ae:	69bb      	ldr	r3, [r7, #24]
 801c8b0:	3301      	adds	r3, #1
 801c8b2:	781b      	ldrb	r3, [r3, #0]
 801c8b4:	3b30      	subs	r3, #48	; 0x30
 801c8b6:	63bb      	str	r3, [r7, #56]	; 0x38
			s+=3;
 801c8b8:	69bb      	ldr	r3, [r7, #24]
 801c8ba:	3303      	adds	r3, #3
 801c8bc:	61bb      	str	r3, [r7, #24]
 801c8be:	e005      	b.n	801c8cc <printf_core+0x100>
		} else {
			argpos = -1;
 801c8c0:	f04f 33ff 	mov.w	r3, #4294967295
 801c8c4:	63bb      	str	r3, [r7, #56]	; 0x38
			s++;
 801c8c6:	69bb      	ldr	r3, [r7, #24]
 801c8c8:	3301      	adds	r3, #1
 801c8ca:	61bb      	str	r3, [r7, #24]
		}

		/* Read modifier flags */
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<(*s-' '))); s++)
 801c8cc:	2300      	movs	r3, #0
 801c8ce:	62bb      	str	r3, [r7, #40]	; 0x28
 801c8d0:	e00b      	b.n	801c8ea <printf_core+0x11e>
			fl |= 1U<<(*s-' ');
 801c8d2:	69bb      	ldr	r3, [r7, #24]
 801c8d4:	781b      	ldrb	r3, [r3, #0]
 801c8d6:	3b20      	subs	r3, #32
 801c8d8:	2201      	movs	r2, #1
 801c8da:	fa02 f303 	lsl.w	r3, r2, r3
 801c8de:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801c8e0:	4313      	orrs	r3, r2
 801c8e2:	62bb      	str	r3, [r7, #40]	; 0x28
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<(*s-' '))); s++)
 801c8e4:	69bb      	ldr	r3, [r7, #24]
 801c8e6:	3301      	adds	r3, #1
 801c8e8:	61bb      	str	r3, [r7, #24]
 801c8ea:	69bb      	ldr	r3, [r7, #24]
 801c8ec:	781b      	ldrb	r3, [r3, #0]
 801c8ee:	3b20      	subs	r3, #32
 801c8f0:	2b1f      	cmp	r3, #31
 801c8f2:	d809      	bhi.n	801c908 <printf_core+0x13c>
 801c8f4:	69bb      	ldr	r3, [r7, #24]
 801c8f6:	781b      	ldrb	r3, [r3, #0]
 801c8f8:	3b20      	subs	r3, #32
 801c8fa:	4a5b      	ldr	r2, [pc, #364]	; (801ca68 <printf_core+0x29c>)
 801c8fc:	fa22 f303 	lsr.w	r3, r2, r3
 801c900:	f003 0301 	and.w	r3, r3, #1
 801c904:	2b00      	cmp	r3, #0
 801c906:	d1e4      	bne.n	801c8d2 <printf_core+0x106>
		/* Read field width */
		if (*s=='*') {
 801c908:	69bb      	ldr	r3, [r7, #24]
 801c90a:	781b      	ldrb	r3, [r3, #0]
 801c90c:	2b2a      	cmp	r3, #42	; 0x2a
 801c90e:	d146      	bne.n	801c99e <printf_core+0x1d2>
			if (isdigit(s[1]) && s[2]=='$') {
 801c910:	69bb      	ldr	r3, [r7, #24]
 801c912:	3301      	adds	r3, #1
 801c914:	781b      	ldrb	r3, [r3, #0]
 801c916:	3b30      	subs	r3, #48	; 0x30
 801c918:	2b09      	cmp	r3, #9
 801c91a:	d822      	bhi.n	801c962 <printf_core+0x196>
 801c91c:	69bb      	ldr	r3, [r7, #24]
 801c91e:	3302      	adds	r3, #2
 801c920:	781b      	ldrb	r3, [r3, #0]
 801c922:	2b24      	cmp	r3, #36	; 0x24
 801c924:	d11d      	bne.n	801c962 <printf_core+0x196>
				l10n=1;
 801c926:	2301      	movs	r3, #1
 801c928:	627b      	str	r3, [r7, #36]	; 0x24
				nl_type[s[1]-'0'] = INT;
 801c92a:	69bb      	ldr	r3, [r7, #24]
 801c92c:	3301      	adds	r3, #1
 801c92e:	781b      	ldrb	r3, [r3, #0]
 801c930:	461a      	mov	r2, r3
 801c932:	4b4e      	ldr	r3, [pc, #312]	; (801ca6c <printf_core+0x2a0>)
 801c934:	4413      	add	r3, r2
 801c936:	009b      	lsls	r3, r3, #2
 801c938:	687a      	ldr	r2, [r7, #4]
 801c93a:	4413      	add	r3, r2
 801c93c:	220a      	movs	r2, #10
 801c93e:	601a      	str	r2, [r3, #0]
				w = nl_arg[s[1]-'0'].i;
 801c940:	69bb      	ldr	r3, [r7, #24]
 801c942:	3301      	adds	r3, #1
 801c944:	781b      	ldrb	r3, [r3, #0]
 801c946:	461a      	mov	r2, r3
 801c948:	4b49      	ldr	r3, [pc, #292]	; (801ca70 <printf_core+0x2a4>)
 801c94a:	4413      	add	r3, r2
 801c94c:	00db      	lsls	r3, r3, #3
 801c94e:	68ba      	ldr	r2, [r7, #8]
 801c950:	4413      	add	r3, r2
 801c952:	e9d3 2300 	ldrd	r2, r3, [r3]
 801c956:	4613      	mov	r3, r2
 801c958:	62fb      	str	r3, [r7, #44]	; 0x2c
				s+=3;
 801c95a:	69bb      	ldr	r3, [r7, #24]
 801c95c:	3303      	adds	r3, #3
 801c95e:	61bb      	str	r3, [r7, #24]
 801c960:	e012      	b.n	801c988 <printf_core+0x1bc>
			} else if (!l10n) {
 801c962:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c964:	2b00      	cmp	r3, #0
 801c966:	f040 83c8 	bne.w	801d0fa <printf_core+0x92e>
				w = f ? va_arg(*ap, int) : 0;
 801c96a:	697b      	ldr	r3, [r7, #20]
 801c96c:	2b00      	cmp	r3, #0
 801c96e:	d006      	beq.n	801c97e <printf_core+0x1b2>
 801c970:	68fb      	ldr	r3, [r7, #12]
 801c972:	681b      	ldr	r3, [r3, #0]
 801c974:	1d19      	adds	r1, r3, #4
 801c976:	68fa      	ldr	r2, [r7, #12]
 801c978:	6011      	str	r1, [r2, #0]
 801c97a:	681b      	ldr	r3, [r3, #0]
 801c97c:	e000      	b.n	801c980 <printf_core+0x1b4>
 801c97e:	2300      	movs	r3, #0
 801c980:	62fb      	str	r3, [r7, #44]	; 0x2c
				s++;
 801c982:	69bb      	ldr	r3, [r7, #24]
 801c984:	3301      	adds	r3, #1
 801c986:	61bb      	str	r3, [r7, #24]
			} else goto inval;
			if (w<0) fl|=LEFT_ADJ, w=-w;
 801c988:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c98a:	2b00      	cmp	r3, #0
 801c98c:	da11      	bge.n	801c9b2 <printf_core+0x1e6>
 801c98e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c990:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 801c994:	62bb      	str	r3, [r7, #40]	; 0x28
 801c996:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c998:	425b      	negs	r3, r3
 801c99a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801c99c:	e009      	b.n	801c9b2 <printf_core+0x1e6>
		} else if ((w=getint(&s))<0) goto overflow;
 801c99e:	f107 0318 	add.w	r3, r7, #24
 801c9a2:	4618      	mov	r0, r3
 801c9a4:	f7ff fed4 	bl	801c750 <getint>
 801c9a8:	62f8      	str	r0, [r7, #44]	; 0x2c
 801c9aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c9ac:	2b00      	cmp	r3, #0
 801c9ae:	f2c0 83b9 	blt.w	801d124 <printf_core+0x958>

		/* Read precision */
		if (*s=='.' && s[1]=='*') {
 801c9b2:	69bb      	ldr	r3, [r7, #24]
 801c9b4:	781b      	ldrb	r3, [r3, #0]
 801c9b6:	2b2e      	cmp	r3, #46	; 0x2e
 801c9b8:	d144      	bne.n	801ca44 <printf_core+0x278>
 801c9ba:	69bb      	ldr	r3, [r7, #24]
 801c9bc:	3301      	adds	r3, #1
 801c9be:	781b      	ldrb	r3, [r3, #0]
 801c9c0:	2b2a      	cmp	r3, #42	; 0x2a
 801c9c2:	d13f      	bne.n	801ca44 <printf_core+0x278>
			if (isdigit(s[2]) && s[3]=='$') {
 801c9c4:	69bb      	ldr	r3, [r7, #24]
 801c9c6:	3302      	adds	r3, #2
 801c9c8:	781b      	ldrb	r3, [r3, #0]
 801c9ca:	3b30      	subs	r3, #48	; 0x30
 801c9cc:	2b09      	cmp	r3, #9
 801c9ce:	d820      	bhi.n	801ca12 <printf_core+0x246>
 801c9d0:	69bb      	ldr	r3, [r7, #24]
 801c9d2:	3303      	adds	r3, #3
 801c9d4:	781b      	ldrb	r3, [r3, #0]
 801c9d6:	2b24      	cmp	r3, #36	; 0x24
 801c9d8:	d11b      	bne.n	801ca12 <printf_core+0x246>
				nl_type[s[2]-'0'] = INT;
 801c9da:	69bb      	ldr	r3, [r7, #24]
 801c9dc:	3302      	adds	r3, #2
 801c9de:	781b      	ldrb	r3, [r3, #0]
 801c9e0:	461a      	mov	r2, r3
 801c9e2:	4b22      	ldr	r3, [pc, #136]	; (801ca6c <printf_core+0x2a0>)
 801c9e4:	4413      	add	r3, r2
 801c9e6:	009b      	lsls	r3, r3, #2
 801c9e8:	687a      	ldr	r2, [r7, #4]
 801c9ea:	4413      	add	r3, r2
 801c9ec:	220a      	movs	r2, #10
 801c9ee:	601a      	str	r2, [r3, #0]
				p = nl_arg[s[2]-'0'].i;
 801c9f0:	69bb      	ldr	r3, [r7, #24]
 801c9f2:	3302      	adds	r3, #2
 801c9f4:	781b      	ldrb	r3, [r3, #0]
 801c9f6:	461a      	mov	r2, r3
 801c9f8:	4b1d      	ldr	r3, [pc, #116]	; (801ca70 <printf_core+0x2a4>)
 801c9fa:	4413      	add	r3, r2
 801c9fc:	00db      	lsls	r3, r3, #3
 801c9fe:	68ba      	ldr	r2, [r7, #8]
 801ca00:	4413      	add	r3, r2
 801ca02:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ca06:	4613      	mov	r3, r2
 801ca08:	633b      	str	r3, [r7, #48]	; 0x30
				s+=4;
 801ca0a:	69bb      	ldr	r3, [r7, #24]
 801ca0c:	3304      	adds	r3, #4
 801ca0e:	61bb      	str	r3, [r7, #24]
 801ca10:	e012      	b.n	801ca38 <printf_core+0x26c>
			} else if (!l10n) {
 801ca12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ca14:	2b00      	cmp	r3, #0
 801ca16:	f040 8372 	bne.w	801d0fe <printf_core+0x932>
				p = f ? va_arg(*ap, int) : 0;
 801ca1a:	697b      	ldr	r3, [r7, #20]
 801ca1c:	2b00      	cmp	r3, #0
 801ca1e:	d006      	beq.n	801ca2e <printf_core+0x262>
 801ca20:	68fb      	ldr	r3, [r7, #12]
 801ca22:	681b      	ldr	r3, [r3, #0]
 801ca24:	1d19      	adds	r1, r3, #4
 801ca26:	68fa      	ldr	r2, [r7, #12]
 801ca28:	6011      	str	r1, [r2, #0]
 801ca2a:	681b      	ldr	r3, [r3, #0]
 801ca2c:	e000      	b.n	801ca30 <printf_core+0x264>
 801ca2e:	2300      	movs	r3, #0
 801ca30:	633b      	str	r3, [r7, #48]	; 0x30
				s+=2;
 801ca32:	69bb      	ldr	r3, [r7, #24]
 801ca34:	3302      	adds	r3, #2
 801ca36:	61bb      	str	r3, [r7, #24]
			} else goto inval;
			xp = (p>=0);
 801ca38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ca3a:	43db      	mvns	r3, r3
 801ca3c:	0fdb      	lsrs	r3, r3, #31
 801ca3e:	b2db      	uxtb	r3, r3
 801ca40:	637b      	str	r3, [r7, #52]	; 0x34
 801ca42:	e01c      	b.n	801ca7e <printf_core+0x2b2>
		} else if (*s=='.') {
 801ca44:	69bb      	ldr	r3, [r7, #24]
 801ca46:	781b      	ldrb	r3, [r3, #0]
 801ca48:	2b2e      	cmp	r3, #46	; 0x2e
 801ca4a:	d113      	bne.n	801ca74 <printf_core+0x2a8>
			s++;
 801ca4c:	69bb      	ldr	r3, [r7, #24]
 801ca4e:	3301      	adds	r3, #1
 801ca50:	61bb      	str	r3, [r7, #24]
			p = getint(&s);
 801ca52:	f107 0318 	add.w	r3, r7, #24
 801ca56:	4618      	mov	r0, r3
 801ca58:	f7ff fe7a 	bl	801c750 <getint>
 801ca5c:	6338      	str	r0, [r7, #48]	; 0x30
			xp = 1;
 801ca5e:	2301      	movs	r3, #1
 801ca60:	637b      	str	r3, [r7, #52]	; 0x34
 801ca62:	e00c      	b.n	801ca7e <printf_core+0x2b2>
 801ca64:	080231a8 	.word	0x080231a8
 801ca68:	00012889 	.word	0x00012889
 801ca6c:	3fffffd0 	.word	0x3fffffd0
 801ca70:	1fffffd0 	.word	0x1fffffd0
		} else {
			p = -1;
 801ca74:	f04f 33ff 	mov.w	r3, #4294967295
 801ca78:	633b      	str	r3, [r7, #48]	; 0x30
			xp = 0;
 801ca7a:	2300      	movs	r3, #0
 801ca7c:	637b      	str	r3, [r7, #52]	; 0x34
		}

		/* Format specifier state machine */
		st=0;
 801ca7e:	2300      	movs	r3, #0
 801ca80:	63fb      	str	r3, [r7, #60]	; 0x3c
		do {
			if (OOB(*s)) goto inval;
 801ca82:	69bb      	ldr	r3, [r7, #24]
 801ca84:	781b      	ldrb	r3, [r3, #0]
 801ca86:	3b41      	subs	r3, #65	; 0x41
 801ca88:	2b39      	cmp	r3, #57	; 0x39
 801ca8a:	f200 833a 	bhi.w	801d102 <printf_core+0x936>
			ps=st;
 801ca8e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ca90:	65fb      	str	r3, [r7, #92]	; 0x5c
			st=states[st]S(*s++);
 801ca92:	69bb      	ldr	r3, [r7, #24]
 801ca94:	1c5a      	adds	r2, r3, #1
 801ca96:	61ba      	str	r2, [r7, #24]
 801ca98:	781b      	ldrb	r3, [r3, #0]
 801ca9a:	3b41      	subs	r3, #65	; 0x41
 801ca9c:	49b8      	ldr	r1, [pc, #736]	; (801cd80 <printf_core+0x5b4>)
 801ca9e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801caa0:	203a      	movs	r0, #58	; 0x3a
 801caa2:	fb00 f202 	mul.w	r2, r0, r2
 801caa6:	440a      	add	r2, r1
 801caa8:	4413      	add	r3, r2
 801caaa:	781b      	ldrb	r3, [r3, #0]
 801caac:	63fb      	str	r3, [r7, #60]	; 0x3c
		} while (st-1<STOP);
 801caae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801cab0:	3b01      	subs	r3, #1
 801cab2:	2b07      	cmp	r3, #7
 801cab4:	d9e5      	bls.n	801ca82 <printf_core+0x2b6>
		if (!st) goto inval;
 801cab6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801cab8:	2b00      	cmp	r3, #0
 801caba:	f000 8324 	beq.w	801d106 <printf_core+0x93a>

		/* Check validity of argument type (nl/normal) */
		if (st==NOARG) {
 801cabe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801cac0:	2b1b      	cmp	r3, #27
 801cac2:	d103      	bne.n	801cacc <printf_core+0x300>
			if (argpos>=0) goto inval;
 801cac4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cac6:	2b00      	cmp	r3, #0
 801cac8:	db1f      	blt.n	801cb0a <printf_core+0x33e>
 801caca:	e31f      	b.n	801d10c <printf_core+0x940>
		} else {
			if (argpos>=0) nl_type[argpos]=st, arg=nl_arg[argpos];
 801cacc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cace:	2b00      	cmp	r3, #0
 801cad0:	db0e      	blt.n	801caf0 <printf_core+0x324>
 801cad2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cad4:	009b      	lsls	r3, r3, #2
 801cad6:	687a      	ldr	r2, [r7, #4]
 801cad8:	4413      	add	r3, r2
 801cada:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801cadc:	601a      	str	r2, [r3, #0]
 801cade:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cae0:	00db      	lsls	r3, r3, #3
 801cae2:	68ba      	ldr	r2, [r7, #8]
 801cae4:	4413      	add	r3, r2
 801cae6:	e9d3 2300 	ldrd	r2, r3, [r3]
 801caea:	e9c7 2318 	strd	r2, r3, [r7, #96]	; 0x60
 801caee:	e00c      	b.n	801cb0a <printf_core+0x33e>
			else if (f) pop_arg(&arg, st, ap);
 801caf0:	697b      	ldr	r3, [r7, #20]
 801caf2:	2b00      	cmp	r3, #0
 801caf4:	d007      	beq.n	801cb06 <printf_core+0x33a>
 801caf6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801caf8:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801cafc:	68fa      	ldr	r2, [r7, #12]
 801cafe:	4618      	mov	r0, r3
 801cb00:	f7fe f8a6 	bl	801ac50 <pop_arg>
 801cb04:	e001      	b.n	801cb0a <printf_core+0x33e>
			else return 0;
 801cb06:	2300      	movs	r3, #0
 801cb08:	e320      	b.n	801d14c <printf_core+0x980>
		}

		if (!f) continue;
 801cb0a:	697b      	ldr	r3, [r7, #20]
 801cb0c:	2b00      	cmp	r3, #0
 801cb0e:	f000 82ae 	beq.w	801d06e <printf_core+0x8a2>

		z = buf + sizeof(buf);
 801cb12:	f107 0374 	add.w	r3, r7, #116	; 0x74
 801cb16:	3328      	adds	r3, #40	; 0x28
 801cb18:	623b      	str	r3, [r7, #32]
		prefix = "-+   0X0x";
 801cb1a:	4b9a      	ldr	r3, [pc, #616]	; (801cd84 <printf_core+0x5b8>)
 801cb1c:	64fb      	str	r3, [r7, #76]	; 0x4c
		pl = 0;
 801cb1e:	2300      	movs	r3, #0
 801cb20:	657b      	str	r3, [r7, #84]	; 0x54
		t = s[-1];
 801cb22:	69bb      	ldr	r3, [r7, #24]
 801cb24:	3b01      	subs	r3, #1
 801cb26:	781b      	ldrb	r3, [r3, #0]
 801cb28:	653b      	str	r3, [r7, #80]	; 0x50

		/* Transform ls,lc -> S,C */
		if (ps && (t&15)==3) t&=~32;
 801cb2a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801cb2c:	2b00      	cmp	r3, #0
 801cb2e:	d008      	beq.n	801cb42 <printf_core+0x376>
 801cb30:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801cb32:	f003 030f 	and.w	r3, r3, #15
 801cb36:	2b03      	cmp	r3, #3
 801cb38:	d103      	bne.n	801cb42 <printf_core+0x376>
 801cb3a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801cb3c:	f023 0320 	bic.w	r3, r3, #32
 801cb40:	653b      	str	r3, [r7, #80]	; 0x50

		/* - and 0 flags are mutually exclusive */
		if (fl & LEFT_ADJ) fl &= ~ZERO_PAD;
 801cb42:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cb44:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801cb48:	2b00      	cmp	r3, #0
 801cb4a:	d003      	beq.n	801cb54 <printf_core+0x388>
 801cb4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cb4e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801cb52:	62bb      	str	r3, [r7, #40]	; 0x28
 801cb54:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801cb56:	3b41      	subs	r3, #65	; 0x41
 801cb58:	2b37      	cmp	r3, #55	; 0x37
 801cb5a:	f200 8220 	bhi.w	801cf9e <printf_core+0x7d2>
 801cb5e:	a201      	add	r2, pc, #4	; (adr r2, 801cb64 <printf_core+0x398>)
 801cb60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801cb64:	0801cf6d 	.word	0x0801cf6d
 801cb68:	0801cf9f 	.word	0x0801cf9f
 801cb6c:	0801ce6b 	.word	0x0801ce6b
 801cb70:	0801cf9f 	.word	0x0801cf9f
 801cb74:	0801cf6d 	.word	0x0801cf6d
 801cb78:	0801cf6d 	.word	0x0801cf6d
 801cb7c:	0801cf6d 	.word	0x0801cf6d
 801cb80:	0801cf9f 	.word	0x0801cf9f
 801cb84:	0801cf9f 	.word	0x0801cf9f
 801cb88:	0801cf9f 	.word	0x0801cf9f
 801cb8c:	0801cf9f 	.word	0x0801cf9f
 801cb90:	0801cf9f 	.word	0x0801cf9f
 801cb94:	0801cf9f 	.word	0x0801cf9f
 801cb98:	0801cf9f 	.word	0x0801cf9f
 801cb9c:	0801cf9f 	.word	0x0801cf9f
 801cba0:	0801cf9f 	.word	0x0801cf9f
 801cba4:	0801cf9f 	.word	0x0801cf9f
 801cba8:	0801cf9f 	.word	0x0801cf9f
 801cbac:	0801ce83 	.word	0x0801ce83
 801cbb0:	0801cf9f 	.word	0x0801cf9f
 801cbb4:	0801cf9f 	.word	0x0801cf9f
 801cbb8:	0801cf9f 	.word	0x0801cf9f
 801cbbc:	0801cf9f 	.word	0x0801cf9f
 801cbc0:	0801ccd9 	.word	0x0801ccd9
 801cbc4:	0801cf9f 	.word	0x0801cf9f
 801cbc8:	0801cf9f 	.word	0x0801cf9f
 801cbcc:	0801cf9f 	.word	0x0801cf9f
 801cbd0:	0801cf9f 	.word	0x0801cf9f
 801cbd4:	0801cf9f 	.word	0x0801cf9f
 801cbd8:	0801cf9f 	.word	0x0801cf9f
 801cbdc:	0801cf9f 	.word	0x0801cf9f
 801cbe0:	0801cf9f 	.word	0x0801cf9f
 801cbe4:	0801cf6d 	.word	0x0801cf6d
 801cbe8:	0801cf9f 	.word	0x0801cf9f
 801cbec:	0801cded 	.word	0x0801cded
 801cbf0:	0801cd3d 	.word	0x0801cd3d
 801cbf4:	0801cf6d 	.word	0x0801cf6d
 801cbf8:	0801cf6d 	.word	0x0801cf6d
 801cbfc:	0801cf6d 	.word	0x0801cf6d
 801cc00:	0801cf9f 	.word	0x0801cf9f
 801cc04:	0801cd3d 	.word	0x0801cd3d
 801cc08:	0801cf9f 	.word	0x0801cf9f
 801cc0c:	0801cf9f 	.word	0x0801cf9f
 801cc10:	0801cf9f 	.word	0x0801cf9f
 801cc14:	0801ce0b 	.word	0x0801ce0b
 801cc18:	0801cc45 	.word	0x0801cc45
 801cc1c:	0801cd0f 	.word	0x0801cd0f
 801cc20:	0801ccc3 	.word	0x0801ccc3
 801cc24:	0801cf9f 	.word	0x0801cf9f
 801cc28:	0801cf9f 	.word	0x0801cf9f
 801cc2c:	0801ce1d 	.word	0x0801ce1d
 801cc30:	0801cf9f 	.word	0x0801cf9f
 801cc34:	0801cd8d 	.word	0x0801cd8d
 801cc38:	0801cf9f 	.word	0x0801cf9f
 801cc3c:	0801cf9f 	.word	0x0801cf9f
 801cc40:	0801ccd9 	.word	0x0801ccd9
 801cc44:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801cc46:	2b07      	cmp	r3, #7
 801cc48:	f200 8214 	bhi.w	801d074 <printf_core+0x8a8>
 801cc4c:	a201      	add	r2, pc, #4	; (adr r2, 801cc54 <printf_core+0x488>)
 801cc4e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801cc52:	bf00      	nop
 801cc54:	0801cc75 	.word	0x0801cc75
 801cc58:	0801cc7d 	.word	0x0801cc7d
 801cc5c:	0801cc85 	.word	0x0801cc85
 801cc60:	0801cc95 	.word	0x0801cc95
 801cc64:	0801cc9f 	.word	0x0801cc9f
 801cc68:	0801d075 	.word	0x0801d075
 801cc6c:	0801cca9 	.word	0x0801cca9
 801cc70:	0801ccb1 	.word	0x0801ccb1

		switch(t) {
		case 'n':
			switch(ps) {
			case BARE: *(int *)arg.p = cnt; break;
 801cc74:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801cc76:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801cc78:	601a      	str	r2, [r3, #0]
 801cc7a:	e021      	b.n	801ccc0 <printf_core+0x4f4>
			case LPRE: *(long *)arg.p = cnt; break;
 801cc7c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801cc7e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801cc80:	601a      	str	r2, [r3, #0]
 801cc82:	e01d      	b.n	801ccc0 <printf_core+0x4f4>
			case LLPRE: *(long long *)arg.p = cnt; break;
 801cc84:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801cc86:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cc88:	461a      	mov	r2, r3
 801cc8a:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801cc8e:	e9c1 2300 	strd	r2, r3, [r1]
 801cc92:	e015      	b.n	801ccc0 <printf_core+0x4f4>
			case HPRE: *(unsigned short *)arg.p = cnt; break;
 801cc94:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801cc96:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801cc98:	b292      	uxth	r2, r2
 801cc9a:	801a      	strh	r2, [r3, #0]
 801cc9c:	e010      	b.n	801ccc0 <printf_core+0x4f4>
			case HHPRE: *(unsigned char *)arg.p = cnt; break;
 801cc9e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801cca0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801cca2:	b2d2      	uxtb	r2, r2
 801cca4:	701a      	strb	r2, [r3, #0]
 801cca6:	e00b      	b.n	801ccc0 <printf_core+0x4f4>
			case ZTPRE: *(size_t *)arg.p = cnt; break;
 801cca8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ccaa:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801ccac:	601a      	str	r2, [r3, #0]
 801ccae:	e007      	b.n	801ccc0 <printf_core+0x4f4>
			case JPRE: *(uintmax_t *)arg.p = cnt; break;
 801ccb0:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801ccb2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ccb4:	461a      	mov	r2, r3
 801ccb6:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801ccba:	e9c1 2300 	strd	r2, r3, [r1]
 801ccbe:	bf00      	nop
			}
			continue;
 801ccc0:	e1d8      	b.n	801d074 <printf_core+0x8a8>
		case 'p':
			p = MAX((unsigned)p, 2*sizeof(void*));
 801ccc2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ccc4:	2b08      	cmp	r3, #8
 801ccc6:	bf38      	it	cc
 801ccc8:	2308      	movcc	r3, #8
 801ccca:	633b      	str	r3, [r7, #48]	; 0x30
			t = 'x';
 801cccc:	2378      	movs	r3, #120	; 0x78
 801ccce:	653b      	str	r3, [r7, #80]	; 0x50
			fl |= ALT_FORM;  /* fallthrough */
 801ccd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ccd2:	f043 0308 	orr.w	r3, r3, #8
 801ccd6:	62bb      	str	r3, [r7, #40]	; 0x28
		case 'x': case 'X':
			a = fmt_x(arg.i, z, t&32);
 801ccd8:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 801ccdc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ccde:	f003 0320 	and.w	r3, r3, #32
 801cce2:	6a3a      	ldr	r2, [r7, #32]
 801cce4:	f7fe f95e 	bl	801afa4 <fmt_x>
 801cce8:	61f8      	str	r0, [r7, #28]
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
 801ccea:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801ccee:	4313      	orrs	r3, r2
 801ccf0:	d052      	beq.n	801cd98 <printf_core+0x5cc>
 801ccf2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ccf4:	f003 0308 	and.w	r3, r3, #8
 801ccf8:	2b00      	cmp	r3, #0
 801ccfa:	d04d      	beq.n	801cd98 <printf_core+0x5cc>
 801ccfc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ccfe:	111b      	asrs	r3, r3, #4
 801cd00:	461a      	mov	r2, r3
 801cd02:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cd04:	4413      	add	r3, r2
 801cd06:	64fb      	str	r3, [r7, #76]	; 0x4c
 801cd08:	2302      	movs	r3, #2
 801cd0a:	657b      	str	r3, [r7, #84]	; 0x54
 801cd0c:	e044      	b.n	801cd98 <printf_core+0x5cc>
			if (0) {
		case 'o':
			a = fmt_o(arg.i, z);
 801cd0e:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 801cd12:	6a3a      	ldr	r2, [r7, #32]
 801cd14:	f7fe f97e 	bl	801b014 <fmt_o>
 801cd18:	61f8      	str	r0, [r7, #28]
			if ((fl&ALT_FORM) && p<z-a+1) p=z-a+1;
 801cd1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cd1c:	f003 0308 	and.w	r3, r3, #8
 801cd20:	2b00      	cmp	r3, #0
 801cd22:	d039      	beq.n	801cd98 <printf_core+0x5cc>
 801cd24:	6a3a      	ldr	r2, [r7, #32]
 801cd26:	69fb      	ldr	r3, [r7, #28]
 801cd28:	1ad3      	subs	r3, r2, r3
 801cd2a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cd2c:	429a      	cmp	r2, r3
 801cd2e:	dc33      	bgt.n	801cd98 <printf_core+0x5cc>
 801cd30:	6a3a      	ldr	r2, [r7, #32]
 801cd32:	69fb      	ldr	r3, [r7, #28]
 801cd34:	1ad3      	subs	r3, r2, r3
 801cd36:	3301      	adds	r3, #1
 801cd38:	633b      	str	r3, [r7, #48]	; 0x30
 801cd3a:	e02d      	b.n	801cd98 <printf_core+0x5cc>
			} if (0) {
		case 'd': case 'i':
			pl=1;
 801cd3c:	2301      	movs	r3, #1
 801cd3e:	657b      	str	r3, [r7, #84]	; 0x54
			if (arg.i>INTMAX_MAX) {
 801cd40:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cd44:	2a00      	cmp	r2, #0
 801cd46:	f173 0300 	sbcs.w	r3, r3, #0
 801cd4a:	da07      	bge.n	801cd5c <printf_core+0x590>
				arg.i=-arg.i;
 801cd4c:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cd50:	4252      	negs	r2, r2
 801cd52:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 801cd56:	e9c7 2318 	strd	r2, r3, [r7, #96]	; 0x60
 801cd5a:	e017      	b.n	801cd8c <printf_core+0x5c0>
			} else if (fl & MARK_POS) {
 801cd5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cd5e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801cd62:	2b00      	cmp	r3, #0
 801cd64:	d003      	beq.n	801cd6e <printf_core+0x5a2>
				prefix++;
 801cd66:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cd68:	3301      	adds	r3, #1
 801cd6a:	64fb      	str	r3, [r7, #76]	; 0x4c
 801cd6c:	e00e      	b.n	801cd8c <printf_core+0x5c0>
			} else if (fl & PAD_POS) {
 801cd6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cd70:	f003 0301 	and.w	r3, r3, #1
 801cd74:	2b00      	cmp	r3, #0
 801cd76:	d007      	beq.n	801cd88 <printf_core+0x5bc>
				prefix+=2;
 801cd78:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801cd7a:	3302      	adds	r3, #2
 801cd7c:	64fb      	str	r3, [r7, #76]	; 0x4c
 801cd7e:	e005      	b.n	801cd8c <printf_core+0x5c0>
 801cd80:	08023968 	.word	0x08023968
 801cd84:	08023194 	.word	0x08023194
			} else pl=0;
 801cd88:	2300      	movs	r3, #0
 801cd8a:	657b      	str	r3, [r7, #84]	; 0x54
		case 'u':
			a = fmt_u(arg.i, z);
 801cd8c:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 801cd90:	6a3a      	ldr	r2, [r7, #32]
 801cd92:	f7fe f969 	bl	801b068 <fmt_u>
 801cd96:	61f8      	str	r0, [r7, #28]
			}
			if (xp && p<0) goto overflow;
 801cd98:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cd9a:	2b00      	cmp	r3, #0
 801cd9c:	d003      	beq.n	801cda6 <printf_core+0x5da>
 801cd9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cda0:	2b00      	cmp	r3, #0
 801cda2:	f2c0 81c1 	blt.w	801d128 <printf_core+0x95c>
			if (xp) fl &= ~ZERO_PAD;
 801cda6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cda8:	2b00      	cmp	r3, #0
 801cdaa:	d003      	beq.n	801cdb4 <printf_core+0x5e8>
 801cdac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cdae:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801cdb2:	62bb      	str	r3, [r7, #40]	; 0x28
			if (!arg.i && !p) {
 801cdb4:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cdb8:	4313      	orrs	r3, r2
 801cdba:	d105      	bne.n	801cdc8 <printf_core+0x5fc>
 801cdbc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cdbe:	2b00      	cmp	r3, #0
 801cdc0:	d102      	bne.n	801cdc8 <printf_core+0x5fc>
				a=z;
 801cdc2:	6a3b      	ldr	r3, [r7, #32]
 801cdc4:	61fb      	str	r3, [r7, #28]
				break;
 801cdc6:	e0ea      	b.n	801cf9e <printf_core+0x7d2>
			}
			p = MAX(p, z-a + !arg.i);
 801cdc8:	6a3a      	ldr	r2, [r7, #32]
 801cdca:	69fb      	ldr	r3, [r7, #28]
 801cdcc:	1ad1      	subs	r1, r2, r3
 801cdce:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cdd2:	4313      	orrs	r3, r2
 801cdd4:	2b00      	cmp	r3, #0
 801cdd6:	bf0c      	ite	eq
 801cdd8:	2301      	moveq	r3, #1
 801cdda:	2300      	movne	r3, #0
 801cddc:	b2db      	uxtb	r3, r3
 801cdde:	440b      	add	r3, r1
 801cde0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cde2:	4293      	cmp	r3, r2
 801cde4:	bfb8      	it	lt
 801cde6:	4613      	movlt	r3, r2
 801cde8:	633b      	str	r3, [r7, #48]	; 0x30
			break;
 801cdea:	e0d8      	b.n	801cf9e <printf_core+0x7d2>
		case 'c':
			*(a=z-(p=1))=arg.i;
 801cdec:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cdf0:	2101      	movs	r1, #1
 801cdf2:	6339      	str	r1, [r7, #48]	; 0x30
 801cdf4:	6a39      	ldr	r1, [r7, #32]
 801cdf6:	3901      	subs	r1, #1
 801cdf8:	61f9      	str	r1, [r7, #28]
 801cdfa:	b2d2      	uxtb	r2, r2
 801cdfc:	69fb      	ldr	r3, [r7, #28]
 801cdfe:	701a      	strb	r2, [r3, #0]
			fl &= ~ZERO_PAD;
 801ce00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ce02:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801ce06:	62bb      	str	r3, [r7, #40]	; 0x28
			break;
 801ce08:	e0c9      	b.n	801cf9e <printf_core+0x7d2>
		case 'm':
			if (1) a = strerror(errno); else /* fallthrough */
 801ce0a:	f7f3 f8c5 	bl	800ff98 <__errno_location>
 801ce0e:	4603      	mov	r3, r0
 801ce10:	681b      	ldr	r3, [r3, #0]
 801ce12:	4618      	mov	r0, r3
 801ce14:	f000 fff8 	bl	801de08 <strerror>
 801ce18:	61f8      	str	r0, [r7, #28]
 801ce1a:	e006      	b.n	801ce2a <printf_core+0x65e>
		case 's':
			a = arg.p ? arg.p : "(null)";
 801ce1c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ce1e:	2b00      	cmp	r3, #0
 801ce20:	d001      	beq.n	801ce26 <printf_core+0x65a>
 801ce22:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ce24:	e000      	b.n	801ce28 <printf_core+0x65c>
 801ce26:	4b9d      	ldr	r3, [pc, #628]	; (801d09c <printf_core+0x8d0>)
 801ce28:	61fb      	str	r3, [r7, #28]
			z = a + strnlen(a, p<0 ? INT_MAX : p);
 801ce2a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ce2c:	2b00      	cmp	r3, #0
 801ce2e:	db01      	blt.n	801ce34 <printf_core+0x668>
 801ce30:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ce32:	e001      	b.n	801ce38 <printf_core+0x66c>
 801ce34:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801ce38:	4619      	mov	r1, r3
 801ce3a:	69f8      	ldr	r0, [r7, #28]
 801ce3c:	f001 f85f 	bl	801defe <strnlen>
 801ce40:	4602      	mov	r2, r0
 801ce42:	69fb      	ldr	r3, [r7, #28]
 801ce44:	4413      	add	r3, r2
 801ce46:	623b      	str	r3, [r7, #32]
			if (p<0 && *z) goto overflow;
 801ce48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ce4a:	2b00      	cmp	r3, #0
 801ce4c:	da04      	bge.n	801ce58 <printf_core+0x68c>
 801ce4e:	6a3b      	ldr	r3, [r7, #32]
 801ce50:	781b      	ldrb	r3, [r3, #0]
 801ce52:	2b00      	cmp	r3, #0
 801ce54:	f040 816a 	bne.w	801d12c <printf_core+0x960>
			p = z-a;
 801ce58:	6a3a      	ldr	r2, [r7, #32]
 801ce5a:	69fb      	ldr	r3, [r7, #28]
 801ce5c:	1ad3      	subs	r3, r2, r3
 801ce5e:	633b      	str	r3, [r7, #48]	; 0x30
			fl &= ~ZERO_PAD;
 801ce60:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ce62:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801ce66:	62bb      	str	r3, [r7, #40]	; 0x28
			break;
 801ce68:	e099      	b.n	801cf9e <printf_core+0x7d2>
		case 'C':
			wc[0] = arg.i;
 801ce6a:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801ce6e:	4613      	mov	r3, r2
 801ce70:	66bb      	str	r3, [r7, #104]	; 0x68
			wc[1] = 0;
 801ce72:	2300      	movs	r3, #0
 801ce74:	66fb      	str	r3, [r7, #108]	; 0x6c
			arg.p = wc;
 801ce76:	f107 0368 	add.w	r3, r7, #104	; 0x68
 801ce7a:	663b      	str	r3, [r7, #96]	; 0x60
			p = -1; /* fallthrough */
 801ce7c:	f04f 33ff 	mov.w	r3, #4294967295
 801ce80:	633b      	str	r3, [r7, #48]	; 0x30
		case 'S':
			ws = arg.p;
 801ce82:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ce84:	65bb      	str	r3, [r7, #88]	; 0x58
			for (i=l=0; (int)i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-(int)i; i+=l);
 801ce86:	2300      	movs	r3, #0
 801ce88:	647b      	str	r3, [r7, #68]	; 0x44
 801ce8a:	2300      	movs	r3, #0
 801ce8c:	64bb      	str	r3, [r7, #72]	; 0x48
 801ce8e:	e003      	b.n	801ce98 <printf_core+0x6cc>
 801ce90:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ce92:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801ce94:	4413      	add	r3, r2
 801ce96:	64bb      	str	r3, [r7, #72]	; 0x48
 801ce98:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ce9a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801ce9c:	429a      	cmp	r2, r3
 801ce9e:	dd17      	ble.n	801ced0 <printf_core+0x704>
 801cea0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801cea2:	681b      	ldr	r3, [r3, #0]
 801cea4:	2b00      	cmp	r3, #0
 801cea6:	d013      	beq.n	801ced0 <printf_core+0x704>
 801cea8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801ceaa:	1d1a      	adds	r2, r3, #4
 801ceac:	65ba      	str	r2, [r7, #88]	; 0x58
 801ceae:	681a      	ldr	r2, [r3, #0]
 801ceb0:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801ceb4:	4611      	mov	r1, r2
 801ceb6:	4618      	mov	r0, r3
 801ceb8:	f002 fa44 	bl	801f344 <wctomb>
 801cebc:	6478      	str	r0, [r7, #68]	; 0x44
 801cebe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cec0:	2b00      	cmp	r3, #0
 801cec2:	db05      	blt.n	801ced0 <printf_core+0x704>
 801cec4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801cec6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cec8:	1ad3      	subs	r3, r2, r3
 801ceca:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801cecc:	429a      	cmp	r2, r3
 801cece:	dddf      	ble.n	801ce90 <printf_core+0x6c4>
			if (l<0) return -1;
 801ced0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ced2:	2b00      	cmp	r3, #0
 801ced4:	da02      	bge.n	801cedc <printf_core+0x710>
 801ced6:	f04f 33ff 	mov.w	r3, #4294967295
 801ceda:	e137      	b.n	801d14c <printf_core+0x980>
			if (i > INT_MAX) goto overflow;
 801cedc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801cede:	2b00      	cmp	r3, #0
 801cee0:	f2c0 8126 	blt.w	801d130 <printf_core+0x964>
			p = i;
 801cee4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801cee6:	633b      	str	r3, [r7, #48]	; 0x30
			pad(f, ' ', w, p, fl);
 801cee8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ceea:	9300      	str	r3, [sp, #0]
 801ceec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ceee:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801cef0:	2120      	movs	r1, #32
 801cef2:	6978      	ldr	r0, [r7, #20]
 801cef4:	f7fd fff0 	bl	801aed8 <pad>
			ws = arg.p;
 801cef8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801cefa:	65bb      	str	r3, [r7, #88]	; 0x58
			for (i=0; (int)i<0+p && *ws && (int)i+(l=wctomb(mb, *ws++))<=p; i+=l)
 801cefc:	2300      	movs	r3, #0
 801cefe:	64bb      	str	r3, [r7, #72]	; 0x48
 801cf00:	e00a      	b.n	801cf18 <printf_core+0x74c>
				out(f, mb, l);
 801cf02:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801cf04:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801cf08:	4619      	mov	r1, r3
 801cf0a:	6978      	ldr	r0, [r7, #20]
 801cf0c:	f7fd ffce 	bl	801aeac <out>
			for (i=0; (int)i<0+p && *ws && (int)i+(l=wctomb(mb, *ws++))<=p; i+=l)
 801cf10:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cf12:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801cf14:	4413      	add	r3, r2
 801cf16:	64bb      	str	r3, [r7, #72]	; 0x48
 801cf18:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801cf1a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cf1c:	429a      	cmp	r2, r3
 801cf1e:	dd14      	ble.n	801cf4a <printf_core+0x77e>
 801cf20:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801cf22:	681b      	ldr	r3, [r3, #0]
 801cf24:	2b00      	cmp	r3, #0
 801cf26:	d010      	beq.n	801cf4a <printf_core+0x77e>
 801cf28:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801cf2a:	1d1a      	adds	r2, r3, #4
 801cf2c:	65ba      	str	r2, [r7, #88]	; 0x58
 801cf2e:	681a      	ldr	r2, [r3, #0]
 801cf30:	f107 0370 	add.w	r3, r7, #112	; 0x70
 801cf34:	4611      	mov	r1, r2
 801cf36:	4618      	mov	r0, r3
 801cf38:	f002 fa04 	bl	801f344 <wctomb>
 801cf3c:	6478      	str	r0, [r7, #68]	; 0x44
 801cf3e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801cf40:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cf42:	4413      	add	r3, r2
 801cf44:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cf46:	429a      	cmp	r2, r3
 801cf48:	dadb      	bge.n	801cf02 <printf_core+0x736>
			pad(f, ' ', w, p, fl^LEFT_ADJ);
 801cf4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cf4c:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 801cf50:	9300      	str	r3, [sp, #0]
 801cf52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cf54:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801cf56:	2120      	movs	r1, #32
 801cf58:	6978      	ldr	r0, [r7, #20]
 801cf5a:	f7fd ffbd 	bl	801aed8 <pad>
			l = w>p ? w : p;
 801cf5e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cf60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801cf62:	4293      	cmp	r3, r2
 801cf64:	bfb8      	it	lt
 801cf66:	4613      	movlt	r3, r2
 801cf68:	647b      	str	r3, [r7, #68]	; 0x44
			continue;
 801cf6a:	e087      	b.n	801d07c <printf_core+0x8b0>
		case 'e': case 'f': case 'g': case 'a':
		case 'E': case 'F': case 'G': case 'A':
			if (xp && p<0) goto overflow;
 801cf6c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cf6e:	2b00      	cmp	r3, #0
 801cf70:	d003      	beq.n	801cf7a <printf_core+0x7ae>
 801cf72:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cf74:	2b00      	cmp	r3, #0
 801cf76:	f2c0 80dd 	blt.w	801d134 <printf_core+0x968>
			l = fmt_fp(f, arg.f, w, p, fl, t);
 801cf7a:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801cf7e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801cf80:	6d38      	ldr	r0, [r7, #80]	; 0x50
 801cf82:	9003      	str	r0, [sp, #12]
 801cf84:	9102      	str	r1, [sp, #8]
 801cf86:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801cf88:	9101      	str	r1, [sp, #4]
 801cf8a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801cf8c:	9100      	str	r1, [sp, #0]
 801cf8e:	6978      	ldr	r0, [r7, #20]
 801cf90:	f7fe f8ba 	bl	801b108 <fmt_fp>
 801cf94:	6478      	str	r0, [r7, #68]	; 0x44
			if (l<0) goto overflow;
 801cf96:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801cf98:	2b00      	cmp	r3, #0
 801cf9a:	da6e      	bge.n	801d07a <printf_core+0x8ae>
 801cf9c:	e0cf      	b.n	801d13e <printf_core+0x972>
			continue;
		}

		if (p < z-a) p = z-a;
 801cf9e:	6a3a      	ldr	r2, [r7, #32]
 801cfa0:	69fb      	ldr	r3, [r7, #28]
 801cfa2:	1ad3      	subs	r3, r2, r3
 801cfa4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cfa6:	429a      	cmp	r2, r3
 801cfa8:	da03      	bge.n	801cfb2 <printf_core+0x7e6>
 801cfaa:	6a3a      	ldr	r2, [r7, #32]
 801cfac:	69fb      	ldr	r3, [r7, #28]
 801cfae:	1ad3      	subs	r3, r2, r3
 801cfb0:	633b      	str	r3, [r7, #48]	; 0x30
		if (p > INT_MAX-pl) goto overflow;
 801cfb2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801cfb4:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801cfb8:	1a9b      	subs	r3, r3, r2
 801cfba:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801cfbc:	429a      	cmp	r2, r3
 801cfbe:	f300 80bb 	bgt.w	801d138 <printf_core+0x96c>
		if (w < pl+p) w = pl+p;
 801cfc2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801cfc4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cfc6:	4413      	add	r3, r2
 801cfc8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801cfca:	429a      	cmp	r2, r3
 801cfcc:	da03      	bge.n	801cfd6 <printf_core+0x80a>
 801cfce:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801cfd0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cfd2:	4413      	add	r3, r2
 801cfd4:	62fb      	str	r3, [r7, #44]	; 0x2c
		if (w > INT_MAX-cnt) goto overflow;
 801cfd6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801cfd8:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801cfdc:	1a9b      	subs	r3, r3, r2
 801cfde:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801cfe0:	429a      	cmp	r2, r3
 801cfe2:	f300 80ab 	bgt.w	801d13c <printf_core+0x970>

		pad(f, ' ', w, pl+p, fl);
 801cfe6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801cfe8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801cfea:	441a      	add	r2, r3
 801cfec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cfee:	9300      	str	r3, [sp, #0]
 801cff0:	4613      	mov	r3, r2
 801cff2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801cff4:	2120      	movs	r1, #32
 801cff6:	6978      	ldr	r0, [r7, #20]
 801cff8:	f7fd ff6e 	bl	801aed8 <pad>
		out(f, prefix, pl);
 801cffc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801cffe:	461a      	mov	r2, r3
 801d000:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801d002:	6978      	ldr	r0, [r7, #20]
 801d004:	f7fd ff52 	bl	801aeac <out>
		pad(f, '0', w, pl+p, fl^ZERO_PAD);
 801d008:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801d00a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d00c:	441a      	add	r2, r3
 801d00e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801d010:	f483 3380 	eor.w	r3, r3, #65536	; 0x10000
 801d014:	9300      	str	r3, [sp, #0]
 801d016:	4613      	mov	r3, r2
 801d018:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d01a:	2130      	movs	r1, #48	; 0x30
 801d01c:	6978      	ldr	r0, [r7, #20]
 801d01e:	f7fd ff5b 	bl	801aed8 <pad>
		pad(f, '0', p, z-a, 0);
 801d022:	6a3a      	ldr	r2, [r7, #32]
 801d024:	69fb      	ldr	r3, [r7, #28]
 801d026:	1ad3      	subs	r3, r2, r3
 801d028:	2200      	movs	r2, #0
 801d02a:	9200      	str	r2, [sp, #0]
 801d02c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801d02e:	2130      	movs	r1, #48	; 0x30
 801d030:	6978      	ldr	r0, [r7, #20]
 801d032:	f7fd ff51 	bl	801aed8 <pad>
		out(f, a, z-a);
 801d036:	6a3a      	ldr	r2, [r7, #32]
 801d038:	69fb      	ldr	r3, [r7, #28]
 801d03a:	1ad3      	subs	r3, r2, r3
 801d03c:	461a      	mov	r2, r3
 801d03e:	69f9      	ldr	r1, [r7, #28]
 801d040:	6978      	ldr	r0, [r7, #20]
 801d042:	f7fd ff33 	bl	801aeac <out>
		pad(f, ' ', w, pl+p, fl^LEFT_ADJ);
 801d046:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801d048:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d04a:	441a      	add	r2, r3
 801d04c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801d04e:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 801d052:	9300      	str	r3, [sp, #0]
 801d054:	4613      	mov	r3, r2
 801d056:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d058:	2120      	movs	r1, #32
 801d05a:	6978      	ldr	r0, [r7, #20]
 801d05c:	f7fd ff3c 	bl	801aed8 <pad>

		l = w;
 801d060:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d062:	647b      	str	r3, [r7, #68]	; 0x44
 801d064:	f7ff bbca 	b.w	801c7fc <printf_core+0x30>
		if (l) continue;
 801d068:	bf00      	nop
 801d06a:	f7ff bbc7 	b.w	801c7fc <printf_core+0x30>
		if (!f) continue;
 801d06e:	bf00      	nop
 801d070:	f7ff bbc4 	b.w	801c7fc <printf_core+0x30>
			continue;
 801d074:	bf00      	nop
 801d076:	f7ff bbc1 	b.w	801c7fc <printf_core+0x30>
			continue;
 801d07a:	bf00      	nop
		if (l > INT_MAX - cnt) goto overflow;
 801d07c:	f7ff bbbe 	b.w	801c7fc <printf_core+0x30>
		if (!*s) break;
 801d080:	bf00      	nop
	}

	if (f) return cnt;
 801d082:	697b      	ldr	r3, [r7, #20]
 801d084:	2b00      	cmp	r3, #0
 801d086:	d001      	beq.n	801d08c <printf_core+0x8c0>
 801d088:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d08a:	e05f      	b.n	801d14c <printf_core+0x980>
	if (!l10n) return 0;
 801d08c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d08e:	2b00      	cmp	r3, #0
 801d090:	d101      	bne.n	801d096 <printf_core+0x8ca>
 801d092:	2300      	movs	r3, #0
 801d094:	e05a      	b.n	801d14c <printf_core+0x980>

	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
 801d096:	2301      	movs	r3, #1
 801d098:	64bb      	str	r3, [r7, #72]	; 0x48
 801d09a:	e011      	b.n	801d0c0 <printf_core+0x8f4>
 801d09c:	080231a0 	.word	0x080231a0
		pop_arg(nl_arg+i, nl_type[i], ap);
 801d0a0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d0a2:	00db      	lsls	r3, r3, #3
 801d0a4:	68ba      	ldr	r2, [r7, #8]
 801d0a6:	18d0      	adds	r0, r2, r3
 801d0a8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d0aa:	009b      	lsls	r3, r3, #2
 801d0ac:	687a      	ldr	r2, [r7, #4]
 801d0ae:	4413      	add	r3, r2
 801d0b0:	681b      	ldr	r3, [r3, #0]
 801d0b2:	68fa      	ldr	r2, [r7, #12]
 801d0b4:	4619      	mov	r1, r3
 801d0b6:	f7fd fdcb 	bl	801ac50 <pop_arg>
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
 801d0ba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d0bc:	3301      	adds	r3, #1
 801d0be:	64bb      	str	r3, [r7, #72]	; 0x48
 801d0c0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d0c2:	2b09      	cmp	r3, #9
 801d0c4:	d80a      	bhi.n	801d0dc <printf_core+0x910>
 801d0c6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d0c8:	009b      	lsls	r3, r3, #2
 801d0ca:	687a      	ldr	r2, [r7, #4]
 801d0cc:	4413      	add	r3, r2
 801d0ce:	681b      	ldr	r3, [r3, #0]
 801d0d0:	2b00      	cmp	r3, #0
 801d0d2:	d1e5      	bne.n	801d0a0 <printf_core+0x8d4>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
 801d0d4:	e002      	b.n	801d0dc <printf_core+0x910>
 801d0d6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d0d8:	3301      	adds	r3, #1
 801d0da:	64bb      	str	r3, [r7, #72]	; 0x48
 801d0dc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d0de:	2b09      	cmp	r3, #9
 801d0e0:	d806      	bhi.n	801d0f0 <printf_core+0x924>
 801d0e2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d0e4:	009b      	lsls	r3, r3, #2
 801d0e6:	687a      	ldr	r2, [r7, #4]
 801d0e8:	4413      	add	r3, r2
 801d0ea:	681b      	ldr	r3, [r3, #0]
 801d0ec:	2b00      	cmp	r3, #0
 801d0ee:	d0f2      	beq.n	801d0d6 <printf_core+0x90a>
	if (i<=NL_ARGMAX) goto inval;
 801d0f0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d0f2:	2b09      	cmp	r3, #9
 801d0f4:	d909      	bls.n	801d10a <printf_core+0x93e>
	return 1;
 801d0f6:	2301      	movs	r3, #1
 801d0f8:	e028      	b.n	801d14c <printf_core+0x980>
			} else goto inval;
 801d0fa:	bf00      	nop
 801d0fc:	e006      	b.n	801d10c <printf_core+0x940>
			} else goto inval;
 801d0fe:	bf00      	nop
 801d100:	e004      	b.n	801d10c <printf_core+0x940>
			if (OOB(*s)) goto inval;
 801d102:	bf00      	nop
 801d104:	e002      	b.n	801d10c <printf_core+0x940>
		if (!st) goto inval;
 801d106:	bf00      	nop
 801d108:	e000      	b.n	801d10c <printf_core+0x940>
	if (i<=NL_ARGMAX) goto inval;
 801d10a:	bf00      	nop

inval:
	errno = EINVAL;
 801d10c:	f7f2 ff44 	bl	800ff98 <__errno_location>
 801d110:	4603      	mov	r3, r0
 801d112:	2216      	movs	r2, #22
 801d114:	601a      	str	r2, [r3, #0]
	return -1;
 801d116:	f04f 33ff 	mov.w	r3, #4294967295
 801d11a:	e017      	b.n	801d14c <printf_core+0x980>
		if (l > INT_MAX - cnt) goto overflow;
 801d11c:	bf00      	nop
 801d11e:	e00e      	b.n	801d13e <printf_core+0x972>
		if (z-a > INT_MAX-cnt) goto overflow;
 801d120:	bf00      	nop
 801d122:	e00c      	b.n	801d13e <printf_core+0x972>
		} else if ((w=getint(&s))<0) goto overflow;
 801d124:	bf00      	nop
 801d126:	e00a      	b.n	801d13e <printf_core+0x972>
			if (xp && p<0) goto overflow;
 801d128:	bf00      	nop
 801d12a:	e008      	b.n	801d13e <printf_core+0x972>
			if (p<0 && *z) goto overflow;
 801d12c:	bf00      	nop
 801d12e:	e006      	b.n	801d13e <printf_core+0x972>
			if (i > INT_MAX) goto overflow;
 801d130:	bf00      	nop
 801d132:	e004      	b.n	801d13e <printf_core+0x972>
			if (xp && p<0) goto overflow;
 801d134:	bf00      	nop
 801d136:	e002      	b.n	801d13e <printf_core+0x972>
		if (p > INT_MAX-pl) goto overflow;
 801d138:	bf00      	nop
 801d13a:	e000      	b.n	801d13e <printf_core+0x972>
		if (w > INT_MAX-cnt) goto overflow;
 801d13c:	bf00      	nop
overflow:
	errno = EOVERFLOW;
 801d13e:	f7f2 ff2b 	bl	800ff98 <__errno_location>
 801d142:	4603      	mov	r3, r0
 801d144:	224b      	movs	r2, #75	; 0x4b
 801d146:	601a      	str	r2, [r3, #0]
	return -1;
 801d148:	f04f 33ff 	mov.w	r3, #4294967295
}
 801d14c:	4a05      	ldr	r2, [pc, #20]	; (801d164 <printf_core+0x998>)
 801d14e:	6811      	ldr	r1, [r2, #0]
 801d150:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 801d154:	4051      	eors	r1, r2
 801d156:	d001      	beq.n	801d15c <printf_core+0x990>
 801d158:	f7e7 fa40 	bl	80045dc <__stack_chk_fail>
 801d15c:	4618      	mov	r0, r3
 801d15e:	37a0      	adds	r7, #160	; 0xa0
 801d160:	46bd      	mov	sp, r7
 801d162:	bd80      	pop	{r7, pc}
 801d164:	080231a8 	.word	0x080231a8

0801d168 <vfprintf>:

int vfprintf(FILE *restrict f, const char *restrict fmt, va_list ap)
{
 801d168:	b580      	push	{r7, lr}
 801d16a:	b0c0      	sub	sp, #256	; 0x100
 801d16c:	af02      	add	r7, sp, #8
 801d16e:	60f8      	str	r0, [r7, #12]
 801d170:	60b9      	str	r1, [r7, #8]
 801d172:	607a      	str	r2, [r7, #4]
 801d174:	4b59      	ldr	r3, [pc, #356]	; (801d2dc <vfprintf+0x174>)
 801d176:	681b      	ldr	r3, [r3, #0]
 801d178:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 801d17c:	f04f 0300 	mov.w	r3, #0
	va_list ap2;
	int nl_type[NL_ARGMAX+1] = {0};
 801d180:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801d184:	2228      	movs	r2, #40	; 0x28
 801d186:	2100      	movs	r1, #0
 801d188:	4618      	mov	r0, r3
 801d18a:	f7f2 f8bd 	bl	800f308 <memset>
	union arg nl_arg[NL_ARGMAX+1];
	unsigned char internal_buf[80], *saved_buf = 0;
 801d18e:	2300      	movs	r3, #0
 801d190:	61bb      	str	r3, [r7, #24]
	int olderr;
	int ret;

	/* the copy allows passing va_list* even if va_list is an array */
	va_copy(ap2, ap);
 801d192:	687b      	ldr	r3, [r7, #4]
 801d194:	617b      	str	r3, [r7, #20]
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
 801d196:	f107 0150 	add.w	r1, r7, #80	; 0x50
 801d19a:	f107 0214 	add.w	r2, r7, #20
 801d19e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801d1a2:	9300      	str	r3, [sp, #0]
 801d1a4:	460b      	mov	r3, r1
 801d1a6:	68b9      	ldr	r1, [r7, #8]
 801d1a8:	2000      	movs	r0, #0
 801d1aa:	f7ff fb0f 	bl	801c7cc <printf_core>
 801d1ae:	4603      	mov	r3, r0
 801d1b0:	2b00      	cmp	r3, #0
 801d1b2:	da02      	bge.n	801d1ba <vfprintf+0x52>
		va_end(ap2);
		return -1;
 801d1b4:	f04f 33ff 	mov.w	r3, #4294967295
 801d1b8:	e084      	b.n	801d2c4 <vfprintf+0x15c>
	}

	FLOCK(f);
 801d1ba:	68fb      	ldr	r3, [r7, #12]
 801d1bc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801d1be:	2b00      	cmp	r3, #0
 801d1c0:	db04      	blt.n	801d1cc <vfprintf+0x64>
 801d1c2:	68f8      	ldr	r0, [r7, #12]
 801d1c4:	f000 f88c 	bl	801d2e0 <__lockfile>
 801d1c8:	4603      	mov	r3, r0
 801d1ca:	e000      	b.n	801d1ce <vfprintf+0x66>
 801d1cc:	2300      	movs	r3, #0
 801d1ce:	623b      	str	r3, [r7, #32]
	olderr = f->flags & F_ERR;
 801d1d0:	68fb      	ldr	r3, [r7, #12]
 801d1d2:	681b      	ldr	r3, [r3, #0]
 801d1d4:	f003 0320 	and.w	r3, r3, #32
 801d1d8:	627b      	str	r3, [r7, #36]	; 0x24
	if (f->mode < 1) f->flags &= ~F_ERR;
 801d1da:	68fb      	ldr	r3, [r7, #12]
 801d1dc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801d1de:	2b00      	cmp	r3, #0
 801d1e0:	dc05      	bgt.n	801d1ee <vfprintf+0x86>
 801d1e2:	68fb      	ldr	r3, [r7, #12]
 801d1e4:	681b      	ldr	r3, [r3, #0]
 801d1e6:	f023 0220 	bic.w	r2, r3, #32
 801d1ea:	68fb      	ldr	r3, [r7, #12]
 801d1ec:	601a      	str	r2, [r3, #0]
	if (!f->buf_size) {
 801d1ee:	68fb      	ldr	r3, [r7, #12]
 801d1f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801d1f2:	2b00      	cmp	r3, #0
 801d1f4:	d114      	bne.n	801d220 <vfprintf+0xb8>
		saved_buf = f->buf;
 801d1f6:	68fb      	ldr	r3, [r7, #12]
 801d1f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801d1fa:	61bb      	str	r3, [r7, #24]
		f->buf = internal_buf;
 801d1fc:	68fb      	ldr	r3, [r7, #12]
 801d1fe:	f107 02a4 	add.w	r2, r7, #164	; 0xa4
 801d202:	631a      	str	r2, [r3, #48]	; 0x30
		f->buf_size = sizeof internal_buf;
 801d204:	68fb      	ldr	r3, [r7, #12]
 801d206:	2250      	movs	r2, #80	; 0x50
 801d208:	635a      	str	r2, [r3, #52]	; 0x34
		f->wpos = f->wbase = f->wend = 0;
 801d20a:	68fb      	ldr	r3, [r7, #12]
 801d20c:	2200      	movs	r2, #0
 801d20e:	611a      	str	r2, [r3, #16]
 801d210:	68fb      	ldr	r3, [r7, #12]
 801d212:	691a      	ldr	r2, [r3, #16]
 801d214:	68fb      	ldr	r3, [r7, #12]
 801d216:	61da      	str	r2, [r3, #28]
 801d218:	68fb      	ldr	r3, [r7, #12]
 801d21a:	69da      	ldr	r2, [r3, #28]
 801d21c:	68fb      	ldr	r3, [r7, #12]
 801d21e:	615a      	str	r2, [r3, #20]
	}
	if (!f->wend && __towrite(f)) ret = -1;
 801d220:	68fb      	ldr	r3, [r7, #12]
 801d222:	691b      	ldr	r3, [r3, #16]
 801d224:	2b00      	cmp	r3, #0
 801d226:	d109      	bne.n	801d23c <vfprintf+0xd4>
 801d228:	68f8      	ldr	r0, [r7, #12]
 801d22a:	f000 f87a 	bl	801d322 <__towrite>
 801d22e:	4603      	mov	r3, r0
 801d230:	2b00      	cmp	r3, #0
 801d232:	d003      	beq.n	801d23c <vfprintf+0xd4>
 801d234:	f04f 33ff 	mov.w	r3, #4294967295
 801d238:	61fb      	str	r3, [r7, #28]
 801d23a:	e00c      	b.n	801d256 <vfprintf+0xee>
	else ret = printf_core(f, fmt, &ap2, nl_arg, nl_type);
 801d23c:	f107 0150 	add.w	r1, r7, #80	; 0x50
 801d240:	f107 0214 	add.w	r2, r7, #20
 801d244:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801d248:	9300      	str	r3, [sp, #0]
 801d24a:	460b      	mov	r3, r1
 801d24c:	68b9      	ldr	r1, [r7, #8]
 801d24e:	68f8      	ldr	r0, [r7, #12]
 801d250:	f7ff fabc 	bl	801c7cc <printf_core>
 801d254:	61f8      	str	r0, [r7, #28]
	if (saved_buf) {
 801d256:	69bb      	ldr	r3, [r7, #24]
 801d258:	2b00      	cmp	r3, #0
 801d25a:	d01d      	beq.n	801d298 <vfprintf+0x130>
		f->write(f, 0, 0);
 801d25c:	68fb      	ldr	r3, [r7, #12]
 801d25e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801d260:	2200      	movs	r2, #0
 801d262:	2100      	movs	r1, #0
 801d264:	68f8      	ldr	r0, [r7, #12]
 801d266:	4798      	blx	r3
		if (!f->wpos) ret = -1;
 801d268:	68fb      	ldr	r3, [r7, #12]
 801d26a:	695b      	ldr	r3, [r3, #20]
 801d26c:	2b00      	cmp	r3, #0
 801d26e:	d102      	bne.n	801d276 <vfprintf+0x10e>
 801d270:	f04f 33ff 	mov.w	r3, #4294967295
 801d274:	61fb      	str	r3, [r7, #28]
		f->buf = saved_buf;
 801d276:	68fb      	ldr	r3, [r7, #12]
 801d278:	69ba      	ldr	r2, [r7, #24]
 801d27a:	631a      	str	r2, [r3, #48]	; 0x30
		f->buf_size = 0;
 801d27c:	68fb      	ldr	r3, [r7, #12]
 801d27e:	2200      	movs	r2, #0
 801d280:	635a      	str	r2, [r3, #52]	; 0x34
		f->wpos = f->wbase = f->wend = 0;
 801d282:	68fb      	ldr	r3, [r7, #12]
 801d284:	2200      	movs	r2, #0
 801d286:	611a      	str	r2, [r3, #16]
 801d288:	68fb      	ldr	r3, [r7, #12]
 801d28a:	691a      	ldr	r2, [r3, #16]
 801d28c:	68fb      	ldr	r3, [r7, #12]
 801d28e:	61da      	str	r2, [r3, #28]
 801d290:	68fb      	ldr	r3, [r7, #12]
 801d292:	69da      	ldr	r2, [r3, #28]
 801d294:	68fb      	ldr	r3, [r7, #12]
 801d296:	615a      	str	r2, [r3, #20]
	}
	if (f->flags & F_ERR) ret = -1;
 801d298:	68fb      	ldr	r3, [r7, #12]
 801d29a:	681b      	ldr	r3, [r3, #0]
 801d29c:	f003 0320 	and.w	r3, r3, #32
 801d2a0:	2b00      	cmp	r3, #0
 801d2a2:	d002      	beq.n	801d2aa <vfprintf+0x142>
 801d2a4:	f04f 33ff 	mov.w	r3, #4294967295
 801d2a8:	61fb      	str	r3, [r7, #28]
	f->flags |= olderr;
 801d2aa:	68fb      	ldr	r3, [r7, #12]
 801d2ac:	681a      	ldr	r2, [r3, #0]
 801d2ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d2b0:	431a      	orrs	r2, r3
 801d2b2:	68fb      	ldr	r3, [r7, #12]
 801d2b4:	601a      	str	r2, [r3, #0]
	FUNLOCK(f);
 801d2b6:	6a3b      	ldr	r3, [r7, #32]
 801d2b8:	2b00      	cmp	r3, #0
 801d2ba:	d002      	beq.n	801d2c2 <vfprintf+0x15a>
 801d2bc:	68f8      	ldr	r0, [r7, #12]
 801d2be:	f000 f820 	bl	801d302 <__unlockfile>
	va_end(ap2);
	return ret;
 801d2c2:	69fb      	ldr	r3, [r7, #28]
}
 801d2c4:	4a05      	ldr	r2, [pc, #20]	; (801d2dc <vfprintf+0x174>)
 801d2c6:	6811      	ldr	r1, [r2, #0]
 801d2c8:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 801d2cc:	4051      	eors	r1, r2
 801d2ce:	d001      	beq.n	801d2d4 <vfprintf+0x16c>
 801d2d0:	f7e7 f984 	bl	80045dc <__stack_chk_fail>
 801d2d4:	4618      	mov	r0, r3
 801d2d6:	37f8      	adds	r7, #248	; 0xf8
 801d2d8:	46bd      	mov	sp, r7
 801d2da:	bd80      	pop	{r7, pc}
 801d2dc:	080231ac 	.word	0x080231ac

0801d2e0 <__lockfile>:
#include "stdio_impl.h"
#include "pthread_impl.h"

int __lockfile(FILE *f)
{
 801d2e0:	b580      	push	{r7, lr}
 801d2e2:	b082      	sub	sp, #8
 801d2e4:	af00      	add	r7, sp, #0
 801d2e6:	6078      	str	r0, [r7, #4]
		    a_cas(&f->lock, owner, owner|MAYBE_WAITERS)==owner)
			__futexwait(&f->lock, owner|MAYBE_WAITERS, 1);
	}
	return 1;
#else
	if (f != NULL) {
 801d2e8:	687b      	ldr	r3, [r7, #4]
 801d2ea:	2b00      	cmp	r3, #0
 801d2ec:	d004      	beq.n	801d2f8 <__lockfile+0x18>
		pthread_mutex_lock(&(f->_lock));
 801d2ee:	687b      	ldr	r3, [r7, #4]
 801d2f0:	3380      	adds	r3, #128	; 0x80
 801d2f2:	4618      	mov	r0, r3
 801d2f4:	f002 f92f 	bl	801f556 <pthread_mutex_lock>
	}
	return 1;
 801d2f8:	2301      	movs	r3, #1
#endif
}
 801d2fa:	4618      	mov	r0, r3
 801d2fc:	3708      	adds	r7, #8
 801d2fe:	46bd      	mov	sp, r7
 801d300:	bd80      	pop	{r7, pc}

0801d302 <__unlockfile>:

void __unlockfile(FILE *f)
{
 801d302:	b580      	push	{r7, lr}
 801d304:	b082      	sub	sp, #8
 801d306:	af00      	add	r7, sp, #0
 801d308:	6078      	str	r0, [r7, #4]
#ifndef __LITEOS__
	if (a_swap(&f->lock, 0) & MAYBE_WAITERS)
		__wake(&f->lock, 1, 1);
#else
	if (f != NULL) {
 801d30a:	687b      	ldr	r3, [r7, #4]
 801d30c:	2b00      	cmp	r3, #0
 801d30e:	d004      	beq.n	801d31a <__unlockfile+0x18>
		pthread_mutex_unlock(&(f->_lock));
 801d310:	687b      	ldr	r3, [r7, #4]
 801d312:	3380      	adds	r3, #128	; 0x80
 801d314:	4618      	mov	r0, r3
 801d316:	f002 f953 	bl	801f5c0 <pthread_mutex_unlock>
	}
#endif
}
 801d31a:	bf00      	nop
 801d31c:	3708      	adds	r7, #8
 801d31e:	46bd      	mov	sp, r7
 801d320:	bd80      	pop	{r7, pc}

0801d322 <__towrite>:
#include "stdio_impl.h"

int __towrite(FILE *f)
{
 801d322:	b480      	push	{r7}
 801d324:	b083      	sub	sp, #12
 801d326:	af00      	add	r7, sp, #0
 801d328:	6078      	str	r0, [r7, #4]
	f->mode |= f->mode-1;
 801d32a:	687b      	ldr	r3, [r7, #4]
 801d32c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801d32e:	687b      	ldr	r3, [r7, #4]
 801d330:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801d332:	3b01      	subs	r3, #1
 801d334:	431a      	orrs	r2, r3
 801d336:	687b      	ldr	r3, [r7, #4]
 801d338:	64da      	str	r2, [r3, #76]	; 0x4c
	if (f->flags & F_NOWR) {
 801d33a:	687b      	ldr	r3, [r7, #4]
 801d33c:	681b      	ldr	r3, [r3, #0]
 801d33e:	f003 0308 	and.w	r3, r3, #8
 801d342:	2b00      	cmp	r3, #0
 801d344:	d008      	beq.n	801d358 <__towrite+0x36>
		f->flags |= F_ERR;
 801d346:	687b      	ldr	r3, [r7, #4]
 801d348:	681b      	ldr	r3, [r3, #0]
 801d34a:	f043 0220 	orr.w	r2, r3, #32
 801d34e:	687b      	ldr	r3, [r7, #4]
 801d350:	601a      	str	r2, [r3, #0]
		return EOF;
 801d352:	f04f 33ff 	mov.w	r3, #4294967295
 801d356:	e01f      	b.n	801d398 <__towrite+0x76>
	}
#ifdef __LITEOS__
	if (f->flags & F_CLS) {
 801d358:	687b      	ldr	r3, [r7, #4]
 801d35a:	681b      	ldr	r3, [r3, #0]
 801d35c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801d360:	2b00      	cmp	r3, #0
 801d362:	d002      	beq.n	801d36a <__towrite+0x48>
		return EOF;
 801d364:	f04f 33ff 	mov.w	r3, #4294967295
 801d368:	e016      	b.n	801d398 <__towrite+0x76>
	}
#endif
	/* Clear read buffer (easier than summoning nasal demons) */
	f->rpos = f->rend = 0;
 801d36a:	687b      	ldr	r3, [r7, #4]
 801d36c:	2200      	movs	r2, #0
 801d36e:	609a      	str	r2, [r3, #8]
 801d370:	687b      	ldr	r3, [r7, #4]
 801d372:	689a      	ldr	r2, [r3, #8]
 801d374:	687b      	ldr	r3, [r7, #4]
 801d376:	605a      	str	r2, [r3, #4]

	/* Activate write through the buffer. */
	f->wpos = f->wbase = f->buf;
 801d378:	687b      	ldr	r3, [r7, #4]
 801d37a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801d37c:	687b      	ldr	r3, [r7, #4]
 801d37e:	61da      	str	r2, [r3, #28]
 801d380:	687b      	ldr	r3, [r7, #4]
 801d382:	69da      	ldr	r2, [r3, #28]
 801d384:	687b      	ldr	r3, [r7, #4]
 801d386:	615a      	str	r2, [r3, #20]
	f->wend = f->buf + f->buf_size;
 801d388:	687b      	ldr	r3, [r7, #4]
 801d38a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801d38c:	687b      	ldr	r3, [r7, #4]
 801d38e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801d390:	441a      	add	r2, r3
 801d392:	687b      	ldr	r3, [r7, #4]
 801d394:	611a      	str	r2, [r3, #16]

	return 0;
 801d396:	2300      	movs	r3, #0
}
 801d398:	4618      	mov	r0, r3
 801d39a:	370c      	adds	r7, #12
 801d39c:	46bd      	mov	sp, r7
 801d39e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d3a2:	4770      	bx	lr

0801d3a4 <__fwritex>:
#if defined(__LITEOS__) && defined(LOSCFG_LLTSER)
#include "gcov_ser.h"
#endif

size_t __fwritex(const unsigned char * restrict s, size_t l, FILE * restrict f)
{
 801d3a4:	b580      	push	{r7, lr}
 801d3a6:	b086      	sub	sp, #24
 801d3a8:	af00      	add	r7, sp, #0
 801d3aa:	60f8      	str	r0, [r7, #12]
 801d3ac:	60b9      	str	r1, [r7, #8]
 801d3ae:	607a      	str	r2, [r7, #4]
	size_t i = 0;
 801d3b0:	2300      	movs	r3, #0
 801d3b2:	613b      	str	r3, [r7, #16]

	if (!f->wend && __towrite(f)) {
 801d3b4:	687b      	ldr	r3, [r7, #4]
 801d3b6:	691b      	ldr	r3, [r3, #16]
 801d3b8:	2b00      	cmp	r3, #0
 801d3ba:	d107      	bne.n	801d3cc <__fwritex+0x28>
 801d3bc:	6878      	ldr	r0, [r7, #4]
 801d3be:	f7ff ffb0 	bl	801d322 <__towrite>
 801d3c2:	4603      	mov	r3, r0
 801d3c4:	2b00      	cmp	r3, #0
 801d3c6:	d001      	beq.n	801d3cc <__fwritex+0x28>
		return 0;
 801d3c8:	2300      	movs	r3, #0
 801d3ca:	e04c      	b.n	801d466 <__fwritex+0xc2>
	}

	if (l > f->wend - f->wpos) {
 801d3cc:	687b      	ldr	r3, [r7, #4]
 801d3ce:	691a      	ldr	r2, [r3, #16]
 801d3d0:	687b      	ldr	r3, [r7, #4]
 801d3d2:	695b      	ldr	r3, [r3, #20]
 801d3d4:	1ad3      	subs	r3, r2, r3
 801d3d6:	461a      	mov	r2, r3
 801d3d8:	68bb      	ldr	r3, [r7, #8]
 801d3da:	4293      	cmp	r3, r2
 801d3dc:	d907      	bls.n	801d3ee <__fwritex+0x4a>
		return f->write(f, s, l);
 801d3de:	687b      	ldr	r3, [r7, #4]
 801d3e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801d3e2:	68ba      	ldr	r2, [r7, #8]
 801d3e4:	68f9      	ldr	r1, [r7, #12]
 801d3e6:	6878      	ldr	r0, [r7, #4]
 801d3e8:	4798      	blx	r3
 801d3ea:	4603      	mov	r3, r0
 801d3ec:	e03b      	b.n	801d466 <__fwritex+0xc2>
	}

	if (f->lbf >= 0) {
 801d3ee:	687b      	ldr	r3, [r7, #4]
 801d3f0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801d3f2:	2b00      	cmp	r3, #0
 801d3f4:	db27      	blt.n	801d446 <__fwritex+0xa2>
		/* Match /^(.*\n|)/ */
		for (i = l; i && s[i - 1] != '\n'; i--);
 801d3f6:	68bb      	ldr	r3, [r7, #8]
 801d3f8:	613b      	str	r3, [r7, #16]
 801d3fa:	e002      	b.n	801d402 <__fwritex+0x5e>
 801d3fc:	693b      	ldr	r3, [r7, #16]
 801d3fe:	3b01      	subs	r3, #1
 801d400:	613b      	str	r3, [r7, #16]
 801d402:	693b      	ldr	r3, [r7, #16]
 801d404:	2b00      	cmp	r3, #0
 801d406:	d006      	beq.n	801d416 <__fwritex+0x72>
 801d408:	693b      	ldr	r3, [r7, #16]
 801d40a:	3b01      	subs	r3, #1
 801d40c:	68fa      	ldr	r2, [r7, #12]
 801d40e:	4413      	add	r3, r2
 801d410:	781b      	ldrb	r3, [r3, #0]
 801d412:	2b0a      	cmp	r3, #10
 801d414:	d1f2      	bne.n	801d3fc <__fwritex+0x58>
		if (i) {
 801d416:	693b      	ldr	r3, [r7, #16]
 801d418:	2b00      	cmp	r3, #0
 801d41a:	d014      	beq.n	801d446 <__fwritex+0xa2>
			size_t n = f->write(f, s, i);
 801d41c:	687b      	ldr	r3, [r7, #4]
 801d41e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801d420:	693a      	ldr	r2, [r7, #16]
 801d422:	68f9      	ldr	r1, [r7, #12]
 801d424:	6878      	ldr	r0, [r7, #4]
 801d426:	4798      	blx	r3
 801d428:	6178      	str	r0, [r7, #20]
			if (n < i) {
 801d42a:	697a      	ldr	r2, [r7, #20]
 801d42c:	693b      	ldr	r3, [r7, #16]
 801d42e:	429a      	cmp	r2, r3
 801d430:	d201      	bcs.n	801d436 <__fwritex+0x92>
				return n;
 801d432:	697b      	ldr	r3, [r7, #20]
 801d434:	e017      	b.n	801d466 <__fwritex+0xc2>
			}
			s += i;
 801d436:	68fa      	ldr	r2, [r7, #12]
 801d438:	693b      	ldr	r3, [r7, #16]
 801d43a:	4413      	add	r3, r2
 801d43c:	60fb      	str	r3, [r7, #12]
			l -= i;
 801d43e:	68ba      	ldr	r2, [r7, #8]
 801d440:	693b      	ldr	r3, [r7, #16]
 801d442:	1ad3      	subs	r3, r2, r3
 801d444:	60bb      	str	r3, [r7, #8]
		}
	}

	memcpy(f->wpos, s, l);
 801d446:	687b      	ldr	r3, [r7, #4]
 801d448:	695b      	ldr	r3, [r3, #20]
 801d44a:	68ba      	ldr	r2, [r7, #8]
 801d44c:	68f9      	ldr	r1, [r7, #12]
 801d44e:	4618      	mov	r0, r3
 801d450:	f7fb fe54 	bl	80190fc <memcpy>
	f->wpos += l;
 801d454:	687b      	ldr	r3, [r7, #4]
 801d456:	695a      	ldr	r2, [r3, #20]
 801d458:	68bb      	ldr	r3, [r7, #8]
 801d45a:	441a      	add	r2, r3
 801d45c:	687b      	ldr	r3, [r7, #4]
 801d45e:	615a      	str	r2, [r3, #20]
	return l + i;
 801d460:	68ba      	ldr	r2, [r7, #8]
 801d462:	693b      	ldr	r3, [r7, #16]
 801d464:	4413      	add	r3, r2
}
 801d466:	4618      	mov	r0, r3
 801d468:	3718      	adds	r7, #24
 801d46a:	46bd      	mov	sp, r7
 801d46c:	bd80      	pop	{r7, pc}

0801d46e <LOS_IntLock>:
{
 801d46e:	b580      	push	{r7, lr}
 801d470:	af00      	add	r7, sp, #0
    return ArchIntLock();
 801d472:	f7e3 fc29 	bl	8000cc8 <ArchIntLock>
 801d476:	4603      	mov	r3, r0
}
 801d478:	4618      	mov	r0, r3
 801d47a:	bd80      	pop	{r7, pc}

0801d47c <LOS_IntRestore>:
{
 801d47c:	b580      	push	{r7, lr}
 801d47e:	b082      	sub	sp, #8
 801d480:	af00      	add	r7, sp, #0
 801d482:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 801d484:	6878      	ldr	r0, [r7, #4]
 801d486:	f7e3 fc27 	bl	8000cd8 <ArchIntRestore>
}
 801d48a:	bf00      	nop
 801d48c:	3708      	adds	r7, #8
 801d48e:	46bd      	mov	sp, r7
 801d490:	bd80      	pop	{r7, pc}

0801d492 <LOS_SpinLockSave>:
{
 801d492:	b580      	push	{r7, lr}
 801d494:	b082      	sub	sp, #8
 801d496:	af00      	add	r7, sp, #0
 801d498:	6078      	str	r0, [r7, #4]
 801d49a:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 801d49c:	f7ff ffe7 	bl	801d46e <LOS_IntLock>
 801d4a0:	4602      	mov	r2, r0
 801d4a2:	683b      	ldr	r3, [r7, #0]
 801d4a4:	601a      	str	r2, [r3, #0]
}
 801d4a6:	bf00      	nop
 801d4a8:	3708      	adds	r7, #8
 801d4aa:	46bd      	mov	sp, r7
 801d4ac:	bd80      	pop	{r7, pc}

0801d4ae <LOS_SpinUnlockRestore>:
{
 801d4ae:	b580      	push	{r7, lr}
 801d4b0:	b082      	sub	sp, #8
 801d4b2:	af00      	add	r7, sp, #0
 801d4b4:	6078      	str	r0, [r7, #4]
 801d4b6:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 801d4b8:	6838      	ldr	r0, [r7, #0]
 801d4ba:	f7ff ffdf 	bl	801d47c <LOS_IntRestore>
}
 801d4be:	bf00      	nop
 801d4c0:	3708      	adds	r7, #8
 801d4c2:	46bd      	mov	sp, r7
 801d4c4:	bd80      	pop	{r7, pc}
	...

0801d4c8 <ValidTimeval64>:
    return TRUE;
}

#ifndef LOSCFG_AARCH64
STATIC INLINE BOOL ValidTimeval64(const struct timeval64 *tv)
{
 801d4c8:	b480      	push	{r7}
 801d4ca:	b083      	sub	sp, #12
 801d4cc:	af00      	add	r7, sp, #0
 801d4ce:	6078      	str	r0, [r7, #4]
    /* Fail a NULL pointer */
    if (tv == NULL) {
 801d4d0:	687b      	ldr	r3, [r7, #4]
 801d4d2:	2b00      	cmp	r3, #0
 801d4d4:	d101      	bne.n	801d4da <ValidTimeval64+0x12>
        return FALSE;
 801d4d6:	2300      	movs	r3, #0
 801d4d8:	e01a      	b.n	801d510 <ValidTimeval64+0x48>
    }

    /* Fail illegal microseconds values */
    if ((tv->tv_usec < 0) || (tv->tv_usec >= OS_SYS_US_PER_SECOND) || (tv->tv_sec < 0)) {
 801d4da:	687b      	ldr	r3, [r7, #4]
 801d4dc:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 801d4e0:	2a00      	cmp	r2, #0
 801d4e2:	f173 0300 	sbcs.w	r3, r3, #0
 801d4e6:	db10      	blt.n	801d50a <ValidTimeval64+0x42>
 801d4e8:	687b      	ldr	r3, [r7, #4]
 801d4ea:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 801d4ee:	480b      	ldr	r0, [pc, #44]	; (801d51c <ValidTimeval64+0x54>)
 801d4f0:	f04f 0100 	mov.w	r1, #0
 801d4f4:	4290      	cmp	r0, r2
 801d4f6:	eb71 0303 	sbcs.w	r3, r1, r3
 801d4fa:	db06      	blt.n	801d50a <ValidTimeval64+0x42>
 801d4fc:	687b      	ldr	r3, [r7, #4]
 801d4fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d502:	2a00      	cmp	r2, #0
 801d504:	f173 0300 	sbcs.w	r3, r3, #0
 801d508:	da01      	bge.n	801d50e <ValidTimeval64+0x46>
        return FALSE;
 801d50a:	2300      	movs	r3, #0
 801d50c:	e000      	b.n	801d510 <ValidTimeval64+0x48>
    }

    return TRUE;
 801d50e:	2301      	movs	r3, #1
}
 801d510:	4618      	mov	r0, r3
 801d512:	370c      	adds	r7, #12
 801d514:	46bd      	mov	sp, r7
 801d516:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d51a:	4770      	bx	lr
 801d51c:	000f423f 	.word	0x000f423f

0801d520 <OsTimeSpecAdd>:
    LOS_SpinUnlockRestore(&g_timeSpin, intSave);
    return 0;
}

STATIC INLINE struct timespec64 OsTimeSpecAdd(const struct timespec64 t1, const struct timespec64 t2)
{
 801d520:	b082      	sub	sp, #8
 801d522:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 801d526:	b08d      	sub	sp, #52	; 0x34
 801d528:	af00      	add	r7, sp, #0
 801d52a:	61f8      	str	r0, [r7, #28]
 801d52c:	f107 0150 	add.w	r1, r7, #80	; 0x50
 801d530:	e881 000c 	stmia.w	r1, {r2, r3}
    struct timespec64 ret = {0};
 801d534:	f107 0320 	add.w	r3, r7, #32
 801d538:	2200      	movs	r2, #0
 801d53a:	601a      	str	r2, [r3, #0]
 801d53c:	605a      	str	r2, [r3, #4]
 801d53e:	609a      	str	r2, [r3, #8]
 801d540:	60da      	str	r2, [r3, #12]

    ret.tv_sec = t1.tv_sec + t2.tv_sec;
 801d542:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 801d546:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	; 0x60
 801d54a:	1884      	adds	r4, r0, r2
 801d54c:	eb41 0503 	adc.w	r5, r1, r3
 801d550:	e9c7 4508 	strd	r4, r5, [r7, #32]
    ret.tv_nsec = t1.tv_nsec + t2.tv_nsec;
 801d554:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	; 0x58
 801d558:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	; 0x68
 801d55c:	1884      	adds	r4, r0, r2
 801d55e:	613c      	str	r4, [r7, #16]
 801d560:	eb41 0303 	adc.w	r3, r1, r3
 801d564:	617b      	str	r3, [r7, #20]
 801d566:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 801d56a:	e9c7 340a 	strd	r3, r4, [r7, #40]	; 0x28
    if (ret.tv_nsec >= OS_SYS_NS_PER_SECOND) {
 801d56e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d572:	a123      	add	r1, pc, #140	; (adr r1, 801d600 <OsTimeSpecAdd+0xe0>)
 801d574:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d578:	4290      	cmp	r0, r2
 801d57a:	eb71 0303 	sbcs.w	r3, r1, r3
 801d57e:	da18      	bge.n	801d5b2 <OsTimeSpecAdd+0x92>
        ret.tv_sec += 1;
 801d580:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801d584:	1c51      	adds	r1, r2, #1
 801d586:	60b9      	str	r1, [r7, #8]
 801d588:	f143 0300 	adc.w	r3, r3, #0
 801d58c:	60fb      	str	r3, [r7, #12]
 801d58e:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 801d592:	e9c7 3408 	strd	r3, r4, [r7, #32]
        ret.tv_nsec -= OS_SYS_NS_PER_SECOND;
 801d596:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d59a:	a11b      	add	r1, pc, #108	; (adr r1, 801d608 <OsTimeSpecAdd+0xe8>)
 801d59c:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d5a0:	1814      	adds	r4, r2, r0
 801d5a2:	603c      	str	r4, [r7, #0]
 801d5a4:	414b      	adcs	r3, r1
 801d5a6:	607b      	str	r3, [r7, #4]
 801d5a8:	e9d7 3400 	ldrd	r3, r4, [r7]
 801d5ac:	e9c7 340a 	strd	r3, r4, [r7, #40]	; 0x28
 801d5b0:	e018      	b.n	801d5e4 <OsTimeSpecAdd+0xc4>
    } else if (ret.tv_nsec < 0L) {
 801d5b2:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d5b6:	2a00      	cmp	r2, #0
 801d5b8:	f173 0300 	sbcs.w	r3, r3, #0
 801d5bc:	da12      	bge.n	801d5e4 <OsTimeSpecAdd+0xc4>
        ret.tv_sec -= 1;
 801d5be:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801d5c2:	f112 3aff 	adds.w	sl, r2, #4294967295
 801d5c6:	f143 3bff 	adc.w	fp, r3, #4294967295
 801d5ca:	e9c7 ab08 	strd	sl, fp, [r7, #32]
        ret.tv_nsec += OS_SYS_NS_PER_SECOND;
 801d5ce:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d5d2:	a10f      	add	r1, pc, #60	; (adr r1, 801d610 <OsTimeSpecAdd+0xf0>)
 801d5d4:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d5d8:	eb12 0800 	adds.w	r8, r2, r0
 801d5dc:	eb43 0901 	adc.w	r9, r3, r1
 801d5e0:	e9c7 890a 	strd	r8, r9, [r7, #40]	; 0x28
    }

    return ret;
 801d5e4:	69fb      	ldr	r3, [r7, #28]
 801d5e6:	461c      	mov	r4, r3
 801d5e8:	f107 0320 	add.w	r3, r7, #32
 801d5ec:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d5ee:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 801d5f2:	69f8      	ldr	r0, [r7, #28]
 801d5f4:	3734      	adds	r7, #52	; 0x34
 801d5f6:	46bd      	mov	sp, r7
 801d5f8:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 801d5fc:	b002      	add	sp, #8
 801d5fe:	4770      	bx	lr
 801d600:	3b9ac9ff 	.word	0x3b9ac9ff
 801d604:	00000000 	.word	0x00000000
 801d608:	c4653600 	.word	0xc4653600
 801d60c:	ffffffff 	.word	0xffffffff
 801d610:	3b9aca00 	.word	0x3b9aca00
 801d614:	00000000 	.word	0x00000000

0801d618 <OsTimeSpecSub>:

STATIC INLINE struct timespec64 OsTimeSpecSub(const struct timespec64 t1, const struct timespec64 t2)
{
 801d618:	b082      	sub	sp, #8
 801d61a:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801d61e:	b088      	sub	sp, #32
 801d620:	af00      	add	r7, sp, #0
 801d622:	60f8      	str	r0, [r7, #12]
 801d624:	f107 0140 	add.w	r1, r7, #64	; 0x40
 801d628:	e881 000c 	stmia.w	r1, {r2, r3}
    struct timespec64 ret = {0};
 801d62c:	f107 0310 	add.w	r3, r7, #16
 801d630:	2200      	movs	r2, #0
 801d632:	601a      	str	r2, [r3, #0]
 801d634:	605a      	str	r2, [r3, #4]
 801d636:	609a      	str	r2, [r3, #8]
 801d638:	60da      	str	r2, [r3, #12]

    ret.tv_sec = t1.tv_sec - t2.tv_sec;
 801d63a:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
 801d63e:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 801d642:	1a86      	subs	r6, r0, r2
 801d644:	603e      	str	r6, [r7, #0]
 801d646:	eb61 0303 	sbc.w	r3, r1, r3
 801d64a:	607b      	str	r3, [r7, #4]
 801d64c:	e9d7 2300 	ldrd	r2, r3, [r7]
 801d650:	e9c7 2304 	strd	r2, r3, [r7, #16]
    ret.tv_nsec = t1.tv_nsec - t2.tv_nsec;
 801d654:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
 801d658:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 801d65c:	ebb0 0a02 	subs.w	sl, r0, r2
 801d660:	eb61 0b03 	sbc.w	fp, r1, r3
 801d664:	e9c7 ab06 	strd	sl, fp, [r7, #24]
    if (ret.tv_nsec < 0) {
 801d668:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801d66c:	2a00      	cmp	r2, #0
 801d66e:	f173 0300 	sbcs.w	r3, r3, #0
 801d672:	da11      	bge.n	801d698 <OsTimeSpecSub+0x80>
        ret.tv_sec -= 1;
 801d674:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801d678:	f112 38ff 	adds.w	r8, r2, #4294967295
 801d67c:	f143 39ff 	adc.w	r9, r3, #4294967295
 801d680:	e9c7 8904 	strd	r8, r9, [r7, #16]
        ret.tv_nsec += OS_SYS_NS_PER_SECOND;
 801d684:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801d688:	a10b      	add	r1, pc, #44	; (adr r1, 801d6b8 <OsTimeSpecSub+0xa0>)
 801d68a:	e9d1 0100 	ldrd	r0, r1, [r1]
 801d68e:	1814      	adds	r4, r2, r0
 801d690:	eb43 0501 	adc.w	r5, r3, r1
 801d694:	e9c7 4506 	strd	r4, r5, [r7, #24]
    }

    return ret;
 801d698:	68fb      	ldr	r3, [r7, #12]
 801d69a:	461c      	mov	r4, r3
 801d69c:	f107 0310 	add.w	r3, r7, #16
 801d6a0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d6a2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 801d6a6:	68f8      	ldr	r0, [r7, #12]
 801d6a8:	3720      	adds	r7, #32
 801d6aa:	46bd      	mov	sp, r7
 801d6ac:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801d6b0:	b002      	add	sp, #8
 801d6b2:	4770      	bx	lr
 801d6b4:	f3af 8000 	nop.w
 801d6b8:	3b9aca00 	.word	0x3b9aca00
 801d6bc:	00000000 	.word	0x00000000

0801d6c0 <OsSetTimeOfDay>:

STATIC INT32 OsSetTimeOfDay(const struct timeval64 *tv, const struct timezone *tz)
{
 801d6c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801d6c4:	b0a5      	sub	sp, #148	; 0x94
 801d6c6:	af06      	add	r7, sp, #24
 801d6c8:	61f8      	str	r0, [r7, #28]
 801d6ca:	61b9      	str	r1, [r7, #24]
 801d6cc:	4b82      	ldr	r3, [pc, #520]	; (801d8d8 <OsSetTimeOfDay+0x218>)
 801d6ce:	681b      	ldr	r3, [r3, #0]
 801d6d0:	677b      	str	r3, [r7, #116]	; 0x74
 801d6d2:	f04f 0300 	mov.w	r3, #0
    UINT64 nowNsec;
    UINT32 intSave;
    struct timespec64 setTime = {0};
 801d6d6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801d6da:	2200      	movs	r2, #0
 801d6dc:	601a      	str	r2, [r3, #0]
 801d6de:	605a      	str	r2, [r3, #4]
 801d6e0:	609a      	str	r2, [r3, #8]
 801d6e2:	60da      	str	r2, [r3, #12]
    struct timespec64 hwTime = {0};
 801d6e4:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801d6e8:	2200      	movs	r2, #0
 801d6ea:	601a      	str	r2, [r3, #0]
 801d6ec:	605a      	str	r2, [r3, #4]
 801d6ee:	609a      	str	r2, [r3, #8]
 801d6f0:	60da      	str	r2, [r3, #12]
    struct timespec64 realTime = {0};
 801d6f2:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801d6f6:	2200      	movs	r2, #0
 801d6f8:	601a      	str	r2, [r3, #0]
 801d6fa:	605a      	str	r2, [r3, #4]
 801d6fc:	609a      	str	r2, [r3, #8]
 801d6fe:	60da      	str	r2, [r3, #12]
    struct timespec64 tmp = {0};
 801d700:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801d704:	2200      	movs	r2, #0
 801d706:	601a      	str	r2, [r3, #0]
 801d708:	605a      	str	r2, [r3, #4]
 801d70a:	609a      	str	r2, [r3, #8]
 801d70c:	60da      	str	r2, [r3, #12]

    (VOID)tz;
    nowNsec = LOS_CurrNanosec();
 801d70e:	f7e6 fe7b 	bl	8004408 <LOS_CurrNanosec>
 801d712:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
    setTime.tv_sec = tv->tv_sec;
 801d716:	69fb      	ldr	r3, [r7, #28]
 801d718:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d71c:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
    setTime.tv_nsec = tv->tv_usec * OS_SYS_NS_PER_US;
 801d720:	69fb      	ldr	r3, [r7, #28]
 801d722:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 801d726:	4602      	mov	r2, r0
 801d728:	460b      	mov	r3, r1
 801d72a:	f04f 0400 	mov.w	r4, #0
 801d72e:	f04f 0500 	mov.w	r5, #0
 801d732:	015d      	lsls	r5, r3, #5
 801d734:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 801d738:	0154      	lsls	r4, r2, #5
 801d73a:	4622      	mov	r2, r4
 801d73c:	462b      	mov	r3, r5
 801d73e:	1a12      	subs	r2, r2, r0
 801d740:	eb63 0301 	sbc.w	r3, r3, r1
 801d744:	f04f 0400 	mov.w	r4, #0
 801d748:	f04f 0500 	mov.w	r5, #0
 801d74c:	009d      	lsls	r5, r3, #2
 801d74e:	ea45 7592 	orr.w	r5, r5, r2, lsr #30
 801d752:	0094      	lsls	r4, r2, #2
 801d754:	4622      	mov	r2, r4
 801d756:	462b      	mov	r3, r5
 801d758:	1812      	adds	r2, r2, r0
 801d75a:	eb41 0303 	adc.w	r3, r1, r3
 801d75e:	f04f 0000 	mov.w	r0, #0
 801d762:	f04f 0100 	mov.w	r1, #0
 801d766:	00d9      	lsls	r1, r3, #3
 801d768:	ea41 7152 	orr.w	r1, r1, r2, lsr #29
 801d76c:	00d0      	lsls	r0, r2, #3
 801d76e:	4602      	mov	r2, r0
 801d770:	460b      	mov	r3, r1
 801d772:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
    hwTime.tv_sec = nowNsec / OS_SYS_NS_PER_SECOND;
 801d776:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 801d77a:	a355      	add	r3, pc, #340	; (adr r3, 801d8d0 <OsSetTimeOfDay+0x210>)
 801d77c:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d780:	f7e3 f908 	bl	8000994 <__aeabi_uldivmod>
 801d784:	4602      	mov	r2, r0
 801d786:	460b      	mov	r3, r1
 801d788:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40
    hwTime.tv_nsec = (INT64)(nowNsec -  hwTime.tv_sec * OS_SYS_NS_PER_SECOND);
 801d78c:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 801d790:	4952      	ldr	r1, [pc, #328]	; (801d8dc <OsSetTimeOfDay+0x21c>)
 801d792:	fb01 f003 	mul.w	r0, r1, r3
 801d796:	2100      	movs	r1, #0
 801d798:	fb01 f102 	mul.w	r1, r1, r2
 801d79c:	4401      	add	r1, r0
 801d79e:	484f      	ldr	r0, [pc, #316]	; (801d8dc <OsSetTimeOfDay+0x21c>)
 801d7a0:	fba2 2300 	umull	r2, r3, r2, r0
 801d7a4:	4419      	add	r1, r3
 801d7a6:	460b      	mov	r3, r1
 801d7a8:	4610      	mov	r0, r2
 801d7aa:	4619      	mov	r1, r3
 801d7ac:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d7b0:	ebb2 0800 	subs.w	r8, r2, r0
 801d7b4:	eb63 0901 	sbc.w	r9, r3, r1
 801d7b8:	4642      	mov	r2, r8
 801d7ba:	464b      	mov	r3, r9
 801d7bc:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48

    LOS_SpinLockSave(&g_timeSpin, &intSave);
 801d7c0:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801d7c4:	4619      	mov	r1, r3
 801d7c6:	4846      	ldr	r0, [pc, #280]	; (801d8e0 <OsSetTimeOfDay+0x220>)
 801d7c8:	f7ff fe63 	bl	801d492 <LOS_SpinLockSave>
    /* stop on-going continuous adjusement */
    if (g_adjTimeLeft) {
 801d7cc:	4b45      	ldr	r3, [pc, #276]	; (801d8e4 <OsSetTimeOfDay+0x224>)
 801d7ce:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d7d2:	4313      	orrs	r3, r2
 801d7d4:	d006      	beq.n	801d7e4 <OsSetTimeOfDay+0x124>
        g_adjTimeLeft = 0;
 801d7d6:	4943      	ldr	r1, [pc, #268]	; (801d8e4 <OsSetTimeOfDay+0x224>)
 801d7d8:	f04f 0200 	mov.w	r2, #0
 801d7dc:	f04f 0300 	mov.w	r3, #0
 801d7e0:	e9c1 2300 	strd	r2, r3, [r1]
    }
    realTime = OsTimeSpecAdd(hwTime, g_accDeltaFromAdj);
 801d7e4:	f107 0550 	add.w	r5, r7, #80	; 0x50
 801d7e8:	4b3f      	ldr	r3, [pc, #252]	; (801d8e8 <OsSetTimeOfDay+0x228>)
 801d7ea:	ac02      	add	r4, sp, #8
 801d7ec:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d7ee:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d7f2:	466a      	mov	r2, sp
 801d7f4:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801d7f8:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d7fc:	e882 0003 	stmia.w	r2, {r0, r1}
 801d800:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801d804:	cb0c      	ldmia	r3, {r2, r3}
 801d806:	4628      	mov	r0, r5
 801d808:	f7ff fe8a 	bl	801d520 <OsTimeSpecAdd>
    realTime = OsTimeSpecAdd(realTime, g_accDeltaFromSet);
 801d80c:	f107 0508 	add.w	r5, r7, #8
 801d810:	4b36      	ldr	r3, [pc, #216]	; (801d8ec <OsSetTimeOfDay+0x22c>)
 801d812:	ac02      	add	r4, sp, #8
 801d814:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d816:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d81a:	466a      	mov	r2, sp
 801d81c:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801d820:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d824:	e882 0003 	stmia.w	r2, {r0, r1}
 801d828:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801d82c:	cb0c      	ldmia	r3, {r2, r3}
 801d82e:	4628      	mov	r0, r5
 801d830:	f7ff fe76 	bl	801d520 <OsTimeSpecAdd>
 801d834:	f107 0450 	add.w	r4, r7, #80	; 0x50
 801d838:	f107 0308 	add.w	r3, r7, #8
 801d83c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d83e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    tmp = OsTimeSpecSub(setTime, realTime);
 801d842:	f107 0560 	add.w	r5, r7, #96	; 0x60
 801d846:	ac02      	add	r4, sp, #8
 801d848:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801d84c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d84e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d852:	466a      	mov	r2, sp
 801d854:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801d858:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d85c:	e882 0003 	stmia.w	r2, {r0, r1}
 801d860:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801d864:	cb0c      	ldmia	r3, {r2, r3}
 801d866:	4628      	mov	r0, r5
 801d868:	f7ff fed6 	bl	801d618 <OsTimeSpecSub>
    g_accDeltaFromSet = OsTimeSpecAdd(g_accDeltaFromSet, tmp);
 801d86c:	4b1f      	ldr	r3, [pc, #124]	; (801d8ec <OsSetTimeOfDay+0x22c>)
 801d86e:	607b      	str	r3, [r7, #4]
 801d870:	f107 0608 	add.w	r6, r7, #8
 801d874:	4c1d      	ldr	r4, [pc, #116]	; (801d8ec <OsSetTimeOfDay+0x22c>)
 801d876:	ad02      	add	r5, sp, #8
 801d878:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801d87c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d87e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 801d882:	466a      	mov	r2, sp
 801d884:	f104 0308 	add.w	r3, r4, #8
 801d888:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d88c:	e882 0003 	stmia.w	r2, {r0, r1}
 801d890:	e894 000c 	ldmia.w	r4, {r2, r3}
 801d894:	4630      	mov	r0, r6
 801d896:	f7ff fe43 	bl	801d520 <OsTimeSpecAdd>
 801d89a:	687c      	ldr	r4, [r7, #4]
 801d89c:	f107 0308 	add.w	r3, r7, #8
 801d8a0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d8a2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    LOS_SpinUnlockRestore(&g_timeSpin, intSave);
 801d8a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d8a8:	4619      	mov	r1, r3
 801d8aa:	480d      	ldr	r0, [pc, #52]	; (801d8e0 <OsSetTimeOfDay+0x220>)
 801d8ac:	f7ff fdff 	bl	801d4ae <LOS_SpinUnlockRestore>

    return 0;
 801d8b0:	2300      	movs	r3, #0
}
 801d8b2:	4a09      	ldr	r2, [pc, #36]	; (801d8d8 <OsSetTimeOfDay+0x218>)
 801d8b4:	6811      	ldr	r1, [r2, #0]
 801d8b6:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801d8b8:	4051      	eors	r1, r2
 801d8ba:	d001      	beq.n	801d8c0 <OsSetTimeOfDay+0x200>
 801d8bc:	f7e6 fe8e 	bl	80045dc <__stack_chk_fail>
 801d8c0:	4618      	mov	r0, r3
 801d8c2:	377c      	adds	r7, #124	; 0x7c
 801d8c4:	46bd      	mov	sp, r7
 801d8c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801d8ca:	bf00      	nop
 801d8cc:	f3af 8000 	nop.w
 801d8d0:	3b9aca00 	.word	0x3b9aca00
 801d8d4:	00000000 	.word	0x00000000
 801d8d8:	080231b8 	.word	0x080231b8
 801d8dc:	3b9aca00 	.word	0x3b9aca00
 801d8e0:	200033e0 	.word	0x200033e0
 801d8e4:	200033e8 	.word	0x200033e8
 801d8e8:	200033f0 	.word	0x200033f0
 801d8ec:	20003400 	.word	0x20003400

0801d8f0 <settimeofday64>:
    return OsSetTimeOfDay(&stTimeVal64, tz);
}

#ifndef LOSCFG_AARCH64
int settimeofday64(const struct timeval64 *tv, const struct timezone *tz)
{
 801d8f0:	b580      	push	{r7, lr}
 801d8f2:	b084      	sub	sp, #16
 801d8f4:	af00      	add	r7, sp, #0
 801d8f6:	6078      	str	r0, [r7, #4]
 801d8f8:	6039      	str	r1, [r7, #0]
    if (!ValidTimeval64(tv)) {
 801d8fa:	6878      	ldr	r0, [r7, #4]
 801d8fc:	f7ff fde4 	bl	801d4c8 <ValidTimeval64>
 801d900:	4603      	mov	r3, r0
 801d902:	2b00      	cmp	r3, #0
 801d904:	d10b      	bne.n	801d91e <settimeofday64+0x2e>
        TIME_RETURN(EINVAL);
 801d906:	2300      	movs	r3, #0
 801d908:	60fb      	str	r3, [r7, #12]
 801d90a:	f04f 33ff 	mov.w	r3, #4294967295
 801d90e:	60fb      	str	r3, [r7, #12]
 801d910:	f7f2 fb42 	bl	800ff98 <__errno_location>
 801d914:	4603      	mov	r3, r0
 801d916:	2216      	movs	r2, #22
 801d918:	601a      	str	r2, [r3, #0]
 801d91a:	68fb      	ldr	r3, [r7, #12]
 801d91c:	e004      	b.n	801d928 <settimeofday64+0x38>
    }

    return OsSetTimeOfDay(tv, tz);
 801d91e:	6839      	ldr	r1, [r7, #0]
 801d920:	6878      	ldr	r0, [r7, #4]
 801d922:	f7ff fecd 	bl	801d6c0 <OsSetTimeOfDay>
 801d926:	4603      	mov	r3, r0
}
 801d928:	4618      	mov	r0, r3
 801d92a:	3710      	adds	r7, #16
 801d92c:	46bd      	mov	sp, r7
 801d92e:	bd80      	pop	{r7, pc}

0801d930 <OsGettimeOfDay>:

    return settimeofday(&tv, NULL);
}

STATIC INT32 OsGettimeOfDay(struct timeval64 *tv, const struct timezone *tz)
{
 801d930:	b5b0      	push	{r4, r5, r7, lr}
 801d932:	b09a      	sub	sp, #104	; 0x68
 801d934:	af06      	add	r7, sp, #24
 801d936:	6178      	str	r0, [r7, #20]
 801d938:	6139      	str	r1, [r7, #16]
 801d93a:	4b55      	ldr	r3, [pc, #340]	; (801da90 <OsGettimeOfDay+0x160>)
 801d93c:	681b      	ldr	r3, [r3, #0]
 801d93e:	64fb      	str	r3, [r7, #76]	; 0x4c
 801d940:	f04f 0300 	mov.w	r3, #0
    UINT64 nowNsec;
    UINT32 intSave;

    (VOID)tz;
    struct timespec64 hwTime = {0};
 801d944:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801d948:	2200      	movs	r2, #0
 801d94a:	601a      	str	r2, [r3, #0]
 801d94c:	605a      	str	r2, [r3, #4]
 801d94e:	609a      	str	r2, [r3, #8]
 801d950:	60da      	str	r2, [r3, #12]
    struct timespec64 realTime = {0};
 801d952:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801d956:	2200      	movs	r2, #0
 801d958:	601a      	str	r2, [r3, #0]
 801d95a:	605a      	str	r2, [r3, #4]
 801d95c:	609a      	str	r2, [r3, #8]
 801d95e:	60da      	str	r2, [r3, #12]

    nowNsec = LOS_CurrNanosec();
 801d960:	f7e6 fd52 	bl	8004408 <LOS_CurrNanosec>
 801d964:	e9c7 0108 	strd	r0, r1, [r7, #32]
    hwTime.tv_sec = nowNsec / OS_SYS_NS_PER_SECOND;
 801d968:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801d96c:	a346      	add	r3, pc, #280	; (adr r3, 801da88 <OsGettimeOfDay+0x158>)
 801d96e:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d972:	f7e3 f80f 	bl	8000994 <__aeabi_uldivmod>
 801d976:	4602      	mov	r2, r0
 801d978:	460b      	mov	r3, r1
 801d97a:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
    hwTime.tv_nsec = (INT64)(nowNsec - (hwTime.tv_sec * OS_SYS_NS_PER_SECOND));
 801d97e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801d982:	4944      	ldr	r1, [pc, #272]	; (801da94 <OsGettimeOfDay+0x164>)
 801d984:	fb01 f003 	mul.w	r0, r1, r3
 801d988:	2100      	movs	r1, #0
 801d98a:	fb01 f102 	mul.w	r1, r1, r2
 801d98e:	4401      	add	r1, r0
 801d990:	4840      	ldr	r0, [pc, #256]	; (801da94 <OsGettimeOfDay+0x164>)
 801d992:	fba2 2300 	umull	r2, r3, r2, r0
 801d996:	4419      	add	r1, r3
 801d998:	460b      	mov	r3, r1
 801d99a:	4610      	mov	r0, r2
 801d99c:	4619      	mov	r1, r3
 801d99e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801d9a2:	1a14      	subs	r4, r2, r0
 801d9a4:	eb63 0501 	sbc.w	r5, r3, r1
 801d9a8:	4622      	mov	r2, r4
 801d9aa:	462b      	mov	r3, r5
 801d9ac:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30

    LOS_SpinLockSave(&g_timeSpin, &intSave);
 801d9b0:	f107 0318 	add.w	r3, r7, #24
 801d9b4:	4619      	mov	r1, r3
 801d9b6:	4838      	ldr	r0, [pc, #224]	; (801da98 <OsGettimeOfDay+0x168>)
 801d9b8:	f7ff fd6b 	bl	801d492 <LOS_SpinLockSave>
    realTime = OsTimeSpecAdd(hwTime, g_accDeltaFromAdj);
 801d9bc:	f107 0538 	add.w	r5, r7, #56	; 0x38
 801d9c0:	4b36      	ldr	r3, [pc, #216]	; (801da9c <OsGettimeOfDay+0x16c>)
 801d9c2:	ac02      	add	r4, sp, #8
 801d9c4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d9c6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d9ca:	466a      	mov	r2, sp
 801d9cc:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801d9d0:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d9d4:	e882 0003 	stmia.w	r2, {r0, r1}
 801d9d8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801d9dc:	cb0c      	ldmia	r3, {r2, r3}
 801d9de:	4628      	mov	r0, r5
 801d9e0:	f7ff fd9e 	bl	801d520 <OsTimeSpecAdd>
    realTime = OsTimeSpecAdd(realTime, g_accDeltaFromSet);
 801d9e4:	463d      	mov	r5, r7
 801d9e6:	4b2e      	ldr	r3, [pc, #184]	; (801daa0 <OsGettimeOfDay+0x170>)
 801d9e8:	ac02      	add	r4, sp, #8
 801d9ea:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d9ec:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801d9f0:	466a      	mov	r2, sp
 801d9f2:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801d9f6:	e893 0003 	ldmia.w	r3, {r0, r1}
 801d9fa:	e882 0003 	stmia.w	r2, {r0, r1}
 801d9fe:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801da02:	cb0c      	ldmia	r3, {r2, r3}
 801da04:	4628      	mov	r0, r5
 801da06:	f7ff fd8b 	bl	801d520 <OsTimeSpecAdd>
 801da0a:	f107 0438 	add.w	r4, r7, #56	; 0x38
 801da0e:	463b      	mov	r3, r7
 801da10:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801da12:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    LOS_SpinUnlockRestore(&g_timeSpin, intSave);
 801da16:	69bb      	ldr	r3, [r7, #24]
 801da18:	4619      	mov	r1, r3
 801da1a:	481f      	ldr	r0, [pc, #124]	; (801da98 <OsGettimeOfDay+0x168>)
 801da1c:	f7ff fd47 	bl	801d4ae <LOS_SpinUnlockRestore>

    tv->tv_sec = realTime.tv_sec;
 801da20:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801da24:	6979      	ldr	r1, [r7, #20]
 801da26:	e9c1 2300 	strd	r2, r3, [r1]
    tv->tv_usec = realTime.tv_nsec / OS_SYS_NS_PER_US;
 801da2a:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
 801da2e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801da32:	f04f 0300 	mov.w	r3, #0
 801da36:	f7e3 fb49 	bl	80010cc <__aeabi_ldivmod>
 801da3a:	4602      	mov	r2, r0
 801da3c:	460b      	mov	r3, r1
 801da3e:	6979      	ldr	r1, [r7, #20]
 801da40:	e9c1 2302 	strd	r2, r3, [r1, #8]

    if (tv->tv_sec < 0) {
 801da44:	697b      	ldr	r3, [r7, #20]
 801da46:	e9d3 2300 	ldrd	r2, r3, [r3]
 801da4a:	2a00      	cmp	r2, #0
 801da4c:	f173 0300 	sbcs.w	r3, r3, #0
 801da50:	da0b      	bge.n	801da6a <OsGettimeOfDay+0x13a>
        TIME_RETURN(EINVAL);
 801da52:	2300      	movs	r3, #0
 801da54:	61fb      	str	r3, [r7, #28]
 801da56:	f04f 33ff 	mov.w	r3, #4294967295
 801da5a:	61fb      	str	r3, [r7, #28]
 801da5c:	f7f2 fa9c 	bl	800ff98 <__errno_location>
 801da60:	4603      	mov	r3, r0
 801da62:	2216      	movs	r2, #22
 801da64:	601a      	str	r2, [r3, #0]
 801da66:	69fb      	ldr	r3, [r7, #28]
 801da68:	e000      	b.n	801da6c <OsGettimeOfDay+0x13c>
    }
    return 0;
 801da6a:	2300      	movs	r3, #0
}
 801da6c:	4a08      	ldr	r2, [pc, #32]	; (801da90 <OsGettimeOfDay+0x160>)
 801da6e:	6811      	ldr	r1, [r2, #0]
 801da70:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801da72:	4051      	eors	r1, r2
 801da74:	d001      	beq.n	801da7a <OsGettimeOfDay+0x14a>
 801da76:	f7e6 fdb1 	bl	80045dc <__stack_chk_fail>
 801da7a:	4618      	mov	r0, r3
 801da7c:	3750      	adds	r7, #80	; 0x50
 801da7e:	46bd      	mov	sp, r7
 801da80:	bdb0      	pop	{r4, r5, r7, pc}
 801da82:	bf00      	nop
 801da84:	f3af 8000 	nop.w
 801da88:	3b9aca00 	.word	0x3b9aca00
 801da8c:	00000000 	.word	0x00000000
 801da90:	080231c4 	.word	0x080231c4
 801da94:	3b9aca00 	.word	0x3b9aca00
 801da98:	200033e0 	.word	0x200033e0
 801da9c:	200033f0 	.word	0x200033f0
 801daa0:	20003400 	.word	0x20003400

0801daa4 <gettimeofday64>:

#ifndef LOSCFG_AARCH64
int gettimeofday64(struct timeval64 *tv, struct timezone *tz)
{
 801daa4:	b580      	push	{r7, lr}
 801daa6:	b084      	sub	sp, #16
 801daa8:	af00      	add	r7, sp, #0
 801daaa:	6078      	str	r0, [r7, #4]
 801daac:	6039      	str	r1, [r7, #0]
    if (tv == NULL) {
 801daae:	687b      	ldr	r3, [r7, #4]
 801dab0:	2b00      	cmp	r3, #0
 801dab2:	d10b      	bne.n	801dacc <gettimeofday64+0x28>
        TIME_RETURN(EINVAL);
 801dab4:	2300      	movs	r3, #0
 801dab6:	60fb      	str	r3, [r7, #12]
 801dab8:	f04f 33ff 	mov.w	r3, #4294967295
 801dabc:	60fb      	str	r3, [r7, #12]
 801dabe:	f7f2 fa6b 	bl	800ff98 <__errno_location>
 801dac2:	4603      	mov	r3, r0
 801dac4:	2216      	movs	r2, #22
 801dac6:	601a      	str	r2, [r3, #0]
 801dac8:	68fb      	ldr	r3, [r7, #12]
 801daca:	e004      	b.n	801dad6 <gettimeofday64+0x32>
    }

    return OsGettimeOfDay(tv, tz);
 801dacc:	6839      	ldr	r1, [r7, #0]
 801dace:	6878      	ldr	r0, [r7, #4]
 801dad0:	f7ff ff2e 	bl	801d930 <OsGettimeOfDay>
 801dad4:	4603      	mov	r3, r0
}
 801dad6:	4618      	mov	r0, r3
 801dad8:	3710      	adds	r7, #16
 801dada:	46bd      	mov	sp, r7
 801dadc:	bd80      	pop	{r7, pc}

0801dade <valid_tm_wday>:
typedef time64_t Time64_T;
static struct TM g_returnDate;
static char g_returnString[RETURN_STRING_LEN];

static int valid_tm_wday(const struct TM *date)
{
 801dade:	b480      	push	{r7}
 801dae0:	b083      	sub	sp, #12
 801dae2:	af00      	add	r7, sp, #0
 801dae4:	6078      	str	r0, [r7, #4]
    if ((date->tm_wday >= 0) && (date->tm_wday <= 6)) {
 801dae6:	687b      	ldr	r3, [r7, #4]
 801dae8:	699b      	ldr	r3, [r3, #24]
 801daea:	2b00      	cmp	r3, #0
 801daec:	db05      	blt.n	801dafa <valid_tm_wday+0x1c>
 801daee:	687b      	ldr	r3, [r7, #4]
 801daf0:	699b      	ldr	r3, [r3, #24]
 801daf2:	2b06      	cmp	r3, #6
 801daf4:	dc01      	bgt.n	801dafa <valid_tm_wday+0x1c>
        return 1;
 801daf6:	2301      	movs	r3, #1
 801daf8:	e000      	b.n	801dafc <valid_tm_wday+0x1e>
    } else {
        return 0;
 801dafa:	2300      	movs	r3, #0
    }
}
 801dafc:	4618      	mov	r0, r3
 801dafe:	370c      	adds	r7, #12
 801db00:	46bd      	mov	sp, r7
 801db02:	f85d 7b04 	ldr.w	r7, [sp], #4
 801db06:	4770      	bx	lr

0801db08 <valid_tm_mon>:

static int valid_tm_mon(const struct TM *date)
{
 801db08:	b480      	push	{r7}
 801db0a:	b083      	sub	sp, #12
 801db0c:	af00      	add	r7, sp, #0
 801db0e:	6078      	str	r0, [r7, #4]
    if ((date->tm_mon >= 0) && (date->tm_mon <= 11)) {
 801db10:	687b      	ldr	r3, [r7, #4]
 801db12:	691b      	ldr	r3, [r3, #16]
 801db14:	2b00      	cmp	r3, #0
 801db16:	db05      	blt.n	801db24 <valid_tm_mon+0x1c>
 801db18:	687b      	ldr	r3, [r7, #4]
 801db1a:	691b      	ldr	r3, [r3, #16]
 801db1c:	2b0b      	cmp	r3, #11
 801db1e:	dc01      	bgt.n	801db24 <valid_tm_mon+0x1c>
        return 1;
 801db20:	2301      	movs	r3, #1
 801db22:	e000      	b.n	801db26 <valid_tm_mon+0x1e>
    } else {
        return 0;
 801db24:	2300      	movs	r3, #0
    }
}
 801db26:	4618      	mov	r0, r3
 801db28:	370c      	adds	r7, #12
 801db2a:	46bd      	mov	sp, r7
 801db2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801db30:	4770      	bx	lr
 801db32:	0000      	movs	r0, r0
 801db34:	0000      	movs	r0, r0
	...

0801db38 <localtime64_r>:

struct TM *localtime64_r(const Time64_T *time, struct TM *local_tm)
{
 801db38:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801db3c:	b086      	sub	sp, #24
 801db3e:	af00      	add	r7, sp, #0
 801db40:	6078      	str	r0, [r7, #4]
 801db42:	6039      	str	r1, [r7, #0]
    Time64_T timeoff;
    int dstsec = 0;
 801db44:	2300      	movs	r3, #0
 801db46:	60fb      	str	r3, [r7, #12]

    (void)LIBC_LOCK(g_tzdstLock);
 801db48:	482d      	ldr	r0, [pc, #180]	; (801dc00 <localtime64_r+0xc8>)
 801db4a:	f001 faa1 	bl	801f090 <LibcLock>
    if (CheckWithinDstPeriod(NULL, *time) == TRUE) {
 801db4e:	687b      	ldr	r3, [r7, #4]
 801db50:	e9d3 2300 	ldrd	r2, r3, [r3]
 801db54:	2000      	movs	r0, #0
 801db56:	f001 fa05 	bl	801ef64 <CheckWithinDstPeriod>
 801db5a:	4603      	mov	r3, r0
 801db5c:	2b01      	cmp	r3, #1
 801db5e:	d102      	bne.n	801db66 <localtime64_r+0x2e>
        dstsec = DstForwardSecondGet();
 801db60:	f000 fe60 	bl	801e824 <DstForwardSecondGet>
 801db64:	60f8      	str	r0, [r7, #12]
    }
    timeoff = *time + timezone + dstsec;
 801db66:	687b      	ldr	r3, [r7, #4]
 801db68:	e9d3 0100 	ldrd	r0, r1, [r3]
 801db6c:	4b25      	ldr	r3, [pc, #148]	; (801dc04 <localtime64_r+0xcc>)
 801db6e:	681b      	ldr	r3, [r3, #0]
 801db70:	461a      	mov	r2, r3
 801db72:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801db76:	1884      	adds	r4, r0, r2
 801db78:	eb41 0503 	adc.w	r5, r1, r3
 801db7c:	68fb      	ldr	r3, [r7, #12]
 801db7e:	461a      	mov	r2, r3
 801db80:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801db84:	eb14 0802 	adds.w	r8, r4, r2
 801db88:	eb45 0903 	adc.w	r9, r5, r3
 801db8c:	e9c7 8904 	strd	r8, r9, [r7, #16]
    (void)LIBC_UNLOCK(g_tzdstLock);
 801db90:	481b      	ldr	r0, [pc, #108]	; (801dc00 <localtime64_r+0xc8>)
 801db92:	f001 faa7 	bl	801f0e4 <LibcUnlock>

    /* Reject time_t values whose year would overflow int because
     * __secs_to_zone cannot safely handle them. */
    if ((timeoff < (INT_MIN * MAX_SEC_PER_YEAR)) || (timeoff > (INT_MAX * MAX_SEC_PER_YEAR))) {
 801db96:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801db9a:	f04f 30ff 	mov.w	r0, #4294967295
 801db9e:	491a      	ldr	r1, [pc, #104]	; (801dc08 <localtime64_r+0xd0>)
 801dba0:	4290      	cmp	r0, r2
 801dba2:	eb71 0303 	sbcs.w	r3, r1, r3
 801dba6:	da08      	bge.n	801dbba <localtime64_r+0x82>
 801dba8:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801dbac:	a112      	add	r1, pc, #72	; (adr r1, 801dbf8 <localtime64_r+0xc0>)
 801dbae:	e9d1 0100 	ldrd	r0, r1, [r1]
 801dbb2:	4290      	cmp	r0, r2
 801dbb4:	eb71 0303 	sbcs.w	r3, r1, r3
 801dbb8:	da06      	bge.n	801dbc8 <localtime64_r+0x90>
        errno = EOVERFLOW;
 801dbba:	f7f2 f9ed 	bl	800ff98 <__errno_location>
 801dbbe:	4603      	mov	r3, r0
 801dbc0:	224b      	movs	r2, #75	; 0x4b
 801dbc2:	601a      	str	r2, [r3, #0]
        return 0;
 801dbc4:	2300      	movs	r3, #0
 801dbc6:	e00f      	b.n	801dbe8 <localtime64_r+0xb0>
    }

    if (__secs_to_tm(timeoff, local_tm) < 0) {
 801dbc8:	683a      	ldr	r2, [r7, #0]
 801dbca:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801dbce:	f000 f9af 	bl	801df30 <__secs_to_tm>
 801dbd2:	4603      	mov	r3, r0
 801dbd4:	2b00      	cmp	r3, #0
 801dbd6:	da06      	bge.n	801dbe6 <localtime64_r+0xae>
        errno = EOVERFLOW;
 801dbd8:	f7f2 f9de 	bl	800ff98 <__errno_location>
 801dbdc:	4603      	mov	r3, r0
 801dbde:	224b      	movs	r2, #75	; 0x4b
 801dbe0:	601a      	str	r2, [r3, #0]
        return 0;
 801dbe2:	2300      	movs	r3, #0
 801dbe4:	e000      	b.n	801dbe8 <localtime64_r+0xb0>
    }
    return local_tm;
 801dbe6:	683b      	ldr	r3, [r7, #0]
}
 801dbe8:	4618      	mov	r0, r3
 801dbea:	3718      	adds	r7, #24
 801dbec:	46bd      	mov	sp, r7
 801dbee:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 801dbf2:	bf00      	nop
 801dbf4:	f3af 8000 	nop.w
 801dbf8:	fe1d7b00 	.word	0xfe1d7b00
 801dbfc:	00f1427f 	.word	0x00f1427f
 801dc00:	20000570 	.word	0x20000570
 801dc04:	200037dc 	.word	0x200037dc
 801dc08:	ff0ebd7f 	.word	0xff0ebd7f

0801dc0c <localtime64>:

struct TM *localtime64(const Time64_T *time)
{
 801dc0c:	b580      	push	{r7, lr}
 801dc0e:	b082      	sub	sp, #8
 801dc10:	af00      	add	r7, sp, #0
 801dc12:	6078      	str	r0, [r7, #4]
    return localtime64_r(time, &g_returnDate);
 801dc14:	4904      	ldr	r1, [pc, #16]	; (801dc28 <localtime64+0x1c>)
 801dc16:	6878      	ldr	r0, [r7, #4]
 801dc18:	f7ff ff8e 	bl	801db38 <localtime64_r>
 801dc1c:	4603      	mov	r3, r0
}
 801dc1e:	4618      	mov	r0, r3
 801dc20:	3708      	adds	r7, #8
 801dc22:	46bd      	mov	sp, r7
 801dc24:	bd80      	pop	{r7, pc}
 801dc26:	bf00      	nop
 801dc28:	20003410 	.word	0x20003410

0801dc2c <asctime64_r>:

char *asctime64_r(const struct TM *date, char *result)
{
 801dc2c:	b580      	push	{r7, lr}
 801dc2e:	b082      	sub	sp, #8
 801dc30:	af00      	add	r7, sp, #0
 801dc32:	6078      	str	r0, [r7, #4]
 801dc34:	6039      	str	r1, [r7, #0]
    if (!valid_tm_wday(date) || !valid_tm_mon(date)) {
 801dc36:	6878      	ldr	r0, [r7, #4]
 801dc38:	f7ff ff51 	bl	801dade <valid_tm_wday>
 801dc3c:	4603      	mov	r3, r0
 801dc3e:	2b00      	cmp	r3, #0
 801dc40:	d005      	beq.n	801dc4e <asctime64_r+0x22>
 801dc42:	6878      	ldr	r0, [r7, #4]
 801dc44:	f7ff ff60 	bl	801db08 <valid_tm_mon>
 801dc48:	4603      	mov	r3, r0
 801dc4a:	2b00      	cmp	r3, #0
 801dc4c:	d101      	bne.n	801dc52 <asctime64_r+0x26>
        return NULL;
 801dc4e:	2300      	movs	r3, #0
 801dc50:	e00c      	b.n	801dc6c <asctime64_r+0x40>
    }

    if ((TM_YEAR_BASE + date->tm_year) > TM_YEAR_MAX) {
 801dc52:	687b      	ldr	r3, [r7, #4]
 801dc54:	695b      	ldr	r3, [r3, #20]
 801dc56:	f641 72a3 	movw	r2, #8099	; 0x1fa3
 801dc5a:	4293      	cmp	r3, r2
 801dc5c:	dd01      	ble.n	801dc62 <asctime64_r+0x36>
        return NULL;
 801dc5e:	2300      	movs	r3, #0
 801dc60:	e004      	b.n	801dc6c <asctime64_r+0x40>
    }

    return asctime_r(date, result);
 801dc62:	6839      	ldr	r1, [r7, #0]
 801dc64:	6878      	ldr	r0, [r7, #4]
 801dc66:	f000 fd6d 	bl	801e744 <__asctime_r>
 801dc6a:	4603      	mov	r3, r0
}
 801dc6c:	4618      	mov	r0, r3
 801dc6e:	3708      	adds	r7, #8
 801dc70:	46bd      	mov	sp, r7
 801dc72:	bd80      	pop	{r7, pc}

0801dc74 <asctime64>:

char *asctime64(const struct TM *date)
{
 801dc74:	b580      	push	{r7, lr}
 801dc76:	b082      	sub	sp, #8
 801dc78:	af00      	add	r7, sp, #0
 801dc7a:	6078      	str	r0, [r7, #4]
    return asctime64_r(date, g_returnString);
 801dc7c:	4904      	ldr	r1, [pc, #16]	; (801dc90 <asctime64+0x1c>)
 801dc7e:	6878      	ldr	r0, [r7, #4]
 801dc80:	f7ff ffd4 	bl	801dc2c <asctime64_r>
 801dc84:	4603      	mov	r3, r0
}
 801dc86:	4618      	mov	r0, r3
 801dc88:	3708      	adds	r7, #8
 801dc8a:	46bd      	mov	sp, r7
 801dc8c:	bd80      	pop	{r7, pc}
 801dc8e:	bf00      	nop
 801dc90:	2000343c 	.word	0x2000343c

0801dc94 <ctime64>:

char *ctime64(const Time64_T *time)
{
 801dc94:	b580      	push	{r7, lr}
 801dc96:	b084      	sub	sp, #16
 801dc98:	af00      	add	r7, sp, #0
 801dc9a:	6078      	str	r0, [r7, #4]
    struct TM *ptm = localtime64(time);
 801dc9c:	6878      	ldr	r0, [r7, #4]
 801dc9e:	f7ff ffb5 	bl	801dc0c <localtime64>
 801dca2:	60f8      	str	r0, [r7, #12]
    if (ptm != NULL) {
 801dca4:	68fb      	ldr	r3, [r7, #12]
 801dca6:	2b00      	cmp	r3, #0
 801dca8:	d004      	beq.n	801dcb4 <ctime64+0x20>
        return asctime64(ptm);
 801dcaa:	68f8      	ldr	r0, [r7, #12]
 801dcac:	f7ff ffe2 	bl	801dc74 <asctime64>
 801dcb0:	4603      	mov	r3, r0
 801dcb2:	e000      	b.n	801dcb6 <ctime64+0x22>
    }
    return NULL;
 801dcb4:	2300      	movs	r3, #0
}
 801dcb6:	4618      	mov	r0, r3
 801dcb8:	3710      	adds	r7, #16
 801dcba:	46bd      	mov	sp, r7
 801dcbc:	bd80      	pop	{r7, pc}
	...

0801dcc0 <mktime64>:

Time64_T mktime64(struct TM *tm)
{
 801dcc0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801dcc4:	b086      	sub	sp, #24
 801dcc6:	af00      	add	r7, sp, #0
 801dcc8:	6078      	str	r0, [r7, #4]
    long long t = __tm_to_secs(tm);
 801dcca:	6878      	ldr	r0, [r7, #4]
 801dccc:	f000 faea 	bl	801e2a4 <__tm_to_secs>
 801dcd0:	e9c7 0104 	strd	r0, r1, [r7, #16]
    int dstsec = 0;
 801dcd4:	2300      	movs	r3, #0
 801dcd6:	60fb      	str	r3, [r7, #12]

    (void)LIBC_LOCK(g_tzdstLock);
 801dcd8:	481a      	ldr	r0, [pc, #104]	; (801dd44 <mktime64+0x84>)
 801dcda:	f001 f9d9 	bl	801f090 <LibcLock>
    if (tm->tm_isdst != 0) {
 801dcde:	687b      	ldr	r3, [r7, #4]
 801dce0:	6a1b      	ldr	r3, [r3, #32]
 801dce2:	2b00      	cmp	r3, #0
 801dce4:	d00f      	beq.n	801dd06 <mktime64+0x46>
        if (CheckWithinDstPeriod(tm, 0) == TRUE) {
 801dce6:	f04f 0200 	mov.w	r2, #0
 801dcea:	f04f 0300 	mov.w	r3, #0
 801dcee:	6878      	ldr	r0, [r7, #4]
 801dcf0:	f001 f938 	bl	801ef64 <CheckWithinDstPeriod>
 801dcf4:	4603      	mov	r3, r0
 801dcf6:	2b01      	cmp	r3, #1
 801dcf8:	d102      	bne.n	801dd00 <mktime64+0x40>
            dstsec = DstForwardSecondGet();
 801dcfa:	f000 fd93 	bl	801e824 <DstForwardSecondGet>
 801dcfe:	60f8      	str	r0, [r7, #12]
        }
        tm->tm_isdst = 0;
 801dd00:	687b      	ldr	r3, [r7, #4]
 801dd02:	2200      	movs	r2, #0
 801dd04:	621a      	str	r2, [r3, #32]
    }
    t = t - timezone - dstsec;
 801dd06:	4b10      	ldr	r3, [pc, #64]	; (801dd48 <mktime64+0x88>)
 801dd08:	681b      	ldr	r3, [r3, #0]
 801dd0a:	461a      	mov	r2, r3
 801dd0c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801dd10:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801dd14:	1a84      	subs	r4, r0, r2
 801dd16:	eb61 0503 	sbc.w	r5, r1, r3
 801dd1a:	68fb      	ldr	r3, [r7, #12]
 801dd1c:	461a      	mov	r2, r3
 801dd1e:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801dd22:	ebb4 0802 	subs.w	r8, r4, r2
 801dd26:	eb65 0903 	sbc.w	r9, r5, r3
 801dd2a:	e9c7 8904 	strd	r8, r9, [r7, #16]
    (void)LIBC_UNLOCK(g_tzdstLock);
 801dd2e:	4805      	ldr	r0, [pc, #20]	; (801dd44 <mktime64+0x84>)
 801dd30:	f001 f9d8 	bl	801f0e4 <LibcUnlock>

    if ((Time64_T)t != t) {
        goto error;
    }

    return t;
 801dd34:	e9d7 2304 	ldrd	r2, r3, [r7, #16]

error:
    (void)LIBC_UNLOCK(g_tzdstLock);
    errno = EOVERFLOW;
    return -1;
}
 801dd38:	4610      	mov	r0, r2
 801dd3a:	4619      	mov	r1, r3
 801dd3c:	3718      	adds	r7, #24
 801dd3e:	46bd      	mov	sp, r7
 801dd40:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 801dd44:	20000570 	.word	0x20000570
 801dd48:	200037dc 	.word	0x200037dc

0801dd4c <gmtime64_r>:

struct TM *gmtime64_r(const Time64_T *in_time, struct TM *tm)
{
 801dd4c:	b580      	push	{r7, lr}
 801dd4e:	b082      	sub	sp, #8
 801dd50:	af00      	add	r7, sp, #0
 801dd52:	6078      	str	r0, [r7, #4]
 801dd54:	6039      	str	r1, [r7, #0]
    if (__secs_to_tm(*in_time, tm) < 0) {
 801dd56:	687b      	ldr	r3, [r7, #4]
 801dd58:	e9d3 0100 	ldrd	r0, r1, [r3]
 801dd5c:	683a      	ldr	r2, [r7, #0]
 801dd5e:	f000 f8e7 	bl	801df30 <__secs_to_tm>
 801dd62:	4603      	mov	r3, r0
 801dd64:	2b00      	cmp	r3, #0
 801dd66:	da06      	bge.n	801dd76 <gmtime64_r+0x2a>
        errno = EOVERFLOW;
 801dd68:	f7f2 f916 	bl	800ff98 <__errno_location>
 801dd6c:	4603      	mov	r3, r0
 801dd6e:	224b      	movs	r2, #75	; 0x4b
 801dd70:	601a      	str	r2, [r3, #0]
        return 0;
 801dd72:	2300      	movs	r3, #0
 801dd74:	e009      	b.n	801dd8a <gmtime64_r+0x3e>
    }
    tm->tm_isdst = 0;
 801dd76:	683b      	ldr	r3, [r7, #0]
 801dd78:	2200      	movs	r2, #0
 801dd7a:	621a      	str	r2, [r3, #32]
    tm->__tm_gmtoff = 0;
 801dd7c:	683b      	ldr	r3, [r7, #0]
 801dd7e:	2200      	movs	r2, #0
 801dd80:	625a      	str	r2, [r3, #36]	; 0x24
    tm->__tm_zone = __utc;
 801dd82:	683b      	ldr	r3, [r7, #0]
 801dd84:	4a03      	ldr	r2, [pc, #12]	; (801dd94 <gmtime64_r+0x48>)
 801dd86:	629a      	str	r2, [r3, #40]	; 0x28
    return tm;
 801dd88:	683b      	ldr	r3, [r7, #0]
}
 801dd8a:	4618      	mov	r0, r3
 801dd8c:	3708      	adds	r7, #8
 801dd8e:	46bd      	mov	sp, r7
 801dd90:	bd80      	pop	{r7, pc}
 801dd92:	bf00      	nop
 801dd94:	080242d0 	.word	0x080242d0

0801dd98 <__strerror_l>:
static const char errmsg[] =
#include "__strerror.h"
;

char *__strerror_l(int e, locale_t loc)
{
 801dd98:	b480      	push	{r7}
 801dd9a:	b085      	sub	sp, #20
 801dd9c:	af00      	add	r7, sp, #0
 801dd9e:	6078      	str	r0, [r7, #4]
 801dda0:	6039      	str	r1, [r7, #0]
	 * historical typo, so we just remap it. */
	if (EDQUOT==1133) {
		if (e==109) e=-1;
		else if (e==EDQUOT) e=109;
	}
	for (i=0; errid[i] && errid[i] != e; i++);
 801dda2:	2300      	movs	r3, #0
 801dda4:	60fb      	str	r3, [r7, #12]
 801dda6:	e002      	b.n	801ddae <__strerror_l+0x16>
 801dda8:	68fb      	ldr	r3, [r7, #12]
 801ddaa:	3301      	adds	r3, #1
 801ddac:	60fb      	str	r3, [r7, #12]
 801ddae:	4a14      	ldr	r2, [pc, #80]	; (801de00 <__strerror_l+0x68>)
 801ddb0:	68fb      	ldr	r3, [r7, #12]
 801ddb2:	4413      	add	r3, r2
 801ddb4:	781b      	ldrb	r3, [r3, #0]
 801ddb6:	2b00      	cmp	r3, #0
 801ddb8:	d007      	beq.n	801ddca <__strerror_l+0x32>
 801ddba:	4a11      	ldr	r2, [pc, #68]	; (801de00 <__strerror_l+0x68>)
 801ddbc:	68fb      	ldr	r3, [r7, #12]
 801ddbe:	4413      	add	r3, r2
 801ddc0:	781b      	ldrb	r3, [r3, #0]
 801ddc2:	461a      	mov	r2, r3
 801ddc4:	687b      	ldr	r3, [r7, #4]
 801ddc6:	4293      	cmp	r3, r2
 801ddc8:	d1ee      	bne.n	801dda8 <__strerror_l+0x10>
	for (s=errmsg; i; s++, i--) for (; *s; s++);
 801ddca:	4b0e      	ldr	r3, [pc, #56]	; (801de04 <__strerror_l+0x6c>)
 801ddcc:	60bb      	str	r3, [r7, #8]
 801ddce:	e00c      	b.n	801ddea <__strerror_l+0x52>
 801ddd0:	68bb      	ldr	r3, [r7, #8]
 801ddd2:	3301      	adds	r3, #1
 801ddd4:	60bb      	str	r3, [r7, #8]
 801ddd6:	68bb      	ldr	r3, [r7, #8]
 801ddd8:	781b      	ldrb	r3, [r3, #0]
 801ddda:	2b00      	cmp	r3, #0
 801dddc:	d1f8      	bne.n	801ddd0 <__strerror_l+0x38>
 801ddde:	68bb      	ldr	r3, [r7, #8]
 801dde0:	3301      	adds	r3, #1
 801dde2:	60bb      	str	r3, [r7, #8]
 801dde4:	68fb      	ldr	r3, [r7, #12]
 801dde6:	3b01      	subs	r3, #1
 801dde8:	60fb      	str	r3, [r7, #12]
 801ddea:	68fb      	ldr	r3, [r7, #12]
 801ddec:	2b00      	cmp	r3, #0
 801ddee:	d1f2      	bne.n	801ddd6 <__strerror_l+0x3e>
	return (char *)s;
 801ddf0:	68bb      	ldr	r3, [r7, #8]
}
 801ddf2:	4618      	mov	r0, r3
 801ddf4:	3714      	adds	r7, #20
 801ddf6:	46bd      	mov	sp, r7
 801ddf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ddfc:	4770      	bx	lr
 801ddfe:	bf00      	nop
 801de00:	08023b48 	.word	0x08023b48
 801de04:	08023ba4 	.word	0x08023ba4

0801de08 <strerror>:

char *strerror(int e)
{
 801de08:	b580      	push	{r7, lr}
 801de0a:	b082      	sub	sp, #8
 801de0c:	af00      	add	r7, sp, #0
 801de0e:	6078      	str	r0, [r7, #4]
	return __strerror_l(e, CURRENT_LOCALE);
 801de10:	2101      	movs	r1, #1
 801de12:	6878      	ldr	r0, [r7, #4]
 801de14:	f7ff ffc0 	bl	801dd98 <__strerror_l>
 801de18:	4603      	mov	r3, r0
}
 801de1a:	4618      	mov	r0, r3
 801de1c:	3708      	adds	r7, #8
 801de1e:	46bd      	mov	sp, r7
 801de20:	bd80      	pop	{r7, pc}

0801de22 <__memrchr>:
#include <string.h>

void *__memrchr(const void *m, int c, size_t n)
{
 801de22:	b480      	push	{r7}
 801de24:	b087      	sub	sp, #28
 801de26:	af00      	add	r7, sp, #0
 801de28:	60f8      	str	r0, [r7, #12]
 801de2a:	60b9      	str	r1, [r7, #8]
 801de2c:	607a      	str	r2, [r7, #4]
	const unsigned char *s = m;
 801de2e:	68fb      	ldr	r3, [r7, #12]
 801de30:	617b      	str	r3, [r7, #20]
	c = (unsigned char)c;
 801de32:	68bb      	ldr	r3, [r7, #8]
 801de34:	b2db      	uxtb	r3, r3
 801de36:	60bb      	str	r3, [r7, #8]
	while (n--) if (s[n]==c) return (void *)(s+n);
 801de38:	e00b      	b.n	801de52 <__memrchr+0x30>
 801de3a:	697a      	ldr	r2, [r7, #20]
 801de3c:	687b      	ldr	r3, [r7, #4]
 801de3e:	4413      	add	r3, r2
 801de40:	781b      	ldrb	r3, [r3, #0]
 801de42:	461a      	mov	r2, r3
 801de44:	68bb      	ldr	r3, [r7, #8]
 801de46:	4293      	cmp	r3, r2
 801de48:	d103      	bne.n	801de52 <__memrchr+0x30>
 801de4a:	697a      	ldr	r2, [r7, #20]
 801de4c:	687b      	ldr	r3, [r7, #4]
 801de4e:	4413      	add	r3, r2
 801de50:	e005      	b.n	801de5e <__memrchr+0x3c>
 801de52:	687b      	ldr	r3, [r7, #4]
 801de54:	1e5a      	subs	r2, r3, #1
 801de56:	607a      	str	r2, [r7, #4]
 801de58:	2b00      	cmp	r3, #0
 801de5a:	d1ee      	bne.n	801de3a <__memrchr+0x18>
	return 0;
 801de5c:	2300      	movs	r3, #0
}
 801de5e:	4618      	mov	r0, r3
 801de60:	371c      	adds	r7, #28
 801de62:	46bd      	mov	sp, r7
 801de64:	f85d 7b04 	ldr.w	r7, [sp], #4
 801de68:	4770      	bx	lr

0801de6a <strncasecmp>:
#include <strings.h>
#include <ctype.h>

int strncasecmp(const char *_l, const char *_r, size_t n)
{
 801de6a:	b590      	push	{r4, r7, lr}
 801de6c:	b087      	sub	sp, #28
 801de6e:	af00      	add	r7, sp, #0
 801de70:	60f8      	str	r0, [r7, #12]
 801de72:	60b9      	str	r1, [r7, #8]
 801de74:	607a      	str	r2, [r7, #4]
	const unsigned char *l=(void *)_l, *r=(void *)_r;
 801de76:	68fb      	ldr	r3, [r7, #12]
 801de78:	613b      	str	r3, [r7, #16]
 801de7a:	68bb      	ldr	r3, [r7, #8]
 801de7c:	617b      	str	r3, [r7, #20]
	if (!n--) return 0;
 801de7e:	687b      	ldr	r3, [r7, #4]
 801de80:	1e5a      	subs	r2, r3, #1
 801de82:	607a      	str	r2, [r7, #4]
 801de84:	2b00      	cmp	r3, #0
 801de86:	d10a      	bne.n	801de9e <strncasecmp+0x34>
 801de88:	2300      	movs	r3, #0
 801de8a:	e034      	b.n	801def6 <strncasecmp+0x8c>
	for (; *l && *r && n && (*l == *r || tolower(*l) == tolower(*r)); l++, r++, n--);
 801de8c:	693b      	ldr	r3, [r7, #16]
 801de8e:	3301      	adds	r3, #1
 801de90:	613b      	str	r3, [r7, #16]
 801de92:	697b      	ldr	r3, [r7, #20]
 801de94:	3301      	adds	r3, #1
 801de96:	617b      	str	r3, [r7, #20]
 801de98:	687b      	ldr	r3, [r7, #4]
 801de9a:	3b01      	subs	r3, #1
 801de9c:	607b      	str	r3, [r7, #4]
 801de9e:	693b      	ldr	r3, [r7, #16]
 801dea0:	781b      	ldrb	r3, [r3, #0]
 801dea2:	2b00      	cmp	r3, #0
 801dea4:	d01a      	beq.n	801dedc <strncasecmp+0x72>
 801dea6:	697b      	ldr	r3, [r7, #20]
 801dea8:	781b      	ldrb	r3, [r3, #0]
 801deaa:	2b00      	cmp	r3, #0
 801deac:	d016      	beq.n	801dedc <strncasecmp+0x72>
 801deae:	687b      	ldr	r3, [r7, #4]
 801deb0:	2b00      	cmp	r3, #0
 801deb2:	d013      	beq.n	801dedc <strncasecmp+0x72>
 801deb4:	693b      	ldr	r3, [r7, #16]
 801deb6:	781a      	ldrb	r2, [r3, #0]
 801deb8:	697b      	ldr	r3, [r7, #20]
 801deba:	781b      	ldrb	r3, [r3, #0]
 801debc:	429a      	cmp	r2, r3
 801debe:	d0e5      	beq.n	801de8c <strncasecmp+0x22>
 801dec0:	693b      	ldr	r3, [r7, #16]
 801dec2:	781b      	ldrb	r3, [r3, #0]
 801dec4:	4618      	mov	r0, r3
 801dec6:	f000 fc81 	bl	801e7cc <tolower>
 801deca:	4604      	mov	r4, r0
 801decc:	697b      	ldr	r3, [r7, #20]
 801dece:	781b      	ldrb	r3, [r3, #0]
 801ded0:	4618      	mov	r0, r3
 801ded2:	f000 fc7b 	bl	801e7cc <tolower>
 801ded6:	4603      	mov	r3, r0
 801ded8:	429c      	cmp	r4, r3
 801deda:	d0d7      	beq.n	801de8c <strncasecmp+0x22>
	return tolower(*l) - tolower(*r);
 801dedc:	693b      	ldr	r3, [r7, #16]
 801dede:	781b      	ldrb	r3, [r3, #0]
 801dee0:	4618      	mov	r0, r3
 801dee2:	f000 fc73 	bl	801e7cc <tolower>
 801dee6:	4604      	mov	r4, r0
 801dee8:	697b      	ldr	r3, [r7, #20]
 801deea:	781b      	ldrb	r3, [r3, #0]
 801deec:	4618      	mov	r0, r3
 801deee:	f000 fc6d 	bl	801e7cc <tolower>
 801def2:	4603      	mov	r3, r0
 801def4:	1ae3      	subs	r3, r4, r3
}
 801def6:	4618      	mov	r0, r3
 801def8:	371c      	adds	r7, #28
 801defa:	46bd      	mov	sp, r7
 801defc:	bd90      	pop	{r4, r7, pc}

0801defe <strnlen>:
#include <string.h>

size_t strnlen(const char *s, size_t n)
{
 801defe:	b580      	push	{r7, lr}
 801df00:	b084      	sub	sp, #16
 801df02:	af00      	add	r7, sp, #0
 801df04:	6078      	str	r0, [r7, #4]
 801df06:	6039      	str	r1, [r7, #0]
	const char *p = memchr(s, 0, n);
 801df08:	683a      	ldr	r2, [r7, #0]
 801df0a:	2100      	movs	r1, #0
 801df0c:	6878      	ldr	r0, [r7, #4]
 801df0e:	f001 f908 	bl	801f122 <memchr>
 801df12:	60f8      	str	r0, [r7, #12]
	return p ? p-s : n;
 801df14:	68fb      	ldr	r3, [r7, #12]
 801df16:	2b00      	cmp	r3, #0
 801df18:	d003      	beq.n	801df22 <strnlen+0x24>
 801df1a:	68fa      	ldr	r2, [r7, #12]
 801df1c:	687b      	ldr	r3, [r7, #4]
 801df1e:	1ad3      	subs	r3, r2, r3
 801df20:	e000      	b.n	801df24 <strnlen+0x26>
 801df22:	683b      	ldr	r3, [r7, #0]
}
 801df24:	4618      	mov	r0, r3
 801df26:	3710      	adds	r7, #16
 801df28:	46bd      	mov	sp, r7
 801df2a:	bd80      	pop	{r7, pc}
 801df2c:	0000      	movs	r0, r0
	...

0801df30 <__secs_to_tm>:
#define DAYS_PER_400Y (365*400 + 97)
#define DAYS_PER_100Y (365*100 + 24)
#define DAYS_PER_4Y   (365*4   + 1)

int __secs_to_tm(long long t, struct tm *tm)
{
 801df30:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 801df34:	b09a      	sub	sp, #104	; 0x68
 801df36:	af00      	add	r7, sp, #0
 801df38:	e9c7 0108 	strd	r0, r1, [r7, #32]
 801df3c:	61fa      	str	r2, [r7, #28]
	int months;
	int wday, yday, leap;
	static const char days_in_month[] = {31,30,31,30,31,31,30,31,30,31,31,29};

	/* Reject time_t values whose year would overflow int */
	if (t < INT_MIN * 31622400LL || t > INT_MAX * 31622400LL)
 801df3e:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801df42:	f04f 32ff 	mov.w	r2, #4294967295
 801df46:	4ba6      	ldr	r3, [pc, #664]	; (801e1e0 <__secs_to_tm+0x2b0>)
 801df48:	4282      	cmp	r2, r0
 801df4a:	418b      	sbcs	r3, r1
 801df4c:	da07      	bge.n	801df5e <__secs_to_tm+0x2e>
 801df4e:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801df52:	a39f      	add	r3, pc, #636	; (adr r3, 801e1d0 <__secs_to_tm+0x2a0>)
 801df54:	e9d3 2300 	ldrd	r2, r3, [r3]
 801df58:	4282      	cmp	r2, r0
 801df5a:	418b      	sbcs	r3, r1
 801df5c:	da02      	bge.n	801df64 <__secs_to_tm+0x34>
		return -1;
 801df5e:	f04f 33ff 	mov.w	r3, #4294967295
 801df62:	e196      	b.n	801e292 <__secs_to_tm+0x362>

	secs = t - LEAPOCH;
 801df64:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801df68:	a39b      	add	r3, pc, #620	; (adr r3, 801e1d8 <__secs_to_tm+0x2a8>)
 801df6a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801df6e:	1884      	adds	r4, r0, r2
 801df70:	eb41 0503 	adc.w	r5, r1, r3
 801df74:	e9c7 4518 	strd	r4, r5, [r7, #96]	; 0x60
	days = secs / 86400;
 801df78:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 801df7c:	4a99      	ldr	r2, [pc, #612]	; (801e1e4 <__secs_to_tm+0x2b4>)
 801df7e:	f04f 0300 	mov.w	r3, #0
 801df82:	f7e3 f8a3 	bl	80010cc <__aeabi_ldivmod>
 801df86:	4602      	mov	r2, r0
 801df88:	460b      	mov	r3, r1
 801df8a:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50
	remsecs = secs % 86400;
 801df8e:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	; 0x60
 801df92:	4a94      	ldr	r2, [pc, #592]	; (801e1e4 <__secs_to_tm+0x2b4>)
 801df94:	f04f 0300 	mov.w	r3, #0
 801df98:	f7e3 f898 	bl	80010cc <__aeabi_ldivmod>
 801df9c:	4613      	mov	r3, r2
 801df9e:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (remsecs < 0) {
 801dfa0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801dfa2:	2b00      	cmp	r3, #0
 801dfa4:	da0b      	bge.n	801dfbe <__secs_to_tm+0x8e>
		remsecs += 86400;
 801dfa6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801dfa8:	4b8e      	ldr	r3, [pc, #568]	; (801e1e4 <__secs_to_tm+0x2b4>)
 801dfaa:	4413      	add	r3, r2
 801dfac:	62fb      	str	r3, [r7, #44]	; 0x2c
		days--;
 801dfae:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 801dfb2:	f112 38ff 	adds.w	r8, r2, #4294967295
 801dfb6:	f143 39ff 	adc.w	r9, r3, #4294967295
 801dfba:	e9c7 8914 	strd	r8, r9, [r7, #80]	; 0x50
	}

	wday = (3+days)%7;
 801dfbe:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 801dfc2:	1cd1      	adds	r1, r2, #3
 801dfc4:	6139      	str	r1, [r7, #16]
 801dfc6:	f143 0300 	adc.w	r3, r3, #0
 801dfca:	617b      	str	r3, [r7, #20]
 801dfcc:	f04f 0207 	mov.w	r2, #7
 801dfd0:	f04f 0300 	mov.w	r3, #0
 801dfd4:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801dfd8:	f7e3 f878 	bl	80010cc <__aeabi_ldivmod>
 801dfdc:	4613      	mov	r3, r2
 801dfde:	647b      	str	r3, [r7, #68]	; 0x44
	if (wday < 0) wday += 7;
 801dfe0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801dfe2:	2b00      	cmp	r3, #0
 801dfe4:	da02      	bge.n	801dfec <__secs_to_tm+0xbc>
 801dfe6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801dfe8:	3307      	adds	r3, #7
 801dfea:	647b      	str	r3, [r7, #68]	; 0x44

	qc_cycles = days / DAYS_PER_400Y;
 801dfec:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 801dff0:	4a7d      	ldr	r2, [pc, #500]	; (801e1e8 <__secs_to_tm+0x2b8>)
 801dff2:	f04f 0300 	mov.w	r3, #0
 801dff6:	f7e3 f869 	bl	80010cc <__aeabi_ldivmod>
 801dffa:	4602      	mov	r2, r0
 801dffc:	460b      	mov	r3, r1
 801dffe:	4613      	mov	r3, r2
 801e000:	637b      	str	r3, [r7, #52]	; 0x34
	remdays = days % DAYS_PER_400Y;
 801e002:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 801e006:	4a78      	ldr	r2, [pc, #480]	; (801e1e8 <__secs_to_tm+0x2b8>)
 801e008:	f04f 0300 	mov.w	r3, #0
 801e00c:	f7e3 f85e 	bl	80010cc <__aeabi_ldivmod>
 801e010:	4613      	mov	r3, r2
 801e012:	62bb      	str	r3, [r7, #40]	; 0x28
	if (remdays < 0) {
 801e014:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e016:	2b00      	cmp	r3, #0
 801e018:	da06      	bge.n	801e028 <__secs_to_tm+0xf8>
		remdays += DAYS_PER_400Y;
 801e01a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801e01c:	4b72      	ldr	r3, [pc, #456]	; (801e1e8 <__secs_to_tm+0x2b8>)
 801e01e:	4413      	add	r3, r2
 801e020:	62bb      	str	r3, [r7, #40]	; 0x28
		qc_cycles--;
 801e022:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e024:	3b01      	subs	r3, #1
 801e026:	637b      	str	r3, [r7, #52]	; 0x34
	}

	c_cycles = remdays / DAYS_PER_100Y;
 801e028:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e02a:	4a70      	ldr	r2, [pc, #448]	; (801e1ec <__secs_to_tm+0x2bc>)
 801e02c:	fb82 1203 	smull	r1, r2, r2, r3
 801e030:	441a      	add	r2, r3
 801e032:	13d2      	asrs	r2, r2, #15
 801e034:	17db      	asrs	r3, r3, #31
 801e036:	1ad3      	subs	r3, r2, r3
 801e038:	63bb      	str	r3, [r7, #56]	; 0x38
	if (c_cycles == 4) c_cycles--;
 801e03a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e03c:	2b04      	cmp	r3, #4
 801e03e:	d102      	bne.n	801e046 <__secs_to_tm+0x116>
 801e040:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e042:	3b01      	subs	r3, #1
 801e044:	63bb      	str	r3, [r7, #56]	; 0x38
	remdays -= c_cycles * DAYS_PER_100Y;
 801e046:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e048:	4a69      	ldr	r2, [pc, #420]	; (801e1f0 <__secs_to_tm+0x2c0>)
 801e04a:	fb02 f303 	mul.w	r3, r2, r3
 801e04e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801e050:	4413      	add	r3, r2
 801e052:	62bb      	str	r3, [r7, #40]	; 0x28

	q_cycles = remdays / DAYS_PER_4Y;
 801e054:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e056:	4a67      	ldr	r2, [pc, #412]	; (801e1f4 <__secs_to_tm+0x2c4>)
 801e058:	fb82 1203 	smull	r1, r2, r2, r3
 801e05c:	11d2      	asrs	r2, r2, #7
 801e05e:	17db      	asrs	r3, r3, #31
 801e060:	1ad3      	subs	r3, r2, r3
 801e062:	63fb      	str	r3, [r7, #60]	; 0x3c
	if (q_cycles == 25) q_cycles--;
 801e064:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801e066:	2b19      	cmp	r3, #25
 801e068:	d102      	bne.n	801e070 <__secs_to_tm+0x140>
 801e06a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801e06c:	3b01      	subs	r3, #1
 801e06e:	63fb      	str	r3, [r7, #60]	; 0x3c
	remdays -= q_cycles * DAYS_PER_4Y;
 801e070:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801e072:	4a61      	ldr	r2, [pc, #388]	; (801e1f8 <__secs_to_tm+0x2c8>)
 801e074:	fb02 f303 	mul.w	r3, r2, r3
 801e078:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801e07a:	4413      	add	r3, r2
 801e07c:	62bb      	str	r3, [r7, #40]	; 0x28

	remyears = remdays / 365;
 801e07e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e080:	4a5e      	ldr	r2, [pc, #376]	; (801e1fc <__secs_to_tm+0x2cc>)
 801e082:	fb82 1203 	smull	r1, r2, r2, r3
 801e086:	441a      	add	r2, r3
 801e088:	1212      	asrs	r2, r2, #8
 801e08a:	17db      	asrs	r3, r3, #31
 801e08c:	1ad3      	subs	r3, r2, r3
 801e08e:	633b      	str	r3, [r7, #48]	; 0x30
	if (remyears == 4) remyears--;
 801e090:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e092:	2b04      	cmp	r3, #4
 801e094:	d102      	bne.n	801e09c <__secs_to_tm+0x16c>
 801e096:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e098:	3b01      	subs	r3, #1
 801e09a:	633b      	str	r3, [r7, #48]	; 0x30
	remdays -= remyears * 365;
 801e09c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e09e:	f46f 72b6 	mvn.w	r2, #364	; 0x16c
 801e0a2:	fb02 f303 	mul.w	r3, r2, r3
 801e0a6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801e0a8:	4413      	add	r3, r2
 801e0aa:	62bb      	str	r3, [r7, #40]	; 0x28

	leap = !remyears && (q_cycles || !c_cycles);
 801e0ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e0ae:	2b00      	cmp	r3, #0
 801e0b0:	d107      	bne.n	801e0c2 <__secs_to_tm+0x192>
 801e0b2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801e0b4:	2b00      	cmp	r3, #0
 801e0b6:	d102      	bne.n	801e0be <__secs_to_tm+0x18e>
 801e0b8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e0ba:	2b00      	cmp	r3, #0
 801e0bc:	d101      	bne.n	801e0c2 <__secs_to_tm+0x192>
 801e0be:	2301      	movs	r3, #1
 801e0c0:	e000      	b.n	801e0c4 <__secs_to_tm+0x194>
 801e0c2:	2300      	movs	r3, #0
 801e0c4:	64fb      	str	r3, [r7, #76]	; 0x4c
	yday = remdays + 31 + 28 + leap;
 801e0c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e0c8:	333b      	adds	r3, #59	; 0x3b
 801e0ca:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801e0cc:	4413      	add	r3, r2
 801e0ce:	64bb      	str	r3, [r7, #72]	; 0x48
	if (yday >= 365+leap) yday -= 365+leap;
 801e0d0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801e0d2:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 801e0d6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801e0d8:	429a      	cmp	r2, r3
 801e0da:	dd05      	ble.n	801e0e8 <__secs_to_tm+0x1b8>
 801e0dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801e0de:	f203 136d 	addw	r3, r3, #365	; 0x16d
 801e0e2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801e0e4:	1ad3      	subs	r3, r2, r3
 801e0e6:	64bb      	str	r3, [r7, #72]	; 0x48

	years = remyears + 4*q_cycles + 100*c_cycles + 400LL*qc_cycles;
 801e0e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801e0ea:	009a      	lsls	r2, r3, #2
 801e0ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e0ee:	441a      	add	r2, r3
 801e0f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e0f2:	2164      	movs	r1, #100	; 0x64
 801e0f4:	fb01 f303 	mul.w	r3, r1, r3
 801e0f8:	4413      	add	r3, r2
 801e0fa:	4698      	mov	r8, r3
 801e0fc:	ea4f 79e8 	mov.w	r9, r8, asr #31
 801e100:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e102:	4618      	mov	r0, r3
 801e104:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801e108:	4602      	mov	r2, r0
 801e10a:	460b      	mov	r3, r1
 801e10c:	1894      	adds	r4, r2, r2
 801e10e:	60bc      	str	r4, [r7, #8]
 801e110:	415b      	adcs	r3, r3
 801e112:	60fb      	str	r3, [r7, #12]
 801e114:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801e118:	1812      	adds	r2, r2, r0
 801e11a:	eb41 0303 	adc.w	r3, r1, r3
 801e11e:	f04f 0400 	mov.w	r4, #0
 801e122:	f04f 0500 	mov.w	r5, #0
 801e126:	00dd      	lsls	r5, r3, #3
 801e128:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
 801e12c:	00d4      	lsls	r4, r2, #3
 801e12e:	4622      	mov	r2, r4
 801e130:	462b      	mov	r3, r5
 801e132:	1812      	adds	r2, r2, r0
 801e134:	eb41 0303 	adc.w	r3, r1, r3
 801e138:	f04f 0000 	mov.w	r0, #0
 801e13c:	f04f 0100 	mov.w	r1, #0
 801e140:	0119      	lsls	r1, r3, #4
 801e142:	ea41 7112 	orr.w	r1, r1, r2, lsr #28
 801e146:	0110      	lsls	r0, r2, #4
 801e148:	4602      	mov	r2, r0
 801e14a:	460b      	mov	r3, r1
 801e14c:	eb18 0102 	adds.w	r1, r8, r2
 801e150:	6039      	str	r1, [r7, #0]
 801e152:	eb49 0303 	adc.w	r3, r9, r3
 801e156:	607b      	str	r3, [r7, #4]
 801e158:	e9d7 3400 	ldrd	r3, r4, [r7]
 801e15c:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58

	for (months=0; days_in_month[months] <= remdays; months++)
 801e160:	2300      	movs	r3, #0
 801e162:	643b      	str	r3, [r7, #64]	; 0x40
 801e164:	e00a      	b.n	801e17c <__secs_to_tm+0x24c>
		remdays -= days_in_month[months];
 801e166:	4a26      	ldr	r2, [pc, #152]	; (801e200 <__secs_to_tm+0x2d0>)
 801e168:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e16a:	4413      	add	r3, r2
 801e16c:	781b      	ldrb	r3, [r3, #0]
 801e16e:	461a      	mov	r2, r3
 801e170:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e172:	1a9b      	subs	r3, r3, r2
 801e174:	62bb      	str	r3, [r7, #40]	; 0x28
	for (months=0; days_in_month[months] <= remdays; months++)
 801e176:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e178:	3301      	adds	r3, #1
 801e17a:	643b      	str	r3, [r7, #64]	; 0x40
 801e17c:	4a20      	ldr	r2, [pc, #128]	; (801e200 <__secs_to_tm+0x2d0>)
 801e17e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e180:	4413      	add	r3, r2
 801e182:	781b      	ldrb	r3, [r3, #0]
 801e184:	461a      	mov	r2, r3
 801e186:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e188:	4293      	cmp	r3, r2
 801e18a:	daec      	bge.n	801e166 <__secs_to_tm+0x236>

	if (months >= 10) {
 801e18c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e18e:	2b09      	cmp	r3, #9
 801e190:	dd0a      	ble.n	801e1a8 <__secs_to_tm+0x278>
		months -= 12;
 801e192:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e194:	3b0c      	subs	r3, #12
 801e196:	643b      	str	r3, [r7, #64]	; 0x40
		years++;
 801e198:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 801e19c:	f112 0a01 	adds.w	sl, r2, #1
 801e1a0:	f143 0b00 	adc.w	fp, r3, #0
 801e1a4:	e9c7 ab16 	strd	sl, fp, [r7, #88]	; 0x58
	}

	if (years+100 > INT_MAX || years+100 < INT_MIN)
 801e1a8:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 801e1ac:	4815      	ldr	r0, [pc, #84]	; (801e204 <__secs_to_tm+0x2d4>)
 801e1ae:	f04f 0100 	mov.w	r1, #0
 801e1b2:	4290      	cmp	r0, r2
 801e1b4:	eb71 0303 	sbcs.w	r3, r1, r3
 801e1b8:	db07      	blt.n	801e1ca <__secs_to_tm+0x29a>
 801e1ba:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 801e1be:	4812      	ldr	r0, [pc, #72]	; (801e208 <__secs_to_tm+0x2d8>)
 801e1c0:	f04f 31ff 	mov.w	r1, #4294967295
 801e1c4:	4282      	cmp	r2, r0
 801e1c6:	418b      	sbcs	r3, r1
 801e1c8:	da20      	bge.n	801e20c <__secs_to_tm+0x2dc>
		return -1;
 801e1ca:	f04f 33ff 	mov.w	r3, #4294967295
 801e1ce:	e060      	b.n	801e292 <__secs_to_tm+0x362>
 801e1d0:	fe1d7b00 	.word	0xfe1d7b00
 801e1d4:	00f1427f 	.word	0x00f1427f
 801e1d8:	c743a280 	.word	0xc743a280
 801e1dc:	ffffffff 	.word	0xffffffff
 801e1e0:	ff0ebd7f 	.word	0xff0ebd7f
 801e1e4:	00015180 	.word	0x00015180
 801e1e8:	00023ab1 	.word	0x00023ab1
 801e1ec:	e5ac81fb 	.word	0xe5ac81fb
 801e1f0:	ffff7154 	.word	0xffff7154
 801e1f4:	166db073 	.word	0x166db073
 801e1f8:	fffffa4b 	.word	0xfffffa4b
 801e1fc:	b38cf9b1 	.word	0xb38cf9b1
 801e200:	080242c4 	.word	0x080242c4
 801e204:	7fffff9b 	.word	0x7fffff9b
 801e208:	7fffff9c 	.word	0x7fffff9c

	tm->tm_year = years + 100;
 801e20c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801e20e:	3364      	adds	r3, #100	; 0x64
 801e210:	461a      	mov	r2, r3
 801e212:	69fb      	ldr	r3, [r7, #28]
 801e214:	615a      	str	r2, [r3, #20]
	tm->tm_mon = months + 2;
 801e216:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e218:	1c9a      	adds	r2, r3, #2
 801e21a:	69fb      	ldr	r3, [r7, #28]
 801e21c:	611a      	str	r2, [r3, #16]
	tm->tm_mday = remdays + 1;
 801e21e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e220:	1c5a      	adds	r2, r3, #1
 801e222:	69fb      	ldr	r3, [r7, #28]
 801e224:	60da      	str	r2, [r3, #12]
	tm->tm_wday = wday;
 801e226:	69fb      	ldr	r3, [r7, #28]
 801e228:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801e22a:	619a      	str	r2, [r3, #24]
	tm->tm_yday = yday;
 801e22c:	69fb      	ldr	r3, [r7, #28]
 801e22e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801e230:	61da      	str	r2, [r3, #28]

	tm->tm_hour = remsecs / 3600;
 801e232:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e234:	4a19      	ldr	r2, [pc, #100]	; (801e29c <__secs_to_tm+0x36c>)
 801e236:	fb82 1203 	smull	r1, r2, r2, r3
 801e23a:	441a      	add	r2, r3
 801e23c:	12d2      	asrs	r2, r2, #11
 801e23e:	17db      	asrs	r3, r3, #31
 801e240:	1ad2      	subs	r2, r2, r3
 801e242:	69fb      	ldr	r3, [r7, #28]
 801e244:	609a      	str	r2, [r3, #8]
	tm->tm_min = remsecs / 60 % 60;
 801e246:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e248:	4a15      	ldr	r2, [pc, #84]	; (801e2a0 <__secs_to_tm+0x370>)
 801e24a:	fb82 1203 	smull	r1, r2, r2, r3
 801e24e:	441a      	add	r2, r3
 801e250:	1152      	asrs	r2, r2, #5
 801e252:	17db      	asrs	r3, r3, #31
 801e254:	1ad2      	subs	r2, r2, r3
 801e256:	4b12      	ldr	r3, [pc, #72]	; (801e2a0 <__secs_to_tm+0x370>)
 801e258:	fb83 1302 	smull	r1, r3, r3, r2
 801e25c:	4413      	add	r3, r2
 801e25e:	1159      	asrs	r1, r3, #5
 801e260:	17d3      	asrs	r3, r2, #31
 801e262:	1ac9      	subs	r1, r1, r3
 801e264:	460b      	mov	r3, r1
 801e266:	011b      	lsls	r3, r3, #4
 801e268:	1a5b      	subs	r3, r3, r1
 801e26a:	009b      	lsls	r3, r3, #2
 801e26c:	1ad1      	subs	r1, r2, r3
 801e26e:	69fb      	ldr	r3, [r7, #28]
 801e270:	6059      	str	r1, [r3, #4]
	tm->tm_sec = remsecs % 60;
 801e272:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801e274:	4b0a      	ldr	r3, [pc, #40]	; (801e2a0 <__secs_to_tm+0x370>)
 801e276:	fb83 1302 	smull	r1, r3, r3, r2
 801e27a:	4413      	add	r3, r2
 801e27c:	1159      	asrs	r1, r3, #5
 801e27e:	17d3      	asrs	r3, r2, #31
 801e280:	1ac9      	subs	r1, r1, r3
 801e282:	460b      	mov	r3, r1
 801e284:	011b      	lsls	r3, r3, #4
 801e286:	1a5b      	subs	r3, r3, r1
 801e288:	009b      	lsls	r3, r3, #2
 801e28a:	1ad1      	subs	r1, r2, r3
 801e28c:	69fb      	ldr	r3, [r7, #28]
 801e28e:	6019      	str	r1, [r3, #0]

	return 0;
 801e290:	2300      	movs	r3, #0
}
 801e292:	4618      	mov	r0, r3
 801e294:	3768      	adds	r7, #104	; 0x68
 801e296:	46bd      	mov	sp, r7
 801e298:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 801e29c:	91a2b3c5 	.word	0x91a2b3c5
 801e2a0:	88888889 	.word	0x88888889

0801e2a4 <__tm_to_secs>:
#include "time_impl.h"

long long __tm_to_secs(const struct tm *tm)
{
 801e2a4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 801e2a8:	b094      	sub	sp, #80	; 0x50
 801e2aa:	af00      	add	r7, sp, #0
 801e2ac:	6278      	str	r0, [r7, #36]	; 0x24
 801e2ae:	4b88      	ldr	r3, [pc, #544]	; (801e4d0 <__tm_to_secs+0x22c>)
 801e2b0:	681b      	ldr	r3, [r3, #0]
 801e2b2:	64fb      	str	r3, [r7, #76]	; 0x4c
 801e2b4:	f04f 0300 	mov.w	r3, #0
	int is_leap;
	long long year = tm->tm_year;
 801e2b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e2ba:	695b      	ldr	r3, [r3, #20]
 801e2bc:	461a      	mov	r2, r3
 801e2be:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801e2c2:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	int month = tm->tm_mon;
 801e2c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e2c8:	691b      	ldr	r3, [r3, #16]
 801e2ca:	633b      	str	r3, [r7, #48]	; 0x30
	if (month >= 12 || month < 0) {
 801e2cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e2ce:	2b0b      	cmp	r3, #11
 801e2d0:	dc02      	bgt.n	801e2d8 <__tm_to_secs+0x34>
 801e2d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e2d4:	2b00      	cmp	r3, #0
 801e2d6:	da28      	bge.n	801e32a <__tm_to_secs+0x86>
		int adj = month / 12;
 801e2d8:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801e2da:	4b7e      	ldr	r3, [pc, #504]	; (801e4d4 <__tm_to_secs+0x230>)
 801e2dc:	fb83 2301 	smull	r2, r3, r3, r1
 801e2e0:	105a      	asrs	r2, r3, #1
 801e2e2:	17cb      	asrs	r3, r1, #31
 801e2e4:	1ad3      	subs	r3, r2, r3
 801e2e6:	637b      	str	r3, [r7, #52]	; 0x34
		month %= 12;
 801e2e8:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801e2ea:	4b7a      	ldr	r3, [pc, #488]	; (801e4d4 <__tm_to_secs+0x230>)
 801e2ec:	fb83 2301 	smull	r2, r3, r3, r1
 801e2f0:	105a      	asrs	r2, r3, #1
 801e2f2:	17cb      	asrs	r3, r1, #31
 801e2f4:	1ad2      	subs	r2, r2, r3
 801e2f6:	4613      	mov	r3, r2
 801e2f8:	005b      	lsls	r3, r3, #1
 801e2fa:	4413      	add	r3, r2
 801e2fc:	009b      	lsls	r3, r3, #2
 801e2fe:	1acb      	subs	r3, r1, r3
 801e300:	633b      	str	r3, [r7, #48]	; 0x30
		if (month < 0) {
 801e302:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e304:	2b00      	cmp	r3, #0
 801e306:	da05      	bge.n	801e314 <__tm_to_secs+0x70>
			adj--;
 801e308:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e30a:	3b01      	subs	r3, #1
 801e30c:	637b      	str	r3, [r7, #52]	; 0x34
			month += 12;
 801e30e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e310:	330c      	adds	r3, #12
 801e312:	633b      	str	r3, [r7, #48]	; 0x30
		}
		year += adj;
 801e314:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e316:	4618      	mov	r0, r3
 801e318:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801e31c:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801e320:	1814      	adds	r4, r2, r0
 801e322:	eb43 0501 	adc.w	r5, r3, r1
 801e326:	e9c7 450e 	strd	r4, r5, [r7, #56]	; 0x38
	}
	long long t = __year_to_secs(year, &is_leap);
 801e32a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801e32e:	461a      	mov	r2, r3
 801e330:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 801e334:	f000 f8d0 	bl	801e4d8 <__year_to_secs>
 801e338:	e9c7 0110 	strd	r0, r1, [r7, #64]	; 0x40
	t += __month_to_secs(month, is_leap);
 801e33c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e33e:	4619      	mov	r1, r3
 801e340:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801e342:	f000 ff59 	bl	801f1f8 <__month_to_secs>
 801e346:	4603      	mov	r3, r0
 801e348:	4618      	mov	r0, r3
 801e34a:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801e34e:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 801e352:	eb12 0800 	adds.w	r8, r2, r0
 801e356:	eb43 0901 	adc.w	r9, r3, r1
 801e35a:	e9c7 8910 	strd	r8, r9, [r7, #64]	; 0x40
	t += 86400LL * (tm->tm_mday-1);
 801e35e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e360:	68db      	ldr	r3, [r3, #12]
 801e362:	3b01      	subs	r3, #1
 801e364:	461a      	mov	r2, r3
 801e366:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801e36a:	4610      	mov	r0, r2
 801e36c:	4619      	mov	r1, r3
 801e36e:	1804      	adds	r4, r0, r0
 801e370:	61bc      	str	r4, [r7, #24]
 801e372:	4149      	adcs	r1, r1
 801e374:	61f9      	str	r1, [r7, #28]
 801e376:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 801e37a:	1880      	adds	r0, r0, r2
 801e37c:	eb43 0101 	adc.w	r1, r3, r1
 801e380:	f04f 0200 	mov.w	r2, #0
 801e384:	f04f 0300 	mov.w	r3, #0
 801e388:	010b      	lsls	r3, r1, #4
 801e38a:	ea43 7310 	orr.w	r3, r3, r0, lsr #28
 801e38e:	0102      	lsls	r2, r0, #4
 801e390:	1a12      	subs	r2, r2, r0
 801e392:	eb63 0301 	sbc.w	r3, r3, r1
 801e396:	f04f 0000 	mov.w	r0, #0
 801e39a:	f04f 0100 	mov.w	r1, #0
 801e39e:	0119      	lsls	r1, r3, #4
 801e3a0:	ea41 7112 	orr.w	r1, r1, r2, lsr #28
 801e3a4:	0110      	lsls	r0, r2, #4
 801e3a6:	1a80      	subs	r0, r0, r2
 801e3a8:	eb61 0103 	sbc.w	r1, r1, r3
 801e3ac:	f04f 0200 	mov.w	r2, #0
 801e3b0:	f04f 0300 	mov.w	r3, #0
 801e3b4:	01cb      	lsls	r3, r1, #7
 801e3b6:	ea43 6350 	orr.w	r3, r3, r0, lsr #25
 801e3ba:	01c2      	lsls	r2, r0, #7
 801e3bc:	4610      	mov	r0, r2
 801e3be:	4619      	mov	r1, r3
 801e3c0:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 801e3c4:	1814      	adds	r4, r2, r0
 801e3c6:	613c      	str	r4, [r7, #16]
 801e3c8:	414b      	adcs	r3, r1
 801e3ca:	617b      	str	r3, [r7, #20]
 801e3cc:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 801e3d0:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
	t += 3600LL * tm->tm_hour;
 801e3d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e3d6:	689b      	ldr	r3, [r3, #8]
 801e3d8:	4618      	mov	r0, r3
 801e3da:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801e3de:	4602      	mov	r2, r0
 801e3e0:	460b      	mov	r3, r1
 801e3e2:	f04f 0400 	mov.w	r4, #0
 801e3e6:	f04f 0500 	mov.w	r5, #0
 801e3ea:	00dd      	lsls	r5, r3, #3
 801e3ec:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
 801e3f0:	00d4      	lsls	r4, r2, #3
 801e3f2:	4622      	mov	r2, r4
 801e3f4:	462b      	mov	r3, r5
 801e3f6:	1a12      	subs	r2, r2, r0
 801e3f8:	eb63 0301 	sbc.w	r3, r3, r1
 801e3fc:	f04f 0400 	mov.w	r4, #0
 801e400:	f04f 0500 	mov.w	r5, #0
 801e404:	015d      	lsls	r5, r3, #5
 801e406:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 801e40a:	0154      	lsls	r4, r2, #5
 801e40c:	4622      	mov	r2, r4
 801e40e:	462b      	mov	r3, r5
 801e410:	1812      	adds	r2, r2, r0
 801e412:	eb41 0303 	adc.w	r3, r1, r3
 801e416:	f04f 0000 	mov.w	r0, #0
 801e41a:	f04f 0100 	mov.w	r1, #0
 801e41e:	0119      	lsls	r1, r3, #4
 801e420:	ea41 7112 	orr.w	r1, r1, r2, lsr #28
 801e424:	0110      	lsls	r0, r2, #4
 801e426:	4602      	mov	r2, r0
 801e428:	460b      	mov	r3, r1
 801e42a:	4610      	mov	r0, r2
 801e42c:	4619      	mov	r1, r3
 801e42e:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 801e432:	1814      	adds	r4, r2, r0
 801e434:	60bc      	str	r4, [r7, #8]
 801e436:	414b      	adcs	r3, r1
 801e438:	60fb      	str	r3, [r7, #12]
 801e43a:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 801e43e:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
	t += 60LL * tm->tm_min;
 801e442:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e444:	685b      	ldr	r3, [r3, #4]
 801e446:	461c      	mov	r4, r3
 801e448:	ea4f 75e4 	mov.w	r5, r4, asr #31
 801e44c:	4622      	mov	r2, r4
 801e44e:	462b      	mov	r3, r5
 801e450:	f04f 0000 	mov.w	r0, #0
 801e454:	f04f 0100 	mov.w	r1, #0
 801e458:	0119      	lsls	r1, r3, #4
 801e45a:	ea41 7112 	orr.w	r1, r1, r2, lsr #28
 801e45e:	0110      	lsls	r0, r2, #4
 801e460:	4602      	mov	r2, r0
 801e462:	460b      	mov	r3, r1
 801e464:	1b12      	subs	r2, r2, r4
 801e466:	eb63 0305 	sbc.w	r3, r3, r5
 801e46a:	f04f 0000 	mov.w	r0, #0
 801e46e:	f04f 0100 	mov.w	r1, #0
 801e472:	0099      	lsls	r1, r3, #2
 801e474:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
 801e478:	0090      	lsls	r0, r2, #2
 801e47a:	4602      	mov	r2, r0
 801e47c:	460b      	mov	r3, r1
 801e47e:	4610      	mov	r0, r2
 801e480:	4619      	mov	r1, r3
 801e482:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 801e486:	1814      	adds	r4, r2, r0
 801e488:	603c      	str	r4, [r7, #0]
 801e48a:	414b      	adcs	r3, r1
 801e48c:	607b      	str	r3, [r7, #4]
 801e48e:	e9d7 3400 	ldrd	r3, r4, [r7]
 801e492:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
	t += tm->tm_sec;
 801e496:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e498:	681b      	ldr	r3, [r3, #0]
 801e49a:	461a      	mov	r2, r3
 801e49c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801e4a0:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
 801e4a4:	eb10 0a02 	adds.w	sl, r0, r2
 801e4a8:	eb41 0b03 	adc.w	fp, r1, r3
 801e4ac:	e9c7 ab10 	strd	sl, fp, [r7, #64]	; 0x40
	return t;
 801e4b0:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
}
 801e4b4:	4906      	ldr	r1, [pc, #24]	; (801e4d0 <__tm_to_secs+0x22c>)
 801e4b6:	6808      	ldr	r0, [r1, #0]
 801e4b8:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801e4ba:	4048      	eors	r0, r1
 801e4bc:	d001      	beq.n	801e4c2 <__tm_to_secs+0x21e>
 801e4be:	f7e6 f88d 	bl	80045dc <__stack_chk_fail>
 801e4c2:	4610      	mov	r0, r2
 801e4c4:	4619      	mov	r1, r3
 801e4c6:	3750      	adds	r7, #80	; 0x50
 801e4c8:	46bd      	mov	sp, r7
 801e4ca:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 801e4ce:	bf00      	nop
 801e4d0:	080231d4 	.word	0x080231d4
 801e4d4:	2aaaaaab 	.word	0x2aaaaaab

0801e4d8 <__year_to_secs>:
long long __year_to_secs(long long year, int *is_leap)
{
 801e4d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e4dc:	b095      	sub	sp, #84	; 0x54
 801e4de:	af00      	add	r7, sp, #0
 801e4e0:	e9c7 010a 	strd	r0, r1, [r7, #40]	; 0x28
 801e4e4:	627a      	str	r2, [r7, #36]	; 0x24
 801e4e6:	4b94      	ldr	r3, [pc, #592]	; (801e738 <__year_to_secs+0x260>)
 801e4e8:	681b      	ldr	r3, [r3, #0]
 801e4ea:	64fb      	str	r3, [r7, #76]	; 0x4c
 801e4ec:	f04f 0300 	mov.w	r3, #0
	if (year-2ULL <= 136) {
 801e4f0:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e4f4:	1e91      	subs	r1, r2, #2
 801e4f6:	61b9      	str	r1, [r7, #24]
 801e4f8:	f143 33ff 	adc.w	r3, r3, #4294967295
 801e4fc:	61fb      	str	r3, [r7, #28]
 801e4fe:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801e502:	2b00      	cmp	r3, #0
 801e504:	bf08      	it	eq
 801e506:	2a89      	cmpeq	r2, #137	; 0x89
 801e508:	d228      	bcs.n	801e55c <__year_to_secs+0x84>
		int y = year;
 801e50a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e50c:	64bb      	str	r3, [r7, #72]	; 0x48
		int leaps = (y-68)>>2;
 801e50e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801e510:	3b44      	subs	r3, #68	; 0x44
 801e512:	109b      	asrs	r3, r3, #2
 801e514:	637b      	str	r3, [r7, #52]	; 0x34
		if (!((y-68)&3)) {
 801e516:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801e518:	f003 0303 	and.w	r3, r3, #3
 801e51c:	2b00      	cmp	r3, #0
 801e51e:	d109      	bne.n	801e534 <__year_to_secs+0x5c>
			leaps--;
 801e520:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e522:	3b01      	subs	r3, #1
 801e524:	637b      	str	r3, [r7, #52]	; 0x34
			if (is_leap) *is_leap = 1;
 801e526:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e528:	2b00      	cmp	r3, #0
 801e52a:	d009      	beq.n	801e540 <__year_to_secs+0x68>
 801e52c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e52e:	2201      	movs	r2, #1
 801e530:	601a      	str	r2, [r3, #0]
 801e532:	e005      	b.n	801e540 <__year_to_secs+0x68>
		} else if (is_leap) *is_leap = 0;
 801e534:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e536:	2b00      	cmp	r3, #0
 801e538:	d002      	beq.n	801e540 <__year_to_secs+0x68>
 801e53a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e53c:	2200      	movs	r2, #0
 801e53e:	601a      	str	r2, [r3, #0]
		return 31536000*(y-70) + 86400*leaps;
 801e540:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801e542:	3b46      	subs	r3, #70	; 0x46
 801e544:	4a7d      	ldr	r2, [pc, #500]	; (801e73c <__year_to_secs+0x264>)
 801e546:	fb02 f203 	mul.w	r2, r2, r3
 801e54a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e54c:	497c      	ldr	r1, [pc, #496]	; (801e740 <__year_to_secs+0x268>)
 801e54e:	fb01 f303 	mul.w	r3, r1, r3
 801e552:	4413      	add	r3, r2
 801e554:	469a      	mov	sl, r3
 801e556:	ea4f 7bea 	mov.w	fp, sl, asr #31
 801e55a:	e0da      	b.n	801e712 <__year_to_secs+0x23a>
	}

	int cycles, centuries, leaps, rem;

	if (!is_leap) is_leap = &(int){0};
 801e55c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e55e:	2b00      	cmp	r3, #0
 801e560:	d104      	bne.n	801e56c <__year_to_secs+0x94>
 801e562:	2300      	movs	r3, #0
 801e564:	633b      	str	r3, [r7, #48]	; 0x30
 801e566:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801e56a:	627b      	str	r3, [r7, #36]	; 0x24
	cycles = (year-100) / 400;
 801e56c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e570:	f1b2 0164 	subs.w	r1, r2, #100	; 0x64
 801e574:	6139      	str	r1, [r7, #16]
 801e576:	f143 33ff 	adc.w	r3, r3, #4294967295
 801e57a:	617b      	str	r3, [r7, #20]
 801e57c:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801e580:	f04f 0300 	mov.w	r3, #0
 801e584:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 801e588:	f7e2 fda0 	bl	80010cc <__aeabi_ldivmod>
 801e58c:	4602      	mov	r2, r0
 801e58e:	460b      	mov	r3, r1
 801e590:	4613      	mov	r3, r2
 801e592:	63bb      	str	r3, [r7, #56]	; 0x38
	rem = (year-100) % 400;
 801e594:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e598:	f1b2 0164 	subs.w	r1, r2, #100	; 0x64
 801e59c:	60b9      	str	r1, [r7, #8]
 801e59e:	f143 33ff 	adc.w	r3, r3, #4294967295
 801e5a2:	60fb      	str	r3, [r7, #12]
 801e5a4:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801e5a8:	f04f 0300 	mov.w	r3, #0
 801e5ac:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801e5b0:	f7e2 fd8c 	bl	80010cc <__aeabi_ldivmod>
 801e5b4:	4613      	mov	r3, r2
 801e5b6:	647b      	str	r3, [r7, #68]	; 0x44
	if (rem < 0) {
 801e5b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e5ba:	2b00      	cmp	r3, #0
 801e5bc:	da06      	bge.n	801e5cc <__year_to_secs+0xf4>
		cycles--;
 801e5be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801e5c0:	3b01      	subs	r3, #1
 801e5c2:	63bb      	str	r3, [r7, #56]	; 0x38
		rem += 400;
 801e5c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e5c6:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 801e5ca:	647b      	str	r3, [r7, #68]	; 0x44
	}
	if (!rem) {
 801e5cc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e5ce:	2b00      	cmp	r3, #0
 801e5d0:	d107      	bne.n	801e5e2 <__year_to_secs+0x10a>
		*is_leap = 1;
 801e5d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e5d4:	2201      	movs	r2, #1
 801e5d6:	601a      	str	r2, [r3, #0]
		centuries = 0;
 801e5d8:	2300      	movs	r3, #0
 801e5da:	63fb      	str	r3, [r7, #60]	; 0x3c
		leaps = 0;
 801e5dc:	2300      	movs	r3, #0
 801e5de:	643b      	str	r3, [r7, #64]	; 0x40
 801e5e0:	e037      	b.n	801e652 <__year_to_secs+0x17a>
	} else {
		if (rem >= 200) {
 801e5e2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e5e4:	2bc7      	cmp	r3, #199	; 0xc7
 801e5e6:	dd10      	ble.n	801e60a <__year_to_secs+0x132>
			if (rem >= 300) centuries = 3, rem -= 300;
 801e5e8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e5ea:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 801e5ee:	db06      	blt.n	801e5fe <__year_to_secs+0x126>
 801e5f0:	2303      	movs	r3, #3
 801e5f2:	63fb      	str	r3, [r7, #60]	; 0x3c
 801e5f4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e5f6:	f5a3 7396 	sub.w	r3, r3, #300	; 0x12c
 801e5fa:	647b      	str	r3, [r7, #68]	; 0x44
 801e5fc:	e010      	b.n	801e620 <__year_to_secs+0x148>
			else centuries = 2, rem -= 200;
 801e5fe:	2302      	movs	r3, #2
 801e600:	63fb      	str	r3, [r7, #60]	; 0x3c
 801e602:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e604:	3bc8      	subs	r3, #200	; 0xc8
 801e606:	647b      	str	r3, [r7, #68]	; 0x44
 801e608:	e00a      	b.n	801e620 <__year_to_secs+0x148>
		} else {
			if (rem >= 100) centuries = 1, rem -= 100;
 801e60a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e60c:	2b63      	cmp	r3, #99	; 0x63
 801e60e:	dd05      	ble.n	801e61c <__year_to_secs+0x144>
 801e610:	2301      	movs	r3, #1
 801e612:	63fb      	str	r3, [r7, #60]	; 0x3c
 801e614:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e616:	3b64      	subs	r3, #100	; 0x64
 801e618:	647b      	str	r3, [r7, #68]	; 0x44
 801e61a:	e001      	b.n	801e620 <__year_to_secs+0x148>
			else centuries = 0;
 801e61c:	2300      	movs	r3, #0
 801e61e:	63fb      	str	r3, [r7, #60]	; 0x3c
		}
		if (!rem) {
 801e620:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e622:	2b00      	cmp	r3, #0
 801e624:	d105      	bne.n	801e632 <__year_to_secs+0x15a>
			*is_leap = 0;
 801e626:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e628:	2200      	movs	r2, #0
 801e62a:	601a      	str	r2, [r3, #0]
			leaps = 0;
 801e62c:	2300      	movs	r3, #0
 801e62e:	643b      	str	r3, [r7, #64]	; 0x40
 801e630:	e00f      	b.n	801e652 <__year_to_secs+0x17a>
		} else {
			leaps = rem / 4U;
 801e632:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e634:	089b      	lsrs	r3, r3, #2
 801e636:	643b      	str	r3, [r7, #64]	; 0x40
			rem %= 4U;
 801e638:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e63a:	f003 0303 	and.w	r3, r3, #3
 801e63e:	647b      	str	r3, [r7, #68]	; 0x44
			*is_leap = !rem;
 801e640:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801e642:	2b00      	cmp	r3, #0
 801e644:	bf0c      	ite	eq
 801e646:	2301      	moveq	r3, #1
 801e648:	2300      	movne	r3, #0
 801e64a:	b2db      	uxtb	r3, r3
 801e64c:	461a      	mov	r2, r3
 801e64e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e650:	601a      	str	r2, [r3, #0]
		}
	}

	leaps += 97*cycles + 24*centuries - *is_leap;
 801e652:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801e654:	4613      	mov	r3, r2
 801e656:	005b      	lsls	r3, r3, #1
 801e658:	4413      	add	r3, r2
 801e65a:	015b      	lsls	r3, r3, #5
 801e65c:	1899      	adds	r1, r3, r2
 801e65e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801e660:	4613      	mov	r3, r2
 801e662:	005b      	lsls	r3, r3, #1
 801e664:	4413      	add	r3, r2
 801e666:	00db      	lsls	r3, r3, #3
 801e668:	18ca      	adds	r2, r1, r3
 801e66a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e66c:	681b      	ldr	r3, [r3, #0]
 801e66e:	1ad3      	subs	r3, r2, r3
 801e670:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801e672:	4413      	add	r3, r2
 801e674:	643b      	str	r3, [r7, #64]	; 0x40

	return (year-100) * 31536000LL + leaps * 86400LL + 946684800 + 86400;
 801e676:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801e67a:	f1b2 0464 	subs.w	r4, r2, #100	; 0x64
 801e67e:	f143 35ff 	adc.w	r5, r3, #4294967295
 801e682:	4b2e      	ldr	r3, [pc, #184]	; (801e73c <__year_to_secs+0x264>)
 801e684:	fb03 f205 	mul.w	r2, r3, r5
 801e688:	2300      	movs	r3, #0
 801e68a:	fb03 f304 	mul.w	r3, r3, r4
 801e68e:	4413      	add	r3, r2
 801e690:	4a2a      	ldr	r2, [pc, #168]	; (801e73c <__year_to_secs+0x264>)
 801e692:	fba4 4502 	umull	r4, r5, r4, r2
 801e696:	442b      	add	r3, r5
 801e698:	461d      	mov	r5, r3
 801e69a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e69c:	461a      	mov	r2, r3
 801e69e:	ea4f 73e2 	mov.w	r3, r2, asr #31
 801e6a2:	4610      	mov	r0, r2
 801e6a4:	4619      	mov	r1, r3
 801e6a6:	1806      	adds	r6, r0, r0
 801e6a8:	603e      	str	r6, [r7, #0]
 801e6aa:	4149      	adcs	r1, r1
 801e6ac:	6079      	str	r1, [r7, #4]
 801e6ae:	e9d7 0100 	ldrd	r0, r1, [r7]
 801e6b2:	1880      	adds	r0, r0, r2
 801e6b4:	eb43 0101 	adc.w	r1, r3, r1
 801e6b8:	f04f 0200 	mov.w	r2, #0
 801e6bc:	f04f 0300 	mov.w	r3, #0
 801e6c0:	010b      	lsls	r3, r1, #4
 801e6c2:	ea43 7310 	orr.w	r3, r3, r0, lsr #28
 801e6c6:	0102      	lsls	r2, r0, #4
 801e6c8:	1a12      	subs	r2, r2, r0
 801e6ca:	eb63 0301 	sbc.w	r3, r3, r1
 801e6ce:	f04f 0000 	mov.w	r0, #0
 801e6d2:	f04f 0100 	mov.w	r1, #0
 801e6d6:	0119      	lsls	r1, r3, #4
 801e6d8:	ea41 7112 	orr.w	r1, r1, r2, lsr #28
 801e6dc:	0110      	lsls	r0, r2, #4
 801e6de:	1a80      	subs	r0, r0, r2
 801e6e0:	eb61 0103 	sbc.w	r1, r1, r3
 801e6e4:	f04f 0200 	mov.w	r2, #0
 801e6e8:	f04f 0300 	mov.w	r3, #0
 801e6ec:	01cb      	lsls	r3, r1, #7
 801e6ee:	ea43 6350 	orr.w	r3, r3, r0, lsr #25
 801e6f2:	01c2      	lsls	r2, r0, #7
 801e6f4:	4610      	mov	r0, r2
 801e6f6:	4619      	mov	r1, r3
 801e6f8:	4602      	mov	r2, r0
 801e6fa:	460b      	mov	r3, r1
 801e6fc:	eb14 0802 	adds.w	r8, r4, r2
 801e700:	eb45 0903 	adc.w	r9, r5, r3
 801e704:	a30a      	add	r3, pc, #40	; (adr r3, 801e730 <__year_to_secs+0x258>)
 801e706:	e9d3 2300 	ldrd	r2, r3, [r3]
 801e70a:	eb18 0a02 	adds.w	sl, r8, r2
 801e70e:	eb49 0b03 	adc.w	fp, r9, r3
 801e712:	4652      	mov	r2, sl
 801e714:	465b      	mov	r3, fp
}
 801e716:	4908      	ldr	r1, [pc, #32]	; (801e738 <__year_to_secs+0x260>)
 801e718:	6808      	ldr	r0, [r1, #0]
 801e71a:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801e71c:	4048      	eors	r0, r1
 801e71e:	d001      	beq.n	801e724 <__year_to_secs+0x24c>
 801e720:	f7e5 ff5c 	bl	80045dc <__stack_chk_fail>
 801e724:	4610      	mov	r0, r2
 801e726:	4619      	mov	r1, r3
 801e728:	3754      	adds	r7, #84	; 0x54
 801e72a:	46bd      	mov	sp, r7
 801e72c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801e730:	386e9500 	.word	0x386e9500
 801e734:	00000000 	.word	0x00000000
 801e738:	080231d8 	.word	0x080231d8
 801e73c:	01e13380 	.word	0x01e13380
 801e740:	00015180 	.word	0x00015180

0801e744 <__asctime_r>:
#include <langinfo.h>
#include "locale_impl.h"
#include "atomic.h"

char *__asctime_r(const struct tm *restrict tm, char *restrict buf)
{
 801e744:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e746:	b089      	sub	sp, #36	; 0x24
 801e748:	af06      	add	r7, sp, #24
 801e74a:	6078      	str	r0, [r7, #4]
 801e74c:	6039      	str	r1, [r7, #0]
	if (snprintf(buf, 26, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
		__nl_langinfo_l(ABDAY_1+tm->tm_wday, C_LOCALE),
 801e74e:	687b      	ldr	r3, [r7, #4]
 801e750:	699b      	ldr	r3, [r3, #24]
	if (snprintf(buf, 26, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
 801e752:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 801e756:	491a      	ldr	r1, [pc, #104]	; (801e7c0 <__asctime_r+0x7c>)
 801e758:	4618      	mov	r0, r3
 801e75a:	f7fc f8e5 	bl	801a928 <__nl_langinfo_l>
 801e75e:	4606      	mov	r6, r0
		__nl_langinfo_l(ABMON_1+tm->tm_mon, C_LOCALE),
 801e760:	687b      	ldr	r3, [r7, #4]
 801e762:	691a      	ldr	r2, [r3, #16]
	if (snprintf(buf, 26, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
 801e764:	4b17      	ldr	r3, [pc, #92]	; (801e7c4 <__asctime_r+0x80>)
 801e766:	4413      	add	r3, r2
 801e768:	4915      	ldr	r1, [pc, #84]	; (801e7c0 <__asctime_r+0x7c>)
 801e76a:	4618      	mov	r0, r3
 801e76c:	f7fc f8dc 	bl	801a928 <__nl_langinfo_l>
 801e770:	4605      	mov	r5, r0
 801e772:	687b      	ldr	r3, [r7, #4]
 801e774:	68db      	ldr	r3, [r3, #12]
 801e776:	687a      	ldr	r2, [r7, #4]
 801e778:	6892      	ldr	r2, [r2, #8]
 801e77a:	6879      	ldr	r1, [r7, #4]
 801e77c:	6849      	ldr	r1, [r1, #4]
 801e77e:	6878      	ldr	r0, [r7, #4]
 801e780:	6800      	ldr	r0, [r0, #0]
		tm->tm_mday, tm->tm_hour,
		tm->tm_min, tm->tm_sec,
		1900 + tm->tm_year) >= 26)
 801e782:	687c      	ldr	r4, [r7, #4]
 801e784:	6964      	ldr	r4, [r4, #20]
	if (snprintf(buf, 26, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
 801e786:	f204 746c 	addw	r4, r4, #1900	; 0x76c
 801e78a:	9405      	str	r4, [sp, #20]
 801e78c:	9004      	str	r0, [sp, #16]
 801e78e:	9103      	str	r1, [sp, #12]
 801e790:	9202      	str	r2, [sp, #8]
 801e792:	9301      	str	r3, [sp, #4]
 801e794:	9500      	str	r5, [sp, #0]
 801e796:	4633      	mov	r3, r6
 801e798:	4a0b      	ldr	r2, [pc, #44]	; (801e7c8 <__asctime_r+0x84>)
 801e79a:	211a      	movs	r1, #26
 801e79c:	6838      	ldr	r0, [r7, #0]
 801e79e:	f7fc f959 	bl	801aa54 <snprintf>
 801e7a2:	4603      	mov	r3, r0
 801e7a4:	2b19      	cmp	r3, #25
 801e7a6:	dd06      	ble.n	801e7b6 <__asctime_r+0x72>
		 * on other implementations (e.g. stack smashing..).
		 */
#ifndef __LITEOS__
		a_crash();
#else
		errno = EOVERFLOW;
 801e7a8:	f7f1 fbf6 	bl	800ff98 <__errno_location>
 801e7ac:	4603      	mov	r3, r0
 801e7ae:	224b      	movs	r2, #75	; 0x4b
 801e7b0:	601a      	str	r2, [r3, #0]
		return NULL;
 801e7b2:	2300      	movs	r3, #0
 801e7b4:	e000      	b.n	801e7b8 <__asctime_r+0x74>
#endif
	}
	return buf;
 801e7b6:	683b      	ldr	r3, [r7, #0]
}
 801e7b8:	4618      	mov	r0, r3
 801e7ba:	370c      	adds	r7, #12
 801e7bc:	46bd      	mov	sp, r7
 801e7be:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801e7c0:	080242d4 	.word	0x080242d4
 801e7c4:	0002000e 	.word	0x0002000e
 801e7c8:	080231dc 	.word	0x080231dc

0801e7cc <tolower>:
#include <ctype.h>

int tolower(int c)
{
 801e7cc:	b480      	push	{r7}
 801e7ce:	b083      	sub	sp, #12
 801e7d0:	af00      	add	r7, sp, #0
 801e7d2:	6078      	str	r0, [r7, #4]
	if (isupper(c)) return c | 32;
 801e7d4:	687b      	ldr	r3, [r7, #4]
 801e7d6:	3b41      	subs	r3, #65	; 0x41
 801e7d8:	2b19      	cmp	r3, #25
 801e7da:	d803      	bhi.n	801e7e4 <tolower+0x18>
 801e7dc:	687b      	ldr	r3, [r7, #4]
 801e7de:	f043 0320 	orr.w	r3, r3, #32
 801e7e2:	e000      	b.n	801e7e6 <tolower+0x1a>
	return c;
 801e7e4:	687b      	ldr	r3, [r7, #4]
}
 801e7e6:	4618      	mov	r0, r3
 801e7e8:	370c      	adds	r7, #12
 801e7ea:	46bd      	mov	sp, r7
 801e7ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e7f0:	4770      	bx	lr

0801e7f2 <StringToDigital>:
    }
    return TRUE;
}

STATIC INLINE INT32 StringToDigital(CHAR high, CHAR low)
{
 801e7f2:	b480      	push	{r7}
 801e7f4:	b083      	sub	sp, #12
 801e7f6:	af00      	add	r7, sp, #0
 801e7f8:	4603      	mov	r3, r0
 801e7fa:	460a      	mov	r2, r1
 801e7fc:	71fb      	strb	r3, [r7, #7]
 801e7fe:	4613      	mov	r3, r2
 801e800:	71bb      	strb	r3, [r7, #6]
    /* 10: decimal base number */
    return ((high - '0') * 10) + (low - '0');
 801e802:	79fb      	ldrb	r3, [r7, #7]
 801e804:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 801e808:	4613      	mov	r3, r2
 801e80a:	009b      	lsls	r3, r3, #2
 801e80c:	4413      	add	r3, r2
 801e80e:	005b      	lsls	r3, r3, #1
 801e810:	461a      	mov	r2, r3
 801e812:	79bb      	ldrb	r3, [r7, #6]
 801e814:	3b30      	subs	r3, #48	; 0x30
 801e816:	4413      	add	r3, r2
}
 801e818:	4618      	mov	r0, r3
 801e81a:	370c      	adds	r7, #12
 801e81c:	46bd      	mov	sp, r7
 801e81e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e822:	4770      	bx	lr

0801e824 <DstForwardSecondGet>:
INT32 g_dstForwardSeconds = 0;
STATIC CHAR g_strDstStart[DST_SET_LENGTH_MAX] = {0};
STATIC CHAR g_strDstEnd[DST_SET_LENGTH_MAX] = {0};

INT32 DstForwardSecondGet(VOID)
{
 801e824:	b480      	push	{r7}
 801e826:	af00      	add	r7, sp, #0
    return g_dstForwardSeconds;
 801e828:	4b03      	ldr	r3, [pc, #12]	; (801e838 <DstForwardSecondGet+0x14>)
 801e82a:	681b      	ldr	r3, [r3, #0]
}
 801e82c:	4618      	mov	r0, r3
 801e82e:	46bd      	mov	sp, r7
 801e830:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e834:	4770      	bx	lr
 801e836:	bf00      	nop
 801e838:	20003464 	.word	0x20003464

0801e83c <GetMonthFromString>:

STATIC INT32 GetMonthFromString(const CHAR *strMonth)
{
 801e83c:	b580      	push	{r7, lr}
 801e83e:	b084      	sub	sp, #16
 801e840:	af00      	add	r7, sp, #0
 801e842:	6078      	str	r0, [r7, #4]
    UINT32 index;
    for (index = 0; index < sizeof(g_strMonth) / sizeof(CHAR *); index++) {
 801e844:	2300      	movs	r3, #0
 801e846:	60fb      	str	r3, [r7, #12]
 801e848:	e010      	b.n	801e86c <GetMonthFromString+0x30>
        if (strncmp(strMonth, g_strMonth[index], MONTH_NAME_LEN) == 0) {
 801e84a:	4a0d      	ldr	r2, [pc, #52]	; (801e880 <GetMonthFromString+0x44>)
 801e84c:	68fb      	ldr	r3, [r7, #12]
 801e84e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e852:	2203      	movs	r2, #3
 801e854:	4619      	mov	r1, r3
 801e856:	6878      	ldr	r0, [r7, #4]
 801e858:	f7fa fefc 	bl	8019654 <strncmp>
 801e85c:	4603      	mov	r3, r0
 801e85e:	2b00      	cmp	r3, #0
 801e860:	d101      	bne.n	801e866 <GetMonthFromString+0x2a>
            /* A legal month is from 0 to 11. */
            return (int)index;
 801e862:	68fb      	ldr	r3, [r7, #12]
 801e864:	e007      	b.n	801e876 <GetMonthFromString+0x3a>
    for (index = 0; index < sizeof(g_strMonth) / sizeof(CHAR *); index++) {
 801e866:	68fb      	ldr	r3, [r7, #12]
 801e868:	3301      	adds	r3, #1
 801e86a:	60fb      	str	r3, [r7, #12]
 801e86c:	68fb      	ldr	r3, [r7, #12]
 801e86e:	2b0b      	cmp	r3, #11
 801e870:	d9eb      	bls.n	801e84a <GetMonthFromString+0xe>
        }
    }

    return -1;
 801e872:	f04f 33ff 	mov.w	r3, #4294967295
}
 801e876:	4618      	mov	r0, r3
 801e878:	3710      	adds	r7, #16
 801e87a:	46bd      	mov	sp, r7
 801e87c:	bd80      	pop	{r7, pc}
 801e87e:	bf00      	nop
 801e880:	20000574 	.word	0x20000574

0801e884 <GetWeekDayFromString>:

STATIC INT32 GetWeekDayFromString(const CHAR *strWeekDay)
{
 801e884:	b580      	push	{r7, lr}
 801e886:	b084      	sub	sp, #16
 801e888:	af00      	add	r7, sp, #0
 801e88a:	6078      	str	r0, [r7, #4]
    UINT32 index;
    for (index = 0; index < sizeof(g_strWeekDay) / sizeof(CHAR *); index++) {
 801e88c:	2300      	movs	r3, #0
 801e88e:	60fb      	str	r3, [r7, #12]
 801e890:	e010      	b.n	801e8b4 <GetWeekDayFromString+0x30>
        if (strncmp(strWeekDay, g_strWeekDay[index], MONTH_NAME_LEN) == 0) {
 801e892:	4a0d      	ldr	r2, [pc, #52]	; (801e8c8 <GetWeekDayFromString+0x44>)
 801e894:	68fb      	ldr	r3, [r7, #12]
 801e896:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e89a:	2203      	movs	r2, #3
 801e89c:	4619      	mov	r1, r3
 801e89e:	6878      	ldr	r0, [r7, #4]
 801e8a0:	f7fa fed8 	bl	8019654 <strncmp>
 801e8a4:	4603      	mov	r3, r0
 801e8a6:	2b00      	cmp	r3, #0
 801e8a8:	d101      	bne.n	801e8ae <GetWeekDayFromString+0x2a>
            /* Day of the week (0-6, Sunday = 0) */
            return (INT32)index;
 801e8aa:	68fb      	ldr	r3, [r7, #12]
 801e8ac:	e007      	b.n	801e8be <GetWeekDayFromString+0x3a>
    for (index = 0; index < sizeof(g_strWeekDay) / sizeof(CHAR *); index++) {
 801e8ae:	68fb      	ldr	r3, [r7, #12]
 801e8b0:	3301      	adds	r3, #1
 801e8b2:	60fb      	str	r3, [r7, #12]
 801e8b4:	68fb      	ldr	r3, [r7, #12]
 801e8b6:	2b06      	cmp	r3, #6
 801e8b8:	d9eb      	bls.n	801e892 <GetWeekDayFromString+0xe>
        }
    }

    return -1;
 801e8ba:	f04f 33ff 	mov.w	r3, #4294967295
}
 801e8be:	4618      	mov	r0, r3
 801e8c0:	3710      	adds	r7, #16
 801e8c2:	46bd      	mov	sp, r7
 801e8c4:	bd80      	pop	{r7, pc}
 801e8c6:	bf00      	nop
 801e8c8:	200005b8 	.word	0x200005b8

0801e8cc <GetMonthWeekFromString>:

STATIC INT32 GetMonthWeekFromString(const CHAR *strMonthWeek)
{
 801e8cc:	b580      	push	{r7, lr}
 801e8ce:	b084      	sub	sp, #16
 801e8d0:	af00      	add	r7, sp, #0
 801e8d2:	6078      	str	r0, [r7, #4]
    UINT32 index;
    for (index = 0; index < sizeof(g_strMonthWeek) / sizeof(CHAR *); index++) {
 801e8d4:	2300      	movs	r3, #0
 801e8d6:	60fb      	str	r3, [r7, #12]
 801e8d8:	e011      	b.n	801e8fe <GetMonthWeekFromString+0x32>
        if (strncmp(strMonthWeek, g_strMonthWeek[index], MONTH_NAME_LEN) == 0) {
 801e8da:	4a0d      	ldr	r2, [pc, #52]	; (801e910 <GetMonthWeekFromString+0x44>)
 801e8dc:	68fb      	ldr	r3, [r7, #12]
 801e8de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e8e2:	2203      	movs	r2, #3
 801e8e4:	4619      	mov	r1, r3
 801e8e6:	6878      	ldr	r0, [r7, #4]
 801e8e8:	f7fa feb4 	bl	8019654 <strncmp>
 801e8ec:	4603      	mov	r3, r0
 801e8ee:	2b00      	cmp	r3, #0
 801e8f0:	d102      	bne.n	801e8f8 <GetMonthWeekFromString+0x2c>
            /* Month of the week (1-5) */
            return (INT32)(index + 1);
 801e8f2:	68fb      	ldr	r3, [r7, #12]
 801e8f4:	3301      	adds	r3, #1
 801e8f6:	e007      	b.n	801e908 <GetMonthWeekFromString+0x3c>
    for (index = 0; index < sizeof(g_strMonthWeek) / sizeof(CHAR *); index++) {
 801e8f8:	68fb      	ldr	r3, [r7, #12]
 801e8fa:	3301      	adds	r3, #1
 801e8fc:	60fb      	str	r3, [r7, #12]
 801e8fe:	68fb      	ldr	r3, [r7, #12]
 801e900:	2b04      	cmp	r3, #4
 801e902:	d9ea      	bls.n	801e8da <GetMonthWeekFromString+0xe>
        }
    }

    return -1;
 801e904:	f04f 33ff 	mov.w	r3, #4294967295
}
 801e908:	4618      	mov	r0, r3
 801e90a:	3710      	adds	r7, #16
 801e90c:	46bd      	mov	sp, r7
 801e90e:	bd80      	pop	{r7, pc}
 801e910:	200005a4 	.word	0x200005a4

0801e914 <CheckTimeVaild>:

STATIC INLINE INT32 CheckTimeVaild(const CHAR *strTimeString)
{
 801e914:	b480      	push	{r7}
 801e916:	b083      	sub	sp, #12
 801e918:	af00      	add	r7, sp, #0
 801e91a:	6078      	str	r0, [r7, #4]
    if (((strTimeString[0] < '0') || (strTimeString[0] > '9')) ||
 801e91c:	687b      	ldr	r3, [r7, #4]
 801e91e:	781b      	ldrb	r3, [r3, #0]
 801e920:	2b2f      	cmp	r3, #47	; 0x2f
 801e922:	d90d      	bls.n	801e940 <CheckTimeVaild+0x2c>
 801e924:	687b      	ldr	r3, [r7, #4]
 801e926:	781b      	ldrb	r3, [r3, #0]
 801e928:	2b39      	cmp	r3, #57	; 0x39
 801e92a:	d809      	bhi.n	801e940 <CheckTimeVaild+0x2c>
        ((strTimeString[1] < '0') || (strTimeString[1] > '9'))) {
 801e92c:	687b      	ldr	r3, [r7, #4]
 801e92e:	3301      	adds	r3, #1
 801e930:	781b      	ldrb	r3, [r3, #0]
    if (((strTimeString[0] < '0') || (strTimeString[0] > '9')) ||
 801e932:	2b2f      	cmp	r3, #47	; 0x2f
 801e934:	d904      	bls.n	801e940 <CheckTimeVaild+0x2c>
        ((strTimeString[1] < '0') || (strTimeString[1] > '9'))) {
 801e936:	687b      	ldr	r3, [r7, #4]
 801e938:	3301      	adds	r3, #1
 801e93a:	781b      	ldrb	r3, [r3, #0]
 801e93c:	2b39      	cmp	r3, #57	; 0x39
 801e93e:	d902      	bls.n	801e946 <CheckTimeVaild+0x32>
        return -1;
 801e940:	f04f 33ff 	mov.w	r3, #4294967295
 801e944:	e000      	b.n	801e948 <CheckTimeVaild+0x34>
    }
    return 0;
 801e946:	2300      	movs	r3, #0
}
 801e948:	4618      	mov	r0, r3
 801e94a:	370c      	adds	r7, #12
 801e94c:	46bd      	mov	sp, r7
 801e94e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e952:	4770      	bx	lr

0801e954 <GetMonthDayFromString>:

/* Day of the month 1 ~ 31 */
STATIC INT32 GetMonthDayFromString(INT32 month, const CHAR *strMonDay)
{
 801e954:	b580      	push	{r7, lr}
 801e956:	b084      	sub	sp, #16
 801e958:	af00      	add	r7, sp, #0
 801e95a:	6078      	str	r0, [r7, #4]
 801e95c:	6039      	str	r1, [r7, #0]
    INT32 monDay;

    if (CheckTimeVaild(strMonDay)) {
 801e95e:	6838      	ldr	r0, [r7, #0]
 801e960:	f7ff ffd8 	bl	801e914 <CheckTimeVaild>
 801e964:	4603      	mov	r3, r0
 801e966:	2b00      	cmp	r3, #0
 801e968:	d002      	beq.n	801e970 <GetMonthDayFromString+0x1c>
        return -1;
 801e96a:	f04f 33ff 	mov.w	r3, #4294967295
 801e96e:	e023      	b.n	801e9b8 <GetMonthDayFromString+0x64>
    }

    monDay = StringToDigital(strMonDay[0], strMonDay[1]);
 801e970:	683b      	ldr	r3, [r7, #0]
 801e972:	781a      	ldrb	r2, [r3, #0]
 801e974:	683b      	ldr	r3, [r7, #0]
 801e976:	3301      	adds	r3, #1
 801e978:	781b      	ldrb	r3, [r3, #0]
 801e97a:	4619      	mov	r1, r3
 801e97c:	4610      	mov	r0, r2
 801e97e:	f7ff ff38 	bl	801e7f2 <StringToDigital>
 801e982:	60f8      	str	r0, [r7, #12]
    if (monDay > 31) {
 801e984:	68fb      	ldr	r3, [r7, #12]
 801e986:	2b1f      	cmp	r3, #31
 801e988:	dd02      	ble.n	801e990 <GetMonthDayFromString+0x3c>
        return -1;
 801e98a:	f04f 33ff 	mov.w	r3, #4294967295
 801e98e:	e013      	b.n	801e9b8 <GetMonthDayFromString+0x64>
    }

    /* Not every year have 29 days in Feb when set DST. */
    if ((monDay == 29) && ((month + 1) == 2)) {
 801e990:	68fb      	ldr	r3, [r7, #12]
 801e992:	2b1d      	cmp	r3, #29
 801e994:	d105      	bne.n	801e9a2 <GetMonthDayFromString+0x4e>
 801e996:	687b      	ldr	r3, [r7, #4]
 801e998:	2b01      	cmp	r3, #1
 801e99a:	d102      	bne.n	801e9a2 <GetMonthDayFromString+0x4e>
        return -1;
 801e99c:	f04f 33ff 	mov.w	r3, #4294967295
 801e9a0:	e00a      	b.n	801e9b8 <GetMonthDayFromString+0x64>
    }

    if (monDay > g_monLengths[0][month]) {
 801e9a2:	4a07      	ldr	r2, [pc, #28]	; (801e9c0 <GetMonthDayFromString+0x6c>)
 801e9a4:	687b      	ldr	r3, [r7, #4]
 801e9a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e9aa:	68fa      	ldr	r2, [r7, #12]
 801e9ac:	429a      	cmp	r2, r3
 801e9ae:	dd02      	ble.n	801e9b6 <GetMonthDayFromString+0x62>
        return -1;
 801e9b0:	f04f 33ff 	mov.w	r3, #4294967295
 801e9b4:	e000      	b.n	801e9b8 <GetMonthDayFromString+0x64>
    }

    /* Day of the month (1-31) */
    return monDay;
 801e9b6:	68fb      	ldr	r3, [r7, #12]
}
 801e9b8:	4618      	mov	r0, r3
 801e9ba:	3710      	adds	r7, #16
 801e9bc:	46bd      	mov	sp, r7
 801e9be:	bd80      	pop	{r7, pc}
 801e9c0:	080242ec 	.word	0x080242ec

0801e9c4 <GetDaySecondsFromString>:
 * 0~23 for hours per day
 * 0~59 for minutes per hour
 * 0~59 for seconds per minute
 */
STATIC INT32 GetDaySecondsFromString(const CHAR *strTimeString)
{
 801e9c4:	b580      	push	{r7, lr}
 801e9c6:	b086      	sub	sp, #24
 801e9c8:	af00      	add	r7, sp, #0
 801e9ca:	6078      	str	r0, [r7, #4]
    INT32 hour, min, sec;

    if (CheckTimeVaild(strTimeString)) {
 801e9cc:	6878      	ldr	r0, [r7, #4]
 801e9ce:	f7ff ffa1 	bl	801e914 <CheckTimeVaild>
 801e9d2:	4603      	mov	r3, r0
 801e9d4:	2b00      	cmp	r3, #0
 801e9d6:	d002      	beq.n	801e9de <GetDaySecondsFromString+0x1a>
        return -1;
 801e9d8:	f04f 33ff 	mov.w	r3, #4294967295
 801e9dc:	e06a      	b.n	801eab4 <GetDaySecondsFromString+0xf0>
    }

    if (CheckTimeVaild(strTimeString + 3)) {
 801e9de:	687b      	ldr	r3, [r7, #4]
 801e9e0:	3303      	adds	r3, #3
 801e9e2:	4618      	mov	r0, r3
 801e9e4:	f7ff ff96 	bl	801e914 <CheckTimeVaild>
 801e9e8:	4603      	mov	r3, r0
 801e9ea:	2b00      	cmp	r3, #0
 801e9ec:	d002      	beq.n	801e9f4 <GetDaySecondsFromString+0x30>
        return -1;
 801e9ee:	f04f 33ff 	mov.w	r3, #4294967295
 801e9f2:	e05f      	b.n	801eab4 <GetDaySecondsFromString+0xf0>
    }

    if (CheckTimeVaild(strTimeString + 6)) {
 801e9f4:	687b      	ldr	r3, [r7, #4]
 801e9f6:	3306      	adds	r3, #6
 801e9f8:	4618      	mov	r0, r3
 801e9fa:	f7ff ff8b 	bl	801e914 <CheckTimeVaild>
 801e9fe:	4603      	mov	r3, r0
 801ea00:	2b00      	cmp	r3, #0
 801ea02:	d002      	beq.n	801ea0a <GetDaySecondsFromString+0x46>
        return -1;
 801ea04:	f04f 33ff 	mov.w	r3, #4294967295
 801ea08:	e054      	b.n	801eab4 <GetDaySecondsFromString+0xf0>
    }

    if ((strTimeString[2] != ':') || (strTimeString[5] != ':')) {
 801ea0a:	687b      	ldr	r3, [r7, #4]
 801ea0c:	3302      	adds	r3, #2
 801ea0e:	781b      	ldrb	r3, [r3, #0]
 801ea10:	2b3a      	cmp	r3, #58	; 0x3a
 801ea12:	d104      	bne.n	801ea1e <GetDaySecondsFromString+0x5a>
 801ea14:	687b      	ldr	r3, [r7, #4]
 801ea16:	3305      	adds	r3, #5
 801ea18:	781b      	ldrb	r3, [r3, #0]
 801ea1a:	2b3a      	cmp	r3, #58	; 0x3a
 801ea1c:	d002      	beq.n	801ea24 <GetDaySecondsFromString+0x60>
        return -1;
 801ea1e:	f04f 33ff 	mov.w	r3, #4294967295
 801ea22:	e047      	b.n	801eab4 <GetDaySecondsFromString+0xf0>
    }

    hour = StringToDigital(strTimeString[0], strTimeString[1]);
 801ea24:	687b      	ldr	r3, [r7, #4]
 801ea26:	781a      	ldrb	r2, [r3, #0]
 801ea28:	687b      	ldr	r3, [r7, #4]
 801ea2a:	3301      	adds	r3, #1
 801ea2c:	781b      	ldrb	r3, [r3, #0]
 801ea2e:	4619      	mov	r1, r3
 801ea30:	4610      	mov	r0, r2
 801ea32:	f7ff fede 	bl	801e7f2 <StringToDigital>
 801ea36:	60f8      	str	r0, [r7, #12]
    min = StringToDigital(strTimeString[3], strTimeString[4]);
 801ea38:	687b      	ldr	r3, [r7, #4]
 801ea3a:	3303      	adds	r3, #3
 801ea3c:	781a      	ldrb	r2, [r3, #0]
 801ea3e:	687b      	ldr	r3, [r7, #4]
 801ea40:	3304      	adds	r3, #4
 801ea42:	781b      	ldrb	r3, [r3, #0]
 801ea44:	4619      	mov	r1, r3
 801ea46:	4610      	mov	r0, r2
 801ea48:	f7ff fed3 	bl	801e7f2 <StringToDigital>
 801ea4c:	6138      	str	r0, [r7, #16]
    sec = StringToDigital(strTimeString[6], strTimeString[7]);
 801ea4e:	687b      	ldr	r3, [r7, #4]
 801ea50:	3306      	adds	r3, #6
 801ea52:	781a      	ldrb	r2, [r3, #0]
 801ea54:	687b      	ldr	r3, [r7, #4]
 801ea56:	3307      	adds	r3, #7
 801ea58:	781b      	ldrb	r3, [r3, #0]
 801ea5a:	4619      	mov	r1, r3
 801ea5c:	4610      	mov	r0, r2
 801ea5e:	f7ff fec8 	bl	801e7f2 <StringToDigital>
 801ea62:	6178      	str	r0, [r7, #20]
    /* Hours (0-23) */
    if ((hour < 0) || (hour > 23)) {
 801ea64:	68fb      	ldr	r3, [r7, #12]
 801ea66:	2b00      	cmp	r3, #0
 801ea68:	db02      	blt.n	801ea70 <GetDaySecondsFromString+0xac>
 801ea6a:	68fb      	ldr	r3, [r7, #12]
 801ea6c:	2b17      	cmp	r3, #23
 801ea6e:	dd02      	ble.n	801ea76 <GetDaySecondsFromString+0xb2>
        return -1;
 801ea70:	f04f 33ff 	mov.w	r3, #4294967295
 801ea74:	e01e      	b.n	801eab4 <GetDaySecondsFromString+0xf0>
    }

    /* Minutes (0-59) */
    if ((min < 0) || (min > 59)) {
 801ea76:	693b      	ldr	r3, [r7, #16]
 801ea78:	2b00      	cmp	r3, #0
 801ea7a:	db02      	blt.n	801ea82 <GetDaySecondsFromString+0xbe>
 801ea7c:	693b      	ldr	r3, [r7, #16]
 801ea7e:	2b3b      	cmp	r3, #59	; 0x3b
 801ea80:	dd02      	ble.n	801ea88 <GetDaySecondsFromString+0xc4>
        return -1;
 801ea82:	f04f 33ff 	mov.w	r3, #4294967295
 801ea86:	e015      	b.n	801eab4 <GetDaySecondsFromString+0xf0>
    }

    /* Seconds (0-59), not consider of the leap seconds in DST. */
    if ((sec < 0) || (sec > 59)) {
 801ea88:	697b      	ldr	r3, [r7, #20]
 801ea8a:	2b00      	cmp	r3, #0
 801ea8c:	db02      	blt.n	801ea94 <GetDaySecondsFromString+0xd0>
 801ea8e:	697b      	ldr	r3, [r7, #20]
 801ea90:	2b3b      	cmp	r3, #59	; 0x3b
 801ea92:	dd02      	ble.n	801ea9a <GetDaySecondsFromString+0xd6>
        return -1;
 801ea94:	f04f 33ff 	mov.w	r3, #4294967295
 801ea98:	e00c      	b.n	801eab4 <GetDaySecondsFromString+0xf0>
    }

    return hour * 3600 + min * 60 + sec;
 801ea9a:	68fb      	ldr	r3, [r7, #12]
 801ea9c:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 801eaa0:	fb02 f103 	mul.w	r1, r2, r3
 801eaa4:	693a      	ldr	r2, [r7, #16]
 801eaa6:	4613      	mov	r3, r2
 801eaa8:	011b      	lsls	r3, r3, #4
 801eaaa:	1a9b      	subs	r3, r3, r2
 801eaac:	009b      	lsls	r3, r3, #2
 801eaae:	18ca      	adds	r2, r1, r3
 801eab0:	697b      	ldr	r3, [r7, #20]
 801eab2:	4413      	add	r3, r2
}
 801eab4:	4618      	mov	r0, r3
 801eab6:	3718      	adds	r7, #24
 801eab8:	46bd      	mov	sp, r7
 801eaba:	bd80      	pop	{r7, pc}

0801eabc <DstGetDayOfMonth>:

STATIC INT32 DstGetDayOfMonth(INT32 year, INT32 month, INT32 mweek, INT32 wday)
{
 801eabc:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801eac0:	b098      	sub	sp, #96	; 0x60
 801eac2:	af00      	add	r7, sp, #0
 801eac4:	60f8      	str	r0, [r7, #12]
 801eac6:	60b9      	str	r1, [r7, #8]
 801eac8:	607a      	str	r2, [r7, #4]
 801eaca:	603b      	str	r3, [r7, #0]
 801eacc:	4b64      	ldr	r3, [pc, #400]	; (801ec60 <DstGetDayOfMonth+0x1a4>)
 801eace:	681b      	ldr	r3, [r3, #0]
 801ead0:	65fb      	str	r3, [r7, #92]	; 0x5c
 801ead2:	f04f 0300 	mov.w	r3, #0
#define FIRST_DAY 4   /* the first day of 1970.1.1 is Thursday. */
    INT32 firstWeekDay; /* First week day in this month of the specified year. */
    INT32 firstMdayOfTargetWday; /* First target month day in this month of the specified year. */
    INT32 targetMdayOfTargetWday; /* The target month day specified by user. */
    struct tm time = {0};
 801ead6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801eada:	222c      	movs	r2, #44	; 0x2c
 801eadc:	2100      	movs	r1, #0
 801eade:	4618      	mov	r0, r3
 801eae0:	f7f0 fc12 	bl	800f308 <memset>
    INT64 seconds, days;

    time.tm_year = year;
 801eae4:	68fb      	ldr	r3, [r7, #12]
 801eae6:	647b      	str	r3, [r7, #68]	; 0x44
    time.tm_mon = month;
 801eae8:	68bb      	ldr	r3, [r7, #8]
 801eaea:	643b      	str	r3, [r7, #64]	; 0x40
    time.tm_mday = 1;
 801eaec:	2301      	movs	r3, #1
 801eaee:	63fb      	str	r3, [r7, #60]	; 0x3c
    /* 14: Hour-value range is [0,23] */
    time.tm_hour = 14;
 801eaf0:	230e      	movs	r3, #14
 801eaf2:	63bb      	str	r3, [r7, #56]	; 0x38
    time.tm_isdst = 0;
 801eaf4:	2300      	movs	r3, #0
 801eaf6:	653b      	str	r3, [r7, #80]	; 0x50
#ifdef LOSCFG_AARCH64
    seconds = mktime(&time);
#else
    seconds = mktime64(&time);
 801eaf8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801eafc:	4618      	mov	r0, r3
 801eafe:	f7ff f8df 	bl	801dcc0 <mktime64>
 801eb02:	e9c7 0108 	strd	r0, r1, [r7, #32]
#endif
    if (seconds == -1) {
 801eb06:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801eb0a:	f1b3 3fff 	cmp.w	r3, #4294967295
 801eb0e:	bf08      	it	eq
 801eb10:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 801eb14:	d102      	bne.n	801eb1c <DstGetDayOfMonth+0x60>
        return -1;
 801eb16:	f04f 33ff 	mov.w	r3, #4294967295
 801eb1a:	e095      	b.n	801ec48 <DstGetDayOfMonth+0x18c>
    }
    days = seconds / SECSPERDAY;
 801eb1c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801eb20:	4a50      	ldr	r2, [pc, #320]	; (801ec64 <DstGetDayOfMonth+0x1a8>)
 801eb22:	f04f 0300 	mov.w	r3, #0
 801eb26:	f7e2 fad1 	bl	80010cc <__aeabi_ldivmod>
 801eb2a:	4602      	mov	r2, r0
 801eb2c:	460b      	mov	r3, r1
 801eb2e:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
    if (days < 0) {
 801eb32:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801eb36:	2a00      	cmp	r2, #0
 801eb38:	f173 0300 	sbcs.w	r3, r3, #0
 801eb3c:	da19      	bge.n	801eb72 <DstGetDayOfMonth+0xb6>
        days = -days;
 801eb3e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801eb42:	4252      	negs	r2, r2
 801eb44:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 801eb48:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
        firstWeekDay = DAYSPERWEEK - (days - (DAYSPERWEEK - FIRST_DAY)) % DAYSPERWEEK;
 801eb4c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801eb50:	f1b2 0803 	subs.w	r8, r2, #3
 801eb54:	f143 39ff 	adc.w	r9, r3, #4294967295
 801eb58:	f04f 0207 	mov.w	r2, #7
 801eb5c:	f04f 0300 	mov.w	r3, #0
 801eb60:	4640      	mov	r0, r8
 801eb62:	4649      	mov	r1, r9
 801eb64:	f7e2 fab2 	bl	80010cc <__aeabi_ldivmod>
 801eb68:	4613      	mov	r3, r2
 801eb6a:	f1c3 0307 	rsb	r3, r3, #7
 801eb6e:	617b      	str	r3, [r7, #20]
 801eb70:	e018      	b.n	801eba4 <DstGetDayOfMonth+0xe8>
    } else {
        if (days > FIRST_DAY) {
 801eb72:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801eb76:	2a05      	cmp	r2, #5
 801eb78:	f173 0300 	sbcs.w	r3, r3, #0
 801eb7c:	db10      	blt.n	801eba0 <DstGetDayOfMonth+0xe4>
            firstWeekDay = 1 + (days - FIRST_DAY) % DAYSPERWEEK;
 801eb7e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801eb82:	1f14      	subs	r4, r2, #4
 801eb84:	f143 35ff 	adc.w	r5, r3, #4294967295
 801eb88:	f04f 0207 	mov.w	r2, #7
 801eb8c:	f04f 0300 	mov.w	r3, #0
 801eb90:	4620      	mov	r0, r4
 801eb92:	4629      	mov	r1, r5
 801eb94:	f7e2 fa9a 	bl	80010cc <__aeabi_ldivmod>
 801eb98:	4613      	mov	r3, r2
 801eb9a:	3301      	adds	r3, #1
 801eb9c:	617b      	str	r3, [r7, #20]
 801eb9e:	e001      	b.n	801eba4 <DstGetDayOfMonth+0xe8>
        } else {
            firstWeekDay = FIRST_DAY;
 801eba0:	2304      	movs	r3, #4
 801eba2:	617b      	str	r3, [r7, #20]
        }
    }

    firstMdayOfTargetWday = 1 + (DAYSPERWEEK + wday - firstWeekDay) % DAYSPERWEEK;
 801eba4:	683b      	ldr	r3, [r7, #0]
 801eba6:	1dda      	adds	r2, r3, #7
 801eba8:	697b      	ldr	r3, [r7, #20]
 801ebaa:	1ad2      	subs	r2, r2, r3
 801ebac:	4b2e      	ldr	r3, [pc, #184]	; (801ec68 <DstGetDayOfMonth+0x1ac>)
 801ebae:	fb83 1302 	smull	r1, r3, r3, r2
 801ebb2:	4413      	add	r3, r2
 801ebb4:	1099      	asrs	r1, r3, #2
 801ebb6:	17d3      	asrs	r3, r2, #31
 801ebb8:	1ac9      	subs	r1, r1, r3
 801ebba:	460b      	mov	r3, r1
 801ebbc:	00db      	lsls	r3, r3, #3
 801ebbe:	1a5b      	subs	r3, r3, r1
 801ebc0:	1ad1      	subs	r1, r2, r3
 801ebc2:	1c4b      	adds	r3, r1, #1
 801ebc4:	61fb      	str	r3, [r7, #28]
    /*
     * Users may use 5th weekday to represent the last week of this month
     * for example "Oct-5th-Fri", but there does not exist the 5th Friday in October, so the last monweek is 4th.
     */
    targetMdayOfTargetWday = firstMdayOfTargetWday + (mweek - 1) * DAYSPERWEEK;
 801ebc6:	687b      	ldr	r3, [r7, #4]
 801ebc8:	1e5a      	subs	r2, r3, #1
 801ebca:	4613      	mov	r3, r2
 801ebcc:	00db      	lsls	r3, r3, #3
 801ebce:	1a9b      	subs	r3, r3, r2
 801ebd0:	69fa      	ldr	r2, [r7, #28]
 801ebd2:	4413      	add	r3, r2
 801ebd4:	61bb      	str	r3, [r7, #24]
    if (targetMdayOfTargetWday > g_monLengths[(INT32)isleap(year + TM_YEAR_BASE)][month]) {
 801ebd6:	68fb      	ldr	r3, [r7, #12]
 801ebd8:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 801ebdc:	f003 0303 	and.w	r3, r3, #3
 801ebe0:	2b00      	cmp	r3, #0
 801ebe2:	d120      	bne.n	801ec26 <DstGetDayOfMonth+0x16a>
 801ebe4:	68fb      	ldr	r3, [r7, #12]
 801ebe6:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 801ebea:	4b20      	ldr	r3, [pc, #128]	; (801ec6c <DstGetDayOfMonth+0x1b0>)
 801ebec:	fb83 1302 	smull	r1, r3, r3, r2
 801ebf0:	1159      	asrs	r1, r3, #5
 801ebf2:	17d3      	asrs	r3, r2, #31
 801ebf4:	1acb      	subs	r3, r1, r3
 801ebf6:	2164      	movs	r1, #100	; 0x64
 801ebf8:	fb01 f303 	mul.w	r3, r1, r3
 801ebfc:	1ad3      	subs	r3, r2, r3
 801ebfe:	2b00      	cmp	r3, #0
 801ec00:	d10f      	bne.n	801ec22 <DstGetDayOfMonth+0x166>
 801ec02:	68fb      	ldr	r3, [r7, #12]
 801ec04:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 801ec08:	4b18      	ldr	r3, [pc, #96]	; (801ec6c <DstGetDayOfMonth+0x1b0>)
 801ec0a:	fb83 1302 	smull	r1, r3, r3, r2
 801ec0e:	11d9      	asrs	r1, r3, #7
 801ec10:	17d3      	asrs	r3, r2, #31
 801ec12:	1acb      	subs	r3, r1, r3
 801ec14:	f44f 71c8 	mov.w	r1, #400	; 0x190
 801ec18:	fb01 f303 	mul.w	r3, r1, r3
 801ec1c:	1ad3      	subs	r3, r2, r3
 801ec1e:	2b00      	cmp	r3, #0
 801ec20:	d101      	bne.n	801ec26 <DstGetDayOfMonth+0x16a>
 801ec22:	2201      	movs	r2, #1
 801ec24:	e000      	b.n	801ec28 <DstGetDayOfMonth+0x16c>
 801ec26:	2200      	movs	r2, #0
 801ec28:	4911      	ldr	r1, [pc, #68]	; (801ec70 <DstGetDayOfMonth+0x1b4>)
 801ec2a:	4613      	mov	r3, r2
 801ec2c:	005b      	lsls	r3, r3, #1
 801ec2e:	4413      	add	r3, r2
 801ec30:	009b      	lsls	r3, r3, #2
 801ec32:	68ba      	ldr	r2, [r7, #8]
 801ec34:	4413      	add	r3, r2
 801ec36:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 801ec3a:	69ba      	ldr	r2, [r7, #24]
 801ec3c:	429a      	cmp	r2, r3
 801ec3e:	dd02      	ble.n	801ec46 <DstGetDayOfMonth+0x18a>
        targetMdayOfTargetWday -= 7;
 801ec40:	69bb      	ldr	r3, [r7, #24]
 801ec42:	3b07      	subs	r3, #7
 801ec44:	61bb      	str	r3, [r7, #24]
    }

    return targetMdayOfTargetWday;
 801ec46:	69bb      	ldr	r3, [r7, #24]
}
 801ec48:	4a05      	ldr	r2, [pc, #20]	; (801ec60 <DstGetDayOfMonth+0x1a4>)
 801ec4a:	6811      	ldr	r1, [r2, #0]
 801ec4c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801ec4e:	4051      	eors	r1, r2
 801ec50:	d001      	beq.n	801ec56 <DstGetDayOfMonth+0x19a>
 801ec52:	f7e5 fcc3 	bl	80045dc <__stack_chk_fail>
 801ec56:	4618      	mov	r0, r3
 801ec58:	3760      	adds	r7, #96	; 0x60
 801ec5a:	46bd      	mov	sp, r7
 801ec5c:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 801ec60:	08023288 	.word	0x08023288
 801ec64:	00015180 	.word	0x00015180
 801ec68:	92492493 	.word	0x92492493
 801ec6c:	51eb851f 	.word	0x51eb851f
 801ec70:	080242ec 	.word	0x080242ec

0801ec74 <DateDecode>:
 * idx 012345678901234
 * 2.  Oct-1st-Fri 02:59:59
 * idx 12345678901234567890
 */
STATIC INT32 DateDecode(INT32 year, const CHAR *dstString, INT32 *month, INT32 *monDay, INT32 *sec)
{
 801ec74:	b580      	push	{r7, lr}
 801ec76:	b086      	sub	sp, #24
 801ec78:	af00      	add	r7, sp, #0
 801ec7a:	60f8      	str	r0, [r7, #12]
 801ec7c:	60b9      	str	r1, [r7, #8]
 801ec7e:	607a      	str	r2, [r7, #4]
 801ec80:	603b      	str	r3, [r7, #0]
    INT32 monWeek, weekDay;
    /* For example "Feb-03 03:00:00" */
    if (strlen(dstString) == DST_STR_LEN_FORMAT_MDAY) {
 801ec82:	68b8      	ldr	r0, [r7, #8]
 801ec84:	f7f0 fc63 	bl	800f54e <strlen>
 801ec88:	4603      	mov	r3, r0
 801ec8a:	2b0f      	cmp	r3, #15
 801ec8c:	d13d      	bne.n	801ed0a <DateDecode+0x96>
        if ((dstString[3] != '-') || (dstString[6] != ' ')) {
 801ec8e:	68bb      	ldr	r3, [r7, #8]
 801ec90:	3303      	adds	r3, #3
 801ec92:	781b      	ldrb	r3, [r3, #0]
 801ec94:	2b2d      	cmp	r3, #45	; 0x2d
 801ec96:	d104      	bne.n	801eca2 <DateDecode+0x2e>
 801ec98:	68bb      	ldr	r3, [r7, #8]
 801ec9a:	3306      	adds	r3, #6
 801ec9c:	781b      	ldrb	r3, [r3, #0]
 801ec9e:	2b20      	cmp	r3, #32
 801eca0:	d002      	beq.n	801eca8 <DateDecode+0x34>
            return -1;
 801eca2:	f04f 33ff 	mov.w	r3, #4294967295
 801eca6:	e096      	b.n	801edd6 <DateDecode+0x162>
        }

        *month = GetMonthFromString(&dstString[0]);
 801eca8:	68b8      	ldr	r0, [r7, #8]
 801ecaa:	f7ff fdc7 	bl	801e83c <GetMonthFromString>
 801ecae:	4602      	mov	r2, r0
 801ecb0:	687b      	ldr	r3, [r7, #4]
 801ecb2:	601a      	str	r2, [r3, #0]
        if (*month == -1) {
 801ecb4:	687b      	ldr	r3, [r7, #4]
 801ecb6:	681b      	ldr	r3, [r3, #0]
 801ecb8:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ecbc:	d102      	bne.n	801ecc4 <DateDecode+0x50>
            return -1;
 801ecbe:	f04f 33ff 	mov.w	r3, #4294967295
 801ecc2:	e088      	b.n	801edd6 <DateDecode+0x162>
        }

        *monDay = GetMonthDayFromString(*month, &dstString[4]);
 801ecc4:	687b      	ldr	r3, [r7, #4]
 801ecc6:	681a      	ldr	r2, [r3, #0]
 801ecc8:	68bb      	ldr	r3, [r7, #8]
 801ecca:	3304      	adds	r3, #4
 801eccc:	4619      	mov	r1, r3
 801ecce:	4610      	mov	r0, r2
 801ecd0:	f7ff fe40 	bl	801e954 <GetMonthDayFromString>
 801ecd4:	4602      	mov	r2, r0
 801ecd6:	683b      	ldr	r3, [r7, #0]
 801ecd8:	601a      	str	r2, [r3, #0]
        if (*monDay == -1) {
 801ecda:	683b      	ldr	r3, [r7, #0]
 801ecdc:	681b      	ldr	r3, [r3, #0]
 801ecde:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ece2:	d102      	bne.n	801ecea <DateDecode+0x76>
            return -1;
 801ece4:	f04f 33ff 	mov.w	r3, #4294967295
 801ece8:	e075      	b.n	801edd6 <DateDecode+0x162>
        }

        *sec = GetDaySecondsFromString(&dstString[7]);
 801ecea:	68bb      	ldr	r3, [r7, #8]
 801ecec:	3307      	adds	r3, #7
 801ecee:	4618      	mov	r0, r3
 801ecf0:	f7ff fe68 	bl	801e9c4 <GetDaySecondsFromString>
 801ecf4:	4602      	mov	r2, r0
 801ecf6:	6a3b      	ldr	r3, [r7, #32]
 801ecf8:	601a      	str	r2, [r3, #0]
        if (*sec == -1) {
 801ecfa:	6a3b      	ldr	r3, [r7, #32]
 801ecfc:	681b      	ldr	r3, [r3, #0]
 801ecfe:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ed02:	d167      	bne.n	801edd4 <DateDecode+0x160>
            return -1;
 801ed04:	f04f 33ff 	mov.w	r3, #4294967295
 801ed08:	e065      	b.n	801edd6 <DateDecode+0x162>
        }
    } else if (strlen(dstString) == DST_STR_LEN_FORMAT_WDAY) {
 801ed0a:	68b8      	ldr	r0, [r7, #8]
 801ed0c:	f7f0 fc1f 	bl	800f54e <strlen>
 801ed10:	4603      	mov	r3, r0
 801ed12:	2b14      	cmp	r3, #20
 801ed14:	d15b      	bne.n	801edce <DateDecode+0x15a>
        /* For example "Oct-1st-Fri 02:59:59" */
        if ((dstString[3] != '-') || (dstString[7] != '-') || (dstString[11] != ' ')) {
 801ed16:	68bb      	ldr	r3, [r7, #8]
 801ed18:	3303      	adds	r3, #3
 801ed1a:	781b      	ldrb	r3, [r3, #0]
 801ed1c:	2b2d      	cmp	r3, #45	; 0x2d
 801ed1e:	d109      	bne.n	801ed34 <DateDecode+0xc0>
 801ed20:	68bb      	ldr	r3, [r7, #8]
 801ed22:	3307      	adds	r3, #7
 801ed24:	781b      	ldrb	r3, [r3, #0]
 801ed26:	2b2d      	cmp	r3, #45	; 0x2d
 801ed28:	d104      	bne.n	801ed34 <DateDecode+0xc0>
 801ed2a:	68bb      	ldr	r3, [r7, #8]
 801ed2c:	330b      	adds	r3, #11
 801ed2e:	781b      	ldrb	r3, [r3, #0]
 801ed30:	2b20      	cmp	r3, #32
 801ed32:	d002      	beq.n	801ed3a <DateDecode+0xc6>
            return -1;
 801ed34:	f04f 33ff 	mov.w	r3, #4294967295
 801ed38:	e04d      	b.n	801edd6 <DateDecode+0x162>
        }

        *month = GetMonthFromString(&dstString[0]);
 801ed3a:	68b8      	ldr	r0, [r7, #8]
 801ed3c:	f7ff fd7e 	bl	801e83c <GetMonthFromString>
 801ed40:	4602      	mov	r2, r0
 801ed42:	687b      	ldr	r3, [r7, #4]
 801ed44:	601a      	str	r2, [r3, #0]
        if (*month == -1) {
 801ed46:	687b      	ldr	r3, [r7, #4]
 801ed48:	681b      	ldr	r3, [r3, #0]
 801ed4a:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ed4e:	d102      	bne.n	801ed56 <DateDecode+0xe2>
            return -1;
 801ed50:	f04f 33ff 	mov.w	r3, #4294967295
 801ed54:	e03f      	b.n	801edd6 <DateDecode+0x162>
        }

        monWeek = GetMonthWeekFromString(&dstString[4]);
 801ed56:	68bb      	ldr	r3, [r7, #8]
 801ed58:	3304      	adds	r3, #4
 801ed5a:	4618      	mov	r0, r3
 801ed5c:	f7ff fdb6 	bl	801e8cc <GetMonthWeekFromString>
 801ed60:	6138      	str	r0, [r7, #16]
        if (monWeek == -1) {
 801ed62:	693b      	ldr	r3, [r7, #16]
 801ed64:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ed68:	d102      	bne.n	801ed70 <DateDecode+0xfc>
            return -1;
 801ed6a:	f04f 33ff 	mov.w	r3, #4294967295
 801ed6e:	e032      	b.n	801edd6 <DateDecode+0x162>
        }

        weekDay = GetWeekDayFromString(&dstString[8]);
 801ed70:	68bb      	ldr	r3, [r7, #8]
 801ed72:	3308      	adds	r3, #8
 801ed74:	4618      	mov	r0, r3
 801ed76:	f7ff fd85 	bl	801e884 <GetWeekDayFromString>
 801ed7a:	6178      	str	r0, [r7, #20]
        if (weekDay == -1) {
 801ed7c:	697b      	ldr	r3, [r7, #20]
 801ed7e:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ed82:	d102      	bne.n	801ed8a <DateDecode+0x116>
            return -1;
 801ed84:	f04f 33ff 	mov.w	r3, #4294967295
 801ed88:	e025      	b.n	801edd6 <DateDecode+0x162>
        }

        *sec = GetDaySecondsFromString(&dstString[12]);
 801ed8a:	68bb      	ldr	r3, [r7, #8]
 801ed8c:	330c      	adds	r3, #12
 801ed8e:	4618      	mov	r0, r3
 801ed90:	f7ff fe18 	bl	801e9c4 <GetDaySecondsFromString>
 801ed94:	4602      	mov	r2, r0
 801ed96:	6a3b      	ldr	r3, [r7, #32]
 801ed98:	601a      	str	r2, [r3, #0]
        if (*sec == -1) {
 801ed9a:	6a3b      	ldr	r3, [r7, #32]
 801ed9c:	681b      	ldr	r3, [r3, #0]
 801ed9e:	f1b3 3fff 	cmp.w	r3, #4294967295
 801eda2:	d102      	bne.n	801edaa <DateDecode+0x136>
            return -1;
 801eda4:	f04f 33ff 	mov.w	r3, #4294967295
 801eda8:	e015      	b.n	801edd6 <DateDecode+0x162>
        }

        *monDay = DstGetDayOfMonth(year, *month, monWeek, weekDay);
 801edaa:	687b      	ldr	r3, [r7, #4]
 801edac:	6819      	ldr	r1, [r3, #0]
 801edae:	697b      	ldr	r3, [r7, #20]
 801edb0:	693a      	ldr	r2, [r7, #16]
 801edb2:	68f8      	ldr	r0, [r7, #12]
 801edb4:	f7ff fe82 	bl	801eabc <DstGetDayOfMonth>
 801edb8:	4602      	mov	r2, r0
 801edba:	683b      	ldr	r3, [r7, #0]
 801edbc:	601a      	str	r2, [r3, #0]
        if (*monDay  == -1) {
 801edbe:	683b      	ldr	r3, [r7, #0]
 801edc0:	681b      	ldr	r3, [r3, #0]
 801edc2:	f1b3 3fff 	cmp.w	r3, #4294967295
 801edc6:	d105      	bne.n	801edd4 <DateDecode+0x160>
            return -1;
 801edc8:	f04f 33ff 	mov.w	r3, #4294967295
 801edcc:	e003      	b.n	801edd6 <DateDecode+0x162>
        }
    } else {
        return -1;
 801edce:	f04f 33ff 	mov.w	r3, #4294967295
 801edd2:	e000      	b.n	801edd6 <DateDecode+0x162>
    }

    return 0;
 801edd4:	2300      	movs	r3, #0
}
 801edd6:	4618      	mov	r0, r3
 801edd8:	3718      	adds	r7, #24
 801edda:	46bd      	mov	sp, r7
 801eddc:	bd80      	pop	{r7, pc}
	...

0801ede0 <DstConfigDecode>:

STATIC INT64 DstConfigDecode(INT32 year, const CHAR *dstString)
{
 801ede0:	b5b0      	push	{r4, r5, r7, lr}
 801ede2:	b096      	sub	sp, #88	; 0x58
 801ede4:	af02      	add	r7, sp, #8
 801ede6:	6078      	str	r0, [r7, #4]
 801ede8:	6039      	str	r1, [r7, #0]
 801edea:	4b2a      	ldr	r3, [pc, #168]	; (801ee94 <DstConfigDecode+0xb4>)
 801edec:	681b      	ldr	r3, [r3, #0]
 801edee:	64fb      	str	r3, [r7, #76]	; 0x4c
 801edf0:	f04f 0300 	mov.w	r3, #0
    INT32 month, monDay, sec;
    INT32 ret;
    struct tm time = {0};
 801edf4:	f107 0320 	add.w	r3, r7, #32
 801edf8:	222c      	movs	r2, #44	; 0x2c
 801edfa:	2100      	movs	r1, #0
 801edfc:	4618      	mov	r0, r3
 801edfe:	f7f0 fa83 	bl	800f308 <memset>
    INT64 dstSeconds;

    ret = DateDecode(year, dstString, &month, &monDay, &sec);
 801ee02:	f107 010c 	add.w	r1, r7, #12
 801ee06:	f107 0208 	add.w	r2, r7, #8
 801ee0a:	f107 0310 	add.w	r3, r7, #16
 801ee0e:	9300      	str	r3, [sp, #0]
 801ee10:	460b      	mov	r3, r1
 801ee12:	6839      	ldr	r1, [r7, #0]
 801ee14:	6878      	ldr	r0, [r7, #4]
 801ee16:	f7ff ff2d 	bl	801ec74 <DateDecode>
 801ee1a:	6178      	str	r0, [r7, #20]
    if (ret == -1) {
 801ee1c:	697b      	ldr	r3, [r7, #20]
 801ee1e:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ee22:	d104      	bne.n	801ee2e <DstConfigDecode+0x4e>
        return -1;
 801ee24:	f04f 34ff 	mov.w	r4, #4294967295
 801ee28:	f04f 35ff 	mov.w	r5, #4294967295
 801ee2c:	e024      	b.n	801ee78 <DstConfigDecode+0x98>
    }
    /* get the DST period */
    time.tm_year = year;
 801ee2e:	687b      	ldr	r3, [r7, #4]
 801ee30:	637b      	str	r3, [r7, #52]	; 0x34
    time.tm_mon = month;
 801ee32:	68bb      	ldr	r3, [r7, #8]
 801ee34:	633b      	str	r3, [r7, #48]	; 0x30
    time.tm_mday = monDay;
 801ee36:	68fb      	ldr	r3, [r7, #12]
 801ee38:	62fb      	str	r3, [r7, #44]	; 0x2c
    time.tm_isdst = 0;
 801ee3a:	2300      	movs	r3, #0
 801ee3c:	643b      	str	r3, [r7, #64]	; 0x40
#ifdef LOSCFG_AARCH64
    dstSeconds = mktime(&time);
#else
    dstSeconds = mktime64(&time);
 801ee3e:	f107 0320 	add.w	r3, r7, #32
 801ee42:	4618      	mov	r0, r3
 801ee44:	f7fe ff3c 	bl	801dcc0 <mktime64>
 801ee48:	e9c7 0106 	strd	r0, r1, [r7, #24]
#endif
    if (dstSeconds == -1) {
 801ee4c:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801ee50:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ee54:	bf08      	it	eq
 801ee56:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 801ee5a:	d104      	bne.n	801ee66 <DstConfigDecode+0x86>
        return -1;
 801ee5c:	f04f 34ff 	mov.w	r4, #4294967295
 801ee60:	f04f 35ff 	mov.w	r5, #4294967295
 801ee64:	e008      	b.n	801ee78 <DstConfigDecode+0x98>
    }

    return dstSeconds + sec;
 801ee66:	693b      	ldr	r3, [r7, #16]
 801ee68:	4618      	mov	r0, r3
 801ee6a:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801ee6e:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801ee72:	1884      	adds	r4, r0, r2
 801ee74:	eb41 0503 	adc.w	r5, r1, r3
 801ee78:	4622      	mov	r2, r4
 801ee7a:	462b      	mov	r3, r5
}
 801ee7c:	4905      	ldr	r1, [pc, #20]	; (801ee94 <DstConfigDecode+0xb4>)
 801ee7e:	6808      	ldr	r0, [r1, #0]
 801ee80:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801ee82:	4048      	eors	r0, r1
 801ee84:	d001      	beq.n	801ee8a <DstConfigDecode+0xaa>
 801ee86:	f7e5 fba9 	bl	80045dc <__stack_chk_fail>
 801ee8a:	4610      	mov	r0, r2
 801ee8c:	4619      	mov	r1, r3
 801ee8e:	3750      	adds	r7, #80	; 0x50
 801ee90:	46bd      	mov	sp, r7
 801ee92:	bdb0      	pop	{r4, r5, r7, pc}
 801ee94:	0802328c 	.word	0x0802328c

0801ee98 <CheckDstPeriodInner>:

    return TRUE;
}

STATIC BOOL CheckDstPeriodInner(const struct tm * const tm, INT64 seconds, INT64 dstStart, INT64 dstEnd)
{
 801ee98:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
 801ee9c:	b085      	sub	sp, #20
 801ee9e:	af00      	add	r7, sp, #0
 801eea0:	60f8      	str	r0, [r7, #12]
 801eea2:	e9c7 2300 	strd	r2, r3, [r7]
    if (tm != NULL) {
 801eea6:	68fb      	ldr	r3, [r7, #12]
 801eea8:	2b00      	cmp	r3, #0
 801eeaa:	d040      	beq.n	801ef2e <CheckDstPeriodInner+0x96>
        if (tm->tm_isdst < 0) {
 801eeac:	68fb      	ldr	r3, [r7, #12]
 801eeae:	6a1b      	ldr	r3, [r3, #32]
 801eeb0:	2b00      	cmp	r3, #0
 801eeb2:	da34      	bge.n	801ef1e <CheckDstPeriodInner+0x86>
            /* it must to be. */
            if ((seconds >= dstStart) && (seconds < dstStart + g_dstForwardSeconds)) {
 801eeb4:	e9d7 0100 	ldrd	r0, r1, [r7]
 801eeb8:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801eebc:	4290      	cmp	r0, r2
 801eebe:	eb71 0303 	sbcs.w	r3, r1, r3
 801eec2:	db12      	blt.n	801eeea <CheckDstPeriodInner+0x52>
 801eec4:	4b26      	ldr	r3, [pc, #152]	; (801ef60 <CheckDstPeriodInner+0xc8>)
 801eec6:	681b      	ldr	r3, [r3, #0]
 801eec8:	4618      	mov	r0, r3
 801eeca:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801eece:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801eed2:	eb10 0802 	adds.w	r8, r0, r2
 801eed6:	eb41 0903 	adc.w	r9, r1, r3
 801eeda:	e9d7 2300 	ldrd	r2, r3, [r7]
 801eede:	4542      	cmp	r2, r8
 801eee0:	eb73 0309 	sbcs.w	r3, r3, r9
 801eee4:	da01      	bge.n	801eeea <CheckDstPeriodInner+0x52>
                return FALSE;
 801eee6:	2300      	movs	r3, #0
 801eee8:	e034      	b.n	801ef54 <CheckDstPeriodInner+0xbc>
            }

            /* determine the time period of the second pass, out of the DST period. */
            if ((seconds > dstEnd) && (seconds <= dstEnd + g_dstForwardSeconds)) {
 801eeea:	e9d7 2300 	ldrd	r2, r3, [r7]
 801eeee:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 801eef2:	4290      	cmp	r0, r2
 801eef4:	eb71 0303 	sbcs.w	r3, r1, r3
 801eef8:	da19      	bge.n	801ef2e <CheckDstPeriodInner+0x96>
 801eefa:	4b19      	ldr	r3, [pc, #100]	; (801ef60 <CheckDstPeriodInner+0xc8>)
 801eefc:	681b      	ldr	r3, [r3, #0]
 801eefe:	4618      	mov	r0, r3
 801ef00:	ea4f 71e0 	mov.w	r1, r0, asr #31
 801ef04:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 801ef08:	1884      	adds	r4, r0, r2
 801ef0a:	eb41 0503 	adc.w	r5, r1, r3
 801ef0e:	e9d7 2300 	ldrd	r2, r3, [r7]
 801ef12:	4294      	cmp	r4, r2
 801ef14:	eb75 0303 	sbcs.w	r3, r5, r3
 801ef18:	db09      	blt.n	801ef2e <CheckDstPeriodInner+0x96>
                return TRUE;
 801ef1a:	2301      	movs	r3, #1
 801ef1c:	e01a      	b.n	801ef54 <CheckDstPeriodInner+0xbc>
            }
        } else if (tm->tm_isdst > 0) {
 801ef1e:	68fb      	ldr	r3, [r7, #12]
 801ef20:	6a1b      	ldr	r3, [r3, #32]
 801ef22:	2b00      	cmp	r3, #0
 801ef24:	dd01      	ble.n	801ef2a <CheckDstPeriodInner+0x92>
            /* the logical judgment here is the opposite of common sense */
            return TRUE;
 801ef26:	2301      	movs	r3, #1
 801ef28:	e014      	b.n	801ef54 <CheckDstPeriodInner+0xbc>
        } else {
            /* tm->tm_isdst is zero */
            return FALSE;
 801ef2a:	2300      	movs	r3, #0
 801ef2c:	e012      	b.n	801ef54 <CheckDstPeriodInner+0xbc>
        }
    }

    if ((seconds < dstStart) || (seconds >= dstEnd)) {
 801ef2e:	e9d7 0100 	ldrd	r0, r1, [r7]
 801ef32:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 801ef36:	4290      	cmp	r0, r2
 801ef38:	eb71 0303 	sbcs.w	r3, r1, r3
 801ef3c:	db07      	blt.n	801ef4e <CheckDstPeriodInner+0xb6>
 801ef3e:	e9d7 0100 	ldrd	r0, r1, [r7]
 801ef42:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 801ef46:	4290      	cmp	r0, r2
 801ef48:	eb71 0303 	sbcs.w	r3, r1, r3
 801ef4c:	db01      	blt.n	801ef52 <CheckDstPeriodInner+0xba>
        return FALSE; /* daylight saving time is not effect. */
 801ef4e:	2300      	movs	r3, #0
 801ef50:	e000      	b.n	801ef54 <CheckDstPeriodInner+0xbc>
    }

    return TRUE;
 801ef52:	2301      	movs	r3, #1
}
 801ef54:	4618      	mov	r0, r3
 801ef56:	3714      	adds	r7, #20
 801ef58:	46bd      	mov	sp, r7
 801ef5a:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
 801ef5e:	4770      	bx	lr
 801ef60:	20003464 	.word	0x20003464

0801ef64 <CheckWithinDstPeriod>:

BOOL CheckWithinDstPeriod(const struct tm * const tm, INT64 seconds)
{
 801ef64:	b580      	push	{r7, lr}
 801ef66:	b098      	sub	sp, #96	; 0x60
 801ef68:	af04      	add	r7, sp, #16
 801ef6a:	60f8      	str	r0, [r7, #12]
 801ef6c:	e9c7 2300 	strd	r2, r3, [r7]
 801ef70:	4b42      	ldr	r3, [pc, #264]	; (801f07c <CheckWithinDstPeriod+0x118>)
 801ef72:	681b      	ldr	r3, [r3, #0]
 801ef74:	64fb      	str	r3, [r7, #76]	; 0x4c
 801ef76:	f04f 0300 	mov.w	r3, #0
    INT64 dstStart, dstEnd;
    struct tm time = {0};
 801ef7a:	f107 0320 	add.w	r3, r7, #32
 801ef7e:	222c      	movs	r2, #44	; 0x2c
 801ef80:	2100      	movs	r1, #0
 801ef82:	4618      	mov	r0, r3
 801ef84:	f7f0 f9c0 	bl	800f308 <memset>

    if (LIBC_LOCK(g_tzdstLock)) {
 801ef88:	483d      	ldr	r0, [pc, #244]	; (801f080 <CheckWithinDstPeriod+0x11c>)
 801ef8a:	f000 f881 	bl	801f090 <LibcLock>
 801ef8e:	4603      	mov	r3, r0
 801ef90:	2b00      	cmp	r3, #0
 801ef92:	d001      	beq.n	801ef98 <CheckWithinDstPeriod+0x34>
        return FALSE;
 801ef94:	2300      	movs	r3, #0
 801ef96:	e066      	b.n	801f066 <CheckWithinDstPeriod+0x102>
    }
    if (g_isDstWork == FALSE) {
 801ef98:	4b3a      	ldr	r3, [pc, #232]	; (801f084 <CheckWithinDstPeriod+0x120>)
 801ef9a:	681b      	ldr	r3, [r3, #0]
 801ef9c:	2b00      	cmp	r3, #0
 801ef9e:	d104      	bne.n	801efaa <CheckWithinDstPeriod+0x46>
        (void)LIBC_UNLOCK(g_tzdstLock);
 801efa0:	4837      	ldr	r0, [pc, #220]	; (801f080 <CheckWithinDstPeriod+0x11c>)
 801efa2:	f000 f89f 	bl	801f0e4 <LibcUnlock>
        return FALSE;
 801efa6:	2300      	movs	r3, #0
 801efa8:	e05d      	b.n	801f066 <CheckWithinDstPeriod+0x102>
    }

    (void)LIBC_UNLOCK(g_tzdstLock);
 801efaa:	4835      	ldr	r0, [pc, #212]	; (801f080 <CheckWithinDstPeriod+0x11c>)
 801efac:	f000 f89a 	bl	801f0e4 <LibcUnlock>
    /* represent a local time. */
    if (tm != NULL) {
 801efb0:	68fb      	ldr	r3, [r7, #12]
 801efb2:	2b00      	cmp	r3, #0
 801efb4:	d01b      	beq.n	801efee <CheckWithinDstPeriod+0x8a>
        (void)memcpy_s(&time, sizeof(struct tm), tm, sizeof(struct tm));
 801efb6:	f107 0020 	add.w	r0, r7, #32
 801efba:	232c      	movs	r3, #44	; 0x2c
 801efbc:	68fa      	ldr	r2, [r7, #12]
 801efbe:	212c      	movs	r1, #44	; 0x2c
 801efc0:	f7f8 f86a 	bl	8017098 <memcpy_s>
        time.tm_isdst = 0;
 801efc4:	2300      	movs	r3, #0
 801efc6:	643b      	str	r3, [r7, #64]	; 0x40
        /* the input-param of seconds is unused in this case. */
#ifdef LOSCFG_AARCH64
        seconds = mktime(&time);
#else
        seconds = mktime64(&time);
 801efc8:	f107 0320 	add.w	r3, r7, #32
 801efcc:	4618      	mov	r0, r3
 801efce:	f7fe fe77 	bl	801dcc0 <mktime64>
 801efd2:	4602      	mov	r2, r0
 801efd4:	460b      	mov	r3, r1
 801efd6:	e9c7 2300 	strd	r2, r3, [r7]
#endif
        if (seconds == -1) {
 801efda:	e9d7 2300 	ldrd	r2, r3, [r7]
 801efde:	f1b3 3fff 	cmp.w	r3, #4294967295
 801efe2:	bf08      	it	eq
 801efe4:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 801efe8:	d10d      	bne.n	801f006 <CheckWithinDstPeriod+0xa2>
            return FALSE;
 801efea:	2300      	movs	r3, #0
 801efec:	e03b      	b.n	801f066 <CheckWithinDstPeriod+0x102>
    } else {
        /* represent a standard time, not care TZ. */
#ifdef LOSCFG_AARCH64
        if (gmtime_r(&seconds, &time) == NULL) {
#else
        if (gmtime64_r(&seconds, &time) == NULL) {
 801efee:	f107 0220 	add.w	r2, r7, #32
 801eff2:	463b      	mov	r3, r7
 801eff4:	4611      	mov	r1, r2
 801eff6:	4618      	mov	r0, r3
 801eff8:	f7fe fea8 	bl	801dd4c <gmtime64_r>
 801effc:	4603      	mov	r3, r0
 801effe:	2b00      	cmp	r3, #0
 801f000:	d101      	bne.n	801f006 <CheckWithinDstPeriod+0xa2>
#endif
            return FALSE;
 801f002:	2300      	movs	r3, #0
 801f004:	e02f      	b.n	801f066 <CheckWithinDstPeriod+0x102>
        }
    }

    dstStart = DstConfigDecode(time.tm_year, g_strDstStart);
 801f006:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801f008:	491f      	ldr	r1, [pc, #124]	; (801f088 <CheckWithinDstPeriod+0x124>)
 801f00a:	4618      	mov	r0, r3
 801f00c:	f7ff fee8 	bl	801ede0 <DstConfigDecode>
 801f010:	e9c7 0104 	strd	r0, r1, [r7, #16]
    dstEnd = DstConfigDecode(time.tm_year, g_strDstEnd);
 801f014:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801f016:	491d      	ldr	r1, [pc, #116]	; (801f08c <CheckWithinDstPeriod+0x128>)
 801f018:	4618      	mov	r0, r3
 801f01a:	f7ff fee1 	bl	801ede0 <DstConfigDecode>
 801f01e:	e9c7 0106 	strd	r0, r1, [r7, #24]
    if ((dstStart == -1) || (dstEnd == -1)) {
 801f022:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801f026:	f1b3 3fff 	cmp.w	r3, #4294967295
 801f02a:	bf08      	it	eq
 801f02c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 801f030:	d007      	beq.n	801f042 <CheckWithinDstPeriod+0xde>
 801f032:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801f036:	f1b3 3fff 	cmp.w	r3, #4294967295
 801f03a:	bf08      	it	eq
 801f03c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 801f040:	d101      	bne.n	801f046 <CheckWithinDstPeriod+0xe2>
        return FALSE;
 801f042:	2300      	movs	r3, #0
 801f044:	e00f      	b.n	801f066 <CheckWithinDstPeriod+0x102>
    }

    return CheckDstPeriodInner(tm, seconds, dstStart, dstEnd);
 801f046:	e9d7 0100 	ldrd	r0, r1, [r7]
 801f04a:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801f04e:	e9cd 2302 	strd	r2, r3, [sp, #8]
 801f052:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 801f056:	e9cd 2300 	strd	r2, r3, [sp]
 801f05a:	4602      	mov	r2, r0
 801f05c:	460b      	mov	r3, r1
 801f05e:	68f8      	ldr	r0, [r7, #12]
 801f060:	f7ff ff1a 	bl	801ee98 <CheckDstPeriodInner>
 801f064:	4603      	mov	r3, r0
}
 801f066:	4a05      	ldr	r2, [pc, #20]	; (801f07c <CheckWithinDstPeriod+0x118>)
 801f068:	6811      	ldr	r1, [r2, #0]
 801f06a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801f06c:	4051      	eors	r1, r2
 801f06e:	d001      	beq.n	801f074 <CheckWithinDstPeriod+0x110>
 801f070:	f7e5 fab4 	bl	80045dc <__stack_chk_fail>
 801f074:	4618      	mov	r0, r3
 801f076:	3750      	adds	r7, #80	; 0x50
 801f078:	46bd      	mov	sp, r7
 801f07a:	bd80      	pop	{r7, pc}
 801f07c:	08023290 	.word	0x08023290
 801f080:	20000570 	.word	0x20000570
 801f084:	20003460 	.word	0x20003460
 801f088:	20003468 	.word	0x20003468
 801f08c:	20003480 	.word	0x20003480

0801f090 <LibcLock>:
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

INT32 LibcLock(UINT32 *lock)
{
 801f090:	b580      	push	{r7, lr}
 801f092:	b082      	sub	sp, #8
 801f094:	af00      	add	r7, sp, #0
 801f096:	6078      	str	r0, [r7, #4]
    if (lock == NULL) {
 801f098:	687b      	ldr	r3, [r7, #4]
 801f09a:	2b00      	cmp	r3, #0
 801f09c:	d102      	bne.n	801f0a4 <LibcLock+0x14>
        return -1;
 801f09e:	f04f 33ff 	mov.w	r3, #4294967295
 801f0a2:	e01b      	b.n	801f0dc <LibcLock+0x4c>
    }

    if (*lock == LIBC_LOCK_INITIALIZER) {
 801f0a4:	687b      	ldr	r3, [r7, #4]
 801f0a6:	681b      	ldr	r3, [r3, #0]
 801f0a8:	f1b3 3fff 	cmp.w	r3, #4294967295
 801f0ac:	d108      	bne.n	801f0c0 <LibcLock+0x30>
        if (LOS_MuxCreate(lock) != LOS_OK) {
 801f0ae:	6878      	ldr	r0, [r7, #4]
 801f0b0:	f7ec f992 	bl	800b3d8 <LOS_MuxCreate>
 801f0b4:	4603      	mov	r3, r0
 801f0b6:	2b00      	cmp	r3, #0
 801f0b8:	d002      	beq.n	801f0c0 <LibcLock+0x30>
            return -1;
 801f0ba:	f04f 33ff 	mov.w	r3, #4294967295
 801f0be:	e00d      	b.n	801f0dc <LibcLock+0x4c>
        }
    }

    if (LOS_MuxPend(*lock, LOS_WAIT_FOREVER) != LOS_OK) {
 801f0c0:	687b      	ldr	r3, [r7, #4]
 801f0c2:	681b      	ldr	r3, [r3, #0]
 801f0c4:	f04f 31ff 	mov.w	r1, #4294967295
 801f0c8:	4618      	mov	r0, r3
 801f0ca:	f7ec fc2f 	bl	800b92c <LOS_MuxPend>
 801f0ce:	4603      	mov	r3, r0
 801f0d0:	2b00      	cmp	r3, #0
 801f0d2:	d002      	beq.n	801f0da <LibcLock+0x4a>
        return -1;
 801f0d4:	f04f 33ff 	mov.w	r3, #4294967295
 801f0d8:	e000      	b.n	801f0dc <LibcLock+0x4c>
    } else {
        return 0;
 801f0da:	2300      	movs	r3, #0
    }
}
 801f0dc:	4618      	mov	r0, r3
 801f0de:	3708      	adds	r7, #8
 801f0e0:	46bd      	mov	sp, r7
 801f0e2:	bd80      	pop	{r7, pc}

0801f0e4 <LibcUnlock>:

INT32 LibcUnlock(const UINT32 *lock)
{
 801f0e4:	b580      	push	{r7, lr}
 801f0e6:	b082      	sub	sp, #8
 801f0e8:	af00      	add	r7, sp, #0
 801f0ea:	6078      	str	r0, [r7, #4]
    if ((lock == NULL) || (*lock == LIBC_LOCK_INITIALIZER)) {
 801f0ec:	687b      	ldr	r3, [r7, #4]
 801f0ee:	2b00      	cmp	r3, #0
 801f0f0:	d004      	beq.n	801f0fc <LibcUnlock+0x18>
 801f0f2:	687b      	ldr	r3, [r7, #4]
 801f0f4:	681b      	ldr	r3, [r3, #0]
 801f0f6:	f1b3 3fff 	cmp.w	r3, #4294967295
 801f0fa:	d102      	bne.n	801f102 <LibcUnlock+0x1e>
        return -1;
 801f0fc:	f04f 33ff 	mov.w	r3, #4294967295
 801f100:	e00b      	b.n	801f11a <LibcUnlock+0x36>
    }

    if (LOS_MuxPost(*lock) != LOS_OK) {
 801f102:	687b      	ldr	r3, [r7, #4]
 801f104:	681b      	ldr	r3, [r3, #0]
 801f106:	4618      	mov	r0, r3
 801f108:	f7ec fd90 	bl	800bc2c <LOS_MuxPost>
 801f10c:	4603      	mov	r3, r0
 801f10e:	2b00      	cmp	r3, #0
 801f110:	d002      	beq.n	801f118 <LibcUnlock+0x34>
        return -1;
 801f112:	f04f 33ff 	mov.w	r3, #4294967295
 801f116:	e000      	b.n	801f11a <LibcUnlock+0x36>
    } else {
        return 0;
 801f118:	2300      	movs	r3, #0
    }
}
 801f11a:	4618      	mov	r0, r3
 801f11c:	3708      	adds	r7, #8
 801f11e:	46bd      	mov	sp, r7
 801f120:	bd80      	pop	{r7, pc}

0801f122 <memchr>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) (((x)-ONES) & ~(x) & HIGHS)

void *memchr(const void *src, int c, size_t n)
{
 801f122:	b480      	push	{r7}
 801f124:	b089      	sub	sp, #36	; 0x24
 801f126:	af00      	add	r7, sp, #0
 801f128:	60f8      	str	r0, [r7, #12]
 801f12a:	60b9      	str	r1, [r7, #8]
 801f12c:	607a      	str	r2, [r7, #4]
	const unsigned char *s = src;
 801f12e:	68fb      	ldr	r3, [r7, #12]
 801f130:	617b      	str	r3, [r7, #20]
	c = (unsigned char)c;
 801f132:	68bb      	ldr	r3, [r7, #8]
 801f134:	b2db      	uxtb	r3, r3
 801f136:	60bb      	str	r3, [r7, #8]
#ifdef __GNUC__
	for (; ((uintptr_t)s & ALIGN) && n && *s != c; s++, n--);
 801f138:	e005      	b.n	801f146 <memchr+0x24>
 801f13a:	697b      	ldr	r3, [r7, #20]
 801f13c:	3301      	adds	r3, #1
 801f13e:	617b      	str	r3, [r7, #20]
 801f140:	687b      	ldr	r3, [r7, #4]
 801f142:	3b01      	subs	r3, #1
 801f144:	607b      	str	r3, [r7, #4]
 801f146:	697b      	ldr	r3, [r7, #20]
 801f148:	f003 0303 	and.w	r3, r3, #3
 801f14c:	2b00      	cmp	r3, #0
 801f14e:	d008      	beq.n	801f162 <memchr+0x40>
 801f150:	687b      	ldr	r3, [r7, #4]
 801f152:	2b00      	cmp	r3, #0
 801f154:	d005      	beq.n	801f162 <memchr+0x40>
 801f156:	697b      	ldr	r3, [r7, #20]
 801f158:	781b      	ldrb	r3, [r3, #0]
 801f15a:	461a      	mov	r2, r3
 801f15c:	68bb      	ldr	r3, [r7, #8]
 801f15e:	4293      	cmp	r3, r2
 801f160:	d1eb      	bne.n	801f13a <memchr+0x18>
	if (n && *s != c) {
 801f162:	687b      	ldr	r3, [r7, #4]
 801f164:	2b00      	cmp	r3, #0
 801f166:	d031      	beq.n	801f1cc <memchr+0xaa>
 801f168:	697b      	ldr	r3, [r7, #20]
 801f16a:	781b      	ldrb	r3, [r3, #0]
 801f16c:	461a      	mov	r2, r3
 801f16e:	68bb      	ldr	r3, [r7, #8]
 801f170:	4293      	cmp	r3, r2
 801f172:	d02b      	beq.n	801f1cc <memchr+0xaa>
		typedef size_t __attribute__((__may_alias__)) word;
		const word *w;
		size_t k = ONES * c;
 801f174:	68ba      	ldr	r2, [r7, #8]
 801f176:	4613      	mov	r3, r2
 801f178:	021b      	lsls	r3, r3, #8
 801f17a:	4413      	add	r3, r2
 801f17c:	041a      	lsls	r2, r3, #16
 801f17e:	4413      	add	r3, r2
 801f180:	61fb      	str	r3, [r7, #28]
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
 801f182:	697b      	ldr	r3, [r7, #20]
 801f184:	61bb      	str	r3, [r7, #24]
 801f186:	e005      	b.n	801f194 <memchr+0x72>
 801f188:	69bb      	ldr	r3, [r7, #24]
 801f18a:	3304      	adds	r3, #4
 801f18c:	61bb      	str	r3, [r7, #24]
 801f18e:	687b      	ldr	r3, [r7, #4]
 801f190:	3b04      	subs	r3, #4
 801f192:	607b      	str	r3, [r7, #4]
 801f194:	687b      	ldr	r3, [r7, #4]
 801f196:	2b03      	cmp	r3, #3
 801f198:	d90f      	bls.n	801f1ba <memchr+0x98>
 801f19a:	69bb      	ldr	r3, [r7, #24]
 801f19c:	681a      	ldr	r2, [r3, #0]
 801f19e:	69fb      	ldr	r3, [r7, #28]
 801f1a0:	4053      	eors	r3, r2
 801f1a2:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 801f1a6:	69bb      	ldr	r3, [r7, #24]
 801f1a8:	6819      	ldr	r1, [r3, #0]
 801f1aa:	69fb      	ldr	r3, [r7, #28]
 801f1ac:	404b      	eors	r3, r1
 801f1ae:	43db      	mvns	r3, r3
 801f1b0:	4013      	ands	r3, r2
 801f1b2:	f003 3380 	and.w	r3, r3, #2155905152	; 0x80808080
 801f1b6:	2b00      	cmp	r3, #0
 801f1b8:	d0e6      	beq.n	801f188 <memchr+0x66>
		s = (const void *)w;
 801f1ba:	69bb      	ldr	r3, [r7, #24]
 801f1bc:	617b      	str	r3, [r7, #20]
	}
#endif
	for (; n && *s != c; s++, n--);
 801f1be:	e005      	b.n	801f1cc <memchr+0xaa>
 801f1c0:	697b      	ldr	r3, [r7, #20]
 801f1c2:	3301      	adds	r3, #1
 801f1c4:	617b      	str	r3, [r7, #20]
 801f1c6:	687b      	ldr	r3, [r7, #4]
 801f1c8:	3b01      	subs	r3, #1
 801f1ca:	607b      	str	r3, [r7, #4]
 801f1cc:	687b      	ldr	r3, [r7, #4]
 801f1ce:	2b00      	cmp	r3, #0
 801f1d0:	d005      	beq.n	801f1de <memchr+0xbc>
 801f1d2:	697b      	ldr	r3, [r7, #20]
 801f1d4:	781b      	ldrb	r3, [r3, #0]
 801f1d6:	461a      	mov	r2, r3
 801f1d8:	68bb      	ldr	r3, [r7, #8]
 801f1da:	4293      	cmp	r3, r2
 801f1dc:	d1f0      	bne.n	801f1c0 <memchr+0x9e>
	return n ? (void *)s : 0;
 801f1de:	687b      	ldr	r3, [r7, #4]
 801f1e0:	2b00      	cmp	r3, #0
 801f1e2:	d001      	beq.n	801f1e8 <memchr+0xc6>
 801f1e4:	697b      	ldr	r3, [r7, #20]
 801f1e6:	e000      	b.n	801f1ea <memchr+0xc8>
 801f1e8:	2300      	movs	r3, #0
}
 801f1ea:	4618      	mov	r0, r3
 801f1ec:	3724      	adds	r7, #36	; 0x24
 801f1ee:	46bd      	mov	sp, r7
 801f1f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f1f4:	4770      	bx	lr
	...

0801f1f8 <__month_to_secs>:
int __month_to_secs(int month, int is_leap)
{
 801f1f8:	b480      	push	{r7}
 801f1fa:	b085      	sub	sp, #20
 801f1fc:	af00      	add	r7, sp, #0
 801f1fe:	6078      	str	r0, [r7, #4]
 801f200:	6039      	str	r1, [r7, #0]
	static const int secs_through_month[] = {
		0, 31*86400, 59*86400, 90*86400,
		120*86400, 151*86400, 181*86400, 212*86400,
		243*86400, 273*86400, 304*86400, 334*86400 };
	int t = secs_through_month[month];
 801f202:	4a0b      	ldr	r2, [pc, #44]	; (801f230 <__month_to_secs+0x38>)
 801f204:	687b      	ldr	r3, [r7, #4]
 801f206:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801f20a:	60fb      	str	r3, [r7, #12]
	if (is_leap && month >= 2) t+=86400;
 801f20c:	683b      	ldr	r3, [r7, #0]
 801f20e:	2b00      	cmp	r3, #0
 801f210:	d006      	beq.n	801f220 <__month_to_secs+0x28>
 801f212:	687b      	ldr	r3, [r7, #4]
 801f214:	2b01      	cmp	r3, #1
 801f216:	dd03      	ble.n	801f220 <__month_to_secs+0x28>
 801f218:	68fa      	ldr	r2, [r7, #12]
 801f21a:	4b06      	ldr	r3, [pc, #24]	; (801f234 <__month_to_secs+0x3c>)
 801f21c:	4413      	add	r3, r2
 801f21e:	60fb      	str	r3, [r7, #12]
	return t;
 801f220:	68fb      	ldr	r3, [r7, #12]
}
 801f222:	4618      	mov	r0, r3
 801f224:	3714      	adds	r7, #20
 801f226:	46bd      	mov	sp, r7
 801f228:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f22c:	4770      	bx	lr
 801f22e:	bf00      	nop
 801f230:	0802434c 	.word	0x0802434c
 801f234:	00015180 	.word	0x00015180

0801f238 <frexpl>:
#include "libm.h"

#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
long double frexpl(long double x, int *e)
{
 801f238:	b580      	push	{r7, lr}
 801f23a:	b084      	sub	sp, #16
 801f23c:	af00      	add	r7, sp, #0
 801f23e:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801f242:	607a      	str	r2, [r7, #4]
	return frexp(x, e);
 801f244:	687a      	ldr	r2, [r7, #4]
 801f246:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801f24a:	f000 f807 	bl	801f25c <frexp>
 801f24e:	4602      	mov	r2, r0
 801f250:	460b      	mov	r3, r1
}
 801f252:	4610      	mov	r0, r2
 801f254:	4619      	mov	r1, r3
 801f256:	3710      	adds	r7, #16
 801f258:	46bd      	mov	sp, r7
 801f25a:	bd80      	pop	{r7, pc}

0801f25c <frexp>:
#include <math.h>
#include <stdint.h>

double frexp(double x, int *e)
{
 801f25c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801f260:	b088      	sub	sp, #32
 801f262:	af00      	add	r7, sp, #0
 801f264:	e9c7 0102 	strd	r0, r1, [r7, #8]
 801f268:	607a      	str	r2, [r7, #4]
	union { double d; uint64_t i; } y = { x };
 801f26a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801f26e:	e9c7 2306 	strd	r2, r3, [r7, #24]
	int ee = y.i>>52 & 0x7ff;
 801f272:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 801f276:	f04f 0200 	mov.w	r2, #0
 801f27a:	f04f 0300 	mov.w	r3, #0
 801f27e:	0d0a      	lsrs	r2, r1, #20
 801f280:	2300      	movs	r3, #0
 801f282:	4613      	mov	r3, r2
 801f284:	f3c3 030a 	ubfx	r3, r3, #0, #11
 801f288:	617b      	str	r3, [r7, #20]

	if (!ee) {
 801f28a:	697b      	ldr	r3, [r7, #20]
 801f28c:	2b00      	cmp	r3, #0
 801f28e:	d127      	bne.n	801f2e0 <frexp+0x84>
		if (x) {
 801f290:	f04f 0200 	mov.w	r2, #0
 801f294:	f04f 0300 	mov.w	r3, #0
 801f298:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801f29c:	f7e1 fe9c 	bl	8000fd8 <__aeabi_dcmpeq>
 801f2a0:	4603      	mov	r3, r0
 801f2a2:	2b00      	cmp	r3, #0
 801f2a4:	d116      	bne.n	801f2d4 <frexp+0x78>
			x = frexp(x*0x1p64, e);
 801f2a6:	f04f 0200 	mov.w	r2, #0
 801f2aa:	4b23      	ldr	r3, [pc, #140]	; (801f338 <frexp+0xdc>)
 801f2ac:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801f2b0:	f7e1 f95e 	bl	8000570 <__aeabi_dmul>
 801f2b4:	4602      	mov	r2, r0
 801f2b6:	460b      	mov	r3, r1
 801f2b8:	4610      	mov	r0, r2
 801f2ba:	4619      	mov	r1, r3
 801f2bc:	687a      	ldr	r2, [r7, #4]
 801f2be:	f7ff ffcd 	bl	801f25c <frexp>
 801f2c2:	e9c7 0102 	strd	r0, r1, [r7, #8]
			*e -= 64;
 801f2c6:	687b      	ldr	r3, [r7, #4]
 801f2c8:	681b      	ldr	r3, [r3, #0]
 801f2ca:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
 801f2ce:	687b      	ldr	r3, [r7, #4]
 801f2d0:	601a      	str	r2, [r3, #0]
 801f2d2:	e002      	b.n	801f2da <frexp+0x7e>
		} else *e = 0;
 801f2d4:	687b      	ldr	r3, [r7, #4]
 801f2d6:	2200      	movs	r2, #0
 801f2d8:	601a      	str	r2, [r3, #0]
		return x;
 801f2da:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801f2de:	e024      	b.n	801f32a <frexp+0xce>
	} else if (ee == 0x7ff) {
 801f2e0:	697b      	ldr	r3, [r7, #20]
 801f2e2:	f240 72ff 	movw	r2, #2047	; 0x7ff
 801f2e6:	4293      	cmp	r3, r2
 801f2e8:	d102      	bne.n	801f2f0 <frexp+0x94>
		return x;
 801f2ea:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801f2ee:	e01c      	b.n	801f32a <frexp+0xce>
	}

	*e = ee - 0x3fe;
 801f2f0:	697b      	ldr	r3, [r7, #20]
 801f2f2:	f2a3 32fe 	subw	r2, r3, #1022	; 0x3fe
 801f2f6:	687b      	ldr	r3, [r7, #4]
 801f2f8:	601a      	str	r2, [r3, #0]
	y.i &= 0x800fffffffffffffull;
 801f2fa:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801f2fe:	f04f 30ff 	mov.w	r0, #4294967295
 801f302:	490e      	ldr	r1, [pc, #56]	; (801f33c <frexp+0xe0>)
 801f304:	ea02 0800 	and.w	r8, r2, r0
 801f308:	ea03 0901 	and.w	r9, r3, r1
 801f30c:	e9c7 8906 	strd	r8, r9, [r7, #24]
	y.i |= 0x3fe0000000000000ull;
 801f310:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 801f314:	f04f 0000 	mov.w	r0, #0
 801f318:	4909      	ldr	r1, [pc, #36]	; (801f340 <frexp+0xe4>)
 801f31a:	ea42 0400 	orr.w	r4, r2, r0
 801f31e:	ea43 0501 	orr.w	r5, r3, r1
 801f322:	e9c7 4506 	strd	r4, r5, [r7, #24]
	return y.d;
 801f326:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
}
 801f32a:	4610      	mov	r0, r2
 801f32c:	4619      	mov	r1, r3
 801f32e:	3720      	adds	r7, #32
 801f330:	46bd      	mov	sp, r7
 801f332:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 801f336:	bf00      	nop
 801f338:	43f00000 	.word	0x43f00000
 801f33c:	800fffff 	.word	0x800fffff
 801f340:	3fe00000 	.word	0x3fe00000

0801f344 <wctomb>:
#include <stdlib.h>
#include <wchar.h>

int wctomb(char *s, wchar_t wc)
{
 801f344:	b580      	push	{r7, lr}
 801f346:	b082      	sub	sp, #8
 801f348:	af00      	add	r7, sp, #0
 801f34a:	6078      	str	r0, [r7, #4]
 801f34c:	6039      	str	r1, [r7, #0]
	if (!s) return 0;
 801f34e:	687b      	ldr	r3, [r7, #4]
 801f350:	2b00      	cmp	r3, #0
 801f352:	d101      	bne.n	801f358 <wctomb+0x14>
 801f354:	2300      	movs	r3, #0
 801f356:	e005      	b.n	801f364 <wctomb+0x20>
	return wcrtomb(s, wc, 0);
 801f358:	2200      	movs	r2, #0
 801f35a:	6839      	ldr	r1, [r7, #0]
 801f35c:	6878      	ldr	r0, [r7, #4]
 801f35e:	f000 faa3 	bl	801f8a8 <wcrtomb>
 801f362:	4603      	mov	r3, r0
}
 801f364:	4618      	mov	r0, r3
 801f366:	3708      	adds	r7, #8
 801f368:	46bd      	mov	sp, r7
 801f36a:	bd80      	pop	{r7, pc}

0801f36c <LOS_ListInit>:
{
 801f36c:	b480      	push	{r7}
 801f36e:	b083      	sub	sp, #12
 801f370:	af00      	add	r7, sp, #0
 801f372:	6078      	str	r0, [r7, #4]
    list->pstNext = list;
 801f374:	687b      	ldr	r3, [r7, #4]
 801f376:	687a      	ldr	r2, [r7, #4]
 801f378:	605a      	str	r2, [r3, #4]
    list->pstPrev = list;
 801f37a:	687b      	ldr	r3, [r7, #4]
 801f37c:	687a      	ldr	r2, [r7, #4]
 801f37e:	601a      	str	r2, [r3, #0]
}
 801f380:	bf00      	nop
 801f382:	370c      	adds	r7, #12
 801f384:	46bd      	mov	sp, r7
 801f386:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f38a:	4770      	bx	lr

0801f38c <ArchCurrCpuid>:
{
 801f38c:	b480      	push	{r7}
 801f38e:	af00      	add	r7, sp, #0
    return 0;
 801f390:	2300      	movs	r3, #0
}
 801f392:	4618      	mov	r0, r3
 801f394:	46bd      	mov	sp, r7
 801f396:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f39a:	4770      	bx	lr

0801f39c <LOS_IntLock>:
{
 801f39c:	b580      	push	{r7, lr}
 801f39e:	af00      	add	r7, sp, #0
    return ArchIntLock();
 801f3a0:	f7e1 fc92 	bl	8000cc8 <ArchIntLock>
 801f3a4:	4603      	mov	r3, r0
}
 801f3a6:	4618      	mov	r0, r3
 801f3a8:	bd80      	pop	{r7, pc}

0801f3aa <LOS_IntRestore>:
{
 801f3aa:	b580      	push	{r7, lr}
 801f3ac:	b082      	sub	sp, #8
 801f3ae:	af00      	add	r7, sp, #0
 801f3b0:	6078      	str	r0, [r7, #4]
    ArchIntRestore(intSave);
 801f3b2:	6878      	ldr	r0, [r7, #4]
 801f3b4:	f7e1 fc90 	bl	8000cd8 <ArchIntRestore>
}
 801f3b8:	bf00      	nop
 801f3ba:	3708      	adds	r7, #8
 801f3bc:	46bd      	mov	sp, r7
 801f3be:	bd80      	pop	{r7, pc}

0801f3c0 <ArchCurrTaskGet>:
{
 801f3c0:	b480      	push	{r7}
 801f3c2:	af00      	add	r7, sp, #0
    return g_runTask;
 801f3c4:	4b03      	ldr	r3, [pc, #12]	; (801f3d4 <ArchCurrTaskGet+0x14>)
 801f3c6:	681b      	ldr	r3, [r3, #0]
}
 801f3c8:	4618      	mov	r0, r3
 801f3ca:	46bd      	mov	sp, r7
 801f3cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f3d0:	4770      	bx	lr
 801f3d2:	bf00      	nop
 801f3d4:	200033cc 	.word	0x200033cc

0801f3d8 <OsPercpuGet>:
{
 801f3d8:	b580      	push	{r7, lr}
 801f3da:	af00      	add	r7, sp, #0
    return &g_percpu[ArchCurrCpuid()];
 801f3dc:	f7ff ffd6 	bl	801f38c <ArchCurrCpuid>
 801f3e0:	4602      	mov	r2, r0
 801f3e2:	4613      	mov	r3, r2
 801f3e4:	00db      	lsls	r3, r3, #3
 801f3e6:	4413      	add	r3, r2
 801f3e8:	009b      	lsls	r3, r3, #2
 801f3ea:	4a02      	ldr	r2, [pc, #8]	; (801f3f4 <OsPercpuGet+0x1c>)
 801f3ec:	4413      	add	r3, r2
}
 801f3ee:	4618      	mov	r0, r3
 801f3f0:	bd80      	pop	{r7, pc}
 801f3f2:	bf00      	nop
 801f3f4:	200036fc 	.word	0x200036fc

0801f3f8 <OsPreemptableInSched>:
{
 801f3f8:	b580      	push	{r7, lr}
 801f3fa:	b082      	sub	sp, #8
 801f3fc:	af00      	add	r7, sp, #0
    BOOL preemptable = FALSE;
 801f3fe:	2300      	movs	r3, #0
 801f400:	607b      	str	r3, [r7, #4]
    preemptable = (OsPercpuGet()->taskLockCnt == 0);
 801f402:	f7ff ffe9 	bl	801f3d8 <OsPercpuGet>
 801f406:	4603      	mov	r3, r0
 801f408:	695b      	ldr	r3, [r3, #20]
 801f40a:	2b00      	cmp	r3, #0
 801f40c:	bf0c      	ite	eq
 801f40e:	2301      	moveq	r3, #1
 801f410:	2300      	movne	r3, #0
 801f412:	b2db      	uxtb	r3, r3
 801f414:	607b      	str	r3, [r7, #4]
    if (!preemptable) {
 801f416:	687b      	ldr	r3, [r7, #4]
 801f418:	2b00      	cmp	r3, #0
 801f41a:	d104      	bne.n	801f426 <OsPreemptableInSched+0x2e>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 801f41c:	f7ff ffdc 	bl	801f3d8 <OsPercpuGet>
 801f420:	4603      	mov	r3, r0
 801f422:	2201      	movs	r2, #1
 801f424:	621a      	str	r2, [r3, #32]
    return preemptable;
 801f426:	687b      	ldr	r3, [r7, #4]
}
 801f428:	4618      	mov	r0, r3
 801f42a:	3708      	adds	r7, #8
 801f42c:	46bd      	mov	sp, r7
 801f42e:	bd80      	pop	{r7, pc}

0801f430 <LOS_Schedule>:
{
 801f430:	b580      	push	{r7, lr}
 801f432:	af00      	add	r7, sp, #0
    if (OS_INT_ACTIVE) {
 801f434:	f7e3 f914 	bl	8002660 <IntActive>
 801f438:	4603      	mov	r3, r0
 801f43a:	2b00      	cmp	r3, #0
 801f43c:	d005      	beq.n	801f44a <LOS_Schedule+0x1a>
        OsPercpuGet()->schedFlag = INT_PEND_RESCH;
 801f43e:	f7ff ffcb 	bl	801f3d8 <OsPercpuGet>
 801f442:	4603      	mov	r3, r0
 801f444:	2201      	movs	r2, #1
 801f446:	621a      	str	r2, [r3, #32]
        return;
 801f448:	e001      	b.n	801f44e <LOS_Schedule+0x1e>
    OsSchedPreempt();
 801f44a:	f7e9 fc73 	bl	8008d34 <OsSchedPreempt>
}
 801f44e:	bd80      	pop	{r7, pc}

0801f450 <LOS_SpinLockSave>:
{
 801f450:	b580      	push	{r7, lr}
 801f452:	b082      	sub	sp, #8
 801f454:	af00      	add	r7, sp, #0
 801f456:	6078      	str	r0, [r7, #4]
 801f458:	6039      	str	r1, [r7, #0]
    *intSave = LOS_IntLock();
 801f45a:	f7ff ff9f 	bl	801f39c <LOS_IntLock>
 801f45e:	4602      	mov	r2, r0
 801f460:	683b      	ldr	r3, [r7, #0]
 801f462:	601a      	str	r2, [r3, #0]
}
 801f464:	bf00      	nop
 801f466:	3708      	adds	r7, #8
 801f468:	46bd      	mov	sp, r7
 801f46a:	bd80      	pop	{r7, pc}

0801f46c <LOS_SpinUnlockRestore>:
{
 801f46c:	b580      	push	{r7, lr}
 801f46e:	b082      	sub	sp, #8
 801f470:	af00      	add	r7, sp, #0
 801f472:	6078      	str	r0, [r7, #4]
 801f474:	6039      	str	r1, [r7, #0]
    LOS_IntRestore(intSave);
 801f476:	6838      	ldr	r0, [r7, #0]
 801f478:	f7ff ff97 	bl	801f3aa <LOS_IntRestore>
}
 801f47c:	bf00      	nop
 801f47e:	3708      	adds	r7, #8
 801f480:	46bd      	mov	sp, r7
 801f482:	bd80      	pop	{r7, pc}

0801f484 <OsCurrTaskGet>:
{
 801f484:	b580      	push	{r7, lr}
 801f486:	af00      	add	r7, sp, #0
    return (LosTaskCB *)ArchCurrTaskGet();
 801f488:	f7ff ff9a 	bl	801f3c0 <ArchCurrTaskGet>
 801f48c:	4603      	mov	r3, r0
}
 801f48e:	4618      	mov	r0, r3
 801f490:	bd80      	pop	{r7, pc}

0801f492 <OsMuxDlockNodeInsertHook>:
{
 801f492:	b580      	push	{r7, lr}
 801f494:	b082      	sub	sp, #8
 801f496:	af00      	add	r7, sp, #0
 801f498:	6078      	str	r0, [r7, #4]
 801f49a:	6039      	str	r1, [r7, #0]
    OsMuxDlockNodeInsert(taskId, muxCB);
 801f49c:	6839      	ldr	r1, [r7, #0]
 801f49e:	6878      	ldr	r0, [r7, #4]
 801f4a0:	f7e7 fa54 	bl	800694c <OsMuxDlockNodeInsert>
}
 801f4a4:	bf00      	nop
 801f4a6:	3708      	adds	r7, #8
 801f4a8:	46bd      	mov	sp, r7
 801f4aa:	bd80      	pop	{r7, pc}

0801f4ac <LOS_MpSchedule>:
{
 801f4ac:	b480      	push	{r7}
 801f4ae:	b083      	sub	sp, #12
 801f4b0:	af00      	add	r7, sp, #0
 801f4b2:	6078      	str	r0, [r7, #4]
}
 801f4b4:	bf00      	nop
 801f4b6:	370c      	adds	r7, #12
 801f4b8:	46bd      	mov	sp, r7
 801f4ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f4be:	4770      	bx	lr

0801f4c0 <CheckMutexAttr>:
    attr->type = (UINT8)((attr->type & ~MUTEXATTR_TYPE_MASK) | (UINT32)type);
    return ENOERR;
}

STATIC UINT32 CheckMutexAttr(const pthread_mutexattr_t *attr)
{
 801f4c0:	b480      	push	{r7}
 801f4c2:	b083      	sub	sp, #12
 801f4c4:	af00      	add	r7, sp, #0
 801f4c6:	6078      	str	r0, [r7, #4]
    if (((INT8)(attr->type) < PTHREAD_MUTEX_NORMAL) ||
 801f4c8:	687b      	ldr	r3, [r7, #4]
 801f4ca:	789b      	ldrb	r3, [r3, #2]
 801f4cc:	b25b      	sxtb	r3, r3
 801f4ce:	2b00      	cmp	r3, #0
 801f4d0:	db03      	blt.n	801f4da <CheckMutexAttr+0x1a>
        (attr->type > PTHREAD_MUTEX_ERRORCHECK)) {
 801f4d2:	687b      	ldr	r3, [r7, #4]
 801f4d4:	789b      	ldrb	r3, [r3, #2]
    if (((INT8)(attr->type) < PTHREAD_MUTEX_NORMAL) ||
 801f4d6:	2b02      	cmp	r3, #2
 801f4d8:	d901      	bls.n	801f4de <CheckMutexAttr+0x1e>
        return LOS_NOK;
 801f4da:	2301      	movs	r3, #1
 801f4dc:	e016      	b.n	801f50c <CheckMutexAttr+0x4c>
    }
    if (((INT8)(attr->prioceiling) < OS_TASK_PRIORITY_HIGHEST) ||
 801f4de:	687b      	ldr	r3, [r7, #4]
 801f4e0:	785b      	ldrb	r3, [r3, #1]
 801f4e2:	b25b      	sxtb	r3, r3
 801f4e4:	2b00      	cmp	r3, #0
 801f4e6:	db03      	blt.n	801f4f0 <CheckMutexAttr+0x30>
        (attr->prioceiling > OS_TASK_PRIORITY_LOWEST)) {
 801f4e8:	687b      	ldr	r3, [r7, #4]
 801f4ea:	785b      	ldrb	r3, [r3, #1]
    if (((INT8)(attr->prioceiling) < OS_TASK_PRIORITY_HIGHEST) ||
 801f4ec:	2b1f      	cmp	r3, #31
 801f4ee:	d901      	bls.n	801f4f4 <CheckMutexAttr+0x34>
        return LOS_NOK;
 801f4f0:	2301      	movs	r3, #1
 801f4f2:	e00b      	b.n	801f50c <CheckMutexAttr+0x4c>
    }
    if (((INT8)(attr->protocol) < PTHREAD_PRIO_NONE) ||
 801f4f4:	687b      	ldr	r3, [r7, #4]
 801f4f6:	781b      	ldrb	r3, [r3, #0]
 801f4f8:	b25b      	sxtb	r3, r3
 801f4fa:	2b00      	cmp	r3, #0
 801f4fc:	db03      	blt.n	801f506 <CheckMutexAttr+0x46>
        (attr->protocol > PTHREAD_PRIO_PROTECT)) {
 801f4fe:	687b      	ldr	r3, [r7, #4]
 801f500:	781b      	ldrb	r3, [r3, #0]
    if (((INT8)(attr->protocol) < PTHREAD_PRIO_NONE) ||
 801f502:	2b02      	cmp	r3, #2
 801f504:	d901      	bls.n	801f50a <CheckMutexAttr+0x4a>
        return LOS_NOK;
 801f506:	2301      	movs	r3, #1
 801f508:	e000      	b.n	801f50c <CheckMutexAttr+0x4c>
    }
    return LOS_OK;
 801f50a:	2300      	movs	r3, #0
}
 801f50c:	4618      	mov	r0, r3
 801f50e:	370c      	adds	r7, #12
 801f510:	46bd      	mov	sp, r7
 801f512:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f516:	4770      	bx	lr

0801f518 <OsMuxPreCheck>:
    SCHEDULER_UNLOCK(intSave);
    return ENOERR;
}

UINT32 OsMuxPreCheck(const pthread_mutex_t *mutex, const LosTaskCB *runTask)
{
 801f518:	b580      	push	{r7, lr}
 801f51a:	b082      	sub	sp, #8
 801f51c:	af00      	add	r7, sp, #0
 801f51e:	6078      	str	r0, [r7, #4]
 801f520:	6039      	str	r1, [r7, #0]
    if (mutex == NULL) {
 801f522:	687b      	ldr	r3, [r7, #4]
 801f524:	2b00      	cmp	r3, #0
 801f526:	d101      	bne.n	801f52c <OsMuxPreCheck+0x14>
        return EINVAL;
 801f528:	2316      	movs	r3, #22
 801f52a:	e010      	b.n	801f54e <OsMuxPreCheck+0x36>
    }

    if (OS_INT_ACTIVE) {
 801f52c:	f7e3 f898 	bl	8002660 <IntActive>
 801f530:	4603      	mov	r3, r0
 801f532:	2b00      	cmp	r3, #0
 801f534:	d001      	beq.n	801f53a <OsMuxPreCheck+0x22>
        return EPERM;
 801f536:	2301      	movs	r3, #1
 801f538:	e009      	b.n	801f54e <OsMuxPreCheck+0x36>
    /* DO NOT recommend to use blocking API in system tasks */
    if (runTask->taskFlags & OS_TASK_FLAG_SYSTEM) {
        PRINT_DEBUG("Warning: DO NOT recommend to use %s in system tasks.\n", __FUNCTION__);
    }

    if (CheckMutexAttr(&mutex->stAttr) != LOS_OK) {
 801f53a:	687b      	ldr	r3, [r7, #4]
 801f53c:	4618      	mov	r0, r3
 801f53e:	f7ff ffbf 	bl	801f4c0 <CheckMutexAttr>
 801f542:	4603      	mov	r3, r0
 801f544:	2b00      	cmp	r3, #0
 801f546:	d001      	beq.n	801f54c <OsMuxPreCheck+0x34>
        return EINVAL;
 801f548:	2316      	movs	r3, #22
 801f54a:	e000      	b.n	801f54e <OsMuxPreCheck+0x36>
    }

    return ENOERR;
 801f54c:	2300      	movs	r3, #0
}
 801f54e:	4618      	mov	r0, r3
 801f550:	3708      	adds	r7, #8
 801f552:	46bd      	mov	sp, r7
 801f554:	bd80      	pop	{r7, pc}

0801f556 <pthread_mutex_lock>:

/* Lock mutex, waiting for it if necessary. */
int pthread_mutex_lock(pthread_mutex_t *mutex)
{
 801f556:	b580      	push	{r7, lr}
 801f558:	b086      	sub	sp, #24
 801f55a:	af00      	add	r7, sp, #0
 801f55c:	6078      	str	r0, [r7, #4]
    MuxBaseCB *muxPended = NULL;
 801f55e:	2300      	movs	r3, #0
 801f560:	60fb      	str	r3, [r7, #12]
    LosTaskCB *runTask = NULL;
 801f562:	2300      	movs	r3, #0
 801f564:	613b      	str	r3, [r7, #16]
    UINT32 ret;

    runTask = (LosTaskCB*)OsCurrTaskGet();
 801f566:	f7ff ff8d 	bl	801f484 <OsCurrTaskGet>
 801f56a:	6138      	str	r0, [r7, #16]
    ret = OsMuxPreCheck(mutex, runTask);
 801f56c:	6939      	ldr	r1, [r7, #16]
 801f56e:	6878      	ldr	r0, [r7, #4]
 801f570:	f7ff ffd2 	bl	801f518 <OsMuxPreCheck>
 801f574:	6178      	str	r0, [r7, #20]
    if (ret != ENOERR) {
 801f576:	697b      	ldr	r3, [r7, #20]
 801f578:	2b00      	cmp	r3, #0
 801f57a:	d001      	beq.n	801f580 <pthread_mutex_lock+0x2a>
        return (INT32)ret;
 801f57c:	697b      	ldr	r3, [r7, #20]
 801f57e:	e01b      	b.n	801f5b8 <pthread_mutex_lock+0x62>
    }

    muxPended = &mutex->stLock;
 801f580:	687b      	ldr	r3, [r7, #4]
 801f582:	3304      	adds	r3, #4
 801f584:	60fb      	str	r3, [r7, #12]
    if ((mutex->stAttr.type == PTHREAD_MUTEX_ERRORCHECK) &&
 801f586:	687b      	ldr	r3, [r7, #4]
 801f588:	789b      	ldrb	r3, [r3, #2]
 801f58a:	2b02      	cmp	r3, #2
 801f58c:	d10a      	bne.n	801f5a4 <pthread_mutex_lock+0x4e>
        (muxPended->muxCount != 0) &&
 801f58e:	68fb      	ldr	r3, [r7, #12]
 801f590:	899b      	ldrh	r3, [r3, #12]
    if ((mutex->stAttr.type == PTHREAD_MUTEX_ERRORCHECK) &&
 801f592:	2b00      	cmp	r3, #0
 801f594:	d006      	beq.n	801f5a4 <pthread_mutex_lock+0x4e>
        (muxPended->owner == runTask)) {
 801f596:	68fb      	ldr	r3, [r7, #12]
 801f598:	689b      	ldr	r3, [r3, #8]
        (muxPended->muxCount != 0) &&
 801f59a:	693a      	ldr	r2, [r7, #16]
 801f59c:	429a      	cmp	r2, r3
 801f59e:	d101      	bne.n	801f5a4 <pthread_mutex_lock+0x4e>
        return EDEADLK;
 801f5a0:	2323      	movs	r3, #35	; 0x23
 801f5a2:	e009      	b.n	801f5b8 <pthread_mutex_lock+0x62>
    }

    ret = OsMuxPendForPosix(mutex, LOS_WAIT_FOREVER);
 801f5a4:	f04f 31ff 	mov.w	r1, #4294967295
 801f5a8:	6878      	ldr	r0, [r7, #4]
 801f5aa:	f000 f84d 	bl	801f648 <OsMuxPendForPosix>
 801f5ae:	6178      	str	r0, [r7, #20]
    return map_errno(ret);
 801f5b0:	6978      	ldr	r0, [r7, #20]
 801f5b2:	f000 fa15 	bl	801f9e0 <map_errno>
 801f5b6:	4603      	mov	r3, r0
}
 801f5b8:	4618      	mov	r0, r3
 801f5ba:	3718      	adds	r7, #24
 801f5bc:	46bd      	mov	sp, r7
 801f5be:	bd80      	pop	{r7, pc}

0801f5c0 <pthread_mutex_unlock>:
    ret = OsMuxPendForPosix(mutex, 0);
    return map_errno(ret);
}

int pthread_mutex_unlock(pthread_mutex_t *mutex)
{
 801f5c0:	b580      	push	{r7, lr}
 801f5c2:	b084      	sub	sp, #16
 801f5c4:	af00      	add	r7, sp, #0
 801f5c6:	6078      	str	r0, [r7, #4]
    LosTaskCB *runTask = NULL;
 801f5c8:	2300      	movs	r3, #0
 801f5ca:	60bb      	str	r3, [r7, #8]
    UINT32 ret;

    runTask = (LosTaskCB*)OsCurrTaskGet();
 801f5cc:	f7ff ff5a 	bl	801f484 <OsCurrTaskGet>
 801f5d0:	60b8      	str	r0, [r7, #8]
    ret = OsMuxPreCheck(mutex, runTask);
 801f5d2:	68b9      	ldr	r1, [r7, #8]
 801f5d4:	6878      	ldr	r0, [r7, #4]
 801f5d6:	f7ff ff9f 	bl	801f518 <OsMuxPreCheck>
 801f5da:	60f8      	str	r0, [r7, #12]
    if (ret != ENOERR) {
 801f5dc:	68fb      	ldr	r3, [r7, #12]
 801f5de:	2b00      	cmp	r3, #0
 801f5e0:	d001      	beq.n	801f5e6 <pthread_mutex_unlock+0x26>
        return (INT32)ret;
 801f5e2:	68fb      	ldr	r3, [r7, #12]
 801f5e4:	e003      	b.n	801f5ee <pthread_mutex_unlock+0x2e>
    }

    return OsMuxPostForPosix(mutex);
 801f5e6:	6878      	ldr	r0, [r7, #4]
 801f5e8:	f000 f8da 	bl	801f7a0 <OsMuxPostForPosix>
 801f5ec:	4603      	mov	r3, r0
}
 801f5ee:	4618      	mov	r0, r3
 801f5f0:	3710      	adds	r7, #16
 801f5f2:	46bd      	mov	sp, r7
 801f5f4:	bd80      	pop	{r7, pc}

0801f5f6 <OsMuxBitmapSet>:

STATIC VOID OsMuxBitmapSet(const pthread_mutex_t *mutex, const LosTaskCB *runTask, const MuxBaseCB *muxPended)
{
 801f5f6:	b580      	push	{r7, lr}
 801f5f8:	b084      	sub	sp, #16
 801f5fa:	af00      	add	r7, sp, #0
 801f5fc:	60f8      	str	r0, [r7, #12]
 801f5fe:	60b9      	str	r1, [r7, #8]
 801f600:	607a      	str	r2, [r7, #4]
    if ((muxPended->owner->priority > runTask->priority) &&
 801f602:	687b      	ldr	r3, [r7, #4]
 801f604:	689b      	ldr	r3, [r3, #8]
 801f606:	88da      	ldrh	r2, [r3, #6]
 801f608:	68bb      	ldr	r3, [r7, #8]
 801f60a:	88db      	ldrh	r3, [r3, #6]
 801f60c:	429a      	cmp	r2, r3
 801f60e:	d916      	bls.n	801f63e <OsMuxBitmapSet+0x48>
        (mutex->stAttr.protocol == PTHREAD_PRIO_INHERIT)) {
 801f610:	68fb      	ldr	r3, [r7, #12]
 801f612:	781b      	ldrb	r3, [r3, #0]
    if ((muxPended->owner->priority > runTask->priority) &&
 801f614:	2b01      	cmp	r3, #1
 801f616:	d112      	bne.n	801f63e <OsMuxBitmapSet+0x48>
        LOS_BitmapSet(&(muxPended->owner->priBitMap), muxPended->owner->priority);
 801f618:	687b      	ldr	r3, [r7, #4]
 801f61a:	689b      	ldr	r3, [r3, #8]
 801f61c:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 801f620:	687b      	ldr	r3, [r7, #4]
 801f622:	689b      	ldr	r3, [r3, #8]
 801f624:	88db      	ldrh	r3, [r3, #6]
 801f626:	4619      	mov	r1, r3
 801f628:	4610      	mov	r0, r2
 801f62a:	f7ec fbbd 	bl	800bda8 <LOS_BitmapSet>
        OsTaskPriModify(muxPended->owner, runTask->priority);
 801f62e:	687b      	ldr	r3, [r7, #4]
 801f630:	689a      	ldr	r2, [r3, #8]
 801f632:	68bb      	ldr	r3, [r7, #8]
 801f634:	88db      	ldrh	r3, [r3, #6]
 801f636:	4619      	mov	r1, r3
 801f638:	4610      	mov	r0, r2
 801f63a:	f7e3 fba3 	bl	8002d84 <OsTaskPriModify>
    }
}
 801f63e:	bf00      	nop
 801f640:	3710      	adds	r7, #16
 801f642:	46bd      	mov	sp, r7
 801f644:	bd80      	pop	{r7, pc}
	...

0801f648 <OsMuxPendForPosix>:

STATIC UINT32 OsMuxPendForPosix(pthread_mutex_t *mutex, UINT32 timeout)
{
 801f648:	b580      	push	{r7, lr}
 801f64a:	b088      	sub	sp, #32
 801f64c:	af00      	add	r7, sp, #0
 801f64e:	6078      	str	r0, [r7, #4]
 801f650:	6039      	str	r1, [r7, #0]
 801f652:	4b50      	ldr	r3, [pc, #320]	; (801f794 <OsMuxPendForPosix+0x14c>)
 801f654:	681b      	ldr	r3, [r3, #0]
 801f656:	61fb      	str	r3, [r7, #28]
 801f658:	f04f 0300 	mov.w	r3, #0
    UINT32 retErr;
    UINT32 intSave;
    MuxBaseCB *muxPended = &mutex->stLock;
 801f65c:	687b      	ldr	r3, [r7, #4]
 801f65e:	3304      	adds	r3, #4
 801f660:	617b      	str	r3, [r7, #20]
    LosTaskCB *runTask = NULL;
 801f662:	2300      	movs	r3, #0
 801f664:	61bb      	str	r3, [r7, #24]

    SCHEDULER_LOCK(intSave);
 801f666:	f107 030c 	add.w	r3, r7, #12
 801f66a:	4619      	mov	r1, r3
 801f66c:	484a      	ldr	r0, [pc, #296]	; (801f798 <OsMuxPendForPosix+0x150>)
 801f66e:	f7ff feef 	bl	801f450 <LOS_SpinLockSave>
    if ((muxPended->muxList.pstPrev == NULL) ||
 801f672:	697b      	ldr	r3, [r7, #20]
 801f674:	681b      	ldr	r3, [r3, #0]
 801f676:	2b00      	cmp	r3, #0
 801f678:	d003      	beq.n	801f682 <OsMuxPendForPosix+0x3a>
        (muxPended->muxList.pstNext == NULL)) {
 801f67a:	697b      	ldr	r3, [r7, #20]
 801f67c:	685b      	ldr	r3, [r3, #4]
    if ((muxPended->muxList.pstPrev == NULL) ||
 801f67e:	2b00      	cmp	r3, #0
 801f680:	d109      	bne.n	801f696 <OsMuxPendForPosix+0x4e>
        /* This is for mutex macro initialization. */
        muxPended->muxCount = 0;
 801f682:	697b      	ldr	r3, [r7, #20]
 801f684:	2200      	movs	r2, #0
 801f686:	819a      	strh	r2, [r3, #12]
        muxPended->owner = NULL;
 801f688:	697b      	ldr	r3, [r7, #20]
 801f68a:	2200      	movs	r2, #0
 801f68c:	609a      	str	r2, [r3, #8]
        LOS_ListInit(&muxPended->muxList);
 801f68e:	697b      	ldr	r3, [r7, #20]
 801f690:	4618      	mov	r0, r3
 801f692:	f7ff fe6b 	bl	801f36c <LOS_ListInit>
    }
    runTask = OsCurrTaskGet();
 801f696:	f7ff fef5 	bl	801f484 <OsCurrTaskGet>
 801f69a:	61b8      	str	r0, [r7, #24]
    if (muxPended->muxCount == 0) {
 801f69c:	697b      	ldr	r3, [r7, #20]
 801f69e:	899b      	ldrh	r3, [r3, #12]
 801f6a0:	2b00      	cmp	r3, #0
 801f6a2:	d130      	bne.n	801f706 <OsMuxPendForPosix+0xbe>
        muxPended->muxCount++;
 801f6a4:	697b      	ldr	r3, [r7, #20]
 801f6a6:	899b      	ldrh	r3, [r3, #12]
 801f6a8:	3301      	adds	r3, #1
 801f6aa:	b29a      	uxth	r2, r3
 801f6ac:	697b      	ldr	r3, [r7, #20]
 801f6ae:	819a      	strh	r2, [r3, #12]
        muxPended->owner = runTask;
 801f6b0:	697b      	ldr	r3, [r7, #20]
 801f6b2:	69ba      	ldr	r2, [r7, #24]
 801f6b4:	609a      	str	r2, [r3, #8]
        OsMuxDlockNodeInsertHook(runTask->taskId, muxPended);
 801f6b6:	69bb      	ldr	r3, [r7, #24]
 801f6b8:	695b      	ldr	r3, [r3, #20]
 801f6ba:	6979      	ldr	r1, [r7, #20]
 801f6bc:	4618      	mov	r0, r3
 801f6be:	f7ff fee8 	bl	801f492 <OsMuxDlockNodeInsertHook>

        if ((runTask->priority > mutex->stAttr.prioceiling) &&
 801f6c2:	69bb      	ldr	r3, [r7, #24]
 801f6c4:	88da      	ldrh	r2, [r3, #6]
 801f6c6:	687b      	ldr	r3, [r7, #4]
 801f6c8:	785b      	ldrb	r3, [r3, #1]
 801f6ca:	b29b      	uxth	r3, r3
 801f6cc:	429a      	cmp	r2, r3
 801f6ce:	d913      	bls.n	801f6f8 <OsMuxPendForPosix+0xb0>
            (mutex->stAttr.protocol == PTHREAD_PRIO_PROTECT)) {
 801f6d0:	687b      	ldr	r3, [r7, #4]
 801f6d2:	781b      	ldrb	r3, [r3, #0]
        if ((runTask->priority > mutex->stAttr.prioceiling) &&
 801f6d4:	2b02      	cmp	r3, #2
 801f6d6:	d10f      	bne.n	801f6f8 <OsMuxPendForPosix+0xb0>
            LOS_BitmapSet(&runTask->priBitMap, runTask->priority);
 801f6d8:	69bb      	ldr	r3, [r7, #24]
 801f6da:	f103 026c 	add.w	r2, r3, #108	; 0x6c
 801f6de:	69bb      	ldr	r3, [r7, #24]
 801f6e0:	88db      	ldrh	r3, [r3, #6]
 801f6e2:	4619      	mov	r1, r3
 801f6e4:	4610      	mov	r0, r2
 801f6e6:	f7ec fb5f 	bl	800bda8 <LOS_BitmapSet>
            OsTaskPriModify(runTask, mutex->stAttr.prioceiling);
 801f6ea:	687b      	ldr	r3, [r7, #4]
 801f6ec:	785b      	ldrb	r3, [r3, #1]
 801f6ee:	b29b      	uxth	r3, r3
 801f6f0:	4619      	mov	r1, r3
 801f6f2:	69b8      	ldr	r0, [r7, #24]
 801f6f4:	f7e3 fb46 	bl	8002d84 <OsTaskPriModify>
        }

        SCHEDULER_UNLOCK(intSave);
 801f6f8:	68fb      	ldr	r3, [r7, #12]
 801f6fa:	4619      	mov	r1, r3
 801f6fc:	4826      	ldr	r0, [pc, #152]	; (801f798 <OsMuxPendForPosix+0x150>)
 801f6fe:	f7ff feb5 	bl	801f46c <LOS_SpinUnlockRestore>
        return LOS_OK;
 801f702:	2300      	movs	r3, #0
 801f704:	e03b      	b.n	801f77e <OsMuxPendForPosix+0x136>
    }

    if ((muxPended->owner == runTask) &&
 801f706:	697b      	ldr	r3, [r7, #20]
 801f708:	689b      	ldr	r3, [r3, #8]
 801f70a:	69ba      	ldr	r2, [r7, #24]
 801f70c:	429a      	cmp	r2, r3
 801f70e:	d110      	bne.n	801f732 <OsMuxPendForPosix+0xea>
        (mutex->stAttr.type == PTHREAD_MUTEX_RECURSIVE)) {
 801f710:	687b      	ldr	r3, [r7, #4]
 801f712:	789b      	ldrb	r3, [r3, #2]
    if ((muxPended->owner == runTask) &&
 801f714:	2b01      	cmp	r3, #1
 801f716:	d10c      	bne.n	801f732 <OsMuxPendForPosix+0xea>
        muxPended->muxCount++;
 801f718:	697b      	ldr	r3, [r7, #20]
 801f71a:	899b      	ldrh	r3, [r3, #12]
 801f71c:	3301      	adds	r3, #1
 801f71e:	b29a      	uxth	r2, r3
 801f720:	697b      	ldr	r3, [r7, #20]
 801f722:	819a      	strh	r2, [r3, #12]
        SCHEDULER_UNLOCK(intSave);
 801f724:	68fb      	ldr	r3, [r7, #12]
 801f726:	4619      	mov	r1, r3
 801f728:	481b      	ldr	r0, [pc, #108]	; (801f798 <OsMuxPendForPosix+0x150>)
 801f72a:	f7ff fe9f 	bl	801f46c <LOS_SpinUnlockRestore>
        return LOS_OK;
 801f72e:	2300      	movs	r3, #0
 801f730:	e025      	b.n	801f77e <OsMuxPendForPosix+0x136>
    }

    if (!OsPreemptableInSched()) {
 801f732:	f7ff fe61 	bl	801f3f8 <OsPreemptableInSched>
 801f736:	4603      	mov	r3, r0
 801f738:	2b00      	cmp	r3, #0
 801f73a:	d102      	bne.n	801f742 <OsMuxPendForPosix+0xfa>
        retErr = LOS_ERRNO_MUX_PEND_IN_LOCK;
 801f73c:	4b17      	ldr	r3, [pc, #92]	; (801f79c <OsMuxPendForPosix+0x154>)
 801f73e:	613b      	str	r3, [r7, #16]
        goto LOS_ERREND;
 801f740:	e017      	b.n	801f772 <OsMuxPendForPosix+0x12a>
    }

    OsMuxBitmapSet(mutex, runTask, muxPended);
 801f742:	697a      	ldr	r2, [r7, #20]
 801f744:	69b9      	ldr	r1, [r7, #24]
 801f746:	6878      	ldr	r0, [r7, #4]
 801f748:	f7ff ff55 	bl	801f5f6 <OsMuxBitmapSet>
    retErr = OsMuxPendOp(runTask, muxPended, timeout, &intSave);
 801f74c:	f107 030c 	add.w	r3, r7, #12
 801f750:	683a      	ldr	r2, [r7, #0]
 801f752:	6979      	ldr	r1, [r7, #20]
 801f754:	69b8      	ldr	r0, [r7, #24]
 801f756:	f7ec f8a1 	bl	800b89c <OsMuxPendOp>
 801f75a:	6138      	str	r0, [r7, #16]
    if (retErr != LOS_OK) {
 801f75c:	693b      	ldr	r3, [r7, #16]
 801f75e:	2b00      	cmp	r3, #0
 801f760:	d106      	bne.n	801f770 <OsMuxPendForPosix+0x128>
        goto LOS_ERREND;
    }

    SCHEDULER_UNLOCK(intSave);
 801f762:	68fb      	ldr	r3, [r7, #12]
 801f764:	4619      	mov	r1, r3
 801f766:	480c      	ldr	r0, [pc, #48]	; (801f798 <OsMuxPendForPosix+0x150>)
 801f768:	f7ff fe80 	bl	801f46c <LOS_SpinUnlockRestore>
    return LOS_OK;
 801f76c:	2300      	movs	r3, #0
 801f76e:	e006      	b.n	801f77e <OsMuxPendForPosix+0x136>
        goto LOS_ERREND;
 801f770:	bf00      	nop

LOS_ERREND:
    SCHEDULER_UNLOCK(intSave);
 801f772:	68fb      	ldr	r3, [r7, #12]
 801f774:	4619      	mov	r1, r3
 801f776:	4808      	ldr	r0, [pc, #32]	; (801f798 <OsMuxPendForPosix+0x150>)
 801f778:	f7ff fe78 	bl	801f46c <LOS_SpinUnlockRestore>
    return retErr;
 801f77c:	693b      	ldr	r3, [r7, #16]
}
 801f77e:	4a05      	ldr	r2, [pc, #20]	; (801f794 <OsMuxPendForPosix+0x14c>)
 801f780:	6811      	ldr	r1, [r2, #0]
 801f782:	69fa      	ldr	r2, [r7, #28]
 801f784:	4051      	eors	r1, r2
 801f786:	d001      	beq.n	801f78c <OsMuxPendForPosix+0x144>
 801f788:	f7e4 ff28 	bl	80045dc <__stack_chk_fail>
 801f78c:	4618      	mov	r0, r3
 801f78e:	3720      	adds	r7, #32
 801f790:	46bd      	mov	sp, r7
 801f792:	bd80      	pop	{r7, pc}
 801f794:	080232a0 	.word	0x080232a0
 801f798:	20000770 	.word	0x20000770
 801f79c:	02001d06 	.word	0x02001d06

0801f7a0 <OsMuxPostForPosix>:

STATIC INT32 OsMuxPostForPosix(pthread_mutex_t *mutex)
{
 801f7a0:	b580      	push	{r7, lr}
 801f7a2:	b088      	sub	sp, #32
 801f7a4:	af00      	add	r7, sp, #0
 801f7a6:	6078      	str	r0, [r7, #4]
 801f7a8:	4b3d      	ldr	r3, [pc, #244]	; (801f8a0 <OsMuxPostForPosix+0x100>)
 801f7aa:	681b      	ldr	r3, [r3, #0]
 801f7ac:	61fb      	str	r3, [r7, #28]
 801f7ae:	f04f 0300 	mov.w	r3, #0
    UINT32 intSave;
    UINT32 ret;
    UINT16 bitMapPri;
    MuxBaseCB *muxPosted = &mutex->stLock;
 801f7b2:	687b      	ldr	r3, [r7, #4]
 801f7b4:	3304      	adds	r3, #4
 801f7b6:	613b      	str	r3, [r7, #16]
    LosTaskCB *runTask = NULL;
 801f7b8:	2300      	movs	r3, #0
 801f7ba:	617b      	str	r3, [r7, #20]

    SCHEDULER_LOCK(intSave);
 801f7bc:	f107 030c 	add.w	r3, r7, #12
 801f7c0:	4619      	mov	r1, r3
 801f7c2:	4838      	ldr	r0, [pc, #224]	; (801f8a4 <OsMuxPostForPosix+0x104>)
 801f7c4:	f7ff fe44 	bl	801f450 <LOS_SpinLockSave>

    if (muxPosted->muxCount == 0) {
 801f7c8:	693b      	ldr	r3, [r7, #16]
 801f7ca:	899b      	ldrh	r3, [r3, #12]
 801f7cc:	2b00      	cmp	r3, #0
 801f7ce:	d106      	bne.n	801f7de <OsMuxPostForPosix+0x3e>
        SCHEDULER_UNLOCK(intSave);
 801f7d0:	68fb      	ldr	r3, [r7, #12]
 801f7d2:	4619      	mov	r1, r3
 801f7d4:	4833      	ldr	r0, [pc, #204]	; (801f8a4 <OsMuxPostForPosix+0x104>)
 801f7d6:	f7ff fe49 	bl	801f46c <LOS_SpinUnlockRestore>
        return EPERM;
 801f7da:	2301      	movs	r3, #1
 801f7dc:	e054      	b.n	801f888 <OsMuxPostForPosix+0xe8>
    }

    runTask = OsCurrTaskGet();
 801f7de:	f7ff fe51 	bl	801f484 <OsCurrTaskGet>
 801f7e2:	6178      	str	r0, [r7, #20]
    if (muxPosted->owner != runTask) {
 801f7e4:	693b      	ldr	r3, [r7, #16]
 801f7e6:	689b      	ldr	r3, [r3, #8]
 801f7e8:	697a      	ldr	r2, [r7, #20]
 801f7ea:	429a      	cmp	r2, r3
 801f7ec:	d006      	beq.n	801f7fc <OsMuxPostForPosix+0x5c>
        SCHEDULER_UNLOCK(intSave);
 801f7ee:	68fb      	ldr	r3, [r7, #12]
 801f7f0:	4619      	mov	r1, r3
 801f7f2:	482c      	ldr	r0, [pc, #176]	; (801f8a4 <OsMuxPostForPosix+0x104>)
 801f7f4:	f7ff fe3a 	bl	801f46c <LOS_SpinUnlockRestore>
        return EPERM;
 801f7f8:	2301      	movs	r3, #1
 801f7fa:	e045      	b.n	801f888 <OsMuxPostForPosix+0xe8>
    }

    if ((--muxPosted->muxCount != 0) &&
 801f7fc:	693b      	ldr	r3, [r7, #16]
 801f7fe:	899b      	ldrh	r3, [r3, #12]
 801f800:	3b01      	subs	r3, #1
 801f802:	b29a      	uxth	r2, r3
 801f804:	693b      	ldr	r3, [r7, #16]
 801f806:	819a      	strh	r2, [r3, #12]
 801f808:	693b      	ldr	r3, [r7, #16]
 801f80a:	899b      	ldrh	r3, [r3, #12]
 801f80c:	2b00      	cmp	r3, #0
 801f80e:	d00a      	beq.n	801f826 <OsMuxPostForPosix+0x86>
        (mutex->stAttr.type == PTHREAD_MUTEX_RECURSIVE)) {
 801f810:	687b      	ldr	r3, [r7, #4]
 801f812:	789b      	ldrb	r3, [r3, #2]
    if ((--muxPosted->muxCount != 0) &&
 801f814:	2b01      	cmp	r3, #1
 801f816:	d106      	bne.n	801f826 <OsMuxPostForPosix+0x86>
        SCHEDULER_UNLOCK(intSave);
 801f818:	68fb      	ldr	r3, [r7, #12]
 801f81a:	4619      	mov	r1, r3
 801f81c:	4821      	ldr	r0, [pc, #132]	; (801f8a4 <OsMuxPostForPosix+0x104>)
 801f81e:	f7ff fe25 	bl	801f46c <LOS_SpinUnlockRestore>
        return ENOERR;
 801f822:	2300      	movs	r3, #0
 801f824:	e030      	b.n	801f888 <OsMuxPostForPosix+0xe8>
    }

    if (mutex->stAttr.protocol == PTHREAD_PRIO_PROTECT) {
 801f826:	687b      	ldr	r3, [r7, #4]
 801f828:	781b      	ldrb	r3, [r3, #0]
 801f82a:	2b02      	cmp	r3, #2
 801f82c:	d115      	bne.n	801f85a <OsMuxPostForPosix+0xba>
        bitMapPri = LOS_HighBitGet(runTask->priBitMap);
 801f82e:	697b      	ldr	r3, [r7, #20]
 801f830:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801f832:	4618      	mov	r0, r3
 801f834:	f7ec faef 	bl	800be16 <LOS_HighBitGet>
 801f838:	4603      	mov	r3, r0
 801f83a:	817b      	strh	r3, [r7, #10]
        if (bitMapPri != LOS_INVALID_BIT_INDEX) {
 801f83c:	897b      	ldrh	r3, [r7, #10]
 801f83e:	2b20      	cmp	r3, #32
 801f840:	d00b      	beq.n	801f85a <OsMuxPostForPosix+0xba>
            LOS_BitmapClr(&runTask->priBitMap, bitMapPri);
 801f842:	697b      	ldr	r3, [r7, #20]
 801f844:	336c      	adds	r3, #108	; 0x6c
 801f846:	897a      	ldrh	r2, [r7, #10]
 801f848:	4611      	mov	r1, r2
 801f84a:	4618      	mov	r0, r3
 801f84c:	f7ec fac7 	bl	800bdde <LOS_BitmapClr>
            OsTaskPriModify(runTask, bitMapPri);
 801f850:	897b      	ldrh	r3, [r7, #10]
 801f852:	4619      	mov	r1, r3
 801f854:	6978      	ldr	r0, [r7, #20]
 801f856:	f7e3 fa95 	bl	8002d84 <OsTaskPriModify>
        }
    }

    /* Whether a task block the mutex lock. */
    ret = OsMuxPostOp(runTask, (MuxBaseCB *)muxPosted);
 801f85a:	6939      	ldr	r1, [r7, #16]
 801f85c:	6978      	ldr	r0, [r7, #20]
 801f85e:	f7ec f986 	bl	800bb6e <OsMuxPostOp>
 801f862:	61b8      	str	r0, [r7, #24]
    SCHEDULER_UNLOCK(intSave);
 801f864:	68fb      	ldr	r3, [r7, #12]
 801f866:	4619      	mov	r1, r3
 801f868:	480e      	ldr	r0, [pc, #56]	; (801f8a4 <OsMuxPostForPosix+0x104>)
 801f86a:	f7ff fdff 	bl	801f46c <LOS_SpinUnlockRestore>
    if ((ret == MUX_SCHEDULE) ||
 801f86e:	69bb      	ldr	r3, [r7, #24]
 801f870:	2b01      	cmp	r3, #1
 801f872:	d003      	beq.n	801f87c <OsMuxPostForPosix+0xdc>
        (mutex->stAttr.protocol == PTHREAD_PRIO_PROTECT)) {
 801f874:	687b      	ldr	r3, [r7, #4]
 801f876:	781b      	ldrb	r3, [r3, #0]
    if ((ret == MUX_SCHEDULE) ||
 801f878:	2b02      	cmp	r3, #2
 801f87a:	d104      	bne.n	801f886 <OsMuxPostForPosix+0xe6>
        LOS_MpSchedule(OS_MP_CPU_ALL);
 801f87c:	2001      	movs	r0, #1
 801f87e:	f7ff fe15 	bl	801f4ac <LOS_MpSchedule>
        LOS_Schedule();
 801f882:	f7ff fdd5 	bl	801f430 <LOS_Schedule>
    }

    return ENOERR;
 801f886:	2300      	movs	r3, #0
}
 801f888:	4a05      	ldr	r2, [pc, #20]	; (801f8a0 <OsMuxPostForPosix+0x100>)
 801f88a:	6811      	ldr	r1, [r2, #0]
 801f88c:	69fa      	ldr	r2, [r7, #28]
 801f88e:	4051      	eors	r1, r2
 801f890:	d001      	beq.n	801f896 <OsMuxPostForPosix+0xf6>
 801f892:	f7e4 fea3 	bl	80045dc <__stack_chk_fail>
 801f896:	4618      	mov	r0, r3
 801f898:	3720      	adds	r7, #32
 801f89a:	46bd      	mov	sp, r7
 801f89c:	bd80      	pop	{r7, pc}
 801f89e:	bf00      	nop
 801f8a0:	080232a4 	.word	0x080232a4
 801f8a4:	20000770 	.word	0x20000770

0801f8a8 <wcrtomb>:
#include <wchar.h>
#include <errno.h>
#include "internal.h"

size_t wcrtomb(char *restrict s, wchar_t wc, mbstate_t *restrict st)
{
 801f8a8:	b580      	push	{r7, lr}
 801f8aa:	b084      	sub	sp, #16
 801f8ac:	af00      	add	r7, sp, #0
 801f8ae:	60f8      	str	r0, [r7, #12]
 801f8b0:	60b9      	str	r1, [r7, #8]
 801f8b2:	607a      	str	r2, [r7, #4]
	if (!s) return 1;
 801f8b4:	68fb      	ldr	r3, [r7, #12]
 801f8b6:	2b00      	cmp	r3, #0
 801f8b8:	d101      	bne.n	801f8be <wcrtomb+0x16>
 801f8ba:	2301      	movs	r3, #1
 801f8bc:	e08c      	b.n	801f9d8 <wcrtomb+0x130>
	if ((unsigned)wc < 0x80) {
 801f8be:	68bb      	ldr	r3, [r7, #8]
 801f8c0:	2b7f      	cmp	r3, #127	; 0x7f
 801f8c2:	d805      	bhi.n	801f8d0 <wcrtomb+0x28>
		*s = wc;
 801f8c4:	68bb      	ldr	r3, [r7, #8]
 801f8c6:	b2da      	uxtb	r2, r3
 801f8c8:	68fb      	ldr	r3, [r7, #12]
 801f8ca:	701a      	strb	r2, [r3, #0]
		return 1;
 801f8cc:	2301      	movs	r3, #1
 801f8ce:	e083      	b.n	801f9d8 <wcrtomb+0x130>
			errno = EILSEQ;
			return -1;
		}
		*s = wc;
		return 1;
	} else if ((unsigned)wc < 0x800) {
 801f8d0:	68bb      	ldr	r3, [r7, #8]
 801f8d2:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 801f8d6:	d215      	bcs.n	801f904 <wcrtomb+0x5c>
		*s++ = 0xc0 | (wc>>6);
 801f8d8:	68bb      	ldr	r3, [r7, #8]
 801f8da:	099b      	lsrs	r3, r3, #6
 801f8dc:	b2da      	uxtb	r2, r3
 801f8de:	68fb      	ldr	r3, [r7, #12]
 801f8e0:	1c59      	adds	r1, r3, #1
 801f8e2:	60f9      	str	r1, [r7, #12]
 801f8e4:	f062 023f 	orn	r2, r2, #63	; 0x3f
 801f8e8:	b2d2      	uxtb	r2, r2
 801f8ea:	701a      	strb	r2, [r3, #0]
		*s = 0x80 | (wc&0x3f);
 801f8ec:	68bb      	ldr	r3, [r7, #8]
 801f8ee:	b2db      	uxtb	r3, r3
 801f8f0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f8f4:	b2db      	uxtb	r3, r3
 801f8f6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f8fa:	b2da      	uxtb	r2, r3
 801f8fc:	68fb      	ldr	r3, [r7, #12]
 801f8fe:	701a      	strb	r2, [r3, #0]
		return 2;
 801f900:	2302      	movs	r3, #2
 801f902:	e069      	b.n	801f9d8 <wcrtomb+0x130>
	} else if ((unsigned)wc < 0xd800 || (unsigned)wc-0xe000 < 0x2000) {
 801f904:	68bb      	ldr	r3, [r7, #8]
 801f906:	f5b3 4f58 	cmp.w	r3, #55296	; 0xd800
 801f90a:	d305      	bcc.n	801f918 <wcrtomb+0x70>
 801f90c:	68bb      	ldr	r3, [r7, #8]
 801f90e:	f5a3 4360 	sub.w	r3, r3, #57344	; 0xe000
 801f912:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 801f916:	d222      	bcs.n	801f95e <wcrtomb+0xb6>
		*s++ = 0xe0 | (wc>>12);
 801f918:	68bb      	ldr	r3, [r7, #8]
 801f91a:	0b1b      	lsrs	r3, r3, #12
 801f91c:	b2da      	uxtb	r2, r3
 801f91e:	68fb      	ldr	r3, [r7, #12]
 801f920:	1c59      	adds	r1, r3, #1
 801f922:	60f9      	str	r1, [r7, #12]
 801f924:	f062 021f 	orn	r2, r2, #31
 801f928:	b2d2      	uxtb	r2, r2
 801f92a:	701a      	strb	r2, [r3, #0]
		*s++ = 0x80 | ((wc>>6)&0x3f);
 801f92c:	68bb      	ldr	r3, [r7, #8]
 801f92e:	099b      	lsrs	r3, r3, #6
 801f930:	b2db      	uxtb	r3, r3
 801f932:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f936:	b2da      	uxtb	r2, r3
 801f938:	68fb      	ldr	r3, [r7, #12]
 801f93a:	1c59      	adds	r1, r3, #1
 801f93c:	60f9      	str	r1, [r7, #12]
 801f93e:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801f942:	b2d2      	uxtb	r2, r2
 801f944:	701a      	strb	r2, [r3, #0]
		*s = 0x80 | (wc&0x3f);
 801f946:	68bb      	ldr	r3, [r7, #8]
 801f948:	b2db      	uxtb	r3, r3
 801f94a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f94e:	b2db      	uxtb	r3, r3
 801f950:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f954:	b2da      	uxtb	r2, r3
 801f956:	68fb      	ldr	r3, [r7, #12]
 801f958:	701a      	strb	r2, [r3, #0]
		return 3;
 801f95a:	2303      	movs	r3, #3
 801f95c:	e03c      	b.n	801f9d8 <wcrtomb+0x130>
	} else if ((unsigned)wc-0x10000 < 0x100000) {
 801f95e:	68bb      	ldr	r3, [r7, #8]
 801f960:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
 801f964:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 801f968:	d22f      	bcs.n	801f9ca <wcrtomb+0x122>
		*s++ = 0xf0 | (wc>>18);
 801f96a:	68bb      	ldr	r3, [r7, #8]
 801f96c:	0c9b      	lsrs	r3, r3, #18
 801f96e:	b2da      	uxtb	r2, r3
 801f970:	68fb      	ldr	r3, [r7, #12]
 801f972:	1c59      	adds	r1, r3, #1
 801f974:	60f9      	str	r1, [r7, #12]
 801f976:	f062 020f 	orn	r2, r2, #15
 801f97a:	b2d2      	uxtb	r2, r2
 801f97c:	701a      	strb	r2, [r3, #0]
		*s++ = 0x80 | ((wc>>12)&0x3f);
 801f97e:	68bb      	ldr	r3, [r7, #8]
 801f980:	0b1b      	lsrs	r3, r3, #12
 801f982:	b2db      	uxtb	r3, r3
 801f984:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f988:	b2da      	uxtb	r2, r3
 801f98a:	68fb      	ldr	r3, [r7, #12]
 801f98c:	1c59      	adds	r1, r3, #1
 801f98e:	60f9      	str	r1, [r7, #12]
 801f990:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801f994:	b2d2      	uxtb	r2, r2
 801f996:	701a      	strb	r2, [r3, #0]
		*s++ = 0x80 | ((wc>>6)&0x3f);
 801f998:	68bb      	ldr	r3, [r7, #8]
 801f99a:	099b      	lsrs	r3, r3, #6
 801f99c:	b2db      	uxtb	r3, r3
 801f99e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f9a2:	b2da      	uxtb	r2, r3
 801f9a4:	68fb      	ldr	r3, [r7, #12]
 801f9a6:	1c59      	adds	r1, r3, #1
 801f9a8:	60f9      	str	r1, [r7, #12]
 801f9aa:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801f9ae:	b2d2      	uxtb	r2, r2
 801f9b0:	701a      	strb	r2, [r3, #0]
		*s = 0x80 | (wc&0x3f);
 801f9b2:	68bb      	ldr	r3, [r7, #8]
 801f9b4:	b2db      	uxtb	r3, r3
 801f9b6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801f9ba:	b2db      	uxtb	r3, r3
 801f9bc:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801f9c0:	b2da      	uxtb	r2, r3
 801f9c2:	68fb      	ldr	r3, [r7, #12]
 801f9c4:	701a      	strb	r2, [r3, #0]
		return 4;
 801f9c6:	2304      	movs	r3, #4
 801f9c8:	e006      	b.n	801f9d8 <wcrtomb+0x130>
	}
	errno = EILSEQ;
 801f9ca:	f7f0 fae5 	bl	800ff98 <__errno_location>
 801f9ce:	4603      	mov	r3, r0
 801f9d0:	2254      	movs	r2, #84	; 0x54
 801f9d2:	601a      	str	r2, [r3, #0]
	return -1;
 801f9d4:	f04f 33ff 	mov.w	r3, #4294967295
}
 801f9d8:	4618      	mov	r0, r3
 801f9da:	3710      	adds	r7, #16
 801f9dc:	46bd      	mov	sp, r7
 801f9de:	bd80      	pop	{r7, pc}

0801f9e0 <map_errno>:
extern "C" {
#endif /* __cplusplus */
#endif /* __cplusplus */

int map_errno(UINT32 err)
{
 801f9e0:	b580      	push	{r7, lr}
 801f9e2:	b082      	sub	sp, #8
 801f9e4:	af00      	add	r7, sp, #0
 801f9e6:	6078      	str	r0, [r7, #4]
    if (err == LOS_OK) {
 801f9e8:	687b      	ldr	r3, [r7, #4]
 801f9ea:	2b00      	cmp	r3, #0
 801f9ec:	d101      	bne.n	801f9f2 <map_errno+0x12>
        return ENOERR;
 801f9ee:	2300      	movs	r3, #0
 801f9f0:	e1c0      	b.n	801fd74 <map_errno+0x394>
    }
    switch (err) {
 801f9f2:	687b      	ldr	r3, [r7, #4]
 801f9f4:	f1b3 3fff 	cmp.w	r3, #4294967295
 801f9f8:	f000 8155 	beq.w	801fca6 <map_errno+0x2c6>
 801f9fc:	687b      	ldr	r3, [r7, #4]
 801f9fe:	4acb      	ldr	r2, [pc, #812]	; (801fd2c <map_errno+0x34c>)
 801fa00:	4293      	cmp	r3, r2
 801fa02:	f000 8150 	beq.w	801fca6 <map_errno+0x2c6>
 801fa06:	687b      	ldr	r3, [r7, #4]
 801fa08:	4ac8      	ldr	r2, [pc, #800]	; (801fd2c <map_errno+0x34c>)
 801fa0a:	4293      	cmp	r3, r2
 801fa0c:	f200 81a8 	bhi.w	801fd60 <map_errno+0x380>
 801fa10:	687b      	ldr	r3, [r7, #4]
 801fa12:	4ac7      	ldr	r2, [pc, #796]	; (801fd30 <map_errno+0x350>)
 801fa14:	4293      	cmp	r3, r2
 801fa16:	f000 8152 	beq.w	801fcbe <map_errno+0x2de>
 801fa1a:	687b      	ldr	r3, [r7, #4]
 801fa1c:	4ac4      	ldr	r2, [pc, #784]	; (801fd30 <map_errno+0x350>)
 801fa1e:	4293      	cmp	r3, r2
 801fa20:	f200 819e 	bhi.w	801fd60 <map_errno+0x380>
 801fa24:	687b      	ldr	r3, [r7, #4]
 801fa26:	4ac3      	ldr	r2, [pc, #780]	; (801fd34 <map_errno+0x354>)
 801fa28:	4293      	cmp	r3, r2
 801fa2a:	f200 8199 	bhi.w	801fd60 <map_errno+0x380>
 801fa2e:	687b      	ldr	r3, [r7, #4]
 801fa30:	4ac1      	ldr	r2, [pc, #772]	; (801fd38 <map_errno+0x358>)
 801fa32:	4293      	cmp	r3, r2
 801fa34:	d81c      	bhi.n	801fa70 <map_errno+0x90>
 801fa36:	687b      	ldr	r3, [r7, #4]
 801fa38:	4ac0      	ldr	r2, [pc, #768]	; (801fd3c <map_errno+0x35c>)
 801fa3a:	4293      	cmp	r3, r2
 801fa3c:	f000 816f 	beq.w	801fd1e <map_errno+0x33e>
 801fa40:	687b      	ldr	r3, [r7, #4]
 801fa42:	4abe      	ldr	r2, [pc, #760]	; (801fd3c <map_errno+0x35c>)
 801fa44:	4293      	cmp	r3, r2
 801fa46:	f200 818b 	bhi.w	801fd60 <map_errno+0x380>
 801fa4a:	687b      	ldr	r3, [r7, #4]
 801fa4c:	4abc      	ldr	r2, [pc, #752]	; (801fd40 <map_errno+0x360>)
 801fa4e:	4293      	cmp	r3, r2
 801fa50:	f200 8186 	bhi.w	801fd60 <map_errno+0x380>
 801fa54:	687b      	ldr	r3, [r7, #4]
 801fa56:	4abb      	ldr	r2, [pc, #748]	; (801fd44 <map_errno+0x364>)
 801fa58:	4293      	cmp	r3, r2
 801fa5a:	d225      	bcs.n	801faa8 <map_errno+0xc8>
 801fa5c:	687b      	ldr	r3, [r7, #4]
 801fa5e:	4aba      	ldr	r2, [pc, #744]	; (801fd48 <map_errno+0x368>)
 801fa60:	4293      	cmp	r3, r2
 801fa62:	f200 80d3 	bhi.w	801fc0c <map_errno+0x22c>
 801fa66:	687b      	ldr	r3, [r7, #4]
 801fa68:	f1b3 2f02 	cmp.w	r3, #33554944	; 0x2000200
 801fa6c:	d87a      	bhi.n	801fb64 <map_errno+0x184>
 801fa6e:	e177      	b.n	801fd60 <map_errno+0x380>
 801fa70:	687a      	ldr	r2, [r7, #4]
 801fa72:	4bb6      	ldr	r3, [pc, #728]	; (801fd4c <map_errno+0x36c>)
 801fa74:	4413      	add	r3, r2
 801fa76:	2b08      	cmp	r3, #8
 801fa78:	f200 8172 	bhi.w	801fd60 <map_errno+0x380>
 801fa7c:	a201      	add	r2, pc, #4	; (adr r2, 801fa84 <map_errno+0xa4>)
 801fa7e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801fa82:	bf00      	nop
 801fa84:	0801fc6b 	.word	0x0801fc6b
 801fa88:	0801fc6b 	.word	0x0801fc6b
 801fa8c:	0801fc83 	.word	0x0801fc83
 801fa90:	0801fc77 	.word	0x0801fc77
 801fa94:	0801fc9b 	.word	0x0801fc9b
 801fa98:	0801fc8f 	.word	0x0801fc8f
 801fa9c:	0801fc77 	.word	0x0801fc77
 801faa0:	0801fd61 	.word	0x0801fd61
 801faa4:	0801fc77 	.word	0x0801fc77
 801faa8:	687a      	ldr	r2, [r7, #4]
 801faaa:	4ba9      	ldr	r3, [pc, #676]	; (801fd50 <map_errno+0x370>)
 801faac:	4413      	add	r3, r2
 801faae:	2b08      	cmp	r3, #8
 801fab0:	f200 8156 	bhi.w	801fd60 <map_errno+0x380>
 801fab4:	a201      	add	r2, pc, #4	; (adr r2, 801fabc <map_errno+0xdc>)
 801fab6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801faba:	bf00      	nop
 801fabc:	0801fcd7 	.word	0x0801fcd7
 801fac0:	0801fd61 	.word	0x0801fd61
 801fac4:	0801fccb 	.word	0x0801fccb
 801fac8:	0801fcd7 	.word	0x0801fcd7
 801facc:	0801fcfb 	.word	0x0801fcfb
 801fad0:	0801fcef 	.word	0x0801fcef
 801fad4:	0801fd07 	.word	0x0801fd07
 801fad8:	0801fd13 	.word	0x0801fd13
 801fadc:	0801fce3 	.word	0x0801fce3
 801fae0:	687a      	ldr	r2, [r7, #4]
 801fae2:	4b9c      	ldr	r3, [pc, #624]	; (801fd54 <map_errno+0x374>)
 801fae4:	4413      	add	r3, r2
 801fae6:	2b1b      	cmp	r3, #27
 801fae8:	f200 813a 	bhi.w	801fd60 <map_errno+0x380>
 801faec:	a201      	add	r2, pc, #4	; (adr r2, 801faf4 <map_errno+0x114>)
 801faee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801faf2:	bf00      	nop
 801faf4:	0801fc3b 	.word	0x0801fc3b
 801faf8:	0801fc23 	.word	0x0801fc23
 801fafc:	0801fc53 	.word	0x0801fc53
 801fb00:	0801fd61 	.word	0x0801fd61
 801fb04:	0801fd61 	.word	0x0801fd61
 801fb08:	0801fc47 	.word	0x0801fc47
 801fb0c:	0801fd61 	.word	0x0801fd61
 801fb10:	0801fc5f 	.word	0x0801fc5f
 801fb14:	0801fd61 	.word	0x0801fd61
 801fb18:	0801fd61 	.word	0x0801fd61
 801fb1c:	0801fc23 	.word	0x0801fc23
 801fb20:	0801fc23 	.word	0x0801fc23
 801fb24:	0801fc23 	.word	0x0801fc23
 801fb28:	0801fd61 	.word	0x0801fd61
 801fb2c:	0801fd61 	.word	0x0801fd61
 801fb30:	0801fd61 	.word	0x0801fd61
 801fb34:	0801fc23 	.word	0x0801fc23
 801fb38:	0801fc23 	.word	0x0801fc23
 801fb3c:	0801fd61 	.word	0x0801fd61
 801fb40:	0801fc23 	.word	0x0801fc23
 801fb44:	0801fc2f 	.word	0x0801fc2f
 801fb48:	0801fd61 	.word	0x0801fd61
 801fb4c:	0801fc5f 	.word	0x0801fc5f
 801fb50:	0801fd61 	.word	0x0801fd61
 801fb54:	0801fd61 	.word	0x0801fd61
 801fb58:	0801fd61 	.word	0x0801fd61
 801fb5c:	0801fd61 	.word	0x0801fd61
 801fb60:	0801fc2f 	.word	0x0801fc2f
 801fb64:	687a      	ldr	r2, [r7, #4]
 801fb66:	f06f 2302 	mvn.w	r3, #33554944	; 0x2000200
 801fb6a:	4413      	add	r3, r2
 801fb6c:	2b24      	cmp	r3, #36	; 0x24
 801fb6e:	f200 80f7 	bhi.w	801fd60 <map_errno+0x380>
 801fb72:	a201      	add	r2, pc, #4	; (adr r2, 801fb78 <map_errno+0x198>)
 801fb74:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801fb78:	0801fca7 	.word	0x0801fca7
 801fb7c:	0801fd61 	.word	0x0801fd61
 801fb80:	0801fca7 	.word	0x0801fca7
 801fb84:	0801fca7 	.word	0x0801fca7
 801fb88:	0801fca7 	.word	0x0801fca7
 801fb8c:	0801fca7 	.word	0x0801fca7
 801fb90:	0801fca7 	.word	0x0801fca7
 801fb94:	0801fd61 	.word	0x0801fd61
 801fb98:	0801fd61 	.word	0x0801fd61
 801fb9c:	0801fca7 	.word	0x0801fca7
 801fba0:	0801fd61 	.word	0x0801fd61
 801fba4:	0801fd61 	.word	0x0801fd61
 801fba8:	0801fd61 	.word	0x0801fd61
 801fbac:	0801fd61 	.word	0x0801fd61
 801fbb0:	0801fd61 	.word	0x0801fd61
 801fbb4:	0801fd61 	.word	0x0801fd61
 801fbb8:	0801fcb3 	.word	0x0801fcb3
 801fbbc:	0801fd61 	.word	0x0801fd61
 801fbc0:	0801fd61 	.word	0x0801fd61
 801fbc4:	0801fd61 	.word	0x0801fd61
 801fbc8:	0801fd61 	.word	0x0801fd61
 801fbcc:	0801fd61 	.word	0x0801fd61
 801fbd0:	0801fd61 	.word	0x0801fd61
 801fbd4:	0801fd61 	.word	0x0801fd61
 801fbd8:	0801fd61 	.word	0x0801fd61
 801fbdc:	0801fd61 	.word	0x0801fd61
 801fbe0:	0801fd61 	.word	0x0801fd61
 801fbe4:	0801fd61 	.word	0x0801fd61
 801fbe8:	0801fd61 	.word	0x0801fd61
 801fbec:	0801fd61 	.word	0x0801fd61
 801fbf0:	0801fd61 	.word	0x0801fd61
 801fbf4:	0801fca7 	.word	0x0801fca7
 801fbf8:	0801fd61 	.word	0x0801fd61
 801fbfc:	0801fd61 	.word	0x0801fd61
 801fc00:	0801fd61 	.word	0x0801fd61
 801fc04:	0801fd61 	.word	0x0801fd61
 801fc08:	0801fcb3 	.word	0x0801fcb3
 801fc0c:	687b      	ldr	r3, [r7, #4]
 801fc0e:	4a52      	ldr	r2, [pc, #328]	; (801fd58 <map_errno+0x378>)
 801fc10:	4293      	cmp	r3, r2
 801fc12:	f200 80a5 	bhi.w	801fd60 <map_errno+0x380>
 801fc16:	687b      	ldr	r3, [r7, #4]
 801fc18:	4a50      	ldr	r2, [pc, #320]	; (801fd5c <map_errno+0x37c>)
 801fc1a:	4293      	cmp	r3, r2
 801fc1c:	f4bf af60 	bcs.w	801fae0 <map_errno+0x100>
 801fc20:	e09e      	b.n	801fd60 <map_errno+0x380>
        case LOS_ERRNO_QUEUE_WRITESIZE_ISZERO:
        case LOS_ERRNO_QUEUE_SIZE_TOO_BIG:
        case LOS_ERRNO_QUEUE_CREAT_PTR_NULL:
        case LOS_ERRNO_QUEUE_PARA_ISZERO:
        case LOS_ERRNO_QUEUE_WRITE_SIZE_TOO_BIG:
            errno = EINVAL;
 801fc22:	f7f0 f9b9 	bl	800ff98 <__errno_location>
 801fc26:	4603      	mov	r3, r0
 801fc28:	2216      	movs	r2, #22
 801fc2a:	601a      	str	r2, [r3, #0]
            break;
 801fc2c:	e09e      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_QUEUE_ISFULL:
        case LOS_ERRNO_QUEUE_ISEMPTY:
            errno = EAGAIN;
 801fc2e:	f7f0 f9b3 	bl	800ff98 <__errno_location>
 801fc32:	4603      	mov	r3, r0
 801fc34:	220b      	movs	r2, #11
 801fc36:	601a      	str	r2, [r3, #0]
            break;
 801fc38:	e098      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_QUEUE_CREATE_NO_MEMORY:
            errno = ENOSPC;
 801fc3a:	f7f0 f9ad 	bl	800ff98 <__errno_location>
 801fc3e:	4603      	mov	r3, r0
 801fc40:	221c      	movs	r2, #28
 801fc42:	601a      	str	r2, [r3, #0]
            break;
 801fc44:	e092      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_QUEUE_TIMEOUT:
            errno = ETIMEDOUT;
 801fc46:	f7f0 f9a7 	bl	800ff98 <__errno_location>
 801fc4a:	4603      	mov	r3, r0
 801fc4c:	226e      	movs	r2, #110	; 0x6e
 801fc4e:	601a      	str	r2, [r3, #0]
            break;
 801fc50:	e08c      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_QUEUE_CB_UNAVAILABLE:
            errno = ENFILE;
 801fc52:	f7f0 f9a1 	bl	800ff98 <__errno_location>
 801fc56:	4603      	mov	r3, r0
 801fc58:	2217      	movs	r2, #23
 801fc5a:	601a      	str	r2, [r3, #0]
            break;
 801fc5c:	e086      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_QUEUE_READ_IN_INTERRUPT:
        case LOS_ERRNO_QUEUE_WRITE_IN_INTERRUPT:
            errno = EINTR;
 801fc5e:	f7f0 f99b 	bl	800ff98 <__errno_location>
 801fc62:	4603      	mov	r3, r0
 801fc64:	2204      	movs	r2, #4
 801fc66:	601a      	str	r2, [r3, #0]
            break;
 801fc68:	e080      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_MUX_INVALID:
        case LOS_ERRNO_MUX_PTR_NULL:
            errno = EINVAL;
 801fc6a:	f7f0 f995 	bl	800ff98 <__errno_location>
 801fc6e:	4603      	mov	r3, r0
 801fc70:	2216      	movs	r2, #22
 801fc72:	601a      	str	r2, [r3, #0]
            break;
 801fc74:	e07a      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_MUX_PENDED:
        case LOS_ERRNO_MUX_UNAVAILABLE:
        case LOS_ERRNO_MUX_TIMEOUT:
            errno = EBUSY;
 801fc76:	f7f0 f98f 	bl	800ff98 <__errno_location>
 801fc7a:	4603      	mov	r3, r0
 801fc7c:	2210      	movs	r2, #16
 801fc7e:	601a      	str	r2, [r3, #0]
            break;
 801fc80:	e074      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_MUX_ALL_BUSY:
            errno = EAGAIN;
 801fc82:	f7f0 f989 	bl	800ff98 <__errno_location>
 801fc86:	4603      	mov	r3, r0
 801fc88:	220b      	movs	r2, #11
 801fc8a:	601a      	str	r2, [r3, #0]
            break;
 801fc8c:	e06e      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_MUX_PEND_IN_LOCK:
            errno = EDEADLK;
 801fc8e:	f7f0 f983 	bl	800ff98 <__errno_location>
 801fc92:	4603      	mov	r3, r0
 801fc94:	2223      	movs	r2, #35	; 0x23
 801fc96:	601a      	str	r2, [r3, #0]
            break;
 801fc98:	e068      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_MUX_PEND_INTERR:
            errno = EPERM;
 801fc9a:	f7f0 f97d 	bl	800ff98 <__errno_location>
 801fc9e:	4603      	mov	r3, r0
 801fca0:	2201      	movs	r2, #1
 801fca2:	601a      	str	r2, [r3, #0]
            break;
 801fca4:	e062      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_TSK_STKSZ_TOO_LARGE:
        case LOS_ERRNO_TSK_STKSZ_TOO_SMALL:
        case LOS_ERRNO_TSK_NOT_CREATED:
        case LOS_ERRNO_TSK_CPU_AFFINITY_MASK_ERR:
        case OS_ERROR:
            errno = EINVAL;
 801fca6:	f7f0 f977 	bl	800ff98 <__errno_location>
 801fcaa:	4603      	mov	r3, r0
 801fcac:	2216      	movs	r2, #22
 801fcae:	601a      	str	r2, [r3, #0]
            break;
 801fcb0:	e05c      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_TSK_TCB_UNAVAILABLE:
        case LOS_ERRNO_TSK_MP_SYNC_RESOURCE:
            errno = ENOSPC;
 801fcb2:	f7f0 f971 	bl	800ff98 <__errno_location>
 801fcb6:	4603      	mov	r3, r0
 801fcb8:	221c      	movs	r2, #28
 801fcba:	601a      	str	r2, [r3, #0]
            break;
 801fcbc:	e056      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_TSK_NO_MEMORY:
            errno = ENOMEM;
 801fcbe:	f7f0 f96b 	bl	800ff98 <__errno_location>
 801fcc2:	4603      	mov	r3, r0
 801fcc4:	220c      	movs	r2, #12
 801fcc6:	601a      	str	r2, [r3, #0]
            break;
 801fcc8:	e050      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_SEM_ALL_BUSY:
            errno = ENOSPC;
 801fcca:	f7f0 f965 	bl	800ff98 <__errno_location>
 801fcce:	4603      	mov	r3, r0
 801fcd0:	221c      	movs	r2, #28
 801fcd2:	601a      	str	r2, [r3, #0]
            break;
 801fcd4:	e04a      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_SEM_INVALID:
        case LOS_ERRNO_SEM_UNAVAILABLE:
            errno = EINVAL;
 801fcd6:	f7f0 f95f 	bl	800ff98 <__errno_location>
 801fcda:	4603      	mov	r3, r0
 801fcdc:	2216      	movs	r2, #22
 801fcde:	601a      	str	r2, [r3, #0]
            break;
 801fce0:	e044      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_SEM_PENDED:
            errno = EBUSY;
 801fce2:	f7f0 f959 	bl	800ff98 <__errno_location>
 801fce6:	4603      	mov	r3, r0
 801fce8:	2210      	movs	r2, #16
 801fcea:	601a      	str	r2, [r3, #0]
            break;
 801fcec:	e03e      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_SEM_PEND_IN_LOCK:
            errno = EPERM;
 801fcee:	f7f0 f953 	bl	800ff98 <__errno_location>
 801fcf2:	4603      	mov	r3, r0
 801fcf4:	2201      	movs	r2, #1
 801fcf6:	601a      	str	r2, [r3, #0]
            break;
 801fcf8:	e038      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_SEM_PEND_INTERR:
            errno = EINTR;
 801fcfa:	f7f0 f94d 	bl	800ff98 <__errno_location>
 801fcfe:	4603      	mov	r3, r0
 801fd00:	2204      	movs	r2, #4
 801fd02:	601a      	str	r2, [r3, #0]
            break;
 801fd04:	e032      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_SEM_TIMEOUT:
            errno = ETIMEDOUT;
 801fd06:	f7f0 f947 	bl	800ff98 <__errno_location>
 801fd0a:	4603      	mov	r3, r0
 801fd0c:	226e      	movs	r2, #110	; 0x6e
 801fd0e:	601a      	str	r2, [r3, #0]
            break;
 801fd10:	e02c      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_SEM_OVERFLOW:
            errno = ENOSPC;
 801fd12:	f7f0 f941 	bl	800ff98 <__errno_location>
 801fd16:	4603      	mov	r3, r0
 801fd18:	221c      	movs	r2, #28
 801fd1a:	601a      	str	r2, [r3, #0]
            break;
 801fd1c:	e026      	b.n	801fd6c <map_errno+0x38c>
        case LOS_ERRNO_EVENT_SHOULD_NOT_DESTORY:
            errno = EBUSY;
 801fd1e:	f7f0 f93b 	bl	800ff98 <__errno_location>
 801fd22:	4603      	mov	r3, r0
 801fd24:	2210      	movs	r2, #16
 801fd26:	601a      	str	r2, [r3, #0]
            break;
 801fd28:	e020      	b.n	801fd6c <map_errno+0x38c>
 801fd2a:	bf00      	nop
 801fd2c:	03000223 	.word	0x03000223
 801fd30:	03000200 	.word	0x03000200
 801fd34:	02001d09 	.word	0x02001d09
 801fd38:	02001d00 	.word	0x02001d00
 801fd3c:	02001c08 	.word	0x02001c08
 801fd40:	02000709 	.word	0x02000709
 801fd44:	02000701 	.word	0x02000701
 801fd48:	02000225 	.word	0x02000225
 801fd4c:	fdffe2ff 	.word	0xfdffe2ff
 801fd50:	fdfff8ff 	.word	0xfdfff8ff
 801fd54:	fdfff9fe 	.word	0xfdfff9fe
 801fd58:	0200061d 	.word	0x0200061d
 801fd5c:	02000602 	.word	0x02000602
        default:
            errno = EINVAL;
 801fd60:	f7f0 f91a 	bl	800ff98 <__errno_location>
 801fd64:	4603      	mov	r3, r0
 801fd66:	2216      	movs	r2, #22
 801fd68:	601a      	str	r2, [r3, #0]
            break;
 801fd6a:	bf00      	nop
    }
    return errno;
 801fd6c:	f7f0 f914 	bl	800ff98 <__errno_location>
 801fd70:	4603      	mov	r3, r0
 801fd72:	681b      	ldr	r3, [r3, #0]
}
 801fd74:	4618      	mov	r0, r3
 801fd76:	3708      	adds	r7, #8
 801fd78:	46bd      	mov	sp, r7
 801fd7a:	bd80      	pop	{r7, pc}
